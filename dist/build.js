/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 21);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports) {

window.JSCompiler_renameProperty = function (prop, obj) {
  return prop;
};
/** @namespace */


let Polymer;

/***/ }),
/* 1 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}
/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */


var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);

emptyFunction.thatReturnsThis = function () {
  return this;
};

emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["dashToCamelCase"] = dashToCamelCase;
/* harmony export (immutable) */ __webpack_exports__["camelToDashCase"] = camelToDashCase;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);

const caseMap = {};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH = /([A-Z])/g;
function dashToCamelCase(dash) {
  return caseMap[dash] || (caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL, m => m[1].toUpperCase()));
}
function camelToDashCase(camel) {
  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase());
}

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(22);
} else {
  module.exports = __webpack_require__(23);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */


var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return resolveCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return resolveUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return pathFromUrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);

let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */

function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  } // Lazy feature detection.


  if (workingURL === undefined) {
    workingURL = false;

    try {
      const u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = u.href === 'http://a/c%20d';
    } catch (e) {// silently fail
    }
  }

  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }

  if (workingURL) {
    return new URL(url, baseURI).href;
  } // Fallback to creating an anchor into a disconnected document.


  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }

  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;
}
/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */


function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function (m, pre, url, post) {
    return pre + '\'' + resolveUrl(url.replace(/["']/g, ''), baseURI) + '\'' + post;
  });
}
/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */


function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}





/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
 // unique global id for deduping mixins.

let dedupeId = 0;
/**
 * @constructor
 * @extends {Function}
 */

function MixinFunction() {}
/** @type {(WeakMap | undefined)} */


MixinFunction.prototype.__mixinApplications;
/** @type {(Object | undefined)} */

MixinFunction.prototype.__mixinSet;
const dedupingMixin = function (mixin) {
  let mixinApplications =
  /** @type {!MixinFunction} */
  mixin.__mixinApplications;

  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    /** @type {!MixinFunction} */

    mixin.__mixinApplications = mixinApplications;
  } // maintain a unique id for each mixin


  let mixinDedupeId = dedupeId++;

  function dedupingMixin(base) {
    let baseSet =
    /** @type {!MixinFunction} */
    base.__mixinSet;

    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }

    let map = mixinApplications;
    let extended = map.get(base);

    if (!extended) {
      extended =
      /** @type {!Function} */
      mixin(base);
      map.set(base, extended);
    } // copy inherited mixin set from the extended class, or the base class
    // NOTE: we avoid use of Set here because some browser (IE11)
    // cannot extend a base Set via the constructor.


    let mixinSet = Object.create(
    /** @type {!MixinFunction} */
    extended.__mixinSet || baseSet || null);
    mixinSet[mixinDedupeId] = true;
    /** @type {!MixinFunction} */

    extended.__mixinSet = mixinSet;
    return extended;
  }

  return dedupingMixin;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = dedupingMixin;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;

    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame

    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */


var emptyFunction = __webpack_require__(2);
/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */


var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });

    if (typeof console !== 'undefined') {
      console.error(message);
    }

    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["default"] = reactInit;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_react_dom___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_react_dom__);


function reactInit(selector, ReactComponent) {
  document.addEventListener('DOMContentLoaded', function () {
    document.querySelectorAll(selector).forEach(function (node) {
      __WEBPACK_IMPORTED_MODULE_1_react_dom___default.a.render(__WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(ReactComponent, {
        heading: node.getAttribute('data-heading'),
        subtext: node.getAttribute('data-subtext'),
        size: node.getAttribute('data-size'),
        hashr: node.getAttribute('data-hashr')
      }), node);
    });
  });
}

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(8);

  var warning = __webpack_require__(9);

  var ReactPropTypesSecret = __webpack_require__(24);

  var loggedTypeFailures = {};
}
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */


function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error; // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.

        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }

        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);

        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;
          var stack = getStack ? getStack() : '';
          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */


var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */

var ExecutionEnvironment = {
  canUseDOM: canUseDOM,
  canUseWorkers: typeof Worker !== 'undefined',
  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
  canUseViewport: canUseDOM && !!window.screen,
  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};
module.exports = ExecutionEnvironment;

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(2);
/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */


var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }

      return {
        remove: emptyFunction
      };
    }
  },
  registerDefault: function registerDefault() {}
};
module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */

function getActiveElement(doc)
/*?DOMElement*/
{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);

  if (typeof doc === 'undefined') {
    return null;
  }

  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */


var hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */

function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}
/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */


function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  } // Test for A's keys different from B.


  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(27);
/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */


function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Settings */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return rootPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return sanitizeDOMValue; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__resolve_url_js__ = __webpack_require__(6);


/**
 * Legacy settings.
 * @namespace
 * @memberof Polymer
 */

const settings = undefined || {};
const useShadow = !window.ShadyDOM;
/* unused harmony export useShadow */

const useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
/* unused harmony export useNativeCSSProperties */

const useNativeCustomElements = !window.customElements.polyfillWrapFlushCallback;
/* unused harmony export useNativeCustomElements */


/**
 * Globally settable property that is automatically assigned to
 * `Polymer.ElementMixin` instances, useful for binding in templates to
 * make URL's relative to an application's root.  Defaults to the main
 * document URL, but can be overridden by users.  It may be useful to set
 * `Polymer.rootPath` to provide a stable application mount path when
 * using client side routing.
 *
 * @memberof Polymer
 */

let rootPath = undefined || Object(__WEBPACK_IMPORTED_MODULE_1__resolve_url_js__["a" /* pathFromUrl */])(document.baseURI || window.location.href);

const setRootPath = function (path) {
  rootPath = path;
};
/* unused harmony export setRootPath */

/**
 * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:
 *
 *     Polymer = {
 *       sanitizeDOMValue: function(value, name, type, node) { ... }
 *     }
 *
 * Where:
 *
 * `value` is the value to sanitize.
 * `name` is the name of an attribute or property (for example, href).
 * `type` indicates where the value is being inserted: one of property, attribute, or text.
 * `node` is the node where the value is being inserted.
 *
 * @type {(function(*,string,string,Node):*)|undefined}
 * @memberof Polymer
 */

let sanitizeDOMValue = undefined;

const setSanitizeDOMValue = function (newSanitizeDOMValue) {
  sanitizeDOMValue = newSanitizeDOMValue;
};
/* unused harmony export setSanitizeDOMValue */


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(10);
__webpack_require__(34);
__webpack_require__(37);
module.exports = __webpack_require__(38);


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var m = __webpack_require__(11),
    n = __webpack_require__(5),
    p = __webpack_require__(2),
    q = "function" === typeof Symbol && Symbol["for"],
    r = q ? Symbol["for"]("react.element") : 60103,
    t = q ? Symbol["for"]("react.call") : 60104,
    u = q ? Symbol["for"]("react.return") : 60105,
    v = q ? Symbol["for"]("react.portal") : 60106,
    w = q ? Symbol["for"]("react.fragment") : 60107,
    x = "function" === typeof Symbol && Symbol.iterator;

function y(a) {
  for (var b = arguments.length - 1, e = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, c = 0; c < b; c++) e += "\x26args[]\x3d" + encodeURIComponent(arguments[c + 1]);

  b = Error(e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");
  b.name = "Invariant Violation";
  b.framesToPop = 1;
  throw b;
}

var z = {
  isMounted: function () {
    return !1;
  },
  enqueueForceUpdate: function () {},
  enqueueReplaceState: function () {},
  enqueueSetState: function () {}
};

function A(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = n;
  this.updater = e || z;
}

A.prototype.isReactComponent = {};

A.prototype.setState = function (a, b) {
  "object" !== typeof a && "function" !== typeof a && null != a ? y("85") : void 0;
  this.updater.enqueueSetState(this, a, b, "setState");
};

A.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};

function B(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = n;
  this.updater = e || z;
}

function C() {}

C.prototype = A.prototype;
var D = B.prototype = new C();
D.constructor = B;
m(D, A.prototype);
D.isPureReactComponent = !0;

function E(a, b, e) {
  this.props = a;
  this.context = b;
  this.refs = n;
  this.updater = e || z;
}

var F = E.prototype = new C();
F.constructor = E;
m(F, A.prototype);
F.unstable_isAsyncReactComponent = !0;

F.render = function () {
  return this.props.children;
};

var G = {
  current: null
},
    H = Object.prototype.hasOwnProperty,
    I = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};

function J(a, b, e) {
  var c,
      d = {},
      g = null,
      k = null;
  if (null != b) for (c in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (g = "" + b.key), b) H.call(b, c) && !I.hasOwnProperty(c) && (d[c] = b[c]);
  var f = arguments.length - 2;
  if (1 === f) d.children = e;else if (1 < f) {
    for (var h = Array(f), l = 0; l < f; l++) h[l] = arguments[l + 2];

    d.children = h;
  }
  if (a && a.defaultProps) for (c in f = a.defaultProps, f) void 0 === d[c] && (d[c] = f[c]);
  return {
    $$typeof: r,
    type: a,
    key: g,
    ref: k,
    props: d,
    _owner: G.current
  };
}

function K(a) {
  return "object" === typeof a && null !== a && a.$$typeof === r;
}

function escape(a) {
  var b = {
    "\x3d": "\x3d0",
    ":": "\x3d2"
  };
  return "$" + ("" + a).replace(/[=:]/g, function (a) {
    return b[a];
  });
}

var L = /\/+/g,
    M = [];

function N(a, b, e, c) {
  if (M.length) {
    var d = M.pop();
    d.result = a;
    d.keyPrefix = b;
    d.func = e;
    d.context = c;
    d.count = 0;
    return d;
  }

  return {
    result: a,
    keyPrefix: b,
    func: e,
    context: c,
    count: 0
  };
}

function O(a) {
  a.result = null;
  a.keyPrefix = null;
  a.func = null;
  a.context = null;
  a.count = 0;
  10 > M.length && M.push(a);
}

function P(a, b, e, c) {
  var d = typeof a;
  if ("undefined" === d || "boolean" === d) a = null;
  var g = !1;
  if (null === a) g = !0;else switch (d) {
    case "string":
    case "number":
      g = !0;
      break;

    case "object":
      switch (a.$$typeof) {
        case r:
        case t:
        case u:
        case v:
          g = !0;
      }

  }
  if (g) return e(c, a, "" === b ? "." + Q(a, 0) : b), 1;
  g = 0;
  b = "" === b ? "." : b + ":";
  if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
    d = a[k];
    var f = b + Q(d, k);
    g += P(d, f, e, c);
  } else if (null === a || "undefined" === typeof a ? f = null : (f = x && a[x] || a["@@iterator"], f = "function" === typeof f ? f : null), "function" === typeof f) for (a = f.call(a), k = 0; !(d = a.next()).done;) d = d.value, f = b + Q(d, k++), g += P(d, f, e, c);else "object" === d && (e = "" + a, y("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));
  return g;
}

function Q(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape(a.key) : b.toString(36);
}

function R(a, b) {
  a.func.call(a.context, b, a.count++);
}

function S(a, b, e) {
  var c = a.result,
      d = a.keyPrefix;
  a = a.func.call(a.context, b, a.count++);
  Array.isArray(a) ? T(a, c, e, p.thatReturnsArgument) : null != a && (K(a) && (b = d + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(L, "$\x26/") + "/") + e, a = {
    $$typeof: r,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  }), c.push(a));
}

function T(a, b, e, c, d) {
  var g = "";
  null != e && (g = ("" + e).replace(L, "$\x26/") + "/");
  b = N(b, g, c, d);
  null == a || P(a, "", S, b);
  O(b);
}

var U = {
  Children: {
    map: function (a, b, e) {
      if (null == a) return a;
      var c = [];
      T(a, c, null, b, e);
      return c;
    },
    forEach: function (a, b, e) {
      if (null == a) return a;
      b = N(null, null, b, e);
      null == a || P(a, "", R, b);
      O(b);
    },
    count: function (a) {
      return null == a ? 0 : P(a, "", p.thatReturnsNull, null);
    },
    toArray: function (a) {
      var b = [];
      T(a, b, null, p.thatReturnsArgument);
      return b;
    },
    only: function (a) {
      K(a) ? void 0 : y("143");
      return a;
    }
  },
  Component: A,
  PureComponent: B,
  unstable_AsyncComponent: E,
  Fragment: w,
  createElement: J,
  cloneElement: function (a, b, e) {
    var c = m({}, a.props),
        d = a.key,
        g = a.ref,
        k = a._owner;

    if (null != b) {
      void 0 !== b.ref && (g = b.ref, k = G.current);
      void 0 !== b.key && (d = "" + b.key);
      if (a.type && a.type.defaultProps) var f = a.type.defaultProps;

      for (h in b) H.call(b, h) && !I.hasOwnProperty(h) && (c[h] = void 0 === b[h] && void 0 !== f ? f[h] : b[h]);
    }

    var h = arguments.length - 2;
    if (1 === h) c.children = e;else if (1 < h) {
      f = Array(h);

      for (var l = 0; l < h; l++) f[l] = arguments[l + 2];

      c.children = f;
    }
    return {
      $$typeof: r,
      type: a.type,
      key: d,
      ref: g,
      props: c,
      _owner: k
    };
  },
  createFactory: function (a) {
    var b = J.bind(null, a);
    b.type = a;
    return b;
  },
  isValidElement: K,
  version: "16.2.0",
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    ReactCurrentOwner: G,
    assign: m
  }
},
    V = Object.freeze({
  default: U
}),
    W = V && U || V;
module.exports = W["default"] ? W["default"] : W;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var _assign = __webpack_require__(11);

    var emptyObject = __webpack_require__(5);

    var invariant = __webpack_require__(8);

    var warning = __webpack_require__(9);

    var emptyFunction = __webpack_require__(2);

    var checkPropTypes = __webpack_require__(12); // TODO: this is special because it gets imported during build.


    var ReactVersion = '16.2.0'; // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.

    var hasSymbol = typeof Symbol === 'function' && Symbol['for'];
    var REACT_ELEMENT_TYPE = hasSymbol ? Symbol['for']('react.element') : 0xeac7;
    var REACT_CALL_TYPE = hasSymbol ? Symbol['for']('react.call') : 0xeac8;
    var REACT_RETURN_TYPE = hasSymbol ? Symbol['for']('react.return') : 0xeac9;
    var REACT_PORTAL_TYPE = hasSymbol ? Symbol['for']('react.portal') : 0xeaca;
    var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol['for']('react.fragment') : 0xeacb;
    var MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator';

    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable === 'undefined') {
        return null;
      }

      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];

      if (typeof maybeIterator === 'function') {
        return maybeIterator;
      }

      return null;
    }
    /**
     * WARNING: DO NOT manually require this module.
     * This is a replacement for `invariant(...)` used by the error code system
     * and will _only_ be required by the corresponding babel pass.
     * It always throws.
     */

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */


    var lowPriorityWarning = function () {};

    {
      var printWarning = function (format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });

        if (typeof console !== 'undefined') {
          console.warn(message);
        }

        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function (condition, format) {
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }

        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }
    var lowPriorityWarning$1 = lowPriorityWarning;
    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var constructor = publicInstance.constructor;
        var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;

        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }

        warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }
    /**
     * This is the abstract API for an update queue.
     */


    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function (publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function (publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function (publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };
    /**
     * Base class helpers for the updating state of a component.
     */

    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
      // renderer.

      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};
    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */

    Component.prototype.setState = function (partialState, callback) {
      !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };
    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */


    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };
    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */


    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };

      var defineDeprecationWarning = function (methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function () {
            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };

      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }
    /**
     * Base class helpers for the updating state of a component.
     */

    function PureComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
      // renderer.

      this.updater = updater || ReactNoopUpdateQueue;
    }

    function ComponentDummy() {}

    ComponentDummy.prototype = Component.prototype;
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.

    _assign(pureComponentPrototype, Component.prototype);

    pureComponentPrototype.isPureReactComponent = true;

    function AsyncComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the
      // renderer.

      this.updater = updater || ReactNoopUpdateQueue;
    }

    var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
    asyncComponentPrototype.constructor = AsyncComponent; // Avoid an extra prototype jump for these methods.

    _assign(asyncComponentPrototype, Component.prototype);

    asyncComponentPrototype.unstable_isAsyncReactComponent = true;

    asyncComponentPrototype.render = function () {
      return this.props.children;
    };
    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */


    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };
    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;

          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function () {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };

      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function () {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };

      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }
    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, no instanceof check
     * will work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} key
     * @param {string|object} ref
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @param {*} owner
     * @param {*} props
     * @internal
     */


    var ReactElement = function (type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allow us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE,
        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,
        // Record the component responsible for creating this element.
        _owner: owner
      };
      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {}; // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.

        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        }); // self and source are DEV only properties.

        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        }); // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.

        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });

        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }
      return element;
    };
    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */


    function createElement(type, config, children) {
      var propName; // Reserved names are extracted

      var props = {};
      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }

        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      } // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.


      var childrenLength = arguments.length - 2;

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }

        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      } // Resolve default props


      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;

        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }

      {
        if (key || ref) {
          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;

            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }

            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }
    /**
     * Return a function that produces ReactElements of a given type.
     * See https://reactjs.org/docs/react-api.html#createfactory
     */


    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
      return newElement;
    }
    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */


    function cloneElement(element, config, children) {
      var propName; // Original props are copied

      var props = _assign({}, element.props); // Reserved names are extracted


      var key = element.key;
      var ref = element.ref; // Self is preserved since the owner is preserved.

      var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.

      var source = element._source; // Owner will be preserved, unless ref is overridden

      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }

        if (hasValidKey(config)) {
          key = '' + config.key;
        } // Remaining properties override existing props


        var defaultProps;

        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }

        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      } // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.


      var childrenLength = arguments.length - 2;

      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);

        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }

        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }
    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a valid component.
     * @final
     */


    function isValidElement(object) {
      return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }

    var ReactDebugCurrentFrame = {};
    {
      // Component that is being worked on
      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var impl = ReactDebugCurrentFrame.getCurrentStack;

        if (impl) {
          return impl();
        }

        return null;
      };
    }
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';
    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */

    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = ('' + key).replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });
      return '$' + escapedString;
    }
    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */


    var didWarnAboutMaps = false;
    var userProvidedKeyEscapeRegex = /\/+/g;

    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    var POOL_SIZE = 10;
    var traverseContextPool = [];

    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
      if (traverseContextPool.length) {
        var traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = 0;
        return traverseContext;
      } else {
        return {
          result: mapResult,
          keyPrefix: keyPrefix,
          func: mapFunction,
          context: mapContext,
          count: 0
        };
      }
    }

    function releaseTraverseContext(traverseContext) {
      traverseContext.result = null;
      traverseContext.keyPrefix = null;
      traverseContext.func = null;
      traverseContext.context = null;
      traverseContext.count = 0;

      if (traverseContextPool.length < POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }
    /**
     * @param {?*} children Children tree container.
     * @param {!string} nameSoFar Name of the key path so far.
     * @param {!function} callback Callback to invoke with each child found.
     * @param {?*} traverseContext Used to pass information throughout the traversal
     * process.
     * @return {!number} The number of children in this subtree.
     */


    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children;

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      var invokeCallback = false;

      if (children === null) {
        invokeCallback = true;
      } else {
        switch (type) {
          case 'string':
          case 'number':
            invokeCallback = true;
            break;

          case 'object':
            switch (children.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_CALL_TYPE:
              case REACT_RETURN_TYPE:
              case REACT_PORTAL_TYPE:
                invokeCallback = true;
            }

        }
      }

      if (invokeCallback) {
        callback(traverseContext, children, // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows.
        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }

      var child;
      var nextName;
      var subtreeCount = 0; // Count of children found in the current subtree.

      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = getIteratorFn(children);

        if (typeof iteratorFn === 'function') {
          {
            // Warn about using Maps as children
            if (iteratorFn === children.entries) {
              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
              didWarnAboutMaps = true;
            }
          }
          var iterator = iteratorFn.call(children);
          var step;
          var ii = 0;

          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else if (type === 'object') {
          var addendum = '';
          {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
          }
          var childrenString = '' + children;
          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
        }
      }

      return subtreeCount;
    }
    /**
     * Traverses children that are typically specified as `props.children`, but
     * might also be specified through attributes:
     *
     * - `traverseAllChildren(this.props.children, ...)`
     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
     *
     * The `traverseContext` is an optional argument that is passed through the
     * entire traversal. It can be used to store accumulations or anything else that
     * the callback might find relevant.
     *
     * @param {?*} children Children tree object.
     * @param {!function} callback To invoke upon traversing each child.
     * @param {?*} traverseContext Context for traversal.
     * @return {!number} The number of children in this subtree.
     */


    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }
    /**
     * Generate a key string that identifies a component within a set.
     *
     * @param {*} component A component that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */


    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if (typeof component === 'object' && component !== null && component.key != null) {
        // Explicit key
        return escape(component.key);
      } // Implicit key determined by the index in the set


      return index.toString(36);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
          context = bookKeeping.context;
      func.call(context, child, bookKeeping.count++);
    }
    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.foreach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */


    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }

      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;
      var mappedChild = func.call(context, child, bookKeeping.count++);

      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
        }

        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';

      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }

      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }
    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.map
     *
     * The provided mapFunction(child, key, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */


    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }

      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }
    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.count
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */


    function countChildren(children, context) {
      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
    }
    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.toarray
     */


    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
      return result;
    }
    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.only
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */


    function onlyChild(children) {
      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
      return children;
    }

    var describeComponentFrame = function (name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    };

    function getComponentName(fiber) {
      var type = fiber.type;

      if (typeof type === 'string') {
        return type;
      }

      if (typeof type === 'function') {
        return type.displayName || type.name;
      }

      return null;
    }
    /**
     * ReactElementValidator provides a wrapper around a element factory
     * which validates the props passed to the element. This is intended to be
     * used only in DEV and could be replaced by a static type checker for languages
     * that support it.
     */


    {
      var currentlyValidatingElement = null;
      var propTypesMisspellWarningShown = false;

      var getDisplayName = function (element) {
        if (element == null) {
          return '#empty';
        } else if (typeof element === 'string' || typeof element === 'number') {
          return '#text';
        } else if (typeof element.type === 'string') {
          return element.type;
        } else if (element.type === REACT_FRAGMENT_TYPE) {
          return 'React.Fragment';
        } else {
          return element.type.displayName || element.type.name || 'Unknown';
        }
      };

      var getStackAddendum = function () {
        var stack = '';

        if (currentlyValidatingElement) {
          var name = getDisplayName(currentlyValidatingElement);
          var owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
        }

        stack += ReactDebugCurrentFrame.getStackAddendum() || '';
        return stack;
      };

      var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
    }

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current);

        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }

      return '';
    }

    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }

      return '';
    }
    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */


    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;

        if (parentName) {
          info = '\n\nCheck the top-level render call using <' + parentName + '>.';
        }
      }

      return info;
    }
    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */


    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }

      element._store.validated = true;
      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);

      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }

      ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.

      var childOwner = '';

      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
      }

      currentlyValidatingElement = element;
      {
        warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
      }
      currentlyValidatingElement = null;
    }
    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */


    function validateChildKeys(node, parentType) {
      if (typeof node !== 'object') {
        return;
      }

      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];

          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = getIteratorFn(node);

        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;

            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }
    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */


    function validatePropTypes(element) {
      var componentClass = element.type;

      if (typeof componentClass !== 'function') {
        return;
      }

      var name = componentClass.displayName || componentClass.name;
      var propTypes = componentClass.propTypes;

      if (propTypes) {
        currentlyValidatingElement = element;
        checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
        currentlyValidatingElement = null;
      } else if (componentClass.PropTypes !== undefined && !propTypesMisspellWarningShown) {
        propTypesMisspellWarningShown = true;
        warning(false, 'Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', name || 'Unknown');
      }

      if (typeof componentClass.getDefaultProps === 'function') {
        warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
      }
    }
    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */


    function validateFragmentProps(fragment) {
      currentlyValidatingElement = fragment;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (!VALID_FRAGMENT_PROPS.has(key)) {
            warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (fragment.ref !== null) {
        warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
      }

      currentlyValidatingElement = null;
    }

    function createElementWithValidation(type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function' || typeof type === 'symbol' || typeof type === 'number'; // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.

      if (!validType) {
        var info = '';

        if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in, or you might have mixed up default and named imports.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);

        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += getStackAddendum() || '';
        warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type, info);
      }

      var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.

      if (element == null) {
        return element;
      } // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)


      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if (typeof type === 'symbol' && type === REACT_FRAGMENT_TYPE) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type); // Legacy hook TODO: Warn if this is accessed

      validatedFactory.type = type;
      {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function () {
            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }
      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);

      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }

      validatePropTypes(newElement);
      return newElement;
    }

    var React = {
      Children: {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      },
      Component: Component,
      PureComponent: PureComponent,
      unstable_AsyncComponent: AsyncComponent,
      Fragment: REACT_FRAGMENT_TYPE,
      createElement: createElementWithValidation,
      cloneElement: cloneElementWithValidation,
      createFactory: createFactoryWithValidation,
      isValidElement: isValidElement,
      version: ReactVersion,
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
        ReactCurrentOwner: ReactCurrentOwner,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
      }
    };
    {
      _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
        // These should not be included in production.
        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
        // Shim for React DOM 16.0.0 which still destructured (but not used) this.
        // TODO: remove in React 17.0.
        ReactComponentTreeHook: {}
      });
    }
    var React$2 = Object.freeze({
      default: React
    });
    var React$3 = React$2 && React || React$2; // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.

    var react = React$3['default'] ? React$3['default'] : React$3;
    module.exports = react;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }

  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }

  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(26);
} else {
  module.exports = __webpack_require__(29);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.2.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var aa = __webpack_require__(4),
    l = __webpack_require__(13),
    B = __webpack_require__(14),
    C = __webpack_require__(2),
    ba = __webpack_require__(15),
    da = __webpack_require__(16),
    ea = __webpack_require__(17),
    fa = __webpack_require__(18),
    ia = __webpack_require__(19),
    D = __webpack_require__(5);

function E(a) {
  for (var b = arguments.length - 1, c = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, d = 0; d < b; d++) c += "\x26args[]\x3d" + encodeURIComponent(arguments[d + 1]);

  b = Error(c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");
  b.name = "Invariant Violation";
  b.framesToPop = 1;
  throw b;
}

aa ? void 0 : E("227");
var oa = {
  children: !0,
  dangerouslySetInnerHTML: !0,
  defaultValue: !0,
  defaultChecked: !0,
  innerHTML: !0,
  suppressContentEditableWarning: !0,
  suppressHydrationWarning: !0,
  style: !0
};

function pa(a, b) {
  return (a & b) === b;
}

var ta = {
  MUST_USE_PROPERTY: 1,
  HAS_BOOLEAN_VALUE: 4,
  HAS_NUMERIC_VALUE: 8,
  HAS_POSITIVE_NUMERIC_VALUE: 24,
  HAS_OVERLOADED_BOOLEAN_VALUE: 32,
  HAS_STRING_BOOLEAN_VALUE: 64,
  injectDOMPropertyConfig: function (a) {
    var b = ta,
        c = a.Properties || {},
        d = a.DOMAttributeNamespaces || {},
        e = a.DOMAttributeNames || {};
    a = a.DOMMutationMethods || {};

    for (var f in c) {
      ua.hasOwnProperty(f) ? E("48", f) : void 0;
      var g = f.toLowerCase(),
          h = c[f];
      g = {
        attributeName: g,
        attributeNamespace: null,
        propertyName: f,
        mutationMethod: null,
        mustUseProperty: pa(h, b.MUST_USE_PROPERTY),
        hasBooleanValue: pa(h, b.HAS_BOOLEAN_VALUE),
        hasNumericValue: pa(h, b.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: pa(h, b.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: pa(h, b.HAS_OVERLOADED_BOOLEAN_VALUE),
        hasStringBooleanValue: pa(h, b.HAS_STRING_BOOLEAN_VALUE)
      };
      1 >= g.hasBooleanValue + g.hasNumericValue + g.hasOverloadedBooleanValue ? void 0 : E("50", f);
      e.hasOwnProperty(f) && (g.attributeName = e[f]);
      d.hasOwnProperty(f) && (g.attributeNamespace = d[f]);
      a.hasOwnProperty(f) && (g.mutationMethod = a[f]);
      ua[f] = g;
    }
  }
},
    ua = {};

function va(a, b) {
  if (oa.hasOwnProperty(a) || 2 < a.length && ("o" === a[0] || "O" === a[0]) && ("n" === a[1] || "N" === a[1])) return !1;
  if (null === b) return !0;

  switch (typeof b) {
    case "boolean":
      return oa.hasOwnProperty(a) ? a = !0 : (b = wa(a)) ? a = b.hasBooleanValue || b.hasStringBooleanValue || b.hasOverloadedBooleanValue : (a = a.toLowerCase().slice(0, 5), a = "data-" === a || "aria-" === a), a;

    case "undefined":
    case "number":
    case "string":
    case "object":
      return !0;

    default:
      return !1;
  }
}

function wa(a) {
  return ua.hasOwnProperty(a) ? ua[a] : null;
}

var xa = ta,
    ya = xa.MUST_USE_PROPERTY,
    K = xa.HAS_BOOLEAN_VALUE,
    za = xa.HAS_NUMERIC_VALUE,
    Aa = xa.HAS_POSITIVE_NUMERIC_VALUE,
    Ba = xa.HAS_OVERLOADED_BOOLEAN_VALUE,
    Ca = xa.HAS_STRING_BOOLEAN_VALUE,
    Da = {
  Properties: {
    allowFullScreen: K,
    async: K,
    autoFocus: K,
    autoPlay: K,
    capture: Ba,
    checked: ya | K,
    cols: Aa,
    contentEditable: Ca,
    controls: K,
    "default": K,
    defer: K,
    disabled: K,
    download: Ba,
    draggable: Ca,
    formNoValidate: K,
    hidden: K,
    loop: K,
    multiple: ya | K,
    muted: ya | K,
    noValidate: K,
    open: K,
    playsInline: K,
    readOnly: K,
    required: K,
    reversed: K,
    rows: Aa,
    rowSpan: za,
    scoped: K,
    seamless: K,
    selected: ya | K,
    size: Aa,
    start: za,
    span: Aa,
    spellCheck: Ca,
    style: 0,
    tabIndex: 0,
    itemScope: K,
    acceptCharset: 0,
    className: 0,
    htmlFor: 0,
    httpEquiv: 0,
    value: Ca
  },
  DOMAttributeNames: {
    acceptCharset: "accept-charset",
    className: "class",
    htmlFor: "for",
    httpEquiv: "http-equiv"
  },
  DOMMutationMethods: {
    value: function (a, b) {
      if (null == b) return a.removeAttribute("value");
      "number" !== a.type || !1 === a.hasAttribute("value") ? a.setAttribute("value", "" + b) : a.validity && !a.validity.badInput && a.ownerDocument.activeElement !== a && a.setAttribute("value", "" + b);
    }
  }
},
    Ea = xa.HAS_STRING_BOOLEAN_VALUE,
    M = {
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace"
},
    Ga = {
  Properties: {
    autoReverse: Ea,
    externalResourcesRequired: Ea,
    preserveAlpha: Ea
  },
  DOMAttributeNames: {
    autoReverse: "autoReverse",
    externalResourcesRequired: "externalResourcesRequired",
    preserveAlpha: "preserveAlpha"
  },
  DOMAttributeNamespaces: {
    xlinkActuate: M.xlink,
    xlinkArcrole: M.xlink,
    xlinkHref: M.xlink,
    xlinkRole: M.xlink,
    xlinkShow: M.xlink,
    xlinkTitle: M.xlink,
    xlinkType: M.xlink,
    xmlBase: M.xml,
    xmlLang: M.xml,
    xmlSpace: M.xml
  }
},
    Ha = /[\-\:]([a-z])/g;

function Ia(a) {
  return a[1].toUpperCase();
}

"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function (a) {
  var b = a.replace(Ha, Ia);
  Ga.Properties[b] = 0;
  Ga.DOMAttributeNames[b] = a;
});
xa.injectDOMPropertyConfig(Da);
xa.injectDOMPropertyConfig(Ga);
var P = {
  _caughtError: null,
  _hasCaughtError: !1,
  _rethrowError: null,
  _hasRethrowError: !1,
  injection: {
    injectErrorUtils: function (a) {
      "function" !== typeof a.invokeGuardedCallback ? E("197") : void 0;
      Ja = a.invokeGuardedCallback;
    }
  },
  invokeGuardedCallback: function (a, b, c, d, e, f, g, h, k) {
    Ja.apply(P, arguments);
  },
  invokeGuardedCallbackAndCatchFirstError: function (a, b, c, d, e, f, g, h, k) {
    P.invokeGuardedCallback.apply(this, arguments);

    if (P.hasCaughtError()) {
      var q = P.clearCaughtError();
      P._hasRethrowError || (P._hasRethrowError = !0, P._rethrowError = q);
    }
  },
  rethrowCaughtError: function () {
    return Ka.apply(P, arguments);
  },
  hasCaughtError: function () {
    return P._hasCaughtError;
  },
  clearCaughtError: function () {
    if (P._hasCaughtError) {
      var a = P._caughtError;
      P._caughtError = null;
      P._hasCaughtError = !1;
      return a;
    }

    E("198");
  }
};

function Ja(a, b, c, d, e, f, g, h, k) {
  P._hasCaughtError = !1;
  P._caughtError = null;
  var q = Array.prototype.slice.call(arguments, 3);

  try {
    b.apply(c, q);
  } catch (v) {
    P._caughtError = v, P._hasCaughtError = !0;
  }
}

function Ka() {
  if (P._hasRethrowError) {
    var a = P._rethrowError;
    P._rethrowError = null;
    P._hasRethrowError = !1;
    throw a;
  }
}

var La = null,
    Ma = {};

function Na() {
  if (La) for (var a in Ma) {
    var b = Ma[a],
        c = La.indexOf(a);
    -1 < c ? void 0 : E("96", a);

    if (!Oa[c]) {
      b.extractEvents ? void 0 : E("97", a);
      Oa[c] = b;
      c = b.eventTypes;

      for (var d in c) {
        var e = void 0;
        var f = c[d],
            g = b,
            h = d;
        Pa.hasOwnProperty(h) ? E("99", h) : void 0;
        Pa[h] = f;
        var k = f.phasedRegistrationNames;

        if (k) {
          for (e in k) k.hasOwnProperty(e) && Qa(k[e], g, h);

          e = !0;
        } else f.registrationName ? (Qa(f.registrationName, g, h), e = !0) : e = !1;

        e ? void 0 : E("98", d, a);
      }
    }
  }
}

function Qa(a, b, c) {
  Ra[a] ? E("100", a) : void 0;
  Ra[a] = b;
  Sa[a] = b.eventTypes[c].dependencies;
}

var Oa = [],
    Pa = {},
    Ra = {},
    Sa = {};

function Ta(a) {
  La ? E("101") : void 0;
  La = Array.prototype.slice.call(a);
  Na();
}

function Ua(a) {
  var b = !1,
      c;

  for (c in a) if (a.hasOwnProperty(c)) {
    var d = a[c];
    Ma.hasOwnProperty(c) && Ma[c] === d || (Ma[c] ? E("102", c) : void 0, Ma[c] = d, b = !0);
  }

  b && Na();
}

var Va = Object.freeze({
  plugins: Oa,
  eventNameDispatchConfigs: Pa,
  registrationNameModules: Ra,
  registrationNameDependencies: Sa,
  possibleRegistrationNames: null,
  injectEventPluginOrder: Ta,
  injectEventPluginsByName: Ua
}),
    Wa = null,
    Xa = null,
    Ya = null;

function Za(a, b, c, d) {
  b = a.type || "unknown-event";
  a.currentTarget = Ya(d);
  P.invokeGuardedCallbackAndCatchFirstError(b, c, void 0, a);
  a.currentTarget = null;
}

function $a(a, b) {
  null == b ? E("30") : void 0;
  if (null == a) return b;

  if (Array.isArray(a)) {
    if (Array.isArray(b)) return a.push.apply(a, b), a;
    a.push(b);
    return a;
  }

  return Array.isArray(b) ? [a].concat(b) : [a, b];
}

function ab(a, b, c) {
  Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
}

var bb = null;

function cb(a, b) {
  if (a) {
    var c = a._dispatchListeners,
        d = a._dispatchInstances;
    if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++) Za(a, b, c[e], d[e]);else c && Za(a, b, c, d);
    a._dispatchListeners = null;
    a._dispatchInstances = null;
    a.isPersistent() || a.constructor.release(a);
  }
}

function db(a) {
  return cb(a, !0);
}

function gb(a) {
  return cb(a, !1);
}

var hb = {
  injectEventPluginOrder: Ta,
  injectEventPluginsByName: Ua
};

function ib(a, b) {
  var c = a.stateNode;
  if (!c) return null;
  var d = Wa(c);
  if (!d) return null;
  c = d[b];

  a: switch (b) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));
      a = !d;
      break a;

    default:
      a = !1;
  }

  if (a) return null;
  c && "function" !== typeof c ? E("231", b, typeof c) : void 0;
  return c;
}

function jb(a, b, c, d) {
  for (var e, f = 0; f < Oa.length; f++) {
    var g = Oa[f];
    g && (g = g.extractEvents(a, b, c, d)) && (e = $a(e, g));
  }

  return e;
}

function kb(a) {
  a && (bb = $a(bb, a));
}

function lb(a) {
  var b = bb;
  bb = null;
  b && (a ? ab(b, db) : ab(b, gb), bb ? E("95") : void 0, P.rethrowCaughtError());
}

var mb = Object.freeze({
  injection: hb,
  getListener: ib,
  extractEvents: jb,
  enqueueEvents: kb,
  processEventQueue: lb
}),
    nb = Math.random().toString(36).slice(2),
    Q = "__reactInternalInstance$" + nb,
    ob = "__reactEventHandlers$" + nb;

function pb(a) {
  if (a[Q]) return a[Q];

  for (var b = []; !a[Q];) if (b.push(a), a.parentNode) a = a.parentNode;else return null;

  var c = void 0,
      d = a[Q];
  if (5 === d.tag || 6 === d.tag) return d;

  for (; a && (d = a[Q]); a = b.pop()) c = d;

  return c;
}

function qb(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;
  E("33");
}

function rb(a) {
  return a[ob] || null;
}

var sb = Object.freeze({
  precacheFiberNode: function (a, b) {
    b[Q] = a;
  },
  getClosestInstanceFromNode: pb,
  getInstanceFromNode: function (a) {
    a = a[Q];
    return !a || 5 !== a.tag && 6 !== a.tag ? null : a;
  },
  getNodeFromInstance: qb,
  getFiberCurrentPropsFromNode: rb,
  updateFiberProps: function (a, b) {
    a[ob] = b;
  }
});

function tb(a) {
  do a = a["return"]; while (a && 5 !== a.tag);

  return a ? a : null;
}

function ub(a, b, c) {
  for (var d = []; a;) d.push(a), a = tb(a);

  for (a = d.length; 0 < a--;) b(d[a], "captured", c);

  for (a = 0; a < d.length; a++) b(d[a], "bubbled", c);
}

function vb(a, b, c) {
  if (b = ib(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = $a(c._dispatchListeners, b), c._dispatchInstances = $a(c._dispatchInstances, a);
}

function wb(a) {
  a && a.dispatchConfig.phasedRegistrationNames && ub(a._targetInst, vb, a);
}

function xb(a) {
  if (a && a.dispatchConfig.phasedRegistrationNames) {
    var b = a._targetInst;
    b = b ? tb(b) : null;
    ub(b, vb, a);
  }
}

function yb(a, b, c) {
  a && c && c.dispatchConfig.registrationName && (b = ib(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = $a(c._dispatchListeners, b), c._dispatchInstances = $a(c._dispatchInstances, a));
}

function zb(a) {
  a && a.dispatchConfig.registrationName && yb(a._targetInst, null, a);
}

function Ab(a) {
  ab(a, wb);
}

function Bb(a, b, c, d) {
  if (c && d) a: {
    var e = c;

    for (var f = d, g = 0, h = e; h; h = tb(h)) g++;

    h = 0;

    for (var k = f; k; k = tb(k)) h++;

    for (; 0 < g - h;) e = tb(e), g--;

    for (; 0 < h - g;) f = tb(f), h--;

    for (; g--;) {
      if (e === f || e === f.alternate) break a;
      e = tb(e);
      f = tb(f);
    }

    e = null;
  } else e = null;
  f = e;

  for (e = []; c && c !== f;) {
    g = c.alternate;
    if (null !== g && g === f) break;
    e.push(c);
    c = tb(c);
  }

  for (c = []; d && d !== f;) {
    g = d.alternate;
    if (null !== g && g === f) break;
    c.push(d);
    d = tb(d);
  }

  for (d = 0; d < e.length; d++) yb(e[d], "bubbled", a);

  for (a = c.length; 0 < a--;) yb(c[a], "captured", b);
}

var Cb = Object.freeze({
  accumulateTwoPhaseDispatches: Ab,
  accumulateTwoPhaseDispatchesSkipTarget: function (a) {
    ab(a, xb);
  },
  accumulateEnterLeaveDispatches: Bb,
  accumulateDirectDispatches: function (a) {
    ab(a, zb);
  }
}),
    Db = null;

function Eb() {
  !Db && l.canUseDOM && (Db = "textContent" in document.documentElement ? "textContent" : "innerText");
  return Db;
}

var S = {
  _root: null,
  _startText: null,
  _fallbackText: null
};

function Fb() {
  if (S._fallbackText) return S._fallbackText;
  var a,
      b = S._startText,
      c = b.length,
      d,
      e = Gb(),
      f = e.length;

  for (a = 0; a < c && b[a] === e[a]; a++);

  var g = c - a;

  for (d = 1; d <= g && b[c - d] === e[f - d]; d++);

  S._fallbackText = e.slice(a, 1 < d ? 1 - d : void 0);
  return S._fallbackText;
}

function Gb() {
  return "value" in S._root ? S._root.value : S._root[Eb()];
}

var Hb = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),
    Ib = {
  type: null,
  target: null,
  currentTarget: C.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (a) {
    return a.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

function T(a, b, c, d) {
  this.dispatchConfig = a;
  this._targetInst = b;
  this.nativeEvent = c;
  a = this.constructor.Interface;

  for (var e in a) a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);

  this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? C.thatReturnsTrue : C.thatReturnsFalse;
  this.isPropagationStopped = C.thatReturnsFalse;
  return this;
}

B(T.prototype, {
  preventDefault: function () {
    this.defaultPrevented = !0;
    var a = this.nativeEvent;
    a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = C.thatReturnsTrue);
  },
  stopPropagation: function () {
    var a = this.nativeEvent;
    a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = C.thatReturnsTrue);
  },
  persist: function () {
    this.isPersistent = C.thatReturnsTrue;
  },
  isPersistent: C.thatReturnsFalse,
  destructor: function () {
    var a = this.constructor.Interface,
        b;

    for (b in a) this[b] = null;

    for (a = 0; a < Hb.length; a++) this[Hb[a]] = null;
  }
});
T.Interface = Ib;

T.augmentClass = function (a, b) {
  function c() {}

  c.prototype = this.prototype;
  var d = new c();
  B(d, a.prototype);
  a.prototype = d;
  a.prototype.constructor = a;
  a.Interface = B({}, this.Interface, b);
  a.augmentClass = this.augmentClass;
  Jb(a);
};

Jb(T);

function Kb(a, b, c, d) {
  if (this.eventPool.length) {
    var e = this.eventPool.pop();
    this.call(e, a, b, c, d);
    return e;
  }

  return new this(a, b, c, d);
}

function Lb(a) {
  a instanceof this ? void 0 : E("223");
  a.destructor();
  10 > this.eventPool.length && this.eventPool.push(a);
}

function Jb(a) {
  a.eventPool = [];
  a.getPooled = Kb;
  a.release = Lb;
}

function Mb(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

T.augmentClass(Mb, {
  data: null
});

function Nb(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

T.augmentClass(Nb, {
  data: null
});
var Pb = [9, 13, 27, 32],
    Vb = l.canUseDOM && "CompositionEvent" in window,
    Wb = null;
l.canUseDOM && "documentMode" in document && (Wb = document.documentMode);
var Xb;

if (Xb = l.canUseDOM && "TextEvent" in window && !Wb) {
  var Yb = window.opera;
  Xb = !("object" === typeof Yb && "function" === typeof Yb.version && 12 >= parseInt(Yb.version(), 10));
}

var Zb = Xb,
    $b = l.canUseDOM && (!Vb || Wb && 8 < Wb && 11 >= Wb),
    ac = String.fromCharCode(32),
    bc = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: "onBeforeInput",
      captured: "onBeforeInputCapture"
    },
    dependencies: ["topCompositionEnd", "topKeyPress", "topTextInput", "topPaste"]
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: "onCompositionEnd",
      captured: "onCompositionEndCapture"
    },
    dependencies: "topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: "onCompositionStart",
      captured: "onCompositionStartCapture"
    },
    dependencies: "topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: "onCompositionUpdate",
      captured: "onCompositionUpdateCapture"
    },
    dependencies: "topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ")
  }
},
    cc = !1;

function dc(a, b) {
  switch (a) {
    case "topKeyUp":
      return -1 !== Pb.indexOf(b.keyCode);

    case "topKeyDown":
      return 229 !== b.keyCode;

    case "topKeyPress":
    case "topMouseDown":
    case "topBlur":
      return !0;

    default:
      return !1;
  }
}

function ec(a) {
  a = a.detail;
  return "object" === typeof a && "data" in a ? a.data : null;
}

var fc = !1;

function gc(a, b) {
  switch (a) {
    case "topCompositionEnd":
      return ec(b);

    case "topKeyPress":
      if (32 !== b.which) return null;
      cc = !0;
      return ac;

    case "topTextInput":
      return a = b.data, a === ac && cc ? null : a;

    default:
      return null;
  }
}

function hc(a, b) {
  if (fc) return "topCompositionEnd" === a || !Vb && dc(a, b) ? (a = Fb(), S._root = null, S._startText = null, S._fallbackText = null, fc = !1, a) : null;

  switch (a) {
    case "topPaste":
      return null;

    case "topKeyPress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;
        if (b.which) return String.fromCharCode(b.which);
      }

      return null;

    case "topCompositionEnd":
      return $b ? null : b.data;

    default:
      return null;
  }
}

var ic = {
  eventTypes: bc,
  extractEvents: function (a, b, c, d) {
    var e;
    if (Vb) b: {
      switch (a) {
        case "topCompositionStart":
          var f = bc.compositionStart;
          break b;

        case "topCompositionEnd":
          f = bc.compositionEnd;
          break b;

        case "topCompositionUpdate":
          f = bc.compositionUpdate;
          break b;
      }

      f = void 0;
    } else fc ? dc(a, c) && (f = bc.compositionEnd) : "topKeyDown" === a && 229 === c.keyCode && (f = bc.compositionStart);
    f ? ($b && (fc || f !== bc.compositionStart ? f === bc.compositionEnd && fc && (e = Fb()) : (S._root = d, S._startText = Gb(), fc = !0)), f = Mb.getPooled(f, b, c, d), e ? f.data = e : (e = ec(c), null !== e && (f.data = e)), Ab(f), e = f) : e = null;
    (a = Zb ? gc(a, c) : hc(a, c)) ? (b = Nb.getPooled(bc.beforeInput, b, c, d), b.data = a, Ab(b)) : b = null;
    return [e, b];
  }
},
    jc = null,
    kc = null,
    lc = null;

function mc(a) {
  if (a = Xa(a)) {
    jc && "function" === typeof jc.restoreControlledState ? void 0 : E("194");
    var b = Wa(a.stateNode);
    jc.restoreControlledState(a.stateNode, a.type, b);
  }
}

var nc = {
  injectFiberControlledHostComponent: function (a) {
    jc = a;
  }
};

function oc(a) {
  kc ? lc ? lc.push(a) : lc = [a] : kc = a;
}

function pc() {
  if (kc) {
    var a = kc,
        b = lc;
    lc = kc = null;
    mc(a);
    if (b) for (a = 0; a < b.length; a++) mc(b[a]);
  }
}

var qc = Object.freeze({
  injection: nc,
  enqueueStateRestore: oc,
  restoreStateIfNeeded: pc
});

function rc(a, b) {
  return a(b);
}

var sc = !1;

function tc(a, b) {
  if (sc) return rc(a, b);
  sc = !0;

  try {
    return rc(a, b);
  } finally {
    sc = !1, pc();
  }
}

var uc = {
  color: !0,
  date: !0,
  datetime: !0,
  "datetime-local": !0,
  email: !0,
  month: !0,
  number: !0,
  password: !0,
  range: !0,
  search: !0,
  tel: !0,
  text: !0,
  time: !0,
  url: !0,
  week: !0
};

function vc(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return "input" === b ? !!uc[a.type] : "textarea" === b ? !0 : !1;
}

function wc(a) {
  a = a.target || a.srcElement || window;
  a.correspondingUseElement && (a = a.correspondingUseElement);
  return 3 === a.nodeType ? a.parentNode : a;
}

var xc;
l.canUseDOM && (xc = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", ""));

function yc(a, b) {
  if (!l.canUseDOM || b && !("addEventListener" in document)) return !1;
  b = "on" + a;
  var c = b in document;
  c || (c = document.createElement("div"), c.setAttribute(b, "return;"), c = "function" === typeof c[b]);
  !c && xc && "wheel" === a && (c = document.implementation.hasFeature("Events.wheel", "3.0"));
  return c;
}

function zc(a) {
  var b = a.type;
  return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}

function Ac(a) {
  var b = zc(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];
  if (!a.hasOwnProperty(b) && "function" === typeof c.get && "function" === typeof c.set) return Object.defineProperty(a, b, {
    enumerable: c.enumerable,
    configurable: !0,
    get: function () {
      return c.get.call(this);
    },
    set: function (a) {
      d = "" + a;
      c.set.call(this, a);
    }
  }), {
    getValue: function () {
      return d;
    },
    setValue: function (a) {
      d = "" + a;
    },
    stopTracking: function () {
      a._valueTracker = null;
      delete a[b];
    }
  };
}

function Bc(a) {
  a._valueTracker || (a._valueTracker = Ac(a));
}

function Cc(a) {
  if (!a) return !1;
  var b = a._valueTracker;
  if (!b) return !0;
  var c = b.getValue();
  var d = "";
  a && (d = zc(a) ? a.checked ? "true" : "false" : a.value);
  a = d;
  return a !== c ? (b.setValue(a), !0) : !1;
}

var Dc = {
  change: {
    phasedRegistrationNames: {
      bubbled: "onChange",
      captured: "onChangeCapture"
    },
    dependencies: "topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ")
  }
};

function Ec(a, b, c) {
  a = T.getPooled(Dc.change, a, b, c);
  a.type = "change";
  oc(c);
  Ab(a);
  return a;
}

var Fc = null,
    Gc = null;

function Hc(a) {
  kb(a);
  lb(!1);
}

function Ic(a) {
  var b = qb(a);
  if (Cc(b)) return a;
}

function Jc(a, b) {
  if ("topChange" === a) return b;
}

var Kc = !1;
l.canUseDOM && (Kc = yc("input") && (!document.documentMode || 9 < document.documentMode));

function Lc() {
  Fc && (Fc.detachEvent("onpropertychange", Mc), Gc = Fc = null);
}

function Mc(a) {
  "value" === a.propertyName && Ic(Gc) && (a = Ec(Gc, a, wc(a)), tc(Hc, a));
}

function Nc(a, b, c) {
  "topFocus" === a ? (Lc(), Fc = b, Gc = c, Fc.attachEvent("onpropertychange", Mc)) : "topBlur" === a && Lc();
}

function Oc(a) {
  if ("topSelectionChange" === a || "topKeyUp" === a || "topKeyDown" === a) return Ic(Gc);
}

function Pc(a, b) {
  if ("topClick" === a) return Ic(b);
}

function $c(a, b) {
  if ("topInput" === a || "topChange" === a) return Ic(b);
}

var ad = {
  eventTypes: Dc,
  _isInputEventSupported: Kc,
  extractEvents: function (a, b, c, d) {
    var e = b ? qb(b) : window,
        f = e.nodeName && e.nodeName.toLowerCase();
    if ("select" === f || "input" === f && "file" === e.type) var g = Jc;else if (vc(e)) {
      if (Kc) g = $c;else {
        g = Oc;
        var h = Nc;
      }
    } else f = e.nodeName, !f || "input" !== f.toLowerCase() || "checkbox" !== e.type && "radio" !== e.type || (g = Pc);
    if (g && (g = g(a, b))) return Ec(g, c, d);
    h && h(a, e, b);
    "topBlur" === a && null != b && (a = b._wrapperState || e._wrapperState) && a.controlled && "number" === e.type && (a = "" + e.value, e.getAttribute("value") !== a && e.setAttribute("value", a));
  }
};

function bd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

T.augmentClass(bd, {
  view: null,
  detail: null
});
var cd = {
  Alt: "altKey",
  Control: "ctrlKey",
  Meta: "metaKey",
  Shift: "shiftKey"
};

function dd(a) {
  var b = this.nativeEvent;
  return b.getModifierState ? b.getModifierState(a) : (a = cd[a]) ? !!b[a] : !1;
}

function ed() {
  return dd;
}

function fd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

bd.augmentClass(fd, {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  pageX: null,
  pageY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: ed,
  button: null,
  buttons: null,
  relatedTarget: function (a) {
    return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
  }
});
var gd = {
  mouseEnter: {
    registrationName: "onMouseEnter",
    dependencies: ["topMouseOut", "topMouseOver"]
  },
  mouseLeave: {
    registrationName: "onMouseLeave",
    dependencies: ["topMouseOut", "topMouseOver"]
  }
},
    hd = {
  eventTypes: gd,
  extractEvents: function (a, b, c, d) {
    if ("topMouseOver" === a && (c.relatedTarget || c.fromElement) || "topMouseOut" !== a && "topMouseOver" !== a) return null;
    var e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window;
    "topMouseOut" === a ? (a = b, b = (b = c.relatedTarget || c.toElement) ? pb(b) : null) : a = null;
    if (a === b) return null;
    var f = null == a ? e : qb(a);
    e = null == b ? e : qb(b);
    var g = fd.getPooled(gd.mouseLeave, a, c, d);
    g.type = "mouseleave";
    g.target = f;
    g.relatedTarget = e;
    c = fd.getPooled(gd.mouseEnter, b, c, d);
    c.type = "mouseenter";
    c.target = e;
    c.relatedTarget = f;
    Bb(g, c, a, b);
    return [g, c];
  }
},
    id = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;

function jd(a) {
  a = a.type;
  return "string" === typeof a ? a : "function" === typeof a ? a.displayName || a.name : null;
}

function kd(a) {
  var b = a;
  if (a.alternate) for (; b["return"];) b = b["return"];else {
    if (0 !== (b.effectTag & 2)) return 1;

    for (; b["return"];) if (b = b["return"], 0 !== (b.effectTag & 2)) return 1;
  }
  return 3 === b.tag ? 2 : 3;
}

function ld(a) {
  return (a = a._reactInternalFiber) ? 2 === kd(a) : !1;
}

function md(a) {
  2 !== kd(a) ? E("188") : void 0;
}

function nd(a) {
  var b = a.alternate;
  if (!b) return b = kd(a), 3 === b ? E("188") : void 0, 1 === b ? null : a;

  for (var c = a, d = b;;) {
    var e = c["return"],
        f = e ? e.alternate : null;
    if (!e || !f) break;

    if (e.child === f.child) {
      for (var g = e.child; g;) {
        if (g === c) return md(e), a;
        if (g === d) return md(e), b;
        g = g.sibling;
      }

      E("188");
    }

    if (c["return"] !== d["return"]) c = e, d = f;else {
      g = !1;

      for (var h = e.child; h;) {
        if (h === c) {
          g = !0;
          c = e;
          d = f;
          break;
        }

        if (h === d) {
          g = !0;
          d = e;
          c = f;
          break;
        }

        h = h.sibling;
      }

      if (!g) {
        for (h = f.child; h;) {
          if (h === c) {
            g = !0;
            c = f;
            d = e;
            break;
          }

          if (h === d) {
            g = !0;
            d = f;
            c = e;
            break;
          }

          h = h.sibling;
        }

        g ? void 0 : E("189");
      }
    }
    c.alternate !== d ? E("190") : void 0;
  }

  3 !== c.tag ? E("188") : void 0;
  return c.stateNode.current === c ? a : b;
}

function od(a) {
  a = nd(a);
  if (!a) return null;

  for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;
    if (b.child) b.child["return"] = b, b = b.child;else {
      if (b === a) break;

      for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;
        b = b["return"];
      }

      b.sibling["return"] = b["return"];
      b = b.sibling;
    }
  }

  return null;
}

function pd(a) {
  a = nd(a);
  if (!a) return null;

  for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;
    if (b.child && 4 !== b.tag) b.child["return"] = b, b = b.child;else {
      if (b === a) break;

      for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;
        b = b["return"];
      }

      b.sibling["return"] = b["return"];
      b = b.sibling;
    }
  }

  return null;
}

var qd = [];

function rd(a) {
  var b = a.targetInst;

  do {
    if (!b) {
      a.ancestors.push(b);
      break;
    }

    var c;

    for (c = b; c["return"];) c = c["return"];

    c = 3 !== c.tag ? null : c.stateNode.containerInfo;
    if (!c) break;
    a.ancestors.push(b);
    b = pb(c);
  } while (b);

  for (c = 0; c < a.ancestors.length; c++) b = a.ancestors[c], sd(a.topLevelType, b, a.nativeEvent, wc(a.nativeEvent));
}

var td = !0,
    sd = void 0;

function ud(a) {
  td = !!a;
}

function U(a, b, c) {
  return c ? ba.listen(c, b, vd.bind(null, a)) : null;
}

function wd(a, b, c) {
  return c ? ba.capture(c, b, vd.bind(null, a)) : null;
}

function vd(a, b) {
  if (td) {
    var c = wc(b);
    c = pb(c);
    null === c || "number" !== typeof c.tag || 2 === kd(c) || (c = null);

    if (qd.length) {
      var d = qd.pop();
      d.topLevelType = a;
      d.nativeEvent = b;
      d.targetInst = c;
      a = d;
    } else a = {
      topLevelType: a,
      nativeEvent: b,
      targetInst: c,
      ancestors: []
    };

    try {
      tc(rd, a);
    } finally {
      a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 10 > qd.length && qd.push(a);
    }
  }
}

var xd = Object.freeze({
  get _enabled() {
    return td;
  },

  get _handleTopLevel() {
    return sd;
  },

  setHandleTopLevel: function (a) {
    sd = a;
  },
  setEnabled: ud,
  isEnabled: function () {
    return td;
  },
  trapBubbledEvent: U,
  trapCapturedEvent: wd,
  dispatchEvent: vd
});

function yd(a, b) {
  var c = {};
  c[a.toLowerCase()] = b.toLowerCase();
  c["Webkit" + a] = "webkit" + b;
  c["Moz" + a] = "moz" + b;
  c["ms" + a] = "MS" + b;
  c["O" + a] = "o" + b.toLowerCase();
  return c;
}

var zd = {
  animationend: yd("Animation", "AnimationEnd"),
  animationiteration: yd("Animation", "AnimationIteration"),
  animationstart: yd("Animation", "AnimationStart"),
  transitionend: yd("Transition", "TransitionEnd")
},
    Ad = {},
    Bd = {};
l.canUseDOM && (Bd = document.createElement("div").style, "AnimationEvent" in window || (delete zd.animationend.animation, delete zd.animationiteration.animation, delete zd.animationstart.animation), "TransitionEvent" in window || delete zd.transitionend.transition);

function Cd(a) {
  if (Ad[a]) return Ad[a];
  if (!zd[a]) return a;
  var b = zd[a],
      c;

  for (c in b) if (b.hasOwnProperty(c) && c in Bd) return Ad[a] = b[c];

  return "";
}

var Dd = {
  topAbort: "abort",
  topAnimationEnd: Cd("animationend") || "animationend",
  topAnimationIteration: Cd("animationiteration") || "animationiteration",
  topAnimationStart: Cd("animationstart") || "animationstart",
  topBlur: "blur",
  topCancel: "cancel",
  topCanPlay: "canplay",
  topCanPlayThrough: "canplaythrough",
  topChange: "change",
  topClick: "click",
  topClose: "close",
  topCompositionEnd: "compositionend",
  topCompositionStart: "compositionstart",
  topCompositionUpdate: "compositionupdate",
  topContextMenu: "contextmenu",
  topCopy: "copy",
  topCut: "cut",
  topDoubleClick: "dblclick",
  topDrag: "drag",
  topDragEnd: "dragend",
  topDragEnter: "dragenter",
  topDragExit: "dragexit",
  topDragLeave: "dragleave",
  topDragOver: "dragover",
  topDragStart: "dragstart",
  topDrop: "drop",
  topDurationChange: "durationchange",
  topEmptied: "emptied",
  topEncrypted: "encrypted",
  topEnded: "ended",
  topError: "error",
  topFocus: "focus",
  topInput: "input",
  topKeyDown: "keydown",
  topKeyPress: "keypress",
  topKeyUp: "keyup",
  topLoadedData: "loadeddata",
  topLoad: "load",
  topLoadedMetadata: "loadedmetadata",
  topLoadStart: "loadstart",
  topMouseDown: "mousedown",
  topMouseMove: "mousemove",
  topMouseOut: "mouseout",
  topMouseOver: "mouseover",
  topMouseUp: "mouseup",
  topPaste: "paste",
  topPause: "pause",
  topPlay: "play",
  topPlaying: "playing",
  topProgress: "progress",
  topRateChange: "ratechange",
  topScroll: "scroll",
  topSeeked: "seeked",
  topSeeking: "seeking",
  topSelectionChange: "selectionchange",
  topStalled: "stalled",
  topSuspend: "suspend",
  topTextInput: "textInput",
  topTimeUpdate: "timeupdate",
  topToggle: "toggle",
  topTouchCancel: "touchcancel",
  topTouchEnd: "touchend",
  topTouchMove: "touchmove",
  topTouchStart: "touchstart",
  topTransitionEnd: Cd("transitionend") || "transitionend",
  topVolumeChange: "volumechange",
  topWaiting: "waiting",
  topWheel: "wheel"
},
    Ed = {},
    Fd = 0,
    Gd = "_reactListenersID" + ("" + Math.random()).slice(2);

function Hd(a) {
  Object.prototype.hasOwnProperty.call(a, Gd) || (a[Gd] = Fd++, Ed[a[Gd]] = {});
  return Ed[a[Gd]];
}

function Id(a) {
  for (; a && a.firstChild;) a = a.firstChild;

  return a;
}

function Jd(a, b) {
  var c = Id(a);
  a = 0;

  for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;
      if (a <= b && d >= b) return {
        node: c,
        offset: b - a
      };
      a = d;
    }

    a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;
          break a;
        }

        c = c.parentNode;
      }

      c = void 0;
    }

    c = Id(c);
  }
}

function Kd(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();
  return b && ("input" === b && "text" === a.type || "textarea" === b || "true" === a.contentEditable);
}

var Ld = l.canUseDOM && "documentMode" in document && 11 >= document.documentMode,
    Md = {
  select: {
    phasedRegistrationNames: {
      bubbled: "onSelect",
      captured: "onSelectCapture"
    },
    dependencies: "topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ")
  }
},
    Nd = null,
    Od = null,
    Pd = null,
    Qd = !1;

function Rd(a, b) {
  if (Qd || null == Nd || Nd !== da()) return null;
  var c = Nd;
  "selectionStart" in c && Kd(c) ? c = {
    start: c.selectionStart,
    end: c.selectionEnd
  } : window.getSelection ? (c = window.getSelection(), c = {
    anchorNode: c.anchorNode,
    anchorOffset: c.anchorOffset,
    focusNode: c.focusNode,
    focusOffset: c.focusOffset
  }) : c = void 0;
  return Pd && ea(Pd, c) ? null : (Pd = c, a = T.getPooled(Md.select, Od, a, b), a.type = "select", a.target = Nd, Ab(a), a);
}

var Sd = {
  eventTypes: Md,
  extractEvents: function (a, b, c, d) {
    var e = d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument,
        f;

    if (!(f = !e)) {
      a: {
        e = Hd(e);
        f = Sa.onSelect;

        for (var g = 0; g < f.length; g++) {
          var h = f[g];

          if (!e.hasOwnProperty(h) || !e[h]) {
            e = !1;
            break a;
          }
        }

        e = !0;
      }

      f = !e;
    }

    if (f) return null;
    e = b ? qb(b) : window;

    switch (a) {
      case "topFocus":
        if (vc(e) || "true" === e.contentEditable) Nd = e, Od = b, Pd = null;
        break;

      case "topBlur":
        Pd = Od = Nd = null;
        break;

      case "topMouseDown":
        Qd = !0;
        break;

      case "topContextMenu":
      case "topMouseUp":
        return Qd = !1, Rd(c, d);

      case "topSelectionChange":
        if (Ld) break;

      case "topKeyDown":
      case "topKeyUp":
        return Rd(c, d);
    }

    return null;
  }
};

function Td(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

T.augmentClass(Td, {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
});

function Ud(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

T.augmentClass(Ud, {
  clipboardData: function (a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  }
});

function Vd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

bd.augmentClass(Vd, {
  relatedTarget: null
});

function Wd(a) {
  var b = a.keyCode;
  "charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;
  return 32 <= a || 13 === a ? a : 0;
}

var Xd = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
},
    Yd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
};

function Zd(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

bd.augmentClass(Zd, {
  key: function (a) {
    if (a.key) {
      var b = Xd[a.key] || a.key;
      if ("Unidentified" !== b) return b;
    }

    return "keypress" === a.type ? (a = Wd(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Yd[a.keyCode] || "Unidentified" : "";
  },
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: ed,
  charCode: function (a) {
    return "keypress" === a.type ? Wd(a) : 0;
  },
  keyCode: function (a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  },
  which: function (a) {
    return "keypress" === a.type ? Wd(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }
});

function $d(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

fd.augmentClass($d, {
  dataTransfer: null
});

function ae(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

bd.augmentClass(ae, {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: ed
});

function be(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

T.augmentClass(be, {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
});

function ce(a, b, c, d) {
  return T.call(this, a, b, c, d);
}

fd.augmentClass(ce, {
  deltaX: function (a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  },
  deltaY: function (a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  },
  deltaZ: null,
  deltaMode: null
});
var de = {},
    ee = {};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function (a) {
  var b = a[0].toUpperCase() + a.slice(1),
      c = "on" + b;
  b = "top" + b;
  c = {
    phasedRegistrationNames: {
      bubbled: c,
      captured: c + "Capture"
    },
    dependencies: [b]
  };
  de[a] = c;
  ee[b] = c;
});
var fe = {
  eventTypes: de,
  extractEvents: function (a, b, c, d) {
    var e = ee[a];
    if (!e) return null;

    switch (a) {
      case "topKeyPress":
        if (0 === Wd(c)) return null;

      case "topKeyDown":
      case "topKeyUp":
        a = Zd;
        break;

      case "topBlur":
      case "topFocus":
        a = Vd;
        break;

      case "topClick":
        if (2 === c.button) return null;

      case "topDoubleClick":
      case "topMouseDown":
      case "topMouseMove":
      case "topMouseUp":
      case "topMouseOut":
      case "topMouseOver":
      case "topContextMenu":
        a = fd;
        break;

      case "topDrag":
      case "topDragEnd":
      case "topDragEnter":
      case "topDragExit":
      case "topDragLeave":
      case "topDragOver":
      case "topDragStart":
      case "topDrop":
        a = $d;
        break;

      case "topTouchCancel":
      case "topTouchEnd":
      case "topTouchMove":
      case "topTouchStart":
        a = ae;
        break;

      case "topAnimationEnd":
      case "topAnimationIteration":
      case "topAnimationStart":
        a = Td;
        break;

      case "topTransitionEnd":
        a = be;
        break;

      case "topScroll":
        a = bd;
        break;

      case "topWheel":
        a = ce;
        break;

      case "topCopy":
      case "topCut":
      case "topPaste":
        a = Ud;
        break;

      default:
        a = T;
    }

    b = a.getPooled(e, b, c, d);
    Ab(b);
    return b;
  }
};

sd = function (a, b, c, d) {
  a = jb(a, b, c, d);
  kb(a);
  lb(!1);
};

hb.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
Wa = sb.getFiberCurrentPropsFromNode;
Xa = sb.getInstanceFromNode;
Ya = sb.getNodeFromInstance;
hb.injectEventPluginsByName({
  SimpleEventPlugin: fe,
  EnterLeaveEventPlugin: hd,
  ChangeEventPlugin: ad,
  SelectEventPlugin: Sd,
  BeforeInputEventPlugin: ic
});
var ge = [],
    he = -1;

function V(a) {
  0 > he || (a.current = ge[he], ge[he] = null, he--);
}

function W(a, b) {
  he++;
  ge[he] = a.current;
  a.current = b;
}

new Set();
var ie = {
  current: D
},
    X = {
  current: !1
},
    je = D;

function ke(a) {
  return le(a) ? je : ie.current;
}

function me(a, b) {
  var c = a.type.contextTypes;
  if (!c) return D;
  var d = a.stateNode;
  if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
  var e = {},
      f;

  for (f in c) e[f] = b[f];

  d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);
  return e;
}

function le(a) {
  return 2 === a.tag && null != a.type.childContextTypes;
}

function ne(a) {
  le(a) && (V(X, a), V(ie, a));
}

function oe(a, b, c) {
  null != ie.cursor ? E("168") : void 0;
  W(ie, b, a);
  W(X, c, a);
}

function pe(a, b) {
  var c = a.stateNode,
      d = a.type.childContextTypes;
  if ("function" !== typeof c.getChildContext) return b;
  c = c.getChildContext();

  for (var e in c) e in d ? void 0 : E("108", jd(a) || "Unknown", e);

  return B({}, b, c);
}

function qe(a) {
  if (!le(a)) return !1;
  var b = a.stateNode;
  b = b && b.__reactInternalMemoizedMergedChildContext || D;
  je = ie.current;
  W(ie, b, a);
  W(X, X.current, a);
  return !0;
}

function re(a, b) {
  var c = a.stateNode;
  c ? void 0 : E("169");

  if (b) {
    var d = pe(a, je);
    c.__reactInternalMemoizedMergedChildContext = d;
    V(X, a);
    V(ie, a);
    W(ie, d, a);
  } else V(X, a);

  W(X, b, a);
}

function Y(a, b, c) {
  this.tag = a;
  this.key = b;
  this.stateNode = this.type = null;
  this.sibling = this.child = this["return"] = null;
  this.index = 0;
  this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null;
  this.internalContextTag = c;
  this.effectTag = 0;
  this.lastEffect = this.firstEffect = this.nextEffect = null;
  this.expirationTime = 0;
  this.alternate = null;
}

function se(a, b, c) {
  var d = a.alternate;
  null === d ? (d = new Y(a.tag, a.key, a.internalContextTag), d.type = a.type, d.stateNode = a.stateNode, d.alternate = a, a.alternate = d) : (d.effectTag = 0, d.nextEffect = null, d.firstEffect = null, d.lastEffect = null);
  d.expirationTime = c;
  d.pendingProps = b;
  d.child = a.child;
  d.memoizedProps = a.memoizedProps;
  d.memoizedState = a.memoizedState;
  d.updateQueue = a.updateQueue;
  d.sibling = a.sibling;
  d.index = a.index;
  d.ref = a.ref;
  return d;
}

function te(a, b, c) {
  var d = void 0,
      e = a.type,
      f = a.key;
  "function" === typeof e ? (d = e.prototype && e.prototype.isReactComponent ? new Y(2, f, b) : new Y(0, f, b), d.type = e, d.pendingProps = a.props) : "string" === typeof e ? (d = new Y(5, f, b), d.type = e, d.pendingProps = a.props) : "object" === typeof e && null !== e && "number" === typeof e.tag ? (d = e, d.pendingProps = a.props) : E("130", null == e ? e : typeof e, "");
  d.expirationTime = c;
  return d;
}

function ue(a, b, c, d) {
  b = new Y(10, d, b);
  b.pendingProps = a;
  b.expirationTime = c;
  return b;
}

function ve(a, b, c) {
  b = new Y(6, null, b);
  b.pendingProps = a;
  b.expirationTime = c;
  return b;
}

function we(a, b, c) {
  b = new Y(7, a.key, b);
  b.type = a.handler;
  b.pendingProps = a;
  b.expirationTime = c;
  return b;
}

function xe(a, b, c) {
  a = new Y(9, null, b);
  a.expirationTime = c;
  return a;
}

function ye(a, b, c) {
  b = new Y(4, a.key, b);
  b.pendingProps = a.children || [];
  b.expirationTime = c;
  b.stateNode = {
    containerInfo: a.containerInfo,
    pendingChildren: null,
    implementation: a.implementation
  };
  return b;
}

var ze = null,
    Ae = null;

function Be(a) {
  return function (b) {
    try {
      return a(b);
    } catch (c) {}
  };
}

function Ce(a) {
  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
  var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (b.isDisabled || !b.supportsFiber) return !0;

  try {
    var c = b.inject(a);
    ze = Be(function (a) {
      return b.onCommitFiberRoot(c, a);
    });
    Ae = Be(function (a) {
      return b.onCommitFiberUnmount(c, a);
    });
  } catch (d) {}

  return !0;
}

function De(a) {
  "function" === typeof ze && ze(a);
}

function Ee(a) {
  "function" === typeof Ae && Ae(a);
}

function Fe(a) {
  return {
    baseState: a,
    expirationTime: 0,
    first: null,
    last: null,
    callbackList: null,
    hasForceUpdate: !1,
    isInitialized: !1
  };
}

function Ge(a, b) {
  null === a.last ? a.first = a.last = b : (a.last.next = b, a.last = b);
  if (0 === a.expirationTime || a.expirationTime > b.expirationTime) a.expirationTime = b.expirationTime;
}

function He(a, b) {
  var c = a.alternate,
      d = a.updateQueue;
  null === d && (d = a.updateQueue = Fe(null));
  null !== c ? (a = c.updateQueue, null === a && (a = c.updateQueue = Fe(null))) : a = null;
  a = a !== d ? a : null;
  null === a ? Ge(d, b) : null === d.last || null === a.last ? (Ge(d, b), Ge(a, b)) : (Ge(d, b), a.last = b);
}

function Ie(a, b, c, d) {
  a = a.partialState;
  return "function" === typeof a ? a.call(b, c, d) : a;
}

function Je(a, b, c, d, e, f) {
  null !== a && a.updateQueue === c && (c = b.updateQueue = {
    baseState: c.baseState,
    expirationTime: c.expirationTime,
    first: c.first,
    last: c.last,
    isInitialized: c.isInitialized,
    callbackList: null,
    hasForceUpdate: !1
  });
  c.expirationTime = 0;
  c.isInitialized ? a = c.baseState : (a = c.baseState = b.memoizedState, c.isInitialized = !0);

  for (var g = !0, h = c.first, k = !1; null !== h;) {
    var q = h.expirationTime;

    if (q > f) {
      var v = c.expirationTime;
      if (0 === v || v > q) c.expirationTime = q;
      k || (k = !0, c.baseState = a);
    } else {
      k || (c.first = h.next, null === c.first && (c.last = null));
      if (h.isReplace) a = Ie(h, d, a, e), g = !0;else if (q = Ie(h, d, a, e)) a = g ? B({}, a, q) : B(a, q), g = !1;
      h.isForced && (c.hasForceUpdate = !0);
      null !== h.callback && (q = c.callbackList, null === q && (q = c.callbackList = []), q.push(h));
    }

    h = h.next;
  }

  null !== c.callbackList ? b.effectTag |= 32 : null !== c.first || c.hasForceUpdate || (b.updateQueue = null);
  k || (c.baseState = a);
  return a;
}

function Ke(a, b) {
  var c = a.callbackList;
  if (null !== c) for (a.callbackList = null, a = 0; a < c.length; a++) {
    var d = c[a],
        e = d.callback;
    d.callback = null;
    "function" !== typeof e ? E("191", e) : void 0;
    e.call(b);
  }
}

function Le(a, b, c, d) {
  function e(a, b) {
    b.updater = f;
    a.stateNode = b;
    b._reactInternalFiber = a;
  }

  var f = {
    isMounted: ld,
    enqueueSetState: function (c, d, e) {
      c = c._reactInternalFiber;
      e = void 0 === e ? null : e;
      var g = b(c);
      He(c, {
        expirationTime: g,
        partialState: d,
        callback: e,
        isReplace: !1,
        isForced: !1,
        nextCallback: null,
        next: null
      });
      a(c, g);
    },
    enqueueReplaceState: function (c, d, e) {
      c = c._reactInternalFiber;
      e = void 0 === e ? null : e;
      var g = b(c);
      He(c, {
        expirationTime: g,
        partialState: d,
        callback: e,
        isReplace: !0,
        isForced: !1,
        nextCallback: null,
        next: null
      });
      a(c, g);
    },
    enqueueForceUpdate: function (c, d) {
      c = c._reactInternalFiber;
      d = void 0 === d ? null : d;
      var e = b(c);
      He(c, {
        expirationTime: e,
        partialState: null,
        callback: d,
        isReplace: !1,
        isForced: !0,
        nextCallback: null,
        next: null
      });
      a(c, e);
    }
  };
  return {
    adoptClassInstance: e,
    constructClassInstance: function (a, b) {
      var c = a.type,
          d = ke(a),
          f = 2 === a.tag && null != a.type.contextTypes,
          g = f ? me(a, d) : D;
      b = new c(b, g);
      e(a, b);
      f && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = d, a.__reactInternalMemoizedMaskedChildContext = g);
      return b;
    },
    mountClassInstance: function (a, b) {
      var c = a.alternate,
          d = a.stateNode,
          e = d.state || null,
          g = a.pendingProps;
      g ? void 0 : E("158");
      var h = ke(a);
      d.props = g;
      d.state = a.memoizedState = e;
      d.refs = D;
      d.context = me(a, h);
      null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent && (a.internalContextTag |= 1);
      "function" === typeof d.componentWillMount && (e = d.state, d.componentWillMount(), e !== d.state && f.enqueueReplaceState(d, d.state, null), e = a.updateQueue, null !== e && (d.state = Je(c, a, e, d, g, b)));
      "function" === typeof d.componentDidMount && (a.effectTag |= 4);
    },
    updateClassInstance: function (a, b, e) {
      var g = b.stateNode;
      g.props = b.memoizedProps;
      g.state = b.memoizedState;
      var h = b.memoizedProps,
          k = b.pendingProps;
      k || (k = h, null == k ? E("159") : void 0);
      var u = g.context,
          z = ke(b);
      z = me(b, z);
      "function" !== typeof g.componentWillReceiveProps || h === k && u === z || (u = g.state, g.componentWillReceiveProps(k, z), g.state !== u && f.enqueueReplaceState(g, g.state, null));
      u = b.memoizedState;
      e = null !== b.updateQueue ? Je(a, b, b.updateQueue, g, k, e) : u;
      if (!(h !== k || u !== e || X.current || null !== b.updateQueue && b.updateQueue.hasForceUpdate)) return "function" !== typeof g.componentDidUpdate || h === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), !1;
      var G = k;
      if (null === h || null !== b.updateQueue && b.updateQueue.hasForceUpdate) G = !0;else {
        var I = b.stateNode,
            L = b.type;
        G = "function" === typeof I.shouldComponentUpdate ? I.shouldComponentUpdate(G, e, z) : L.prototype && L.prototype.isPureReactComponent ? !ea(h, G) || !ea(u, e) : !0;
      }
      G ? ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(k, e, z), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4)) : ("function" !== typeof g.componentDidUpdate || h === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), c(b, k), d(b, e));
      g.props = k;
      g.state = e;
      g.context = z;
      return G;
    }
  };
}

var Qe = "function" === typeof Symbol && Symbol["for"],
    Re = Qe ? Symbol["for"]("react.element") : 60103,
    Se = Qe ? Symbol["for"]("react.call") : 60104,
    Te = Qe ? Symbol["for"]("react.return") : 60105,
    Ue = Qe ? Symbol["for"]("react.portal") : 60106,
    Ve = Qe ? Symbol["for"]("react.fragment") : 60107,
    We = "function" === typeof Symbol && Symbol.iterator;

function Xe(a) {
  if (null === a || "undefined" === typeof a) return null;
  a = We && a[We] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}

var Ye = Array.isArray;

function Ze(a, b) {
  var c = b.ref;

  if (null !== c && "function" !== typeof c) {
    if (b._owner) {
      b = b._owner;
      var d = void 0;
      b && (2 !== b.tag ? E("110") : void 0, d = b.stateNode);
      d ? void 0 : E("147", c);
      var e = "" + c;
      if (null !== a && null !== a.ref && a.ref._stringRef === e) return a.ref;

      a = function (a) {
        var b = d.refs === D ? d.refs = {} : d.refs;
        null === a ? delete b[e] : b[e] = a;
      };

      a._stringRef = e;
      return a;
    }

    "string" !== typeof c ? E("148") : void 0;
    b._owner ? void 0 : E("149", c);
  }

  return c;
}

function $e(a, b) {
  "textarea" !== a.type && E("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
}

function af(a) {
  function b(b, c) {
    if (a) {
      var d = b.lastEffect;
      null !== d ? (d.nextEffect = c, b.lastEffect = c) : b.firstEffect = b.lastEffect = c;
      c.nextEffect = null;
      c.effectTag = 8;
    }
  }

  function c(c, d) {
    if (!a) return null;

    for (; null !== d;) b(c, d), d = d.sibling;

    return null;
  }

  function d(a, b) {
    for (a = new Map(); null !== b;) null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;

    return a;
  }

  function e(a, b, c) {
    a = se(a, b, c);
    a.index = 0;
    a.sibling = null;
    return a;
  }

  function f(b, c, d) {
    b.index = d;
    if (!a) return c;
    d = b.alternate;
    if (null !== d) return d = d.index, d < c ? (b.effectTag = 2, c) : d;
    b.effectTag = 2;
    return c;
  }

  function g(b) {
    a && null === b.alternate && (b.effectTag = 2);
    return b;
  }

  function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = ve(c, a.internalContextTag, d), b["return"] = a, b;
    b = e(b, c, d);
    b["return"] = a;
    return b;
  }

  function k(a, b, c, d) {
    if (null !== b && b.type === c.type) return d = e(b, c.props, d), d.ref = Ze(b, c), d["return"] = a, d;
    d = te(c, a.internalContextTag, d);
    d.ref = Ze(b, c);
    d["return"] = a;
    return d;
  }

  function q(a, b, c, d) {
    if (null === b || 7 !== b.tag) return b = we(c, a.internalContextTag, d), b["return"] = a, b;
    b = e(b, c, d);
    b["return"] = a;
    return b;
  }

  function v(a, b, c, d) {
    if (null === b || 9 !== b.tag) return b = xe(c, a.internalContextTag, d), b.type = c.value, b["return"] = a, b;
    b = e(b, null, d);
    b.type = c.value;
    b["return"] = a;
    return b;
  }

  function y(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = ye(c, a.internalContextTag, d), b["return"] = a, b;
    b = e(b, c.children || [], d);
    b["return"] = a;
    return b;
  }

  function u(a, b, c, d, f) {
    if (null === b || 10 !== b.tag) return b = ue(c, a.internalContextTag, d, f), b["return"] = a, b;
    b = e(b, c, d);
    b["return"] = a;
    return b;
  }

  function z(a, b, c) {
    if ("string" === typeof b || "number" === typeof b) return b = ve("" + b, a.internalContextTag, c), b["return"] = a, b;

    if ("object" === typeof b && null !== b) {
      switch (b.$$typeof) {
        case Re:
          if (b.type === Ve) return b = ue(b.props.children, a.internalContextTag, c, b.key), b["return"] = a, b;
          c = te(b, a.internalContextTag, c);
          c.ref = Ze(null, b);
          c["return"] = a;
          return c;

        case Se:
          return b = we(b, a.internalContextTag, c), b["return"] = a, b;

        case Te:
          return c = xe(b, a.internalContextTag, c), c.type = b.value, c["return"] = a, c;

        case Ue:
          return b = ye(b, a.internalContextTag, c), b["return"] = a, b;
      }

      if (Ye(b) || Xe(b)) return b = ue(b, a.internalContextTag, c, null), b["return"] = a, b;
      $e(a, b);
    }

    return null;
  }

  function G(a, b, c, d) {
    var e = null !== b ? b.key : null;
    if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);

    if ("object" === typeof c && null !== c) {
      switch (c.$$typeof) {
        case Re:
          return c.key === e ? c.type === Ve ? u(a, b, c.props.children, d, e) : k(a, b, c, d) : null;

        case Se:
          return c.key === e ? q(a, b, c, d) : null;

        case Te:
          return null === e ? v(a, b, c, d) : null;

        case Ue:
          return c.key === e ? y(a, b, c, d) : null;
      }

      if (Ye(c) || Xe(c)) return null !== e ? null : u(a, b, c, d, null);
      $e(a, c);
    }

    return null;
  }

  function I(a, b, c, d, e) {
    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);

    if ("object" === typeof d && null !== d) {
      switch (d.$$typeof) {
        case Re:
          return a = a.get(null === d.key ? c : d.key) || null, d.type === Ve ? u(b, a, d.props.children, e, d.key) : k(b, a, d, e);

        case Se:
          return a = a.get(null === d.key ? c : d.key) || null, q(b, a, d, e);

        case Te:
          return a = a.get(c) || null, v(b, a, d, e);

        case Ue:
          return a = a.get(null === d.key ? c : d.key) || null, y(b, a, d, e);
      }

      if (Ye(d) || Xe(d)) return a = a.get(c) || null, u(b, a, d, e, null);
      $e(b, d);
    }

    return null;
  }

  function L(e, g, m, A) {
    for (var h = null, r = null, n = g, w = g = 0, k = null; null !== n && w < m.length; w++) {
      n.index > w ? (k = n, n = null) : k = n.sibling;
      var x = G(e, n, m[w], A);

      if (null === x) {
        null === n && (n = k);
        break;
      }

      a && n && null === x.alternate && b(e, n);
      g = f(x, g, w);
      null === r ? h = x : r.sibling = x;
      r = x;
      n = k;
    }

    if (w === m.length) return c(e, n), h;

    if (null === n) {
      for (; w < m.length; w++) if (n = z(e, m[w], A)) g = f(n, g, w), null === r ? h = n : r.sibling = n, r = n;

      return h;
    }

    for (n = d(e, n); w < m.length; w++) if (k = I(n, e, w, m[w], A)) {
      if (a && null !== k.alternate) n["delete"](null === k.key ? w : k.key);
      g = f(k, g, w);
      null === r ? h = k : r.sibling = k;
      r = k;
    }

    a && n.forEach(function (a) {
      return b(e, a);
    });
    return h;
  }

  function N(e, g, m, A) {
    var h = Xe(m);
    "function" !== typeof h ? E("150") : void 0;
    m = h.call(m);
    null == m ? E("151") : void 0;

    for (var r = h = null, n = g, w = g = 0, k = null, x = m.next(); null !== n && !x.done; w++, x = m.next()) {
      n.index > w ? (k = n, n = null) : k = n.sibling;
      var J = G(e, n, x.value, A);

      if (null === J) {
        n || (n = k);
        break;
      }

      a && n && null === J.alternate && b(e, n);
      g = f(J, g, w);
      null === r ? h = J : r.sibling = J;
      r = J;
      n = k;
    }

    if (x.done) return c(e, n), h;

    if (null === n) {
      for (; !x.done; w++, x = m.next()) x = z(e, x.value, A), null !== x && (g = f(x, g, w), null === r ? h = x : r.sibling = x, r = x);

      return h;
    }

    for (n = d(e, n); !x.done; w++, x = m.next()) if (x = I(n, e, w, x.value, A), null !== x) {
      if (a && null !== x.alternate) n["delete"](null === x.key ? w : x.key);
      g = f(x, g, w);
      null === r ? h = x : r.sibling = x;
      r = x;
    }

    a && n.forEach(function (a) {
      return b(e, a);
    });
    return h;
  }

  return function (a, d, f, h) {
    "object" === typeof f && null !== f && f.type === Ve && null === f.key && (f = f.props.children);
    var m = "object" === typeof f && null !== f;
    if (m) switch (f.$$typeof) {
      case Re:
        a: {
          var r = f.key;

          for (m = d; null !== m;) {
            if (m.key === r) {
              if (10 === m.tag ? f.type === Ve : m.type === f.type) {
                c(a, m.sibling);
                d = e(m, f.type === Ve ? f.props.children : f.props, h);
                d.ref = Ze(m, f);
                d["return"] = a;
                a = d;
                break a;
              } else {
                c(a, m);
                break;
              }
            } else b(a, m);
            m = m.sibling;
          }

          f.type === Ve ? (d = ue(f.props.children, a.internalContextTag, h, f.key), d["return"] = a, a = d) : (h = te(f, a.internalContextTag, h), h.ref = Ze(d, f), h["return"] = a, a = h);
        }

        return g(a);

      case Se:
        a: {
          for (m = f.key; null !== d;) {
            if (d.key === m) {
              if (7 === d.tag) {
                c(a, d.sibling);
                d = e(d, f, h);
                d["return"] = a;
                a = d;
                break a;
              } else {
                c(a, d);
                break;
              }
            } else b(a, d);
            d = d.sibling;
          }

          d = we(f, a.internalContextTag, h);
          d["return"] = a;
          a = d;
        }

        return g(a);

      case Te:
        a: {
          if (null !== d) if (9 === d.tag) {
            c(a, d.sibling);
            d = e(d, null, h);
            d.type = f.value;
            d["return"] = a;
            a = d;
            break a;
          } else c(a, d);
          d = xe(f, a.internalContextTag, h);
          d.type = f.value;
          d["return"] = a;
          a = d;
        }

        return g(a);

      case Ue:
        a: {
          for (m = f.key; null !== d;) {
            if (d.key === m) {
              if (4 === d.tag && d.stateNode.containerInfo === f.containerInfo && d.stateNode.implementation === f.implementation) {
                c(a, d.sibling);
                d = e(d, f.children || [], h);
                d["return"] = a;
                a = d;
                break a;
              } else {
                c(a, d);
                break;
              }
            } else b(a, d);
            d = d.sibling;
          }

          d = ye(f, a.internalContextTag, h);
          d["return"] = a;
          a = d;
        }

        return g(a);
    }
    if ("string" === typeof f || "number" === typeof f) return f = "" + f, null !== d && 6 === d.tag ? (c(a, d.sibling), d = e(d, f, h)) : (c(a, d), d = ve(f, a.internalContextTag, h)), d["return"] = a, a = d, g(a);
    if (Ye(f)) return L(a, d, f, h);
    if (Xe(f)) return N(a, d, f, h);
    m && $e(a, f);
    if ("undefined" === typeof f) switch (a.tag) {
      case 2:
      case 1:
        h = a.type, E("152", h.displayName || h.name || "Component");
    }
    return c(a, d);
  };
}

var bf = af(!0),
    cf = af(!1);

function df(a, b, c, d, e) {
  function f(a, b, c) {
    var d = b.expirationTime;
    b.child = null === a ? cf(b, null, c, d) : bf(b, a.child, c, d);
  }

  function g(a, b) {
    var c = b.ref;
    null === c || a && a.ref === c || (b.effectTag |= 128);
  }

  function h(a, b, c, d) {
    g(a, b);
    if (!c) return d && re(b, !1), q(a, b);
    c = b.stateNode;
    id.current = b;
    var e = c.render();
    b.effectTag |= 1;
    f(a, b, e);
    b.memoizedState = c.state;
    b.memoizedProps = c.props;
    d && re(b, !0);
    return b.child;
  }

  function k(a) {
    var b = a.stateNode;
    b.pendingContext ? oe(a, b.pendingContext, b.pendingContext !== b.context) : b.context && oe(a, b.context, !1);
    I(a, b.containerInfo);
  }

  function q(a, b) {
    null !== a && b.child !== a.child ? E("153") : void 0;

    if (null !== b.child) {
      a = b.child;
      var c = se(a, a.pendingProps, a.expirationTime);
      b.child = c;

      for (c["return"] = b; null !== a.sibling;) a = a.sibling, c = c.sibling = se(a, a.pendingProps, a.expirationTime), c["return"] = b;

      c.sibling = null;
    }

    return b.child;
  }

  function v(a, b) {
    switch (b.tag) {
      case 3:
        k(b);
        break;

      case 2:
        qe(b);
        break;

      case 4:
        I(b, b.stateNode.containerInfo);
    }

    return null;
  }

  var y = a.shouldSetTextContent,
      u = a.useSyncScheduling,
      z = a.shouldDeprioritizeSubtree,
      G = b.pushHostContext,
      I = b.pushHostContainer,
      L = c.enterHydrationState,
      N = c.resetHydrationState,
      J = c.tryToClaimNextHydratableInstance;
  a = Le(d, e, function (a, b) {
    a.memoizedProps = b;
  }, function (a, b) {
    a.memoizedState = b;
  });
  var w = a.adoptClassInstance,
      m = a.constructClassInstance,
      A = a.mountClassInstance,
      Ob = a.updateClassInstance;
  return {
    beginWork: function (a, b, c) {
      if (0 === b.expirationTime || b.expirationTime > c) return v(a, b);

      switch (b.tag) {
        case 0:
          null !== a ? E("155") : void 0;
          var d = b.type,
              e = b.pendingProps,
              r = ke(b);
          r = me(b, r);
          d = d(e, r);
          b.effectTag |= 1;
          "object" === typeof d && null !== d && "function" === typeof d.render ? (b.tag = 2, e = qe(b), w(b, d), A(b, c), b = h(a, b, !0, e)) : (b.tag = 1, f(a, b, d), b.memoizedProps = e, b = b.child);
          return b;

        case 1:
          a: {
            e = b.type;
            c = b.pendingProps;
            d = b.memoizedProps;
            if (X.current) null === c && (c = d);else if (null === c || d === c) {
              b = q(a, b);
              break a;
            }
            d = ke(b);
            d = me(b, d);
            e = e(c, d);
            b.effectTag |= 1;
            f(a, b, e);
            b.memoizedProps = c;
            b = b.child;
          }

          return b;

        case 2:
          return e = qe(b), d = void 0, null === a ? b.stateNode ? E("153") : (m(b, b.pendingProps), A(b, c), d = !0) : d = Ob(a, b, c), h(a, b, d, e);

        case 3:
          return k(b), e = b.updateQueue, null !== e ? (d = b.memoizedState, e = Je(a, b, e, null, null, c), d === e ? (N(), b = q(a, b)) : (d = e.element, r = b.stateNode, (null === a || null === a.child) && r.hydrate && L(b) ? (b.effectTag |= 2, b.child = cf(b, null, d, c)) : (N(), f(a, b, d)), b.memoizedState = e, b = b.child)) : (N(), b = q(a, b)), b;

        case 5:
          G(b);
          null === a && J(b);
          e = b.type;
          var n = b.memoizedProps;
          d = b.pendingProps;
          null === d && (d = n, null === d ? E("154") : void 0);
          r = null !== a ? a.memoizedProps : null;
          X.current || null !== d && n !== d ? (n = d.children, y(e, d) ? n = null : r && y(e, r) && (b.effectTag |= 16), g(a, b), 2147483647 !== c && !u && z(e, d) ? (b.expirationTime = 2147483647, b = null) : (f(a, b, n), b.memoizedProps = d, b = b.child)) : b = q(a, b);
          return b;

        case 6:
          return null === a && J(b), a = b.pendingProps, null === a && (a = b.memoizedProps), b.memoizedProps = a, null;

        case 8:
          b.tag = 7;

        case 7:
          e = b.pendingProps;
          if (X.current) null === e && (e = a && a.memoizedProps, null === e ? E("154") : void 0);else if (null === e || b.memoizedProps === e) e = b.memoizedProps;
          d = e.children;
          b.stateNode = null === a ? cf(b, b.stateNode, d, c) : bf(b, b.stateNode, d, c);
          b.memoizedProps = e;
          return b.stateNode;

        case 9:
          return null;

        case 4:
          a: {
            I(b, b.stateNode.containerInfo);
            e = b.pendingProps;
            if (X.current) null === e && (e = a && a.memoizedProps, null == e ? E("154") : void 0);else if (null === e || b.memoizedProps === e) {
              b = q(a, b);
              break a;
            }
            null === a ? b.child = bf(b, null, e, c) : f(a, b, e);
            b.memoizedProps = e;
            b = b.child;
          }

          return b;

        case 10:
          a: {
            c = b.pendingProps;
            if (X.current) null === c && (c = b.memoizedProps);else if (null === c || b.memoizedProps === c) {
              b = q(a, b);
              break a;
            }
            f(a, b, c);
            b.memoizedProps = c;
            b = b.child;
          }

          return b;

        default:
          E("156");
      }
    },
    beginFailedWork: function (a, b, c) {
      switch (b.tag) {
        case 2:
          qe(b);
          break;

        case 3:
          k(b);
          break;

        default:
          E("157");
      }

      b.effectTag |= 64;
      null === a ? b.child = null : b.child !== a.child && (b.child = a.child);
      if (0 === b.expirationTime || b.expirationTime > c) return v(a, b);
      b.firstEffect = null;
      b.lastEffect = null;
      b.child = null === a ? cf(b, null, null, c) : bf(b, a.child, null, c);
      2 === b.tag && (a = b.stateNode, b.memoizedProps = a.props, b.memoizedState = a.state);
      return b.child;
    }
  };
}

function ef(a, b, c) {
  function d(a) {
    a.effectTag |= 4;
  }

  var e = a.createInstance,
      f = a.createTextInstance,
      g = a.appendInitialChild,
      h = a.finalizeInitialChildren,
      k = a.prepareUpdate,
      q = a.persistence,
      v = b.getRootHostContainer,
      y = b.popHostContext,
      u = b.getHostContext,
      z = b.popHostContainer,
      G = c.prepareToHydrateHostInstance,
      I = c.prepareToHydrateHostTextInstance,
      L = c.popHydrationState,
      N = void 0,
      J = void 0,
      w = void 0;
  a.mutation ? (N = function () {}, J = function (a, b, c) {
    (b.updateQueue = c) && d(b);
  }, w = function (a, b, c, e) {
    c !== e && d(b);
  }) : q ? E("235") : E("236");
  return {
    completeWork: function (a, b, c) {
      var m = b.pendingProps;
      if (null === m) m = b.memoizedProps;else if (2147483647 !== b.expirationTime || 2147483647 === c) b.pendingProps = null;

      switch (b.tag) {
        case 1:
          return null;

        case 2:
          return ne(b), null;

        case 3:
          z(b);
          V(X, b);
          V(ie, b);
          m = b.stateNode;
          m.pendingContext && (m.context = m.pendingContext, m.pendingContext = null);
          if (null === a || null === a.child) L(b), b.effectTag &= -3;
          N(b);
          return null;

        case 5:
          y(b);
          c = v();
          var A = b.type;

          if (null !== a && null != b.stateNode) {
            var p = a.memoizedProps,
                q = b.stateNode,
                x = u();
            q = k(q, A, p, m, c, x);
            J(a, b, q, A, p, m, c);
            a.ref !== b.ref && (b.effectTag |= 128);
          } else {
            if (!m) return null === b.stateNode ? E("166") : void 0, null;
            a = u();
            if (L(b)) G(b, c, a) && d(b);else {
              a = e(A, m, c, a, b);

              a: for (p = b.child; null !== p;) {
                if (5 === p.tag || 6 === p.tag) g(a, p.stateNode);else if (4 !== p.tag && null !== p.child) {
                  p.child["return"] = p;
                  p = p.child;
                  continue;
                }
                if (p === b) break;

                for (; null === p.sibling;) {
                  if (null === p["return"] || p["return"] === b) break a;
                  p = p["return"];
                }

                p.sibling["return"] = p["return"];
                p = p.sibling;
              }

              h(a, A, m, c) && d(b);
              b.stateNode = a;
            }
            null !== b.ref && (b.effectTag |= 128);
          }

          return null;

        case 6:
          if (a && null != b.stateNode) w(a, b, a.memoizedProps, m);else {
            if ("string" !== typeof m) return null === b.stateNode ? E("166") : void 0, null;
            a = v();
            c = u();
            L(b) ? I(b) && d(b) : b.stateNode = f(m, a, c, b);
          }
          return null;

        case 7:
          (m = b.memoizedProps) ? void 0 : E("165");
          b.tag = 8;
          A = [];

          a: for ((p = b.stateNode) && (p["return"] = b); null !== p;) {
            if (5 === p.tag || 6 === p.tag || 4 === p.tag) E("247");else if (9 === p.tag) A.push(p.type);else if (null !== p.child) {
              p.child["return"] = p;
              p = p.child;
              continue;
            }

            for (; null === p.sibling;) {
              if (null === p["return"] || p["return"] === b) break a;
              p = p["return"];
            }

            p.sibling["return"] = p["return"];
            p = p.sibling;
          }

          p = m.handler;
          m = p(m.props, A);
          b.child = bf(b, null !== a ? a.child : null, m, c);
          return b.child;

        case 8:
          return b.tag = 7, null;

        case 9:
          return null;

        case 10:
          return null;

        case 4:
          return z(b), N(b), null;

        case 0:
          E("167");

        default:
          E("156");
      }
    }
  };
}

function ff(a, b) {
  function c(a) {
    var c = a.ref;
    if (null !== c) try {
      c(null);
    } catch (A) {
      b(a, A);
    }
  }

  function d(a) {
    "function" === typeof Ee && Ee(a);

    switch (a.tag) {
      case 2:
        c(a);
        var d = a.stateNode;
        if ("function" === typeof d.componentWillUnmount) try {
          d.props = a.memoizedProps, d.state = a.memoizedState, d.componentWillUnmount();
        } catch (A) {
          b(a, A);
        }
        break;

      case 5:
        c(a);
        break;

      case 7:
        e(a.stateNode);
        break;

      case 4:
        k && g(a);
    }
  }

  function e(a) {
    for (var b = a;;) if (d(b), null === b.child || k && 4 === b.tag) {
      if (b === a) break;

      for (; null === b.sibling;) {
        if (null === b["return"] || b["return"] === a) return;
        b = b["return"];
      }

      b.sibling["return"] = b["return"];
      b = b.sibling;
    } else b.child["return"] = b, b = b.child;
  }

  function f(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }

  function g(a) {
    for (var b = a, c = !1, f = void 0, g = void 0;;) {
      if (!c) {
        c = b["return"];

        a: for (;;) {
          null === c ? E("160") : void 0;

          switch (c.tag) {
            case 5:
              f = c.stateNode;
              g = !1;
              break a;

            case 3:
              f = c.stateNode.containerInfo;
              g = !0;
              break a;

            case 4:
              f = c.stateNode.containerInfo;
              g = !0;
              break a;
          }

          c = c["return"];
        }

        c = !0;
      }

      if (5 === b.tag || 6 === b.tag) e(b), g ? J(f, b.stateNode) : N(f, b.stateNode);else if (4 === b.tag ? f = b.stateNode.containerInfo : d(b), null !== b.child) {
        b.child["return"] = b;
        b = b.child;
        continue;
      }
      if (b === a) break;

      for (; null === b.sibling;) {
        if (null === b["return"] || b["return"] === a) return;
        b = b["return"];
        4 === b.tag && (c = !1);
      }

      b.sibling["return"] = b["return"];
      b = b.sibling;
    }
  }

  var h = a.getPublicInstance,
      k = a.mutation;
  a = a.persistence;
  k || (a ? E("235") : E("236"));
  var q = k.commitMount,
      v = k.commitUpdate,
      y = k.resetTextContent,
      u = k.commitTextUpdate,
      z = k.appendChild,
      G = k.appendChildToContainer,
      I = k.insertBefore,
      L = k.insertInContainerBefore,
      N = k.removeChild,
      J = k.removeChildFromContainer;
  return {
    commitResetTextContent: function (a) {
      y(a.stateNode);
    },
    commitPlacement: function (a) {
      a: {
        for (var b = a["return"]; null !== b;) {
          if (f(b)) {
            var c = b;
            break a;
          }

          b = b["return"];
        }

        E("160");
        c = void 0;
      }

      var d = b = void 0;

      switch (c.tag) {
        case 5:
          b = c.stateNode;
          d = !1;
          break;

        case 3:
          b = c.stateNode.containerInfo;
          d = !0;
          break;

        case 4:
          b = c.stateNode.containerInfo;
          d = !0;
          break;

        default:
          E("161");
      }

      c.effectTag & 16 && (y(b), c.effectTag &= -17);

      a: b: for (c = a;;) {
        for (; null === c.sibling;) {
          if (null === c["return"] || f(c["return"])) {
            c = null;
            break a;
          }

          c = c["return"];
        }

        c.sibling["return"] = c["return"];

        for (c = c.sibling; 5 !== c.tag && 6 !== c.tag;) {
          if (c.effectTag & 2) continue b;
          if (null === c.child || 4 === c.tag) continue b;else c.child["return"] = c, c = c.child;
        }

        if (!(c.effectTag & 2)) {
          c = c.stateNode;
          break a;
        }
      }

      for (var e = a;;) {
        if (5 === e.tag || 6 === e.tag) c ? d ? L(b, e.stateNode, c) : I(b, e.stateNode, c) : d ? G(b, e.stateNode) : z(b, e.stateNode);else if (4 !== e.tag && null !== e.child) {
          e.child["return"] = e;
          e = e.child;
          continue;
        }
        if (e === a) break;

        for (; null === e.sibling;) {
          if (null === e["return"] || e["return"] === a) return;
          e = e["return"];
        }

        e.sibling["return"] = e["return"];
        e = e.sibling;
      }
    },
    commitDeletion: function (a) {
      g(a);
      a["return"] = null;
      a.child = null;
      a.alternate && (a.alternate.child = null, a.alternate["return"] = null);
    },
    commitWork: function (a, b) {
      switch (b.tag) {
        case 2:
          break;

        case 5:
          var c = b.stateNode;

          if (null != c) {
            var d = b.memoizedProps;
            a = null !== a ? a.memoizedProps : d;
            var e = b.type,
                f = b.updateQueue;
            b.updateQueue = null;
            null !== f && v(c, f, e, a, d, b);
          }

          break;

        case 6:
          null === b.stateNode ? E("162") : void 0;
          c = b.memoizedProps;
          u(b.stateNode, null !== a ? a.memoizedProps : c, c);
          break;

        case 3:
          break;

        default:
          E("163");
      }
    },
    commitLifeCycles: function (a, b) {
      switch (b.tag) {
        case 2:
          var c = b.stateNode;
          if (b.effectTag & 4) if (null === a) c.props = b.memoizedProps, c.state = b.memoizedState, c.componentDidMount();else {
            var d = a.memoizedProps;
            a = a.memoizedState;
            c.props = b.memoizedProps;
            c.state = b.memoizedState;
            c.componentDidUpdate(d, a);
          }
          b = b.updateQueue;
          null !== b && Ke(b, c);
          break;

        case 3:
          c = b.updateQueue;
          null !== c && Ke(c, null !== b.child ? b.child.stateNode : null);
          break;

        case 5:
          c = b.stateNode;
          null === a && b.effectTag & 4 && q(c, b.type, b.memoizedProps, b);
          break;

        case 6:
          break;

        case 4:
          break;

        default:
          E("163");
      }
    },
    commitAttachRef: function (a) {
      var b = a.ref;

      if (null !== b) {
        var c = a.stateNode;

        switch (a.tag) {
          case 5:
            b(h(c));
            break;

          default:
            b(c);
        }
      }
    },
    commitDetachRef: function (a) {
      a = a.ref;
      null !== a && a(null);
    }
  };
}

var gf = {};

function hf(a) {
  function b(a) {
    a === gf ? E("174") : void 0;
    return a;
  }

  var c = a.getChildHostContext,
      d = a.getRootHostContext,
      e = {
    current: gf
  },
      f = {
    current: gf
  },
      g = {
    current: gf
  };
  return {
    getHostContext: function () {
      return b(e.current);
    },
    getRootHostContainer: function () {
      return b(g.current);
    },
    popHostContainer: function (a) {
      V(e, a);
      V(f, a);
      V(g, a);
    },
    popHostContext: function (a) {
      f.current === a && (V(e, a), V(f, a));
    },
    pushHostContainer: function (a, b) {
      W(g, b, a);
      b = d(b);
      W(f, a, a);
      W(e, b, a);
    },
    pushHostContext: function (a) {
      var d = b(g.current),
          h = b(e.current);
      d = c(h, a.type, d);
      h !== d && (W(f, a, a), W(e, d, a));
    },
    resetHostContainer: function () {
      e.current = gf;
      g.current = gf;
    }
  };
}

function jf(a) {
  function b(a, b) {
    var c = new Y(5, null, 0);
    c.type = "DELETED";
    c.stateNode = b;
    c["return"] = a;
    c.effectTag = 8;
    null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }

  function c(a, b) {
    switch (a.tag) {
      case 5:
        return b = f(b, a.type, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

      case 6:
        return b = g(b, a.pendingProps), null !== b ? (a.stateNode = b, !0) : !1;

      default:
        return !1;
    }
  }

  function d(a) {
    for (a = a["return"]; null !== a && 5 !== a.tag && 3 !== a.tag;) a = a["return"];

    y = a;
  }

  var e = a.shouldSetTextContent;
  a = a.hydration;
  if (!a) return {
    enterHydrationState: function () {
      return !1;
    },
    resetHydrationState: function () {},
    tryToClaimNextHydratableInstance: function () {},
    prepareToHydrateHostInstance: function () {
      E("175");
    },
    prepareToHydrateHostTextInstance: function () {
      E("176");
    },
    popHydrationState: function () {
      return !1;
    }
  };
  var f = a.canHydrateInstance,
      g = a.canHydrateTextInstance,
      h = a.getNextHydratableSibling,
      k = a.getFirstHydratableChild,
      q = a.hydrateInstance,
      v = a.hydrateTextInstance,
      y = null,
      u = null,
      z = !1;
  return {
    enterHydrationState: function (a) {
      u = k(a.stateNode.containerInfo);
      y = a;
      return z = !0;
    },
    resetHydrationState: function () {
      u = y = null;
      z = !1;
    },
    tryToClaimNextHydratableInstance: function (a) {
      if (z) {
        var d = u;

        if (d) {
          if (!c(a, d)) {
            d = h(d);

            if (!d || !c(a, d)) {
              a.effectTag |= 2;
              z = !1;
              y = a;
              return;
            }

            b(y, u);
          }

          y = a;
          u = k(d);
        } else a.effectTag |= 2, z = !1, y = a;
      }
    },
    prepareToHydrateHostInstance: function (a, b, c) {
      b = q(a.stateNode, a.type, a.memoizedProps, b, c, a);
      a.updateQueue = b;
      return null !== b ? !0 : !1;
    },
    prepareToHydrateHostTextInstance: function (a) {
      return v(a.stateNode, a.memoizedProps, a);
    },
    popHydrationState: function (a) {
      if (a !== y) return !1;
      if (!z) return d(a), z = !0, !1;
      var c = a.type;
      if (5 !== a.tag || "head" !== c && "body" !== c && !e(c, a.memoizedProps)) for (c = u; c;) b(a, c), c = h(c);
      d(a);
      u = y ? h(a.stateNode) : null;
      return !0;
    }
  };
}

function kf(a) {
  function b(a) {
    Qb = ja = !0;
    var b = a.stateNode;
    b.current === a ? E("177") : void 0;
    b.isReadyForCommit = !1;
    id.current = null;
    if (1 < a.effectTag) {
      if (null !== a.lastEffect) {
        a.lastEffect.nextEffect = a;
        var c = a.firstEffect;
      } else c = a;
    } else c = a.firstEffect;
    yg();

    for (t = c; null !== t;) {
      var d = !1,
          e = void 0;

      try {
        for (; null !== t;) {
          var f = t.effectTag;
          f & 16 && zg(t);

          if (f & 128) {
            var g = t.alternate;
            null !== g && Ag(g);
          }

          switch (f & -242) {
            case 2:
              Ne(t);
              t.effectTag &= -3;
              break;

            case 6:
              Ne(t);
              t.effectTag &= -3;
              Oe(t.alternate, t);
              break;

            case 4:
              Oe(t.alternate, t);
              break;

            case 8:
              Sc = !0, Bg(t), Sc = !1;
          }

          t = t.nextEffect;
        }
      } catch (Tc) {
        d = !0, e = Tc;
      }

      d && (null === t ? E("178") : void 0, h(t, e), null !== t && (t = t.nextEffect));
    }

    Cg();
    b.current = a;

    for (t = c; null !== t;) {
      c = !1;
      d = void 0;

      try {
        for (; null !== t;) {
          var k = t.effectTag;
          k & 36 && Dg(t.alternate, t);
          k & 128 && Eg(t);
          if (k & 64) switch (e = t, f = void 0, null !== R && (f = R.get(e), R["delete"](e), null == f && null !== e.alternate && (e = e.alternate, f = R.get(e), R["delete"](e))), null == f ? E("184") : void 0, e.tag) {
            case 2:
              e.stateNode.componentDidCatch(f.error, {
                componentStack: f.componentStack
              });
              break;

            case 3:
              null === ca && (ca = f.error);
              break;

            default:
              E("157");
          }
          var Qc = t.nextEffect;
          t.nextEffect = null;
          t = Qc;
        }
      } catch (Tc) {
        c = !0, d = Tc;
      }

      c && (null === t ? E("178") : void 0, h(t, d), null !== t && (t = t.nextEffect));
    }

    ja = Qb = !1;
    "function" === typeof De && De(a.stateNode);
    ha && (ha.forEach(G), ha = null);
    null !== ca && (a = ca, ca = null, Ob(a));
    b = b.current.expirationTime;
    0 === b && (qa = R = null);
    return b;
  }

  function c(a) {
    for (;;) {
      var b = Fg(a.alternate, a, H),
          c = a["return"],
          d = a.sibling;
      var e = a;

      if (2147483647 === H || 2147483647 !== e.expirationTime) {
        if (2 !== e.tag && 3 !== e.tag) var f = 0;else f = e.updateQueue, f = null === f ? 0 : f.expirationTime;

        for (var g = e.child; null !== g;) 0 !== g.expirationTime && (0 === f || f > g.expirationTime) && (f = g.expirationTime), g = g.sibling;

        e.expirationTime = f;
      }

      if (null !== b) return b;
      null !== c && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, c.lastEffect = a));
      if (null !== d) return d;
      if (null !== c) a = c;else {
        a.stateNode.isReadyForCommit = !0;
        break;
      }
    }

    return null;
  }

  function d(a) {
    var b = rg(a.alternate, a, H);
    null === b && (b = c(a));
    id.current = null;
    return b;
  }

  function e(a) {
    var b = Gg(a.alternate, a, H);
    null === b && (b = c(a));
    id.current = null;
    return b;
  }

  function f(a) {
    if (null !== R) {
      if (!(0 === H || H > a)) if (H <= Uc) for (; null !== F;) F = k(F) ? e(F) : d(F);else for (; null !== F && !A();) F = k(F) ? e(F) : d(F);
    } else if (!(0 === H || H > a)) if (H <= Uc) for (; null !== F;) F = d(F);else for (; null !== F && !A();) F = d(F);
  }

  function g(a, b) {
    ja ? E("243") : void 0;
    ja = !0;
    a.isReadyForCommit = !1;

    if (a !== ra || b !== H || null === F) {
      for (; -1 < he;) ge[he] = null, he--;

      je = D;
      ie.current = D;
      X.current = !1;
      x();
      ra = a;
      H = b;
      F = se(ra.current, null, b);
    }

    var c = !1,
        d = null;

    try {
      f(b);
    } catch (Rc) {
      c = !0, d = Rc;
    }

    for (; c;) {
      if (eb) {
        ca = d;
        break;
      }

      var g = F;
      if (null === g) eb = !0;else {
        var k = h(g, d);
        null === k ? E("183") : void 0;

        if (!eb) {
          try {
            c = k;
            d = b;

            for (k = c; null !== g;) {
              switch (g.tag) {
                case 2:
                  ne(g);
                  break;

                case 5:
                  qg(g);
                  break;

                case 3:
                  p(g);
                  break;

                case 4:
                  p(g);
              }

              if (g === k || g.alternate === k) break;
              g = g["return"];
            }

            F = e(c);
            f(d);
          } catch (Rc) {
            c = !0;
            d = Rc;
            continue;
          }

          break;
        }
      }
    }

    b = ca;
    eb = ja = !1;
    ca = null;
    null !== b && Ob(b);
    return a.isReadyForCommit ? a.current.alternate : null;
  }

  function h(a, b) {
    var c = id.current = null,
        d = !1,
        e = !1,
        f = null;
    if (3 === a.tag) c = a, q(a) && (eb = !0);else for (var g = a["return"]; null !== g && null === c;) {
      2 === g.tag ? "function" === typeof g.stateNode.componentDidCatch && (d = !0, f = jd(g), c = g, e = !0) : 3 === g.tag && (c = g);

      if (q(g)) {
        if (Sc || null !== ha && (ha.has(g) || null !== g.alternate && ha.has(g.alternate))) return null;
        c = null;
        e = !1;
      }

      g = g["return"];
    }

    if (null !== c) {
      null === qa && (qa = new Set());
      qa.add(c);
      var h = "";
      g = a;

      do {
        a: switch (g.tag) {
          case 0:
          case 1:
          case 2:
          case 5:
            var k = g._debugOwner,
                Qc = g._debugSource;
            var m = jd(g);
            var n = null;
            k && (n = jd(k));
            k = Qc;
            m = "\n    in " + (m || "Unknown") + (k ? " (at " + k.fileName.replace(/^.*[\\\/]/, "") + ":" + k.lineNumber + ")" : n ? " (created by " + n + ")" : "");
            break a;

          default:
            m = "";
        }

        h += m;
        g = g["return"];
      } while (g);

      g = h;
      a = jd(a);
      null === R && (R = new Map());
      b = {
        componentName: a,
        componentStack: g,
        error: b,
        errorBoundary: d ? c.stateNode : null,
        errorBoundaryFound: d,
        errorBoundaryName: f,
        willRetry: e
      };
      R.set(c, b);

      try {
        var p = b.error;
        p && p.suppressReactErrorLogging || console.error(p);
      } catch (Vc) {
        Vc && Vc.suppressReactErrorLogging || console.error(Vc);
      }

      Qb ? (null === ha && (ha = new Set()), ha.add(c)) : G(c);
      return c;
    }

    null === ca && (ca = b);
    return null;
  }

  function k(a) {
    return null !== R && (R.has(a) || null !== a.alternate && R.has(a.alternate));
  }

  function q(a) {
    return null !== qa && (qa.has(a) || null !== a.alternate && qa.has(a.alternate));
  }

  function v() {
    return 20 * (((I() + 100) / 20 | 0) + 1);
  }

  function y(a) {
    return 0 !== ka ? ka : ja ? Qb ? 1 : H : !Hg || a.internalContextTag & 1 ? v() : 1;
  }

  function u(a, b) {
    return z(a, b, !1);
  }

  function z(a, b) {
    for (; null !== a;) {
      if (0 === a.expirationTime || a.expirationTime > b) a.expirationTime = b;
      null !== a.alternate && (0 === a.alternate.expirationTime || a.alternate.expirationTime > b) && (a.alternate.expirationTime = b);
      if (null === a["return"]) if (3 === a.tag) {
        var c = a.stateNode;
        !ja && c === ra && b < H && (F = ra = null, H = 0);
        var d = c,
            e = b;
        Rb > Ig && E("185");
        if (null === d.nextScheduledRoot) d.remainingExpirationTime = e, null === O ? (sa = O = d, d.nextScheduledRoot = d) : (O = O.nextScheduledRoot = d, O.nextScheduledRoot = sa);else {
          var f = d.remainingExpirationTime;
          if (0 === f || e < f) d.remainingExpirationTime = e;
        }
        Fa || (la ? Sb && (ma = d, na = 1, m(ma, na)) : 1 === e ? w(1, null) : L(e));
        !ja && c === ra && b < H && (F = ra = null, H = 0);
      } else break;
      a = a["return"];
    }
  }

  function G(a) {
    z(a, 1, !0);
  }

  function I() {
    return Uc = ((Wc() - Pe) / 10 | 0) + 2;
  }

  function L(a) {
    if (0 !== Tb) {
      if (a > Tb) return;
      Jg(Xc);
    }

    var b = Wc() - Pe;
    Tb = a;
    Xc = Kg(J, {
      timeout: 10 * (a - 2) - b
    });
  }

  function N() {
    var a = 0,
        b = null;
    if (null !== O) for (var c = O, d = sa; null !== d;) {
      var e = d.remainingExpirationTime;

      if (0 === e) {
        null === c || null === O ? E("244") : void 0;

        if (d === d.nextScheduledRoot) {
          sa = O = d.nextScheduledRoot = null;
          break;
        } else if (d === sa) sa = e = d.nextScheduledRoot, O.nextScheduledRoot = e, d.nextScheduledRoot = null;else if (d === O) {
          O = c;
          O.nextScheduledRoot = sa;
          d.nextScheduledRoot = null;
          break;
        } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null;

        d = c.nextScheduledRoot;
      } else {
        if (0 === a || e < a) a = e, b = d;
        if (d === O) break;
        c = d;
        d = d.nextScheduledRoot;
      }
    }
    c = ma;
    null !== c && c === b ? Rb++ : Rb = 0;
    ma = b;
    na = a;
  }

  function J(a) {
    w(0, a);
  }

  function w(a, b) {
    fb = b;

    for (N(); null !== ma && 0 !== na && (0 === a || na <= a) && !Yc;) m(ma, na), N();

    null !== fb && (Tb = 0, Xc = -1);
    0 !== na && L(na);
    fb = null;
    Yc = !1;
    Rb = 0;
    if (Ub) throw a = Zc, Zc = null, Ub = !1, a;
  }

  function m(a, c) {
    Fa ? E("245") : void 0;
    Fa = !0;

    if (c <= I()) {
      var d = a.finishedWork;
      null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (a.remainingExpirationTime = b(d)));
    } else d = a.finishedWork, null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (A() ? a.finishedWork = d : a.remainingExpirationTime = b(d)));

    Fa = !1;
  }

  function A() {
    return null === fb || fb.timeRemaining() > Lg ? !1 : Yc = !0;
  }

  function Ob(a) {
    null === ma ? E("246") : void 0;
    ma.remainingExpirationTime = 0;
    Ub || (Ub = !0, Zc = a);
  }

  var r = hf(a),
      n = jf(a),
      p = r.popHostContainer,
      qg = r.popHostContext,
      x = r.resetHostContainer,
      Me = df(a, r, n, u, y),
      rg = Me.beginWork,
      Gg = Me.beginFailedWork,
      Fg = ef(a, r, n).completeWork;
  r = ff(a, h);
  var zg = r.commitResetTextContent,
      Ne = r.commitPlacement,
      Bg = r.commitDeletion,
      Oe = r.commitWork,
      Dg = r.commitLifeCycles,
      Eg = r.commitAttachRef,
      Ag = r.commitDetachRef,
      Wc = a.now,
      Kg = a.scheduleDeferredCallback,
      Jg = a.cancelDeferredCallback,
      Hg = a.useSyncScheduling,
      yg = a.prepareForCommit,
      Cg = a.resetAfterCommit,
      Pe = Wc(),
      Uc = 2,
      ka = 0,
      ja = !1,
      F = null,
      ra = null,
      H = 0,
      t = null,
      R = null,
      qa = null,
      ha = null,
      ca = null,
      eb = !1,
      Qb = !1,
      Sc = !1,
      sa = null,
      O = null,
      Tb = 0,
      Xc = -1,
      Fa = !1,
      ma = null,
      na = 0,
      Yc = !1,
      Ub = !1,
      Zc = null,
      fb = null,
      la = !1,
      Sb = !1,
      Ig = 1E3,
      Rb = 0,
      Lg = 1;
  return {
    computeAsyncExpiration: v,
    computeExpirationForFiber: y,
    scheduleWork: u,
    batchedUpdates: function (a, b) {
      var c = la;
      la = !0;

      try {
        return a(b);
      } finally {
        (la = c) || Fa || w(1, null);
      }
    },
    unbatchedUpdates: function (a) {
      if (la && !Sb) {
        Sb = !0;

        try {
          return a();
        } finally {
          Sb = !1;
        }
      }

      return a();
    },
    flushSync: function (a) {
      var b = la;
      la = !0;

      try {
        a: {
          var c = ka;
          ka = 1;

          try {
            var d = a();
            break a;
          } finally {
            ka = c;
          }

          d = void 0;
        }

        return d;
      } finally {
        la = b, Fa ? E("187") : void 0, w(1, null);
      }
    },
    deferredUpdates: function (a) {
      var b = ka;
      ka = v();

      try {
        return a();
      } finally {
        ka = b;
      }
    }
  };
}

function lf(a) {
  function b(a) {
    a = od(a);
    return null === a ? null : a.stateNode;
  }

  var c = a.getPublicInstance;
  a = kf(a);
  var d = a.computeAsyncExpiration,
      e = a.computeExpirationForFiber,
      f = a.scheduleWork;
  return {
    createContainer: function (a, b) {
      var c = new Y(3, null, 0);
      a = {
        current: c,
        containerInfo: a,
        pendingChildren: null,
        remainingExpirationTime: 0,
        isReadyForCommit: !1,
        finishedWork: null,
        context: null,
        pendingContext: null,
        hydrate: b,
        nextScheduledRoot: null
      };
      return c.stateNode = a;
    },
    updateContainer: function (a, b, c, q) {
      var g = b.current;

      if (c) {
        c = c._reactInternalFiber;
        var h;

        b: {
          2 === kd(c) && 2 === c.tag ? void 0 : E("170");

          for (h = c; 3 !== h.tag;) {
            if (le(h)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;
              break b;
            }

            (h = h["return"]) ? void 0 : E("171");
          }

          h = h.stateNode.context;
        }

        c = le(c) ? pe(c, h) : h;
      } else c = D;

      null === b.context ? b.context = c : b.pendingContext = c;
      b = q;
      b = void 0 === b ? null : b;
      q = null != a && null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent ? d() : e(g);
      He(g, {
        expirationTime: q,
        partialState: {
          element: a
        },
        callback: b,
        isReplace: !1,
        isForced: !1,
        nextCallback: null,
        next: null
      });
      f(g, q);
    },
    batchedUpdates: a.batchedUpdates,
    unbatchedUpdates: a.unbatchedUpdates,
    deferredUpdates: a.deferredUpdates,
    flushSync: a.flushSync,
    getPublicRootInstance: function (a) {
      a = a.current;
      if (!a.child) return null;

      switch (a.child.tag) {
        case 5:
          return c(a.child.stateNode);

        default:
          return a.child.stateNode;
      }
    },
    findHostInstance: b,
    findHostInstanceWithNoPortals: function (a) {
      a = pd(a);
      return null === a ? null : a.stateNode;
    },
    injectIntoDevTools: function (a) {
      var c = a.findFiberByHostInstance;
      return Ce(B({}, a, {
        findHostInstanceByFiber: function (a) {
          return b(a);
        },
        findFiberByHostInstance: function (a) {
          return c ? c(a) : null;
        }
      }));
    }
  };
}

var mf = Object.freeze({
  default: lf
}),
    nf = mf && lf || mf,
    of = nf["default"] ? nf["default"] : nf;

function pf(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return {
    $$typeof: Ue,
    key: null == d ? null : "" + d,
    children: a,
    containerInfo: b,
    implementation: c
  };
}

var qf = "object" === typeof performance && "function" === typeof performance.now,
    rf = void 0;
rf = qf ? function () {
  return performance.now();
} : function () {
  return Date.now();
};
var sf = void 0,
    tf = void 0;
if (l.canUseDOM) {
  if ("function" !== typeof requestIdleCallback || "function" !== typeof cancelIdleCallback) {
    var uf = null,
        vf = !1,
        wf = -1,
        xf = !1,
        yf = 0,
        zf = 33,
        Af = 33,
        Bf;
    Bf = qf ? {
      didTimeout: !1,
      timeRemaining: function () {
        var a = yf - performance.now();
        return 0 < a ? a : 0;
      }
    } : {
      didTimeout: !1,
      timeRemaining: function () {
        var a = yf - Date.now();
        return 0 < a ? a : 0;
      }
    };
    var Cf = "__reactIdleCallback$" + Math.random().toString(36).slice(2);
    window.addEventListener("message", function (a) {
      if (a.source === window && a.data === Cf) {
        vf = !1;
        a = rf();
        if (0 >= yf - a) {
          if (-1 !== wf && wf <= a) Bf.didTimeout = !0;else {
            xf || (xf = !0, requestAnimationFrame(Df));
            return;
          }
        } else Bf.didTimeout = !1;
        wf = -1;
        a = uf;
        uf = null;
        null !== a && a(Bf);
      }
    }, !1);

    var Df = function (a) {
      xf = !1;
      var b = a - yf + Af;
      b < Af && zf < Af ? (8 > b && (b = 8), Af = b < zf ? zf : b) : zf = b;
      yf = a + Af;
      vf || (vf = !0, window.postMessage(Cf, "*"));
    };

    sf = function (a, b) {
      uf = a;
      null != b && "number" === typeof b.timeout && (wf = rf() + b.timeout);
      xf || (xf = !0, requestAnimationFrame(Df));
      return 0;
    };

    tf = function () {
      uf = null;
      vf = !1;
      wf = -1;
    };
  } else sf = window.requestIdleCallback, tf = window.cancelIdleCallback;
} else sf = function (a) {
  return setTimeout(function () {
    a({
      timeRemaining: function () {
        return Infinity;
      }
    });
  });
}, tf = function (a) {
  clearTimeout(a);
};
var Ef = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    Ff = {},
    Gf = {};

function Hf(a) {
  if (Gf.hasOwnProperty(a)) return !0;
  if (Ff.hasOwnProperty(a)) return !1;
  if (Ef.test(a)) return Gf[a] = !0;
  Ff[a] = !0;
  return !1;
}

function If(a, b, c) {
  var d = wa(b);

  if (d && va(b, c)) {
    var e = d.mutationMethod;
    e ? e(a, c) : null == c || d.hasBooleanValue && !c || d.hasNumericValue && isNaN(c) || d.hasPositiveNumericValue && 1 > c || d.hasOverloadedBooleanValue && !1 === c ? Jf(a, b) : d.mustUseProperty ? a[d.propertyName] = c : (b = d.attributeName, (e = d.attributeNamespace) ? a.setAttributeNS(e, b, "" + c) : d.hasBooleanValue || d.hasOverloadedBooleanValue && !0 === c ? a.setAttribute(b, "") : a.setAttribute(b, "" + c));
  } else Kf(a, b, va(b, c) ? c : null);
}

function Kf(a, b, c) {
  Hf(b) && (null == c ? a.removeAttribute(b) : a.setAttribute(b, "" + c));
}

function Jf(a, b) {
  var c = wa(b);
  c ? (b = c.mutationMethod) ? b(a, void 0) : c.mustUseProperty ? a[c.propertyName] = c.hasBooleanValue ? !1 : "" : a.removeAttribute(c.attributeName) : a.removeAttribute(b);
}

function Lf(a, b) {
  var c = b.value,
      d = b.checked;
  return B({
    type: void 0,
    step: void 0,
    min: void 0,
    max: void 0
  }, b, {
    defaultChecked: void 0,
    defaultValue: void 0,
    value: null != c ? c : a._wrapperState.initialValue,
    checked: null != d ? d : a._wrapperState.initialChecked
  });
}

function Mf(a, b) {
  var c = b.defaultValue;
  a._wrapperState = {
    initialChecked: null != b.checked ? b.checked : b.defaultChecked,
    initialValue: null != b.value ? b.value : c,
    controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value
  };
}

function Nf(a, b) {
  b = b.checked;
  null != b && If(a, "checked", b);
}

function Of(a, b) {
  Nf(a, b);
  var c = b.value;
  if (null != c) {
    if (0 === c && "" === a.value) a.value = "0";else if ("number" === b.type) {
      if (b = parseFloat(a.value) || 0, c != b || c == b && a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else null == b.value && null != b.defaultValue && a.defaultValue !== "" + b.defaultValue && (a.defaultValue = "" + b.defaultValue), null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}

function Pf(a, b) {
  switch (b.type) {
    case "submit":
    case "reset":
      break;

    case "color":
    case "date":
    case "datetime":
    case "datetime-local":
    case "month":
    case "time":
    case "week":
      a.value = "";
      a.value = a.defaultValue;
      break;

    default:
      a.value = a.value;
  }

  b = a.name;
  "" !== b && (a.name = "");
  a.defaultChecked = !a.defaultChecked;
  a.defaultChecked = !a.defaultChecked;
  "" !== b && (a.name = b);
}

function Qf(a) {
  var b = "";
  aa.Children.forEach(a, function (a) {
    null == a || "string" !== typeof a && "number" !== typeof a || (b += a);
  });
  return b;
}

function Rf(a, b) {
  a = B({
    children: void 0
  }, b);
  if (b = Qf(b.children)) a.children = b;
  return a;
}

function Sf(a, b, c, d) {
  a = a.options;

  if (b) {
    b = {};

    for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;

    for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
  } else {
    c = "" + c;
    b = null;

    for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;
        d && (a[e].defaultSelected = !0);
        return;
      }

      null !== b || a[e].disabled || (b = a[e]);
    }

    null !== b && (b.selected = !0);
  }
}

function Tf(a, b) {
  var c = b.value;
  a._wrapperState = {
    initialValue: null != c ? c : b.defaultValue,
    wasMultiple: !!b.multiple
  };
}

function Uf(a, b) {
  null != b.dangerouslySetInnerHTML ? E("91") : void 0;
  return B({}, b, {
    value: void 0,
    defaultValue: void 0,
    children: "" + a._wrapperState.initialValue
  });
}

function Vf(a, b) {
  var c = b.value;
  null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? E("92") : void 0, Array.isArray(b) && (1 >= b.length ? void 0 : E("93"), b = b[0]), c = "" + b), null == c && (c = ""));
  a._wrapperState = {
    initialValue: "" + c
  };
}

function Wf(a, b) {
  var c = b.value;
  null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && (a.defaultValue = c));
  null != b.defaultValue && (a.defaultValue = b.defaultValue);
}

function Xf(a) {
  var b = a.textContent;
  b === a._wrapperState.initialValue && (a.value = b);
}

var Yf = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg"
};

function Zf(a) {
  switch (a) {
    case "svg":
      return "http://www.w3.org/2000/svg";

    case "math":
      return "http://www.w3.org/1998/Math/MathML";

    default:
      return "http://www.w3.org/1999/xhtml";
  }
}

function $f(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? Zf(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}

var ag = void 0,
    bg = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if (a.namespaceURI !== Yf.svg || "innerHTML" in a) a.innerHTML = b;else {
    ag = ag || document.createElement("div");
    ag.innerHTML = "\x3csvg\x3e" + b + "\x3c/svg\x3e";

    for (b = ag.firstChild; a.firstChild;) a.removeChild(a.firstChild);

    for (; b.firstChild;) a.appendChild(b.firstChild);
  }
});

function cg(a, b) {
  if (b) {
    var c = a.firstChild;

    if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;
      return;
    }
  }

  a.textContent = b;
}

var dg = {
  animationIterationCount: !0,
  borderImageOutset: !0,
  borderImageSlice: !0,
  borderImageWidth: !0,
  boxFlex: !0,
  boxFlexGroup: !0,
  boxOrdinalGroup: !0,
  columnCount: !0,
  columns: !0,
  flex: !0,
  flexGrow: !0,
  flexPositive: !0,
  flexShrink: !0,
  flexNegative: !0,
  flexOrder: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowSpan: !0,
  gridRowStart: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnSpan: !0,
  gridColumnStart: !0,
  fontWeight: !0,
  lineClamp: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  tabSize: !0,
  widows: !0,
  zIndex: !0,
  zoom: !0,
  fillOpacity: !0,
  floodOpacity: !0,
  stopOpacity: !0,
  strokeDasharray: !0,
  strokeDashoffset: !0,
  strokeMiterlimit: !0,
  strokeOpacity: !0,
  strokeWidth: !0
},
    eg = ["Webkit", "ms", "Moz", "O"];
Object.keys(dg).forEach(function (a) {
  eg.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);
    dg[b] = dg[a];
  });
});

function fg(a, b) {
  a = a.style;

  for (var c in b) if (b.hasOwnProperty(c)) {
    var d = 0 === c.indexOf("--");
    var e = c;
    var f = b[c];
    e = null == f || "boolean" === typeof f || "" === f ? "" : d || "number" !== typeof f || 0 === f || dg.hasOwnProperty(e) && dg[e] ? ("" + f).trim() : f + "px";
    "float" === c && (c = "cssFloat");
    d ? a.setProperty(c, e) : a[c] = e;
  }
}

var gg = B({
  menuitem: !0
}, {
  area: !0,
  base: !0,
  br: !0,
  col: !0,
  embed: !0,
  hr: !0,
  img: !0,
  input: !0,
  keygen: !0,
  link: !0,
  meta: !0,
  param: !0,
  source: !0,
  track: !0,
  wbr: !0
});

function hg(a, b, c) {
  b && (gg[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? E("137", a, c()) : void 0), null != b.dangerouslySetInnerHTML && (null != b.children ? E("60") : void 0, "object" === typeof b.dangerouslySetInnerHTML && "__html" in b.dangerouslySetInnerHTML ? void 0 : E("61")), null != b.style && "object" !== typeof b.style ? E("62", c()) : void 0);
}

function ig(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;

  switch (a) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return !1;

    default:
      return !0;
  }
}

var jg = Yf.html,
    kg = C.thatReturns("");

function lg(a, b) {
  a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;
  var c = Hd(a);
  b = Sa[b];

  for (var d = 0; d < b.length; d++) {
    var e = b[d];
    c.hasOwnProperty(e) && c[e] || ("topScroll" === e ? wd("topScroll", "scroll", a) : "topFocus" === e || "topBlur" === e ? (wd("topFocus", "focus", a), wd("topBlur", "blur", a), c.topBlur = !0, c.topFocus = !0) : "topCancel" === e ? (yc("cancel", !0) && wd("topCancel", "cancel", a), c.topCancel = !0) : "topClose" === e ? (yc("close", !0) && wd("topClose", "close", a), c.topClose = !0) : Dd.hasOwnProperty(e) && U(e, Dd[e], a), c[e] = !0);
  }
}

var mg = {
  topAbort: "abort",
  topCanPlay: "canplay",
  topCanPlayThrough: "canplaythrough",
  topDurationChange: "durationchange",
  topEmptied: "emptied",
  topEncrypted: "encrypted",
  topEnded: "ended",
  topError: "error",
  topLoadedData: "loadeddata",
  topLoadedMetadata: "loadedmetadata",
  topLoadStart: "loadstart",
  topPause: "pause",
  topPlay: "play",
  topPlaying: "playing",
  topProgress: "progress",
  topRateChange: "ratechange",
  topSeeked: "seeked",
  topSeeking: "seeking",
  topStalled: "stalled",
  topSuspend: "suspend",
  topTimeUpdate: "timeupdate",
  topVolumeChange: "volumechange",
  topWaiting: "waiting"
};

function ng(a, b, c, d) {
  c = 9 === c.nodeType ? c : c.ownerDocument;
  d === jg && (d = Zf(a));
  d === jg ? "script" === a ? (a = c.createElement("div"), a.innerHTML = "\x3cscript\x3e\x3c/script\x3e", a = a.removeChild(a.firstChild)) : a = "string" === typeof b.is ? c.createElement(a, {
    is: b.is
  }) : c.createElement(a) : a = c.createElementNS(d, a);
  return a;
}

function og(a, b) {
  return (9 === b.nodeType ? b : b.ownerDocument).createTextNode(a);
}

function pg(a, b, c, d) {
  var e = ig(b, c);

  switch (b) {
    case "iframe":
    case "object":
      U("topLoad", "load", a);
      var f = c;
      break;

    case "video":
    case "audio":
      for (f in mg) mg.hasOwnProperty(f) && U(f, mg[f], a);

      f = c;
      break;

    case "source":
      U("topError", "error", a);
      f = c;
      break;

    case "img":
    case "image":
      U("topError", "error", a);
      U("topLoad", "load", a);
      f = c;
      break;

    case "form":
      U("topReset", "reset", a);
      U("topSubmit", "submit", a);
      f = c;
      break;

    case "details":
      U("topToggle", "toggle", a);
      f = c;
      break;

    case "input":
      Mf(a, c);
      f = Lf(a, c);
      U("topInvalid", "invalid", a);
      lg(d, "onChange");
      break;

    case "option":
      f = Rf(a, c);
      break;

    case "select":
      Tf(a, c);
      f = B({}, c, {
        value: void 0
      });
      U("topInvalid", "invalid", a);
      lg(d, "onChange");
      break;

    case "textarea":
      Vf(a, c);
      f = Uf(a, c);
      U("topInvalid", "invalid", a);
      lg(d, "onChange");
      break;

    default:
      f = c;
  }

  hg(b, f, kg);
  var g = f,
      h;

  for (h in g) if (g.hasOwnProperty(h)) {
    var k = g[h];
    "style" === h ? fg(a, k, kg) : "dangerouslySetInnerHTML" === h ? (k = k ? k.__html : void 0, null != k && bg(a, k)) : "children" === h ? "string" === typeof k ? ("textarea" !== b || "" !== k) && cg(a, k) : "number" === typeof k && cg(a, "" + k) : "suppressContentEditableWarning" !== h && "suppressHydrationWarning" !== h && "autoFocus" !== h && (Ra.hasOwnProperty(h) ? null != k && lg(d, h) : e ? Kf(a, h, k) : null != k && If(a, h, k));
  }

  switch (b) {
    case "input":
      Bc(a);
      Pf(a, c);
      break;

    case "textarea":
      Bc(a);
      Xf(a, c);
      break;

    case "option":
      null != c.value && a.setAttribute("value", c.value);
      break;

    case "select":
      a.multiple = !!c.multiple;
      b = c.value;
      null != b ? Sf(a, !!c.multiple, b, !1) : null != c.defaultValue && Sf(a, !!c.multiple, c.defaultValue, !0);
      break;

    default:
      "function" === typeof f.onClick && (a.onclick = C);
  }
}

function sg(a, b, c, d, e) {
  var f = null;

  switch (b) {
    case "input":
      c = Lf(a, c);
      d = Lf(a, d);
      f = [];
      break;

    case "option":
      c = Rf(a, c);
      d = Rf(a, d);
      f = [];
      break;

    case "select":
      c = B({}, c, {
        value: void 0
      });
      d = B({}, d, {
        value: void 0
      });
      f = [];
      break;

    case "textarea":
      c = Uf(a, c);
      d = Uf(a, d);
      f = [];
      break;

    default:
      "function" !== typeof c.onClick && "function" === typeof d.onClick && (a.onclick = C);
  }

  hg(b, d, kg);
  var g, h;
  a = null;

  for (g in c) if (!d.hasOwnProperty(g) && c.hasOwnProperty(g) && null != c[g]) if ("style" === g) for (h in b = c[g], b) b.hasOwnProperty(h) && (a || (a = {}), a[h] = "");else "dangerouslySetInnerHTML" !== g && "children" !== g && "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && "autoFocus" !== g && (Ra.hasOwnProperty(g) ? f || (f = []) : (f = f || []).push(g, null));

  for (g in d) {
    var k = d[g];
    b = null != c ? c[g] : void 0;
    if (d.hasOwnProperty(g) && k !== b && (null != k || null != b)) if ("style" === g) {
      if (b) {
        for (h in b) !b.hasOwnProperty(h) || k && k.hasOwnProperty(h) || (a || (a = {}), a[h] = "");

        for (h in k) k.hasOwnProperty(h) && b[h] !== k[h] && (a || (a = {}), a[h] = k[h]);
      } else a || (f || (f = []), f.push(g, a)), a = k;
    } else "dangerouslySetInnerHTML" === g ? (k = k ? k.__html : void 0, b = b ? b.__html : void 0, null != k && b !== k && (f = f || []).push(g, "" + k)) : "children" === g ? b === k || "string" !== typeof k && "number" !== typeof k || (f = f || []).push(g, "" + k) : "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && (Ra.hasOwnProperty(g) ? (null != k && lg(e, g), f || b === k || (f = [])) : (f = f || []).push(g, k));
  }

  a && (f = f || []).push("style", a);
  return f;
}

function tg(a, b, c, d, e) {
  "input" === c && "radio" === e.type && null != e.name && Nf(a, e);
  ig(c, d);
  d = ig(c, e);

  for (var f = 0; f < b.length; f += 2) {
    var g = b[f],
        h = b[f + 1];
    "style" === g ? fg(a, h, kg) : "dangerouslySetInnerHTML" === g ? bg(a, h) : "children" === g ? cg(a, h) : d ? null != h ? Kf(a, g, h) : a.removeAttribute(g) : null != h ? If(a, g, h) : Jf(a, g);
  }

  switch (c) {
    case "input":
      Of(a, e);
      break;

    case "textarea":
      Wf(a, e);
      break;

    case "select":
      a._wrapperState.initialValue = void 0, b = a._wrapperState.wasMultiple, a._wrapperState.wasMultiple = !!e.multiple, c = e.value, null != c ? Sf(a, !!e.multiple, c, !1) : b !== !!e.multiple && (null != e.defaultValue ? Sf(a, !!e.multiple, e.defaultValue, !0) : Sf(a, !!e.multiple, e.multiple ? [] : "", !1));
  }
}

function ug(a, b, c, d, e) {
  switch (b) {
    case "iframe":
    case "object":
      U("topLoad", "load", a);
      break;

    case "video":
    case "audio":
      for (var f in mg) mg.hasOwnProperty(f) && U(f, mg[f], a);

      break;

    case "source":
      U("topError", "error", a);
      break;

    case "img":
    case "image":
      U("topError", "error", a);
      U("topLoad", "load", a);
      break;

    case "form":
      U("topReset", "reset", a);
      U("topSubmit", "submit", a);
      break;

    case "details":
      U("topToggle", "toggle", a);
      break;

    case "input":
      Mf(a, c);
      U("topInvalid", "invalid", a);
      lg(e, "onChange");
      break;

    case "select":
      Tf(a, c);
      U("topInvalid", "invalid", a);
      lg(e, "onChange");
      break;

    case "textarea":
      Vf(a, c), U("topInvalid", "invalid", a), lg(e, "onChange");
  }

  hg(b, c, kg);
  d = null;

  for (var g in c) c.hasOwnProperty(g) && (f = c[g], "children" === g ? "string" === typeof f ? a.textContent !== f && (d = ["children", f]) : "number" === typeof f && a.textContent !== "" + f && (d = ["children", "" + f]) : Ra.hasOwnProperty(g) && null != f && lg(e, g));

  switch (b) {
    case "input":
      Bc(a);
      Pf(a, c);
      break;

    case "textarea":
      Bc(a);
      Xf(a, c);
      break;

    case "select":
    case "option":
      break;

    default:
      "function" === typeof c.onClick && (a.onclick = C);
  }

  return d;
}

function vg(a, b) {
  return a.nodeValue !== b;
}

var wg = Object.freeze({
  createElement: ng,
  createTextNode: og,
  setInitialProperties: pg,
  diffProperties: sg,
  updateProperties: tg,
  diffHydratedProperties: ug,
  diffHydratedText: vg,
  warnForUnmatchedText: function () {},
  warnForDeletedHydratableElement: function () {},
  warnForDeletedHydratableText: function () {},
  warnForInsertedHydratedElement: function () {},
  warnForInsertedHydratedText: function () {},
  restoreControlledState: function (a, b, c) {
    switch (b) {
      case "input":
        Of(a, c);
        b = c.name;

        if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode;) c = c.parentNode;

          c = c.querySelectorAll("input[name\x3d" + JSON.stringify("" + b) + '][type\x3d"radio"]');

          for (b = 0; b < c.length; b++) {
            var d = c[b];

            if (d !== a && d.form === a.form) {
              var e = rb(d);
              e ? void 0 : E("90");
              Cc(d);
              Of(d, e);
            }
          }
        }

        break;

      case "textarea":
        Wf(a, c);
        break;

      case "select":
        b = c.value, null != b && Sf(a, !!c.multiple, b, !1);
    }
  }
});
nc.injectFiberControlledHostComponent(wg);
var xg = null,
    Mg = null;

function Ng(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}

function Og(a) {
  a = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null;
  return !(!a || 1 !== a.nodeType || !a.hasAttribute("data-reactroot"));
}

var Z = of({
  getRootHostContext: function (a) {
    var b = a.nodeType;

    switch (b) {
      case 9:
      case 11:
        a = (a = a.documentElement) ? a.namespaceURI : $f(null, "");
        break;

      default:
        b = 8 === b ? a.parentNode : a, a = b.namespaceURI || null, b = b.tagName, a = $f(a, b);
    }

    return a;
  },
  getChildHostContext: function (a, b) {
    return $f(a, b);
  },
  getPublicInstance: function (a) {
    return a;
  },
  prepareForCommit: function () {
    xg = td;
    var a = da();

    if (Kd(a)) {
      if ("selectionStart" in a) var b = {
        start: a.selectionStart,
        end: a.selectionEnd
      };else a: {
        var c = window.getSelection && window.getSelection();

        if (c && 0 !== c.rangeCount) {
          b = c.anchorNode;
          var d = c.anchorOffset,
              e = c.focusNode;
          c = c.focusOffset;

          try {
            b.nodeType, e.nodeType;
          } catch (z) {
            b = null;
            break a;
          }

          var f = 0,
              g = -1,
              h = -1,
              k = 0,
              q = 0,
              v = a,
              y = null;

          b: for (;;) {
            for (var u;;) {
              v !== b || 0 !== d && 3 !== v.nodeType || (g = f + d);
              v !== e || 0 !== c && 3 !== v.nodeType || (h = f + c);
              3 === v.nodeType && (f += v.nodeValue.length);
              if (null === (u = v.firstChild)) break;
              y = v;
              v = u;
            }

            for (;;) {
              if (v === a) break b;
              y === b && ++k === d && (g = f);
              y === e && ++q === c && (h = f);
              if (null !== (u = v.nextSibling)) break;
              v = y;
              y = v.parentNode;
            }

            v = u;
          }

          b = -1 === g || -1 === h ? null : {
            start: g,
            end: h
          };
        } else b = null;
      }
      b = b || {
        start: 0,
        end: 0
      };
    } else b = null;

    Mg = {
      focusedElem: a,
      selectionRange: b
    };
    ud(!1);
  },
  resetAfterCommit: function () {
    var a = Mg,
        b = da(),
        c = a.focusedElem,
        d = a.selectionRange;

    if (b !== c && fa(document.documentElement, c)) {
      if (Kd(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (window.getSelection) {
        b = window.getSelection();
        var e = c[Eb()].length;
        a = Math.min(d.start, e);
        d = void 0 === d.end ? a : Math.min(d.end, e);
        !b.extend && a > d && (e = d, d = a, a = e);
        e = Jd(c, a);
        var f = Jd(c, d);

        if (e && f && (1 !== b.rangeCount || b.anchorNode !== e.node || b.anchorOffset !== e.offset || b.focusNode !== f.node || b.focusOffset !== f.offset)) {
          var g = document.createRange();
          g.setStart(e.node, e.offset);
          b.removeAllRanges();
          a > d ? (b.addRange(g), b.extend(f.node, f.offset)) : (g.setEnd(f.node, f.offset), b.addRange(g));
        }
      }
      b = [];

      for (a = c; a = a.parentNode;) 1 === a.nodeType && b.push({
        element: a,
        left: a.scrollLeft,
        top: a.scrollTop
      });

      ia(c);

      for (c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }

    Mg = null;
    ud(xg);
    xg = null;
  },
  createInstance: function (a, b, c, d, e) {
    a = ng(a, b, c, d);
    a[Q] = e;
    a[ob] = b;
    return a;
  },
  appendInitialChild: function (a, b) {
    a.appendChild(b);
  },
  finalizeInitialChildren: function (a, b, c, d) {
    pg(a, b, c, d);

    a: {
      switch (b) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          a = !!c.autoFocus;
          break a;
      }

      a = !1;
    }

    return a;
  },
  prepareUpdate: function (a, b, c, d, e) {
    return sg(a, b, c, d, e);
  },
  shouldSetTextContent: function (a, b) {
    return "textarea" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === typeof b.dangerouslySetInnerHTML && null !== b.dangerouslySetInnerHTML && "string" === typeof b.dangerouslySetInnerHTML.__html;
  },
  shouldDeprioritizeSubtree: function (a, b) {
    return !!b.hidden;
  },
  createTextInstance: function (a, b, c, d) {
    a = og(a, b);
    a[Q] = d;
    return a;
  },
  now: rf,
  mutation: {
    commitMount: function (a) {
      a.focus();
    },
    commitUpdate: function (a, b, c, d, e) {
      a[ob] = e;
      tg(a, b, c, d, e);
    },
    resetTextContent: function (a) {
      a.textContent = "";
    },
    commitTextUpdate: function (a, b, c) {
      a.nodeValue = c;
    },
    appendChild: function (a, b) {
      a.appendChild(b);
    },
    appendChildToContainer: function (a, b) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, a) : a.appendChild(b);
    },
    insertBefore: function (a, b, c) {
      a.insertBefore(b, c);
    },
    insertInContainerBefore: function (a, b, c) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, c) : a.insertBefore(b, c);
    },
    removeChild: function (a, b) {
      a.removeChild(b);
    },
    removeChildFromContainer: function (a, b) {
      8 === a.nodeType ? a.parentNode.removeChild(b) : a.removeChild(b);
    }
  },
  hydration: {
    canHydrateInstance: function (a, b) {
      return 1 !== a.nodeType || b.toLowerCase() !== a.nodeName.toLowerCase() ? null : a;
    },
    canHydrateTextInstance: function (a, b) {
      return "" === b || 3 !== a.nodeType ? null : a;
    },
    getNextHydratableSibling: function (a) {
      for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !== a.nodeType;) a = a.nextSibling;

      return a;
    },
    getFirstHydratableChild: function (a) {
      for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType;) a = a.nextSibling;

      return a;
    },
    hydrateInstance: function (a, b, c, d, e, f) {
      a[Q] = f;
      a[ob] = c;
      return ug(a, b, c, e, d);
    },
    hydrateTextInstance: function (a, b, c) {
      a[Q] = c;
      return vg(a, b);
    },
    didNotMatchHydratedContainerTextInstance: function () {},
    didNotMatchHydratedTextInstance: function () {},
    didNotHydrateContainerInstance: function () {},
    didNotHydrateInstance: function () {},
    didNotFindHydratableContainerInstance: function () {},
    didNotFindHydratableContainerTextInstance: function () {},
    didNotFindHydratableInstance: function () {},
    didNotFindHydratableTextInstance: function () {}
  },
  scheduleDeferredCallback: sf,
  cancelDeferredCallback: tf,
  useSyncScheduling: !0
});
rc = Z.batchedUpdates;

function Pg(a, b, c, d, e) {
  Ng(c) ? void 0 : E("200");
  var f = c._reactRootContainer;
  if (f) Z.updateContainer(b, f, a, e);else {
    d = d || Og(c);
    if (!d) for (f = void 0; f = c.lastChild;) c.removeChild(f);
    var g = Z.createContainer(c, d);
    f = c._reactRootContainer = g;
    Z.unbatchedUpdates(function () {
      Z.updateContainer(b, g, a, e);
    });
  }
  return Z.getPublicRootInstance(f);
}

function Qg(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  Ng(b) ? void 0 : E("200");
  return pf(a, b, null, c);
}

function Rg(a, b) {
  this._reactRootContainer = Z.createContainer(a, b);
}

Rg.prototype.render = function (a, b) {
  Z.updateContainer(a, this._reactRootContainer, null, b);
};

Rg.prototype.unmount = function (a) {
  Z.updateContainer(null, this._reactRootContainer, null, a);
};

var Sg = {
  createPortal: Qg,
  findDOMNode: function (a) {
    if (null == a) return null;
    if (1 === a.nodeType) return a;
    var b = a._reactInternalFiber;
    if (b) return Z.findHostInstance(b);
    "function" === typeof a.render ? E("188") : E("213", Object.keys(a));
  },
  hydrate: function (a, b, c) {
    return Pg(null, a, b, !0, c);
  },
  render: function (a, b, c) {
    return Pg(null, a, b, !1, c);
  },
  unstable_renderSubtreeIntoContainer: function (a, b, c, d) {
    null == a || void 0 === a._reactInternalFiber ? E("38") : void 0;
    return Pg(a, b, c, !1, d);
  },
  unmountComponentAtNode: function (a) {
    Ng(a) ? void 0 : E("40");
    return a._reactRootContainer ? (Z.unbatchedUpdates(function () {
      Pg(null, null, a, !1, function () {
        a._reactRootContainer = null;
      });
    }), !0) : !1;
  },
  unstable_createPortal: Qg,
  unstable_batchedUpdates: tc,
  unstable_deferredUpdates: Z.deferredUpdates,
  flushSync: Z.flushSync,
  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
    EventPluginHub: mb,
    EventPluginRegistry: Va,
    EventPropagators: Cb,
    ReactControlledComponent: qc,
    ReactDOMComponentTree: sb,
    ReactDOMEventListener: xd
  }
};
Z.injectIntoDevTools({
  findFiberByHostInstance: pb,
  bundleType: 0,
  version: "16.2.0",
  rendererPackageName: "react-dom"
});
var Tg = Object.freeze({
  default: Sg
}),
    Ug = Tg && Sg || Tg;
module.exports = Ug["default"] ? Ug["default"] : Ug;

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(28);
/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */


function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */

function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.2.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */if(process.env.NODE_ENV!=="production"){(function(){'use strict';var React=__webpack_require__(4);var invariant=__webpack_require__(8);var warning=__webpack_require__(9);var ExecutionEnvironment=__webpack_require__(13);var _assign=__webpack_require__(14);var emptyFunction=__webpack_require__(2);var EventListener=__webpack_require__(15);var getActiveElement=__webpack_require__(16);var shallowEqual=__webpack_require__(17);var containsNode=__webpack_require__(18);var focusNode=__webpack_require__(19);var emptyObject=__webpack_require__(5);var checkPropTypes=__webpack_require__(12);var hyphenateStyleName=__webpack_require__(30);var camelizeStyleName=__webpack_require__(32);/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */!React?invariant(false,'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'):void 0;// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS={children:true,dangerouslySetInnerHTML:true,defaultValue:true,defaultChecked:true,innerHTML:true,suppressContentEditableWarning:true,suppressHydrationWarning:true,style:true};function checkMask(value,bitmask){return(value&bitmask)===bitmask;}var DOMPropertyInjection={/**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */MUST_USE_PROPERTY:0x1,HAS_BOOLEAN_VALUE:0x4,HAS_NUMERIC_VALUE:0x8,HAS_POSITIVE_NUMERIC_VALUE:0x10|0x8,HAS_OVERLOADED_BOOLEAN_VALUE:0x20,HAS_STRING_BOOLEAN_VALUE:0x40,/**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */injectDOMPropertyConfig:function(domPropertyConfig){var Injection=DOMPropertyInjection;var Properties=domPropertyConfig.Properties||{};var DOMAttributeNamespaces=domPropertyConfig.DOMAttributeNamespaces||{};var DOMAttributeNames=domPropertyConfig.DOMAttributeNames||{};var DOMMutationMethods=domPropertyConfig.DOMMutationMethods||{};for(var propName in Properties){!!properties.hasOwnProperty(propName)?invariant(false,"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.",propName):void 0;var lowerCased=propName.toLowerCase();var propConfig=Properties[propName];var propertyInfo={attributeName:lowerCased,attributeNamespace:null,propertyName:propName,mutationMethod:null,mustUseProperty:checkMask(propConfig,Injection.MUST_USE_PROPERTY),hasBooleanValue:checkMask(propConfig,Injection.HAS_BOOLEAN_VALUE),hasNumericValue:checkMask(propConfig,Injection.HAS_NUMERIC_VALUE),hasPositiveNumericValue:checkMask(propConfig,Injection.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:checkMask(propConfig,Injection.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:checkMask(propConfig,Injection.HAS_STRING_BOOLEAN_VALUE)};!(propertyInfo.hasBooleanValue+propertyInfo.hasNumericValue+propertyInfo.hasOverloadedBooleanValue<=1)?invariant(false,"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s",propName):void 0;if(DOMAttributeNames.hasOwnProperty(propName)){var attributeName=DOMAttributeNames[propName];propertyInfo.attributeName=attributeName;}if(DOMAttributeNamespaces.hasOwnProperty(propName)){propertyInfo.attributeNamespace=DOMAttributeNamespaces[propName];}if(DOMMutationMethods.hasOwnProperty(propName)){propertyInfo.mutationMethod=DOMMutationMethods[propName];}// Downcase references to whitelist properties to check for membership
// without case-sensitivity. This allows the whitelist to pick up
// `allowfullscreen`, which should be written using the property configuration
// for `allowFullscreen`
properties[propName]=propertyInfo;}}};/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+"\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";var ROOT_ATTRIBUTE_NAME='data-reactroot';/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */var properties={};/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */function shouldSetAttribute(name,value){if(isReservedProp(name)){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return false;}if(value===null){return true;}switch(typeof value){case'boolean':return shouldAttributeAcceptBooleanValue(name);case'undefined':case'number':case'string':case'object':return true;default:// function, symbol
return false;}}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function shouldAttributeAcceptBooleanValue(name){if(isReservedProp(name)){return true;}var propertyInfo=getPropertyInfo(name);if(propertyInfo){return propertyInfo.hasBooleanValue||propertyInfo.hasStringBooleanValue||propertyInfo.hasOverloadedBooleanValue;}var prefix=name.toLowerCase().slice(0,5);return prefix==='data-'||prefix==='aria-';}/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */function isReservedProp(name){return RESERVED_PROPS.hasOwnProperty(name);}var injection=DOMPropertyInjection;var MUST_USE_PROPERTY=injection.MUST_USE_PROPERTY;var HAS_BOOLEAN_VALUE=injection.HAS_BOOLEAN_VALUE;var HAS_NUMERIC_VALUE=injection.HAS_NUMERIC_VALUE;var HAS_POSITIVE_NUMERIC_VALUE=injection.HAS_POSITIVE_NUMERIC_VALUE;var HAS_OVERLOADED_BOOLEAN_VALUE=injection.HAS_OVERLOADED_BOOLEAN_VALUE;var HAS_STRING_BOOLEAN_VALUE=injection.HAS_STRING_BOOLEAN_VALUE;var HTMLDOMPropertyConfig={// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
Properties:{allowFullScreen:HAS_BOOLEAN_VALUE,// specifies target context for links with `preload` type
async:HAS_BOOLEAN_VALUE,// Note: there is a special case that prevents it from being written to the DOM
// on the client side because the browsers are inconsistent. Instead we call focus().
autoFocus:HAS_BOOLEAN_VALUE,autoPlay:HAS_BOOLEAN_VALUE,capture:HAS_OVERLOADED_BOOLEAN_VALUE,checked:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,cols:HAS_POSITIVE_NUMERIC_VALUE,contentEditable:HAS_STRING_BOOLEAN_VALUE,controls:HAS_BOOLEAN_VALUE,'default':HAS_BOOLEAN_VALUE,defer:HAS_BOOLEAN_VALUE,disabled:HAS_BOOLEAN_VALUE,download:HAS_OVERLOADED_BOOLEAN_VALUE,draggable:HAS_STRING_BOOLEAN_VALUE,formNoValidate:HAS_BOOLEAN_VALUE,hidden:HAS_BOOLEAN_VALUE,loop:HAS_BOOLEAN_VALUE,// Caution; `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`.
multiple:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,muted:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,noValidate:HAS_BOOLEAN_VALUE,open:HAS_BOOLEAN_VALUE,playsInline:HAS_BOOLEAN_VALUE,readOnly:HAS_BOOLEAN_VALUE,required:HAS_BOOLEAN_VALUE,reversed:HAS_BOOLEAN_VALUE,rows:HAS_POSITIVE_NUMERIC_VALUE,rowSpan:HAS_NUMERIC_VALUE,scoped:HAS_BOOLEAN_VALUE,seamless:HAS_BOOLEAN_VALUE,selected:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,size:HAS_POSITIVE_NUMERIC_VALUE,start:HAS_NUMERIC_VALUE,// support for projecting regular DOM Elements via V1 named slots ( shadow dom )
span:HAS_POSITIVE_NUMERIC_VALUE,spellCheck:HAS_STRING_BOOLEAN_VALUE,// Style must be explicitly set in the attribute list. React components
// expect a style object
style:0,// Keep it in the whitelist because it is case-sensitive for SVG.
tabIndex:0,// itemScope is for for Microdata support.
// See http://schema.org/docs/gs.html
itemScope:HAS_BOOLEAN_VALUE,// These attributes must stay in the white-list because they have
// different attribute names (see DOMAttributeNames below)
acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,// Attributes with mutation methods must be specified in the whitelist
// Set the string boolean flag to allow the behavior
value:HAS_STRING_BOOLEAN_VALUE},DOMAttributeNames:{acceptCharset:'accept-charset',className:'class',htmlFor:'for',httpEquiv:'http-equiv'},DOMMutationMethods:{value:function(node,value){if(value==null){return node.removeAttribute('value');}// Number inputs get special treatment due to some edge cases in
// Chrome. Let everything else assign the value attribute as normal.
// https://github.com/facebook/react/issues/7253#issuecomment-236074326
if(node.type!=='number'||node.hasAttribute('value')===false){node.setAttribute('value',''+value);}else if(node.validity&&!node.validity.badInput&&node.ownerDocument.activeElement!==node){// Don't assign an attribute if validation reports bad
// input. Chrome will clear the value. Additionally, don't
// operate on inputs that have focus, otherwise Chrome might
// strip off trailing decimal places and cause the user's
// cursor position to jump to the beginning of the input.
//
// In ReactDOMInput, we have an onBlur event that will trigger
// this function again when focus is lost.
node.setAttribute('value',''+value);}}}};var HAS_STRING_BOOLEAN_VALUE$1=injection.HAS_STRING_BOOLEAN_VALUE;var NS={xlink:'http://www.w3.org/1999/xlink',xml:'http://www.w3.org/XML/1998/namespace'};/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */var ATTRS=['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','x-height','xlink:actuate','xlink:arcrole','xlink:href','xlink:role','xlink:show','xlink:title','xlink:type','xml:base','xmlns:xlink','xml:lang','xml:space'];var SVGDOMPropertyConfig={Properties:{autoReverse:HAS_STRING_BOOLEAN_VALUE$1,externalResourcesRequired:HAS_STRING_BOOLEAN_VALUE$1,preserveAlpha:HAS_STRING_BOOLEAN_VALUE$1},DOMAttributeNames:{autoReverse:'autoReverse',externalResourcesRequired:'externalResourcesRequired',preserveAlpha:'preserveAlpha'},DOMAttributeNamespaces:{xlinkActuate:NS.xlink,xlinkArcrole:NS.xlink,xlinkHref:NS.xlink,xlinkRole:NS.xlink,xlinkShow:NS.xlink,xlinkTitle:NS.xlink,xlinkType:NS.xlink,xmlBase:NS.xml,xmlLang:NS.xml,xmlSpace:NS.xml}};var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function(token){return token[1].toUpperCase();};ATTRS.forEach(function(original){var reactName=original.replace(CAMELIZE,capitalize);SVGDOMPropertyConfig.Properties[reactName]=0;SVGDOMPropertyConfig.DOMAttributeNames[reactName]=original;});injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);var ReactErrorUtils={// Used by Fiber to simulate a try-catch.
_caughtError:null,_hasCaughtError:false,// Used by event system to capture/rethrow the first error.
_rethrowError:null,_hasRethrowError:false,injection:{injectErrorUtils:function(injectedErrorUtils){!(typeof injectedErrorUtils.invokeGuardedCallback==='function')?invariant(false,'Injected invokeGuardedCallback() must be a function.'):void 0;invokeGuardedCallback=injectedErrorUtils.invokeGuardedCallback;}},/**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallback:function(name,func,context,a,b,c,d,e,f){invokeGuardedCallback.apply(ReactErrorUtils,arguments);},/**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallbackAndCatchFirstError:function(name,func,context,a,b,c,d,e,f){ReactErrorUtils.invokeGuardedCallback.apply(this,arguments);if(ReactErrorUtils.hasCaughtError()){var error=ReactErrorUtils.clearCaughtError();if(!ReactErrorUtils._hasRethrowError){ReactErrorUtils._hasRethrowError=true;ReactErrorUtils._rethrowError=error;}}},/**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */rethrowCaughtError:function(){return rethrowCaughtError.apply(ReactErrorUtils,arguments);},hasCaughtError:function(){return ReactErrorUtils._hasCaughtError;},clearCaughtError:function(){if(ReactErrorUtils._hasCaughtError){var error=ReactErrorUtils._caughtError;ReactErrorUtils._caughtError=null;ReactErrorUtils._hasCaughtError=false;return error;}else{invariant(false,'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');}}};var invokeGuardedCallback=function(name,func,context,a,b,c,d,e,f){ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){ReactErrorUtils._caughtError=error;ReactErrorUtils._hasCaughtError=true;}};{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// untintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function(name,func,context,a,b,c,d,e,f){// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error=void 0;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function onError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}}// Create a fake event type.
var evtType='react-'+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',onError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
var evt=document.createEvent('Event');evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(didError){if(!didSetError){// The callback errored, but the error event never fired.
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}ReactErrorUtils._hasCaughtError=true;ReactErrorUtils._caughtError=error;}else{ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;}// Remove our event listeners
window.removeEventListener('error',onError);};invokeGuardedCallback=invokeGuardedCallbackDev;}}var rethrowCaughtError=function(){if(ReactErrorUtils._hasRethrowError){var error=ReactErrorUtils._rethrowError;ReactErrorUtils._rethrowError=null;ReactErrorUtils._hasRethrowError=false;throw error;}};/**
 * Injectable ordering of event plugins.
 */var eventPluginOrder=null;/**
 * Injectable mapping from names to event plugin modules.
 */var namesToPlugins={};/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.
return;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);!(pluginIndex>-1)?invariant(false,'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',pluginName):void 0;if(plugins[pluginIndex]){continue;}!pluginModule.extractEvents?invariant(false,'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',pluginName):void 0;plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)?invariant(false,'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',eventName,pluginName):void 0;}}}/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){!!eventNameDispatchConfigs.hasOwnProperty(eventName)?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',eventName):void 0;eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */function publishRegistrationName(registrationName,pluginModule,eventName){!!registrationNameModules[registrationName]?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',registrationName):void 0;registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */ /**
 * Ordered list of injected plugins.
 */var plugins=[];/**
 * Mapping from event name to dispatch config
 */var eventNameDispatchConfigs={};/**
 * Mapping from registration name to plugin module
 */var registrationNameModules={};/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */function injectEventPluginOrder(injectedEventPluginOrder){!!eventPluginOrder?invariant(false,'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'):void 0;// Clone the ordering so it cannot be dynamically mutated.
eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){!!namesToPlugins[pluginName]?invariant(false,'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',pluginName):void 0;namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}var EventPluginRegistry=Object.freeze({plugins:plugins,eventNameDispatchConfigs:eventNameDispatchConfigs,registrationNameModules:registrationNameModules,registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames,injectEventPluginOrder:injectEventPluginOrder,injectEventPluginsByName:injectEventPluginsByName});var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;var injection$2={injectComponentTree:function(Injected){getFiberCurrentPropsFromNode=Injected.getFiberCurrentPropsFromNode;getInstanceFromNode=Injected.getInstanceFromNode;getNodeFromInstance=Injected.getNodeFromInstance;{warning(getNodeFromInstance&&getInstanceFromNode,'EventPluginUtils.injection.injectComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.');}}};var validateEventDispatches;{validateEventDispatches=function(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;warning(instancesIsArr===listenersIsArr&&instancesLen===listenersLen,'EventPluginUtils: Invalid `event`.');};}/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */function executeDispatch(event,simulated,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**
 * Standard/simple iteration through an event's collected dispatches.
 */function executeDispatchesInOrder(event,simulated){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.
executeDispatch(event,simulated,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,simulated,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */ /**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */ /**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */ /**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */function accumulateInto(current,next){!(next!=null)?invariant(false,'accumulateInto(...): Accumulated items must not be null or undefined.'):void 0;if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not
// certain that x is an Array (x could be a string with concat method).
if(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.
return[current].concat(next);}return[current,next];}/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */var eventQueue=null;/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */var executeDispatchesAndRelease=function(event,simulated){if(event){executeDispatchesInOrder(event,simulated);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseSimulated=function(e){return executeDispatchesAndRelease(e,true);};var executeDispatchesAndReleaseTopLevel=function(e){return executeDispatchesAndRelease(e,false);};function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */ /**
 * Methods for injecting dependencies.
 */var injection$1={/**
   * @param {array} InjectedEventPluginOrder
   * @public
   */injectEventPluginOrder:injectEventPluginOrder,/**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */injectEventPluginsByName:injectEventPluginsByName};/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var listener;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
// live here; needs to be moved to a better place soon
var stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.
return null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}!(!listener||typeof listener==='function')?invariant(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener):void 0;return listener;}/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.
var possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */function enqueueEvents(events){if(events){eventQueue=accumulateInto(eventQueue,events);}}/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */function processEventQueue(simulated){// Set `eventQueue` to null before processing it so that we can tell if more
// events get enqueued while processing.
var processingEventQueue=eventQueue;eventQueue=null;if(!processingEventQueue){return;}if(simulated){forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseSimulated);}else{forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);}!!eventQueue?invariant(false,'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'):void 0;// This would be a good time to rethrow if any of the event handlers threw.
ReactErrorUtils.rethrowCaughtError();}var EventPluginHub=Object.freeze({injection:injection$1,getListener:getListener,extractEvents:extractEvents,enqueueEvents:enqueueEvents,processEventQueue:processEventQueue});var IndeterminateComponent=0;// Before we know whether it is functional or class
var FunctionalComponent=1;var ClassComponent=2;var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var CallComponent=7;var CallHandlerPhase=8;var ReturnComponent=9;var Fragment=10;var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;function precacheFiberNode$1(hostInst,node){node[internalInstanceKey]=hostInst;}/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */function getClosestInstanceFromNode(node){if(node[internalInstanceKey]){return node[internalInstanceKey];}// Walk up the tree until we find an ancestor whose instance we have cached.
var parents=[];while(!node[internalInstanceKey]){parents.push(node);if(node.parentNode){node=node.parentNode;}else{// Top of the tree. This node must not be part of a React tree (or is
// unmounted, potentially).
return null;}}var closest=void 0;var inst=node[internalInstanceKey];if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber, this will always be the deepest root.
return inst;}for(;node&&(inst=node[internalInstanceKey]);node=parents.pop()){closest=inst;}return closest;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
invariant(false,'getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps$1(node,props){node[internalEventHandlersKey]=props;}var ReactDOMComponentTree=Object.freeze({precacheFiberNode:precacheFiberNode$1,getClosestInstanceFromNode:getClosestInstanceFromNode,getInstanceFromNode:getInstanceFromNode$1,getNodeFromInstance:getNodeFromInstance$1,getFiberCurrentPropsFromNode:getFiberCurrentPropsFromNode$1,updateFiberProps:updateFiberProps$1});function getParent(inst){do{inst=inst['return'];// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**
 * Return if A is an ancestor of B.
 */ /**
 * Return the parent instance of the passed-in instance.
 */function getParentInstance(inst){return getParent(inst);}/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 */ /**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */function accumulateDirectionalDispatches(inst,phase,event){{warning(inst,'Dispatching inst must not be null');}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */function accumulateTwoPhaseDispatchesSingleSkipTarget(event){if(event&&event.dispatchConfig.phasedRegistrationNames){var targetInst=event._targetInst;var parentInst=targetInst?getParentInstance(targetInst):null;traverseTwoPhase(parentInst,accumulateDirectionalDispatches,event);}}/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateTwoPhaseDispatchesSkipTarget(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingleSkipTarget);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}var EventPropagators=Object.freeze({accumulateTwoPhaseDispatches:accumulateTwoPhaseDispatches,accumulateTwoPhaseDispatchesSkipTarget:accumulateTwoPhaseDispatchesSkipTarget,accumulateEnterLeaveDispatches:accumulateEnterLeaveDispatches,accumulateDirectDispatches:accumulateDirectDispatches});var contentKey=null;/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */function getTextContentAccessor(){if(!contentKey&&ExecutionEnvironment.canUseDOM){// Prefer textContent to innerText because many browsers support both but
// SVG <text> elements don't support innerText even when <div> does.
contentKey='textContent'in document.documentElement?'textContent':'innerText';}return contentKey;}/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var compositionState={_root:null,_startText:null,_fallbackText:null};function initialize(nativeEventTarget){compositionState._root=nativeEventTarget;compositionState._startText=getText();return true;}function reset(){compositionState._root=null;compositionState._startText=null;compositionState._fallbackText=null;}function getData(){if(compositionState._fallbackText){return compositionState._fallbackText;}var start;var startValue=compositionState._startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;compositionState._fallbackText=endValue.slice(start,sliceTail);return compositionState._fallbackText;}function getText(){if('value'in compositionState._root){return compositionState._root.value;}return compositionState._root[getTextContentAccessor()];}/* eslint valid-typeof: 0 */var didWarnForAddedNewProperty=false;var isProxySupported=typeof Proxy==='function';var EVENT_POOL_SIZE=10;var shouldBeReleasedProperties=['dispatchConfig','_targetInst','nativeEvent','isDefaultPrevented','isPropagationStopped','_dispatchListeners','_dispatchInstances'];/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here
currentTarget:emptyFunction.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings
delete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings
}var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else{if(propName==='target'){this.target=nativeEventTarget;}else{this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=emptyFunction.thatReturnsTrue;}else{this.isDefaultPrevented=emptyFunction.thatReturnsFalse;}this.isPropagationStopped=emptyFunction.thatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=emptyFunction.thatReturnsTrue;},stopPropagation:function(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=emptyFunction.thatReturnsTrue;},/**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */persist:function(){this.isPersistent=emptyFunction.thatReturnsTrue;},/**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */isPersistent:emptyFunction.thatReturnsFalse,/**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */destructor:function(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}for(var i=0;i<shouldBeReleasedProperties.length;i++){this[shouldBeReleasedProperties[i]]=null;}{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',emptyFunction));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',emptyFunction));}}});SyntheticEvent.Interface=EventInterface;/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */SyntheticEvent.augmentClass=function(Class,Interface){var Super=this;var E=function(){};E.prototype=Super.prototype;var prototype=new E();_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.augmentClass=Super.augmentClass;addEventPoolingTo(Class);};/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */{if(isProxySupported){/*eslint-disable no-func-assign */SyntheticEvent=new Proxy(SyntheticEvent,{construct:function(target,args){return this.apply(target,Object.create(target.prototype),args);},apply:function(constructor,that,args){return new Proxy(constructor.apply(that,args),{set:function(target,prop,value){if(prop!=='isPersistent'&&!target.constructor.Interface.hasOwnProperty(prop)&&shouldBeReleasedProperties.indexOf(prop)===-1){warning(didWarnForAddedNewProperty||target.isPersistent(),"This synthetic event is reused for performance reasons. If you're "+"seeing this, you're adding a new property in the synthetic event object. "+'The property is never released. See '+'https://fb.me/react-event-pooling for more information.');didWarnForAddedNewProperty=true;}target[prop]=value;return true;}});}});/*eslint-enable no-func-assign */}}addEventPoolingTo(SyntheticEvent);/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return{configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){var warningCondition=false;warning(warningCondition,"This synthetic event is reused for performance reasons. If you're seeing this, "+"you're %s `%s` on a released/nullified synthetic event. %s. "+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result);}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;!(event instanceof EventConstructor)?invariant(false,'Trying to release an event instance  into a pool of a different type.'):void 0;event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}var SyntheticEvent$1=SyntheticEvent;/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var CompositionEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticCompositionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticCompositionEvent,CompositionEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */var InputEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticInputEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticInputEvent,InputEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=ExecutionEnvironment.canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(ExecutionEnvironment.canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=ExecutionEnvironment.canUseDOM&&'TextEvent'in window&&!documentMode&&!isPresto();// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=ExecutionEnvironment.canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */function isPresto(){var opera=window.opera;return typeof opera==='object'&&typeof opera.version==='function'&&parseInt(opera.version(),10)<=12;}var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.
var eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:['topCompositionEnd','topKeyPress','topTextInput','topPaste']},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:['topBlur','topCompositionEnd','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:['topBlur','topCompositionStart','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:['topBlur','topCompositionUpdate','topKeyDown','topKeyPress','topKeyUp','topMouseDown']}};// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */function getCompositionEventType(topLevelType){switch(topLevelType){case'topCompositionStart':return eventTypes.compositionStart;case'topCompositionEnd':return eventTypes.compositionEnd;case'topCompositionUpdate':return eventTypes.compositionUpdate;}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType==='topKeyDown'&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case'topKeyUp':// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'topKeyDown':// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case'topKeyPress':case'topMouseDown':case'topBlur':// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if(typeof detail==='object'&&'data'in detail){return detail.data;}return null;}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case'topCompositionEnd':return getDataFromCustomEvent(nativeEvent);case'topKeyPress':/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'topTextInput':// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to blacklist it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(topLevelType==='topCompositionEnd'||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case'topPaste':// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case'topKeyPress':/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'topCompositionEnd':return useFallbackCompositionData?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else{chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){return[extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget),extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget)];}};// Use to restore controlled state after a change event has fired.
var fiberHostComponent=null;var ReactControlledComponentInjection={injectFiberControlledHostComponent:function(hostComponentImpl){// The fiber implementation doesn't use dynamic dispatch so we need to
// inject the implementation.
fiberHostComponent=hostComponentImpl;}};var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}!(fiberHostComponent&&typeof fiberHostComponent.restoreControlledState==='function')?invariant(false,'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=getFiberCurrentPropsFromNode(internalInstance.stateNode);fiberHostComponent.restoreControlledState(internalInstance.stateNode,internalInstance.type,props);}var injection$3=ReactControlledComponentInjection;function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}var ReactControlledComponent=Object.freeze({injection:injection$3,enqueueStateRestore:enqueueStateRestore,restoreStateIfNeeded:restoreStateIfNeeded});// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var fiberBatchedUpdates=function(fn,bookkeeping){return fn(bookkeeping);};var isNestingBatched=false;function batchedUpdates(fn,bookkeeping){if(isNestingBatched){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state. Therefore, we add the target to
// a queue of work.
return fiberBatchedUpdates(fn,bookkeeping);}isNestingBatched=true;try{return fiberBatchedUpdates(fn,bookkeeping);}finally{// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
isNestingBatched=false;restoreStateIfNeeded();}}var ReactGenericBatchingInjection={injectFiberBatchedUpdates:function(_batchedUpdates){fiberBatchedUpdates=_batchedUpdates;}};var injection$4=ReactGenericBatchingInjection;/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}var useHasFeature;if(ExecutionEnvironment.canUseDOM){useHasFeature=document.implementation&&document.implementation.hasFeature&&// always returns true in newer browsers as per the standard.
// @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
document.implementation.hasFeature('','')!==true;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix,capture){if(!ExecutionEnvironment.canUseDOM||capture&&!('addEventListener'in document)){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}if(!isSupported&&useHasFeature&&eventNameSuffix==='wheel'){// This is the only way to test support for the `wheel` event in IE9+.
isSupported=document.implementation.hasFeature('Events.wheel','3.0');}return isSupported;}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable,configurable:true,get:function(){return descriptor.get.call(this);},set:function(value){currentValue=''+value;descriptor.set.call(this,value);}});var tracker={getValue:function(){return currentValue;},setValue:function(value){currentValue=''+value;},stopTracking:function(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:['topBlur','topChange','topClick','topFocus','topInput','topKeyDown','topKeyUp','topSelectionChange']}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent$1.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.
enqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,event);}function runEventInBatch(event){enqueueEvents(event);processEventQueue(false);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType==='topChange'){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(ExecutionEnvironment.canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType==='topFocus'){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType==='topBlur'){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType==='topSelectionChange'||topLevelType==='topKeyUp'||topLevelType==='topKeyDown'){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType==='topClick'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType==='topInput'||topLevelType==='topChange'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(inst,node){// TODO: In IE, inst is occasionally null. Why?
if(inst==null){return;}// Fiber and ReactDOM keep wrapper state in separate places
var state=inst._wrapperState||node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}// If controlled, assign the value attribute to the current value on blur
var value=''+node.value;if(node.getAttribute('value')!==value){node.setAttribute('value',value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(topLevelType==='topBlur'){handleControlledInputBlur(targetInst,targetNode);}}};/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','TapEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var UIEventInterface={view:null,detail:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticUIEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticUIEvent,UIEventInterface);/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var MouseEventInterface={screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticMouseEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticMouseEvent,MouseEventInterface);var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:['topMouseOut','topMouseOver']},mouseLeave:{registrationName:'onMouseLeave',dependencies:['topMouseOut','topMouseOver']}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){if(topLevelType==='topMouseOver'&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){return null;}if(topLevelType!=='topMouseOut'&&topLevelType!=='topMouseOver'){// Must not be a mouse in or mouse out - ignoring.
return null;}var win;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(topLevelType==='topMouseOut'){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return null;}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave,from,nativeEvent,nativeEventTarget);leave.type='mouseleave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter,to,nativeEvent,nativeEventTarget);enter.type='mouseenter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);return[leave,enter];}};/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 */ /**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}var ReactInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var ReactCurrentOwner=ReactInternals.ReactCurrentOwner;var ReactDebugCurrentFrame=ReactInternals.ReactDebugCurrentFrame;function getComponentName(fiber){var type=fiber.type;if(typeof type==='string'){return type;}if(typeof type==='function'){return type.displayName||type.name;}return null;}// Don't change these two values:
var NoEffect=0;//           0b00000000
var PerformedWork=1;//      0b00000001
// You can change the rest (and add more).
var Placement=2;//          0b00000010
var Update=4;//             0b00000100
var PlacementAndUpdate=6;// 0b00000110
var Deletion=8;//           0b00001000
var ContentReset=16;//      0b00010000
var Callback=32;//          0b00100000
var Err=64;//               0b01000000
var Ref=128;//              0b10000000
var MOUNTING=1;var MOUNTED=2;var UNMOUNTED=3;function isFiberMountedImpl(fiber){var node=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}while(node['return']){node=node['return'];if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}}}else{while(node['return']){node=node['return'];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return MOUNTED;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return UNMOUNTED;}function isFiberMounted(fiber){return isFiberMountedImpl(fiber)===MOUNTED;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;warning(instance._warnedAboutRefsInRender,'%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber)||'A component');instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return isFiberMountedImpl(fiber)===MOUNTED;}function assertIsMounted(fiber){!(isFiberMountedImpl(fiber)===MOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var state=isFiberMountedImpl(fiber);!(state!==UNMOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(state===MOUNTING){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a['return'];var parentB=parentA?parentA.alternate:null;if(!parentA||!parentB){// We're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
invariant(false,'Unable to find node on an unmounted component.');}if(a['return']!==b['return']){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}!didFindChild?invariant(false,'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'):void 0;}}!(a.alternate===b)?invariant(false,'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.'):void 0;}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
!(a.tag===HostRoot)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child&&node.tag!==HostPortal){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */function findRootContainerNode(inst){// TODO: It may be a good idea to cache this to prevent unnecessary DOM
// traversal, but caching is difficult to do correctly without using a
// mutation observer to listen for all DOM changes.
while(inst['return']){inst=inst['return'];}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.
return null;}return inst.stateNode.containerInfo;}// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return{topLevelType:topLevelType,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}function handleTopLevelImpl(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.
// It's important that we build the array of ancestors before calling any
// event handlers, because event handlers can modify the DOM, leading to
// inconsistencies with ReactMount's node cache. See #1105.
var ancestor=targetInst;do{if(!ancestor){bookKeeping.ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}bookKeeping.ancestors.push(ancestor);ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];_handleTopLevel(bookKeeping.topLevelType,targetInst,bookKeeping.nativeEvent,getEventTarget(bookKeeping.nativeEvent));}}// TODO: can we stop exporting these?
var _enabled=true;var _handleTopLevel=void 0;function setHandleTopLevel(handleTopLevel){_handleTopLevel=handleTopLevel;}function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapBubbledEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.listen(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapCapturedEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.capture(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}function dispatchEvent(topLevelType,nativeEvent){if(!_enabled){return;}var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null&&typeof targetInst.tag==='number'&&!isFiberMounted(targetInst)){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst);try{// Event queue being processed in the same cycle allows
// `preventDefault`.
batchedUpdates(handleTopLevelImpl,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}var ReactDOMEventListener=Object.freeze({get _enabled(){return _enabled;},get _handleTopLevel(){return _handleTopLevel;},setHandleTopLevel:setHandleTopLevel,setEnabled:setEnabled,isEnabled:isEnabled,trapBubbledEvent:trapBubbledEvent,trapCapturedEvent:trapCapturedEvent,dispatchEvent:dispatchEvent});/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;prefixes['ms'+styleProp]='MS'+eventName;prefixes['O'+styleProp]='o'+eventName.toLowerCase();return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(ExecutionEnvironment.canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return'';}/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */var topLevelTypes$1={topAbort:'abort',topAnimationEnd:getVendorPrefixedEventName('animationend')||'animationend',topAnimationIteration:getVendorPrefixedEventName('animationiteration')||'animationiteration',topAnimationStart:getVendorPrefixedEventName('animationstart')||'animationstart',topBlur:'blur',topCancel:'cancel',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topChange:'change',topClick:'click',topClose:'close',topCompositionEnd:'compositionend',topCompositionStart:'compositionstart',topCompositionUpdate:'compositionupdate',topContextMenu:'contextmenu',topCopy:'copy',topCut:'cut',topDoubleClick:'dblclick',topDrag:'drag',topDragEnd:'dragend',topDragEnter:'dragenter',topDragExit:'dragexit',topDragLeave:'dragleave',topDragOver:'dragover',topDragStart:'dragstart',topDrop:'drop',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topFocus:'focus',topInput:'input',topKeyDown:'keydown',topKeyPress:'keypress',topKeyUp:'keyup',topLoadedData:'loadeddata',topLoad:'load',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topMouseDown:'mousedown',topMouseMove:'mousemove',topMouseOut:'mouseout',topMouseOver:'mouseover',topMouseUp:'mouseup',topPaste:'paste',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topScroll:'scroll',topSeeked:'seeked',topSeeking:'seeking',topSelectionChange:'selectionchange',topStalled:'stalled',topSuspend:'suspend',topTextInput:'textInput',topTimeUpdate:'timeupdate',topToggle:'toggle',topTouchCancel:'touchcancel',topTouchEnd:'touchend',topTouchMove:'touchmove',topTouchStart:'touchstart',topTransitionEnd:getVendorPrefixedEventName('transitionend')||'transitionend',topVolumeChange:'volumechange',topWaiting:'waiting',topWheel:'wheel'};var BrowserEventConstants={topLevelTypes:topLevelTypes$1};function runEventQueueInBatch(events){enqueueEvents(events);processEventQueue(false);}/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */function handleTopLevel(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);runEventQueueInBatch(events);}var topLevelTypes=BrowserEventConstants.topLevelTypes;/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */var alreadyListeningTo={};var reactTopListenersCounter=0;/**
 * To ensure no conflicts with other potential React instances on the page
 */var topListenersIDKey='_reactListenersID'+(''+Math.random()).slice(2);function getListeningForDocument(mountAt){// In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
// directly.
if(!Object.prototype.hasOwnProperty.call(mountAt,topListenersIDKey)){mountAt[topListenersIDKey]=reactTopListenersCounter++;alreadyListeningTo[mountAt[topListenersIDKey]]={};}return alreadyListeningTo[mountAt[topListenersIDKey]];}/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */function listenTo(registrationName,contentDocumentHandle){var mountAt=contentDocumentHandle;var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){if(dependency==='topScroll'){trapCapturedEvent('topScroll','scroll',mountAt);}else if(dependency==='topFocus'||dependency==='topBlur'){trapCapturedEvent('topFocus','focus',mountAt);trapCapturedEvent('topBlur','blur',mountAt);// to make sure blur and focus event listeners are only attached once
isListening.topBlur=true;isListening.topFocus=true;}else if(dependency==='topCancel'){if(isEventSupported('cancel',true)){trapCapturedEvent('topCancel','cancel',mountAt);}isListening.topCancel=true;}else if(dependency==='topClose'){if(isEventSupported('close',true)){trapCapturedEvent('topClose','close',mountAt);}isListening.topClose=true;}else if(topLevelTypes.hasOwnProperty(dependency)){trapBubbledEvent(dependency,topLevelTypes[dependency],mountAt);}isListening[dependency]=true;}}}function isListeningToAllDependencies(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){return false;}}return true;}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var selection=window.getSelection&&window.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode,anchorOffset=selection.anchorOffset,focusNode$$1=selection.focusNode,focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode$$1.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode$$1&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode$$1&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){if(!window.getSelection){return;}var selection=window.getSelection();var length=node[getTextContentAccessor()].length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=document.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isInDocument(node){return containsNode(document.documentElement,node);}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&elem.type==='text'||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElement();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection$1(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElement();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}focusNode(priorFocusedElem);for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection$1(input){var selection=void 0;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=ExecutionEnvironment.canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:['topBlur','topContextMenu','topFocus','topKeyDown','topKeyUp','topMouseDown','topMouseUp','topSelectionChange']}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */function getSelection(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else if(window.getSelection){var selection=window.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement()){return null;}// Only fire when selection has actually changed.
var currentSelection=getSelection(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent$1.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){var doc=nativeEventTarget.window===nativeEventTarget?nativeEventTarget.document:nativeEventTarget.nodeType===DOCUMENT_NODE?nativeEventTarget:nativeEventTarget.ownerDocument;// Track whether all listeners exists for this plugin. If none exist, we do
// not extract events. See #3639.
if(!doc||!isListeningToAllDependencies('onSelect',doc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.
case'topFocus':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'topBlur':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case'topMouseDown':mouseDown=true;break;case'topContextMenu':case'topMouseUp':mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case'topSelectionChange':if(skipSelectionChangeEvent){break;}// falls through
case'topKeyDown':case'topKeyUp':return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var AnimationEventInterface={animationName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticAnimationEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticAnimationEvent,AnimationEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var ClipboardEventInterface={clipboardData:function(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticClipboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticClipboardEvent,ClipboardEventInterface);/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var FocusEventInterface={relatedTarget:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticFocusEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticFocusEvent,FocusEventInterface);/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var KeyboardEventInterface={key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface
charCode:function(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticKeyboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent,KeyboardEventInterface);/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var DragEventInterface={dataTransfer:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticDragEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticDragEvent,DragEventInterface);/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var TouchEventInterface={touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticTouchEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticTouchEvent,TouchEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var TransitionEventInterface={propertyName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticTransitionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticTransitionEvent,TransitionEventInterface);/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var WheelEventInterface={deltaX:function(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticWheelEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticWheelEvent,WheelEventInterface);/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */var eventTypes$4={};var topLevelEventsToDispatchConfig={};['abort','animationEnd','animationIteration','animationStart','blur','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','doubleClick','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','focus','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','progress','rateChange','reset','scroll','seeked','seeking','stalled','submit','suspend','timeUpdate','toggle','touchCancel','touchEnd','touchMove','touchStart','transitionEnd','volumeChange','waiting','wheel'].forEach(function(event){var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var topEvent='top'+capitalizedEvent;var type={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent]};eventTypes$4[event]=type;topLevelEventsToDispatchConfig[topEvent]=type;});// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes=['topAbort','topCancel','topCanPlay','topCanPlayThrough','topClose','topDurationChange','topEmptied','topEncrypted','topEnded','topError','topInput','topInvalid','topLoad','topLoadedData','topLoadedMetadata','topLoadStart','topPause','topPlay','topPlaying','topProgress','topRateChange','topReset','topSeeked','topSeeking','topStalled','topSubmit','topSuspend','topTimeUpdate','topToggle','topVolumeChange','topWaiting'];var SimpleEventPlugin={eventTypes:eventTypes$4,extractEvents:function(topLevelType,targetInst,nativeEvent,nativeEventTarget){var dispatchConfig=topLevelEventsToDispatchConfig[topLevelType];if(!dispatchConfig){return null;}var EventConstructor;switch(topLevelType){case'topKeyPress':// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case'topKeyDown':case'topKeyUp':EventConstructor=SyntheticKeyboardEvent;break;case'topBlur':case'topFocus':EventConstructor=SyntheticFocusEvent;break;case'topClick':// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return null;}/* falls through */case'topDoubleClick':case'topMouseDown':case'topMouseMove':case'topMouseUp':// TODO: Disabled elements should not respond to mouse events
/* falls through */case'topMouseOut':case'topMouseOver':case'topContextMenu':EventConstructor=SyntheticMouseEvent;break;case'topDrag':case'topDragEnd':case'topDragEnter':case'topDragExit':case'topDragLeave':case'topDragOver':case'topDragStart':case'topDrop':EventConstructor=SyntheticDragEvent;break;case'topTouchCancel':case'topTouchEnd':case'topTouchMove':case'topTouchStart':EventConstructor=SyntheticTouchEvent;break;case'topAnimationEnd':case'topAnimationIteration':case'topAnimationStart':EventConstructor=SyntheticAnimationEvent;break;case'topTransitionEnd':EventConstructor=SyntheticTransitionEvent;break;case'topScroll':EventConstructor=SyntheticUIEvent;break;case'topWheel':EventConstructor=SyntheticWheelEvent;break;case'topCopy':case'topCut':case'topPaste':EventConstructor=SyntheticClipboardEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){warning(false,'SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events
// @see http://www.w3.org/TR/html5/index.html#events-0
EventConstructor=SyntheticEvent$1;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};setHandleTopLevel(handleTopLevel);/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */injection$1.injectEventPluginOrder(DOMEventPluginOrder);injection$2.injectComponentTree(ReactDOMComponentTree);/**
 * Some important event plugins included by default (without having to require
 * them).
 */injection$1.injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});var enableAsyncSubtreeAPI=true;var enableAsyncSchedulingByDefaultInReactDOM=false;// Exports ReactDOM.createRoot
var enableCreateRoot=false;var enableUserTimingAPI=true;// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler=true;// Experimental noop mode (currently unused):
var enableNoopReconciler=false;// Experimental persistent mode (CS):
var enablePersistentReconciler=false;// Helps identify side effects in begin-phase lifecycle hooks and setState reducers:
var debugRenderPhaseSideEffects=false;// Only used in www builds.
var valueStack=[];{var fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{warning(false,'Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){warning(false,'Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}function reset$1(){while(index>-1){valueStack[index]=null;{fiberStack[index]=null;}index--;}}var describeComponentFrame=function(name,source,ownerName){return'\n    in '+(name||'Unknown')+(source?' (at '+source.fileName.replace(/^.*[\\\/]/,'')+':'+source.lineNumber+')':ownerName?' (created by '+ownerName+')':'');};function describeFiber(fiber){switch(fiber.tag){case IndeterminateComponent:case FunctionalComponent:case ClassComponent:case HostComponent:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber);var ownerName=null;if(owner){ownerName=getComponentName(owner);}return describeComponentFrame(name,source,ownerName);default:return'';}}// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);// Otherwise this return pointer might point to the wrong tree:
node=node['return'];}while(node);return info;}function getCurrentFiberOwnerName(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}var owner=fiber._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner);}}return null;}function getCurrentFiberStackAddendum(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackAddendumByWorkInProgressFiber(fiber);}return null;}function resetCurrentFiber(){ReactDebugCurrentFrame.getCurrentStack=null;ReactDebugCurrentFiber.current=null;ReactDebugCurrentFiber.phase=null;}function setCurrentFiber(fiber){ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackAddendum;ReactDebugCurrentFiber.current=fiber;ReactDebugCurrentFiber.phase=null;}function setCurrentPhase(phase){ReactDebugCurrentFiber.phase=phase;}var ReactDebugCurrentFiber={current:null,phase:null,resetCurrentFiber:resetCurrentFiber,setCurrentFiber:setCurrentFiber,setCurrentPhase:setCurrentPhase,getCurrentFiberOwnerName:getCurrentFiberOwnerName,getCurrentFiberStackAddendum:getCurrentFiberStackAddendum};// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji='\u269B';var warningEmoji='\u26D4';var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber=null;// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;var isWaitingForCallback=false;// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit=new Set();var formatMarkName=function(markName){return reactEmoji+' '+markName;};var formatLabel=function(label,warning$$1){var prefix=warning$$1?warningEmoji+' ':reactEmoji+' ';var suffix=warning$$1?' Warning: '+warning$$1:'';return''+prefix+label+suffix;};var beginMark=function(markName){performance.mark(formatMarkName(markName));};var clearMark=function(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function(label,markName,warning$$1){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning$$1);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.
// This could only happen if React crashed in an unexpected place earlier.
// Don't pile on with more errors.
// Clear marks immediately to avoid growing buffer.
performance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function(label,debugID){return label+' (#'+debugID+')';};var getFiberLabel=function(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.
return componentName+' ['+(isMounted?'update':'mount')+']';}else{// Composite component methods.
return componentName+'.'+phase;}};var beginFiberMark=function(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because
// there is a fixed overhead for every measurement, and we don't
// want to stretch the commit phase beyond necessary.
return false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function(fiber,phase,warning$$1){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning$$1);};var shouldIgnoreFiber=function(fiber){// Host components should be skipped in the timeline.
// We could check typeof fiber.type, but does this work with RN?
switch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case ReturnComponent:case Fragment:return true;default:return false;}};var clearPendingPhaseMeasurement=function(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function(){// Stops all currently active measurements so that they can be resumed
// if we continue in a later deferred loop from the same unit of work.
var fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber['return'];}};var resumeTimersRecursively=function(fiber){if(fiber['return']!==null){resumeTimersRecursively(fiber['return']);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function(){// Resumes all measurements that were active during the last deferred loop.
if(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){if(enableUserTimingAPI){effectCountInCurrentCommit++;}}function recordScheduleUpdate(){if(enableUserTimingAPI){if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startRequestCallbackTimer(){if(enableUserTimingAPI){if(supportsUserTiming&&!isWaitingForCallback){isWaitingForCallback=true;beginMark('(Waiting for async callback...)');}}}function stopRequestCallbackTimer(didExpire){if(enableUserTimingAPI){if(supportsUserTiming){isWaitingForCallback=false;var warning$$1=didExpire?'React was blocked by main thread':null;endMark('(Waiting for async callback...)','(Waiting for async callback...)',warning$$1);}}}function startWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.
currentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.
// Otherwise flamechart will be deep even for small updates.
fiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning$$1='An error was thrown inside this error boundary';endFiberMark(fiber,null,warning$$1);}}function startPhaseTimer(fiber,phase){if(enableUserTimingAPI){if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning$$1=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning$$1);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){if(enableUserTimingAPI){currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.
// Any other measurements are performed within.
beginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.
resumeTimers();}}function stopWorkLoopTimer(interruptedBy){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning$$1='A top-level update interrupted the previous render';}else{var componentName=getComponentName(interruptedBy)||'Unknown';warning$$1='An update to '+componentName+' interrupted the previous render';}}else if(commitCountInCurrentWorkLoop>1){warning$$1='There were cascading updates';}commitCountInCurrentWorkLoop=0;// Pause any measurements until the next loop.
pauseTimers();endMark('(React Tree Reconciliation)','(React Tree Reconciliation)',warning$$1);}}function startCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(hasScheduledUpdateInCurrentCommit){warning$$1='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning$$1='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning$$1);}}function startCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Host Effects: '+count+' Total)','(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Calling Lifecycle Methods: '+count+' Total)','(Calling Lifecycle Methods)',null);}}{var warnedAboutMissingGetChildContext={};}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyObject;function getUnmaskedContext(workInProgress){var hasOwnContext=isContextProvider(workInProgress);if(hasOwnContext){// If the fiber is a context provider itself, when we read its context
// we have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}function cacheContext(workInProgress,unmaskedContext,maskedContext){var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}function getMaskedContext(workInProgress,unmaskedContext){var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name,ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}function hasContextChanged(){return didPerformWorkStackCursor.current;}function isContextConsumer(fiber){return fiber.tag===ClassComponent&&fiber.type.contextTypes!=null;}function isContextProvider(fiber){return fiber.tag===ClassComponent&&fiber.type.childContextTypes!=null;}function popContextProvider(fiber){if(!isContextProvider(fiber)){return;}pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function pushTopLevelContextObject(fiber,context,didChange){!(contextStackCursor.cursor==null)?invariant(false,'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'):void 0;push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}function processChildContext(fiber,parentContext){var instance=fiber.stateNode;var childContextTypes=fiber.type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;warning(false,'%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=void 0;{ReactDebugCurrentFiber.setCurrentPhase('getChildContext');}startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();{ReactDebugCurrentFiber.setCurrentPhase(null);}for(var contextKey in childContext){!(contextKey in childContextTypes)?invariant(false,'%s.getChildContext(): key "%s" is not defined in childContextTypes.',getComponentName(fiber)||'Unknown',contextKey):void 0;}{var name=getComponentName(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when
// somebody calls unstable_renderSubtreeIntoContainer() and we process
// context from the parent component instance. The stack will be missing
// because it's outside of the reconciliation, and so the pointer has not
// been set. This is rare and doesn't matter. We'll also remove that API.
ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}return _assign({},parentContext,childContext);}function pushContextProvider(workInProgress){if(!isContextProvider(workInProgress)){return false;}var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}function invalidateContextProvider(workInProgress,didChange){var instance=workInProgress.stateNode;!instance?invariant(false,'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}function resetContext(){previousContext=emptyObject;contextStackCursor.current=emptyObject;didPerformWorkStackCursor.current=false;}function findCurrentUnmaskedContext(fiber){// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)?invariant(false,'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'):void 0;var node=fiber;while(node.tag!==HostRoot){if(isContextProvider(node)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}var parent=node['return'];!parent?invariant(false,'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;node=parent;}return node.stateNode.context;}var NoWork=0;// TODO: Use an opaque type once ESLint et al support the syntax
var Sync=1;var Never=2147483647;// Max int32: Math.pow(2, 31) - 1
var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=2;// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms){// Always add an offset so that we don't clash with the magic number for NoWork.
return(ms/UNIT_SIZE|0)+MAGIC_NUMBER_OFFSET;}function expirationTimeToMs(expirationTime){return(expirationTime-MAGIC_NUMBER_OFFSET)*UNIT_SIZE;}function ceiling(num,precision){return((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return ceiling(currentTime+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}var NoContext=0;var AsyncUpdates=1;{var hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */ /* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
{var debugCounter=1;}function FiberNode(tag,key,internalContextTag){// Instance
this.tag=tag;this.key=key;this.type=null;this.stateNode=null;// Fiber
this['return']=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=null;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.internalContextTag=internalContextTag;// Effects
this.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.alternate=null;{this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugIsCurrentlyTiming=false;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function(tag,key,internalContextTag){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,key,internalContextTag);};function shouldConstruct(Component){return!!(Component.prototype&&Component.prototype.isReactComponent);}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps,expirationTime){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,current.key,current.internalContextTag);workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;}workInProgress.alternate=current;current.alternate=workInProgress;}else{// We already have an alternate.
// Reset the effect tag.
workInProgress.effectTag=NoEffect;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;}workInProgress.expirationTime=expirationTime;workInProgress.pendingProps=pendingProps;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;return workInProgress;}function createHostRootFiber(){var fiber=createFiber(HostRoot,null,NoContext);return fiber;}function createFiberFromElement(element,internalContextTag,expirationTime){var owner=null;{owner=element._owner;}var fiber=void 0;var type=element.type,key=element.key;if(typeof type==='function'){fiber=shouldConstruct(type)?createFiber(ClassComponent,key,internalContextTag):createFiber(IndeterminateComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if(typeof type==='string'){fiber=createFiber(HostComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if(typeof type==='object'&&type!==null&&typeof type.tag==='number'){// Currently assumed to be a continuation and therefore is a fiber already.
// TODO: The yield system is currently broken for updates in some cases.
// The reified yield stores a fiber, but we don't know which fiber that is;
// the current or a workInProgress? When the continuation gets rendered here
// we don't know if we can reuse that fiber or if we need to clone it.
// There is probably a clever way to restructure this.
fiber=type;fiber.pendingProps=element.props;}else{var info='';{if(type===undefined||typeof type==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in, or you might have mixed up default and named imports.";}var ownerName=owner?getComponentName(owner):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}invariant(false,'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',type==null?type:typeof type,info);}{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}fiber.expirationTime=expirationTime;return fiber;}function createFiberFromFragment(elements,internalContextTag,expirationTime,key){var fiber=createFiber(Fragment,key,internalContextTag);fiber.pendingProps=elements;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,internalContextTag,expirationTime){var fiber=createFiber(HostText,null,internalContextTag);fiber.pendingProps=content;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,NoContext);fiber.type='DELETED';return fiber;}function createFiberFromCall(call,internalContextTag,expirationTime){var fiber=createFiber(CallComponent,call.key,internalContextTag);fiber.type=call.handler;fiber.pendingProps=call;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromReturn(returnNode,internalContextTag,expirationTime){var fiber=createFiber(ReturnComponent,null,internalContextTag);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromPortal(portal,internalContextTag,expirationTime){var fiber=createFiber(HostPortal,portal.key,internalContextTag);fiber.pendingProps=portal.children||[];fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}function createFiberRoot(containerInfo,hydrate){// Cyclic construction. This cheats the type system right now because
// stateNode is any.
var uninitializedFiber=createHostRootFiber();var root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,remainingExpirationTime:NoWork,isReadyForCommit:false,finishedWork:null,context:null,pendingContext:null,hydrate:hydrate,nextScheduledRoot:null};uninitializedFiber.stateNode=root;return root;}var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;function catchErrors(fn){return function(arg){try{return fn(arg);}catch(err){if(true&&!hasLoggedError){hasLoggedError=true;warning(false,'React DevTools encountered an error: %s',err);}}};}function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{warning(false,'The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
onCommitFiberRoot=catchErrors(function(root){return hook.onCommitFiberRoot(rendererID,root);});onCommitFiberUnmount=catchErrors(function(fiber){return hook.onCommitFiberUnmount(rendererID,fiber);});}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{warning(false,'React DevTools encountered an error: %s.',err);}}// DevTools exists
return true;}function onCommitRoot(root){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}{var didWarnUpdateInsideUpdate=false;}// Callbacks are not validated until invocation
// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.
function createUpdateQueue(baseState){var queue={baseState:baseState,expirationTime:NoWork,first:null,last:null,callbackList:null,hasForceUpdate:false,isInitialized:false};{queue.isProcessing=false;}return queue;}function insertUpdateIntoQueue(queue,update){// Append the update to the end of the list.
if(queue.last===null){// Queue is empty
queue.first=queue.last=update;}else{queue.last.next=update;queue.last=update;}if(queue.expirationTime===NoWork||queue.expirationTime>update.expirationTime){queue.expirationTime=update.expirationTime;}}function insertUpdateIntoFiber(fiber,update){// We'll have at least one and at most two distinct update queues.
var alternateFiber=fiber.alternate;var queue1=fiber.updateQueue;if(queue1===null){// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
queue1=fiber.updateQueue=createUpdateQueue(null);}var queue2=void 0;if(alternateFiber!==null){queue2=alternateFiber.updateQueue;if(queue2===null){queue2=alternateFiber.updateQueue=createUpdateQueue(null);}}else{queue2=null;}queue2=queue2!==queue1?queue2:null;// Warn if an update is scheduled from inside an updater function.
{if((queue1.isProcessing||queue2!==null&&queue2.isProcessing)&&!didWarnUpdateInsideUpdate){warning(false,'An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}// If there's only one queue, add the update to that queue and exit.
if(queue2===null){insertUpdateIntoQueue(queue1,update);return;}// If either queue is empty, we need to add to both queues.
if(queue1.last===null||queue2.last===null){insertUpdateIntoQueue(queue1,update);insertUpdateIntoQueue(queue2,update);return;}// If both lists are not empty, the last update is the same for both lists
// because of structural sharing. So, we should only append to one of
// the lists.
insertUpdateIntoQueue(queue1,update);// But we still need to update the `last` pointer of queue2.
queue2.last=update;}function getUpdateExpirationTime(fiber){if(fiber.tag!==ClassComponent&&fiber.tag!==HostRoot){return NoWork;}var updateQueue=fiber.updateQueue;if(updateQueue===null){return NoWork;}return updateQueue.expirationTime;}function getStateFromUpdate(update,instance,prevState,props){var partialState=update.partialState;if(typeof partialState==='function'){var updateFn=partialState;// Invoke setState callback an extra time to help detect side-effects.
if(debugRenderPhaseSideEffects){updateFn.call(instance,prevState,props);}return updateFn.call(instance,prevState,props);}else{return partialState;}}function processUpdateQueue(current,workInProgress,queue,instance,props,renderExpirationTime){if(current!==null&&current.updateQueue===queue){// We need to create a work-in-progress queue, by cloning the current queue.
var currentQueue=queue;queue=workInProgress.updateQueue={baseState:currentQueue.baseState,expirationTime:currentQueue.expirationTime,first:currentQueue.first,last:currentQueue.last,isInitialized:currentQueue.isInitialized,// These fields are no longer valid because they were already committed.
// Reset them.
callbackList:null,hasForceUpdate:false};}{// Set this flag so we can warn if setState is called inside the update
// function of another setState.
queue.isProcessing=true;}// Reset the remaining expiration time. If we skip over any updates, we'll
// increase this accordingly.
queue.expirationTime=NoWork;// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
var state=void 0;if(queue.isInitialized){state=queue.baseState;}else{state=queue.baseState=workInProgress.memoizedState;queue.isInitialized=true;}var dontMutatePrevState=true;var update=queue.first;var didSkip=false;while(update!==null){var updateExpirationTime=update.expirationTime;if(updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.
var remainingExpirationTime=queue.expirationTime;if(remainingExpirationTime===NoWork||remainingExpirationTime>updateExpirationTime){// Update the remaining expiration time.
queue.expirationTime=updateExpirationTime;}if(!didSkip){didSkip=true;queue.baseState=state;}// Continue to the next update.
update=update.next;continue;}// This update does have sufficient priority.
// If no previous updates were skipped, drop this update from the queue by
// advancing the head of the list.
if(!didSkip){queue.first=update.next;if(queue.first===null){queue.last=null;}}// Process the update
var _partialState=void 0;if(update.isReplace){state=getStateFromUpdate(update,instance,state,props);dontMutatePrevState=true;}else{_partialState=getStateFromUpdate(update,instance,state,props);if(_partialState){if(dontMutatePrevState){// $FlowFixMe: Idk how to type this properly.
state=_assign({},state,_partialState);}else{state=_assign(state,_partialState);}dontMutatePrevState=false;}}if(update.isForced){queue.hasForceUpdate=true;}if(update.callback!==null){// Append to list of callbacks.
var _callbackList=queue.callbackList;if(_callbackList===null){_callbackList=queue.callbackList=[];}_callbackList.push(update);}update=update.next;}if(queue.callbackList!==null){workInProgress.effectTag|=Callback;}else if(queue.first===null&&!queue.hasForceUpdate){// The queue is empty. We can reset it.
workInProgress.updateQueue=null;}if(!didSkip){didSkip=true;queue.baseState=state;}{// No longer processing.
queue.isProcessing=false;}return state;}function commitCallbacks(queue,context){var callbackList=queue.callbackList;if(callbackList===null){return;}// Set the list to null to make sure they don't get called more than once.
queue.callbackList=null;for(var i=0;i<callbackList.length;i++){var update=callbackList[i];var _callback=update.callback;// This update might be processed again. Clear the callback so it's only
// called once.
update.callback=null;!(typeof _callback==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',_callback):void 0;_callback.call(context);}}var fakeInternalInstance={};var isArray=Array.isArray;{var didWarnAboutStateAssignmentForComponent={};var warnOnInvalidCallback=function(callback,callerName){warning(callback===null||typeof callback==='function','%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function(){invariant(false,'_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}var ReactFiberClassComponent=function(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState){// Class component state updater
var updater={isMounted:isMounted,enqueueSetState:function(instance,partialState,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'setState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:partialState,callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueReplaceState:function(instance,state,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'replaceState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:state,callback:callback,isReplace:true,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueForceUpdate:function(instance,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'forceUpdate');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:null,callback:callback,isReplace:false,isForced:true,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext){if(oldProps===null||workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate){// If the workInProgress already has an Update effect, return true
return true;}var instance=workInProgress.stateNode;var type=workInProgress.type;if(typeof instance.shouldComponentUpdate==='function'){startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.shouldComponentUpdate(newProps,newState,newContext);}{warning(shouldUpdate!==undefined,'%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(workInProgress)||'Unknown');}return shouldUpdate;}if(type.prototype&&type.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress){var instance=workInProgress.stateNode;var type=workInProgress.type;{var name=getComponentName(workInProgress);var renderPresent=instance.render;if(!renderPresent){if(type.prototype&&typeof type.prototype.render==='function'){warning(false,'%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{warning(false,'%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}var noGetInitialStateOnES6=!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state;warning(noGetInitialStateOnES6,'getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);var noGetDefaultPropsOnES6=!instance.getDefaultProps||instance.getDefaultProps.isReactClassApproved;warning(noGetDefaultPropsOnES6,'getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);var noInstancePropTypes=!instance.propTypes;warning(noInstancePropTypes,'propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);var noInstanceContextTypes=!instance.contextTypes;warning(noInstanceContextTypes,'contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);var noComponentShouldUpdate=typeof instance.componentShouldUpdate!=='function';warning(noComponentShouldUpdate,'%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);if(type.prototype&&type.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){warning(false,'%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(workInProgress)||'A pure component');}var noComponentDidUnmount=typeof instance.componentDidUnmount!=='function';warning(noComponentDidUnmount,'%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);var noComponentDidReceiveProps=typeof instance.componentDidReceiveProps!=='function';warning(noComponentDidReceiveProps,'%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);var noComponentWillRecieveProps=typeof instance.componentWillRecieveProps!=='function';warning(noComponentWillRecieveProps,'%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);var hasMutatedProps=instance.props!==workInProgress.pendingProps;warning(instance.props===undefined||!hasMutatedProps,'%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);var noInstanceDefaultProps=!instance.defaultProps;warning(noInstanceDefaultProps,'Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}var state=instance.state;if(state&&(typeof state!=='object'||isArray(state))){warning(false,'%s.state: must be set to an object or null',getComponentName(workInProgress));}if(typeof instance.getChildContext==='function'){warning(typeof workInProgress.type.childContextTypes==='object','%s.getChildContext(): childContextTypes must be defined in order to '+'use getChildContext().',getComponentName(workInProgress));}}function resetInputPointers(workInProgress,instance){instance.props=workInProgress.memoizedProps;instance.state=workInProgress.memoizedState;}function adoptClassInstance(workInProgress,instance){instance.updater=updater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,props){var ctor=workInProgress.type;var unmaskedContext=getUnmaskedContext(workInProgress);var needsContext=isContextConsumer(workInProgress);var context=needsContext?getMaskedContext(workInProgress,unmaskedContext):emptyObject;var instance=new ctor(props,context);adoptClassInstance(workInProgress,instance);// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(needsContext){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;instance.componentWillMount();stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillMount();}if(oldState!==instance.state){{warning(false,'%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress));}updater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,newContext){startPhaseTimer(workInProgress,'componentWillReceiveProps');var oldState=instance.state;instance.componentWillReceiveProps(newProps,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillReceiveProps(newProps,newContext);}if(instance.state!==oldState){{var componentName=getComponentName(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent[componentName]){warning(false,'%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);didWarnAboutStateAssignmentForComponent[componentName]=true;}}updater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,renderExpirationTime){var current=workInProgress.alternate;{checkClassInstance(workInProgress);}var instance=workInProgress.stateNode;var state=instance.state||null;var props=workInProgress.pendingProps;!props?invariant(false,'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.'):void 0;var unmaskedContext=getUnmaskedContext(workInProgress);instance.props=props;instance.state=workInProgress.memoizedState=state;instance.refs=emptyObject;instance.context=getMaskedContext(workInProgress,unmaskedContext);if(enableAsyncSubtreeAPI&&workInProgress.type!=null&&workInProgress.type.prototype!=null&&workInProgress.type.prototype.unstable_isAsyncReactComponent===true){workInProgress.internalContextTag|=AsyncUpdates;}if(typeof instance.componentWillMount==='function'){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){instance.state=processUpdateQueue(current,workInProgress,updateQueue,instance,props,renderExpirationTime);}}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}// Called on a preexisting class instance. Returns false if a resumed render
// could be reused.
// function resumeMountClassInstance(
//   workInProgress: Fiber,
//   priorityLevel: PriorityLevel,
// ): boolean {
//   const instance = workInProgress.stateNode;
//   resetInputPointers(workInProgress, instance);
//   let newState = workInProgress.memoizedState;
//   let newProps = workInProgress.pendingProps;
//   if (!newProps) {
//     // If there isn't any new props, then we'll reuse the memoized props.
//     // This could be from already completed work.
//     newProps = workInProgress.memoizedProps;
//     invariant(
//       newProps != null,
//       'There should always be pending or memoized props. This error is ' +
//         'likely caused by a bug in React. Please file an issue.',
//     );
//   }
//   const newUnmaskedContext = getUnmaskedContext(workInProgress);
//   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);
//   const oldContext = instance.context;
//   const oldProps = workInProgress.memoizedProps;
//   if (
//     typeof instance.componentWillReceiveProps === 'function' &&
//     (oldProps !== newProps || oldContext !== newContext)
//   ) {
//     callComponentWillReceiveProps(
//       workInProgress,
//       instance,
//       newProps,
//       newContext,
//     );
//   }
//   // Process the update queue before calling shouldComponentUpdate
//   const updateQueue = workInProgress.updateQueue;
//   if (updateQueue !== null) {
//     newState = processUpdateQueue(
//       workInProgress,
//       updateQueue,
//       instance,
//       newState,
//       newProps,
//       priorityLevel,
//     );
//   }
//   // TODO: Should we deal with a setState that happened after the last
//   // componentWillMount and before this componentWillMount? Probably
//   // unsupported anyway.
//   if (
//     !checkShouldComponentUpdate(
//       workInProgress,
//       workInProgress.memoizedProps,
//       newProps,
//       workInProgress.memoizedState,
//       newState,
//       newContext,
//     )
//   ) {
//     // Update the existing instance's state, props, and context pointers even
//     // though we're bailing out.
//     instance.props = newProps;
//     instance.state = newState;
//     instance.context = newContext;
//     return false;
//   }
//   // Update the input pointers now so that they are correct when we call
//   // componentWillMount
//   instance.props = newProps;
//   instance.state = newState;
//   instance.context = newContext;
//   if (typeof instance.componentWillMount === 'function') {
//     callComponentWillMount(workInProgress, instance);
//     // componentWillMount may have called setState. Process the update queue.
//     const newUpdateQueue = workInProgress.updateQueue;
//     if (newUpdateQueue !== null) {
//       newState = processUpdateQueue(
//         workInProgress,
//         newUpdateQueue,
//         instance,
//         newState,
//         newProps,
//         priorityLevel,
//       );
//     }
//   }
//   if (typeof instance.componentDidMount === 'function') {
//     workInProgress.effectTag |= Update;
//   }
//   instance.state = newState;
//   return true;
// }
// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,renderExpirationTime){var instance=workInProgress.stateNode;resetInputPointers(workInProgress,instance);var oldProps=workInProgress.memoizedProps;var newProps=workInProgress.pendingProps;if(!newProps){// If there aren't any new props, then we'll reuse the memoized props.
// This could be from already completed work.
newProps=oldProps;!(newProps!=null)?invariant(false,'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var oldContext=instance.context;var newUnmaskedContext=getUnmaskedContext(workInProgress);var newContext=getMaskedContext(workInProgress,newUnmaskedContext);// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
if(typeof instance.componentWillReceiveProps==='function'&&(oldProps!==newProps||oldContext!==newContext)){callComponentWillReceiveProps(workInProgress,instance,newProps,newContext);}// Compute the next state using the memoized state and the update queue.
var oldState=workInProgress.memoizedState;// TODO: Previous state can be null.
var newState=void 0;if(workInProgress.updateQueue!==null){newState=processUpdateQueue(current,workInProgress,workInProgress.updateQueue,instance,newProps,renderExpirationTime);}else{newState=oldState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!(workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate)){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}return false;}var shouldUpdate=checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext);if(shouldUpdate){if(typeof instance.componentWillUpdate==='function'){startPhaseTimer(workInProgress,'componentWillUpdate');instance.componentWillUpdate(newProps,newState,newContext);stopPhaseTimer();// Simulate an async bailout/interruption by invoking lifecycle twice.
if(debugRenderPhaseSideEffects){instance.componentWillUpdate(newProps,newState,newContext);}}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
memoizeProps(workInProgress,newProps);memoizeState(workInProgress,newState);}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=newContext;return shouldUpdate;}return{adoptClassInstance:adoptClassInstance,constructClassInstance:constructClassInstance,mountClassInstance:mountClassInstance,// resumeMountClassInstance,
updateClassInstance:updateClassInstance};};// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var hasSymbol=typeof Symbol==='function'&&Symbol['for'];var REACT_ELEMENT_TYPE=hasSymbol?Symbol['for']('react.element'):0xeac7;var REACT_CALL_TYPE=hasSymbol?Symbol['for']('react.call'):0xeac8;var REACT_RETURN_TYPE=hasSymbol?Symbol['for']('react.return'):0xeac9;var REACT_PORTAL_TYPE=hasSymbol?Symbol['for']('react.portal'):0xeaca;var REACT_FRAGMENT_TYPE=hasSymbol?Symbol['for']('react.fragment'):0xeacb;var MAYBE_ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable==='undefined'){return null;}var maybeIterator=MAYBE_ITERATOR_SYMBOL&&maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof maybeIterator==='function'){return maybeIterator;}return null;}var getCurrentFiberStackAddendum$1=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnAboutMaps=false;/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */var ownerHasKeyUseWarning={};var ownerHasFunctionTypeWarning={};var warnForMissingKey=function(child){if(child===null||typeof child!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}!(typeof child._store==='object')?invariant(false,'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'):void 0;child._store.validated=true;var currentComponentErrorInfo='Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;warning(false,'Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.%s',getCurrentFiberStackAddendum$1());};}var isArray$1=Array.isArray;function coerceRef(current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'){if(element._owner){var owner=element._owner;var inst=void 0;if(owner){var ownerFiber=owner;!(ownerFiber.tag===ClassComponent)?invariant(false,'Stateless function components cannot have refs.'):void 0;inst=ownerFiber.stateNode;}!inst?invariant(false,'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',mixedRef):void 0;var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current!==null&&current.ref!==null&&current.ref._stringRef===stringRef){return current.ref;}var ref=function(value){var refs=inst.refs===emptyObject?inst.refs={}:inst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{!(typeof mixedRef==='string')?invariant(false,'Expected ref to be a function or a string.'):void 0;!element._owner?invariant(false,'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).',mixedRef):void 0;}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+(getCurrentFiberStackAddendum$1()||'');}invariant(false,'Objects are not valid as a React child (found: %s).%s',Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild,addendum);}}function warnOnFunctionType(){var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;warning(false,'Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.%s',getCurrentFiberStackAddendum$1()||'');}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}// Deletions are added in reversed order so we add it to the front.
// At this point, the return fiber's effect list is empty except for
// deletions, so we can just append the deletion to the list. The remaining
// effects aren't added until the complete phase. Once we implement
// resuming, this may not be true.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps,expirationTime){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
var clone=createWorkInProgress(fiber,pendingProps,expirationTime);clone.index=0;clone.sibling=null;return clone;}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.effectTag=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,expirationTime){if(current===null||current.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,textContent,expirationTime);existing['return']=returnFiber;return existing;}}function updateElement(returnFiber,current,element,expirationTime){if(current!==null&&current.type===element.type){// Move based on index
var existing=useFiber(current,element.props,expirationTime);existing.ref=coerceRef(current,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{// Insert
var created=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);created.ref=coerceRef(current,element);created['return']=returnFiber;return created;}}function updateCall(returnFiber,current,call,expirationTime){// TODO: Should this also compare handler to determine whether to reuse?
if(current===null||current.tag!==CallComponent){// Insert
var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,call,expirationTime);existing['return']=returnFiber;return existing;}}function updateReturn(returnFiber,current,returnNode,expirationTime){if(current===null||current.tag!==ReturnComponent){// Insert
var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}}function updatePortal(returnFiber,current,portal,expirationTime){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,expirationTime,key){if(current===null||current.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.internalContextTag,expirationTime,key);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,fragment,expirationTime);existing['return']=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.type===REACT_FRAGMENT_TYPE){var _created=createFiberFromFragment(newChild.props.children,returnFiber.internalContextTag,expirationTime,newChild.key);_created['return']=returnFiber;return _created;}else{var _created2=createFiberFromElement(newChild,returnFiber.internalContextTag,expirationTime);_created2.ref=coerceRef(null,newChild);_created2['return']=returnFiber;return _created2;}}case REACT_CALL_TYPE:{var _created3=createFiberFromCall(newChild,returnFiber.internalContextTag,expirationTime);_created3['return']=returnFiber;return _created3;}case REACT_RETURN_TYPE:{var _created4=createFiberFromReturn(newChild,returnFiber.internalContextTag,expirationTime);_created4.type=newChild.value;_created4['return']=returnFiber;return _created4;}case REACT_PORTAL_TYPE:{var _created5=createFiberFromPortal(newChild,returnFiber.internalContextTag,expirationTime);_created5['return']=returnFiber;return _created5;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created6=createFiberFromFragment(newChild,returnFiber.internalContextTag,expirationTime,null);_created6['return']=returnFiber;return _created6;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_CALL_TYPE:{if(newChild.key===key){return updateCall(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_RETURN_TYPE:{// Returns don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a
// yield.
if(key===null){return updateReturn(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if(typeof newChild==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_CALL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateCall(returnFiber,_matchedFiber2,newChild,expirationTime);}case REACT_RETURN_TYPE:{// Returns don't have keys, so we neither have to check the old nor
// new node for the key. If both are returns, they match.
var _matchedFiber3=existingChildren.get(newIdx)||null;return updateReturn(returnFiber,_matchedFiber3,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber4=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber4,newChild,expirationTime);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber5=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber5,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys){{if(typeof child!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_CALL_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}warning(false,'Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.%s',key,getCurrentFiberStackAddendum$1());break;default:break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from boths ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(!_newFiber){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);!(typeof iteratorFn==='function')?invariant(false,'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'):void 0;{// Warn about using Maps as children
if(typeof newChildrenIterable.entries==='function'){var possibleMap=newChildrenIterable;if(possibleMap.entries===iteratorFn){warning(didWarnAboutMaps,'Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.%s',getCurrentFiberStackAddendum$1());didWarnAboutMaps=true;}}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);!(newChildren!=null)?invariant(false,'An iterable object provided no iterator.'):void 0;var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(!oldFiber){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent,expirationTime);existing['return']=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===Fragment?element.type===REACT_FRAGMENT_TYPE:child.type===element.type){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.type===REACT_FRAGMENT_TYPE?element.props.children:element.props,expirationTime);existing.ref=coerceRef(child,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.internalContextTag,expirationTime,element.key);created['return']=returnFiber;return created;}else{var _created7=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);_created7.ref=coerceRef(currentFirstChild,element);_created7['return']=returnFiber;return _created7;}}function reconcileSingleCall(returnFiber,currentFirstChild,call,expirationTime){var key=call.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===CallComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,call,expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleReturn(returnFiber,currentFirstChild,returnNode,expirationTime){// There's no need to check for keys on yields since they're stateless.
var child=currentFirstChild;if(child!==null){if(child.tag===ReturnComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);}}var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
if(typeof newChild==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null){newChild=newChild.props.children;}// Handle object types
var isObject=typeof newChild==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_CALL_TYPE:return placeSingleChild(reconcileSingleCall(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_RETURN_TYPE:return placeSingleChild(reconcileSingleReturn(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'){// If the new child is undefined, and the return fiber is a composite
// component, throw an error. If Fiber return types are disabled,
// we already threw above.
switch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
break;}}}// Intentionally fall through to the next case, which handles both
// functions and classes
// eslint-disable-next-lined no-fallthrough
case FunctionalComponent:{var Component=returnFiber.type;invariant(false,'%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',Component.displayName||Component.name||'Component');}}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true);var mountChildFibers=ChildReconciler(false);function cloneChildFibers(current,workInProgress){!(current===null||workInProgress.child===current.child)?invariant(false,'Resuming work not yet implemented.'):void 0;if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);workInProgress.child=newChild;newChild['return']=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);newChild['return']=workInProgress;}newChild.sibling=null;}{var warnedAboutStatelessRefs={};}var ReactFiberBeginWork=function(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber){var shouldSetTextContent=config.shouldSetTextContent,useSyncScheduling=config.useSyncScheduling,shouldDeprioritizeSubtree=config.shouldDeprioritizeSubtree;var pushHostContext=hostContext.pushHostContext,pushHostContainer=hostContext.pushHostContainer;var enterHydrationState=hydrationContext.enterHydrationState,resetHydrationState=hydrationContext.resetHydrationState,tryToClaimNextHydratableInstance=hydrationContext.tryToClaimNextHydratableInstance;var _ReactFiberClassCompo=ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState),adoptClassInstance=_ReactFiberClassCompo.adoptClassInstance,constructClassInstance=_ReactFiberClassCompo.constructClassInstance,mountClassInstance=_ReactFiberClassCompo.mountClassInstance,updateClassInstance=_ReactFiberClassCompo.updateClassInstance;// TODO: Remove this and use reconcileChildrenAtExpirationTime directly.
function reconcileChildren(current,workInProgress,nextChildren){reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,workInProgress.expirationTime);}function reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibers(workInProgress,null,nextChildren,renderExpirationTime);}else{// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,current.child,nextChildren,renderExpirationTime);}}function updateFragment(current,workInProgress){var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=workInProgress.memoizedProps;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(ref!==null&&(!current||current.ref!==ref)){// Schedule a Ref effect
workInProgress.effectTag|=Ref;}}function updateFunctionalComponent(current,workInProgress){var fn=workInProgress.type;var nextProps=workInProgress.pendingProps;var memoizedProps=workInProgress.memoizedProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextProps===null){nextProps=memoizedProps;}}else{if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}// TODO: consider bringing fn.shouldComponentUpdate() back.
// It used to be here.
}var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var nextChildren;{ReactCurrentOwner.current=workInProgress;ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=fn(nextProps,context);ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateClassComponent(current,workInProgress,renderExpirationTime){// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);var shouldUpdate=void 0;if(current===null){if(!workInProgress.stateNode){// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,workInProgress.pendingProps);mountClassInstance(workInProgress,renderExpirationTime);shouldUpdate=true;}else{invariant(false,'Resuming work not yet implemented.');// In a resume, we'll already have an instance we can reuse.
// shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
}}else{shouldUpdate=updateClassInstance(current,workInProgress,renderExpirationTime);}return finishClassComponent(current,workInProgress,shouldUpdate,hasContext);}function finishClassComponent(current,workInProgress,shouldUpdate,hasContext){// Refs should update even if shouldComponentUpdate returns false
markRef(current,workInProgress);if(!shouldUpdate){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner.current=workInProgress;var nextChildren=void 0;{ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=instance.render();if(debugRenderPhaseSideEffects){instance.render();}ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);// Memoize props and state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
memoizeState(workInProgress,instance.state);memoizeProps(workInProgress,instance.props);// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){var prevState=workInProgress.memoizedState;var state=processUpdateQueue(current,workInProgress,updateQueue,null,null,renderExpirationTime);if(prevState===state){// If the state is the same as before, that's a bailout because we had
// no work that expires at this time.
resetHydrationState();return bailoutOnAlreadyFinishedWork(current,workInProgress);}var element=state.element;var root=workInProgress.stateNode;if((current===null||current.child===null)&&root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
// We always try to hydrate. If this isn't a hydration pass there won't
// be any children to hydrate which is effectively the same thing as
// not hydrating.
// This is a bit of a hack. We track the host root as a placement to
// know that we're currently in a mounting state. That way isMounted
// works as expected. We must reset this before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag|=Placement;// Ensure that children mount into this root without tracking
// side-effects. This ensures that we don't store Placement effects on
// nodes that will be hydrated.
workInProgress.child=mountChildFibers(workInProgress,null,element,renderExpirationTime);}else{// Otherwise reset hydration state in case we aborted and resumed another
// root.
resetHydrationState();reconcileChildren(current,workInProgress,element);}memoizeState(workInProgress,state);return workInProgress.child;}resetHydrationState();// If there is no update queue, that's a bailout because the root has no props.
return bailoutOnAlreadyFinishedWork(current,workInProgress);}function updateHostComponent(current,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var memoizedProps=workInProgress.memoizedProps;var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=memoizedProps;!(nextProps!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var prevProps=current!==null?current.memoizedProps:null;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
}else if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also have access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.effectTag|=ContentReset;}markRef(current,workInProgress);// Check the host config to see if the children are offscreen/hidden.
if(renderExpirationTime!==Never&&!useSyncScheduling&&shouldDeprioritizeSubtree(type,nextProps)){// Down-prioritize the children.
workInProgress.expirationTime=Never;// Bailout and come back to this fiber later.
return null;}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=workInProgress.memoizedProps;}memoizeProps(workInProgress,nextProps);// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountIndeterminateComponent(current,workInProgress,renderExpirationTime){!(current===null)?invariant(false,'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.'):void 0;var fn=workInProgress.type;var props=workInProgress.pendingProps;var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var value;{if(fn.prototype&&typeof fn.prototype.render==='function'){var componentName=getComponentName(workInProgress);warning(false,"The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);}ReactCurrentOwner.current=workInProgress;value=fn(props,context);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if(typeof value==='object'&&value!==null&&typeof value.render==='function'){// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,renderExpirationTime);return finishClassComponent(current,workInProgress,true,hasContext);}else{// Proceed under the assumption that this is a functional component
workInProgress.tag=FunctionalComponent;{var Component=workInProgress.type;if(Component){warning(!Component.childContextTypes,'%s(...): childContextTypes cannot be defined on a functional component.',Component.displayName||Component.name||'Component');}if(workInProgress.ref!==null){var info='';var ownerName=ReactDebugCurrentFiber.getCurrentFiberOwnerName();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!warnedAboutStatelessRefs[warningKey]){warnedAboutStatelessRefs[warningKey]=true;warning(false,'Stateless function components cannot be given refs. '+'Attempts to access this ref will fail.%s%s',info,ReactDebugCurrentFiber.getCurrentFiberStackAddendum());}}}reconcileChildren(current,workInProgress,value);memoizeProps(workInProgress,props);return workInProgress.child;}}function updateCallComponent(current,workInProgress,renderExpirationTime){var nextCall=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextCall===null){nextCall=current&&current.memoizedProps;!(nextCall!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextCall===null||workInProgress.memoizedProps===nextCall){nextCall=workInProgress.memoizedProps;// TODO: When bailing out, we might need to return the stateNode instead
// of the child. To check it for work.
// return bailoutOnAlreadyFinishedWork(current, workInProgress);
}var nextChildren=nextCall.children;// The following is a fork of reconcileChildrenAtExpirationTime but using
// stateNode to store the child.
if(current===null){workInProgress.stateNode=mountChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}else{workInProgress.stateNode=reconcileChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}memoizeProps(workInProgress,nextCall);// This doesn't take arbitrary time so we could synchronously just begin
// eagerly do the work of workInProgress.child as an optimization.
return workInProgress.stateNode;}function updatePortalComponent(current,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=current&&current.memoizedProps;!(nextChildren!=null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}if(current===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibers(workInProgress,null,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);}else{reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);}return workInProgress.child;}/*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */function bailoutOnAlreadyFinishedWork(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: We should ideally be able to bail out early if the children have no
// more work to do. However, since we don't have a separation of this
// Fiber's priority and its children yet - we don't know without doing lots
// of the same work we do anyway. Once we have that separation we can just
// bail out here if the children has no more work at this priority level.
// if (workInProgress.priorityOfChildren <= priorityLevel) {
//   // If there are side-effects in these children that have not yet been
//   // committed we need to ensure that they get properly transferred up.
//   if (current && current.child !== workInProgress.child) {
//     reuseChildrenEffects(workInProgress, child);
//   }
//   return null;
// }
cloneChildFibers(current,workInProgress);return workInProgress.child;}function bailoutOnLowPriority(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: Handle HostComponent tags here as well and call pushHostContext()?
// See PR 8590 discussion for context
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);break;case ClassComponent:pushContextProvider(workInProgress);break;case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;}// TODO: What if this is currently in progress?
// How can that happen? How is this not being cloned?
return null;}// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
function memoizeProps(workInProgress,nextProps){workInProgress.memoizedProps=nextProps;}function memoizeState(workInProgress,nextState){workInProgress.memoizedState=nextState;// Don't reset the updateQueue, in case there are pending updates. Resetting
// is handled by processUpdateQueue.
}function beginWork(current,workInProgress,renderExpirationTime){if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}switch(workInProgress.tag){case IndeterminateComponent:return mountIndeterminateComponent(current,workInProgress,renderExpirationTime);case FunctionalComponent:return updateFunctionalComponent(current,workInProgress);case ClassComponent:return updateClassComponent(current,workInProgress,renderExpirationTime);case HostRoot:return updateHostRoot(current,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current,workInProgress,renderExpirationTime);case HostText:return updateHostText(current,workInProgress);case CallHandlerPhase:// This is a restart. Reset the tag to the initial phase.
workInProgress.tag=CallComponent;// Intentionally fall through since this is now the same.
case CallComponent:return updateCallComponent(current,workInProgress,renderExpirationTime);case ReturnComponent:// A return component is just a placeholder, we can just run through the
// next one immediately.
return null;case HostPortal:return updatePortalComponent(current,workInProgress,renderExpirationTime);case Fragment:return updateFragment(current,workInProgress);default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}function beginFailedWork(current,workInProgress,renderExpirationTime){// Push context providers here to avoid a push/pop context mismatch.
switch(workInProgress.tag){case ClassComponent:pushContextProvider(workInProgress);break;case HostRoot:pushHostRootContext(workInProgress);break;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}// Add an error effect so we can handle the error during the commit phase
workInProgress.effectTag|=Err;// This is a weird case where we do "resume" work — work that failed on
// our first attempt. Because we no longer have a notion of "progressed
// deletions," reset the child to the current child to make sure we delete
// it again. TODO: Find a better way to handle this, perhaps during a more
// general overhaul of error handling.
if(current===null){workInProgress.child=null;}else if(workInProgress.child!==current.child){workInProgress.child=current.child;}if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}// If we don't bail out, we're going be recomputing our children so we need
// to drop our effect list.
workInProgress.firstEffect=null;workInProgress.lastEffect=null;// Unmount the current children as if the component rendered null
var nextChildren=null;reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime);if(workInProgress.tag===ClassComponent){var instance=workInProgress.stateNode;workInProgress.memoizedProps=instance.props;workInProgress.memoizedState=instance.state;}return workInProgress.child;}return{beginWork:beginWork,beginFailedWork:beginFailedWork};};var ReactFiberCompleteWork=function(config,hostContext,hydrationContext){var createInstance=config.createInstance,createTextInstance=config.createTextInstance,appendInitialChild=config.appendInitialChild,finalizeInitialChildren=config.finalizeInitialChildren,prepareUpdate=config.prepareUpdate,mutation=config.mutation,persistence=config.persistence;var getRootHostContainer=hostContext.getRootHostContainer,popHostContext=hostContext.popHostContext,getHostContext=hostContext.getHostContext,popHostContainer=hostContext.popHostContainer;var prepareToHydrateHostInstance=hydrationContext.prepareToHydrateHostInstance,prepareToHydrateHostTextInstance=hydrationContext.prepareToHydrateHostTextInstance,popHydrationState=hydrationContext.popHydrationState;function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// an UpdateAndPlacement.
workInProgress.effectTag|=Update;}function markRef(workInProgress){workInProgress.effectTag|=Ref;}function appendAllReturns(returns,workInProgress){var node=workInProgress.stateNode;if(node){node['return']=workInProgress;}while(node!==null){if(node.tag===HostComponent||node.tag===HostText||node.tag===HostPortal){invariant(false,'A call cannot have host component children.');}else if(node.tag===ReturnComponent){returns.push(node.type);}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function moveCallToHandlerPhase(current,workInProgress,renderExpirationTime){var call=workInProgress.memoizedProps;!call?invariant(false,'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.'):void 0;// First step of the call has completed. Now we need to do the second.
// TODO: It would be nice to have a multi stage call represented by a
// single component, or at least tail call optimize nested ones. Currently
// that requires additional fields that we don't want to add to the fiber.
// So this requires nested handlers.
// Note: This doesn't mutate the alternate node. I don't think it needs to
// since this stage is reset for every pass.
workInProgress.tag=CallHandlerPhase;// Build up the returns.
// TODO: Compare this to a generator or opaque helpers like Children.
var returns=[];appendAllReturns(returns,workInProgress);var fn=call.handler;var props=call.props;var nextChildren=fn(props,returns);var currentFirstChild=current!==null?current.child:null;workInProgress.child=reconcileChildFibers(workInProgress,currentFirstChild,nextChildren,renderExpirationTime);return workInProgress.child;}function appendAllChildren(parent,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}var updateHostContainer=void 0;var updateHostComponent=void 0;var updateHostText=void 0;if(mutation){if(enableMutatingReconciler){// Mutation mode
updateHostContainer=function(workInProgress){// Noop
};updateHostComponent=function(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText=function(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}else{invariant(false,'Mutating reconciler is disabled.');}}else if(persistence){if(enablePersistentReconciler){// Persistent host tree mode
var cloneInstance=persistence.cloneInstance,createContainerChildSet=persistence.createContainerChildSet,appendChildToContainerChildSet=persistence.appendChildToContainerChildSet,finalizeContainerChildren=persistence.finalizeContainerChildren;// An unfortunate fork of appendAllChildren because we have two different parent types.
var appendAllChildrenToContainer=function(containerChildSet,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendChildToContainerChildSet(containerChildSet,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}};updateHostContainer=function(workInProgress){var portalOrRoot=workInProgress.stateNode;var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged){// No changes, just reuse the existing instance.
}else{var container=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(container);if(finalizeContainerChildren(container,newChildSet)){markUpdate(workInProgress);}portalOrRoot.pendingChildren=newChildSet;// If children might have changed, we have to add them all to the set.
appendAllChildrenToContainer(newChildSet,workInProgress);// Schedule an update on the container to swap out the container.
markUpdate(workInProgress);}};updateHostComponent=function(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// If there are no effects associated with this node, then none of our children had any updates.
// This guarantees that we can reuse all of them.
var childrenUnchanged=workInProgress.firstEffect===null;var currentInstance=current.stateNode;if(childrenUnchanged&&updatePayload===null){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;}else{var recyclableInstance=workInProgress.stateNode;var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,childrenUnchanged,recyclableInstance);if(finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=newInstance;if(childrenUnchanged){// If there are no other effects in this tree, we need to flag this node as having one.
// Even though we're not going to use it for anything.
// Otherwise parents won't know that there are new children to propagate upwards.
markUpdate(workInProgress);}else{// If children might have changed, we have to add them all to the set.
appendAllChildren(newInstance,workInProgress);}}};updateHostText=function(current,workInProgress,oldText,newText){if(oldText!==newText){// If the text content differs, we'll create a new text instance for it.
var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress);// We'll have to mark it as having an effect, even though we won't use the effect for anything.
// This lets the parents know that at least one of their children has changed.
markUpdate(workInProgress);}};}else{invariant(false,'Persistent reconciler is disabled.');}}else{if(enableNoopReconciler){// No host operations
updateHostContainer=function(workInProgress){// Noop
};updateHostComponent=function(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// Noop
};updateHostText=function(current,workInProgress,oldText,newText){// Noop
};}else{invariant(false,'Noop reconciler is disabled.');}}function completeWork(current,workInProgress,renderExpirationTime){// Get the latest props.
var newProps=workInProgress.pendingProps;if(newProps===null){newProps=workInProgress.memoizedProps;}else if(workInProgress.expirationTime!==Never||renderExpirationTime===Never){// Reset the pending props, unless this was a down-prioritization.
workInProgress.pendingProps=null;}switch(workInProgress.tag){case FunctionalComponent:return null;case ClassComponent:{// We are leaving this subtree, so pop context if any.
popContextProvider(workInProgress);return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
popHydrationState(workInProgress);// This resets the hacky state to fix isMounted before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag&=~Placement;}updateHostContainer(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef(workInProgress);}}else{if(!newProps){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on we want to add then top->down or
// bottom->up. Top->down is faster in IE11.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,_currentHostContext)){// If changes to the hydrated node needs to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var _instance=createInstance(type,newProps,rootContainerInstance,_currentHostContext,workInProgress);appendAllChildren(_instance,workInProgress);// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(_instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=_instance;}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef(workInProgress);}}return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _rootContainerInstance=getRootHostContainer();var _currentHostContext2=getHostContext();var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext2,workInProgress);}}return null;}case CallComponent:return moveCallToHandlerPhase(current,workInProgress,renderExpirationTime);case CallHandlerPhase:// Reset the tag to now be a first phase call.
workInProgress.tag=CallComponent;return null;case ReturnComponent:// Does nothing.
return null;case Fragment:return null;case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);return null;// Error cases
case IndeterminateComponent:invariant(false,'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');// eslint-disable-next-line no-fallthrough
default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}return{completeWork:completeWork};};var invokeGuardedCallback$2=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError$1=ReactErrorUtils.hasCaughtError;var clearCaughtError$1=ReactErrorUtils.clearCaughtError;var ReactFiberCommitWork=function(config,captureError){var getPublicInstance=config.getPublicInstance,mutation=config.mutation,persistence=config.persistence;var callComponentWillUnmountWithTimer=function(current,instance){startPhaseTimer(current,'componentWillUnmount');instance.props=current.memoizedProps;instance.state=current.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current,instance){{invokeGuardedCallback$2(null,callComponentWillUnmountWithTimer,null,current,instance);if(hasCaughtError$1()){var unmountError=clearCaughtError$1();captureError(current,unmountError);}}}function safelyDetachRef(current){var ref=current.ref;if(ref!==null){{invokeGuardedCallback$2(null,ref,null,null);if(hasCaughtError$1()){var refError=clearCaughtError$1();captureError(current,refError);}}}}function commitLifeCycles(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current===null){startPhaseTimer(finishedWork,'componentDidMount');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidMount();stopPhaseTimer();}else{var prevProps=current.memoizedProps;var prevState=current.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidUpdate(prevProps,prevState);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){commitCallbacks(updateQueue,instance);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=finishedWork.child!==null?finishedWork.child.stateNode:null;commitCallbacks(_updateQueue,_instance);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork);}return;}case HostText:{// We have no life-cycles associated with text.
return;}case HostPortal:{// We have no life-cycles associated with portals.
return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;switch(finishedWork.tag){case HostComponent:ref(getPublicInstance(instance));break;default:ref(instance);}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){currentRef(null);}}// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current){if(typeof onCommitUnmount==='function'){onCommitUnmount(current);}switch(current.tag){case ClassComponent:{safelyDetachRef(current);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,instance);}return;}case HostComponent:{safelyDetachRef(current);return;}case CallComponent:{commitNestedUnmounts(current.stateNode);return;}case HostPortal:{// TODO: this is recursive.
// We are also not using this parent because
// the portal will get pushed immediately.
if(enableMutatingReconciler&&mutation){unmountHostComponents(current);}else if(enablePersistentReconciler&&persistence){emptyPortalContainer(current);}return;}}}function commitNestedUnmounts(root){// While we're inside a removed host node we don't want to call
// removeChild on the inner nodes because they're removed by the top
// call anyway. We also want to call componentWillUnmount on all
// composites before this host node is removed from the tree. Therefore
var node=root;while(true){commitUnmount(node);// Visit children because they may contain more composite or host nodes.
// Skip portals because commitUnmount() currently visits them recursively.
if(node.child!==null&&(// If we use mutation we drill down into portals using commitUnmount above.
// If we don't use mutation we drill down into portals here instead.
!mutation||node.tag!==HostPortal)){node.child['return']=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node['return']===null||node['return']===root){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function detachFiber(current){// Cut off the return pointers to disconnect it from the tree. Ideally, we
// should clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child. This child
// itself will be GC:ed when the parent updates the next time.
current['return']=null;current.child=null;if(current.alternate){current.alternate.child=null;current.alternate['return']=null;}}if(!mutation){var commitContainer=void 0;if(persistence){var replaceContainerChildren=persistence.replaceContainerChildren,createContainerChildSet=persistence.createContainerChildSet;var emptyPortalContainer=function(current){var portal=current.stateNode;var containerInfo=portal.containerInfo;var emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet);};commitContainer=function(finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{return;}case HostText:{return;}case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode;var containerInfo=portalOrRoot.containerInfo,_pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,_pendingChildren);return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}};}else{commitContainer=function(finishedWork){// Noop
};}if(enablePersistentReconciler||enableNoopReconciler){return{commitResetTextContent:function(finishedWork){},commitPlacement:function(finishedWork){},commitDeletion:function(current){// Detach refs and call componentWillUnmount() on the whole subtree.
commitNestedUnmounts(current);detachFiber(current);},commitWork:function(current,finishedWork){commitContainer(finishedWork);},commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else if(persistence){invariant(false,'Persistent reconciler is disabled.');}else{invariant(false,'Noop reconciler is disabled.');}}var commitMount=mutation.commitMount,commitUpdate=mutation.commitUpdate,resetTextContent=mutation.resetTextContent,commitTextUpdate=mutation.commitTextUpdate,appendChild=mutation.appendChild,appendChildToContainer=mutation.appendChildToContainer,insertBefore=mutation.insertBefore,insertInContainerBefore=mutation.insertInContainerBefore,removeChild=mutation.removeChild,removeChildFromContainer=mutation.removeChildFromContainer;function getHostParentFiber(fiber){var parent=fiber['return'];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent['return'];}invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node['return']===null||isHostParent(node['return'])){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.effectTag&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child['return']=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.effectTag&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){// Recursively insert all host nodes into the parent.
var parentFiber=getHostParentFiber(finishedWork);var parent=void 0;var isContainer=void 0;switch(parentFiber.tag){case HostComponent:parent=parentFiber.stateNode;isContainer=false;break;case HostRoot:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;default:invariant(false,'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent||node.tag===HostText){if(before){if(isContainer){insertInContainerBefore(parent,node.stateNode,before);}else{insertBefore(parent,node.stateNode,before);}}else{if(isContainer){appendChildToContainer(parent,node.stateNode);}else{appendChild(parent,node.stateNode);}}}else if(node.tag===HostPortal){// If the insertion itself is a portal, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node['return']===null||node['return']===finishedWork){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function unmountHostComponents(current){// We only have the top Fiber that was inserted but we need recurse down its
var node=current;// Each iteration, currentParent is populated with node's host parent if not
// currentParentIsValid.
var currentParentIsValid=false;var currentParent=void 0;var currentParentIsContainer=void 0;while(true){if(!currentParentIsValid){var parent=node['return'];findParent:while(true){!(parent!==null)?invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(parent.tag){case HostComponent:currentParent=parent.stateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent['return'];}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(node);// After all the children have unmounted, it is now safe to remove the
// node from the tree.
if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
}else if(node.tag===HostPortal){// When we go into a portal, it becomes the parent to remove from.
// We will reassign it back when we pop the portal on the way up.
currentParent=node.stateNode.containerInfo;// Visit children because portals might contain host components.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}else{commitUnmount(node);// Visit children because we may find more host components below.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node['return']===null||node['return']===current){return;}node=node['return'];if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
// Since we don't keep a stack of them, we will search for it.
currentParentIsValid=false;}}node.sibling['return']=node['return'];node=node.sibling;}}function commitDeletion(current){// Recursively delete all host nodes from the parent.
// Detach refs and call componentWillUnmount() on the whole subtree.
unmountHostComponents(current);detachFiber(current);}function commitWork(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork);}}return;}case HostText:{!(finishedWork.stateNode!==null)?invariant(false,'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'):void 0;var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitResetTextContent(current){resetTextContent(current.stateNode);}if(enableMutatingReconciler){return{commitResetTextContent:commitResetTextContent,commitPlacement:commitPlacement,commitDeletion:commitDeletion,commitWork:commitWork,commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else{invariant(false,'Mutating reconciler is disabled.');}};var NO_CONTEXT={};var ReactFiberHostContext=function(config){var getChildHostContext=config.getChildHostContext,getRootHostContext=config.getRootHostContext;var contextStackCursor=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){!(c!==NO_CONTEXT)?invariant(false,'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'):void 0;return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor.current);var nextContext=getChildHostContext(context,fiber.type,rootInstance);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);}function resetHostContainer(){contextStackCursor.current=NO_CONTEXT;rootInstanceStackCursor.current=NO_CONTEXT;}return{getHostContext:getHostContext,getRootHostContainer:getRootHostContainer,popHostContainer:popHostContainer,popHostContext:popHostContext,pushHostContainer:pushHostContainer,pushHostContext:pushHostContext,resetHostContainer:resetHostContainer};};var ReactFiberHydrationContext=function(config){var shouldSetTextContent=config.shouldSetTextContent,hydration=config.hydration;// If this doesn't have hydration mode.
if(!hydration){return{enterHydrationState:function(){return false;},resetHydrationState:function(){},tryToClaimNextHydratableInstance:function(){},prepareToHydrateHostInstance:function(){invariant(false,'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},prepareToHydrateHostTextInstance:function(){invariant(false,'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},popHydrationState:function(fiber){return false;}};}var canHydrateInstance=hydration.canHydrateInstance,canHydrateTextInstance=hydration.canHydrateTextInstance,getNextHydratableSibling=hydration.getNextHydratableSibling,getFirstHydratableChild=hydration.getFirstHydratableChild,hydrateInstance=hydration.hydrateInstance,hydrateTextInstance=hydration.hydrateTextInstance,didNotMatchHydratedContainerTextInstance=hydration.didNotMatchHydratedContainerTextInstance,didNotMatchHydratedTextInstance=hydration.didNotMatchHydratedTextInstance,didNotHydrateContainerInstance=hydration.didNotHydrateContainerInstance,didNotHydrateInstance=hydration.didNotHydrateInstance,didNotFindHydratableContainerInstance=hydration.didNotFindHydratableContainerInstance,didNotFindHydratableContainerTextInstance=hydration.didNotFindHydratableContainerTextInstance,didNotFindHydratableInstance=hydration.didNotFindHydratableInstance,didNotFindHydratableTextInstance=hydration.didNotFindHydratableTextInstance;// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete['return']=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
// these children are not part of the reconciliation list of children.
// Even if we abort and rereconcile the children, that will try to hydrate
// again and the nodes are still in the host tree so these will be
// recreated.
if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag|=Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;}break;}default:return;}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;var instance=canHydrateInstance(nextInstance,type,props);if(instance!==null){fiber.stateNode=instance;return true;}return false;}case HostText:{var text=fiber.pendingProps;var textInstance=canHydrateTextInstance(nextInstance,text);if(textInstance!==null){fiber.stateNode=textInstance;return true;}return false;}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}if(!tryHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(nextInstance);if(!nextInstance||!tryHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(hydrationParentFiber,nextHydratableInstance);}hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function popToNextHostParent(fiber){var parent=fiber['return'];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot){parent=parent['return'];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them.
// TODO: Better heuristic.
if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return true;}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}return{enterHydrationState:enterHydrationState,resetHydrationState:resetHydrationState,tryToClaimNextHydratableInstance:tryToClaimNextHydratableInstance,prepareToHydrateHostInstance:prepareToHydrateHostInstance,prepareToHydrateHostTextInstance:prepareToHydrateHostTextInstance,popHydrationState:popHydrationState};};// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation={debugTool:null};var ReactFiberInstrumentation_1=ReactFiberInstrumentation;var defaultShowDialog=function(capturedError){return true;};var showDialog=defaultShowDialog;function logCapturedError(capturedError){var logError=showDialog(capturedError);// Allow injected showDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}var error=capturedError.error;var suppressLogging=error&&error.suppressReactErrorLogging;if(suppressLogging){return;}{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;var componentNameMessage=componentName?'The above error occurred in the <'+componentName+'> component:':'The above error occurred in one of your React components:';var errorBoundaryMessage=void 0;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
if(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage='React will try to recreate this component tree from scratch '+('using the error boundary you provided, '+errorBoundaryName+'.');}else{errorBoundaryMessage='This error was initially handled by the error boundary '+errorBoundaryName+'.\n'+'Recreating the tree from scratch failed so React will unmount the tree.';}}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=''+componentNameMessage+componentStack+'\n\n'+(''+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console.error(combinedMessage);}}var invokeGuardedCallback$1=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError=ReactErrorUtils.hasCaughtError;var clearCaughtError=ReactErrorUtils.clearCaughtError;{var didWarnAboutStateTransition=false;var didWarnSetStateChildContext=false;var didWarnStateUpdateForUnmountedComponent={};var warnAboutUpdateOnUnmounted=function(fiber){var componentName=getComponentName(fiber)||'ReactClass';if(didWarnStateUpdateForUnmountedComponent[componentName]){return;}warning(false,'Can only update a mounted or mounting '+'component. This usually means you called setState, replaceState, '+'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease '+'check the code for the %s component.',componentName);didWarnStateUpdateForUnmountedComponent[componentName]=true;};var warnAboutInvalidUpdates=function(instance){switch(ReactDebugCurrentFiber.phase){case'getChildContext':if(didWarnSetStateChildContext){return;}warning(false,'setState(...): Cannot call setState() inside getChildContext()');didWarnSetStateChildContext=true;break;case'render':if(didWarnAboutStateTransition){return;}warning(false,'Cannot update during an existing state transition (such as within '+"`render` or another component's constructor). Render methods should "+'be a pure function of props and state; constructor side-effects are '+'an anti-pattern, but can be moved to `componentWillMount`.');didWarnAboutStateTransition=true;break;}};}var ReactFiberScheduler=function(config){var hostContext=ReactFiberHostContext(config);var hydrationContext=ReactFiberHydrationContext(config);var popHostContainer=hostContext.popHostContainer,popHostContext=hostContext.popHostContext,resetHostContainer=hostContext.resetHostContainer;var _ReactFiberBeginWork=ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber),beginWork=_ReactFiberBeginWork.beginWork,beginFailedWork=_ReactFiberBeginWork.beginFailedWork;var _ReactFiberCompleteWo=ReactFiberCompleteWork(config,hostContext,hydrationContext),completeWork=_ReactFiberCompleteWo.completeWork;var _ReactFiberCommitWork=ReactFiberCommitWork(config,captureError),commitResetTextContent=_ReactFiberCommitWork.commitResetTextContent,commitPlacement=_ReactFiberCommitWork.commitPlacement,commitDeletion=_ReactFiberCommitWork.commitDeletion,commitWork=_ReactFiberCommitWork.commitWork,commitLifeCycles=_ReactFiberCommitWork.commitLifeCycles,commitAttachRef=_ReactFiberCommitWork.commitAttachRef,commitDetachRef=_ReactFiberCommitWork.commitDetachRef;var now=config.now,scheduleDeferredCallback=config.scheduleDeferredCallback,cancelDeferredCallback=config.cancelDeferredCallback,useSyncScheduling=config.useSyncScheduling,prepareForCommit=config.prepareForCommit,resetAfterCommit=config.resetAfterCommit;// Represents the current time in ms.
var startTime=now();var mostRecentCurrentTime=msToExpirationTime(0);// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
var expirationContext=NoWork;var isWorking=false;// The next work in progress fiber that we're currently working on.
var nextUnitOfWork=null;var nextRoot=null;// The time at which we're currently rendering work.
var nextRenderExpirationTime=NoWork;// The next fiber with an effect that we're currently committing.
var nextEffect=null;// Keep track of which fibers have captured an error that need to be handled.
// Work is removed from this collection after componentDidCatch is called.
var capturedErrors=null;// Keep track of which fibers have failed during the current batch of work.
// This is a different set than capturedErrors, because it is not reset until
// the end of the batch. This is needed to propagate errors correctly if a
// subtree fails more than once.
var failedBoundaries=null;// Error boundaries that captured an error during the current commit.
var commitPhaseBoundaries=null;var firstUncaughtError=null;var didFatal=false;var isCommitting=false;var isUnmounting=false;// Used for performance tracking.
var interruptedBy=null;function resetContextStack(){// Reset the stack
reset$1();// Reset the cursors
resetContext();resetHostContainer();}function commitAllHostEffects(){while(nextEffect!==null){{ReactDebugCurrentFiber.setCurrentFiber(nextEffect);}recordEffect();var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current=nextEffect.alternate;if(current!==null){commitDetachRef(current);}}// The following switch statement is only concerned about placement,
// updates, and deletions. To avoid needing to add a case for every
// possible bitmap value, we remove the secondary effects from the
// effect tag and switch on that value.
var primaryEffectTag=effectTag&~(Callback|Err|ContentReset|Ref|PerformedWork);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted
// does and isMounted is deprecated anyway so we should be able
// to kill this.
nextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement
commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
nextEffect.effectTag&=~Placement;// Update
var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Update:{var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Deletion:{isUnmounting=true;commitDeletion(nextEffect);isUnmounting=false;break;}}nextEffect=nextEffect.nextEffect;}{ReactDebugCurrentFiber.resetCurrentFiber();}}function commitAllLifeCycles(){while(nextEffect!==null){var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current=nextEffect.alternate;commitLifeCycles(current,nextEffect);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}if(effectTag&Err){recordEffect();commitErrorHandling(nextEffect);}var next=nextEffect.nextEffect;// Ensure that we clean these up so that we don't accidentally keep them.
// I'm not actually sure this matters because we can't reset firstEffect
// and lastEffect since they're on every node, not just the effectful
// ones. So we have to clean everything as we reuse nodes anyway.
nextEffect.nextEffect=null;// Ensure that we reset the effectTag here so that we can rely on effect
// tags to reason about the current life-cycle.
nextEffect=next;}}function commitRoot(finishedWork){// We keep track of this so that captureError can collect any boundaries
// that capture an error during the commit phase. The reason these aren't
// local to this function is because errors that occur during cWU are
// captured elsewhere, to prevent the unmount from being interrupted.
isWorking=true;isCommitting=true;startCommitTimer();var root=finishedWork.stateNode;!(root.current!==finishedWork)?invariant(false,'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'):void 0;root.isReadyForCommit=false;// Reset this to null before calling lifecycles
ReactCurrentOwner.current=null;var firstEffect=void 0;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
// the root has an effect, we need to add it to the end of the list. The
// resulting list is the set that would belong to the root's parent, if
// it had one; that is, all the effects in the tree including the root.
if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.
firstEffect=finishedWork.firstEffect;}prepareForCommit();// Commit all the side-effects within a tree. We'll do this in two passes.
// The first pass performs all the host insertions, updates, deletions and
// ref unmounts.
nextEffect=firstEffect;startCommitHostEffectsTimer();while(nextEffect!==null){var didError=false;var _error=void 0;{invokeGuardedCallback$1(null,commitAllHostEffects,null);if(hasCaughtError()){didError=true;_error=clearCaughtError();}}if(didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitHostEffectsTimer();resetAfterCommit();// The work-in-progress tree is now the current tree. This must come after
// the first pass of the commit phase, so that the previous tree is still
// current during componentWillUnmount, but before the second pass, so that
// the finished work is current during componentDidMount/Update.
root.current=finishedWork;// In the second pass we'll perform all life-cycles and ref callbacks.
// Life-cycles happen as a separate pass so that all placements, updates,
// and deletions in the entire tree have already been invoked.
// This pass also triggers any renderer-specific initial effects.
nextEffect=firstEffect;startCommitLifeCyclesTimer();while(nextEffect!==null){var _didError=false;var _error2=void 0;{invokeGuardedCallback$1(null,commitAllLifeCycles,null);if(hasCaughtError()){_didError=true;_error2=clearCaughtError();}}if(_didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error2);if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}isCommitting=false;isWorking=false;stopCommitLifeCyclesTimer();stopCommitTimer();if(typeof onCommitRoot==='function'){onCommitRoot(finishedWork.stateNode);}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);}// If we caught any errors during this commit, schedule their boundaries
// to update.
if(commitPhaseBoundaries){commitPhaseBoundaries.forEach(scheduleErrorRecovery);commitPhaseBoundaries=null;}if(firstUncaughtError!==null){var _error3=firstUncaughtError;firstUncaughtError=null;onUncaughtError(_error3);}var remainingTime=root.current.expirationTime;if(remainingTime===NoWork){capturedErrors=null;failedBoundaries=null;}return remainingTime;}function resetExpirationTime(workInProgress,renderTime){if(renderTime!==Never&&workInProgress.expirationTime===Never){// The children of this component are hidden. Don't bubble their
// expiration times.
return;}// Check for pending updates.
var newExpirationTime=getUpdateExpirationTime(workInProgress);// TODO: Calls need to visit stateNode
// Bubble up the earliest expiration time.
var child=workInProgress.child;while(child!==null){if(child.expirationTime!==NoWork&&(newExpirationTime===NoWork||newExpirationTime>child.expirationTime)){newExpirationTime=child.expirationTime;}child=child.sibling;}workInProgress.expirationTime=newExpirationTime;}function completeUnitOfWork(workInProgress){while(true){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=completeWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}var returnFiber=workInProgress['return'];var siblingFiber=workInProgress.sibling;resetExpirationTime(workInProgress,nextRenderExpirationTime);if(next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come
// back here again.
return next;}if(returnFiber!==null){// Append all the effects of the subtree and this fiber onto the effect
// list of the parent. The completion order of the children affects the
// side-effect order.
if(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
// side-effects. We can perform certain side-effects earlier if
// needed, by doing multiple passes over the effect list. We don't want
// to schedule our own side-effect on our own list because if end up
// reusing children we'll schedule this effect onto itself since we're
// at the end.
var effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect list.
// PerformedWork effect is read by React DevTools but shouldn't be committed.
if(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else{returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{// We've reached the root.
var root=workInProgress.stateNode;root.isReadyForCommit=true;return null;}}// Without this explicit null return Flow complains of invalid return type
// TODO Remove the above while(true) loop
// eslint-disable-next-line no-unreachable
return null;}function performUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function performFailedUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginFailedWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function workLoop(expirationTime){if(capturedErrors!==null){// If there are unhandled errors, switch to the slow work loop.
// TODO: How to avoid this check in the fast path? Maybe the renderer
// could keep track of which roots have unhandled errors and call a
// forked version of renderRoot.
slowWorkLoopThatChecksForFailedWork(expirationTime);return;}if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}function slowWorkLoopThatChecksForFailedWork(expirationTime){if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}}function renderRootCatchBlock(root,failedWork,boundary,expirationTime){// We're going to restart the error boundary that captured the error.
// Conceptually, we're unwinding the stack. We need to unwind the
// context stack, too.
unwindContexts(failedWork,boundary);// Restart the error boundary using a forked version of
// performUnitOfWork that deletes the boundary's children. The entire
// failed subree will be unmounted. During the commit phase, a special
// lifecycle method is called on the error boundary, which triggers
// a re-render.
nextUnitOfWork=performFailedUnitOfWork(boundary);// Continue working.
workLoop(expirationTime);}function renderRoot(root,expirationTime){!!isWorking?invariant(false,'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isWorking=true;// We're about to mutate the work-in-progress tree. If the root was pending
// commit, it no longer is: we'll need to complete it again.
root.isReadyForCommit=false;// Check if we're starting from a fresh stack, or if we're resuming from
// previously yielded work.
if(root!==nextRoot||expirationTime!==nextRenderExpirationTime||nextUnitOfWork===null){// Reset the stack and start working from the root.
resetContextStack();nextRoot=root;nextRenderExpirationTime=expirationTime;nextUnitOfWork=createWorkInProgress(nextRoot.current,null,expirationTime);}startWorkLoopTimer(nextUnitOfWork);var didError=false;var error=null;{invokeGuardedCallback$1(null,workLoop,null,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();}}// An error was thrown during the render phase.
while(didError){if(didFatal){// This was a fatal error. Don't attempt to recover from it.
firstUncaughtError=error;break;}var failedWork=nextUnitOfWork;if(failedWork===null){// An error was thrown but there's no current unit of work. This can
// happen during the commit phase if there's a bug in the renderer.
didFatal=true;continue;}// "Capture" the error by finding the nearest boundary. If there is no
// error boundary, we use the root.
var boundary=captureError(failedWork,error);!(boundary!==null)?invariant(false,'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didFatal){// The error we just captured was a fatal error. This happens
// when the error propagates to the root more than once.
continue;}didError=false;error=null;{invokeGuardedCallback$1(null,renderRootCatchBlock,null,root,failedWork,boundary,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();continue;}}// We're finished working. Exit the error loop.
break;}var uncaughtError=firstUncaughtError;// We're done performing work. Time to clean up.
stopWorkLoopTimer(interruptedBy);interruptedBy=null;isWorking=false;didFatal=false;firstUncaughtError=null;if(uncaughtError!==null){onUncaughtError(uncaughtError);}return root.isReadyForCommit?root.current.alternate:null;}// Returns the boundary that captured the error, or null if the error is ignored
function captureError(failedWork,error){// It is no longer valid because we exited the user code.
ReactCurrentOwner.current=null;{ReactDebugCurrentFiber.resetCurrentFiber();}// Search for the nearest error boundary.
var boundary=null;// Passed to logCapturedError()
var errorBoundaryFound=false;var willRetry=false;var errorBoundaryName=null;// Host containers are a special case. If the failed work itself is a host
// container, then it acts as its own boundary. In all other cases, we
// ignore the work itself and only search through the parents.
if(failedWork.tag===HostRoot){boundary=failedWork;if(isFailedBoundary(failedWork)){// If this root already failed, there must have been an error when
// attempting to unmount it. This is a worst-case scenario and
// should only be possible if there's a bug in the renderer.
didFatal=true;}}else{var node=failedWork['return'];while(node!==null&&boundary===null){if(node.tag===ClassComponent){var instance=node.stateNode;if(typeof instance.componentDidCatch==='function'){errorBoundaryFound=true;errorBoundaryName=getComponentName(node);// Found an error boundary!
boundary=node;willRetry=true;}}else if(node.tag===HostRoot){// Treat the root like a no-op error boundary
boundary=node;}if(isFailedBoundary(node)){// This boundary is already in a failed state.
// If we're currently unmounting, that means this error was
// thrown while unmounting a failed subtree. We should ignore
// the error.
if(isUnmounting){return null;}// If we're in the commit phase, we should check to see if
// this boundary already captured an error during this commit.
// This case exists because multiple errors can be thrown during
// a single commit without interruption.
if(commitPhaseBoundaries!==null&&(commitPhaseBoundaries.has(node)||node.alternate!==null&&commitPhaseBoundaries.has(node.alternate))){// If so, we should ignore this error.
return null;}// The error should propagate to the next boundary -— we keep looking.
boundary=null;willRetry=false;}node=node['return'];}}if(boundary!==null){// Add to the collection of failed boundaries. This lets us know that
// subsequent errors in this subtree should propagate to the next boundary.
if(failedBoundaries===null){failedBoundaries=new Set();}failedBoundaries.add(boundary);// This method is unsafe outside of the begin and complete phases.
// We might be in the commit phase when an error is captured.
// The risk is that the return path from this Fiber may not be accurate.
// That risk is acceptable given the benefit of providing users more context.
var _componentStack=getStackAddendumByWorkInProgressFiber(failedWork);var _componentName=getComponentName(failedWork);// Add to the collection of captured errors. This is stored as a global
// map of errors and their component stack location keyed by the boundaries
// that capture them. We mostly use this Map as a Set; it's a Map only to
// avoid adding a field to Fiber to store the error.
if(capturedErrors===null){capturedErrors=new Map();}var capturedError={componentName:_componentName,componentStack:_componentStack,error:error,errorBoundary:errorBoundaryFound?boundary.stateNode:null,errorBoundaryFound:errorBoundaryFound,errorBoundaryName:errorBoundaryName,willRetry:willRetry};capturedErrors.set(boundary,capturedError);try{logCapturedError(capturedError);}catch(e){// Prevent cycle if logCapturedError() throws.
// A cycle may still occur if logCapturedError renders a component that throws.
var suppressLogging=e&&e.suppressReactErrorLogging;if(!suppressLogging){console.error(e);}}// If we're in the commit phase, defer scheduling an update on the
// boundary until after the commit is complete
if(isCommitting){if(commitPhaseBoundaries===null){commitPhaseBoundaries=new Set();}commitPhaseBoundaries.add(boundary);}else{// Otherwise, schedule an update now.
// TODO: Is this actually necessary during the render phase? Is it
// possible to unwind and continue rendering at the same priority,
// without corrupting internal state?
scheduleErrorRecovery(boundary);}return boundary;}else if(firstUncaughtError===null){// If no boundary is found, we'll need to throw the error
firstUncaughtError=error;}return null;}function hasCapturedError(fiber){// TODO: capturedErrors should store the boundary instance, to avoid needing
// to check the alternate.
return capturedErrors!==null&&(capturedErrors.has(fiber)||fiber.alternate!==null&&capturedErrors.has(fiber.alternate));}function isFailedBoundary(fiber){// TODO: failedBoundaries should store the boundary instance, to avoid
// needing to check the alternate.
return failedBoundaries!==null&&(failedBoundaries.has(fiber)||fiber.alternate!==null&&failedBoundaries.has(fiber.alternate));}function commitErrorHandling(effectfulFiber){var capturedError=void 0;if(capturedErrors!==null){capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);if(capturedError==null){if(effectfulFiber.alternate!==null){effectfulFiber=effectfulFiber.alternate;capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);}}}!(capturedError!=null)?invariant(false,'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(effectfulFiber.tag){case ClassComponent:var instance=effectfulFiber.stateNode;var info={componentStack:capturedError.componentStack};// Allow the boundary to handle the error, usually by scheduling
// an update to itself
instance.componentDidCatch(capturedError.error,info);return;case HostRoot:if(firstUncaughtError===null){firstUncaughtError=capturedError.error;}return;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}}function unwindContexts(from,to){var node=from;while(node!==null){switch(node.tag){case ClassComponent:popContextProvider(node);break;case HostComponent:popHostContext(node);break;case HostRoot:popHostContainer(node);break;case HostPortal:popHostContainer(node);break;}if(node===to||node.alternate===to){stopFailedWorkTimer(node);break;}else{stopWorkTimer(node);}node=node['return'];}}function computeAsyncExpiration(){// Given the current clock time, returns an expiration time. We use rounding
// to batch like updates together.
// Should complete within ~1000ms. 1200ms max.
var currentTime=recalculateCurrentTime();var expirationMs=1000;var bucketSizeMs=200;return computeExpirationBucket(currentTime,expirationMs,bucketSizeMs);}function computeExpirationForFiber(fiber){var expirationTime=void 0;if(expirationContext!==NoWork){// An explicit expiration context was set;
expirationTime=expirationContext;}else if(isWorking){if(isCommitting){// Updates that occur during the commit phase should have sync priority
// by default.
expirationTime=Sync;}else{// Updates during the render phase should expire at the same time as
// the work that is being rendered.
expirationTime=nextRenderExpirationTime;}}else{// No explicit expiration context was set, and we're not currently
// performing work. Calculate a new expiration time.
if(useSyncScheduling&&!(fiber.internalContextTag&AsyncUpdates)){// This is a sync update
expirationTime=Sync;}else{// This is an async update
expirationTime=computeAsyncExpiration();}}return expirationTime;}function scheduleWork(fiber,expirationTime){return scheduleWorkImpl(fiber,expirationTime,false);}function checkRootNeedsClearing(root,fiber,expirationTime){if(!isWorking&&root===nextRoot&&expirationTime<nextRenderExpirationTime){// Restart the root from the top.
if(nextUnitOfWork!==null){// This is an interruption. (Used for performance tracking.)
interruptedBy=fiber;}nextRoot=null;nextUnitOfWork=null;nextRenderExpirationTime=NoWork;}}function scheduleWorkImpl(fiber,expirationTime,isErrorRecovery){recordScheduleUpdate();{if(!isErrorRecovery&&fiber.tag===ClassComponent){var instance=fiber.stateNode;warnAboutInvalidUpdates(instance);}}var node=fiber;while(node!==null){// Walk the parent path to the root and update each node's
// expiration time.
if(node.expirationTime===NoWork||node.expirationTime>expirationTime){node.expirationTime=expirationTime;}if(node.alternate!==null){if(node.alternate.expirationTime===NoWork||node.alternate.expirationTime>expirationTime){node.alternate.expirationTime=expirationTime;}}if(node['return']===null){if(node.tag===HostRoot){var root=node.stateNode;checkRootNeedsClearing(root,fiber,expirationTime);requestWork(root,expirationTime);checkRootNeedsClearing(root,fiber,expirationTime);}else{{if(!isErrorRecovery&&fiber.tag===ClassComponent){warnAboutUpdateOnUnmounted(fiber);}}return;}}node=node['return'];}}function scheduleErrorRecovery(fiber){scheduleWorkImpl(fiber,Sync,true);}function recalculateCurrentTime(){// Subtract initial time so it fits inside 32bits
var ms=now()-startTime;mostRecentCurrentTime=msToExpirationTime(ms);return mostRecentCurrentTime;}function deferredUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=computeAsyncExpiration();try{return fn();}finally{expirationContext=previousExpirationContext;}}function syncUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=Sync;try{return fn();}finally{expirationContext=previousExpirationContext;}}// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.
// Linked-list of roots
var firstScheduledRoot=null;var lastScheduledRoot=null;var callbackExpirationTime=NoWork;var callbackID=-1;var isRendering=false;var nextFlushedRoot=null;var nextFlushedExpirationTime=NoWork;var deadlineDidExpire=false;var hasUnhandledError=false;var unhandledError=null;var deadline=null;var isBatchingUpdates=false;var isUnbatchingUpdates=false;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=1000;var nestedUpdateCount=0;var timeHeuristicForUnitOfWork=1;function scheduleCallbackWithExpiration(expirationTime){if(callbackExpirationTime!==NoWork){// A callback is already scheduled. Check its expiration time (timeout).
if(expirationTime>callbackExpirationTime){// Existing callback has sufficient timeout. Exit.
return;}else{// Existing callback has insufficient timeout. Cancel and schedule a
// new one.
cancelDeferredCallback(callbackID);}// The request callback timer is already running. Don't start a new one.
}else{startRequestCallbackTimer();}// Compute a timeout for the given expiration time.
var currentMs=now()-startTime;var expirationMs=expirationTimeToMs(expirationTime);var timeout=expirationMs-currentMs;callbackExpirationTime=expirationTime;callbackID=scheduleDeferredCallback(performAsyncWork,{timeout:timeout});}// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root,expirationTime){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){invariant(false,'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');}// Add the root to the schedule.
// Check if this root is already part of the schedule.
if(root.nextScheduledRoot===null){// This root is not already scheduled. Add it.
root.remainingExpirationTime=expirationTime;if(lastScheduledRoot===null){firstScheduledRoot=lastScheduledRoot=root;root.nextScheduledRoot=root;}else{lastScheduledRoot.nextScheduledRoot=root;lastScheduledRoot=root;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;}}else{// This root is already scheduled, but its priority may have increased.
var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork||expirationTime<remainingExpirationTime){// Update the priority.
root.remainingExpirationTime=expirationTime;}}if(isRendering){// Prevent reentrancy. Remaining work will be scheduled at the end of
// the currently rendering batch.
return;}if(isBatchingUpdates){// Flush work at the end of the batch.
if(isUnbatchingUpdates){// ...unless we're inside unbatchedUpdates, in which case we should
// flush it now.
nextFlushedRoot=root;nextFlushedExpirationTime=Sync;performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);}return;}// TODO: Get rid of Sync and use current time?
if(expirationTime===Sync){performWork(Sync,null);}else{scheduleCallbackWithExpiration(expirationTime);}}function findHighestPriorityRoot(){var highestPriorityWork=NoWork;var highestPriorityRoot=null;if(lastScheduledRoot!==null){var previousScheduledRoot=lastScheduledRoot;var root=firstScheduledRoot;while(root!==null){var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork){// This root no longer has work. Remove it from the scheduler.
// TODO: This check is redudant, but Flow is confused by the branch
// below where we set lastScheduledRoot to null, even though we break
// from the loop right after.
!(previousScheduledRoot!==null&&lastScheduledRoot!==null)?invariant(false,'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(root===root.nextScheduledRoot){// This is the only root in the list.
root.nextScheduledRoot=null;firstScheduledRoot=lastScheduledRoot=null;break;}else if(root===firstScheduledRoot){// This is the first root in the list.
var next=root.nextScheduledRoot;firstScheduledRoot=next;lastScheduledRoot.nextScheduledRoot=next;root.nextScheduledRoot=null;}else if(root===lastScheduledRoot){// This is the last root in the list.
lastScheduledRoot=previousScheduledRoot;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;root.nextScheduledRoot=null;break;}else{previousScheduledRoot.nextScheduledRoot=root.nextScheduledRoot;root.nextScheduledRoot=null;}root=previousScheduledRoot.nextScheduledRoot;}else{if(highestPriorityWork===NoWork||remainingExpirationTime<highestPriorityWork){// Update the priority, if it's higher
highestPriorityWork=remainingExpirationTime;highestPriorityRoot=root;}if(root===lastScheduledRoot){break;}previousScheduledRoot=root;root=root.nextScheduledRoot;}}}// If the next root is the same as the previous root, this is a nested
// update. To prevent an infinite loop, increment the nested update count.
var previousFlushedRoot=nextFlushedRoot;if(previousFlushedRoot!==null&&previousFlushedRoot===highestPriorityRoot){nestedUpdateCount++;}else{// Reset whenever we switch roots.
nestedUpdateCount=0;}nextFlushedRoot=highestPriorityRoot;nextFlushedExpirationTime=highestPriorityWork;}function performAsyncWork(dl){performWork(NoWork,dl);}function performWork(minExpirationTime,dl){deadline=dl;// Keep working on roots until there's no more work, or until the we reach
// the deadline.
findHighestPriorityRoot();if(enableUserTimingAPI&&deadline!==null){var didExpire=nextFlushedExpirationTime<recalculateCurrentTime();stopRequestCallbackTimer(didExpire);}while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||nextFlushedExpirationTime<=minExpirationTime)&&!deadlineDidExpire){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);// Find the next highest priority work.
findHighestPriorityRoot();}// We're done flushing work. Either we ran out of time in this callback,
// or there's no more work left with sufficient priority.
// If we're inside a callback, set this to false since we just completed it.
if(deadline!==null){callbackExpirationTime=NoWork;callbackID=-1;}// If there's work left over, schedule a new callback.
if(nextFlushedExpirationTime!==NoWork){scheduleCallbackWithExpiration(nextFlushedExpirationTime);}// Clean-up.
deadline=null;deadlineDidExpire=false;nestedUpdateCount=0;if(hasUnhandledError){var _error4=unhandledError;unhandledError=null;hasUnhandledError=false;throw _error4;}}function performWorkOnRoot(root,expirationTime){!!isRendering?invariant(false,'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isRendering=true;// Check if this is async work or sync/expired work.
// TODO: Pass current time as argument to renderRoot, commitRoot
if(expirationTime<=recalculateCurrentTime()){// Flush sync work.
var finishedWork=root.finishedWork;if(finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(finishedWork);}else{root.finishedWork=null;finishedWork=renderRoot(root,expirationTime);if(finishedWork!==null){// We've completed the root. Commit it.
root.remainingExpirationTime=commitRoot(finishedWork);}}}else{// Flush async work.
var _finishedWork=root.finishedWork;if(_finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(_finishedWork);}else{root.finishedWork=null;_finishedWork=renderRoot(root,expirationTime);if(_finishedWork!==null){// We've completed the root. Check the deadline one more time
// before committing.
if(!shouldYield()){// Still time left. Commit the root.
root.remainingExpirationTime=commitRoot(_finishedWork);}else{// There's no time left. Mark this root as complete. We'll come
// back and commit it later.
root.finishedWork=_finishedWork;}}}}isRendering=false;}// When working on async work, the reconciler asks the renderer if it should
// yield execution. For DOM, we implement this with requestIdleCallback.
function shouldYield(){if(deadline===null){return false;}if(deadline.timeRemaining()>timeHeuristicForUnitOfWork){// Disregard deadline.didTimeout. Only expired work should be flushed
// during a timeout. This path is only hit for non-expired work.
return false;}deadlineDidExpire=true;return true;}// TODO: Not happy about this hook. Conceptually, renderRoot should return a
// tuple of (isReadyForCommit, didError, error)
function onUncaughtError(error){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// Unschedule this root so we don't work on it again until there's
// another update.
nextFlushedRoot.remainingExpirationTime=NoWork;if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates(fn,a){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return fn(a);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performWork(Sync,null);}}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn){if(isBatchingUpdates&&!isUnbatchingUpdates){isUnbatchingUpdates=true;try{return fn();}finally{isUnbatchingUpdates=false;}}return fn();}// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return syncUpdates(fn);}finally{isBatchingUpdates=previousIsBatchingUpdates;!!isRendering?invariant(false,'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'):void 0;performWork(Sync,null);}}return{computeAsyncExpiration:computeAsyncExpiration,computeExpirationForFiber:computeExpirationForFiber,scheduleWork:scheduleWork,batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,flushSync:flushSync,deferredUpdates:deferredUpdates};};{var didWarnAboutNestedUpdates=false;}// 0 is PROD, 1 is DEV.
// Might add PROFILE later.
function getContextForSubtree(parentComponent){if(!parentComponent){return emptyObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);return isContextProvider(fiber)?processChildContext(fiber,parentContext):parentContext;}var ReactFiberReconciler$1=function(config){var getPublicInstance=config.getPublicInstance;var _ReactFiberScheduler=ReactFiberScheduler(config),computeAsyncExpiration=_ReactFiberScheduler.computeAsyncExpiration,computeExpirationForFiber=_ReactFiberScheduler.computeExpirationForFiber,scheduleWork=_ReactFiberScheduler.scheduleWork,batchedUpdates=_ReactFiberScheduler.batchedUpdates,unbatchedUpdates=_ReactFiberScheduler.unbatchedUpdates,flushSync=_ReactFiberScheduler.flushSync,deferredUpdates=_ReactFiberScheduler.deferredUpdates;function scheduleTopLevelUpdate(current,element,callback){{if(ReactDebugCurrentFiber.phase==='render'&&ReactDebugCurrentFiber.current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;warning(false,'Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(ReactDebugCurrentFiber.current)||'Unknown');}}callback=callback===undefined?null:callback;{warning(callback===null||typeof callback==='function','render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}var expirationTime=void 0;// Check if the top-level element is an async wrapper component. If so,
// treat updates to the root as async. This is a bit weird but lets us
// avoid a separate `renderAsync` API.
if(enableAsyncSubtreeAPI&&element!=null&&element.type!=null&&element.type.prototype!=null&&element.type.prototype.unstable_isAsyncReactComponent===true){expirationTime=computeAsyncExpiration();}else{expirationTime=computeExpirationForFiber(current);}var update={expirationTime:expirationTime,partialState:{element:element},callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(current,update);scheduleWork(current,expirationTime);}function findHostInstance(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}return{createContainer:function(containerInfo,hydrate){return createFiberRoot(containerInfo,hydrate);},updateContainer:function(element,container,parentComponent,callback){// TODO: If this is a nested container, this won't be the root.
var current=container.current;{if(ReactFiberInstrumentation_1.debugTool){if(current.alternate===null){ReactFiberInstrumentation_1.debugTool.onMountContainer(container);}else if(element===null){ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);}else{ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);}}}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}scheduleTopLevelUpdate(current,element,callback);},batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,deferredUpdates:deferredUpdates,flushSync:flushSync,getPublicRootInstance:function(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}},findHostInstance:findHostInstance,findHostInstanceWithNoPortals:function(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},injectIntoDevTools:function(devToolsConfig){var findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;return injectInternals(_assign({},devToolsConfig,{findHostInstanceByFiber:function(fiber){return findHostInstance(fiber);},findFiberByHostInstance:function(instance){if(!findFiberByHostInstance){// Might not be implemented by the renderer.
return null;}return findFiberByHostInstance(instance);}}));}};};var ReactFiberReconciler$2=Object.freeze({default:ReactFiberReconciler$1});var ReactFiberReconciler$3=ReactFiberReconciler$2&&ReactFiberReconciler$1||ReactFiberReconciler$2;// TODO: bundle Flow types with the package.
// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler=ReactFiberReconciler$3['default']?ReactFiberReconciler$3['default']:ReactFiberReconciler$3;function createPortal$1(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}// TODO: this is special because it gets imported during build.
var ReactVersion='16.2.0';// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.
{if(ExecutionEnvironment.canUseDOM&&typeof requestAnimationFrame!=='function'){warning(false,'React depends on requestAnimationFrame. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}var hasNativePerformanceNow=typeof performance==='object'&&typeof performance.now==='function';var now=void 0;if(hasNativePerformanceNow){now=function(){return performance.now();};}else{now=function(){return Date.now();};}// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC=void 0;var cIC=void 0;if(!ExecutionEnvironment.canUseDOM){rIC=function(frameCallback){return setTimeout(function(){frameCallback({timeRemaining:function(){return Infinity;}});});};cIC=function(timeoutID){clearTimeout(timeoutID);};}else if(typeof requestIdleCallback!=='function'||typeof cancelIdleCallback!=='function'){// Polyfill requestIdleCallback and cancelIdleCallback
var scheduledRICCallback=null;var isIdleScheduled=false;var timeoutTime=-1;var isAnimationFrameScheduled=false;var frameDeadline=0;// We start out assuming that we run at 30fps but then the heuristic tracking
// will adjust this value to a faster fps if we get more frequent animation
// frames.
var previousFrameTime=33;var activeFrameTime=33;var frameDeadlineObject;if(hasNativePerformanceNow){frameDeadlineObject={didTimeout:false,timeRemaining:function(){// We assume that if we have a performance timer that the rAF callback
// gets a performance timer value. Not sure if this is always true.
var remaining=frameDeadline-performance.now();return remaining>0?remaining:0;}};}else{frameDeadlineObject={didTimeout:false,timeRemaining:function(){// Fallback to Date.now()
var remaining=frameDeadline-Date.now();return remaining>0?remaining:0;}};}// We use the postMessage trick to defer idle work until after the repaint.
var messageKey='__reactIdleCallback$'+Math.random().toString(36).slice(2);var idleTick=function(event){if(event.source!==window||event.data!==messageKey){return;}isIdleScheduled=false;var currentTime=now();if(frameDeadline-currentTime<=0){// There's no time left in this idle period. Check if the callback has
// a timeout and whether it's been exceeded.
if(timeoutTime!==-1&&timeoutTime<=currentTime){// Exceeded the timeout. Invoke the callback even though there's no
// time left.
frameDeadlineObject.didTimeout=true;}else{// No timeout.
if(!isAnimationFrameScheduled){// Schedule another animation callback so we retry later.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}// Exit without invoking the callback.
return;}}else{// There's still time left in this idle period.
frameDeadlineObject.didTimeout=false;}timeoutTime=-1;var callback=scheduledRICCallback;scheduledRICCallback=null;if(callback!==null){callback(frameDeadlineObject);}};// Assumes that we have addEventListener in this environment. Might need
// something better for old IE.
window.addEventListener('message',idleTick,false);var animationTick=function(rafTime){isAnimationFrameScheduled=false;var nextFrameTime=rafTime-frameDeadline+activeFrameTime;if(nextFrameTime<activeFrameTime&&previousFrameTime<activeFrameTime){if(nextFrameTime<8){// Defensive coding. We don't support higher frame rates than 120hz.
// If we get lower than that, it is probably a bug.
nextFrameTime=8;}// If one frame goes long, then the next one can be short to catch up.
// If two frames are short in a row, then that's an indication that we
// actually have a higher frame rate than what we're currently optimizing.
// We adjust our heuristic dynamically accordingly. For example, if we're
// running on 120hz display or 90hz VR display.
// Take the max of the two in case one of them was an anomaly due to
// missed frame deadlines.
activeFrameTime=nextFrameTime<previousFrameTime?previousFrameTime:nextFrameTime;}else{previousFrameTime=nextFrameTime;}frameDeadline=rafTime+activeFrameTime;if(!isIdleScheduled){isIdleScheduled=true;window.postMessage(messageKey,'*');}};rIC=function(callback,options){// This assumes that we only schedule one callback at a time because that's
// how Fiber uses it.
scheduledRICCallback=callback;if(options!=null&&typeof options.timeout==='number'){timeoutTime=now()+options.timeout;}if(!isAnimationFrameScheduled){// If rAF didn't already schedule one, we need to schedule a frame.
// TODO: If this rAF doesn't materialize because the browser throttles, we
// might want to still have setTimeout trigger rIC as a backup to ensure
// that we keep performing work.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}return 0;};cIC=function(){scheduledRICCallback=null;isIdleScheduled=false;timeoutTime=-1;};}else{rIC=window.requestIdleCallback;cIC=window.cancelIdleCallback;}/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var lowPriorityWarning=function(){};{var printWarning=function(format){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});if(typeof console!=='undefined'){console.warn(message);}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
throw new Error(message);}catch(x){}};lowPriorityWarning=function(condition,format){if(format===undefined){throw new Error('`warning(condition, format, ...args)` requires a warning '+'message argument');}if(!condition){for(var _len2=arguments.length,args=Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){args[_key2-2]=arguments[_key2];}printWarning.apply(undefined,[format].concat(args));}};}var lowPriorityWarning$1=lowPriorityWarning;// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(validatedAttributeNameCache.hasOwnProperty(attributeName)){return true;}if(illegalAttributeNameCache.hasOwnProperty(attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{warning(false,'Invalid attribute name: `%s`',attributeName);}return false;}// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo,value){return value==null||propertyInfo.hasBooleanValue&&!value||propertyInfo.hasNumericValue&&isNaN(value)||propertyInfo.hasPositiveNumericValue&&value<1||propertyInfo.hasOverloadedBooleanValue&&value===false;}/**
 * Operations for dealing with DOM properties.
 */ /**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected){{var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod||propertyInfo.mustUseProperty){return node[propertyInfo.propertyName];}else{var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.hasOverloadedBooleanValue){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldIgnoreValue(propertyInfo,expected)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldIgnoreValue(propertyInfo,expected)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.hasBooleanValue){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldIgnoreValue(propertyInfo,expected)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value){var propertyInfo=getPropertyInfo(name);if(propertyInfo&&shouldSetAttribute(name,value)){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,value);}else if(shouldIgnoreValue(propertyInfo,value)){deleteValueForProperty(node,name);return;}else if(propertyInfo.mustUseProperty){// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyInfo.propertyName]=value;}else{var attributeName=propertyInfo.attributeName;var namespace=propertyInfo.attributeNamespace;// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
if(namespace){node.setAttributeNS(namespace,attributeName,''+value);}else if(propertyInfo.hasBooleanValue||propertyInfo.hasOverloadedBooleanValue&&value===true){node.setAttribute(attributeName,'');}else{node.setAttribute(attributeName,''+value);}}}else{setValueForAttribute(node,name,shouldSetAttribute(name,value)?value:null);return;}{}}function setValueForAttribute(node,name,value){if(!isAttributeNameSafe(name)){return;}if(value==null){node.removeAttribute(name);}else{node.setAttribute(name,''+value);}{}}/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForAttribute(node,name){node.removeAttribute(name);}/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForProperty(node,name){var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,undefined);}else if(propertyInfo.mustUseProperty){var propName=propertyInfo.propertyName;if(propertyInfo.hasBooleanValue){node[propName]=false;}else{node[propName]='';}}else{node.removeAttribute(propertyInfo.attributeName);}}else{node.removeAttribute(name);}}var ReactControlledValuePropTypes={checkPropTypes:null};{var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function(props,propName,componentName){if(!props[propName]||hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function(props,propName,componentName){if(!props[propName]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props,getStack){checkPropTypes(propTypes,props,'prop',tagName,getStack);};}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$3=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var value=props.value;var checked=props.checked;var hostProps=_assign({// Make sure we set .type before any other properties (setting .value
// before .type means .value is lost in IE11 and below)
type:undefined,// Make sure we set .step before .value (setting .value before .step
// means .value is rounded on mount, based upon step precision)
step:undefined,// Make sure we set .min & .max before .value (to ensure proper order
// in corner cases such as min or max deriving from value, e.g. Issue #7170)
min:undefined,max:undefined},props,{defaultChecked:undefined,defaultValue:undefined,value:value!=null?value:node._wrapperState.initialValue,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props,getCurrentFiberStackAddendum$3);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){warning(false,'%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){warning(false,'%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnValueDefaultValue=true;}}var defaultValue=props.defaultValue;var node=element;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:props.value!=null?props.value:defaultValue,controlled:isControlled(props)};}function updateChecked(element,props){var node=element;var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked);}}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){warning(false,'A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){warning(false,'A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnControlledToUncontrolled=true;}}updateChecked(element,props);var value=props.value;if(value!=null){if(value===0&&node.value===''){node.value='0';// Note: IE9 reports a number inputs as 'text', so check props instead.
}else if(props.type==='number'){// Simulate `input.valueAsNumber`. IE9 does not support it
var valueAsNumber=parseFloat(node.value)||0;if(// eslint-disable-next-line
value!=valueAsNumber||// eslint-disable-next-line
value==valueAsNumber&&node.value!=value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else if(node.value!==''+value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else{if(props.value==null&&props.defaultValue!=null){// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
if(node.defaultValue!==''+props.defaultValue){node.defaultValue=''+props.defaultValue;}}if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props){var node=element;// Detach value from defaultValue. We won't do anything if we're working on
// submit or reset inputs as those values & defaultValues are linked. They
// are not resetable nodes so this operation doesn't matter and actually
// removes browser-default values (eg "Submit Query") when no value is
// provided.
switch(props.type){case'submit':case'reset':break;case'color':case'date':case'datetime':case'datetime-local':case'month':case'time':case'week':// This fixes the no-show issue on iOS Safari and Android Chrome:
// https://github.com/facebook/react/issues/7233
node.value='';node.value=node.defaultValue;break;default:node.value=node.value;break;}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}node.defaultChecked=!node.defaultChecked;node.defaultChecked=!node.defaultChecked;if(name!==''){node.name=name;}}function restoreControlledState$1(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode$1(otherNode);!otherProps?invariant(false,'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'):void 0;// We need update the tracked value on the named cousin since the value
// was changed but the input saw no event or value set
updateValueIfChanged(otherNode);// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}function flattenChildren(children){var content='';// Flatten children and warn if they aren't strings or numbers;
// invalid types are ignored.
// We can silently skip them because invalid DOM nesting warning
// catches these cases in Fiber.
React.Children.forEach(children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){content+=child;}});return content;}/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){// TODO (yungsters): Remove support for `selected` in <option>.
{warning(props.selected==null,'Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',props.value);}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$4=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerName$3();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){ReactControlledValuePropTypes.checkPropTypes('select',props,getCurrentFiberStackAddendum$4);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){warning(false,'The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){warning(false,'The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=''+propValue;var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}var value=props.value;node._wrapperState={initialValue:value!=null?value:props.defaultValue,wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){warning(false,'Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;// After the initial mount, we control selected-ness manually so don't pass
// this value down
node._wrapperState.initialValue=undefined;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$2(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$3(element,props){var node=element;!(props.dangerouslySetInnerHTML==null)?invariant(false,'`dangerouslySetInnerHTML` does not make sense on <textarea>.'):void 0;// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:''+node._wrapperState.initialValue});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props,getCurrentFiberStackAddendum$5);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){warning(false,'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValDefaultVal=true;}}var initialValue=props.value;// Only bother fetching default value if we're going to use it
if(initialValue==null){var defaultValue=props.defaultValue;// TODO (yungsters): Remove support for children content in <textarea>.
var children=props.children;if(children!=null){{warning(false,'Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}!(defaultValue==null)?invariant(false,'If you supply `defaultValue` on a <textarea>, do not pass children.'):void 0;if(Array.isArray(children)){!(children.length<=1)?invariant(false,'<textarea> can only have at most one child.'):void 0;children=children[0];}defaultValue=''+children;}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:''+initialValue};}function updateWrapper$1(element,props){var node=element;var value=props.value;if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=''+value;// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null){node.defaultValue=newValue;}}if(props.defaultValue!=null){node.defaultValue=props.defaultValue;}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){node.value=textContent;}}function restoreControlledState$3(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE$1='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE$1,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE$1;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE$1){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE$1;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp */ /**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};// SVG temp container for IE lacking innerHTML
var reusableSVGContainer=void 0;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
if(node.namespaceURI===Namespaces.svg&&!('innerHTML'in node)){reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}}else{node.innerHTML=html;}});/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}return(''+value).trim();}var warnValidStyle=emptyFunction;{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var warnHyphenatedStyleName=function(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported style property %s. Did you mean %s?%s',name,camelizeStyleName(name),getStack());};var warnBadVendoredStyleName=function(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported vendor-prefixed style property %s. Did you mean %s?%s',name,name.charAt(0).toUpperCase()+name.slice(1),getStack());};var warnStyleValueWithSemicolon=function(name,value,getStack){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;warning(false,"Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.%s',name,value.replace(badStyleValueWithSemicolonPattern,''),getStack());};var warnStyleValueIsNaN=function(name,value,getStack){if(warnedForNaNValue){return;}warnedForNaNValue=true;warning(false,'`NaN` is an invalid value for the `%s` css style property.%s',name,getStack());};var warnStyleValueIsInfinity=function(name,value,getStack){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;warning(false,'`Infinity` is an invalid value for the `%s` css style property.%s',name,getStack());};warnValidStyle=function(name,value,getStack){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name,getStack);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name,getStack);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value,getStack);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value,getStack);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value,getStack);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 */ /**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+hyphenateStyleName(styleName)+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles,getStack){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName],getStack);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=_assign({menuitem:true},omittedCloseTags);var HTML$1='__html';function assertValidProps(tag,props,getStack){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){!(props.children==null&&props.dangerouslySetInnerHTML==null)?invariant(false,'%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',tag,getStack()):void 0;}if(props.dangerouslySetInnerHTML!=null){!(props.children==null)?invariant(false,'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'):void 0;!(typeof props.dangerouslySetInnerHTML==='object'&&HTML$1 in props.dangerouslySetInnerHTML)?invariant(false,'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'):void 0;}{warning(props.suppressContentEditableWarning||!props.contentEditable||props.children==null,'A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.%s',getStack());}!(props.style==null||typeof props.style==='object')?invariant(false,'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s',getStack()):void 0;}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this whitelist too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}var ariaProperties={'aria-current':0,// state
'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;function getStackAddendum(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperty(tagName,name){if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){warning(false,'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s',name,getStackAddendum());warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){warning(false,'Invalid ARIA attribute `%s`. Did you mean `%s`?%s',name,correctName,getStackAddendum());warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){warning(false,'Unknown ARIA attribute `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum());warnedProperties[name]=true;return true;}}return true;}function warnInvalidARIAProps(type,props){var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){warning(false,'Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}else if(invalidProps.length>1){warning(false,'Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function getStackAddendum$1(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperties$1(type,props){if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.%s',type,getStackAddendum$1());}else{warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.%s',type,getStackAddendum$1());}}}// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite','class':'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime','default':'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',download:'download',draggable:'draggable',enctype:'encType','for':'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2','in':'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform','typeof':'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};function getStackAddendum$2(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}{var warnedProperties$1={};var hasOwnProperty$1=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on./;var INVALID_EVENT_NAME_REGEX=/^on[^A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var validateProperty$1=function(tagName,name,value,canUseEventSystem){if(hasOwnProperty$1.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}var lowerCasedName=name.toLowerCase();if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){warning(false,'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}// We can't rely on the event system being injected on the server.
if(canUseEventSystem){if(registrationNameModules.hasOwnProperty(name)){return true;}var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){warning(false,'Invalid event handler property `%s`. Did you mean `%s`?%s',name,registrationName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(EVENT_NAME_REGEX.test(name)){warning(false,'Unknown event handler property `%s`. It will be ignored.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we are in a server environment.
// So we can't tell if the event name is correct for sure, but we can filter
// out known bad ones like `onclick`. We can't suggest a specific replacement though.
if(INVALID_EVENT_NAME_REGEX.test(name)){warning(false,'Invalid event handler property `%s`. '+'React events use the camelCase naming convention, for example `onClick`.%s',name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='innerhtml'){warning(false,'Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){warning(false,'The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){warning(false,'Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.%s',typeof value,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){warning(false,'Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}var isReserved=isReservedProp(name);// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){warning(false,'Invalid DOM property `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
warning(false,'React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.%s',name,lowerCasedName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&!shouldAttributeAcceptBooleanValue(name)){if(value){warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.%s',value,name,name,value,name,getStackAddendum$2());}else{warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',value,name,name,value,name,name,name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(!shouldSetAttribute(name,value)){warnedProperties$1[name]=true;return false;}return true;};}var warnUnknownProperties=function(type,props,canUseEventSystem){var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key],canUseEventSystem);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){warning(false,'Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}else if(unknownProps.length>1){warning(false,'Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}};function validateProperties$2(type,props,canUseEventSystem){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props,canUseEventSystem);}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$2=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnInvalidHydration=false;var didWarnShadyDOM=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML='__html';var HTML_NAMESPACE=Namespaces.html;var getStack=emptyFunction.thatReturns('');{getStack=getCurrentFiberStackAddendum$2;var warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July
// 2017 it intends to ship it due to widespread usage. We intentionally
// *don't* warn for <time> even if it's unrecognized by Chrome because
// it soon will be, and many apps have been using it anyway.
time:true,// There are working polyfills for <dialog>. Let people use it.
dialog:true};var validatePropertiesInDevelopment=function(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props,/* canUseEventSystem */true);};// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;var normalizeMarkupForTextOrAttribute=function(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};var warnForTextDifference=function(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;warning(false,'Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};var warnForPropDifference=function(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;warning(false,'Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};var warnForExtraAttributes=function(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});warning(false,'Extra attributes from the server: %s',names);};var warnForInvalidEventListener=function(registrationName,listener){if(listener===false){warning(false,'Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',registrationName,registrationName,registrationName,getCurrentFiberStackAddendum$2());}else{warning(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.%s',registrationName,typeof listener,getCurrentFiberStackAddendum$2());}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
var normalizeHTML=function(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;listenTo(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents={topAbort:'abort',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topLoadedData:'loadeddata',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topSeeked:'seeked',topSeeking:'seeking',topStalled:'stalled',topSuspend:'suspend',topTimeUpdate:'timeupdate',topVolumeChange:'volumechange',topWaiting:'waiting'};function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=emptyFunction;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// We polyfill it separately on the client during commit.
// We blacklist it here rather than in the property list because we emit it in SSR.
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(isCustomComponentTag){setValueForAttribute(domElement,propKey,nextProp);}else if(nextProp!=null){// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
setValueForProperty(domElement,propKey,nextProp);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent(domElement,propValue);}else if(isCustomComponentTag){if(propValue!=null){setValueForAttribute(domElement,propKey,propValue);}else{deleteValueForAttribute(domElement,propKey);}}else if(propValue!=null){setValueForProperty(domElement,propKey,propValue);}else{// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
deleteValueForProperty(domElement,propKey);}}}function createElement$1(type,props,rootContainerElement,parentNamespace){// We create tags in the namespace of their parent container, except HTML
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{var isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
warning(isCustomComponentTag||type===type.toLowerCase(),'<%s /> is using uppercase HTML. Always use lowercase HTML tags '+'in React.',type);}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;warning(false,'The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode$1(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties$1(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
var props;switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}props=rawProps;break;case'source':trapBubbledEvent('topError','error',domElement);props=rawProps;break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);props=rawProps;break;case'details':trapBubbledEvent('topToggle','toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props,getStack);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties$1(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps,getStack);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN){// Noop. This is handled by the clear text mechanism.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// Noop. It doesn't work on updates anyway.
}else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the whitelist in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;var lastHtml=lastProp?lastProp[HTML]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,''+nextHtml);}}else{// TODO: It might be too late to clear this if we have children
// inserted already.
}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else{// For any other property we always add it to the queue and then we
// filter it out using the whitelist during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties$1(domElement,updatePayload,tag,lastRawProps,nextRawProps){// Update checked *before* name.
// In the middle of an update, it is possible to have multiple checked.
// When a checked radio tries to change name, browser makes another radio's checked false.
if(tag==='input'&&nextRawProps.type==='radio'&&nextRawProps.name!=null){updateChecked(domElement,nextRawProps);}var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function diffHydratedProperties$1(domElement,tag,rawProps,parentNamespace,rootContainerElement){{var suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING$1]===true;var isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}break;case'source':trapBubbledEvent('topError','error',domElement);break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);break;case'details':trapBubbledEvent('topToggle','toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps,getStack);{var extraAttributeNames=new Set();var attributes=domElement.attributes;for(var i=0;i<attributes.length;i++){var name=attributes[i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted
case'data-reactroot':break;// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else{// Validate that the properties correspond to their expected values.
var serverValue;var propertyInfo;if(suppressHydrationWarning){// Don't bother comparing. We're ignoring all these warnings.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected'){// Noop
}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var rawHtml=nextProp?nextProp[HTML]||'':'';var serverHTML=domElement.innerHTML;var expectedHTML=normalizeHTML(domElement,rawHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(shouldSetAttribute(propKey,nextProp)){if(propertyInfo=getPropertyInfo(propKey)){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());}else{// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText$1(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText$1(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement$1(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText$1(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState(domElement,tag,props){switch(tag){case'input':restoreControlledState$1(domElement,props);return;case'textarea':restoreControlledState$3(domElement,props);return;case'select':restoreControlledState$2(domElement,props);return;}}var ReactDOMFiberComponent=Object.freeze({createElement:createElement$1,createTextNode:createTextNode$1,setInitialProperties:setInitialProperties$1,diffProperties:diffProperties$1,updateProperties:updateProperties$1,diffHydratedProperties:diffHydratedProperties$1,diffHydratedText:diffHydratedText$1,warnForUnmatchedText:warnForUnmatchedText$1,warnForDeletedHydratableElement:warnForDeletedHydratableElement$1,warnForDeletedHydratableText:warnForDeletedHydratableText$1,warnForInsertedHydratedElement:warnForInsertedHydratedElement$1,warnForInsertedHydratedText:warnForInsertedHydratedText$1,restoreControlledState:restoreControlledState});// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var validateDOMNesting=emptyFunction;{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};var updatedAncestorInfo$1=function(oldInfo,tag,instance){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag,instance:instance};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn={};validateDOMNesting=function(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){warning(childTag==null,'validateDOMNesting: when childText is passed, childTag should be null');childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackAddendum$6();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn[warnKey]){return;}didWarn[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody> to your code to match the DOM tree generated by '+'the browser.';}warning(false,'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info,addendum);}else{warning(false,'validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.%s',tagDisplayName,ancestorTag,addendum);}};// TODO: turn this into a named export
validateDOMNesting.updatedAncestorInfo=updatedAncestorInfo$1;// For testing
validateDOMNesting.isTagValidInContext=function(tag,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;return isTagValidWithParent(tag,parentTag)&&!findInvalidAncestorForTag(tag,ancestorInfo);};}var validateDOMNesting$1=validateDOMNesting;// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement=createElement$1;var createTextNode=createTextNode$1;var setInitialProperties=setInitialProperties$1;var diffProperties=diffProperties$1;var updateProperties=updateProperties$1;var diffHydratedProperties=diffHydratedProperties$1;var diffHydratedText=diffHydratedText$1;var warnForUnmatchedText=warnForUnmatchedText$1;var warnForDeletedHydratableElement=warnForDeletedHydratableElement$1;var warnForDeletedHydratableText=warnForDeletedHydratableText$1;var warnForInsertedHydratedElement=warnForInsertedHydratedElement$1;var warnForInsertedHydratedText=warnForInsertedHydratedText$1;var updatedAncestorInfo=validateDOMNesting$1.updatedAncestorInfo;var precacheFiberNode=precacheFiberNode$1;var updateFiberProps=updateFiberProps$1;{var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';if(typeof Map!=='function'||Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){warning(false,'React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);var eventsEnabled=null;var selectionInformation=null;/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}var DOMRenderer=reactReconciler({getRootHostContext:function(rootContainerInstance){var type=void 0;var namespace=void 0;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var _ancestorInfo=updatedAncestorInfo(null,validatedTag,null);return{namespace:namespace,ancestorInfo:_ancestorInfo};}return namespace;},getChildHostContext:function(parentHostContext,type){{var parentHostContextDev=parentHostContext;var _namespace=getChildNamespace(parentHostContextDev.namespace,type);var _ancestorInfo2=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type,null);return{namespace:_namespace,ancestorInfo:_ancestorInfo2};}var parentNamespace=parentHostContext;return getChildNamespace(parentNamespace,type);},getPublicInstance:function(instance){return instance;},prepareForCommit:function(){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);},resetAfterCommit:function(){restoreSelection(selectionInformation);selectionInformation=null;setEnabled(eventsEnabled);eventsEnabled=null;},createInstance:function(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace=void 0;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting$1(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;},appendInitialChild:function(parentInstance,child){parentInstance.appendChild(child);},finalizeInitialChildren:function(domElement,type,props,rootContainerInstance){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);},prepareUpdate:function(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(typeof newProps.children!==typeof oldProps.children&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);},shouldSetTextContent:function(type,props){return type==='textarea'||typeof props.children==='string'||typeof props.children==='number'||typeof props.dangerouslySetInnerHTML==='object'&&props.dangerouslySetInnerHTML!==null&&typeof props.dangerouslySetInnerHTML.__html==='string';},shouldDeprioritizeSubtree:function(type,props){return!!props.hidden;},createTextInstance:function(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting$1(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;},now:now,mutation:{commitMount:function(domElement,type,newProps,internalInstanceHandle){domElement.focus();},commitUpdate:function(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);},resetTextContent:function(domElement){domElement.textContent='';},commitTextUpdate:function(textInstance,oldText,newText){textInstance.nodeValue=newText;},appendChild:function(parentInstance,child){parentInstance.appendChild(child);},appendChildToContainer:function(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,container);}else{container.appendChild(child);}},insertBefore:function(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);},insertInContainerBefore:function(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}},removeChild:function(parentInstance,child){parentInstance.removeChild(child);},removeChildFromContainer:function(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}},hydration:{canHydrateInstance:function(instance,type,props){if(instance.nodeType!==ELEMENT_NODE||type.toLowerCase()!==instance.nodeName.toLowerCase()){return null;}// This has now been refined to an element node.
return instance;},canHydrateTextInstance:function(instance,text){if(text===''||instance.nodeType!==TEXT_NODE){// Empty strings are not parsed by HTML so there won't be a correct match here.
return null;}// This has now been refined to a text node.
return instance;},getNextHydratableSibling:function(instance){var node=instance.nextSibling;// Skip non-hydratable nodes.
while(node&&node.nodeType!==ELEMENT_NODE&&node.nodeType!==TEXT_NODE){node=node.nextSibling;}return node;},getFirstHydratableChild:function(parentInstance){var next=parentInstance.firstChild;// Skip non-hydratable nodes.
while(next&&next.nodeType!==ELEMENT_NODE&&next.nodeType!==TEXT_NODE){next=next.nextSibling;}return next;},hydrateInstance:function(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace=void 0;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);},hydrateTextInstance:function(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);},didNotMatchHydratedContainerTextInstance:function(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}},didNotMatchHydratedTextInstance:function(parentType,parentProps,parentInstance,textInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForUnmatchedText(textInstance,text);}},didNotHydrateContainerInstance:function(parentContainer,instance){{if(instance.nodeType===1){warnForDeletedHydratableElement(parentContainer,instance);}else{warnForDeletedHydratableText(parentContainer,instance);}}},didNotHydrateInstance:function(parentType,parentProps,parentInstance,instance){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){if(instance.nodeType===1){warnForDeletedHydratableElement(parentInstance,instance);}else{warnForDeletedHydratableText(parentInstance,instance);}}},didNotFindHydratableContainerInstance:function(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type,props);}},didNotFindHydratableContainerTextInstance:function(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}},didNotFindHydratableInstance:function(parentType,parentProps,parentInstance,type,props){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedElement(parentInstance,type,props);}},didNotFindHydratableTextInstance:function(parentType,parentProps,parentInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedText(parentInstance,text);}}},scheduleDeferredCallback:rIC,cancelDeferredCallback:cIC,useSyncScheduling:!enableAsyncSchedulingByDefaultInReactDOM});injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);var warnedAboutHydrateAPI=false;function renderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){warning(hostInstance.parentNode===container,'render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));warning(!hasNonRootReactChild||isRootRenderedBySomeReact,'render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');warning(container.nodeType!==ELEMENT_NODE||!container.tagName||container.tagName.toUpperCase()!=='BODY','render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}var root=container._reactRootContainer;if(!root){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
if(!shouldHydrate){var warned=false;var rootSibling=void 0;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;warning(false,'render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;lowPriorityWarning$1(false,'render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}var newRoot=DOMRenderer.createContainer(container,shouldHydrate);root=container._reactRootContainer=newRoot;// Initial mount should not be batched.
DOMRenderer.unbatchedUpdates(function(){DOMRenderer.updateContainer(children,newRoot,parentComponent,callback);});}else{DOMRenderer.updateContainer(children,root,parentComponent,callback);}return DOMRenderer.getPublicRootInstance(root);}function createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;// TODO: pass ReactDOM portal implementation as third argument
return createPortal$1(children,container,null,key);}function ReactRoot(container,hydrate){var root=DOMRenderer.createContainer(container,hydrate);this._reactRootContainer=root;}ReactRoot.prototype.render=function(children,callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(children,root,null,callback);};ReactRoot.prototype.unmount=function(callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(null,root,null,callback);};var ReactDOM={createPortal:createPortal,findDOMNode:function(componentOrElement){{var owner=ReactCurrentOwner.current;if(owner!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;warning(warnedAboutRefsInRender,'%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner)||'A component');owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}var inst=get(componentOrElement);if(inst){return DOMRenderer.findHostInstance(inst);}if(typeof componentOrElement.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Element appears to be neither ReactComponent nor DOMNode. Keys: %s',Object.keys(componentOrElement));}},hydrate:function(element,container,callback){// TODO: throw or warn if we couldn't hydrate?
return renderSubtreeIntoContainer(null,element,container,true,callback);},render:function(element,container,callback){return renderSubtreeIntoContainer(null,element,container,false,callback);},unstable_renderSubtreeIntoContainer:function(parentComponent,element,containerNode,callback){!(parentComponent!=null&&has(parentComponent))?invariant(false,'parentComponent must be a valid React Component'):void 0;return renderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);},unmountComponentAtNode:function(container){!isValidContainer(container)?invariant(false,'unmountComponentAtNode(...): Target container is not a DOM element.'):void 0;if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);warning(!renderedByDifferentReact,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}// Unmount should not be batched.
DOMRenderer.unbatchedUpdates(function(){renderSubtreeIntoContainer(null,null,container,false,function(){container._reactRootContainer=null;});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===1&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;warning(!hasNonRootReactChild,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}return false;}},// Temporary alias since we already shipped React 16 RC with it.
// TODO: remove in React 17.
unstable_createPortal:createPortal,unstable_batchedUpdates:batchedUpdates,unstable_deferredUpdates:DOMRenderer.deferredUpdates,flushSync:DOMRenderer.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{// For TapEventPlugin which is popular in open source
EventPluginHub:EventPluginHub,// Used by test-utils
EventPluginRegistry:EventPluginRegistry,EventPropagators:EventPropagators,ReactControlledComponent:ReactControlledComponent,ReactDOMComponentTree:ReactDOMComponentTree,ReactDOMEventListener:ReactDOMEventListener}};if(enableCreateRoot){ReactDOM.createRoot=function createRoot(container,options){var hydrate=options!=null&&options.hydrate===true;return new ReactRoot(container,hydrate);};}var foundDevTools=DOMRenderer.injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&ExecutionEnvironment.canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}var ReactDOM$2=Object.freeze({default:ReactDOM});var ReactDOM$3=ReactDOM$2&&ReactDOM||ReactDOM$2;// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom=ReactDOM$3['default']?ReactDOM$3['default']:ReactDOM$3;module.exports=reactDom;})();}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */


var hyphenate = __webpack_require__(31);

var msPattern = /^ms-/;
/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */

function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;
/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */

function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */


var camelize = __webpack_require__(33);

var msPattern = /^-ms-/;
/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */

function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;
/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */

function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js__);


var getBreakpoint = function () {
  return window.getComputedStyle(window.document.querySelector('body'), ':before').getPropertyValue('content').replace(/"/g, '');
};

function breakpoint(breakpoint, callback) {
  if (typeof callback === "function") {
    if (getBreakpoint() === breakpoint) {
      callback();
    }

    $(window).resize(function () {
      if (getBreakpoint() === breakpoint) {
        callback();
      }
    });
  } else {
    return getBreakpoint() === breakpoint;
  }
}

function desktop(callback) {
  return breakpoint("desktop", callback);
}

function tablet(callback) {
  return breakpoint("tablet", callback);
}

function phone(callback) {
  return breakpoint("phone", callback);
}

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function () {
  /*
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */
  'use strict';

  var p,
      q = "undefined" != typeof window && window === this ? this : "undefined" != typeof global && null != global ? global : this,
      ba = "function" == typeof Object.defineProperties ? Object.defineProperty : function (a, b, c) {
    a != Array.prototype && a != Object.prototype && (a[b] = c.value);
  };

  function ca() {
    ca = function () {};

    q.Symbol || (q.Symbol = da);
  }

  var da = function () {
    var a = 0;
    return function (b) {
      return "jscomp_symbol_" + (b || "") + a++;
    };
  }();

  function ea() {
    ca();
    var a = q.Symbol.iterator;
    a || (a = q.Symbol.iterator = q.Symbol("iterator"));
    "function" != typeof Array.prototype[a] && ba(Array.prototype, a, {
      configurable: !0,
      writable: !0,
      value: function () {
        return fa(this);
      }
    });

    ea = function () {};
  }

  function fa(a) {
    var b = 0;
    return ha(function () {
      return b < a.length ? {
        done: !1,
        value: a[b++]
      } : {
        done: !0
      };
    });
  }

  function ha(a) {
    ea();
    a = {
      next: a
    };

    a[q.Symbol.iterator] = function () {
      return this;
    };

    return a;
  }

  function ia(a) {
    ea();
    var b = a[Symbol.iterator];
    return b ? b.call(a) : fa(a);
  }

  function ja(a) {
    for (var b, c = []; !(b = a.next()).done;) c.push(b.value);

    return c;
  }

  (function () {
    if (!function () {
      var a = document.createEvent("Event");
      a.initEvent("foo", !0, !0);
      a.preventDefault();
      return a.defaultPrevented;
    }()) {
      var a = Event.prototype.preventDefault;

      Event.prototype.preventDefault = function () {
        this.cancelable && (a.call(this), Object.defineProperty(this, "defaultPrevented", {
          get: function () {
            return !0;
          },
          configurable: !0
        }));
      };
    }

    var b = /Trident/.test(navigator.userAgent);
    if (!window.CustomEvent || b && "function" !== typeof window.CustomEvent) window.CustomEvent = function (a, b) {
      b = b || {};
      var c = document.createEvent("CustomEvent");
      c.initCustomEvent(a, !!b.bubbles, !!b.cancelable, b.detail);
      return c;
    }, window.CustomEvent.prototype = window.Event.prototype;

    if (!window.Event || b && "function" !== typeof window.Event) {
      var c = window.Event;

      window.Event = function (a, b) {
        b = b || {};
        var c = document.createEvent("Event");
        c.initEvent(a, !!b.bubbles, !!b.cancelable);
        return c;
      };

      if (c) for (var d in c) window.Event[d] = c[d];
      window.Event.prototype = c.prototype;
    }

    if (!window.MouseEvent || b && "function" !== typeof window.MouseEvent) {
      b = window.MouseEvent;

      window.MouseEvent = function (a, b) {
        b = b || {};
        var c = document.createEvent("MouseEvent");
        c.initMouseEvent(a, !!b.bubbles, !!b.cancelable, b.view || window, b.detail, b.screenX, b.screenY, b.clientX, b.clientY, b.ctrlKey, b.altKey, b.shiftKey, b.metaKey, b.button, b.relatedTarget);
        return c;
      };

      if (b) for (d in b) window.MouseEvent[d] = b[d];
      window.MouseEvent.prototype = b.prototype;
    }

    Array.from || (Array.from = function (a) {
      return [].slice.call(a);
    });
    Object.assign || (Object.assign = function (a, b) {
      for (var c = [].slice.call(arguments, 1), d = 0, e; d < c.length; d++) if (e = c[d]) for (var f = a, m = e, n = Object.getOwnPropertyNames(m), w = 0; w < n.length; w++) e = n[w], f[e] = m[e];

      return a;
    });
  })(window.WebComponents);

  (function () {
    function a() {}

    function b(a, b) {
      switch (a.nodeType) {
        case Node.DOCUMENT_NODE:
          return w.call(a, b);

        case Node.DOCUMENT_FRAGMENT_NODE:
          return I.call(a, b);

        default:
          return n.call(a, b);
      }
    }

    var c = "undefined" === typeof HTMLTemplateElement,
        d = !(document.createDocumentFragment().cloneNode() instanceof DocumentFragment),
        e = !1;
    /Trident/.test(navigator.userAgent) && function () {
      function a(a, b) {
        if (a instanceof DocumentFragment) for (var d; d = a.firstChild;) c.call(this, d, b);else c.call(this, a, b);
        return a;
      }

      e = !0;
      var b = Node.prototype.cloneNode;

      Node.prototype.cloneNode = function (a) {
        a = b.call(this, a);
        this instanceof DocumentFragment && (a.__proto__ = DocumentFragment.prototype);
        return a;
      };

      DocumentFragment.prototype.querySelectorAll = HTMLElement.prototype.querySelectorAll;
      DocumentFragment.prototype.querySelector = HTMLElement.prototype.querySelector;
      Object.defineProperties(DocumentFragment.prototype, {
        nodeType: {
          get: function () {
            return Node.DOCUMENT_FRAGMENT_NODE;
          },
          configurable: !0
        },
        localName: {
          get: function () {},
          configurable: !0
        },
        nodeName: {
          get: function () {
            return "#document-fragment";
          },
          configurable: !0
        }
      });
      var c = Node.prototype.insertBefore;
      Node.prototype.insertBefore = a;
      var d = Node.prototype.appendChild;

      Node.prototype.appendChild = function (b) {
        b instanceof DocumentFragment ? a.call(this, b, null) : d.call(this, b);
        return b;
      };

      var f = Node.prototype.removeChild,
          h = Node.prototype.replaceChild;

      Node.prototype.replaceChild = function (b, c) {
        b instanceof DocumentFragment ? (a.call(this, b, c), f.call(this, c)) : h.call(this, b, c);
        return c;
      };

      Document.prototype.createDocumentFragment = function () {
        var a = this.createElement("df");
        a.__proto__ = DocumentFragment.prototype;
        return a;
      };

      var g = Document.prototype.importNode;

      Document.prototype.importNode = function (a, b) {
        b = g.call(this, a, b || !1);
        a instanceof DocumentFragment && (b.__proto__ = DocumentFragment.prototype);
        return b;
      };
    }();

    var f = Node.prototype.cloneNode,
        h = Document.prototype.createElement,
        g = Document.prototype.importNode,
        k = Node.prototype.removeChild,
        l = Node.prototype.appendChild,
        m = Node.prototype.replaceChild,
        n = Element.prototype.querySelectorAll,
        w = Document.prototype.querySelectorAll,
        I = DocumentFragment.prototype.querySelectorAll,
        Za = function () {
      if (!c) {
        var a = document.createElement("template"),
            b = document.createElement("template");
        b.content.appendChild(document.createElement("div"));
        a.content.appendChild(b);
        a = a.cloneNode(!0);
        return 0 === a.content.childNodes.length || 0 === a.content.firstChild.content.childNodes.length || d;
      }
    }();

    if (c) {
      var t = document.implementation.createHTMLDocument("template"),
          na = !0,
          aa = document.createElement("style");
      aa.textContent = "template{display:none;}";
      var T = document.head;
      T.insertBefore(aa, T.firstElementChild);
      a.prototype = Object.create(HTMLElement.prototype);
      var U = !document.createElement("div").hasOwnProperty("innerHTML");

      a.D = function (b) {
        if (!b.content) {
          b.content = t.createDocumentFragment();

          for (var c; c = b.firstChild;) l.call(b.content, c);

          if (U) b.__proto__ = a.prototype;else if (b.cloneNode = function (b) {
            return a.a(this, b);
          }, na) try {
            nc(b), oc(b);
          } catch (Ng) {
            na = !1;
          }
          a.J(b.content);
        }
      };

      var nc = function (b) {
        Object.defineProperty(b, "innerHTML", {
          get: function () {
            for (var a = "", b = this.content.firstChild; b; b = b.nextSibling) a += b.outerHTML || b.data.replace(Ge, pc);

            return a;
          },
          set: function (b) {
            t.body.innerHTML = b;

            for (a.J(t); this.content.firstChild;) k.call(this.content, this.content.firstChild);

            for (; t.body.firstChild;) l.call(this.content, t.body.firstChild);
          },
          configurable: !0
        });
      },
          oc = function (a) {
        Object.defineProperty(a, "outerHTML", {
          get: function () {
            return "<template>" + this.innerHTML + "</template>";
          },
          set: function (a) {
            if (this.parentNode) {
              t.body.innerHTML = a;

              for (a = this.ownerDocument.createDocumentFragment(); t.body.firstChild;) l.call(a, t.body.firstChild);

              m.call(this.parentNode, a, this);
            } else throw Error("Failed to set the 'outerHTML' property on 'Element': This element has no parent node.");
          },
          configurable: !0
        });
      };

      nc(a.prototype);
      oc(a.prototype);

      a.J = function (c) {
        c = b(c, "template");

        for (var d = 0, e = c.length, f; d < e && (f = c[d]); d++) a.D(f);
      };

      document.addEventListener("DOMContentLoaded", function () {
        a.J(document);
      });

      Document.prototype.createElement = function () {
        var b = h.apply(this, arguments);
        "template" === b.localName && a.D(b);
        return b;
      };

      var Ge = /[&\u00A0<>]/g,
          pc = function (a) {
        switch (a) {
          case "&":
            return "&amp;";

          case "<":
            return "&lt;";

          case ">":
            return "&gt;";

          case "\u00a0":
            return "&nbsp;";
        }
      };
    }

    if (c || Za) {
      a.a = function (a, b) {
        var c = f.call(a, !1);
        this.D && this.D(c);
        b && (l.call(c.content, f.call(a.content, !0)), $a(c.content, a.content));
        return c;
      };

      var $a = function (c, d) {
        if (d.querySelectorAll && (d = b(d, "template"), 0 !== d.length)) {
          c = b(c, "template");

          for (var e = 0, f = c.length, h, g; e < f; e++) g = d[e], h = c[e], a && a.D && a.D(g), m.call(h.parentNode, He.call(g, !0), h);
        }
      },
          He = Node.prototype.cloneNode = function (b) {
        if (!e && d && this instanceof DocumentFragment) {
          if (b) var c = Ie.call(this.ownerDocument, this, !0);else return this.ownerDocument.createDocumentFragment();
        } else this.nodeType === Node.ELEMENT_NODE && "template" === this.localName ? c = a.a(this, b) : c = f.call(this, b);
        b && $a(c, this);
        return c;
      },
          Ie = Document.prototype.importNode = function (b, c) {
        c = c || !1;
        if ("template" === b.localName) return a.a(b, c);
        var d = g.call(this, b, c);
        c && $a(d, b);
        return d;
      };
    }

    c && (window.HTMLTemplateElement = a);
  })();

  var ka;
  Array.isArray ? ka = Array.isArray : ka = function (a) {
    return "[object Array]" === Object.prototype.toString.call(a);
  };
  var la = ka;
  var ma = 0,
      oa,
      pa = "undefined" !== typeof window ? window : void 0,
      qa = pa || {},
      ra = qa.MutationObserver || qa.WebKitMutationObserver,
      sa = "undefined" !== typeof Uint8ClampedArray && "undefined" !== typeof importScripts && "undefined" !== typeof MessageChannel;

  function ta() {
    return "undefined" !== typeof oa ? function () {
      oa(ua);
    } : va();
  }

  function wa() {
    var a = 0,
        b = new ra(ua),
        c = document.createTextNode("");
    b.observe(c, {
      characterData: !0
    });
    return function () {
      c.data = a = ++a % 2;
    };
  }

  function xa() {
    var a = new MessageChannel();
    a.port1.onmessage = ua;
    return function () {
      return a.port2.postMessage(0);
    };
  }

  function va() {
    var a = setTimeout;
    return function () {
      return a(ua, 1);
    };
  }

  var ya = Array(1E3);

  function ua() {
    for (var a = 0; a < ma; a += 2) (0, ya[a])(ya[a + 1]), ya[a] = void 0, ya[a + 1] = void 0;

    ma = 0;
  }

  var za, Aa;
  if ("undefined" === typeof self && "undefined" !== typeof process && "[object process]" === {}.toString.call(process)) Aa = function () {
    return process.jb(ua);
  };else {
    var Ba;
    if (ra) Ba = wa();else {
      var Ca;
      if (sa) Ca = xa();else {
        var Da;
        if (void 0 === pa && "function" === "function") try {
          var Ea = __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"vertx\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

          oa = Ea.lb || Ea.kb;
          Da = ta();
        } catch (a) {
          Da = va();
        } else Da = va();
        Ca = Da;
      }
      Ba = Ca;
    }
    Aa = Ba;
  }
  za = Aa;

  function Fa(a, b) {
    ya[ma] = a;
    ya[ma + 1] = b;
    ma += 2;
    2 === ma && za();
  }

  ;

  function Ga(a, b) {
    var c = this,
        d = new this.constructor(Ha);
    void 0 === d[Ia] && Ja(d);
    var e = c.g;

    if (e) {
      var f = arguments[e - 1];
      Fa(function () {
        return Ka(e, d, f, c.f);
      });
    } else La(c, d, a, b);

    return d;
  }

  ;

  function Ma(a) {
    if (a && "object" === typeof a && a.constructor === this) return a;
    var b = new this(Ha);
    Na(b, a);
    return b;
  }

  ;
  var Ia = Math.random().toString(36).substring(16);

  function Ha() {}

  var Pa = new Oa();

  function Qa(a) {
    try {
      return a.then;
    } catch (b) {
      return Pa.error = b, Pa;
    }
  }

  function Ra(a, b, c, d) {
    try {
      a.call(b, c, d);
    } catch (e) {
      return e;
    }
  }

  function Sa(a, b, c) {
    Fa(function (a) {
      var d = !1,
          f = Ra(c, b, function (c) {
        d || (d = !0, b !== c ? Na(a, c) : r(a, c));
      }, function (b) {
        d || (d = !0, u(a, b));
      });
      !d && f && (d = !0, u(a, f));
    }, a);
  }

  function Ta(a, b) {
    1 === b.g ? r(a, b.f) : 2 === b.g ? u(a, b.f) : La(b, void 0, function (b) {
      return Na(a, b);
    }, function (b) {
      return u(a, b);
    });
  }

  function Ua(a, b, c) {
    b.constructor === a.constructor && c === Ga && b.constructor.resolve === Ma ? Ta(a, b) : c === Pa ? (u(a, Pa.error), Pa.error = null) : void 0 === c ? r(a, b) : "function" === typeof c ? Sa(a, b, c) : r(a, b);
  }

  function Na(a, b) {
    if (a === b) u(a, new TypeError("You cannot resolve a promise with itself"));else {
      var c = typeof b;
      null === b || "object" !== c && "function" !== c ? r(a, b) : Ua(a, b, Qa(b));
    }
  }

  function Va(a) {
    a.pa && a.pa(a.f);
    Wa(a);
  }

  function r(a, b) {
    void 0 === a.g && (a.f = b, a.g = 1, 0 !== a.I.length && Fa(Wa, a));
  }

  function u(a, b) {
    void 0 === a.g && (a.g = 2, a.f = b, Fa(Va, a));
  }

  function La(a, b, c, d) {
    var e = a.I,
        f = e.length;
    a.pa = null;
    e[f] = b;
    e[f + 1] = c;
    e[f + 2] = d;
    0 === f && a.g && Fa(Wa, a);
  }

  function Wa(a) {
    var b = a.I,
        c = a.g;

    if (0 !== b.length) {
      for (var d, e, f = a.f, h = 0; h < b.length; h += 3) d = b[h], e = b[h + c], d ? Ka(c, d, e, f) : e(f);

      a.I.length = 0;
    }
  }

  function Oa() {
    this.error = null;
  }

  var Xa = new Oa();

  function Ka(a, b, c, d) {
    var e = "function" === typeof c;

    if (e) {
      try {
        var f = c(d);
      } catch (l) {
        Xa.error = l, f = Xa;
      }

      if (f === Xa) {
        var h = !0;
        var g = f.error;
        f.error = null;
      } else var k = !0;

      if (b === f) {
        u(b, new TypeError("A promises callback cannot return that same promise."));
        return;
      }
    } else f = d, k = !0;

    void 0 === b.g && (e && k ? Na(b, f) : h ? u(b, g) : 1 === a ? r(b, f) : 2 === a && u(b, f));
  }

  function Ya(a, b) {
    try {
      b(function (b) {
        Na(a, b);
      }, function (b) {
        u(a, b);
      });
    } catch (c) {
      u(a, c);
    }
  }

  var ab = 0;

  function Ja(a) {
    a[Ia] = ab++;
    a.g = void 0;
    a.f = void 0;
    a.I = [];
  }

  ;

  function bb(a, b) {
    this.Ga = a;
    this.A = new a(Ha);
    this.A[Ia] || Ja(this.A);
    if (la(b)) {
      if (this.S = this.length = b.length, this.f = Array(this.length), 0 === this.length) r(this.A, this.f);else {
        this.length = this.length || 0;

        for (a = 0; void 0 === this.g && a < b.length; a++) cb(this, b[a], a);

        0 === this.S && r(this.A, this.f);
      }
    } else u(this.A, Error("Array Methods must be provided an Array"));
  }

  function cb(a, b, c) {
    var d = a.Ga,
        e = d.resolve;
    e === Ma ? (e = Qa(b), e === Ga && void 0 !== b.g ? db(a, b.g, c, b.f) : "function" !== typeof e ? (a.S--, a.f[c] = b) : d === v ? (d = new d(Ha), Ua(d, b, e), eb(a, d, c)) : eb(a, new d(function (a) {
      return a(b);
    }), c)) : eb(a, e(b), c);
  }

  function db(a, b, c, d) {
    var e = a.A;
    void 0 === e.g && (a.S--, 2 === b ? u(e, d) : a.f[c] = d);
    0 === a.S && r(e, a.f);
  }

  function eb(a, b, c) {
    La(b, void 0, function (b) {
      return db(a, 1, c, b);
    }, function (b) {
      return db(a, 2, c, b);
    });
  }

  ;

  function fb(a) {
    return new bb(this, a).A;
  }

  ;

  function gb(a) {
    var b = this;
    return la(a) ? new b(function (c, d) {
      for (var e = a.length, f = 0; f < e; f++) b.resolve(a[f]).then(c, d);
    }) : new b(function (a, b) {
      return b(new TypeError("You must pass an array to race."));
    });
  }

  ;

  function hb(a) {
    var b = new this(Ha);
    u(b, a);
    return b;
  }

  ;

  function v(a) {
    this[Ia] = ab++;
    this.f = this.g = void 0;
    this.I = [];

    if (Ha !== a) {
      if ("function" !== typeof a) throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
      if (this instanceof v) Ya(this, a);else throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
    }
  }

  v.prototype = {
    constructor: v,
    then: Ga,
    a: function (a) {
      return this.then(null, a);
    }
  };
  /*
  Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  window.Promise || (window.Promise = v, v.prototype["catch"] = v.prototype.a, v.prototype.then = v.prototype.then, v.all = fb, v.race = gb, v.resolve = Ma, v.reject = hb);

  (function (a) {
    function b(a, b) {
      if ("function" === typeof window.CustomEvent) return new CustomEvent(a, b);
      var c = document.createEvent("CustomEvent");
      c.initCustomEvent(a, !!b.bubbles, !!b.cancelable, b.detail);
      return c;
    }

    function c(a) {
      if (m) return a.ownerDocument !== document ? a.ownerDocument : null;
      var b = a.__importDoc;

      if (!b && a.parentNode) {
        b = a.parentNode;
        if ("function" === typeof b.closest) b = b.closest("link[rel=import]");else for (; !g(b) && (b = b.parentNode););
        a.__importDoc = b;
      }

      return b;
    }

    function d(a) {
      var b = document.querySelectorAll("link[rel=import]:not([import-dependency])"),
          c = b.length;
      c ? l(b, function (b) {
        return h(b, function () {
          0 === --c && a();
        });
      }) : a();
    }

    function e(a) {
      function b() {
        "loading" !== document.readyState && document.body && (document.removeEventListener("readystatechange", b), a());
      }

      document.addEventListener("readystatechange", b);
      b();
    }

    function f(a) {
      e(function () {
        return d(function () {
          return a && a();
        });
      });
    }

    function h(a, b) {
      if (a.__loaded) b && b();else if ("script" === a.localName && !a.src || "style" === a.localName && !a.firstChild) a.__loaded = !0, b && b();else {
        var c = function (d) {
          a.removeEventListener(d.type, c);
          a.__loaded = !0;
          b && b();
        };

        a.addEventListener("load", c);
        aa && "style" === a.localName || a.addEventListener("error", c);
      }
    }

    function g(a) {
      return a.nodeType === Node.ELEMENT_NODE && "link" === a.localName && "import" === a.rel;
    }

    function k() {
      var a = this;
      this.a = {};
      this.b = 0;
      this.h = new MutationObserver(function (b) {
        return a.Qa(b);
      });
      this.h.observe(document.head, {
        childList: !0,
        subtree: !0
      });
      this.c(document);
    }

    function l(a, b, c) {
      var d = a ? a.length : 0,
          e = c ? -1 : 1;

      for (c = c ? d - 1 : 0; c < d && 0 <= c; c += e) b(a[c], c);
    }

    var m = "import" in document.createElement("link"),
        n = null;
    !1 === "currentScript" in document && Object.defineProperty(document, "currentScript", {
      get: function () {
        return n || ("complete" !== document.readyState ? document.scripts[document.scripts.length - 1] : null);
      },
      configurable: !0
    });
    var w = /(url\()([^)]*)(\))/g,
        I = /(@import[\s]+(?!url\())([^;]*)(;)/g,
        Za = /(<link[^>]*)(rel=['|"]?stylesheet['|"]?[^>]*>)/g,
        t = {
      Ka: function (a, b) {
        a.href && a.setAttribute("href", t.Y(a.getAttribute("href"), b));
        a.src && a.setAttribute("src", t.Y(a.getAttribute("src"), b));

        if ("style" === a.localName) {
          var c = t.ua(a.textContent, b, w);
          a.textContent = t.ua(c, b, I);
        }
      },
      ua: function (a, b, c) {
        return a.replace(c, function (a, c, d, e) {
          a = d.replace(/["']/g, "");
          b && (a = t.Y(a, b));
          return c + "'" + a + "'" + e;
        });
      },
      Y: function (a, b) {
        if (void 0 === t.ca) {
          t.ca = !1;

          try {
            var c = new URL("b", "http://a");
            c.pathname = "c%20d";
            t.ca = "http://a/c%20d" === c.href;
          } catch (pc) {}
        }

        if (t.ca) return new URL(a, b).href;
        c = t.Da;
        c || (c = document.implementation.createHTMLDocument("temp"), t.Da = c, c.ma = c.createElement("base"), c.head.appendChild(c.ma), c.la = c.createElement("a"));
        c.ma.href = b;
        c.la.href = a;
        return c.la.href || a;
      }
    },
        na = {
      async: !0,
      load: function (a, b, c) {
        if (a) {
          if (a.match(/^data:/)) {
            a = a.split(",");
            var d = a[1];
            d = -1 < a[0].indexOf(";base64") ? atob(d) : decodeURIComponent(d);
            b(d);
          } else {
            var e = new XMLHttpRequest();
            e.open("GET", a, na.async);

            e.onload = function () {
              var a = e.responseURL || e.getResponseHeader("Location");
              a && 0 === a.indexOf("/") && (a = (location.origin || location.protocol + "//" + location.host) + a);
              var d = e.response || e.responseText;
              304 === e.status || 0 === e.status || 200 <= e.status && 300 > e.status ? b(d, a) : c(d);
            };

            e.send();
          }
        } else c("error: href must be specified");
      }
    },
        aa = /Trident/.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent);

    k.prototype.c = function (a) {
      var b = this;
      a = a.querySelectorAll("link[rel=import]");
      l(a, function (a) {
        return b.L(a);
      });
    };

    k.prototype.L = function (a) {
      var b = this,
          c = a.href;

      if (void 0 !== this.a[c]) {
        var d = this.a[c];
        d && d.__loaded && (a.import = d, this.o(a));
      } else this.b++, this.a[c] = "pending", na.load(c, function (a, d) {
        a = b.Ra(a, d || c);
        b.a[c] = a;
        b.b--;
        b.c(a);
        b.sa();
      }, function () {
        b.a[c] = null;
        b.b--;
        b.sa();
      });
    };

    k.prototype.Ra = function (a, b) {
      if (!a) return document.createDocumentFragment();
      aa && (a = a.replace(Za, function (a, b, c) {
        return -1 === a.indexOf("type=") ? b + " type=import-disable " + c : a;
      }));
      var c = document.createElement("template");
      c.innerHTML = a;
      if (c.content) a = c.content;else for (a = document.createDocumentFragment(); c.firstChild;) a.appendChild(c.firstChild);
      if (c = a.querySelector("base")) b = t.Y(c.getAttribute("href"), b), c.removeAttribute("href");
      c = a.querySelectorAll('link[rel=import], link[rel=stylesheet][href][type=import-disable],\n    style:not([type]), link[rel=stylesheet][href]:not([type]),\n    script:not([type]), script[type="application/javascript"],\n    script[type="text/javascript"]');
      var d = 0;
      l(c, function (a) {
        h(a);
        t.Ka(a, b);
        a.setAttribute("import-dependency", "");
        "script" === a.localName && !a.src && a.textContent && (a.setAttribute("src", "data:text/javascript;charset=utf-8," + encodeURIComponent(a.textContent + ("\n//# sourceURL=" + b + (d ? "-" + d : "") + ".js\n"))), a.textContent = "", d++);
      });
      return a;
    };

    k.prototype.sa = function () {
      var a = this;

      if (!this.b) {
        this.h.disconnect();
        this.flatten(document);

        var b = !1,
            c = !1,
            d = function () {
          c && b && (a.c(document), a.b || (a.h.observe(document.head, {
            childList: !0,
            subtree: !0
          }), a.Pa()));
        };

        this.Wa(function () {
          c = !0;
          d();
        });
        this.Sa(function () {
          b = !0;
          d();
        });
      }
    };

    k.prototype.flatten = function (a) {
      var b = this;
      a = a.querySelectorAll("link[rel=import]");
      l(a, function (a) {
        var c = b.a[a.href];
        (a.import = c) && c.nodeType === Node.DOCUMENT_FRAGMENT_NODE && (b.a[a.href] = a, a.readyState = "loading", a.import = a, b.flatten(c), a.appendChild(c));
      });
    };

    k.prototype.Sa = function (a) {
      function b(e) {
        if (e < d) {
          var f = c[e],
              g = document.createElement("script");
          f.removeAttribute("import-dependency");
          l(f.attributes, function (a) {
            return g.setAttribute(a.name, a.value);
          });
          n = g;
          f.parentNode.replaceChild(g, f);
          h(g, function () {
            n = null;
            b(e + 1);
          });
        } else a();
      }

      var c = document.querySelectorAll("script[import-dependency]"),
          d = c.length;
      b(0);
    };

    k.prototype.Wa = function (a) {
      var b = document.querySelectorAll("style[import-dependency],\n    link[rel=stylesheet][import-dependency]"),
          d = b.length;

      if (d) {
        var e = aa && !!document.querySelector("link[rel=stylesheet][href][type=import-disable]");
        l(b, function (b) {
          h(b, function () {
            b.removeAttribute("import-dependency");
            0 === --d && a();
          });

          if (e && b.parentNode !== document.head) {
            var f = document.createElement(b.localName);
            f.__appliedElement = b;
            f.setAttribute("type", "import-placeholder");
            b.parentNode.insertBefore(f, b.nextSibling);

            for (f = c(b); f && c(f);) f = c(f);

            f.parentNode !== document.head && (f = null);
            document.head.insertBefore(b, f);
            b.removeAttribute("type");
          }
        });
      } else a();
    };

    k.prototype.Pa = function () {
      var a = this,
          b = document.querySelectorAll("link[rel=import]");
      l(b, function (b) {
        return a.o(b);
      }, !0);
    };

    k.prototype.o = function (a) {
      a.__loaded || (a.__loaded = !0, a.import && (a.import.readyState = "complete"), a.dispatchEvent(b(a.import ? "load" : "error", {
        bubbles: !1,
        cancelable: !1,
        detail: void 0
      })));
    };

    k.prototype.Qa = function (a) {
      var b = this;
      l(a, function (a) {
        return l(a.addedNodes, function (a) {
          a && a.nodeType === Node.ELEMENT_NODE && (g(a) ? b.L(a) : b.c(a));
        });
      });
    };

    if (m) {
      var T = document.querySelectorAll("link[rel=import]");
      l(T, function (a) {
        a.import && "loading" === a.import.readyState || (a.__loaded = !0);
      });

      T = function (a) {
        a = a.target;
        g(a) && (a.__loaded = !0);
      };

      document.addEventListener("load", T, !0);
      document.addEventListener("error", T, !0);
    } else {
      var U = Object.getOwnPropertyDescriptor(Node.prototype, "baseURI");
      Object.defineProperty((!U || U.configurable ? Node : Element).prototype, "baseURI", {
        get: function () {
          var a = g(this) ? this : c(this);
          return a ? a.href : U && U.get ? U.get.call(this) : (document.querySelector("base") || window.location).href;
        },
        configurable: !0,
        enumerable: !0
      });
      e(function () {
        return new k();
      });
    }

    f(function () {
      return document.dispatchEvent(b("HTMLImportsLoaded", {
        cancelable: !0,
        bubbles: !0,
        detail: void 0
      }));
    });
    a.useNative = m;
    a.whenReady = f;
    a.importForElement = c;
  })(window.HTMLImports = window.HTMLImports || {});
  /*
  Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */


  window.WebComponents = window.WebComponents || {
    flags: {}
  };
  var ib = document.querySelector('script[src*="webcomponents-lite.js"]'),
      jb = /wc-(.+)/,
      x = {};

  if (!x.noOpts) {
    location.search.slice(1).split("&").forEach(function (a) {
      a = a.split("=");
      var b;
      a[0] && (b = a[0].match(jb)) && (x[b[1]] = a[1] || !0);
    });
    if (ib) for (var kb = 0, lb; lb = ib.attributes[kb]; kb++) "src" !== lb.name && (x[lb.name] = lb.value || !0);

    if (x.log && x.log.split) {
      var mb = x.log.split(",");
      x.log = {};
      mb.forEach(function (a) {
        x.log[a] = !0;
      });
    } else x.log = {};
  }

  window.WebComponents.flags = x;
  var nb = x.shadydom;
  nb && (window.ShadyDOM = window.ShadyDOM || {}, window.ShadyDOM.force = nb);
  var ob = x.register || x.ce;
  ob && window.customElements && (window.customElements.forcePolyfill = ob);
  /*
  Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
  This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
  The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
  The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
  Code distributed by Google as part of the polymer project is also
  subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
  */

  var y = window.ShadyDOM || {};
  y.Ma = !(!Element.prototype.attachShadow || !Node.prototype.getRootNode);
  var pb = Object.getOwnPropertyDescriptor(Node.prototype, "firstChild");
  y.M = !!(pb && pb.configurable && pb.get);
  y.ta = y.force || !y.Ma;

  function qb(a) {
    return a.__shady && void 0 !== a.__shady.firstChild;
  }

  function z(a) {
    return "ShadyRoot" === a.Aa;
  }

  function rb(a) {
    a = a.getRootNode();
    if (z(a)) return a;
  }

  var sb = Element.prototype,
      tb = sb.matches || sb.matchesSelector || sb.mozMatchesSelector || sb.msMatchesSelector || sb.oMatchesSelector || sb.webkitMatchesSelector;

  function ub(a, b) {
    if (a && b) for (var c = Object.getOwnPropertyNames(b), d = 0, e; d < c.length && (e = c[d]); d++) {
      var f = Object.getOwnPropertyDescriptor(b, e);
      f && Object.defineProperty(a, e, f);
    }
  }

  function vb(a, b) {
    for (var c = [], d = 1; d < arguments.length; ++d) c[d - 1] = arguments[d];

    for (d = 0; d < c.length; d++) ub(a, c[d]);

    return a;
  }

  function wb(a, b) {
    for (var c in b) a[c] = b[c];
  }

  var xb = document.createTextNode(""),
      yb = 0,
      zb = [];
  new MutationObserver(function () {
    for (; zb.length;) try {
      zb.shift()();
    } catch (a) {
      throw xb.textContent = yb++, a;
    }
  }).observe(xb, {
    characterData: !0
  });

  function Ab(a) {
    zb.push(a);
    xb.textContent = yb++;
  }

  var Bb = !!document.contains;

  function Cb(a, b) {
    for (; b;) {
      if (b == a) return !0;
      b = b.parentNode;
    }

    return !1;
  }

  ;
  var Db = [],
      Eb;

  function Fb(a) {
    Eb || (Eb = !0, Ab(Gb));
    Db.push(a);
  }

  function Gb() {
    Eb = !1;

    for (var a = !!Db.length; Db.length;) Db.shift()();

    return a;
  }

  Gb.list = Db;

  function Hb() {
    this.a = !1;
    this.addedNodes = [];
    this.removedNodes = [];
    this.V = new Set();
  }

  function Ib(a) {
    a.a || (a.a = !0, Ab(function () {
      Jb(a);
    }));
  }

  function Jb(a) {
    if (a.a) {
      a.a = !1;
      var b = a.takeRecords();
      b.length && a.V.forEach(function (a) {
        a(b);
      });
    }
  }

  Hb.prototype.takeRecords = function () {
    if (this.addedNodes.length || this.removedNodes.length) {
      var a = [{
        addedNodes: this.addedNodes,
        removedNodes: this.removedNodes
      }];
      this.addedNodes = [];
      this.removedNodes = [];
      return a;
    }

    return [];
  };

  function Kb(a, b) {
    a.__shady = a.__shady || {};
    a.__shady.N || (a.__shady.N = new Hb());

    a.__shady.N.V.add(b);

    var c = a.__shady.N;
    return {
      Ea: b,
      C: c,
      Ha: a,
      takeRecords: function () {
        return c.takeRecords();
      }
    };
  }

  function Lb(a) {
    var b = a && a.C;
    b && (b.V.delete(a.Ea), b.V.size || (a.Ha.__shady.N = null));
  }

  function Mb(a, b) {
    var c = b.getRootNode();
    return a.map(function (a) {
      var b = c === a.target.getRootNode();

      if (b && a.addedNodes) {
        if (b = Array.from(a.addedNodes).filter(function (a) {
          return c === a.getRootNode();
        }), b.length) return a = Object.create(a), Object.defineProperty(a, "addedNodes", {
          value: b,
          configurable: !0
        }), a;
      } else if (b) return a;
    }).filter(function (a) {
      return a;
    });
  }

  ;
  var A = {},
      Nb = Element.prototype.insertBefore,
      Ob = Element.prototype.removeChild,
      Pb = Element.prototype.setAttribute,
      Qb = Element.prototype.removeAttribute,
      Rb = Element.prototype.cloneNode,
      Sb = Document.prototype.importNode,
      Tb = Element.prototype.addEventListener,
      Ub = Element.prototype.removeEventListener,
      Vb = Window.prototype.addEventListener,
      Wb = Window.prototype.removeEventListener,
      Xb = Element.prototype.dispatchEvent,
      Yb = Element.prototype.querySelector,
      Zb = Element.prototype.querySelectorAll,
      $b = Node.prototype.contains || HTMLElement.prototype.contains;
  A.appendChild = Element.prototype.appendChild;
  A.insertBefore = Nb;
  A.removeChild = Ob;
  A.setAttribute = Pb;
  A.removeAttribute = Qb;
  A.cloneNode = Rb;
  A.importNode = Sb;
  A.addEventListener = Tb;
  A.removeEventListener = Ub;
  A.ab = Vb;
  A.bb = Wb;
  A.dispatchEvent = Xb;
  A.querySelector = Yb;
  A.querySelectorAll = Zb;
  A.contains = $b;
  var ac = /[&\u00A0"]/g,
      bc = /[&\u00A0<>]/g;

  function cc(a) {
    switch (a) {
      case "&":
        return "&amp;";

      case "<":
        return "&lt;";

      case ">":
        return "&gt;";

      case '"':
        return "&quot;";

      case "\u00a0":
        return "&nbsp;";
    }
  }

  function dc(a) {
    for (var b = {}, c = 0; c < a.length; c++) b[a[c]] = !0;

    return b;
  }

  var ec = dc("area base br col command embed hr img input keygen link meta param source track wbr".split(" ")),
      fc = dc("style script xmp iframe noembed noframes plaintext noscript".split(" "));

  function gc(a, b) {
    "template" === a.localName && (a = a.content);

    for (var c = "", d = b ? b(a) : a.childNodes, e = 0, f = d.length, h; e < f && (h = d[e]); e++) {
      a: {
        var g = h;
        var k = a;
        var l = b;

        switch (g.nodeType) {
          case Node.ELEMENT_NODE:
            for (var m = g.localName, n = "<" + m, w = g.attributes, I = 0; k = w[I]; I++) n += " " + k.name + '="' + k.value.replace(ac, cc) + '"';

            n += ">";
            g = ec[m] ? n : n + gc(g, l) + "</" + m + ">";
            break a;

          case Node.TEXT_NODE:
            g = g.data;
            g = k && fc[k.localName] ? g : g.replace(bc, cc);
            break a;

          case Node.COMMENT_NODE:
            g = "\x3c!--" + g.data + "--\x3e";
            break a;

          default:
            throw window.console.error(g), Error("not implemented");
        }
      }

      c += g;
    }

    return c;
  }

  ;
  var B = {},
      C = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, !1),
      D = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, !1);

  function hc(a) {
    var b = [];
    C.currentNode = a;

    for (a = C.firstChild(); a;) b.push(a), a = C.nextSibling();

    return b;
  }

  B.parentNode = function (a) {
    C.currentNode = a;
    return C.parentNode();
  };

  B.firstChild = function (a) {
    C.currentNode = a;
    return C.firstChild();
  };

  B.lastChild = function (a) {
    C.currentNode = a;
    return C.lastChild();
  };

  B.previousSibling = function (a) {
    C.currentNode = a;
    return C.previousSibling();
  };

  B.nextSibling = function (a) {
    C.currentNode = a;
    return C.nextSibling();
  };

  B.childNodes = hc;

  B.parentElement = function (a) {
    D.currentNode = a;
    return D.parentNode();
  };

  B.firstElementChild = function (a) {
    D.currentNode = a;
    return D.firstChild();
  };

  B.lastElementChild = function (a) {
    D.currentNode = a;
    return D.lastChild();
  };

  B.previousElementSibling = function (a) {
    D.currentNode = a;
    return D.previousSibling();
  };

  B.nextElementSibling = function (a) {
    D.currentNode = a;
    return D.nextSibling();
  };

  B.children = function (a) {
    var b = [];
    D.currentNode = a;

    for (a = D.firstChild(); a;) b.push(a), a = D.nextSibling();

    return b;
  };

  B.innerHTML = function (a) {
    return gc(a, function (a) {
      return hc(a);
    });
  };

  B.textContent = function (a) {
    switch (a.nodeType) {
      case Node.ELEMENT_NODE:
      case Node.DOCUMENT_FRAGMENT_NODE:
        a = document.createTreeWalker(a, NodeFilter.SHOW_TEXT, null, !1);

        for (var b = "", c; c = a.nextNode();) b += c.nodeValue;

        return b;

      default:
        return a.nodeValue;
    }
  };

  var ic = Object.getOwnPropertyDescriptor(Element.prototype, "innerHTML") || Object.getOwnPropertyDescriptor(HTMLElement.prototype, "innerHTML"),
      jc = document.implementation.createHTMLDocument("inert"),
      kc = Object.getOwnPropertyDescriptor(Document.prototype, "activeElement"),
      lc = {
    parentElement: {
      get: function () {
        var a = this.__shady && this.__shady.parentNode;
        a && a.nodeType !== Node.ELEMENT_NODE && (a = null);
        return void 0 !== a ? a : B.parentElement(this);
      },
      configurable: !0
    },
    parentNode: {
      get: function () {
        var a = this.__shady && this.__shady.parentNode;
        return void 0 !== a ? a : B.parentNode(this);
      },
      configurable: !0
    },
    nextSibling: {
      get: function () {
        var a = this.__shady && this.__shady.nextSibling;
        return void 0 !== a ? a : B.nextSibling(this);
      },
      configurable: !0
    },
    previousSibling: {
      get: function () {
        var a = this.__shady && this.__shady.previousSibling;
        return void 0 !== a ? a : B.previousSibling(this);
      },
      configurable: !0
    },
    className: {
      get: function () {
        return this.getAttribute("class") || "";
      },
      set: function (a) {
        this.setAttribute("class", a);
      },
      configurable: !0
    },
    nextElementSibling: {
      get: function () {
        if (this.__shady && void 0 !== this.__shady.nextSibling) {
          for (var a = this.nextSibling; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.nextSibling;

          return a;
        }

        return B.nextElementSibling(this);
      },
      configurable: !0
    },
    previousElementSibling: {
      get: function () {
        if (this.__shady && void 0 !== this.__shady.previousSibling) {
          for (var a = this.previousSibling; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.previousSibling;

          return a;
        }

        return B.previousElementSibling(this);
      },
      configurable: !0
    }
  },
      mc = {
    childNodes: {
      get: function () {
        if (qb(this)) {
          if (!this.__shady.childNodes) {
            this.__shady.childNodes = [];

            for (var a = this.firstChild; a; a = a.nextSibling) this.__shady.childNodes.push(a);
          }

          var b = this.__shady.childNodes;
        } else b = B.childNodes(this);

        b.item = function (a) {
          return b[a];
        };

        return b;
      },
      configurable: !0
    },
    childElementCount: {
      get: function () {
        return this.children.length;
      },
      configurable: !0
    },
    firstChild: {
      get: function () {
        var a = this.__shady && this.__shady.firstChild;
        return void 0 !== a ? a : B.firstChild(this);
      },
      configurable: !0
    },
    lastChild: {
      get: function () {
        var a = this.__shady && this.__shady.lastChild;
        return void 0 !== a ? a : B.lastChild(this);
      },
      configurable: !0
    },
    textContent: {
      get: function () {
        if (qb(this)) {
          for (var a = [], b = 0, c = this.childNodes, d; d = c[b]; b++) d.nodeType !== Node.COMMENT_NODE && a.push(d.textContent);

          return a.join("");
        }

        return B.textContent(this);
      },
      set: function (a) {
        switch (this.nodeType) {
          case Node.ELEMENT_NODE:
          case Node.DOCUMENT_FRAGMENT_NODE:
            for (; this.firstChild;) this.removeChild(this.firstChild);

            (0 < a.length || this.nodeType === Node.ELEMENT_NODE) && this.appendChild(document.createTextNode(a));
            break;

          default:
            this.nodeValue = a;
        }
      },
      configurable: !0
    },
    firstElementChild: {
      get: function () {
        if (this.__shady && void 0 !== this.__shady.firstChild) {
          for (var a = this.firstChild; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.nextSibling;

          return a;
        }

        return B.firstElementChild(this);
      },
      configurable: !0
    },
    lastElementChild: {
      get: function () {
        if (this.__shady && void 0 !== this.__shady.lastChild) {
          for (var a = this.lastChild; a && a.nodeType !== Node.ELEMENT_NODE;) a = a.previousSibling;

          return a;
        }

        return B.lastElementChild(this);
      },
      configurable: !0
    },
    children: {
      get: function () {
        var a;
        qb(this) ? a = Array.prototype.filter.call(this.childNodes, function (a) {
          return a.nodeType === Node.ELEMENT_NODE;
        }) : a = B.children(this);

        a.item = function (b) {
          return a[b];
        };

        return a;
      },
      configurable: !0
    },
    innerHTML: {
      get: function () {
        var a = "template" === this.localName ? this.content : this;
        return qb(this) ? gc(a) : B.innerHTML(a);
      },
      set: function (a) {
        for (var b = "template" === this.localName ? this.content : this; b.firstChild;) b.removeChild(b.firstChild);

        var c = this.localName;
        c && "template" !== c || (c = "div");
        c = jc.createElement(c);

        for (ic && ic.set ? ic.set.call(c, a) : c.innerHTML = a; c.firstChild;) b.appendChild(c.firstChild);
      },
      configurable: !0
    }
  },
      qc = {
    shadowRoot: {
      get: function () {
        return this.__shady && this.__shady.Ua || null;
      },
      configurable: !0
    }
  },
      rc = {
    activeElement: {
      get: function () {
        var a = kc && kc.get ? kc.get.call(document) : y.M ? void 0 : document.activeElement;

        if (a && a.nodeType) {
          var b = !!z(this);

          if (this === document || b && this.host !== a && A.contains.call(this.host, a)) {
            for (b = rb(a); b && b !== this;) a = b.host, b = rb(a);

            a = this === document ? b ? null : a : b === this ? a : null;
          } else a = null;
        } else a = null;

        return a;
      },
      set: function () {},
      configurable: !0
    }
  };

  function E(a, b, c) {
    for (var d in b) {
      var e = Object.getOwnPropertyDescriptor(a, d);
      e && e.configurable || !e && c ? Object.defineProperty(a, d, b[d]) : c && console.warn("Could not define", d, "on", a);
    }
  }

  function F(a) {
    E(a, lc);
    E(a, mc);
    E(a, rc);
  }

  var sc = y.M ? function () {} : function (a) {
    a.__shady && a.__shady.Ba || (a.__shady = a.__shady || {}, a.__shady.Ba = !0, E(a, lc, !0));
  },
      tc = y.M ? function () {} : function (a) {
    a.__shady && a.__shady.za || (a.__shady = a.__shady || {}, a.__shady.za = !0, E(a, mc, !0), E(a, qc, !0));
  };

  function uc(a, b, c) {
    sc(a);
    c = c || null;
    a.__shady = a.__shady || {};
    b.__shady = b.__shady || {};
    c && (c.__shady = c.__shady || {});
    a.__shady.previousSibling = c ? c.__shady.previousSibling : b.lastChild;
    var d = a.__shady.previousSibling;
    d && d.__shady && (d.__shady.nextSibling = a);
    (d = a.__shady.nextSibling = c) && d.__shady && (d.__shady.previousSibling = a);
    a.__shady.parentNode = b;
    c ? c === b.__shady.firstChild && (b.__shady.firstChild = a) : (b.__shady.lastChild = a, b.__shady.firstChild || (b.__shady.firstChild = a));
    b.__shady.childNodes = null;
  }

  function vc(a) {
    if (!a.__shady || void 0 === a.__shady.firstChild) {
      a.__shady = a.__shady || {};
      a.__shady.firstChild = B.firstChild(a);
      a.__shady.lastChild = B.lastChild(a);
      tc(a);

      for (var b = a.__shady.childNodes = B.childNodes(a), c = 0, d; c < b.length && (d = b[c]); c++) d.__shady = d.__shady || {}, d.__shady.parentNode = a, d.__shady.nextSibling = b[c + 1] || null, d.__shady.previousSibling = b[c - 1] || null, sc(d);
    }
  }

  ;

  function wc(a, b, c) {
    if (b === a) throw Error("Failed to execute 'appendChild' on 'Node': The new child element contains the parent.");

    if (c) {
      var d = c.__shady && c.__shady.parentNode;
      if (void 0 !== d && d !== a || void 0 === d && B.parentNode(c) !== a) throw Error("Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.");
    }

    if (c === b) return b;
    b.parentNode && xc(b.parentNode, b);
    d = rb(a);
    var e;
    if (e = d) a: {
      if (!b.__noInsertionPoint) {
        var f;
        "slot" === b.localName ? f = [b] : b.querySelectorAll && (f = b.querySelectorAll("slot"));

        if (f && f.length) {
          e = f;
          break a;
        }
      }

      e = void 0;
    }
    (f = e) && d.H.push.apply(d.H, [].concat(f instanceof Array ? f : ja(ia(f))));
    d && ("slot" === a.localName || f) && yc(d);

    if (qb(a)) {
      d = c;
      tc(a);
      a.__shady = a.__shady || {};
      void 0 !== a.__shady.firstChild && (a.__shady.childNodes = null);

      if (b.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        f = b.childNodes;

        for (e = 0; e < f.length; e++) uc(f[e], a, d);

        b.__shady = b.__shady || {};
        d = void 0 !== b.__shady.firstChild ? null : void 0;
        b.__shady.firstChild = b.__shady.lastChild = d;
        b.__shady.childNodes = d;
      } else uc(b, a, d);

      if (zc(a)) {
        yc(a.__shady.root);
        var h = !0;
      } else a.__shady.root && (h = !0);
    }

    h || (h = z(a) ? a.host : a, c ? (c = Ac(c), A.insertBefore.call(h, b, c)) : A.appendChild.call(h, b));
    Bc(a, b);
    return b;
  }

  function xc(a, b) {
    if (b.parentNode !== a) throw Error("The node to be removed is not a child of this node: " + b);
    var c = rb(b);

    if (qb(a)) {
      b.__shady = b.__shady || {};
      a.__shady = a.__shady || {};
      b === a.__shady.firstChild && (a.__shady.firstChild = b.__shady.nextSibling);
      b === a.__shady.lastChild && (a.__shady.lastChild = b.__shady.previousSibling);
      var d = b.__shady.previousSibling,
          e = b.__shady.nextSibling;
      d && (d.__shady = d.__shady || {}, d.__shady.nextSibling = e);
      e && (e.__shady = e.__shady || {}, e.__shady.previousSibling = d);
      b.__shady.parentNode = b.__shady.previousSibling = b.__shady.nextSibling = void 0;
      void 0 !== a.__shady.childNodes && (a.__shady.childNodes = null);

      if (zc(a)) {
        yc(a.__shady.root);
        var f = !0;
      }
    }

    Cc(b);

    if (c) {
      (d = a && "slot" === a.localName) && (f = !0);
      Dc(c);
      e = c.l;

      for (var h in e) for (var g = e[h], k = 0; k < g.length; k++) {
        var l = g[k];

        if (Cb(b, l)) {
          g.splice(k, 1);
          var m = c.s.indexOf(l);
          0 <= m && c.s.splice(m, 1);
          k--;
          if (m = l.__shady.K) for (l = 0; l < m.length; l++) {
            var n = m[l],
                w = B.parentNode(n);
            w && A.removeChild.call(w, n);
          }
          m = !0;
        }
      }

      (m || d) && yc(c);
    }

    f || (f = z(a) ? a.host : a, (!a.__shady.root && "slot" !== b.localName || f === B.parentNode(b)) && A.removeChild.call(f, b));
    Bc(a, null, b);
    return b;
  }

  function Cc(a) {
    if (a.__shady && void 0 !== a.__shady.ka) for (var b = a.childNodes, c = 0, d = b.length, e; c < d && (e = b[c]); c++) Cc(e);
    a.__shady && (a.__shady.ka = void 0);
  }

  function Ac(a) {
    var b = a;
    a && "slot" === a.localName && (b = (b = a.__shady && a.__shady.K) && b.length ? b[0] : Ac(a.nextSibling));
    return b;
  }

  function zc(a) {
    return (a = a && a.__shady && a.__shady.root) && Ec(a);
  }

  function Fc(a, b) {
    if ("slot" === b) a = a.parentNode, zc(a) && yc(a.__shady.root);else if ("slot" === a.localName && "name" === b && (b = rb(a))) {
      var c = a.Ca,
          d = Gc(a);

      if (d !== c) {
        c = b.l[c];
        var e = c.indexOf(a);
        0 <= e && c.splice(e, 1);
        c = b.l[d] || (b.l[d] = []);
        c.push(a);
        1 < c.length && (b.l[d] = Hc(c));
      }

      yc(b);
    }
  }

  function Bc(a, b, c) {
    if (a = a.__shady && a.__shady.N) b && a.addedNodes.push(b), c && a.removedNodes.push(c), Ib(a);
  }

  function Ic(a) {
    if (a && a.nodeType) {
      a.__shady = a.__shady || {};
      var b = a.__shady.ka;
      void 0 === b && (z(a) ? b = a : b = (b = a.parentNode) ? Ic(b) : a, A.contains.call(document.documentElement, a) && (a.__shady.ka = b));
      return b;
    }
  }

  function Jc(a, b, c) {
    var d = [];
    Kc(a.childNodes, b, c, d);
    return d;
  }

  function Kc(a, b, c, d) {
    for (var e = 0, f = a.length, h; e < f && (h = a[e]); e++) {
      var g;

      if (g = h.nodeType === Node.ELEMENT_NODE) {
        g = h;
        var k = b,
            l = c,
            m = d,
            n = k(g);
        n && m.push(g);
        l && l(n) ? g = n : (Kc(g.childNodes, k, l, m), g = void 0);
      }

      if (g) break;
    }
  }

  var Lc = null;

  function Mc(a, b, c) {
    Lc || (Lc = window.ShadyCSS && window.ShadyCSS.ScopingShim);
    Lc && "class" === b ? Lc.setElementClass(a, c) : (A.setAttribute.call(a, b, c), Fc(a, b));
  }

  function Nc(a, b) {
    if (a.ownerDocument !== document) return A.importNode.call(document, a, b);
    var c = A.importNode.call(document, a, !1);

    if (b) {
      a = a.childNodes;
      b = 0;

      for (var d; b < a.length; b++) d = Nc(a[b], !0), c.appendChild(d);
    }

    return c;
  }

  ;
  var Oc = "__eventWrappers" + Date.now(),
      Pc = {
    blur: !0,
    focus: !0,
    focusin: !0,
    focusout: !0,
    click: !0,
    dblclick: !0,
    mousedown: !0,
    mouseenter: !0,
    mouseleave: !0,
    mousemove: !0,
    mouseout: !0,
    mouseover: !0,
    mouseup: !0,
    wheel: !0,
    beforeinput: !0,
    input: !0,
    keydown: !0,
    keyup: !0,
    compositionstart: !0,
    compositionupdate: !0,
    compositionend: !0,
    touchstart: !0,
    touchend: !0,
    touchmove: !0,
    touchcancel: !0,
    pointerover: !0,
    pointerenter: !0,
    pointerdown: !0,
    pointermove: !0,
    pointerup: !0,
    pointercancel: !0,
    pointerout: !0,
    pointerleave: !0,
    gotpointercapture: !0,
    lostpointercapture: !0,
    dragstart: !0,
    drag: !0,
    dragenter: !0,
    dragleave: !0,
    dragover: !0,
    drop: !0,
    dragend: !0,
    DOMActivate: !0,
    DOMFocusIn: !0,
    DOMFocusOut: !0,
    keypress: !0
  };

  function Qc(a, b) {
    var c = [],
        d = a;

    for (a = a === window ? window : a.getRootNode(); d;) c.push(d), d = d.assignedSlot ? d.assignedSlot : d.nodeType === Node.DOCUMENT_FRAGMENT_NODE && d.host && (b || d !== a) ? d.host : d.parentNode;

    c[c.length - 1] === document && c.push(window);
    return c;
  }

  function Rc(a, b) {
    if (!z) return a;
    a = Qc(a, !0);

    for (var c = 0, d, e, f, h; c < b.length; c++) if (d = b[c], f = d === window ? window : d.getRootNode(), f !== e && (h = a.indexOf(f), e = f), !z(f) || -1 < h) return d;
  }

  var Sc = {
    get composed() {
      !1 !== this.isTrusted && void 0 === this.Z && (this.Z = Pc[this.type]);
      return this.Z || !1;
    },

    composedPath: function () {
      this.na || (this.na = Qc(this.__target, this.composed));
      return this.na;
    },

    get target() {
      return Rc(this.currentTarget, this.composedPath());
    },

    get relatedTarget() {
      if (!this.aa) return null;
      this.oa || (this.oa = Qc(this.aa, !0));
      return Rc(this.currentTarget, this.oa);
    },

    stopPropagation: function () {
      Event.prototype.stopPropagation.call(this);
      this.$ = !0;
    },
    stopImmediatePropagation: function () {
      Event.prototype.stopImmediatePropagation.call(this);
      this.$ = this.ya = !0;
    }
  };

  function Tc(a) {
    function b(b, d) {
      b = new a(b, d);
      b.Z = d && !!d.composed;
      return b;
    }

    wb(b, a);
    b.prototype = a.prototype;
    return b;
  }

  var Uc = {
    focus: !0,
    blur: !0
  };

  function Vc(a) {
    return a.__target !== a.target || a.aa !== a.relatedTarget;
  }

  function Wc(a, b, c) {
    if (c = b.__handlers && b.__handlers[a.type] && b.__handlers[a.type][c]) for (var d = 0, e; (e = c[d]) && (!Vc(a) || a.target !== a.relatedTarget) && (e.call(b, a), !a.ya); d++);
  }

  function Xc(a) {
    var b = a.composedPath();
    Object.defineProperty(a, "currentTarget", {
      get: function () {
        return d;
      },
      configurable: !0
    });

    for (var c = b.length - 1; 0 <= c; c--) {
      var d = b[c];
      Wc(a, d, "capture");
      if (a.$) return;
    }

    Object.defineProperty(a, "eventPhase", {
      get: function () {
        return Event.AT_TARGET;
      }
    });
    var e;

    for (c = 0; c < b.length; c++) {
      d = b[c];
      var f = d.__shady && d.__shady.root;
      if (0 === c || f && f === e) if (Wc(a, d, "bubble"), d !== window && (e = d.getRootNode()), a.$) break;
    }
  }

  function Yc(a, b, c, d, e, f) {
    for (var h = 0; h < a.length; h++) {
      var g = a[h],
          k = g.type,
          l = g.capture,
          m = g.once,
          n = g.passive;
      if (b === g.node && c === k && d === l && e === m && f === n) return h;
    }

    return -1;
  }

  function Zc(a, b, c) {
    if (b) {
      if (c && "object" === typeof c) {
        var d = !!c.capture;
        var e = !!c.once;
        var f = !!c.passive;
      } else d = !!c, f = e = !1;

      var h = c && c.ba || this,
          g = b[Oc];

      if (g) {
        if (-1 < Yc(g, h, a, d, e, f)) return;
      } else b[Oc] = [];

      g = function (d) {
        e && this.removeEventListener(a, b, c);
        d.__target || $c(d);

        if (h !== this) {
          var f = Object.getOwnPropertyDescriptor(d, "currentTarget");
          Object.defineProperty(d, "currentTarget", {
            get: function () {
              return h;
            },
            configurable: !0
          });
        }

        if (d.composed || -1 < d.composedPath().indexOf(h)) if (Vc(d) && d.target === d.relatedTarget) d.eventPhase === Event.BUBBLING_PHASE && d.stopImmediatePropagation();else if (d.eventPhase === Event.CAPTURING_PHASE || d.bubbles || d.target === h || h instanceof Window) {
          var g = "object" === typeof b && b.handleEvent ? b.handleEvent(d) : b.call(h, d);
          h !== this && (f ? (Object.defineProperty(d, "currentTarget", f), f = null) : delete d.currentTarget);
          return g;
        }
      };

      b[Oc].push({
        node: this,
        type: a,
        capture: d,
        once: e,
        passive: f,
        cb: g
      });
      Uc[a] ? (this.__handlers = this.__handlers || {}, this.__handlers[a] = this.__handlers[a] || {
        capture: [],
        bubble: []
      }, this.__handlers[a][d ? "capture" : "bubble"].push(g)) : (this instanceof Window ? A.ab : A.addEventListener).call(this, a, g, c);
    }
  }

  function ad(a, b, c) {
    if (b) {
      if (c && "object" === typeof c) {
        var d = !!c.capture;
        var e = !!c.once;
        var f = !!c.passive;
      } else d = !!c, f = e = !1;

      var h = c && c.ba || this,
          g = void 0;
      var k = null;

      try {
        k = b[Oc];
      } catch (l) {}

      k && (e = Yc(k, h, a, d, e, f), -1 < e && (g = k.splice(e, 1)[0].cb, k.length || (b[Oc] = void 0)));
      (this instanceof Window ? A.bb : A.removeEventListener).call(this, a, g || b, c);
      g && Uc[a] && this.__handlers && this.__handlers[a] && (a = this.__handlers[a][d ? "capture" : "bubble"], g = a.indexOf(g), -1 < g && a.splice(g, 1));
    }
  }

  function bd() {
    for (var a in Uc) window.addEventListener(a, function (a) {
      a.__target || ($c(a), Xc(a));
    }, !0);
  }

  function $c(a) {
    a.__target = a.target;
    a.aa = a.relatedTarget;

    if (y.M) {
      var b = Object.getPrototypeOf(a);

      if (!b.hasOwnProperty("__patchProto")) {
        var c = Object.create(b);
        c.fb = b;
        ub(c, Sc);
        b.__patchProto = c;
      }

      a.__proto__ = b.__patchProto;
    } else ub(a, Sc);
  }

  var cd = Tc(window.Event),
      dd = Tc(window.CustomEvent),
      ed = Tc(window.MouseEvent);

  function fd(a, b) {
    return {
      index: a,
      O: [],
      U: b
    };
  }

  function gd(a, b, c, d) {
    var e = 0,
        f = 0,
        h = 0,
        g = 0,
        k = Math.min(b - e, d - f);
    if (0 == e && 0 == f) a: {
      for (h = 0; h < k; h++) if (a[h] !== c[h]) break a;

      h = k;
    }

    if (b == a.length && d == c.length) {
      g = a.length;

      for (var l = c.length, m = 0; m < k - h && hd(a[--g], c[--l]);) m++;

      g = m;
    }

    e += h;
    f += h;
    b -= g;
    d -= g;
    if (0 == b - e && 0 == d - f) return [];

    if (e == b) {
      for (b = fd(e, 0); f < d;) b.O.push(c[f++]);

      return [b];
    }

    if (f == d) return [fd(e, b - e)];
    k = e;
    h = f;
    d = d - h + 1;
    g = b - k + 1;
    b = Array(d);

    for (l = 0; l < d; l++) b[l] = Array(g), b[l][0] = l;

    for (l = 0; l < g; l++) b[0][l] = l;

    for (l = 1; l < d; l++) for (m = 1; m < g; m++) if (a[k + m - 1] === c[h + l - 1]) b[l][m] = b[l - 1][m - 1];else {
      var n = b[l - 1][m] + 1,
          w = b[l][m - 1] + 1;
      b[l][m] = n < w ? n : w;
    }

    k = b.length - 1;
    h = b[0].length - 1;
    d = b[k][h];

    for (a = []; 0 < k || 0 < h;) 0 == k ? (a.push(2), h--) : 0 == h ? (a.push(3), k--) : (g = b[k - 1][h - 1], l = b[k - 1][h], m = b[k][h - 1], n = l < m ? l < g ? l : g : m < g ? m : g, n == g ? (g == d ? a.push(0) : (a.push(1), d = g), k--, h--) : n == l ? (a.push(3), k--, d = l) : (a.push(2), h--, d = m));

    a.reverse();
    b = void 0;
    k = [];

    for (h = 0; h < a.length; h++) switch (a[h]) {
      case 0:
        b && (k.push(b), b = void 0);
        e++;
        f++;
        break;

      case 1:
        b || (b = fd(e, 0));
        b.U++;
        e++;
        b.O.push(c[f]);
        f++;
        break;

      case 2:
        b || (b = fd(e, 0));
        b.U++;
        e++;
        break;

      case 3:
        b || (b = fd(e, 0)), b.O.push(c[f]), f++;
    }

    b && k.push(b);
    return k;
  }

  function hd(a, b) {
    return a === b;
  }

  ;
  var id = {};

  function G(a, b, c) {
    if (a !== id) throw new TypeError("Illegal constructor");
    a = document.createDocumentFragment();
    a.__proto__ = G.prototype;
    a.Aa = "ShadyRoot";
    vc(b);
    vc(a);
    a.host = b;
    a.a = c && c.mode;
    b.__shady = b.__shady || {};
    b.__shady.root = a;
    b.__shady.Ua = "closed" !== a.a ? a : null;
    a.T = !1;
    a.s = [];
    a.l = {};
    a.H = [];
    c = B.childNodes(b);

    for (var d = 0, e = c.length; d < e; d++) A.removeChild.call(b, c[d]);

    return a;
  }

  G.prototype = Object.create(DocumentFragment.prototype);

  function yc(a) {
    a.T || (a.T = !0, Fb(function () {
      return jd(a);
    }));
  }

  function jd(a) {
    for (var b; a;) {
      a.T && (b = a);

      a: {
        var c = a;
        a = c.host.getRootNode();
        if (z(a)) for (var d = c.host.childNodes, e = 0; e < d.length; e++) if (c = d[e], "slot" == c.localName) break a;
        a = void 0;
      }
    }

    b && b._renderRoot();
  }

  G.prototype._renderRoot = function () {
    this.T = !1;
    Dc(this);

    for (var a = 0, b; a < this.s.length; a++) {
      b = this.s[a];
      var c = b.__shady.assignedNodes;
      b.__shady.assignedNodes = [];
      b.__shady.K = [];
      if (b.__shady.qa = c) for (var d = 0; d < c.length; d++) {
        var e = c[d];
        e.__shady.ga = e.__shady.assignedSlot;
        e.__shady.assignedSlot === b && (e.__shady.assignedSlot = null);
      }
    }

    for (b = this.host.firstChild; b; b = b.nextSibling) kd(this, b);

    for (a = 0; a < this.s.length; a++) {
      b = this.s[a];
      if (!b.__shady.assignedNodes.length) for (c = b.firstChild; c; c = c.nextSibling) kd(this, c, b);
      c = b.parentNode;
      (c = c.__shady && c.__shady.root) && Ec(c) && c._renderRoot();
      ld(this, b.__shady.K, b.__shady.assignedNodes);

      if (c = b.__shady.qa) {
        for (d = 0; d < c.length; d++) c[d].__shady.ga = null;

        b.__shady.qa = null;
        c.length > b.__shady.assignedNodes.length && (b.__shady.ia = !0);
      }

      b.__shady.ia && (b.__shady.ia = !1, md(this, b));
    }

    a = this.s;
    b = [];

    for (c = 0; c < a.length; c++) d = a[c].parentNode, d.__shady && d.__shady.root || !(0 > b.indexOf(d)) || b.push(d);

    for (a = 0; a < b.length; a++) {
      c = b[a];
      d = c === this ? this.host : c;
      e = [];
      c = c.childNodes;

      for (var f = 0; f < c.length; f++) {
        var h = c[f];

        if ("slot" == h.localName) {
          h = h.__shady.K;

          for (var g = 0; g < h.length; g++) e.push(h[g]);
        } else e.push(h);
      }

      c = void 0;
      f = B.childNodes(d);
      h = gd(e, e.length, f, f.length);

      for (var k = g = 0; g < h.length && (c = h[g]); g++) {
        for (var l = 0, m; l < c.O.length && (m = c.O[l]); l++) B.parentNode(m) === d && A.removeChild.call(d, m), f.splice(c.index + k, 1);

        k -= c.U;
      }

      for (k = 0; k < h.length && (c = h[k]); k++) for (g = f[c.index], l = c.index; l < c.index + c.U; l++) m = e[l], A.insertBefore.call(d, m, g), f.splice(l, 0, m);
    }
  };

  function kd(a, b, c) {
    b.__shady = b.__shady || {};
    var d = b.__shady.ga;
    b.__shady.ga = null;
    c || (c = (a = a.l[b.slot || "__catchall"]) && a[0]);
    c ? (c.__shady.assignedNodes.push(b), b.__shady.assignedSlot = c) : b.__shady.assignedSlot = void 0;
    d !== b.__shady.assignedSlot && b.__shady.assignedSlot && (b.__shady.assignedSlot.__shady.ia = !0);
  }

  function ld(a, b, c) {
    for (var d = 0, e; d < c.length && (e = c[d]); d++) if ("slot" == e.localName) {
      var f = e.__shady.assignedNodes;
      f && f.length && ld(a, b, f);
    } else b.push(c[d]);
  }

  function md(a, b) {
    A.dispatchEvent.call(b, new Event("slotchange"));
    b.__shady.assignedSlot && md(a, b.__shady.assignedSlot);
  }

  function Dc(a) {
    if (a.H.length) {
      for (var b = a.H, c, d = 0; d < b.length; d++) {
        var e = b[d];
        e.__shady = e.__shady || {};
        vc(e);
        vc(e.parentNode);
        var f = Gc(e);
        a.l[f] ? (c = c || {}, c[f] = !0, a.l[f].push(e)) : a.l[f] = [e];
        a.s.push(e);
      }

      if (c) for (var h in c) a.l[h] = Hc(a.l[h]);
      a.H = [];
    }
  }

  function Gc(a) {
    var b = a.name || a.getAttribute("name") || "__catchall";
    return a.Ca = b;
  }

  function Hc(a) {
    return a.sort(function (a, c) {
      a = nd(a);

      for (var b = nd(c), e = 0; e < a.length; e++) {
        c = a[e];
        var f = b[e];
        if (c !== f) return a = Array.from(c.parentNode.childNodes), a.indexOf(c) - a.indexOf(f);
      }
    });
  }

  function nd(a) {
    var b = [];

    do b.unshift(a); while (a = a.parentNode);

    return b;
  }

  function Ec(a) {
    Dc(a);
    return !!a.s.length;
  }

  G.prototype.addEventListener = function (a, b, c) {
    "object" !== typeof c && (c = {
      capture: !!c
    });
    c.ba = this;
    this.host.addEventListener(a, b, c);
  };

  G.prototype.removeEventListener = function (a, b, c) {
    "object" !== typeof c && (c = {
      capture: !!c
    });
    c.ba = this;
    this.host.removeEventListener(a, b, c);
  };

  G.prototype.getElementById = function (a) {
    return Jc(this, function (b) {
      return b.id == a;
    }, function (a) {
      return !!a;
    })[0] || null;
  };

  var od = G.prototype;
  E(od, mc, !0);
  E(od, rc, !0);

  function pd(a) {
    var b = a.getRootNode();
    z(b) && jd(b);
    return a.__shady && a.__shady.assignedSlot || null;
  }

  var qd = {
    addEventListener: Zc.bind(window),
    removeEventListener: ad.bind(window)
  },
      rd = {
    addEventListener: Zc,
    removeEventListener: ad,
    appendChild: function (a) {
      return wc(this, a);
    },
    insertBefore: function (a, b) {
      return wc(this, a, b);
    },
    removeChild: function (a) {
      return xc(this, a);
    },
    replaceChild: function (a, b) {
      wc(this, a, b);
      xc(this, b);
      return a;
    },
    cloneNode: function (a) {
      if ("template" == this.localName) var b = A.cloneNode.call(this, a);else if (b = A.cloneNode.call(this, !1), a) {
        a = this.childNodes;

        for (var c = 0, d; c < a.length; c++) d = a[c].cloneNode(!0), b.appendChild(d);
      }
      return b;
    },
    getRootNode: function () {
      return Ic(this);
    },
    contains: function (a) {
      return Cb(this, a);
    },

    get isConnected() {
      var a = this.ownerDocument;
      if (Bb && A.contains.call(a, this) || a.documentElement && A.contains.call(a.documentElement, this)) return !0;

      for (a = this; a && !(a instanceof Document);) a = a.parentNode || (a instanceof G ? a.host : void 0);

      return !!(a && a instanceof Document);
    },

    dispatchEvent: function (a) {
      Gb();
      return A.dispatchEvent.call(this, a);
    }
  },
      sd = {
    get assignedSlot() {
      return pd(this);
    }

  },
      td = {
    querySelector: function (a) {
      return Jc(this, function (b) {
        return tb.call(b, a);
      }, function (a) {
        return !!a;
      })[0] || null;
    },
    querySelectorAll: function (a) {
      return Jc(this, function (b) {
        return tb.call(b, a);
      });
    }
  },
      ud = {
    assignedNodes: function (a) {
      if ("slot" === this.localName) {
        var b = this.getRootNode();
        z(b) && jd(b);
        return this.__shady ? (a && a.flatten ? this.__shady.K : this.__shady.assignedNodes) || [] : [];
      }
    }
  },
      vd = vb({
    setAttribute: function (a, b) {
      Mc(this, a, b);
    },
    removeAttribute: function (a) {
      A.removeAttribute.call(this, a);
      Fc(this, a);
    },
    attachShadow: function (a) {
      if (!this) throw "Must provide a host.";
      if (!a) throw "Not enough arguments.";
      return new G(id, this, a);
    },

    get slot() {
      return this.getAttribute("slot");
    },

    set slot(a) {
      Mc(this, "slot", a);
    },

    get assignedSlot() {
      return pd(this);
    }

  }, td, ud);
  Object.defineProperties(vd, qc);
  var wd = vb({
    importNode: function (a, b) {
      return Nc(a, b);
    },
    getElementById: function (a) {
      return Jc(this, function (b) {
        return b.id == a;
      }, function (a) {
        return !!a;
      })[0] || null;
    }
  }, td);
  Object.defineProperties(wd, {
    _activeElement: rc.activeElement
  });
  var xd = HTMLElement.prototype.blur,
      yd = vb({
    blur: function () {
      var a = this.__shady && this.__shady.root;
      (a = a && a.activeElement) ? a.blur() : xd.call(this);
    }
  });

  function H(a, b) {
    for (var c = Object.getOwnPropertyNames(b), d = 0; d < c.length; d++) {
      var e = c[d],
          f = Object.getOwnPropertyDescriptor(b, e);
      f.value ? a[e] = f.value : Object.defineProperty(a, e, f);
    }
  }

  ;

  if (y.ta) {
    var ShadyDOM = {
      inUse: y.ta,
      patch: function (a) {
        return a;
      },
      isShadyRoot: z,
      enqueue: Fb,
      flush: Gb,
      settings: y,
      filterMutations: Mb,
      observeChildren: Kb,
      unobserveChildren: Lb,
      nativeMethods: A,
      nativeTree: B
    };
    window.ShadyDOM = ShadyDOM;
    window.Event = cd;
    window.CustomEvent = dd;
    window.MouseEvent = ed;
    bd();
    var zd = window.customElements && window.customElements.nativeHTMLElement || HTMLElement;
    H(window.Node.prototype, rd);
    H(window.Window.prototype, qd);
    H(window.Text.prototype, sd);
    H(window.DocumentFragment.prototype, td);
    H(window.Element.prototype, vd);
    H(window.Document.prototype, wd);
    window.HTMLSlotElement && H(window.HTMLSlotElement.prototype, ud);
    H(zd.prototype, yd);
    y.M && (F(window.Node.prototype), F(window.Text.prototype), F(window.DocumentFragment.prototype), F(window.Element.prototype), F(zd.prototype), F(window.Document.prototype), window.HTMLSlotElement && F(window.HTMLSlotElement.prototype));
    window.ShadowRoot = G;
  }

  ;
  var Ad = new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));

  function Bd(a) {
    var b = Ad.has(a);
    a = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(a);
    return !b && a;
  }

  function J(a) {
    var b = a.isConnected;
    if (void 0 !== b) return b;

    for (; a && !(a.__CE_isImportDocument || a instanceof Document);) a = a.parentNode || (window.ShadowRoot && a instanceof ShadowRoot ? a.host : void 0);

    return !(!a || !(a.__CE_isImportDocument || a instanceof Document));
  }

  function Cd(a, b) {
    for (; b && b !== a && !b.nextSibling;) b = b.parentNode;

    return b && b !== a ? b.nextSibling : null;
  }

  function K(a, b, c) {
    c = void 0 === c ? new Set() : c;

    for (var d = a; d;) {
      if (d.nodeType === Node.ELEMENT_NODE) {
        var e = d;
        b(e);
        var f = e.localName;

        if ("link" === f && "import" === e.getAttribute("rel")) {
          d = e.import;
          if (d instanceof Node && !c.has(d)) for (c.add(d), d = d.firstChild; d; d = d.nextSibling) K(d, b, c);
          d = Cd(a, e);
          continue;
        } else if ("template" === f) {
          d = Cd(a, e);
          continue;
        }

        if (e = e.__CE_shadowRoot) for (e = e.firstChild; e; e = e.nextSibling) K(e, b, c);
      }

      d = d.firstChild ? d.firstChild : Cd(a, d);
    }
  }

  function L(a, b, c) {
    a[b] = c;
  }

  ;

  function Dd() {
    this.a = new Map();
    this.o = new Map();
    this.h = [];
    this.c = !1;
  }

  function Ed(a, b, c) {
    a.a.set(b, c);
    a.o.set(c.constructor, c);
  }

  function Fd(a, b) {
    a.c = !0;
    a.h.push(b);
  }

  function Gd(a, b) {
    a.c && K(b, function (b) {
      return a.b(b);
    });
  }

  Dd.prototype.b = function (a) {
    if (this.c && !a.__CE_patched) {
      a.__CE_patched = !0;

      for (var b = 0; b < this.h.length; b++) this.h[b](a);
    }
  };

  function M(a, b) {
    var c = [];
    K(b, function (a) {
      return c.push(a);
    });

    for (b = 0; b < c.length; b++) {
      var d = c[b];
      1 === d.__CE_state ? a.connectedCallback(d) : Hd(a, d);
    }
  }

  function N(a, b) {
    var c = [];
    K(b, function (a) {
      return c.push(a);
    });

    for (b = 0; b < c.length; b++) {
      var d = c[b];
      1 === d.__CE_state && a.disconnectedCallback(d);
    }
  }

  function O(a, b, c) {
    c = void 0 === c ? {} : c;

    var d = c.$a || new Set(),
        e = c.wa || function (b) {
      return Hd(a, b);
    },
        f = [];

    K(b, function (b) {
      if ("link" === b.localName && "import" === b.getAttribute("rel")) {
        var c = b.import;
        c instanceof Node && (c.__CE_isImportDocument = !0, c.__CE_hasRegistry = !0);
        c && "complete" === c.readyState ? c.__CE_documentLoadHandled = !0 : b.addEventListener("load", function () {
          var c = b.import;

          if (!c.__CE_documentLoadHandled) {
            c.__CE_documentLoadHandled = !0;
            var f = new Set(d);
            f.delete(c);
            O(a, c, {
              $a: f,
              wa: e
            });
          }
        });
      } else f.push(b);
    }, d);
    if (a.c) for (b = 0; b < f.length; b++) a.b(f[b]);

    for (b = 0; b < f.length; b++) e(f[b]);
  }

  function Hd(a, b) {
    if (void 0 === b.__CE_state) {
      var c = b.ownerDocument;
      if (c.defaultView || c.__CE_isImportDocument && c.__CE_hasRegistry) if (c = a.a.get(b.localName)) {
        c.constructionStack.push(b);
        var d = c.constructor;

        try {
          try {
            if (new d() !== b) throw Error("The custom element constructor did not produce the element being upgraded.");
          } finally {
            c.constructionStack.pop();
          }
        } catch (h) {
          throw b.__CE_state = 2, h;
        }

        b.__CE_state = 1;
        b.__CE_definition = c;
        if (c.attributeChangedCallback) for (c = c.observedAttributes, d = 0; d < c.length; d++) {
          var e = c[d],
              f = b.getAttribute(e);
          null !== f && a.attributeChangedCallback(b, e, null, f, null);
        }
        J(b) && a.connectedCallback(b);
      }
    }
  }

  Dd.prototype.connectedCallback = function (a) {
    var b = a.__CE_definition;
    b.connectedCallback && b.connectedCallback.call(a);
  };

  Dd.prototype.disconnectedCallback = function (a) {
    var b = a.__CE_definition;
    b.disconnectedCallback && b.disconnectedCallback.call(a);
  };

  Dd.prototype.attributeChangedCallback = function (a, b, c, d, e) {
    var f = a.__CE_definition;
    f.attributeChangedCallback && -1 < f.observedAttributes.indexOf(b) && f.attributeChangedCallback.call(a, b, c, d, e);
  };

  function Id(a) {
    var b = document;
    this.j = a;
    this.a = b;
    this.C = void 0;
    O(this.j, this.a);
    "loading" === this.a.readyState && (this.C = new MutationObserver(this.b.bind(this)), this.C.observe(this.a, {
      childList: !0,
      subtree: !0
    }));
  }

  function Jd(a) {
    a.C && a.C.disconnect();
  }

  Id.prototype.b = function (a) {
    var b = this.a.readyState;
    "interactive" !== b && "complete" !== b || Jd(this);

    for (b = 0; b < a.length; b++) for (var c = a[b].addedNodes, d = 0; d < c.length; d++) O(this.j, c[d]);
  };

  function Kd() {
    var a = this;
    this.b = this.a = void 0;
    this.c = new Promise(function (b) {
      a.b = b;
      a.a && b(a.a);
    });
  }

  Kd.prototype.resolve = function (a) {
    if (this.a) throw Error("Already resolved.");
    this.a = a;
    this.b && this.b(a);
  };

  function P(a) {
    this.da = !1;
    this.j = a;
    this.ha = new Map();

    this.ea = function (a) {
      return a();
    };

    this.R = !1;
    this.fa = [];
    this.Fa = new Id(a);
  }

  P.prototype.define = function (a, b) {
    var c = this;
    if (!(b instanceof Function)) throw new TypeError("Custom element constructors must be functions.");
    if (!Bd(a)) throw new SyntaxError("The element name '" + a + "' is not valid.");
    if (this.j.a.get(a)) throw Error("A custom element with name '" + a + "' has already been defined.");
    if (this.da) throw Error("A custom element is already being defined.");
    this.da = !0;

    try {
      var d = function (a) {
        var b = e[a];
        if (void 0 !== b && !(b instanceof Function)) throw Error("The '" + a + "' callback must be a function.");
        return b;
      },
          e = b.prototype;

      if (!(e instanceof Object)) throw new TypeError("The custom element constructor's prototype is not an object.");
      var f = d("connectedCallback");
      var h = d("disconnectedCallback");
      var g = d("adoptedCallback");
      var k = d("attributeChangedCallback");
      var l = b.observedAttributes || [];
    } catch (m) {
      return;
    } finally {
      this.da = !1;
    }

    b = {
      localName: a,
      constructor: b,
      connectedCallback: f,
      disconnectedCallback: h,
      adoptedCallback: g,
      attributeChangedCallback: k,
      observedAttributes: l,
      constructionStack: []
    };
    Ed(this.j, a, b);
    this.fa.push(b);
    this.R || (this.R = !0, this.ea(function () {
      return Ld(c);
    }));
  };

  function Ld(a) {
    if (!1 !== a.R) {
      a.R = !1;

      for (var b = a.fa, c = [], d = new Map(), e = 0; e < b.length; e++) d.set(b[e].localName, []);

      O(a.j, document, {
        wa: function (b) {
          if (void 0 === b.__CE_state) {
            var e = b.localName,
                f = d.get(e);
            f ? f.push(b) : a.j.a.get(e) && c.push(b);
          }
        }
      });

      for (e = 0; e < c.length; e++) Hd(a.j, c[e]);

      for (; 0 < b.length;) {
        var f = b.shift();
        e = f.localName;
        f = d.get(f.localName);

        for (var h = 0; h < f.length; h++) Hd(a.j, f[h]);

        (e = a.ha.get(e)) && e.resolve(void 0);
      }
    }
  }

  P.prototype.get = function (a) {
    if (a = this.j.a.get(a)) return a.constructor;
  };

  P.prototype.whenDefined = function (a) {
    if (!Bd(a)) return Promise.reject(new SyntaxError("'" + a + "' is not a valid custom element name."));
    var b = this.ha.get(a);
    if (b) return b.c;
    b = new Kd();
    this.ha.set(a, b);
    this.j.a.get(a) && !this.fa.some(function (b) {
      return b.localName === a;
    }) && b.resolve(void 0);
    return b.c;
  };

  P.prototype.Ta = function (a) {
    Jd(this.Fa);
    var b = this.ea;

    this.ea = function (c) {
      return a(function () {
        return b(c);
      });
    };
  };

  window.CustomElementRegistry = P;
  P.prototype.define = P.prototype.define;
  P.prototype.get = P.prototype.get;
  P.prototype.whenDefined = P.prototype.whenDefined;
  P.prototype.polyfillWrapFlushCallback = P.prototype.Ta;
  var Md = window.Document.prototype.createElement,
      Nd = window.Document.prototype.createElementNS,
      Od = window.Document.prototype.importNode,
      Pd = window.Document.prototype.prepend,
      Qd = window.Document.prototype.append,
      Rd = window.DocumentFragment.prototype.prepend,
      Sd = window.DocumentFragment.prototype.append,
      Td = window.Node.prototype.cloneNode,
      Ud = window.Node.prototype.appendChild,
      Vd = window.Node.prototype.insertBefore,
      Wd = window.Node.prototype.removeChild,
      Xd = window.Node.prototype.replaceChild,
      Yd = Object.getOwnPropertyDescriptor(window.Node.prototype, "textContent"),
      Zd = window.Element.prototype.attachShadow,
      $d = Object.getOwnPropertyDescriptor(window.Element.prototype, "innerHTML"),
      ae = window.Element.prototype.getAttribute,
      be = window.Element.prototype.setAttribute,
      ce = window.Element.prototype.removeAttribute,
      de = window.Element.prototype.getAttributeNS,
      ee = window.Element.prototype.setAttributeNS,
      fe = window.Element.prototype.removeAttributeNS,
      ge = window.Element.prototype.insertAdjacentElement,
      he = window.Element.prototype.prepend,
      ie = window.Element.prototype.append,
      je = window.Element.prototype.before,
      ke = window.Element.prototype.after,
      le = window.Element.prototype.replaceWith,
      me = window.Element.prototype.remove,
      ne = window.HTMLElement,
      oe = Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, "innerHTML"),
      pe = window.HTMLElement.prototype.insertAdjacentElement;
  var qe = new function () {}();

  function re() {
    var a = se;

    window.HTMLElement = function () {
      function b() {
        var b = this.constructor,
            d = a.o.get(b);
        if (!d) throw Error("The custom element being constructed was not registered with `customElements`.");
        var e = d.constructionStack;
        if (0 === e.length) return e = Md.call(document, d.localName), Object.setPrototypeOf(e, b.prototype), e.__CE_state = 1, e.__CE_definition = d, a.b(e), e;
        d = e.length - 1;
        var f = e[d];
        if (f === qe) throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
        e[d] = qe;
        Object.setPrototypeOf(f, b.prototype);
        a.b(f);
        return f;
      }

      b.prototype = ne.prototype;
      return b;
    }();
  }

  ;

  function te(a, b, c) {
    function d(b) {
      return function (c) {
        for (var d = [], e = 0; e < arguments.length; ++e) d[e - 0] = arguments[e];

        e = [];

        for (var f = [], l = 0; l < d.length; l++) {
          var m = d[l];
          m instanceof Element && J(m) && f.push(m);
          if (m instanceof DocumentFragment) for (m = m.firstChild; m; m = m.nextSibling) e.push(m);else e.push(m);
        }

        b.apply(this, d);

        for (d = 0; d < f.length; d++) N(a, f[d]);

        if (J(this)) for (d = 0; d < e.length; d++) f = e[d], f instanceof Element && M(a, f);
      };
    }

    void 0 !== c.X && (b.prepend = d(c.X));
    void 0 !== c.append && (b.append = d(c.append));
  }

  ;

  function ue() {
    var a = se;
    L(Document.prototype, "createElement", function (b) {
      if (this.__CE_hasRegistry) {
        var c = a.a.get(b);
        if (c) return new c.constructor();
      }

      b = Md.call(this, b);
      a.b(b);
      return b;
    });
    L(Document.prototype, "importNode", function (b, c) {
      b = Od.call(this, b, c);
      this.__CE_hasRegistry ? O(a, b) : Gd(a, b);
      return b;
    });
    L(Document.prototype, "createElementNS", function (b, c) {
      if (this.__CE_hasRegistry && (null === b || "http://www.w3.org/1999/xhtml" === b)) {
        var d = a.a.get(c);
        if (d) return new d.constructor();
      }

      b = Nd.call(this, b, c);
      a.b(b);
      return b;
    });
    te(a, Document.prototype, {
      X: Pd,
      append: Qd
    });
  }

  ;

  function ve() {
    var a = se;

    function b(b, d) {
      Object.defineProperty(b, "textContent", {
        enumerable: d.enumerable,
        configurable: !0,
        get: d.get,
        set: function (b) {
          if (this.nodeType === Node.TEXT_NODE) d.set.call(this, b);else {
            var c = void 0;

            if (this.firstChild) {
              var e = this.childNodes,
                  g = e.length;

              if (0 < g && J(this)) {
                c = Array(g);

                for (var k = 0; k < g; k++) c[k] = e[k];
              }
            }

            d.set.call(this, b);
            if (c) for (b = 0; b < c.length; b++) N(a, c[b]);
          }
        }
      });
    }

    L(Node.prototype, "insertBefore", function (b, d) {
      if (b instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(b.childNodes);
        b = Vd.call(this, b, d);
        if (J(this)) for (d = 0; d < c.length; d++) M(a, c[d]);
        return b;
      }

      c = J(b);
      d = Vd.call(this, b, d);
      c && N(a, b);
      J(this) && M(a, b);
      return d;
    });
    L(Node.prototype, "appendChild", function (b) {
      if (b instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(b.childNodes);
        b = Ud.call(this, b);
        if (J(this)) for (var e = 0; e < c.length; e++) M(a, c[e]);
        return b;
      }

      c = J(b);
      e = Ud.call(this, b);
      c && N(a, b);
      J(this) && M(a, b);
      return e;
    });
    L(Node.prototype, "cloneNode", function (b) {
      b = Td.call(this, b);
      this.ownerDocument.__CE_hasRegistry ? O(a, b) : Gd(a, b);
      return b;
    });
    L(Node.prototype, "removeChild", function (b) {
      var c = J(b),
          e = Wd.call(this, b);
      c && N(a, b);
      return e;
    });
    L(Node.prototype, "replaceChild", function (b, d) {
      if (b instanceof DocumentFragment) {
        var c = Array.prototype.slice.apply(b.childNodes);
        b = Xd.call(this, b, d);
        if (J(this)) for (N(a, d), d = 0; d < c.length; d++) M(a, c[d]);
        return b;
      }

      c = J(b);
      var f = Xd.call(this, b, d),
          h = J(this);
      h && N(a, d);
      c && N(a, b);
      h && M(a, b);
      return f;
    });
    Yd && Yd.get ? b(Node.prototype, Yd) : Fd(a, function (a) {
      b(a, {
        enumerable: !0,
        configurable: !0,
        get: function () {
          for (var a = [], b = 0; b < this.childNodes.length; b++) a.push(this.childNodes[b].textContent);

          return a.join("");
        },
        set: function (a) {
          for (; this.firstChild;) Wd.call(this, this.firstChild);

          Ud.call(this, document.createTextNode(a));
        }
      });
    });
  }

  ;

  function we(a) {
    var b = Element.prototype;

    function c(b) {
      return function (c) {
        for (var d = [], e = 0; e < arguments.length; ++e) d[e - 0] = arguments[e];

        e = [];

        for (var g = [], k = 0; k < d.length; k++) {
          var l = d[k];
          l instanceof Element && J(l) && g.push(l);
          if (l instanceof DocumentFragment) for (l = l.firstChild; l; l = l.nextSibling) e.push(l);else e.push(l);
        }

        b.apply(this, d);

        for (d = 0; d < g.length; d++) N(a, g[d]);

        if (J(this)) for (d = 0; d < e.length; d++) g = e[d], g instanceof Element && M(a, g);
      };
    }

    void 0 !== je && (b.before = c(je));
    void 0 !== je && (b.after = c(ke));
    void 0 !== le && L(b, "replaceWith", function (b) {
      for (var c = [], d = 0; d < arguments.length; ++d) c[d - 0] = arguments[d];

      d = [];

      for (var h = [], g = 0; g < c.length; g++) {
        var k = c[g];
        k instanceof Element && J(k) && h.push(k);
        if (k instanceof DocumentFragment) for (k = k.firstChild; k; k = k.nextSibling) d.push(k);else d.push(k);
      }

      g = J(this);
      le.apply(this, c);

      for (c = 0; c < h.length; c++) N(a, h[c]);

      if (g) for (N(a, this), c = 0; c < d.length; c++) h = d[c], h instanceof Element && M(a, h);
    });
    void 0 !== me && L(b, "remove", function () {
      var b = J(this);
      me.call(this);
      b && N(a, this);
    });
  }

  ;

  function xe() {
    var a = se;

    function b(b, c) {
      Object.defineProperty(b, "innerHTML", {
        enumerable: c.enumerable,
        configurable: !0,
        get: c.get,
        set: function (b) {
          var d = this,
              e = void 0;
          J(this) && (e = [], K(this, function (a) {
            a !== d && e.push(a);
          }));
          c.set.call(this, b);
          if (e) for (var f = 0; f < e.length; f++) {
            var l = e[f];
            1 === l.__CE_state && a.disconnectedCallback(l);
          }
          this.ownerDocument.__CE_hasRegistry ? O(a, this) : Gd(a, this);
          return b;
        }
      });
    }

    function c(b, c) {
      L(b, "insertAdjacentElement", function (b, d) {
        var e = J(d);
        b = c.call(this, b, d);
        e && N(a, d);
        J(b) && M(a, d);
        return b;
      });
    }

    Zd && L(Element.prototype, "attachShadow", function (a) {
      return this.__CE_shadowRoot = a = Zd.call(this, a);
    });
    $d && $d.get ? b(Element.prototype, $d) : oe && oe.get ? b(HTMLElement.prototype, oe) : Fd(a, function (a) {
      b(a, {
        enumerable: !0,
        configurable: !0,
        get: function () {
          return Td.call(this, !0).innerHTML;
        },
        set: function (a) {
          var b = "template" === this.localName,
              c = b ? this.content : this,
              d = Md.call(document, this.localName);

          for (d.innerHTML = a; 0 < c.childNodes.length;) Wd.call(c, c.childNodes[0]);

          for (a = b ? d.content : d; 0 < a.childNodes.length;) Ud.call(c, a.childNodes[0]);
        }
      });
    });
    L(Element.prototype, "setAttribute", function (b, c) {
      if (1 !== this.__CE_state) return be.call(this, b, c);
      var d = ae.call(this, b);
      be.call(this, b, c);
      c = ae.call(this, b);
      a.attributeChangedCallback(this, b, d, c, null);
    });
    L(Element.prototype, "setAttributeNS", function (b, c, f) {
      if (1 !== this.__CE_state) return ee.call(this, b, c, f);
      var d = de.call(this, b, c);
      ee.call(this, b, c, f);
      f = de.call(this, b, c);
      a.attributeChangedCallback(this, c, d, f, b);
    });
    L(Element.prototype, "removeAttribute", function (b) {
      if (1 !== this.__CE_state) return ce.call(this, b);
      var c = ae.call(this, b);
      ce.call(this, b);
      null !== c && a.attributeChangedCallback(this, b, c, null, null);
    });
    L(Element.prototype, "removeAttributeNS", function (b, c) {
      if (1 !== this.__CE_state) return fe.call(this, b, c);
      var d = de.call(this, b, c);
      fe.call(this, b, c);
      var e = de.call(this, b, c);
      d !== e && a.attributeChangedCallback(this, c, d, e, b);
    });
    pe ? c(HTMLElement.prototype, pe) : ge ? c(Element.prototype, ge) : console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");
    te(a, Element.prototype, {
      X: he,
      append: ie
    });
    we(a);
  }

  ;
  var ye = window.customElements;

  if (!ye || ye.forcePolyfill || "function" != typeof ye.define || "function" != typeof ye.get) {
    var se = new Dd();
    re();
    ue();
    te(se, DocumentFragment.prototype, {
      X: Rd,
      append: Sd
    });
    ve();
    xe();
    document.__CE_hasRegistry = !0;
    var customElements = new P(se);
    Object.defineProperty(window, "customElements", {
      configurable: !0,
      enumerable: !0,
      value: customElements
    });
  }

  ;

  function ze() {
    this.end = this.start = 0;
    this.rules = this.parent = this.previous = null;
    this.cssText = this.parsedCssText = "";
    this.atRule = !1;
    this.type = 0;
    this.parsedSelector = this.selector = this.keyframesName = "";
  }

  function Ae(a) {
    a = a.replace(Be, "").replace(Ce, "");
    var b = De,
        c = a,
        d = new ze();
    d.start = 0;
    d.end = c.length;

    for (var e = d, f = 0, h = c.length; f < h; f++) if ("{" === c[f]) {
      e.rules || (e.rules = []);
      var g = e,
          k = g.rules[g.rules.length - 1] || null;
      e = new ze();
      e.start = f + 1;
      e.parent = g;
      e.previous = k;
      g.rules.push(e);
    } else "}" === c[f] && (e.end = f + 1, e = e.parent || d);

    return b(d, a);
  }

  function De(a, b) {
    var c = b.substring(a.start, a.end - 1);
    a.parsedCssText = a.cssText = c.trim();
    a.parent && (c = b.substring(a.previous ? a.previous.end : a.parent.start, a.start - 1), c = Ee(c), c = c.replace(Fe, " "), c = c.substring(c.lastIndexOf(";") + 1), c = a.parsedSelector = a.selector = c.trim(), a.atRule = 0 === c.indexOf("@"), a.atRule ? 0 === c.indexOf("@media") ? a.type = Je : c.match(Ke) && (a.type = Le, a.keyframesName = a.selector.split(Fe).pop()) : a.type = 0 === c.indexOf("--") ? Me : Ne);
    if (c = a.rules) for (var d = 0, e = c.length, f; d < e && (f = c[d]); d++) De(f, b);
    return a;
  }

  function Ee(a) {
    return a.replace(/\\([0-9a-f]{1,6})\s/gi, function (a, c) {
      a = c;

      for (c = 6 - a.length; c--;) a = "0" + a;

      return "\\" + a;
    });
  }

  function Oe(a, b, c) {
    c = void 0 === c ? "" : c;
    var d = "";

    if (a.cssText || a.rules) {
      var e = a.rules,
          f;
      if (f = e) f = e[0], f = !(f && f.selector && 0 === f.selector.indexOf("--"));

      if (f) {
        f = 0;

        for (var h = e.length, g; f < h && (g = e[f]); f++) d = Oe(g, b, d);
      } else b ? b = a.cssText : (b = a.cssText, b = b.replace(Pe, "").replace(Qe, ""), b = b.replace(Re, "").replace(Se, "")), (d = b.trim()) && (d = "  " + d + "\n");
    }

    d && (a.selector && (c += a.selector + " {\n"), c += d, a.selector && (c += "}\n\n"));
    return c;
  }

  var Ne = 1,
      Le = 7,
      Je = 4,
      Me = 1E3,
      Be = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
      Ce = /@import[^;]*;/gim,
      Pe = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
      Qe = /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
      Re = /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
      Se = /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
      Ke = /^@[^\s]*keyframes/,
      Fe = /\s+/g;
  var Q = !(window.ShadyDOM && window.ShadyDOM.inUse),
      Te;

  function Ue(a) {
    Te = a && a.shimcssproperties ? !1 : Q || !(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) || !window.CSS || !CSS.supports || !CSS.supports("box-shadow", "0 0 0 var(--foo)"));
  }

  window.ShadyCSS && void 0 !== window.ShadyCSS.nativeCss ? Te = window.ShadyCSS.nativeCss : window.ShadyCSS ? (Ue(window.ShadyCSS), window.ShadyCSS = void 0) : Ue(window.WebComponents && window.WebComponents.flags);
  var R = Te;
  var Ve = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,
      We = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,
      Xe = /(--[\w-]+)\s*([:,;)]|$)/gi,
      Ye = /(animation\s*:)|(animation-name\s*:)/,
      Ze = /@media\s(.*)/,
      $e = /\{[^}]*\}/g;
  var af = new Set();

  function bf(a, b) {
    if (!a) return "";
    "string" === typeof a && (a = Ae(a));
    b && cf(a, b);
    return Oe(a, R);
  }

  function df(a) {
    !a.__cssRules && a.textContent && (a.__cssRules = Ae(a.textContent));
    return a.__cssRules || null;
  }

  function ef(a) {
    return !!a.parent && a.parent.type === Le;
  }

  function cf(a, b, c, d) {
    if (a) {
      var e = !1,
          f = a.type;

      if (d && f === Je) {
        var h = a.selector.match(Ze);
        h && (window.matchMedia(h[1]).matches || (e = !0));
      }

      f === Ne ? b(a) : c && f === Le ? c(a) : f === Me && (e = !0);

      if ((a = a.rules) && !e) {
        e = 0;
        f = a.length;

        for (var g; e < f && (g = a[e]); e++) cf(g, b, c, d);
      }
    }
  }

  function ff(a, b, c, d) {
    var e = document.createElement("style");
    b && e.setAttribute("scope", b);
    e.textContent = a;
    gf(e, c, d);
    return e;
  }

  var S = null;

  function gf(a, b, c) {
    b = b || document.head;
    b.insertBefore(a, c && c.nextSibling || b.firstChild);
    S ? a.compareDocumentPosition(S) === Node.DOCUMENT_POSITION_PRECEDING && (S = a) : S = a;
  }

  function hf(a, b) {
    var c = a.indexOf("var(");
    if (-1 === c) return b(a, "", "", "");

    a: {
      var d = 0;
      var e = c + 3;

      for (var f = a.length; e < f; e++) if ("(" === a[e]) d++;else if (")" === a[e] && 0 === --d) break a;

      e = -1;
    }

    d = a.substring(c + 4, e);
    c = a.substring(0, c);
    a = hf(a.substring(e + 1), b);
    e = d.indexOf(",");
    return -1 === e ? b(c, d.trim(), "", a) : b(c, d.substring(0, e).trim(), d.substring(e + 1).trim(), a);
  }

  function jf(a, b) {
    Q ? a.setAttribute("class", b) : window.ShadyDOM.nativeMethods.setAttribute.call(a, "class", b);
  }

  function V(a) {
    var b = a.localName,
        c = "";
    b ? -1 < b.indexOf("-") || (c = b, b = a.getAttribute && a.getAttribute("is") || "") : (b = a.is, c = a.extends);
    return {
      is: b,
      P: c
    };
  }

  ;

  function kf() {}

  function lf(a, b, c) {
    var d = W;
    a.__styleScoped ? a.__styleScoped = null : mf(d, a, b || "", c);
  }

  function mf(a, b, c, d) {
    b.nodeType === Node.ELEMENT_NODE && nf(b, c, d);
    if (b = "template" === b.localName ? (b.content || b.gb).childNodes : b.children || b.childNodes) for (var e = 0; e < b.length; e++) mf(a, b[e], c, d);
  }

  function nf(a, b, c) {
    if (b) if (a.classList) c ? (a.classList.remove("style-scope"), a.classList.remove(b)) : (a.classList.add("style-scope"), a.classList.add(b));else if (a.getAttribute) {
      var d = a.getAttribute(of);
      c ? d && (b = d.replace("style-scope", "").replace(b, ""), jf(a, b)) : jf(a, (d ? d + " " : "") + "style-scope " + b);
    }
  }

  function pf(a, b, c) {
    var d = W,
        e = a.__cssBuild;
    Q || "shady" === e ? b = bf(b, c) : (a = V(a), b = qf(d, b, a.is, a.P, c) + "\n\n");
    return b.trim();
  }

  function qf(a, b, c, d, e) {
    var f = rf(c, d);
    c = c ? sf + c : "";
    return bf(b, function (b) {
      b.c || (b.selector = b.m = tf(a, b, a.b, c, f), b.c = !0);
      e && e(b, c, f);
    });
  }

  function rf(a, b) {
    return b ? "[is=" + a + "]" : a;
  }

  function tf(a, b, c, d, e) {
    var f = b.selector.split(uf);

    if (!ef(b)) {
      b = 0;

      for (var h = f.length, g; b < h && (g = f[b]); b++) f[b] = c.call(a, g, d, e);
    }

    return f.join(uf);
  }

  function vf(a) {
    return a.replace(wf, function (a, c, d) {
      -1 < d.indexOf("+") ? d = d.replace(/\+/g, "___") : -1 < d.indexOf("___") && (d = d.replace(/___/g, "+"));
      return ":" + c + "(" + d + ")";
    });
  }

  kf.prototype.b = function (a, b, c) {
    var d = !1;
    a = a.trim();
    var e = wf.test(a);
    e && (a = a.replace(wf, function (a, b, c) {
      return ":" + b + "(" + c.replace(/\s/g, "") + ")";
    }), a = vf(a));
    a = a.replace(xf, yf + " $1");
    a = a.replace(zf, function (a, e, g) {
      d || (a = Af(g, e, b, c), d = d || a.stop, e = a.Ja, g = a.value);
      return e + g;
    });
    e && (a = vf(a));
    return a;
  };

  function Af(a, b, c, d) {
    var e = a.indexOf(Bf);
    0 <= a.indexOf(yf) ? a = Cf(a, d) : 0 !== e && (a = c ? Df(a, c) : a);
    c = !1;
    0 <= e && (b = "", c = !0);

    if (c) {
      var f = !0;
      c && (a = a.replace(Ef, function (a, b) {
        return " > " + b;
      }));
    }

    a = a.replace(Ff, function (a, b, c) {
      return '[dir="' + c + '"] ' + b + ", " + b + '[dir="' + c + '"]';
    });
    return {
      value: a,
      Ja: b,
      stop: f
    };
  }

  function Df(a, b) {
    a = a.split(Gf);
    a[0] += b;
    return a.join(Gf);
  }

  function Cf(a, b) {
    var c = a.match(Hf);
    return (c = c && c[2].trim() || "") ? c[0].match(If) ? a.replace(Hf, function (a, c, f) {
      return b + f;
    }) : c.split(If)[0] === b ? c : Jf : a.replace(yf, b);
  }

  function Kf(a) {
    a.selector === Lf && (a.selector = "html");
  }

  kf.prototype.c = function (a) {
    return a.match(Bf) ? this.b(a, Mf) : Df(a.trim(), Mf);
  };

  q.Object.defineProperties(kf.prototype, {
    a: {
      configurable: !0,
      enumerable: !0,
      get: function () {
        return "style-scope";
      }
    }
  });
  var wf = /:(nth[-\w]+)\(([^)]+)\)/,
      Mf = ":not(.style-scope)",
      uf = ",",
      zf = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=[])+)/g,
      If = /[[.:#*]/,
      yf = ":host",
      Lf = ":root",
      Bf = "::slotted",
      xf = new RegExp("^(" + Bf + ")"),
      Hf = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,
      Ef = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,
      Ff = /(.*):dir\((?:(ltr|rtl))\)/,
      sf = ".",
      Gf = ":",
      of = "class",
      Jf = "should_not_match",
      W = new kf();

  function Nf(a, b, c, d) {
    this.w = a || null;
    this.b = b || null;
    this.ja = c || [];
    this.G = null;
    this.P = d || "";
    this.a = this.u = this.B = null;
  }

  function X(a) {
    return a ? a.__styleInfo : null;
  }

  function Of(a, b) {
    return a.__styleInfo = b;
  }

  Nf.prototype.c = function () {
    return this.w;
  };

  Nf.prototype._getStyleRules = Nf.prototype.c;
  var Pf,
      Qf = window.Element.prototype;
  Pf = Qf.matches || Qf.matchesSelector || Qf.mozMatchesSelector || Qf.msMatchesSelector || Qf.oMatchesSelector || Qf.webkitMatchesSelector;
  var Rf = navigator.userAgent.match("Trident");

  function Sf() {}

  function Tf(a) {
    var b = {},
        c = [],
        d = 0;
    cf(a, function (a) {
      Uf(a);
      a.index = d++;
      a = a.i.cssText;

      for (var c; c = Xe.exec(a);) {
        var e = c[1];
        ":" !== c[2] && (b[e] = !0);
      }
    }, function (a) {
      c.push(a);
    });
    a.b = c;
    a = [];

    for (var e in b) a.push(e);

    return a;
  }

  function Uf(a) {
    if (!a.i) {
      var b = {},
          c = {};
      Vf(a, c) && (b.v = c, a.rules = null);
      b.cssText = a.parsedCssText.replace($e, "").replace(Ve, "");
      a.i = b;
    }
  }

  function Vf(a, b) {
    var c = a.i;

    if (c) {
      if (c.v) return Object.assign(b, c.v), !0;
    } else {
      c = a.parsedCssText;

      for (var d; a = Ve.exec(c);) {
        d = (a[2] || a[3]).trim();
        if ("inherit" !== d || "unset" !== d) b[a[1].trim()] = d;
        d = !0;
      }

      return d;
    }
  }

  function Wf(a, b, c) {
    b && (b = 0 <= b.indexOf(";") ? Xf(a, b, c) : hf(b, function (b, e, f, h) {
      if (!e) return b + h;
      (e = Wf(a, c[e], c)) && "initial" !== e ? "apply-shim-inherit" === e && (e = "inherit") : e = Wf(a, c[f] || f, c) || f;
      return b + (e || "") + h;
    }));
    return b && b.trim() || "";
  }

  function Xf(a, b, c) {
    b = b.split(";");

    for (var d = 0, e, f; d < b.length; d++) if (e = b[d]) {
      We.lastIndex = 0;
      if (f = We.exec(e)) e = Wf(a, c[f[1]], c);else if (f = e.indexOf(":"), -1 !== f) {
        var h = e.substring(f);
        h = h.trim();
        h = Wf(a, h, c) || h;
        e = e.substring(0, f) + h;
      }
      b[d] = e && e.lastIndexOf(";") === e.length - 1 ? e.slice(0, -1) : e || "";
    }

    return b.join(";");
  }

  function Yf(a, b) {
    var c = {},
        d = [];
    cf(a, function (a) {
      a.i || Uf(a);
      var e = a.m || a.parsedSelector;
      b && a.i.v && e && Pf.call(b, e) && (Vf(a, c), a = a.index, e = parseInt(a / 32, 10), d[e] = (d[e] || 0) | 1 << a % 32);
    }, null, !0);
    return {
      v: c,
      key: d
    };
  }

  function Zf(a, b, c, d) {
    b.i || Uf(b);

    if (b.i.v) {
      var e = V(a);
      a = e.is;
      e = e.P;
      e = a ? rf(a, e) : "html";
      var f = b.parsedSelector,
          h = ":host > *" === f || "html" === f,
          g = 0 === f.indexOf(":host") && !h;
      "shady" === c && (h = f === e + " > *." + e || -1 !== f.indexOf("html"), g = !h && 0 === f.indexOf(e));
      "shadow" === c && (h = ":host > *" === f || "html" === f, g = g && !h);
      if (h || g) c = e, g && (Q && !b.m && (b.m = tf(W, b, W.b, a ? sf + a : "", e)), c = b.m || e), d({
        Xa: c,
        Oa: g,
        ib: h
      });
    }
  }

  function $f(a, b) {
    var c = {},
        d = {},
        e = b && b.__cssBuild;
    cf(b, function (b) {
      Zf(a, b, e, function (e) {
        Pf.call(a.hb || a, e.Xa) && (e.Oa ? Vf(b, c) : Vf(b, d));
      });
    }, null, !0);
    return {
      Va: d,
      Na: c
    };
  }

  function ag(a, b, c, d) {
    var e = V(b),
        f = rf(e.is, e.P),
        h = new RegExp("(?:^|[^.#[:])" + (b.extends ? "\\" + f.slice(0, -1) + "\\]" : f) + "($|[.:[\\s>+~])");
    e = X(b).w;
    var g = bg(e, d);
    return pf(b, e, function (b) {
      var e = "";
      b.i || Uf(b);
      b.i.cssText && (e = Xf(a, b.i.cssText, c));
      b.cssText = e;

      if (!Q && !ef(b) && b.cssText) {
        var k = e = b.cssText;
        null == b.ra && (b.ra = Ye.test(e));
        if (b.ra) if (null == b.W) {
          b.W = [];

          for (var n in g) k = g[n], k = k(e), e !== k && (e = k, b.W.push(n));
        } else {
          for (n = 0; n < b.W.length; ++n) k = g[b.W[n]], e = k(e);

          k = e;
        }
        b.cssText = k;
        b.m = b.m || b.selector;
        e = "." + d;
        n = b.m.split(",");
        k = 0;

        for (var w = n.length, I; k < w && (I = n[k]); k++) n[k] = I.match(h) ? I.replace(f, e) : e + " " + I;

        b.selector = n.join(",");
      }
    });
  }

  function bg(a, b) {
    a = a.b;
    var c = {};
    if (!Q && a) for (var d = 0, e = a[d]; d < a.length; e = a[++d]) {
      var f = e,
          h = b;
      f.h = new RegExp(f.keyframesName, "g");
      f.a = f.keyframesName + "-" + h;
      f.m = f.m || f.selector;
      f.selector = f.m.replace(f.keyframesName, f.a);
      c[e.keyframesName] = cg(e);
    }
    return c;
  }

  function cg(a) {
    return function (b) {
      return b.replace(a.h, a.a);
    };
  }

  function dg(a, b) {
    var c = eg,
        d = df(a);
    a.textContent = bf(d, function (a) {
      var d = a.cssText = a.parsedCssText;
      a.i && a.i.cssText && (d = d.replace(Pe, "").replace(Qe, ""), a.cssText = Xf(c, d, b));
    });
  }

  q.Object.defineProperties(Sf.prototype, {
    a: {
      configurable: !0,
      enumerable: !0,
      get: function () {
        return "x-scope";
      }
    }
  });
  var eg = new Sf();
  var fg = {},
      gg = window.customElements;

  if (gg && !Q) {
    var hg = gg.define;

    gg.define = function (a, b, c) {
      var d = document.createComment(" Shady DOM styles for " + a + " "),
          e = document.head;
      e.insertBefore(d, (S ? S.nextSibling : null) || e.firstChild);
      S = d;
      fg[a] = d;
      return hg.call(gg, a, b, c);
    };
  }

  ;

  function ig() {
    this.cache = {};
  }

  ig.prototype.store = function (a, b, c, d) {
    var e = this.cache[a] || [];
    e.push({
      v: b,
      styleElement: c,
      u: d
    });
    100 < e.length && e.shift();
    this.cache[a] = e;
  };

  ig.prototype.fetch = function (a, b, c) {
    if (a = this.cache[a]) for (var d = a.length - 1; 0 <= d; d--) {
      var e = a[d],
          f;

      a: {
        for (f = 0; f < c.length; f++) {
          var h = c[f];

          if (e.v[h] !== b[h]) {
            f = !1;
            break a;
          }
        }

        f = !0;
      }

      if (f) return e;
    }
  };

  function jg() {}

  function kg(a) {
    for (var b = 0; b < a.length; b++) {
      var c = a[b];
      if (c.target !== document.documentElement && c.target !== document.head) for (var d = 0; d < c.addedNodes.length; d++) {
        var e = c.addedNodes[d];

        if (e.nodeType === Node.ELEMENT_NODE) {
          var f = e.getRootNode();
          var h = e;
          var g = [];
          h.classList ? g = Array.from(h.classList) : h instanceof window.SVGElement && h.hasAttribute("class") && (g = h.getAttribute("class").split(/\s+/));
          h = g;
          g = h.indexOf(W.a);
          if ((h = -1 < g ? h[g + 1] : "") && f === e.ownerDocument) lf(e, h, !0);else if (f.nodeType === Node.DOCUMENT_FRAGMENT_NODE && (f = f.host)) if (f = V(f).is, h === f) for (e = window.ShadyDOM.nativeMethods.querySelectorAll.call(e, ":not(." + W.a + ")"), f = 0; f < e.length; f++) nf(e[f], h);else h && lf(e, h, !0), lf(e, f);
        }
      }
    }
  }

  if (!Q) {
    var lg = new MutationObserver(kg),
        mg = function (a) {
      lg.observe(a, {
        childList: !0,
        subtree: !0
      });
    };

    if (window.customElements && !window.customElements.polyfillWrapFlushCallback) mg(document);else {
      var ng = function () {
        mg(document.body);
      };

      window.HTMLImports ? window.HTMLImports.whenReady(ng) : requestAnimationFrame(function () {
        if ("loading" === document.readyState) {
          var a = function () {
            ng();
            document.removeEventListener("readystatechange", a);
          };

          document.addEventListener("readystatechange", a);
        } else ng();
      });
    }

    jg = function () {
      kg(lg.takeRecords());
    };
  }

  var og = jg;
  var pg = {};
  var qg = Promise.resolve();

  function rg(a) {
    if (a = pg[a]) a._applyShimCurrentVersion = a._applyShimCurrentVersion || 0, a._applyShimValidatingVersion = a._applyShimValidatingVersion || 0, a._applyShimNextVersion = (a._applyShimNextVersion || 0) + 1;
  }

  function sg(a) {
    return a._applyShimCurrentVersion === a._applyShimNextVersion;
  }

  function tg(a) {
    a._applyShimValidatingVersion = a._applyShimNextVersion;
    a.b || (a.b = !0, qg.then(function () {
      a._applyShimCurrentVersion = a._applyShimNextVersion;
      a.b = !1;
    }));
  }

  ;
  var ug = null,
      vg = window.HTMLImports && window.HTMLImports.whenReady || null,
      wg;

  function xg(a) {
    requestAnimationFrame(function () {
      vg ? vg(a) : (ug || (ug = new Promise(function (a) {
        wg = a;
      }), "complete" === document.readyState ? wg() : document.addEventListener("readystatechange", function () {
        "complete" === document.readyState && wg();
      })), ug.then(function () {
        a && a();
      }));
    });
  }

  ;
  var yg = new ig();

  function Y() {
    var a = this;
    this.L = {};
    this.c = document.documentElement;
    var b = new ze();
    b.rules = [];
    this.h = Of(this.c, new Nf(b));
    this.o = !1;
    this.b = this.a = null;
    xg(function () {
      zg(a);
    });
  }

  p = Y.prototype;

  p.xa = function () {
    og();
  };

  p.La = function (a) {
    return df(a);
  };

  p.Za = function (a) {
    return bf(a);
  };

  p.prepareTemplate = function (a, b, c) {
    if (!a.h) {
      a.h = !0;
      a.name = b;
      a.extends = c;
      pg[b] = a;
      var d = (d = a.content.querySelector("style")) ? d.getAttribute("css-build") || "" : "";
      var e = [];

      for (var f = a.content.querySelectorAll("style"), h = 0; h < f.length; h++) {
        var g = f[h];

        if (g.hasAttribute("shady-unscoped")) {
          if (!Q) {
            var k = g.textContent;
            af.has(k) || (af.add(k), k = g.cloneNode(!0), document.head.appendChild(k));
            g.parentNode.removeChild(g);
          }
        } else e.push(g.textContent), g.parentNode.removeChild(g);
      }

      e = e.join("").trim();
      c = {
        is: b,
        extends: c,
        eb: d
      };
      Q || lf(a.content, b);
      zg(this);
      f = We.test(e) || Ve.test(e);
      We.lastIndex = 0;
      Ve.lastIndex = 0;
      e = Ae(e);
      f && R && this.a && this.a.transformRules(e, b);
      a._styleAst = e;
      a.o = d;
      d = [];
      R || (d = Tf(a._styleAst));
      if (!d.length || R) e = Q ? a.content : null, b = fg[b], f = pf(c, a._styleAst), b = f.length ? ff(f, c.is, e, b) : void 0, a.a = b;
      a.c = d;
    }
  };

  function Ag(a) {
    !a.b && window.ShadyCSS && window.ShadyCSS.CustomStyleInterface && (a.b = window.ShadyCSS.CustomStyleInterface, a.b.transformCallback = function (b) {
      a.va(b);
    }, a.b.validateCallback = function () {
      requestAnimationFrame(function () {
        (a.b.enqueued || a.o) && a.F();
      });
    });
  }

  function zg(a) {
    !a.a && window.ShadyCSS && window.ShadyCSS.ApplyShim && (a.a = window.ShadyCSS.ApplyShim, a.a.invalidCallback = rg);
    Ag(a);
  }

  p.F = function () {
    zg(this);

    if (this.b) {
      var a = this.b.processStyles();

      if (this.b.enqueued) {
        if (R) for (var b = 0; b < a.length; b++) {
          var c = this.b.getStyleForCustomStyle(a[b]);

          if (c && R && this.a) {
            var d = df(c);
            zg(this);
            this.a.transformRules(d);
            c.textContent = bf(d);
          }
        } else for (Bg(this, this.c, this.h), b = 0; b < a.length; b++) (c = this.b.getStyleForCustomStyle(a[b])) && dg(c, this.h.B);
        this.b.enqueued = !1;
        this.o && !R && this.styleDocument();
      }
    }
  };

  p.styleElement = function (a, b) {
    var c = V(a).is,
        d = X(a);

    if (!d) {
      var e = V(a);
      d = e.is;
      e = e.P;
      var f = fg[d];
      d = pg[d];

      if (d) {
        var h = d._styleAst;
        var g = d.c;
      }

      d = Of(a, new Nf(h, f, g, e));
    }

    a !== this.c && (this.o = !0);
    b && (d.G = d.G || {}, Object.assign(d.G, b));

    if (R) {
      if (d.G) {
        b = d.G;

        for (var k in b) null === k ? a.style.removeProperty(k) : a.style.setProperty(k, b[k]);
      }

      if (((k = pg[c]) || a === this.c) && k && k.a && !sg(k)) {
        if (sg(k) || k._applyShimValidatingVersion !== k._applyShimNextVersion) zg(this), this.a && this.a.transformRules(k._styleAst, c), k.a.textContent = pf(a, d.w), tg(k);
        Q && (c = a.shadowRoot) && (c.querySelector("style").textContent = pf(a, d.w));
        d.w = k._styleAst;
      }
    } else if (Bg(this, a, d), d.ja && d.ja.length) {
      c = d;
      k = V(a).is;
      d = (b = yg.fetch(k, c.B, c.ja)) ? b.styleElement : null;
      h = c.u;
      (g = b && b.u) || (g = this.L[k] = (this.L[k] || 0) + 1, g = k + "-" + g);
      c.u = g;
      g = c.u;
      e = eg;
      e = d ? d.textContent || "" : ag(e, a, c.B, g);
      f = X(a);
      var l = f.a;
      l && !Q && l !== d && (l._useCount--, 0 >= l._useCount && l.parentNode && l.parentNode.removeChild(l));
      Q ? f.a ? (f.a.textContent = e, d = f.a) : e && (d = ff(e, g, a.shadowRoot, f.b)) : d ? d.parentNode || (Rf && -1 < e.indexOf("@media") && (d.textContent = e), gf(d, null, f.b)) : e && (d = ff(e, g, null, f.b));
      d && (d._useCount = d._useCount || 0, f.a != d && d._useCount++, f.a = d);
      g = d;
      Q || (d = c.u, f = e = a.getAttribute("class") || "", h && (f = e.replace(new RegExp("\\s*x-scope\\s*" + h + "\\s*", "g"), " ")), f += (f ? " " : "") + "x-scope " + d, e !== f && jf(a, f));
      b || yg.store(k, c.B, g, c.u);
    }
  };

  function Cg(a, b) {
    return (b = b.getRootNode().host) ? X(b) ? b : Cg(a, b) : a.c;
  }

  function Bg(a, b, c) {
    a = Cg(a, b);
    var d = X(a);
    a = Object.create(d.B || null);
    var e = $f(b, c.w);
    b = Yf(d.w, b).v;
    Object.assign(a, e.Na, b, e.Va);
    b = c.G;

    for (var f in b) if ((e = b[f]) || 0 === e) a[f] = e;

    f = eg;
    b = Object.getOwnPropertyNames(a);

    for (e = 0; e < b.length; e++) d = b[e], a[d] = Wf(f, a[d], a);

    c.B = a;
  }

  p.styleDocument = function (a) {
    this.styleSubtree(this.c, a);
  };

  p.styleSubtree = function (a, b) {
    var c = a.shadowRoot;
    (c || a === this.c) && this.styleElement(a, b);
    if (b = c && (c.children || c.childNodes)) for (a = 0; a < b.length; a++) this.styleSubtree(b[a]);else if (a = a.children || a.childNodes) for (b = 0; b < a.length; b++) this.styleSubtree(a[b]);
  };

  p.va = function (a) {
    var b = this,
        c = df(a);
    cf(c, function (a) {
      if (Q) Kf(a);else {
        var c = W;
        a.selector = a.parsedSelector;
        Kf(a);
        a.selector = a.m = tf(c, a, c.c, void 0, void 0);
      }
      R && (zg(b), b.a && b.a.transformRule(a));
    });
    R ? a.textContent = bf(c) : this.h.w.rules.push(c);
  };

  p.getComputedStyleValue = function (a, b) {
    var c;
    R || (c = (X(a) || X(Cg(this, a))).B[b]);
    return (c = c || window.getComputedStyle(a).getPropertyValue(b)) ? c.trim() : "";
  };

  p.Ya = function (a, b) {
    var c = a.getRootNode();
    b = b ? b.split(/\s/) : [];
    c = c.host && c.host.localName;

    if (!c) {
      var d = a.getAttribute("class");

      if (d) {
        d = d.split(/\s/);

        for (var e = 0; e < d.length; e++) if (d[e] === W.a) {
          c = d[e + 1];
          break;
        }
      }
    }

    c && b.push(W.a, c);
    R || (c = X(a)) && c.u && b.push(eg.a, c.u);
    jf(a, b.join(" "));
  };

  p.Ia = function (a) {
    return X(a);
  };

  Y.prototype.flush = Y.prototype.xa;
  Y.prototype.prepareTemplate = Y.prototype.prepareTemplate;
  Y.prototype.styleElement = Y.prototype.styleElement;
  Y.prototype.styleDocument = Y.prototype.styleDocument;
  Y.prototype.styleSubtree = Y.prototype.styleSubtree;
  Y.prototype.getComputedStyleValue = Y.prototype.getComputedStyleValue;
  Y.prototype.setElementClass = Y.prototype.Ya;
  Y.prototype._styleInfoForNode = Y.prototype.Ia;
  Y.prototype.transformCustomStyleForDocument = Y.prototype.va;
  Y.prototype.getStyleAst = Y.prototype.La;
  Y.prototype.styleAstToString = Y.prototype.Za;
  Y.prototype.flushCustomStyles = Y.prototype.F;
  Object.defineProperties(Y.prototype, {
    nativeShadow: {
      get: function () {
        return Q;
      }
    },
    nativeCss: {
      get: function () {
        return R;
      }
    }
  });
  var Z = new Y(),
      Dg,
      Eg;
  window.ShadyCSS && (Dg = window.ShadyCSS.ApplyShim, Eg = window.ShadyCSS.CustomStyleInterface);
  window.ShadyCSS = {
    ScopingShim: Z,
    prepareTemplate: function (a, b, c) {
      Z.F();
      Z.prepareTemplate(a, b, c);
    },
    styleSubtree: function (a, b) {
      Z.F();
      Z.styleSubtree(a, b);
    },
    styleElement: function (a) {
      Z.F();
      Z.styleElement(a);
    },
    styleDocument: function (a) {
      Z.F();
      Z.styleDocument(a);
    },
    getComputedStyleValue: function (a, b) {
      return Z.getComputedStyleValue(a, b);
    },
    nativeCss: R,
    nativeShadow: Q
  };
  Dg && (window.ShadyCSS.ApplyShim = Dg);
  Eg && (window.ShadyCSS.CustomStyleInterface = Eg);
  var Fg = window.customElements,
      Gg = window.HTMLImports,
      Hg = window.HTMLTemplateElement;
  window.WebComponents = window.WebComponents || {};

  if (Fg && Fg.polyfillWrapFlushCallback) {
    var Ig,
        Jg = function () {
      if (Ig) {
        Hg.J && Hg.J(window.document);
        var a = Ig;
        Ig = null;
        a();
        return !0;
      }
    },
        Kg = Gg.whenReady;

    Fg.polyfillWrapFlushCallback(function (a) {
      Ig = a;
      Kg(Jg);
    });

    Gg.whenReady = function (a) {
      Kg(function () {
        Jg() ? Gg.whenReady(a) : a();
      });
    };
  }

  Gg.whenReady(function () {
    requestAnimationFrame(function () {
      window.WebComponents.ready = !0;
      document.dispatchEvent(new CustomEvent("WebComponentsReady", {
        bubbles: !0
      }));
    });
  });
  var Lg = document.createElement("style");
  Lg.textContent = "body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";
  var Mg = document.querySelector("head");
  Mg.insertBefore(Lg, Mg.firstChild);
}).call(this); //# sourceMappingURL=webcomponents-lite.js.map
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(36), __webpack_require__(1)))

/***/ }),
/* 36 */
/***/ (function(module, exports) {

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
  // This works if the window reference is available
  if (typeof window === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_react___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_react__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__reactInit__ = __webpack_require__(10);



class Heading extends __WEBPACK_IMPORTED_MODULE_0_react___default.a.Component {
  render() {
    var HeadingTag = `${this.props.size}`;
    return __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("div", null, __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement(HeadingTag, null, this.props.heading), __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("p", null, this.props.subtext), this.props.hashr && __WEBPACK_IMPORTED_MODULE_0_react___default.a.createElement("hr", null));
  }

}

Object(__WEBPACK_IMPORTED_MODULE_1__reactInit__["default"])(".react-heading", Heading);

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tta_underlined_text_html__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tta_underlined_text_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__tta_underlined_text_html__);


class TTAUnderlinedText extends __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__["a" /* Element */] {
  static get is() {
    return "tta-underlined-text";
  }

  static get template() {
    return __WEBPACK_IMPORTED_MODULE_1__tta_underlined_text_html___default.a;
  }

  constructor() {
    super();
  }

  static get properties() {
    return {
      text: {
        type: String
      },
      hasHr: {
        type: Boolean
      }
    };
  }

}
/* harmony export (immutable) */ __webpack_exports__["default"] = TTAUnderlinedText;
 // Register custom element class with browser

customElements.define(TTAUnderlinedText.is, TTAUnderlinedText);

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Element; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_mixins_element_mixin_js__ = __webpack_require__(40);

/**
 * Base class that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @constructor
 * @implements {Polymer_ElementMixin}
 * @extends HTMLElement
 * @appliesMixin Polymer.ElementMixin
 * @summary Custom element base class that provides the core API for Polymer's
 *   key meta-programming features including template stamping, data-binding,
 *   attribute deserialization, and property change observation
 */

const Element = Object(__WEBPACK_IMPORTED_MODULE_0__lib_mixins_element_mixin_js__["a" /* ElementMixin */])(HTMLElement);


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export instanceCount */
/* unused harmony export _regLog */
/* unused harmony export register */
/* unused harmony export dumpRegistrations */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_mixin_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__property_effects_js__ = __webpack_require__(43);









const ElementMixin = Object(__WEBPACK_IMPORTED_MODULE_2__utils_mixin_js__["a" /* dedupingMixin */])(base => {
  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_PropertyEffects}
   */
  const polymerElementBase = Object(__WEBPACK_IMPORTED_MODULE_7__property_effects_js__["a" /* PropertyEffects */])(base);
  let caseMap = __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__;
  /**
   * Returns the `properties` object specifically on `klass`. Use for:
   * (1) super chain mixes togther to make `propertiesForClass` which is
   * then used to make `observedAttributes`.
   * (2) properties effects and observers are created from it at `finalize` time.
   *
   * @param {HTMLElement} klass Element class
   * @return {Object} Object containing own properties for this class
   * @private
   */

  function ownPropertiesForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownProperties', klass))) {
      klass.__ownProperties = klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
      /** @type PolymerElementConstructor */
      klass.properties : {};
    }

    return klass.__ownProperties;
  }
  /**
   * Returns the `observers` array specifically on `klass`. Use for
   * setting up observers.
   *
   * @param {HTMLElement} klass Element class
   * @return {Array} Array containing own observers for this class
   * @private
   */


  function ownObserversForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__ownObservers', klass))) {
      klass.__ownObservers = klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
      /** @type PolymerElementConstructor */
      klass.observers : [];
    }

    return klass.__ownObservers;
  }
  /**
   * Mixes `props` into `flattenedProps` but upgrades shorthand type
   * syntax to { type: Type}.
   *
   * @param {Object} flattenedProps Bag to collect flattened properties into
   * @param {Object} props Bag of properties to add to `flattenedProps`
   * @return {Object} The input `flattenedProps` bag
   * @private
   */


  function flattenProperties(flattenedProps, props) {
    for (let p in props) {
      let o = props[p];

      if (typeof o == 'function') {
        o = {
          type: o
        };
      }

      flattenedProps[p] = o;
    }

    return flattenedProps;
  }
  /**
   * Returns a flattened list of properties mixed together from the chain of all
   * constructor's `config.properties`. This list is used to create
   * (1) observedAttributes,
   * (2) class property default values
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   * @suppress {missingProperties} class.prototype is not a property for some reason?
   * @private
   */


  function propertiesForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classProperties', klass))) {
      klass.__classProperties = flattenProperties({}, ownPropertiesForClass(klass));
      let superCtor = Object.getPrototypeOf(klass.prototype).constructor;

      if (superCtor.prototype instanceof PolymerElement) {
        klass.__classProperties = Object.assign(Object.create(propertiesForClass(
        /** @type PolymerElementConstructor */
        superCtor)), klass.__classProperties);
      }
    }

    return klass.__classProperties;
  }
  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `propertiesForClass`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */


  function propertyDefaultsForClass(klass) {
    if (!klass.hasOwnProperty(JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
      klass.__classPropertyDefaults = null;
      let props = propertiesForClass(klass);

      for (let p in props) {
        let info = props[p];

        if ('value' in info) {
          klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
          klass.__classPropertyDefaults[p] = info;
        }
      }
    }

    return klass.__classPropertyDefaults;
  }
  /**
   * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
   * @param {PolymerElementConstructor} klass Element class
   * @return {boolean} True if all metaprogramming for this class has been
   *   completed
   * @private
   */


  function hasClassFinalized(klass) {
    return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
  }
  /**
   * Called by `ElementClass.finalize()`. Ensures this `klass` and
   * *all superclasses* are finalized by traversing the prototype chain
   * and calling `klass.finalize()`.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */


  function finalizeClassAndSuper(klass) {
    let proto =
    /** @type PolymerElementConstructor */
    klass.prototype;
    let superCtor = Object.getPrototypeOf(proto).constructor;

    if (superCtor.prototype instanceof PolymerElement) {
      superCtor.finalize();
    }

    finalizeClass(klass);
  }
  /**
   * Configures a `klass` based on a staic `klass.config` object and
   * a `template`. This includes creating accessors and effects
   * for properties in `config` and the `template` as well as preparing the
   * `template` for stamping.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */


  function finalizeClass(klass) {
    klass.__finalized = true;
    let proto =
    /** @type PolymerElementConstructor */
    klass.prototype;

    if (klass.hasOwnProperty(JSCompiler_renameProperty('is', klass)) && klass.is) {
      register(proto);
    }

    let props = ownPropertiesForClass(klass);

    if (props) {
      finalizeProperties(proto, props);
    }

    let observers = ownObserversForClass(klass);

    if (observers) {
      finalizeObservers(proto, observers, props);
    } // note: create "working" template that is finalized at instance time


    let template =
    /** @type PolymerElementConstructor */
    klass.template;

    if (template) {
      if (typeof template === 'string') {
        let t = document.createElement('template');
        t.innerHTML = template;
        template = t;
      } else {
        template = template.cloneNode(true);
      }

      proto._template = template;
    }
  }
  /**
   * Configures a `proto` based on a `properties` object.
   * Leverages `PropertyEffects` to create property accessors and effects
   * supporting, observers, reflecting to attributes, change notification,
   * computed properties, and read only properties.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *    and effects to
   * @param {Object} properties Flattened bag of property descriptors for
   *    this class
   * @private
   */


  function finalizeProperties(proto, properties) {
    for (let p in properties) {
      createPropertyFromConfig(proto, p, properties[p], properties);
    }
  }
  /**
   * Configures a `proto` based on a `observers` array.
   * Leverages `PropertyEffects` to create observers.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {Object} observers Flattened array of observer descriptors for
   *   this class
   * @param {Object} dynamicFns Object containing keys for any properties
   *   that are functions and should trigger the effect when the function
   *   reference is changed
   * @private
   */


  function finalizeObservers(proto, observers, dynamicFns) {
    for (let i = 0; i < observers.length; i++) {
      proto._createMethodObserver(observers[i], dynamicFns);
    }
  }
  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should may contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is dersialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * also automatically is set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttriute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   * Also consider adding warnings when an effect cannot be changed.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @private
   */


  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    } // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.


    if (info.computed && !proto._hasReadOnlyEffect(name)) {
      proto._createComputedProperty(name, info.computed, allProps);
    }

    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    }

    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    }

    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    } // always add observer


    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
  }
  /**
   * Configures an element `proto` to function with a given `template`.
   * The element name `is` and extends `ext` must be specified for ShadyCSS
   * style scoping.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {!HTMLTemplateElement} template Template to process and bind
   * @param {string} baseURI URL against which to resolve urls in
   *   style element cssText
   * @param {string} is Tag name (or type extension name) for this element
   * @param {string=} ext For type extensions, the tag name that was extended
   * @private
   */


  function finalizeTemplate(proto, template, baseURI, is, ext) {
    // support `include="module-name"`
    let cssText = Object(__WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__["a" /* cssFromModuleImports */])(is) + Object(__WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__["b" /* cssFromTemplate */])(template, baseURI);

    if (cssText) {
      let style = document.createElement('style');
      style.textContent = cssText;
      template.content.insertBefore(style, template.content.firstChild);
    }

    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is, ext);
    }

    proto._bindTemplate(template);
  }
  /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   */


  class PolymerElement extends polymerElementBase {
    /**
     * Standard Custom Elements V1 API.  The default implementation returns
     * a list of dash-cased attributes based on a flattening of all properties
     * declared in `static get properties()` for this element and any
     * superclasses.
     *
     * @return {Array} Observed attribute list
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
        let list = [];
        let properties = propertiesForClass(this);

        for (let prop in properties) {
          list.push(Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["camelToDashCase"])(prop));
        }

        this.__observedAttributes = list;
      }

      return this.__observedAttributes;
    }
    /**
     * Called automatically when the first element instance is created to
     * ensure that class finalization work has been completed.
     * May be called by users to eagerly perform class finalization work
     * prior to the creation of the first element instance.
     *
     * Class finalization work generally includes meta-programming such as
     * creating property accessors and any property effect metadata needed for
     * the features used.
     *
     * @public
     */


    static finalize() {
      if (!hasClassFinalized(this)) {
        finalizeClassAndSuper(this);
      }
    }
    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation
     * will return the first `<template>` in a `dom-module` whose `id`
     * matches this element's `is`.
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * may be either an `HTMLTemplateElement` or a string that will be
     * automatically parsed into a template.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `Polymer.DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {HTMLTemplateElement|string} Template to be stamped
     */


    static get template() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
        this._template = __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */].import(
        /** @type PolymerElementConstructor*/
        this.is, 'template') || // note: implemented so a subclass can retrieve the super
        // template; call the super impl this way so that `this` points
        // to the superclass.
        Object.getPrototypeOf(
        /** @type PolymerElementConstructor*/
        this.prototype).constructor.template;
      }

      return this._template;
    }
    /**
     * Path matching the url from which the element was imported.
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     * Defaults to the path matching the url containing a `dom-module` element
     * matching this element's static `is` property.
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     */


    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
        const module = __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */].import(
        /** @type PolymerElementConstructor */
        this.is);
        this._importPath = module ? module.assetpath : '' || Object.getPrototypeOf(
        /** @type PolymerElementConstructor*/
        this.prototype).constructor.importPath;
      }

      return this._importPath;
    }

    constructor() {
      super();
      /** @type {HTMLTemplateElement} */

      this._template;
      /** @type {string} */

      this._importPath;
      /** @type {string} */

      this.rootPath;
      /** @type {string} */

      this.importPath;
      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */

      this.root;
      /** @type {!Object<string, !Node>} */

      this.$;
    }
    /**
     * Overrides the default `Polymer.PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @override
     * @suppress {invalidCasts}
     */


    _initializeProperties() {
      instanceCount++;
      this.constructor.finalize();
      const importPath = this.constructor.importPath; // note: finalize template when we have access to `localName` to
      // avoid dependence on `is` for polyfilling styling.

      if (this._template && !this._template.__polymerFinalized) {
        this._template.__polymerFinalized = true;
        const baseURI = importPath ? Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(importPath) : '';
        finalizeTemplate(
        /** @type {!PolymerElement} */
        this.__proto__, this._template, baseURI,
        /**@type {!HTMLElement}*/
        this.localName);
      }

      super._initializeProperties(); // set path defaults


      this.rootPath = __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__["a" /* rootPath */];
      this.importPath = importPath; // apply property defaults...

      let p$ = propertyDefaultsForClass(this.constructor);

      if (!p$) {
        return;
      }

      for (let p in p$) {
        let info = p$[p]; // Don't set default value if there is already an own property, which
        // happens when a `properties` property with default but no effects had
        // a property set (e.g. bound) by its host before upgrade

        if (!this.hasOwnProperty(p)) {
          let value = typeof info.value == 'function' ? info.value.call(this) : info.value; // Set via `_setProperty` if there is an accessor, to enable
          // initializing readOnly property defaults

          if (this._hasAccessor(p)) {
            this._setPendingProperty(p, value, true);
          } else {
            this[p] = value;
          }
        }
      }
    }
    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @suppress {invalidCasts}
     */


    connectedCallback() {
      if (window.ShadyCSS && this._template) {
        window.ShadyCSS.styleElement(
        /** @type {!HTMLElement} */
        this);
      }

      this._enableProperties();
    }
    /**
     * Provides a default implementation of the standard Custom Elements
     * `disconnectedCallback`.
     */


    disconnectedCallback() {}
    /**
     * Stamps the element template.
     *
     * @override
     */


    ready() {
      if (this._template) {
        this.root = this._stampTemplate(this._template);
        this.$ = this.root.$;
      }

      super.ready();
    }
    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @override
     */


    _readyClients() {
      if (this._template) {
        this.root = this._attachDom(
        /** @type {StampedTemplate} */
        this.root);
      } // The super._readyClients here sets the clients initialized flag.
      // We must wait to do this until after client dom is created/attached
      // so that this flag can be checked to prevent notifications fired
      // during this process from being handled before clients are ready.


      super._readyClients();
    }
    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */


    _attachDom(dom) {
      if (this.attachShadow) {
        if (dom) {
          if (!this.shadowRoot) {
            this.attachShadow({
              mode: 'open'
            });
          }

          this.shadowRoot.appendChild(dom);
          return this.shadowRoot;
        }

        return null;
      } else {
        throw new Error('ShadowDOM not available. ' + // TODO(sorvell): move to compile-time conditional when supported
        'Polymer.Element can create dom as children instead of in ' + 'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
      }
    }
    /**
     * Provides a default implementation of the standard Custom Elements
     * `attributeChangedCallback`.
     *
     * By default, attributes declared in `properties` metadata are
     * deserialized using their `type` information to properties of the
     * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
     * properties.
     *
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @override
     */


    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        let property = caseMap.dashToCamelCase(name);
        let type = propertiesForClass(this.constructor)[property].type;

        if (!this._hasReadOnlyEffect(property)) {
          this._attributeToProperty(name, value, type);
        }
      }
    }
    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @suppress {invalidCasts}
     */


    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree(
        /** @type {!HTMLElement} */
        this, properties);
      }
    }
    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */


    resolveUrl(url, base) {
      if (!base && this.importPath) {
        base = Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(this.importPath);
      }

      return Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(url, base);
    }
    /**
     * Overrides `PropertyAccessors` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @override
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */


    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
      return super._parseTemplateContent(template, templateInfo, nodeInfo);
    }

  }

  return PolymerElement;
});
/* harmony export (immutable) */ __webpack_exports__["a"] = ElementMixin;

let instanceCount = 0;
const registrations = [];
/* unused harmony export registrations */

function _regLog(prototype) {
  console.log('[' + prototype.is + ']: registered');
}
function register(prototype) {
  registrations.push(prototype);
  undefined && _regLog(prototype);
}
function dumpRegistrations() {
  registrations.forEach(_regLog);
}
const updateStyles = function (props) {
  if (window.ShadyCSS) {
    window.ShadyCSS.styleDocument(props);
  }
};
/* unused harmony export updateStyles */


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export cssFromModules */
/* unused harmony export cssFromModule */
/* harmony export (immutable) */ __webpack_exports__["b"] = cssFromTemplate;
/* harmony export (immutable) */ __webpack_exports__["a"] = cssFromModuleImports;
/* unused harmony export _cssFromModuleImports */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__resolve_url_js__ = __webpack_require__(6);

const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
const INCLUDE_ATTR = 'include';

function importModule(moduleId) {
  const
  /** Polymer.DomModule */
  PolymerDomModule = customElements.get('dom-module');

  if (!PolymerDomModule) {
    return null;
  }

  return PolymerDomModule.import(moduleId);
}
/** @typedef {{assetpath: string}} */


let templateWithAssetPath; // eslint-disable-line no-unused-vars

function cssFromModules(moduleIds) {
  let modules = moduleIds.trim().split(/\s+/);
  let cssText = '';

  for (let i = 0; i < modules.length; i++) {
    cssText += cssFromModule(modules[i]);
  }

  return cssText;
}
function cssFromModule(moduleId) {
  let m = importModule(moduleId);

  if (m && m._cssText === undefined) {
    // module imports: <link rel="import" type="css">
    let cssText = _cssFromModuleImports(m); // include css from the first template in the module


    let t = m.querySelector('template');

    if (t) {
      cssText += cssFromTemplate(t,
      /** @type {templateWithAssetPath} */
      m.assetpath);
    }

    m._cssText = cssText || null;
  }

  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
  }

  return m && m._cssText || '';
}
function cssFromTemplate(template, baseURI) {
  let cssText = ''; // if element is a template, get content from its .content

  let e$ = template.content.querySelectorAll('style');

  for (let i = 0; i < e$.length; i++) {
    let e = e$[i]; // support style sharing by allowing styles to "include"
    // other dom-modules that contain styling

    let include = e.getAttribute(INCLUDE_ATTR);

    if (include) {
      cssText += cssFromModules(include);
    }

    e.parentNode.removeChild(e);
    cssText += baseURI ? Object(__WEBPACK_IMPORTED_MODULE_0__resolve_url_js__["b" /* resolveCss */])(e.textContent, baseURI) : e.textContent;
  }

  return cssText;
}
function cssFromModuleImports(moduleId) {
  let m = importModule(moduleId);
  return m ? _cssFromModuleImports(m) : '';
}
function _cssFromModuleImports(module) {
  let cssText = '';
  let p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);

  for (let i = 0; i < p$.length; i++) {
    let p = p$[i];

    if (p.import) {
      let importDoc = p.import; // NOTE: polyfill affordance.
      // under the HTMLImports polyfill, there will be no 'body',
      // but the import pseudo-doc can be used directly.

      let container = importDoc.body ? importDoc.body : importDoc;
      cssText += Object(__WEBPACK_IMPORTED_MODULE_0__resolve_url_js__["b" /* resolveCss */])(container.textContent, importDoc.baseURI);
    }
  }

  return cssText;
}

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DomModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__ = __webpack_require__(6);


let modules = {};
let lcModules = {};

function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}

function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}
/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */


class DomModule extends HTMLElement {
  static get observedAttributes() {
    return ['id'];
  }
  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   */


  static import(id, selector) {
    if (id) {
      let m = findModule(id);

      if (m && selector) {
        return m.querySelector(selector);
      }

      return m;
    }

    return null;
  }

  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this.register();
    }
  }
  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */


  get assetpath() {
    // Don't override existing assetpath.
    if (!this.__assetpath) {
      // note: assetpath set via an attribute must be relative to this
      // element's location; accomodate polyfilled HTMLImports
      const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = Object(__WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__["c" /* resolveUrl */])(this.getAttribute('assetpath') || '', owner.baseURI);
      this.__assetpath = Object(__WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__["a" /* pathFromUrl */])(url);
    }

    return this.__assetpath;
  }
  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   */


  register(id) {
    id = id || this.id;

    if (id) {
      this.id = id; // store id separate from lowercased id so that
      // in all cases mixedCase id will stored distinctly
      // and lowercase version is a fallback

      modules[id] = this;
      lcModules[id.toLowerCase()] = this;
      styleOutsideTemplateCheck(this);
    }
  }

}

DomModule.prototype['modules'] = modules;
customElements.define('dom-module', DomModule);


/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_path_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__property_accessors_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__template_stamp_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_settings_js__ = __webpack_require__(20);








/** @const {Object} */

const CaseMap = __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__; // Monotonically increasing unique ID used for de-duping effects triggered
// from multiple properties in the same turn

let dedupeId = 0;
/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */

const TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};
/**
 * @typedef {{
 * name: (string | undefined),
 * structured: (boolean | undefined),
 * wildcard: (boolean | undefined)
 * }}
 */

let DataTrigger; //eslint-disable-line no-unused-vars

/**
 * @typedef {{
 * info: ?,
 * trigger: (!DataTrigger | undefined),
 * fn: (!Function | undefined)
 * }}
 */

let DataEffect; //eslint-disable-line no-unused-vars

let PropertyEffectsType; //eslint-disable-line no-unused-vars

/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @return {Object} The own-property map of effects for the given type
 * @private
 */

function ensureOwnEffectMap(model, type) {
  let effects = model[type];

  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);

    for (let p in effects) {
      let protoFx = effects[p];
      let instFx = effects[p] = Array(protoFx.length);

      for (let i = 0; i < protoFx.length; i++) {
        instFx[i] = protoFx[i];
      }
    }
  }

  return effects;
} // -- effects ----------------------------------------------

/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {Object} props Bag of current property changes
 * @param {Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */


function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    let ran = false;
    let id = dedupeId++;

    for (let prop in props) {
      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
        ran = true;
      }
    }

    return ran;
  }

  return false;
}
/**
 * Runs a list of effects for a given property.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */


function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  let ran = false;
  let rootProperty = hasPaths ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* root */])(prop) : prop;
  let fxs = effects[rootProperty];

  if (fxs) {
    for (let i = 0, l = fxs.length, fx; i < l && (fx = fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }

        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }

  return ran;
}
/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */


function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    let triggerPath = trigger.name;
    return triggerPath == path || trigger.structured && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["b" /* isAncestor */])(triggerPath, path) || trigger.wildcard && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(triggerPath, path);
  } else {
    return true;
  }
}
/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */


function runObserverEffect(inst, property, props, oldProps, info) {
  let fn = inst[info.methodName];
  let changedProp = info.property;

  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.methodName + '` not defined');
  }
}
/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */


function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  // Notify
  let fxs = inst[TYPES.NOTIFY];
  let notified;
  let id = dedupeId++; // Try normal notify effects; if none, fall back to try path notification

  for (let prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  } // Flush host if we actually notified and host was batching
  // And the host has already initialized clients; this prevents
  // an issue with a host observing data changes before clients are ready.


  let host;

  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}
/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */


function notifyPath(inst, path, props) {
  let rootProperty = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* root */])(path);

  if (rootProperty !== path) {
    let eventName = Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["camelToDashCase"])(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }

  return false;
}
/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} eventName The name of the event to send ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property changed, the path
 *   that changed (optional).
 * @private
 * @suppress {invalidCasts}
 */


function dispatchNotifyEvent(inst, eventName, value, path) {
  let detail = {
    value: value,
    queueProperty: true
  };

  if (path) {
    detail.path = path;
  }
  /** @type {!HTMLElement} */


  inst.dispatchEvent(new CustomEvent(eventName, {
    detail
  }));
}
/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */


function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  let rootProperty = hasPaths ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* root */])(property) : property;
  let path = rootProperty != property ? property : null;
  let value = path ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, path) : inst.__data[property];

  if (path && value === undefined) {
    value = props[property]; // specifically for .splices
  }

  dispatchNotifyEvent(inst, info.eventName, value, path);
}
/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!PropertyEffectsType} inst Host element instance handling the notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @private
 */


function handleNotification(event, inst, fromProp, toPath, negate) {
  let value;
  let detail =
  /** @type {Object} */
  event.detail;
  let fromPath = detail && detail.path;

  if (fromPath) {
    toPath = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["h" /* translate */])(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.target[fromProp];
  }

  value = negate ? !value : value;

  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}
/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */


function runReflectEffect(inst, property, props, oldProps, info) {
  let value = inst.__data[property];

  if (__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["b" /* sanitizeDOMValue */]) {
    value = Object(__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["b" /* sanitizeDOMValue */])(value, info.attrName, 'attribute',
    /** @type {Node} */
    inst);
  }

  inst._propertyToAttribute(property, info.attrName, value);
}
/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {!Object} changedProps Bag of changed properties
 * @param {!Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */


function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  let computeEffects = inst[TYPES.COMPUTE];

  if (computeEffects) {
    let inputProps = changedProps;

    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
      Object.assign(oldProps, inst.__dataOld);
      Object.assign(changedProps, inst.__dataPending);
      inputProps = inst.__dataPending;
      inst.__dataPending = null;
    }
  }
}
/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */


function runComputedEffect(inst, property, props, oldProps, info) {
  let result = runMethodEffect(inst, property, props, oldProps, info);
  let computedProp = info.methodInfo;

  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
  }
}
/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!PropertyEffectsType} inst The instance whose props are changing
 * @param {string | !Array<(string|number)>} path Path that has changed
 * @param {*} value Value of changed path
 * @private
 */


function computeLinkedPaths(inst, path, value) {
  let links = inst.__dataLinkedPaths;

  if (links) {
    let link;

    for (let a in links) {
      let b = links[a];

      if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(a, path)) {
        link = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["h" /* translate */])(a, b, path);

        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(b, path)) {
        link = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["h" /* translate */])(b, a, path);

        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
} // -- bindings ----------------------------------------------

/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @private
 */


function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  // Create binding metadata and add to nodeInfo
  nodeInfo.bindings = nodeInfo.bindings || [];
  let
  /** Binding */
  binding = {
    kind,
    target,
    parts,
    literal,
    isCompound: parts.length !== 1
  };
  nodeInfo.bindings.push(binding); // Add listener info to binding metadata

  if (shouldAddListener(binding)) {
    let {
      event,
      negate
    } = binding.parts[0];
    binding.listenerEvent = event || CaseMap.camelToDashCase(target) + '-changed';
    binding.listenerNegate = negate;
  } // Add "propagate" property effects to templateInfo


  let index = templateInfo.nodeInfoList.length;

  for (let i = 0; i < binding.parts.length; i++) {
    let part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}
/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 */


function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target + ' because "-" is not a valid attribute starting character');
    } else {
      let dependencies = part.dependencies;
      let info = {
        index,
        binding,
        part,
        evaluator: constructor
      };

      for (let j = 0; j < dependencies.length; j++) {
        let trigger = dependencies[j];

        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }

        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info,
          trigger
        });
      }
    }
  }
}
/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @private
 */


function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  let node = nodeList[info.index];
  let binding = info.binding;
  let part = info.part; // Subpath notification: transform path and set to client
  // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop

  if (hasPaths && part.source && path.length > part.source.length && binding.kind == 'property' && !binding.isCompound && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    let value = props[path];
    path = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["h" /* translate */])(part.source, binding.target, path);

    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths); // Propagate value to child


    applyBindingValue(inst, node, binding, part, value);
  }
}
/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!PropertyEffectsType} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @private
 */


function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);

  if (__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["b" /* sanitizeDOMValue */]) {
    value = Object(__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["b" /* sanitizeDOMValue */])(value, binding.target, binding.kind, node);
  }

  if (binding.kind == 'attribute') {
    // Attribute binding
    inst._valueToNodeAttribute(
    /** @type {Element} */
    node, value, binding.target);
  } else {
    // Property binding
    let prop = binding.target;

    if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}
/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */


function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }

  if (binding.kind !== 'attribute') {
    // Some browsers serialize `undefined` to `"undefined"`
    if (binding.target === 'textContent' || node.localName == 'input' && binding.target == 'value') {
      value = value == undefined ? '' : value;
    }
  }

  return value;
}
/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */


function shouldAddListener(binding) {
  return Boolean(binding.target) && binding.kind != 'attribute' && binding.kind != 'text' && !binding.isCompound && binding.parts[0].mode === '{';
}
/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!PropertyEffectsType} inst Instance that bas been previously bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @private
 */


function setupBindings(inst, templateInfo) {
  // Setup compound storage, dataHost, and notify listeners
  let {
    nodeList,
    nodeInfoList
  } = templateInfo;

  if (nodeInfoList.length) {
    for (let i = 0; i < nodeInfoList.length; i++) {
      let info = nodeInfoList[i];
      let node = nodeList[i];
      let bindings = info.bindings;

      if (bindings) {
        for (let i = 0; i < bindings.length; i++) {
          let binding = bindings[i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }

      node.__dataHost = inst;
    }
  }
}
/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @private
 */


function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    // Create compound storage map
    let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
    let parts = binding.parts; // Copy literals from parts into storage for this binding

    let literals = new Array(parts.length);

    for (let j = 0; j < parts.length; j++) {
      literals[j] = parts[j].literal;
    }

    let target = binding.target;
    storage[target] = literals; // Configure properties with their literal parts

    if (binding.literal && binding.kind == 'property') {
      node[target] = binding.literal;
    }
  }
}
/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!PropertyEffectsType} inst Host element instance to handle notification event
 * @param {Binding} binding Binding metadata
 * @private
 */


function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    let part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function (e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
} // -- for method-based effects (complexObserver & computed) --------------

/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @private
 */


function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]);
  let info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo,
    dynamicFn
  };

  for (let i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn,
        info: info,
        trigger: arg
      });
    }
  }

  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn,
      info: info
    });
  }
}
/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */


function runMethodEffect(inst, property, props, oldProps, info) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  let context = inst._methodHost || inst;
  let fn = context[info.methodName];

  if (fn) {
    let args = marshalArgs(inst.__data, info.args, property, props);
    return fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}

const emptyArray = []; // Regular expressions used for binding

const IDENT = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
const NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
const SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
const DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' + STRING + ')\\s*' + ')';
const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
const ARGUMENT_LIST = '(?:' + '\\(\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\)\\s*' + ')';
const BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3

const OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
const CLOSE_BRACKET = '(?:]]|}})';
const NEGATE = '(?:(!)\\s*)?'; // Group 2

const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");
/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */

function literalFromParts(parts) {
  let s = '';

  for (let i = 0; i < parts.length; i++) {
    let literal = parts[i].literal;
    s += literal || '';
  }

  return s;
}
/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */


function parseMethod(expression) {
  // tries to match valid javascript property names
  let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);

  if (m) {
    let methodName = m[1];
    let sig = {
      methodName,
      static: true,
      args: emptyArray
    };

    if (m[2].trim()) {
      // replace escaped commas with comma entity, split on un-escaped commas
      let args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }

  return null;
}
/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */


function parseArgs(argList, sig) {
  sig.args = argList.map(function (rawArg) {
    let arg = parseArg(rawArg);

    if (!arg.literal) {
      sig.static = false;
    }

    return arg;
  }, this);
  return sig;
}
/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */


function parseArg(rawArg) {
  // clean up whitespace
  let arg = rawArg.trim() // replace comma entity with comma
  .replace(/&comma;/g, ',') // repair extra escape sequences; note only commas strictly need
  // escaping, but we allow any other char to be escaped since its
  // likely users will do this
  .replace(/\\(.)/g, '\$1'); // basic argument descriptor

  let a = {
    name: arg,
    value: '',
    literal: false
  }; // detect literal value (must be String or Number)

  let fc = arg[0];

  if (fc === '-') {
    fc = arg[1];
  }

  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }

  switch (fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;

    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  } // if not literal, look for structured path


  if (!a.literal) {
    a.rootProperty = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* root */])(arg); // detect structured path (has dots)

    a.structured = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(arg);

    if (a.structured) {
      a.wildcard = arg.slice(-2) == '.*';

      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }

  return a;
}
/**
 * Gather the argument values for a method specified in the provided array
 * of argument metadata.
 *
 * The `path` and `value` arguments are used to fill in wildcard descriptor
 * when the method is being called as a result of a path notification.
 *
 * @param {Object} data Instance data storage object to read properties from
 * @param {!Array<!MethodArg>} args Array of argument metadata
 * @param {string} path Property/path name that triggered the method effect
 * @param {Object} props Bag of current property changes
 * @return {Array<*>} Array of argument values
 * @private
 */


function marshalArgs(data, args, path, props) {
  let values = [];

  for (let i = 0, l = args.length; i < l; i++) {
    let arg = args[i];
    let name = arg.name;
    let v;

    if (arg.literal) {
      v = arg.value;
    } else {
      if (arg.structured) {
        v = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(data, name); // when data is not stored e.g. `splices`

        if (v === undefined) {
          v = props[name];
        }
      } else {
        v = data[name];
      }
    }

    if (arg.wildcard) {
      // Only send the actual path changed info if the change that
      // caused the observer to run matched the wildcard
      let baseChanged = name.indexOf(path + '.') === 0;
      let matches = path.indexOf(name) === 0 && !baseChanged;
      values[i] = {
        path: matches ? path : name,
        value: matches ? props[path] : v,
        base: v
      };
    } else {
      values[i] = v;
    }
  }

  return values;
} // data api

/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @private
 */


function notifySplices(inst, array, path, splices) {
  let splicesPath = path + '.splices';
  inst.notifyPath(splicesPath, {
    indexSplices: splices
  });
  inst.notifyPath(path + '.length', array.length); // Null here to allow potentially large splice records to be GC'ed.

  inst.__data[splicesPath] = {
    indexSplices: null
  };
}
/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @private
 */


function notifySplice(inst, array, path, index, addedCount, removed) {
  notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}
/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */


function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}

const PropertyEffects = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {
  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   */
  const propertyEffectsBase = Object(__WEBPACK_IMPORTED_MODULE_5__template_stamp_js__["a" /* TemplateStamp */])(Object(__WEBPACK_IMPORTED_MODULE_4__property_accessors_js__["a" /* PropertyAccessors */])(superClass));
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */

  class PropertyEffects extends propertyEffectsBase {
    constructor() {
      super();
      /** @type {boolean} */

      this.__dataClientsReady;
      /** @type {Array} */

      this.__dataPendingClients;
      /** @type {Object} */

      this.__dataToNotify;
      /** @type {Object} */

      this.__dataLinkedPaths;
      /** @type {boolean} */

      this.__dataHasPaths;
      /** @type {Object} */

      this.__dataCompoundStorage;
      /** @type {Polymer_PropertyEffects} */

      this.__dataHost;
      /** @type {!Object} */

      this.__dataTemp;
      /** @type {boolean} */

      this.__dataClientsInitialized;
      /** @type {!Object} */

      this.__data;
      /** @type {!Object} */

      this.__dataPending;
      /** @type {!Object} */

      this.__dataOld;
      /** @type {Object} */

      this.__computeEffects;
      /** @type {Object} */

      this.__reflectEffects;
      /** @type {Object} */

      this.__notifyEffects;
      /** @type {Object} */

      this.__propagateEffects;
      /** @type {Object} */

      this.__observeEffects;
      /** @type {Object} */

      this.__readOnly;
      /** @type {number} */

      this.__dataCounter;
      /** @type {!TemplateInfo} */

      this.__templateInfo;
    }

    get PROPERTY_EFFECT_TYPES() {
      return TYPES;
    }

    _initializeProperties() {
      super._initializeProperties();

      hostStack.registerHost(this);
      this.__dataClientsReady = false;
      this.__dataPendingClients = null;
      this.__dataToNotify = null;
      this.__dataLinkedPaths = null;
      this.__dataHasPaths = false; // May be set on instance prior to upgrade

      this.__dataCompoundStorage = this.__dataCompoundStorage || null;
      this.__dataHost = this.__dataHost || null;
      this.__dataTemp = {};
      this.__dataClientsInitialized = false;
    }
    /**
     * Overrides `Polymer.PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     */


    _initializeProtoProperties(props) {
      this.__data = Object.create(props);
      this.__dataPending = Object.create(props);
      this.__dataOld = {};
    }
    /**
     * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     */


    _initializeInstanceProperties(props) {
      let readOnly = this[TYPES.READ_ONLY];

      for (let prop in props) {
        if (!readOnly || !readOnly[prop]) {
          this.__dataPending = this.__dataPending || {};
          this.__dataOld = this.__dataOld || {};
          this.__data[prop] = this.__dataPending[prop] = props[prop];
        }
      }
    } // Prototype setup ----------------------------------------

    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @protected
     */


    _addPropertyEffect(property, type, effect) {
      this._createPropertyAccessor(property, type == TYPES.READ_ONLY); // effects are accumulated into arrays per property based on type


      let effects = ensureOwnEffectMap(this, type)[property];

      if (!effects) {
        effects = this[type][property] = [];
      }

      effects.push(effect);
    }
    /**
     * Removes the given property effect.
     *
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     */


    _removePropertyEffect(property, type, effect) {
      let effects = ensureOwnEffectMap(this, type)[property];
      let idx = effects.indexOf(effect);

      if (idx >= 0) {
        effects.splice(idx, 1);
      }
    }
    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */


    _hasPropertyEffect(property, type) {
      let effects = this[type];
      return Boolean(effects && effects[property]);
    }
    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */


    _hasReadOnlyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.READ_ONLY);
    }
    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */


    _hasNotifyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.NOTIFY);
    }
    /**
     * Returns whether the current prototype/instance has a "reflect to attribute"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */


    _hasReflectEffect(property) {
      return this._hasPropertyEffect(property, TYPES.REFLECT);
    }
    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */


    _hasComputedEffect(property) {
      return this._hasPropertyEffect(property, TYPES.COMPUTE);
    } // Runtime ----------------------------------------

    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */


    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
      if (isPathNotification || Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* root */])(Array.isArray(path) ? path[0] : path) !== path) {
        // Dirty check changes being set to a path against the actual object,
        // since this is the entry point for paths into the system; from here
        // the only dirty checks are against the `__dataTemp` cache to prevent
        // duplicate work in the same turn only. Note, if this was a notification
        // of a change already set to a path (isPathNotification: true),
        // we always let the change through and skip the `set` since it was
        // already dirty checked at the point of entry and the underlying
        // object has already been updated
        if (!isPathNotification) {
          let old = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path);
          path =
          /** @type {string} */
          Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* set */])(this, path, value); // Use property-accessor's simpler dirty check

          if (!path || !super._shouldPropertyChange(path, value, old)) {
            return false;
          }
        }

        this.__dataHasPaths = true;

        if (this._setPendingProperty(
        /**@type{string}*/
        path, value, shouldNotify)) {
          computeLinkedPaths(this, path, value);
          return true;
        }
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
          return this._setPendingProperty(
          /**@type{string}*/
          path, value, shouldNotify);
        } else {
          this[path] = value;
        }
      }

      return false;
    }
    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @param {Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @protected
     */


    _setUnmanagedPropertyToNode(node, prop, value) {
      // It is a judgment call that resetting primitives is
      // "bad" and resettings objects is also "good"; alternatively we could
      // implement a whitelist of tag & property values that should never
      // be reset (e.g. <input>.value && <select>.value)
      if (value !== node[prop] || typeof value == 'object') {
        node[prop] = value;
      }
    }
    /**
     * Overrides the `PropertyAccessors` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChaged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     * @override
     */


    _setPendingProperty(property, value, shouldNotify) {
      let isPath = this.__dataHasPaths && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(property);
      let prevProps = isPath ? this.__dataTemp : this.__data;

      if (this._shouldPropertyChange(property, value, prevProps[property])) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        } // Ensure old is captured from the last turn


        if (!(property in this.__dataOld)) {
          this.__dataOld[property] = this.__data[property];
        } // Paths are stored in temporary cache (cleared at end of turn),
        // which is used for dirty-checking, all others stored in __data


        if (isPath) {
          this.__dataTemp[property] = value;
        } else {
          this.__data[property] = value;
        } // All changes go into pending property bag, passed to _propertiesChanged


        this.__dataPending[property] = value; // Track properties that should notify separately

        if (isPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
          this.__dataToNotify = this.__dataToNotify || {};
          this.__dataToNotify[property] = shouldNotify;
        }

        return true;
      }

      return false;
    }
    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     */


    _setProperty(property, value) {
      if (this._setPendingProperty(property, value, true)) {
        this._invalidateProperties();
      }
    }
    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     */


    _invalidateProperties() {
      if (this.__dataReady) {
        this._flushProperties();
      }
    }
    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @param {Object} client PropertyEffects client to enqueue
     * @protected
     */


    _enqueueClient(client) {
      this.__dataPendingClients = this.__dataPendingClients || [];

      if (client !== this) {
        this.__dataPendingClients.push(client);
      }
    }
    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @protected
     */


    _flushClients() {
      if (!this.__dataClientsReady) {
        this.__dataClientsReady = true;

        this._readyClients(); // Override point where accessors are turned on; importantly,
        // this is after clients have fully readied, providing a guarantee
        // that any property effects occur only after all clients are ready.


        this.__dataReady = true;
      } else {
        this.__enableOrFlushClients();
      }
    } // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.


    __enableOrFlushClients() {
      let clients = this.__dataPendingClients;

      if (clients) {
        this.__dataPendingClients = null;

        for (let i = 0; i < clients.length; i++) {
          let client = clients[i];

          if (!client.__dataEnabled) {
            client._enableProperties();
          } else if (client.__dataPending) {
            client._flushProperties();
          }
        }
      }
    }
    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @protected
     */


    _readyClients() {
      this.__enableOrFlushClients();
    }
    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @public
     */


    setProperties(props, setReadOnly) {
      for (let path in props) {
        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
          //TODO(kschaaf): explicitly disallow paths in setProperty?
          // wildcard observers currently only pass the first changed path
          // in the `info` object, and you could do some odd things batching
          // paths, e.g. {'foo.bar': {...}, 'foo': null}
          this._setPendingPropertyOrPath(path, props[path], true);
        }
      }

      this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     */


    ready() {
      // It is important that `super.ready()` is not called here as it
      // immediately turns on accessors. Instead, we wait until `readyClients`
      // to enable accessors to provide a guarantee that clients are ready
      // before processing any accessors side effects.
      this._flushProperties(); // If no data was pending, `_flushProperties` will not `flushClients`
      // so ensure this is done.


      if (!this.__dataClientsReady) {
        this._flushClients();
      } // Before ready, client notifications do not trigger _flushProperties.
      // Therefore a flush is necessary here if data has been set.


      if (this.__dataPending) {
        this._flushProperties();
      }
    }
    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     */


    _propertiesChanged(currentProps, changedProps, oldProps) {
      // ----------------------------
      // let c = Object.getOwnPropertyNames(changedProps || {});
      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
      // if (window.debug) { debugger; }
      // ----------------------------
      let hasPaths = this.__dataHasPaths;
      this.__dataHasPaths = false; // Compute properties

      runComputedEffects(this, changedProps, oldProps, hasPaths); // Clear notify properties prior to possible reentry (propagate, observe),
      // but after computing effects have a chance to add to them

      let notifyProps = this.__dataToNotify;
      this.__dataToNotify = null; // Propagate properties to clients

      this._propagatePropertyChanges(changedProps, oldProps, hasPaths); // Flush clients


      this._flushClients(); // Reflect properties


      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths); // Observe properties

      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths); // Notify properties to host

      if (notifyProps) {
        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
      } // Clear temporary cache at end of turn


      if (this.__dataCounter == 1) {
        this.__dataTemp = {};
      } // ----------------------------
      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
      // ----------------------------

    }
    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @protected
     */


    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
      if (this[TYPES.PROPAGATE]) {
        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
      }

      let templateInfo = this.__templateInfo;

      while (templateInfo) {
        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps, hasPaths, templateInfo.nodeList);
        templateInfo = templateInfo.nextTemplateInfo;
      }
    }
    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @public
     */


    linkPaths(to, from) {
      to = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["e" /* normalize */])(to);
      from = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["e" /* normalize */])(from);
      this.__dataLinkedPaths = this.__dataLinkedPaths || {};
      this.__dataLinkedPaths[to] = from;
    }
    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @public
     */


    unlinkPaths(path) {
      path = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["e" /* normalize */])(path);

      if (this.__dataLinkedPaths) {
        delete this.__dataLinkedPaths[path];
      }
    }
    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     * @public
    */


    notifySplices(path, splices) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info);
      notifySplices(this, array, info.path, splices);
    }
    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */


    get(path, root) {
      return Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(root || this, path);
    }
    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @public
    */


    set(path, value, root) {
      if (root) {
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* set */])(root, path, value);
      } else {
        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][
        /** @type {string} */
        path]) {
          if (this._setPendingPropertyOrPath(path, value, true)) {
            this._invalidateProperties();
          }
        }
      }
    }
    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */


    push(path, ...items) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array}*/
      Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info);
      let len = array.length;
      let ret = array.push(...items);

      if (items.length) {
        notifySplice(this, array, info.path, len, items.length, []);
      }

      return ret;
    }
    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */


    pop(path) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info);
      let hadLength = Boolean(array.length);
      let ret = array.pop();

      if (hadLength) {
        notifySplice(this, array, info.path, array.length, 0, [ret]);
      }

      return ret;
    }
    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {Array} Array of removed items.
     * @public
     */


    splice(path, start, deleteCount, ...items) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info); // Normalize fancy native splice handling of crazy start values

      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else {
        start = Math.floor(start);
      }

      if (!start) {
        start = 0;
      }

      let ret = array.splice(start, deleteCount, ...items);

      if (items.length || ret.length) {
        notifySplice(this, array, info.path, start, items.length, ret);
      }

      return ret;
    }
    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */


    shift(path) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info);
      let hadLength = Boolean(array.length);
      let ret = array.shift();

      if (hadLength) {
        notifySplice(this, array, info.path, 0, 0, [ret]);
      }

      return ret;
    }
    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */


    unshift(path, ...items) {
      let info = {
        path: ''
      };
      let array =
      /** @type {Array} */
      Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info);
      let ret = array.unshift(...items);

      if (items.length) {
        notifySplice(this, array, info.path, 0, items.length, []);
      }

      return ret;
    }
    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @public
    */


    notifyPath(path, value) {
      /** @type {string} */
      let propPath;

      if (arguments.length == 1) {
        // Get value if not supplied
        let info = {
          path: ''
        };
        value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info);
        propPath = info.path;
      } else if (Array.isArray(path)) {
        // Normalize path if needed
        propPath = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["e" /* normalize */])(path);
      } else {
        propPath =
        /** @type{string} */
        path;
      }

      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
        this._invalidateProperties();
      }
    }
    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @protected
     */


    _createReadOnlyProperty(property, protectedSetter) {
      this._addPropertyEffect(property, TYPES.READ_ONLY);

      if (protectedSetter) {
        this['_set' + upper(property)] =
        /** @this {PropertyEffects} */
        function (value) {
          this._setProperty(property, value);
        };
      }
    }
    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @param {string} methodName Name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @protected
     */


    _createPropertyObserver(property, methodName, dynamicFn) {
      let info = {
        property,
        methodName,
        dynamicFn: Boolean(dynamicFn)
      };

      this._addPropertyEffect(property, TYPES.OBSERVE, {
        fn: runObserverEffect,
        info,
        trigger: {
          name: property
        }
      });

      if (dynamicFn) {
        this._addPropertyEffect(methodName, TYPES.OBSERVE, {
          fn: runObserverEffect,
          info,
          trigger: {
            name: methodName
          }
        });
      }
    }
    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */


    _createMethodObserver(expression, dynamicFn) {
      let sig = parseMethod(expression);

      if (!sig) {
        throw new Error("Malformed observer expression '" + expression + "'");
      }

      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
    }
    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @protected
     */


    _createNotifyingProperty(property) {
      this._addPropertyEffect(property, TYPES.NOTIFY, {
        fn: runNotifyEffect,
        info: {
          eventName: CaseMap.camelToDashCase(property) + '-changed',
          property: property
        }
      });
    }
    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @protected
     */


    _createReflectedProperty(property) {
      let attr = CaseMap.camelToDashCase(property);

      if (attr[0] === '-') {
        console.warn('Property ' + property + ' cannot be reflected to attribute ' + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
      } else {
        this._addPropertyEffect(property, TYPES.REFLECT, {
          fn: runReflectEffect,
          info: {
            attrName: attr
          }
        });
      }
    }
    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */


    _createComputedProperty(property, expression, dynamicFn) {
      let sig = parseMethod(expression);

      if (!sig) {
        throw new Error("Malformed computed expression '" + expression + "'");
      }

      createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
    } // -- static class methods ------------

    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @protected
     */


    static addPropertyEffect(property, type, effect) {
      this.prototype._addPropertyEffect(property, type, effect);
    }
    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string} methodName Name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @protected
     */


    static createPropertyObserver(property, methodName, dynamicFn) {
      this.prototype._createPropertyObserver(property, methodName, dynamicFn);
    }
    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal Javascript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */


    static createMethodObserver(expression, dynamicFn) {
      this.prototype._createMethodObserver(expression, dynamicFn);
    }
    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @protected
     */


    static createNotifyingProperty(property) {
      this.prototype._createNotifyingProperty(property);
    }
    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @protected
     */


    static createReadOnlyProperty(property, protectedSetter) {
      this.prototype._createReadOnlyProperty(property, protectedSetter);
    }
    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @protected
     */


    static createReflectedProperty(property) {
      this.prototype._createReflectedProperty(property);
    }
    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal Javascript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @protected
     */


    static createComputedProperty(property, expression, dynamicFn) {
      this.prototype._createComputedProperty(property, expression, dynamicFn);
    }
    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {Object} Template metadata object
     * @protected
     */


    static bindTemplate(template) {
      return this.prototype._bindTemplate(template);
    } // -- binding ----------------------------------------------

    /**
     * Equivalent to static `bindTemplate` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @param {HTMLTemplateElement} template Template containing binding
     *   bindings
     * @param {boolean=} instanceBinding When false (default), performs
     *   "prototypical" binding of the template and overwrites any previously
     *   bound template for the class. When true (as passed from
     *   `_stampTemplate`), the template info is instanced and linked into
     *   the list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     *   this is an instance of the prototypical template info
     * @protected
     */


    _bindTemplate(template, instanceBinding) {
      let templateInfo = this.constructor._parseTemplate(template);

      let wasPreBound = this.__templateInfo == templateInfo; // Optimization: since this is called twice for proto-bound templates,
      // don't attempt to recreate accessors if this template was pre-bound

      if (!wasPreBound) {
        for (let prop in templateInfo.propertyEffects) {
          this._createPropertyAccessor(prop);
        }
      }

      if (instanceBinding) {
        // For instance-time binding, create instance of template metadata
        // and link into list of templates if necessary
        templateInfo =
        /** @type {!TemplateInfo} */
        Object.create(templateInfo);
        templateInfo.wasPreBound = wasPreBound;

        if (!wasPreBound && this.__templateInfo) {
          let last = this.__templateInfoLast || this.__templateInfo;
          this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
          templateInfo.previousTemplateInfo = last;
          return templateInfo;
        }
      }

      return this.__templateInfo = templateInfo;
    }
    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @protected
     */


    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
      hostProps[prop] = true;
      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
      let propEffects = effects[prop] = effects[prop] || [];
      propEffects.push(effect);
    }
    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */


    _stampTemplate(template) {
      // Ensures that created dom is `_enqueueClient`'d to this element so
      // that it can be flushed on next call to `_flushProperties`
      hostStack.beginHosting(this);

      let dom = super._stampTemplate(template);

      hostStack.endHosting(this);

      let templateInfo =
      /** @type {!TemplateInfo} */
      this._bindTemplate(template, true); // Add template-instance-specific data to instanced templateInfo


      templateInfo.nodeList = dom.nodeList; // Capture child nodes to allow unstamping of non-prototypical templates

      if (!templateInfo.wasPreBound) {
        let nodes = templateInfo.childNodes = [];

        for (let n = dom.firstChild; n; n = n.nextSibling) {
          nodes.push(n);
        }
      }

      dom.templateInfo = templateInfo; // Setup compound storage, 2-way listeners, and dataHost for bindings

      setupBindings(this, templateInfo); // Flush properties into template nodes if already booted

      if (this.__dataReady) {
        runEffects(this, templateInfo.propertyEffects, this.__data, null, false, templateInfo.nodeList);
      }

      return dom;
    }
    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @protected
     */


    _removeBoundDom(dom) {
      // Unlink template info
      let templateInfo = dom.templateInfo;

      if (templateInfo.previousTemplateInfo) {
        templateInfo.previousTemplateInfo.nextTemplateInfo = templateInfo.nextTemplateInfo;
      }

      if (templateInfo.nextTemplateInfo) {
        templateInfo.nextTemplateInfo.previousTemplateInfo = templateInfo.previousTemplateInfo;
      }

      if (this.__templateInfoLast == templateInfo) {
        this.__templateInfoLast = templateInfo.previousTemplateInfo;
      }

      templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null; // Remove stamped nodes

      let nodes = templateInfo.childNodes;

      for (let i = 0; i < nodes.length; i++) {
        let node = nodes[i];
        node.parentNode.removeChild(node);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @override
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */


    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = super._parseTemplateNode(node, templateInfo, nodeInfo);

      if (node.nodeType === Node.TEXT_NODE) {
        let parts = this._parseBindings(node.textContent, templateInfo);

        if (parts) {
          // Initialize the textContent with any literal parts
          // NOTE: default to a space here so the textNode remains; some browsers
          // (IE) evacipate an empty textNode following cloneNode/importNode.
          node.textContent = literalFromParts(parts) || ' ';
          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
          noted = true;
        }
      }

      return noted;
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @override
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */


    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      let parts = this._parseBindings(value, templateInfo);

      if (parts) {
        // Attribute or property
        let origName = name;
        let kind = 'property';

        if (name[name.length - 1] == '$') {
          name = name.slice(0, -1);
          kind = 'attribute';
        } // Initialize attribute bindings with any literal parts


        let literal = literalFromParts(parts);

        if (literal && kind == 'attribute') {
          node.setAttribute(name, literal);
        } // Clear attribute before removing, since IE won't allow removing
        // `value` attribute if it previously had a value (can't
        // unconditionally set '' before removing since attributes with `$`
        // can't be set using setAttribute)


        if (node.localName === 'input' && origName === 'value') {
          node.setAttribute(origName, '');
        } // Remove annotation


        node.removeAttribute(origName); // Case hackery: attributes are lower-case, but bind targets
        // (properties) are case sensitive. Gambit is to map dash-case to
        // camel-case: `foo-bar` becomes `fooBar`.
        // Attribute bindings are excepted.

        if (kind === 'property') {
          name = Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["dashToCamelCase"])(name);
        }

        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
        return true;
      } else {
        return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @override
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */


    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
      let noted = super._parseTemplateNestedTemplate(node, templateInfo, nodeInfo); // Merge host props into outer template and add bindings


      let hostProps = nodeInfo.templateInfo.hostProps;
      let mode = '{';

      for (let source in hostProps) {
        let parts = [{
          mode,
          source,
          dependencies: [source]
        }];
        addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
      }

      return noted;
    }
    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     */


    static _parseBindings(text, templateInfo) {
      let parts = [];
      let lastIndex = 0;
      let m; // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
      // Regex matches:
      //        Iteration 1:  Iteration 2:
      // m[1]: '{{'          '[['
      // m[2]: ''            '!'
      // m[3]: 'prop'        'compute(foo,bar)'

      while ((m = bindingRegex.exec(text)) !== null) {
        // Add literal part
        if (m.index > lastIndex) {
          parts.push({
            literal: text.slice(lastIndex, m.index)
          });
        } // Add binding part


        let mode = m[1][0];
        let negate = Boolean(m[2]);
        let source = m[3].trim();
        let customEvent = false,
            notifyEvent = '',
            colon = -1;

        if (mode == '{' && (colon = source.indexOf('::')) > 0) {
          notifyEvent = source.substring(colon + 2);
          source = source.substring(0, colon);
          customEvent = true;
        }

        let signature = parseMethod(source);
        let dependencies = [];

        if (signature) {
          // Inline computed function
          let {
            args,
            methodName
          } = signature;

          for (let i = 0; i < args.length; i++) {
            let arg = args[i];

            if (!arg.literal) {
              dependencies.push(arg);
            }
          }

          let dynamicFns = templateInfo.dynamicFns;

          if (dynamicFns && dynamicFns[methodName] || signature.static) {
            dependencies.push(methodName);
            signature.dynamicFn = true;
          }
        } else {
          // Property or path
          dependencies.push(source);
        }

        parts.push({
          source,
          mode,
          negate,
          customEvent,
          signature,
          dependencies,
          event: notifyEvent
        });
        lastIndex = bindingRegex.lastIndex;
      } // Add a final literal part


      if (lastIndex && lastIndex < text.length) {
        let literal = text.substring(lastIndex);

        if (literal) {
          parts.push({
            literal: literal
          });
        }
      }

      if (parts.length) {
        return parts;
      } else {
        return null;
      }
    }
    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {this} inst Element that should be used as scope for
     *   binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     */


    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
      let value;

      if (part.signature) {
        value = runMethodEffect(inst, path, props, oldProps, part.signature);
      } else if (path != part.source) {
        value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, part.source);
      } else {
        if (hasPaths && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(path)) {
          value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, path);
        } else {
          value = inst.__data[path];
        }
      }

      if (part.negate) {
        value = !value;
      }

      return value;
    }

  } // make a typing for closure :P


  PropertyEffectsType = PropertyEffects;
  return PropertyEffects;
});
/* harmony export (immutable) */ __webpack_exports__["a"] = PropertyEffects;

/**
 * Helper api for enqueing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */

let hostStack = {
  stack: [],

  /**
   * @param {*} inst Instance to add to hostStack
   * @this {hostStack}
   */
  registerHost(inst) {
    if (this.stack.length) {
      let host = this.stack[this.stack.length - 1];

      host._enqueueClient(inst);
    }
  },

  /**
   * @param {*} inst Instance to begin hosting
   * @this {hostStack}
   */
  beginHosting(inst) {
    this.stack.push(inst);
  },

  /**
   * @param {*} inst Instance to end hosting
   * @this {hostStack}
   */
  endHosting(inst) {
    let stackLen = this.stack.length;

    if (stackLen && this.stack[stackLen - 1] == inst) {
      this.stack.pop();
    }
  }

};

/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = isPath;
/* harmony export (immutable) */ __webpack_exports__["f"] = root;
/* harmony export (immutable) */ __webpack_exports__["b"] = isAncestor;
/* harmony export (immutable) */ __webpack_exports__["c"] = isDescendant;
/* harmony export (immutable) */ __webpack_exports__["h"] = translate;
/* unused harmony export matches */
/* harmony export (immutable) */ __webpack_exports__["e"] = normalize;
/* unused harmony export split */
/* harmony export (immutable) */ __webpack_exports__["a"] = get;
/* harmony export (immutable) */ __webpack_exports__["g"] = set;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);

function isPath(path) {
  return path.indexOf('.') >= 0;
}
function root(path) {
  let dotIndex = path.indexOf('.');

  if (dotIndex === -1) {
    return path;
  }

  return path.slice(0, dotIndex);
}
function isAncestor(base, path) {
  //     base.startsWith(path + '.');
  return base.indexOf(path + '.') === 0;
}
function isDescendant(base, path) {
  //     path.startsWith(base + '.');
  return path.indexOf(base + '.') === 0;
}
function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}
function matches(base, path) {
  return base === path || isAncestor(base, path) || isDescendant(base, path);
}
function normalize(path) {
  if (Array.isArray(path)) {
    let parts = [];

    for (let i = 0; i < path.length; i++) {
      let args = path[i].toString().split('.');

      for (let j = 0; j < args.length; j++) {
        parts.push(args[j]);
      }
    }

    return parts.join('.');
  } else {
    return path;
  }
}
function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split('.');
  }

  return path.toString().split('.');
}
function get(root, path, info) {
  let prop = root;
  let parts = split(path); // Loop over path parts[0..n-1] and dereference

  for (let i = 0; i < parts.length; i++) {
    if (!prop) {
      return;
    }

    let part = parts[i];
    prop = prop[part];
  }

  if (info) {
    info.path = parts.join('.');
  }

  return prop;
}
function set(root, path, value) {
  let prop = root;
  let parts = split(path);
  let last = parts[parts.length - 1];

  if (parts.length > 1) {
    // Loop over path parts[0..n-2] and dereference
    for (let i = 0; i < parts.length - 1; i++) {
      let part = parts[i];
      prop = prop[part];

      if (!prop) {
        return;
      }
    } // Set value to object at end of path


    prop[last] = value;
  } else {
    // Simple property set
    prop[path] = value;
  }

  return parts.join('.');
}
const isDeep = isPath;
/* unused harmony export isDeep */


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_case_map_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_async_js__ = __webpack_require__(46);




let caseMap = __WEBPACK_IMPORTED_MODULE_2__utils_case_map_js__;
let microtask = __WEBPACK_IMPORTED_MODULE_3__utils_async_js__["a" /* microTask */]; // Save map of native properties; this forms a blacklist or properties
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws

const nativeProperties = {};
let proto = HTMLElement.prototype;

while (proto) {
  let props = Object.getOwnPropertyNames(proto);

  for (let i = 0; i < props.length; i++) {
    nativeProperties[props[i]] = true;
  }

  proto = Object.getPrototypeOf(proto);
}
/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @private
 */


function saveAccessorValue(model, property) {
  // Don't read/store value for any native properties since they could throw
  if (!nativeProperties[property]) {
    let value = model[property];

    if (value !== undefined) {
      if (model.__data) {
        // Adding accessor to instance; update the property
        // It is the user's responsibility to call _flushProperties
        model._setPendingProperty(property, value);
      } else {
        // Adding accessor to proto; save proto's value for instance-time use
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }

        model.__dataProto[property] = value;
      }
    }
  }
}

const PropertyAccessors = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends HTMLElement
   * @unrestricted
   */
  class PropertyAccessors extends superClass {
    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     */
    static createPropertiesForAttributes() {
      let a$ = this.observedAttributes;

      for (let i = 0; i < a$.length; i++) {
        this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[i]));
      }
    }

    constructor() {
      super();
      /** @type {boolean} */

      this.__serializing;
      /** @type {number} */

      this.__dataCounter;
      /** @type {boolean} */

      this.__dataEnabled;
      /** @type {boolean} */

      this.__dataReady;
      /** @type {boolean} */

      this.__dataInvalid;
      /** @type {!Object} */

      this.__data;
      /** @type {Object} */

      this.__dataPending;
      /** @type {Object} */

      this.__dataOld;
      /** @type {Object} */

      this.__dataProto;
      /** @type {Object} */

      this.__dataHasAccessor;
      /** @type {Object} */

      this.__dataInstanceProps;

      this._initializeProperties();
    }
    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     */


    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        this._attributeToProperty(name, value);
      }
    }
    /**
     * Initializes the local storage for property accessors.
     *
     * Provided as an override point for performing any setup work prior
     * to initializing the property accessor system.
     *
     * @protected
     */


    _initializeProperties() {
      this.__serializing = false;
      this.__dataCounter = 0;
      this.__dataEnabled = false;
      this.__dataReady = false;
      this.__dataInvalid = false;
      this.__data = {};
      this.__dataPending = null;
      this.__dataOld = null;

      if (this.__dataProto) {
        this._initializeProtoProperties(this.__dataProto);

        this.__dataProto = null;
      } // Capture instance properties; these will be set into accessors
      // during first flush. Don't set them here, since we want
      // these to overwrite defaults/constructor assignments


      for (let p in this.__dataHasAccessor) {
        if (this.hasOwnProperty(p)) {
          this.__dataInstanceProps = this.__dataInstanceProps || {};
          this.__dataInstanceProps[p] = this[p];
          delete this[p];
        }
      }
    }
    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @protected
     */


    _initializeProtoProperties(props) {
      for (let p in props) {
        this._setProperty(p, props[p]);
      }
    }
    /**
     * Called at ready time with bag of instance properties that overwrote
     * accessors when the element upgraded.
     *
     * The default implementation sets these properties back into the
     * setter at ready time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @protected
     */


    _initializeInstanceProperties(props) {
      Object.assign(this, props);
    }
    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     */


    _ensureAttribute(attribute, value) {
      if (!this.hasAttribute(attribute)) {
        this._valueToNodeAttribute(this, value, attribute);
      }
    }
    /**
     * Deserializes an attribute to its associated property.
     *
     * This method calls the `_deserializeValue` method to convert the string to
     * a typed value.
     *
     * @param {string} attribute Name of attribute to deserialize.
     * @param {?string} value of the attribute.
     * @param {*=} type type to deserialize to.
     */


    _attributeToProperty(attribute, value, type) {
      // Don't deserialize back to property if currently reflecting
      if (!this.__serializing) {
        let property = caseMap.dashToCamelCase(attribute);
        this[property] = this._deserializeValue(value, type);
      }
    }
    /**
     * Serializes a property to its associated attribute.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect.
     * @param {*=} value Property value to refect.
     */


    _propertyToAttribute(property, attribute, value) {
      this.__serializing = true;
      value = arguments.length < 3 ? this[property] : value;

      this._valueToNodeAttribute(this, value, attribute || caseMap.camelToDashCase(property));

      this.__serializing = false;
    }
    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * This method calls the `_serializeValue` method to convert the typed
     * value to a string.  If the `_serializeValue` method returns `undefined`,
     * the attribute will be removed (this is the default for boolean
     * type `false`).
     *
     * @param {Element} node Element to set attribute to.
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     */


    _valueToNodeAttribute(node, value, attribute) {
      let str = this._serializeValue(value);

      if (str === undefined) {
        node.removeAttribute(attribute);
      } else {
        node.setAttribute(attribute, str);
      }
    }
    /**
     * Converts a typed JavaScript value to a string.
     *
     * This method is called by Polymer when setting JS property values to
     * HTML attributes.  Users may override this method on Polymer element
     * prototypes to provide serialization for custom types.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property value.
     */


    _serializeValue(value) {
      /* eslint-disable no-fallthrough */
      switch (typeof value) {
        case 'boolean':
          return value ? '' : undefined;

        case 'object':
          if (value instanceof Date) {
            return value.toString();
          } else if (value) {
            try {
              return JSON.stringify(value);
            } catch (x) {
              return '';
            }
          }

        default:
          return value != null ? value.toString() : undefined;
      }
    }
    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     * Note: The return value of `undefined` is used as a sentinel value to
     * indicate the attribute should be removed.
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     */


    _deserializeValue(value, type) {
      /**
       * @type {*}
       */
      let outValue;

      switch (type) {
        case Number:
          outValue = Number(value);
          break;

        case Boolean:
          outValue = value !== null;
          break;

        case Object:
          try {
            outValue = JSON.parse(
            /** @type string */
            value);
          } catch (x) {// allow non-JSON literals like Strings and Numbers
          }

          break;

        case Array:
          try {
            outValue = JSON.parse(
            /** @type string */
            value);
          } catch (x) {
            outValue = null;
            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
          }

          break;

        case Date:
          outValue = new Date(value);
          break;

        case String:
        default:
          outValue = value;
          break;
      }

      return outValue;
    }
    /* eslint-enable no-fallthrough */

    /**
     * Creates a setter/getter pair for the named property with its own
     * local storage.  The getter returns the value in the local storage,
     * and the setter calls `_setProperty`, which updates the local storage
     * for the property and enqueues a `_propertiesChanged` callback.
     *
     * This method may be called on a prototype or an instance.  Calling
     * this method may overwrite a property value that already exists on
     * the prototype/instance by creating the accessor.  When calling on
     * a prototype, any overwritten values are saved in `__dataProto`,
     * and it is up to the subclasser to decide how/when to set those
     * properties back into the accessor.  When calling on an instance,
     * the overwritten value is set via `_setPendingProperty`, and the
     * user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     *
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created; the
     *   protected `_setProperty` function must be used to set the property
     * @protected
     */


    _createPropertyAccessor(property, readOnly) {
      if (!this.hasOwnProperty('__dataHasAccessor')) {
        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
      }

      if (!this.__dataHasAccessor[property]) {
        this.__dataHasAccessor[property] = true;
        saveAccessorValue(this, property);
        Object.defineProperty(this, property, {
          /* eslint-disable valid-jsdoc */

          /** @this {PropertyAccessors} */
          get: function () {
            return this.__data[property];
          },

          /** @this {PropertyAccessors} */
          set: readOnly ? function () {} : function (value) {
            this._setProperty(property, value);
          }
          /* eslint-enable */

        });
      }
    }
    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     */


    _hasAccessor(property) {
      return this.__dataHasAccessor && this.__dataHasAccessor[property];
    }
    /**
     * Updates the local storage for a property (via `_setPendingProperty`)
     * and enqueues a `_proeprtiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @protected
     */


    _setProperty(property, value) {
      if (this._setPendingProperty(property, value)) {
        this._invalidateProperties();
      }
    }
    /**
     * Updates the local storage for a property, records the previous value,
     * and adds it to the set of "pending changes" that will be passed to the
     * `_propertiesChanged` callback.  This method does not enqueue the
     * `_propertiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {boolean} Returns true if the property changed
     * @protected
     */


    _setPendingProperty(property, value) {
      let old = this.__data[property];

      let changed = this._shouldPropertyChange(property, value, old);

      if (changed) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        } // Ensure old is captured from the last turn


        if (this.__dataOld && !(property in this.__dataOld)) {
          this.__dataOld[property] = old;
        }

        this.__data[property] = value;
        this.__dataPending[property] = value;
      }

      return changed;
    }
    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     */


    _isPropertyPending(prop) {
      return Boolean(this.__dataPending && prop in this.__dataPending);
    }
    /**
     * Marks the properties as invalid, and enqueues an async
     * `_propertiesChanged` callback.
     *
     * @protected
     */


    _invalidateProperties() {
      if (!this.__dataInvalid && this.__dataReady) {
        this.__dataInvalid = true;
        microtask.run(() => {
          if (this.__dataInvalid) {
            this.__dataInvalid = false;

            this._flushProperties();
          }
        });
      }
    }
    /**
     * Call to enable property accessor processing. Before this method is
     * called accessor values will be set but side effects are
     * queued. When called, any pending side effects occur immediately.
     * For elements, generally `connectedCallback` is a normal spot to do so.
     * It is safe to call this method multiple times as it only turns on
     * property accessors once.
     */


    _enableProperties() {
      if (!this.__dataEnabled) {
        this.__dataEnabled = true;

        if (this.__dataInstanceProps) {
          this._initializeInstanceProperties(this.__dataInstanceProps);

          this.__dataInstanceProps = null;
        }

        this.ready();
      }
    }
    /**
     * Calls the `_propertiesChanged` callback with the current set of
     * pending changes (and old values recorded when pending changes were
     * set), and resets the pending set of changes. Generally, this method
     * should not be called in user code.
     *
     *
     * @protected
     */


    _flushProperties() {
      if (this.__dataPending && this.__dataOld) {
        let changedProps = this.__dataPending;
        this.__dataPending = null;
        this.__dataCounter++;

        this._propertiesChanged(this.__data, changedProps, this.__dataOld);

        this.__dataCounter--;
      }
    }
    /**
     * Lifecycle callback called the first time properties are being flushed.
     * Prior to `ready`, all property sets through accessors are queued and
     * their effects are flushed after this method returns.
     *
     * Users may override this function to implement behavior that is
     * dependent on the element having its properties initialized, e.g.
     * from defaults (initialized from `constructor`, `_initializeProperties`),
     * `attributeChangedCallback`, or values propagated from host e.g. via
     * bindings.  `super.ready()` must be called to ensure the data system
     * becomes enabled.
     *
     * @public
     */


    ready() {
      this.__dataReady = true; // Run normal flush

      this._flushProperties();
    }
    /**
     * Callback called when any properties with accessors created via
     * `_createPropertyAccessor` have been set.
     *
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {!Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {!Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @protected
     */


    _propertiesChanged(currentProps, changedProps, oldProps) {} // eslint-disable-line no-unused-vars

    /**
     * Method called to determine whether a property value should be
     * considered as a change and cause the `_propertiesChanged` callback
     * to be enqueued.
     *
     * The default implementation returns `true` for primitive types if a
     * strict equality check fails, and returns `true` for all Object/Arrays.
     * The method always returns false for `NaN`.
     *
     * Override this method to e.g. provide stricter checking for
     * Objects/Arrays when using immutable patterns.
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     *   and enqueue a `_proeprtiesChanged` callback
     * @protected
     */


    _shouldPropertyChange(property, value, old) {
      return (// Strict equality check
        old !== value && ( // This ensures (old==NaN, value==NaN) always returns false
        old === old || value === value)
      );
    }

  }

  return PropertyAccessors;
});
/* harmony export (immutable) */ __webpack_exports__["a"] = PropertyAccessors;


/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);

/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */

let AsyncInterface; // eslint-disable-line no-unused-vars
// Microtask implemented using Mutation Observer

let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, {
  characterData: true
});

function microtaskFlush() {
  const len = microtaskCallbacks.length;

  for (let i = 0; i < len; i++) {
    let cb = microtaskCallbacks[i];

    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(() => {
          throw e;
        });
      }
    }
  }

  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}

const timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} delay Time to wait before calling callbacks in ms
   * @return {AsyncInterface} An async timeout interface
   */
  after(delay) {
    return {
      run(fn) {
        return setTimeout(fn, delay);
      },

      cancel: window.clearTimeout.bind(window)
    };
  },

  /**
   * Enqueues a function called in the next task.
   *
   * @memberof Polymer.Async.timeOut
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.setTimeout.bind(window),

  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.clearTimeout.bind(window)
};
/* unused harmony export timeOut */

const animationFrame = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof Polymer.Async.animationFrame
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.requestAnimationFrame.bind(window),

  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.cancelAnimationFrame.bind(window)
};
/* unused harmony export animationFrame */

const idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {function(IdleDeadline)} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
  },

  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel(handle) {
    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
  }

};
/* unused harmony export idlePeriod */

const microTask = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof Polymer.Async.microTask
   * @param {Function} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    microtaskNode.textContent = microtaskNodeContent++;
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },

  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof Polymer.Async.microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle;

    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }

      microtaskCallbacks[idx] = null;
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = microTask;


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(7);

 // 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)

const templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};

function wrapTemplateExtension(node) {
  let is = node.getAttribute('is');

  if (is && templateExtensions[is]) {
    let t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);

    while (t.attributes.length) {
      node.setAttribute(t.attributes[0].name, t.attributes[0].value);
      t.removeAttribute(t.attributes[0].name);
    }
  }

  return node;
}

function findTemplateNode(root, nodeInfo) {
  // recursively ascend tree until we hit root
  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo); // unwind the stack, returning the indexed node at each level

  if (parent) {
    // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    for (let n = parent.firstChild, i = 0; n; n = n.nextSibling) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
} // construct `$` map (from id annotations)


function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
} // install event listeners (from event annotations)


function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (let j = 0, e$ = nodeInfo.events, e; j < e$.length && (e = e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
} // push configuration references at configure time


function applyTemplateContent(inst, node, nodeInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
  }
}

function createNodeEventHandler(context, eventName, methodName) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  context = context._methodHost || context;

  let handler = function (e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };

  return handler;
}

const TemplateStamp = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {
  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */
  class TemplateStamp extends superClass {
    /**
     * Scans a template to produce template metadata.
     *
     * Template-specific metadata are stored in the object returned, and node-
     * specific metadata are stored in objects in its flattened `nodeInfoList`
     * array.  Only nodes in the template that were parsed as nodes of
     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
     * contains an `index` (`childNodes` index in parent) and optionally
     * `parent`, which points to node info of its parent (including its index).
     *
     * The template metadata object returned from this method has the following
     * structure (many fields optional):
     *
     * ```js
     *   {
     *     // Flattened list of node metadata (for nodes that generated metadata)
     *     nodeInfoList: [
     *       {
     *         // `id` attribute for any nodes with id's for generating `$` map
     *         id: {string},
     *         // `on-event="handler"` metadata
     *         events: [
     *           {
     *             name: {string},   // event name
     *             value: {string},  // handler method name
     *           }, ...
     *         ],
     *         // Notes when the template contained a `<slot>` for shady DOM
     *         // optimization purposes
     *         hasInsertionPoint: {boolean},
     *         // For nested `<template>`` nodes, nested template metadata
     *         templateInfo: {object}, // nested template metadata
     *         // Metadata to allow efficient retrieval of instanced node
     *         // corresponding to this metadata
     *         parentInfo: {number},   // reference to parent nodeInfo>
     *         parentIndex: {number},  // index in parent's `childNodes` collection
     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
     *       },
     *       ...
     *     ],
     *     // When true, the template had the `strip-whitespace` attribute
     *     // or was nested in a template with that setting
     *     stripWhitespace: {boolean},
     *     // For nested templates, nested template content is moved into
     *     // a document fragment stored here; this is an optimization to
     *     // avoid the cost of nested template cloning
     *     content: {DocumentFragment}
     *   }
     * ```
     *
     * This method kicks off a recursive treewalk as follows:
     *
     * ```
     *    _parseTemplate <---------------------+
     *      _parseTemplateContent              |
     *        _parseTemplateNode  <------------|--+
     *          _parseTemplateNestedTemplate --+  |
     *          _parseTemplateChildNodes ---------+
     *          _parseTemplateNodeAttributes
     *            _parseTemplateNodeAttribute
     *
     * ```
     *
     * These methods may be overridden to add custom metadata about templates
     * to either `templateInfo` or `nodeInfo`.
     *
     * Note that this method may be destructive to the template, in that
     * e.g. event annotations may be removed after being noted in the
     * template metadata.
     *
     * @param {!HTMLTemplateElement} template Template to parse
     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
     *   template, for parsing nested templates
     * @return {!TemplateInfo} Parsed template metadata
     */
    static _parseTemplate(template, outerTemplateInfo) {
      // since a template may be re-used, memo-ize metadata
      if (!template._templateInfo) {
        let templateInfo = template._templateInfo = {};
        templateInfo.nodeInfoList = [];
        templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template.hasAttribute('strip-whitespace');

        this._parseTemplateContent(template, templateInfo, {
          parent: null
        });
      }

      return template._templateInfo;
    }

    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
    }
    /**
     * Parses template node and adds template and node metadata based on
     * the current node, and its `childNodes` and `attributes`.
     *
     * This method may be overridden to add custom node or template specific
     * metadata based on this node.
     *
     * @param {Node} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */


    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted;
      let element =
      /** @type Element */
      node;

      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
      } else if (element.localName === 'slot') {
        // For ShadyDom optimization, indicating there is an insertion point
        templateInfo.hasInsertionPoint = true;
      }

      if (element.firstChild) {
        noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
      }

      if (element.hasAttributes && element.hasAttributes()) {
        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
      }

      return noted;
    }
    /**
     * Parses template child nodes for the given root node.
     *
     * This method also wraps whitelisted legacy template extensions
     * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
     * wrappers, collapses text nodes, and strips whitespace from the template
     * if the `templateInfo.stripWhitespace` setting was provided.
     *
     * @param {Node} root Root node whose `childNodes` will be parsed
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     */


    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
      for (let node = root.firstChild, parentIndex = 0, next; node; node = next) {
        // Wrap templates
        if (node.localName == 'template') {
          node = wrapTemplateExtension(node);
        } // collapse adjacent textNodes: fixes an IE issue that can cause
        // text nodes to be inexplicably split =(
        // note that root.normalize() should work but does not so we do this
        // manually.


        next = node.nextSibling;

        if (node.nodeType === Node.TEXT_NODE) {
          let
          /** Node */
          n = next;

          while (n && n.nodeType === Node.TEXT_NODE) {
            node.textContent += n.textContent;
            next = n.nextSibling;
            root.removeChild(n);
            n = next;
          } // optionally strip whitespace


          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
            root.removeChild(node);
            continue;
          }
        }

        let childInfo = {
          parentIndex,
          parentInfo: nodeInfo
        };

        if (this._parseTemplateNode(node, templateInfo, childInfo)) {
          childInfo.infoIndex = templateInfo.nodeInfoList.push(
          /** @type {!NodeInfo} */
          childInfo) - 1;
        } // Increment if not removed


        if (node.parentNode) {
          parentIndex++;
        }
      }
    }
    /**
     * Parses template content for the given nested `<template>`.
     *
     * Nested template info is stored as `templateInfo` in the current node's
     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
     * It will then be the responsibility of the host to set it back to the
     * template and for users stamping nested templates to use the
     * `_contentForTemplate` method to retrieve the content for this template
     * (an optimization to avoid the cost of cloning nested template content).
     *
     * @param {HTMLTemplateElement} node Node to parse (a <template>)
     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
     *   that includes the template `node`
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */


    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
      let templateInfo = this._parseTemplate(node, outerTemplateInfo);

      let content = templateInfo.content = node.content.ownerDocument.createDocumentFragment();
      content.appendChild(node.content);
      nodeInfo.templateInfo = templateInfo;
      return true;
    }
    /**
     * Parses template node attributes and adds node metadata to `nodeInfo`
     * for nodes of interest.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */


    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
      // Make copy of original attribute list, since the order may change
      // as attributes are added and removed
      let noted = false;
      let attrs = Array.from(node.attributes);

      for (let i = attrs.length - 1, a; a = attrs[i]; i--) {
        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
      }

      return noted;
    }
    /**
     * Parses a single template node attribute and adds node metadata to
     * `nodeInfo` for attributes of interest.
     *
     * This implementation adds metadata for `on-event="handler"` attributes
     * and `id` attributes.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */


    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      // events (on-*)
      if (name.slice(0, 3) === 'on-') {
        node.removeAttribute(name);
        nodeInfo.events = nodeInfo.events || [];
        nodeInfo.events.push({
          name: name.slice(3),
          value
        });
        return true;
      } // static id
      else if (name === 'id') {
          nodeInfo.id = value;
          return true;
        }

      return false;
    }
    /**
     * Returns the `content` document fragment for a given template.
     *
     * For nested templates, Polymer performs an optimization to cache nested
     * template content to avoid the cost of cloning deeply nested templates.
     * This method retrieves the cached content for a given template.
     *
     * @param {HTMLTemplateElement} template Template to retrieve `content` for
     * @return {DocumentFragment} Content fragment
     */


    static _contentForTemplate(template) {
      let templateInfo =
      /** @type {HTMLTemplateElementWithInfo} */
      template._templateInfo;
      return templateInfo && templateInfo.content || template.content;
    }
    /**
     * Clones the provided template content and returns a document fragment
     * containing the cloned dom.
     *
     * The template is parsed (once and memoized) using this library's
     * template parsing features, and provides the following value-added
     * features:
     * * Adds declarative event listeners for `on-event="handler"` attributes
     * * Generates an "id map" for all nodes with id's under `$` on returned
     *   document fragment
     * * Passes template info including `content` back to templates as
     *   `_templateInfo` (a performance optimization to avoid deep template
     *   cloning)
     *
     * Note that the memoized template parsing process is destructive to the
     * template: attributes for bindings and declarative event listeners are
     * removed after being noted in notes, and any nested `<template>.content`
     * is removed and stored in notes as well.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     */


    _stampTemplate(template) {
      // Polyfill support: bootstrap the template if it has not already been
      if (template && !template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
        HTMLTemplateElement.decorate(template);
      }

      let templateInfo = this.constructor._parseTemplate(template);

      let nodeInfo = templateInfo.nodeInfoList;
      let content = templateInfo.content || template.content;
      let dom =
      /** @type DocumentFragment */
      document.importNode(content, true); // NOTE: ShadyDom optimization indicating there is an insertion point

      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
      let nodes = dom.nodeList = new Array(nodeInfo.length);
      dom.$ = {};

      for (let i = 0, l = nodeInfo.length, info; i < l && (info = nodeInfo[i]); i++) {
        let node = nodes[i] = findTemplateNode(dom, info);
        applyIdToMap(this, dom.$, node, info);
        applyTemplateContent(this, node, info);
        applyEventListener(this, node, info);
      }

      return (
        /** @type {!StampedTemplate} */
        dom
      );
    }
    /**
     * Adds an event listener by method name for the event provided.
     *
     * This method generates a handler function that looks up the method
     * name at handling time.
     *
     * @param {Node} node Node to add listener on
     * @param {string} eventName Name of event
     * @param {string} methodName Name of method
     * @param {*=} context Context the method will be called on (defaults
     *   to `node`)
     * @return {Function} Generated handler function
     */


    _addMethodEventListenerToNode(node, eventName, methodName, context) {
      context = context || node;
      let handler = createNodeEventHandler(context, eventName, methodName);

      this._addEventListenerToNode(node, eventName, handler);

      return handler;
    }
    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {Node} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {Function} handler Listener function to add
     */


    _addEventListenerToNode(node, eventName, handler) {
      node.addEventListener(eventName, handler);
    }
    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {Node} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {Function} handler Listener function to remove
     */


    _removeEventListenerFromNode(node, eventName, handler) {
      node.removeEventListener(eventName, handler);
    }

  }

  return TemplateStamp;
});
/* harmony export (immutable) */ __webpack_exports__["a"] = TemplateStamp;


/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = "<style>\n  hr {\n      border: 0.5px solid;\n  }\n</style>\n\n<div>[[text]]</div>\n\n<hr>\n"

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgNjA4YWRiZjcxYjhhODdiN2IxNWUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3dhcm5pbmcuanMiLCJ3ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9yZWFjdEluaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL2dsb2JhbC9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy93ZWJjb21wb25lbnRzLWxpdGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9jb21wb25lbnRzL3JlYWN0SGVhZGluZy9jbGllbnQuanN4Iiwid2VicGFjazovLy8uL2VsZW1lbnRzL3R0YS11bmRlcmxpbmVkLXRleHQvdHRhLXVuZGVybGluZWQtdGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9wYXRoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktYWNjZXNzb3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmpzIiwid2VicGFjazovLy8uL2VsZW1lbnRzL3R0YS11bmRlcmxpbmVkLXRleHQvdHRhLXVuZGVybGluZWQtdGV4dC5odG1sIl0sIm5hbWVzIjpbIndpbmRvdyIsIkpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkiLCJwcm9wIiwib2JqIiwiUG9seW1lciIsInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImVudiIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJhcmciLCJlbXB0eUZ1bmN0aW9uIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNOdWxsIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsImNhc2VNYXAiLCJEQVNIX1RPX0NBTUVMIiwiQ0FNRUxfVE9fREFTSCIsImRhc2hUb0NhbWVsQ2FzZSIsImRhc2giLCJpbmRleE9mIiwicmVwbGFjZSIsIm0iLCJ0b1VwcGVyQ2FzZSIsImNhbWVsVG9EYXNoQ2FzZSIsImNhbWVsIiwidG9Mb3dlckNhc2UiLCJOT0RFX0VOViIsInJlcXVpcmUiLCJlbXB0eU9iamVjdCIsIk9iamVjdCIsImZyZWV6ZSIsIkNTU19VUkxfUlgiLCJBQlNfVVJMIiwid29ya2luZ1VSTCIsInJlc29sdmVEb2MiLCJyZXNvbHZlVXJsIiwidXJsIiwiYmFzZVVSSSIsInRlc3QiLCJ1bmRlZmluZWQiLCJ1IiwiVVJMIiwicGF0aG5hbWUiLCJocmVmIiwiZG9jdW1lbnQiLCJsb2NhdGlvbiIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlSFRNTERvY3VtZW50IiwiYmFzZSIsImNyZWF0ZUVsZW1lbnQiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJhbmNob3IiLCJib2R5IiwicmVzb2x2ZUNzcyIsImNzc1RleHQiLCJwcmUiLCJwb3N0IiwicGF0aEZyb21VcmwiLCJzdWJzdHJpbmciLCJsYXN0SW5kZXhPZiIsImRlZHVwZUlkIiwiTWl4aW5GdW5jdGlvbiIsIl9fbWl4aW5BcHBsaWNhdGlvbnMiLCJfX21peGluU2V0IiwiZGVkdXBpbmdNaXhpbiIsIm1peGluIiwibWl4aW5BcHBsaWNhdGlvbnMiLCJXZWFrTWFwIiwibWl4aW5EZWR1cGVJZCIsImJhc2VTZXQiLCJtYXAiLCJleHRlbmRlZCIsImdldCIsInNldCIsIm1peGluU2V0IiwiY3JlYXRlIiwidmFsaWRhdGVGb3JtYXQiLCJmb3JtYXQiLCJpbnZhcmlhbnQiLCJjb25kaXRpb24iLCJhIiwiYiIsImMiLCJkIiwiZiIsImVycm9yIiwiYXJnSW5kZXgiLCJmcmFtZXNUb1BvcCIsIndhcm5pbmciLCJwcmludFdhcm5pbmciLCJfbGVuIiwiX2tleSIsIm1lc3NhZ2UiLCJjb25zb2xlIiwieCIsIl9sZW4yIiwiX2tleTIiLCJyZWFjdEluaXQiLCJzZWxlY3RvciIsIlJlYWN0Q29tcG9uZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwibm9kZSIsIlJlYWN0RE9NIiwicmVuZGVyIiwiZ2V0QXR0cmlidXRlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaGFzT3duUHJvcGVydHkiLCJwcm9wSXNFbnVtZXJhYmxlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJ0b09iamVjdCIsInZhbCIsIlR5cGVFcnJvciIsInNob3VsZFVzZU5hdGl2ZSIsImFzc2lnbiIsInRlc3QxIiwiU3RyaW5nIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInRlc3QyIiwiZnJvbUNoYXJDb2RlIiwib3JkZXIyIiwibiIsImpvaW4iLCJ0ZXN0MyIsInNwbGl0IiwibGV0dGVyIiwia2V5cyIsImVyciIsInRhcmdldCIsInNvdXJjZSIsImZyb20iLCJ0byIsInN5bWJvbHMiLCJzIiwia2V5IiwiUmVhY3RQcm9wVHlwZXNTZWNyZXQiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJjaGVja1Byb3BUeXBlcyIsInR5cGVTcGVjcyIsInZhbHVlcyIsImNvbXBvbmVudE5hbWUiLCJnZXRTdGFjayIsInR5cGVTcGVjTmFtZSIsImV4Iiwic3RhY2siLCJjYW5Vc2VET00iLCJFeGVjdXRpb25FbnZpcm9ubWVudCIsImNhblVzZVdvcmtlcnMiLCJXb3JrZXIiLCJjYW5Vc2VFdmVudExpc3RlbmVycyIsImF0dGFjaEV2ZW50IiwiY2FuVXNlVmlld3BvcnQiLCJzY3JlZW4iLCJpc0luV29ya2VyIiwiRXZlbnRMaXN0ZW5lciIsImxpc3RlbiIsImV2ZW50VHlwZSIsImNhbGxiYWNrIiwicmVtb3ZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwiY2FwdHVyZSIsInJlZ2lzdGVyRGVmYXVsdCIsImdldEFjdGl2ZUVsZW1lbnQiLCJkb2MiLCJhY3RpdmVFbGVtZW50IiwiaXMiLCJ5Iiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXNCIiwiaXNUZXh0Tm9kZSIsImNvbnRhaW5zTm9kZSIsIm91dGVyTm9kZSIsImlubmVyTm9kZSIsInBhcmVudE5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiZm9jdXNOb2RlIiwiZm9jdXMiLCJzZXR0aW5ncyIsInVzZVNoYWRvdyIsIlNoYWR5RE9NIiwidXNlTmF0aXZlQ1NTUHJvcGVydGllcyIsIkJvb2xlYW4iLCJTaGFkeUNTUyIsIm5hdGl2ZUNzcyIsInVzZU5hdGl2ZUN1c3RvbUVsZW1lbnRzIiwiY3VzdG9tRWxlbWVudHMiLCJwb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrIiwicm9vdFBhdGgiLCJzZXRSb290UGF0aCIsInBhdGgiLCJzYW5pdGl6ZURPTVZhbHVlIiwic2V0U2FuaXRpemVET01WYWx1ZSIsIm5ld1Nhbml0aXplRE9NVmFsdWUiLCJwIiwicSIsIlN5bWJvbCIsInIiLCJ0IiwidiIsInciLCJpdGVyYXRvciIsImVuY29kZVVSSUNvbXBvbmVudCIsInoiLCJpc01vdW50ZWQiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwiQSIsInByb3BzIiwiY29udGV4dCIsInJlZnMiLCJ1cGRhdGVyIiwiaXNSZWFjdENvbXBvbmVudCIsInNldFN0YXRlIiwiZm9yY2VVcGRhdGUiLCJCIiwiQyIsIkQiLCJjb25zdHJ1Y3RvciIsImlzUHVyZVJlYWN0Q29tcG9uZW50IiwiRSIsIkYiLCJ1bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQiLCJjaGlsZHJlbiIsIkciLCJjdXJyZW50IiwiSCIsIkkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsIkoiLCJnIiwiayIsImgiLCJsIiwiZGVmYXVsdFByb3BzIiwiJCR0eXBlb2YiLCJ0eXBlIiwiX293bmVyIiwiSyIsImVzY2FwZSIsIkwiLCJNIiwiTiIsInBvcCIsInJlc3VsdCIsImtleVByZWZpeCIsImZ1bmMiLCJjb3VudCIsIk8iLCJQIiwiUSIsImlzQXJyYXkiLCJuZXh0IiwiZG9uZSIsInZhbHVlIiwidG9TdHJpbmciLCJSIiwiUyIsIlQiLCJVIiwiQ2hpbGRyZW4iLCJ0b0FycmF5Iiwib25seSIsIkNvbXBvbmVudCIsIlB1cmVDb21wb25lbnQiLCJ1bnN0YWJsZV9Bc3luY0NvbXBvbmVudCIsIkZyYWdtZW50IiwiY2xvbmVFbGVtZW50IiwiY3JlYXRlRmFjdG9yeSIsImJpbmQiLCJpc1ZhbGlkRWxlbWVudCIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiUmVhY3RDdXJyZW50T3duZXIiLCJWIiwiZGVmYXVsdCIsIlciLCJfYXNzaWduIiwiUmVhY3RWZXJzaW9uIiwiaGFzU3ltYm9sIiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiUkVBQ1RfQ0FMTF9UWVBFIiwiUkVBQ1RfUkVUVVJOX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsImxvd1ByaW9yaXR5V2FybmluZyIsIndhcm4iLCJsb3dQcmlvcml0eVdhcm5pbmckMSIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCIsIndhcm5Ob29wIiwicHVibGljSW5zdGFuY2UiLCJjYWxsZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJ3YXJuaW5nS2V5IiwiUmVhY3ROb29wVXBkYXRlUXVldWUiLCJjb21wbGV0ZVN0YXRlIiwicGFydGlhbFN0YXRlIiwiZGVwcmVjYXRlZEFQSXMiLCJyZXBsYWNlU3RhdGUiLCJkZWZpbmVEZXByZWNhdGlvbldhcm5pbmciLCJtZXRob2ROYW1lIiwiaW5mbyIsImRlZmluZVByb3BlcnR5IiwiZm5OYW1lIiwiQ29tcG9uZW50RHVtbXkiLCJwdXJlQ29tcG9uZW50UHJvdG90eXBlIiwiQXN5bmNDb21wb25lbnQiLCJhc3luY0NvbXBvbmVudFByb3RvdHlwZSIsIlJFU0VSVkVEX1BST1BTIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImhhc1ZhbGlkUmVmIiwiY29uZmlnIiwiZ2V0dGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiY29uZmlndXJhYmxlIiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJzZWxmIiwib3duZXIiLCJlbGVtZW50IiwiX3N0b3JlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwicHJvcE5hbWUiLCJjaGlsZHJlbkxlbmd0aCIsImNoaWxkQXJyYXkiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsIl9zZWxmIiwiX3NvdXJjZSIsIm9iamVjdCIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJnZXRDdXJyZW50U3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiaW1wbCIsIlNFUEFSQVRPUiIsIlNVQlNFUEFSQVRPUiIsImVzY2FwZVJlZ2V4IiwiZXNjYXBlckxvb2t1cCIsImVzY2FwZWRTdHJpbmciLCJtYXRjaCIsImRpZFdhcm5BYm91dE1hcHMiLCJ1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCIsImVzY2FwZVVzZXJQcm92aWRlZEtleSIsInRleHQiLCJQT09MX1NJWkUiLCJ0cmF2ZXJzZUNvbnRleHRQb29sIiwiZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0IiwibWFwUmVzdWx0IiwibWFwRnVuY3Rpb24iLCJtYXBDb250ZXh0IiwidHJhdmVyc2VDb250ZXh0IiwicmVsZWFzZVRyYXZlcnNlQ29udGV4dCIsInRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsIiwibmFtZVNvRmFyIiwiaW52b2tlQ2FsbGJhY2siLCJnZXRDb21wb25lbnRLZXkiLCJjaGlsZCIsIm5leHROYW1lIiwic3VidHJlZUNvdW50IiwibmV4dE5hbWVQcmVmaXgiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJpaSIsImFkZGVuZHVtIiwiY2hpbGRyZW5TdHJpbmciLCJ0cmF2ZXJzZUFsbENoaWxkcmVuIiwiY29tcG9uZW50IiwiaW5kZXgiLCJmb3JFYWNoU2luZ2xlQ2hpbGQiLCJib29rS2VlcGluZyIsImZvckVhY2hDaGlsZHJlbiIsImZvckVhY2hGdW5jIiwiZm9yRWFjaENvbnRleHQiLCJtYXBTaW5nbGVDaGlsZEludG9Db250ZXh0IiwiY2hpbGRLZXkiLCJtYXBwZWRDaGlsZCIsIm1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwiLCJwcmVmaXgiLCJlc2NhcGVkUHJlZml4IiwibWFwQ2hpbGRyZW4iLCJjb3VudENoaWxkcmVuIiwib25seUNoaWxkIiwiZGVzY3JpYmVDb21wb25lbnRGcmFtZSIsIm93bmVyTmFtZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImdldENvbXBvbmVudE5hbWUiLCJmaWJlciIsImN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50IiwicHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24iLCJnZXREaXNwbGF5TmFtZSIsIlZBTElEX0ZSQUdNRU5UX1BST1BTIiwiTWFwIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJlbGVtZW50UHJvcHMiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsInZhbGlkYXRlUHJvcFR5cGVzIiwiY29tcG9uZW50Q2xhc3MiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50IiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiIsIl9kaWRJdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3IiLCJfc3RlcCIsImhhcyIsImNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24iLCJ2YWxpZGF0ZWRGYWN0b3J5IiwiY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJSZWFjdCIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJSZWFjdCQyIiwiUmVhY3QkMyIsInJlYWN0IiwiY2hlY2tEQ0UiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJhYSIsImJhIiwiZGEiLCJlYSIsImZhIiwiaWEiLCJvYSIsImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MIiwiZGVmYXVsdFZhbHVlIiwiZGVmYXVsdENoZWNrZWQiLCJpbm5lckhUTUwiLCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmciLCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmciLCJzdHlsZSIsInBhIiwidGEiLCJNVVNUX1VTRV9QUk9QRVJUWSIsIkhBU19CT09MRUFOX1ZBTFVFIiwiSEFTX05VTUVSSUNfVkFMVUUiLCJIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSIsIkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUiLCJIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUiLCJpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyIsIlByb3BlcnRpZXMiLCJET01BdHRyaWJ1dGVOYW1lc3BhY2VzIiwiRE9NQXR0cmlidXRlTmFtZXMiLCJET01NdXRhdGlvbk1ldGhvZHMiLCJ1YSIsImF0dHJpYnV0ZU5hbWUiLCJhdHRyaWJ1dGVOYW1lc3BhY2UiLCJwcm9wZXJ0eU5hbWUiLCJtdXRhdGlvbk1ldGhvZCIsIm11c3RVc2VQcm9wZXJ0eSIsImhhc0Jvb2xlYW5WYWx1ZSIsImhhc051bWVyaWNWYWx1ZSIsImhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlIiwiaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSIsImhhc1N0cmluZ0Jvb2xlYW5WYWx1ZSIsInZhIiwid2EiLCJzbGljZSIsInhhIiwieWEiLCJ6YSIsIkFhIiwiQmEiLCJDYSIsIkRhIiwiYWxsb3dGdWxsU2NyZWVuIiwiYXN5bmMiLCJhdXRvRm9jdXMiLCJhdXRvUGxheSIsImNoZWNrZWQiLCJjb2xzIiwiY29udGVudEVkaXRhYmxlIiwiY29udHJvbHMiLCJkZWZlciIsImRpc2FibGVkIiwiZG93bmxvYWQiLCJkcmFnZ2FibGUiLCJmb3JtTm9WYWxpZGF0ZSIsImhpZGRlbiIsImxvb3AiLCJtdWx0aXBsZSIsIm11dGVkIiwibm9WYWxpZGF0ZSIsIm9wZW4iLCJwbGF5c0lubGluZSIsInJlYWRPbmx5IiwicmVxdWlyZWQiLCJyZXZlcnNlZCIsInJvd3MiLCJyb3dTcGFuIiwic2NvcGVkIiwic2VhbWxlc3MiLCJzZWxlY3RlZCIsInNpemUiLCJzdGFydCIsInNwYW4iLCJzcGVsbENoZWNrIiwidGFiSW5kZXgiLCJpdGVtU2NvcGUiLCJhY2NlcHRDaGFyc2V0IiwiY2xhc3NOYW1lIiwiaHRtbEZvciIsImh0dHBFcXVpdiIsInJlbW92ZUF0dHJpYnV0ZSIsImhhc0F0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInZhbGlkaXR5IiwiYmFkSW5wdXQiLCJvd25lckRvY3VtZW50IiwiRWEiLCJ4bGluayIsInhtbCIsIkdhIiwiYXV0b1JldmVyc2UiLCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkIiwicHJlc2VydmVBbHBoYSIsInhsaW5rQWN0dWF0ZSIsInhsaW5rQXJjcm9sZSIsInhsaW5rSHJlZiIsInhsaW5rUm9sZSIsInhsaW5rU2hvdyIsInhsaW5rVGl0bGUiLCJ4bGlua1R5cGUiLCJ4bWxCYXNlIiwieG1sTGFuZyIsInhtbFNwYWNlIiwiSGEiLCJJYSIsIl9jYXVnaHRFcnJvciIsIl9oYXNDYXVnaHRFcnJvciIsIl9yZXRocm93RXJyb3IiLCJfaGFzUmV0aHJvd0Vycm9yIiwiaW5qZWN0aW9uIiwiaW5qZWN0RXJyb3JVdGlscyIsImludm9rZUd1YXJkZWRDYWxsYmFjayIsIkphIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yIiwiaGFzQ2F1Z2h0RXJyb3IiLCJjbGVhckNhdWdodEVycm9yIiwicmV0aHJvd0NhdWdodEVycm9yIiwiS2EiLCJMYSIsIk1hIiwiTmEiLCJPYSIsImV4dHJhY3RFdmVudHMiLCJldmVudFR5cGVzIiwiUGEiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyIsIlFhIiwicmVnaXN0cmF0aW9uTmFtZSIsIlJhIiwiU2EiLCJkZXBlbmRlbmNpZXMiLCJUYSIsIlVhIiwiVmEiLCJwbHVnaW5zIiwiZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzIiwicmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMiLCJyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzIiwicG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyIsImluamVjdEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUiLCJXYSIsIlhhIiwiWWEiLCJaYSIsImN1cnJlbnRUYXJnZXQiLCIkYSIsImFiIiwiYmIiLCJjYiIsIl9kaXNwYXRjaExpc3RlbmVycyIsIl9kaXNwYXRjaEluc3RhbmNlcyIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiaXNQZXJzaXN0ZW50IiwicmVsZWFzZSIsImRiIiwiZ2IiLCJoYiIsImliIiwic3RhdGVOb2RlIiwiamIiLCJrYiIsImxiIiwibWIiLCJnZXRMaXN0ZW5lciIsImVucXVldWVFdmVudHMiLCJwcm9jZXNzRXZlbnRRdWV1ZSIsIm5iIiwiTWF0aCIsInJhbmRvbSIsIm9iIiwicGIiLCJ0YWciLCJxYiIsInJiIiwic2IiLCJwcmVjYWNoZUZpYmVyTm9kZSIsImdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImdldE5vZGVGcm9tSW5zdGFuY2UiLCJnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlIiwidXBkYXRlRmliZXJQcm9wcyIsInRiIiwidWIiLCJ2YiIsImRpc3BhdGNoQ29uZmlnIiwid2IiLCJfdGFyZ2V0SW5zdCIsInhiIiwieWIiLCJ6YiIsIkFiIiwiQmIiLCJhbHRlcm5hdGUiLCJDYiIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCIsImFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyIsImFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzIiwiRGIiLCJFYiIsImRvY3VtZW50RWxlbWVudCIsIl9yb290IiwiX3N0YXJ0VGV4dCIsIl9mYWxsYmFja1RleHQiLCJGYiIsIkdiIiwiSGIiLCJJYiIsImV2ZW50UGhhc2UiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInRpbWVTdGFtcCIsIkRhdGUiLCJub3ciLCJkZWZhdWx0UHJldmVudGVkIiwiaXNUcnVzdGVkIiwibmF0aXZlRXZlbnQiLCJJbnRlcmZhY2UiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJyZXR1cm5WYWx1ZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsImRlc3RydWN0b3IiLCJhdWdtZW50Q2xhc3MiLCJKYiIsIktiIiwiZXZlbnRQb29sIiwiTGIiLCJnZXRQb29sZWQiLCJNYiIsImRhdGEiLCJOYiIsIlBiIiwiVmIiLCJXYiIsImRvY3VtZW50TW9kZSIsIlhiIiwiWWIiLCJvcGVyYSIsInBhcnNlSW50IiwiWmIiLCIkYiIsImFjIiwiYmMiLCJiZWZvcmVJbnB1dCIsImJ1YmJsZWQiLCJjYXB0dXJlZCIsImNvbXBvc2l0aW9uRW5kIiwiY29tcG9zaXRpb25TdGFydCIsImNvbXBvc2l0aW9uVXBkYXRlIiwiY2MiLCJkYyIsImtleUNvZGUiLCJlYyIsImRldGFpbCIsImZjIiwiZ2MiLCJ3aGljaCIsImhjIiwiY3RybEtleSIsImFsdEtleSIsIm1ldGFLZXkiLCJjaGFyIiwiaWMiLCJqYyIsImtjIiwibGMiLCJtYyIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUiLCJuYyIsImluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQiLCJvYyIsInBjIiwicWMiLCJlbnF1ZXVlU3RhdGVSZXN0b3JlIiwicmVzdG9yZVN0YXRlSWZOZWVkZWQiLCJyYyIsInNjIiwidGMiLCJ1YyIsImNvbG9yIiwiZGF0ZSIsImRhdGV0aW1lIiwiZW1haWwiLCJtb250aCIsIm51bWJlciIsInBhc3N3b3JkIiwicmFuZ2UiLCJzZWFyY2giLCJ0ZWwiLCJ0aW1lIiwid2VlayIsInZjIiwibm9kZU5hbWUiLCJ3YyIsInNyY0VsZW1lbnQiLCJjb3JyZXNwb25kaW5nVXNlRWxlbWVudCIsIm5vZGVUeXBlIiwieGMiLCJoYXNGZWF0dXJlIiwieWMiLCJ6YyIsIkFjIiwiZ2V0VmFsdWUiLCJzZXRWYWx1ZSIsInN0b3BUcmFja2luZyIsIl92YWx1ZVRyYWNrZXIiLCJCYyIsIkNjIiwiRGMiLCJjaGFuZ2UiLCJFYyIsIkZjIiwiR2MiLCJIYyIsIkljIiwiSmMiLCJLYyIsIkxjIiwiTWMiLCJOYyIsIk9jIiwiUGMiLCIkYyIsImFkIiwiX2lzSW5wdXRFdmVudFN1cHBvcnRlZCIsIl93cmFwcGVyU3RhdGUiLCJjb250cm9sbGVkIiwiYmQiLCJ2aWV3IiwiY2QiLCJBbHQiLCJDb250cm9sIiwiTWV0YSIsIlNoaWZ0IiwiZGQiLCJnZXRNb2RpZmllclN0YXRlIiwiZWQiLCJmZCIsInNjcmVlblgiLCJzY3JlZW5ZIiwiY2xpZW50WCIsImNsaWVudFkiLCJwYWdlWCIsInBhZ2VZIiwic2hpZnRLZXkiLCJidXR0b24iLCJidXR0b25zIiwicmVsYXRlZFRhcmdldCIsImZyb21FbGVtZW50IiwidG9FbGVtZW50IiwiZ2QiLCJtb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsImhkIiwiZGVmYXVsdFZpZXciLCJwYXJlbnRXaW5kb3ciLCJpZCIsImpkIiwia2QiLCJlZmZlY3RUYWciLCJsZCIsIl9yZWFjdEludGVybmFsRmliZXIiLCJtZCIsIm5kIiwic2libGluZyIsIm9kIiwicGQiLCJxZCIsInJkIiwidGFyZ2V0SW5zdCIsImFuY2VzdG9ycyIsImNvbnRhaW5lckluZm8iLCJzZCIsInRvcExldmVsVHlwZSIsInRkIiwidWQiLCJ2ZCIsIndkIiwieGQiLCJfZW5hYmxlZCIsIl9oYW5kbGVUb3BMZXZlbCIsInNldEhhbmRsZVRvcExldmVsIiwic2V0RW5hYmxlZCIsImlzRW5hYmxlZCIsInRyYXBCdWJibGVkRXZlbnQiLCJ0cmFwQ2FwdHVyZWRFdmVudCIsImRpc3BhdGNoRXZlbnQiLCJ5ZCIsInpkIiwiYW5pbWF0aW9uZW5kIiwiYW5pbWF0aW9uaXRlcmF0aW9uIiwiYW5pbWF0aW9uc3RhcnQiLCJ0cmFuc2l0aW9uZW5kIiwiQWQiLCJCZCIsImFuaW1hdGlvbiIsInRyYW5zaXRpb24iLCJDZCIsIkRkIiwidG9wQWJvcnQiLCJ0b3BBbmltYXRpb25FbmQiLCJ0b3BBbmltYXRpb25JdGVyYXRpb24iLCJ0b3BBbmltYXRpb25TdGFydCIsInRvcEJsdXIiLCJ0b3BDYW5jZWwiLCJ0b3BDYW5QbGF5IiwidG9wQ2FuUGxheVRocm91Z2giLCJ0b3BDaGFuZ2UiLCJ0b3BDbGljayIsInRvcENsb3NlIiwidG9wQ29tcG9zaXRpb25FbmQiLCJ0b3BDb21wb3NpdGlvblN0YXJ0IiwidG9wQ29tcG9zaXRpb25VcGRhdGUiLCJ0b3BDb250ZXh0TWVudSIsInRvcENvcHkiLCJ0b3BDdXQiLCJ0b3BEb3VibGVDbGljayIsInRvcERyYWciLCJ0b3BEcmFnRW5kIiwidG9wRHJhZ0VudGVyIiwidG9wRHJhZ0V4aXQiLCJ0b3BEcmFnTGVhdmUiLCJ0b3BEcmFnT3ZlciIsInRvcERyYWdTdGFydCIsInRvcERyb3AiLCJ0b3BEdXJhdGlvbkNoYW5nZSIsInRvcEVtcHRpZWQiLCJ0b3BFbmNyeXB0ZWQiLCJ0b3BFbmRlZCIsInRvcEVycm9yIiwidG9wRm9jdXMiLCJ0b3BJbnB1dCIsInRvcEtleURvd24iLCJ0b3BLZXlQcmVzcyIsInRvcEtleVVwIiwidG9wTG9hZGVkRGF0YSIsInRvcExvYWQiLCJ0b3BMb2FkZWRNZXRhZGF0YSIsInRvcExvYWRTdGFydCIsInRvcE1vdXNlRG93biIsInRvcE1vdXNlTW92ZSIsInRvcE1vdXNlT3V0IiwidG9wTW91c2VPdmVyIiwidG9wTW91c2VVcCIsInRvcFBhc3RlIiwidG9wUGF1c2UiLCJ0b3BQbGF5IiwidG9wUGxheWluZyIsInRvcFByb2dyZXNzIiwidG9wUmF0ZUNoYW5nZSIsInRvcFNjcm9sbCIsInRvcFNlZWtlZCIsInRvcFNlZWtpbmciLCJ0b3BTZWxlY3Rpb25DaGFuZ2UiLCJ0b3BTdGFsbGVkIiwidG9wU3VzcGVuZCIsInRvcFRleHRJbnB1dCIsInRvcFRpbWVVcGRhdGUiLCJ0b3BUb2dnbGUiLCJ0b3BUb3VjaENhbmNlbCIsInRvcFRvdWNoRW5kIiwidG9wVG91Y2hNb3ZlIiwidG9wVG91Y2hTdGFydCIsInRvcFRyYW5zaXRpb25FbmQiLCJ0b3BWb2x1bWVDaGFuZ2UiLCJ0b3BXYWl0aW5nIiwidG9wV2hlZWwiLCJFZCIsIkZkIiwiR2QiLCJIZCIsIklkIiwiZmlyc3RDaGlsZCIsIkpkIiwidGV4dENvbnRlbnQiLCJvZmZzZXQiLCJuZXh0U2libGluZyIsIktkIiwiTGQiLCJNZCIsInNlbGVjdCIsIk5kIiwiT2QiLCJQZCIsIlFkIiwiUmQiLCJzZWxlY3Rpb25TdGFydCIsImVuZCIsInNlbGVjdGlvbkVuZCIsImdldFNlbGVjdGlvbiIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsIlNkIiwib25TZWxlY3QiLCJUZCIsImFuaW1hdGlvbk5hbWUiLCJlbGFwc2VkVGltZSIsInBzZXVkb0VsZW1lbnQiLCJVZCIsImNsaXBib2FyZERhdGEiLCJWZCIsIldkIiwiY2hhckNvZGUiLCJYZCIsIkVzYyIsIlNwYWNlYmFyIiwiTGVmdCIsIlVwIiwiUmlnaHQiLCJEb3duIiwiRGVsIiwiV2luIiwiTWVudSIsIkFwcHMiLCJTY3JvbGwiLCJNb3pQcmludGFibGVLZXkiLCJZZCIsIlpkIiwicmVwZWF0IiwibG9jYWxlIiwiJGQiLCJkYXRhVHJhbnNmZXIiLCJhZSIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJiZSIsImNlIiwiZGVsdGFYIiwid2hlZWxEZWx0YVgiLCJkZWx0YVkiLCJ3aGVlbERlbHRhWSIsIndoZWVsRGVsdGEiLCJkZWx0YVoiLCJkZWx0YU1vZGUiLCJkZSIsImVlIiwiZmUiLCJTaW1wbGVFdmVudFBsdWdpbiIsIkVudGVyTGVhdmVFdmVudFBsdWdpbiIsIkNoYW5nZUV2ZW50UGx1Z2luIiwiU2VsZWN0RXZlbnRQbHVnaW4iLCJCZWZvcmVJbnB1dEV2ZW50UGx1Z2luIiwiZ2UiLCJoZSIsIlNldCIsImllIiwiWCIsImplIiwia2UiLCJsZSIsIm1lIiwiY29udGV4dFR5cGVzIiwiX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0IiwiY2hpbGRDb250ZXh0VHlwZXMiLCJuZSIsIm9lIiwiY3Vyc29yIiwicGUiLCJnZXRDaGlsZENvbnRleHQiLCJxZSIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwicmUiLCJZIiwibWVtb2l6ZWRTdGF0ZSIsInVwZGF0ZVF1ZXVlIiwibWVtb2l6ZWRQcm9wcyIsInBlbmRpbmdQcm9wcyIsImludGVybmFsQ29udGV4dFRhZyIsImxhc3RFZmZlY3QiLCJmaXJzdEVmZmVjdCIsIm5leHRFZmZlY3QiLCJleHBpcmF0aW9uVGltZSIsInNlIiwidGUiLCJ1ZSIsInZlIiwid2UiLCJoYW5kbGVyIiwieGUiLCJ5ZSIsInBlbmRpbmdDaGlsZHJlbiIsInplIiwiQWUiLCJCZSIsIkNlIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJpbmplY3QiLCJvbkNvbW1pdEZpYmVyUm9vdCIsIm9uQ29tbWl0RmliZXJVbm1vdW50IiwiRGUiLCJFZSIsIkZlIiwiYmFzZVN0YXRlIiwiZmlyc3QiLCJsYXN0IiwiY2FsbGJhY2tMaXN0IiwiaGFzRm9yY2VVcGRhdGUiLCJpc0luaXRpYWxpemVkIiwiR2UiLCJIZSIsIkllIiwiSmUiLCJpc1JlcGxhY2UiLCJpc0ZvcmNlZCIsIktlIiwiTGUiLCJuZXh0Q2FsbGJhY2siLCJhZG9wdENsYXNzSW5zdGFuY2UiLCJjb25zdHJ1Y3RDbGFzc0luc3RhbmNlIiwibW91bnRDbGFzc0luc3RhbmNlIiwic3RhdGUiLCJjb21wb25lbnRXaWxsTW91bnQiLCJjb21wb25lbnREaWRNb3VudCIsInVwZGF0ZUNsYXNzSW5zdGFuY2UiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50RGlkVXBkYXRlIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlFlIiwiUmUiLCJTZSIsIlRlIiwiVWUiLCJWZSIsIldlIiwiWGUiLCJZZSIsIlplIiwiX3N0cmluZ1JlZiIsIiRlIiwiYWYiLCJiZiIsImNmIiwiZGYiLCJwZW5kaW5nQ29udGV4dCIsInNob3VsZFNldFRleHRDb250ZW50IiwidXNlU3luY1NjaGVkdWxpbmciLCJzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlIiwicHVzaEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250YWluZXIiLCJlbnRlckh5ZHJhdGlvblN0YXRlIiwicmVzZXRIeWRyYXRpb25TdGF0ZSIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiT2IiLCJiZWdpbldvcmsiLCJoeWRyYXRlIiwiYmVnaW5GYWlsZWRXb3JrIiwiZWYiLCJjcmVhdGVJbnN0YW5jZSIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImFwcGVuZEluaXRpYWxDaGlsZCIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlcGFyZVVwZGF0ZSIsInBlcnNpc3RlbmNlIiwiZ2V0Um9vdEhvc3RDb250YWluZXIiLCJwb3BIb3N0Q29udGV4dCIsImdldEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInBvcEh5ZHJhdGlvblN0YXRlIiwibXV0YXRpb24iLCJjb21wbGV0ZVdvcmsiLCJmZiIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJjb21taXRNb3VudCIsImNvbW1pdFVwZGF0ZSIsInJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRUZXh0VXBkYXRlIiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImluc2VydEJlZm9yZSIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJjb21taXRSZXNldFRleHRDb250ZW50IiwiY29tbWl0UGxhY2VtZW50IiwiY29tbWl0RGVsZXRpb24iLCJjb21taXRXb3JrIiwiY29tbWl0TGlmZUN5Y2xlcyIsImNvbW1pdEF0dGFjaFJlZiIsImNvbW1pdERldGFjaFJlZiIsImdmIiwiaGYiLCJnZXRDaGlsZEhvc3RDb250ZXh0IiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwicmVzZXRIb3N0Q29udGFpbmVyIiwiamYiLCJoeWRyYXRpb24iLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJjYW5IeWRyYXRlVGV4dEluc3RhbmNlIiwiZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwia2YiLCJRYiIsImphIiwiaXNSZWFkeUZvckNvbW1pdCIsInlnIiwiemciLCJBZyIsIk5lIiwiT2UiLCJTYyIsIkJnIiwiVGMiLCJDZyIsIkRnIiwiRWciLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudFN0YWNrIiwiY2EiLCJRYyIsImhhIiwicWEiLCJGZyIsInJnIiwiR2ciLCJVYyIsInJhIiwiUmMiLCJlYiIsInFnIiwiYWRkIiwiX2RlYnVnT3duZXIiLCJfZGVidWdTb3VyY2UiLCJlcnJvckJvdW5kYXJ5IiwiZXJyb3JCb3VuZGFyeUZvdW5kIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJ3aWxsUmV0cnkiLCJzdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nIiwiVmMiLCJrYSIsIkhnIiwiUmIiLCJJZyIsIm5leHRTY2hlZHVsZWRSb290IiwicmVtYWluaW5nRXhwaXJhdGlvblRpbWUiLCJzYSIsIkZhIiwibGEiLCJTYiIsIm1hIiwibmEiLCJXYyIsIlBlIiwiVGIiLCJKZyIsIlhjIiwiS2ciLCJmYiIsIlljIiwiVWIiLCJaYyIsImZpbmlzaGVkV29yayIsInRpbWVSZW1haW5pbmciLCJMZyIsIk1lIiwic2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrIiwiY2FuY2VsRGVmZXJyZWRDYWxsYmFjayIsInByZXBhcmVGb3JDb21taXQiLCJyZXNldEFmdGVyQ29tbWl0IiwiY29tcHV0ZUFzeW5jRXhwaXJhdGlvbiIsImNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIiLCJzY2hlZHVsZVdvcmsiLCJiYXRjaGVkVXBkYXRlcyIsInVuYmF0Y2hlZFVwZGF0ZXMiLCJmbHVzaFN5bmMiLCJkZWZlcnJlZFVwZGF0ZXMiLCJsZiIsImNyZWF0ZUNvbnRhaW5lciIsInVwZGF0ZUNvbnRhaW5lciIsImdldFB1YmxpY1Jvb3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyIsImluamVjdEludG9EZXZUb29scyIsImZpbmRGaWJlckJ5SG9zdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIiLCJtZiIsIm5mIiwib2YiLCJwZiIsInFmIiwicGVyZm9ybWFuY2UiLCJyZiIsInNmIiwidGYiLCJyZXF1ZXN0SWRsZUNhbGxiYWNrIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwidWYiLCJ2ZiIsIndmIiwieGYiLCJ5ZiIsInpmIiwiQWYiLCJCZiIsImRpZFRpbWVvdXQiLCJDZiIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIkRmIiwicG9zdE1lc3NhZ2UiLCJJbmZpbml0eSIsIkVmIiwiRmYiLCJHZiIsIkhmIiwiSWYiLCJpc05hTiIsIkpmIiwic2V0QXR0cmlidXRlTlMiLCJLZiIsIkxmIiwibWluIiwibWF4IiwiaW5pdGlhbFZhbHVlIiwiaW5pdGlhbENoZWNrZWQiLCJNZiIsIk5mIiwiT2YiLCJwYXJzZUZsb2F0IiwiUGYiLCJRZiIsIlJmIiwiU2YiLCJvcHRpb25zIiwiZGVmYXVsdFNlbGVjdGVkIiwiVGYiLCJ3YXNNdWx0aXBsZSIsIlVmIiwiVmYiLCJXZiIsIlhmIiwiWWYiLCJodG1sIiwibWF0aG1sIiwic3ZnIiwiWmYiLCIkZiIsImFnIiwiYmciLCJNU0FwcCIsImV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uIiwibmFtZXNwYWNlVVJJIiwiY2ciLCJsYXN0Q2hpbGQiLCJub2RlVmFsdWUiLCJkZyIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiYm9yZGVySW1hZ2VPdXRzZXQiLCJib3JkZXJJbWFnZVNsaWNlIiwiYm9yZGVySW1hZ2VXaWR0aCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImNvbHVtbnMiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsImVnIiwiY2hhckF0IiwiZmciLCJ0cmltIiwic2V0UHJvcGVydHkiLCJnZyIsIm1lbnVpdGVtIiwiYXJlYSIsImJyIiwiY29sIiwiZW1iZWQiLCJociIsImltZyIsImlucHV0Iiwia2V5Z2VuIiwibGluayIsIm1ldGEiLCJwYXJhbSIsInRyYWNrIiwid2JyIiwiaGciLCJpZyIsImpnIiwia2ciLCJsZyIsIm1nIiwibmciLCJjcmVhdGVFbGVtZW50TlMiLCJvZyIsImNyZWF0ZVRleHROb2RlIiwicGciLCJfX2h0bWwiLCJvbkNsaWNrIiwib25jbGljayIsInNnIiwidGciLCJ1ZyIsInZnIiwid2ciLCJzZXRJbml0aWFsUHJvcGVydGllcyIsImRpZmZQcm9wZXJ0aWVzIiwidXBkYXRlUHJvcGVydGllcyIsImRpZmZIeWRyYXRlZFByb3BlcnRpZXMiLCJkaWZmSHlkcmF0ZWRUZXh0Iiwid2FybkZvclVubWF0Y2hlZFRleHQiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50Iiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCIsIkpTT04iLCJzdHJpbmdpZnkiLCJmb3JtIiwieGciLCJNZyIsIk5nIiwiT2ciLCJaIiwidGFnTmFtZSIsInJhbmdlQ291bnQiLCJmb2N1c2VkRWxlbSIsInNlbGVjdGlvblJhbmdlIiwiZXh0ZW5kIiwiY3JlYXRlUmFuZ2UiLCJzZXRTdGFydCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwic2V0RW5kIiwibGVmdCIsInNjcm9sbExlZnQiLCJ0b3AiLCJzY3JvbGxUb3AiLCJkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsIlBnIiwiX3JlYWN0Um9vdENvbnRhaW5lciIsIlFnIiwiUmciLCJ1bm1vdW50IiwiU2ciLCJjcmVhdGVQb3J0YWwiLCJmaW5kRE9NTm9kZSIsInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInVuc3RhYmxlX2NyZWF0ZVBvcnRhbCIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzIiwiRXZlbnRQbHVnaW5IdWIiLCJFdmVudFBsdWdpblJlZ2lzdHJ5IiwiRXZlbnRQcm9wYWdhdG9ycyIsIlJlYWN0Q29udHJvbGxlZENvbXBvbmVudCIsIlJlYWN0RE9NQ29tcG9uZW50VHJlZSIsIlJlYWN0RE9NRXZlbnRMaXN0ZW5lciIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwiVGciLCJVZyIsImlzTm9kZSIsIk5vZGUiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJjYW1lbGl6ZVN0eWxlTmFtZSIsImNoZWNrTWFzayIsImJpdG1hc2siLCJET01Qcm9wZXJ0eUluamVjdGlvbiIsImRvbVByb3BlcnR5Q29uZmlnIiwiSW5qZWN0aW9uIiwicHJvcGVydGllcyIsImxvd2VyQ2FzZWQiLCJwcm9wQ29uZmlnIiwicHJvcGVydHlJbmZvIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIkFUVFJJQlVURV9OQU1FX0NIQVIiLCJST09UX0FUVFJJQlVURV9OQU1FIiwic2hvdWxkU2V0QXR0cmlidXRlIiwiaXNSZXNlcnZlZFByb3AiLCJzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUiLCJnZXRQcm9wZXJ0eUluZm8iLCJIVE1MRE9NUHJvcGVydHlDb25maWciLCJIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSIsIk5TIiwiQVRUUlMiLCJTVkdET01Qcm9wZXJ0eUNvbmZpZyIsIkNBTUVMSVpFIiwiY2FwaXRhbGl6ZSIsInRva2VuIiwib3JpZ2luYWwiLCJyZWFjdE5hbWUiLCJSZWFjdEVycm9yVXRpbHMiLCJpbmplY3RlZEVycm9yVXRpbHMiLCJmdW5jQXJncyIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYiLCJkaWRFcnJvciIsImNhbGxDYWxsYmFjayIsImV2dFR5cGUiLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsIm9uRXJyb3IiLCJldmVudCIsImNvbG5vIiwibGluZW5vIiwiZXZ0IiwiaW5pdEV2ZW50IiwiZXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luTW9kdWxlIiwicGx1Z2luSW5kZXgiLCJwdWJsaXNoZWRFdmVudHMiLCJldmVudE5hbWUiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJwaGFzZU5hbWUiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lIiwicHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUiLCJsb3dlckNhc2VkTmFtZSIsIm9uZGJsY2xpY2siLCJpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RlZE5hbWVzVG9QbHVnaW5zIiwiaXNPcmRlcmluZ0RpcnR5IiwiaW5qZWN0aW9uJDIiLCJpbmplY3RDb21wb25lbnRUcmVlIiwiSW5qZWN0ZWQiLCJ2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyIsImRpc3BhdGNoTGlzdGVuZXJzIiwiZGlzcGF0Y2hJbnN0YW5jZXMiLCJsaXN0ZW5lcnNJc0FyciIsImxpc3RlbmVyc0xlbiIsImluc3RhbmNlc0lzQXJyIiwiaW5zdGFuY2VzTGVuIiwiZXhlY3V0ZURpc3BhdGNoIiwic2ltdWxhdGVkIiwibGlzdGVuZXIiLCJpbnN0IiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJhcnIiLCJzY29wZSIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImlzSW50ZXJhY3RpdmUiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImluamVjdGlvbiQxIiwibmF0aXZlRXZlbnRUYXJnZXQiLCJldmVudHMiLCJwb3NzaWJsZVBsdWdpbiIsImV4dHJhY3RlZEV2ZW50cyIsInByb2Nlc3NpbmdFdmVudFF1ZXVlIiwiSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkNhbGxDb21wb25lbnQiLCJDYWxsSGFuZGxlclBoYXNlIiwiUmV0dXJuQ29tcG9uZW50IiwicmFuZG9tS2V5IiwiaW50ZXJuYWxJbnN0YW5jZUtleSIsImludGVybmFsRXZlbnRIYW5kbGVyc0tleSIsInByZWNhY2hlRmliZXJOb2RlJDEiLCJob3N0SW5zdCIsInBhcmVudHMiLCJjbG9zZXN0IiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSQxIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSQxIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxIiwidXBkYXRlRmliZXJQcm9wcyQxIiwiZ2V0UGFyZW50IiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpbnN0QSIsImluc3RCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwiZ2V0UGFyZW50SW5zdGFuY2UiLCJ0cmF2ZXJzZVR3b1BoYXNlIiwiZm4iLCJ0cmF2ZXJzZUVudGVyTGVhdmUiLCJhcmdGcm9tIiwiYXJnVG8iLCJjb21tb24iLCJwYXRoRnJvbSIsInBhdGhUbyIsIl9hbHRlcm5hdGUiLCJfaSIsImxpc3RlbmVyQXRQaGFzZSIsInByb3BhZ2F0aW9uUGhhc2UiLCJhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzIiwicGhhc2UiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQiLCJwYXJlbnRJbnN0IiwiYWNjdW11bGF0ZURpc3BhdGNoZXMiLCJpZ25vcmVkRGlyZWN0aW9uIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUiLCJsZWF2ZSIsImVudGVyIiwiY29udGVudEtleSIsImdldFRleHRDb250ZW50QWNjZXNzb3IiLCJjb21wb3NpdGlvblN0YXRlIiwiaW5pdGlhbGl6ZSIsImdldFRleHQiLCJyZXNldCIsImdldERhdGEiLCJzdGFydFZhbHVlIiwic3RhcnRMZW5ndGgiLCJlbmRWYWx1ZSIsImVuZExlbmd0aCIsIm1pbkVuZCIsInNsaWNlVGFpbCIsImRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IiwiaXNQcm94eVN1cHBvcnRlZCIsIlByb3h5IiwiRVZFTlRfUE9PTF9TSVpFIiwic2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMiLCJFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0V2ZW50Iiwibm9ybWFsaXplIiwiZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbiIsIkNsYXNzIiwiU3VwZXIiLCJhZGRFdmVudFBvb2xpbmdUbyIsImNvbnN0cnVjdCIsInRoYXQiLCJnZXRWYWwiLCJpc0Z1bmN0aW9uIiwiYWN0aW9uIiwid2FybmluZ0NvbmRpdGlvbiIsImdldFBvb2xlZEV2ZW50IiwibmF0aXZlSW5zdCIsIkV2ZW50Q29uc3RydWN0b3IiLCJpbnN0YW5jZSIsInJlbGVhc2VQb29sZWRFdmVudCIsIlN5bnRoZXRpY0V2ZW50JDEiLCJDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljQ29tcG9zaXRpb25FdmVudCIsImRpc3BhdGNoTWFya2VyIiwiSW5wdXRFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0lucHV0RXZlbnQiLCJFTkRfS0VZQ09ERVMiLCJTVEFSVF9LRVlDT0RFIiwiY2FuVXNlQ29tcG9zaXRpb25FdmVudCIsImNhblVzZVRleHRJbnB1dEV2ZW50IiwiaXNQcmVzdG8iLCJ1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSIsIlNQQUNFQkFSX0NPREUiLCJTUEFDRUJBUl9DSEFSIiwiaGFzU3BhY2VLZXlwcmVzcyIsImlzS2V5cHJlc3NDb21tYW5kIiwiZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCIsImlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCIsImdldERhdGFGcm9tQ3VzdG9tRXZlbnQiLCJpc0NvbXBvc2luZyIsImV4dHJhY3RDb21wb3NpdGlvbkV2ZW50IiwiZmFsbGJhY2tEYXRhIiwiY3VzdG9tRGF0YSIsImdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnMiLCJjaGFycyIsImdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyIsImV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50IiwiZmliZXJIb3N0Q29tcG9uZW50IiwiUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uIiwiaG9zdENvbXBvbmVudEltcGwiLCJyZXN0b3JlVGFyZ2V0IiwicmVzdG9yZVF1ZXVlIiwicmVzdG9yZVN0YXRlT2ZUYXJnZXQiLCJpbnRlcm5hbEluc3RhbmNlIiwiaW5qZWN0aW9uJDMiLCJxdWV1ZWRUYXJnZXRzIiwiZmliZXJCYXRjaGVkVXBkYXRlcyIsImJvb2trZWVwaW5nIiwiaXNOZXN0aW5nQmF0Y2hlZCIsIlJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uIiwiaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyIsIl9iYXRjaGVkVXBkYXRlcyIsImluamVjdGlvbiQ0Iiwic3VwcG9ydGVkSW5wdXRUeXBlcyIsImlzVGV4dElucHV0RWxlbWVudCIsImVsZW0iLCJFTEVNRU5UX05PREUiLCJURVhUX05PREUiLCJDT01NRU5UX05PREUiLCJET0NVTUVOVF9OT0RFIiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsImdldEV2ZW50VGFyZ2V0IiwidXNlSGFzRmVhdHVyZSIsImlzRXZlbnRTdXBwb3J0ZWQiLCJldmVudE5hbWVTdWZmaXgiLCJpc1N1cHBvcnRlZCIsImlzQ2hlY2thYmxlIiwiZ2V0VHJhY2tlciIsImRldGFjaFRyYWNrZXIiLCJnZXRWYWx1ZUZyb21Ob2RlIiwidHJhY2tWYWx1ZU9uTm9kZSIsInZhbHVlRmllbGQiLCJkZXNjcmlwdG9yIiwiY3VycmVudFZhbHVlIiwidHJhY2tlciIsInVwZGF0ZVZhbHVlSWZDaGFuZ2VkIiwibGFzdFZhbHVlIiwibmV4dFZhbHVlIiwiZXZlbnRUeXBlcyQxIiwiY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50IiwiYWN0aXZlRWxlbWVudEluc3QiLCJzaG91bGRVc2VDaGFuZ2VFdmVudCIsIm1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQiLCJydW5FdmVudEluQmF0Y2giLCJnZXRJbnN0SWZWYWx1ZUNoYW5nZWQiLCJ0YXJnZXROb2RlIiwiZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50IiwiaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwic3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiaGFuZGxlUHJvcGVydHlDaGFuZ2UiLCJzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsImhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCIsImdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwiLCJzaG91bGRVc2VDbGlja0V2ZW50IiwiZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50IiwiaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1ciIsImdldFRhcmdldEluc3RGdW5jIiwiaGFuZGxlRXZlbnRGdW5jIiwiRE9NRXZlbnRQbHVnaW5PcmRlciIsIlVJRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNVSUV2ZW50IiwibW9kaWZpZXJLZXlUb1Byb3AiLCJtb2RpZmllclN0YXRlR2V0dGVyIiwia2V5QXJnIiwic3ludGhldGljRXZlbnQiLCJrZXlQcm9wIiwiZ2V0RXZlbnRNb2RpZmllclN0YXRlIiwiTW91c2VFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJldmVudFR5cGVzJDIiLCJ3aW4iLCJyZWxhdGVkIiwiZnJvbU5vZGUiLCJ0b05vZGUiLCJSZWFjdEludGVybmFscyIsIk5vRWZmZWN0IiwiUGVyZm9ybWVkV29yayIsIlBsYWNlbWVudCIsIlVwZGF0ZSIsIlBsYWNlbWVudEFuZFVwZGF0ZSIsIkRlbGV0aW9uIiwiQ29udGVudFJlc2V0IiwiQ2FsbGJhY2siLCJFcnIiLCJSZWYiLCJNT1VOVElORyIsIk1PVU5URUQiLCJVTk1PVU5URUQiLCJpc0ZpYmVyTW91bnRlZEltcGwiLCJpc0ZpYmVyTW91bnRlZCIsIm93bmVyRmliZXIiLCJfd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJhc3NlcnRJc01vdW50ZWQiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsInBhcmVudEEiLCJwYXJlbnRCIiwiZGlkRmluZENoaWxkIiwiX2NoaWxkIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJwYXJlbnQiLCJjdXJyZW50UGFyZW50IiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFIiwiY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wiLCJmaW5kUm9vdENvbnRhaW5lck5vZGUiLCJnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJyZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiaGFuZGxlVG9wTGV2ZWxJbXBsIiwiYW5jZXN0b3IiLCJyb290IiwiaGFuZGxlVG9wTGV2ZWwiLCJlbmFibGVkIiwiaGFuZGxlckJhc2VOYW1lIiwibWFrZVByZWZpeE1hcCIsInN0eWxlUHJvcCIsInByZWZpeGVzIiwidmVuZG9yUHJlZml4ZXMiLCJwcmVmaXhlZEV2ZW50TmFtZXMiLCJnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSIsInByZWZpeE1hcCIsInRvcExldmVsVHlwZXMkMSIsIkJyb3dzZXJFdmVudENvbnN0YW50cyIsInRvcExldmVsVHlwZXMiLCJydW5FdmVudFF1ZXVlSW5CYXRjaCIsImFscmVhZHlMaXN0ZW5pbmdUbyIsInJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciIsInRvcExpc3RlbmVyc0lES2V5IiwiZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQiLCJtb3VudEF0IiwibGlzdGVuVG8iLCJjb250ZW50RG9jdW1lbnRIYW5kbGUiLCJpc0xpc3RlbmluZyIsImRlcGVuZGVuY3kiLCJpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzIiwiZ2V0TGVhZk5vZGUiLCJnZXRTaWJsaW5nTm9kZSIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJub2RlU3RhcnQiLCJub2RlRW5kIiwiZ2V0T2Zmc2V0cyIsInNlbGVjdGlvbiIsImZvY3VzTm9kZSQkMSIsImdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzIiwiaW5kZXhXaXRoaW5BbmNob3IiLCJpbmRleFdpdGhpbkZvY3VzIiwib3V0ZXIiLCJzZXRPZmZzZXRzIiwib2Zmc2V0cyIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsImlzSW5Eb2N1bWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImdldFNlbGVjdGlvbkluZm9ybWF0aW9uIiwiZ2V0U2VsZWN0aW9uJDEiLCJyZXN0b3JlU2VsZWN0aW9uIiwicHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbiIsImN1ckZvY3VzZWRFbGVtIiwicHJpb3JGb2N1c2VkRWxlbSIsInByaW9yU2VsZWN0aW9uUmFuZ2UiLCJzZXRTZWxlY3Rpb24iLCJza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQiLCJldmVudFR5cGVzJDMiLCJhY3RpdmVFbGVtZW50JDEiLCJhY3RpdmVFbGVtZW50SW5zdCQxIiwibGFzdFNlbGVjdGlvbiIsIm1vdXNlRG93biIsImNvbnN0cnVjdFNlbGVjdEV2ZW50IiwiY3VycmVudFNlbGVjdGlvbiIsIkFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljQW5pbWF0aW9uRXZlbnQiLCJDbGlwYm9hcmRFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0NsaXBib2FyZEV2ZW50IiwiRm9jdXNFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0ZvY3VzRXZlbnQiLCJnZXRFdmVudENoYXJDb2RlIiwibm9ybWFsaXplS2V5IiwidHJhbnNsYXRlVG9LZXkiLCJnZXRFdmVudEtleSIsIktleWJvYXJkRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNLZXlib2FyZEV2ZW50IiwiRHJhZ0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRHJhZ0V2ZW50IiwiVG91Y2hFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1RvdWNoRXZlbnQiLCJUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQiLCJXaGVlbEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljV2hlZWxFdmVudCIsImV2ZW50VHlwZXMkNCIsInRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyIsImNhcGl0YWxpemVkRXZlbnQiLCJvbkV2ZW50IiwidG9wRXZlbnQiLCJrbm93bkhUTUxUb3BMZXZlbFR5cGVzIiwiZW5hYmxlQXN5bmNTdWJ0cmVlQVBJIiwiZW5hYmxlQXN5bmNTY2hlZHVsaW5nQnlEZWZhdWx0SW5SZWFjdERPTSIsImVuYWJsZUNyZWF0ZVJvb3QiLCJlbmFibGVVc2VyVGltaW5nQVBJIiwiZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyIiwiZW5hYmxlTm9vcFJlY29uY2lsZXIiLCJlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciIsImRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cyIsInZhbHVlU3RhY2siLCJmaWJlclN0YWNrIiwiY3JlYXRlQ3Vyc29yIiwicmVzZXQkMSIsImRlc2NyaWJlRmliZXIiLCJnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyIiwid29ya0luUHJvZ3Jlc3MiLCJnZXRDdXJyZW50RmliZXJPd25lck5hbWUiLCJSZWFjdERlYnVnQ3VycmVudEZpYmVyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSIsInJlc2V0Q3VycmVudEZpYmVyIiwic2V0Q3VycmVudEZpYmVyIiwic2V0Q3VycmVudFBoYXNlIiwicmVhY3RFbW9qaSIsIndhcm5pbmdFbW9qaSIsInN1cHBvcnRzVXNlclRpbWluZyIsIm1hcmsiLCJjbGVhck1hcmtzIiwibWVhc3VyZSIsImNsZWFyTWVhc3VyZXMiLCJjdXJyZW50RmliZXIiLCJjdXJyZW50UGhhc2UiLCJjdXJyZW50UGhhc2VGaWJlciIsImlzQ29tbWl0dGluZyIsImhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCIsImhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlIiwiY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCIsImVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0IiwiaXNXYWl0aW5nRm9yQ2FsbGJhY2siLCJsYWJlbHNJbkN1cnJlbnRDb21taXQiLCJmb3JtYXRNYXJrTmFtZSIsIm1hcmtOYW1lIiwiZm9ybWF0TGFiZWwiLCJsYWJlbCIsIndhcm5pbmckJDEiLCJzdWZmaXgiLCJiZWdpbk1hcmsiLCJjbGVhck1hcmsiLCJlbmRNYXJrIiwiZm9ybWF0dGVkTWFya05hbWUiLCJmb3JtYXR0ZWRMYWJlbCIsImdldEZpYmVyTWFya05hbWUiLCJkZWJ1Z0lEIiwiZ2V0RmliZXJMYWJlbCIsImJlZ2luRmliZXJNYXJrIiwiX2RlYnVnSUQiLCJjbGVhckZpYmVyTWFyayIsImVuZEZpYmVyTWFyayIsInNob3VsZElnbm9yZUZpYmVyIiwiY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCIsInBhdXNlVGltZXJzIiwiX2RlYnVnSXNDdXJyZW50bHlUaW1pbmciLCJyZXN1bWVUaW1lcnNSZWN1cnNpdmVseSIsInJlc3VtZVRpbWVycyIsInJlY29yZEVmZmVjdCIsInJlY29yZFNjaGVkdWxlVXBkYXRlIiwic3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lciIsInN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lciIsImRpZEV4cGlyZSIsInN0YXJ0V29ya1RpbWVyIiwiY2FuY2VsV29ya1RpbWVyIiwic3RvcFdvcmtUaW1lciIsInN0b3BGYWlsZWRXb3JrVGltZXIiLCJzdGFydFBoYXNlVGltZXIiLCJzdG9wUGhhc2VUaW1lciIsInN0YXJ0V29ya0xvb3BUaW1lciIsIm5leHRVbml0T2ZXb3JrIiwic3RvcFdvcmtMb29wVGltZXIiLCJpbnRlcnJ1cHRlZEJ5Iiwic3RhcnRDb21taXRUaW1lciIsImNsZWFyIiwic3RvcENvbW1pdFRpbWVyIiwic3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyIiwic3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIiLCJzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lciIsInN0b3BDb21taXRMaWZlQ3ljbGVzVGltZXIiLCJ3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHQiLCJjb250ZXh0U3RhY2tDdXJzb3IiLCJkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yIiwicHJldmlvdXNDb250ZXh0IiwiZ2V0VW5tYXNrZWRDb250ZXh0IiwiaGFzT3duQ29udGV4dCIsImlzQ29udGV4dFByb3ZpZGVyIiwiY2FjaGVDb250ZXh0IiwidW5tYXNrZWRDb250ZXh0IiwibWFza2VkQ29udGV4dCIsImdldE1hc2tlZENvbnRleHQiLCJoYXNDb250ZXh0Q2hhbmdlZCIsImlzQ29udGV4dENvbnN1bWVyIiwicG9wQ29udGV4dFByb3ZpZGVyIiwicG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwicHVzaFRvcExldmVsQ29udGV4dE9iamVjdCIsImRpZENoYW5nZSIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiY2hpbGRDb250ZXh0IiwiY29udGV4dEtleSIsInB1c2hDb250ZXh0UHJvdmlkZXIiLCJtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsImludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIiLCJtZXJnZWRDb250ZXh0IiwicmVzZXRDb250ZXh0IiwiZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQiLCJOb1dvcmsiLCJTeW5jIiwiTmV2ZXIiLCJVTklUX1NJWkUiLCJNQUdJQ19OVU1CRVJfT0ZGU0VUIiwibXNUb0V4cGlyYXRpb25UaW1lIiwibXMiLCJleHBpcmF0aW9uVGltZVRvTXMiLCJjZWlsaW5nIiwibnVtIiwicHJlY2lzaW9uIiwiY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQiLCJjdXJyZW50VGltZSIsImV4cGlyYXRpb25Jbk1zIiwiYnVja2V0U2l6ZU1zIiwiTm9Db250ZXh0IiwiQXN5bmNVcGRhdGVzIiwiaGFzQmFkTWFwUG9seWZpbGwiLCJub25FeHRlbnNpYmxlT2JqZWN0IiwicHJldmVudEV4dGVuc2lvbnMiLCJkZWJ1Z0NvdW50ZXIiLCJGaWJlck5vZGUiLCJjcmVhdGVGaWJlciIsInNob3VsZENvbnN0cnVjdCIsImNyZWF0ZVdvcmtJblByb2dyZXNzIiwiY3JlYXRlSG9zdFJvb3RGaWJlciIsImNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImVsZW1lbnRzIiwiY3JlYXRlRmliZXJGcm9tVGV4dCIsImNvbnRlbnQiLCJjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbiIsImNyZWF0ZUZpYmVyRnJvbUNhbGwiLCJjcmVhdGVGaWJlckZyb21SZXR1cm4iLCJyZXR1cm5Ob2RlIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwicG9ydGFsIiwiY3JlYXRlRmliZXJSb290IiwidW5pbml0aWFsaXplZEZpYmVyIiwiaGFzTG9nZ2VkRXJyb3IiLCJjYXRjaEVycm9ycyIsImluamVjdEludGVybmFscyIsImludGVybmFscyIsImhvb2siLCJyZW5kZXJlcklEIiwib25Db21taXRSb290Iiwib25Db21taXRVbm1vdW50IiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImNyZWF0ZVVwZGF0ZVF1ZXVlIiwiaXNQcm9jZXNzaW5nIiwiaW5zZXJ0VXBkYXRlSW50b1F1ZXVlIiwidXBkYXRlIiwiaW5zZXJ0VXBkYXRlSW50b0ZpYmVyIiwiYWx0ZXJuYXRlRmliZXIiLCJxdWV1ZTEiLCJxdWV1ZTIiLCJnZXRVcGRhdGVFeHBpcmF0aW9uVGltZSIsImdldFN0YXRlRnJvbVVwZGF0ZSIsInByZXZTdGF0ZSIsInVwZGF0ZUZuIiwicHJvY2Vzc1VwZGF0ZVF1ZXVlIiwicmVuZGVyRXhwaXJhdGlvblRpbWUiLCJkb250TXV0YXRlUHJldlN0YXRlIiwiZGlkU2tpcCIsInVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiX3BhcnRpYWxTdGF0ZSIsIl9jYWxsYmFja0xpc3QiLCJjb21taXRDYWxsYmFja3MiLCJfY2FsbGJhY2siLCJmYWtlSW50ZXJuYWxJbnN0YW5jZSIsImRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCIsIndhcm5PbkludmFsaWRDYWxsYmFjayIsIlJlYWN0RmliZXJDbGFzc0NvbXBvbmVudCIsIm1lbW9pemVQcm9wcyIsIm1lbW9pemVTdGF0ZSIsImNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlIiwib2xkUHJvcHMiLCJuZXdQcm9wcyIsIm9sZFN0YXRlIiwibmV3U3RhdGUiLCJuZXdDb250ZXh0Iiwic2hvdWxkVXBkYXRlIiwiY2hlY2tDbGFzc0luc3RhbmNlIiwicmVuZGVyUHJlc2VudCIsIm5vR2V0SW5pdGlhbFN0YXRlT25FUzYiLCJnZXRJbml0aWFsU3RhdGUiLCJub0dldERlZmF1bHRQcm9wc09uRVM2Iiwibm9JbnN0YW5jZVByb3BUeXBlcyIsIm5vSW5zdGFuY2VDb250ZXh0VHlwZXMiLCJub0NvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsIm5vQ29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFVubW91bnQiLCJub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsIm5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJoYXNNdXRhdGVkUHJvcHMiLCJub0luc3RhbmNlRGVmYXVsdFByb3BzIiwicmVzZXRJbnB1dFBvaW50ZXJzIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImN0b3IiLCJuZWVkc0NvbnRleHQiLCJjYWxsQ29tcG9uZW50V2lsbE1vdW50IiwiY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJvbGRDb250ZXh0IiwibmV3VW5tYXNrZWRDb250ZXh0IiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxIiwib3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nIiwid2FybkZvck1pc3NpbmdLZXkiLCJpc0FycmF5JDEiLCJjb2VyY2VSZWYiLCJtaXhlZFJlZiIsInN0cmluZ1JlZiIsInRocm93T25JbnZhbGlkT2JqZWN0VHlwZSIsInJldHVybkZpYmVyIiwibmV3Q2hpbGQiLCJ3YXJuT25GdW5jdGlvblR5cGUiLCJDaGlsZFJlY29uY2lsZXIiLCJzaG91bGRUcmFja1NpZGVFZmZlY3RzIiwiZGVsZXRlQ2hpbGQiLCJjaGlsZFRvRGVsZXRlIiwiZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4iLCJjdXJyZW50Rmlyc3RDaGlsZCIsIm1hcFJlbWFpbmluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGQiLCJ1c2VGaWJlciIsImNsb25lIiwicGxhY2VDaGlsZCIsIm5ld0ZpYmVyIiwibGFzdFBsYWNlZEluZGV4IiwibmV3SW5kZXgiLCJvbGRJbmRleCIsInBsYWNlU2luZ2xlQ2hpbGQiLCJ1cGRhdGVUZXh0Tm9kZSIsImNyZWF0ZWQiLCJleGlzdGluZyIsInVwZGF0ZUVsZW1lbnQiLCJ1cGRhdGVDYWxsIiwidXBkYXRlUmV0dXJuIiwidXBkYXRlUG9ydGFsIiwidXBkYXRlRnJhZ21lbnQiLCJjcmVhdGVDaGlsZCIsIl9jcmVhdGVkIiwiX2NyZWF0ZWQyIiwiX2NyZWF0ZWQzIiwiX2NyZWF0ZWQ0IiwiX2NyZWF0ZWQ1IiwiX2NyZWF0ZWQ2IiwidXBkYXRlU2xvdCIsIm9sZEZpYmVyIiwidXBkYXRlRnJvbU1hcCIsIm5ld0lkeCIsIm1hdGNoZWRGaWJlciIsIl9tYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyMiIsIl9tYXRjaGVkRmliZXIzIiwiX21hdGNoZWRGaWJlcjQiLCJfbWF0Y2hlZEZpYmVyNSIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsIl9uZXdGaWJlciIsIl9uZXdGaWJlcjIiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yIiwibmV3Q2hpbGRyZW5JdGVyYWJsZSIsInBvc3NpYmxlTWFwIiwiX25ld0NoaWxkcmVuIiwiX25ld0ZpYmVyMyIsIl9uZXdGaWJlcjQiLCJyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZSIsInJlY29uY2lsZVNpbmdsZUVsZW1lbnQiLCJfY3JlYXRlZDciLCJyZWNvbmNpbGVTaW5nbGVDYWxsIiwicmVjb25jaWxlU2luZ2xlUmV0dXJuIiwicmVjb25jaWxlU2luZ2xlUG9ydGFsIiwicmVjb25jaWxlQ2hpbGRGaWJlcnMiLCJpc09iamVjdCIsIl9pc01vY2tGdW5jdGlvbiIsIm1vdW50Q2hpbGRGaWJlcnMiLCJjbG9uZUNoaWxkRmliZXJzIiwiY3VycmVudENoaWxkIiwid2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzIiwiUmVhY3RGaWJlckJlZ2luV29yayIsImhvc3RDb250ZXh0IiwiaHlkcmF0aW9uQ29udGV4dCIsIl9SZWFjdEZpYmVyQ2xhc3NDb21wbyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwicmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsIm1hcmtSZWYiLCJ1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibmV4dFByb3BzIiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJoYXNDb250ZXh0IiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJwdXNoSG9zdFJvb3RDb250ZXh0IiwidXBkYXRlSG9zdFJvb3QiLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwicHJldlByb3BzIiwiaXNEaXJlY3RUZXh0Q2hpbGQiLCJ1cGRhdGVIb3N0VGV4dCIsIm1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsImRlYnVnU291cmNlIiwidXBkYXRlQ2FsbENvbXBvbmVudCIsIm5leHRDYWxsIiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiYmFpbG91dE9uTG93UHJpb3JpdHkiLCJuZXh0U3RhdGUiLCJSZWFjdEZpYmVyQ29tcGxldGVXb3JrIiwibWFya1VwZGF0ZSIsImFwcGVuZEFsbFJldHVybnMiLCJyZXR1cm5zIiwibW92ZUNhbGxUb0hhbmRsZXJQaGFzZSIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZVBheWxvYWQiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJvbGRUZXh0IiwibmV3VGV4dCIsImNsb25lSW5zdGFuY2UiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJwb3J0YWxPclJvb3QiLCJjaGlsZHJlblVuY2hhbmdlZCIsImNvbnRhaW5lciIsIm5ld0NoaWxkU2V0IiwiY3VycmVudEluc3RhbmNlIiwicmVjeWNsYWJsZUluc3RhbmNlIiwibmV3SW5zdGFuY2UiLCJjdXJyZW50SG9zdENvbnRleHQiLCJmaWJlclJvb3QiLCJfY3VycmVudEhvc3RDb250ZXh0Iiwid2FzSHlkcmF0ZWQiLCJfaW5zdGFuY2UiLCJfcm9vdENvbnRhaW5lckluc3RhbmNlIiwiX2N1cnJlbnRIb3N0Q29udGV4dDIiLCJfd2FzSHlkcmF0ZWQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiIsImhhc0NhdWdodEVycm9yJDEiLCJjbGVhckNhdWdodEVycm9yJDEiLCJSZWFjdEZpYmVyQ29tbWl0V29yayIsImNhcHR1cmVFcnJvciIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsInVubW91bnRFcnJvciIsInNhZmVseURldGFjaFJlZiIsInJlZkVycm9yIiwiX3VwZGF0ZVF1ZXVlIiwiX2luc3RhbmNlMiIsImN1cnJlbnRSZWYiLCJjb21taXRVbm1vdW50IiwiY29tbWl0TmVzdGVkVW5tb3VudHMiLCJ1bm1vdW50SG9zdENvbXBvbmVudHMiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImRldGFjaEZpYmVyIiwiY29tbWl0Q29udGFpbmVyIiwicmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuIiwiZW1wdHlDaGlsZFNldCIsIl9wZW5kaW5nQ2hpbGRyZW4iLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsInNpYmxpbmdzIiwicGFyZW50RmliZXIiLCJpc0NvbnRhaW5lciIsImJlZm9yZSIsImN1cnJlbnRQYXJlbnRJc1ZhbGlkIiwiY3VycmVudFBhcmVudElzQ29udGFpbmVyIiwiZmluZFBhcmVudCIsInRleHRJbnN0YW5jZSIsIk5PX0NPTlRFWFQiLCJSZWFjdEZpYmVySG9zdENvbnRleHQiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsInJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yIiwicmVxdWlyZWRDb250ZXh0Iiwicm9vdEluc3RhbmNlIiwibmV4dFJvb3RJbnN0YW5jZSIsIm5leHRSb290Q29udGV4dCIsIm5leHRDb250ZXh0IiwiUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQiLCJoeWRyYXRpb25QYXJlbnRGaWJlciIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJpc0h5ZHJhdGluZyIsInBhcmVudEluc3RhbmNlIiwiZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZSIsInBhcmVudENvbnRhaW5lciIsInBhcmVudFByb3BzIiwiX3R5cGUiLCJfcHJvcHMiLCJfdGV4dCIsInRyeUh5ZHJhdGUiLCJuZXh0SW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiIsImRlYnVnVG9vbCIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSIsImRlZmF1bHRTaG93RGlhbG9nIiwiY2FwdHVyZWRFcnJvciIsInNob3dEaWFsb2ciLCJsb2dDYXB0dXJlZEVycm9yIiwibG9nRXJyb3IiLCJzdXBwcmVzc0xvZ2dpbmciLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tYmluZWRNZXNzYWdlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrJDEiLCJkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24iLCJkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQiLCJ3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCIsIndhcm5BYm91dEludmFsaWRVcGRhdGVzIiwiUmVhY3RGaWJlclNjaGVkdWxlciIsIl9SZWFjdEZpYmVyQmVnaW5Xb3JrIiwiX1JlYWN0RmliZXJDb21wbGV0ZVdvIiwiX1JlYWN0RmliZXJDb21taXRXb3JrIiwic3RhcnRUaW1lIiwibW9zdFJlY2VudEN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkNvbnRleHQiLCJpc1dvcmtpbmciLCJuZXh0Um9vdCIsIm5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSIsImNhcHR1cmVkRXJyb3JzIiwiZmFpbGVkQm91bmRhcmllcyIsImNvbW1pdFBoYXNlQm91bmRhcmllcyIsImZpcnN0VW5jYXVnaHRFcnJvciIsImRpZEZhdGFsIiwiaXNVbm1vdW50aW5nIiwicmVzZXRDb250ZXh0U3RhY2siLCJjb21taXRBbGxIb3N0RWZmZWN0cyIsInByaW1hcnlFZmZlY3RUYWciLCJfY3VycmVudCIsIl9jdXJyZW50MiIsImNvbW1pdEFsbExpZmVDeWNsZXMiLCJjb21taXRFcnJvckhhbmRsaW5nIiwiY29tbWl0Um9vdCIsIl9lcnJvciIsIl9kaWRFcnJvciIsIl9lcnJvcjIiLCJvbkNvbW1pdFdvcmsiLCJzY2hlZHVsZUVycm9yUmVjb3ZlcnkiLCJfZXJyb3IzIiwib25VbmNhdWdodEVycm9yIiwicmVtYWluaW5nVGltZSIsInJlc2V0RXhwaXJhdGlvblRpbWUiLCJyZW5kZXJUaW1lIiwibmV3RXhwaXJhdGlvblRpbWUiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJzaWJsaW5nRmliZXIiLCJvbkNvbXBsZXRlV29yayIsInBlcmZvcm1Vbml0T2ZXb3JrIiwib25CZWdpbldvcmsiLCJwZXJmb3JtRmFpbGVkVW5pdE9mV29yayIsIndvcmtMb29wIiwic2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsiLCJzaG91bGRZaWVsZCIsImhhc0NhcHR1cmVkRXJyb3IiLCJyZW5kZXJSb290Q2F0Y2hCbG9jayIsImZhaWxlZFdvcmsiLCJib3VuZGFyeSIsInVud2luZENvbnRleHRzIiwicmVuZGVyUm9vdCIsInVuY2F1Z2h0RXJyb3IiLCJpc0ZhaWxlZEJvdW5kYXJ5IiwiX2NvbXBvbmVudFN0YWNrIiwiX2NvbXBvbmVudE5hbWUiLCJlZmZlY3RmdWxGaWJlciIsInJlY2FsY3VsYXRlQ3VycmVudFRpbWUiLCJleHBpcmF0aW9uTXMiLCJzY2hlZHVsZVdvcmtJbXBsIiwiY2hlY2tSb290TmVlZHNDbGVhcmluZyIsImlzRXJyb3JSZWNvdmVyeSIsInJlcXVlc3RXb3JrIiwicHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCIsInN5bmNVcGRhdGVzIiwiZmlyc3RTY2hlZHVsZWRSb290IiwibGFzdFNjaGVkdWxlZFJvb3QiLCJjYWxsYmFja0V4cGlyYXRpb25UaW1lIiwiY2FsbGJhY2tJRCIsImlzUmVuZGVyaW5nIiwibmV4dEZsdXNoZWRSb290IiwibmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSIsImRlYWRsaW5lRGlkRXhwaXJlIiwiaGFzVW5oYW5kbGVkRXJyb3IiLCJ1bmhhbmRsZWRFcnJvciIsImRlYWRsaW5lIiwiaXNCYXRjaGluZ1VwZGF0ZXMiLCJpc1VuYmF0Y2hpbmdVcGRhdGVzIiwiTkVTVEVEX1VQREFURV9MSU1JVCIsIm5lc3RlZFVwZGF0ZUNvdW50IiwidGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsiLCJzY2hlZHVsZUNhbGxiYWNrV2l0aEV4cGlyYXRpb24iLCJjdXJyZW50TXMiLCJwZXJmb3JtQXN5bmNXb3JrIiwicGVyZm9ybVdvcmtPblJvb3QiLCJwZXJmb3JtV29yayIsImZpbmRIaWdoZXN0UHJpb3JpdHlSb290IiwiaGlnaGVzdFByaW9yaXR5V29yayIsImhpZ2hlc3RQcmlvcml0eVJvb3QiLCJwcmV2aW91c1NjaGVkdWxlZFJvb3QiLCJwcmV2aW91c0ZsdXNoZWRSb290IiwiZGwiLCJtaW5FeHBpcmF0aW9uVGltZSIsIl9lcnJvcjQiLCJfZmluaXNoZWRXb3JrIiwicHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyIsImRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDEiLCJfUmVhY3RGaWJlclNjaGVkdWxlciIsInNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUiLCJob3N0RmliZXIiLCJvbk1vdW50Q29udGFpbmVyIiwib25Vbm1vdW50Q29udGFpbmVyIiwib25VcGRhdGVDb250YWluZXIiLCJjb250YWluZXJGaWJlciIsImRldlRvb2xzQ29uZmlnIiwiUmVhY3RGaWJlclJlY29uY2lsZXIkMiIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDMiLCJyZWFjdFJlY29uY2lsZXIiLCJjcmVhdGVQb3J0YWwkMSIsImhhc05hdGl2ZVBlcmZvcm1hbmNlTm93IiwicklDIiwiY0lDIiwiZnJhbWVDYWxsYmFjayIsInRpbWVvdXRJRCIsInNjaGVkdWxlZFJJQ0NhbGxiYWNrIiwiaXNJZGxlU2NoZWR1bGVkIiwidGltZW91dFRpbWUiLCJpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkIiwiZnJhbWVEZWFkbGluZSIsInByZXZpb3VzRnJhbWVUaW1lIiwiYWN0aXZlRnJhbWVUaW1lIiwiZnJhbWVEZWFkbGluZU9iamVjdCIsInJlbWFpbmluZyIsIm1lc3NhZ2VLZXkiLCJpZGxlVGljayIsImFuaW1hdGlvblRpY2siLCJyYWZUaW1lIiwibmV4dEZyYW1lVGltZSIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiUmVnRXhwIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJzaG91bGRJZ25vcmVWYWx1ZSIsImdldFZhbHVlRm9yUHJvcGVydHkiLCJleHBlY3RlZCIsInN0cmluZ1ZhbHVlIiwiZ2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5IiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm5hbWVzcGFjZSIsInNldFZhbHVlRm9yQXR0cmlidXRlIiwiZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUiLCJSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyIsImhhc1JlYWRPbmx5VmFsdWUiLCJjaGVja2JveCIsImltYWdlIiwicmFkaW8iLCJzdWJtaXQiLCJvbkNoYW5nZSIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiaXNDb250cm9sbGVkIiwidXNlc0NoZWNrZWQiLCJnZXRIb3N0UHJvcHMiLCJob3N0UHJvcHMiLCJpbml0V3JhcHBlclN0YXRlIiwidXBkYXRlQ2hlY2tlZCIsInVwZGF0ZVdyYXBwZXIiLCJ2YWx1ZUFzTnVtYmVyIiwicG9zdE1vdW50V3JhcHBlciIsInJlc3RvcmVDb250cm9sbGVkU3RhdGUkMSIsInVwZGF0ZU5hbWVkQ291c2lucyIsInJvb3ROb2RlIiwicXVlcnlSb290IiwiZ3JvdXAiLCJvdGhlck5vZGUiLCJvdGhlclByb3BzIiwiZmxhdHRlbkNoaWxkcmVuIiwidmFsaWRhdGVQcm9wcyIsInBvc3RNb3VudFdyYXBwZXIkMSIsImdldEhvc3RQcm9wcyQxIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDMiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQiLCJkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSIsInZhbHVlUHJvcE5hbWVzIiwiY2hlY2tTZWxlY3RQcm9wVHlwZXMiLCJ1cGRhdGVPcHRpb25zIiwicHJvcFZhbHVlIiwic2V0RGVmYXVsdFNlbGVjdGVkIiwic2VsZWN0ZWRWYWx1ZXMiLCJzZWxlY3RlZFZhbHVlIiwiX3NlbGVjdGVkVmFsdWUiLCJfaTIiLCJnZXRIb3N0UHJvcHMkMiIsImluaXRXcmFwcGVyU3RhdGUkMSIsInBvc3RNb3VudFdyYXBwZXIkMiIsInBvc3RVcGRhdGVXcmFwcGVyIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1IiwiZGlkV2FyblZhbERlZmF1bHRWYWwiLCJnZXRIb3N0UHJvcHMkMyIsImluaXRXcmFwcGVyU3RhdGUkMiIsInVwZGF0ZVdyYXBwZXIkMSIsIm5ld1ZhbHVlIiwicG9zdE1vdW50V3JhcHBlciQzIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzIiwiSFRNTF9OQU1FU1BBQ0UkMSIsIk1BVEhfTkFNRVNQQUNFIiwiU1ZHX05BTUVTUEFDRSIsIk5hbWVzcGFjZXMiLCJnZXRJbnRyaW5zaWNOYW1lc3BhY2UiLCJnZXRDaGlsZE5hbWVzcGFjZSIsInBhcmVudE5hbWVzcGFjZSIsImNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24iLCJhcmcwIiwiYXJnMSIsImFyZzIiLCJhcmczIiwicmV1c2FibGVTVkdDb250YWluZXIiLCJzZXRJbm5lckhUTUwiLCJzdmdOb2RlIiwic2V0VGV4dENvbnRlbnQiLCJpc1VuaXRsZXNzTnVtYmVyIiwicHJlZml4S2V5IiwiZGFuZ2Vyb3VzU3R5bGVWYWx1ZSIsImlzQ3VzdG9tUHJvcGVydHkiLCJpc0VtcHR5Iiwid2FyblZhbGlkU3R5bGUiLCJiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4iLCJiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4iLCJ3YXJuZWRTdHlsZU5hbWVzIiwid2FybmVkU3R5bGVWYWx1ZXMiLCJ3YXJuZWRGb3JOYU5WYWx1ZSIsIndhcm5lZEZvckluZmluaXR5VmFsdWUiLCJ3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSIsIndhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZSIsIndhcm5TdHlsZVZhbHVlV2l0aFNlbWljb2xvbiIsIndhcm5TdHlsZVZhbHVlSXNOYU4iLCJ3YXJuU3R5bGVWYWx1ZUlzSW5maW5pdHkiLCJpc0Zpbml0ZSIsIndhcm5WYWxpZFN0eWxlJDEiLCJjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMiLCJzdHlsZXMiLCJzZXJpYWxpemVkIiwiZGVsaW1pdGVyIiwic3R5bGVOYW1lIiwic3R5bGVWYWx1ZSIsInNldFZhbHVlRm9yU3R5bGVzIiwib21pdHRlZENsb3NlVGFncyIsInZvaWRFbGVtZW50VGFncyIsIkhUTUwkMSIsImFzc2VydFZhbGlkUHJvcHMiLCJpc0N1c3RvbUNvbXBvbmVudCIsImFyaWFQcm9wZXJ0aWVzIiwid2FybmVkUHJvcGVydGllcyIsInJBUklBIiwickFSSUFDYW1lbCIsInZhbGlkYXRlUHJvcGVydHkiLCJhcmlhTmFtZSIsImNvcnJlY3ROYW1lIiwic3RhbmRhcmROYW1lIiwid2FybkludmFsaWRBUklBUHJvcHMiLCJpbnZhbGlkUHJvcHMiLCJpc1ZhbGlkIiwidW5rbm93blByb3BTdHJpbmciLCJ2YWxpZGF0ZVByb3BlcnRpZXMiLCJkaWRXYXJuVmFsdWVOdWxsIiwiZ2V0U3RhY2tBZGRlbmR1bSQxIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDEiLCJwb3NzaWJsZVN0YW5kYXJkTmFtZXMiLCJhY2NlcHQiLCJhY2NlcHRjaGFyc2V0IiwiYWNjZXNza2V5IiwiYWxsb3dmdWxsc2NyZWVuIiwiYWx0IiwiYXMiLCJhdXRvY2FwaXRhbGl6ZSIsImF1dG9jb21wbGV0ZSIsImF1dG9jb3JyZWN0IiwiYXV0b2ZvY3VzIiwiYXV0b3BsYXkiLCJhdXRvc2F2ZSIsImNlbGxwYWRkaW5nIiwiY2VsbHNwYWNpbmciLCJjaGFsbGVuZ2UiLCJjaGFyc2V0IiwiY2l0ZSIsImNsYXNzaWQiLCJjbGFzc25hbWUiLCJjb2xzcGFuIiwiY29udGVudGVkaXRhYmxlIiwiY29udGV4dG1lbnUiLCJjb250cm9sc2xpc3QiLCJjb29yZHMiLCJjcm9zc29yaWdpbiIsImRhbmdlcm91c2x5c2V0aW5uZXJodG1sIiwiZGVmYXVsdGNoZWNrZWQiLCJkZWZhdWx0dmFsdWUiLCJlbmN0eXBlIiwiZm9ybW1ldGhvZCIsImZvcm1hY3Rpb24iLCJmb3JtZW5jdHlwZSIsImZvcm1ub3ZhbGlkYXRlIiwiZm9ybXRhcmdldCIsImZyYW1lYm9yZGVyIiwiaGVhZGVycyIsImhlaWdodCIsImhpZ2giLCJocmVmbGFuZyIsImh0bWxmb3IiLCJodHRwZXF1aXYiLCJpY29uIiwiaW5uZXJodG1sIiwiaW5wdXRtb2RlIiwiaW50ZWdyaXR5IiwiaXRlbWlkIiwiaXRlbXByb3AiLCJpdGVtcmVmIiwiaXRlbXNjb3BlIiwiaXRlbXR5cGUiLCJrZXlwYXJhbXMiLCJrZXl0eXBlIiwia2luZCIsImxhbmciLCJsaXN0IiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW53aWR0aCIsIm1hcmdpbmhlaWdodCIsIm1heGxlbmd0aCIsIm1lZGlhIiwibWVkaWFncm91cCIsIm1ldGhvZCIsIm1pbmxlbmd0aCIsIm5vbmNlIiwibm92YWxpZGF0ZSIsIm9wdGltdW0iLCJwYXR0ZXJuIiwicGxhY2Vob2xkZXIiLCJwbGF5c2lubGluZSIsInBvc3RlciIsInByZWxvYWQiLCJwcm9maWxlIiwicmFkaW9ncm91cCIsInJlYWRvbmx5IiwicmVmZXJyZXJwb2xpY3kiLCJyZWwiLCJyb2xlIiwicm93c3BhbiIsInNhbmRib3giLCJzY3JvbGxpbmciLCJzaGFwZSIsInNpemVzIiwic3BlbGxjaGVjayIsInNyYyIsInNyY2RvYyIsInNyY2xhbmciLCJzcmNzZXQiLCJzdW1tYXJ5IiwidGFiaW5kZXgiLCJ1c2VtYXAiLCJ3aWR0aCIsIndtb2RlIiwid3JhcCIsImFib3V0IiwiYWNjZW50aGVpZ2h0IiwiYWNjdW11bGF0ZSIsImFkZGl0aXZlIiwiYWxpZ25tZW50YmFzZWxpbmUiLCJhbGxvd3Jlb3JkZXIiLCJhbHBoYWJldGljIiwiYW1wbGl0dWRlIiwiYXJhYmljZm9ybSIsImFzY2VudCIsImF0dHJpYnV0ZW5hbWUiLCJhdHRyaWJ1dGV0eXBlIiwiYXV0b3JldmVyc2UiLCJhemltdXRoIiwiYmFzZWZyZXF1ZW5jeSIsImJhc2VsaW5lc2hpZnQiLCJiYXNlcHJvZmlsZSIsImJib3giLCJiZWdpbiIsImJpYXMiLCJieSIsImNhbGNtb2RlIiwiY2FwaGVpZ2h0IiwiY2xpcCIsImNsaXBwYXRoIiwiY2xpcHBhdGh1bml0cyIsImNsaXBydWxlIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3giLCJjeSIsImRhdGF0eXBlIiwiZGVjZWxlcmF0ZSIsImRlc2NlbnQiLCJkaWZmdXNlY29uc3RhbnQiLCJkaXJlY3Rpb24iLCJkaXNwbGF5IiwiZGl2aXNvciIsImRvbWluYW50YmFzZWxpbmUiLCJkdXIiLCJkeCIsImR5IiwiZWRnZW1vZGUiLCJlbGV2YXRpb24iLCJlbmFibGViYWNrZ3JvdW5kIiwiZXhwb25lbnQiLCJleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkIiwiZmlsbCIsImZpbGxvcGFjaXR5IiwiZmlsbHJ1bGUiLCJmaWx0ZXIiLCJmaWx0ZXJyZXMiLCJmaWx0ZXJ1bml0cyIsImZsb29kb3BhY2l0eSIsImZsb29kY29sb3IiLCJmb2N1c2FibGUiLCJmb250ZmFtaWx5IiwiZm9udHNpemUiLCJmb250c2l6ZWFkanVzdCIsImZvbnRzdHJldGNoIiwiZm9udHN0eWxlIiwiZm9udHZhcmlhbnQiLCJmb250d2VpZ2h0IiwiZngiLCJmeSIsImcxIiwiZzIiLCJnbHlwaG5hbWUiLCJnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbCIsImdseXBob3JpZW50YXRpb252ZXJ0aWNhbCIsImdseXBocmVmIiwiZ3JhZGllbnR0cmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIiwiaGFuZ2luZyIsImhvcml6YWR2eCIsImhvcml6b3JpZ2lueCIsImlkZW9ncmFwaGljIiwiaW1hZ2VyZW5kZXJpbmciLCJpbjIiLCJpbmxpc3QiLCJpbnRlcmNlcHQiLCJrMSIsImsyIiwiazMiLCJrNCIsImtlcm5lbG1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiLCJrZXJuaW5nIiwia2V5cG9pbnRzIiwia2V5c3BsaW5lcyIsImtleXRpbWVzIiwibGVuZ3RoYWRqdXN0IiwibGV0dGVyc3BhY2luZyIsImxpZ2h0aW5nY29sb3IiLCJsaW1pdGluZ2NvbmVhbmdsZSIsImxvY2FsIiwibWFya2VyZW5kIiwibWFya2VyaGVpZ2h0IiwibWFya2VybWlkIiwibWFya2Vyc3RhcnQiLCJtYXJrZXJ1bml0cyIsIm1hcmtlcndpZHRoIiwibWFzayIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtb2N0YXZlcyIsIm9wZXJhdG9yIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVyZmxvdyIsIm92ZXJsaW5lcG9zaXRpb24iLCJvdmVybGluZXRoaWNrbmVzcyIsInBhaW50b3JkZXIiLCJwYW5vc2UxIiwicGF0aGxlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIiwicG9pbnRlcmV2ZW50cyIsInBvaW50cyIsInBvaW50c2F0eCIsInBvaW50c2F0eSIsInBvaW50c2F0eiIsInByZXNlcnZlYWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIiwicHJpbWl0aXZldW5pdHMiLCJwcm9wZXJ0eSIsInJhZGl1cyIsInJlZngiLCJyZWZ5IiwicmVuZGVyaW5naW50ZW50IiwicmVwZWF0Y291bnQiLCJyZXBlYXRkdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIiwicmVzb3VyY2UiLCJyZXN0YXJ0IiwicmVzdWx0cyIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlY3VyaXR5Iiwic2VlZCIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3RyaW5nIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRyYW5zZm9ybSIsInUxIiwidTIiLCJ1bmRlcmxpbmVwb3NpdGlvbiIsInVuZGVybGluZXRoaWNrbmVzcyIsInVuaWNvZGUiLCJ1bmljb2RlYmlkaSIsInVuaWNvZGVyYW5nZSIsInVuaXRzcGVyZW0iLCJ1bnNlbGVjdGFibGUiLCJ2YWxwaGFiZXRpYyIsInZlY3RvcmVmZmVjdCIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4Y2hhbm5lbHNlbGVjdG9yIiwieGhlaWdodCIsInhsaW5rYWN0dWF0ZSIsInhsaW5rYXJjcm9sZSIsInhsaW5raHJlZiIsInhsaW5rcm9sZSIsInhsaW5rc2hvdyIsInhsaW5rdGl0bGUiLCJ4bGlua3R5cGUiLCJ4bWxiYXNlIiwieG1sbGFuZyIsInhtbG5zIiwieG1sbnN4bGluayIsInhtbHNwYWNlIiwieTEiLCJ5MiIsInljaGFubmVsc2VsZWN0b3IiLCJ6b29tYW5kcGFuIiwiZ2V0U3RhY2tBZGRlbmR1bSQyIiwid2FybmVkUHJvcGVydGllcyQxIiwiaGFzT3duUHJvcGVydHkkMSIsIkVWRU5UX05BTUVfUkVHRVgiLCJJTlZBTElEX0VWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwidmFsaWRhdGVQcm9wZXJ0eSQxIiwiY2FuVXNlRXZlbnRTeXN0ZW0iLCJpc1Jlc2VydmVkIiwid2FyblVua25vd25Qcm9wZXJ0aWVzIiwidW5rbm93blByb3BzIiwidmFsaWRhdGVQcm9wZXJ0aWVzJDIiLCJnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMiIsImRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uIiwiZGlkV2FyblNoYWR5RE9NIiwiREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwiLCJTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkciLCJTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxIiwiQVVUT0ZPQ1VTIiwiQ0hJTERSRU4iLCJTVFlMRSIsIkhUTUwiLCJIVE1MX05BTUVTUEFDRSIsIndhcm5lZFVua25vd25UYWdzIiwiZGlhbG9nIiwidmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCIsIk5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCIsIk5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCIsIm5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZSIsIm1hcmt1cCIsIm1hcmt1cFN0cmluZyIsIndhcm5Gb3JUZXh0RGlmZmVyZW5jZSIsInNlcnZlclRleHQiLCJjbGllbnRUZXh0Iiwibm9ybWFsaXplZENsaWVudFRleHQiLCJub3JtYWxpemVkU2VydmVyVGV4dCIsIndhcm5Gb3JQcm9wRGlmZmVyZW5jZSIsInNlcnZlclZhbHVlIiwiY2xpZW50VmFsdWUiLCJub3JtYWxpemVkQ2xpZW50VmFsdWUiLCJub3JtYWxpemVkU2VydmVyVmFsdWUiLCJ3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzIiwiYXR0cmlidXRlTmFtZXMiLCJuYW1lcyIsIndhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciIsIm5vcm1hbGl6ZUhUTUwiLCJ0ZXN0RWxlbWVudCIsImVuc3VyZUxpc3RlbmluZ1RvIiwicm9vdENvbnRhaW5lckVsZW1lbnQiLCJpc0RvY3VtZW50T3JGcmFnbWVudCIsImdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lciIsIm1lZGlhRXZlbnRzIiwidHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQiLCJzZXRJbml0aWFsRE9NUHJvcGVydGllcyIsImRvbUVsZW1lbnQiLCJpc0N1c3RvbUNvbXBvbmVudFRhZyIsInByb3BLZXkiLCJuZXh0UHJvcCIsIm5leHRIdG1sIiwiY2FuU2V0VGV4dENvbnRlbnQiLCJ1cGRhdGVET01Qcm9wZXJ0aWVzIiwid2FzQ3VzdG9tQ29tcG9uZW50VGFnIiwiY3JlYXRlRWxlbWVudCQxIiwiZGl2IiwiY3JlYXRlVGV4dE5vZGUkMSIsInNldEluaXRpYWxQcm9wZXJ0aWVzJDEiLCJyYXdQcm9wcyIsInNoYWR5Um9vdCIsImRpZmZQcm9wZXJ0aWVzJDEiLCJsYXN0UmF3UHJvcHMiLCJuZXh0UmF3UHJvcHMiLCJsYXN0UHJvcHMiLCJzdHlsZVVwZGF0ZXMiLCJsYXN0U3R5bGUiLCJsYXN0UHJvcCIsImxhc3RIdG1sIiwidXBkYXRlUHJvcGVydGllcyQxIiwiZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxIiwiZXh0cmFBdHRyaWJ1dGVOYW1lcyIsImF0dHJpYnV0ZXMiLCJyYXdIdG1sIiwic2VydmVySFRNTCIsImV4cGVjdGVkSFRNTCIsImV4cGVjdGVkU3R5bGUiLCJvd25OYW1lc3BhY2UiLCJkaWZmSHlkcmF0ZWRUZXh0JDEiLCJ0ZXh0Tm9kZSIsImlzRGlmZmVyZW50Iiwid2FybkZvclVubWF0Y2hlZFRleHQkMSIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMSIsIndhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMSIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxIiwid2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEiLCJSZWFjdERPTUZpYmVyQ29tcG9uZW50IiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2IiwidmFsaWRhdGVET01OZXN0aW5nIiwic3BlY2lhbFRhZ3MiLCJpblNjb3BlVGFncyIsImJ1dHRvblNjb3BlVGFncyIsImltcGxpZWRFbmRUYWdzIiwiZW1wdHlBbmNlc3RvckluZm8iLCJmb3JtVGFnIiwiYVRhZ0luU2NvcGUiLCJidXR0b25UYWdJblNjb3BlIiwibm9iclRhZ0luU2NvcGUiLCJwVGFnSW5CdXR0b25TY29wZSIsImxpc3RJdGVtVGFnQXV0b2Nsb3NpbmciLCJkbEl0ZW1UYWdBdXRvY2xvc2luZyIsInVwZGF0ZWRBbmNlc3RvckluZm8kMSIsIm9sZEluZm8iLCJhbmNlc3RvckluZm8iLCJpc1RhZ1ZhbGlkV2l0aFBhcmVudCIsInBhcmVudFRhZyIsImZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWciLCJkaWRXYXJuIiwiY2hpbGRUYWciLCJjaGlsZFRleHQiLCJwYXJlbnRJbmZvIiwiaW52YWxpZFBhcmVudCIsImludmFsaWRBbmNlc3RvciIsImludmFsaWRQYXJlbnRPckFuY2VzdG9yIiwiYW5jZXN0b3JUYWciLCJ3YXJuS2V5IiwidGFnRGlzcGxheU5hbWUiLCJ3aGl0ZXNwYWNlSW5mbyIsInVwZGF0ZWRBbmNlc3RvckluZm8iLCJpc1RhZ1ZhbGlkSW5Db250ZXh0IiwidmFsaWRhdGVET01OZXN0aW5nJDEiLCJTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyIsImV2ZW50c0VuYWJsZWQiLCJzZWxlY3Rpb25JbmZvcm1hdGlvbiIsImlzVmFsaWRDb250YWluZXIiLCJnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIiLCJzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMiLCJyb290RWxlbWVudCIsInNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQiLCJET01SZW5kZXJlciIsInZhbGlkYXRlZFRhZyIsIl9hbmNlc3RvckluZm8iLCJwYXJlbnRIb3N0Q29udGV4dCIsInBhcmVudEhvc3RDb250ZXh0RGV2IiwiX25hbWVzcGFjZSIsIl9hbmNlc3RvckluZm8yIiwiaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSIsImhvc3RDb250ZXh0RGV2Iiwib3duQW5jZXN0b3JJbmZvIiwiYmVmb3JlQ2hpbGQiLCJ3YXJuZWRBYm91dEh5ZHJhdGVBUEkiLCJyZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciIsImZvcmNlSHlkcmF0ZSIsImhvc3RJbnN0YW5jZSIsImlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QiLCJyb290RWwiLCJoYXNOb25Sb290UmVhY3RDaGlsZCIsInNob3VsZEh5ZHJhdGUiLCJ3YXJuZWQiLCJyb290U2libGluZyIsIm5ld1Jvb3QiLCJSZWFjdFJvb3QiLCJjb21wb25lbnRPckVsZW1lbnQiLCJ3YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImNvbnRhaW5lck5vZGUiLCJyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QiLCJfcm9vdEVsIiwiaXNDb250YWluZXJSZWFjdFJvb3QiLCJjcmVhdGVSb290IiwiZm91bmREZXZUb29scyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInByb3RvY29sIiwiUmVhY3RET00kMiIsIlJlYWN0RE9NJDMiLCJyZWFjdERvbSIsImh5cGhlbmF0ZSIsIm1zUGF0dGVybiIsIl91cHBlcmNhc2VQYXR0ZXJuIiwiY2FtZWxpemUiLCJfaHlwaGVuUGF0dGVybiIsIl8iLCJjaGFyYWN0ZXIiLCJnZXRCcmVha3BvaW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiYnJlYWtwb2ludCIsIiQiLCJyZXNpemUiLCJkZXNrdG9wIiwidGFibGV0IiwicGhvbmUiLCJnbG9iYWwiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiRXZlbnQiLCJDdXN0b21FdmVudCIsImluaXRDdXN0b21FdmVudCIsIk1vdXNlRXZlbnQiLCJpbml0TW91c2VFdmVudCIsIldlYkNvbXBvbmVudHMiLCJIVE1MVGVtcGxhdGVFbGVtZW50IiwiY3JlYXRlRG9jdW1lbnRGcmFnbWVudCIsImNsb25lTm9kZSIsIkRvY3VtZW50RnJhZ21lbnQiLCJfX3Byb3RvX18iLCJIVE1MRWxlbWVudCIsImxvY2FsTmFtZSIsInJlcGxhY2VDaGlsZCIsIkRvY3VtZW50IiwiaW1wb3J0Tm9kZSIsIkVsZW1lbnQiLCJjaGlsZE5vZGVzIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJvdXRlckhUTUwiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2ViS2l0TXV0YXRpb25PYnNlcnZlciIsIlVpbnQ4Q2xhbXBlZEFycmF5IiwiaW1wb3J0U2NyaXB0cyIsIk1lc3NhZ2VDaGFubmVsIiwib2JzZXJ2ZSIsImNoYXJhY3RlckRhdGEiLCJwb3J0MSIsIm9ubWVzc2FnZSIsInBvcnQyIiwidGhlbiIsInJlc29sdmUiLCJQcm9taXNlIiwiYWxsIiwicmFjZSIsInJlamVjdCIsIl9faW1wb3J0RG9jIiwicmVhZHlTdGF0ZSIsIl9fbG9hZGVkIiwiY2hpbGRMaXN0Iiwic3VidHJlZSIsInNjcmlwdHMiLCJsb2FkIiwiYXRvYiIsImRlY29kZVVSSUNvbXBvbmVudCIsIlhNTEh0dHBSZXF1ZXN0Iiwib25sb2FkIiwicmVzcG9uc2VVUkwiLCJnZXRSZXNwb25zZUhlYWRlciIsImhvc3QiLCJyZXNwb25zZSIsInJlc3BvbnNlVGV4dCIsInN0YXR1cyIsInNlbmQiLCJpbXBvcnQiLCJvIiwiZGlzY29ubmVjdCIsImZsYXR0ZW4iLCJfX2FwcGxpZWRFbGVtZW50IiwiYWRkZWROb2RlcyIsInVzZU5hdGl2ZSIsIndoZW5SZWFkeSIsImltcG9ydEZvckVsZW1lbnQiLCJIVE1MSW1wb3J0cyIsImZsYWdzIiwibm9PcHRzIiwibG9nIiwic2hhZHlkb20iLCJmb3JjZSIsInJlZ2lzdGVyIiwiZm9yY2VQb2x5ZmlsbCIsImF0dGFjaFNoYWRvdyIsImdldFJvb3ROb2RlIiwiX19zaGFkeSIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJzaGlmdCIsInJlbW92ZWROb2RlcyIsInRha2VSZWNvcmRzIiwiZGVsZXRlIiwiV2luZG93IiwiY3JlYXRlVHJlZVdhbGtlciIsIk5vZGVGaWx0ZXIiLCJTSE9XX0FMTCIsIlNIT1dfRUxFTUVOVCIsImN1cnJlbnROb2RlIiwicHJldmlvdXNTaWJsaW5nIiwicGFyZW50RWxlbWVudCIsImxhc3RFbGVtZW50Q2hpbGQiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiU0hPV19URVhUIiwibmV4dE5vZGUiLCJpdGVtIiwiY2hpbGRFbGVtZW50Q291bnQiLCJzaGFkb3dSb290IiwiX19ub0luc2VydGlvblBvaW50Iiwic3BsaWNlIiwiU2NvcGluZ1NoaW0iLCJzZXRFbGVtZW50Q2xhc3MiLCJibHVyIiwiZm9jdXNpbiIsImZvY3Vzb3V0IiwiY2xpY2siLCJkYmxjbGljayIsIm1vdXNlZG93biIsIm1vdXNlZW50ZXIiLCJtb3VzZWxlYXZlIiwibW91c2Vtb3ZlIiwibW91c2VvdXQiLCJtb3VzZW92ZXIiLCJtb3VzZXVwIiwid2hlZWwiLCJiZWZvcmVpbnB1dCIsImtleWRvd24iLCJrZXl1cCIsImNvbXBvc2l0aW9uc3RhcnQiLCJjb21wb3NpdGlvbnVwZGF0ZSIsImNvbXBvc2l0aW9uZW5kIiwidG91Y2hzdGFydCIsInRvdWNoZW5kIiwidG91Y2htb3ZlIiwidG91Y2hjYW5jZWwiLCJwb2ludGVyb3ZlciIsInBvaW50ZXJlbnRlciIsInBvaW50ZXJkb3duIiwicG9pbnRlcm1vdmUiLCJwb2ludGVydXAiLCJwb2ludGVyY2FuY2VsIiwicG9pbnRlcm91dCIsInBvaW50ZXJsZWF2ZSIsImdvdHBvaW50ZXJjYXB0dXJlIiwibG9zdHBvaW50ZXJjYXB0dXJlIiwiZHJhZ3N0YXJ0IiwiZHJhZyIsImRyYWdlbnRlciIsImRyYWdsZWF2ZSIsImRyYWdvdmVyIiwiZHJvcCIsImRyYWdlbmQiLCJET01BY3RpdmF0ZSIsIkRPTUZvY3VzSW4iLCJET01Gb2N1c091dCIsImtleXByZXNzIiwiYXNzaWduZWRTbG90IiwiY29tcG9zZWQiLCJjb21wb3NlZFBhdGgiLCJfX3RhcmdldCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIl9faGFuZGxlcnMiLCJBVF9UQVJHRVQiLCJwYXNzaXZlIiwiQlVCQkxJTkdfUEhBU0UiLCJDQVBUVVJJTkdfUEhBU0UiLCJoYW5kbGVFdmVudCIsImJ1YmJsZSIsImdldFByb3RvdHlwZU9mIiwiX19wYXRjaFByb3RvIiwicmV2ZXJzZSIsIl9yZW5kZXJSb290IiwiYXNzaWduZWROb2RlcyIsImdhIiwic2xvdCIsInNvcnQiLCJ1bnNoaWZ0IiwiZ2V0RWxlbWVudEJ5SWQiLCJpc0Nvbm5lY3RlZCIsIl9hY3RpdmVFbGVtZW50IiwiaW5Vc2UiLCJwYXRjaCIsImlzU2hhZHlSb290IiwiZW5xdWV1ZSIsImZsdXNoIiwiZmlsdGVyTXV0YXRpb25zIiwib2JzZXJ2ZUNoaWxkcmVuIiwidW5vYnNlcnZlQ2hpbGRyZW4iLCJuYXRpdmVNZXRob2RzIiwibmF0aXZlVHJlZSIsIm5hdGl2ZUhUTUxFbGVtZW50IiwiVGV4dCIsIkhUTUxTbG90RWxlbWVudCIsIlNoYWRvd1Jvb3QiLCJfX0NFX2lzSW1wb3J0RG9jdW1lbnQiLCJfX0NFX3NoYWRvd1Jvb3QiLCJfX0NFX3BhdGNoZWQiLCJfX0NFX3N0YXRlIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJkaXNjb25uZWN0ZWRDYWxsYmFjayIsIl9fQ0VfaGFzUmVnaXN0cnkiLCJfX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQiLCJjb25zdHJ1Y3Rpb25TdGFjayIsIl9fQ0VfZGVmaW5pdGlvbiIsImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayIsIm9ic2VydmVkQXR0cmlidXRlcyIsImoiLCJkZWZpbmUiLCJGdW5jdGlvbiIsIlN5bnRheEVycm9yIiwiYWRvcHRlZENhbGxiYWNrIiwid2hlbkRlZmluZWQiLCJzb21lIiwiQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IiwicHJlcGVuZCIsImFwcGVuZCIsImdldEF0dHJpYnV0ZU5TIiwicmVtb3ZlQXR0cmlidXRlTlMiLCJpbnNlcnRBZGphY2VudEVsZW1lbnQiLCJhZnRlciIsInJlcGxhY2VXaXRoIiwic2V0UHJvdG90eXBlT2YiLCJydWxlcyIsInByZXZpb3VzIiwicGFyc2VkQ3NzVGV4dCIsImF0UnVsZSIsInBhcnNlZFNlbGVjdG9yIiwia2V5ZnJhbWVzTmFtZSIsInNoaW1jc3Nwcm9wZXJ0aWVzIiwiQ1NTIiwic3VwcG9ydHMiLCJfX2Nzc1J1bGVzIiwibWF0Y2hNZWRpYSIsIkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyIsImV4dGVuZHMiLCJfX3N0eWxlU2NvcGVkIiwiY2xhc3NMaXN0IiwiX19jc3NCdWlsZCIsInN0b3AiLCJfX3N0eWxlSW5mbyIsIl9nZXRTdHlsZVJ1bGVzIiwiZXhlYyIsImxhc3RJbmRleCIsImNyZWF0ZUNvbW1lbnQiLCJjYWNoZSIsInN0b3JlIiwic3R5bGVFbGVtZW50IiwiZmV0Y2giLCJTVkdFbGVtZW50IiwiX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uIiwiX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uIiwiX2FwcGx5U2hpbU5leHRWZXJzaW9uIiwicHJlcGFyZVRlbXBsYXRlIiwidHJhbnNmb3JtUnVsZXMiLCJfc3R5bGVBc3QiLCJDdXN0b21TdHlsZUludGVyZmFjZSIsInRyYW5zZm9ybUNhbGxiYWNrIiwidmFsaWRhdGVDYWxsYmFjayIsImVucXVldWVkIiwiQXBwbHlTaGltIiwiaW52YWxpZENhbGxiYWNrIiwicHJvY2Vzc1N0eWxlcyIsImdldFN0eWxlRm9yQ3VzdG9tU3R5bGUiLCJzdHlsZURvY3VtZW50IiwicmVtb3ZlUHJvcGVydHkiLCJfdXNlQ291bnQiLCJzdHlsZVN1YnRyZWUiLCJ0cmFuc2Zvcm1SdWxlIiwiZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlIiwiX3N0eWxlSW5mb0Zvck5vZGUiLCJ0cmFuc2Zvcm1DdXN0b21TdHlsZUZvckRvY3VtZW50IiwiZ2V0U3R5bGVBc3QiLCJzdHlsZUFzdFRvU3RyaW5nIiwiZmx1c2hDdXN0b21TdHlsZXMiLCJuYXRpdmVTaGFkb3ciLCJyZWFkeSIsImV2YWwiLCJIZWFkaW5nIiwiSGVhZGluZ1RhZyIsImhlYWRpbmciLCJzdWJ0ZXh0IiwiaGFzaHIiLCJUVEFVbmRlcmxpbmVkVGV4dCIsInRlbXBsYXRlIiwiaGFzSHIiLCJFbGVtZW50TWl4aW4iLCJwb2x5bWVyRWxlbWVudEJhc2UiLCJQcm9wZXJ0eUVmZmVjdHMiLCJvd25Qcm9wZXJ0aWVzRm9yQ2xhc3MiLCJrbGFzcyIsIl9fb3duUHJvcGVydGllcyIsIm93bk9ic2VydmVyc0ZvckNsYXNzIiwiX19vd25PYnNlcnZlcnMiLCJvYnNlcnZlcnMiLCJmbGF0dGVuUHJvcGVydGllcyIsImZsYXR0ZW5lZFByb3BzIiwicHJvcGVydGllc0ZvckNsYXNzIiwiX19jbGFzc1Byb3BlcnRpZXMiLCJzdXBlckN0b3IiLCJQb2x5bWVyRWxlbWVudCIsInByb3BlcnR5RGVmYXVsdHNGb3JDbGFzcyIsIl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzIiwiaGFzQ2xhc3NGaW5hbGl6ZWQiLCJmaW5hbGl6ZUNsYXNzQW5kU3VwZXIiLCJwcm90byIsImZpbmFsaXplIiwiZmluYWxpemVDbGFzcyIsIl9fZmluYWxpemVkIiwiZmluYWxpemVQcm9wZXJ0aWVzIiwiZmluYWxpemVPYnNlcnZlcnMiLCJfdGVtcGxhdGUiLCJjcmVhdGVQcm9wZXJ0eUZyb21Db25maWciLCJkeW5hbWljRm5zIiwiX2NyZWF0ZU1ldGhvZE9ic2VydmVyIiwiYWxsUHJvcHMiLCJjb21wdXRlZCIsIl9oYXNSZWFkT25seUVmZmVjdCIsIl9jcmVhdGVDb21wdXRlZFByb3BlcnR5IiwiX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkiLCJyZWZsZWN0VG9BdHRyaWJ1dGUiLCJfaGFzUmVmbGVjdEVmZmVjdCIsIl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eSIsIm5vdGlmeSIsIl9oYXNOb3RpZnlFZmZlY3QiLCJfY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkiLCJvYnNlcnZlciIsIl9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyIiwiZmluYWxpemVUZW1wbGF0ZSIsImV4dCIsImNzc0Zyb21Nb2R1bGVJbXBvcnRzIiwiY3NzRnJvbVRlbXBsYXRlIiwiX2JpbmRUZW1wbGF0ZSIsIl9fb2JzZXJ2ZWRBdHRyaWJ1dGVzIiwiRG9tTW9kdWxlIiwiaW1wb3J0UGF0aCIsIl9pbXBvcnRQYXRoIiwiYXNzZXRwYXRoIiwiX2luaXRpYWxpemVQcm9wZXJ0aWVzIiwiaW5zdGFuY2VDb3VudCIsIl9fcG9seW1lckZpbmFsaXplZCIsInJlc29sdmVVcmwkMCIsInAkIiwiX2hhc0FjY2Vzc29yIiwiX3NldFBlbmRpbmdQcm9wZXJ0eSIsIl9lbmFibGVQcm9wZXJ0aWVzIiwiX3N0YW1wVGVtcGxhdGUiLCJfcmVhZHlDbGllbnRzIiwiX2F0dGFjaERvbSIsImRvbSIsIm9sZCIsIl9hdHRyaWJ1dGVUb1Byb3BlcnR5IiwidXBkYXRlU3R5bGVzIiwiX3BhcnNlVGVtcGxhdGVDb250ZW50IiwidGVtcGxhdGVJbmZvIiwibm9kZUluZm8iLCJyZWdpc3RyYXRpb25zIiwiX3JlZ0xvZyIsImR1bXBSZWdpc3RyYXRpb25zIiwiTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IiLCJJTkNMVURFX0FUVFIiLCJpbXBvcnRNb2R1bGUiLCJtb2R1bGVJZCIsIlBvbHltZXJEb21Nb2R1bGUiLCJ0ZW1wbGF0ZVdpdGhBc3NldFBhdGgiLCJjc3NGcm9tTW9kdWxlcyIsIm1vZHVsZUlkcyIsIm1vZHVsZXMiLCJjc3NGcm9tTW9kdWxlIiwiX2Nzc1RleHQiLCJfY3NzRnJvbU1vZHVsZUltcG9ydHMiLCJlJCIsImluY2x1ZGUiLCJpbXBvcnREb2MiLCJsY01vZHVsZXMiLCJmaW5kTW9kdWxlIiwic3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayIsIl9fYXNzZXRwYXRoIiwiQ2FzZU1hcCIsIlRZUEVTIiwiQ09NUFVURSIsIlJFRkxFQ1QiLCJOT1RJRlkiLCJQUk9QQUdBVEUiLCJPQlNFUlZFIiwiUkVBRF9PTkxZIiwiRGF0YVRyaWdnZXIiLCJEYXRhRWZmZWN0IiwiUHJvcGVydHlFZmZlY3RzVHlwZSIsImVuc3VyZU93bkVmZmVjdE1hcCIsIm1vZGVsIiwiZWZmZWN0cyIsInByb3RvRngiLCJpbnN0RngiLCJydW5FZmZlY3RzIiwiaGFzUGF0aHMiLCJleHRyYUFyZ3MiLCJyYW4iLCJydW5FZmZlY3RzRm9yUHJvcGVydHkiLCJyb290UHJvcGVydHkiLCJyb290JDAiLCJmeHMiLCJsYXN0UnVuIiwicGF0aE1hdGNoZXNUcmlnZ2VyIiwidHJpZ2dlciIsInRyaWdnZXJQYXRoIiwic3RydWN0dXJlZCIsImlzQW5jZXN0b3IiLCJ3aWxkY2FyZCIsImlzRGVzY2VuZGFudCIsInJ1bk9ic2VydmVyRWZmZWN0IiwiY2hhbmdlZFByb3AiLCJfX2RhdGEiLCJkeW5hbWljRm4iLCJydW5Ob3RpZnlFZmZlY3RzIiwibm90aWZ5UHJvcHMiLCJub3RpZmllZCIsIm5vdGlmeVBhdGgiLCJfX2RhdGFIb3N0IiwiX2ludmFsaWRhdGVQcm9wZXJ0aWVzIiwiY2FtZWxUb0Rhc2hDYXNlJDAiLCJkaXNwYXRjaE5vdGlmeUV2ZW50IiwicXVldWVQcm9wZXJ0eSIsInJ1bk5vdGlmeUVmZmVjdCIsImdldCQwIiwiaGFuZGxlTm90aWZpY2F0aW9uIiwiZnJvbVByb3AiLCJ0b1BhdGgiLCJuZWdhdGUiLCJmcm9tUGF0aCIsInRyYW5zbGF0ZSIsIl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgiLCJydW5SZWZsZWN0RWZmZWN0IiwiYXR0ck5hbWUiLCJfcHJvcGVydHlUb0F0dHJpYnV0ZSIsInJ1bkNvbXB1dGVkRWZmZWN0cyIsImNoYW5nZWRQcm9wcyIsImNvbXB1dGVFZmZlY3RzIiwiaW5wdXRQcm9wcyIsIl9fZGF0YU9sZCIsIl9fZGF0YVBlbmRpbmciLCJydW5Db21wdXRlZEVmZmVjdCIsInJ1bk1ldGhvZEVmZmVjdCIsImNvbXB1dGVkUHJvcCIsIm1ldGhvZEluZm8iLCJfX2RhdGFIYXNBY2Nlc3NvciIsImNvbXB1dGVMaW5rZWRQYXRocyIsImxpbmtzIiwiX19kYXRhTGlua2VkUGF0aHMiLCJhZGRCaW5kaW5nIiwicGFydHMiLCJsaXRlcmFsIiwiYmluZGluZ3MiLCJpc0NvbXBvdW5kIiwic2hvdWxkQWRkTGlzdGVuZXIiLCJsaXN0ZW5lckV2ZW50IiwibGlzdGVuZXJOZWdhdGUiLCJub2RlSW5mb0xpc3QiLCJwYXJ0IiwiY29tcG91bmRJbmRleCIsImFkZEVmZmVjdEZvckJpbmRpbmdQYXJ0IiwiZXZhbHVhdG9yIiwicGFyc2VBcmciLCJfYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCIsInJ1bkJpbmRpbmdFZmZlY3QiLCJub2RlTGlzdCIsIl9lbnF1ZXVlQ2xpZW50IiwiX2V2YWx1YXRlQmluZGluZyIsImFwcGx5QmluZGluZ1ZhbHVlIiwiY29tcHV0ZUJpbmRpbmdWYWx1ZSIsIl92YWx1ZVRvTm9kZUF0dHJpYnV0ZSIsIl9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZSIsInN0b3JhZ2UiLCJfX2RhdGFDb21wb3VuZFN0b3JhZ2UiLCJzZXR1cEJpbmRpbmdzIiwic2V0dXBDb21wb3VuZFN0b3JhZ2UiLCJhZGROb3RpZnlMaXN0ZW5lciIsImxpdGVyYWxzIiwiY3JlYXRlTWV0aG9kRWZmZWN0Iiwic2lnIiwiZWZmZWN0Rm4iLCJzdGF0aWMiLCJfYWRkUHJvcGVydHlFZmZlY3QiLCJfbWV0aG9kSG9zdCIsIm1hcnNoYWxBcmdzIiwiZW1wdHlBcnJheSIsIklERU5UIiwiTlVNQkVSIiwiU1FVT1RFX1NUUklORyIsIkRRVU9URV9TVFJJTkciLCJTVFJJTkciLCJBUkdVTUVOVCIsIkFSR1VNRU5UUyIsIkFSR1VNRU5UX0xJU1QiLCJCSU5ESU5HIiwiT1BFTl9CUkFDS0VUIiwiQ0xPU0VfQlJBQ0tFVCIsIk5FR0FURSIsIkVYUFJFU1NJT04iLCJiaW5kaW5nUmVnZXgiLCJsaXRlcmFsRnJvbVBhcnRzIiwicGFyc2VNZXRob2QiLCJleHByZXNzaW9uIiwicGFyc2VBcmdzIiwiYXJnTGlzdCIsInJhd0FyZyIsIk51bWJlciIsImlzUGF0aCQwIiwiYmFzZUNoYW5nZWQiLCJub3RpZnlTcGxpY2VzIiwic3BsaWNlcyIsInNwbGljZXNQYXRoIiwiaW5kZXhTcGxpY2VzIiwibm90aWZ5U3BsaWNlIiwiYWRkZWRDb3VudCIsInJlbW92ZWQiLCJ1cHBlciIsInN1cGVyQ2xhc3MiLCJwcm9wZXJ0eUVmZmVjdHNCYXNlIiwiVGVtcGxhdGVTdGFtcCIsIlByb3BlcnR5QWNjZXNzb3JzIiwiX19kYXRhQ2xpZW50c1JlYWR5IiwiX19kYXRhUGVuZGluZ0NsaWVudHMiLCJfX2RhdGFUb05vdGlmeSIsIl9fZGF0YUhhc1BhdGhzIiwiX19kYXRhVGVtcCIsIl9fZGF0YUNsaWVudHNJbml0aWFsaXplZCIsIl9fY29tcHV0ZUVmZmVjdHMiLCJfX3JlZmxlY3RFZmZlY3RzIiwiX19ub3RpZnlFZmZlY3RzIiwiX19wcm9wYWdhdGVFZmZlY3RzIiwiX19vYnNlcnZlRWZmZWN0cyIsIl9fcmVhZE9ubHkiLCJfX2RhdGFDb3VudGVyIiwiX190ZW1wbGF0ZUluZm8iLCJQUk9QRVJUWV9FRkZFQ1RfVFlQRVMiLCJob3N0U3RhY2siLCJyZWdpc3Rlckhvc3QiLCJfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyIsIl9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzIiwiZWZmZWN0IiwiX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IiLCJfcmVtb3ZlUHJvcGVydHlFZmZlY3QiLCJpZHgiLCJfaGFzUHJvcGVydHlFZmZlY3QiLCJfaGFzQ29tcHV0ZWRFZmZlY3QiLCJzaG91bGROb3RpZnkiLCJpc1BhdGhOb3RpZmljYXRpb24iLCJzZXQkMCIsIl9zaG91bGRQcm9wZXJ0eUNoYW5nZSIsImlzUGF0aCIsIl9zZXRQcm9wZXJ0eSIsIl9fZGF0YVJlYWR5IiwiX2ZsdXNoUHJvcGVydGllcyIsImNsaWVudCIsIl9mbHVzaENsaWVudHMiLCJfX2VuYWJsZU9yRmx1c2hDbGllbnRzIiwiY2xpZW50cyIsIl9fZGF0YUVuYWJsZWQiLCJzZXRQcm9wZXJ0aWVzIiwic2V0UmVhZE9ubHkiLCJfcHJvcGVydGllc0NoYW5nZWQiLCJjdXJyZW50UHJvcHMiLCJfcHJvcGFnYXRlUHJvcGVydHlDaGFuZ2VzIiwicHJvcGVydHlFZmZlY3RzIiwibmV4dFRlbXBsYXRlSW5mbyIsImxpbmtQYXRocyIsInVubGlua1BhdGhzIiwiaXRlbXMiLCJyZXQiLCJoYWRMZW5ndGgiLCJkZWxldGVDb3VudCIsImZsb29yIiwicHJvcFBhdGgiLCJwcm90ZWN0ZWRTZXR0ZXIiLCJhdHRyIiwiYWRkUHJvcGVydHlFZmZlY3QiLCJjcmVhdGVQcm9wZXJ0eU9ic2VydmVyIiwiY3JlYXRlTWV0aG9kT2JzZXJ2ZXIiLCJjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eSIsImNyZWF0ZVJlYWRPbmx5UHJvcGVydHkiLCJjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eSIsImNyZWF0ZUNvbXB1dGVkUHJvcGVydHkiLCJiaW5kVGVtcGxhdGUiLCJpbnN0YW5jZUJpbmRpbmciLCJfcGFyc2VUZW1wbGF0ZSIsIndhc1ByZUJvdW5kIiwiX190ZW1wbGF0ZUluZm9MYXN0IiwicHJldmlvdXNUZW1wbGF0ZUluZm8iLCJwcm9wRWZmZWN0cyIsImJlZ2luSG9zdGluZyIsImVuZEhvc3RpbmciLCJub2RlcyIsIl9yZW1vdmVCb3VuZERvbSIsIl9wYXJzZVRlbXBsYXRlTm9kZSIsIm5vdGVkIiwiX3BhcnNlQmluZGluZ3MiLCJfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUiLCJvcmlnTmFtZSIsIl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUiLCJjdXN0b21FdmVudCIsIm5vdGlmeUV2ZW50IiwiY29sb24iLCJzaWduYXR1cmUiLCJzdGFja0xlbiIsImRvdEluZGV4IiwibmV3QmFzZSIsImlzRGVlcCIsIm1pY3JvdGFzayIsIm5hdGl2ZVByb3BlcnRpZXMiLCJzYXZlQWNjZXNzb3JWYWx1ZSIsIl9fZGF0YVByb3RvIiwiY3JlYXRlUHJvcGVydGllc0ZvckF0dHJpYnV0ZXMiLCJhJCIsIl9fc2VyaWFsaXppbmciLCJfX2RhdGFJbnZhbGlkIiwiX19kYXRhSW5zdGFuY2VQcm9wcyIsIl9lbnN1cmVBdHRyaWJ1dGUiLCJhdHRyaWJ1dGUiLCJfZGVzZXJpYWxpemVWYWx1ZSIsInN0ciIsIl9zZXJpYWxpemVWYWx1ZSIsIm91dFZhbHVlIiwicGFyc2UiLCJjaGFuZ2VkIiwiX2lzUHJvcGVydHlQZW5kaW5nIiwiQXN5bmNJbnRlcmZhY2UiLCJtaWNyb3Rhc2tDdXJySGFuZGxlIiwibWljcm90YXNrTGFzdEhhbmRsZSIsIm1pY3JvdGFza0NhbGxiYWNrcyIsIm1pY3JvdGFza05vZGVDb250ZW50IiwibWljcm90YXNrTm9kZSIsIm1pY3JvdGFza0ZsdXNoIiwidGltZU91dCIsImRlbGF5IiwiY2FuY2VsIiwiYW5pbWF0aW9uRnJhbWUiLCJjYW5jZWxBbmltYXRpb25GcmFtZSIsImlkbGVQZXJpb2QiLCJoYW5kbGUiLCJtaWNyb1Rhc2siLCJ0ZW1wbGF0ZUV4dGVuc2lvbnMiLCJ3cmFwVGVtcGxhdGVFeHRlbnNpb24iLCJmaW5kVGVtcGxhdGVOb2RlIiwicGFyZW50SW5kZXgiLCJhcHBseUlkVG9NYXAiLCJhcHBseUV2ZW50TGlzdGVuZXIiLCJfYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZSIsImFwcGx5VGVtcGxhdGVDb250ZW50IiwiX3RlbXBsYXRlSW5mbyIsImNyZWF0ZU5vZGVFdmVudEhhbmRsZXIiLCJvdXRlclRlbXBsYXRlSW5mbyIsInN0cmlwV2hpdGVTcGFjZSIsImhhc0luc2VydGlvblBvaW50IiwiX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzIiwiaGFzQXR0cmlidXRlcyIsIl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMiLCJjaGlsZEluZm8iLCJpbmZvSW5kZXgiLCJhdHRycyIsIl9jb250ZW50Rm9yVGVtcGxhdGUiLCJkZWNvcmF0ZSIsIl9hZGRFdmVudExpc3RlbmVyVG9Ob2RlIiwiX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDN0RBQSxPQUFPQyx5QkFBUCxHQUFtQyxVQUFTQyxJQUFULEVBQWVDLEdBQWYsRUFBb0I7QUFBRSxTQUFPRCxJQUFQO0FBQWMsQ0FBdkU7QUFFQTs7O0FBQ0EsSUFBSUUsT0FBSixDOzs7Ozs7QUNIQTtBQUNBLElBQUlDLFVBQVVDLE9BQU9DLE9BQVAsR0FBaUIsRUFBL0IsQyxDQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUlDLGdCQUFKO0FBQ0EsSUFBSUMsa0JBQUo7O0FBRUEsU0FBU0MsZ0JBQVQsR0FBNEI7QUFDeEIsUUFBTSxJQUFJQyxLQUFKLENBQVUsaUNBQVYsQ0FBTjtBQUNIOztBQUNELFNBQVNDLG1CQUFULEdBQWdDO0FBQzVC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Q2hENzZCLFdBQUtILGdCQUFMLENBQXNCczRDLFNBQXRCLEVBQWlDdGQsT0FBakM7QUFDRDtBQUVEOzs7Ozs7Ozs7QUFPQTJvRixpQ0FBNkJ4akgsSUFBN0IsRUFBbUNtNEMsU0FBbkMsRUFBOEN0ZCxPQUE5QyxFQUF1RDtBQUNyRDc2QixXQUFLeUQsbUJBQUwsQ0FBeUIwMEMsU0FBekIsRUFBb0N0ZCxPQUFwQztBQUNEOztBQWxXb0M7O0FBc1d2QyxTQUFPMi9FLGFBQVA7QUFFRCxDQS9XNEIsQ0FBdEIsQzs7Ozs7Ozs7QUNwRlAsaUNBQWlDLDRCQUE0QixLQUFLLDRDIiwiZmlsZSI6IjYwOGFkYmY3MWI4YTg3YjdiMTVlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMjEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDYwOGFkYmY3MWI4YTg3YjdiMTVlIiwid2luZG93LkpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wLCBvYmopIHsgcmV0dXJuIHByb3A7IH1cblxuLyoqIEBuYW1lc3BhY2UgKi9cbmxldCBQb2x5bWVyO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Jvb3QuanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5jb25zdCBjYXNlTWFwID0ge307XG5jb25zdCBEQVNIX1RPX0NBTUVMID0gLy1bYS16XS9nO1xuY29uc3QgQ0FNRUxfVE9fREFTSCA9IC8oW0EtWl0pL2c7XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXNoVG9DYW1lbENhc2UoZGFzaCkge1xuICByZXR1cm4gY2FzZU1hcFtkYXNoXSB8fCAoXG4gICAgY2FzZU1hcFtkYXNoXSA9IGRhc2guaW5kZXhPZignLScpIDwgMCA/IGRhc2ggOiBkYXNoLnJlcGxhY2UoREFTSF9UT19DQU1FTCxcbiAgICAgIChtKSA9PiBtWzFdLnRvVXBwZXJDYXNlKClcbiAgICApXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW1lbFRvRGFzaENhc2UoY2FtZWwpIHtcbiAgcmV0dXJuIGNhc2VNYXBbY2FtZWxdIHx8IChcbiAgICBjYXNlTWFwW2NhbWVsXSA9IGNhbWVsLnJlcGxhY2UoQ0FNRUxfVE9fREFTSCwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9jYXNlLW1hcC5qcyIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5sZXQgQ1NTX1VSTF9SWCA9IC8odXJsXFwoKShbXildKikoXFwpKS9nO1xubGV0IEFCU19VUkwgPSAvKF5cXC8pfCheIyl8KF5bXFx3LVxcZF0qOikvO1xubGV0IHdvcmtpbmdVUkw7XG5sZXQgcmVzb2x2ZURvYztcbi8qKlxuICogUmVzb2x2ZXMgdGhlIGdpdmVuIFVSTCBhZ2FpbnN0IHRoZSBwcm92aWRlZCBgYmFzZVVyaScuXG4gKlxuICogQG1lbWJlcm9mIFBvbHltZXIuUmVzb2x2ZVVybFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBJbnB1dCBVUkwgdG8gcmVzb2x2ZVxuICogQHBhcmFtIHs/c3RyaW5nPX0gYmFzZVVSSSBCYXNlIFVSSSB0byByZXNvbHZlIHRoZSBVUkwgYWdhaW5zdFxuICogQHJldHVybiB7c3RyaW5nfSByZXNvbHZlZCBVUkxcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVVybCh1cmwsIGJhc2VVUkkpIHtcbiAgaWYgKHVybCAmJiBBQlNfVVJMLnRlc3QodXJsKSkge1xuICAgIHJldHVybiB1cmw7XG4gIH1cbiAgLy8gTGF6eSBmZWF0dXJlIGRldGVjdGlvbi5cbiAgaWYgKHdvcmtpbmdVUkwgPT09IHVuZGVmaW5lZCkge1xuICAgIHdvcmtpbmdVUkwgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdSA9IG5ldyBVUkwoJ2InLCAnaHR0cDovL2EnKTtcbiAgICAgIHUucGF0aG5hbWUgPSAnYyUyMGQnO1xuICAgICAgd29ya2luZ1VSTCA9ICh1LmhyZWYgPT09ICdodHRwOi8vYS9jJTIwZCcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIHNpbGVudGx5IGZhaWxcbiAgICB9XG4gIH1cbiAgaWYgKCFiYXNlVVJJKSB7XG4gICAgYmFzZVVSSSA9IGRvY3VtZW50LmJhc2VVUkkgfHwgd2luZG93LmxvY2F0aW9uLmhyZWY7XG4gIH1cbiAgaWYgKHdvcmtpbmdVUkwpIHtcbiAgICByZXR1cm4gKG5ldyBVUkwodXJsLCBiYXNlVVJJKSkuaHJlZjtcbiAgfVxuICAvLyBGYWxsYmFjayB0byBjcmVhdGluZyBhbiBhbmNob3IgaW50byBhIGRpc2Nvbm5lY3RlZCBkb2N1bWVudC5cbiAgaWYgKCFyZXNvbHZlRG9jKSB7XG4gICAgcmVzb2x2ZURvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgndGVtcCcpO1xuICAgIHJlc29sdmVEb2MuYmFzZSA9IHJlc29sdmVEb2MuY3JlYXRlRWxlbWVudCgnYmFzZScpO1xuICAgIHJlc29sdmVEb2MuaGVhZC5hcHBlbmRDaGlsZChyZXNvbHZlRG9jLmJhc2UpO1xuICAgIHJlc29sdmVEb2MuYW5jaG9yID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgcmVzb2x2ZURvYy5ib2R5LmFwcGVuZENoaWxkKHJlc29sdmVEb2MuYW5jaG9yKTtcbiAgfVxuICByZXNvbHZlRG9jLmJhc2UuaHJlZiA9IGJhc2VVUkk7XG4gIHJlc29sdmVEb2MuYW5jaG9yLmhyZWYgPSB1cmw7XG4gIHJldHVybiByZXNvbHZlRG9jLmFuY2hvci5ocmVmIHx8IHVybDtcblxufVxuXG4vKipcbiAqIFJlc29sdmVzIGFueSByZWxhdGl2ZSBVUkwncyBpbiB0aGUgZ2l2ZW4gQ1NTIHRleHQgYWdhaW5zdCB0aGUgcHJvdmlkZWRcbiAqIGBvd25lckRvY3VtZW50YCdzIGBiYXNlVVJJYC5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dCBDU1MgdGV4dCB0byBwcm9jZXNzXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBCYXNlIFVSSSB0byByZXNvbHZlIHRoZSBVUkwgYWdhaW5zdFxuICogQHJldHVybiB7c3RyaW5nfSBQcm9jZXNzZWQgQ1NTIHRleHQgd2l0aCByZXNvbHZlZCBVUkwnc1xuICovXG5mdW5jdGlvbiByZXNvbHZlQ3NzKGNzc1RleHQsIGJhc2VVUkkpIHtcbiAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShDU1NfVVJMX1JYLCBmdW5jdGlvbihtLCBwcmUsIHVybCwgcG9zdCkge1xuICAgIHJldHVybiBwcmUgKyAnXFwnJyArXG4gICAgICByZXNvbHZlVXJsKHVybC5yZXBsYWNlKC9bXCInXS9nLCAnJyksIGJhc2VVUkkpICtcbiAgICAgICdcXCcnICsgcG9zdDtcbiAgfSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIHBhdGggZnJvbSBhIGdpdmVuIGB1cmxgLiBUaGUgcGF0aCBpbmNsdWRlcyB0aGUgdHJhaWxpbmdcbiAqIGAvYCBmcm9tIHRoZSB1cmwuXG4gKlxuICogQG1lbWJlcm9mIFBvbHltZXIuUmVzb2x2ZVVybFxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBJbnB1dCBVUkwgdG8gdHJhbnNmb3JtXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIHBhdGhcbiAqL1xuZnVuY3Rpb24gcGF0aEZyb21VcmwodXJsKSB7XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKDAsIHVybC5sYXN0SW5kZXhPZignLycpICsgMSk7XG59XG5cbmV4cG9ydCB7IHJlc29sdmVDc3MgfTtcbmV4cG9ydCB7IHJlc29sdmVVcmwgfTtcbmV4cG9ydCB7IHBhdGhGcm9tVXJsIH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8vIHVuaXF1ZSBnbG9iYWwgaWQgZm9yIGRlZHVwaW5nIG1peGlucy5cbmxldCBkZWR1cGVJZCA9IDA7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIE1peGluRnVuY3Rpb24oKXt9XG4vKiogQHR5cGUgeyhXZWFrTWFwIHwgdW5kZWZpbmVkKX0gKi9cbk1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4vKiogQHR5cGUgeyhPYmplY3QgfCB1bmRlZmluZWQpfSAqL1xuTWl4aW5GdW5jdGlvbi5wcm90b3R5cGUuX19taXhpblNldDtcblxuZXhwb3J0IGNvbnN0IGRlZHVwaW5nTWl4aW4gPSBmdW5jdGlvbihtaXhpbikge1xuICBsZXQgbWl4aW5BcHBsaWNhdGlvbnMgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucztcbiAgaWYgKCFtaXhpbkFwcGxpY2F0aW9ucykge1xuICAgIG1peGluQXBwbGljYXRpb25zID0gbmV3IFdlYWtNYXAoKTtcbiAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucyA9IG1peGluQXBwbGljYXRpb25zO1xuICB9XG4gIC8vIG1haW50YWluIGEgdW5pcXVlIGlkIGZvciBlYWNoIG1peGluXG4gIGxldCBtaXhpbkRlZHVwZUlkID0gZGVkdXBlSWQrKztcbiAgZnVuY3Rpb24gZGVkdXBpbmdNaXhpbihiYXNlKSB7XG4gICAgbGV0IGJhc2VTZXQgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhiYXNlKS5fX21peGluU2V0O1xuICAgIGlmIChiYXNlU2V0ICYmIGJhc2VTZXRbbWl4aW5EZWR1cGVJZF0pIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBsZXQgbWFwID0gbWl4aW5BcHBsaWNhdGlvbnM7XG4gICAgbGV0IGV4dGVuZGVkID0gbWFwLmdldChiYXNlKTtcbiAgICBpZiAoIWV4dGVuZGVkKSB7XG4gICAgICBleHRlbmRlZCA9IC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyhtaXhpbikoYmFzZSk7XG4gICAgICBtYXAuc2V0KGJhc2UsIGV4dGVuZGVkKTtcbiAgICB9XG4gICAgLy8gY29weSBpbmhlcml0ZWQgbWl4aW4gc2V0IGZyb20gdGhlIGV4dGVuZGVkIGNsYXNzLCBvciB0aGUgYmFzZSBjbGFzc1xuICAgIC8vIE5PVEU6IHdlIGF2b2lkIHVzZSBvZiBTZXQgaGVyZSBiZWNhdXNlIHNvbWUgYnJvd3NlciAoSUUxMSlcbiAgICAvLyBjYW5ub3QgZXh0ZW5kIGEgYmFzZSBTZXQgdmlhIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBsZXQgbWl4aW5TZXQgPSBPYmplY3QuY3JlYXRlKC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0IHx8IGJhc2VTZXQgfHwgbnVsbCk7XG4gICAgbWl4aW5TZXRbbWl4aW5EZWR1cGVJZF0gPSB0cnVlO1xuICAgIC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0ID0gbWl4aW5TZXQ7XG4gICAgcmV0dXJuIGV4dGVuZGVkO1xuICB9XG5cbiAgcmV0dXJuIGRlZHVwaW5nTWl4aW47XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWFjdEluaXQoc2VsZWN0b3IsIFJlYWN0Q29tcG9uZW50KSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbigpIHtcbiAgXHRkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKS5mb3JFYWNoKGZ1bmN0aW9uKG5vZGUpIHtcbiAgXHRcdFJlYWN0RE9NLnJlbmRlcihcbiAgICAgICAgPFJlYWN0Q29tcG9uZW50IGhlYWRpbmc9e25vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhlYWRpbmcnKX1cbiAgICAgICAgICAgICAgXHRcdFx0XHRcdHN1YnRleHQ9e25vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXN1YnRleHQnKX1cbiAgICAgICAgICAgICAgXHRcdFx0XHRcdHNpemU9e25vZGUuZ2V0QXR0cmlidXRlKCdkYXRhLXNpemUnKX1cbiAgICAgICAgICAgICAgXHRcdFx0XHRcdGhhc2hyPXtub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1oYXNocicpfSAvPixcbiAgICAgICAgbm9kZSk7XG4gIFx0fSk7XG4gIH0pO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vY29tcG9uZW50cy9yZWFjdEluaXQuanMiLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gbGlzdGVuKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiBjYXB0dXJlKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignQXR0ZW1wdGVkIHRvIGxpc3RlbiB0byBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlIG9uIGEgJyArICdicm93c2VyIHRoYXQgZG9lcyBub3Qgc3VwcG9ydCB0aGUgY2FwdHVyZSBwaGFzZS4gWW91ciBhcHBsaWNhdGlvbiAnICsgJ3dpbGwgbm90IHJlY2VpdmUgc29tZSBldmVudHMuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGVtcHR5RnVuY3Rpb25cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIHJlZ2lzdGVyRGVmYXVsdDogZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0KCkge31cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRMaXN0ZW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGZiLXd3dy90eXBlb2YtdW5kZWZpbmVkICovXG5cbi8qKlxuICogU2FtZSBhcyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGJ1dCB3cmFwcyBpbiBhIHRyeS1jYXRjaCBibG9jay4gSW4gSUUgaXQgaXNcbiAqIG5vdCBzYWZlIHRvIGNhbGwgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBpZiB0aGVyZSBpcyBub3RoaW5nIGZvY3VzZWQuXG4gKlxuICogVGhlIGFjdGl2ZUVsZW1lbnQgd2lsbCBiZSBudWxsIG9ubHkgaWYgdGhlIGRvY3VtZW50IG9yIGRvY3VtZW50IGJvZHkgaXMgbm90XG4gKiB5ZXQgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0gez9ET01Eb2N1bWVudH0gZG9jIERlZmF1bHRzIHRvIGN1cnJlbnQgZG9jdW1lbnQuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH1cbiAqL1xuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudChkb2MpIC8qP0RPTUVsZW1lbnQqL3tcbiAgZG9jID0gZG9jIHx8ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB1bmRlZmluZWQpO1xuICBpZiAodHlwZW9mIGRvYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2MuYWN0aXZlRWxlbWVudCB8fCBkb2MuYm9keTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBkb2MuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gKi9cbmZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICBpZiAoeCA9PT0geSkge1xuICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgLy8gQWRkZWQgdGhlIG5vbnplcm8geSBjaGVjayB0byBtYWtlIEZsb3cgaGFwcHksIGJ1dCBpdCBpcyByZWR1bmRhbnRcbiAgICByZXR1cm4geCAhPT0gMCB8fCB5ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gIH1cbn1cblxuLyoqXG4gKiBQZXJmb3JtcyBlcXVhbGl0eSBieSBpdGVyYXRpbmcgdGhyb3VnaCBrZXlzIG9uIGFuIG9iamVjdCBhbmQgcmV0dXJuaW5nIGZhbHNlXG4gKiB3aGVuIGFueSBrZXkgaGFzIHZhbHVlcyB3aGljaCBhcmUgbm90IHN0cmljdGx5IGVxdWFsIGJldHdlZW4gdGhlIGFyZ3VtZW50cy5cbiAqIFJldHVybnMgdHJ1ZSB3aGVuIHRoZSB2YWx1ZXMgb2YgYWxsIGtleXMgYXJlIHN0cmljdGx5IGVxdWFsLlxuICovXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAoaXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGtleXNBW2ldKSB8fCAhaXMob2JqQVtrZXlzQVtpXV0sIG9iakJba2V5c0FbaV1dKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYWxsb3dFcXVhbDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbnZhciBpc1RleHROb2RlID0gcmVxdWlyZSgnLi9pc1RleHROb2RlJyk7XG5cbi8qZXNsaW50LWRpc2FibGUgbm8tYml0d2lzZSAqL1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIERPTSBub2RlIGNvbnRhaW5zIG9yIGlzIGFub3RoZXIgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZSkge1xuICBpZiAoIW91dGVyTm9kZSB8fCAhaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZSA9PT0gaW5uZXJOb2RlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUoaW5uZXJOb2RlKSkge1xuICAgIHJldHVybiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUucGFyZW50Tm9kZSk7XG4gIH0gZWxzZSBpZiAoJ2NvbnRhaW5zJyBpbiBvdXRlck5vZGUpIHtcbiAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSB7XG4gICAgcmV0dXJuICEhKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihpbm5lck5vZGUpICYgMTYpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY29udGFpbnNOb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZSBpbnB1dC90ZXh0YXJlYSB0byBmb2N1c1xuICovXG5cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IHBhdGhGcm9tVXJsIH0gZnJvbSAnLi9yZXNvbHZlLXVybC5qcyc7XG5cbi8qKlxuICogTGVnYWN5IHNldHRpbmdzLlxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xuY29uc3Qgc2V0dGluZ3MgPSB1bmRlZmluZWQgfHwge307XG5leHBvcnQgY29uc3QgdXNlU2hhZG93ID0gISh3aW5kb3cuU2hhZHlET00pO1xuZXhwb3J0IGNvbnN0IHVzZU5hdGl2ZUNTU1Byb3BlcnRpZXMgPSBCb29sZWFuKCF3aW5kb3cuU2hhZHlDU1MgfHwgd2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcyk7XG5leHBvcnQgY29uc3QgdXNlTmF0aXZlQ3VzdG9tRWxlbWVudHMgPSAhKHdpbmRvdy5jdXN0b21FbGVtZW50cy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKTtcbmV4cG9ydCB7IHNldHRpbmdzIGFzIFNldHRpbmdzIH07XG5cbi8qKlxuICogR2xvYmFsbHkgc2V0dGFibGUgcHJvcGVydHkgdGhhdCBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHRvXG4gKiBgUG9seW1lci5FbGVtZW50TWl4aW5gIGluc3RhbmNlcywgdXNlZnVsIGZvciBiaW5kaW5nIGluIHRlbXBsYXRlcyB0b1xuICogbWFrZSBVUkwncyByZWxhdGl2ZSB0byBhbiBhcHBsaWNhdGlvbidzIHJvb3QuICBEZWZhdWx0cyB0byB0aGUgbWFpblxuICogZG9jdW1lbnQgVVJMLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdXNlcnMuICBJdCBtYXkgYmUgdXNlZnVsIHRvIHNldFxuICogYFBvbHltZXIucm9vdFBhdGhgIHRvIHByb3ZpZGUgYSBzdGFibGUgYXBwbGljYXRpb24gbW91bnQgcGF0aCB3aGVuXG4gKiB1c2luZyBjbGllbnQgc2lkZSByb3V0aW5nLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmxldCByb290UGF0aCA9IHVuZGVmaW5lZCB8fFxuICBwYXRoRnJvbVVybChkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuZXhwb3J0IHsgcm9vdFBhdGggfTtcblxuZXhwb3J0IGNvbnN0IHNldFJvb3RQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICByb290UGF0aCA9IHBhdGg7XG59O1xuXG4vKipcbiAqIEEgZ2xvYmFsIGNhbGxiYWNrIHVzZWQgdG8gc2FuaXRpemUgYW55IHZhbHVlIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgRE9NLiBUaGUgY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuICpcbiAqICAgICBQb2x5bWVyID0ge1xuICogICAgICAgc2FuaXRpemVET01WYWx1ZTogZnVuY3Rpb24odmFsdWUsIG5hbWUsIHR5cGUsIG5vZGUpIHsgLi4uIH1cbiAqICAgICB9XG4gKlxuICogV2hlcmU6XG4gKlxuICogYHZhbHVlYCBpcyB0aGUgdmFsdWUgdG8gc2FuaXRpemUuXG4gKiBgbmFtZWAgaXMgdGhlIG5hbWUgb2YgYW4gYXR0cmlidXRlIG9yIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgaHJlZikuXG4gKiBgdHlwZWAgaW5kaWNhdGVzIHdoZXJlIHRoZSB2YWx1ZSBpcyBiZWluZyBpbnNlcnRlZDogb25lIG9mIHByb3BlcnR5LCBhdHRyaWJ1dGUsIG9yIHRleHQuXG4gKiBgbm9kZWAgaXMgdGhlIG5vZGUgd2hlcmUgdGhlIHZhbHVlIGlzIGJlaW5nIGluc2VydGVkLlxuICpcbiAqIEB0eXBlIHsoZnVuY3Rpb24oKixzdHJpbmcsc3RyaW5nLE5vZGUpOiopfHVuZGVmaW5lZH1cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmxldCBzYW5pdGl6ZURPTVZhbHVlID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgeyBzYW5pdGl6ZURPTVZhbHVlIH07XG5cbmV4cG9ydCBjb25zdCBzZXRTYW5pdGl6ZURPTVZhbHVlID0gZnVuY3Rpb24obmV3U2FuaXRpemVET01WYWx1ZSkge1xuICBzYW5pdGl6ZURPTVZhbHVlID0gbmV3U2FuaXRpemVET01WYWx1ZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc2V0dGluZ3MuanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7dmFyIG09cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIiksbj1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlPYmplY3RcIikscD1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlGdW5jdGlvblwiKSxxPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSxyPXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKTo2MDEwMyx0PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuY2FsbFwiKTo2MDEwNCx1PXE/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucmV0dXJuXCIpOjYwMTA1LHY9cT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5wb3J0YWxcIik6NjAxMDYsdz1xP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LHg9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sLml0ZXJhdG9yO1xuZnVuY3Rpb24geShhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGU9XCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnRcXHgzZFwiK2EsYz0wO2M8YjtjKyspZSs9XCJcXHgyNmFyZ3NbXVxceDNkXCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tjKzFdKTtiPUVycm9yKGUrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtiLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7Yi5mcmFtZXNUb1BvcD0xO3Rocm93IGI7fVxudmFyIHo9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319O2Z1bmN0aW9uIEEoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8en1BLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9O0EucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIiE9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmbnVsbCE9YT95KFwiODVcIik6dm9pZCAwO3RoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcyxhLGIsXCJzZXRTdGF0ZVwiKX07QS5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGEsXCJmb3JjZVVwZGF0ZVwiKX07XG5mdW5jdGlvbiBCKGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHp9ZnVuY3Rpb24gQygpe31DLnByb3RvdHlwZT1BLnByb3RvdHlwZTt2YXIgRD1CLnByb3RvdHlwZT1uZXcgQztELmNvbnN0cnVjdG9yPUI7bShELEEucHJvdG90eXBlKTtELmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwO2Z1bmN0aW9uIEUoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8en12YXIgRj1FLnByb3RvdHlwZT1uZXcgQztGLmNvbnN0cnVjdG9yPUU7bShGLEEucHJvdG90eXBlKTtGLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudD0hMDtGLnJlbmRlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BzLmNoaWxkcmVufTt2YXIgRz17Y3VycmVudDpudWxsfSxIPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksST17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gSihhLGIsZSl7dmFyIGMsZD17fSxnPW51bGwsaz1udWxsO2lmKG51bGwhPWIpZm9yKGMgaW4gdm9pZCAwIT09Yi5yZWYmJihrPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGc9XCJcIitiLmtleSksYilILmNhbGwoYixjKSYmIUkuaGFzT3duUHJvcGVydHkoYykmJihkW2NdPWJbY10pO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZilkLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGYpe2Zvcih2YXIgaD1BcnJheShmKSxsPTA7bDxmO2wrKyloW2xdPWFyZ3VtZW50c1tsKzJdO2QuY2hpbGRyZW49aH1pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoYyBpbiBmPWEuZGVmYXVsdFByb3BzLGYpdm9pZCAwPT09ZFtjXSYmKGRbY109ZltjXSk7cmV0dXJueyQkdHlwZW9mOnIsdHlwZTphLGtleTpnLHJlZjprLHByb3BzOmQsX293bmVyOkcuY3VycmVudH19ZnVuY3Rpb24gSyhhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09cn1cbmZ1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCJcXHgzZFwiOlwiXFx4M2QwXCIsXCI6XCI6XCJcXHgzZDJcIn07cmV0dXJuXCIkXCIrKFwiXCIrYSkucmVwbGFjZSgvWz06XS9nLGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfSl9dmFyIEw9L1xcLysvZyxNPVtdO2Z1bmN0aW9uIE4oYSxiLGUsYyl7aWYoTS5sZW5ndGgpe3ZhciBkPU0ucG9wKCk7ZC5yZXN1bHQ9YTtkLmtleVByZWZpeD1iO2QuZnVuYz1lO2QuY29udGV4dD1jO2QuY291bnQ9MDtyZXR1cm4gZH1yZXR1cm57cmVzdWx0OmEsa2V5UHJlZml4OmIsZnVuYzplLGNvbnRleHQ6Yyxjb3VudDowfX1mdW5jdGlvbiBPKGEpe2EucmVzdWx0PW51bGw7YS5rZXlQcmVmaXg9bnVsbDthLmZ1bmM9bnVsbDthLmNvbnRleHQ9bnVsbDthLmNvdW50PTA7MTA+TS5sZW5ndGgmJk0ucHVzaChhKX1cbmZ1bmN0aW9uIFAoYSxiLGUsYyl7dmFyIGQ9dHlwZW9mIGE7aWYoXCJ1bmRlZmluZWRcIj09PWR8fFwiYm9vbGVhblwiPT09ZClhPW51bGw7dmFyIGc9ITE7aWYobnVsbD09PWEpZz0hMDtlbHNlIHN3aXRjaChkKXtjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm51bWJlclwiOmc9ITA7YnJlYWs7Y2FzZSBcIm9iamVjdFwiOnN3aXRjaChhLiQkdHlwZW9mKXtjYXNlIHI6Y2FzZSB0OmNhc2UgdTpjYXNlIHY6Zz0hMH19aWYoZylyZXR1cm4gZShjLGEsXCJcIj09PWI/XCIuXCIrUShhLDApOmIpLDE7Zz0wO2I9XCJcIj09PWI/XCIuXCI6YitcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgaz0wO2s8YS5sZW5ndGg7aysrKXtkPWFba107dmFyIGY9YitRKGQsayk7Zys9UChkLGYsZSxjKX1lbHNlIGlmKG51bGw9PT1hfHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGE/Zj1udWxsOihmPXgmJmFbeF18fGFbXCJAQGl0ZXJhdG9yXCJdLGY9XCJmdW5jdGlvblwiPT09dHlwZW9mIGY/ZjpudWxsKSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZilmb3IoYT1cbmYuY2FsbChhKSxrPTA7IShkPWEubmV4dCgpKS5kb25lOylkPWQudmFsdWUsZj1iK1EoZCxrKyspLGcrPVAoZCxmLGUsYyk7ZWxzZVwib2JqZWN0XCI9PT1kJiYoZT1cIlwiK2EseShcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PWU/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhhKS5qb2luKFwiLCBcIikrXCJ9XCI6ZSxcIlwiKSk7cmV0dXJuIGd9ZnVuY3Rpb24gUShhLGIpe3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmbnVsbCE9PWEmJm51bGwhPWEua2V5P2VzY2FwZShhLmtleSk6Yi50b1N0cmluZygzNil9ZnVuY3Rpb24gUihhLGIpe2EuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyl9XG5mdW5jdGlvbiBTKGEsYixlKXt2YXIgYz1hLnJlc3VsdCxkPWEua2V5UHJlZml4O2E9YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKTtBcnJheS5pc0FycmF5KGEpP1QoYSxjLGUscC50aGF0UmV0dXJuc0FyZ3VtZW50KTpudWxsIT1hJiYoSyhhKSYmKGI9ZCsoIWEua2V5fHxiJiZiLmtleT09PWEua2V5P1wiXCI6KFwiXCIrYS5rZXkpLnJlcGxhY2UoTCxcIiRcXHgyNi9cIikrXCIvXCIpK2UsYT17JCR0eXBlb2Y6cix0eXBlOmEudHlwZSxrZXk6YixyZWY6YS5yZWYscHJvcHM6YS5wcm9wcyxfb3duZXI6YS5fb3duZXJ9KSxjLnB1c2goYSkpfWZ1bmN0aW9uIFQoYSxiLGUsYyxkKXt2YXIgZz1cIlwiO251bGwhPWUmJihnPShcIlwiK2UpLnJlcGxhY2UoTCxcIiRcXHgyNi9cIikrXCIvXCIpO2I9TihiLGcsYyxkKTtudWxsPT1hfHxQKGEsXCJcIixTLGIpO08oYil9XG52YXIgVT17Q2hpbGRyZW46e21hcDpmdW5jdGlvbihhLGIsZSl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgYz1bXTtUKGEsYyxudWxsLGIsZSk7cmV0dXJuIGN9LGZvckVhY2g6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7Yj1OKG51bGwsbnVsbCxiLGUpO251bGw9PWF8fFAoYSxcIlwiLFIsYik7TyhiKX0sY291bnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/MDpQKGEsXCJcIixwLnRoYXRSZXR1cm5zTnVsbCxudWxsKX0sdG9BcnJheTpmdW5jdGlvbihhKXt2YXIgYj1bXTtUKGEsYixudWxsLHAudGhhdFJldHVybnNBcmd1bWVudCk7cmV0dXJuIGJ9LG9ubHk6ZnVuY3Rpb24oYSl7SyhhKT92b2lkIDA6eShcIjE0M1wiKTtyZXR1cm4gYX19LENvbXBvbmVudDpBLFB1cmVDb21wb25lbnQ6Qix1bnN0YWJsZV9Bc3luY0NvbXBvbmVudDpFLEZyYWdtZW50OncsY3JlYXRlRWxlbWVudDpKLGNsb25lRWxlbWVudDpmdW5jdGlvbihhLGIsZSl7dmFyIGM9bSh7fSxhLnByb3BzKSxcbmQ9YS5rZXksZz1hLnJlZixrPWEuX293bmVyO2lmKG51bGwhPWIpe3ZvaWQgMCE9PWIucmVmJiYoZz1iLnJlZixrPUcuY3VycmVudCk7dm9pZCAwIT09Yi5rZXkmJihkPVwiXCIrYi5rZXkpO2lmKGEudHlwZSYmYS50eXBlLmRlZmF1bHRQcm9wcyl2YXIgZj1hLnR5cGUuZGVmYXVsdFByb3BzO2ZvcihoIGluIGIpSC5jYWxsKGIsaCkmJiFJLmhhc093blByb3BlcnR5KGgpJiYoY1toXT12b2lkIDA9PT1iW2hdJiZ2b2lkIDAhPT1mP2ZbaF06YltoXSl9dmFyIGg9YXJndW1lbnRzLmxlbmd0aC0yO2lmKDE9PT1oKWMuY2hpbGRyZW49ZTtlbHNlIGlmKDE8aCl7Zj1BcnJheShoKTtmb3IodmFyIGw9MDtsPGg7bCsrKWZbbF09YXJndW1lbnRzW2wrMl07Yy5jaGlsZHJlbj1mfXJldHVybnskJHR5cGVvZjpyLHR5cGU6YS50eXBlLGtleTpkLHJlZjpnLHByb3BzOmMsX293bmVyOmt9fSxjcmVhdGVGYWN0b3J5OmZ1bmN0aW9uKGEpe3ZhciBiPUouYmluZChudWxsLGEpO2IudHlwZT1hO3JldHVybiBifSxcbmlzVmFsaWRFbGVtZW50OkssdmVyc2lvbjpcIjE2LjIuMFwiLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntSZWFjdEN1cnJlbnRPd25lcjpHLGFzc2lnbjptfX0sVj1PYmplY3QuZnJlZXplKHtkZWZhdWx0OlV9KSxXPVYmJlV8fFY7bW9kdWxlLmV4cG9ydHM9V1tcImRlZmF1bHRcIl0/V1tcImRlZmF1bHRcIl06VztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjIuMFxuICogcmVhY3QuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMi4wJztcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuZnVuY3Rpb24gd2Fybk5vb3AocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAge1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IHB1YmxpY0luc3RhbmNlLmNvbnN0cnVjdG9yO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29uc3RydWN0b3IgJiYgKGNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lIHx8IGNvbnN0cnVjdG9yLm5hbWUpIHx8ICdSZWFjdENsYXNzJztcbiAgICB2YXIgd2FybmluZ0tleSA9IGNvbXBvbmVudE5hbWUgKyAnLicgKyBjYWxsZXJOYW1lO1xuICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgd2FybmluZyhmYWxzZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlIGNoZWNrIHRoZSBjb2RlIGZvciB0aGUgJXMgY29tcG9uZW50LicsIGNhbGxlck5hbWUsIGNhbGxlck5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBhYnN0cmFjdCBBUEkgZm9yIGFuIHVwZGF0ZSBxdWV1ZS5cbiAqL1xudmFyIFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlID0ge1xuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNvbXBsZXRlU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IE5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFN0YXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3NldFN0YXRlJyk7XG4gIH1cbn07XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIENvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuQ29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLnNldFN0YXRlID0gZnVuY3Rpb24gKHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2spIHtcbiAgISh0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgcGFydGlhbFN0YXRlID09PSAnZnVuY3Rpb24nIHx8IHBhcnRpYWxTdGF0ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzLicpIDogdm9pZCAwO1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsIHBhcnRpYWxTdGF0ZSwgY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuZm9yY2VVcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLCBjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgQVBJcy4gVGhlc2UgQVBJcyB1c2VkIHRvIGV4aXN0IG9uIGNsYXNzaWMgUmVhY3QgY2xhc3NlcyBidXQgc2luY2VcbiAqIHdlIHdvdWxkIGxpa2UgdG8gZGVwcmVjYXRlIHRoZW0sIHdlJ3JlIG5vdCBnb2luZyB0byBtb3ZlIHRoZW0gb3ZlciB0byB0aGlzXG4gKiBtb2Rlcm4gYmFzZSBjbGFzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZ2V0dGVyIHRoYXQgd2FybnMgaWYgaXQncyBhY2Nlc3NlZC5cbiAqL1xue1xuICB2YXIgZGVwcmVjYXRlZEFQSXMgPSB7XG4gICAgaXNNb3VudGVkOiBbJ2lzTW91bnRlZCcsICdJbnN0ZWFkLCBtYWtlIHN1cmUgdG8gY2xlYW4gdXAgc3Vic2NyaXB0aW9ucyBhbmQgcGVuZGluZyByZXF1ZXN0cyBpbiAnICsgJ2NvbXBvbmVudFdpbGxVbm1vdW50IHRvIHByZXZlbnQgbWVtb3J5IGxlYWtzLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddXG4gIH07XG4gIHZhciBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcgPSBmdW5jdGlvbiAobWV0aG9kTmFtZSwgaW5mbykge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICclcyguLi4pIGlzIGRlcHJlY2F0ZWQgaW4gcGxhaW4gSmF2YVNjcmlwdCBSZWFjdCBjbGFzc2VzLiAlcycsIGluZm9bMF0sIGluZm9bMV0pO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuICBmb3IgKHZhciBmbk5hbWUgaW4gZGVwcmVjYXRlZEFQSXMpIHtcbiAgICBpZiAoZGVwcmVjYXRlZEFQSXMuaGFzT3duUHJvcGVydHkoZm5OYW1lKSkge1xuICAgICAgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nKGZuTmFtZSwgZGVwcmVjYXRlZEFQSXNbZm5OYW1lXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQmFzZSBjbGFzcyBoZWxwZXJzIGZvciB0aGUgdXBkYXRpbmcgc3RhdGUgb2YgYSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIFB1cmVDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbmZ1bmN0aW9uIENvbXBvbmVudER1bW15KCkge31cbkNvbXBvbmVudER1bW15LnByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG52YXIgcHVyZUNvbXBvbmVudFByb3RvdHlwZSA9IFB1cmVDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gUHVyZUNvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihwdXJlQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuXG5mdW5jdGlvbiBBc3luY0NvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxudmFyIGFzeW5jQ29tcG9uZW50UHJvdG90eXBlID0gQXN5bmNDb21wb25lbnQucHJvdG90eXBlID0gbmV3IENvbXBvbmVudER1bW15KCk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEFzeW5jQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKGFzeW5jQ29tcG9uZW50UHJvdG90eXBlLCBDb21wb25lbnQucHJvdG90eXBlKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9IHRydWU7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLnByb3BzLmNoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBLZWVwcyB0cmFjayBvZiB0aGUgY3VycmVudCBvd25lci5cbiAqXG4gKiBUaGUgY3VycmVudCBvd25lciBpcyB0aGUgY29tcG9uZW50IHdobyBzaG91bGQgb3duIGFueSBjb21wb25lbnRzIHRoYXQgYXJlXG4gKiBjdXJyZW50bHkgYmVpbmcgY29uc3RydWN0ZWQuXG4gKi9cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAdHlwZSB7UmVhY3RDb21wb25lbnR9XG4gICAqL1xuICBjdXJyZW50OiBudWxsXG59O1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTtcbiAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcbiAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCBwcm9kdWNlcyBSZWFjdEVsZW1lbnRzIG9mIGEgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZmFjdG9yeVxuICovXG5cblxuZnVuY3Rpb24gY2xvbmVBbmRSZXBsYWNlS2V5KG9sZEVsZW1lbnQsIG5ld0tleSkge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG5ld0tleSwgb2xkRWxlbWVudC5yZWYsIG9sZEVsZW1lbnQuX3NlbGYsIG9sZEVsZW1lbnQuX3NvdXJjZSwgb2xkRWxlbWVudC5fb3duZXIsIG9sZEVsZW1lbnQucHJvcHMpO1xuXG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG4vKipcbiAqIENsb25lIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IHVzaW5nIGVsZW1lbnQgYXMgdGhlIHN0YXJ0aW5nIHBvaW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjbG9uZWVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gY2xvbmVFbGVtZW50KGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gX2Fzc2lnbih7fSwgZWxlbWVudC5wcm9wcyk7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgLy8gU2VsZiBpcyBwcmVzZXJ2ZWQgc2luY2UgdGhlIG93bmVyIGlzIHByZXNlcnZlZC5cbiAgdmFyIHNlbGYgPSBlbGVtZW50Ll9zZWxmO1xuICAvLyBTb3VyY2UgaXMgcHJlc2VydmVkIHNpbmNlIGNsb25lRWxlbWVudCBpcyB1bmxpa2VseSB0byBiZSB0YXJnZXRlZCBieSBhXG4gIC8vIHRyYW5zcGlsZXIsIGFuZCB0aGUgb3JpZ2luYWwgc291cmNlIGlzIHByb2JhYmx5IGEgYmV0dGVyIGluZGljYXRvciBvZiB0aGVcbiAgLy8gdHJ1ZSBvd25lci5cbiAgdmFyIHNvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcblxuICAvLyBPd25lciB3aWxsIGJlIHByZXNlcnZlZCwgdW5sZXNzIHJlZiBpcyBvdmVycmlkZGVuXG4gIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICAvLyBTaWxlbnRseSBzdGVhbCB0aGUgcmVmIGZyb20gdGhlIHBhcmVudC5cbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgb3ZlcnJpZGUgZXhpc3RpbmcgcHJvcHNcbiAgICB2YXIgZGVmYXVsdFByb3BzO1xuICAgIGlmIChlbGVtZW50LnR5cGUgJiYgZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZGVmYXVsdFByb3BzID0gZWxlbWVudC50eXBlLmRlZmF1bHRQcm9wcztcbiAgICB9XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0UHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGRlZmF1bHRQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIENoaWxkcmVuIGNhbiBiZSBtb3JlIHRoYW4gb25lIGFyZ3VtZW50LCBhbmQgdGhvc2UgYXJlIHRyYW5zZmVycmVkIG9udG9cbiAgLy8gdGhlIG5ld2x5IGFsbG9jYXRlZCBwcm9wcyBvYmplY3QuXG4gIHZhciBjaGlsZHJlbkxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGggLSAyO1xuICBpZiAoY2hpbGRyZW5MZW5ndGggPT09IDEpIHtcbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICB9IGVsc2UgaWYgKGNoaWxkcmVuTGVuZ3RoID4gMSkge1xuICAgIHZhciBjaGlsZEFycmF5ID0gQXJyYXkoY2hpbGRyZW5MZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW5MZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGRBcnJheVtpXSA9IGFyZ3VtZW50c1tpICsgMl07XG4gICAgfVxuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRBcnJheTtcbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQoZWxlbWVudC50eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIGNvbXBvbmVudC5cbiAqIEBmaW5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudChvYmplY3QpIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxue1xuICAvLyBDb21wb25lbnQgdGhhdCBpcyBiZWluZyB3b3JrZWQgb25cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICByZXR1cm4gaW1wbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTVUJTRVBBUkFUT1IgPSAnOic7XG5cbi8qKlxuICogRXNjYXBlIGFuZCB3cmFwIGtleSBzbyBpdCBpcyBzYWZlIHRvIHVzZSBhcyBhIHJlYWN0aWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBlc2NhcGVkIGtleS5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlKGtleSkge1xuICB2YXIgZXNjYXBlUmVnZXggPSAvWz06XS9nO1xuICB2YXIgZXNjYXBlckxvb2t1cCA9IHtcbiAgICAnPSc6ICc9MCcsXG4gICAgJzonOiAnPTInXG4gIH07XG4gIHZhciBlc2NhcGVkU3RyaW5nID0gKCcnICsga2V5KS5yZXBsYWNlKGVzY2FwZVJlZ2V4LCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICByZXR1cm4gZXNjYXBlckxvb2t1cFttYXRjaF07XG4gIH0pO1xuXG4gIHJldHVybiAnJCcgKyBlc2NhcGVkU3RyaW5nO1xufVxuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKy9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICckJi8nKTtcbn1cblxudmFyIFBPT0xfU0laRSA9IDEwO1xudmFyIHRyYXZlcnNlQ29udGV4dFBvb2wgPSBbXTtcbmZ1bmN0aW9uIGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IHRyYXZlcnNlQ29udGV4dFBvb2wucG9wKCk7XG4gICAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG1hcFJlc3VsdDtcbiAgICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbWFwRnVuY3Rpb247XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBtYXBDb250ZXh0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gICAgcmV0dXJuIHRyYXZlcnNlQ29udGV4dDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVzdWx0OiBtYXBSZXN1bHQsXG4gICAgICBrZXlQcmVmaXg6IGtleVByZWZpeCxcbiAgICAgIGZ1bmM6IG1hcEZ1bmN0aW9uLFxuICAgICAgY29udGV4dDogbWFwQ29udGV4dCxcbiAgICAgIGNvdW50OiAwXG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCkge1xuICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5mdW5jID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvbnRleHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGggPCBQT09MX1NJWkUpIHtcbiAgICB0cmF2ZXJzZUNvbnRleHRQb29sLnB1c2godHJhdmVyc2VDb250ZXh0KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHshc3RyaW5nfSBuYW1lU29GYXIgTmFtZSBvZiB0aGUga2V5IHBhdGggc28gZmFyLlxuICogQHBhcmFtIHshZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIGludm9rZSB3aXRoIGVhY2ggY2hpbGQgZm91bmQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgVXNlZCB0byBwYXNzIGluZm9ybWF0aW9uIHRocm91Z2hvdXQgdGhlIHRyYXZlcnNhbFxuICogcHJvY2Vzcy5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgbmFtZVNvRmFyLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIHZhciB0eXBlID0gdHlwZW9mIGNoaWxkcmVuO1xuXG4gIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCB0eXBlID09PSAnYm9vbGVhbicpIHtcbiAgICAvLyBBbGwgb2YgdGhlIGFib3ZlIGFyZSBwZXJjZWl2ZWQgYXMgbnVsbC5cbiAgICBjaGlsZHJlbiA9IG51bGw7XG4gIH1cblxuICB2YXIgaW52b2tlQ2FsbGJhY2sgPSBmYWxzZTtcblxuICBpZiAoY2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgaW52b2tlQ2FsbGJhY2sgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHN3aXRjaCAoY2hpbGRyZW4uJCR0eXBlb2YpIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgICBpbnZva2VDYWxsYmFjayA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoaW52b2tlQ2FsbGJhY2spIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG57XG4gIHZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgdmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG5cbiAgdmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIpKTtcbiAgICB9XG4gICAgc3RhY2sgKz0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBWQUxJRF9GUkFHTUVOVF9QUk9QUyA9IG5ldyBNYXAoW1snY2hpbGRyZW4nLCB0cnVlXSwgWydrZXknLCB0cnVlXV0pO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIHZhciBwcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXM7XG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0pO1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbiAgfSBlbHNlIGlmIChjb21wb25lbnRDbGFzcy5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0NvbXBvbmVudCAlcyBkZWNsYXJlZCBgUHJvcFR5cGVzYCBpbnN0ZWFkIG9mIGBwcm9wVHlwZXNgLiBEaWQgeW91IG1pc3NwZWxsIHRoZSBwcm9wZXJ0eSBhc3NpZ25tZW50PycsIG5hbWUgfHwgJ1Vua25vd24nKTtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZnJhZ21lbnQ7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIVZBTElEX0ZSQUdNRU5UX1BST1BTLmhhcyhrZXkpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB0eXBlID09PSAnbnVtYmVyJztcbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyAmJiB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZhY3RvcnlXaXRoVmFsaWRhdGlvbih0eXBlKSB7XG4gIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIExlZ2FjeSBob29rIFRPRE86IFdhcm4gaWYgdGhpcyBpcyBhY2Nlc3NlZFxuICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICd0eXBlJywge1xuICAgICAgICAgIHZhbHVlOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiB2YWxpZGF0ZWRGYWN0b3J5O1xufVxuXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbihlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBjbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YWxpZGF0ZUNoaWxkS2V5cyhhcmd1bWVudHNbaV0sIG5ld0VsZW1lbnQudHlwZSk7XG4gIH1cbiAgdmFsaWRhdGVQcm9wVHlwZXMobmV3RWxlbWVudCk7XG4gIHJldHVybiBuZXdFbGVtZW50O1xufVxuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcbiAgdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6IEFzeW5jQ29tcG9uZW50LFxuXG4gIEZyYWdtZW50OiBSRUFDVF9GUkFHTUVOVF9UWVBFLFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbntcbiAgX2Fzc2lnbihSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCwge1xuICAgIC8vIFRoZXNlIHNob3VsZCBub3QgYmUgaW5jbHVkZWQgaW4gcHJvZHVjdGlvbi5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lOiBSZWFjdERlYnVnQ3VycmVudEZyYW1lLFxuICAgIC8vIFNoaW0gZm9yIFJlYWN0IERPTSAxNi4wLjAgd2hpY2ggc3RpbGwgZGVzdHJ1Y3R1cmVkIChidXQgbm90IHVzZWQpIHRoaXMuXG4gICAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LjAuXG4gICAgUmVhY3RDb21wb25lbnRUcmVlSG9vazoge31cbiAgfSk7XG59XG5cblxuXG52YXIgUmVhY3QkMiA9IE9iamVjdC5mcmVlemUoe1xuXHRkZWZhdWx0OiBSZWFjdFxufSk7XG5cbnZhciBSZWFjdCQzID0gKCBSZWFjdCQyICYmIFJlYWN0ICkgfHwgUmVhY3QkMjtcblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3QgPSBSZWFjdCQzWydkZWZhdWx0J10gPyBSZWFjdCQzWydkZWZhdWx0J10gOiBSZWFjdCQzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlYWN0O1xuICB9KSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMi4wXG4gKiByZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4vKlxuIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuKi9cbid1c2Ugc3RyaWN0Jzt2YXIgYWE9cmVxdWlyZShcInJlYWN0XCIpLGw9cmVxdWlyZShcImZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpLEI9cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIiksQz1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlGdW5jdGlvblwiKSxiYT1yZXF1aXJlKFwiZmJqcy9saWIvRXZlbnRMaXN0ZW5lclwiKSxkYT1yZXF1aXJlKFwiZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudFwiKSxlYT1yZXF1aXJlKFwiZmJqcy9saWIvc2hhbGxvd0VxdWFsXCIpLGZhPXJlcXVpcmUoXCJmYmpzL2xpYi9jb250YWluc05vZGVcIiksaWE9cmVxdWlyZShcImZianMvbGliL2ZvY3VzTm9kZVwiKSxEPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eU9iamVjdFwiKTtcbmZ1bmN0aW9uIEUoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxjPVwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50XFx4M2RcIithLGQ9MDtkPGI7ZCsrKWMrPVwiXFx4MjZhcmdzW11cXHgzZFwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbZCsxXSk7Yj1FcnJvcihjK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7Yi5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwiO2IuZnJhbWVzVG9Qb3A9MTt0aHJvdyBiO31hYT92b2lkIDA6RShcIjIyN1wiKTtcbnZhciBvYT17Y2hpbGRyZW46ITAsZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6ITAsZGVmYXVsdFZhbHVlOiEwLGRlZmF1bHRDaGVja2VkOiEwLGlubmVySFRNTDohMCxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6ITAsc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiEwLHN0eWxlOiEwfTtmdW5jdGlvbiBwYShhLGIpe3JldHVybihhJmIpPT09Yn1cbnZhciB0YT17TVVTVF9VU0VfUFJPUEVSVFk6MSxIQVNfQk9PTEVBTl9WQUxVRTo0LEhBU19OVU1FUklDX1ZBTFVFOjgsSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6MjQsSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTozMixIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6NjQsaW5qZWN0RE9NUHJvcGVydHlDb25maWc6ZnVuY3Rpb24oYSl7dmFyIGI9dGEsYz1hLlByb3BlcnRpZXN8fHt9LGQ9YS5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzfHx7fSxlPWEuRE9NQXR0cmlidXRlTmFtZXN8fHt9O2E9YS5ET01NdXRhdGlvbk1ldGhvZHN8fHt9O2Zvcih2YXIgZiBpbiBjKXt1YS5oYXNPd25Qcm9wZXJ0eShmKT9FKFwiNDhcIixmKTp2b2lkIDA7dmFyIGc9Zi50b0xvd2VyQ2FzZSgpLGg9Y1tmXTtnPXthdHRyaWJ1dGVOYW1lOmcsYXR0cmlidXRlTmFtZXNwYWNlOm51bGwscHJvcGVydHlOYW1lOmYsbXV0YXRpb25NZXRob2Q6bnVsbCxtdXN0VXNlUHJvcGVydHk6cGEoaCxiLk1VU1RfVVNFX1BST1BFUlRZKSxcbmhhc0Jvb2xlYW5WYWx1ZTpwYShoLGIuSEFTX0JPT0xFQU5fVkFMVUUpLGhhc051bWVyaWNWYWx1ZTpwYShoLGIuSEFTX05VTUVSSUNfVkFMVUUpLGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOnBhKGgsYi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpwYShoLGIuSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksaGFzU3RyaW5nQm9vbGVhblZhbHVlOnBhKGgsYi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpfTsxPj1nLmhhc0Jvb2xlYW5WYWx1ZStnLmhhc051bWVyaWNWYWx1ZStnLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU/dm9pZCAwOkUoXCI1MFwiLGYpO2UuaGFzT3duUHJvcGVydHkoZikmJihnLmF0dHJpYnV0ZU5hbWU9ZVtmXSk7ZC5oYXNPd25Qcm9wZXJ0eShmKSYmKGcuYXR0cmlidXRlTmFtZXNwYWNlPWRbZl0pO2EuaGFzT3duUHJvcGVydHkoZikmJihnLm11dGF0aW9uTWV0aG9kPWFbZl0pO3VhW2ZdPWd9fX0sdWE9e307XG5mdW5jdGlvbiB2YShhLGIpe2lmKG9hLmhhc093blByb3BlcnR5KGEpfHwyPGEubGVuZ3RoJiYoXCJvXCI9PT1hWzBdfHxcIk9cIj09PWFbMF0pJiYoXCJuXCI9PT1hWzFdfHxcIk5cIj09PWFbMV0pKXJldHVybiExO2lmKG51bGw9PT1iKXJldHVybiEwO3N3aXRjaCh0eXBlb2YgYil7Y2FzZSBcImJvb2xlYW5cIjpyZXR1cm4gb2EuaGFzT3duUHJvcGVydHkoYSk/YT0hMDooYj13YShhKSk/YT1iLmhhc0Jvb2xlYW5WYWx1ZXx8Yi5oYXNTdHJpbmdCb29sZWFuVmFsdWV8fGIuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTooYT1hLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCw1KSxhPVwiZGF0YS1cIj09PWF8fFwiYXJpYS1cIj09PWEpLGE7Y2FzZSBcInVuZGVmaW5lZFwiOmNhc2UgXCJudW1iZXJcIjpjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm9iamVjdFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIHdhKGEpe3JldHVybiB1YS5oYXNPd25Qcm9wZXJ0eShhKT91YVthXTpudWxsfVxudmFyIHhhPXRhLHlhPXhhLk1VU1RfVVNFX1BST1BFUlRZLEs9eGEuSEFTX0JPT0xFQU5fVkFMVUUsemE9eGEuSEFTX05VTUVSSUNfVkFMVUUsQWE9eGEuSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsQmE9eGEuSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxDYT14YS5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsRGE9e1Byb3BlcnRpZXM6e2FsbG93RnVsbFNjcmVlbjpLLGFzeW5jOkssYXV0b0ZvY3VzOkssYXV0b1BsYXk6SyxjYXB0dXJlOkJhLGNoZWNrZWQ6eWF8Syxjb2xzOkFhLGNvbnRlbnRFZGl0YWJsZTpDYSxjb250cm9sczpLLFwiZGVmYXVsdFwiOkssZGVmZXI6SyxkaXNhYmxlZDpLLGRvd25sb2FkOkJhLGRyYWdnYWJsZTpDYSxmb3JtTm9WYWxpZGF0ZTpLLGhpZGRlbjpLLGxvb3A6SyxtdWx0aXBsZTp5YXxLLG11dGVkOnlhfEssbm9WYWxpZGF0ZTpLLG9wZW46SyxwbGF5c0lubGluZTpLLHJlYWRPbmx5OksscmVxdWlyZWQ6SyxyZXZlcnNlZDpLLHJvd3M6QWEscm93U3Bhbjp6YSxcbnNjb3BlZDpLLHNlYW1sZXNzOkssc2VsZWN0ZWQ6eWF8SyxzaXplOkFhLHN0YXJ0OnphLHNwYW46QWEsc3BlbGxDaGVjazpDYSxzdHlsZTowLHRhYkluZGV4OjAsaXRlbVNjb3BlOkssYWNjZXB0Q2hhcnNldDowLGNsYXNzTmFtZTowLGh0bWxGb3I6MCxodHRwRXF1aXY6MCx2YWx1ZTpDYX0sRE9NQXR0cmlidXRlTmFtZXM6e2FjY2VwdENoYXJzZXQ6XCJhY2NlcHQtY2hhcnNldFwiLGNsYXNzTmFtZTpcImNsYXNzXCIsaHRtbEZvcjpcImZvclwiLGh0dHBFcXVpdjpcImh0dHAtZXF1aXZcIn0sRE9NTXV0YXRpb25NZXRob2RzOnt2YWx1ZTpmdW5jdGlvbihhLGIpe2lmKG51bGw9PWIpcmV0dXJuIGEucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7XCJudW1iZXJcIiE9PWEudHlwZXx8ITE9PT1hLmhhc0F0dHJpYnV0ZShcInZhbHVlXCIpP2Euc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK2IpOmEudmFsaWRpdHkmJiFhLnZhbGlkaXR5LmJhZElucHV0JiZhLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9PWEmJlxuYS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFwiXCIrYil9fX0sRWE9eGEuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLE09e3hsaW5rOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLHhtbDpcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwifSxHYT17UHJvcGVydGllczp7YXV0b1JldmVyc2U6RWEsZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDpFYSxwcmVzZXJ2ZUFscGhhOkVhfSxET01BdHRyaWJ1dGVOYW1lczp7YXV0b1JldmVyc2U6XCJhdXRvUmV2ZXJzZVwiLGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6XCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCIscHJlc2VydmVBbHBoYTpcInByZXNlcnZlQWxwaGFcIn0sRE9NQXR0cmlidXRlTmFtZXNwYWNlczp7eGxpbmtBY3R1YXRlOk0ueGxpbmsseGxpbmtBcmNyb2xlOk0ueGxpbmsseGxpbmtIcmVmOk0ueGxpbmsseGxpbmtSb2xlOk0ueGxpbmsseGxpbmtTaG93Ok0ueGxpbmsseGxpbmtUaXRsZTpNLnhsaW5rLHhsaW5rVHlwZTpNLnhsaW5rLFxueG1sQmFzZTpNLnhtbCx4bWxMYW5nOk0ueG1sLHhtbFNwYWNlOk0ueG1sfX0sSGE9L1tcXC1cXDpdKFthLXpdKS9nO2Z1bmN0aW9uIElhKGEpe3JldHVybiBhWzFdLnRvVXBwZXJDYXNlKCl9XG5cImFjY2VudC1oZWlnaHQgYWxpZ25tZW50LWJhc2VsaW5lIGFyYWJpYy1mb3JtIGJhc2VsaW5lLXNoaWZ0IGNhcC1oZWlnaHQgY2xpcC1wYXRoIGNsaXAtcnVsZSBjb2xvci1pbnRlcnBvbGF0aW9uIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyBjb2xvci1wcm9maWxlIGNvbG9yLXJlbmRlcmluZyBkb21pbmFudC1iYXNlbGluZSBlbmFibGUtYmFja2dyb3VuZCBmaWxsLW9wYWNpdHkgZmlsbC1ydWxlIGZsb29kLWNvbG9yIGZsb29kLW9wYWNpdHkgZm9udC1mYW1pbHkgZm9udC1zaXplIGZvbnQtc2l6ZS1hZGp1c3QgZm9udC1zdHJldGNoIGZvbnQtc3R5bGUgZm9udC12YXJpYW50IGZvbnQtd2VpZ2h0IGdseXBoLW5hbWUgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCBnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCBob3Jpei1hZHYteCBob3Jpei1vcmlnaW4teCBpbWFnZS1yZW5kZXJpbmcgbGV0dGVyLXNwYWNpbmcgbGlnaHRpbmctY29sb3IgbWFya2VyLWVuZCBtYXJrZXItbWlkIG1hcmtlci1zdGFydCBvdmVybGluZS1wb3NpdGlvbiBvdmVybGluZS10aGlja25lc3MgcGFpbnQtb3JkZXIgcGFub3NlLTEgcG9pbnRlci1ldmVudHMgcmVuZGVyaW5nLWludGVudCBzaGFwZS1yZW5kZXJpbmcgc3RvcC1jb2xvciBzdG9wLW9wYWNpdHkgc3RyaWtldGhyb3VnaC1wb3NpdGlvbiBzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyBzdHJva2UtZGFzaGFycmF5IHN0cm9rZS1kYXNob2Zmc2V0IHN0cm9rZS1saW5lY2FwIHN0cm9rZS1saW5lam9pbiBzdHJva2UtbWl0ZXJsaW1pdCBzdHJva2Utb3BhY2l0eSBzdHJva2Utd2lkdGggdGV4dC1hbmNob3IgdGV4dC1kZWNvcmF0aW9uIHRleHQtcmVuZGVyaW5nIHVuZGVybGluZS1wb3NpdGlvbiB1bmRlcmxpbmUtdGhpY2tuZXNzIHVuaWNvZGUtYmlkaSB1bmljb2RlLXJhbmdlIHVuaXRzLXBlci1lbSB2LWFscGhhYmV0aWMgdi1oYW5naW5nIHYtaWRlb2dyYXBoaWMgdi1tYXRoZW1hdGljYWwgdmVjdG9yLWVmZmVjdCB2ZXJ0LWFkdi15IHZlcnQtb3JpZ2luLXggdmVydC1vcmlnaW4teSB3b3JkLXNwYWNpbmcgd3JpdGluZy1tb2RlIHgtaGVpZ2h0IHhsaW5rOmFjdHVhdGUgeGxpbms6YXJjcm9sZSB4bGluazpocmVmIHhsaW5rOnJvbGUgeGxpbms6c2hvdyB4bGluazp0aXRsZSB4bGluazp0eXBlIHhtbDpiYXNlIHhtbG5zOnhsaW5rIHhtbDpsYW5nIHhtbDpzcGFjZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShIYSxcbklhKTtHYS5Qcm9wZXJ0aWVzW2JdPTA7R2EuRE9NQXR0cmlidXRlTmFtZXNbYl09YX0pO3hhLmluamVjdERPTVByb3BlcnR5Q29uZmlnKERhKTt4YS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhHYSk7XG52YXIgUD17X2NhdWdodEVycm9yOm51bGwsX2hhc0NhdWdodEVycm9yOiExLF9yZXRocm93RXJyb3I6bnVsbCxfaGFzUmV0aHJvd0Vycm9yOiExLGluamVjdGlvbjp7aW5qZWN0RXJyb3JVdGlsczpmdW5jdGlvbihhKXtcImZ1bmN0aW9uXCIhPT10eXBlb2YgYS5pbnZva2VHdWFyZGVkQ2FsbGJhY2s/RShcIjE5N1wiKTp2b2lkIDA7SmE9YS5pbnZva2VHdWFyZGVkQ2FsbGJhY2t9fSxpbnZva2VHdWFyZGVkQ2FsbGJhY2s6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxoLGspe0phLmFwcGx5KFAsYXJndW1lbnRzKX0saW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsaCxrKXtQLmludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoUC5oYXNDYXVnaHRFcnJvcigpKXt2YXIgcT1QLmNsZWFyQ2F1Z2h0RXJyb3IoKTtQLl9oYXNSZXRocm93RXJyb3J8fChQLl9oYXNSZXRocm93RXJyb3I9ITAsUC5fcmV0aHJvd0Vycm9yPVxucSl9fSxyZXRocm93Q2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gS2EuYXBwbHkoUCxhcmd1bWVudHMpfSxoYXNDYXVnaHRFcnJvcjpmdW5jdGlvbigpe3JldHVybiBQLl9oYXNDYXVnaHRFcnJvcn0sY2xlYXJDYXVnaHRFcnJvcjpmdW5jdGlvbigpe2lmKFAuX2hhc0NhdWdodEVycm9yKXt2YXIgYT1QLl9jYXVnaHRFcnJvcjtQLl9jYXVnaHRFcnJvcj1udWxsO1AuX2hhc0NhdWdodEVycm9yPSExO3JldHVybiBhfUUoXCIxOThcIil9fTtmdW5jdGlvbiBKYShhLGIsYyxkLGUsZixnLGgsayl7UC5faGFzQ2F1Z2h0RXJyb3I9ITE7UC5fY2F1Z2h0RXJyb3I9bnVsbDt2YXIgcT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMyk7dHJ5e2IuYXBwbHkoYyxxKX1jYXRjaCh2KXtQLl9jYXVnaHRFcnJvcj12LFAuX2hhc0NhdWdodEVycm9yPSEwfX1cbmZ1bmN0aW9uIEthKCl7aWYoUC5faGFzUmV0aHJvd0Vycm9yKXt2YXIgYT1QLl9yZXRocm93RXJyb3I7UC5fcmV0aHJvd0Vycm9yPW51bGw7UC5faGFzUmV0aHJvd0Vycm9yPSExO3Rocm93IGE7fX12YXIgTGE9bnVsbCxNYT17fTtcbmZ1bmN0aW9uIE5hKCl7aWYoTGEpZm9yKHZhciBhIGluIE1hKXt2YXIgYj1NYVthXSxjPUxhLmluZGV4T2YoYSk7LTE8Yz92b2lkIDA6RShcIjk2XCIsYSk7aWYoIU9hW2NdKXtiLmV4dHJhY3RFdmVudHM/dm9pZCAwOkUoXCI5N1wiLGEpO09hW2NdPWI7Yz1iLmV2ZW50VHlwZXM7Zm9yKHZhciBkIGluIGMpe3ZhciBlPXZvaWQgMDt2YXIgZj1jW2RdLGc9YixoPWQ7UGEuaGFzT3duUHJvcGVydHkoaCk/RShcIjk5XCIsaCk6dm9pZCAwO1BhW2hdPWY7dmFyIGs9Zi5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztpZihrKXtmb3IoZSBpbiBrKWsuaGFzT3duUHJvcGVydHkoZSkmJlFhKGtbZV0sZyxoKTtlPSEwfWVsc2UgZi5yZWdpc3RyYXRpb25OYW1lPyhRYShmLnJlZ2lzdHJhdGlvbk5hbWUsZyxoKSxlPSEwKTplPSExO2U/dm9pZCAwOkUoXCI5OFwiLGQsYSl9fX19XG5mdW5jdGlvbiBRYShhLGIsYyl7UmFbYV0/RShcIjEwMFwiLGEpOnZvaWQgMDtSYVthXT1iO1NhW2FdPWIuZXZlbnRUeXBlc1tjXS5kZXBlbmRlbmNpZXN9dmFyIE9hPVtdLFBhPXt9LFJhPXt9LFNhPXt9O2Z1bmN0aW9uIFRhKGEpe0xhP0UoXCIxMDFcIik6dm9pZCAwO0xhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEpO05hKCl9ZnVuY3Rpb24gVWEoYSl7dmFyIGI9ITEsYztmb3IoYyBpbiBhKWlmKGEuaGFzT3duUHJvcGVydHkoYykpe3ZhciBkPWFbY107TWEuaGFzT3duUHJvcGVydHkoYykmJk1hW2NdPT09ZHx8KE1hW2NdP0UoXCIxMDJcIixjKTp2b2lkIDAsTWFbY109ZCxiPSEwKX1iJiZOYSgpfVxudmFyIFZhPU9iamVjdC5mcmVlemUoe3BsdWdpbnM6T2EsZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOlBhLHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOlJhLHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6U2EscG9zc2libGVSZWdpc3RyYXRpb25OYW1lczpudWxsLGluamVjdEV2ZW50UGx1Z2luT3JkZXI6VGEsaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOlVhfSksV2E9bnVsbCxYYT1udWxsLFlhPW51bGw7ZnVuY3Rpb24gWmEoYSxiLGMsZCl7Yj1hLnR5cGV8fFwidW5rbm93bi1ldmVudFwiO2EuY3VycmVudFRhcmdldD1ZYShkKTtQLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcihiLGMsdm9pZCAwLGEpO2EuY3VycmVudFRhcmdldD1udWxsfVxuZnVuY3Rpb24gJGEoYSxiKXtudWxsPT1iP0UoXCIzMFwiKTp2b2lkIDA7aWYobnVsbD09YSlyZXR1cm4gYjtpZihBcnJheS5pc0FycmF5KGEpKXtpZihBcnJheS5pc0FycmF5KGIpKXJldHVybiBhLnB1c2guYXBwbHkoYSxiKSxhO2EucHVzaChiKTtyZXR1cm4gYX1yZXR1cm4gQXJyYXkuaXNBcnJheShiKT9bYV0uY29uY2F0KGIpOlthLGJdfWZ1bmN0aW9uIGFiKGEsYixjKXtBcnJheS5pc0FycmF5KGEpP2EuZm9yRWFjaChiLGMpOmEmJmIuY2FsbChjLGEpfXZhciBiYj1udWxsO1xuZnVuY3Rpb24gY2IoYSxiKXtpZihhKXt2YXIgYz1hLl9kaXNwYXRjaExpc3RlbmVycyxkPWEuX2Rpc3BhdGNoSW5zdGFuY2VzO2lmKEFycmF5LmlzQXJyYXkoYykpZm9yKHZhciBlPTA7ZTxjLmxlbmd0aCYmIWEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtlKyspWmEoYSxiLGNbZV0sZFtlXSk7ZWxzZSBjJiZaYShhLGIsYyxkKTthLl9kaXNwYXRjaExpc3RlbmVycz1udWxsO2EuX2Rpc3BhdGNoSW5zdGFuY2VzPW51bGw7YS5pc1BlcnNpc3RlbnQoKXx8YS5jb25zdHJ1Y3Rvci5yZWxlYXNlKGEpfX1mdW5jdGlvbiBkYihhKXtyZXR1cm4gY2IoYSwhMCl9ZnVuY3Rpb24gZ2IoYSl7cmV0dXJuIGNiKGEsITEpfXZhciBoYj17aW5qZWN0RXZlbnRQbHVnaW5PcmRlcjpUYSxpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6VWF9O1xuZnVuY3Rpb24gaWIoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZTtpZighYylyZXR1cm4gbnVsbDt2YXIgZD1XYShjKTtpZighZClyZXR1cm4gbnVsbDtjPWRbYl07YTpzd2l0Y2goYil7Y2FzZSBcIm9uQ2xpY2tcIjpjYXNlIFwib25DbGlja0NhcHR1cmVcIjpjYXNlIFwib25Eb3VibGVDbGlja1wiOmNhc2UgXCJvbkRvdWJsZUNsaWNrQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlRG93blwiOmNhc2UgXCJvbk1vdXNlRG93bkNhcHR1cmVcIjpjYXNlIFwib25Nb3VzZU1vdmVcIjpjYXNlIFwib25Nb3VzZU1vdmVDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VVcFwiOmNhc2UgXCJvbk1vdXNlVXBDYXB0dXJlXCI6KGQ9IWQuZGlzYWJsZWQpfHwoYT1hLnR5cGUsZD0hKFwiYnV0dG9uXCI9PT1hfHxcImlucHV0XCI9PT1hfHxcInNlbGVjdFwiPT09YXx8XCJ0ZXh0YXJlYVwiPT09YSkpO2E9IWQ7YnJlYWsgYTtkZWZhdWx0OmE9ITF9aWYoYSlyZXR1cm4gbnVsbDtjJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYz9FKFwiMjMxXCIsYix0eXBlb2YgYyk6dm9pZCAwO1xucmV0dXJuIGN9ZnVuY3Rpb24gamIoYSxiLGMsZCl7Zm9yKHZhciBlLGY9MDtmPE9hLmxlbmd0aDtmKyspe3ZhciBnPU9hW2ZdO2cmJihnPWcuZXh0cmFjdEV2ZW50cyhhLGIsYyxkKSkmJihlPSRhKGUsZykpfXJldHVybiBlfWZ1bmN0aW9uIGtiKGEpe2EmJihiYj0kYShiYixhKSl9ZnVuY3Rpb24gbGIoYSl7dmFyIGI9YmI7YmI9bnVsbDtiJiYoYT9hYihiLGRiKTphYihiLGdiKSxiYj9FKFwiOTVcIik6dm9pZCAwLFAucmV0aHJvd0NhdWdodEVycm9yKCkpfXZhciBtYj1PYmplY3QuZnJlZXplKHtpbmplY3Rpb246aGIsZ2V0TGlzdGVuZXI6aWIsZXh0cmFjdEV2ZW50czpqYixlbnF1ZXVlRXZlbnRzOmtiLHByb2Nlc3NFdmVudFF1ZXVlOmxifSksbmI9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksUT1cIl9fcmVhY3RJbnRlcm5hbEluc3RhbmNlJFwiK25iLG9iPVwiX19yZWFjdEV2ZW50SGFuZGxlcnMkXCIrbmI7XG5mdW5jdGlvbiBwYihhKXtpZihhW1FdKXJldHVybiBhW1FdO2Zvcih2YXIgYj1bXTshYVtRXTspaWYoYi5wdXNoKGEpLGEucGFyZW50Tm9kZSlhPWEucGFyZW50Tm9kZTtlbHNlIHJldHVybiBudWxsO3ZhciBjPXZvaWQgMCxkPWFbUV07aWYoNT09PWQudGFnfHw2PT09ZC50YWcpcmV0dXJuIGQ7Zm9yKDthJiYoZD1hW1FdKTthPWIucG9wKCkpYz1kO3JldHVybiBjfWZ1bmN0aW9uIHFiKGEpe2lmKDU9PT1hLnRhZ3x8Nj09PWEudGFnKXJldHVybiBhLnN0YXRlTm9kZTtFKFwiMzNcIil9ZnVuY3Rpb24gcmIoYSl7cmV0dXJuIGFbb2JdfHxudWxsfVxudmFyIHNiPU9iamVjdC5mcmVlemUoe3ByZWNhY2hlRmliZXJOb2RlOmZ1bmN0aW9uKGEsYil7YltRXT1hfSxnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTpwYixnZXRJbnN0YW5jZUZyb21Ob2RlOmZ1bmN0aW9uKGEpe2E9YVtRXTtyZXR1cm4hYXx8NSE9PWEudGFnJiY2IT09YS50YWc/bnVsbDphfSxnZXROb2RlRnJvbUluc3RhbmNlOnFiLGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6cmIsdXBkYXRlRmliZXJQcm9wczpmdW5jdGlvbihhLGIpe2Fbb2JdPWJ9fSk7ZnVuY3Rpb24gdGIoYSl7ZG8gYT1hW1wicmV0dXJuXCJdO3doaWxlKGEmJjUhPT1hLnRhZyk7cmV0dXJuIGE/YTpudWxsfWZ1bmN0aW9uIHViKGEsYixjKXtmb3IodmFyIGQ9W107YTspZC5wdXNoKGEpLGE9dGIoYSk7Zm9yKGE9ZC5sZW5ndGg7MDxhLS07KWIoZFthXSxcImNhcHR1cmVkXCIsYyk7Zm9yKGE9MDthPGQubGVuZ3RoO2ErKyliKGRbYV0sXCJidWJibGVkXCIsYyl9XG5mdW5jdGlvbiB2YihhLGIsYyl7aWYoYj1pYihhLGMuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbYl0pKWMuX2Rpc3BhdGNoTGlzdGVuZXJzPSRhKGMuX2Rpc3BhdGNoTGlzdGVuZXJzLGIpLGMuX2Rpc3BhdGNoSW5zdGFuY2VzPSRhKGMuX2Rpc3BhdGNoSW5zdGFuY2VzLGEpfWZ1bmN0aW9uIHdiKGEpe2EmJmEuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMmJnViKGEuX3RhcmdldEluc3QsdmIsYSl9ZnVuY3Rpb24geGIoYSl7aWYoYSYmYS5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcyl7dmFyIGI9YS5fdGFyZ2V0SW5zdDtiPWI/dGIoYik6bnVsbDt1YihiLHZiLGEpfX1cbmZ1bmN0aW9uIHliKGEsYixjKXthJiZjJiZjLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUmJihiPWliKGEsYy5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSkmJihjLl9kaXNwYXRjaExpc3RlbmVycz0kYShjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz0kYShjLl9kaXNwYXRjaEluc3RhbmNlcyxhKSl9ZnVuY3Rpb24gemIoYSl7YSYmYS5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lJiZ5YihhLl90YXJnZXRJbnN0LG51bGwsYSl9ZnVuY3Rpb24gQWIoYSl7YWIoYSx3Yil9XG5mdW5jdGlvbiBCYihhLGIsYyxkKXtpZihjJiZkKWE6e3ZhciBlPWM7Zm9yKHZhciBmPWQsZz0wLGg9ZTtoO2g9dGIoaCkpZysrO2g9MDtmb3IodmFyIGs9ZjtrO2s9dGIoaykpaCsrO2Zvcig7MDxnLWg7KWU9dGIoZSksZy0tO2Zvcig7MDxoLWc7KWY9dGIoZiksaC0tO2Zvcig7Zy0tOyl7aWYoZT09PWZ8fGU9PT1mLmFsdGVybmF0ZSlicmVhayBhO2U9dGIoZSk7Zj10YihmKX1lPW51bGx9ZWxzZSBlPW51bGw7Zj1lO2ZvcihlPVtdO2MmJmMhPT1mOyl7Zz1jLmFsdGVybmF0ZTtpZihudWxsIT09ZyYmZz09PWYpYnJlYWs7ZS5wdXNoKGMpO2M9dGIoYyl9Zm9yKGM9W107ZCYmZCE9PWY7KXtnPWQuYWx0ZXJuYXRlO2lmKG51bGwhPT1nJiZnPT09ZilicmVhaztjLnB1c2goZCk7ZD10YihkKX1mb3IoZD0wO2Q8ZS5sZW5ndGg7ZCsrKXliKGVbZF0sXCJidWJibGVkXCIsYSk7Zm9yKGE9Yy5sZW5ndGg7MDxhLS07KXliKGNbYV0sXCJjYXB0dXJlZFwiLGIpfVxudmFyIENiPU9iamVjdC5mcmVlemUoe2FjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6QWIsYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQ6ZnVuY3Rpb24oYSl7YWIoYSx4Yil9LGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczpCYixhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczpmdW5jdGlvbihhKXthYihhLHpiKX19KSxEYj1udWxsO2Z1bmN0aW9uIEViKCl7IURiJiZsLmNhblVzZURPTSYmKERiPVwidGV4dENvbnRlbnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudD9cInRleHRDb250ZW50XCI6XCJpbm5lclRleHRcIik7cmV0dXJuIERifXZhciBTPXtfcm9vdDpudWxsLF9zdGFydFRleHQ6bnVsbCxfZmFsbGJhY2tUZXh0Om51bGx9O1xuZnVuY3Rpb24gRmIoKXtpZihTLl9mYWxsYmFja1RleHQpcmV0dXJuIFMuX2ZhbGxiYWNrVGV4dDt2YXIgYSxiPVMuX3N0YXJ0VGV4dCxjPWIubGVuZ3RoLGQsZT1HYigpLGY9ZS5sZW5ndGg7Zm9yKGE9MDthPGMmJmJbYV09PT1lW2FdO2ErKyk7dmFyIGc9Yy1hO2ZvcihkPTE7ZDw9ZyYmYltjLWRdPT09ZVtmLWRdO2QrKyk7Uy5fZmFsbGJhY2tUZXh0PWUuc2xpY2UoYSwxPGQ/MS1kOnZvaWQgMCk7cmV0dXJuIFMuX2ZhbGxiYWNrVGV4dH1mdW5jdGlvbiBHYigpe3JldHVyblwidmFsdWVcImluIFMuX3Jvb3Q/Uy5fcm9vdC52YWx1ZTpTLl9yb290W0ViKCldfVxudmFyIEhiPVwiZGlzcGF0Y2hDb25maWcgX3RhcmdldEluc3QgbmF0aXZlRXZlbnQgaXNEZWZhdWx0UHJldmVudGVkIGlzUHJvcGFnYXRpb25TdG9wcGVkIF9kaXNwYXRjaExpc3RlbmVycyBfZGlzcGF0Y2hJbnN0YW5jZXNcIi5zcGxpdChcIiBcIiksSWI9e3R5cGU6bnVsbCx0YXJnZXQ6bnVsbCxjdXJyZW50VGFyZ2V0OkMudGhhdFJldHVybnNOdWxsLGV2ZW50UGhhc2U6bnVsbCxidWJibGVzOm51bGwsY2FuY2VsYWJsZTpudWxsLHRpbWVTdGFtcDpmdW5jdGlvbihhKXtyZXR1cm4gYS50aW1lU3RhbXB8fERhdGUubm93KCl9LGRlZmF1bHRQcmV2ZW50ZWQ6bnVsbCxpc1RydXN0ZWQ6bnVsbH07XG5mdW5jdGlvbiBUKGEsYixjLGQpe3RoaXMuZGlzcGF0Y2hDb25maWc9YTt0aGlzLl90YXJnZXRJbnN0PWI7dGhpcy5uYXRpdmVFdmVudD1jO2E9dGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7Zm9yKHZhciBlIGluIGEpYS5oYXNPd25Qcm9wZXJ0eShlKSYmKChiPWFbZV0pP3RoaXNbZV09YihjKTpcInRhcmdldFwiPT09ZT90aGlzLnRhcmdldD1kOnRoaXNbZV09Y1tlXSk7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9KG51bGwhPWMuZGVmYXVsdFByZXZlbnRlZD9jLmRlZmF1bHRQcmV2ZW50ZWQ6ITE9PT1jLnJldHVyblZhbHVlKT9DLnRoYXRSZXR1cm5zVHJ1ZTpDLnRoYXRSZXR1cm5zRmFsc2U7dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1DLnRoYXRSZXR1cm5zRmFsc2U7cmV0dXJuIHRoaXN9XG5CKFQucHJvdG90eXBlLHtwcmV2ZW50RGVmYXVsdDpmdW5jdGlvbigpe3RoaXMuZGVmYXVsdFByZXZlbnRlZD0hMDt2YXIgYT10aGlzLm5hdGl2ZUV2ZW50O2EmJihhLnByZXZlbnREZWZhdWx0P2EucHJldmVudERlZmF1bHQoKTpcInVua25vd25cIiE9PXR5cGVvZiBhLnJldHVyblZhbHVlJiYoYS5yZXR1cm5WYWx1ZT0hMSksdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQ9Qy50aGF0UmV0dXJuc1RydWUpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXt2YXIgYT10aGlzLm5hdGl2ZUV2ZW50O2EmJihhLnN0b3BQcm9wYWdhdGlvbj9hLnN0b3BQcm9wYWdhdGlvbigpOlwidW5rbm93blwiIT09dHlwZW9mIGEuY2FuY2VsQnViYmxlJiYoYS5jYW5jZWxCdWJibGU9ITApLHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9Qy50aGF0UmV0dXJuc1RydWUpfSxwZXJzaXN0OmZ1bmN0aW9uKCl7dGhpcy5pc1BlcnNpc3RlbnQ9Qy50aGF0UmV0dXJuc1RydWV9LGlzUGVyc2lzdGVudDpDLnRoYXRSZXR1cm5zRmFsc2UsXG5kZXN0cnVjdG9yOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UsYjtmb3IoYiBpbiBhKXRoaXNbYl09bnVsbDtmb3IoYT0wO2E8SGIubGVuZ3RoO2ErKyl0aGlzW0hiW2FdXT1udWxsfX0pO1QuSW50ZXJmYWNlPUliO1QuYXVnbWVudENsYXNzPWZ1bmN0aW9uKGEsYil7ZnVuY3Rpb24gYygpe31jLnByb3RvdHlwZT10aGlzLnByb3RvdHlwZTt2YXIgZD1uZXcgYztCKGQsYS5wcm90b3R5cGUpO2EucHJvdG90eXBlPWQ7YS5wcm90b3R5cGUuY29uc3RydWN0b3I9YTthLkludGVyZmFjZT1CKHt9LHRoaXMuSW50ZXJmYWNlLGIpO2EuYXVnbWVudENsYXNzPXRoaXMuYXVnbWVudENsYXNzO0piKGEpfTtKYihUKTtmdW5jdGlvbiBLYihhLGIsYyxkKXtpZih0aGlzLmV2ZW50UG9vbC5sZW5ndGgpe3ZhciBlPXRoaXMuZXZlbnRQb29sLnBvcCgpO3RoaXMuY2FsbChlLGEsYixjLGQpO3JldHVybiBlfXJldHVybiBuZXcgdGhpcyhhLGIsYyxkKX1cbmZ1bmN0aW9uIExiKGEpe2EgaW5zdGFuY2VvZiB0aGlzP3ZvaWQgMDpFKFwiMjIzXCIpO2EuZGVzdHJ1Y3RvcigpOzEwPnRoaXMuZXZlbnRQb29sLmxlbmd0aCYmdGhpcy5ldmVudFBvb2wucHVzaChhKX1mdW5jdGlvbiBKYihhKXthLmV2ZW50UG9vbD1bXTthLmdldFBvb2xlZD1LYjthLnJlbGVhc2U9TGJ9ZnVuY3Rpb24gTWIoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKE1iLHtkYXRhOm51bGx9KTtmdW5jdGlvbiBOYihhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoTmIse2RhdGE6bnVsbH0pO3ZhciBQYj1bOSwxMywyNywzMl0sVmI9bC5jYW5Vc2VET00mJlwiQ29tcG9zaXRpb25FdmVudFwiaW4gd2luZG93LFdiPW51bGw7bC5jYW5Vc2VET00mJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmKFdiPWRvY3VtZW50LmRvY3VtZW50TW9kZSk7dmFyIFhiO1xuaWYoWGI9bC5jYW5Vc2VET00mJlwiVGV4dEV2ZW50XCJpbiB3aW5kb3cmJiFXYil7dmFyIFliPXdpbmRvdy5vcGVyYTtYYj0hKFwib2JqZWN0XCI9PT10eXBlb2YgWWImJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBZYi52ZXJzaW9uJiYxMj49cGFyc2VJbnQoWWIudmVyc2lvbigpLDEwKSl9XG52YXIgWmI9WGIsJGI9bC5jYW5Vc2VET00mJighVmJ8fFdiJiY4PFdiJiYxMT49V2IpLGFjPVN0cmluZy5mcm9tQ2hhckNvZGUoMzIpLGJjPXtiZWZvcmVJbnB1dDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkJlZm9yZUlucHV0XCIsY2FwdHVyZWQ6XCJvbkJlZm9yZUlucHV0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6W1widG9wQ29tcG9zaXRpb25FbmRcIixcInRvcEtleVByZXNzXCIsXCJ0b3BUZXh0SW5wdXRcIixcInRvcFBhc3RlXCJdfSxjb21wb3NpdGlvbkVuZDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uRW5kXCIsY2FwdHVyZWQ6XCJvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uRW5kIHRvcEtleURvd24gdG9wS2V5UHJlc3MgdG9wS2V5VXAgdG9wTW91c2VEb3duXCIuc3BsaXQoXCIgXCIpfSxjb21wb3NpdGlvblN0YXJ0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25TdGFydFwiLFxuY2FwdHVyZWQ6XCJvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25TdGFydCB0b3BLZXlEb3duIHRvcEtleVByZXNzIHRvcEtleVVwIHRvcE1vdXNlRG93blwiLnNwbGl0KFwiIFwiKX0sY29tcG9zaXRpb25VcGRhdGU6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvblVwZGF0ZVwiLGNhcHR1cmVkOlwib25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvblVwZGF0ZSB0b3BLZXlEb3duIHRvcEtleVByZXNzIHRvcEtleVVwIHRvcE1vdXNlRG93blwiLnNwbGl0KFwiIFwiKX19LGNjPSExO1xuZnVuY3Rpb24gZGMoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcInRvcEtleVVwXCI6cmV0dXJuLTEhPT1QYi5pbmRleE9mKGIua2V5Q29kZSk7Y2FzZSBcInRvcEtleURvd25cIjpyZXR1cm4gMjI5IT09Yi5rZXlDb2RlO2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmNhc2UgXCJ0b3BNb3VzZURvd25cIjpjYXNlIFwidG9wQmx1clwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGVjKGEpe2E9YS5kZXRhaWw7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZcImRhdGFcImluIGE/YS5kYXRhOm51bGx9dmFyIGZjPSExO2Z1bmN0aW9uIGdjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOnJldHVybiBlYyhiKTtjYXNlIFwidG9wS2V5UHJlc3NcIjppZigzMiE9PWIud2hpY2gpcmV0dXJuIG51bGw7Y2M9ITA7cmV0dXJuIGFjO2Nhc2UgXCJ0b3BUZXh0SW5wdXRcIjpyZXR1cm4gYT1iLmRhdGEsYT09PWFjJiZjYz9udWxsOmE7ZGVmYXVsdDpyZXR1cm4gbnVsbH19XG5mdW5jdGlvbiBoYyhhLGIpe2lmKGZjKXJldHVyblwidG9wQ29tcG9zaXRpb25FbmRcIj09PWF8fCFWYiYmZGMoYSxiKT8oYT1GYigpLFMuX3Jvb3Q9bnVsbCxTLl9zdGFydFRleHQ9bnVsbCxTLl9mYWxsYmFja1RleHQ9bnVsbCxmYz0hMSxhKTpudWxsO3N3aXRjaChhKXtjYXNlIFwidG9wUGFzdGVcIjpyZXR1cm4gbnVsbDtjYXNlIFwidG9wS2V5UHJlc3NcIjppZighKGIuY3RybEtleXx8Yi5hbHRLZXl8fGIubWV0YUtleSl8fGIuY3RybEtleSYmYi5hbHRLZXkpe2lmKGIuY2hhciYmMTxiLmNoYXIubGVuZ3RoKXJldHVybiBiLmNoYXI7aWYoYi53aGljaClyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShiLndoaWNoKX1yZXR1cm4gbnVsbDtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpyZXR1cm4gJGI/bnVsbDpiLmRhdGE7ZGVmYXVsdDpyZXR1cm4gbnVsbH19XG52YXIgaWM9e2V2ZW50VHlwZXM6YmMsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZTtpZihWYiliOntzd2l0Y2goYSl7Y2FzZSBcInRvcENvbXBvc2l0aW9uU3RhcnRcIjp2YXIgZj1iYy5jb21wb3NpdGlvblN0YXJ0O2JyZWFrIGI7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6Zj1iYy5jb21wb3NpdGlvbkVuZDticmVhayBiO2Nhc2UgXCJ0b3BDb21wb3NpdGlvblVwZGF0ZVwiOmY9YmMuY29tcG9zaXRpb25VcGRhdGU7YnJlYWsgYn1mPXZvaWQgMH1lbHNlIGZjP2RjKGEsYykmJihmPWJjLmNvbXBvc2l0aW9uRW5kKTpcInRvcEtleURvd25cIj09PWEmJjIyOT09PWMua2V5Q29kZSYmKGY9YmMuY29tcG9zaXRpb25TdGFydCk7Zj8oJGImJihmY3x8ZiE9PWJjLmNvbXBvc2l0aW9uU3RhcnQ/Zj09PWJjLmNvbXBvc2l0aW9uRW5kJiZmYyYmKGU9RmIoKSk6KFMuX3Jvb3Q9ZCxTLl9zdGFydFRleHQ9R2IoKSxmYz0hMCkpLGY9TWIuZ2V0UG9vbGVkKGYsYixjLGQpLGU/Zi5kYXRhPVxuZTooZT1lYyhjKSxudWxsIT09ZSYmKGYuZGF0YT1lKSksQWIoZiksZT1mKTplPW51bGw7KGE9WmI/Z2MoYSxjKTpoYyhhLGMpKT8oYj1OYi5nZXRQb29sZWQoYmMuYmVmb3JlSW5wdXQsYixjLGQpLGIuZGF0YT1hLEFiKGIpKTpiPW51bGw7cmV0dXJuW2UsYl19fSxqYz1udWxsLGtjPW51bGwsbGM9bnVsbDtmdW5jdGlvbiBtYyhhKXtpZihhPVhhKGEpKXtqYyYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGpjLnJlc3RvcmVDb250cm9sbGVkU3RhdGU/dm9pZCAwOkUoXCIxOTRcIik7dmFyIGI9V2EoYS5zdGF0ZU5vZGUpO2pjLnJlc3RvcmVDb250cm9sbGVkU3RhdGUoYS5zdGF0ZU5vZGUsYS50eXBlLGIpfX12YXIgbmM9e2luamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQ6ZnVuY3Rpb24oYSl7amM9YX19O2Z1bmN0aW9uIG9jKGEpe2tjP2xjP2xjLnB1c2goYSk6bGM9W2FdOmtjPWF9XG5mdW5jdGlvbiBwYygpe2lmKGtjKXt2YXIgYT1rYyxiPWxjO2xjPWtjPW51bGw7bWMoYSk7aWYoYilmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKW1jKGJbYV0pfX12YXIgcWM9T2JqZWN0LmZyZWV6ZSh7aW5qZWN0aW9uOm5jLGVucXVldWVTdGF0ZVJlc3RvcmU6b2MscmVzdG9yZVN0YXRlSWZOZWVkZWQ6cGN9KTtmdW5jdGlvbiByYyhhLGIpe3JldHVybiBhKGIpfXZhciBzYz0hMTtmdW5jdGlvbiB0YyhhLGIpe2lmKHNjKXJldHVybiByYyhhLGIpO3NjPSEwO3RyeXtyZXR1cm4gcmMoYSxiKX1maW5hbGx5e3NjPSExLHBjKCl9fXZhciB1Yz17Y29sb3I6ITAsZGF0ZTohMCxkYXRldGltZTohMCxcImRhdGV0aW1lLWxvY2FsXCI6ITAsZW1haWw6ITAsbW9udGg6ITAsbnVtYmVyOiEwLHBhc3N3b3JkOiEwLHJhbmdlOiEwLHNlYXJjaDohMCx0ZWw6ITAsdGV4dDohMCx0aW1lOiEwLHVybDohMCx3ZWVrOiEwfTtcbmZ1bmN0aW9uIHZjKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm5cImlucHV0XCI9PT1iPyEhdWNbYS50eXBlXTpcInRleHRhcmVhXCI9PT1iPyEwOiExfWZ1bmN0aW9uIHdjKGEpe2E9YS50YXJnZXR8fGEuc3JjRWxlbWVudHx8d2luZG93O2EuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQmJihhPWEuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpO3JldHVybiAzPT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGU6YX12YXIgeGM7bC5jYW5Vc2VET00mJih4Yz1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbiYmZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSYmITAhPT1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiXCIsXCJcIikpO1xuZnVuY3Rpb24geWMoYSxiKXtpZighbC5jYW5Vc2VET018fGImJiEoXCJhZGRFdmVudExpc3RlbmVyXCJpbiBkb2N1bWVudCkpcmV0dXJuITE7Yj1cIm9uXCIrYTt2YXIgYz1iIGluIGRvY3VtZW50O2N8fChjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksYy5zZXRBdHRyaWJ1dGUoYixcInJldHVybjtcIiksYz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgY1tiXSk7IWMmJnhjJiZcIndoZWVsXCI9PT1hJiYoYz1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKFwiRXZlbnRzLndoZWVsXCIsXCIzLjBcIikpO3JldHVybiBjfWZ1bmN0aW9uIHpjKGEpe3ZhciBiPWEudHlwZTtyZXR1cm4oYT1hLm5vZGVOYW1lKSYmXCJpbnB1dFwiPT09YS50b0xvd2VyQ2FzZSgpJiYoXCJjaGVja2JveFwiPT09Ynx8XCJyYWRpb1wiPT09Yil9XG5mdW5jdGlvbiBBYyhhKXt2YXIgYj16YyhhKT9cImNoZWNrZWRcIjpcInZhbHVlXCIsYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEuY29uc3RydWN0b3IucHJvdG90eXBlLGIpLGQ9XCJcIithW2JdO2lmKCFhLmhhc093blByb3BlcnR5KGIpJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5nZXQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLnNldClyZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsYix7ZW51bWVyYWJsZTpjLmVudW1lcmFibGUsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBjLmdldC5jYWxsKHRoaXMpfSxzZXQ6ZnVuY3Rpb24oYSl7ZD1cIlwiK2E7Yy5zZXQuY2FsbCh0aGlzLGEpfX0pLHtnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiBkfSxzZXRWYWx1ZTpmdW5jdGlvbihhKXtkPVwiXCIrYX0sc3RvcFRyYWNraW5nOmZ1bmN0aW9uKCl7YS5fdmFsdWVUcmFja2VyPW51bGw7ZGVsZXRlIGFbYl19fX1cbmZ1bmN0aW9uIEJjKGEpe2EuX3ZhbHVlVHJhY2tlcnx8KGEuX3ZhbHVlVHJhY2tlcj1BYyhhKSl9ZnVuY3Rpb24gQ2MoYSl7aWYoIWEpcmV0dXJuITE7dmFyIGI9YS5fdmFsdWVUcmFja2VyO2lmKCFiKXJldHVybiEwO3ZhciBjPWIuZ2V0VmFsdWUoKTt2YXIgZD1cIlwiO2EmJihkPXpjKGEpP2EuY2hlY2tlZD9cInRydWVcIjpcImZhbHNlXCI6YS52YWx1ZSk7YT1kO3JldHVybiBhIT09Yz8oYi5zZXRWYWx1ZShhKSwhMCk6ITF9dmFyIERjPXtjaGFuZ2U6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25DaGFuZ2VcIixjYXB0dXJlZDpcIm9uQ2hhbmdlQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENoYW5nZSB0b3BDbGljayB0b3BGb2N1cyB0b3BJbnB1dCB0b3BLZXlEb3duIHRvcEtleVVwIHRvcFNlbGVjdGlvbkNoYW5nZVwiLnNwbGl0KFwiIFwiKX19O1xuZnVuY3Rpb24gRWMoYSxiLGMpe2E9VC5nZXRQb29sZWQoRGMuY2hhbmdlLGEsYixjKTthLnR5cGU9XCJjaGFuZ2VcIjtvYyhjKTtBYihhKTtyZXR1cm4gYX12YXIgRmM9bnVsbCxHYz1udWxsO2Z1bmN0aW9uIEhjKGEpe2tiKGEpO2xiKCExKX1mdW5jdGlvbiBJYyhhKXt2YXIgYj1xYihhKTtpZihDYyhiKSlyZXR1cm4gYX1mdW5jdGlvbiBKYyhhLGIpe2lmKFwidG9wQ2hhbmdlXCI9PT1hKXJldHVybiBifXZhciBLYz0hMTtsLmNhblVzZURPTSYmKEtjPXljKFwiaW5wdXRcIikmJighZG9jdW1lbnQuZG9jdW1lbnRNb2RlfHw5PGRvY3VtZW50LmRvY3VtZW50TW9kZSkpO2Z1bmN0aW9uIExjKCl7RmMmJihGYy5kZXRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixNYyksR2M9RmM9bnVsbCl9ZnVuY3Rpb24gTWMoYSl7XCJ2YWx1ZVwiPT09YS5wcm9wZXJ0eU5hbWUmJkljKEdjKSYmKGE9RWMoR2MsYSx3YyhhKSksdGMoSGMsYSkpfVxuZnVuY3Rpb24gTmMoYSxiLGMpe1widG9wRm9jdXNcIj09PWE/KExjKCksRmM9YixHYz1jLEZjLmF0dGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLE1jKSk6XCJ0b3BCbHVyXCI9PT1hJiZMYygpfWZ1bmN0aW9uIE9jKGEpe2lmKFwidG9wU2VsZWN0aW9uQ2hhbmdlXCI9PT1hfHxcInRvcEtleVVwXCI9PT1hfHxcInRvcEtleURvd25cIj09PWEpcmV0dXJuIEljKEdjKX1mdW5jdGlvbiBQYyhhLGIpe2lmKFwidG9wQ2xpY2tcIj09PWEpcmV0dXJuIEljKGIpfWZ1bmN0aW9uICRjKGEsYil7aWYoXCJ0b3BJbnB1dFwiPT09YXx8XCJ0b3BDaGFuZ2VcIj09PWEpcmV0dXJuIEljKGIpfVxudmFyIGFkPXtldmVudFR5cGVzOkRjLF9pc0lucHV0RXZlbnRTdXBwb3J0ZWQ6S2MsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1iP3FiKGIpOndpbmRvdyxmPWUubm9kZU5hbWUmJmUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtpZihcInNlbGVjdFwiPT09Znx8XCJpbnB1dFwiPT09ZiYmXCJmaWxlXCI9PT1lLnR5cGUpdmFyIGc9SmM7ZWxzZSBpZih2YyhlKSlpZihLYylnPSRjO2Vsc2V7Zz1PYzt2YXIgaD1OY31lbHNlIGY9ZS5ub2RlTmFtZSwhZnx8XCJpbnB1dFwiIT09Zi50b0xvd2VyQ2FzZSgpfHxcImNoZWNrYm94XCIhPT1lLnR5cGUmJlwicmFkaW9cIiE9PWUudHlwZXx8KGc9UGMpO2lmKGcmJihnPWcoYSxiKSkpcmV0dXJuIEVjKGcsYyxkKTtoJiZoKGEsZSxiKTtcInRvcEJsdXJcIj09PWEmJm51bGwhPWImJihhPWIuX3dyYXBwZXJTdGF0ZXx8ZS5fd3JhcHBlclN0YXRlKSYmYS5jb250cm9sbGVkJiZcIm51bWJlclwiPT09ZS50eXBlJiYoYT1cIlwiK2UudmFsdWUsZS5nZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSE9PVxuYSYmZS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLGEpKX19O2Z1bmN0aW9uIGJkKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhiZCx7dmlldzpudWxsLGRldGFpbDpudWxsfSk7dmFyIGNkPXtBbHQ6XCJhbHRLZXlcIixDb250cm9sOlwiY3RybEtleVwiLE1ldGE6XCJtZXRhS2V5XCIsU2hpZnQ6XCJzaGlmdEtleVwifTtmdW5jdGlvbiBkZChhKXt2YXIgYj10aGlzLm5hdGl2ZUV2ZW50O3JldHVybiBiLmdldE1vZGlmaWVyU3RhdGU/Yi5nZXRNb2RpZmllclN0YXRlKGEpOihhPWNkW2FdKT8hIWJbYV06ITF9ZnVuY3Rpb24gZWQoKXtyZXR1cm4gZGR9ZnVuY3Rpb24gZmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVxuYmQuYXVnbWVudENsYXNzKGZkLHtzY3JlZW5YOm51bGwsc2NyZWVuWTpudWxsLGNsaWVudFg6bnVsbCxjbGllbnRZOm51bGwscGFnZVg6bnVsbCxwYWdlWTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxnZXRNb2RpZmllclN0YXRlOmVkLGJ1dHRvbjpudWxsLGJ1dHRvbnM6bnVsbCxyZWxhdGVkVGFyZ2V0OmZ1bmN0aW9uKGEpe3JldHVybiBhLnJlbGF0ZWRUYXJnZXR8fChhLmZyb21FbGVtZW50PT09YS5zcmNFbGVtZW50P2EudG9FbGVtZW50OmEuZnJvbUVsZW1lbnQpfX0pO1xudmFyIGdkPXttb3VzZUVudGVyOntyZWdpc3RyYXRpb25OYW1lOlwib25Nb3VzZUVudGVyXCIsZGVwZW5kZW5jaWVzOltcInRvcE1vdXNlT3V0XCIsXCJ0b3BNb3VzZU92ZXJcIl19LG1vdXNlTGVhdmU6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvbk1vdXNlTGVhdmVcIixkZXBlbmRlbmNpZXM6W1widG9wTW91c2VPdXRcIixcInRvcE1vdXNlT3ZlclwiXX19LGhkPXtldmVudFR5cGVzOmdkLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoXCJ0b3BNb3VzZU92ZXJcIj09PWEmJihjLnJlbGF0ZWRUYXJnZXR8fGMuZnJvbUVsZW1lbnQpfHxcInRvcE1vdXNlT3V0XCIhPT1hJiZcInRvcE1vdXNlT3ZlclwiIT09YSlyZXR1cm4gbnVsbDt2YXIgZT1kLndpbmRvdz09PWQ/ZDooZT1kLm93bmVyRG9jdW1lbnQpP2UuZGVmYXVsdFZpZXd8fGUucGFyZW50V2luZG93OndpbmRvdztcInRvcE1vdXNlT3V0XCI9PT1hPyhhPWIsYj0oYj1jLnJlbGF0ZWRUYXJnZXR8fGMudG9FbGVtZW50KT9wYihiKTpudWxsKTphPW51bGw7aWYoYT09PVxuYilyZXR1cm4gbnVsbDt2YXIgZj1udWxsPT1hP2U6cWIoYSk7ZT1udWxsPT1iP2U6cWIoYik7dmFyIGc9ZmQuZ2V0UG9vbGVkKGdkLm1vdXNlTGVhdmUsYSxjLGQpO2cudHlwZT1cIm1vdXNlbGVhdmVcIjtnLnRhcmdldD1mO2cucmVsYXRlZFRhcmdldD1lO2M9ZmQuZ2V0UG9vbGVkKGdkLm1vdXNlRW50ZXIsYixjLGQpO2MudHlwZT1cIm1vdXNlZW50ZXJcIjtjLnRhcmdldD1lO2MucmVsYXRlZFRhcmdldD1mO0JiKGcsYyxhLGIpO3JldHVybltnLGNdfX0saWQ9YWEuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQuUmVhY3RDdXJyZW50T3duZXI7ZnVuY3Rpb24gamQoYSl7YT1hLnR5cGU7cmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBhP2E6XCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YS5kaXNwbGF5TmFtZXx8YS5uYW1lOm51bGx9XG5mdW5jdGlvbiBrZChhKXt2YXIgYj1hO2lmKGEuYWx0ZXJuYXRlKWZvcig7YltcInJldHVyblwiXTspYj1iW1wicmV0dXJuXCJdO2Vsc2V7aWYoMCE9PShiLmVmZmVjdFRhZyYyKSlyZXR1cm4gMTtmb3IoO2JbXCJyZXR1cm5cIl07KWlmKGI9YltcInJldHVyblwiXSwwIT09KGIuZWZmZWN0VGFnJjIpKXJldHVybiAxfXJldHVybiAzPT09Yi50YWc/MjozfWZ1bmN0aW9uIGxkKGEpe3JldHVybihhPWEuX3JlYWN0SW50ZXJuYWxGaWJlcik/Mj09PWtkKGEpOiExfWZ1bmN0aW9uIG1kKGEpezIhPT1rZChhKT9FKFwiMTg4XCIpOnZvaWQgMH1cbmZ1bmN0aW9uIG5kKGEpe3ZhciBiPWEuYWx0ZXJuYXRlO2lmKCFiKXJldHVybiBiPWtkKGEpLDM9PT1iP0UoXCIxODhcIik6dm9pZCAwLDE9PT1iP251bGw6YTtmb3IodmFyIGM9YSxkPWI7Oyl7dmFyIGU9Y1tcInJldHVyblwiXSxmPWU/ZS5hbHRlcm5hdGU6bnVsbDtpZighZXx8IWYpYnJlYWs7aWYoZS5jaGlsZD09PWYuY2hpbGQpe2Zvcih2YXIgZz1lLmNoaWxkO2c7KXtpZihnPT09YylyZXR1cm4gbWQoZSksYTtpZihnPT09ZClyZXR1cm4gbWQoZSksYjtnPWcuc2libGluZ31FKFwiMTg4XCIpfWlmKGNbXCJyZXR1cm5cIl0hPT1kW1wicmV0dXJuXCJdKWM9ZSxkPWY7ZWxzZXtnPSExO2Zvcih2YXIgaD1lLmNoaWxkO2g7KXtpZihoPT09Yyl7Zz0hMDtjPWU7ZD1mO2JyZWFrfWlmKGg9PT1kKXtnPSEwO2Q9ZTtjPWY7YnJlYWt9aD1oLnNpYmxpbmd9aWYoIWcpe2ZvcihoPWYuY2hpbGQ7aDspe2lmKGg9PT1jKXtnPSEwO2M9ZjtkPWU7YnJlYWt9aWYoaD09PWQpe2c9ITA7ZD1mO2M9ZTticmVha31oPWguc2libGluZ31nP1xudm9pZCAwOkUoXCIxODlcIil9fWMuYWx0ZXJuYXRlIT09ZD9FKFwiMTkwXCIpOnZvaWQgMH0zIT09Yy50YWc/RShcIjE4OFwiKTp2b2lkIDA7cmV0dXJuIGMuc3RhdGVOb2RlLmN1cnJlbnQ9PT1jP2E6Yn1mdW5jdGlvbiBvZChhKXthPW5kKGEpO2lmKCFhKXJldHVybiBudWxsO2Zvcih2YXIgYj1hOzspe2lmKDU9PT1iLnRhZ3x8Nj09PWIudGFnKXJldHVybiBiO2lmKGIuY2hpbGQpYi5jaGlsZFtcInJldHVyblwiXT1iLGI9Yi5jaGlsZDtlbHNle2lmKGI9PT1hKWJyZWFrO2Zvcig7IWIuc2libGluZzspe2lmKCFiW1wicmV0dXJuXCJdfHxiW1wicmV0dXJuXCJdPT09YSlyZXR1cm4gbnVsbDtiPWJbXCJyZXR1cm5cIl19Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9fXJldHVybiBudWxsfVxuZnVuY3Rpb24gcGQoYSl7YT1uZChhKTtpZighYSlyZXR1cm4gbnVsbDtmb3IodmFyIGI9YTs7KXtpZig1PT09Yi50YWd8fDY9PT1iLnRhZylyZXR1cm4gYjtpZihiLmNoaWxkJiY0IT09Yi50YWcpYi5jaGlsZFtcInJldHVyblwiXT1iLGI9Yi5jaGlsZDtlbHNle2lmKGI9PT1hKWJyZWFrO2Zvcig7IWIuc2libGluZzspe2lmKCFiW1wicmV0dXJuXCJdfHxiW1wicmV0dXJuXCJdPT09YSlyZXR1cm4gbnVsbDtiPWJbXCJyZXR1cm5cIl19Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9fXJldHVybiBudWxsfXZhciBxZD1bXTtcbmZ1bmN0aW9uIHJkKGEpe3ZhciBiPWEudGFyZ2V0SW5zdDtkb3tpZighYil7YS5hbmNlc3RvcnMucHVzaChiKTticmVha312YXIgYztmb3IoYz1iO2NbXCJyZXR1cm5cIl07KWM9Y1tcInJldHVyblwiXTtjPTMhPT1jLnRhZz9udWxsOmMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87aWYoIWMpYnJlYWs7YS5hbmNlc3RvcnMucHVzaChiKTtiPXBiKGMpfXdoaWxlKGIpO2ZvcihjPTA7YzxhLmFuY2VzdG9ycy5sZW5ndGg7YysrKWI9YS5hbmNlc3RvcnNbY10sc2QoYS50b3BMZXZlbFR5cGUsYixhLm5hdGl2ZUV2ZW50LHdjKGEubmF0aXZlRXZlbnQpKX12YXIgdGQ9ITAsc2Q9dm9pZCAwO2Z1bmN0aW9uIHVkKGEpe3RkPSEhYX1mdW5jdGlvbiBVKGEsYixjKXtyZXR1cm4gYz9iYS5saXN0ZW4oYyxiLHZkLmJpbmQobnVsbCxhKSk6bnVsbH1mdW5jdGlvbiB3ZChhLGIsYyl7cmV0dXJuIGM/YmEuY2FwdHVyZShjLGIsdmQuYmluZChudWxsLGEpKTpudWxsfVxuZnVuY3Rpb24gdmQoYSxiKXtpZih0ZCl7dmFyIGM9d2MoYik7Yz1wYihjKTtudWxsPT09Y3x8XCJudW1iZXJcIiE9PXR5cGVvZiBjLnRhZ3x8Mj09PWtkKGMpfHwoYz1udWxsKTtpZihxZC5sZW5ndGgpe3ZhciBkPXFkLnBvcCgpO2QudG9wTGV2ZWxUeXBlPWE7ZC5uYXRpdmVFdmVudD1iO2QudGFyZ2V0SW5zdD1jO2E9ZH1lbHNlIGE9e3RvcExldmVsVHlwZTphLG5hdGl2ZUV2ZW50OmIsdGFyZ2V0SW5zdDpjLGFuY2VzdG9yczpbXX07dHJ5e3RjKHJkLGEpfWZpbmFsbHl7YS50b3BMZXZlbFR5cGU9bnVsbCxhLm5hdGl2ZUV2ZW50PW51bGwsYS50YXJnZXRJbnN0PW51bGwsYS5hbmNlc3RvcnMubGVuZ3RoPTAsMTA+cWQubGVuZ3RoJiZxZC5wdXNoKGEpfX19XG52YXIgeGQ9T2JqZWN0LmZyZWV6ZSh7Z2V0IF9lbmFibGVkKCl7cmV0dXJuIHRkfSxnZXQgX2hhbmRsZVRvcExldmVsKCl7cmV0dXJuIHNkfSxzZXRIYW5kbGVUb3BMZXZlbDpmdW5jdGlvbihhKXtzZD1hfSxzZXRFbmFibGVkOnVkLGlzRW5hYmxlZDpmdW5jdGlvbigpe3JldHVybiB0ZH0sdHJhcEJ1YmJsZWRFdmVudDpVLHRyYXBDYXB0dXJlZEV2ZW50OndkLGRpc3BhdGNoRXZlbnQ6dmR9KTtmdW5jdGlvbiB5ZChhLGIpe3ZhciBjPXt9O2NbYS50b0xvd2VyQ2FzZSgpXT1iLnRvTG93ZXJDYXNlKCk7Y1tcIldlYmtpdFwiK2FdPVwid2Via2l0XCIrYjtjW1wiTW96XCIrYV09XCJtb3pcIitiO2NbXCJtc1wiK2FdPVwiTVNcIitiO2NbXCJPXCIrYV09XCJvXCIrYi50b0xvd2VyQ2FzZSgpO3JldHVybiBjfVxudmFyIHpkPXthbmltYXRpb25lbmQ6eWQoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvbkVuZFwiKSxhbmltYXRpb25pdGVyYXRpb246eWQoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvbkl0ZXJhdGlvblwiKSxhbmltYXRpb25zdGFydDp5ZChcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uU3RhcnRcIiksdHJhbnNpdGlvbmVuZDp5ZChcIlRyYW5zaXRpb25cIixcIlRyYW5zaXRpb25FbmRcIil9LEFkPXt9LEJkPXt9O2wuY2FuVXNlRE9NJiYoQmQ9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5zdHlsZSxcIkFuaW1hdGlvbkV2ZW50XCJpbiB3aW5kb3d8fChkZWxldGUgemQuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbixkZWxldGUgemQuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbixkZWxldGUgemQuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uKSxcIlRyYW5zaXRpb25FdmVudFwiaW4gd2luZG93fHxkZWxldGUgemQudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uKTtcbmZ1bmN0aW9uIENkKGEpe2lmKEFkW2FdKXJldHVybiBBZFthXTtpZighemRbYV0pcmV0dXJuIGE7dmFyIGI9emRbYV0sYztmb3IoYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykmJmMgaW4gQmQpcmV0dXJuIEFkW2FdPWJbY107cmV0dXJuXCJcIn1cbnZhciBEZD17dG9wQWJvcnQ6XCJhYm9ydFwiLHRvcEFuaW1hdGlvbkVuZDpDZChcImFuaW1hdGlvbmVuZFwiKXx8XCJhbmltYXRpb25lbmRcIix0b3BBbmltYXRpb25JdGVyYXRpb246Q2QoXCJhbmltYXRpb25pdGVyYXRpb25cIil8fFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIsdG9wQW5pbWF0aW9uU3RhcnQ6Q2QoXCJhbmltYXRpb25zdGFydFwiKXx8XCJhbmltYXRpb25zdGFydFwiLHRvcEJsdXI6XCJibHVyXCIsdG9wQ2FuY2VsOlwiY2FuY2VsXCIsdG9wQ2FuUGxheTpcImNhbnBsYXlcIix0b3BDYW5QbGF5VGhyb3VnaDpcImNhbnBsYXl0aHJvdWdoXCIsdG9wQ2hhbmdlOlwiY2hhbmdlXCIsdG9wQ2xpY2s6XCJjbGlja1wiLHRvcENsb3NlOlwiY2xvc2VcIix0b3BDb21wb3NpdGlvbkVuZDpcImNvbXBvc2l0aW9uZW5kXCIsdG9wQ29tcG9zaXRpb25TdGFydDpcImNvbXBvc2l0aW9uc3RhcnRcIix0b3BDb21wb3NpdGlvblVwZGF0ZTpcImNvbXBvc2l0aW9udXBkYXRlXCIsdG9wQ29udGV4dE1lbnU6XCJjb250ZXh0bWVudVwiLHRvcENvcHk6XCJjb3B5XCIsXG50b3BDdXQ6XCJjdXRcIix0b3BEb3VibGVDbGljazpcImRibGNsaWNrXCIsdG9wRHJhZzpcImRyYWdcIix0b3BEcmFnRW5kOlwiZHJhZ2VuZFwiLHRvcERyYWdFbnRlcjpcImRyYWdlbnRlclwiLHRvcERyYWdFeGl0OlwiZHJhZ2V4aXRcIix0b3BEcmFnTGVhdmU6XCJkcmFnbGVhdmVcIix0b3BEcmFnT3ZlcjpcImRyYWdvdmVyXCIsdG9wRHJhZ1N0YXJ0OlwiZHJhZ3N0YXJ0XCIsdG9wRHJvcDpcImRyb3BcIix0b3BEdXJhdGlvbkNoYW5nZTpcImR1cmF0aW9uY2hhbmdlXCIsdG9wRW1wdGllZDpcImVtcHRpZWRcIix0b3BFbmNyeXB0ZWQ6XCJlbmNyeXB0ZWRcIix0b3BFbmRlZDpcImVuZGVkXCIsdG9wRXJyb3I6XCJlcnJvclwiLHRvcEZvY3VzOlwiZm9jdXNcIix0b3BJbnB1dDpcImlucHV0XCIsdG9wS2V5RG93bjpcImtleWRvd25cIix0b3BLZXlQcmVzczpcImtleXByZXNzXCIsdG9wS2V5VXA6XCJrZXl1cFwiLHRvcExvYWRlZERhdGE6XCJsb2FkZWRkYXRhXCIsdG9wTG9hZDpcImxvYWRcIix0b3BMb2FkZWRNZXRhZGF0YTpcImxvYWRlZG1ldGFkYXRhXCIsdG9wTG9hZFN0YXJ0OlwibG9hZHN0YXJ0XCIsXG50b3BNb3VzZURvd246XCJtb3VzZWRvd25cIix0b3BNb3VzZU1vdmU6XCJtb3VzZW1vdmVcIix0b3BNb3VzZU91dDpcIm1vdXNlb3V0XCIsdG9wTW91c2VPdmVyOlwibW91c2VvdmVyXCIsdG9wTW91c2VVcDpcIm1vdXNldXBcIix0b3BQYXN0ZTpcInBhc3RlXCIsdG9wUGF1c2U6XCJwYXVzZVwiLHRvcFBsYXk6XCJwbGF5XCIsdG9wUGxheWluZzpcInBsYXlpbmdcIix0b3BQcm9ncmVzczpcInByb2dyZXNzXCIsdG9wUmF0ZUNoYW5nZTpcInJhdGVjaGFuZ2VcIix0b3BTY3JvbGw6XCJzY3JvbGxcIix0b3BTZWVrZWQ6XCJzZWVrZWRcIix0b3BTZWVraW5nOlwic2Vla2luZ1wiLHRvcFNlbGVjdGlvbkNoYW5nZTpcInNlbGVjdGlvbmNoYW5nZVwiLHRvcFN0YWxsZWQ6XCJzdGFsbGVkXCIsdG9wU3VzcGVuZDpcInN1c3BlbmRcIix0b3BUZXh0SW5wdXQ6XCJ0ZXh0SW5wdXRcIix0b3BUaW1lVXBkYXRlOlwidGltZXVwZGF0ZVwiLHRvcFRvZ2dsZTpcInRvZ2dsZVwiLHRvcFRvdWNoQ2FuY2VsOlwidG91Y2hjYW5jZWxcIix0b3BUb3VjaEVuZDpcInRvdWNoZW5kXCIsdG9wVG91Y2hNb3ZlOlwidG91Y2htb3ZlXCIsXG50b3BUb3VjaFN0YXJ0OlwidG91Y2hzdGFydFwiLHRvcFRyYW5zaXRpb25FbmQ6Q2QoXCJ0cmFuc2l0aW9uZW5kXCIpfHxcInRyYW5zaXRpb25lbmRcIix0b3BWb2x1bWVDaGFuZ2U6XCJ2b2x1bWVjaGFuZ2VcIix0b3BXYWl0aW5nOlwid2FpdGluZ1wiLHRvcFdoZWVsOlwid2hlZWxcIn0sRWQ9e30sRmQ9MCxHZD1cIl9yZWFjdExpc3RlbmVyc0lEXCIrKFwiXCIrTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7ZnVuY3Rpb24gSGQoYSl7T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGEsR2QpfHwoYVtHZF09RmQrKyxFZFthW0dkXV09e30pO3JldHVybiBFZFthW0dkXV19ZnVuY3Rpb24gSWQoYSl7Zm9yKDthJiZhLmZpcnN0Q2hpbGQ7KWE9YS5maXJzdENoaWxkO3JldHVybiBhfVxuZnVuY3Rpb24gSmQoYSxiKXt2YXIgYz1JZChhKTthPTA7Zm9yKHZhciBkO2M7KXtpZigzPT09Yy5ub2RlVHlwZSl7ZD1hK2MudGV4dENvbnRlbnQubGVuZ3RoO2lmKGE8PWImJmQ+PWIpcmV0dXJue25vZGU6YyxvZmZzZXQ6Yi1hfTthPWR9YTp7Zm9yKDtjOyl7aWYoYy5uZXh0U2libGluZyl7Yz1jLm5leHRTaWJsaW5nO2JyZWFrIGF9Yz1jLnBhcmVudE5vZGV9Yz12b2lkIDB9Yz1JZChjKX19ZnVuY3Rpb24gS2QoYSl7dmFyIGI9YSYmYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVybiBiJiYoXCJpbnB1dFwiPT09YiYmXCJ0ZXh0XCI9PT1hLnR5cGV8fFwidGV4dGFyZWFcIj09PWJ8fFwidHJ1ZVwiPT09YS5jb250ZW50RWRpdGFibGUpfVxudmFyIExkPWwuY2FuVXNlRE9NJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJjExPj1kb2N1bWVudC5kb2N1bWVudE1vZGUsTWQ9e3NlbGVjdDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvblNlbGVjdFwiLGNhcHR1cmVkOlwib25TZWxlY3RDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29udGV4dE1lbnUgdG9wRm9jdXMgdG9wS2V5RG93biB0b3BLZXlVcCB0b3BNb3VzZURvd24gdG9wTW91c2VVcCB0b3BTZWxlY3Rpb25DaGFuZ2VcIi5zcGxpdChcIiBcIil9fSxOZD1udWxsLE9kPW51bGwsUGQ9bnVsbCxRZD0hMTtcbmZ1bmN0aW9uIFJkKGEsYil7aWYoUWR8fG51bGw9PU5kfHxOZCE9PWRhKCkpcmV0dXJuIG51bGw7dmFyIGM9TmQ7XCJzZWxlY3Rpb25TdGFydFwiaW4gYyYmS2QoYyk/Yz17c3RhcnQ6Yy5zZWxlY3Rpb25TdGFydCxlbmQ6Yy5zZWxlY3Rpb25FbmR9OndpbmRvdy5nZXRTZWxlY3Rpb24/KGM9d2luZG93LmdldFNlbGVjdGlvbigpLGM9e2FuY2hvck5vZGU6Yy5hbmNob3JOb2RlLGFuY2hvck9mZnNldDpjLmFuY2hvck9mZnNldCxmb2N1c05vZGU6Yy5mb2N1c05vZGUsZm9jdXNPZmZzZXQ6Yy5mb2N1c09mZnNldH0pOmM9dm9pZCAwO3JldHVybiBQZCYmZWEoUGQsYyk/bnVsbDooUGQ9YyxhPVQuZ2V0UG9vbGVkKE1kLnNlbGVjdCxPZCxhLGIpLGEudHlwZT1cInNlbGVjdFwiLGEudGFyZ2V0PU5kLEFiKGEpLGEpfVxudmFyIFNkPXtldmVudFR5cGVzOk1kLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9ZC53aW5kb3c9PT1kP2QuZG9jdW1lbnQ6OT09PWQubm9kZVR5cGU/ZDpkLm93bmVyRG9jdW1lbnQsZjtpZighKGY9IWUpKXthOntlPUhkKGUpO2Y9U2Eub25TZWxlY3Q7Zm9yKHZhciBnPTA7ZzxmLmxlbmd0aDtnKyspe3ZhciBoPWZbZ107aWYoIWUuaGFzT3duUHJvcGVydHkoaCl8fCFlW2hdKXtlPSExO2JyZWFrIGF9fWU9ITB9Zj0hZX1pZihmKXJldHVybiBudWxsO2U9Yj9xYihiKTp3aW5kb3c7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BGb2N1c1wiOmlmKHZjKGUpfHxcInRydWVcIj09PWUuY29udGVudEVkaXRhYmxlKU5kPWUsT2Q9YixQZD1udWxsO2JyZWFrO2Nhc2UgXCJ0b3BCbHVyXCI6UGQ9T2Q9TmQ9bnVsbDticmVhaztjYXNlIFwidG9wTW91c2VEb3duXCI6UWQ9ITA7YnJlYWs7Y2FzZSBcInRvcENvbnRleHRNZW51XCI6Y2FzZSBcInRvcE1vdXNlVXBcIjpyZXR1cm4gUWQ9ITEsUmQoYyxkKTtjYXNlIFwidG9wU2VsZWN0aW9uQ2hhbmdlXCI6aWYoTGQpYnJlYWs7XG5jYXNlIFwidG9wS2V5RG93blwiOmNhc2UgXCJ0b3BLZXlVcFwiOnJldHVybiBSZChjLGQpfXJldHVybiBudWxsfX07ZnVuY3Rpb24gVGQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVQuYXVnbWVudENsYXNzKFRkLHthbmltYXRpb25OYW1lOm51bGwsZWxhcHNlZFRpbWU6bnVsbCxwc2V1ZG9FbGVtZW50Om51bGx9KTtmdW5jdGlvbiBVZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9VC5hdWdtZW50Q2xhc3MoVWQse2NsaXBib2FyZERhdGE6ZnVuY3Rpb24oYSl7cmV0dXJuXCJjbGlwYm9hcmREYXRhXCJpbiBhP2EuY2xpcGJvYXJkRGF0YTp3aW5kb3cuY2xpcGJvYXJkRGF0YX19KTtmdW5jdGlvbiBWZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9YmQuYXVnbWVudENsYXNzKFZkLHtyZWxhdGVkVGFyZ2V0Om51bGx9KTtcbmZ1bmN0aW9uIFdkKGEpe3ZhciBiPWEua2V5Q29kZTtcImNoYXJDb2RlXCJpbiBhPyhhPWEuY2hhckNvZGUsMD09PWEmJjEzPT09YiYmKGE9MTMpKTphPWI7cmV0dXJuIDMyPD1hfHwxMz09PWE/YTowfVxudmFyIFhkPXtFc2M6XCJFc2NhcGVcIixTcGFjZWJhcjpcIiBcIixMZWZ0OlwiQXJyb3dMZWZ0XCIsVXA6XCJBcnJvd1VwXCIsUmlnaHQ6XCJBcnJvd1JpZ2h0XCIsRG93bjpcIkFycm93RG93blwiLERlbDpcIkRlbGV0ZVwiLFdpbjpcIk9TXCIsTWVudTpcIkNvbnRleHRNZW51XCIsQXBwczpcIkNvbnRleHRNZW51XCIsU2Nyb2xsOlwiU2Nyb2xsTG9ja1wiLE1velByaW50YWJsZUtleTpcIlVuaWRlbnRpZmllZFwifSxZZD17ODpcIkJhY2tzcGFjZVwiLDk6XCJUYWJcIiwxMjpcIkNsZWFyXCIsMTM6XCJFbnRlclwiLDE2OlwiU2hpZnRcIiwxNzpcIkNvbnRyb2xcIiwxODpcIkFsdFwiLDE5OlwiUGF1c2VcIiwyMDpcIkNhcHNMb2NrXCIsMjc6XCJFc2NhcGVcIiwzMjpcIiBcIiwzMzpcIlBhZ2VVcFwiLDM0OlwiUGFnZURvd25cIiwzNTpcIkVuZFwiLDM2OlwiSG9tZVwiLDM3OlwiQXJyb3dMZWZ0XCIsMzg6XCJBcnJvd1VwXCIsMzk6XCJBcnJvd1JpZ2h0XCIsNDA6XCJBcnJvd0Rvd25cIiw0NTpcIkluc2VydFwiLDQ2OlwiRGVsZXRlXCIsMTEyOlwiRjFcIiwxMTM6XCJGMlwiLDExNDpcIkYzXCIsMTE1OlwiRjRcIixcbjExNjpcIkY1XCIsMTE3OlwiRjZcIiwxMTg6XCJGN1wiLDExOTpcIkY4XCIsMTIwOlwiRjlcIiwxMjE6XCJGMTBcIiwxMjI6XCJGMTFcIiwxMjM6XCJGMTJcIiwxNDQ6XCJOdW1Mb2NrXCIsMTQ1OlwiU2Nyb2xsTG9ja1wiLDIyNDpcIk1ldGFcIn07ZnVuY3Rpb24gWmQoYSxiLGMsZCl7cmV0dXJuIFQuY2FsbCh0aGlzLGEsYixjLGQpfVxuYmQuYXVnbWVudENsYXNzKFpkLHtrZXk6ZnVuY3Rpb24oYSl7aWYoYS5rZXkpe3ZhciBiPVhkW2Eua2V5XXx8YS5rZXk7aWYoXCJVbmlkZW50aWZpZWRcIiE9PWIpcmV0dXJuIGJ9cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlPyhhPVdkKGEpLDEzPT09YT9cIkVudGVyXCI6U3RyaW5nLmZyb21DaGFyQ29kZShhKSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9ZZFthLmtleUNvZGVdfHxcIlVuaWRlbnRpZmllZFwiOlwiXCJ9LGxvY2F0aW9uOm51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLHJlcGVhdDpudWxsLGxvY2FsZTpudWxsLGdldE1vZGlmaWVyU3RhdGU6ZWQsY2hhckNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09YS50eXBlP1dkKGEpOjB9LGtleUNvZGU6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH0sd2hpY2g6ZnVuY3Rpb24oYSl7cmV0dXJuXCJrZXlwcmVzc1wiPT09XG5hLnR5cGU/V2QoYSk6XCJrZXlkb3duXCI9PT1hLnR5cGV8fFwia2V5dXBcIj09PWEudHlwZT9hLmtleUNvZGU6MH19KTtmdW5jdGlvbiAkZChhLGIsYyxkKXtyZXR1cm4gVC5jYWxsKHRoaXMsYSxiLGMsZCl9ZmQuYXVnbWVudENsYXNzKCRkLHtkYXRhVHJhbnNmZXI6bnVsbH0pO2Z1bmN0aW9uIGFlKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1iZC5hdWdtZW50Q2xhc3MoYWUse3RvdWNoZXM6bnVsbCx0YXJnZXRUb3VjaGVzOm51bGwsY2hhbmdlZFRvdWNoZXM6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsZ2V0TW9kaWZpZXJTdGF0ZTplZH0pO2Z1bmN0aW9uIGJlKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1ULmF1Z21lbnRDbGFzcyhiZSx7cHJvcGVydHlOYW1lOm51bGwsZWxhcHNlZFRpbWU6bnVsbCxwc2V1ZG9FbGVtZW50Om51bGx9KTtcbmZ1bmN0aW9uIGNlKGEsYixjLGQpe3JldHVybiBULmNhbGwodGhpcyxhLGIsYyxkKX1mZC5hdWdtZW50Q2xhc3MoY2Use2RlbHRhWDpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWFwiaW4gYT9hLmRlbHRhWDpcIndoZWVsRGVsdGFYXCJpbiBhPy1hLndoZWVsRGVsdGFYOjB9LGRlbHRhWTpmdW5jdGlvbihhKXtyZXR1cm5cImRlbHRhWVwiaW4gYT9hLmRlbHRhWTpcIndoZWVsRGVsdGFZXCJpbiBhPy1hLndoZWVsRGVsdGFZOlwid2hlZWxEZWx0YVwiaW4gYT8tYS53aGVlbERlbHRhOjB9LGRlbHRhWjpudWxsLGRlbHRhTW9kZTpudWxsfSk7dmFyIGRlPXt9LGVlPXt9O1xuXCJhYm9ydCBhbmltYXRpb25FbmQgYW5pbWF0aW9uSXRlcmF0aW9uIGFuaW1hdGlvblN0YXJ0IGJsdXIgY2FuY2VsIGNhblBsYXkgY2FuUGxheVRocm91Z2ggY2xpY2sgY2xvc2UgY29udGV4dE1lbnUgY29weSBjdXQgZG91YmxlQ2xpY2sgZHJhZyBkcmFnRW5kIGRyYWdFbnRlciBkcmFnRXhpdCBkcmFnTGVhdmUgZHJhZ092ZXIgZHJhZ1N0YXJ0IGRyb3AgZHVyYXRpb25DaGFuZ2UgZW1wdGllZCBlbmNyeXB0ZWQgZW5kZWQgZXJyb3IgZm9jdXMgaW5wdXQgaW52YWxpZCBrZXlEb3duIGtleVByZXNzIGtleVVwIGxvYWQgbG9hZGVkRGF0YSBsb2FkZWRNZXRhZGF0YSBsb2FkU3RhcnQgbW91c2VEb3duIG1vdXNlTW92ZSBtb3VzZU91dCBtb3VzZU92ZXIgbW91c2VVcCBwYXN0ZSBwYXVzZSBwbGF5IHBsYXlpbmcgcHJvZ3Jlc3MgcmF0ZUNoYW5nZSByZXNldCBzY3JvbGwgc2Vla2VkIHNlZWtpbmcgc3RhbGxlZCBzdWJtaXQgc3VzcGVuZCB0aW1lVXBkYXRlIHRvZ2dsZSB0b3VjaENhbmNlbCB0b3VjaEVuZCB0b3VjaE1vdmUgdG91Y2hTdGFydCB0cmFuc2l0aW9uRW5kIHZvbHVtZUNoYW5nZSB3YWl0aW5nIHdoZWVsXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YVswXS50b1VwcGVyQ2FzZSgpK1xuYS5zbGljZSgxKSxjPVwib25cIitiO2I9XCJ0b3BcIitiO2M9e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOmMsY2FwdHVyZWQ6YytcIkNhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOltiXX07ZGVbYV09YztlZVtiXT1jfSk7XG52YXIgZmU9e2V2ZW50VHlwZXM6ZGUsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1lZVthXTtpZighZSlyZXR1cm4gbnVsbDtzd2l0Y2goYSl7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoMD09PVdkKGMpKXJldHVybiBudWxsO2Nhc2UgXCJ0b3BLZXlEb3duXCI6Y2FzZSBcInRvcEtleVVwXCI6YT1aZDticmVhaztjYXNlIFwidG9wQmx1clwiOmNhc2UgXCJ0b3BGb2N1c1wiOmE9VmQ7YnJlYWs7Y2FzZSBcInRvcENsaWNrXCI6aWYoMj09PWMuYnV0dG9uKXJldHVybiBudWxsO2Nhc2UgXCJ0b3BEb3VibGVDbGlja1wiOmNhc2UgXCJ0b3BNb3VzZURvd25cIjpjYXNlIFwidG9wTW91c2VNb3ZlXCI6Y2FzZSBcInRvcE1vdXNlVXBcIjpjYXNlIFwidG9wTW91c2VPdXRcIjpjYXNlIFwidG9wTW91c2VPdmVyXCI6Y2FzZSBcInRvcENvbnRleHRNZW51XCI6YT1mZDticmVhaztjYXNlIFwidG9wRHJhZ1wiOmNhc2UgXCJ0b3BEcmFnRW5kXCI6Y2FzZSBcInRvcERyYWdFbnRlclwiOmNhc2UgXCJ0b3BEcmFnRXhpdFwiOmNhc2UgXCJ0b3BEcmFnTGVhdmVcIjpjYXNlIFwidG9wRHJhZ092ZXJcIjpjYXNlIFwidG9wRHJhZ1N0YXJ0XCI6Y2FzZSBcInRvcERyb3BcIjphPVxuJGQ7YnJlYWs7Y2FzZSBcInRvcFRvdWNoQ2FuY2VsXCI6Y2FzZSBcInRvcFRvdWNoRW5kXCI6Y2FzZSBcInRvcFRvdWNoTW92ZVwiOmNhc2UgXCJ0b3BUb3VjaFN0YXJ0XCI6YT1hZTticmVhaztjYXNlIFwidG9wQW5pbWF0aW9uRW5kXCI6Y2FzZSBcInRvcEFuaW1hdGlvbkl0ZXJhdGlvblwiOmNhc2UgXCJ0b3BBbmltYXRpb25TdGFydFwiOmE9VGQ7YnJlYWs7Y2FzZSBcInRvcFRyYW5zaXRpb25FbmRcIjphPWJlO2JyZWFrO2Nhc2UgXCJ0b3BTY3JvbGxcIjphPWJkO2JyZWFrO2Nhc2UgXCJ0b3BXaGVlbFwiOmE9Y2U7YnJlYWs7Y2FzZSBcInRvcENvcHlcIjpjYXNlIFwidG9wQ3V0XCI6Y2FzZSBcInRvcFBhc3RlXCI6YT1VZDticmVhaztkZWZhdWx0OmE9VH1iPWEuZ2V0UG9vbGVkKGUsYixjLGQpO0FiKGIpO3JldHVybiBifX07c2Q9ZnVuY3Rpb24oYSxiLGMsZCl7YT1qYihhLGIsYyxkKTtrYihhKTtsYighMSl9O2hiLmluamVjdEV2ZW50UGx1Z2luT3JkZXIoXCJSZXNwb25kZXJFdmVudFBsdWdpbiBTaW1wbGVFdmVudFBsdWdpbiBUYXBFdmVudFBsdWdpbiBFbnRlckxlYXZlRXZlbnRQbHVnaW4gQ2hhbmdlRXZlbnRQbHVnaW4gU2VsZWN0RXZlbnRQbHVnaW4gQmVmb3JlSW5wdXRFdmVudFBsdWdpblwiLnNwbGl0KFwiIFwiKSk7XG5XYT1zYi5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1hhPXNiLmdldEluc3RhbmNlRnJvbU5vZGU7WWE9c2IuZ2V0Tm9kZUZyb21JbnN0YW5jZTtoYi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1NpbXBsZUV2ZW50UGx1Z2luOmZlLEVudGVyTGVhdmVFdmVudFBsdWdpbjpoZCxDaGFuZ2VFdmVudFBsdWdpbjphZCxTZWxlY3RFdmVudFBsdWdpbjpTZCxCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOmljfSk7dmFyIGdlPVtdLGhlPS0xO2Z1bmN0aW9uIFYoYSl7MD5oZXx8KGEuY3VycmVudD1nZVtoZV0sZ2VbaGVdPW51bGwsaGUtLSl9ZnVuY3Rpb24gVyhhLGIpe2hlKys7Z2VbaGVdPWEuY3VycmVudDthLmN1cnJlbnQ9Yn1uZXcgU2V0O3ZhciBpZT17Y3VycmVudDpEfSxYPXtjdXJyZW50OiExfSxqZT1EO2Z1bmN0aW9uIGtlKGEpe3JldHVybiBsZShhKT9qZTppZS5jdXJyZW50fVxuZnVuY3Rpb24gbWUoYSxiKXt2YXIgYz1hLnR5cGUuY29udGV4dFR5cGVzO2lmKCFjKXJldHVybiBEO3ZhciBkPWEuc3RhdGVOb2RlO2lmKGQmJmQuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD09PWIpcmV0dXJuIGQuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7dmFyIGU9e30sZjtmb3IoZiBpbiBjKWVbZl09YltmXTtkJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9YixhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWUpO3JldHVybiBlfWZ1bmN0aW9uIGxlKGEpe3JldHVybiAyPT09YS50YWcmJm51bGwhPWEudHlwZS5jaGlsZENvbnRleHRUeXBlc31mdW5jdGlvbiBuZShhKXtsZShhKSYmKFYoWCxhKSxWKGllLGEpKX1cbmZ1bmN0aW9uIG9lKGEsYixjKXtudWxsIT1pZS5jdXJzb3I/RShcIjE2OFwiKTp2b2lkIDA7VyhpZSxiLGEpO1coWCxjLGEpfWZ1bmN0aW9uIHBlKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGUsZD1hLnR5cGUuY2hpbGRDb250ZXh0VHlwZXM7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGMuZ2V0Q2hpbGRDb250ZXh0KXJldHVybiBiO2M9Yy5nZXRDaGlsZENvbnRleHQoKTtmb3IodmFyIGUgaW4gYyllIGluIGQ/dm9pZCAwOkUoXCIxMDhcIixqZChhKXx8XCJVbmtub3duXCIsZSk7cmV0dXJuIEIoe30sYixjKX1mdW5jdGlvbiBxZShhKXtpZighbGUoYSkpcmV0dXJuITE7dmFyIGI9YS5zdGF0ZU5vZGU7Yj1iJiZiLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0fHxEO2plPWllLmN1cnJlbnQ7VyhpZSxiLGEpO1coWCxYLmN1cnJlbnQsYSk7cmV0dXJuITB9XG5mdW5jdGlvbiByZShhLGIpe3ZhciBjPWEuc3RhdGVOb2RlO2M/dm9pZCAwOkUoXCIxNjlcIik7aWYoYil7dmFyIGQ9cGUoYSxqZSk7Yy5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dD1kO1YoWCxhKTtWKGllLGEpO1coaWUsZCxhKX1lbHNlIFYoWCxhKTtXKFgsYixhKX1cbmZ1bmN0aW9uIFkoYSxiLGMpe3RoaXMudGFnPWE7dGhpcy5rZXk9Yjt0aGlzLnN0YXRlTm9kZT10aGlzLnR5cGU9bnVsbDt0aGlzLnNpYmxpbmc9dGhpcy5jaGlsZD10aGlzW1wicmV0dXJuXCJdPW51bGw7dGhpcy5pbmRleD0wO3RoaXMubWVtb2l6ZWRTdGF0ZT10aGlzLnVwZGF0ZVF1ZXVlPXRoaXMubWVtb2l6ZWRQcm9wcz10aGlzLnBlbmRpbmdQcm9wcz10aGlzLnJlZj1udWxsO3RoaXMuaW50ZXJuYWxDb250ZXh0VGFnPWM7dGhpcy5lZmZlY3RUYWc9MDt0aGlzLmxhc3RFZmZlY3Q9dGhpcy5maXJzdEVmZmVjdD10aGlzLm5leHRFZmZlY3Q9bnVsbDt0aGlzLmV4cGlyYXRpb25UaW1lPTA7dGhpcy5hbHRlcm5hdGU9bnVsbH1cbmZ1bmN0aW9uIHNlKGEsYixjKXt2YXIgZD1hLmFsdGVybmF0ZTtudWxsPT09ZD8oZD1uZXcgWShhLnRhZyxhLmtleSxhLmludGVybmFsQ29udGV4dFRhZyksZC50eXBlPWEudHlwZSxkLnN0YXRlTm9kZT1hLnN0YXRlTm9kZSxkLmFsdGVybmF0ZT1hLGEuYWx0ZXJuYXRlPWQpOihkLmVmZmVjdFRhZz0wLGQubmV4dEVmZmVjdD1udWxsLGQuZmlyc3RFZmZlY3Q9bnVsbCxkLmxhc3RFZmZlY3Q9bnVsbCk7ZC5leHBpcmF0aW9uVGltZT1jO2QucGVuZGluZ1Byb3BzPWI7ZC5jaGlsZD1hLmNoaWxkO2QubWVtb2l6ZWRQcm9wcz1hLm1lbW9pemVkUHJvcHM7ZC5tZW1vaXplZFN0YXRlPWEubWVtb2l6ZWRTdGF0ZTtkLnVwZGF0ZVF1ZXVlPWEudXBkYXRlUXVldWU7ZC5zaWJsaW5nPWEuc2libGluZztkLmluZGV4PWEuaW5kZXg7ZC5yZWY9YS5yZWY7cmV0dXJuIGR9XG5mdW5jdGlvbiB0ZShhLGIsYyl7dmFyIGQ9dm9pZCAwLGU9YS50eXBlLGY9YS5rZXk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGU/KGQ9ZS5wcm90b3R5cGUmJmUucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQ/bmV3IFkoMixmLGIpOm5ldyBZKDAsZixiKSxkLnR5cGU9ZSxkLnBlbmRpbmdQcm9wcz1hLnByb3BzKTpcInN0cmluZ1wiPT09dHlwZW9mIGU/KGQ9bmV3IFkoNSxmLGIpLGQudHlwZT1lLGQucGVuZGluZ1Byb3BzPWEucHJvcHMpOlwib2JqZWN0XCI9PT10eXBlb2YgZSYmbnVsbCE9PWUmJlwibnVtYmVyXCI9PT10eXBlb2YgZS50YWc/KGQ9ZSxkLnBlbmRpbmdQcm9wcz1hLnByb3BzKTpFKFwiMTMwXCIsbnVsbD09ZT9lOnR5cGVvZiBlLFwiXCIpO2QuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gZH1mdW5jdGlvbiB1ZShhLGIsYyxkKXtiPW5ldyBZKDEwLGQsYik7Yi5wZW5kaW5nUHJvcHM9YTtiLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGJ9XG5mdW5jdGlvbiB2ZShhLGIsYyl7Yj1uZXcgWSg2LG51bGwsYik7Yi5wZW5kaW5nUHJvcHM9YTtiLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGJ9ZnVuY3Rpb24gd2UoYSxiLGMpe2I9bmV3IFkoNyxhLmtleSxiKTtiLnR5cGU9YS5oYW5kbGVyO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifWZ1bmN0aW9uIHhlKGEsYixjKXthPW5ldyBZKDksbnVsbCxiKTthLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGF9ZnVuY3Rpb24geWUoYSxiLGMpe2I9bmV3IFkoNCxhLmtleSxiKTtiLnBlbmRpbmdQcm9wcz1hLmNoaWxkcmVufHxbXTtiLmV4cGlyYXRpb25UaW1lPWM7Yi5zdGF0ZU5vZGU9e2NvbnRhaW5lckluZm86YS5jb250YWluZXJJbmZvLHBlbmRpbmdDaGlsZHJlbjpudWxsLGltcGxlbWVudGF0aW9uOmEuaW1wbGVtZW50YXRpb259O3JldHVybiBifXZhciB6ZT1udWxsLEFlPW51bGw7XG5mdW5jdGlvbiBCZShhKXtyZXR1cm4gZnVuY3Rpb24oYil7dHJ5e3JldHVybiBhKGIpfWNhdGNoKGMpe319fWZ1bmN0aW9uIENlKGEpe2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fKXJldHVybiExO3ZhciBiPV9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztpZihiLmlzRGlzYWJsZWR8fCFiLnN1cHBvcnRzRmliZXIpcmV0dXJuITA7dHJ5e3ZhciBjPWIuaW5qZWN0KGEpO3plPUJlKGZ1bmN0aW9uKGEpe3JldHVybiBiLm9uQ29tbWl0RmliZXJSb290KGMsYSl9KTtBZT1CZShmdW5jdGlvbihhKXtyZXR1cm4gYi5vbkNvbW1pdEZpYmVyVW5tb3VudChjLGEpfSl9Y2F0Y2goZCl7fXJldHVybiEwfWZ1bmN0aW9uIERlKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiB6ZSYmemUoYSl9ZnVuY3Rpb24gRWUoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIEFlJiZBZShhKX1cbmZ1bmN0aW9uIEZlKGEpe3JldHVybntiYXNlU3RhdGU6YSxleHBpcmF0aW9uVGltZTowLGZpcnN0Om51bGwsbGFzdDpudWxsLGNhbGxiYWNrTGlzdDpudWxsLGhhc0ZvcmNlVXBkYXRlOiExLGlzSW5pdGlhbGl6ZWQ6ITF9fWZ1bmN0aW9uIEdlKGEsYil7bnVsbD09PWEubGFzdD9hLmZpcnN0PWEubGFzdD1iOihhLmxhc3QubmV4dD1iLGEubGFzdD1iKTtpZigwPT09YS5leHBpcmF0aW9uVGltZXx8YS5leHBpcmF0aW9uVGltZT5iLmV4cGlyYXRpb25UaW1lKWEuZXhwaXJhdGlvblRpbWU9Yi5leHBpcmF0aW9uVGltZX1cbmZ1bmN0aW9uIEhlKGEsYil7dmFyIGM9YS5hbHRlcm5hdGUsZD1hLnVwZGF0ZVF1ZXVlO251bGw9PT1kJiYoZD1hLnVwZGF0ZVF1ZXVlPUZlKG51bGwpKTtudWxsIT09Yz8oYT1jLnVwZGF0ZVF1ZXVlLG51bGw9PT1hJiYoYT1jLnVwZGF0ZVF1ZXVlPUZlKG51bGwpKSk6YT1udWxsO2E9YSE9PWQ/YTpudWxsO251bGw9PT1hP0dlKGQsYik6bnVsbD09PWQubGFzdHx8bnVsbD09PWEubGFzdD8oR2UoZCxiKSxHZShhLGIpKTooR2UoZCxiKSxhLmxhc3Q9Yil9ZnVuY3Rpb24gSWUoYSxiLGMsZCl7YT1hLnBhcnRpYWxTdGF0ZTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hLmNhbGwoYixjLGQpOmF9XG5mdW5jdGlvbiBKZShhLGIsYyxkLGUsZil7bnVsbCE9PWEmJmEudXBkYXRlUXVldWU9PT1jJiYoYz1iLnVwZGF0ZVF1ZXVlPXtiYXNlU3RhdGU6Yy5iYXNlU3RhdGUsZXhwaXJhdGlvblRpbWU6Yy5leHBpcmF0aW9uVGltZSxmaXJzdDpjLmZpcnN0LGxhc3Q6Yy5sYXN0LGlzSW5pdGlhbGl6ZWQ6Yy5pc0luaXRpYWxpemVkLGNhbGxiYWNrTGlzdDpudWxsLGhhc0ZvcmNlVXBkYXRlOiExfSk7Yy5leHBpcmF0aW9uVGltZT0wO2MuaXNJbml0aWFsaXplZD9hPWMuYmFzZVN0YXRlOihhPWMuYmFzZVN0YXRlPWIubWVtb2l6ZWRTdGF0ZSxjLmlzSW5pdGlhbGl6ZWQ9ITApO2Zvcih2YXIgZz0hMCxoPWMuZmlyc3Qsaz0hMTtudWxsIT09aDspe3ZhciBxPWguZXhwaXJhdGlvblRpbWU7aWYocT5mKXt2YXIgdj1jLmV4cGlyYXRpb25UaW1lO2lmKDA9PT12fHx2PnEpYy5leHBpcmF0aW9uVGltZT1xO2t8fChrPSEwLGMuYmFzZVN0YXRlPWEpfWVsc2V7a3x8KGMuZmlyc3Q9aC5uZXh0LG51bGw9PT1cbmMuZmlyc3QmJihjLmxhc3Q9bnVsbCkpO2lmKGguaXNSZXBsYWNlKWE9SWUoaCxkLGEsZSksZz0hMDtlbHNlIGlmKHE9SWUoaCxkLGEsZSkpYT1nP0Ioe30sYSxxKTpCKGEscSksZz0hMTtoLmlzRm9yY2VkJiYoYy5oYXNGb3JjZVVwZGF0ZT0hMCk7bnVsbCE9PWguY2FsbGJhY2smJihxPWMuY2FsbGJhY2tMaXN0LG51bGw9PT1xJiYocT1jLmNhbGxiYWNrTGlzdD1bXSkscS5wdXNoKGgpKX1oPWgubmV4dH1udWxsIT09Yy5jYWxsYmFja0xpc3Q/Yi5lZmZlY3RUYWd8PTMyOm51bGwhPT1jLmZpcnN0fHxjLmhhc0ZvcmNlVXBkYXRlfHwoYi51cGRhdGVRdWV1ZT1udWxsKTtrfHwoYy5iYXNlU3RhdGU9YSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBLZShhLGIpe3ZhciBjPWEuY2FsbGJhY2tMaXN0O2lmKG51bGwhPT1jKWZvcihhLmNhbGxiYWNrTGlzdD1udWxsLGE9MDthPGMubGVuZ3RoO2ErKyl7dmFyIGQ9Y1thXSxlPWQuY2FsbGJhY2s7ZC5jYWxsYmFjaz1udWxsO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBlP0UoXCIxOTFcIixlKTp2b2lkIDA7ZS5jYWxsKGIpfX1cbmZ1bmN0aW9uIExlKGEsYixjLGQpe2Z1bmN0aW9uIGUoYSxiKXtiLnVwZGF0ZXI9ZjthLnN0YXRlTm9kZT1iO2IuX3JlYWN0SW50ZXJuYWxGaWJlcj1hfXZhciBmPXtpc01vdW50ZWQ6bGQsZW5xdWV1ZVNldFN0YXRlOmZ1bmN0aW9uKGMsZCxlKXtjPWMuX3JlYWN0SW50ZXJuYWxGaWJlcjtlPXZvaWQgMD09PWU/bnVsbDplO3ZhciBnPWIoYyk7SGUoYyx7ZXhwaXJhdGlvblRpbWU6ZyxwYXJ0aWFsU3RhdGU6ZCxjYWxsYmFjazplLGlzUmVwbGFjZTohMSxpc0ZvcmNlZDohMSxuZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTthKGMsZyl9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oYyxkLGUpe2M9Yy5fcmVhY3RJbnRlcm5hbEZpYmVyO2U9dm9pZCAwPT09ZT9udWxsOmU7dmFyIGc9YihjKTtIZShjLHtleHBpcmF0aW9uVGltZTpnLHBhcnRpYWxTdGF0ZTpkLGNhbGxiYWNrOmUsaXNSZXBsYWNlOiEwLGlzRm9yY2VkOiExLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO1xuYShjLGcpfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oYyxkKXtjPWMuX3JlYWN0SW50ZXJuYWxGaWJlcjtkPXZvaWQgMD09PWQ/bnVsbDpkO3ZhciBlPWIoYyk7SGUoYyx7ZXhwaXJhdGlvblRpbWU6ZSxwYXJ0aWFsU3RhdGU6bnVsbCxjYWxsYmFjazpkLGlzUmVwbGFjZTohMSxpc0ZvcmNlZDohMCxuZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTthKGMsZSl9fTtyZXR1cm57YWRvcHRDbGFzc0luc3RhbmNlOmUsY29uc3RydWN0Q2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLGIpe3ZhciBjPWEudHlwZSxkPWtlKGEpLGY9Mj09PWEudGFnJiZudWxsIT1hLnR5cGUuY29udGV4dFR5cGVzLGc9Zj9tZShhLGQpOkQ7Yj1uZXcgYyhiLGcpO2UoYSxiKTtmJiYoYT1hLnN0YXRlTm9kZSxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9ZCxhLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0PWcpO3JldHVybiBifSxtb3VudENsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxcbmIpe3ZhciBjPWEuYWx0ZXJuYXRlLGQ9YS5zdGF0ZU5vZGUsZT1kLnN0YXRlfHxudWxsLGc9YS5wZW5kaW5nUHJvcHM7Zz92b2lkIDA6RShcIjE1OFwiKTt2YXIgaD1rZShhKTtkLnByb3BzPWc7ZC5zdGF0ZT1hLm1lbW9pemVkU3RhdGU9ZTtkLnJlZnM9RDtkLmNvbnRleHQ9bWUoYSxoKTtudWxsIT1hLnR5cGUmJm51bGwhPWEudHlwZS5wcm90b3R5cGUmJiEwPT09YS50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQmJihhLmludGVybmFsQ29udGV4dFRhZ3w9MSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50V2lsbE1vdW50JiYoZT1kLnN0YXRlLGQuY29tcG9uZW50V2lsbE1vdW50KCksZSE9PWQuc3RhdGUmJmYuZW5xdWV1ZVJlcGxhY2VTdGF0ZShkLGQuc3RhdGUsbnVsbCksZT1hLnVwZGF0ZVF1ZXVlLG51bGwhPT1lJiYoZC5zdGF0ZT1KZShjLGEsZSxkLGcsYikpKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnREaWRNb3VudCYmKGEuZWZmZWN0VGFnfD1cbjQpfSx1cGRhdGVDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsYixlKXt2YXIgZz1iLnN0YXRlTm9kZTtnLnByb3BzPWIubWVtb2l6ZWRQcm9wcztnLnN0YXRlPWIubWVtb2l6ZWRTdGF0ZTt2YXIgaD1iLm1lbW9pemVkUHJvcHMsaz1iLnBlbmRpbmdQcm9wcztrfHwoaz1oLG51bGw9PWs/RShcIjE1OVwiKTp2b2lkIDApO3ZhciB1PWcuY29udGV4dCx6PWtlKGIpO3o9bWUoYix6KTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzfHxoPT09ayYmdT09PXp8fCh1PWcuc3RhdGUsZy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKGsseiksZy5zdGF0ZSE9PXUmJmYuZW5xdWV1ZVJlcGxhY2VTdGF0ZShnLGcuc3RhdGUsbnVsbCkpO3U9Yi5tZW1vaXplZFN0YXRlO2U9bnVsbCE9PWIudXBkYXRlUXVldWU/SmUoYSxiLGIudXBkYXRlUXVldWUsZyxrLGUpOnU7aWYoIShoIT09a3x8dSE9PWV8fFguY3VycmVudHx8bnVsbCE9PWIudXBkYXRlUXVldWUmJmIudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpKXJldHVyblwiZnVuY3Rpb25cIiE9PVxudHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxoPT09YS5tZW1vaXplZFByb3BzJiZ1PT09YS5tZW1vaXplZFN0YXRlfHwoYi5lZmZlY3RUYWd8PTQpLCExO3ZhciBHPWs7aWYobnVsbD09PWh8fG51bGwhPT1iLnVwZGF0ZVF1ZXVlJiZiLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKUc9ITA7ZWxzZXt2YXIgST1iLnN0YXRlTm9kZSxMPWIudHlwZTtHPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBJLnNob3VsZENvbXBvbmVudFVwZGF0ZT9JLnNob3VsZENvbXBvbmVudFVwZGF0ZShHLGUseik6TC5wcm90b3R5cGUmJkwucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50PyFlYShoLEcpfHwhZWEodSxlKTohMH1HPyhcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnRXaWxsVXBkYXRlJiZnLmNvbXBvbmVudFdpbGxVcGRhdGUoayxlLHopLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZSYmKGIuZWZmZWN0VGFnfD00KSk6KFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZXx8XG5oPT09YS5tZW1vaXplZFByb3BzJiZ1PT09YS5tZW1vaXplZFN0YXRlfHwoYi5lZmZlY3RUYWd8PTQpLGMoYixrKSxkKGIsZSkpO2cucHJvcHM9aztnLnN0YXRlPWU7Zy5jb250ZXh0PXo7cmV0dXJuIEd9fX12YXIgUWU9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sW1wiZm9yXCJdLFJlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmVsZW1lbnRcIik6NjAxMDMsU2U9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuY2FsbFwiKTo2MDEwNCxUZT1RZT9TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5yZXR1cm5cIik6NjAxMDUsVWU9UWU/U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucG9ydGFsXCIpOjYwMTA2LFZlPVFlP1N5bWJvbFtcImZvclwiXShcInJlYWN0LmZyYWdtZW50XCIpOjYwMTA3LFdlPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcjtcbmZ1bmN0aW9uIFhlKGEpe2lmKG51bGw9PT1hfHxcInVuZGVmaW5lZFwiPT09dHlwZW9mIGEpcmV0dXJuIG51bGw7YT1XZSYmYVtXZV18fGFbXCJAQGl0ZXJhdG9yXCJdO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2E6bnVsbH12YXIgWWU9QXJyYXkuaXNBcnJheTtcbmZ1bmN0aW9uIFplKGEsYil7dmFyIGM9Yi5yZWY7aWYobnVsbCE9PWMmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjKXtpZihiLl9vd25lcil7Yj1iLl9vd25lcjt2YXIgZD12b2lkIDA7YiYmKDIhPT1iLnRhZz9FKFwiMTEwXCIpOnZvaWQgMCxkPWIuc3RhdGVOb2RlKTtkP3ZvaWQgMDpFKFwiMTQ3XCIsYyk7dmFyIGU9XCJcIitjO2lmKG51bGwhPT1hJiZudWxsIT09YS5yZWYmJmEucmVmLl9zdHJpbmdSZWY9PT1lKXJldHVybiBhLnJlZjthPWZ1bmN0aW9uKGEpe3ZhciBiPWQucmVmcz09PUQ/ZC5yZWZzPXt9OmQucmVmcztudWxsPT09YT9kZWxldGUgYltlXTpiW2VdPWF9O2EuX3N0cmluZ1JlZj1lO3JldHVybiBhfVwic3RyaW5nXCIhPT10eXBlb2YgYz9FKFwiMTQ4XCIpOnZvaWQgMDtiLl9vd25lcj92b2lkIDA6RShcIjE0OVwiLGMpfXJldHVybiBjfVxuZnVuY3Rpb24gJGUoYSxiKXtcInRleHRhcmVhXCIhPT1hLnR5cGUmJkUoXCIzMVwiLFwiW29iamVjdCBPYmplY3RdXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYik/XCJvYmplY3Qgd2l0aCBrZXlzIHtcIitPYmplY3Qua2V5cyhiKS5qb2luKFwiLCBcIikrXCJ9XCI6YixcIlwiKX1cbmZ1bmN0aW9uIGFmKGEpe2Z1bmN0aW9uIGIoYixjKXtpZihhKXt2YXIgZD1iLmxhc3RFZmZlY3Q7bnVsbCE9PWQ/KGQubmV4dEVmZmVjdD1jLGIubGFzdEVmZmVjdD1jKTpiLmZpcnN0RWZmZWN0PWIubGFzdEVmZmVjdD1jO2MubmV4dEVmZmVjdD1udWxsO2MuZWZmZWN0VGFnPTh9fWZ1bmN0aW9uIGMoYyxkKXtpZighYSlyZXR1cm4gbnVsbDtmb3IoO251bGwhPT1kOyliKGMsZCksZD1kLnNpYmxpbmc7cmV0dXJuIG51bGx9ZnVuY3Rpb24gZChhLGIpe2ZvcihhPW5ldyBNYXA7bnVsbCE9PWI7KW51bGwhPT1iLmtleT9hLnNldChiLmtleSxiKTphLnNldChiLmluZGV4LGIpLGI9Yi5zaWJsaW5nO3JldHVybiBhfWZ1bmN0aW9uIGUoYSxiLGMpe2E9c2UoYSxiLGMpO2EuaW5kZXg9MDthLnNpYmxpbmc9bnVsbDtyZXR1cm4gYX1mdW5jdGlvbiBmKGIsYyxkKXtiLmluZGV4PWQ7aWYoIWEpcmV0dXJuIGM7ZD1iLmFsdGVybmF0ZTtpZihudWxsIT09ZClyZXR1cm4gZD1kLmluZGV4LGQ8Yz8oYi5lZmZlY3RUYWc9XG4yLGMpOmQ7Yi5lZmZlY3RUYWc9MjtyZXR1cm4gY31mdW5jdGlvbiBnKGIpe2EmJm51bGw9PT1iLmFsdGVybmF0ZSYmKGIuZWZmZWN0VGFnPTIpO3JldHVybiBifWZ1bmN0aW9uIGgoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDYhPT1iLnRhZylyZXR1cm4gYj12ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLGMsZCk7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIGsoYSxiLGMsZCl7aWYobnVsbCE9PWImJmIudHlwZT09PWMudHlwZSlyZXR1cm4gZD1lKGIsYy5wcm9wcyxkKSxkLnJlZj1aZShiLGMpLGRbXCJyZXR1cm5cIl09YSxkO2Q9dGUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKTtkLnJlZj1aZShiLGMpO2RbXCJyZXR1cm5cIl09YTtyZXR1cm4gZH1mdW5jdGlvbiBxKGEsYixjLGQpe2lmKG51bGw9PT1ifHw3IT09Yi50YWcpcmV0dXJuIGI9d2UoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLGQpO1xuYltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIHYoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDkhPT1iLnRhZylyZXR1cm4gYj14ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpLGIudHlwZT1jLnZhbHVlLGJbXCJyZXR1cm5cIl09YSxiO2I9ZShiLG51bGwsZCk7Yi50eXBlPWMudmFsdWU7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIHkoYSxiLGMsZCl7aWYobnVsbD09PWJ8fDQhPT1iLnRhZ3x8Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyE9PWMuY29udGFpbmVySW5mb3x8Yi5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24hPT1jLmltcGxlbWVudGF0aW9uKXJldHVybiBiPXllKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1lKGIsYy5jaGlsZHJlbnx8W10sZCk7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIHUoYSxiLGMsZCxmKXtpZihudWxsPT09Ynx8MTAhPT1iLnRhZylyZXR1cm4gYj11ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLFxuZCxmKSxiW1wicmV0dXJuXCJdPWEsYjtiPWUoYixjLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB6KGEsYixjKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGJ8fFwibnVtYmVyXCI9PT10eXBlb2YgYilyZXR1cm4gYj12ZShcIlwiK2IsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYltcInJldHVyblwiXT1hLGI7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBiJiZudWxsIT09Yil7c3dpdGNoKGIuJCR0eXBlb2Ype2Nhc2UgUmU6aWYoYi50eXBlPT09VmUpcmV0dXJuIGI9dWUoYi5wcm9wcy5jaGlsZHJlbixhLmludGVybmFsQ29udGV4dFRhZyxjLGIua2V5KSxiW1wicmV0dXJuXCJdPWEsYjtjPXRlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyk7Yy5yZWY9WmUobnVsbCxiKTtjW1wicmV0dXJuXCJdPWE7cmV0dXJuIGM7Y2FzZSBTZTpyZXR1cm4gYj13ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxiO2Nhc2UgVGU6cmV0dXJuIGM9eGUoYixhLmludGVybmFsQ29udGV4dFRhZyxcbmMpLGMudHlwZT1iLnZhbHVlLGNbXCJyZXR1cm5cIl09YSxjO2Nhc2UgVWU6cmV0dXJuIGI9eWUoYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYn1pZihZZShiKXx8WGUoYikpcmV0dXJuIGI9dWUoYixhLmludGVybmFsQ29udGV4dFRhZyxjLG51bGwpLGJbXCJyZXR1cm5cIl09YSxiOyRlKGEsYil9cmV0dXJuIG51bGx9ZnVuY3Rpb24gRyhhLGIsYyxkKXt2YXIgZT1udWxsIT09Yj9iLmtleTpudWxsO2lmKFwic3RyaW5nXCI9PT10eXBlb2YgY3x8XCJudW1iZXJcIj09PXR5cGVvZiBjKXJldHVybiBudWxsIT09ZT9udWxsOmgoYSxiLFwiXCIrYyxkKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGMmJm51bGwhPT1jKXtzd2l0Y2goYy4kJHR5cGVvZil7Y2FzZSBSZTpyZXR1cm4gYy5rZXk9PT1lP2MudHlwZT09PVZlP3UoYSxiLGMucHJvcHMuY2hpbGRyZW4sZCxlKTprKGEsYixjLGQpOm51bGw7Y2FzZSBTZTpyZXR1cm4gYy5rZXk9PT1lP3EoYSxiLGMsZCk6bnVsbDtjYXNlIFRlOnJldHVybiBudWxsPT09XG5lP3YoYSxiLGMsZCk6bnVsbDtjYXNlIFVlOnJldHVybiBjLmtleT09PWU/eShhLGIsYyxkKTpudWxsfWlmKFllKGMpfHxYZShjKSlyZXR1cm4gbnVsbCE9PWU/bnVsbDp1KGEsYixjLGQsbnVsbCk7JGUoYSxjKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBJKGEsYixjLGQsZSl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBkfHxcIm51bWJlclwiPT09dHlwZW9mIGQpcmV0dXJuIGE9YS5nZXQoYyl8fG51bGwsaChiLGEsXCJcIitkLGUpO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgZCYmbnVsbCE9PWQpe3N3aXRjaChkLiQkdHlwZW9mKXtjYXNlIFJlOnJldHVybiBhPWEuZ2V0KG51bGw9PT1kLmtleT9jOmQua2V5KXx8bnVsbCxkLnR5cGU9PT1WZT91KGIsYSxkLnByb3BzLmNoaWxkcmVuLGUsZC5rZXkpOmsoYixhLGQsZSk7Y2FzZSBTZTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwscShiLGEsZCxlKTtjYXNlIFRlOnJldHVybiBhPWEuZ2V0KGMpfHxudWxsLHYoYixhLGQsZSk7Y2FzZSBVZTpyZXR1cm4gYT1cbmEuZ2V0KG51bGw9PT1kLmtleT9jOmQua2V5KXx8bnVsbCx5KGIsYSxkLGUpfWlmKFllKGQpfHxYZShkKSlyZXR1cm4gYT1hLmdldChjKXx8bnVsbCx1KGIsYSxkLGUsbnVsbCk7JGUoYixkKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBMKGUsZyxtLEEpe2Zvcih2YXIgaD1udWxsLHI9bnVsbCxuPWcsdz1nPTAsaz1udWxsO251bGwhPT1uJiZ3PG0ubGVuZ3RoO3crKyl7bi5pbmRleD53PyhrPW4sbj1udWxsKTprPW4uc2libGluZzt2YXIgeD1HKGUsbixtW3ddLEEpO2lmKG51bGw9PT14KXtudWxsPT09biYmKG49ayk7YnJlYWt9YSYmbiYmbnVsbD09PXguYWx0ZXJuYXRlJiZiKGUsbik7Zz1mKHgsZyx3KTtudWxsPT09cj9oPXg6ci5zaWJsaW5nPXg7cj14O249a31pZih3PT09bS5sZW5ndGgpcmV0dXJuIGMoZSxuKSxoO2lmKG51bGw9PT1uKXtmb3IoO3c8bS5sZW5ndGg7dysrKWlmKG49eihlLG1bd10sQSkpZz1mKG4sZyx3KSxudWxsPT09cj9oPW46ci5zaWJsaW5nPW4scj1uO3JldHVybiBofWZvcihuPVxuZChlLG4pO3c8bS5sZW5ndGg7dysrKWlmKGs9SShuLGUsdyxtW3ddLEEpKXtpZihhJiZudWxsIT09ay5hbHRlcm5hdGUpbltcImRlbGV0ZVwiXShudWxsPT09ay5rZXk/dzprLmtleSk7Zz1mKGssZyx3KTtudWxsPT09cj9oPWs6ci5zaWJsaW5nPWs7cj1rfWEmJm4uZm9yRWFjaChmdW5jdGlvbihhKXtyZXR1cm4gYihlLGEpfSk7cmV0dXJuIGh9ZnVuY3Rpb24gTihlLGcsbSxBKXt2YXIgaD1YZShtKTtcImZ1bmN0aW9uXCIhPT10eXBlb2YgaD9FKFwiMTUwXCIpOnZvaWQgMDttPWguY2FsbChtKTtudWxsPT1tP0UoXCIxNTFcIik6dm9pZCAwO2Zvcih2YXIgcj1oPW51bGwsbj1nLHc9Zz0wLGs9bnVsbCx4PW0ubmV4dCgpO251bGwhPT1uJiYheC5kb25lO3crKyx4PW0ubmV4dCgpKXtuLmluZGV4Pnc/KGs9bixuPW51bGwpOms9bi5zaWJsaW5nO3ZhciBKPUcoZSxuLHgudmFsdWUsQSk7aWYobnVsbD09PUope258fChuPWspO2JyZWFrfWEmJm4mJm51bGw9PT1KLmFsdGVybmF0ZSYmYihlLG4pO2c9ZihKLFxuZyx3KTtudWxsPT09cj9oPUo6ci5zaWJsaW5nPUo7cj1KO249a31pZih4LmRvbmUpcmV0dXJuIGMoZSxuKSxoO2lmKG51bGw9PT1uKXtmb3IoOyF4LmRvbmU7dysrLHg9bS5uZXh0KCkpeD16KGUseC52YWx1ZSxBKSxudWxsIT09eCYmKGc9Zih4LGcsdyksbnVsbD09PXI/aD14OnIuc2libGluZz14LHI9eCk7cmV0dXJuIGh9Zm9yKG49ZChlLG4pOyF4LmRvbmU7dysrLHg9bS5uZXh0KCkpaWYoeD1JKG4sZSx3LHgudmFsdWUsQSksbnVsbCE9PXgpe2lmKGEmJm51bGwhPT14LmFsdGVybmF0ZSluW1wiZGVsZXRlXCJdKG51bGw9PT14LmtleT93Ongua2V5KTtnPWYoeCxnLHcpO251bGw9PT1yP2g9eDpyLnNpYmxpbmc9eDtyPXh9YSYmbi5mb3JFYWNoKGZ1bmN0aW9uKGEpe3JldHVybiBiKGUsYSl9KTtyZXR1cm4gaH1yZXR1cm4gZnVuY3Rpb24oYSxkLGYsaCl7XCJvYmplY3RcIj09PXR5cGVvZiBmJiZudWxsIT09ZiYmZi50eXBlPT09VmUmJm51bGw9PT1mLmtleSYmKGY9Zi5wcm9wcy5jaGlsZHJlbik7XG52YXIgbT1cIm9iamVjdFwiPT09dHlwZW9mIGYmJm51bGwhPT1mO2lmKG0pc3dpdGNoKGYuJCR0eXBlb2Ype2Nhc2UgUmU6YTp7dmFyIHI9Zi5rZXk7Zm9yKG09ZDtudWxsIT09bTspe2lmKG0ua2V5PT09cilpZigxMD09PW0udGFnP2YudHlwZT09PVZlOm0udHlwZT09PWYudHlwZSl7YyhhLG0uc2libGluZyk7ZD1lKG0sZi50eXBlPT09VmU/Zi5wcm9wcy5jaGlsZHJlbjpmLnByb3BzLGgpO2QucmVmPVplKG0sZik7ZFtcInJldHVyblwiXT1hO2E9ZDticmVhayBhfWVsc2V7YyhhLG0pO2JyZWFrfWVsc2UgYihhLG0pO209bS5zaWJsaW5nfWYudHlwZT09PVZlPyhkPXVlKGYucHJvcHMuY2hpbGRyZW4sYS5pbnRlcm5hbENvbnRleHRUYWcsaCxmLmtleSksZFtcInJldHVyblwiXT1hLGE9ZCk6KGg9dGUoZixhLmludGVybmFsQ29udGV4dFRhZyxoKSxoLnJlZj1aZShkLGYpLGhbXCJyZXR1cm5cIl09YSxhPWgpfXJldHVybiBnKGEpO2Nhc2UgU2U6YTp7Zm9yKG09Zi5rZXk7bnVsbCE9PWQ7KXtpZihkLmtleT09PVxubSlpZig3PT09ZC50YWcpe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLGYsaCk7ZFtcInJldHVyblwiXT1hO2E9ZDticmVhayBhfWVsc2V7YyhhLGQpO2JyZWFrfWVsc2UgYihhLGQpO2Q9ZC5zaWJsaW5nfWQ9d2UoZixhLmludGVybmFsQ29udGV4dFRhZyxoKTtkW1wicmV0dXJuXCJdPWE7YT1kfXJldHVybiBnKGEpO2Nhc2UgVGU6YTp7aWYobnVsbCE9PWQpaWYoOT09PWQudGFnKXtjKGEsZC5zaWJsaW5nKTtkPWUoZCxudWxsLGgpO2QudHlwZT1mLnZhbHVlO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNlIGMoYSxkKTtkPXhlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7ZC50eXBlPWYudmFsdWU7ZFtcInJldHVyblwiXT1hO2E9ZH1yZXR1cm4gZyhhKTtjYXNlIFVlOmE6e2ZvcihtPWYua2V5O251bGwhPT1kOyl7aWYoZC5rZXk9PT1tKWlmKDQ9PT1kLnRhZyYmZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbz09PWYuY29udGFpbmVySW5mbyYmZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb249PT1cbmYuaW1wbGVtZW50YXRpb24pe2MoYSxkLnNpYmxpbmcpO2Q9ZShkLGYuY2hpbGRyZW58fFtdLGgpO2RbXCJyZXR1cm5cIl09YTthPWQ7YnJlYWsgYX1lbHNle2MoYSxkKTticmVha31lbHNlIGIoYSxkKTtkPWQuc2libGluZ31kPXllKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCk7ZFtcInJldHVyblwiXT1hO2E9ZH1yZXR1cm4gZyhhKX1pZihcInN0cmluZ1wiPT09dHlwZW9mIGZ8fFwibnVtYmVyXCI9PT10eXBlb2YgZilyZXR1cm4gZj1cIlwiK2YsbnVsbCE9PWQmJjY9PT1kLnRhZz8oYyhhLGQuc2libGluZyksZD1lKGQsZixoKSk6KGMoYSxkKSxkPXZlKGYsYS5pbnRlcm5hbENvbnRleHRUYWcsaCkpLGRbXCJyZXR1cm5cIl09YSxhPWQsZyhhKTtpZihZZShmKSlyZXR1cm4gTChhLGQsZixoKTtpZihYZShmKSlyZXR1cm4gTihhLGQsZixoKTttJiYkZShhLGYpO2lmKFwidW5kZWZpbmVkXCI9PT10eXBlb2YgZilzd2l0Y2goYS50YWcpe2Nhc2UgMjpjYXNlIDE6aD1hLnR5cGUsRShcIjE1MlwiLGguZGlzcGxheU5hbWV8fFxuaC5uYW1lfHxcIkNvbXBvbmVudFwiKX1yZXR1cm4gYyhhLGQpfX12YXIgYmY9YWYoITApLGNmPWFmKCExKTtcbmZ1bmN0aW9uIGRmKGEsYixjLGQsZSl7ZnVuY3Rpb24gZihhLGIsYyl7dmFyIGQ9Yi5leHBpcmF0aW9uVGltZTtiLmNoaWxkPW51bGw9PT1hP2NmKGIsbnVsbCxjLGQpOmJmKGIsYS5jaGlsZCxjLGQpfWZ1bmN0aW9uIGcoYSxiKXt2YXIgYz1iLnJlZjtudWxsPT09Y3x8YSYmYS5yZWY9PT1jfHwoYi5lZmZlY3RUYWd8PTEyOCl9ZnVuY3Rpb24gaChhLGIsYyxkKXtnKGEsYik7aWYoIWMpcmV0dXJuIGQmJnJlKGIsITEpLHEoYSxiKTtjPWIuc3RhdGVOb2RlO2lkLmN1cnJlbnQ9Yjt2YXIgZT1jLnJlbmRlcigpO2IuZWZmZWN0VGFnfD0xO2YoYSxiLGUpO2IubWVtb2l6ZWRTdGF0ZT1jLnN0YXRlO2IubWVtb2l6ZWRQcm9wcz1jLnByb3BzO2QmJnJlKGIsITApO3JldHVybiBiLmNoaWxkfWZ1bmN0aW9uIGsoYSl7dmFyIGI9YS5zdGF0ZU5vZGU7Yi5wZW5kaW5nQ29udGV4dD9vZShhLGIucGVuZGluZ0NvbnRleHQsYi5wZW5kaW5nQ29udGV4dCE9PWIuY29udGV4dCk6Yi5jb250ZXh0JiZvZShhLFxuYi5jb250ZXh0LCExKTtJKGEsYi5jb250YWluZXJJbmZvKX1mdW5jdGlvbiBxKGEsYil7bnVsbCE9PWEmJmIuY2hpbGQhPT1hLmNoaWxkP0UoXCIxNTNcIik6dm9pZCAwO2lmKG51bGwhPT1iLmNoaWxkKXthPWIuY2hpbGQ7dmFyIGM9c2UoYSxhLnBlbmRpbmdQcm9wcyxhLmV4cGlyYXRpb25UaW1lKTtiLmNoaWxkPWM7Zm9yKGNbXCJyZXR1cm5cIl09YjtudWxsIT09YS5zaWJsaW5nOylhPWEuc2libGluZyxjPWMuc2libGluZz1zZShhLGEucGVuZGluZ1Byb3BzLGEuZXhwaXJhdGlvblRpbWUpLGNbXCJyZXR1cm5cIl09YjtjLnNpYmxpbmc9bnVsbH1yZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiB2KGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDM6ayhiKTticmVhaztjYXNlIDI6cWUoYik7YnJlYWs7Y2FzZSA0OkkoYixiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKX1yZXR1cm4gbnVsbH12YXIgeT1hLnNob3VsZFNldFRleHRDb250ZW50LHU9YS51c2VTeW5jU2NoZWR1bGluZyx6PWEuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSxcbkc9Yi5wdXNoSG9zdENvbnRleHQsST1iLnB1c2hIb3N0Q29udGFpbmVyLEw9Yy5lbnRlckh5ZHJhdGlvblN0YXRlLE49Yy5yZXNldEh5ZHJhdGlvblN0YXRlLEo9Yy50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTthPUxlKGQsZSxmdW5jdGlvbihhLGIpe2EubWVtb2l6ZWRQcm9wcz1ifSxmdW5jdGlvbihhLGIpe2EubWVtb2l6ZWRTdGF0ZT1ifSk7dmFyIHc9YS5hZG9wdENsYXNzSW5zdGFuY2UsbT1hLmNvbnN0cnVjdENsYXNzSW5zdGFuY2UsQT1hLm1vdW50Q2xhc3NJbnN0YW5jZSxPYj1hLnVwZGF0ZUNsYXNzSW5zdGFuY2U7cmV0dXJue2JlZ2luV29yazpmdW5jdGlvbihhLGIsYyl7aWYoMD09PWIuZXhwaXJhdGlvblRpbWV8fGIuZXhwaXJhdGlvblRpbWU+YylyZXR1cm4gdihhLGIpO3N3aXRjaChiLnRhZyl7Y2FzZSAwOm51bGwhPT1hP0UoXCIxNTVcIik6dm9pZCAwO3ZhciBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLHI9a2UoYik7cj1tZShiLHIpO2Q9ZChlLHIpO2IuZWZmZWN0VGFnfD1cbjE7XCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGQucmVuZGVyPyhiLnRhZz0yLGU9cWUoYiksdyhiLGQpLEEoYixjKSxiPWgoYSxiLCEwLGUpKTooYi50YWc9MSxmKGEsYixkKSxiLm1lbW9pemVkUHJvcHM9ZSxiPWIuY2hpbGQpO3JldHVybiBiO2Nhc2UgMTphOntlPWIudHlwZTtjPWIucGVuZGluZ1Byb3BzO2Q9Yi5tZW1vaXplZFByb3BzO2lmKFguY3VycmVudCludWxsPT09YyYmKGM9ZCk7ZWxzZSBpZihudWxsPT09Y3x8ZD09PWMpe2I9cShhLGIpO2JyZWFrIGF9ZD1rZShiKTtkPW1lKGIsZCk7ZT1lKGMsZCk7Yi5lZmZlY3RUYWd8PTE7ZihhLGIsZSk7Yi5tZW1vaXplZFByb3BzPWM7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgMjpyZXR1cm4gZT1xZShiKSxkPXZvaWQgMCxudWxsPT09YT9iLnN0YXRlTm9kZT9FKFwiMTUzXCIpOihtKGIsYi5wZW5kaW5nUHJvcHMpLEEoYixjKSxkPSEwKTpkPU9iKGEsYixjKSxoKGEsYixkLGUpO2Nhc2UgMzpyZXR1cm4gayhiKSxcbmU9Yi51cGRhdGVRdWV1ZSxudWxsIT09ZT8oZD1iLm1lbW9pemVkU3RhdGUsZT1KZShhLGIsZSxudWxsLG51bGwsYyksZD09PWU/KE4oKSxiPXEoYSxiKSk6KGQ9ZS5lbGVtZW50LHI9Yi5zdGF0ZU5vZGUsKG51bGw9PT1hfHxudWxsPT09YS5jaGlsZCkmJnIuaHlkcmF0ZSYmTChiKT8oYi5lZmZlY3RUYWd8PTIsYi5jaGlsZD1jZihiLG51bGwsZCxjKSk6KE4oKSxmKGEsYixkKSksYi5tZW1vaXplZFN0YXRlPWUsYj1iLmNoaWxkKSk6KE4oKSxiPXEoYSxiKSksYjtjYXNlIDU6RyhiKTtudWxsPT09YSYmSihiKTtlPWIudHlwZTt2YXIgbj1iLm1lbW9pemVkUHJvcHM7ZD1iLnBlbmRpbmdQcm9wcztudWxsPT09ZCYmKGQ9bixudWxsPT09ZD9FKFwiMTU0XCIpOnZvaWQgMCk7cj1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6bnVsbDtYLmN1cnJlbnR8fG51bGwhPT1kJiZuIT09ZD8obj1kLmNoaWxkcmVuLHkoZSxkKT9uPW51bGw6ciYmeShlLHIpJiYoYi5lZmZlY3RUYWd8PTE2KSxnKGEsYiksXG4yMTQ3NDgzNjQ3IT09YyYmIXUmJnooZSxkKT8oYi5leHBpcmF0aW9uVGltZT0yMTQ3NDgzNjQ3LGI9bnVsbCk6KGYoYSxiLG4pLGIubWVtb2l6ZWRQcm9wcz1kLGI9Yi5jaGlsZCkpOmI9cShhLGIpO3JldHVybiBiO2Nhc2UgNjpyZXR1cm4gbnVsbD09PWEmJkooYiksYT1iLnBlbmRpbmdQcm9wcyxudWxsPT09YSYmKGE9Yi5tZW1vaXplZFByb3BzKSxiLm1lbW9pemVkUHJvcHM9YSxudWxsO2Nhc2UgODpiLnRhZz03O2Nhc2UgNzplPWIucGVuZGluZ1Byb3BzO2lmKFguY3VycmVudCludWxsPT09ZSYmKGU9YSYmYS5tZW1vaXplZFByb3BzLG51bGw9PT1lP0UoXCIxNTRcIik6dm9pZCAwKTtlbHNlIGlmKG51bGw9PT1lfHxiLm1lbW9pemVkUHJvcHM9PT1lKWU9Yi5tZW1vaXplZFByb3BzO2Q9ZS5jaGlsZHJlbjtiLnN0YXRlTm9kZT1udWxsPT09YT9jZihiLGIuc3RhdGVOb2RlLGQsYyk6YmYoYixiLnN0YXRlTm9kZSxkLGMpO2IubWVtb2l6ZWRQcm9wcz1lO3JldHVybiBiLnN0YXRlTm9kZTtcbmNhc2UgOTpyZXR1cm4gbnVsbDtjYXNlIDQ6YTp7SShiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO2U9Yi5wZW5kaW5nUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1lJiYoZT1hJiZhLm1lbW9pemVkUHJvcHMsbnVsbD09ZT9FKFwiMTU0XCIpOnZvaWQgMCk7ZWxzZSBpZihudWxsPT09ZXx8Yi5tZW1vaXplZFByb3BzPT09ZSl7Yj1xKGEsYik7YnJlYWsgYX1udWxsPT09YT9iLmNoaWxkPWJmKGIsbnVsbCxlLGMpOmYoYSxiLGUpO2IubWVtb2l6ZWRQcm9wcz1lO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDEwOmE6e2M9Yi5wZW5kaW5nUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1jJiYoYz1iLm1lbW9pemVkUHJvcHMpO2Vsc2UgaWYobnVsbD09PWN8fGIubWVtb2l6ZWRQcm9wcz09PWMpe2I9cShhLGIpO2JyZWFrIGF9ZihhLGIsYyk7Yi5tZW1vaXplZFByb3BzPWM7Yj1iLmNoaWxkfXJldHVybiBiO2RlZmF1bHQ6RShcIjE1NlwiKX19LGJlZ2luRmFpbGVkV29yazpmdW5jdGlvbihhLGIsXG5jKXtzd2l0Y2goYi50YWcpe2Nhc2UgMjpxZShiKTticmVhaztjYXNlIDM6ayhiKTticmVhaztkZWZhdWx0OkUoXCIxNTdcIil9Yi5lZmZlY3RUYWd8PTY0O251bGw9PT1hP2IuY2hpbGQ9bnVsbDpiLmNoaWxkIT09YS5jaGlsZCYmKGIuY2hpbGQ9YS5jaGlsZCk7aWYoMD09PWIuZXhwaXJhdGlvblRpbWV8fGIuZXhwaXJhdGlvblRpbWU+YylyZXR1cm4gdihhLGIpO2IuZmlyc3RFZmZlY3Q9bnVsbDtiLmxhc3RFZmZlY3Q9bnVsbDtiLmNoaWxkPW51bGw9PT1hP2NmKGIsbnVsbCxudWxsLGMpOmJmKGIsYS5jaGlsZCxudWxsLGMpOzI9PT1iLnRhZyYmKGE9Yi5zdGF0ZU5vZGUsYi5tZW1vaXplZFByb3BzPWEucHJvcHMsYi5tZW1vaXplZFN0YXRlPWEuc3RhdGUpO3JldHVybiBiLmNoaWxkfX19XG5mdW5jdGlvbiBlZihhLGIsYyl7ZnVuY3Rpb24gZChhKXthLmVmZmVjdFRhZ3w9NH12YXIgZT1hLmNyZWF0ZUluc3RhbmNlLGY9YS5jcmVhdGVUZXh0SW5zdGFuY2UsZz1hLmFwcGVuZEluaXRpYWxDaGlsZCxoPWEuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4saz1hLnByZXBhcmVVcGRhdGUscT1hLnBlcnNpc3RlbmNlLHY9Yi5nZXRSb290SG9zdENvbnRhaW5lcix5PWIucG9wSG9zdENvbnRleHQsdT1iLmdldEhvc3RDb250ZXh0LHo9Yi5wb3BIb3N0Q29udGFpbmVyLEc9Yy5wcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLEk9Yy5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxMPWMucG9wSHlkcmF0aW9uU3RhdGUsTj12b2lkIDAsSj12b2lkIDAsdz12b2lkIDA7YS5tdXRhdGlvbj8oTj1mdW5jdGlvbigpe30sSj1mdW5jdGlvbihhLGIsYyl7KGIudXBkYXRlUXVldWU9YykmJmQoYil9LHc9ZnVuY3Rpb24oYSxiLGMsZSl7YyE9PWUmJmQoYil9KTpxP0UoXCIyMzVcIik6RShcIjIzNlwiKTtcbnJldHVybntjb21wbGV0ZVdvcms6ZnVuY3Rpb24oYSxiLGMpe3ZhciBtPWIucGVuZGluZ1Byb3BzO2lmKG51bGw9PT1tKW09Yi5tZW1vaXplZFByb3BzO2Vsc2UgaWYoMjE0NzQ4MzY0NyE9PWIuZXhwaXJhdGlvblRpbWV8fDIxNDc0ODM2NDc9PT1jKWIucGVuZGluZ1Byb3BzPW51bGw7c3dpdGNoKGIudGFnKXtjYXNlIDE6cmV0dXJuIG51bGw7Y2FzZSAyOnJldHVybiBuZShiKSxudWxsO2Nhc2UgMzp6KGIpO1YoWCxiKTtWKGllLGIpO209Yi5zdGF0ZU5vZGU7bS5wZW5kaW5nQ29udGV4dCYmKG0uY29udGV4dD1tLnBlbmRpbmdDb250ZXh0LG0ucGVuZGluZ0NvbnRleHQ9bnVsbCk7aWYobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKUwoYiksYi5lZmZlY3RUYWcmPS0zO04oYik7cmV0dXJuIG51bGw7Y2FzZSA1OnkoYik7Yz12KCk7dmFyIEE9Yi50eXBlO2lmKG51bGwhPT1hJiZudWxsIT1iLnN0YXRlTm9kZSl7dmFyIHA9YS5tZW1vaXplZFByb3BzLHE9Yi5zdGF0ZU5vZGUseD11KCk7cT1cbmsocSxBLHAsbSxjLHgpO0ooYSxiLHEsQSxwLG0sYyk7YS5yZWYhPT1iLnJlZiYmKGIuZWZmZWN0VGFnfD0xMjgpfWVsc2V7aWYoIW0pcmV0dXJuIG51bGw9PT1iLnN0YXRlTm9kZT9FKFwiMTY2XCIpOnZvaWQgMCxudWxsO2E9dSgpO2lmKEwoYikpRyhiLGMsYSkmJmQoYik7ZWxzZXthPWUoQSxtLGMsYSxiKTthOmZvcihwPWIuY2hpbGQ7bnVsbCE9PXA7KXtpZig1PT09cC50YWd8fDY9PT1wLnRhZylnKGEscC5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PXAudGFnJiZudWxsIT09cC5jaGlsZCl7cC5jaGlsZFtcInJldHVyblwiXT1wO3A9cC5jaGlsZDtjb250aW51ZX1pZihwPT09YilicmVhaztmb3IoO251bGw9PT1wLnNpYmxpbmc7KXtpZihudWxsPT09cFtcInJldHVyblwiXXx8cFtcInJldHVyblwiXT09PWIpYnJlYWsgYTtwPXBbXCJyZXR1cm5cIl19cC5zaWJsaW5nW1wicmV0dXJuXCJdPXBbXCJyZXR1cm5cIl07cD1wLnNpYmxpbmd9aChhLEEsbSxjKSYmZChiKTtiLnN0YXRlTm9kZT1hfW51bGwhPT1iLnJlZiYmXG4oYi5lZmZlY3RUYWd8PTEyOCl9cmV0dXJuIG51bGw7Y2FzZSA2OmlmKGEmJm51bGwhPWIuc3RhdGVOb2RlKXcoYSxiLGEubWVtb2l6ZWRQcm9wcyxtKTtlbHNle2lmKFwic3RyaW5nXCIhPT10eXBlb2YgbSlyZXR1cm4gbnVsbD09PWIuc3RhdGVOb2RlP0UoXCIxNjZcIik6dm9pZCAwLG51bGw7YT12KCk7Yz11KCk7TChiKT9JKGIpJiZkKGIpOmIuc3RhdGVOb2RlPWYobSxhLGMsYil9cmV0dXJuIG51bGw7Y2FzZSA3OihtPWIubWVtb2l6ZWRQcm9wcyk/dm9pZCAwOkUoXCIxNjVcIik7Yi50YWc9ODtBPVtdO2E6Zm9yKChwPWIuc3RhdGVOb2RlKSYmKHBbXCJyZXR1cm5cIl09Yik7bnVsbCE9PXA7KXtpZig1PT09cC50YWd8fDY9PT1wLnRhZ3x8ND09PXAudGFnKUUoXCIyNDdcIik7ZWxzZSBpZig5PT09cC50YWcpQS5wdXNoKHAudHlwZSk7ZWxzZSBpZihudWxsIT09cC5jaGlsZCl7cC5jaGlsZFtcInJldHVyblwiXT1wO3A9cC5jaGlsZDtjb250aW51ZX1mb3IoO251bGw9PT1wLnNpYmxpbmc7KXtpZihudWxsPT09XG5wW1wicmV0dXJuXCJdfHxwW1wicmV0dXJuXCJdPT09YilicmVhayBhO3A9cFtcInJldHVyblwiXX1wLnNpYmxpbmdbXCJyZXR1cm5cIl09cFtcInJldHVyblwiXTtwPXAuc2libGluZ31wPW0uaGFuZGxlcjttPXAobS5wcm9wcyxBKTtiLmNoaWxkPWJmKGIsbnVsbCE9PWE/YS5jaGlsZDpudWxsLG0sYyk7cmV0dXJuIGIuY2hpbGQ7Y2FzZSA4OnJldHVybiBiLnRhZz03LG51bGw7Y2FzZSA5OnJldHVybiBudWxsO2Nhc2UgMTA6cmV0dXJuIG51bGw7Y2FzZSA0OnJldHVybiB6KGIpLE4oYiksbnVsbDtjYXNlIDA6RShcIjE2N1wiKTtkZWZhdWx0OkUoXCIxNTZcIil9fX19XG5mdW5jdGlvbiBmZihhLGIpe2Z1bmN0aW9uIGMoYSl7dmFyIGM9YS5yZWY7aWYobnVsbCE9PWMpdHJ5e2MobnVsbCl9Y2F0Y2goQSl7YihhLEEpfX1mdW5jdGlvbiBkKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiBFZSYmRWUoYSk7c3dpdGNoKGEudGFnKXtjYXNlIDI6YyhhKTt2YXIgZD1hLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7ZC5wcm9wcz1hLm1lbW9pemVkUHJvcHMsZC5zdGF0ZT1hLm1lbW9pemVkU3RhdGUsZC5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKEEpe2IoYSxBKX1icmVhaztjYXNlIDU6YyhhKTticmVhaztjYXNlIDc6ZShhLnN0YXRlTm9kZSk7YnJlYWs7Y2FzZSA0OmsmJmcoYSl9fWZ1bmN0aW9uIGUoYSl7Zm9yKHZhciBiPWE7OylpZihkKGIpLG51bGw9PT1iLmNoaWxkfHxrJiY0PT09Yi50YWcpe2lmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iW1wicmV0dXJuXCJdfHxcbmJbXCJyZXR1cm5cIl09PT1hKXJldHVybjtiPWJbXCJyZXR1cm5cIl19Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9ZWxzZSBiLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIDU9PT1hLnRhZ3x8Mz09PWEudGFnfHw0PT09YS50YWd9ZnVuY3Rpb24gZyhhKXtmb3IodmFyIGI9YSxjPSExLGY9dm9pZCAwLGc9dm9pZCAwOzspe2lmKCFjKXtjPWJbXCJyZXR1cm5cIl07YTpmb3IoOzspe251bGw9PT1jP0UoXCIxNjBcIik6dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA1OmY9Yy5zdGF0ZU5vZGU7Zz0hMTticmVhayBhO2Nhc2UgMzpmPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zz0hMDticmVhayBhO2Nhc2UgNDpmPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zz0hMDticmVhayBhfWM9Y1tcInJldHVyblwiXX1jPSEwfWlmKDU9PT1iLnRhZ3x8Nj09PWIudGFnKWUoYiksZz9KKGYsYi5zdGF0ZU5vZGUpOk4oZixiLnN0YXRlTm9kZSk7XG5lbHNlIGlmKDQ9PT1iLnRhZz9mPWIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm86ZChiKSxudWxsIT09Yi5jaGlsZCl7Yi5jaGlsZFtcInJldHVyblwiXT1iO2I9Yi5jaGlsZDtjb250aW51ZX1pZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09YltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuO2I9YltcInJldHVyblwiXTs0PT09Yi50YWcmJihjPSExKX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319dmFyIGg9YS5nZXRQdWJsaWNJbnN0YW5jZSxrPWEubXV0YXRpb247YT1hLnBlcnNpc3RlbmNlO2t8fChhP0UoXCIyMzVcIik6RShcIjIzNlwiKSk7dmFyIHE9ay5jb21taXRNb3VudCx2PWsuY29tbWl0VXBkYXRlLHk9ay5yZXNldFRleHRDb250ZW50LHU9ay5jb21taXRUZXh0VXBkYXRlLHo9ay5hcHBlbmRDaGlsZCxHPWsuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixJPWsuaW5zZXJ0QmVmb3JlLEw9ay5pbnNlcnRJbkNvbnRhaW5lckJlZm9yZSxcbk49ay5yZW1vdmVDaGlsZCxKPWsucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO3JldHVybntjb21taXRSZXNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEpe3koYS5zdGF0ZU5vZGUpfSxjb21taXRQbGFjZW1lbnQ6ZnVuY3Rpb24oYSl7YTp7Zm9yKHZhciBiPWFbXCJyZXR1cm5cIl07bnVsbCE9PWI7KXtpZihmKGIpKXt2YXIgYz1iO2JyZWFrIGF9Yj1iW1wicmV0dXJuXCJdfUUoXCIxNjBcIik7Yz12b2lkIDB9dmFyIGQ9Yj12b2lkIDA7c3dpdGNoKGMudGFnKXtjYXNlIDU6Yj1jLnN0YXRlTm9kZTtkPSExO2JyZWFrO2Nhc2UgMzpiPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87ZD0hMDticmVhaztjYXNlIDQ6Yj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7ZGVmYXVsdDpFKFwiMTYxXCIpfWMuZWZmZWN0VGFnJjE2JiYoeShiKSxjLmVmZmVjdFRhZyY9LTE3KTthOmI6Zm9yKGM9YTs7KXtmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Y1tcInJldHVyblwiXXx8ZihjW1wicmV0dXJuXCJdKSl7Yz1cbm51bGw7YnJlYWsgYX1jPWNbXCJyZXR1cm5cIl19Yy5zaWJsaW5nW1wicmV0dXJuXCJdPWNbXCJyZXR1cm5cIl07Zm9yKGM9Yy5zaWJsaW5nOzUhPT1jLnRhZyYmNiE9PWMudGFnOyl7aWYoYy5lZmZlY3RUYWcmMiljb250aW51ZSBiO2lmKG51bGw9PT1jLmNoaWxkfHw0PT09Yy50YWcpY29udGludWUgYjtlbHNlIGMuY2hpbGRbXCJyZXR1cm5cIl09YyxjPWMuY2hpbGR9aWYoIShjLmVmZmVjdFRhZyYyKSl7Yz1jLnN0YXRlTm9kZTticmVhayBhfX1mb3IodmFyIGU9YTs7KXtpZig1PT09ZS50YWd8fDY9PT1lLnRhZyljP2Q/TChiLGUuc3RhdGVOb2RlLGMpOkkoYixlLnN0YXRlTm9kZSxjKTpkP0coYixlLnN0YXRlTm9kZSk6eihiLGUuc3RhdGVOb2RlKTtlbHNlIGlmKDQhPT1lLnRhZyYmbnVsbCE9PWUuY2hpbGQpe2UuY2hpbGRbXCJyZXR1cm5cIl09ZTtlPWUuY2hpbGQ7Y29udGludWV9aWYoZT09PWEpYnJlYWs7Zm9yKDtudWxsPT09ZS5zaWJsaW5nOyl7aWYobnVsbD09PWVbXCJyZXR1cm5cIl18fGVbXCJyZXR1cm5cIl09PT1cbmEpcmV0dXJuO2U9ZVtcInJldHVyblwiXX1lLnNpYmxpbmdbXCJyZXR1cm5cIl09ZVtcInJldHVyblwiXTtlPWUuc2libGluZ319LGNvbW1pdERlbGV0aW9uOmZ1bmN0aW9uKGEpe2coYSk7YVtcInJldHVyblwiXT1udWxsO2EuY2hpbGQ9bnVsbDthLmFsdGVybmF0ZSYmKGEuYWx0ZXJuYXRlLmNoaWxkPW51bGwsYS5hbHRlcm5hdGVbXCJyZXR1cm5cIl09bnVsbCl9LGNvbW1pdFdvcms6ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMjpicmVhaztjYXNlIDU6dmFyIGM9Yi5zdGF0ZU5vZGU7aWYobnVsbCE9Yyl7dmFyIGQ9Yi5tZW1vaXplZFByb3BzO2E9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOmQ7dmFyIGU9Yi50eXBlLGY9Yi51cGRhdGVRdWV1ZTtiLnVwZGF0ZVF1ZXVlPW51bGw7bnVsbCE9PWYmJnYoYyxmLGUsYSxkLGIpfWJyZWFrO2Nhc2UgNjpudWxsPT09Yi5zdGF0ZU5vZGU/RShcIjE2MlwiKTp2b2lkIDA7Yz1iLm1lbW9pemVkUHJvcHM7dShiLnN0YXRlTm9kZSxudWxsIT09YT9hLm1lbW9pemVkUHJvcHM6XG5jLGMpO2JyZWFrO2Nhc2UgMzpicmVhaztkZWZhdWx0OkUoXCIxNjNcIil9fSxjb21taXRMaWZlQ3ljbGVzOmZ1bmN0aW9uKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDI6dmFyIGM9Yi5zdGF0ZU5vZGU7aWYoYi5lZmZlY3RUYWcmNClpZihudWxsPT09YSljLnByb3BzPWIubWVtb2l6ZWRQcm9wcyxjLnN0YXRlPWIubWVtb2l6ZWRTdGF0ZSxjLmNvbXBvbmVudERpZE1vdW50KCk7ZWxzZXt2YXIgZD1hLm1lbW9pemVkUHJvcHM7YT1hLm1lbW9pemVkU3RhdGU7Yy5wcm9wcz1iLm1lbW9pemVkUHJvcHM7Yy5zdGF0ZT1iLm1lbW9pemVkU3RhdGU7Yy5jb21wb25lbnREaWRVcGRhdGUoZCxhKX1iPWIudXBkYXRlUXVldWU7bnVsbCE9PWImJktlKGIsYyk7YnJlYWs7Y2FzZSAzOmM9Yi51cGRhdGVRdWV1ZTtudWxsIT09YyYmS2UoYyxudWxsIT09Yi5jaGlsZD9iLmNoaWxkLnN0YXRlTm9kZTpudWxsKTticmVhaztjYXNlIDU6Yz1iLnN0YXRlTm9kZTtudWxsPT09YSYmYi5lZmZlY3RUYWcmNCYmcShjLFxuYi50eXBlLGIubWVtb2l6ZWRQcm9wcyxiKTticmVhaztjYXNlIDY6YnJlYWs7Y2FzZSA0OmJyZWFrO2RlZmF1bHQ6RShcIjE2M1wiKX19LGNvbW1pdEF0dGFjaFJlZjpmdW5jdGlvbihhKXt2YXIgYj1hLnJlZjtpZihudWxsIT09Yil7dmFyIGM9YS5zdGF0ZU5vZGU7c3dpdGNoKGEudGFnKXtjYXNlIDU6YihoKGMpKTticmVhaztkZWZhdWx0OmIoYyl9fX0sY29tbWl0RGV0YWNoUmVmOmZ1bmN0aW9uKGEpe2E9YS5yZWY7bnVsbCE9PWEmJmEobnVsbCl9fX12YXIgZ2Y9e307XG5mdW5jdGlvbiBoZihhKXtmdW5jdGlvbiBiKGEpe2E9PT1nZj9FKFwiMTc0XCIpOnZvaWQgMDtyZXR1cm4gYX12YXIgYz1hLmdldENoaWxkSG9zdENvbnRleHQsZD1hLmdldFJvb3RIb3N0Q29udGV4dCxlPXtjdXJyZW50OmdmfSxmPXtjdXJyZW50OmdmfSxnPXtjdXJyZW50OmdmfTtyZXR1cm57Z2V0SG9zdENvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gYihlLmN1cnJlbnQpfSxnZXRSb290SG9zdENvbnRhaW5lcjpmdW5jdGlvbigpe3JldHVybiBiKGcuY3VycmVudCl9LHBvcEhvc3RDb250YWluZXI6ZnVuY3Rpb24oYSl7VihlLGEpO1YoZixhKTtWKGcsYSl9LHBvcEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEpe2YuY3VycmVudD09PWEmJihWKGUsYSksVihmLGEpKX0scHVzaEhvc3RDb250YWluZXI6ZnVuY3Rpb24oYSxiKXtXKGcsYixhKTtiPWQoYik7VyhmLGEsYSk7VyhlLGIsYSl9LHB1c2hIb3N0Q29udGV4dDpmdW5jdGlvbihhKXt2YXIgZD1iKGcuY3VycmVudCksaD1iKGUuY3VycmVudCk7XG5kPWMoaCxhLnR5cGUsZCk7aCE9PWQmJihXKGYsYSxhKSxXKGUsZCxhKSl9LHJlc2V0SG9zdENvbnRhaW5lcjpmdW5jdGlvbigpe2UuY3VycmVudD1nZjtnLmN1cnJlbnQ9Z2Z9fX1cbmZ1bmN0aW9uIGpmKGEpe2Z1bmN0aW9uIGIoYSxiKXt2YXIgYz1uZXcgWSg1LG51bGwsMCk7Yy50eXBlPVwiREVMRVRFRFwiO2Muc3RhdGVOb2RlPWI7Y1tcInJldHVyblwiXT1hO2MuZWZmZWN0VGFnPTg7bnVsbCE9PWEubGFzdEVmZmVjdD8oYS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YyxhLmxhc3RFZmZlY3Q9Yyk6YS5maXJzdEVmZmVjdD1hLmxhc3RFZmZlY3Q9Y31mdW5jdGlvbiBjKGEsYil7c3dpdGNoKGEudGFnKXtjYXNlIDU6cmV0dXJuIGI9ZihiLGEudHlwZSxhLnBlbmRpbmdQcm9wcyksbnVsbCE9PWI/KGEuc3RhdGVOb2RlPWIsITApOiExO2Nhc2UgNjpyZXR1cm4gYj1nKGIsYS5wZW5kaW5nUHJvcHMpLG51bGwhPT1iPyhhLnN0YXRlTm9kZT1iLCEwKTohMTtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBkKGEpe2ZvcihhPWFbXCJyZXR1cm5cIl07bnVsbCE9PWEmJjUhPT1hLnRhZyYmMyE9PWEudGFnOylhPWFbXCJyZXR1cm5cIl07eT1hfXZhciBlPWEuc2hvdWxkU2V0VGV4dENvbnRlbnQ7XG5hPWEuaHlkcmF0aW9uO2lmKCFhKXJldHVybntlbnRlckh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITF9LHJlc2V0SHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXt9LHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlOmZ1bmN0aW9uKCl7RShcIjE3NVwiKX0scHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXtFKFwiMTc2XCIpfSxwb3BIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3JldHVybiExfX07dmFyIGY9YS5jYW5IeWRyYXRlSW5zdGFuY2UsZz1hLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsaD1hLmdldE5leHRIeWRyYXRhYmxlU2libGluZyxrPWEuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQscT1hLmh5ZHJhdGVJbnN0YW5jZSx2PWEuaHlkcmF0ZVRleHRJbnN0YW5jZSx5PW51bGwsdT1udWxsLHo9ITE7cmV0dXJue2VudGVySHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oYSl7dT1cbmsoYS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7eT1hO3JldHVybiB6PSEwfSxyZXNldEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7dT15PW51bGw7ej0hMX0sdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6ZnVuY3Rpb24oYSl7aWYoeil7dmFyIGQ9dTtpZihkKXtpZighYyhhLGQpKXtkPWgoZCk7aWYoIWR8fCFjKGEsZCkpe2EuZWZmZWN0VGFnfD0yO3o9ITE7eT1hO3JldHVybn1iKHksdSl9eT1hO3U9ayhkKX1lbHNlIGEuZWZmZWN0VGFnfD0yLHo9ITEseT1hfX0scHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyl7Yj1xKGEuc3RhdGVOb2RlLGEudHlwZSxhLm1lbW9pemVkUHJvcHMsYixjLGEpO2EudXBkYXRlUXVldWU9YjtyZXR1cm4gbnVsbCE9PWI/ITA6ITF9LHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiB2KGEuc3RhdGVOb2RlLGEubWVtb2l6ZWRQcm9wcyxhKX0scG9wSHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oYSl7aWYoYSE9PVxueSlyZXR1cm4hMTtpZigheilyZXR1cm4gZChhKSx6PSEwLCExO3ZhciBjPWEudHlwZTtpZig1IT09YS50YWd8fFwiaGVhZFwiIT09YyYmXCJib2R5XCIhPT1jJiYhZShjLGEubWVtb2l6ZWRQcm9wcykpZm9yKGM9dTtjOyliKGEsYyksYz1oKGMpO2QoYSk7dT15P2goYS5zdGF0ZU5vZGUpOm51bGw7cmV0dXJuITB9fX1cbmZ1bmN0aW9uIGtmKGEpe2Z1bmN0aW9uIGIoYSl7UWI9amE9ITA7dmFyIGI9YS5zdGF0ZU5vZGU7Yi5jdXJyZW50PT09YT9FKFwiMTc3XCIpOnZvaWQgMDtiLmlzUmVhZHlGb3JDb21taXQ9ITE7aWQuY3VycmVudD1udWxsO2lmKDE8YS5lZmZlY3RUYWcpaWYobnVsbCE9PWEubGFzdEVmZmVjdCl7YS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YTt2YXIgYz1hLmZpcnN0RWZmZWN0fWVsc2UgYz1hO2Vsc2UgYz1hLmZpcnN0RWZmZWN0O3lnKCk7Zm9yKHQ9YztudWxsIT09dDspe3ZhciBkPSExLGU9dm9pZCAwO3RyeXtmb3IoO251bGwhPT10Oyl7dmFyIGY9dC5lZmZlY3RUYWc7ZiYxNiYmemcodCk7aWYoZiYxMjgpe3ZhciBnPXQuYWx0ZXJuYXRlO251bGwhPT1nJiZBZyhnKX1zd2l0Y2goZiYtMjQyKXtjYXNlIDI6TmUodCk7dC5lZmZlY3RUYWcmPS0zO2JyZWFrO2Nhc2UgNjpOZSh0KTt0LmVmZmVjdFRhZyY9LTM7T2UodC5hbHRlcm5hdGUsdCk7YnJlYWs7Y2FzZSA0Ok9lKHQuYWx0ZXJuYXRlLFxudCk7YnJlYWs7Y2FzZSA4OlNjPSEwLEJnKHQpLFNjPSExfXQ9dC5uZXh0RWZmZWN0fX1jYXRjaChUYyl7ZD0hMCxlPVRjfWQmJihudWxsPT09dD9FKFwiMTc4XCIpOnZvaWQgMCxoKHQsZSksbnVsbCE9PXQmJih0PXQubmV4dEVmZmVjdCkpfUNnKCk7Yi5jdXJyZW50PWE7Zm9yKHQ9YztudWxsIT09dDspe2M9ITE7ZD12b2lkIDA7dHJ5e2Zvcig7bnVsbCE9PXQ7KXt2YXIgaz10LmVmZmVjdFRhZztrJjM2JiZEZyh0LmFsdGVybmF0ZSx0KTtrJjEyOCYmRWcodCk7aWYoayY2NClzd2l0Y2goZT10LGY9dm9pZCAwLG51bGwhPT1SJiYoZj1SLmdldChlKSxSW1wiZGVsZXRlXCJdKGUpLG51bGw9PWYmJm51bGwhPT1lLmFsdGVybmF0ZSYmKGU9ZS5hbHRlcm5hdGUsZj1SLmdldChlKSxSW1wiZGVsZXRlXCJdKGUpKSksbnVsbD09Zj9FKFwiMTg0XCIpOnZvaWQgMCxlLnRhZyl7Y2FzZSAyOmUuc3RhdGVOb2RlLmNvbXBvbmVudERpZENhdGNoKGYuZXJyb3Ise2NvbXBvbmVudFN0YWNrOmYuY29tcG9uZW50U3RhY2t9KTtcbmJyZWFrO2Nhc2UgMzpudWxsPT09Y2EmJihjYT1mLmVycm9yKTticmVhaztkZWZhdWx0OkUoXCIxNTdcIil9dmFyIFFjPXQubmV4dEVmZmVjdDt0Lm5leHRFZmZlY3Q9bnVsbDt0PVFjfX1jYXRjaChUYyl7Yz0hMCxkPVRjfWMmJihudWxsPT09dD9FKFwiMTc4XCIpOnZvaWQgMCxoKHQsZCksbnVsbCE9PXQmJih0PXQubmV4dEVmZmVjdCkpfWphPVFiPSExO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBEZSYmRGUoYS5zdGF0ZU5vZGUpO2hhJiYoaGEuZm9yRWFjaChHKSxoYT1udWxsKTtudWxsIT09Y2EmJihhPWNhLGNhPW51bGwsT2IoYSkpO2I9Yi5jdXJyZW50LmV4cGlyYXRpb25UaW1lOzA9PT1iJiYocWE9Uj1udWxsKTtyZXR1cm4gYn1mdW5jdGlvbiBjKGEpe2Zvcig7Oyl7dmFyIGI9RmcoYS5hbHRlcm5hdGUsYSxIKSxjPWFbXCJyZXR1cm5cIl0sZD1hLnNpYmxpbmc7dmFyIGU9YTtpZigyMTQ3NDgzNjQ3PT09SHx8MjE0NzQ4MzY0NyE9PWUuZXhwaXJhdGlvblRpbWUpe2lmKDIhPT1lLnRhZyYmMyE9PVxuZS50YWcpdmFyIGY9MDtlbHNlIGY9ZS51cGRhdGVRdWV1ZSxmPW51bGw9PT1mPzA6Zi5leHBpcmF0aW9uVGltZTtmb3IodmFyIGc9ZS5jaGlsZDtudWxsIT09ZzspMCE9PWcuZXhwaXJhdGlvblRpbWUmJigwPT09Znx8Zj5nLmV4cGlyYXRpb25UaW1lKSYmKGY9Zy5leHBpcmF0aW9uVGltZSksZz1nLnNpYmxpbmc7ZS5leHBpcmF0aW9uVGltZT1mfWlmKG51bGwhPT1iKXJldHVybiBiO251bGwhPT1jJiYobnVsbD09PWMuZmlyc3RFZmZlY3QmJihjLmZpcnN0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLG51bGwhPT1hLmxhc3RFZmZlY3QmJihudWxsIT09Yy5sYXN0RWZmZWN0JiYoYy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YS5maXJzdEVmZmVjdCksYy5sYXN0RWZmZWN0PWEubGFzdEVmZmVjdCksMTxhLmVmZmVjdFRhZyYmKG51bGwhPT1jLmxhc3RFZmZlY3Q/Yy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YTpjLmZpcnN0RWZmZWN0PWEsYy5sYXN0RWZmZWN0PWEpKTtpZihudWxsIT09ZClyZXR1cm4gZDtcbmlmKG51bGwhPT1jKWE9YztlbHNle2Euc3RhdGVOb2RlLmlzUmVhZHlGb3JDb21taXQ9ITA7YnJlYWt9fXJldHVybiBudWxsfWZ1bmN0aW9uIGQoYSl7dmFyIGI9cmcoYS5hbHRlcm5hdGUsYSxIKTtudWxsPT09YiYmKGI9YyhhKSk7aWQuY3VycmVudD1udWxsO3JldHVybiBifWZ1bmN0aW9uIGUoYSl7dmFyIGI9R2coYS5hbHRlcm5hdGUsYSxIKTtudWxsPT09YiYmKGI9YyhhKSk7aWQuY3VycmVudD1udWxsO3JldHVybiBifWZ1bmN0aW9uIGYoYSl7aWYobnVsbCE9PVIpe2lmKCEoMD09PUh8fEg+YSkpaWYoSDw9VWMpZm9yKDtudWxsIT09RjspRj1rKEYpP2UoRik6ZChGKTtlbHNlIGZvcig7bnVsbCE9PUYmJiFBKCk7KUY9ayhGKT9lKEYpOmQoRil9ZWxzZSBpZighKDA9PT1IfHxIPmEpKWlmKEg8PVVjKWZvcig7bnVsbCE9PUY7KUY9ZChGKTtlbHNlIGZvcig7bnVsbCE9PUYmJiFBKCk7KUY9ZChGKX1mdW5jdGlvbiBnKGEsYil7amE/RShcIjI0M1wiKTp2b2lkIDA7amE9ITA7YS5pc1JlYWR5Rm9yQ29tbWl0PVxuITE7aWYoYSE9PXJhfHxiIT09SHx8bnVsbD09PUYpe2Zvcig7LTE8aGU7KWdlW2hlXT1udWxsLGhlLS07amU9RDtpZS5jdXJyZW50PUQ7WC5jdXJyZW50PSExO3goKTtyYT1hO0g9YjtGPXNlKHJhLmN1cnJlbnQsbnVsbCxiKX12YXIgYz0hMSxkPW51bGw7dHJ5e2YoYil9Y2F0Y2goUmMpe2M9ITAsZD1SY31mb3IoO2M7KXtpZihlYil7Y2E9ZDticmVha312YXIgZz1GO2lmKG51bGw9PT1nKWViPSEwO2Vsc2V7dmFyIGs9aChnLGQpO251bGw9PT1rP0UoXCIxODNcIik6dm9pZCAwO2lmKCFlYil7dHJ5e2M9aztkPWI7Zm9yKGs9YztudWxsIT09Zzspe3N3aXRjaChnLnRhZyl7Y2FzZSAyOm5lKGcpO2JyZWFrO2Nhc2UgNTpxZyhnKTticmVhaztjYXNlIDM6cChnKTticmVhaztjYXNlIDQ6cChnKX1pZihnPT09a3x8Zy5hbHRlcm5hdGU9PT1rKWJyZWFrO2c9Z1tcInJldHVyblwiXX1GPWUoYyk7ZihkKX1jYXRjaChSYyl7Yz0hMDtkPVJjO2NvbnRpbnVlfWJyZWFrfX19Yj1jYTtlYj1qYT0hMTtjYT1cbm51bGw7bnVsbCE9PWImJk9iKGIpO3JldHVybiBhLmlzUmVhZHlGb3JDb21taXQ/YS5jdXJyZW50LmFsdGVybmF0ZTpudWxsfWZ1bmN0aW9uIGgoYSxiKXt2YXIgYz1pZC5jdXJyZW50PW51bGwsZD0hMSxlPSExLGY9bnVsbDtpZigzPT09YS50YWcpYz1hLHEoYSkmJihlYj0hMCk7ZWxzZSBmb3IodmFyIGc9YVtcInJldHVyblwiXTtudWxsIT09ZyYmbnVsbD09PWM7KXsyPT09Zy50YWc/XCJmdW5jdGlvblwiPT09dHlwZW9mIGcuc3RhdGVOb2RlLmNvbXBvbmVudERpZENhdGNoJiYoZD0hMCxmPWpkKGcpLGM9ZyxlPSEwKTozPT09Zy50YWcmJihjPWcpO2lmKHEoZykpe2lmKFNjfHxudWxsIT09aGEmJihoYS5oYXMoZyl8fG51bGwhPT1nLmFsdGVybmF0ZSYmaGEuaGFzKGcuYWx0ZXJuYXRlKSkpcmV0dXJuIG51bGw7Yz1udWxsO2U9ITF9Zz1nW1wicmV0dXJuXCJdfWlmKG51bGwhPT1jKXtudWxsPT09cWEmJihxYT1uZXcgU2V0KTtxYS5hZGQoYyk7dmFyIGg9XCJcIjtnPWE7ZG97YTpzd2l0Y2goZy50YWcpe2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgNTp2YXIgaz1cbmcuX2RlYnVnT3duZXIsUWM9Zy5fZGVidWdTb3VyY2U7dmFyIG09amQoZyk7dmFyIG49bnVsbDtrJiYobj1qZChrKSk7az1RYzttPVwiXFxuICAgIGluIFwiKyhtfHxcIlVua25vd25cIikrKGs/XCIgKGF0IFwiK2suZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLyxcIlwiKStcIjpcIitrLmxpbmVOdW1iZXIrXCIpXCI6bj9cIiAoY3JlYXRlZCBieSBcIituK1wiKVwiOlwiXCIpO2JyZWFrIGE7ZGVmYXVsdDptPVwiXCJ9aCs9bTtnPWdbXCJyZXR1cm5cIl19d2hpbGUoZyk7Zz1oO2E9amQoYSk7bnVsbD09PVImJihSPW5ldyBNYXApO2I9e2NvbXBvbmVudE5hbWU6YSxjb21wb25lbnRTdGFjazpnLGVycm9yOmIsZXJyb3JCb3VuZGFyeTpkP2Muc3RhdGVOb2RlOm51bGwsZXJyb3JCb3VuZGFyeUZvdW5kOmQsZXJyb3JCb3VuZGFyeU5hbWU6Zix3aWxsUmV0cnk6ZX07Ui5zZXQoYyxiKTt0cnl7dmFyIHA9Yi5lcnJvcjtwJiZwLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmd8fGNvbnNvbGUuZXJyb3IocCl9Y2F0Y2goVmMpe1ZjJiZcblZjLnN1cHByZXNzUmVhY3RFcnJvckxvZ2dpbmd8fGNvbnNvbGUuZXJyb3IoVmMpfVFiPyhudWxsPT09aGEmJihoYT1uZXcgU2V0KSxoYS5hZGQoYykpOkcoYyk7cmV0dXJuIGN9bnVsbD09PWNhJiYoY2E9Yik7cmV0dXJuIG51bGx9ZnVuY3Rpb24gayhhKXtyZXR1cm4gbnVsbCE9PVImJihSLmhhcyhhKXx8bnVsbCE9PWEuYWx0ZXJuYXRlJiZSLmhhcyhhLmFsdGVybmF0ZSkpfWZ1bmN0aW9uIHEoYSl7cmV0dXJuIG51bGwhPT1xYSYmKHFhLmhhcyhhKXx8bnVsbCE9PWEuYWx0ZXJuYXRlJiZxYS5oYXMoYS5hbHRlcm5hdGUpKX1mdW5jdGlvbiB2KCl7cmV0dXJuIDIwKigoKEkoKSsxMDApLzIwfDApKzEpfWZ1bmN0aW9uIHkoYSl7cmV0dXJuIDAhPT1rYT9rYTpqYT9RYj8xOkg6IUhnfHxhLmludGVybmFsQ29udGV4dFRhZyYxP3YoKToxfWZ1bmN0aW9uIHUoYSxiKXtyZXR1cm4geihhLGIsITEpfWZ1bmN0aW9uIHooYSxiKXtmb3IoO251bGwhPT1hOyl7aWYoMD09PWEuZXhwaXJhdGlvblRpbWV8fFxuYS5leHBpcmF0aW9uVGltZT5iKWEuZXhwaXJhdGlvblRpbWU9YjtudWxsIT09YS5hbHRlcm5hdGUmJigwPT09YS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWV8fGEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lPmIpJiYoYS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWU9Yik7aWYobnVsbD09PWFbXCJyZXR1cm5cIl0paWYoMz09PWEudGFnKXt2YXIgYz1hLnN0YXRlTm9kZTshamEmJmM9PT1yYSYmYjxIJiYoRj1yYT1udWxsLEg9MCk7dmFyIGQ9YyxlPWI7UmI+SWcmJkUoXCIxODVcIik7aWYobnVsbD09PWQubmV4dFNjaGVkdWxlZFJvb3QpZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1lLG51bGw9PT1PPyhzYT1PPWQsZC5uZXh0U2NoZWR1bGVkUm9vdD1kKTooTz1PLm5leHRTY2hlZHVsZWRSb290PWQsTy5uZXh0U2NoZWR1bGVkUm9vdD1zYSk7ZWxzZXt2YXIgZj1kLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO2lmKDA9PT1mfHxlPGYpZC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1lfUZhfHwobGE/XG5TYiYmKG1hPWQsbmE9MSxtKG1hLG5hKSk6MT09PWU/dygxLG51bGwpOkwoZSkpOyFqYSYmYz09PXJhJiZiPEgmJihGPXJhPW51bGwsSD0wKX1lbHNlIGJyZWFrO2E9YVtcInJldHVyblwiXX19ZnVuY3Rpb24gRyhhKXt6KGEsMSwhMCl9ZnVuY3Rpb24gSSgpe3JldHVybiBVYz0oKFdjKCktUGUpLzEwfDApKzJ9ZnVuY3Rpb24gTChhKXtpZigwIT09VGIpe2lmKGE+VGIpcmV0dXJuO0pnKFhjKX12YXIgYj1XYygpLVBlO1RiPWE7WGM9S2coSix7dGltZW91dDoxMCooYS0yKS1ifSl9ZnVuY3Rpb24gTigpe3ZhciBhPTAsYj1udWxsO2lmKG51bGwhPT1PKWZvcih2YXIgYz1PLGQ9c2E7bnVsbCE9PWQ7KXt2YXIgZT1kLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO2lmKDA9PT1lKXtudWxsPT09Y3x8bnVsbD09PU8/RShcIjI0NFwiKTp2b2lkIDA7aWYoZD09PWQubmV4dFNjaGVkdWxlZFJvb3Qpe3NhPU89ZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2JyZWFrfWVsc2UgaWYoZD09PXNhKXNhPWU9ZC5uZXh0U2NoZWR1bGVkUm9vdCxcbk8ubmV4dFNjaGVkdWxlZFJvb3Q9ZSxkLm5leHRTY2hlZHVsZWRSb290PW51bGw7ZWxzZSBpZihkPT09Tyl7Tz1jO08ubmV4dFNjaGVkdWxlZFJvb3Q9c2E7ZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2JyZWFrfWVsc2UgYy5uZXh0U2NoZWR1bGVkUm9vdD1kLm5leHRTY2hlZHVsZWRSb290LGQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDtkPWMubmV4dFNjaGVkdWxlZFJvb3R9ZWxzZXtpZigwPT09YXx8ZTxhKWE9ZSxiPWQ7aWYoZD09PU8pYnJlYWs7Yz1kO2Q9ZC5uZXh0U2NoZWR1bGVkUm9vdH19Yz1tYTtudWxsIT09YyYmYz09PWI/UmIrKzpSYj0wO21hPWI7bmE9YX1mdW5jdGlvbiBKKGEpe3coMCxhKX1mdW5jdGlvbiB3KGEsYil7ZmI9Yjtmb3IoTigpO251bGwhPT1tYSYmMCE9PW5hJiYoMD09PWF8fG5hPD1hKSYmIVljOyltKG1hLG5hKSxOKCk7bnVsbCE9PWZiJiYoVGI9MCxYYz0tMSk7MCE9PW5hJiZMKG5hKTtmYj1udWxsO1ljPSExO1JiPTA7aWYoVWIpdGhyb3cgYT1aYyxaYz1cbm51bGwsVWI9ITEsYTt9ZnVuY3Rpb24gbShhLGMpe0ZhP0UoXCIyNDVcIik6dm9pZCAwO0ZhPSEwO2lmKGM8PUkoKSl7dmFyIGQ9YS5maW5pc2hlZFdvcms7bnVsbCE9PWQ/KGEuZmluaXNoZWRXb3JrPW51bGwsYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKTooYS5maW5pc2hlZFdvcms9bnVsbCxkPWcoYSxjKSxudWxsIT09ZCYmKGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSkpfWVsc2UgZD1hLmZpbmlzaGVkV29yayxudWxsIT09ZD8oYS5maW5pc2hlZFdvcms9bnVsbCxhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpOihhLmZpbmlzaGVkV29yaz1udWxsLGQ9ZyhhLGMpLG51bGwhPT1kJiYoQSgpP2EuZmluaXNoZWRXb3JrPWQ6YS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKSk7RmE9ITF9ZnVuY3Rpb24gQSgpe3JldHVybiBudWxsPT09ZmJ8fGZiLnRpbWVSZW1haW5pbmcoKT5MZz8hMTpZYz0hMH1mdW5jdGlvbiBPYihhKXtudWxsPT09bWE/RShcIjI0NlwiKTpcbnZvaWQgMDttYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT0wO1VifHwoVWI9ITAsWmM9YSl9dmFyIHI9aGYoYSksbj1qZihhKSxwPXIucG9wSG9zdENvbnRhaW5lcixxZz1yLnBvcEhvc3RDb250ZXh0LHg9ci5yZXNldEhvc3RDb250YWluZXIsTWU9ZGYoYSxyLG4sdSx5KSxyZz1NZS5iZWdpbldvcmssR2c9TWUuYmVnaW5GYWlsZWRXb3JrLEZnPWVmKGEscixuKS5jb21wbGV0ZVdvcms7cj1mZihhLGgpO3ZhciB6Zz1yLmNvbW1pdFJlc2V0VGV4dENvbnRlbnQsTmU9ci5jb21taXRQbGFjZW1lbnQsQmc9ci5jb21taXREZWxldGlvbixPZT1yLmNvbW1pdFdvcmssRGc9ci5jb21taXRMaWZlQ3ljbGVzLEVnPXIuY29tbWl0QXR0YWNoUmVmLEFnPXIuY29tbWl0RGV0YWNoUmVmLFdjPWEubm93LEtnPWEuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLEpnPWEuY2FuY2VsRGVmZXJyZWRDYWxsYmFjayxIZz1hLnVzZVN5bmNTY2hlZHVsaW5nLHlnPWEucHJlcGFyZUZvckNvbW1pdCxDZz1hLnJlc2V0QWZ0ZXJDb21taXQsXG5QZT1XYygpLFVjPTIsa2E9MCxqYT0hMSxGPW51bGwscmE9bnVsbCxIPTAsdD1udWxsLFI9bnVsbCxxYT1udWxsLGhhPW51bGwsY2E9bnVsbCxlYj0hMSxRYj0hMSxTYz0hMSxzYT1udWxsLE89bnVsbCxUYj0wLFhjPS0xLEZhPSExLG1hPW51bGwsbmE9MCxZYz0hMSxVYj0hMSxaYz1udWxsLGZiPW51bGwsbGE9ITEsU2I9ITEsSWc9MUUzLFJiPTAsTGc9MTtyZXR1cm57Y29tcHV0ZUFzeW5jRXhwaXJhdGlvbjp2LGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6eSxzY2hlZHVsZVdvcms6dSxiYXRjaGVkVXBkYXRlczpmdW5jdGlvbihhLGIpe3ZhciBjPWxhO2xhPSEwO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5eyhsYT1jKXx8RmF8fHcoMSxudWxsKX19LHVuYmF0Y2hlZFVwZGF0ZXM6ZnVuY3Rpb24oYSl7aWYobGEmJiFTYil7U2I9ITA7dHJ5e3JldHVybiBhKCl9ZmluYWxseXtTYj0hMX19cmV0dXJuIGEoKX0sZmx1c2hTeW5jOmZ1bmN0aW9uKGEpe3ZhciBiPWxhO2xhPSEwO3RyeXthOnt2YXIgYz1cbmthO2thPTE7dHJ5e3ZhciBkPWEoKTticmVhayBhfWZpbmFsbHl7a2E9Y31kPXZvaWQgMH1yZXR1cm4gZH1maW5hbGx5e2xhPWIsRmE/RShcIjE4N1wiKTp2b2lkIDAsdygxLG51bGwpfX0sZGVmZXJyZWRVcGRhdGVzOmZ1bmN0aW9uKGEpe3ZhciBiPWthO2thPXYoKTt0cnl7cmV0dXJuIGEoKX1maW5hbGx5e2thPWJ9fX19XG5mdW5jdGlvbiBsZihhKXtmdW5jdGlvbiBiKGEpe2E9b2QoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9dmFyIGM9YS5nZXRQdWJsaWNJbnN0YW5jZTthPWtmKGEpO3ZhciBkPWEuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixlPWEuY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixmPWEuc2NoZWR1bGVXb3JrO3JldHVybntjcmVhdGVDb250YWluZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgWSgzLG51bGwsMCk7YT17Y3VycmVudDpjLGNvbnRhaW5lckluZm86YSxwZW5kaW5nQ2hpbGRyZW46bnVsbCxyZW1haW5pbmdFeHBpcmF0aW9uVGltZTowLGlzUmVhZHlGb3JDb21taXQ6ITEsZmluaXNoZWRXb3JrOm51bGwsY29udGV4dDpudWxsLHBlbmRpbmdDb250ZXh0Om51bGwsaHlkcmF0ZTpiLG5leHRTY2hlZHVsZWRSb290Om51bGx9O3JldHVybiBjLnN0YXRlTm9kZT1hfSx1cGRhdGVDb250YWluZXI6ZnVuY3Rpb24oYSxiLGMscSl7dmFyIGc9Yi5jdXJyZW50O2lmKGMpe2M9XG5jLl9yZWFjdEludGVybmFsRmliZXI7dmFyIGg7Yjp7Mj09PWtkKGMpJiYyPT09Yy50YWc/dm9pZCAwOkUoXCIxNzBcIik7Zm9yKGg9YzszIT09aC50YWc7KXtpZihsZShoKSl7aD1oLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDticmVhayBifShoPWhbXCJyZXR1cm5cIl0pP3ZvaWQgMDpFKFwiMTcxXCIpfWg9aC5zdGF0ZU5vZGUuY29udGV4dH1jPWxlKGMpP3BlKGMsaCk6aH1lbHNlIGM9RDtudWxsPT09Yi5jb250ZXh0P2IuY29udGV4dD1jOmIucGVuZGluZ0NvbnRleHQ9YztiPXE7Yj12b2lkIDA9PT1iP251bGw6YjtxPW51bGwhPWEmJm51bGwhPWEudHlwZSYmbnVsbCE9YS50eXBlLnByb3RvdHlwZSYmITA9PT1hLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudD9kKCk6ZShnKTtIZShnLHtleHBpcmF0aW9uVGltZTpxLHBhcnRpYWxTdGF0ZTp7ZWxlbWVudDphfSxjYWxsYmFjazpiLGlzUmVwbGFjZTohMSxpc0ZvcmNlZDohMSxcbm5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2YoZyxxKX0sYmF0Y2hlZFVwZGF0ZXM6YS5iYXRjaGVkVXBkYXRlcyx1bmJhdGNoZWRVcGRhdGVzOmEudW5iYXRjaGVkVXBkYXRlcyxkZWZlcnJlZFVwZGF0ZXM6YS5kZWZlcnJlZFVwZGF0ZXMsZmx1c2hTeW5jOmEuZmx1c2hTeW5jLGdldFB1YmxpY1Jvb3RJbnN0YW5jZTpmdW5jdGlvbihhKXthPWEuY3VycmVudDtpZighYS5jaGlsZClyZXR1cm4gbnVsbDtzd2l0Y2goYS5jaGlsZC50YWcpe2Nhc2UgNTpyZXR1cm4gYyhhLmNoaWxkLnN0YXRlTm9kZSk7ZGVmYXVsdDpyZXR1cm4gYS5jaGlsZC5zdGF0ZU5vZGV9fSxmaW5kSG9zdEluc3RhbmNlOmIsZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHM6ZnVuY3Rpb24oYSl7YT1wZChhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX0saW5qZWN0SW50b0RldlRvb2xzOmZ1bmN0aW9uKGEpe3ZhciBjPWEuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7cmV0dXJuIENlKEIoe30sXG5hLHtmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjpmdW5jdGlvbihhKXtyZXR1cm4gYihhKX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGM/YyhhKTpudWxsfX0pKX19fXZhciBtZj1PYmplY3QuZnJlZXplKHtkZWZhdWx0OmxmfSksbmY9bWYmJmxmfHxtZixvZj1uZltcImRlZmF1bHRcIl0/bmZbXCJkZWZhdWx0XCJdOm5mO2Z1bmN0aW9uIHBmKGEsYixjKXt2YXIgZD0zPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1szXT9hcmd1bWVudHNbM106bnVsbDtyZXR1cm57JCR0eXBlb2Y6VWUsa2V5Om51bGw9PWQ/bnVsbDpcIlwiK2QsY2hpbGRyZW46YSxjb250YWluZXJJbmZvOmIsaW1wbGVtZW50YXRpb246Y319dmFyIHFmPVwib2JqZWN0XCI9PT10eXBlb2YgcGVyZm9ybWFuY2UmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBwZXJmb3JtYW5jZS5ub3cscmY9dm9pZCAwO3JmPXFmP2Z1bmN0aW9uKCl7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfTpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfTtcbnZhciBzZj12b2lkIDAsdGY9dm9pZCAwO1xuaWYobC5jYW5Vc2VET00paWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2t8fFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjYW5jZWxJZGxlQ2FsbGJhY2spe3ZhciB1Zj1udWxsLHZmPSExLHdmPS0xLHhmPSExLHlmPTAsemY9MzMsQWY9MzMsQmY7QmY9cWY/e2RpZFRpbWVvdXQ6ITEsdGltZVJlbWFpbmluZzpmdW5jdGlvbigpe3ZhciBhPXlmLXBlcmZvcm1hbmNlLm5vdygpO3JldHVybiAwPGE/YTowfX06e2RpZFRpbWVvdXQ6ITEsdGltZVJlbWFpbmluZzpmdW5jdGlvbigpe3ZhciBhPXlmLURhdGUubm93KCk7cmV0dXJuIDA8YT9hOjB9fTt2YXIgQ2Y9XCJfX3JlYWN0SWRsZUNhbGxiYWNrJFwiK01hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLGZ1bmN0aW9uKGEpe2lmKGEuc291cmNlPT09d2luZG93JiZhLmRhdGE9PT1DZil7dmY9ITE7YT1yZigpO2lmKDA+PXlmLWEpaWYoLTEhPT13ZiYmd2Y8PVxuYSlCZi5kaWRUaW1lb3V0PSEwO2Vsc2V7eGZ8fCh4Zj0hMCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoRGYpKTtyZXR1cm59ZWxzZSBCZi5kaWRUaW1lb3V0PSExO3dmPS0xO2E9dWY7dWY9bnVsbDtudWxsIT09YSYmYShCZil9fSwhMSk7dmFyIERmPWZ1bmN0aW9uKGEpe3hmPSExO3ZhciBiPWEteWYrQWY7YjxBZiYmemY8QWY/KDg+YiYmKGI9OCksQWY9Yjx6Zj96ZjpiKTp6Zj1iO3lmPWErQWY7dmZ8fCh2Zj0hMCx3aW5kb3cucG9zdE1lc3NhZ2UoQ2YsXCIqXCIpKX07c2Y9ZnVuY3Rpb24oYSxiKXt1Zj1hO251bGwhPWImJlwibnVtYmVyXCI9PT10eXBlb2YgYi50aW1lb3V0JiYod2Y9cmYoKStiLnRpbWVvdXQpO3hmfHwoeGY9ITAscmVxdWVzdEFuaW1hdGlvbkZyYW1lKERmKSk7cmV0dXJuIDB9O3RmPWZ1bmN0aW9uKCl7dWY9bnVsbDt2Zj0hMTt3Zj0tMX19ZWxzZSBzZj13aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayx0Zj13aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrO2Vsc2Ugc2Y9ZnVuY3Rpb24oYSl7cmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXthKHt0aW1lUmVtYWluaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIEluZmluaXR5fX0pfSl9LFxudGY9ZnVuY3Rpb24oYSl7Y2xlYXJUaW1lb3V0KGEpfTt2YXIgRWY9L15bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFwtLjAtOVxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBdKiQvLEZmPXt9LEdmPXt9O1xuZnVuY3Rpb24gSGYoYSl7aWYoR2YuaGFzT3duUHJvcGVydHkoYSkpcmV0dXJuITA7aWYoRmYuaGFzT3duUHJvcGVydHkoYSkpcmV0dXJuITE7aWYoRWYudGVzdChhKSlyZXR1cm4gR2ZbYV09ITA7RmZbYV09ITA7cmV0dXJuITF9XG5mdW5jdGlvbiBJZihhLGIsYyl7dmFyIGQ9d2EoYik7aWYoZCYmdmEoYixjKSl7dmFyIGU9ZC5tdXRhdGlvbk1ldGhvZDtlP2UoYSxjKTpudWxsPT1jfHxkLmhhc0Jvb2xlYW5WYWx1ZSYmIWN8fGQuaGFzTnVtZXJpY1ZhbHVlJiZpc05hTihjKXx8ZC5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSYmMT5jfHxkLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUmJiExPT09Yz9KZihhLGIpOmQubXVzdFVzZVByb3BlcnR5P2FbZC5wcm9wZXJ0eU5hbWVdPWM6KGI9ZC5hdHRyaWJ1dGVOYW1lLChlPWQuYXR0cmlidXRlTmFtZXNwYWNlKT9hLnNldEF0dHJpYnV0ZU5TKGUsYixcIlwiK2MpOmQuaGFzQm9vbGVhblZhbHVlfHxkLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUmJiEwPT09Yz9hLnNldEF0dHJpYnV0ZShiLFwiXCIpOmEuc2V0QXR0cmlidXRlKGIsXCJcIitjKSl9ZWxzZSBLZihhLGIsdmEoYixjKT9jOm51bGwpfVxuZnVuY3Rpb24gS2YoYSxiLGMpe0hmKGIpJiYobnVsbD09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTphLnNldEF0dHJpYnV0ZShiLFwiXCIrYykpfWZ1bmN0aW9uIEpmKGEsYil7dmFyIGM9d2EoYik7Yz8oYj1jLm11dGF0aW9uTWV0aG9kKT9iKGEsdm9pZCAwKTpjLm11c3RVc2VQcm9wZXJ0eT9hW2MucHJvcGVydHlOYW1lXT1jLmhhc0Jvb2xlYW5WYWx1ZT8hMTpcIlwiOmEucmVtb3ZlQXR0cmlidXRlKGMuYXR0cmlidXRlTmFtZSk6YS5yZW1vdmVBdHRyaWJ1dGUoYil9XG5mdW5jdGlvbiBMZihhLGIpe3ZhciBjPWIudmFsdWUsZD1iLmNoZWNrZWQ7cmV0dXJuIEIoe3R5cGU6dm9pZCAwLHN0ZXA6dm9pZCAwLG1pbjp2b2lkIDAsbWF4OnZvaWQgMH0sYix7ZGVmYXVsdENoZWNrZWQ6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsdmFsdWU6bnVsbCE9Yz9jOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsY2hlY2tlZDpudWxsIT1kP2Q6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkfSl9ZnVuY3Rpb24gTWYoYSxiKXt2YXIgYz1iLmRlZmF1bHRWYWx1ZTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxDaGVja2VkOm51bGwhPWIuY2hlY2tlZD9iLmNoZWNrZWQ6Yi5kZWZhdWx0Q2hlY2tlZCxpbml0aWFsVmFsdWU6bnVsbCE9Yi52YWx1ZT9iLnZhbHVlOmMsY29udHJvbGxlZDpcImNoZWNrYm94XCI9PT1iLnR5cGV8fFwicmFkaW9cIj09PWIudHlwZT9udWxsIT1iLmNoZWNrZWQ6bnVsbCE9Yi52YWx1ZX19XG5mdW5jdGlvbiBOZihhLGIpe2I9Yi5jaGVja2VkO251bGwhPWImJklmKGEsXCJjaGVja2VkXCIsYil9ZnVuY3Rpb24gT2YoYSxiKXtOZihhLGIpO3ZhciBjPWIudmFsdWU7aWYobnVsbCE9YylpZigwPT09YyYmXCJcIj09PWEudmFsdWUpYS52YWx1ZT1cIjBcIjtlbHNlIGlmKFwibnVtYmVyXCI9PT1iLnR5cGUpe2lmKGI9cGFyc2VGbG9hdChhLnZhbHVlKXx8MCxjIT1ifHxjPT1iJiZhLnZhbHVlIT1jKWEudmFsdWU9XCJcIitjfWVsc2UgYS52YWx1ZSE9PVwiXCIrYyYmKGEudmFsdWU9XCJcIitjKTtlbHNlIG51bGw9PWIudmFsdWUmJm51bGwhPWIuZGVmYXVsdFZhbHVlJiZhLmRlZmF1bHRWYWx1ZSE9PVwiXCIrYi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1cIlwiK2IuZGVmYXVsdFZhbHVlKSxudWxsPT1iLmNoZWNrZWQmJm51bGwhPWIuZGVmYXVsdENoZWNrZWQmJihhLmRlZmF1bHRDaGVja2VkPSEhYi5kZWZhdWx0Q2hlY2tlZCl9XG5mdW5jdGlvbiBQZihhLGIpe3N3aXRjaChiLnR5cGUpe2Nhc2UgXCJzdWJtaXRcIjpjYXNlIFwicmVzZXRcIjpicmVhaztjYXNlIFwiY29sb3JcIjpjYXNlIFwiZGF0ZVwiOmNhc2UgXCJkYXRldGltZVwiOmNhc2UgXCJkYXRldGltZS1sb2NhbFwiOmNhc2UgXCJtb250aFwiOmNhc2UgXCJ0aW1lXCI6Y2FzZSBcIndlZWtcIjphLnZhbHVlPVwiXCI7YS52YWx1ZT1hLmRlZmF1bHRWYWx1ZTticmVhaztkZWZhdWx0OmEudmFsdWU9YS52YWx1ZX1iPWEubmFtZTtcIlwiIT09YiYmKGEubmFtZT1cIlwiKTthLmRlZmF1bHRDaGVja2VkPSFhLmRlZmF1bHRDaGVja2VkO2EuZGVmYXVsdENoZWNrZWQ9IWEuZGVmYXVsdENoZWNrZWQ7XCJcIiE9PWImJihhLm5hbWU9Yil9ZnVuY3Rpb24gUWYoYSl7dmFyIGI9XCJcIjthYS5DaGlsZHJlbi5mb3JFYWNoKGEsZnVuY3Rpb24oYSl7bnVsbD09YXx8XCJzdHJpbmdcIiE9PXR5cGVvZiBhJiZcIm51bWJlclwiIT09dHlwZW9mIGF8fChiKz1hKX0pO3JldHVybiBifVxuZnVuY3Rpb24gUmYoYSxiKXthPUIoe2NoaWxkcmVuOnZvaWQgMH0sYik7aWYoYj1RZihiLmNoaWxkcmVuKSlhLmNoaWxkcmVuPWI7cmV0dXJuIGF9ZnVuY3Rpb24gU2YoYSxiLGMsZCl7YT1hLm9wdGlvbnM7aWYoYil7Yj17fTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyliW1wiJFwiK2NbZV1dPSEwO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspZT1iLmhhc093blByb3BlcnR5KFwiJFwiK2FbY10udmFsdWUpLGFbY10uc2VsZWN0ZWQhPT1lJiYoYVtjXS5zZWxlY3RlZD1lKSxlJiZkJiYoYVtjXS5kZWZhdWx0U2VsZWN0ZWQ9ITApfWVsc2V7Yz1cIlwiK2M7Yj1udWxsO2ZvcihlPTA7ZTxhLmxlbmd0aDtlKyspe2lmKGFbZV0udmFsdWU9PT1jKXthW2VdLnNlbGVjdGVkPSEwO2QmJihhW2VdLmRlZmF1bHRTZWxlY3RlZD0hMCk7cmV0dXJufW51bGwhPT1ifHxhW2VdLmRpc2FibGVkfHwoYj1hW2VdKX1udWxsIT09YiYmKGIuc2VsZWN0ZWQ9ITApfX1cbmZ1bmN0aW9uIFRmKGEsYil7dmFyIGM9Yi52YWx1ZTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpudWxsIT1jP2M6Yi5kZWZhdWx0VmFsdWUsd2FzTXVsdGlwbGU6ISFiLm11bHRpcGxlfX1mdW5jdGlvbiBVZihhLGIpe251bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/RShcIjkxXCIpOnZvaWQgMDtyZXR1cm4gQih7fSxiLHt2YWx1ZTp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCxjaGlsZHJlbjpcIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWV9KX1mdW5jdGlvbiBWZihhLGIpe3ZhciBjPWIudmFsdWU7bnVsbD09YyYmKGM9Yi5kZWZhdWx0VmFsdWUsYj1iLmNoaWxkcmVuLG51bGwhPWImJihudWxsIT1jP0UoXCI5MlwiKTp2b2lkIDAsQXJyYXkuaXNBcnJheShiKSYmKDE+PWIubGVuZ3RoP3ZvaWQgMDpFKFwiOTNcIiksYj1iWzBdKSxjPVwiXCIrYiksbnVsbD09YyYmKGM9XCJcIikpO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOlwiXCIrY319XG5mdW5jdGlvbiBXZihhLGIpe3ZhciBjPWIudmFsdWU7bnVsbCE9YyYmKGM9XCJcIitjLGMhPT1hLnZhbHVlJiYoYS52YWx1ZT1jKSxudWxsPT1iLmRlZmF1bHRWYWx1ZSYmKGEuZGVmYXVsdFZhbHVlPWMpKTtudWxsIT1iLmRlZmF1bHRWYWx1ZSYmKGEuZGVmYXVsdFZhbHVlPWIuZGVmYXVsdFZhbHVlKX1mdW5jdGlvbiBYZihhKXt2YXIgYj1hLnRleHRDb250ZW50O2I9PT1hLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlJiYoYS52YWx1ZT1iKX12YXIgWWY9e2h0bWw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsbWF0aG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLHN2ZzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9O1xuZnVuY3Rpb24gWmYoYSl7c3dpdGNoKGEpe2Nhc2UgXCJzdmdcIjpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7Y2FzZSBcIm1hdGhcIjpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjtkZWZhdWx0OnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwifX1mdW5jdGlvbiAkZihhLGIpe3JldHVybiBudWxsPT1hfHxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj09PWE/WmYoYik6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPT09YSYmXCJmb3JlaWduT2JqZWN0XCI9PT1iP1wiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiOmF9XG52YXIgYWc9dm9pZCAwLGJnPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgTVNBcHAmJk1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uP2Z1bmN0aW9uKGIsYyxkLGUpe01TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIGEoYixjLGQsZSl9KX06YX0oZnVuY3Rpb24oYSxiKXtpZihhLm5hbWVzcGFjZVVSSSE9PVlmLnN2Z3x8XCJpbm5lckhUTUxcImluIGEpYS5pbm5lckhUTUw9YjtlbHNle2FnPWFnfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO2FnLmlubmVySFRNTD1cIlxceDNjc3ZnXFx4M2VcIitiK1wiXFx4M2Mvc3ZnXFx4M2VcIjtmb3IoYj1hZy5maXJzdENoaWxkO2EuZmlyc3RDaGlsZDspYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpO2Zvcig7Yi5maXJzdENoaWxkOylhLmFwcGVuZENoaWxkKGIuZmlyc3RDaGlsZCl9fSk7XG5mdW5jdGlvbiBjZyhhLGIpe2lmKGIpe3ZhciBjPWEuZmlyc3RDaGlsZDtpZihjJiZjPT09YS5sYXN0Q2hpbGQmJjM9PT1jLm5vZGVUeXBlKXtjLm5vZGVWYWx1ZT1iO3JldHVybn19YS50ZXh0Q29udGVudD1ifVxudmFyIGRnPXthbmltYXRpb25JdGVyYXRpb25Db3VudDohMCxib3JkZXJJbWFnZU91dHNldDohMCxib3JkZXJJbWFnZVNsaWNlOiEwLGJvcmRlckltYWdlV2lkdGg6ITAsYm94RmxleDohMCxib3hGbGV4R3JvdXA6ITAsYm94T3JkaW5hbEdyb3VwOiEwLGNvbHVtbkNvdW50OiEwLGNvbHVtbnM6ITAsZmxleDohMCxmbGV4R3JvdzohMCxmbGV4UG9zaXRpdmU6ITAsZmxleFNocmluazohMCxmbGV4TmVnYXRpdmU6ITAsZmxleE9yZGVyOiEwLGdyaWRSb3c6ITAsZ3JpZFJvd0VuZDohMCxncmlkUm93U3BhbjohMCxncmlkUm93U3RhcnQ6ITAsZ3JpZENvbHVtbjohMCxncmlkQ29sdW1uRW5kOiEwLGdyaWRDb2x1bW5TcGFuOiEwLGdyaWRDb2x1bW5TdGFydDohMCxmb250V2VpZ2h0OiEwLGxpbmVDbGFtcDohMCxsaW5lSGVpZ2h0OiEwLG9wYWNpdHk6ITAsb3JkZXI6ITAsb3JwaGFuczohMCx0YWJTaXplOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMCxmaWxsT3BhY2l0eTohMCxmbG9vZE9wYWNpdHk6ITAsXG5zdG9wT3BhY2l0eTohMCxzdHJva2VEYXNoYXJyYXk6ITAsc3Ryb2tlRGFzaG9mZnNldDohMCxzdHJva2VNaXRlcmxpbWl0OiEwLHN0cm9rZU9wYWNpdHk6ITAsc3Ryb2tlV2lkdGg6ITB9LGVnPVtcIldlYmtpdFwiLFwibXNcIixcIk1velwiLFwiT1wiXTtPYmplY3Qua2V5cyhkZykuZm9yRWFjaChmdW5jdGlvbihhKXtlZy5mb3JFYWNoKGZ1bmN0aW9uKGIpe2I9YithLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Euc3Vic3RyaW5nKDEpO2RnW2JdPWRnW2FdfSl9KTtcbmZ1bmN0aW9uIGZnKGEsYil7YT1hLnN0eWxlO2Zvcih2YXIgYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykpe3ZhciBkPTA9PT1jLmluZGV4T2YoXCItLVwiKTt2YXIgZT1jO3ZhciBmPWJbY107ZT1udWxsPT1mfHxcImJvb2xlYW5cIj09PXR5cGVvZiBmfHxcIlwiPT09Zj9cIlwiOmR8fFwibnVtYmVyXCIhPT10eXBlb2YgZnx8MD09PWZ8fGRnLmhhc093blByb3BlcnR5KGUpJiZkZ1tlXT8oXCJcIitmKS50cmltKCk6ZitcInB4XCI7XCJmbG9hdFwiPT09YyYmKGM9XCJjc3NGbG9hdFwiKTtkP2Euc2V0UHJvcGVydHkoYyxlKTphW2NdPWV9fXZhciBnZz1CKHttZW51aXRlbTohMH0se2FyZWE6ITAsYmFzZTohMCxicjohMCxjb2w6ITAsZW1iZWQ6ITAsaHI6ITAsaW1nOiEwLGlucHV0OiEwLGtleWdlbjohMCxsaW5rOiEwLG1ldGE6ITAscGFyYW06ITAsc291cmNlOiEwLHRyYWNrOiEwLHdicjohMH0pO1xuZnVuY3Rpb24gaGcoYSxiLGMpe2ImJihnZ1thXSYmKG51bGwhPWIuY2hpbGRyZW58fG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/RShcIjEzN1wiLGEsYygpKTp2b2lkIDApLG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJihudWxsIT1iLmNoaWxkcmVuP0UoXCI2MFwiKTp2b2lkIDAsXCJvYmplY3RcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZcIl9faHRtbFwiaW4gYi5kYW5nZXJvdXNseVNldElubmVySFRNTD92b2lkIDA6RShcIjYxXCIpKSxudWxsIT1iLnN0eWxlJiZcIm9iamVjdFwiIT09dHlwZW9mIGIuc3R5bGU/RShcIjYyXCIsYygpKTp2b2lkIDApfVxuZnVuY3Rpb24gaWcoYSxiKXtpZigtMT09PWEuaW5kZXhPZihcIi1cIikpcmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBiLmlzO3N3aXRjaChhKXtjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpjYXNlIFwiY29sb3ItcHJvZmlsZVwiOmNhc2UgXCJmb250LWZhY2VcIjpjYXNlIFwiZm9udC1mYWNlLXNyY1wiOmNhc2UgXCJmb250LWZhY2UtdXJpXCI6Y2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpjYXNlIFwibWlzc2luZy1nbHlwaFwiOnJldHVybiExO2RlZmF1bHQ6cmV0dXJuITB9fXZhciBqZz1ZZi5odG1sLGtnPUMudGhhdFJldHVybnMoXCJcIik7XG5mdW5jdGlvbiBsZyhhLGIpe2E9OT09PWEubm9kZVR5cGV8fDExPT09YS5ub2RlVHlwZT9hOmEub3duZXJEb2N1bWVudDt2YXIgYz1IZChhKTtiPVNhW2JdO2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZT1iW2RdO2MuaGFzT3duUHJvcGVydHkoZSkmJmNbZV18fChcInRvcFNjcm9sbFwiPT09ZT93ZChcInRvcFNjcm9sbFwiLFwic2Nyb2xsXCIsYSk6XCJ0b3BGb2N1c1wiPT09ZXx8XCJ0b3BCbHVyXCI9PT1lPyh3ZChcInRvcEZvY3VzXCIsXCJmb2N1c1wiLGEpLHdkKFwidG9wQmx1clwiLFwiYmx1clwiLGEpLGMudG9wQmx1cj0hMCxjLnRvcEZvY3VzPSEwKTpcInRvcENhbmNlbFwiPT09ZT8oeWMoXCJjYW5jZWxcIiwhMCkmJndkKFwidG9wQ2FuY2VsXCIsXCJjYW5jZWxcIixhKSxjLnRvcENhbmNlbD0hMCk6XCJ0b3BDbG9zZVwiPT09ZT8oeWMoXCJjbG9zZVwiLCEwKSYmd2QoXCJ0b3BDbG9zZVwiLFwiY2xvc2VcIixhKSxjLnRvcENsb3NlPSEwKTpEZC5oYXNPd25Qcm9wZXJ0eShlKSYmVShlLERkW2VdLGEpLGNbZV09ITApfX1cbnZhciBtZz17dG9wQWJvcnQ6XCJhYm9ydFwiLHRvcENhblBsYXk6XCJjYW5wbGF5XCIsdG9wQ2FuUGxheVRocm91Z2g6XCJjYW5wbGF5dGhyb3VnaFwiLHRvcER1cmF0aW9uQ2hhbmdlOlwiZHVyYXRpb25jaGFuZ2VcIix0b3BFbXB0aWVkOlwiZW1wdGllZFwiLHRvcEVuY3J5cHRlZDpcImVuY3J5cHRlZFwiLHRvcEVuZGVkOlwiZW5kZWRcIix0b3BFcnJvcjpcImVycm9yXCIsdG9wTG9hZGVkRGF0YTpcImxvYWRlZGRhdGFcIix0b3BMb2FkZWRNZXRhZGF0YTpcImxvYWRlZG1ldGFkYXRhXCIsdG9wTG9hZFN0YXJ0OlwibG9hZHN0YXJ0XCIsdG9wUGF1c2U6XCJwYXVzZVwiLHRvcFBsYXk6XCJwbGF5XCIsdG9wUGxheWluZzpcInBsYXlpbmdcIix0b3BQcm9ncmVzczpcInByb2dyZXNzXCIsdG9wUmF0ZUNoYW5nZTpcInJhdGVjaGFuZ2VcIix0b3BTZWVrZWQ6XCJzZWVrZWRcIix0b3BTZWVraW5nOlwic2Vla2luZ1wiLHRvcFN0YWxsZWQ6XCJzdGFsbGVkXCIsdG9wU3VzcGVuZDpcInN1c3BlbmRcIix0b3BUaW1lVXBkYXRlOlwidGltZXVwZGF0ZVwiLHRvcFZvbHVtZUNoYW5nZTpcInZvbHVtZWNoYW5nZVwiLFxudG9wV2FpdGluZzpcIndhaXRpbmdcIn07ZnVuY3Rpb24gbmcoYSxiLGMsZCl7Yz05PT09Yy5ub2RlVHlwZT9jOmMub3duZXJEb2N1bWVudDtkPT09amcmJihkPVpmKGEpKTtkPT09amc/XCJzY3JpcHRcIj09PWE/KGE9Yy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGEuaW5uZXJIVE1MPVwiXFx4M2NzY3JpcHRcXHgzZVxceDNjL3NjcmlwdFxceDNlXCIsYT1hLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCkpOmE9XCJzdHJpbmdcIj09PXR5cGVvZiBiLmlzP2MuY3JlYXRlRWxlbWVudChhLHtpczpiLmlzfSk6Yy5jcmVhdGVFbGVtZW50KGEpOmE9Yy5jcmVhdGVFbGVtZW50TlMoZCxhKTtyZXR1cm4gYX1mdW5jdGlvbiBvZyhhLGIpe3JldHVybig5PT09Yi5ub2RlVHlwZT9iOmIub3duZXJEb2N1bWVudCkuY3JlYXRlVGV4dE5vZGUoYSl9XG5mdW5jdGlvbiBwZyhhLGIsYyxkKXt2YXIgZT1pZyhiLGMpO3N3aXRjaChiKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOlUoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7dmFyIGY9YzticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IoZiBpbiBtZyltZy5oYXNPd25Qcm9wZXJ0eShmKSYmVShmLG1nW2ZdLGEpO2Y9YzticmVhaztjYXNlIFwic291cmNlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO2Y9YzticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO1UoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJmb3JtXCI6VShcInRvcFJlc2V0XCIsXCJyZXNldFwiLGEpO1UoXCJ0b3BTdWJtaXRcIixcInN1Ym1pdFwiLGEpO2Y9YzticmVhaztjYXNlIFwiZGV0YWlsc1wiOlUoXCJ0b3BUb2dnbGVcIixcInRvZ2dsZVwiLGEpO2Y9YzticmVhaztjYXNlIFwiaW5wdXRcIjpNZihhLGMpO2Y9TGYoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO1xubGcoZCxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpmPVJmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOlRmKGEsYyk7Zj1CKHt9LGMse3ZhbHVlOnZvaWQgMH0pO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZCxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOlZmKGEsYyk7Zj1VZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7bGcoZCxcIm9uQ2hhbmdlXCIpO2JyZWFrO2RlZmF1bHQ6Zj1jfWhnKGIsZixrZyk7dmFyIGc9ZixoO2ZvcihoIGluIGcpaWYoZy5oYXNPd25Qcm9wZXJ0eShoKSl7dmFyIGs9Z1toXTtcInN0eWxlXCI9PT1oP2ZnKGEsayxrZyk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09aD8oaz1rP2suX19odG1sOnZvaWQgMCxudWxsIT1rJiZiZyhhLGspKTpcImNoaWxkcmVuXCI9PT1oP1wic3RyaW5nXCI9PT10eXBlb2Ygaz8oXCJ0ZXh0YXJlYVwiIT09Ynx8XCJcIiE9PWspJiZjZyhhLGspOlwibnVtYmVyXCI9PT10eXBlb2YgayYmY2coYSxcblwiXCIrayk6XCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWgmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1oJiZcImF1dG9Gb2N1c1wiIT09aCYmKFJhLmhhc093blByb3BlcnR5KGgpP251bGwhPWsmJmxnKGQsaCk6ZT9LZihhLGgsayk6bnVsbCE9ayYmSWYoYSxoLGspKX1zd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6QmMoYSk7UGYoYSxjKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpCYyhhKTtYZihhLGMpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpudWxsIT1jLnZhbHVlJiZhLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsYy52YWx1ZSk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEubXVsdGlwbGU9ISFjLm11bHRpcGxlO2I9Yy52YWx1ZTtudWxsIT1iP1NmKGEsISFjLm11bHRpcGxlLGIsITEpOm51bGwhPWMuZGVmYXVsdFZhbHVlJiZTZihhLCEhYy5tdWx0aXBsZSxjLmRlZmF1bHRWYWx1ZSwhMCk7YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5vbkNsaWNrJiYoYS5vbmNsaWNrPVxuQyl9fVxuZnVuY3Rpb24gc2coYSxiLGMsZCxlKXt2YXIgZj1udWxsO3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpjPUxmKGEsYyk7ZD1MZihhLGQpO2Y9W107YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmM9UmYoYSxjKTtkPVJmKGEsZCk7Zj1bXTticmVhaztjYXNlIFwic2VsZWN0XCI6Yz1CKHt9LGMse3ZhbHVlOnZvaWQgMH0pO2Q9Qih7fSxkLHt2YWx1ZTp2b2lkIDB9KTtmPVtdO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmM9VWYoYSxjKTtkPVVmKGEsZCk7Zj1bXTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjLm9uQ2xpY2smJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLm9uQ2xpY2smJihhLm9uY2xpY2s9Qyl9aGcoYixkLGtnKTt2YXIgZyxoO2E9bnVsbDtmb3IoZyBpbiBjKWlmKCFkLmhhc093blByb3BlcnR5KGcpJiZjLmhhc093blByb3BlcnR5KGcpJiZudWxsIT1jW2ddKWlmKFwic3R5bGVcIj09PWcpZm9yKGggaW4gYj1jW2ddLGIpYi5oYXNPd25Qcm9wZXJ0eShoKSYmKGF8fChhPXt9KSxhW2hdPVxuXCJcIik7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIiE9PWcmJlwiY2hpbGRyZW5cIiE9PWcmJlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1nJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZyYmXCJhdXRvRm9jdXNcIiE9PWcmJihSYS5oYXNPd25Qcm9wZXJ0eShnKT9mfHwoZj1bXSk6KGY9Znx8W10pLnB1c2goZyxudWxsKSk7Zm9yKGcgaW4gZCl7dmFyIGs9ZFtnXTtiPW51bGwhPWM/Y1tnXTp2b2lkIDA7aWYoZC5oYXNPd25Qcm9wZXJ0eShnKSYmayE9PWImJihudWxsIT1rfHxudWxsIT1iKSlpZihcInN0eWxlXCI9PT1nKWlmKGIpe2ZvcihoIGluIGIpIWIuaGFzT3duUHJvcGVydHkoaCl8fGsmJmsuaGFzT3duUHJvcGVydHkoaCl8fChhfHwoYT17fSksYVtoXT1cIlwiKTtmb3IoaCBpbiBrKWsuaGFzT3duUHJvcGVydHkoaCkmJmJbaF0hPT1rW2hdJiYoYXx8KGE9e30pLGFbaF09a1toXSl9ZWxzZSBhfHwoZnx8KGY9W10pLGYucHVzaChnLGEpKSxhPWs7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PVxuZz8oaz1rP2suX19odG1sOnZvaWQgMCxiPWI/Yi5fX2h0bWw6dm9pZCAwLG51bGwhPWsmJmIhPT1rJiYoZj1mfHxbXSkucHVzaChnLFwiXCIraykpOlwiY2hpbGRyZW5cIj09PWc/Yj09PWt8fFwic3RyaW5nXCIhPT10eXBlb2YgayYmXCJudW1iZXJcIiE9PXR5cGVvZiBrfHwoZj1mfHxbXSkucHVzaChnLFwiXCIrayk6XCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWcmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1nJiYoUmEuaGFzT3duUHJvcGVydHkoZyk/KG51bGwhPWsmJmxnKGUsZyksZnx8Yj09PWt8fChmPVtdKSk6KGY9Znx8W10pLnB1c2goZyxrKSl9YSYmKGY9Znx8W10pLnB1c2goXCJzdHlsZVwiLGEpO3JldHVybiBmfVxuZnVuY3Rpb24gdGcoYSxiLGMsZCxlKXtcImlucHV0XCI9PT1jJiZcInJhZGlvXCI9PT1lLnR5cGUmJm51bGwhPWUubmFtZSYmTmYoYSxlKTtpZyhjLGQpO2Q9aWcoYyxlKTtmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrPTIpe3ZhciBnPWJbZl0saD1iW2YrMV07XCJzdHlsZVwiPT09Zz9mZyhhLGgsa2cpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWc/YmcoYSxoKTpcImNoaWxkcmVuXCI9PT1nP2NnKGEsaCk6ZD9udWxsIT1oP0tmKGEsZyxoKTphLnJlbW92ZUF0dHJpYnV0ZShnKTpudWxsIT1oP0lmKGEsZyxoKTpKZihhLGcpfXN3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjpPZihhLGUpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOldmKGEsZSk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU9dm9pZCAwLGI9YS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlLGEuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZT0hIWUubXVsdGlwbGUsYz1lLnZhbHVlLG51bGwhPWM/U2YoYSxcbiEhZS5tdWx0aXBsZSxjLCExKTpiIT09ISFlLm11bHRpcGxlJiYobnVsbCE9ZS5kZWZhdWx0VmFsdWU/U2YoYSwhIWUubXVsdGlwbGUsZS5kZWZhdWx0VmFsdWUsITApOlNmKGEsISFlLm11bHRpcGxlLGUubXVsdGlwbGU/W106XCJcIiwhMSkpfX1cbmZ1bmN0aW9uIHVnKGEsYixjLGQsZSl7c3dpdGNoKGIpe2Nhc2UgXCJpZnJhbWVcIjpjYXNlIFwib2JqZWN0XCI6VShcInRvcExvYWRcIixcImxvYWRcIixhKTticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IodmFyIGYgaW4gbWcpbWcuaGFzT3duUHJvcGVydHkoZikmJlUoZixtZ1tmXSxhKTticmVhaztjYXNlIFwic291cmNlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7VShcInRvcExvYWRcIixcImxvYWRcIixhKTticmVhaztjYXNlIFwiZm9ybVwiOlUoXCJ0b3BSZXNldFwiLFwicmVzZXRcIixhKTtVKFwidG9wU3VibWl0XCIsXCJzdWJtaXRcIixhKTticmVhaztjYXNlIFwiZGV0YWlsc1wiOlUoXCJ0b3BUb2dnbGVcIixcInRvZ2dsZVwiLGEpO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOk1mKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtsZyhlLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOlRmKGEsYyk7XG5VKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2xnKGUsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpWZihhLGMpLFUoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSksbGcoZSxcIm9uQ2hhbmdlXCIpfWhnKGIsYyxrZyk7ZD1udWxsO2Zvcih2YXIgZyBpbiBjKWMuaGFzT3duUHJvcGVydHkoZykmJihmPWNbZ10sXCJjaGlsZHJlblwiPT09Zz9cInN0cmluZ1wiPT09dHlwZW9mIGY/YS50ZXh0Q29udGVudCE9PWYmJihkPVtcImNoaWxkcmVuXCIsZl0pOlwibnVtYmVyXCI9PT10eXBlb2YgZiYmYS50ZXh0Q29udGVudCE9PVwiXCIrZiYmKGQ9W1wiY2hpbGRyZW5cIixcIlwiK2ZdKTpSYS5oYXNPd25Qcm9wZXJ0eShnKSYmbnVsbCE9ZiYmbGcoZSxnKSk7c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOkJjKGEpO1BmKGEsYyk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6QmMoYSk7WGYoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Y2FzZSBcIm9wdGlvblwiOmJyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGMub25DbGljayYmXG4oYS5vbmNsaWNrPUMpfXJldHVybiBkfWZ1bmN0aW9uIHZnKGEsYil7cmV0dXJuIGEubm9kZVZhbHVlIT09Yn1cbnZhciB3Zz1PYmplY3QuZnJlZXplKHtjcmVhdGVFbGVtZW50Om5nLGNyZWF0ZVRleHROb2RlOm9nLHNldEluaXRpYWxQcm9wZXJ0aWVzOnBnLGRpZmZQcm9wZXJ0aWVzOnNnLHVwZGF0ZVByb3BlcnRpZXM6dGcsZGlmZkh5ZHJhdGVkUHJvcGVydGllczp1ZyxkaWZmSHlkcmF0ZWRUZXh0OnZnLHdhcm5Gb3JVbm1hdGNoZWRUZXh0OmZ1bmN0aW9uKCl7fSx3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50OmZ1bmN0aW9uKCl7fSx3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OmZ1bmN0aW9uKCl7fSx3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDpmdW5jdGlvbigpe30scmVzdG9yZUNvbnRyb2xsZWRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOk9mKGEsYyk7Yj1jLm5hbWU7aWYoXCJyYWRpb1wiPT09Yy50eXBlJiZudWxsIT1iKXtmb3IoYz1hO2MucGFyZW50Tm9kZTspYz1cbmMucGFyZW50Tm9kZTtjPWMucXVlcnlTZWxlY3RvckFsbChcImlucHV0W25hbWVcXHgzZFwiK0pTT04uc3RyaW5naWZ5KFwiXCIrYikrJ11bdHlwZVxceDNkXCJyYWRpb1wiXScpO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspe3ZhciBkPWNbYl07aWYoZCE9PWEmJmQuZm9ybT09PWEuZm9ybSl7dmFyIGU9cmIoZCk7ZT92b2lkIDA6RShcIjkwXCIpO0NjKGQpO09mKGQsZSl9fX1icmVhaztjYXNlIFwidGV4dGFyZWFcIjpXZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpiPWMudmFsdWUsbnVsbCE9YiYmU2YoYSwhIWMubXVsdGlwbGUsYiwhMSl9fX0pO25jLmluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQod2cpO3ZhciB4Zz1udWxsLE1nPW51bGw7ZnVuY3Rpb24gTmcoYSl7cmV0dXJuISghYXx8MSE9PWEubm9kZVR5cGUmJjkhPT1hLm5vZGVUeXBlJiYxMSE9PWEubm9kZVR5cGUmJig4IT09YS5ub2RlVHlwZXx8XCIgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgXCIhPT1hLm5vZGVWYWx1ZSkpfVxuZnVuY3Rpb24gT2coYSl7YT1hPzk9PT1hLm5vZGVUeXBlP2EuZG9jdW1lbnRFbGVtZW50OmEuZmlyc3RDaGlsZDpudWxsO3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlfHwhYS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlYWN0cm9vdFwiKSl9XG52YXIgWj1vZih7Z2V0Um9vdEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZVR5cGU7c3dpdGNoKGIpe2Nhc2UgOTpjYXNlIDExOmE9KGE9YS5kb2N1bWVudEVsZW1lbnQpP2EubmFtZXNwYWNlVVJJOiRmKG51bGwsXCJcIik7YnJlYWs7ZGVmYXVsdDpiPTg9PT1iP2EucGFyZW50Tm9kZTphLGE9Yi5uYW1lc3BhY2VVUkl8fG51bGwsYj1iLnRhZ05hbWUsYT0kZihhLGIpfXJldHVybiBhfSxnZXRDaGlsZEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEsYil7cmV0dXJuICRmKGEsYil9LGdldFB1YmxpY0luc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiBhfSxwcmVwYXJlRm9yQ29tbWl0OmZ1bmN0aW9uKCl7eGc9dGQ7dmFyIGE9ZGEoKTtpZihLZChhKSl7aWYoXCJzZWxlY3Rpb25TdGFydFwiaW4gYSl2YXIgYj17c3RhcnQ6YS5zZWxlY3Rpb25TdGFydCxlbmQ6YS5zZWxlY3Rpb25FbmR9O2Vsc2UgYTp7dmFyIGM9d2luZG93LmdldFNlbGVjdGlvbiYmd2luZG93LmdldFNlbGVjdGlvbigpO1xuaWYoYyYmMCE9PWMucmFuZ2VDb3VudCl7Yj1jLmFuY2hvck5vZGU7dmFyIGQ9Yy5hbmNob3JPZmZzZXQsZT1jLmZvY3VzTm9kZTtjPWMuZm9jdXNPZmZzZXQ7dHJ5e2Iubm9kZVR5cGUsZS5ub2RlVHlwZX1jYXRjaCh6KXtiPW51bGw7YnJlYWsgYX12YXIgZj0wLGc9LTEsaD0tMSxrPTAscT0wLHY9YSx5PW51bGw7Yjpmb3IoOzspe2Zvcih2YXIgdTs7KXt2IT09Ynx8MCE9PWQmJjMhPT12Lm5vZGVUeXBlfHwoZz1mK2QpO3YhPT1lfHwwIT09YyYmMyE9PXYubm9kZVR5cGV8fChoPWYrYyk7Mz09PXYubm9kZVR5cGUmJihmKz12Lm5vZGVWYWx1ZS5sZW5ndGgpO2lmKG51bGw9PT0odT12LmZpcnN0Q2hpbGQpKWJyZWFrO3k9djt2PXV9Zm9yKDs7KXtpZih2PT09YSlicmVhayBiO3k9PT1iJiYrK2s9PT1kJiYoZz1mKTt5PT09ZSYmKytxPT09YyYmKGg9Zik7aWYobnVsbCE9PSh1PXYubmV4dFNpYmxpbmcpKWJyZWFrO3Y9eTt5PXYucGFyZW50Tm9kZX12PXV9Yj0tMT09PWd8fC0xPT09aD9udWxsOlxue3N0YXJ0OmcsZW5kOmh9fWVsc2UgYj1udWxsfWI9Ynx8e3N0YXJ0OjAsZW5kOjB9fWVsc2UgYj1udWxsO01nPXtmb2N1c2VkRWxlbTphLHNlbGVjdGlvblJhbmdlOmJ9O3VkKCExKX0scmVzZXRBZnRlckNvbW1pdDpmdW5jdGlvbigpe3ZhciBhPU1nLGI9ZGEoKSxjPWEuZm9jdXNlZEVsZW0sZD1hLnNlbGVjdGlvblJhbmdlO2lmKGIhPT1jJiZmYShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsYykpe2lmKEtkKGMpKWlmKGI9ZC5zdGFydCxhPWQuZW5kLHZvaWQgMD09PWEmJihhPWIpLFwic2VsZWN0aW9uU3RhcnRcImluIGMpYy5zZWxlY3Rpb25TdGFydD1iLGMuc2VsZWN0aW9uRW5kPU1hdGgubWluKGEsYy52YWx1ZS5sZW5ndGgpO2Vsc2UgaWYod2luZG93LmdldFNlbGVjdGlvbil7Yj13aW5kb3cuZ2V0U2VsZWN0aW9uKCk7dmFyIGU9Y1tFYigpXS5sZW5ndGg7YT1NYXRoLm1pbihkLnN0YXJ0LGUpO2Q9dm9pZCAwPT09ZC5lbmQ/YTpNYXRoLm1pbihkLmVuZCxlKTshYi5leHRlbmQmJmE+XG5kJiYoZT1kLGQ9YSxhPWUpO2U9SmQoYyxhKTt2YXIgZj1KZChjLGQpO2lmKGUmJmYmJigxIT09Yi5yYW5nZUNvdW50fHxiLmFuY2hvck5vZGUhPT1lLm5vZGV8fGIuYW5jaG9yT2Zmc2V0IT09ZS5vZmZzZXR8fGIuZm9jdXNOb2RlIT09Zi5ub2RlfHxiLmZvY3VzT2Zmc2V0IT09Zi5vZmZzZXQpKXt2YXIgZz1kb2N1bWVudC5jcmVhdGVSYW5nZSgpO2cuc2V0U3RhcnQoZS5ub2RlLGUub2Zmc2V0KTtiLnJlbW92ZUFsbFJhbmdlcygpO2E+ZD8oYi5hZGRSYW5nZShnKSxiLmV4dGVuZChmLm5vZGUsZi5vZmZzZXQpKTooZy5zZXRFbmQoZi5ub2RlLGYub2Zmc2V0KSxiLmFkZFJhbmdlKGcpKX19Yj1bXTtmb3IoYT1jO2E9YS5wYXJlbnROb2RlOykxPT09YS5ub2RlVHlwZSYmYi5wdXNoKHtlbGVtZW50OmEsbGVmdDphLnNjcm9sbExlZnQsdG9wOmEuc2Nyb2xsVG9wfSk7aWEoYyk7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKylhPWJbY10sYS5lbGVtZW50LnNjcm9sbExlZnQ9YS5sZWZ0LGEuZWxlbWVudC5zY3JvbGxUb3A9XG5hLnRvcH1NZz1udWxsO3VkKHhnKTt4Zz1udWxsfSxjcmVhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkLGUpe2E9bmcoYSxiLGMsZCk7YVtRXT1lO2Fbb2JdPWI7cmV0dXJuIGF9LGFwcGVuZEluaXRpYWxDaGlsZDpmdW5jdGlvbihhLGIpe2EuYXBwZW5kQ2hpbGQoYil9LGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOmZ1bmN0aW9uKGEsYixjLGQpe3BnKGEsYixjLGQpO2E6e3N3aXRjaChiKXtjYXNlIFwiYnV0dG9uXCI6Y2FzZSBcImlucHV0XCI6Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJ0ZXh0YXJlYVwiOmE9ISFjLmF1dG9Gb2N1czticmVhayBhfWE9ITF9cmV0dXJuIGF9LHByZXBhcmVVcGRhdGU6ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gc2coYSxiLGMsZCxlKX0sc2hvdWxkU2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm5cInRleHRhcmVhXCI9PT1hfHxcInN0cmluZ1wiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwibnVtYmVyXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJvYmplY3RcIj09PVxudHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJm51bGwhPT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZcInN0cmluZ1wiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sfSxzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuISFiLmhpZGRlbn0sY3JlYXRlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQpe2E9b2coYSxiKTthW1FdPWQ7cmV0dXJuIGF9LG5vdzpyZixtdXRhdGlvbjp7Y29tbWl0TW91bnQ6ZnVuY3Rpb24oYSl7YS5mb2N1cygpfSxjb21taXRVcGRhdGU6ZnVuY3Rpb24oYSxiLGMsZCxlKXthW29iXT1lO3RnKGEsYixjLGQsZSl9LHJlc2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSl7YS50ZXh0Q29udGVudD1cIlwifSxjb21taXRUZXh0VXBkYXRlOmZ1bmN0aW9uKGEsYixjKXthLm5vZGVWYWx1ZT1jfSxhcHBlbmRDaGlsZDpmdW5jdGlvbihhLGIpe2EuYXBwZW5kQ2hpbGQoYil9LGFwcGVuZENoaWxkVG9Db250YWluZXI6ZnVuY3Rpb24oYSxcbmIpezg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYixhKTphLmFwcGVuZENoaWxkKGIpfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24oYSxiLGMpe2EuaW5zZXJ0QmVmb3JlKGIsYyl9LGluc2VydEluQ29udGFpbmVyQmVmb3JlOmZ1bmN0aW9uKGEsYixjKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGIsYyk6YS5pbnNlcnRCZWZvcmUoYixjKX0scmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLnJlbW92ZUNoaWxkKGIpfSxyZW1vdmVDaGlsZEZyb21Db250YWluZXI6ZnVuY3Rpb24oYSxiKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik6YS5yZW1vdmVDaGlsZChiKX19LGh5ZHJhdGlvbjp7Y2FuSHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDEhPT1hLm5vZGVUeXBlfHxiLnRvTG93ZXJDYXNlKCkhPT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk/bnVsbDphfSxjYW5IeWRyYXRlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEsXG5iKXtyZXR1cm5cIlwiPT09Ynx8MyE9PWEubm9kZVR5cGU/bnVsbDphfSxnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6ZnVuY3Rpb24oYSl7Zm9yKGE9YS5uZXh0U2libGluZzthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX0sZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQ6ZnVuY3Rpb24oYSl7Zm9yKGE9YS5maXJzdENoaWxkO2EmJjEhPT1hLm5vZGVUeXBlJiYzIT09YS5ub2RlVHlwZTspYT1hLm5leHRTaWJsaW5nO3JldHVybiBhfSxoeWRyYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2FbUV09ZjthW29iXT1jO3JldHVybiB1ZyhhLGIsYyxlLGQpfSxoeWRyYXRlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEsYixjKXthW1FdPWM7cmV0dXJuIHZnKGEsYil9LGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9LFxuZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RIeWRyYXRlSW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTpmdW5jdGlvbigpe319LHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazpzZixjYW5jZWxEZWZlcnJlZENhbGxiYWNrOnRmLHVzZVN5bmNTY2hlZHVsaW5nOiEwfSk7cmM9Wi5iYXRjaGVkVXBkYXRlcztcbmZ1bmN0aW9uIFBnKGEsYixjLGQsZSl7TmcoYyk/dm9pZCAwOkUoXCIyMDBcIik7dmFyIGY9Yy5fcmVhY3RSb290Q29udGFpbmVyO2lmKGYpWi51cGRhdGVDb250YWluZXIoYixmLGEsZSk7ZWxzZXtkPWR8fE9nKGMpO2lmKCFkKWZvcihmPXZvaWQgMDtmPWMubGFzdENoaWxkOyljLnJlbW92ZUNoaWxkKGYpO3ZhciBnPVouY3JlYXRlQ29udGFpbmVyKGMsZCk7Zj1jLl9yZWFjdFJvb3RDb250YWluZXI9ZztaLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24oKXtaLnVwZGF0ZUNvbnRhaW5lcihiLGcsYSxlKX0pfXJldHVybiBaLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShmKX1mdW5jdGlvbiBRZyhhLGIpe3ZhciBjPTI8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzJdP2FyZ3VtZW50c1syXTpudWxsO05nKGIpP3ZvaWQgMDpFKFwiMjAwXCIpO3JldHVybiBwZihhLGIsbnVsbCxjKX1cbmZ1bmN0aW9uIFJnKGEsYil7dGhpcy5fcmVhY3RSb290Q29udGFpbmVyPVouY3JlYXRlQ29udGFpbmVyKGEsYil9UmcucHJvdG90eXBlLnJlbmRlcj1mdW5jdGlvbihhLGIpe1oudXBkYXRlQ29udGFpbmVyKGEsdGhpcy5fcmVhY3RSb290Q29udGFpbmVyLG51bGwsYil9O1JnLnByb3RvdHlwZS51bm1vdW50PWZ1bmN0aW9uKGEpe1oudXBkYXRlQ29udGFpbmVyKG51bGwsdGhpcy5fcmVhY3RSb290Q29udGFpbmVyLG51bGwsYSl9O1xudmFyIFNnPXtjcmVhdGVQb3J0YWw6UWcsZmluZERPTU5vZGU6ZnVuY3Rpb24oYSl7aWYobnVsbD09YSlyZXR1cm4gbnVsbDtpZigxPT09YS5ub2RlVHlwZSlyZXR1cm4gYTt2YXIgYj1hLl9yZWFjdEludGVybmFsRmliZXI7aWYoYilyZXR1cm4gWi5maW5kSG9zdEluc3RhbmNlKGIpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBhLnJlbmRlcj9FKFwiMTg4XCIpOkUoXCIyMTNcIixPYmplY3Qua2V5cyhhKSl9LGh5ZHJhdGU6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBQZyhudWxsLGEsYiwhMCxjKX0scmVuZGVyOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gUGcobnVsbCxhLGIsITEsYyl9LHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOmZ1bmN0aW9uKGEsYixjLGQpe251bGw9PWF8fHZvaWQgMD09PWEuX3JlYWN0SW50ZXJuYWxGaWJlcj9FKFwiMzhcIik6dm9pZCAwO3JldHVybiBQZyhhLGIsYywhMSxkKX0sdW5tb3VudENvbXBvbmVudEF0Tm9kZTpmdW5jdGlvbihhKXtOZyhhKT92b2lkIDA6XG5FKFwiNDBcIik7cmV0dXJuIGEuX3JlYWN0Um9vdENvbnRhaW5lcj8oWi51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCl7UGcobnVsbCxudWxsLGEsITEsZnVuY3Rpb24oKXthLl9yZWFjdFJvb3RDb250YWluZXI9bnVsbH0pfSksITApOiExfSx1bnN0YWJsZV9jcmVhdGVQb3J0YWw6UWcsdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6dGMsdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOlouZGVmZXJyZWRVcGRhdGVzLGZsdXNoU3luYzpaLmZsdXNoU3luYyxfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDp7RXZlbnRQbHVnaW5IdWI6bWIsRXZlbnRQbHVnaW5SZWdpc3RyeTpWYSxFdmVudFByb3BhZ2F0b3JzOkNiLFJlYWN0Q29udHJvbGxlZENvbXBvbmVudDpxYyxSZWFjdERPTUNvbXBvbmVudFRyZWU6c2IsUmVhY3RET01FdmVudExpc3RlbmVyOnhkfX07XG5aLmluamVjdEludG9EZXZUb29scyh7ZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6cGIsYnVuZGxlVHlwZTowLHZlcnNpb246XCIxNi4yLjBcIixyZW5kZXJlclBhY2thZ2VOYW1lOlwicmVhY3QtZG9tXCJ9KTt2YXIgVGc9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpTZ30pLFVnPVRnJiZTZ3x8VGc7bW9kdWxlLmV4cG9ydHM9VWdbXCJkZWZhdWx0XCJdP1VnW1wiZGVmYXVsdFwiXTpVZztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBpc05vZGUgPSByZXF1aXJlKCcuL2lzTm9kZScpO1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIHRleHQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNUZXh0Tm9kZShvYmplY3QpIHtcbiAgcmV0dXJuIGlzTm9kZShvYmplY3QpICYmIG9iamVjdC5ub2RlVHlwZSA9PSAzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dE5vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzVGV4dE5vZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzTm9kZShvYmplY3QpIHtcbiAgdmFyIGRvYyA9IG9iamVjdCA/IG9iamVjdC5vd25lckRvY3VtZW50IHx8IG9iamVjdCA6IGRvY3VtZW50O1xuICB2YXIgZGVmYXVsdFZpZXcgPSBkb2MuZGVmYXVsdFZpZXcgfHwgd2luZG93O1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgZGVmYXVsdFZpZXcuTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIGRlZmF1bHRWaWV3Lk5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNOb2RlLmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4yLjBcbiAqIHJlYWN0LWRvbS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbiFSZWFjdCA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NIHdhcyBsb2FkZWQgYmVmb3JlIFJlYWN0LiBNYWtlIHN1cmUgeW91IGxvYWQgdGhlIFJlYWN0IHBhY2thZ2UgYmVmb3JlIGxvYWRpbmcgUmVhY3RET00uJykgOiB2b2lkIDA7XG5cbi8vIFRoZXNlIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGFsbCBsb3dlcmNhc2UgdG8gYWxsb3cgZm9yXG4vLyBjYXNlIGluc2Vuc2l0aXZlIGNoZWNrc1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogdHJ1ZSxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgZGVmYXVsdENoZWNrZWQ6IHRydWUsXG4gIGlubmVySFRNTDogdHJ1ZSxcbiAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiB0cnVlLFxuICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gIHN0eWxlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9QUk9QRVJUWTogMHgxLFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg0LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHg4LFxuICBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTogMHgxMCB8IDB4OCxcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHgyMCxcbiAgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFOiAweDQwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lc3BhY2UgVVJMLiAoQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIG5vIG5hbWVzcGFjZS4pXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgSW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG4gICAgdmFyIFByb3BlcnRpZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lc3BhY2VzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNwYWNlcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IGludmFyaWFudChmYWxzZSwgXCJpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3UncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgJyVzJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLlwiLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNTdHJpbmdCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFKVxuICAgICAgfTtcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgXCJET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yIG51bWVyaWMgdmFsdWUsIGJ1dCBub3QgYSBjb21iaW5hdGlvbjogJXNcIiwgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuXG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBET01BdHRyaWJ1dGVOYW1lc3BhY2VzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTU11dGF0aW9uTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kID0gRE9NTXV0YXRpb25NZXRob2RzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgLy8gRG93bmNhc2UgcmVmZXJlbmNlcyB0byB3aGl0ZWxpc3QgcHJvcGVydGllcyB0byBjaGVjayBmb3IgbWVtYmVyc2hpcFxuICAgICAgLy8gd2l0aG91dCBjYXNlLXNlbnNpdGl2aXR5LiBUaGlzIGFsbG93cyB0aGUgd2hpdGVsaXN0IHRvIHBpY2sgdXBcbiAgICAgIC8vIGBhbGxvd2Z1bGxzY3JlZW5gLCB3aGljaCBzaG91bGQgYmUgd3JpdHRlbiB1c2luZyB0aGUgcHJvcGVydHkgY29uZmlndXJhdGlvblxuICAgICAgLy8gZm9yIGBhbGxvd0Z1bGxzY3JlZW5gXG4gICAgICBwcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcblxuXG52YXIgUk9PVF9BVFRSSUJVVEVfTkFNRSA9ICdkYXRhLXJlYWN0cm9vdCc7XG5cbi8qKlxuICogTWFwIGZyb20gcHJvcGVydHkgXCJzdGFuZGFyZCBuYW1lXCIgdG8gYW4gb2JqZWN0IHdpdGggaW5mbyBhYm91dCBob3cgdG8gc2V0XG4gKiB0aGUgcHJvcGVydHkgaW4gdGhlIERPTS4gRWFjaCBvYmplY3QgY29udGFpbnM6XG4gKlxuICogYXR0cmlidXRlTmFtZTpcbiAqICAgVXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICogcHJvcGVydHlOYW1lOlxuICogICBVc2VkIG9uIERPTSBub2RlIGluc3RhbmNlcy4gKFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IG11dGF0ZSBkdWUgdG9cbiAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gKiBtdXRhdGlvbk1ldGhvZDpcbiAqICAgSWYgbm9uLW51bGwsIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkgb3IgYHNldEF0dHJpYnV0ZSgpYCBhZnRlclxuICogICBpbml0aWFsIHJlbmRlci5cbiAqIG11c3RVc2VQcm9wZXJ0eTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gKiBoYXNCb29sZWFuVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzTnVtZXJpY1ZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAqICAgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICogICBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAqICAgUmVtb3ZlZCB3aGVuIHN0cmljdGx5IGVxdWFsIHRvIGZhbHNlOyBwcmVzZW50IHdpdGhvdXQgYSB2YWx1ZSB3aGVuXG4gKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAqL1xudmFyIHByb3BlcnRpZXMgPSB7fTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSB3cml0ZWFibGUgYXR0cmlidXRlLlxuICogQG1ldGhvZFxuICovXG5mdW5jdGlvbiBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKTtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZ1bmN0aW9uLCBzeW1ib2xcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUluZm8obmFtZSkge1xuICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUobmFtZSkge1xuICBpZiAoaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc1N0cmluZ0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTtcbiAgfVxuICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICByZXR1cm4gcHJlZml4ID09PSAnZGF0YS0nIHx8IHByZWZpeCA9PT0gJ2FyaWEtJztcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIGEgcHJvcGVydHkgbmFtZSBpcyB3aXRoaW4gdGhlIGxpc3Qgb2YgcHJvcGVydGllc1xuICogcmVzZXJ2ZWQgZm9yIGludGVybmFsIFJlYWN0IG9wZXJhdGlvbnMuIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkXG4gKiBub3QgYmUgc2V0IG9uIGFuIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBuYW1lIGlzIHdpdGhpbiByZXNlcnZlZCBwcm9wc1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkUHJvcChuYW1lKSB7XG4gIHJldHVybiBSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbn1cblxudmFyIGluamVjdGlvbiA9IERPTVByb3BlcnR5SW5qZWN0aW9uO1xuXG52YXIgTVVTVF9VU0VfUFJPUEVSVFkgPSBpbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG52YXIgSEFTX0JPT0xFQU5fVkFMVUUgPSBpbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX05VTUVSSUNfVkFMVUUgPSBpbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUgPSBpbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIC8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbiAgLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3RcbiAgLy8gbmFtZSB3YXJuaW5ncy5cbiAgUHJvcGVydGllczoge1xuICAgIGFsbG93RnVsbFNjcmVlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gc3BlY2lmaWVzIHRhcmdldCBjb250ZXh0IGZvciBsaW5rcyB3aXRoIGBwcmVsb2FkYCB0eXBlXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIE5vdGU6IHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgcHJldmVudHMgaXQgZnJvbSBiZWluZyB3cml0dGVuIHRvIHRoZSBET01cbiAgICAvLyBvbiB0aGUgY2xpZW50IHNpZGUgYmVjYXVzZSB0aGUgYnJvd3NlcnMgYXJlIGluY29uc2lzdGVudC4gSW5zdGVhZCB3ZSBjYWxsIGZvY3VzKCkuXG4gICAgYXV0b0ZvY3VzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvUGxheTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY2FwdHVyZTogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBjaGVja2VkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvbHM6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLFxuICAgIGNvbnRyb2xzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAnZGVmYXVsdCc6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRlZmVyOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkaXNhYmxlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybU5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZGRlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG9vcDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gQ2F1dGlvbjsgYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbiAgICAvLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLlxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHBsYXlzSW5saW5lOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZWFkT25seTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVxdWlyZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJldmVyc2VkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByb3dzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICByb3dTcGFuOiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlYW1sZXNzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWxlY3RlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzaXplOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgLy8gc3VwcG9ydCBmb3IgcHJvamVjdGluZyByZWd1bGFyIERPTSBFbGVtZW50cyB2aWEgVjEgbmFtZWQgc2xvdHMgKCBzaGFkb3cgZG9tIClcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gU3R5bGUgbXVzdCBiZSBleHBsaWNpdGx5IHNldCBpbiB0aGUgYXR0cmlidXRlIGxpc3QuIFJlYWN0IGNvbXBvbmVudHNcbiAgICAvLyBleHBlY3QgYSBzdHlsZSBvYmplY3RcbiAgICBzdHlsZTogMCxcbiAgICAvLyBLZWVwIGl0IGluIHRoZSB3aGl0ZWxpc3QgYmVjYXVzZSBpdCBpcyBjYXNlLXNlbnNpdGl2ZSBmb3IgU1ZHLlxuICAgIHRhYkluZGV4OiAwLFxuICAgIC8vIGl0ZW1TY29wZSBpcyBmb3IgZm9yIE1pY3JvZGF0YSBzdXBwb3J0LlxuICAgIC8vIFNlZSBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtU2NvcGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIFRoZXNlIGF0dHJpYnV0ZXMgbXVzdCBzdGF5IGluIHRoZSB3aGl0ZS1saXN0IGJlY2F1c2UgdGhleSBoYXZlXG4gICAgLy8gZGlmZmVyZW50IGF0dHJpYnV0ZSBuYW1lcyAoc2VlIERPTUF0dHJpYnV0ZU5hbWVzIGJlbG93KVxuICAgIGFjY2VwdENoYXJzZXQ6IDAsXG4gICAgY2xhc3NOYW1lOiAwLFxuICAgIGh0bWxGb3I6IDAsXG4gICAgaHR0cEVxdWl2OiAwLFxuICAgIC8vIEF0dHJpYnV0ZXMgd2l0aCBtdXRhdGlvbiBtZXRob2RzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSB3aGl0ZWxpc3RcbiAgICAvLyBTZXQgdGhlIHN0cmluZyBib29sZWFuIGZsYWcgdG8gYWxsb3cgdGhlIGJlaGF2aW9yXG4gICAgdmFsdWU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIERPTU11dGF0aW9uTWV0aG9kczoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgLy8gTnVtYmVyIGlucHV0cyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgZHVlIHRvIHNvbWUgZWRnZSBjYXNlcyBpblxuICAgICAgLy8gQ2hyb21lLiBMZXQgZXZlcnl0aGluZyBlbHNlIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIGFzIG5vcm1hbC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1MyNpc3N1ZWNvbW1lbnQtMjM2MDc0MzI2XG4gICAgICBpZiAobm9kZS50eXBlICE9PSAnbnVtYmVyJyB8fCBub2RlLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsaWRpdHkgJiYgIW5vZGUudmFsaWRpdHkuYmFkSW5wdXQgJiYgbm9kZS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IG5vZGUpIHtcbiAgICAgICAgLy8gRG9uJ3QgYXNzaWduIGFuIGF0dHJpYnV0ZSBpZiB2YWxpZGF0aW9uIHJlcG9ydHMgYmFkXG4gICAgICAgIC8vIGlucHV0LiBDaHJvbWUgd2lsbCBjbGVhciB0aGUgdmFsdWUuIEFkZGl0aW9uYWxseSwgZG9uJ3RcbiAgICAgICAgLy8gb3BlcmF0ZSBvbiBpbnB1dHMgdGhhdCBoYXZlIGZvY3VzLCBvdGhlcndpc2UgQ2hyb21lIG1pZ2h0XG4gICAgICAgIC8vIHN0cmlwIG9mZiB0cmFpbGluZyBkZWNpbWFsIHBsYWNlcyBhbmQgY2F1c2UgdGhlIHVzZXInc1xuICAgICAgICAvLyBjdXJzb3IgcG9zaXRpb24gdG8ganVtcCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW4gUmVhY3RET01JbnB1dCwgd2UgaGF2ZSBhbiBvbkJsdXIgZXZlbnQgdGhhdCB3aWxsIHRyaWdnZXJcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBhZ2FpbiB3aGVuIGZvY3VzIGlzIGxvc3QuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSQxID0gaW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTtcblxuXG52YXIgTlMgPSB7XG4gIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIFNWRyBhdHRyaWJ1dGVzIHRoYXQgbmVlZCBzcGVjaWFsIGNhc2luZyxcbiAqIG5hbWVzcGFjaW5nLCBvciBib29sZWFuIHZhbHVlIGFzc2lnbm1lbnQuXG4gKlxuICogV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuICogdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3RcbiAqIG5hbWUgd2FybmluZ3MuXG4gKlxuICogU1ZHIEF0dHJpYnV0ZXMgTGlzdDpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvYXR0aW5kZXguaHRtbFxuICogU01JTCBTcGVjOlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NtaWxcbiAqL1xudmFyIEFUVFJTID0gWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4LWhlaWdodCcsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWxuczp4bGluaycsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7XG4gICAgYXV0b1JldmVyc2U6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSQxLFxuICAgIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSQxLFxuICAgIHByZXNlcnZlQWxwaGE6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSQxXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYXV0b1JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICAgIHByZXNlcnZlQWxwaGE6ICdwcmVzZXJ2ZUFscGhhJ1xuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiB7XG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rSHJlZjogTlMueGxpbmssXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxuICAgIHhsaW5rVGl0bGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXG4gICAgeG1sQmFzZTogTlMueG1sLFxuICAgIHhtbExhbmc6IE5TLnhtbCxcbiAgICB4bWxTcGFjZTogTlMueG1sXG4gIH1cbn07XG5cbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcbnZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblsxXS50b1VwcGVyQ2FzZSgpO1xufTtcblxuQVRUUlMuZm9yRWFjaChmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIHJlYWN0TmFtZSA9IG9yaWdpbmFsLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuXG4gIFNWR0RPTVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXNbcmVhY3ROYW1lXSA9IDA7XG4gIFNWR0RPTVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzW3JlYWN0TmFtZV0gPSBvcmlnaW5hbDtcbn0pO1xuXG5pbmplY3Rpb24uaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbmluamVjdGlvbi5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIC8vIFVzZWQgYnkgRmliZXIgdG8gc2ltdWxhdGUgYSB0cnktY2F0Y2guXG4gIF9jYXVnaHRFcnJvcjogbnVsbCxcbiAgX2hhc0NhdWdodEVycm9yOiBmYWxzZSxcblxuICAvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxuICBfcmV0aHJvd0Vycm9yOiBudWxsLFxuICBfaGFzUmV0aHJvd0Vycm9yOiBmYWxzZSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RFcnJvclV0aWxzOiBmdW5jdGlvbiAoaW5qZWN0ZWRFcnJvclV0aWxzKSB7XG4gICAgICAhKHR5cGVvZiBpbmplY3RlZEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0luamVjdGVkIGludm9rZUd1YXJkZWRDYWxsYmFjaygpIG11c3QgYmUgYSBmdW5jdGlvbi4nKSA6IHZvaWQgMDtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAgICogUmV0dXJucyBhbiBlcnJvciBpZiBpdCB0aHJvd3MsIG90aGVyd2lzZSBudWxsLlxuICAgKlxuICAgKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gICAqIHVzZSBhIHRyeS1jYXRjaCBkaXJlY3RseSBpcyBzbyB0aGF0IHdlIGNhbiBzd2FwIG91dCBhIGRpZmZlcmVudFxuICAgKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseShSZWFjdEVycm9yVXRpbHMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgaW52b2tlR3VhcmRlZENhbGxiYWNrLCBidXQgaW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gZXJyb3IsIGl0IHN0b3Jlc1xuICAgKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gICAqIFRPRE86IFNlZSBpZiBfY2F1Z2h0RXJyb3IgYW5kIF9yZXRocm93RXJyb3IgY2FuIGJlIHVuaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcjogZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgaWYgKCFSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJldGhyb3dDYXVnaHRFcnJvci5hcHBseShSZWFjdEVycm9yVXRpbHMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgaGFzQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcjtcbiAgfSxcblxuICBjbGVhckNhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3I7XG4gICAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gZXJyb3I7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gIH1cbn07XG5cbntcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW50aW50dWl0aXZlLCB0aG91Z2gsIGJlY2F1c2UgZXZlbiB0aG91Z2ggUmVhY3QgaGFzIGNhdWdodCB0aGUgZXJyb3IsIGZyb21cbiAgLy8gdGhlIGRldmVsb3BlcidzIHBlcnNwZWN0aXZlLCB0aGUgZXJyb3IgaXMgdW5jYXVnaHQuXG4gIC8vXG4gIC8vIFRvIHByZXNlcnZlIHRoZSBleHBlY3RlZCBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvciwgd2UgZG9uJ3QgdXNlIGFcbiAgLy8gdHJ5LWNhdGNoIGluIERFVi4gSW5zdGVhZCwgd2Ugc3luY2hyb25vdXNseSBkaXNwYXRjaCBhIGZha2UgZXZlbnQgdG8gYSBmYWtlXG4gIC8vIERPTSBub2RlLCBhbmQgY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayBmcm9tIGluc2lkZSBhbiBldmVudCBoYW5kbGVyXG4gIC8vIGZvciB0aGF0IGZha2UgZXZlbnQuIElmIHRoZSBjYWxsYmFjayB0aHJvd3MsIHRoZSBlcnJvciBpcyBcImNhcHR1cmVkXCIgdXNpbmdcbiAgLy8gYSBnbG9iYWwgZXZlbnQgaGFuZGxlci4gQnV0IGJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbnMgaW4gYSBkaWZmZXJlbnRcbiAgLy8gZXZlbnQgbG9vcCBjb250ZXh0LCBpdCBkb2VzIG5vdCBpbnRlcnJ1cHQgdGhlIG5vcm1hbCBwcm9ncmFtIGZsb3cuXG4gIC8vIEVmZmVjdGl2ZWx5LCB0aGlzIGdpdmVzIHVzIHRyeS1jYXRjaCBiZWhhdmlvciB3aXRob3V0IGFjdHVhbGx5IHVzaW5nXG4gIC8vIHRyeS1jYXRjaC4gTmVhdCFcblxuICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4gIC8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuICAgIHZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hldGhlciB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB0aHJldyBhbiBlcnJvci4gV2VcbiAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcbiAgICAgIC8vIGNhbGxpbmcgdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZXJyb3JzLCBgZGlkRXJyb3JgIHdpbGwgbmV2ZXIgYmVcbiAgICAgIC8vIHNldCB0byBmYWxzZS4gVGhpcyBzdHJhdGVneSB3b3JrcyBldmVuIGlmIHRoZSBicm93c2VyIGlzIGZsYWt5IGFuZFxuICAgICAgLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG4gICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgYXQgYWxsLlxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTtcblxuICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gICAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soKSB7XG4gICAgICAgIC8vIFdlIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBldmVudCBsaXN0ZW5lcnMgc28gdGhhdFxuICAgICAgICAvLyBuZXN0ZWQgYGludm9rZUd1YXJkZWRDYWxsYmFja2AgY2FsbHMgZG8gbm90IGNsYXNoLiBPdGhlcndpc2UsIGFcbiAgICAgICAgLy8gbmVzdGVkIGNhbGwgd291bGQgdHJpZ2dlciB0aGUgZmFrZSBldmVudCBoYW5kbGVycyBvZiBhbnkgY2FsbCBoaWdoZXJcbiAgICAgICAgLy8gaW4gdGhlIHN0YWNrLlxuICAgICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuICAgICAgdmFyIGRpZFNldEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQpIHtcbiAgICAgICAgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgZGlkU2V0RXJyb3IgPSB0cnVlO1xuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwgJiYgZXZlbnQuY29sbm8gPT09IDAgJiYgZXZlbnQubGluZW5vID09PSAwKSB7XG4gICAgICAgICAgaXNDcm9zc09yaWdpbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50IHR5cGUuXG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgKG5hbWUgPyBuYW1lIDogJ2ludm9rZWd1YXJkZWRjYWxsYmFjaycpO1xuXG4gICAgICAvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgIC8vIFN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQuIElmIHRoZSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uXG4gICAgICAvLyBlcnJvcnMsIGl0IHdpbGwgdHJpZ2dlciBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIuXG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICBpZiAoIWRpZFNldEVycm9yKSB7XG4gICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWNyb3Nzb3JpZ2luLWVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSB0cnVlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgb3VyIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgfTtcblxuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGludm9rZUd1YXJkZWRDYWxsYmFja0RldjtcbiAgfVxufVxuXG52YXIgcmV0aHJvd0NhdWdodEVycm9yID0gZnVuY3Rpb24gKCkge1xuICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvciA9IG51bGw7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IgPSBmYWxzZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBldmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFldmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgZXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgcGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gZXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBpZiAocGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAhcGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCBtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIHBsdWdpbnNbcGx1Z2luSW5kZXhdID0gcGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBGYWlsZWQgdG8gcHVibGlzaCBldmVudCBgJXNgIGZvciBwbHVnaW4gYCVzYC4nLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogdm9pZCAwO1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIXJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIHJlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsIHJlZ2lzdHJhdGlvbk5hbWUpIDogdm9pZCAwO1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xuXG4gIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gPSByZWdpc3RyYXRpb25OYW1lO1xuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJykge1xuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xuXG4vKipcbiAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICovXG52YXIgcGx1Z2lucyA9IFtdO1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICovXG52YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAqL1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAqL1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHJlZ2lzdHJhdGlvbiBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbixcbiAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAqIG9ubHkgaW4gdHJ1ZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0ge307XG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgaW4gdHJ1ZVxuXG4vKipcbiAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcbiAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gKlxuICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbk9yZGVyKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAhIWV2ZW50UGx1Z2luT3JkZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LicpIDogdm9pZCAwO1xuICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXG4gIGV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xufVxuXG4vKipcbiAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAqXG4gKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgcGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBwbHVnaW5Nb2R1bGUpIHtcbiAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IHR3byBkaWZmZXJlbnQgZXZlbnQgcGx1Z2lucyB1c2luZyB0aGUgc2FtZSBuYW1lLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgfVxufVxuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IE9iamVjdC5mcmVlemUoe1xuXHRwbHVnaW5zOiBwbHVnaW5zLFxuXHRldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblx0cmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXHRyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuXHRwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOiBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLFxuXHRpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXHRpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxufSk7XG5cbnZhciBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlID0gbnVsbDtcbnZhciBnZXRJbnN0YW5jZUZyb21Ob2RlID0gbnVsbDtcbnZhciBnZXROb2RlRnJvbUluc3RhbmNlID0gbnVsbDtcblxudmFyIGluamVjdGlvbiQyID0ge1xuICBpbmplY3RDb21wb25lbnRUcmVlOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlID0gSW5qZWN0ZWQuZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTtcbiAgICBnZXRJbnN0YW5jZUZyb21Ob2RlID0gSW5qZWN0ZWQuZ2V0SW5zdGFuY2VGcm9tTm9kZTtcbiAgICBnZXROb2RlRnJvbUluc3RhbmNlID0gSW5qZWN0ZWQuZ2V0Tm9kZUZyb21JbnN0YW5jZTtcblxuICAgIHtcbiAgICAgIHdhcm5pbmcoZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG5cblxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG57XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgd2FybmluZyhpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJyk7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSwgbGlzdGVuZXIsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICB9XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG59XG5cbi8qKlxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxuICovXG5cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayBpbnZva2VkIHdpdGggZWFjaCBlbGVtZW50IG9yIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7P30gW3Njb3BlXSBTY29wZSB1c2VkIGFzIGB0aGlzYCBpbiBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQWNjdW11bGF0ZWQoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgICByZXR1cm4gISEocHJvcHMuZGlzYWJsZWQgJiYgaXNJbnRlcmFjdGl2ZSh0eXBlKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBNZXRob2RzIGZvciBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLlxuICovXG52YXIgaW5qZWN0aW9uJDEgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBsaXN0ZW5lcjtcblxuICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuICBpZiAoIXN0YXRlTm9kZSkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcbiAgaWYgKCFwcm9wcykge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudHM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudHM7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gKiBgcHJvY2Vzc0V2ZW50UXVldWVgIGlzIGludm9rZWQuXG4gKlxuICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZUV2ZW50cyhldmVudHMpIHtcbiAgaWYgKGV2ZW50cykge1xuICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NFdmVudFF1ZXVlKHNpbXVsYXRlZCkge1xuICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbiAgaWYgKCFwcm9jZXNzaW5nRXZlbnRRdWV1ZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzaW11bGF0ZWQpIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCk7XG4gIH1cbiAgISFldmVudFF1ZXVlID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nIGFuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG4gIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuICBSZWFjdEVycm9yVXRpbHMucmV0aHJvd0NhdWdodEVycm9yKCk7XG59XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbiQxLFxuXHRnZXRMaXN0ZW5lcjogZ2V0TGlzdGVuZXIsXG5cdGV4dHJhY3RFdmVudHM6IGV4dHJhY3RFdmVudHMsXG5cdGVucXVldWVFdmVudHM6IGVucXVldWVFdmVudHMsXG5cdHByb2Nlc3NFdmVudFF1ZXVlOiBwcm9jZXNzRXZlbnRRdWV1ZVxufSk7XG5cbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gMDsgLy8gQmVmb3JlIHdlIGtub3cgd2hldGhlciBpdCBpcyBmdW5jdGlvbmFsIG9yIGNsYXNzXG52YXIgRnVuY3Rpb25hbENvbXBvbmVudCA9IDE7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAyO1xudmFyIEhvc3RSb290ID0gMzsgLy8gUm9vdCBvZiBhIGhvc3QgdHJlZS4gQ291bGQgYmUgbmVzdGVkIGluc2lkZSBhbm90aGVyIG5vZGUuXG52YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG52YXIgSG9zdENvbXBvbmVudCA9IDU7XG52YXIgSG9zdFRleHQgPSA2O1xudmFyIENhbGxDb21wb25lbnQgPSA3O1xudmFyIENhbGxIYW5kbGVyUGhhc2UgPSA4O1xudmFyIFJldHVybkNvbXBvbmVudCA9IDk7XG52YXIgRnJhZ21lbnQgPSAxMDtcblxudmFyIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkgPSAnX19yZWFjdEV2ZW50SGFuZGxlcnMkJyArIHJhbmRvbUtleTtcblxuZnVuY3Rpb24gcHJlY2FjaGVGaWJlck5vZGUkMShob3N0SW5zdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBpbnN0YW5jZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY2xvc2VzdCA9IHZvaWQgMDtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIsIHRoaXMgd2lsbCBhbHdheXMgYmUgdGhlIGRlZXBlc3Qgcm9vdC5cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICBmb3IgKDsgbm9kZSAmJiAoaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pOyBub2RlID0gcGFyZW50cy5wb3AoKSkge1xuICAgIGNsb3Nlc3QgPSBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdCkge1xuICAgIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UkMShpbnN0KSB7XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbiAgICAvLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbiAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIH1cblxuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gIGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJyk7XG59XG5cbmZ1bmN0aW9uIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShub2RlKSB7XG4gIHJldHVybiBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyQxKG5vZGUsIHByb3BzKSB7XG4gIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSA9IHByb3BzO1xufVxuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHByZWNhY2hlRmliZXJOb2RlOiBwcmVjYWNoZUZpYmVyTm9kZSQxLFxuXHRnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG5cdGdldEluc3RhbmNlRnJvbU5vZGU6IGdldEluc3RhbmNlRnJvbU5vZGUkMSxcblx0Z2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxLFxuXHRnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlOiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEsXG5cdHVwZGF0ZUZpYmVyUHJvcHM6IHVwZGF0ZUZpYmVyUHJvcHMkMVxufSk7XG5cbmZ1bmN0aW9uIGdldFBhcmVudChpbnN0KSB7XG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdFsncmV0dXJuJ107XG4gICAgLy8gVE9ETzogSWYgdGhpcyBpcyBhIEhvc3RSb290IHdlIG1pZ2h0IHdhbnQgdG8gYmFpbCBvdXQuXG4gICAgLy8gVGhhdCBpcyBkZXBlbmRpbmcgb24gaWYgd2Ugd2FudCBuZXN0ZWQgc3VidHJlZXMgKGxheWVycykgdG8gYnViYmxlXG4gICAgLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4gICAgLy8gaG9zdCBub2RlIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBhbmQgZG9lc24ndCBsZXQgdXNcbiAgICAvLyBkbyB0aGUgcG9ydGFsIGZlYXR1cmUuXG4gIH0gd2hpbGUgKGluc3QgJiYgaW5zdC50YWcgIT09IEhvc3RDb21wb25lbnQpO1xuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICB2YXIgZGVwdGhBID0gMDtcbiAgZm9yICh2YXIgdGVtcEEgPSBpbnN0QTsgdGVtcEE7IHRlbXBBID0gZ2V0UGFyZW50KHRlbXBBKSkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSBnZXRQYXJlbnQodGVtcEIpKSB7XG4gICAgZGVwdGhCKys7XG4gIH1cblxuICAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEEgLSBkZXB0aEIgPiAwKSB7XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGRlcHRoQS0tO1xuICB9XG5cbiAgLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0QiB8fCBpbnN0QSA9PT0gaW5zdEIuYWx0ZXJuYXRlKSB7XG4gICAgICByZXR1cm4gaW5zdEE7XG4gICAgfVxuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgdGhlIHBhc3NlZC1pbiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCkge1xuICByZXR1cm4gZ2V0UGFyZW50KGluc3QpO1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBnZXRQYXJlbnQoaW5zdCk7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhbaV0sICdjYXB0dXJlZCcsIGFyZyk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoW2ldLCAnYnViYmxlZCcsIGFyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAqXG4gKiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIG5vdGhpbmdcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuICB2YXIgcGF0aEZyb20gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIWZyb20pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoZnJvbSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZyb20uYWx0ZXJuYXRlO1xuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoRnJvbS5wdXNoKGZyb20pO1xuICAgIGZyb20gPSBnZXRQYXJlbnQoZnJvbSk7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghdG8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodG8gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBfYWx0ZXJuYXRlID0gdG8uYWx0ZXJuYXRlO1xuICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsICYmIF9hbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IGdldFBhcmVudCh0byk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoRnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhGcm9tW2ldLCAnYnViYmxlZCcsIGFyZ0Zyb20pO1xuICB9XG4gIGZvciAodmFyIF9pID0gcGF0aFRvLmxlbmd0aDsgX2ktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFRvW19pXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVuIGFcbiAqIHNpbmdsZSBvbmUuXG4gKi9cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgcGhhc2UsIGV2ZW50KSB7XG4gIHtcbiAgICB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKTtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGV2ZW50Ll90YXJnZXRJbnN0O1xuICAgIHZhciBwYXJlbnRJbnN0ID0gdGFyZ2V0SW5zdCA/IGdldFBhcmVudEluc3RhbmNlKHRhcmdldEluc3QpIDogbnVsbDtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChpbnN0ICYmIGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0bykge1xuICB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IE9iamVjdC5mcmVlemUoe1xuXHRhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuXHRhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXG5cdGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzLFxuXHRhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNcbn0pO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxuLyoqXG4gKiBUaGlzIGhlbHBlciBvYmplY3Qgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICpcbiAqL1xudmFyIGNvbXBvc2l0aW9uU3RhdGUgPSB7XG4gIF9yb290OiBudWxsLFxuICBfc3RhcnRUZXh0OiBudWxsLFxuICBfZmFsbGJhY2tUZXh0OiBudWxsXG59O1xuXG5mdW5jdGlvbiBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0ID0gZ2V0VGV4dCgpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QgPSBudWxsO1xuICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBudWxsO1xuICBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhKCkge1xuICBpZiAoY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0KSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbiAgfVxuXG4gIHZhciBzdGFydDtcbiAgdmFyIHN0YXJ0VmFsdWUgPSBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQ7XG4gIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICB2YXIgZW5kO1xuICB2YXIgZW5kVmFsdWUgPSBnZXRUZXh0KCk7XG4gIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG59XG5cbmZ1bmN0aW9uIGdldFRleHQoKSB7XG4gIGlmICgndmFsdWUnIGluIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QpIHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdC52YWx1ZTtcbiAgfVxuICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xufVxuXG4vKiBlc2xpbnQgdmFsaWQtdHlwZW9mOiAwICovXG5cbnZhciBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IGZhbHNlO1xudmFyIGlzUHJveHlTdXBwb3J0ZWQgPSB0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbic7XG52YXIgRVZFTlRfUE9PTF9TSVpFID0gMTA7XG5cbnZhciBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyA9IFsnZGlzcGF0Y2hDb25maWcnLCAnX3RhcmdldEluc3QnLCAnbmF0aXZlRXZlbnQnLCAnaXNEZWZhdWx0UHJldmVudGVkJywgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJywgJ19kaXNwYXRjaExpc3RlbmVycycsICdfZGlzcGF0Y2hJbnN0YW5jZXMnXTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwsXG4gIGV2ZW50UGhhc2U6IG51bGwsXG4gIGJ1YmJsZXM6IG51bGwsXG4gIGNhbmNlbGFibGU6IG51bGwsXG4gIHRpbWVTdGFtcDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuICB9LFxuICBkZWZhdWx0UHJldmVudGVkOiBudWxsLFxuICBpc1RydXN0ZWQ6IG51bGxcbn07XG5cbi8qKlxuICogU3ludGhldGljIGV2ZW50cyBhcmUgZGlzcGF0Y2hlZCBieSBldmVudCBwbHVnaW5zLCB0eXBpY2FsbHkgaW4gcmVzcG9uc2UgdG8gYVxuICogdG9wLWxldmVsIGV2ZW50IGRlbGVnYXRpb24gaGFuZGxlci5cbiAqXG4gKiBUaGVzZSBzeXN0ZW1zIHNob3VsZCBnZW5lcmFsbHkgdXNlIHBvb2xpbmcgdG8gcmVkdWNlIHRoZSBmcmVxdWVuY3kgb2YgZ2FyYmFnZVxuICogY29sbGVjdGlvbi4gVGhlIHN5c3RlbSBzaG91bGQgY2hlY2sgYGlzUGVyc2lzdGVudGAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlXG4gKiBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgaW50byB0aGUgcG9vbCBhZnRlciBiZWluZyBkaXNwYXRjaGVkLiBVc2VycyB0aGF0XG4gKiBuZWVkIGEgcGVyc2lzdGVkIGV2ZW50IHNob3VsZCBpbnZva2UgYHBlcnNpc3RgLlxuICpcbiAqIFN5bnRoZXRpYyBldmVudHMgKGFuZCBzdWJjbGFzc2VzKSBpbXBsZW1lbnQgdGhlIERPTSBMZXZlbCAzIEV2ZW50cyBBUEkgYnlcbiAqIG5vcm1hbGl6aW5nIGJyb3dzZXIgcXVpcmtzLiBTdWJjbGFzc2VzIGRvIG5vdCBuZWNlc3NhcmlseSBoYXZlIHRvIGltcGxlbWVudCBhXG4gKiBET00gaW50ZXJmYWNlOyBjdXN0b20gYXBwbGljYXRpb24tc3BlY2lmaWMgZXZlbnRzIGNhbiBhbHNvIHN1YmNsYXNzIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHsqfSB0YXJnZXRJbnN0IE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gbmF0aXZlRXZlbnRUYXJnZXQgVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAge1xuICAgIC8vIHRoZXNlIGhhdmUgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIGRlbGV0ZSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGRlbGV0ZSB0aGlzLnByZXZlbnREZWZhdWx0O1xuICAgIGRlbGV0ZSB0aGlzLnN0b3BQcm9wYWdhdGlvbjtcbiAgfVxuXG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5fdGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gIHRoaXMubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcblxuICB2YXIgSW50ZXJmYWNlID0gdGhpcy5jb25zdHJ1Y3Rvci5JbnRlcmZhY2U7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgIGlmICghSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHtcbiAgICAgIGRlbGV0ZSB0aGlzW3Byb3BOYW1lXTsgLy8gdGhpcyBoYXMgYSBnZXR0ZXIvc2V0dGVyIGZvciB3YXJuaW5nc1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG4gIHJldHVybiB0aGlzO1xufVxuXG5fYXNzaWduKFN5bnRoZXRpY0V2ZW50LnByb3RvdHlwZSwge1xuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LnJldHVyblZhbHVlICE9PSAndW5rbm93bicpIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllc1tpXV0gPSBudWxsO1xuICAgIH1cbiAgICB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hdGl2ZUV2ZW50JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignbmF0aXZlRXZlbnQnLCBudWxsKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ByZXZlbnREZWZhdWx0JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbigncHJldmVudERlZmF1bHQnLCBlbXB0eUZ1bmN0aW9uKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0b3BQcm9wYWdhdGlvbicsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3N0b3BQcm9wYWdhdGlvbicsIGVtcHR5RnVuY3Rpb24pKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5TeW50aGV0aWNFdmVudC5JbnRlcmZhY2UgPSBFdmVudEludGVyZmFjZTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gcmVkdWNlIGJvaWxlcnBsYXRlIHdoZW4gY3JlYXRpbmcgc3ViY2xhc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBDbGFzc1xuICogQHBhcmFtIHs/b2JqZWN0fSBJbnRlcmZhY2VcbiAqL1xuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzID0gZnVuY3Rpb24gKENsYXNzLCBJbnRlcmZhY2UpIHtcbiAgdmFyIFN1cGVyID0gdGhpcztcblxuICB2YXIgRSA9IGZ1bmN0aW9uICgpIHt9O1xuICBFLnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcbiAgdmFyIHByb3RvdHlwZSA9IG5ldyBFKCk7XG5cbiAgX2Fzc2lnbihwcm90b3R5cGUsIENsYXNzLnByb3RvdHlwZSk7XG4gIENsYXNzLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2xhc3M7XG5cbiAgQ2xhc3MuSW50ZXJmYWNlID0gX2Fzc2lnbih7fSwgU3VwZXIuSW50ZXJmYWNlLCBJbnRlcmZhY2UpO1xuICBDbGFzcy5hdWdtZW50Q2xhc3MgPSBTdXBlci5hdWdtZW50Q2xhc3M7XG4gIGFkZEV2ZW50UG9vbGluZ1RvKENsYXNzKTtcbn07XG5cbi8qKiBQcm94eWluZyBhZnRlciBldmVyeXRoaW5nIHNldCBvbiBTeW50aGV0aWNFdmVudFxuICogdG8gcmVzb2x2ZSBQcm94eSBpc3N1ZSBvbiBzb21lIFdlYktpdCBicm93c2Vyc1xuICogaW4gd2hpY2ggc29tZSBFdmVudCBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gdW5kZWZpbmVkIChHSCMxMDAxMClcbiAqL1xue1xuICBpZiAoaXNQcm94eVN1cHBvcnRlZCkge1xuICAgIC8qZXNsaW50LWRpc2FibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgICBTeW50aGV0aWNFdmVudCA9IG5ldyBQcm94eShTeW50aGV0aWNFdmVudCwge1xuICAgICAgY29uc3RydWN0OiBmdW5jdGlvbiAodGFyZ2V0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGx5KHRhcmdldCwgT2JqZWN0LmNyZWF0ZSh0YXJnZXQucHJvdG90eXBlKSwgYXJncyk7XG4gICAgICB9LFxuICAgICAgYXBwbHk6IGZ1bmN0aW9uIChjb25zdHJ1Y3RvciwgdGhhdCwgYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3h5KGNvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3MpLCB7XG4gICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHByb3AgIT09ICdpc1BlcnNpc3RlbnQnICYmICF0YXJnZXQuY29uc3RydWN0b3IuSW50ZXJmYWNlLmhhc093blByb3BlcnR5KHByb3ApICYmIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgfHwgdGFyZ2V0LmlzUGVyc2lzdGVudCgpLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIFwiICsgXCJzZWVpbmcgdGhpcywgeW91J3JlIGFkZGluZyBhIG5ldyBwcm9wZXJ0eSBpbiB0aGUgc3ludGhldGljIGV2ZW50IG9iamVjdC4gXCIgKyAnVGhlIHByb3BlcnR5IGlzIG5ldmVyIHJlbGVhc2VkLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgICAgICAgIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmdldFtwcm9wXSA9IHZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvKmVzbGludC1lbmFibGUgbm8tZnVuYy1hc3NpZ24gKi9cbiAgfVxufVxuXG5hZGRFdmVudFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCk7XG5cbi8qKlxuICogSGVscGVyIHRvIG51bGxpZnkgc3ludGhldGljRXZlbnQgaW5zdGFuY2UgcHJvcGVydGllcyB3aGVuIGRlc3RydWN0aW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByb3BOYW1lXG4gKiBAcGFyYW0gez9vYmplY3R9IGdldFZhbFxuICogQHJldHVybiB7b2JqZWN0fSBkZWZpbmVQcm9wZXJ0eSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbihwcm9wTmFtZSwgZ2V0VmFsKSB7XG4gIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIGdldFZhbCA9PT0gJ2Z1bmN0aW9uJztcbiAgcmV0dXJuIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgc2V0OiBzZXQsXG4gICAgZ2V0OiBnZXRcbiAgfTtcblxuICBmdW5jdGlvbiBzZXQodmFsKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnc2V0dGluZyB0aGUgbWV0aG9kJyA6ICdzZXR0aW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgd2FybihhY3Rpb24sICdUaGlzIGlzIGVmZmVjdGl2ZWx5IGEgbm8tb3AnKTtcbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0KCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ2FjY2Vzc2luZyB0aGUgbWV0aG9kJyA6ICdhY2Nlc3NpbmcgdGhlIHByb3BlcnR5JztcbiAgICB2YXIgcmVzdWx0ID0gaXNGdW5jdGlvbiA/ICdUaGlzIGlzIGEgbm8tb3AgZnVuY3Rpb24nIDogJ1RoaXMgaXMgc2V0IHRvIG51bGwnO1xuICAgIHdhcm4oYWN0aW9uLCByZXN1bHQpO1xuICAgIHJldHVybiBnZXRWYWw7XG4gIH1cblxuICBmdW5jdGlvbiB3YXJuKGFjdGlvbiwgcmVzdWx0KSB7XG4gICAgdmFyIHdhcm5pbmdDb25kaXRpb24gPSBmYWxzZTtcbiAgICB3YXJuaW5nKHdhcm5pbmdDb25kaXRpb24sIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIFwiICsgXCJ5b3UncmUgJXMgYCVzYCBvbiBhIHJlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuICVzLiBcIiArICdJZiB5b3UgbXVzdCBrZWVwIHRoZSBvcmlnaW5hbCBzeW50aGV0aWMgZXZlbnQgYXJvdW5kLCB1c2UgZXZlbnQucGVyc2lzdCgpLiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJywgYWN0aW9uLCBwcm9wTmFtZSwgcmVzdWx0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQb29sZWRFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucG9wKCk7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5jYWxsKGluc3RhbmNlLCBkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4gbmV3IEV2ZW50Q29uc3RydWN0b3IoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVBvb2xlZEV2ZW50KGV2ZW50KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgIShldmVudCBpbnN0YW5jZW9mIEV2ZW50Q29uc3RydWN0b3IpID8gaW52YXJpYW50KGZhbHNlLCAnVHJ5aW5nIHRvIHJlbGVhc2UgYW4gZXZlbnQgaW5zdGFuY2UgIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiB2b2lkIDA7XG4gIGV2ZW50LmRlc3RydWN0b3IoKTtcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCA8IEVWRU5UX1BPT0xfU0laRSkge1xuICAgIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnB1c2goZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50UG9vbGluZ1RvKEV2ZW50Q29uc3RydWN0b3IpIHtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wgPSBbXTtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQgPSBnZXRQb29sZWRFdmVudDtcbiAgRXZlbnRDb25zdHJ1Y3Rvci5yZWxlYXNlID0gcmVsZWFzZVBvb2xlZEV2ZW50O1xufVxuXG52YXIgU3ludGhldGljRXZlbnQkMSA9IFN5bnRoZXRpY0V2ZW50O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudHMtY29tcG9zaXRpb25ldmVudHNcbiAqL1xudmFyIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LCBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1XG4gKiAgICAgIC8jZXZlbnRzLWlucHV0ZXZlbnRzXG4gKi9cbnZhciBJbnB1dEV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljSW5wdXRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljSW5wdXRFdmVudCwgSW5wdXRFdmVudEludGVyZmFjZSk7XG5cbnZhciBFTkRfS0VZQ09ERVMgPSBbOSwgMTMsIDI3LCAzMl07IC8vIFRhYiwgUmV0dXJuLCBFc2MsIFNwYWNlXG52YXIgU1RBUlRfS0VZQ09ERSA9IDIyOTtcblxudmFyIGNhblVzZUNvbXBvc2l0aW9uRXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ0NvbXBvc2l0aW9uRXZlbnQnIGluIHdpbmRvdztcblxudmFyIGRvY3VtZW50TW9kZSA9IG51bGw7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB7XG4gIGRvY3VtZW50TW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbn1cblxuLy8gV2Via2l0IG9mZmVycyBhIHZlcnkgdXNlZnVsIGB0ZXh0SW5wdXRgIGV2ZW50IHRoYXQgY2FuIGJlIHVzZWQgdG9cbi8vIGRpcmVjdGx5IHJlcHJlc2VudCBgYmVmb3JlSW5wdXRgLiBUaGUgSUUgYHRleHRpbnB1dGAgZXZlbnQgaXMgbm90IGFzXG4vLyB1c2VmdWwsIHNvIHdlIGRvbid0IHVzZSBpdC5cbnZhciBjYW5Vc2VUZXh0SW5wdXRFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnVGV4dEV2ZW50JyBpbiB3aW5kb3cgJiYgIWRvY3VtZW50TW9kZSAmJiAhaXNQcmVzdG8oKTtcblxuLy8gSW4gSUU5Kywgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zaXRpb24gZXZlbnRzLCBidXQgdGhlIGRhdGEgc3VwcGxpZWRcbi8vIGJ5IHRoZSBuYXRpdmUgY29tcG9zaXRpb25lbmQgZXZlbnQgbWF5IGJlIGluY29ycmVjdC4gSmFwYW5lc2UgaWRlb2dyYXBoaWNcbi8vIHNwYWNlcywgZm9yIGluc3RhbmNlIChcXHUzMDAwKSBhcmUgbm90IHJlY29yZGVkIGNvcnJlY3RseS5cbnZhciB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAoIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgfHwgZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50TW9kZSA+IDggJiYgZG9jdW1lbnRNb2RlIDw9IDExKTtcblxuLyoqXG4gKiBPcGVyYSA8PSAxMiBpbmNsdWRlcyBUZXh0RXZlbnQgaW4gd2luZG93LCBidXQgZG9lcyBub3QgZmlyZVxuICogdGV4dCBpbnB1dCBldmVudHMuIFJlbHkgb24ga2V5cHJlc3MgaW5zdGVhZC5cbiAqL1xuZnVuY3Rpb24gaXNQcmVzdG8oKSB7XG4gIHZhciBvcGVyYSA9IHdpbmRvdy5vcGVyYTtcbiAgcmV0dXJuIHR5cGVvZiBvcGVyYSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9wZXJhLnZlcnNpb24gPT09ICdmdW5jdGlvbicgJiYgcGFyc2VJbnQob3BlcmEudmVyc2lvbigpLCAxMCkgPD0gMTI7XG59XG5cbnZhciBTUEFDRUJBUl9DT0RFID0gMzI7XG52YXIgU1BBQ0VCQVJfQ0hBUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoU1BBQ0VCQVJfQ09ERSk7XG5cbi8vIEV2ZW50cyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBwcm9wZXJ0eSBuYW1lcy5cbnZhciBldmVudFR5cGVzID0ge1xuICBiZWZvcmVJbnB1dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25CZWZvcmVJbnB1dCcsXG4gICAgICBjYXB0dXJlZDogJ29uQmVmb3JlSW5wdXRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleVByZXNzJywgJ3RvcFRleHRJbnB1dCcsICd0b3BQYXN0ZSddXG4gIH0sXG4gIGNvbXBvc2l0aW9uRW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uRW5kJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvbkVuZENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25TdGFydCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25TdGFydENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblN0YXJ0JywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25VcGRhdGU6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25VcGRhdGUnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfVxufTtcblxuLy8gVHJhY2sgd2hldGhlciB3ZSd2ZSBldmVyIGhhbmRsZWQgYSBrZXlwcmVzcyBvbiB0aGUgc3BhY2Uga2V5LlxudmFyIGhhc1NwYWNlS2V5cHJlc3MgPSBmYWxzZTtcblxuLyoqXG4gKiBSZXR1cm4gd2hldGhlciBhIG5hdGl2ZSBrZXlwcmVzcyBldmVudCBpcyBhc3N1bWVkIHRvIGJlIGEgY29tbWFuZC5cbiAqIFRoaXMgaXMgcmVxdWlyZWQgYmVjYXVzZSBGaXJlZm94IGZpcmVzIGBrZXlwcmVzc2AgZXZlbnRzIGZvciBrZXkgY29tbWFuZHNcbiAqIChjdXQsIGNvcHksIHNlbGVjdC1hbGwsIGV0Yy4pIGV2ZW4gdGhvdWdoIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZC5cbiAqL1xuZnVuY3Rpb24gaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIChuYXRpdmVFdmVudC5jdHJsS2V5IHx8IG5hdGl2ZUV2ZW50LmFsdEtleSB8fCBuYXRpdmVFdmVudC5tZXRhS2V5KSAmJlxuICAvLyBjdHJsS2V5ICYmIGFsdEtleSBpcyBlcXVpdmFsZW50IHRvIEFsdEdyLCBhbmQgaXMgbm90IGEgY29tbWFuZC5cbiAgIShuYXRpdmVFdmVudC5jdHJsS2V5ICYmIG5hdGl2ZUV2ZW50LmFsdEtleSk7XG59XG5cbi8qKlxuICogVHJhbnNsYXRlIG5hdGl2ZSB0b3AgbGV2ZWwgZXZlbnRzIGludG8gZXZlbnQgdHlwZXMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblN0YXJ0JzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25VcGRhdGUnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25VcGRhdGU7XG4gIH1cbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBiZXN0LWd1ZXNzIG1vZGVsIHRoaW5rIHRoaXMgZXZlbnQgc2lnbmlmaWVzIHRoYXRcbiAqIGNvbXBvc2l0aW9uIGhhcyBiZWd1bj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nICYmIG5hdGl2ZUV2ZW50LmtleUNvZGUgPT09IFNUQVJUX0tFWUNPREU7XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgbW9kZSB0aGluayB0aGF0IHRoaXMgZXZlbnQgaXMgdGhlIGVuZCBvZiBjb21wb3NpdGlvbj9cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgLy8gQ29tbWFuZCBrZXlzIGluc2VydCBvciBjbGVhciBJTUUgaW5wdXQuXG4gICAgICByZXR1cm4gRU5EX0tFWUNPREVTLmluZGV4T2YobmF0aXZlRXZlbnQua2V5Q29kZSkgIT09IC0xO1xuICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgLy8gRXhwZWN0IElNRSBrZXlDb2RlIG9uIGVhY2gga2V5ZG93bi4gSWYgd2UgZ2V0IGFueSBvdGhlclxuICAgICAgLy8gY29kZSB3ZSBtdXN0IGhhdmUgZXhpdGVkIGVhcmxpZXIuXG4gICAgICByZXR1cm4gbmF0aXZlRXZlbnQua2V5Q29kZSAhPT0gU1RBUlRfS0VZQ09ERTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIC8vIEV2ZW50cyBhcmUgbm90IHBvc3NpYmxlIHdpdGhvdXQgY2FuY2VsbGluZyBJTUUuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogR29vZ2xlIElucHV0IFRvb2xzIHByb3ZpZGVzIGNvbXBvc2l0aW9uIGRhdGEgdmlhIGEgQ3VzdG9tRXZlbnQsXG4gKiB3aXRoIHRoZSBgZGF0YWAgcHJvcGVydHkgcG9wdWxhdGVkIGluIHRoZSBgZGV0YWlsYCBvYmplY3QuIElmIHRoaXNcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgZXZlbnQgb2JqZWN0LCB1c2UgaXQuIElmIG5vdCwgdGhpcyBpcyBhIHBsYWluXG4gKiBjb21wb3NpdGlvbiBldmVudCBhbmQgd2UgaGF2ZSBub3RoaW5nIHNwZWNpYWwgdG8gZXh0cmFjdC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGRldGFpbCA9IG5hdGl2ZUV2ZW50LmRldGFpbDtcbiAgaWYgKHR5cGVvZiBkZXRhaWwgPT09ICdvYmplY3QnICYmICdkYXRhJyBpbiBkZXRhaWwpIHtcbiAgICByZXR1cm4gZGV0YWlsLmRhdGE7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIFRyYWNrIHRoZSBjdXJyZW50IElNRSBjb21wb3NpdGlvbiBzdGF0dXMsIGlmIGFueS5cbnZhciBpc0NvbXBvc2luZyA9IGZhbHNlO1xuXG4vKipcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQ7XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQ7XG4gIH1cblxuICBpZiAoIWV2ZW50VHlwZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQgY29tcG9zaXRpb24gaXMgc3RvcmVkIHN0YXRpY2FsbHkgYW5kIG11c3Qgbm90IGJlXG4gICAgLy8gb3ZlcndyaXR0ZW4gd2hpbGUgY29tcG9zaXRpb24gY29udGludWVzLlxuICAgIGlmICghaXNDb21wb3NpbmcgJiYgZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uU3RhcnQpIHtcbiAgICAgIGlzQ29tcG9zaW5nID0gaW5pdGlhbGl6ZShuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChpc0NvbXBvc2luZykge1xuICAgICAgICBmYWxsYmFja0RhdGEgPSBnZXREYXRhKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGlmIChmYWxsYmFja0RhdGEpIHtcbiAgICAvLyBJbmplY3QgZGF0YSBnZW5lcmF0ZWQgZnJvbSBmYWxsYmFjayBwYXRoIGludG8gdGhlIHN5bnRoZXRpYyBldmVudC5cbiAgICAvLyBUaGlzIG1hdGNoZXMgdGhlIHByb3BlcnR5IG9mIG5hdGl2ZSBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlLlxuICAgIGV2ZW50LmRhdGEgPSBmYWxsYmFja0RhdGE7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1c3RvbURhdGEgPSBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBpZiAoY3VzdG9tRGF0YSAhPT0gbnVsbCkge1xuICAgICAgZXZlbnQuZGF0YSA9IGN1c3RvbURhdGE7XG4gICAgfVxuICB9XG5cbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RvcExldmVsVHlwZXN9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBzdHJpbmcgY29ycmVzcG9uZGluZyB0byB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIElmIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudHMgYXJlIGF2YWlsYWJsZSwgb3VyIGdvYWwgaXMgdG8gbWFrZVxuICAgICAgICogdXNlIG9mIHRoZW0uIEhvd2V2ZXIsIHRoZXJlIGlzIGEgc3BlY2lhbCBjYXNlOiB0aGUgc3BhY2ViYXIga2V5LlxuICAgICAgICogSW4gV2Via2l0LCBwcmV2ZW50aW5nIGRlZmF1bHQgb24gYSBzcGFjZWJhciBgdGV4dElucHV0YCBldmVudFxuICAgICAgICogY2FuY2VscyBjaGFyYWN0ZXIgaW5zZXJ0aW9uLCBidXQgaXQgKmFsc28qIGNhdXNlcyB0aGUgYnJvd3NlclxuICAgICAgICogdG8gZmFsbCBiYWNrIHRvIGl0cyBkZWZhdWx0IHNwYWNlYmFyIGJlaGF2aW9yIG9mIHNjcm9sbGluZyB0aGVcbiAgICAgICAqIHBhZ2UuXG4gICAgICAgKlxuICAgICAgICogVHJhY2tpbmcgYXQ6XG4gICAgICAgKiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MzU1MTAzXG4gICAgICAgKlxuICAgICAgICogVG8gYXZvaWQgdGhpcyBpc3N1ZSwgdXNlIHRoZSBrZXlwcmVzcyBldmVudCBhcyBpZiBubyBgdGV4dElucHV0YFxuICAgICAgICogZXZlbnQgaXMgYXZhaWxhYmxlLlxuICAgICAgICovXG4gICAgICB2YXIgd2hpY2ggPSBuYXRpdmVFdmVudC53aGljaDtcbiAgICAgIGlmICh3aGljaCAhPT0gU1BBQ0VCQVJfQ09ERSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaGFzU3BhY2VLZXlwcmVzcyA9IHRydWU7XG4gICAgICByZXR1cm4gU1BBQ0VCQVJfQ0hBUjtcblxuICAgIGNhc2UgJ3RvcFRleHRJbnB1dCc6XG4gICAgICAvLyBSZWNvcmQgdGhlIGNoYXJhY3RlcnMgdG8gYmUgYWRkZWQgdG8gdGhlIERPTS5cbiAgICAgIHZhciBjaGFycyA9IG5hdGl2ZUV2ZW50LmRhdGE7XG5cbiAgICAgIC8vIElmIGl0J3MgYSBzcGFjZWJhciBjaGFyYWN0ZXIsIGFzc3VtZSB0aGF0IHdlIGhhdmUgYWxyZWFkeSBoYW5kbGVkXG4gICAgICAvLyBpdCBhdCB0aGUga2V5cHJlc3MgbGV2ZWwgYW5kIGJhaWwgaW1tZWRpYXRlbHkuIEFuZHJvaWQgQ2hyb21lXG4gICAgICAvLyBkb2Vzbid0IGdpdmUgdXMga2V5Y29kZXMsIHNvIHdlIG5lZWQgdG8gYmxhY2tsaXN0IGl0LlxuICAgICAgaWYgKGNoYXJzID09PSBTUEFDRUJBUl9DSEFSICYmIGhhc1NwYWNlS2V5cHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjaGFycztcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBGb3Igb3RoZXIgbmF0aXZlIGV2ZW50IHR5cGVzLCBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3IgYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvdmlkZSB0aGUgYHRleHRJbnB1dGAgZXZlbnQsIGV4dHJhY3QgdGhlXG4gKiBhcHByb3ByaWF0ZSBzdHJpbmcgdG8gdXNlIGZvciBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgZmFsbGJhY2sgc3RyaW5nIGZvciB0aGlzIGBiZWZvcmVJbnB1dGAgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgY29tcG9zaW5nIChJTUUpIGFuZCB1c2luZyBhIGZhbGxiYWNrIHRvIGRvIHNvLFxuICAvLyB0cnkgdG8gZXh0cmFjdCB0aGUgY29tcG9zZWQgY2hhcmFjdGVycyBmcm9tIHRoZSBmYWxsYmFjayBvYmplY3QuXG4gIC8vIElmIGNvbXBvc2l0aW9uIGV2ZW50IGlzIGF2YWlsYWJsZSwgd2UgZXh0cmFjdCBhIHN0cmluZyBvbmx5IGF0XG4gIC8vIGNvbXBvc2l0aW9uZXZlbnQsIG90aGVyd2lzZSBleHRyYWN0IGl0IGF0IGZhbGxiYWNrIGV2ZW50cy5cbiAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENvbXBvc2l0aW9uRW5kJyB8fCAhY2FuVXNlQ29tcG9zaXRpb25FdmVudCAmJiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGdldERhdGEoKTtcbiAgICAgIHJlc2V0KCk7XG4gICAgICBpc0NvbXBvc2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNoYXJzO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgLy8gSWYgYSBwYXN0ZSBldmVudCBvY2N1cnMgYWZ0ZXIgYSBrZXlwcmVzcywgdGhyb3cgb3V0IHRoZSBpbnB1dFxuICAgICAgLy8gY2hhcnMuIFBhc3RlIGV2ZW50cyBzaG91bGQgbm90IGxlYWQgdG8gQmVmb3JlSW5wdXQgZXZlbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBBcyBvZiB2MjcsIEZpcmVmb3ggbWF5IGZpcmUga2V5cHJlc3MgZXZlbnRzIGV2ZW4gd2hlbiBubyBjaGFyYWN0ZXJcbiAgICAgICAqIHdpbGwgYmUgaW5zZXJ0ZWQuIEEgZmV3IHBvc3NpYmlsaXRpZXM6XG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIGAwYC4gQXJyb3cga2V5cywgRXNjIGtleSwgZXRjLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IG5vIGNoYXIgaXMgYXZhaWxhYmxlLlxuICAgICAgICogICBFeDogJ0FsdEdyICsgZGAgaW4gUG9saXNoLiBUaGVyZSBpcyBubyBtb2RpZmllZCBjaGFyYWN0ZXIgZm9yXG4gICAgICAgKiAgIHRoaXMga2V5IGNvbWJpbmF0aW9uIGFuZCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQgaW50byB0aGVcbiAgICAgICAqICAgZG9jdW1lbnQsIGJ1dCBGRiBmaXJlcyB0aGUga2V5cHJlc3MgZm9yIGNoYXIgY29kZSBgMTAwYCBhbnl3YXkuXG4gICAgICAgKiAgIE5vIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBhIGNvbW1hbmQgY29tYmluYXRpb24gaXNcbiAgICAgICAqICAgYmVpbmcgdXNlZC4gRXg6IGBDbWQrQ2AuIE5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCwgYW5kIG5vXG4gICAgICAgKiAgIGBpbnB1dGAgZXZlbnQgd2lsbCBvY2N1ci5cbiAgICAgICAqL1xuICAgICAgaWYgKCFpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkpIHtcbiAgICAgICAgLy8gSUUgZmlyZXMgdGhlIGBrZXlwcmVzc2AgZXZlbnQgd2hlbiBhIHVzZXIgdHlwZXMgYW4gZW1vamkgdmlhXG4gICAgICAgIC8vIFRvdWNoIGtleWJvYXJkIG9mIFdpbmRvd3MuICBJbiBzdWNoIGEgY2FzZSwgdGhlIGBjaGFyYCBwcm9wZXJ0eVxuICAgICAgICAvLyBob2xkcyBhbiBlbW9qaSBjaGFyYWN0ZXIgbGlrZSBgXFx1RDgzRFxcdURFMEFgLiAgQmVjYXVzZSBpdHMgbGVuZ3RoXG4gICAgICAgIC8vIGlzIDIsIHRoZSBwcm9wZXJ0eSBgd2hpY2hgIGRvZXMgbm90IHJlcHJlc2VudCBhbiBlbW9qaSBjb3JyZWN0bHkuXG4gICAgICAgIC8vIEluIHN1Y2ggYSBjYXNlLCB3ZSBkaXJlY3RseSByZXR1cm4gdGhlIGBjaGFyYCBwcm9wZXJ0eSBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHVzaW5nIGB3aGljaGAuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5jaGFyICYmIG5hdGl2ZUV2ZW50LmNoYXIubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHJldHVybiBuYXRpdmVFdmVudC5jaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKG5hdGl2ZUV2ZW50LndoaWNoKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUobmF0aXZlRXZlbnQud2hpY2gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPyBudWxsIDogbmF0aXZlRXZlbnQuZGF0YTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHRyYWN0IGEgU3ludGhldGljSW5wdXRFdmVudCBmb3IgYGJlZm9yZUlucHV0YCwgYmFzZWQgb24gZWl0aGVyIG5hdGl2ZVxuICogYHRleHRJbnB1dGAgb3IgZmFsbGJhY2sgYmVoYXZpb3IuXG4gKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgY2hhcnM7XG5cbiAgaWYgKGNhblVzZVRleHRJbnB1dEV2ZW50KSB7XG4gICAgY2hhcnMgPSBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNoYXJzID0gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpO1xuICB9XG5cbiAgLy8gSWYgbm8gY2hhcmFjdGVycyBhcmUgYmVpbmcgaW5zZXJ0ZWQsIG5vIEJlZm9yZUlucHV0IGV2ZW50IHNob3VsZFxuICAvLyBiZSBmaXJlZC5cbiAgaWYgKCFjaGFycykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGV2ZW50ID0gU3ludGhldGljSW5wdXRFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5iZWZvcmVJbnB1dCwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBldmVudC5kYXRhID0gY2hhcnM7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCksIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KV07XG4gIH1cbn07XG5cbi8vIFVzZSB0byByZXN0b3JlIGNvbnRyb2xsZWQgc3RhdGUgYWZ0ZXIgYSBjaGFuZ2UgZXZlbnQgaGFzIGZpcmVkLlxuXG52YXIgZmliZXJIb3N0Q29tcG9uZW50ID0gbnVsbDtcblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudDogZnVuY3Rpb24gKGhvc3RDb21wb25lbnRJbXBsKSB7XG4gICAgLy8gVGhlIGZpYmVyIGltcGxlbWVudGF0aW9uIGRvZXNuJ3QgdXNlIGR5bmFtaWMgZGlzcGF0Y2ggc28gd2UgbmVlZCB0b1xuICAgIC8vIGluamVjdCB0aGUgaW1wbGVtZW50YXRpb24uXG4gICAgZmliZXJIb3N0Q29tcG9uZW50ID0gaG9zdENvbXBvbmVudEltcGw7XG4gIH1cbn07XG5cbnZhciByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbnZhciByZXN0b3JlUXVldWUgPSBudWxsO1xuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpIHtcbiAgLy8gV2UgcGVyZm9ybSB0aGlzIHRyYW5zbGF0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGV2ZW50IGxvb3Agc28gdGhhdCB3ZVxuICAvLyBhbHdheXMgcmVjZWl2ZSB0aGUgY29ycmVjdCBmaWJlciBoZXJlXG4gIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW5zdGFuY2VGcm9tTm9kZSh0YXJnZXQpO1xuICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAvLyBVbm1vdW50ZWRcbiAgICByZXR1cm47XG4gIH1cbiAgIShmaWJlckhvc3RDb21wb25lbnQgJiYgdHlwZW9mIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ZpYmVyIG5lZWRzIHRvIGJlIGluamVjdGVkIHRvIGhhbmRsZSBhIGZpYmVyIHRhcmdldCBmb3IgY29udHJvbGxlZCBldmVudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUpO1xuICBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSwgaW50ZXJuYWxJbnN0YW5jZS50eXBlLCBwcm9wcyk7XG59XG5cbnZhciBpbmplY3Rpb24kMyA9IFJlYWN0Q29udHJvbGxlZENvbXBvbmVudEluamVjdGlvbjtcblxuZnVuY3Rpb24gZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpIHtcbiAgaWYgKHJlc3RvcmVUYXJnZXQpIHtcbiAgICBpZiAocmVzdG9yZVF1ZXVlKSB7XG4gICAgICByZXN0b3JlUXVldWUucHVzaCh0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN0b3JlUXVldWUgPSBbdGFyZ2V0XTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmVzdG9yZVRhcmdldCA9IHRhcmdldDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlU3RhdGVJZk5lZWRlZCgpIHtcbiAgaWYgKCFyZXN0b3JlVGFyZ2V0KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB0YXJnZXQgPSByZXN0b3JlVGFyZ2V0O1xuICB2YXIgcXVldWVkVGFyZ2V0cyA9IHJlc3RvcmVRdWV1ZTtcbiAgcmVzdG9yZVRhcmdldCA9IG51bGw7XG4gIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbiAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KTtcbiAgaWYgKHF1ZXVlZFRhcmdldHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlZFRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHF1ZXVlZFRhcmdldHNbaV0pO1xuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDMsXG5cdGVucXVldWVTdGF0ZVJlc3RvcmU6IGVucXVldWVTdGF0ZVJlc3RvcmUsXG5cdHJlc3RvcmVTdGF0ZUlmTmVlZGVkOiByZXN0b3JlU3RhdGVJZk5lZWRlZFxufSk7XG5cbi8vIFVzZWQgYXMgYSB3YXkgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcyB3aGVuIHdlIGRvbid0IGhhdmUgYSByZWZlcmVuY2UgdG9cbi8vIHRoZSByZW5kZXJlci4gU3VjaCBhcyB3aGVuIHdlJ3JlIGRpc3BhdGNoaW5nIGV2ZW50cyBvciBpZiB0aGlyZCBwYXJ0eVxuLy8gbGlicmFyaWVzIG5lZWQgdG8gY2FsbCBiYXRjaGVkVXBkYXRlcy4gRXZlbnR1YWxseSwgdGhpcyBBUEkgd2lsbCBnbyBhd2F5IHdoZW5cbi8vIGV2ZXJ5dGhpbmcgaXMgYmF0Y2hlZCBieSBkZWZhdWx0LiBXZSdsbCB0aGVuIGhhdmUgYSBzaW1pbGFyIEFQSSB0byBvcHQtb3V0IG9mXG4vLyBzY2hlZHVsZWQgd29yayBhbmQgaW5zdGVhZCBkbyBzeW5jaHJvbm91cyB3b3JrLlxuXG4vLyBEZWZhdWx0c1xudmFyIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoZm4sIGJvb2trZWVwaW5nKSB7XG4gIHJldHVybiBmbihib29ra2VlcGluZyk7XG59O1xuXG52YXIgaXNOZXN0aW5nQmF0Y2hlZCA9IGZhbHNlO1xuZnVuY3Rpb24gYmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKSB7XG4gIGlmIChpc05lc3RpbmdCYXRjaGVkKSB7XG4gICAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBpbnNpZGUgYW5vdGhlciBiYXRjaCwgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0XG4gICAgLy8gZnVsbHkgY29tcGxldGVzIGJlZm9yZSByZXN0b3Jpbmcgc3RhdGUuIFRoZXJlZm9yZSwgd2UgYWRkIHRoZSB0YXJnZXQgdG9cbiAgICAvLyBhIHF1ZXVlIG9mIHdvcmsuXG4gICAgcmV0dXJuIGZpYmVyQmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfVxuICBpc05lc3RpbmdCYXRjaGVkID0gdHJ1ZTtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZmliZXJCYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIC8vIEhlcmUgd2Ugd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoIGlzIGltcG9ydGFudFxuICAgIC8vIHdoZW4gdXNpbmcgY29udHJvbGxlZCBjb21wb25lbnRzIHdpdGhpbiBsYXllcnM6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNjk4XG4gICAgLy8gVGhlbiB3ZSByZXN0b3JlIHN0YXRlIG9mIGFueSBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAgICBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG4gICAgcmVzdG9yZVN0YXRlSWZOZWVkZWQoKTtcbiAgfVxufVxuXG52YXIgUmVhY3RHZW5lcmljQmF0Y2hpbmdJbmplY3Rpb24gPSB7XG4gIGluamVjdEZpYmVyQmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChfYmF0Y2hlZFVwZGF0ZXMpIHtcbiAgICBmaWJlckJhdGNoZWRVcGRhdGVzID0gX2JhdGNoZWRVcGRhdGVzO1xuICB9XG59O1xuXG52YXIgaW5qZWN0aW9uJDQgPSBSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbjtcblxuLyoqXG4gKiBAc2VlIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL3RoZS1pbnB1dC1lbGVtZW50Lmh0bWwjaW5wdXQtdHlwZS1hdHRyLXN1bW1hcnlcbiAqL1xudmFyIHN1cHBvcnRlZElucHV0VHlwZXMgPSB7XG4gIGNvbG9yOiB0cnVlLFxuICBkYXRlOiB0cnVlLFxuICBkYXRldGltZTogdHJ1ZSxcbiAgJ2RhdGV0aW1lLWxvY2FsJzogdHJ1ZSxcbiAgZW1haWw6IHRydWUsXG4gIG1vbnRoOiB0cnVlLFxuICBudW1iZXI6IHRydWUsXG4gIHBhc3N3b3JkOiB0cnVlLFxuICByYW5nZTogdHJ1ZSxcbiAgc2VhcmNoOiB0cnVlLFxuICB0ZWw6IHRydWUsXG4gIHRleHQ6IHRydWUsXG4gIHRpbWU6IHRydWUsXG4gIHVybDogdHJ1ZSxcbiAgd2VlazogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdpbnB1dCcpIHtcbiAgICByZXR1cm4gISFzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV07XG4gIH1cblxuICBpZiAobm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBIVE1MIG5vZGVUeXBlIHZhbHVlcyB0aGF0IHJlcHJlc2VudCB0aGUgdHlwZSBvZiB0aGUgbm9kZVxuICovXG5cbnZhciBFTEVNRU5UX05PREUgPSAxO1xudmFyIFRFWFRfTk9ERSA9IDM7XG52YXIgQ09NTUVOVF9OT0RFID0gODtcbnZhciBET0NVTUVOVF9OT0RFID0gOTtcbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFID0gMTE7XG5cbi8qKlxuICogR2V0cyB0aGUgdGFyZ2V0IG5vZGUgZnJvbSBhIG5hdGl2ZSBicm93c2VyIGV2ZW50IGJ5IGFjY291bnRpbmcgZm9yXG4gKiBpbmNvbnNpc3RlbmNpZXMgaW4gYnJvd3NlciBET00gQVBJcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtET01FdmVudFRhcmdldH0gVGFyZ2V0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciB0YXJnZXQgPSBuYXRpdmVFdmVudC50YXJnZXQgfHwgbmF0aXZlRXZlbnQuc3JjRWxlbWVudCB8fCB3aW5kb3c7XG5cbiAgLy8gTm9ybWFsaXplIFNWRyA8dXNlPiBlbGVtZW50IGV2ZW50cyAjNDk2M1xuICBpZiAodGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KSB7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0LmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50O1xuICB9XG5cbiAgLy8gU2FmYXJpIG1heSBmaXJlIGV2ZW50cyBvbiB0ZXh0IG5vZGVzIChOb2RlLlRFWFRfTk9ERSBpcyAzKS5cbiAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2pzL2V2ZW50c19wcm9wZXJ0aWVzLmh0bWxcbiAgcmV0dXJuIHRhcmdldC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbnZhciB1c2VIYXNGZWF0dXJlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICB1c2VIYXNGZWF0dXJlID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24gJiYgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSAmJlxuICAvLyBhbHdheXMgcmV0dXJucyB0cnVlIGluIG5ld2VyIGJyb3dzZXJzIGFzIHBlciB0aGUgc3RhbmRhcmQuXG4gIC8vIEBzZWUgaHR0cDovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2RvbS1kb21pbXBsZW1lbnRhdGlvbi1oYXNmZWF0dXJlXG4gIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJycsICcnKSAhPT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBDaGVja3MgaWYgYW4gZXZlbnQgaXMgc3VwcG9ydGVkIGluIHRoZSBjdXJyZW50IGV4ZWN1dGlvbiBlbnZpcm9ubWVudC5cbiAqXG4gKiBOT1RFOiBUaGlzIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5IGZvciBub24tZ2VuZXJpYyBldmVudHMgc3VjaCBhcyBgY2hhbmdlYCxcbiAqIGByZXNldGAsIGBsb2FkYCwgYGVycm9yYCwgYW5kIGBzZWxlY3RgLlxuICpcbiAqIEJvcnJvd3MgZnJvbSBNb2Rlcm5penIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVN1ZmZpeCBFdmVudCBuYW1lLCBlLmcuIFwiY2xpY2tcIi5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IGNhcHR1cmUgQ2hlY2sgaWYgdGhlIGNhcHR1cmUgcGhhc2UgaXMgc3VwcG9ydGVkLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgaXMgc3VwcG9ydGVkLlxuICogQGludGVybmFsXG4gKiBAbGljZW5zZSBNb2Rlcm5penIgMy4wLjBwcmUgKEN1c3RvbSBCdWlsZCkgfCBNSVRcbiAqL1xuZnVuY3Rpb24gaXNFdmVudFN1cHBvcnRlZChldmVudE5hbWVTdWZmaXgsIGNhcHR1cmUpIHtcbiAgaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gfHwgY2FwdHVyZSAmJiAhKCdhZGRFdmVudExpc3RlbmVyJyBpbiBkb2N1bWVudCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgZXZlbnROYW1lID0gJ29uJyArIGV2ZW50TmFtZVN1ZmZpeDtcbiAgdmFyIGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIGRvY3VtZW50O1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5mdW5jdGlvbiBpc0NoZWNrYWJsZShlbGVtKSB7XG4gIHZhciB0eXBlID0gZWxlbS50eXBlO1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAodHlwZSA9PT0gJ2NoZWNrYm94JyB8fCB0eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VHJhY2tlcihub2RlKSB7XG4gIHJldHVybiBub2RlLl92YWx1ZVRyYWNrZXI7XG59XG5cbmZ1bmN0aW9uIGRldGFjaFRyYWNrZXIobm9kZSkge1xuICBub2RlLl92YWx1ZVRyYWNrZXIgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlID0gJyc7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIGlmIChpc0NoZWNrYWJsZShub2RlKSkge1xuICAgIHZhbHVlID0gbm9kZS5jaGVja2VkID8gJ3RydWUnIDogJ2ZhbHNlJztcbiAgfSBlbHNlIHtcbiAgICB2YWx1ZSA9IG5vZGUudmFsdWU7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHRyYWNrVmFsdWVPbk5vZGUobm9kZSkge1xuICB2YXIgdmFsdWVGaWVsZCA9IGlzQ2hlY2thYmxlKG5vZGUpID8gJ2NoZWNrZWQnIDogJ3ZhbHVlJztcbiAgdmFyIGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG5vZGUuY29uc3RydWN0b3IucHJvdG90eXBlLCB2YWx1ZUZpZWxkKTtcblxuICB2YXIgY3VycmVudFZhbHVlID0gJycgKyBub2RlW3ZhbHVlRmllbGRdO1xuXG4gIC8vIGlmIHNvbWVvbmUgaGFzIGFscmVhZHkgZGVmaW5lZCBhIHZhbHVlIG9yIFNhZmFyaSwgdGhlbiBiYWlsXG4gIC8vIGFuZCBkb24ndCB0cmFjayB2YWx1ZSB3aWxsIGNhdXNlIG92ZXIgcmVwb3J0aW5nIG9mIGNoYW5nZXMsXG4gIC8vIGJ1dCBpdCdzIGJldHRlciB0aGVuIGEgaGFyZCBmYWlsdXJlXG4gIC8vIChuZWVkZWQgZm9yIGNlcnRhaW4gdGVzdHMgdGhhdCBzcHlPbiBpbnB1dCB2YWx1ZXMgYW5kIFNhZmFyaSlcbiAgaWYgKG5vZGUuaGFzT3duUHJvcGVydHkodmFsdWVGaWVsZCkgfHwgdHlwZW9mIGRlc2NyaXB0b3IuZ2V0ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBkZXNjcmlwdG9yLnNldCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShub2RlLCB2YWx1ZUZpZWxkLCB7XG4gICAgZW51bWVyYWJsZTogZGVzY3JpcHRvci5lbnVtZXJhYmxlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkZXNjcmlwdG9yLmdldC5jYWxsKHRoaXMpO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICBkZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciB0cmFja2VyID0ge1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgIH0sXG4gICAgc2V0VmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9LFxuICAgIHN0b3BUcmFja2luZzogZnVuY3Rpb24gKCkge1xuICAgICAgZGV0YWNoVHJhY2tlcihub2RlKTtcbiAgICAgIGRlbGV0ZSBub2RlW3ZhbHVlRmllbGRdO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHRyYWNrZXI7XG59XG5cbmZ1bmN0aW9uIHRyYWNrKG5vZGUpIHtcbiAgaWYgKGdldFRyYWNrZXIobm9kZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPOiBPbmNlIGl0J3MganVzdCBGaWJlciB3ZSBjYW4gbW92ZSB0aGlzIHRvIG5vZGUuX3dyYXBwZXJTdGF0ZVxuICBub2RlLl92YWx1ZVRyYWNrZXIgPSB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChub2RlKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciB0cmFja2VyID0gZ2V0VHJhY2tlcihub2RlKTtcbiAgLy8gaWYgdGhlcmUgaXMgbm8gdHJhY2tlciBhdCB0aGlzIHBvaW50IGl0J3MgdW5saWtlbHlcbiAgLy8gdGhhdCB0cnlpbmcgYWdhaW4gd2lsbCBzdWNjZWVkXG4gIGlmICghdHJhY2tlcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGxhc3RWYWx1ZSA9IHRyYWNrZXIuZ2V0VmFsdWUoKTtcbiAgdmFyIG5leHRWYWx1ZSA9IGdldFZhbHVlRnJvbU5vZGUobm9kZSk7XG4gIGlmIChuZXh0VmFsdWUgIT09IGxhc3RWYWx1ZSkge1xuICAgIHRyYWNrZXIuc2V0VmFsdWUobmV4dFZhbHVlKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBldmVudFR5cGVzJDEgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25DaGFuZ2UnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNoYW5nZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDaGFuZ2UnLCAndG9wQ2xpY2snLCAndG9wRm9jdXMnLCAndG9wSW5wdXQnLCAndG9wS2V5RG93bicsICd0b3BLZXlVcCcsICd0b3BTZWxlY3Rpb25DaGFuZ2UnXVxuICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDEuY2hhbmdlLCBpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KTtcbiAgZXZlbnQudHlwZSA9ICdjaGFuZ2UnO1xuICAvLyBGbGFnIHRoaXMgZXZlbnQgbG9vcCBhcyBuZWVkaW5nIHN0YXRlIHJlc3RvcmUuXG4gIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KTtcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cbi8qKlxuICogRm9yIElFIHNoaW1zXG4gKi9cbnZhciBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjaGFuZ2VgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNoYW5nZUV2ZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSA9PT0gJ3NlbGVjdCcgfHwgbm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAnZmlsZSc7XG59XG5cbmZ1bmN0aW9uIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGFjdGl2ZUVsZW1lbnRJbnN0LCBuYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpKTtcblxuICAvLyBJZiBjaGFuZ2UgYW5kIHByb3BlcnR5Y2hhbmdlIGJ1YmJsZWQsIHdlJ2QganVzdCBiaW5kIHRvIGl0IGxpa2UgYWxsIHRoZVxuICAvLyBvdGhlciBldmVudHMgYW5kIGhhdmUgaXQgZ28gdGhyb3VnaCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuIFNpbmNlIGl0XG4gIC8vIGRvZXNuJ3QsIHdlIG1hbnVhbGx5IGxpc3RlbiBmb3IgdGhlIGV2ZW50cyBhbmQgc28gd2UgaGF2ZSB0byBlbnF1ZXVlIGFuZFxuICAvLyBwcm9jZXNzIHRoZSBhYnN0cmFjdCBldmVudCBtYW51YWxseS5cbiAgLy9cbiAgLy8gQmF0Y2hpbmcgaXMgbmVjZXNzYXJ5IGhlcmUgaW4gb3JkZXIgdG8gZW5zdXJlIHRoYXQgYWxsIGV2ZW50IGhhbmRsZXJzIHJ1blxuICAvLyBiZWZvcmUgdGhlIG5leHQgcmVyZW5kZXIgKGluY2x1ZGluZyBldmVudCBoYW5kbGVycyBhdHRhY2hlZCB0byBhbmNlc3RvclxuICAvLyBlbGVtZW50cyBpbnN0ZWFkIG9mIGRpcmVjdGx5IG9uIHRoZSBpbnB1dCkuIFdpdGhvdXQgdGhpcywgY29udHJvbGxlZFxuICAvLyBjb21wb25lbnRzIGRvbid0IHdvcmsgcHJvcGVybHkgaW4gY29uanVuY3Rpb24gd2l0aCBldmVudCBidWJibGluZyBiZWNhdXNlXG4gIC8vIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZCBhbmQgdGhlIHZhbHVlIHJldmVydGVkIGJlZm9yZSBhbGwgdGhlIGV2ZW50XG4gIC8vIGhhbmRsZXJzIGNhbiBydW4uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcwOC5cbiAgYmF0Y2hlZFVwZGF0ZXMocnVuRXZlbnRJbkJhdGNoLCBldmVudCk7XG59XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50SW5CYXRjaChldmVudCkge1xuICBlbnF1ZXVlRXZlbnRzKGV2ZW50KTtcbiAgcHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCkge1xuICB2YXIgdGFyZ2V0Tm9kZSA9IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KTtcbiAgaWYgKHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKHRhcmdldE5vZGUpKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2hhbmdlJykge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHMuXG4gIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2lucHV0JykgJiYgKCFkb2N1bWVudC5kb2N1bWVudE1vZGUgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFN0YXJ0cyB0cmFja2luZyBwcm9wZXJ0eWNoYW5nZSBldmVudHMgb24gdGhlIHBhc3NlZC1pbiBlbGVtZW50XG4gKiBhbmQgb3ZlcnJpZGUgdGhlIHZhbHVlIHByb3BlcnR5IHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHVzZXIgZXZlbnRzIGZyb21cbiAqIHZhbHVlIGNoYW5nZXMgaW4gSlMuXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSB0YXJnZXRJbnN0O1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBSZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0aGUgY3VycmVudGx5LXRyYWNrZWQgZWxlbWVudCxcbiAqIGlmIGFueSBleGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCkge1xuICBpZiAoIWFjdGl2ZUVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgYWN0aXZlRWxlbWVudC5kZXRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbiAgYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgSGFuZGxlcyBhIHByb3BlcnR5Y2hhbmdlIGV2ZW50LCBzZW5kaW5nIGEgYGNoYW5nZWAgZXZlbnQgaWZcbiAqIHRoZSB2YWx1ZSBvZiB0aGUgYWN0aXZlIGVsZW1lbnQgaGFzIGNoYW5nZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5Q2hhbmdlKG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5wcm9wZXJ0eU5hbWUgIT09ICd2YWx1ZScpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCkpIHtcbiAgICBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXQsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEZvY3VzJykge1xuICAgIC8vIEluIElFOSwgcHJvcGVydHljaGFuZ2UgZmlyZXMgZm9yIG1vc3QgaW5wdXQgZXZlbnRzIGJ1dCBpcyBidWdneSBhbmRcbiAgICAvLyBkb2Vzbid0IGZpcmUgd2hlbiB0ZXh0IGlzIGRlbGV0ZWQsIGJ1dCBjb252ZW5pZW50bHksIHNlbGVjdGlvbmNoYW5nZVxuICAgIC8vIGFwcGVhcnMgdG8gZmlyZSBpbiBhbGwgb2YgdGhlIHJlbWFpbmluZyBjYXNlcyBzbyB3ZSBjYXRjaCB0aG9zZSBhbmRcbiAgICAvLyBmb3J3YXJkIHRoZSBldmVudCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWRcbiAgICAvLyBJbiBlaXRoZXIgY2FzZSwgd2UgZG9uJ3Qgd2FudCB0byBjYWxsIHRoZSBldmVudCBoYW5kbGVyIGlmIHRoZSB2YWx1ZVxuICAgIC8vIGlzIGNoYW5nZWQgZnJvbSBKUyBzbyB3ZSByZWRlZmluZSBhIHNldHRlciBmb3IgYC52YWx1ZWAgdGhhdCB1cGRhdGVzXG4gICAgLy8gb3VyIGFjdGl2ZUVsZW1lbnRWYWx1ZSB2YXJpYWJsZSwgYWxsb3dpbmcgdXMgdG8gaWdub3JlIHRob3NlIGNoYW5nZXNcbiAgICAvL1xuICAgIC8vIHN0b3BXYXRjaGluZygpIHNob3VsZCBiZSBhIG5vb3AgaGVyZSBidXQgd2UgY2FsbCBpdCBqdXN0IGluIGNhc2Ugd2VcbiAgICAvLyBtaXNzZWQgYSBibHVyIGV2ZW50IHNvbWVob3cuXG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgICBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KTtcbiAgfSBlbHNlIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gIH1cbn1cblxuLy8gRm9yIElFOCBhbmQgSUU5LlxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcFNlbGVjdGlvbkNoYW5nZScgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5VXAnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleURvd24nKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZChhY3RpdmVFbGVtZW50SW5zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmIChlbGVtLnR5cGUgPT09ICdjaGVja2JveCcgfHwgZWxlbS50eXBlID09PSAncmFkaW8nKTtcbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDbGljaycpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BJbnB1dCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wQ2hhbmdlJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cihpbnN0LCBub2RlKSB7XG4gIC8vIFRPRE86IEluIElFLCBpbnN0IGlzIG9jY2FzaW9uYWxseSBudWxsLiBXaHk/XG4gIGlmIChpbnN0ID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGaWJlciBhbmQgUmVhY3RET00ga2VlcCB3cmFwcGVyIHN0YXRlIGluIHNlcGFyYXRlIHBsYWNlc1xuICB2YXIgc3RhdGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUgfHwgbm9kZS5fd3JhcHBlclN0YXRlO1xuXG4gIGlmICghc3RhdGUgfHwgIXN0YXRlLmNvbnRyb2xsZWQgfHwgbm9kZS50eXBlICE9PSAnbnVtYmVyJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGNvbnRyb2xsZWQsIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIHRvIHRoZSBjdXJyZW50IHZhbHVlIG9uIGJsdXJcbiAgdmFyIHZhbHVlID0gJycgKyBub2RlLnZhbHVlO1xuICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJykgIT09IHZhbHVlKSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25DaGFuZ2VgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBjaGFuZ2UgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy4gVGhpcyBldmVudCBmaXJlcyBhdCBhIHRpbWUgd2hlbiBpdCdzIHBvc3NpYmxlIHRvXG4gKiBjaGFuZ2UgdGhlIGVsZW1lbnQncyB2YWx1ZSB3aXRob3V0IHNlZWluZyBhIGZsaWNrZXIuXG4gKlxuICogU3VwcG9ydGVkIGVsZW1lbnRzIGFyZTpcbiAqIC0gaW5wdXQgKHNlZSBgaXNUZXh0SW5wdXRFbGVtZW50YClcbiAqIC0gdGV4dGFyZWFcbiAqIC0gc2VsZWN0XG4gKi9cbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQxLFxuXG4gIF9pc0lucHV0RXZlbnRTdXBwb3J0ZWQ6IGlzSW5wdXRFdmVudFN1cHBvcnRlZCxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgdGFyZ2V0Tm9kZSA9IHRhcmdldEluc3QgPyBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCkgOiB3aW5kb3c7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SW5zdEZ1bmMsIGhhbmRsZUV2ZW50RnVuYztcbiAgICBpZiAoc2hvdWxkVXNlQ2hhbmdlRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNoYW5nZUV2ZW50O1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkVXNlQ2xpY2tFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudDtcbiAgICB9XG5cbiAgICBpZiAoZ2V0VGFyZ2V0SW5zdEZ1bmMpIHtcbiAgICAgIHZhciBpbnN0ID0gZ2V0VGFyZ2V0SW5zdEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KTtcbiAgICAgIGlmIChpbnN0KSB7XG4gICAgICAgIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGhhbmRsZUV2ZW50RnVuYykge1xuICAgICAgaGFuZGxlRXZlbnRGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SW5zdCk7XG4gICAgfVxuXG4gICAgLy8gV2hlbiBibHVycmluZywgc2V0IHRoZSB2YWx1ZSBhdHRyaWJ1dGUgZm9yIG51bWJlciBpbnB1dHNcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICAgIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIodGFyZ2V0SW5zdCwgdGFyZ2V0Tm9kZSk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIE1vZHVsZSB0aGF0IGlzIGluamVjdGFibGUgaW50byBgRXZlbnRQbHVnaW5IdWJgLCB0aGF0IHNwZWNpZmllcyBhXG4gKiBkZXRlcm1pbmlzdGljIG9yZGVyaW5nIG9mIGBFdmVudFBsdWdpbmBzLiBBIGNvbnZlbmllbnQgd2F5IHRvIHJlYXNvbiBhYm91dFxuICogcGx1Z2lucywgd2l0aG91dCBoYXZpbmcgdG8gcGFja2FnZSBldmVyeSBvbmUgb2YgdGhlbS4gVGhpcyBpcyBiZXR0ZXIgdGhhblxuICogaGF2aW5nIHBsdWdpbnMgYmUgb3JkZXJlZCBpbiB0aGUgc2FtZSBvcmRlciB0aGF0IHRoZXkgYXJlIGluamVjdGVkIGJlY2F1c2VcbiAqIHRoYXQgb3JkZXJpbmcgd291bGQgYmUgaW5mbHVlbmNlZCBieSB0aGUgcGFja2FnaW5nIG9yZGVyLlxuICogYFJlc3BvbmRlckV2ZW50UGx1Z2luYCBtdXN0IG9jY3VyIGJlZm9yZSBgU2ltcGxlRXZlbnRQbHVnaW5gIHNvIHRoYXRcbiAqIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBldmVudHMgaXMgY29udmVuaWVudCBpbiBgU2ltcGxlRXZlbnRQbHVnaW5gIGhhbmRsZXJzLlxuICovXG52YXIgRE9NRXZlbnRQbHVnaW5PcmRlciA9IFsnUmVzcG9uZGVyRXZlbnRQbHVnaW4nLCAnU2ltcGxlRXZlbnRQbHVnaW4nLCAnVGFwRXZlbnRQbHVnaW4nLCAnRW50ZXJMZWF2ZUV2ZW50UGx1Z2luJywgJ0NoYW5nZUV2ZW50UGx1Z2luJywgJ1NlbGVjdEV2ZW50UGx1Z2luJywgJ0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nXTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFVJRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgVUlFdmVudEludGVyZmFjZSA9IHtcbiAgdmlldzogbnVsbCxcbiAgZGV0YWlsOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVUlFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljVUlFdmVudCwgVUlFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBtb2RpZmllciBrZXkgdG8gdGhlIGFzc29jaWF0ZWQgcHJvcGVydHkgaW4gdGhlIGV2ZW50LlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2tleXMtTW9kaWZpZXJzXG4gKi9cblxudmFyIG1vZGlmaWVyS2V5VG9Qcm9wID0ge1xuICBBbHQ6ICdhbHRLZXknLFxuICBDb250cm9sOiAnY3RybEtleScsXG4gIE1ldGE6ICdtZXRhS2V5JyxcbiAgU2hpZnQ6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIHBhZ2VYOiBudWxsLFxuICBwYWdlWTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICBidXR0b246IG51bGwsXG4gIGJ1dHRvbnM6IG51bGwsXG4gIHJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC5yZWxhdGVkVGFyZ2V0IHx8IChldmVudC5mcm9tRWxlbWVudCA9PT0gZXZlbnQuc3JjRWxlbWVudCA/IGV2ZW50LnRvRWxlbWVudCA6IGV2ZW50LmZyb21FbGVtZW50KTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljTW91c2VFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbnZhciBldmVudFR5cGVzJDIgPSB7XG4gIG1vdXNlRW50ZXI6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUVudGVyJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfSxcbiAgbW91c2VMZWF2ZToge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlTGVhdmUnLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9XG59O1xuXG52YXIgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDIsXG5cbiAgLyoqXG4gICAqIEZvciBhbG1vc3QgZXZlcnkgaW50ZXJhY3Rpb24gd2UgY2FyZSBhYm91dCwgdGhlcmUgd2lsbCBiZSBib3RoIGEgdG9wLWxldmVsXG4gICAqIGBtb3VzZW92ZXJgIGFuZCBgbW91c2VvdXRgIGV2ZW50IHRoYXQgb2NjdXJzLiBPbmx5IHVzZSBgbW91c2VvdXRgIHNvIHRoYXRcbiAgICogd2UgZG8gbm90IGV4dHJhY3QgZHVwbGljYXRlIGV2ZW50cy4gSG93ZXZlciwgbW92aW5nIHRoZSBtb3VzZSBpbnRvIHRoZVxuICAgKiBicm93c2VyIGZyb20gb3V0c2lkZSB3aWxsIG5vdCBmaXJlIGEgYG1vdXNlb3V0YCBldmVudC4gSW4gdGhpcyBjYXNlLCB3ZSB1c2VcbiAgICogdGhlIGBtb3VzZW92ZXJgIHRvcC1sZXZlbCBldmVudC5cbiAgICovXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU92ZXInICYmIChuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU91dCcgJiYgdG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdmVyJykge1xuICAgICAgLy8gTXVzdCBub3QgYmUgYSBtb3VzZSBpbiBvciBtb3VzZSBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW47XG4gICAgaWYgKG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICAgIC8vIGBuYXRpdmVFdmVudFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3V0Jykge1xuICAgICAgZnJvbSA9IHRhcmdldEluc3Q7XG4gICAgICB2YXIgcmVsYXRlZCA9IG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQudG9FbGVtZW50O1xuICAgICAgdG8gPSByZWxhdGVkID8gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocmVsYXRlZCkgOiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZpbmcgdG8gYSBub2RlIGZyb20gb3V0c2lkZSB0aGUgd2luZG93LlxuICAgICAgZnJvbSA9IG51bGw7XG4gICAgICB0byA9IHRhcmdldEluc3Q7XG4gICAgfVxuXG4gICAgaWYgKGZyb20gPT09IHRvKSB7XG4gICAgICAvLyBOb3RoaW5nIHBlcnRhaW5zIHRvIG91ciBtYW5hZ2VkIGNvbXBvbmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZnJvbU5vZGUgPSBmcm9tID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlJDEoZnJvbSk7XG4gICAgdmFyIHRvTm9kZSA9IHRvID09IG51bGwgPyB3aW4gOiBnZXROb2RlRnJvbUluc3RhbmNlJDEodG8pO1xuXG4gICAgdmFyIGxlYXZlID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcyQyLm1vdXNlTGVhdmUsIGZyb20sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgbGVhdmUudHlwZSA9ICdtb3VzZWxlYXZlJztcbiAgICBsZWF2ZS50YXJnZXQgPSBmcm9tTm9kZTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG9Ob2RlO1xuXG4gICAgdmFyIGVudGVyID0gU3ludGhldGljTW91c2VFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcyQyLm1vdXNlRW50ZXIsIHRvLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGVudGVyLnR5cGUgPSAnbW91c2VlbnRlcic7XG4gICAgZW50ZXIudGFyZ2V0ID0gdG9Ob2RlO1xuICAgIGVudGVyLnJlbGF0ZWRUYXJnZXQgPSBmcm9tTm9kZTtcblxuICAgIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKTtcblxuICAgIHJldHVybiBbbGVhdmUsIGVudGVyXTtcbiAgfVxufTtcblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNoYXJlZCBhbmQgYXNzdW1lZCB0byBiZSBzdGF0ZWxlc3MuXG4gKiBJZiB0aGlzIGJlY29tZXMgYW4gYWN0dWFsIE1hcCwgdGhhdCB3aWxsIGJyZWFrLlxuICovXG5cbi8qKlxuICogVGhpcyBBUEkgc2hvdWxkIGJlIGNhbGxlZCBgZGVsZXRlYCBidXQgd2UnZCBoYXZlIHRvIG1ha2Ugc3VyZSB0byBhbHdheXNcbiAqIHRyYW5zZm9ybSB0aGVzZSB0byBzdHJpbmdzIGZvciBJRSBzdXBwb3J0LiBXaGVuIHRoaXMgdHJhbnNmb3JtIGlzIGZ1bGx5XG4gKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyO1xufVxuXG5mdW5jdGlvbiBoYXMoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlciAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlciA9IHZhbHVlO1xufVxuXG52YXIgUmVhY3RJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHtcbiAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWU7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8vIERvbid0IGNoYW5nZSB0aGVzZSB0d28gdmFsdWVzOlxudmFyIE5vRWZmZWN0ID0gMDsgLy8gICAgICAgICAgIDBiMDAwMDAwMDBcbnZhciBQZXJmb3JtZWRXb3JrID0gMTsgLy8gICAgICAwYjAwMDAwMDAxXG5cbi8vIFlvdSBjYW4gY2hhbmdlIHRoZSByZXN0IChhbmQgYWRkIG1vcmUpLlxudmFyIFBsYWNlbWVudCA9IDI7IC8vICAgICAgICAgIDBiMDAwMDAwMTBcbnZhciBVcGRhdGUgPSA0OyAvLyAgICAgICAgICAgICAwYjAwMDAwMTAwXG52YXIgUGxhY2VtZW50QW5kVXBkYXRlID0gNjsgLy8gMGIwMDAwMDExMFxudmFyIERlbGV0aW9uID0gODsgLy8gICAgICAgICAgIDBiMDAwMDEwMDBcbnZhciBDb250ZW50UmVzZXQgPSAxNjsgLy8gICAgICAwYjAwMDEwMDAwXG52YXIgQ2FsbGJhY2sgPSAzMjsgLy8gICAgICAgICAgMGIwMDEwMDAwMFxudmFyIEVyciA9IDY0OyAvLyAgICAgICAgICAgICAgIDBiMDEwMDAwMDBcbnZhciBSZWYgPSAxMjg7IC8vICAgICAgICAgICAgICAwYjEwMDAwMDAwXG5cbnZhciBNT1VOVElORyA9IDE7XG52YXIgTU9VTlRFRCA9IDI7XG52YXIgVU5NT1VOVEVEID0gMztcblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSB7XG4gIHZhciBub2RlID0gZmliZXI7XG4gIGlmICghZmliZXIuYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGlzIG1pZ2h0IGJlIGEgbmV3IHRyZWUgdGhhdCBpc24ndCBpbnNlcnRlZFxuICAgIC8vIHlldC4gSWYgaXQgaXMsIHRoZW4gaXQgd2lsbCBoYXZlIGEgcGVuZGluZyBpbnNlcnRpb24gZWZmZWN0IG9uIGl0LlxuICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZVsncmV0dXJuJ10pIHtcbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIGlmICgobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpICE9PSBOb0VmZmVjdCkge1xuICAgICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbiAgICAvLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbiAgICByZXR1cm4gTU9VTlRFRDtcbiAgfVxuICAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gIHJldHVybiBVTk1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkKGZpYmVyKSB7XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIGlmIChvd25lciAhPT0gbnVsbCAmJiBvd25lci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgdmFyIGluc3RhbmNlID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB3YXJuaW5nKGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUob3duZXJGaWJlcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBhc3NlcnRJc01vdW50ZWQoZmliZXIpIHtcbiAgIShpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpID09PSBNT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgaWYgKCFhbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoZW4gd2Ugb25seSBuZWVkIHRvIGNoZWNrIGlmIGl0IGlzIG1vdW50ZWQuXG4gICAgdmFyIHN0YXRlID0gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKTtcbiAgICAhKHN0YXRlICE9PSBVTk1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICAgIGlmIChzdGF0ZSA9PT0gTU9VTlRJTkcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cbiAgdmFyIGEgPSBmaWJlcjtcbiAgdmFyIGIgPSBhbHRlcm5hdGU7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhWydyZXR1cm4nXTtcbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEgPyBwYXJlbnRBLmFsdGVybmF0ZSA6IG51bGw7XG4gICAgaWYgKCFwYXJlbnRBIHx8ICFwYXJlbnRCKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cbiAgICBpZiAocGFyZW50QS5jaGlsZCA9PT0gcGFyZW50Qi5jaGlsZCkge1xuICAgICAgdmFyIGNoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYVsncmV0dXJuJ10gIT09IGJbJ3JldHVybiddKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuICAgICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgICAgIWRpZEZpbmRDaGlsZCA/IGludmFyaWFudChmYWxzZSwgJ0NoaWxkIHdhcyBub3QgZm91bmQgaW4gZWl0aGVyIHBhcmVudCBzZXQuIFRoaXMgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGEuYWx0ZXJuYXRlID09PSBiKSA/IGludmFyaWFudChmYWxzZSwgJ1JldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVyc1xcJyBhbHRlcm5hdGVzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB9XG4gIC8vIElmIHRoZSByb290IGlzIG5vdCBhIGhvc3QgY29udGFpbmVyLCB3ZSdyZSBpbiBhIGRpc2Nvbm5lY3RlZCB0cmVlLiBJLmUuXG4gIC8vIHVubW91bnRlZC5cbiAgIShhLnRhZyA9PT0gSG9zdFJvb3QpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH1cbiAgLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuICByZXR1cm4gYWx0ZXJuYXRlO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQpIHtcbiAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZVsncmV0dXJuJ10gfHwgbm9kZVsncmV0dXJuJ10gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICBpZiAoIWN1cnJlbnRQYXJlbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciBub2RlID0gY3VycmVudFBhcmVudDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgJiYgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChub2RlID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgd2hpbGUgKCFub2RlLnNpYmxpbmcpIHtcbiAgICAgIGlmICghbm9kZVsncmV0dXJuJ10gfHwgbm9kZVsncmV0dXJuJ10gPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG4gIC8vIEZsb3cgbmVlZHMgdGhlIHJldHVybiBudWxsIGhlcmUsIGJ1dCBFU0xpbnQgY29tcGxhaW5zIGFib3V0IGl0LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUgPSAxMDtcbnZhciBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbCA9IFtdO1xuXG4vKipcbiAqIEZpbmQgdGhlIGRlZXBlc3QgUmVhY3QgY29tcG9uZW50IGNvbXBsZXRlbHkgY29udGFpbmluZyB0aGUgcm9vdCBvZiB0aGVcbiAqIHBhc3NlZC1pbiBpbnN0YW5jZSAoZm9yIHVzZSB3aGVuIGVudGlyZSBSZWFjdCB0cmVlcyBhcmUgbmVzdGVkIHdpdGhpbiBlYWNoXG4gKiBvdGhlcikuIElmIFJlYWN0IHRyZWVzIGFyZSBub3QgbmVzdGVkLCByZXR1cm5zIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGZpbmRSb290Q29udGFpbmVyTm9kZShpbnN0KSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHdoaWxlIChpbnN0WydyZXR1cm4nXSkge1xuICAgIGluc3QgPSBpbnN0WydyZXR1cm4nXTtcbiAgfVxuICBpZiAoaW5zdC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHdlJ3JlIGluIGEgZGV0YWNoZWQgdHJlZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gaW5zdC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCkge1xuICBpZiAoY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wubGVuZ3RoKSB7XG4gICAgdmFyIGluc3RhbmNlID0gY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wucG9wKCk7XG4gICAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gdG9wTGV2ZWxUeXBlO1xuICAgIGluc3RhbmNlLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG4gICAgaW5zdGFuY2UudGFyZ2V0SW5zdCA9IHRhcmdldEluc3Q7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiB7XG4gICAgdG9wTGV2ZWxUeXBlOiB0b3BMZXZlbFR5cGUsXG4gICAgbmF0aXZlRXZlbnQ6IG5hdGl2ZUV2ZW50LFxuICAgIHRhcmdldEluc3Q6IHRhcmdldEluc3QsXG4gICAgYW5jZXN0b3JzOiBbXVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGluc3RhbmNlKSB7XG4gIGluc3RhbmNlLnRvcExldmVsVHlwZSA9IG51bGw7XG4gIGluc3RhbmNlLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgaW5zdGFuY2UudGFyZ2V0SW5zdCA9IG51bGw7XG4gIGluc3RhbmNlLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICBpZiAoY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wubGVuZ3RoIDwgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFKSB7XG4gICAgY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIHZhciB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcudGFyZ2V0SW5zdDtcblxuICAvLyBMb29wIHRocm91Z2ggdGhlIGhpZXJhcmNoeSwgaW4gY2FzZSB0aGVyZSdzIGFueSBuZXN0ZWQgY29tcG9uZW50cy5cbiAgLy8gSXQncyBpbXBvcnRhbnQgdGhhdCB3ZSBidWlsZCB0aGUgYXJyYXkgb2YgYW5jZXN0b3JzIGJlZm9yZSBjYWxsaW5nIGFueVxuICAvLyBldmVudCBoYW5kbGVycywgYmVjYXVzZSBldmVudCBoYW5kbGVycyBjYW4gbW9kaWZ5IHRoZSBET00sIGxlYWRpbmcgdG9cbiAgLy8gaW5jb25zaXN0ZW5jaWVzIHdpdGggUmVhY3RNb3VudCdzIG5vZGUgY2FjaGUuIFNlZSAjMTEwNS5cbiAgdmFyIGFuY2VzdG9yID0gdGFyZ2V0SW5zdDtcbiAgZG8ge1xuICAgIGlmICghYW5jZXN0b3IpIHtcbiAgICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgcm9vdCA9IGZpbmRSb290Q29udGFpbmVyTm9kZShhbmNlc3Rvcik7XG4gICAgaWYgKCFyb290KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgIGFuY2VzdG9yID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUocm9vdCk7XG4gIH0gd2hpbGUgKGFuY2VzdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgIHRhcmdldEluc3QgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgYm9va0tlZXBpbmcubmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50KSk7XG4gIH1cbn1cblxuLy8gVE9ETzogY2FuIHdlIHN0b3AgZXhwb3J0aW5nIHRoZXNlP1xudmFyIF9lbmFibGVkID0gdHJ1ZTtcbnZhciBfaGFuZGxlVG9wTGV2ZWwgPSB2b2lkIDA7XG5cbmZ1bmN0aW9uIHNldEhhbmRsZVRvcExldmVsKGhhbmRsZVRvcExldmVsKSB7XG4gIF9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xufVxuXG5mdW5jdGlvbiBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgX2VuYWJsZWQgPSAhIWVuYWJsZWQ7XG59XG5cbmZ1bmN0aW9uIGlzRW5hYmxlZCgpIHtcbiAgcmV0dXJuIF9lbmFibGVkO1xufVxuXG4vKipcbiAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBFdmVudExpc3RlbmVyLmxpc3RlbihlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIGRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuLyoqXG4gKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBoYW5kbGVyQmFzZU5hbWUgRXZlbnQgbmFtZSAoZS5nLiBcImNsaWNrXCIpLlxuICogQHBhcmFtIHtvYmplY3R9IGVsZW1lbnQgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIHJlbW92ZSBmdW5jdGlvbiB3aGljaCB3aWxsIGZvcmNlZnVsbHlcbiAqICAgICAgICAgICAgICAgICAgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB0cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gRXZlbnRMaXN0ZW5lci5jYXB0dXJlKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaEV2ZW50KHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgaWYgKCFfZW5hYmxlZCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuYXRpdmVFdmVudFRhcmdldCA9IGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KTtcbiAgdmFyIHRhcmdldEluc3QgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShuYXRpdmVFdmVudFRhcmdldCk7XG4gIGlmICh0YXJnZXRJbnN0ICE9PSBudWxsICYmIHR5cGVvZiB0YXJnZXRJbnN0LnRhZyA9PT0gJ251bWJlcicgJiYgIWlzRmliZXJNb3VudGVkKHRhcmdldEluc3QpKSB7XG4gICAgLy8gSWYgd2UgZ2V0IGFuIGV2ZW50IChleDogaW1nIG9ubG9hZCkgYmVmb3JlIGNvbW1pdHRpbmcgdGhhdFxuICAgIC8vIGNvbXBvbmVudCdzIG1vdW50LCBpZ25vcmUgaXQgZm9yIG5vdyAodGhhdCBpcywgdHJlYXQgaXQgYXMgaWYgaXQgd2FzIGFuXG4gICAgLy8gZXZlbnQgb24gYSBub24tUmVhY3QgdHJlZSkuIFdlIG1pZ2h0IGFsc28gY29uc2lkZXIgcXVldWVpbmcgZXZlbnRzIGFuZFxuICAgIC8vIGRpc3BhdGNoaW5nIHRoZW0gYWZ0ZXIgdGhlIG1vdW50LlxuICAgIHRhcmdldEluc3QgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJvb2tLZWVwaW5nID0gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpO1xuXG4gIHRyeSB7XG4gICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgIC8vIGBwcmV2ZW50RGVmYXVsdGAuXG4gICAgYmF0Y2hlZFVwZGF0ZXMoaGFuZGxlVG9wTGV2ZWxJbXBsLCBib29rS2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgcmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyhib29rS2VlcGluZyk7XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRXZlbnRMaXN0ZW5lciA9IE9iamVjdC5mcmVlemUoe1xuXHRnZXQgX2VuYWJsZWQgKCkgeyByZXR1cm4gX2VuYWJsZWQ7IH0sXG5cdGdldCBfaGFuZGxlVG9wTGV2ZWwgKCkgeyByZXR1cm4gX2hhbmRsZVRvcExldmVsOyB9LFxuXHRzZXRIYW5kbGVUb3BMZXZlbDogc2V0SGFuZGxlVG9wTGV2ZWwsXG5cdHNldEVuYWJsZWQ6IHNldEVuYWJsZWQsXG5cdGlzRW5hYmxlZDogaXNFbmFibGVkLFxuXHR0cmFwQnViYmxlZEV2ZW50OiB0cmFwQnViYmxlZEV2ZW50LFxuXHR0cmFwQ2FwdHVyZWRFdmVudDogdHJhcENhcHR1cmVkRXZlbnQsXG5cdGRpc3BhdGNoRXZlbnQ6IGRpc3BhdGNoRXZlbnRcbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbWFwcGluZyBvZiBzdGFuZGFyZCB2ZW5kb3IgcHJlZml4ZXMgdXNpbmcgdGhlIGRlZmluZWQgc3R5bGUgcHJvcGVydHkgYW5kIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlUHJvcFxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gbWFrZVByZWZpeE1hcChzdHlsZVByb3AsIGV2ZW50TmFtZSkge1xuICB2YXIgcHJlZml4ZXMgPSB7fTtcblxuICBwcmVmaXhlc1tzdHlsZVByb3AudG9Mb3dlckNhc2UoKV0gPSBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcHJlZml4ZXNbJ1dlYmtpdCcgKyBzdHlsZVByb3BdID0gJ3dlYmtpdCcgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydNb3onICsgc3R5bGVQcm9wXSA9ICdtb3onICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snbXMnICsgc3R5bGVQcm9wXSA9ICdNUycgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydPJyArIHN0eWxlUHJvcF0gPSAnbycgKyBldmVudE5hbWUudG9Mb3dlckNhc2UoKTtcblxuICByZXR1cm4gcHJlZml4ZXM7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGV2ZW50IG5hbWVzIHRvIGEgY29uZmlndXJhYmxlIGxpc3Qgb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgdmVuZG9yUHJlZml4ZXMgPSB7XG4gIGFuaW1hdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkVuZCcpLFxuICBhbmltYXRpb25pdGVyYXRpb246IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25JdGVyYXRpb24nKSxcbiAgYW5pbWF0aW9uc3RhcnQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25TdGFydCcpLFxuICB0cmFuc2l0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdUcmFuc2l0aW9uJywgJ1RyYW5zaXRpb25FbmQnKVxufTtcblxuLyoqXG4gKiBFdmVudCBuYW1lcyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGRldGVjdGVkIGFuZCBwcmVmaXhlZCAoaWYgYXBwbGljYWJsZSkuXG4gKi9cbnZhciBwcmVmaXhlZEV2ZW50TmFtZXMgPSB7fTtcblxuLyoqXG4gKiBFbGVtZW50IHRvIGNoZWNrIGZvciBwcmVmaXhlcyBvbi5cbiAqL1xudmFyIHN0eWxlID0ge307XG5cbi8qKlxuICogQm9vdHN0cmFwIGlmIGEgRE9NIGV4aXN0cy5cbiAqL1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLnN0eWxlO1xuXG4gIC8vIE9uIHNvbWUgcGxhdGZvcm1zLCBpbiBwYXJ0aWN1bGFyIHNvbWUgcmVsZWFzZXMgb2YgQW5kcm9pZCA0LngsXG4gIC8vIHRoZSB1bi1wcmVmaXhlZCBcImFuaW1hdGlvblwiIGFuZCBcInRyYW5zaXRpb25cIiBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIG9uIHRoZVxuICAvLyBzdHlsZSBvYmplY3QgYnV0IHRoZSBldmVudHMgdGhhdCBmaXJlIHdpbGwgc3RpbGwgYmUgcHJlZml4ZWQsIHNvIHdlIG5lZWRcbiAgLy8gdG8gY2hlY2sgaWYgdGhlIHVuLXByZWZpeGVkIGV2ZW50cyBhcmUgdXNhYmxlLCBhbmQgaWYgbm90IHJlbW92ZSB0aGVtIGZyb20gdGhlIG1hcC5cbiAgaWYgKCEoJ0FuaW1hdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbmVuZC5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb247XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbjtcbiAgfVxuXG4gIC8vIFNhbWUgYXMgYWJvdmVcbiAgaWYgKCEoJ1RyYW5zaXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb247XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBkZXRlcm1pbmUgdGhlIGNvcnJlY3QgdmVuZG9yIHByZWZpeGVkIGV2ZW50IG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoZXZlbnROYW1lKSB7XG4gIGlmIChwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgfSBlbHNlIGlmICghdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXSkge1xuICAgIHJldHVybiBldmVudE5hbWU7XG4gIH1cblxuICB2YXIgcHJlZml4TWFwID0gdmVuZG9yUHJlZml4ZXNbZXZlbnROYW1lXTtcblxuICBmb3IgKHZhciBzdHlsZVByb3AgaW4gcHJlZml4TWFwKSB7XG4gICAgaWYgKHByZWZpeE1hcC5oYXNPd25Qcm9wZXJ0eShzdHlsZVByb3ApICYmIHN0eWxlUHJvcCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdID0gcHJlZml4TWFwW3N0eWxlUHJvcF07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFR5cGVzIG9mIHJhdyBzaWduYWxzIGZyb20gdGhlIGJyb3dzZXIgY2F1Z2h0IGF0IHRoZSB0b3AgbGV2ZWwuXG4gKlxuICogRm9yIGV2ZW50cyBsaWtlICdzdWJtaXQnIHdoaWNoIGRvbid0IGNvbnNpc3RlbnRseSBidWJibGUgKHdoaWNoIHdlXG4gKiB0cmFwIGF0IGEgbG93ZXIgbm9kZSB0aGFuIGBkb2N1bWVudGApLCBiaW5kaW5nIGF0IGBkb2N1bWVudGAgd291bGRcbiAqIGNhdXNlIGR1cGxpY2F0ZSBldmVudHMgc28gd2UgZG9uJ3QgaW5jbHVkZSB0aGVtIGhlcmUuXG4gKi9cbnZhciB0b3BMZXZlbFR5cGVzJDEgPSB7XG4gIHRvcEFib3J0OiAnYWJvcnQnLFxuICB0b3BBbmltYXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25lbmQnKSB8fCAnYW5pbWF0aW9uZW5kJyxcbiAgdG9wQW5pbWF0aW9uSXRlcmF0aW9uOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uaXRlcmF0aW9uJykgfHwgJ2FuaW1hdGlvbml0ZXJhdGlvbicsXG4gIHRvcEFuaW1hdGlvblN0YXJ0OiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uc3RhcnQnKSB8fCAnYW5pbWF0aW9uc3RhcnQnLFxuICB0b3BCbHVyOiAnYmx1cicsXG4gIHRvcENhbmNlbDogJ2NhbmNlbCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcENoYW5nZTogJ2NoYW5nZScsXG4gIHRvcENsaWNrOiAnY2xpY2snLFxuICB0b3BDbG9zZTogJ2Nsb3NlJyxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6ICdjb21wb3NpdGlvbmVuZCcsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6ICdjb21wb3NpdGlvbnN0YXJ0JyxcbiAgdG9wQ29tcG9zaXRpb25VcGRhdGU6ICdjb21wb3NpdGlvbnVwZGF0ZScsXG4gIHRvcENvbnRleHRNZW51OiAnY29udGV4dG1lbnUnLFxuICB0b3BDb3B5OiAnY29weScsXG4gIHRvcEN1dDogJ2N1dCcsXG4gIHRvcERvdWJsZUNsaWNrOiAnZGJsY2xpY2snLFxuICB0b3BEcmFnOiAnZHJhZycsXG4gIHRvcERyYWdFbmQ6ICdkcmFnZW5kJyxcbiAgdG9wRHJhZ0VudGVyOiAnZHJhZ2VudGVyJyxcbiAgdG9wRHJhZ0V4aXQ6ICdkcmFnZXhpdCcsXG4gIHRvcERyYWdMZWF2ZTogJ2RyYWdsZWF2ZScsXG4gIHRvcERyYWdPdmVyOiAnZHJhZ292ZXInLFxuICB0b3BEcmFnU3RhcnQ6ICdkcmFnc3RhcnQnLFxuICB0b3BEcm9wOiAnZHJvcCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wRm9jdXM6ICdmb2N1cycsXG4gIHRvcElucHV0OiAnaW5wdXQnLFxuICB0b3BLZXlEb3duOiAna2V5ZG93bicsXG4gIHRvcEtleVByZXNzOiAna2V5cHJlc3MnLFxuICB0b3BLZXlVcDogJ2tleXVwJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkOiAnbG9hZCcsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BNb3VzZURvd246ICdtb3VzZWRvd24nLFxuICB0b3BNb3VzZU1vdmU6ICdtb3VzZW1vdmUnLFxuICB0b3BNb3VzZU91dDogJ21vdXNlb3V0JyxcbiAgdG9wTW91c2VPdmVyOiAnbW91c2VvdmVyJyxcbiAgdG9wTW91c2VVcDogJ21vdXNldXAnLFxuICB0b3BQYXN0ZTogJ3Bhc3RlJyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTY3JvbGw6ICdzY3JvbGwnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFNlbGVjdGlvbkNoYW5nZTogJ3NlbGVjdGlvbmNoYW5nZScsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUZXh0SW5wdXQ6ICd0ZXh0SW5wdXQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFRvZ2dsZTogJ3RvZ2dsZScsXG4gIHRvcFRvdWNoQ2FuY2VsOiAndG91Y2hjYW5jZWwnLFxuICB0b3BUb3VjaEVuZDogJ3RvdWNoZW5kJyxcbiAgdG9wVG91Y2hNb3ZlOiAndG91Y2htb3ZlJyxcbiAgdG9wVG91Y2hTdGFydDogJ3RvdWNoc3RhcnQnLFxuICB0b3BUcmFuc2l0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgndHJhbnNpdGlvbmVuZCcpIHx8ICd0cmFuc2l0aW9uZW5kJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnLFxuICB0b3BXaGVlbDogJ3doZWVsJ1xufTtcblxudmFyIEJyb3dzZXJFdmVudENvbnN0YW50cyA9IHtcbiAgdG9wTGV2ZWxUeXBlczogdG9wTGV2ZWxUeXBlcyQxXG59O1xuXG5mdW5jdGlvbiBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpIHtcbiAgZW5xdWV1ZUV2ZW50cyhldmVudHMpO1xuICBwcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbi8qKlxuICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAqIG9wcG9ydHVuaXR5IHRvIGNyZWF0ZSBgUmVhY3RFdmVudGBzIHRvIGJlIGRpc3BhdGNoZWQuXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudHMgPSBleHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKTtcbn1cblxudmFyIHRvcExldmVsVHlwZXMgPSBCcm93c2VyRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuLyoqXG4gKiBTdW1tYXJ5IG9mIGBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJgIGV2ZW50IGhhbmRsaW5nOlxuICpcbiAqICAtIFRvcC1sZXZlbCBkZWxlZ2F0aW9uIGlzIHVzZWQgdG8gdHJhcCBtb3N0IG5hdGl2ZSBicm93c2VyIGV2ZW50cy4gVGhpc1xuICogICAgbWF5IG9ubHkgb2NjdXIgaW4gdGhlIG1haW4gdGhyZWFkIGFuZCBpcyB0aGUgcmVzcG9uc2liaWxpdHkgb2ZcbiAqICAgIFJlYWN0RE9NRXZlbnRMaXN0ZW5lciwgd2hpY2ggaXMgaW5qZWN0ZWQgYW5kIGNhbiB0aGVyZWZvcmUgc3VwcG9ydFxuICogICAgcGx1Z2dhYmxlIGV2ZW50IHNvdXJjZXMuIFRoaXMgaXMgdGhlIG9ubHkgd29yayB0aGF0IG9jY3VycyBpbiB0aGUgbWFpblxuICogICAgdGhyZWFkLlxuICpcbiAqICAtIFdlIG5vcm1hbGl6ZSBhbmQgZGUtZHVwbGljYXRlIGV2ZW50cyB0byBhY2NvdW50IGZvciBicm93c2VyIHF1aXJrcy4gVGhpc1xuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXG4gKlxuICogIC0gRm9yd2FyZCB0aGVzZSBuYXRpdmUgZXZlbnRzICh3aXRoIHRoZSBhc3NvY2lhdGVkIHRvcC1sZXZlbCB0eXBlIHVzZWQgdG9cbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXG4gKlxuICogT3ZlcnZpZXcgb2YgUmVhY3QgYW5kIHRoZSBldmVudCBzeXN0ZW06XG4gKlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCAgICBET00gICAgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogICAgICAgfCAgICAgICAgICAgLlxuICogICAgICAgdiAgICAgICAgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxuICogfCAgTGlzdGVuZXIgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICB8ICAgICAgICAgfFBsdWdpbiAgICAgfFxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnxFdmVudFBsdWdpbkh1YnwgICAgICAgICAgICAgICAgICAgIHwgICAgRXZlbnQgICB8XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XG4gKiB8ICBFbWl0dGVyICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHw8LS0tK3xQbHVnaW4gICAgIHwgIHxvdGhlciBwbHVnaW58XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLStcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XG4gKiAgICAgICArICAgICAgICAgICAuICAgICAgICAgICAgICAgICstLS0tLS0tK3xQbHVnaW4gICAgIHxcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxuICogfC0tLS0tLS0tLS0tLS18ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogKy0tLS0tLS0tLS0tLS0rICAgLlxuICogICAgICAgICAgICAgICAgICAgLlxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cbiAqL1xuXG52YXIgYWxyZWFkeUxpc3RlbmluZ1RvID0ge307XG52YXIgcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyID0gMDtcblxuLyoqXG4gKiBUbyBlbnN1cmUgbm8gY29uZmxpY3RzIHdpdGggb3RoZXIgcG90ZW50aWFsIFJlYWN0IGluc3RhbmNlcyBvbiB0aGUgcGFnZVxuICovXG52YXIgdG9wTGlzdGVuZXJzSURLZXkgPSAnX3JlYWN0TGlzdGVuZXJzSUQnICsgKCcnICsgTWF0aC5yYW5kb20oKSkuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpIHtcbiAgLy8gSW4gSUU4LCBgbW91bnRBdGAgaXMgYSBob3N0IG9iamVjdCBhbmQgZG9lc24ndCBoYXZlIGBoYXNPd25Qcm9wZXJ0eWBcbiAgLy8gZGlyZWN0bHkuXG4gIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vdW50QXQsIHRvcExpc3RlbmVyc0lES2V5KSkge1xuICAgIG1vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldID0gcmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyKys7XG4gICAgYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXSA9IHt9O1xuICB9XG4gIHJldHVybiBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dO1xufVxuXG4vKipcbiAqIFdlIGxpc3RlbiBmb3IgYnViYmxlZCB0b3VjaCBldmVudHMgb24gdGhlIGRvY3VtZW50IG9iamVjdC5cbiAqXG4gKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXG4gKiBtb3VudGluZyBgb25tb3VzZW1vdmVgIGV2ZW50cyBhdCBzb21lIG5vZGUgdGhhdCB3YXMgbm90IHRoZSBkb2N1bWVudFxuICogZWxlbWVudC4gVGhlIHN5bXB0b21zIHdlcmUgdGhhdCBpZiB5b3VyIG1vdXNlIGlzIG5vdCBtb3Zpbmcgb3ZlciBzb21ldGhpbmdcbiAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxuICogdG9wLWxldmVsIGxpc3RlbmVycyBmb3IgYG9ubW91c2Vtb3ZlYCB3b24ndCBiZSBjYWxsZWQuIEhvd2V2ZXIsIGlmIHlvdVxuICogcmVnaXN0ZXIgdGhlIGBtb3VzZW1vdmVgIG9uIHRoZSBkb2N1bWVudCBvYmplY3QsIHRoZW4gaXQgd2lsbCBvZiBjb3Vyc2VcbiAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgdG8gdGhlIGRvY3VtZW50IG9iamVjdCBvbmx5LCBhdCBsZWFzdCBmb3IgdGhlc2VcbiAqIG1vdmVtZW50IHR5cGVzIG9mIGV2ZW50cyBhbmQgcG9zc2libHkgYWxsIGV2ZW50cy5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gKlxuICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxuICogdGhleSBidWJibGUgdG8gZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHBhcmFtIHtvYmplY3R9IGNvbnRlbnREb2N1bWVudEhhbmRsZSBEb2N1bWVudCB3aGljaCBvd25zIHRoZSBjb250YWluZXJcbiAqL1xuZnVuY3Rpb24gbGlzdGVuVG8ocmVnaXN0cmF0aW9uTmFtZSwgY29udGVudERvY3VtZW50SGFuZGxlKSB7XG4gIHZhciBtb3VudEF0ID0gY29udGVudERvY3VtZW50SGFuZGxlO1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICBpZiAoIShpc0xpc3RlbmluZy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSAmJiBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSkpIHtcbiAgICAgIGlmIChkZXBlbmRlbmN5ID09PSAndG9wU2Nyb2xsJykge1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wU2Nyb2xsJywgJ3Njcm9sbCcsIG1vdW50QXQpO1xuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wRm9jdXMnIHx8IGRlcGVuZGVuY3kgPT09ICd0b3BCbHVyJykge1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wRm9jdXMnLCAnZm9jdXMnLCBtb3VudEF0KTtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcEJsdXInLCAnYmx1cicsIG1vdW50QXQpO1xuXG4gICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICBpc0xpc3RlbmluZy50b3BCbHVyID0gdHJ1ZTtcbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wRm9jdXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wQ2FuY2VsJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnY2FuY2VsJywgdHJ1ZSkpIHtcbiAgICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQ2FuY2VsJywgJ2NhbmNlbCcsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcENhbmNlbCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDbG9zZScpIHtcbiAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2Nsb3NlJywgdHJ1ZSkpIHtcbiAgICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQ2xvc2UnLCAnY2xvc2UnLCBtb3VudEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0xpc3RlbmluZy50b3BDbG9zZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZXMuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChkZXBlbmRlbmN5LCB0b3BMZXZlbFR5cGVzW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgIH1cblxuICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKHJlZ2lzdHJhdGlvbk5hbWUsIG1vdW50QXQpIHtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlJCQxID0gc2VsZWN0aW9uLmZvY3VzTm9kZSxcbiAgICAgIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIC8vIEluIEZpcmVmb3gsIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBjYW4gYmUgXCJhbm9ueW1vdXMgZGl2c1wiLCBlLmcuIHRoZVxuICAvLyB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91cyBkaXZzIGRvIG5vdCBzZWVtIHRvXG4gIC8vIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZCBlcnJvclwiIGlmIGFueSBvZiBpdHNcbiAgLy8gcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZSB3YXkgdG8gYXZvaWQgZXJyb3JpbmdcbiAgLy8gaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmRcbiAgLy8gY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuXG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgYW5jaG9yTm9kZS5ub2RlVHlwZTtcbiAgICBmb2N1c05vZGUkJDEubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUkJDEsIGZvY3VzT2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUkJDEsIGZvY3VzT2Zmc2V0KSB7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgaW5kZXhXaXRoaW5BbmNob3IgPSAwO1xuICB2YXIgaW5kZXhXaXRoaW5Gb2N1cyA9IDA7XG4gIHZhciBub2RlID0gb3V0ZXJOb2RlO1xuICB2YXIgcGFyZW50Tm9kZSA9IG51bGw7XG5cbiAgb3V0ZXI6IHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHQgPSBudWxsO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBhbmNob3JOb2RlICYmIChhbmNob3JPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aCArIGFuY2hvck9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmb2N1c05vZGUkJDEgJiYgKGZvY3VzT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoICsgZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxuICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG91dGVyTm9kZSkge1xuICAgICAgICAvLyBJZiBgb3V0ZXJOb2RlYCBoYXMgY2hpbGRyZW4sIHRoaXMgaXMgYWx3YXlzIHRoZSBzZWNvbmQgdGltZSB2aXNpdGluZ1xuICAgICAgICAvLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbiAgICAgICAgLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgYm90aCBvZmZzZXRzIDAsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBoYXZlIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGFuY2hvck5vZGUgJiYgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGZvY3VzTm9kZSQkMSAmJiArK2luZGV4V2l0aGluRm9jdXMgPT09IGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmICgobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgbmV4dCBzaWJsaW5nIGBuZXh0YC5cbiAgICBub2RlID0gbmV4dDtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuICAgIC8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gc3RhcnRNYXJrZXIub2Zmc2V0ICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IGVuZE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG5cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAndGV4dCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCkge1xuICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHJldHVybiB7XG4gICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgIHNlbGVjdGlvblJhbmdlOiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gZ2V0U2VsZWN0aW9uJDEoZm9jdXNlZEVsZW0pIDogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAqL1xuZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG4gIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICBpZiAoaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBzZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgfVxuXG4gICAgLy8gRm9jdXNpbmcgYSBub2RlIGNhbiBjaGFuZ2UgdGhlIHNjcm9sbCBwb3NpdGlvbiwgd2hpY2ggaXMgdW5kZXNpcmFibGVcbiAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgdmFyIGFuY2VzdG9yID0gcHJpb3JGb2N1c2VkRWxlbTtcbiAgICB3aGlsZSAoYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYW5jZXN0b3Iubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogYW5jZXN0b3IsXG4gICAgICAgICAgbGVmdDogYW5jZXN0b3Iuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFuY2VzdG9yLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZm8gPSBhbmNlc3RvcnNbaV07XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGluZm8ubGVmdDtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxUb3AgPSBpbmZvLnRvcDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24kMShpbnB1dCkge1xuICB2YXIgc2VsZWN0aW9uID0gdm9pZCAwO1xuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSB7XG4gICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0gZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xufVxuXG4vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oaW5wdXQsIG9mZnNldHMpIHtcbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydCxcbiAgICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgfVxufVxuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMkMyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvblNlbGVjdCcsXG4gICAgICBjYXB0dXJlZDogJ29uU2VsZWN0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbnRleHRNZW51JywgJ3RvcEZvY3VzJywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJywgJ3RvcE1vdXNlVXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCQxID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCQxICE9PSBnZXRBY3RpdmVFbGVtZW50KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oYWN0aXZlRWxlbWVudCQxKTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJbnN0JDEsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudCQxO1xuXG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCA/IG5hdGl2ZUV2ZW50VGFyZ2V0LmRvY3VtZW50IDogbmF0aXZlRXZlbnRUYXJnZXQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyBuYXRpdmVFdmVudFRhcmdldCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gVHJhY2sgd2hldGhlciBhbGwgbGlzdGVuZXJzIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4gICAgLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG4gICAgaWYgKCFkb2MgfHwgIWlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMoJ29uU2VsZWN0JywgZG9jKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSB0YXJnZXRJbnN0O1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSAndG9wU2VsZWN0aW9uQ2hhbmdlJzpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xudmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBhbmltYXRpb25OYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNBbmltYXRpb25FdmVudCwgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDbGlwYm9hcmRFdmVudCwgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgRXNjOiAnRXNjYXBlJyxcbiAgU3BhY2ViYXI6ICcgJyxcbiAgTGVmdDogJ0Fycm93TGVmdCcsXG4gIFVwOiAnQXJyb3dVcCcsXG4gIFJpZ2h0OiAnQXJyb3dSaWdodCcsXG4gIERvd246ICdBcnJvd0Rvd24nLFxuICBEZWw6ICdEZWxldGUnLFxuICBXaW46ICdPUycsXG4gIE1lbnU6ICdDb250ZXh0TWVudScsXG4gIEFwcHM6ICdDb250ZXh0TWVudScsXG4gIFNjcm9sbDogJ1Njcm9sbExvY2snLFxuICBNb3pQcmludGFibGVLZXk6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAnOCc6ICdCYWNrc3BhY2UnLFxuICAnOSc6ICdUYWInLFxuICAnMTInOiAnQ2xlYXInLFxuICAnMTMnOiAnRW50ZXInLFxuICAnMTYnOiAnU2hpZnQnLFxuICAnMTcnOiAnQ29udHJvbCcsXG4gICcxOCc6ICdBbHQnLFxuICAnMTknOiAnUGF1c2UnLFxuICAnMjAnOiAnQ2Fwc0xvY2snLFxuICAnMjcnOiAnRXNjYXBlJyxcbiAgJzMyJzogJyAnLFxuICAnMzMnOiAnUGFnZVVwJyxcbiAgJzM0JzogJ1BhZ2VEb3duJyxcbiAgJzM1JzogJ0VuZCcsXG4gICczNic6ICdIb21lJyxcbiAgJzM3JzogJ0Fycm93TGVmdCcsXG4gICczOCc6ICdBcnJvd1VwJyxcbiAgJzM5JzogJ0Fycm93UmlnaHQnLFxuICAnNDAnOiAnQXJyb3dEb3duJyxcbiAgJzQ1JzogJ0luc2VydCcsXG4gICc0Nic6ICdEZWxldGUnLFxuICAnMTEyJzogJ0YxJyxcbiAgJzExMyc6ICdGMicsXG4gICcxMTQnOiAnRjMnLFxuICAnMTE1JzogJ0Y0JyxcbiAgJzExNic6ICdGNScsXG4gICcxMTcnOiAnRjYnLFxuICAnMTE4JzogJ0Y3JyxcbiAgJzExOSc6ICdGOCcsXG4gICcxMjAnOiAnRjknLFxuICAnMTIxJzogJ0YxMCcsXG4gICcxMjInOiAnRjExJyxcbiAgJzEyMyc6ICdGMTInLFxuICAnMTQ0JzogJ051bUxvY2snLFxuICAnMTQ1JzogJ1Njcm9sbExvY2snLFxuICAnMjI0JzogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljS2V5Ym9hcmRFdmVudCwgS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgcHJvcGVydHlOYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LCBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIFR1cm5zXG4gKiBbJ2Fib3J0JywgLi4uXVxuICogaW50b1xuICogZXZlbnRUeXBlcyA9IHtcbiAqICAgJ2Fib3J0Jzoge1xuICogICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gKiAgICAgICBidWJibGVkOiAnb25BYm9ydCcsXG4gKiAgICAgICBjYXB0dXJlZDogJ29uQWJvcnRDYXB0dXJlJyxcbiAqICAgICB9LFxuICogICAgIGRlcGVuZGVuY2llczogWyd0b3BBYm9ydCddLFxuICogICB9LFxuICogICAuLi5cbiAqIH07XG4gKiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gKiAgICd0b3BBYm9ydCc6IHsgc2FtZUNvbmZpZyB9XG4gKiB9O1xuICovXG52YXIgZXZlbnRUeXBlcyQ0ID0ge307XG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge307XG5bJ2Fib3J0JywgJ2FuaW1hdGlvbkVuZCcsICdhbmltYXRpb25JdGVyYXRpb24nLCAnYW5pbWF0aW9uU3RhcnQnLCAnYmx1cicsICdjYW5jZWwnLCAnY2FuUGxheScsICdjYW5QbGF5VGhyb3VnaCcsICdjbGljaycsICdjbG9zZScsICdjb250ZXh0TWVudScsICdjb3B5JywgJ2N1dCcsICdkb3VibGVDbGljaycsICdkcmFnJywgJ2RyYWdFbmQnLCAnZHJhZ0VudGVyJywgJ2RyYWdFeGl0JywgJ2RyYWdMZWF2ZScsICdkcmFnT3ZlcicsICdkcmFnU3RhcnQnLCAnZHJvcCcsICdkdXJhdGlvbkNoYW5nZScsICdlbXB0aWVkJywgJ2VuY3J5cHRlZCcsICdlbmRlZCcsICdlcnJvcicsICdmb2N1cycsICdpbnB1dCcsICdpbnZhbGlkJywgJ2tleURvd24nLCAna2V5UHJlc3MnLCAna2V5VXAnLCAnbG9hZCcsICdsb2FkZWREYXRhJywgJ2xvYWRlZE1ldGFkYXRhJywgJ2xvYWRTdGFydCcsICdtb3VzZURvd24nLCAnbW91c2VNb3ZlJywgJ21vdXNlT3V0JywgJ21vdXNlT3ZlcicsICdtb3VzZVVwJywgJ3Bhc3RlJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsICdwcm9ncmVzcycsICdyYXRlQ2hhbmdlJywgJ3Jlc2V0JywgJ3Njcm9sbCcsICdzZWVrZWQnLCAnc2Vla2luZycsICdzdGFsbGVkJywgJ3N1Ym1pdCcsICdzdXNwZW5kJywgJ3RpbWVVcGRhdGUnLCAndG9nZ2xlJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoRW5kJywgJ3RvdWNoTW92ZScsICd0b3VjaFN0YXJ0JywgJ3RyYW5zaXRpb25FbmQnLCAndm9sdW1lQ2hhbmdlJywgJ3dhaXRpbmcnLCAnd2hlZWwnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcbiAgdmFyIHRvcEV2ZW50ID0gJ3RvcCcgKyBjYXBpdGFsaXplZEV2ZW50O1xuXG4gIHZhciB0eXBlID0ge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBvbkV2ZW50LFxuICAgICAgY2FwdHVyZWQ6IG9uRXZlbnQgKyAnQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcEV2ZW50XVxuICB9O1xuICBldmVudFR5cGVzJDRbZXZlbnRdID0gdHlwZTtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcEV2ZW50XSA9IHR5cGU7XG59KTtcblxuLy8gT25seSB1c2VkIGluIERFViBmb3IgZXhoYXVzdGl2ZW5lc3MgdmFsaWRhdGlvbi5cbnZhciBrbm93bkhUTUxUb3BMZXZlbFR5cGVzID0gWyd0b3BBYm9ydCcsICd0b3BDYW5jZWwnLCAndG9wQ2FuUGxheScsICd0b3BDYW5QbGF5VGhyb3VnaCcsICd0b3BDbG9zZScsICd0b3BEdXJhdGlvbkNoYW5nZScsICd0b3BFbXB0aWVkJywgJ3RvcEVuY3J5cHRlZCcsICd0b3BFbmRlZCcsICd0b3BFcnJvcicsICd0b3BJbnB1dCcsICd0b3BJbnZhbGlkJywgJ3RvcExvYWQnLCAndG9wTG9hZGVkRGF0YScsICd0b3BMb2FkZWRNZXRhZGF0YScsICd0b3BMb2FkU3RhcnQnLCAndG9wUGF1c2UnLCAndG9wUGxheScsICd0b3BQbGF5aW5nJywgJ3RvcFByb2dyZXNzJywgJ3RvcFJhdGVDaGFuZ2UnLCAndG9wUmVzZXQnLCAndG9wU2Vla2VkJywgJ3RvcFNlZWtpbmcnLCAndG9wU3RhbGxlZCcsICd0b3BTdWJtaXQnLCAndG9wU3VzcGVuZCcsICd0b3BUaW1lVXBkYXRlJywgJ3RvcFRvZ2dsZScsICd0b3BWb2x1bWVDaGFuZ2UnLCAndG9wV2FpdGluZyddO1xuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkNCxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ2xpY2snOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICBjYXNlICd0b3BNb3VzZU1vdmUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BNb3VzZU91dCc6XG4gICAgICBjYXNlICd0b3BNb3VzZU92ZXInOlxuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BEcmFnJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbmQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VudGVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFeGl0JzpcbiAgICAgIGNhc2UgJ3RvcERyYWdMZWF2ZSc6XG4gICAgICBjYXNlICd0b3BEcmFnT3Zlcic6XG4gICAgICBjYXNlICd0b3BEcmFnU3RhcnQnOlxuICAgICAgY2FzZSAndG9wRHJvcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVG91Y2hDYW5jZWwnOlxuICAgICAgY2FzZSAndG9wVG91Y2hFbmQnOlxuICAgICAgY2FzZSAndG9wVG91Y2hNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25FbmQnOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uSXRlcmF0aW9uJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvblN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRyYW5zaXRpb25FbmQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFNjcm9sbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFdoZWVsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29weSc6XG4gICAgICBjYXNlICd0b3BDdXQnOlxuICAgICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChrbm93bkhUTUxUb3BMZXZlbFR5cGVzLmluZGV4T2YodG9wTGV2ZWxUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuIFRoaXMgd2FybmluZyAnICsgJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIHRvcExldmVsVHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQkMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxufTtcblxuc2V0SGFuZGxlVG9wTGV2ZWwoaGFuZGxlVG9wTGV2ZWwpO1xuXG4vKipcbiAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICovXG5pbmplY3Rpb24kMS5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERPTUV2ZW50UGx1Z2luT3JkZXIpO1xuaW5qZWN0aW9uJDIuaW5qZWN0Q29tcG9uZW50VHJlZShSZWFjdERPTUNvbXBvbmVudFRyZWUpO1xuXG4vKipcbiAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICogdGhlbSkuXG4gKi9cbmluamVjdGlvbiQxLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG59KTtcblxudmFyIGVuYWJsZUFzeW5jU3VidHJlZUFQSSA9IHRydWU7XG52YXIgZW5hYmxlQXN5bmNTY2hlZHVsaW5nQnlEZWZhdWx0SW5SZWFjdERPTSA9IGZhbHNlO1xuLy8gRXhwb3J0cyBSZWFjdERPTS5jcmVhdGVSb290XG52YXIgZW5hYmxlQ3JlYXRlUm9vdCA9IGZhbHNlO1xudmFyIGVuYWJsZVVzZXJUaW1pbmdBUEkgPSB0cnVlO1xuXG4vLyBNdXRhdGluZyBtb2RlIChSZWFjdCBET00sIFJlYWN0IEFSVCwgUmVhY3QgTmF0aXZlKTpcbnZhciBlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIgPSB0cnVlO1xuLy8gRXhwZXJpbWVudGFsIG5vb3AgbW9kZSAoY3VycmVudGx5IHVudXNlZCk6XG52YXIgZW5hYmxlTm9vcFJlY29uY2lsZXIgPSBmYWxzZTtcbi8vIEV4cGVyaW1lbnRhbCBwZXJzaXN0ZW50IG1vZGUgKENTKTpcbnZhciBlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciA9IGZhbHNlO1xuXG4vLyBIZWxwcyBpZGVudGlmeSBzaWRlIGVmZmVjdHMgaW4gYmVnaW4tcGhhc2UgbGlmZWN5Y2xlIGhvb2tzIGFuZCBzZXRTdGF0ZSByZWR1Y2VyczpcbnZhciBkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMgPSBmYWxzZTtcblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cbnZhciB2YWx1ZVN0YWNrID0gW107XG5cbntcbiAgdmFyIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuXG5cbmZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIGluZGV4LS07XG59XG5cbmZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgaW5kZXgrKztcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXQkMSgpIHtcbiAgd2hpbGUgKGluZGV4ID4gLTEpIHtcbiAgICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAgICB7XG4gICAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gICAgfVxuXG4gICAgaW5kZXgtLTtcbiAgfVxufVxuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB2YXIgb3duZXIgPSBmaWJlci5fZGVidWdPd25lcjtcbiAgICAgIHZhciBzb3VyY2UgPSBmaWJlci5fZGVidWdTb3VyY2U7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpO1xuICAgICAgdmFyIG93bmVyTmFtZSA9IG51bGw7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgb3duZXJOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShvd25lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGNhbiBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgd29yay1pbi1wcm9ncmVzcyBmaWJlciBhbmRcbi8vIG9ubHkgZHVyaW5nIGJlZ2luIG9yIGNvbXBsZXRlIHBoYXNlLiBEbyBub3QgY2FsbCBpdCB1bmRlciBhbnkgb3RoZXJcbi8vIGNpcmN1bXN0YW5jZXMuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBpbmZvID0gJyc7XG4gIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG4gIGRvIHtcbiAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG4gICAgLy8gT3RoZXJ3aXNlIHRoaXMgcmV0dXJuIHBvaW50ZXIgbWlnaHQgcG9pbnQgdG8gdGhlIHdyb25nIHRyZWU6XG4gICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICB9IHdoaWxlIChub2RlKTtcbiAgcmV0dXJuIGluZm87XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSgpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudDtcbiAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSBmaWJlci5fZGVidWdPd25lcjtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudDtcbiAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZlIGJlY2F1c2UgaWYgY3VycmVudCBmaWJlciBleGlzdHMsIHdlIGFyZSByZWNvbmNpbGluZyxcbiAgICAvLyBhbmQgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgd29yay1pbi1wcm9ncmVzcyB2ZXJzaW9uLlxuICAgIHJldHVybiBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZpYmVyKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ID0gbnVsbDtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRGaWJlcihmaWJlcikge1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCA9IGZpYmVyO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudFBoYXNlKHBoYXNlKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBwaGFzZTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RmliZXIgPSB7XG4gIGN1cnJlbnQ6IG51bGwsXG4gIHBoYXNlOiBudWxsLFxuICByZXNldEN1cnJlbnRGaWJlcjogcmVzZXRDdXJyZW50RmliZXIsXG4gIHNldEN1cnJlbnRGaWJlcjogc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50UGhhc2U6IHNldEN1cnJlbnRQaGFzZSxcbiAgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lOiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUsXG4gIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW06IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW1cbn07XG5cbi8vIFByZWZpeCBtZWFzdXJlbWVudHMgc28gdGhhdCBpdCdzIHBvc3NpYmxlIHRvIGZpbHRlciB0aGVtLlxuLy8gTG9uZ2VyIHByZWZpeGVzIGFyZSBoYXJkIHRvIHJlYWQgaW4gRGV2VG9vbHMuXG52YXIgcmVhY3RFbW9qaSA9ICdcXHUyNjlCJztcbnZhciB3YXJuaW5nRW1vamkgPSAnXFx1MjZENCc7XG52YXIgc3VwcG9ydHNVc2VyVGltaW5nID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gS2VlcCB0cmFjayBvZiBjdXJyZW50IGZpYmVyIHNvIHRoYXQgd2Uga25vdyB0aGUgcGF0aCB0byB1bndpbmQgb24gcGF1c2UuXG4vLyBUT0RPOiB0aGlzIGxvb2tzIHRoZSBzYW1lIGFzIG5leHRVbml0T2ZXb3JrIGluIHNjaGVkdWxlci4gQ2FuIHdlIHVuaWZ5IHRoZW0/XG52YXIgY3VycmVudEZpYmVyID0gbnVsbDtcbi8vIElmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgdXNlciBjb2RlLCB3aGljaCBmaWJlciBhbmQgbWV0aG9kIGlzIGl0P1xuLy8gUmV1c2luZyBgY3VycmVudEZpYmVyYCB3b3VsZCBiZSBjb25mdXNpbmcgZm9yIHRoaXMgYmVjYXVzZSB1c2VyIGNvZGUgZmliZXJcbi8vIGNhbiBjaGFuZ2UgZHVyaW5nIGNvbW1pdCBwaGFzZSB0b28sIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIHVud2luZCBpdCAoc2luY2Vcbi8vIGxpZmVjeWNsZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSBkb24ndCByZXNlbWJsZSBhIHRyZWUpLlxudmFyIGN1cnJlbnRQaGFzZSA9IG51bGw7XG52YXIgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuLy8gRGlkIGxpZmVjeWNsZSBob29rIHNjaGVkdWxlIGFuIHVwZGF0ZT8gVGhpcyBpcyBvZnRlbiBhIHBlcmZvcm1hbmNlIHByb2JsZW0sXG4vLyBzbyB3ZSB3aWxsIGtlZXAgdHJhY2sgb2YgaXQsIGFuZCBpbmNsdWRlIGl0IGluIHRoZSByZXBvcnQuXG4vLyBUcmFjayBjb21taXRzIGNhdXNlZCBieSBjYXNjYWRpbmcgdXBkYXRlcy5cbnZhciBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IGZhbHNlO1xudmFyIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xudmFyIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbnZhciBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IGZhbHNlO1xuLy8gRHVyaW5nIGNvbW1pdHMsIHdlIG9ubHkgc2hvdyBhIG1lYXN1cmVtZW50IG9uY2UgcGVyIG1ldGhvZCBuYW1lXG4vLyB0byBhdm9pZCBzdHJldGNoIHRoZSBjb21taXQgcGhhc2Ugd2l0aCBtZWFzdXJlbWVudCBvdmVyaGVhZC5cbnZhciBsYWJlbHNJbkN1cnJlbnRDb21taXQgPSBuZXcgU2V0KCk7XG5cbnZhciBmb3JtYXRNYXJrTmFtZSA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICByZXR1cm4gcmVhY3RFbW9qaSArICcgJyArIG1hcmtOYW1lO1xufTtcblxudmFyIGZvcm1hdExhYmVsID0gZnVuY3Rpb24gKGxhYmVsLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBwcmVmaXggPSB3YXJuaW5nJCQxID8gd2FybmluZ0Vtb2ppICsgJyAnIDogcmVhY3RFbW9qaSArICcgJztcbiAgdmFyIHN1ZmZpeCA9IHdhcm5pbmckJDEgPyAnIFdhcm5pbmc6ICcgKyB3YXJuaW5nJCQxIDogJyc7XG4gIHJldHVybiAnJyArIHByZWZpeCArIGxhYmVsICsgc3VmZml4O1xufTtcblxudmFyIGJlZ2luTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5tYXJrKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgY2xlYXJNYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBlbmRNYXJrID0gZnVuY3Rpb24gKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyQkMSkge1xuICB2YXIgZm9ybWF0dGVkTWFya05hbWUgPSBmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSk7XG4gIHZhciBmb3JtYXR0ZWRMYWJlbCA9IGZvcm1hdExhYmVsKGxhYmVsLCB3YXJuaW5nJCQxKTtcbiAgdHJ5IHtcbiAgICBwZXJmb3JtYW5jZS5tZWFzdXJlKGZvcm1hdHRlZExhYmVsLCBmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIH0gY2F0Y2ggKGVycikge31cbiAgLy8gSWYgcHJldmlvdXMgbWFyayB3YXMgbWlzc2luZyBmb3Igc29tZSByZWFzb24sIHRoaXMgd2lsbCB0aHJvdy5cbiAgLy8gVGhpcyBjb3VsZCBvbmx5IGhhcHBlbiBpZiBSZWFjdCBjcmFzaGVkIGluIGFuIHVuZXhwZWN0ZWQgcGxhY2UgZWFybGllci5cbiAgLy8gRG9uJ3QgcGlsZSBvbiB3aXRoIG1vcmUgZXJyb3JzLlxuXG4gIC8vIENsZWFyIG1hcmtzIGltbWVkaWF0ZWx5IHRvIGF2b2lkIGdyb3dpbmcgYnVmZmVyLlxuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyhmb3JtYXR0ZWRMYWJlbCk7XG59O1xuXG52YXIgZ2V0RmliZXJNYXJrTmFtZSA9IGZ1bmN0aW9uIChsYWJlbCwgZGVidWdJRCkge1xuICByZXR1cm4gbGFiZWwgKyAnICgjJyArIGRlYnVnSUQgKyAnKSc7XG59O1xuXG52YXIgZ2V0RmliZXJMYWJlbCA9IGZ1bmN0aW9uIChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKSB7XG4gIGlmIChwaGFzZSA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXNlIGFyZSBjb21wb3NpdGUgY29tcG9uZW50IHRvdGFsIHRpbWUgbWVhc3VyZW1lbnRzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJyBbJyArIChpc01vdW50ZWQgPyAndXBkYXRlJyA6ICdtb3VudCcpICsgJ10nO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbXBvc2l0ZSBjb21wb25lbnQgbWV0aG9kcy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcuJyArIHBoYXNlO1xuICB9XG59O1xuXG52YXIgYmVnaW5GaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuXG4gIGlmIChpc0NvbW1pdHRpbmcgJiYgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmhhcyhsYWJlbCkpIHtcbiAgICAvLyBEdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSwgd2UgZG9uJ3Qgc2hvdyBkdXBsaWNhdGUgbGFiZWxzIGJlY2F1c2VcbiAgICAvLyB0aGVyZSBpcyBhIGZpeGVkIG92ZXJoZWFkIGZvciBldmVyeSBtZWFzdXJlbWVudCwgYW5kIHdlIGRvbid0XG4gICAgLy8gd2FudCB0byBzdHJldGNoIHRoZSBjb21taXQgcGhhc2UgYmV5b25kIG5lY2Vzc2FyeS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmFkZChsYWJlbCk7XG5cbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGJlZ2luTWFyayhtYXJrTmFtZSk7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIGNsZWFyRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGNsZWFyTWFyayhtYXJrTmFtZSk7XG59O1xuXG52YXIgZW5kRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSwgd2FybmluZyQkMSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcbiAgdmFyIG1hcmtOYW1lID0gZ2V0RmliZXJNYXJrTmFtZShsYWJlbCwgZGVidWdJRCk7XG4gIGVuZE1hcmsobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKTtcbn07XG5cbnZhciBzaG91bGRJZ25vcmVGaWJlciA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAvLyBIb3N0IGNvbXBvbmVudHMgc2hvdWxkIGJlIHNraXBwZWQgaW4gdGhlIHRpbWVsaW5lLlxuICAvLyBXZSBjb3VsZCBjaGVjayB0eXBlb2YgZmliZXIudHlwZSwgYnV0IGRvZXMgdGhpcyB3b3JrIHdpdGggUk4/XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbnZhciBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgY2xlYXJGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSk7XG4gIH1cbiAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICBjdXJyZW50UGhhc2UgPSBudWxsO1xuICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IGZhbHNlO1xufTtcblxudmFyIHBhdXNlVGltZXJzID0gZnVuY3Rpb24gKCkge1xuICAvLyBTdG9wcyBhbGwgY3VycmVudGx5IGFjdGl2ZSBtZWFzdXJlbWVudHMgc28gdGhhdCB0aGV5IGNhbiBiZSByZXN1bWVkXG4gIC8vIGlmIHdlIGNvbnRpbnVlIGluIGEgbGF0ZXIgZGVmZXJyZWQgbG9vcCBmcm9tIHRoZSBzYW1lIHVuaXQgb2Ygd29yay5cbiAgdmFyIGZpYmVyID0gY3VycmVudEZpYmVyO1xuICB3aGlsZSAoZmliZXIpIHtcbiAgICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gICAgfVxuICAgIGZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICB9XG59O1xuXG52YXIgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgaWYgKGZpYmVyWydyZXR1cm4nXSAhPT0gbnVsbCkge1xuICAgIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5KGZpYmVyWydyZXR1cm4nXSk7XG4gIH1cbiAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59O1xuXG52YXIgcmVzdW1lVGltZXJzID0gZnVuY3Rpb24gKCkge1xuICAvLyBSZXN1bWVzIGFsbCBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGFjdGl2ZSBkdXJpbmcgdGhlIGxhc3QgZGVmZXJyZWQgbG9vcC5cbiAgaWYgKGN1cnJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5KGN1cnJlbnRGaWJlcik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlY29yZEVmZmVjdCgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCsrO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFNjaGVkdWxlVXBkYXRlKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbE1vdW50JyAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFJlcXVlc3RDYWxsYmFja1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcgJiYgIWlzV2FpdGluZ0ZvckNhbGxiYWNrKSB7XG4gICAgICBpc1dhaXRpbmdGb3JDYWxsYmFjayA9IHRydWU7XG4gICAgICBiZWdpbk1hcmsoJyhXYWl0aW5nIGZvciBhc3luYyBjYWxsYmFjay4uLiknKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFJlcXVlc3RDYWxsYmFja1RpbWVyKGRpZEV4cGlyZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmIChzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIGlzV2FpdGluZ0ZvckNhbGxiYWNrID0gZmFsc2U7XG4gICAgICB2YXIgd2FybmluZyQkMSA9IGRpZEV4cGlyZSA/ICdSZWFjdCB3YXMgYmxvY2tlZCBieSBtYWluIHRocmVhZCcgOiBudWxsO1xuICAgICAgZW5kTWFyaygnKFdhaXRpbmcgZm9yIGFzeW5jIGNhbGxiYWNrLi4uKScsICcoV2FpdGluZyBmb3IgYXN5bmMgY2FsbGJhY2suLi4pJywgd2FybmluZyQkMSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCB0aGlzIGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbWVtYmVyIHdlIHNob3VsZG4ndCBjb21wbGV0ZSBtZWFzdXJlbWVudCBmb3IgdGhpcyBmaWJlci5cbiAgICAvLyBPdGhlcndpc2UgZmxhbWVjaGFydCB3aWxsIGJlIGRlZXAgZXZlbiBmb3Igc21hbGwgdXBkYXRlcy5cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGNsZWFyRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcEZhaWxlZFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICB2YXIgd2FybmluZyQkMSA9ICdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSB0aGlzIGVycm9yIGJvdW5kYXJ5JztcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgcGhhc2UpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50KCk7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgcGhhc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gZmliZXI7XG4gICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFBoYXNlVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA/ICdTY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJyA6IG51bGw7XG4gICAgICBlbmRGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSwgd2FybmluZyQkMSk7XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yaykge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGN1cnJlbnRGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFRoaXMgaXMgdG9wIGxldmVsIGNhbGwuXG4gICAgLy8gQW55IG90aGVyIG1lYXN1cmVtZW50cyBhcmUgcGVyZm9ybWVkIHdpdGhpbi5cbiAgICBiZWdpbk1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScpO1xuICAgIC8vIFJlc3VtZSBhbnkgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBpbiBwcm9ncmVzcyBkdXJpbmcgdGhlIGxhc3QgbG9vcC5cbiAgICByZXN1bWVUaW1lcnMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5KSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChpbnRlcnJ1cHRlZEJ5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaW50ZXJydXB0ZWRCeS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIHdhcm5pbmckJDEgPSAnQSB0b3AtbGV2ZWwgdXBkYXRlIGludGVycnVwdGVkIHRoZSBwcmV2aW91cyByZW5kZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGludGVycnVwdGVkQnkpIHx8ICdVbmtub3duJztcbiAgICAgICAgd2FybmluZyQkMSA9ICdBbiB1cGRhdGUgdG8gJyArIGNvbXBvbmVudE5hbWUgKyAnIGludGVycnVwdGVkIHRoZSBwcmV2aW91cyByZW5kZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA+IDEpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnVGhlcmUgd2VyZSBjYXNjYWRpbmcgdXBkYXRlcyc7XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFBhdXNlIGFueSBtZWFzdXJlbWVudHMgdW50aWwgdGhlIG5leHQgbG9vcC5cbiAgICBwYXVzZVRpbWVycygpO1xuICAgIGVuZE1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsICcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nJCQxID0gbnVsbDtcbiAgICBpZiAoaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0KSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ0xpZmVjeWNsZSBob29rIHNjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA+IDApIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnQ2F1c2VkIGJ5IGEgY2FzY2FkaW5nIHVwZGF0ZSBpbiBlYXJsaWVyIGNvbW1pdCc7XG4gICAgfVxuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3ArKztcbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcblxuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJywgJyhDb21taXR0aW5nIENoYW5nZXMpJywgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJywgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyaygnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScsIG51bGwpO1xuICB9XG59XG5cbntcbiAgdmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHt9O1xufVxuXG4vLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxudmFyIGNvbnRleHRTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihlbXB0eU9iamVjdCk7XG4vLyBBIGN1cnNvciB0byBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkLlxudmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpO1xuLy8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxudmFyIHByZXZpb3VzQ29udGV4dCA9IGVtcHR5T2JqZWN0O1xuXG5mdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGhhc093bkNvbnRleHQgPSBpc0NvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIGlmIChoYXNPd25Db250ZXh0KSB7XG4gICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgIC8vIHdlIGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4gICAgLy8gcHJldmlvdXMgKHBhcmVudCkgY29udGV4dCBpbnN0ZWFkIGZvciBhIGNvbnRleHQgcHJvdmlkZXIuXG4gICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgfVxuICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBtYXNrZWRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQgPSBtYXNrZWRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG4gIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgLy8gQXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgdW5tYXNrZWQgY29udGV4dCBoYXMgY2hhbmdlZC5cbiAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG4gIC8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIGNvbnRleHRUeXBlcykge1xuICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICB9XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNvbnRleHRUeXBlcywgY29udGV4dCwgJ2NvbnRleHQnLCBuYW1lLCBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0pO1xuICB9XG5cbiAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAvLyBDb250ZXh0IGlzIGNyZWF0ZWQgYmVmb3JlIHRoZSBjbGFzcyBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkIHNvIGNoZWNrIGZvciBpbnN0YW5jZS5cbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGhhc0NvbnRleHRDaGFuZ2VkKCkge1xuICByZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJiBmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJiBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHBvcENvbnRleHRQcm92aWRlcihmaWJlcikge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyKSB7XG4gIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHVzaFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlciwgY29udGV4dCwgZGlkQ2hhbmdlKSB7XG4gICEoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnNvciA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgY29udGV4dCBmb3VuZCBvbiBzdGFjay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBwYXJlbnRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcztcblxuICAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAvLyBJdCBoYXMgb25seSBiZWVuIGFkZGVkIGluIEZpYmVyIHRvIG1hdGNoIHRoZSAodW5pbnRlbnRpb25hbCkgYmVoYXZpb3IgaW4gU3RhY2suXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgdmFyIGNoaWxkQ29udGV4dCA9IHZvaWQgMDtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdnZXRDaGlsZENvbnRleHQnKTtcbiAgfVxuICBzdGFydFBoYXNlVGltZXIoZmliZXIsICdnZXRDaGlsZENvbnRleHQnKTtcbiAgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gIHN0b3BQaGFzZVRpbWVyKCk7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgfVxuICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLCBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bicsIGNvbnRleHRLZXkpIDogdm9pZCAwO1xuICB9XG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUsXG4gICAgLy8gSW4gcHJhY3RpY2UsIHRoZXJlIGlzIG9uZSBjYXNlIGluIHdoaWNoIHdlIHdvbid0IGdldCBhIHN0YWNrLiBJdCdzIHdoZW5cbiAgICAvLyBzb21lYm9keSBjYWxscyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcigpIGFuZCB3ZSBwcm9jZXNzXG4gICAgLy8gY29udGV4dCBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlLiBUaGUgc3RhY2sgd2lsbCBiZSBtaXNzaW5nXG4gICAgLy8gYmVjYXVzZSBpdCdzIG91dHNpZGUgb2YgdGhlIHJlY29uY2lsaWF0aW9uLCBhbmQgc28gdGhlIHBvaW50ZXIgaGFzIG5vdFxuICAgIC8vIGJlZW4gc2V0LiBUaGlzIGlzIHJhcmUgYW5kIGRvZXNuJ3QgbWF0dGVyLiBXZSdsbCBhbHNvIHJlbW92ZSB0aGF0IEFQSS5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0pO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NpZ24oe30sIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKCFpc0NvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vIFdlIHB1c2ggdGhlIGNvbnRleHQgYXMgZWFybHkgYXMgcG9zc2libGUgdG8gZW5zdXJlIHN0YWNrIGludGVncml0eS5cbiAgLy8gSWYgdGhlIGluc3RhbmNlIGRvZXMgbm90IGV4aXN0IHlldCwgd2Ugd2lsbCBwdXNoIG51bGwgYXQgZmlyc3QsXG4gIC8vIGFuZCByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayBsYXRlciB3aGVuIGludmFsaWRhdGluZyB0aGUgY29udGV4dC5cbiAgdmFyIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gUmVtZW1iZXIgdGhlIHBhcmVudCBjb250ZXh0IHNvIHdlIGNhbiBtZXJnZSB3aXRoIGl0IGxhdGVyLlxuICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkaWQtcGVyZm9ybS13b3JrIHZhbHVlIHRvIGF2b2lkIGluYWR2ZXJ0ZW50bHkgYmxvY2tpbmcgdXBkYXRlcy5cbiAgcHJldmlvdXNDb250ZXh0ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBkaWRDaGFuZ2UpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAhaW5zdGFuY2UgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBoYXZlIGFuIGluc3RhbmNlIGJ5IHRoaXMgcG9pbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGRpZENoYW5nZSkge1xuICAgIC8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4gICAgLy8gU2tpcCB0aGlzIGlmIHdlJ3JlIG5vdCB1cGRhdGluZyBkdWUgdG8gc0NVLlxuICAgIC8vIFRoaXMgYXZvaWRzIHVubmVjZXNzYXJpbHkgcmVjb21wdXRpbmcgbWVtb2l6ZWQgdmFsdWVzLlxuICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldmlvdXNDb250ZXh0KTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBvbGQgKG9yIGVtcHR5KSBjb250ZXh0IHdpdGggdGhlIG5ldyBvbmUuXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q29udGV4dCgpIHtcbiAgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gZW1wdHlPYmplY3Q7XG4gIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcikge1xuICAvLyBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgd2l0aCByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsgbm90IHN1cmUgaWYgaXRcbiAgLy8gbWFrZXMgc2Vuc2UgZWxzZXdoZXJlXG4gICEoaXNGaWJlck1vdW50ZWQoZmliZXIpICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgc3VidHJlZSBwYXJlbnQgdG8gYmUgYSBtb3VudGVkIGNsYXNzIGNvbXBvbmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICB2YXIgbm9kZSA9IGZpYmVyO1xuICB3aGlsZSAobm9kZS50YWcgIT09IEhvc3RSb290KSB7XG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAhcGFyZW50ID8gaW52YXJpYW50KGZhbHNlLCAnRm91bmQgdW5leHBlY3RlZCBkZXRhY2hlZCBzdWJ0cmVlIHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBub2RlID0gcGFyZW50O1xuICB9XG4gIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xufVxuXG52YXIgTm9Xb3JrID0gMDsgLy8gVE9ETzogVXNlIGFuIG9wYXF1ZSB0eXBlIG9uY2UgRVNMaW50IGV0IGFsIHN1cHBvcnQgdGhlIHN5bnRheFxuXG52YXIgU3luYyA9IDE7XG52YXIgTmV2ZXIgPSAyMTQ3NDgzNjQ3OyAvLyBNYXggaW50MzI6IE1hdGgucG93KDIsIDMxKSAtIDFcblxudmFyIFVOSVRfU0laRSA9IDEwO1xudmFyIE1BR0lDX05VTUJFUl9PRkZTRVQgPSAyO1xuXG4vLyAxIHVuaXQgb2YgZXhwaXJhdGlvbiB0aW1lIHJlcHJlc2VudHMgMTBtcy5cbmZ1bmN0aW9uIG1zVG9FeHBpcmF0aW9uVGltZShtcykge1xuICAvLyBBbHdheXMgYWRkIGFuIG9mZnNldCBzbyB0aGF0IHdlIGRvbid0IGNsYXNoIHdpdGggdGhlIG1hZ2ljIG51bWJlciBmb3IgTm9Xb3JrLlxuICByZXR1cm4gKG1zIC8gVU5JVF9TSVpFIHwgMCkgKyBNQUdJQ19OVU1CRVJfT0ZGU0VUO1xufVxuXG5mdW5jdGlvbiBleHBpcmF0aW9uVGltZVRvTXMoZXhwaXJhdGlvblRpbWUpIHtcbiAgcmV0dXJuIChleHBpcmF0aW9uVGltZSAtIE1BR0lDX05VTUJFUl9PRkZTRVQpICogVU5JVF9TSVpFO1xufVxuXG5mdW5jdGlvbiBjZWlsaW5nKG51bSwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiAoKG51bSAvIHByZWNpc2lvbiB8IDApICsgMSkgKiBwcmVjaXNpb247XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uSW5NcywgYnVja2V0U2l6ZU1zKSB7XG4gIHJldHVybiBjZWlsaW5nKGN1cnJlbnRUaW1lICsgZXhwaXJhdGlvbkluTXMgLyBVTklUX1NJWkUsIGJ1Y2tldFNpemVNcyAvIFVOSVRfU0laRSk7XG59XG5cbnZhciBOb0NvbnRleHQgPSAwO1xudmFyIEFzeW5jVXBkYXRlcyA9IDE7XG5cbntcbiAgdmFyIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuICAgIFxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxuLy8gQSBGaWJlciBpcyB3b3JrIG9uIGEgQ29tcG9uZW50IHRoYXQgbmVlZHMgdG8gYmUgZG9uZSBvciB3YXMgZG9uZS4gVGhlcmUgY2FuXG4vLyBiZSBtb3JlIHRoYW4gb25lIHBlciBjb21wb25lbnQuXG5cblxue1xuICB2YXIgZGVidWdDb3VudGVyID0gMTtcbn1cblxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIHtcbiAgLy8gSW5zdGFuY2VcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLnR5cGUgPSBudWxsO1xuICB0aGlzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgLy8gRmliZXJcbiAgdGhpc1sncmV0dXJuJ10gPSBudWxsO1xuICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgdGhpcy5zaWJsaW5nID0gbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG5cbiAgdGhpcy5yZWYgPSBudWxsO1xuXG4gIHRoaXMucGVuZGluZ1Byb3BzID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG5cbiAgdGhpcy5pbnRlcm5hbENvbnRleHRUYWcgPSBpbnRlcm5hbENvbnRleHRUYWc7XG5cbiAgLy8gRWZmZWN0c1xuICB0aGlzLmVmZmVjdFRhZyA9IE5vRWZmZWN0O1xuICB0aGlzLm5leHRFZmZlY3QgPSBudWxsO1xuXG4gIHRoaXMuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB0aGlzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIHtcbiAgICB0aGlzLl9kZWJ1Z0lEID0gZGVidWdDb3VudGVyKys7XG4gICAgdGhpcy5fZGVidWdTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBpZiAoIWhhc0JhZE1hcFBvbHlmaWxsICYmIHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG52YXIgY3JlYXRlRmliZXIgPSBmdW5jdGlvbiAodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZykge1xuICAvLyAkRmxvd0ZpeE1lOiB0aGUgc2hhcGVzIGFyZSBleGFjdCBoZXJlIGJ1dCBGbG93IGRvZXNuJ3QgbGlrZSBjb25zdHJ1Y3RvcnNcbiAgcmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbi8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBjdXJyZW50LmtleSwgY3VycmVudC5pbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cbiAgICB7XG4gICAgICAvLyBERVYtb25seSBmaWVsZHNcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEID0gY3VycmVudC5fZGVidWdJRDtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZSA9IGN1cnJlbnQuX2RlYnVnU291cmNlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IE5vRWZmZWN0O1xuXG4gICAgLy8gVGhlIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IG51bGw7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RSb290RmliZXIoKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RSb290LCBudWxsLCBOb0NvbnRleHQpO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgb3duZXIgPSBudWxsO1xuICB7XG4gICAgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IHZvaWQgMDtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGUsXG4gICAgICBrZXkgPSBlbGVtZW50LmtleTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmaWJlciA9IHNob3VsZENvbnN0cnVjdCh0eXBlKSA/IGNyZWF0ZUZpYmVyKENsYXNzQ29tcG9uZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZykgOiBjcmVhdGVGaWJlcihJbmRldGVybWluYXRlQ29tcG9uZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gICAgZmliZXIudHlwZSA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICBmaWJlci50eXBlID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBDdXJyZW50bHkgYXNzdW1lZCB0byBiZSBhIGNvbnRpbnVhdGlvbiBhbmQgdGhlcmVmb3JlIGlzIGEgZmliZXIgYWxyZWFkeS5cbiAgICAvLyBUT0RPOiBUaGUgeWllbGQgc3lzdGVtIGlzIGN1cnJlbnRseSBicm9rZW4gZm9yIHVwZGF0ZXMgaW4gc29tZSBjYXNlcy5cbiAgICAvLyBUaGUgcmVpZmllZCB5aWVsZCBzdG9yZXMgYSBmaWJlciwgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZmliZXIgdGhhdCBpcztcbiAgICAvLyB0aGUgY3VycmVudCBvciBhIHdvcmtJblByb2dyZXNzPyBXaGVuIHRoZSBjb250aW51YXRpb24gZ2V0cyByZW5kZXJlZCBoZXJlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyBpZiB3ZSBjYW4gcmV1c2UgdGhhdCBmaWJlciBvciBpZiB3ZSBuZWVkIHRvIGNsb25lIGl0LlxuICAgIC8vIFRoZXJlIGlzIHByb2JhYmx5IGEgY2xldmVyIHdheSB0byByZXN0cnVjdHVyZSB0aGlzLlxuICAgIGZpYmVyID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAge1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cbiAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWUob3duZXIpIDogbnVsbDtcbiAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKTtcbiAgfVxuXG4gIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEZyYWdtZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnRzO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgbnVsbCwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gY29udGVudDtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgZmliZXIudHlwZSA9ICdERUxFVEVEJztcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoQ2FsbENvbXBvbmVudCwgY2FsbC5rZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnR5cGUgPSBjYWxsLmhhbmRsZXI7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNhbGw7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoUmV0dXJuQ29tcG9uZW50LCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFBvcnRhbCwgcG9ydGFsLmtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuIHx8IFtdO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLCAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaHlkcmF0ZSkge1xuICAvLyBDeWNsaWMgY29uc3RydWN0aW9uLiBUaGlzIGNoZWF0cyB0aGUgdHlwZSBzeXN0ZW0gcmlnaHQgbm93IGJlY2F1c2VcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIoKTtcbiAgdmFyIHJvb3QgPSB7XG4gICAgY3VycmVudDogdW5pbml0aWFsaXplZEZpYmVyLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuICAgIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgaXNSZWFkeUZvckNvbW1pdDogZmFsc2UsXG4gICAgZmluaXNoZWRXb3JrOiBudWxsLFxuICAgIGNvbnRleHQ6IG51bGwsXG4gICAgcGVuZGluZ0NvbnRleHQ6IG51bGwsXG4gICAgaHlkcmF0ZTogaHlkcmF0ZSxcbiAgICBuZXh0U2NoZWR1bGVkUm9vdDogbnVsbFxuICB9O1xuICB1bmluaXRpYWxpemVkRmliZXIuc3RhdGVOb2RlID0gcm9vdDtcbiAgcmV0dXJuIHJvb3Q7XG59XG5cbnZhciBvbkNvbW1pdEZpYmVyUm9vdCA9IG51bGw7XG52YXIgb25Db21taXRGaWJlclVubW91bnQgPSBudWxsO1xudmFyIGhhc0xvZ2dlZEVycm9yID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNhdGNoRXJyb3JzKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhcmcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRydWUgJiYgIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IERldlRvb2xzIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBob29rID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgLy8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbiAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4NzdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgfVxuICAgIC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIHJlbmRlcmVySUQgPSBob29rLmluamVjdChpbnRlcm5hbHMpO1xuICAgIC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG4gICAgb25Db21taXRGaWJlclJvb3QgPSBjYXRjaEVycm9ycyhmdW5jdGlvbiAocm9vdCkge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCk7XG4gICAgfSk7XG4gICAgb25Db21taXRGaWJlclVubW91bnQgPSBjYXRjaEVycm9ycyhmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGZpYmVyKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gQ2F0Y2ggYWxsIGVycm9ycyBiZWNhdXNlIGl0IGlzIHVuc2FmZSB0byB0aHJvdyBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IERldlRvb2xzIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy4nLCBlcnIpO1xuICAgIH1cbiAgfVxuICAvLyBEZXZUb29scyBleGlzdHNcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdChyb290KSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyUm9vdChyb290KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFVubW91bnQoZmliZXIpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50KGZpYmVyKTtcbiAgfVxufVxuXG57XG4gIHZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG59XG5cbi8vIENhbGxiYWNrcyBhcmUgbm90IHZhbGlkYXRlZCB1bnRpbCBpbnZvY2F0aW9uXG5cblxuLy8gU2luZ2x5IGxpbmtlZC1saXN0IG9mIHVwZGF0ZXMuIFdoZW4gYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCwgaXQgaXMgYWRkZWQgdG9cbi8vIHRoZSBxdWV1ZSBvZiB0aGUgY3VycmVudCBmaWJlciBhbmQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoZSB0d28gcXVldWVzXG4vLyBhcmUgc2VwYXJhdGUgYnV0IHRoZXkgc2hhcmUgYSBwZXJzaXN0ZW50IHN0cnVjdHVyZS5cbi8vXG4vLyBEdXJpbmcgcmVjb25jaWxpYXRpb24sIHVwZGF0ZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlcixcbi8vIGJ1dCB0aGV5IHJlbWFpbiBvbiB0aGUgY3VycmVudCBmaWJlci4gVGhhdCBlbnN1cmVzIHRoYXQgaWYgYSB3b3JrLWluLXByb2dyZXNzXG4vLyBpcyBhYm9ydGVkLCB0aGUgYWJvcnRlZCB1cGRhdGVzIGFyZSByZWNvdmVyZWQgYnkgY2xvbmluZyBmcm9tIGN1cnJlbnQuXG4vL1xuLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYWx3YXlzIGEgc3Vic2V0IG9mIHRoZSBjdXJyZW50IHF1ZXVlLlxuLy9cbi8vIFdoZW4gdGhlIHRyZWUgaXMgY29tbWl0dGVkLCB0aGUgd29yay1pbi1wcm9ncmVzcyBiZWNvbWVzIHRoZSBjdXJyZW50LlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZVF1ZXVlKGJhc2VTdGF0ZSkge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBiYXNlU3RhdGUsXG4gICAgZXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBmaXJzdDogbnVsbCxcbiAgICBsYXN0OiBudWxsLFxuICAgIGNhbGxiYWNrTGlzdDogbnVsbCxcbiAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2UsXG4gICAgaXNJbml0aWFsaXplZDogZmFsc2VcbiAgfTtcbiAge1xuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgaWYgKHF1ZXVlLmxhc3QgPT09IG51bGwpIHtcbiAgICAvLyBRdWV1ZSBpcyBlbXB0eVxuICAgIHF1ZXVlLmZpcnN0ID0gcXVldWUubGFzdCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZS5sYXN0Lm5leHQgPSB1cGRhdGU7XG4gICAgcXVldWUubGFzdCA9IHVwZGF0ZTtcbiAgfVxuICBpZiAocXVldWUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBxdWV1ZS5leHBpcmF0aW9uVGltZSA+IHVwZGF0ZS5leHBpcmF0aW9uVGltZSkge1xuICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKSB7XG4gIC8vIFdlJ2xsIGhhdmUgYXQgbGVhc3Qgb25lIGFuZCBhdCBtb3N0IHR3byBkaXN0aW5jdCB1cGRhdGUgcXVldWVzLlxuICB2YXIgYWx0ZXJuYXRlRmliZXIgPSBmaWJlci5hbHRlcm5hdGU7XG4gIHZhciBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgaWYgKHF1ZXVlMSA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE86IFdlIGRvbid0IGtub3cgd2hhdCB0aGUgYmFzZSBzdGF0ZSB3aWxsIGJlIHVudGlsIHdlIGJlZ2luIHdvcmsuXG4gICAgLy8gSXQgZGVwZW5kcyBvbiB3aGljaCBmaWJlciBpcyB0aGUgbmV4dCBjdXJyZW50LiBJbml0aWFsaXplIHdpdGggYW4gZW1wdHlcbiAgICAvLyBiYXNlIHN0YXRlLCB0aGVuIHNldCB0byB0aGUgbWVtb2l6ZWRTdGF0ZSB3aGVuIHJlbmRlcmluZy4gTm90IHN1cGVyXG4gICAgLy8gaGFwcHkgd2l0aCB0aGlzIGFwcHJvYWNoLlxuICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gIH1cblxuICB2YXIgcXVldWUyID0gdm9pZCAwO1xuICBpZiAoYWx0ZXJuYXRlRmliZXIgIT09IG51bGwpIHtcbiAgICBxdWV1ZTIgPSBhbHRlcm5hdGVGaWJlci51cGRhdGVRdWV1ZTtcbiAgICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgICBxdWV1ZTIgPSBhbHRlcm5hdGVGaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKG51bGwpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWV1ZTIgPSBudWxsO1xuICB9XG4gIHF1ZXVlMiA9IHF1ZXVlMiAhPT0gcXVldWUxID8gcXVldWUyIDogbnVsbDtcblxuICAvLyBXYXJuIGlmIGFuIHVwZGF0ZSBpcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgYW4gdXBkYXRlciBmdW5jdGlvbi5cbiAge1xuICAgIGlmICgocXVldWUxLmlzUHJvY2Vzc2luZyB8fCBxdWV1ZTIgIT09IG51bGwgJiYgcXVldWUyLmlzUHJvY2Vzc2luZykgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG4gICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIHF1ZXVlLCBhZGQgdGhlIHVwZGF0ZSB0byB0aGF0IHF1ZXVlIGFuZCBleGl0LlxuICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBlaXRoZXIgcXVldWUgaXMgZW1wdHksIHdlIG5lZWQgdG8gYWRkIHRvIGJvdGggcXVldWVzLlxuICBpZiAocXVldWUxLmxhc3QgPT09IG51bGwgfHwgcXVldWUyLmxhc3QgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTIsIHVwZGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgYm90aCBsaXN0cyBhcmUgbm90IGVtcHR5LCB0aGUgbGFzdCB1cGRhdGUgaXMgdGhlIHNhbWUgZm9yIGJvdGggbGlzdHNcbiAgLy8gYmVjYXVzZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuIFNvLCB3ZSBzaG91bGQgb25seSBhcHBlbmQgdG8gb25lIG9mXG4gIC8vIHRoZSBsaXN0cy5cbiAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgLy8gQnV0IHdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIHRoZSBgbGFzdGAgcG9pbnRlciBvZiBxdWV1ZTIuXG4gIHF1ZXVlMi5sYXN0ID0gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRVcGRhdGVFeHBpcmF0aW9uVGltZShmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBDbGFzc0NvbXBvbmVudCAmJiBmaWJlci50YWcgIT09IEhvc3RSb290KSB7XG4gICAgcmV0dXJuIE5vV29yaztcbiAgfVxuICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE5vV29yaztcbiAgfVxuICByZXR1cm4gdXBkYXRlUXVldWUuZXhwaXJhdGlvblRpbWU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKSB7XG4gIHZhciBwYXJ0aWFsU3RhdGUgPSB1cGRhdGUucGFydGlhbFN0YXRlO1xuICBpZiAodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciB1cGRhdGVGbiA9IHBhcnRpYWxTdGF0ZTtcblxuICAgIC8vIEludm9rZSBzZXRTdGF0ZSBjYWxsYmFjayBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICB1cGRhdGVGbi5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlRm4uY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnRpYWxTdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCBpbnN0YW5jZSwgcHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudXBkYXRlUXVldWUgPT09IHF1ZXVlKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjcmVhdGUgYSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCBieSBjbG9uaW5nIHRoZSBjdXJyZW50IHF1ZXVlLlxuICAgIHZhciBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZXhwaXJhdGlvblRpbWU6IGN1cnJlbnRRdWV1ZS5leHBpcmF0aW9uVGltZSxcbiAgICAgIGZpcnN0OiBjdXJyZW50UXVldWUuZmlyc3QsXG4gICAgICBsYXN0OiBjdXJyZW50UXVldWUubGFzdCxcbiAgICAgIGlzSW5pdGlhbGl6ZWQ6IGN1cnJlbnRRdWV1ZS5pc0luaXRpYWxpemVkLFxuICAgICAgLy8gVGhlc2UgZmllbGRzIGFyZSBubyBsb25nZXIgdmFsaWQgYmVjYXVzZSB0aGV5IHdlcmUgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgICAvLyBSZXNldCB0aGVtLlxuICAgICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgICAgaGFzRm9yY2VVcGRhdGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICAvLyBTZXQgdGhpcyBmbGFnIHNvIHdlIGNhbiB3YXJuIGlmIHNldFN0YXRlIGlzIGNhbGxlZCBpbnNpZGUgdGhlIHVwZGF0ZVxuICAgIC8vIGZ1bmN0aW9uIG9mIGFub3RoZXIgc2V0U3RhdGUuXG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lLiBJZiB3ZSBza2lwIG92ZXIgYW55IHVwZGF0ZXMsIHdlJ2xsXG4gIC8vIGluY3JlYXNlIHRoaXMgYWNjb3JkaW5nbHkuXG4gIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRPRE86IFdlIGRvbid0IGtub3cgd2hhdCB0aGUgYmFzZSBzdGF0ZSB3aWxsIGJlIHVudGlsIHdlIGJlZ2luIHdvcmsuXG4gIC8vIEl0IGRlcGVuZHMgb24gd2hpY2ggZmliZXIgaXMgdGhlIG5leHQgY3VycmVudC4gSW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5XG4gIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgLy8gaGFwcHkgd2l0aCB0aGlzIGFwcHJvYWNoLlxuICB2YXIgc3RhdGUgPSB2b2lkIDA7XG4gIGlmIChxdWV1ZS5pc0luaXRpYWxpemVkKSB7XG4gICAgc3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIHF1ZXVlLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIHZhciBkb250TXV0YXRlUHJldlN0YXRlID0gdHJ1ZTtcbiAgdmFyIHVwZGF0ZSA9IHF1ZXVlLmZpcnN0O1xuICB2YXIgZGlkU2tpcCA9IGZhbHNlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFNraXAgaXQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBxdWV1ZS5leHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID4gdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IHVwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICAgIGRpZFNraXAgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIC8vIENvbnRpbnVlIHRvIHRoZSBuZXh0IHVwZGF0ZS5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiBubyBwcmV2aW91cyB1cGRhdGVzIHdlcmUgc2tpcHBlZCwgZHJvcCB0aGlzIHVwZGF0ZSBmcm9tIHRoZSBxdWV1ZSBieVxuICAgIC8vIGFkdmFuY2luZyB0aGUgaGVhZCBvZiB0aGUgbGlzdC5cbiAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgIHF1ZXVlLmZpcnN0ID0gdXBkYXRlLm5leHQ7XG4gICAgICBpZiAocXVldWUuZmlyc3QgPT09IG51bGwpIHtcbiAgICAgICAgcXVldWUubGFzdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlXG4gICAgdmFyIF9wYXJ0aWFsU3RhdGUgPSB2b2lkIDA7XG4gICAgaWYgKHVwZGF0ZS5pc1JlcGxhY2UpIHtcbiAgICAgIHN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBkb250TXV0YXRlUHJldlN0YXRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3BhcnRpYWxTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgaWYgKF9wYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgaWYgKGRvbnRNdXRhdGVQcmV2U3RhdGUpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lOiBJZGsgaG93IHRvIHR5cGUgdGhpcyBwcm9wZXJseS5cbiAgICAgICAgICBzdGF0ZSA9IF9hc3NpZ24oe30sIHN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZSA9IF9hc3NpZ24oc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5pc0ZvcmNlZCkge1xuICAgICAgcXVldWUuaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodXBkYXRlLmNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAvLyBBcHBlbmQgdG8gbGlzdCBvZiBjYWxsYmFja3MuXG4gICAgICB2YXIgX2NhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdDtcbiAgICAgIGlmIChfY2FsbGJhY2tMaXN0ID09PSBudWxsKSB7XG4gICAgICAgIF9jYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3QgPSBbXTtcbiAgICAgIH1cbiAgICAgIF9jYWxsYmFja0xpc3QucHVzaCh1cGRhdGUpO1xuICAgIH1cbiAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgfVxuXG4gIGlmIChxdWV1ZS5jYWxsYmFja0xpc3QgIT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ2FsbGJhY2s7XG4gIH0gZWxzZSBpZiAocXVldWUuZmlyc3QgPT09IG51bGwgJiYgIXF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSB7XG4gICAgLy8gVGhlIHF1ZXVlIGlzIGVtcHR5LiBXZSBjYW4gcmVzZXQgaXQuXG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICB9XG5cbiAgaWYgKCFkaWRTa2lwKSB7XG4gICAgZGlkU2tpcCA9IHRydWU7XG4gICAgcXVldWUuYmFzZVN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB7XG4gICAgLy8gTm8gbG9uZ2VyIHByb2Nlc3NpbmcuXG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdENhbGxiYWNrcyhxdWV1ZSwgY29udGV4dCkge1xuICB2YXIgY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICBpZiAoY2FsbGJhY2tMaXN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFNldCB0aGUgbGlzdCB0byBudWxsIHRvIG1ha2Ugc3VyZSB0aGV5IGRvbid0IGdldCBjYWxsZWQgbW9yZSB0aGFuIG9uY2UuXG4gIHF1ZXVlLmNhbGxiYWNrTGlzdCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHVwZGF0ZSA9IGNhbGxiYWNrTGlzdFtpXTtcbiAgICB2YXIgX2NhbGxiYWNrID0gdXBkYXRlLmNhbGxiYWNrO1xuICAgIC8vIFRoaXMgdXBkYXRlIG1pZ2h0IGJlIHByb2Nlc3NlZCBhZ2Fpbi4gQ2xlYXIgdGhlIGNhbGxiYWNrIHNvIGl0J3Mgb25seVxuICAgIC8vIGNhbGxlZCBvbmNlLlxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IG51bGw7XG4gICAgISh0eXBlb2YgX2NhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIF9jYWxsYmFjaykgOiB2b2lkIDA7XG4gICAgX2NhbGxiYWNrLmNhbGwoY29udGV4dCk7XG4gIH1cbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IHt9O1xuXG4gIHZhciB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4gIC8vIGl0IGNhdXNlcyBwcm9ibGVtcy4gVGhpcyBpcyBtZWFudCB0byBnaXZlIGEgbmljZXIgZXJyb3IgbWVzc2FnZSBmb3JcbiAgLy8gUmVhY3RET00xNS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihyZWFjdERPTTE2Q29tcG9uZW50LFxuICAvLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4gIC8vIGV4Y2VwdGlvbi5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZha2VJbnRlcm5hbEluc3RhbmNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgMTYrLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgYW5kIGFyZSBhdHRlbXB0aW5nIHRvIG5lc3QgYSBSZWFjdCAxNSB0cmVlIGluc2lkZSBhIFJlYWN0IDE2IHRyZWUgdXNpbmcgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIHdoaWNoIGlzblxcJ3Qgc3VwcG9ydGVkLiBUcnkgdG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggdG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS4nKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxudmFyIFJlYWN0RmliZXJDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uIChzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsIG1lbW9pemVQcm9wcywgbWVtb2l6ZVN0YXRlKSB7XG4gIC8vIENsYXNzIGNvbXBvbmVudCBzdGF0ZSB1cGRhdGVyXG4gIHZhciB1cGRhdGVyID0ge1xuICAgIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogcGFydGlhbFN0YXRlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfSxcbiAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBzdGF0ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IHRydWUsXG4gICAgICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfSxcbiAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBudWxsLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICAgIGlzRm9yY2VkOiB0cnVlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KSB7XG4gICAgaWYgKG9sZFByb3BzID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSB7XG4gICAgICAvLyBJZiB0aGUgd29ya0luUHJvZ3Jlc3MgYWxyZWFkeSBoYXMgYW4gVXBkYXRlIGVmZmVjdCwgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgICAgLy8gU2ltdWxhdGUgYW4gYXN5bmMgYmFpbG91dC9pbnRlcnJ1cHRpb24gYnkgaW52b2tpbmcgbGlmZWN5Y2xlIHR3aWNlLlxuICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgICBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgIH1cblxuICAgICAge1xuICAgICAgICB3YXJuaW5nKHNob3VsZFVwZGF0ZSAhPT0gdW5kZWZpbmVkLCAnJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIHJlbmRlclByZXNlbnQgPSBpbnN0YW5jZS5yZW5kZXI7XG5cbiAgICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm9HZXRJbml0aWFsU3RhdGVPbkVTNiA9ICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8IGluc3RhbmNlLnN0YXRlO1xuICAgICAgd2FybmluZyhub0dldEluaXRpYWxTdGF0ZU9uRVM2LCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgICAgdmFyIG5vR2V0RGVmYXVsdFByb3BzT25FUzYgPSAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZDtcbiAgICAgIHdhcm5pbmcobm9HZXREZWZhdWx0UHJvcHNPbkVTNiwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VQcm9wVHlwZXMgPSAhaW5zdGFuY2UucHJvcFR5cGVzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlUHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZUNvbnRleHRUeXBlcyA9ICFpbnN0YW5jZS5jb250ZXh0VHlwZXM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VDb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudFNob3VsZFVwZGF0ZSA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgICB2YXIgbm9Db21wb25lbnREaWRVbm1vdW50ID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50RGlkVW5tb3VudCwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICB3YXJuaW5nKGluc3RhbmNlLnByb3BzID09PSB1bmRlZmluZWQgfHwgIWhhc011dGF0ZWRQcm9wcywgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyBcInVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLCBuYW1lLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlRGVmYXVsdFByb3BzID0gIWluc3RhbmNlLmRlZmF1bHRQcm9wcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZURlZmF1bHRQcm9wcywgJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGlmIChzdGF0ZSAmJiAodHlwZW9mIHN0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KHN0YXRlKSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3YXJuaW5nKHR5cGVvZiB3b3JrSW5Qcm9ncmVzcy50eXBlLmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JywgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gJyArICd1c2UgZ2V0Q2hpbGRDb250ZXh0KCkuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0SW5wdXRQb2ludGVycyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnVwZGF0ZXIgPSB1cGRhdGVyO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgIC8vIFRoZSBpbnN0YW5jZSBuZWVkcyBhY2Nlc3MgdG8gdGhlIGZpYmVyIHNvIHRoYXQgaXQgY2FuIHNjaGVkdWxlIHVwZGF0ZXNcbiAgICBzZXQoaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICB7XG4gICAgICBpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcHJvcHMpIHtcbiAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIG5lZWRzQ29udGV4dCA9IGlzQ29udGV4dENvbnN1bWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgY29udGV4dCA9IG5lZWRzQ29udGV4dCA/IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkgOiBlbXB0eU9iamVjdDtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7XG4gICAgYWRvcHRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gICAgLy8gUmVhY3RGaWJlckNvbnRleHQgdXN1YWxseSB1cGRhdGVzIHRoaXMgY2FjaGUgYnV0IGNhbid0IGZvciBuZXdseS1jcmVhdGVkIGluc3RhbmNlcy5cbiAgICBpZiAobmVlZHNDb250ZXh0KSB7XG4gICAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsTW91bnQnKTtcbiAgICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgLy8gU2ltdWxhdGUgYW4gYXN5bmMgYmFpbG91dC9pbnRlcnJ1cHRpb24gYnkgaW52b2tpbmcgbGlmZWN5Y2xlIHR3aWNlLlxuICAgIGlmIChkZWJ1Z1JlbmRlclBoYXNlU2lkZUVmZmVjdHMpIHtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgIH1cblxuICAgIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICB9XG4gICAgICB1cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXdDb250ZXh0KSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAvLyBTaW11bGF0ZSBhbiBhc3luYyBiYWlsb3V0L2ludGVycnVwdGlvbiBieSBpbnZva2luZyBsaWZlY3ljbGUgdHdpY2UuXG4gICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgICAge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnO1xuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudFtjb21wb25lbnROYW1lXSkge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEludm9rZXMgdGhlIG1vdW50IGxpZmUtY3ljbGVzIG9uIGEgcHJldmlvdXNseSBuZXZlciByZW5kZXJlZCBpbnN0YW5jZS5cbiAgZnVuY3Rpb24gbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAge1xuICAgICAgY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGUgfHwgbnVsbDtcblxuICAgIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICAhcHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBtdXN0IGJlIHBlbmRpbmcgcHJvcHMgZm9yIGFuIGluaXRpYWwgbW91bnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICAgIGluc3RhbmNlLnByb3BzID0gcHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gc3RhdGU7XG4gICAgaW5zdGFuY2UucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGVuYWJsZUFzeW5jU3VidHJlZUFQSSAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlICE9IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQgPT09IHRydWUpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmludGVybmFsQ29udGV4dFRhZyB8PSBBc3luY1VwZGF0ZXM7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgICAgIC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG4gICAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIGluc3RhbmNlLCBwcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBvbiBhIHByZWV4aXN0aW5nIGNsYXNzIGluc3RhbmNlLiBSZXR1cm5zIGZhbHNlIGlmIGEgcmVzdW1lZCByZW5kZXJcbiAgLy8gY291bGQgYmUgcmV1c2VkLlxuICAvLyBmdW5jdGlvbiByZXN1bWVNb3VudENsYXNzSW5zdGFuY2UoXG4gIC8vICAgd29ya0luUHJvZ3Jlc3M6IEZpYmVyLFxuICAvLyAgIHByaW9yaXR5TGV2ZWw6IFByaW9yaXR5TGV2ZWwsXG4gIC8vICk6IGJvb2xlYW4ge1xuICAvLyAgIGNvbnN0IGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAvLyAgIHJlc2V0SW5wdXRQb2ludGVycyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gIC8vICAgbGV0IG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgLy8gICBsZXQgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIC8vICAgaWYgKCFuZXdQcm9wcykge1xuICAvLyAgICAgLy8gSWYgdGhlcmUgaXNuJ3QgYW55IG5ldyBwcm9wcywgdGhlbiB3ZSdsbCByZXVzZSB0aGUgbWVtb2l6ZWQgcHJvcHMuXG4gIC8vICAgICAvLyBUaGlzIGNvdWxkIGJlIGZyb20gYWxyZWFkeSBjb21wbGV0ZWQgd29yay5cbiAgLy8gICAgIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgLy8gICAgIGludmFyaWFudChcbiAgLy8gICAgICAgbmV3UHJvcHMgIT0gbnVsbCxcbiAgLy8gICAgICAgJ1RoZXJlIHNob3VsZCBhbHdheXMgYmUgcGVuZGluZyBvciBtZW1vaXplZCBwcm9wcy4gVGhpcyBlcnJvciBpcyAnICtcbiAgLy8gICAgICAgICAnbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuICAvLyAgIGNvbnN0IG5ld1VubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gIC8vICAgY29uc3QgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgLy8gICBjb25zdCBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgLy8gICBjb25zdCBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG5cbiAgLy8gICBpZiAoXG4gIC8vICAgICB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAvLyAgICAgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXdDb250ZXh0KVxuICAvLyAgICkge1xuICAvLyAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIG5ld0NvbnRleHQsXG4gIC8vICAgICApO1xuICAvLyAgIH1cblxuICAvLyAgIC8vIFByb2Nlc3MgdGhlIHVwZGF0ZSBxdWV1ZSBiZWZvcmUgY2FsbGluZyBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAgLy8gICBjb25zdCB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAvLyAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICB1cGRhdGVRdWV1ZSxcbiAgLy8gICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVE9ETzogU2hvdWxkIHdlIGRlYWwgd2l0aCBhIHNldFN0YXRlIHRoYXQgaGFwcGVuZWQgYWZ0ZXIgdGhlIGxhc3RcbiAgLy8gICAvLyBjb21wb25lbnRXaWxsTW91bnQgYW5kIGJlZm9yZSB0aGlzIGNvbXBvbmVudFdpbGxNb3VudD8gUHJvYmFibHlcbiAgLy8gICAvLyB1bnN1cHBvcnRlZCBhbnl3YXkuXG5cbiAgLy8gICBpZiAoXG4gIC8vICAgICAhY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUoXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld0NvbnRleHQsXG4gIC8vICAgICApXG4gIC8vICAgKSB7XG4gIC8vICAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gIC8vICAgICAvLyB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQuXG4gIC8vICAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAvLyAgICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuICAvLyAgICAgcmV0dXJuIGZhbHNlO1xuICAvLyAgIH1cblxuICAvLyAgIC8vIFVwZGF0ZSB0aGUgaW5wdXQgcG9pbnRlcnMgbm93IHNvIHRoYXQgdGhleSBhcmUgY29ycmVjdCB3aGVuIHdlIGNhbGxcbiAgLy8gICAvLyBjb21wb25lbnRXaWxsTW91bnRcbiAgLy8gICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAvLyAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIC8vICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgLy8gICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAvLyAgICAgLy8gY29tcG9uZW50V2lsbE1vdW50IG1heSBoYXZlIGNhbGxlZCBzZXRTdGF0ZS4gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlLlxuICAvLyAgICAgY29uc3QgbmV3VXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgLy8gICAgIGlmIChuZXdVcGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAvLyAgICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgICBuZXdVcGRhdGVRdWV1ZSxcbiAgLy8gICAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgICApO1xuICAvLyAgICAgfVxuICAvLyAgIH1cblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIC8vICAgfVxuXG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcblxuICAvLyAgIHJldHVybiB0cnVlO1xuICAvLyB9XG5cbiAgLy8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmVuJ3QgYW55IG5ldyBwcm9wcywgdGhlbiB3ZSdsbCByZXVzZSB0aGUgbWVtb2l6ZWQgcHJvcHMuXG4gICAgICAvLyBUaGlzIGNvdWxkIGJlIGZyb20gYWxyZWFkeSBjb21wbGV0ZWQgd29yay5cbiAgICAgIG5ld1Byb3BzID0gb2xkUHJvcHM7XG4gICAgICAhKG5ld1Byb3BzICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBwZW5kaW5nIG9yIG1lbW9pemVkIHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gICAgdmFyIG5ld1VubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gICAgLy8gTm90ZTogRHVyaW5nIHRoZXNlIGxpZmUtY3ljbGVzLCBpbnN0YW5jZS5wcm9wcy9pbnN0YW5jZS5zdGF0ZSBhcmUgd2hhdFxuICAgIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gICAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpKSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXdDb250ZXh0KTtcbiAgICB9XG5cbiAgICAvLyBDb21wdXRlIHRoZSBuZXh0IHN0YXRlIHVzaW5nIHRoZSBtZW1vaXplZCBzdGF0ZSBhbmQgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIC8vIFRPRE86IFByZXZpb3VzIHN0YXRlIGNhbiBiZSBudWxsLlxuICAgIHZhciBuZXdTdGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIG5ld1Byb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5ld1N0YXRlID0gb2xkU3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgISh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkpIHtcbiAgICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFVwZGF0ZScpO1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCk7XG4gICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAgICAgLy8gU2ltdWxhdGUgYW4gYXN5bmMgYmFpbG91dC9pbnRlcnJ1cHRpb24gYnkgaW52b2tpbmcgbGlmZWN5Y2xlIHR3aWNlLlxuICAgICAgICBpZiAoZGVidWdSZW5kZXJQaGFzZVNpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJuZWQgZmFsc2UsIHdlIHNob3VsZCBzdGlsbCB1cGRhdGUgdGhlXG4gICAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcyk7XG4gICAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdGhlIGV4aXN0aW5nIGluc3RhbmNlJ3Mgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCBwb2ludGVycyBldmVuXG4gICAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYWRvcHRDbGFzc0luc3RhbmNlOiBhZG9wdENsYXNzSW5zdGFuY2UsXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZTogY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICBtb3VudENsYXNzSW5zdGFuY2U6IG1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICAvLyByZXN1bWVNb3VudENsYXNzSW5zdGFuY2UsXG4gICAgdXBkYXRlQ2xhc3NJbnN0YW5jZTogdXBkYXRlQ2xhc3NJbnN0YW5jZVxuICB9O1xufTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBoYXNTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ107XG5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpIDogMHhlYWM4O1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QucmV0dXJuJykgOiAweGVhYzk7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBoYXNTeW1ib2wgPyBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSA6IDB4ZWFjYTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gaGFzU3ltYm9sID8gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSA6IDB4ZWFjYjtcblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuXG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG57XG4gIHZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG4gIC8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9cbiAgdmFyIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICB2YXIgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG5cbiAgdmFyIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09PSBudWxsIHx8IHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjaGlsZC5fc3RvcmUgfHwgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCB8fCBjaGlsZC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAhKHR5cGVvZiBjaGlsZC5fc3RvcmUgPT09ICdvYmplY3QnKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAgIHdhcm5pbmcoZmFsc2UsICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yICcgKyAnbW9yZSBpbmZvcm1hdGlvbi4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgfTtcbn1cblxudmFyIGlzQXJyYXkkMSA9IEFycmF5LmlzQXJyYXk7XG5cbmZ1bmN0aW9uIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGVsZW1lbnQuX293bmVyKSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBpbnN0ID0gdm9pZCAwO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICAgICEob3duZXJGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiB2b2lkIDA7XG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICAgICFpbnN0ID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBvd25lciBmb3Igc3RyaW5nIHJlZiAlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgICB2YXIgc3RyaW5nUmVmID0gJycgKyBtaXhlZFJlZjtcbiAgICAgIC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IG51bGwgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cbiAgICAgIHZhciByZWYgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlbGV0ZSByZWZzW3N0cmluZ1JlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmc1tzdHJpbmdSZWZdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgICEodHlwZW9mIG1peGVkUmVmID09PSAnc3RyaW5nJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZy4nKSA6IHZvaWQgMDtcbiAgICAgICFlbGVtZW50Ll9vd25lciA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKCVzKSBidXQgbm8gb3duZXIgd2FzIHNldC4gWW91IG1heSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQuIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaXhlZFJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAocmV0dXJuRmliZXIudHlwZSAhPT0gJ3RleHRhcmVhJykge1xuICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgIHtcbiAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBuZXdDaGlsZCwgYWRkZW5kdW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkZ1bmN0aW9uVHlwZSgpIHtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG5cbiAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIHdhcm5pbmcoZmFsc2UsICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcbn1cblxuLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBEZWxldGlvbnMgYXJlIGFkZGVkIGluIHJldmVyc2VkIG9yZGVyIHNvIHdlIGFkZCBpdCB0byB0aGUgZnJvbnQuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlIHJldHVybiBmaWJlcidzIGVmZmVjdCBsaXN0IGlzIGVtcHR5IGV4Y2VwdCBmb3JcbiAgICAvLyBkZWxldGlvbnMsIHNvIHdlIGNhbiBqdXN0IGFwcGVuZCB0aGUgZGVsZXRpb24gdG8gdGhlIGxpc3QuIFRoZSByZW1haW5pbmdcbiAgICAvLyBlZmZlY3RzIGFyZW4ndCBhZGRlZCB1bnRpbCB0aGUgY29tcGxldGUgcGhhc2UuIE9uY2Ugd2UgaW1wbGVtZW50XG4gICAgLy8gcmVzdW1pbmcsIHRoaXMgbWF5IG5vdCBiZSB0cnVlLlxuICAgIHZhciBsYXN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdDtcbiAgICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgICAgbGFzdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgICBjaGlsZFRvRGVsZXRlLm5leHRFZmZlY3QgPSBudWxsO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBGb3IgdGhlIHNob3VsZENsb25lIGNhc2UsIHRoaXMgY291bGQgYmUgbWljcm8tb3B0aW1pemVkIGEgYml0IGJ5XG4gICAgLy8gYXNzdW1pbmcgdGhhdCBhZnRlciB0aGUgZmlyc3QgY2hpbGQgd2UndmUgYWxyZWFkeSBhZGRlZCBldmVyeXRoaW5nLlxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkVG9EZWxldGUgIT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG5ldyBNYXAoKTtcblxuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGV4aXN0aW5nQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChleGlzdGluZ0NoaWxkLmtleSAhPT0gbnVsbCkge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmtleSwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBleGlzdGluZ0NoaWxkcmVuLnNldChleGlzdGluZ0NoaWxkLmluZGV4LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH1cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBXZSBjdXJyZW50bHkgc2V0IHNpYmxpbmcgdG8gbnVsbCBhbmQgaW5kZXggdG8gMCBoZXJlIGJlY2F1c2UgaXQgaXMgZWFzeVxuICAgIC8vIHRvIGZvcmdldCB0byBkbyBiZWZvcmUgcmV0dXJuaW5nIGl0LiBFLmcuIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuXG4gICAgdmFyIGNsb25lID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICBjbG9uZS5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgICB2YXIgY3VycmVudCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZEluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpdGVtIGNhbiBzdGF5IGluIHBsYWNlLlxuICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uLlxuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZWZmZWN0VGFnID0gUGxhY2VtZW50O1xuICAgIH1cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC50eXBlID09PSBlbGVtZW50LnR5cGUpIHtcbiAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAge1xuICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC5yZWYgPSBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2FsbChyZXR1cm5GaWJlciwgY3VycmVudCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUT0RPOiBTaG91bGQgdGhpcyBhbHNvIGNvbXBhcmUgaGFuZGxlciB0byBkZXRlcm1pbmUgd2hldGhlciB0byByZXVzZT9cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gQ2FsbENvbXBvbmVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUNhbGwoY2FsbCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGNhbGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVJldHVybihyZXR1cm5GaWJlciwgY3VycmVudCwgcmV0dXJuTm9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZC50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFBvcnRhbCB8fCBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fCBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lLCBrZXkpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmcmFnbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCgnJyArIG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICB2YXIgX2NyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgbmV3Q2hpbGQua2V5KTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfY3JlYXRlZDIgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyLnJlZiA9IGNvZXJjZVJlZihudWxsLCBuZXdDaGlsZCk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkMlsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkMyA9IGNyZWF0ZUZpYmVyRnJvbUNhbGwobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQzWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQ0ID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkNC50eXBlID0gbmV3Q2hpbGQudmFsdWU7XG4gICAgICAgICAgICBfY3JlYXRlZDRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ0O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDUgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ1WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkNTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfY3JlYXRlZDYgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICAgIF9jcmVhdGVkNlsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkNjtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBVcGRhdGUgdGhlIGZpYmVyIGlmIHRoZSBrZXlzIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIG51bGwuXG5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgb2xkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhXG4gICAgICAgICAgICAvLyB5aWVsZC5cbiAgICAgICAgICAgIGlmIChrZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVJldHVybihyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSB0ZXh0IG5vZGVzLCB0aGV5IG1hdGNoLlxuICAgICAgdmFyIG1hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgIHJldHVybiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgbWF0Y2hlZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwgbmV3Q2hpbGQua2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHJldHVybnMsIHRoZXkgbWF0Y2guXG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjMgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMywgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjQgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyNCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyNSA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyNSwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXYXJucyBpZiB0aGVyZSBpcyBhIGR1cGxpY2F0ZSBvciBtaXNzaW5nIGtleVxuICAgKi9cbiAgZnVuY3Rpb24gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcgfHwgY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkKTtcbiAgICAgICAgICB2YXIga2V5ID0gY2hpbGQua2V5O1xuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWtub3duS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLiVzJywga2V5LCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbm93bktleXM7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkFycmF5KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aHMgZW5kcyBzaW5jZSB3ZVxuICAgIC8vIGRvbid0IGhhdmUgYmFja3BvaW50ZXJzIG9uIGZpYmVycy4gSSdtIHRyeWluZyB0byBzZWUgaG93IGZhciB3ZSBjYW4gZ2V0XG4gICAgLy8gd2l0aCB0aGF0IG1vZGVsLiBJZiBpdCBlbmRzIHVwIG5vdCBiZWluZyB3b3J0aCB0aGUgdHJhZGVvZmZzLCB3ZSBjYW5cbiAgICAvLyBhZGQgaXQgbGF0ZXIuXG5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG5cbiAgICAvLyBJbiB0aGlzIGZpcnN0IGl0ZXJhdGlvbiwgd2UnbGwganVzdCBsaXZlIHdpdGggaGl0dGluZyB0aGUgYmFkIGNhc2VcbiAgICAvLyAoYWRkaW5nIGV2ZXJ5dGhpbmcgdG8gYSBNYXApIGluIGZvciBldmVyeSBpbnNlcnQvbW92ZS5cblxuICAgIC8vIElmIHlvdSBjaGFuZ2UgdGhpcyBjb2RlLCBhbHNvIHVwZGF0ZSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKCkgd2hpY2hcbiAgICAvLyB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobS5cblxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChuZXdJZHggPT09IG5ld0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgICB2YXIgX25ld0ZpYmVyID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKCFfbmV3RmliZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyMiA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKF9uZXdGaWJlcjIpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyMi5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuWydkZWxldGUnXShfbmV3RmliZXIyLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjIua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuSXRlcmFibGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyByZWNvbmNpbGVDaGlsZHJlbkFycmF5KCksXG4gICAgLy8gYnV0IHVzaW5nIHRoZSBpdGVyYXRvciBpbnN0ZWFkLlxuXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gb2JqZWN0IGlzIG5vdCBhbiBpdGVyYWJsZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHtcbiAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHBvc3NpYmxlTWFwID0gbmV3Q2hpbGRyZW5JdGVyYWJsZTtcbiAgICAgICAgaWYgKHBvc3NpYmxlTWFwLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cy4gQ29udmVydCBpdCB0byBhIHNlcXVlbmNlL2l0ZXJhYmxlIG9mIGtleWVkICcgKyAnUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgLy8gV2UnbGwgZ2V0IGEgZGlmZmVyZW50IGl0ZXJhdG9yIGxhdGVyIGZvciB0aGUgbWFpbiBwYXNzLlxuICAgICAgdmFyIF9uZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAgIGlmIChfbmV3Q2hpbGRyZW4pIHtcbiAgICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgICAgIHZhciBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgICAgIGZvciAoOyAhX3N0ZXAuZG9uZTsgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBuZXdDaGlsZHJlbiA9IGl0ZXJhdG9yRm4uY2FsbChuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKG5ld0NoaWxkcmVuICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAoIW9sZEZpYmVyKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICBpZiAob2xkRmliZXIgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgc2xvdCwgYnV0IHdlIGRpZG4ndCByZXVzZSB0aGUgZXhpc3RpbmcgZmliZXIsIHNvIHdlXG4gICAgICAgICAgLy8gbmVlZCB0byBkZWxldGUgdGhlIGV4aXN0aW5nIGNoaWxkLlxuICAgICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBuZXdGaWJlcjtcbiAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgIH1cblxuICAgIGlmIChzdGVwLmRvbmUpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9uZXdGaWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMztcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMztcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI0O1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgICAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG4gICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gRnJhZ21lbnQgPyBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgOiBjaGlsZC50eXBlID09PSBlbGVtZW50LnR5cGUpIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA/IGVsZW1lbnQucHJvcHMuY2hpbGRyZW4gOiBlbGVtZW50LnByb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGNoaWxkLCBlbGVtZW50KTtcbiAgICAgICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBleGlzdGluZy5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9jcmVhdGVkNyA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBfY3JlYXRlZDcucmVmID0gY29lcmNlUmVmKGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50KTtcbiAgICAgIF9jcmVhdGVkN1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBfY3JlYXRlZDc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlQ2FsbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGNhbGwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGNhbGwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IENhbGxDb21wb25lbnQpIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGNhbGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUNhbGwoY2FsbCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVJldHVybihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHJldHVybk5vZGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHlpZWxkcyBzaW5jZSB0aGV5J3JlIHN0YXRlbGVzcy5cbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC50YWcgPT09IFJldHVybkNvbXBvbmVudCkge1xuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGV4aXN0aW5nLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IHBvcnRhbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gSG9zdFBvcnRhbCAmJiBjaGlsZC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyA9PT0gcG9ydGFsLmNvbnRhaW5lckluZm8gJiYgY2hpbGQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uID09PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIC8vIFRoaXMgQVBJIHdpbGwgdGFnIHRoZSBjaGlsZHJlbiB3aXRoIHRoZSBzaWRlLWVmZmVjdCBvZiB0aGUgcmVjb25jaWxpYXRpb25cbiAgLy8gaXRzZWxmLiBUaGV5IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHNpZGUtZWZmZWN0IGxpc3QgYXMgd2UgcGFzcyB0aHJvdWdoIHRoZVxuICAvLyBjaGlsZHJlbiBhbmQgdGhlIHBhcmVudC5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnMocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCByZWN1cnNpdmUuXG4gICAgLy8gSWYgdGhlIHRvcCBsZXZlbCBpdGVtIGlzIGFuIGFycmF5LCB3ZSB0cmVhdCBpdCBhcyBhIHNldCBvZiBjaGlsZHJlbixcbiAgICAvLyBub3QgYXMgYSBmcmFnbWVudC4gTmVzdGVkIGFycmF5cyBvbiB0aGUgb3RoZXIgaGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICAvLyBmcmFnbWVudCBub2Rlcy4gUmVjdXJzaW9uIGhhcHBlbnMgYXQgdGhlIG5vcm1hbCBmbG93LlxuXG4gICAgLy8gSGFuZGxlIHRvcCBsZXZlbCB1bmtleWVkIGZyYWdtZW50cyBhcyBpZiB0aGV5IHdlcmUgYXJyYXlzLlxuICAgIC8vIFRoaXMgbGVhZHMgdG8gYW4gYW1iaWd1aXR5IGJldHdlZW4gPD57Wy4uLl19PC8+IGFuZCA8Pi4uLjwvPi5cbiAgICAvLyBXZSB0cmVhdCB0aGUgYW1iaWd1b3VzIGNhc2VzIGFib3ZlIHRoZSBzYW1lLlxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsKSB7XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsO1xuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgdGhlIG5ldyBjaGlsZCBpcyB1bmRlZmluZWQsIGFuZCB0aGUgcmV0dXJuIGZpYmVyIGlzIGEgY29tcG9zaXRlXG4gICAgICAvLyBjb21wb25lbnQsIHRocm93IGFuIGVycm9yLiBJZiBGaWJlciByZXR1cm4gdHlwZXMgYXJlIGRpc2FibGVkLFxuICAgICAgLy8gd2UgYWxyZWFkeSB0aHJldyBhYm92ZS5cbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBuZXh0IGNhc2UsIHdoaWNoIGhhbmRsZXMgYm90aFxuICAgICAgICAvLyBmdW5jdGlvbnMgYW5kIGNsYXNzZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lZCBuby1mYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG4gICAgcmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gIH1cblxuICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnM7XG59XG5cbnZhciByZWNvbmNpbGVDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcih0cnVlKTtcbnZhciBtb3VudENoaWxkRmliZXJzID0gQ2hpbGRSZWNvbmNpbGVyKGZhbHNlKTtcblxuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAhKGN1cnJlbnQgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IGN1cnJlbnQuY2hpbGQpID8gaW52YXJpYW50KGZhbHNlLCAnUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpIDogdm9pZCAwO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuXG4gIG5ld0NoaWxkWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gICAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cbiAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG59XG5cbntcbiAgdmFyIHdhcm5lZEFib3V0U3RhdGVsZXNzUmVmcyA9IHt9O1xufVxuXG52YXIgUmVhY3RGaWJlckJlZ2luV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlID0gY29uZmlnLnNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU7XG4gIHZhciBwdXNoSG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5wdXNoSG9zdENvbnRleHQsXG4gICAgICBwdXNoSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGFpbmVyO1xuICB2YXIgZW50ZXJIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQuZW50ZXJIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LnJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ2xhc3NDb21wbyA9IFJlYWN0RmliZXJDbGFzc0NvbXBvbmVudChzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsIG1lbW9pemVQcm9wcywgbWVtb2l6ZVN0YXRlKSxcbiAgICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5hZG9wdENsYXNzSW5zdGFuY2UsXG4gICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gICAgICBtb3VudENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8ubW91bnRDbGFzc0luc3RhbmNlLFxuICAgICAgdXBkYXRlQ2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby51cGRhdGVDbGFzc0luc3RhbmNlO1xuXG4gIC8vIFRPRE86IFJlbW92ZSB0aGlzIGFuZCB1c2UgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGRpcmVjdGx5LlxuXG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbikge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgICAvLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbiAgICAgIC8vIHdlIHdpbGwgYWRkIHRoZW0gYWxsIHRvIHRoZSBjaGlsZCBiZWZvcmUgaXQgZ2V0cyByZW5kZXJlZC4gVGhhdCBtZWFuc1xuICAgICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAgIC8vIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYW55IHdvcmsgb24gdGhlc2UgY2hpbGRyZW4uIFRoZXJlZm9yZSwgd2UgdXNlXG4gICAgICAvLyB0aGUgY2xvbmUgYWxnb3JpdGhtIHRvIGNyZWF0ZSBhIGNvcHkgb2YgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuLlxuXG4gICAgICAvLyBJZiB3ZSBoYWQgYW55IHByb2dyZXNzZWQgd29yayBhbHJlYWR5LCB0aGF0IGlzIGludmFsaWQgYXQgdGhpcyBwb2ludCBzb1xuICAgICAgLy8gbGV0J3MgdGhyb3cgaXQgb3V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBpZiAocmVmICE9PSBudWxsICYmICghY3VycmVudCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKSkge1xuICAgICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgZm4gPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwpIHtcbiAgICAgICAgbmV4dFByb3BzID0gbWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogY29uc2lkZXIgYnJpbmdpbmcgZm4uc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkgYmFjay5cbiAgICAgIC8vIEl0IHVzZWQgdG8gYmUgaGVyZS5cbiAgICB9XG5cbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gZm4obmV4dFByb3BzLCBjb250ZXh0KTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICAgIH1cbiAgICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgaWYgKCF3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpIHtcbiAgICAgICAgLy8gSW4gdGhlIGluaXRpYWwgcGFzcyB3ZSBtaWdodCBuZWVkIHRvIGNvbnN0cnVjdCB0aGUgaW5zdGFuY2UuXG4gICAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyk7XG4gICAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpO1xuICAgICAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICAgICAgLy8gc2hvdWxkVXBkYXRlID0gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFVwZGF0ZSA9IHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCkge1xuICAgIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoIXNob3VsZFVwZGF0ZSkge1xuICAgICAgLy8gQ29udGV4dCBwcm92aWRlcnMgc2hvdWxkIGRlZmVyIHRvIHNDVSBmb3IgcmVuZGVyaW5nXG4gICAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAvLyBSZXJlbmRlclxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgaWYgKGRlYnVnUmVuZGVyUGhhc2VTaWRlRWZmZWN0cykge1xuICAgICAgICBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICAgIH1cbiAgICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgLy8gTWVtb2l6ZSBwcm9wcyBhbmQgc3RhdGUgdXNpbmcgdGhlIHZhbHVlcyB3ZSBqdXN0IHVzZWQgdG8gcmVuZGVyLlxuICAgIC8vIFRPRE86IFJlc3RydWN0dXJlIHNvIHdlIG5ldmVyIHJlYWQgdmFsdWVzIGZyb20gdGhlIGluc3RhbmNlLlxuICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2Uuc3RhdGUpO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UucHJvcHMpO1xuXG4gICAgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG4gICAgaWYgKGhhc0NvbnRleHQpIHtcbiAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAocm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5wZW5kaW5nQ29udGV4dCwgcm9vdC5wZW5kaW5nQ29udGV4dCAhPT0gcm9vdC5jb250ZXh0KTtcbiAgICB9IGVsc2UgaWYgKHJvb3QuY29udGV4dCkge1xuICAgICAgLy8gU2hvdWxkIGFsd2F5cyBiZSBzZXRcbiAgICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGV4dCwgZmFsc2UpO1xuICAgIH1cbiAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICB2YXIgc3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBudWxsLCBudWxsLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAocHJldlN0YXRlID09PSBzdGF0ZSkge1xuICAgICAgICAvLyBJZiB0aGUgc3RhdGUgaXMgdGhlIHNhbWUgYXMgYmVmb3JlLCB0aGF0J3MgYSBiYWlsb3V0IGJlY2F1c2Ugd2UgaGFkXG4gICAgICAgIC8vIG5vIHdvcmsgdGhhdCBleHBpcmVzIGF0IHRoaXMgdGltZS5cbiAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnQ7XG4gICAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIGlmICgoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSAmJiByb290Lmh5ZHJhdGUgJiYgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgY3VycmVudCBjaGlsZHJlbiB0aGlzIG1pZ2h0IGJlIHRoZSBmaXJzdCBwYXNzLlxuICAgICAgICAvLyBXZSBhbHdheXMgdHJ5IHRvIGh5ZHJhdGUuIElmIHRoaXMgaXNuJ3QgYSBoeWRyYXRpb24gcGFzcyB0aGVyZSB3b24ndFxuICAgICAgICAvLyBiZSBhbnkgY2hpbGRyZW4gdG8gaHlkcmF0ZSB3aGljaCBpcyBlZmZlY3RpdmVseSB0aGUgc2FtZSB0aGluZyBhc1xuICAgICAgICAvLyBub3QgaHlkcmF0aW5nLlxuXG4gICAgICAgIC8vIFRoaXMgaXMgYSBiaXQgb2YgYSBoYWNrLiBXZSB0cmFjayB0aGUgaG9zdCByb290IGFzIGEgcGxhY2VtZW50IHRvXG4gICAgICAgIC8vIGtub3cgdGhhdCB3ZSdyZSBjdXJyZW50bHkgaW4gYSBtb3VudGluZyBzdGF0ZS4gVGhhdCB3YXkgaXNNb3VudGVkXG4gICAgICAgIC8vIHdvcmtzIGFzIGV4cGVjdGVkLiBXZSBtdXN0IHJlc2V0IHRoaXMgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgIC8vIFRPRE86IERlbGV0ZSB0aGlzIHdoZW4gd2UgZGVsZXRlIGlzTW91bnRlZCBhbmQgZmluZERPTU5vZGUuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG5cbiAgICAgICAgLy8gRW5zdXJlIHRoYXQgY2hpbGRyZW4gbW91bnQgaW50byB0aGlzIHJvb3Qgd2l0aG91dCB0cmFja2luZ1xuICAgICAgICAvLyBzaWRlLWVmZmVjdHMuIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGRvbid0IHN0b3JlIFBsYWNlbWVudCBlZmZlY3RzIG9uXG4gICAgICAgIC8vIG5vZGVzIHRoYXQgd2lsbCBiZSBoeWRyYXRlZC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBlbGVtZW50LCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UgcmVzZXQgaHlkcmF0aW9uIHN0YXRlIGluIGNhc2Ugd2UgYWJvcnRlZCBhbmQgcmVzdW1lZCBhbm90aGVyXG4gICAgICAgIC8vIHJvb3QuXG4gICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyB1cGRhdGUgcXVldWUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB0aGUgcm9vdCBoYXMgbm8gcHJvcHMuXG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gbWVtb2l6ZWRQcm9wcztcbiAgICAgICEobmV4dFByb3BzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbDtcblxuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcHMgPT09IG51bGwgfHwgbWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gICAgaWYgKGlzRGlyZWN0VGV4dENoaWxkKSB7XG4gICAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgICAgLy8gdGhpcyBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudCB0aGF0IGFsc28gaGF2ZSBhY2Nlc3MgdG8gdGhpcyBwcm9wLiBUaGF0XG4gICAgICAvLyBhdm9pZHMgYWxsb2NhdGluZyBhbm90aGVyIEhvc3RUZXh0IGZpYmVyIGFuZCB0cmF2ZXJzaW5nIGl0LlxuICAgICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHByZXZQcm9wcyAmJiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcmV2UHJvcHMpKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBhIGRpcmVjdCB0ZXh0IGNoaWxkIHRvIGEgbm9ybWFsIGNoaWxkLCBvciB0b1xuICAgICAgLy8gZW1wdHksIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhlIHRleHQgY29udGVudCB0byBiZSByZXNldC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDb250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBDaGVjayB0aGUgaG9zdCBjb25maWcgdG8gc2VlIGlmIHRoZSBjaGlsZHJlbiBhcmUgb2Zmc2NyZWVuL2hpZGRlbi5cbiAgICBpZiAocmVuZGVyRXhwaXJhdGlvblRpbWUgIT09IE5ldmVyICYmICF1c2VTeW5jU2NoZWR1bGluZyAmJiBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIG5leHRQcm9wcykpIHtcbiAgICAgIC8vIERvd24tcHJpb3JpdGl6ZSB0aGUgY2hpbGRyZW4uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgICAgLy8gQmFpbG91dCBhbmQgY29tZSBiYWNrIHRvIHRoaXMgZmliZXIgbGF0ZXIuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwpIHtcbiAgICAgIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgfVxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcbiAgICAvLyBpbW1lZGlhdGVseSBhZnRlci5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAhKGN1cnJlbnQgPT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIGhhdmUgbW91bnRlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB2YXIgZm4gPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICB2YXIgdmFsdWU7XG5cbiAgICB7XG4gICAgICBpZiAoZm4ucHJvdG90eXBlICYmIHR5cGVvZiBmbi5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsIFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgKyAnVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgdmFsdWUgPSBmbihwcm9wcywgY29udGV4dCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHRydWUsIGhhc0NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBGdW5jdGlvbmFsQ29tcG9uZW50O1xuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybmluZyghQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCAnJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbmFsIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICAgIHZhciBvd25lck5hbWUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZSgpO1xuICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCB8fCAnJztcbiAgICAgICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG4gICAgICAgICAgaWYgKGRlYnVnU291cmNlKSB7XG4gICAgICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXdhcm5lZEFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICAgICAgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcy4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiVzJXMnLCBpbmZvLCBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBwcm9wcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2FsbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgbmV4dENhbGwgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2FsbCA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2FsbCA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDYWxsICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2FsbCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2FsbCkge1xuICAgICAgbmV4dENhbGwgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgLy8gVE9ETzogV2hlbiBiYWlsaW5nIG91dCwgd2UgbWlnaHQgbmVlZCB0byByZXR1cm4gdGhlIHN0YXRlTm9kZSBpbnN0ZWFkXG4gICAgICAvLyBvZiB0aGUgY2hpbGQuIFRvIGNoZWNrIGl0IGZvciB3b3JrLlxuICAgICAgLy8gcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q2FsbC5jaGlsZHJlbjtcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYSBmb3JrIG9mIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZSBidXQgdXNpbmdcbiAgICAvLyBzdGF0ZU5vZGUgdG8gc3RvcmUgdGhlIGNoaWxkLlxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDYWxsKTtcbiAgICAvLyBUaGlzIGRvZXNuJ3QgdGFrZSBhcmJpdHJhcnkgdGltZSBzbyB3ZSBjb3VsZCBzeW5jaHJvbm91c2x5IGp1c3QgYmVnaW5cbiAgICAvLyBlYWdlcmx5IGRvIHRoZSB3b3JrIG9mIHdvcmtJblByb2dyZXNzLmNoaWxkIGFzIGFuIG9wdGltaXphdGlvbi5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSBjdXJyZW50ICYmIGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgIShuZXh0Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuICAgICAgLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG4gICAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgfVxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIC8qXG4gIGZ1bmN0aW9uIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHJldHVybkZpYmVyIDogRmliZXIsIGZpcnN0Q2hpbGQgOiBGaWJlcikge1xuICAgIGxldCBjaGlsZCA9IGZpcnN0Q2hpbGQ7XG4gICAgZG8ge1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGZpcnN0IGFuZCBsYXN0IGVmZmVjdCBvZiB0aGUgcGFyZW50IGNvcnJlc3BvbmRzXG4gICAgICAvLyB0byB0aGUgY2hpbGRyZW4ncyBmaXJzdCBhbmQgbGFzdCBlZmZlY3QuXG4gICAgICBpZiAoIXJldHVybkZpYmVyLmZpcnN0RWZmZWN0KSB7XG4gICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgICBpZiAoY2hpbGQubGFzdEVmZmVjdCkge1xuICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZC5sYXN0RWZmZWN0O1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGNoaWxkID0gY2hpbGQuc2libGluZyk7XG4gIH1cbiAgKi9cblxuICBmdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBpZGVhbGx5IGJlIGFibGUgdG8gYmFpbCBvdXQgZWFybHkgaWYgdGhlIGNoaWxkcmVuIGhhdmUgbm9cbiAgICAvLyBtb3JlIHdvcmsgdG8gZG8uIEhvd2V2ZXIsIHNpbmNlIHdlIGRvbid0IGhhdmUgYSBzZXBhcmF0aW9uIG9mIHRoaXNcbiAgICAvLyBGaWJlcidzIHByaW9yaXR5IGFuZCBpdHMgY2hpbGRyZW4geWV0IC0gd2UgZG9uJ3Qga25vdyB3aXRob3V0IGRvaW5nIGxvdHNcbiAgICAvLyBvZiB0aGUgc2FtZSB3b3JrIHdlIGRvIGFueXdheS4gT25jZSB3ZSBoYXZlIHRoYXQgc2VwYXJhdGlvbiB3ZSBjYW4ganVzdFxuICAgIC8vIGJhaWwgb3V0IGhlcmUgaWYgdGhlIGNoaWxkcmVuIGhhcyBubyBtb3JlIHdvcmsgYXQgdGhpcyBwcmlvcml0eSBsZXZlbC5cbiAgICAvLyBpZiAod29ya0luUHJvZ3Jlc3MucHJpb3JpdHlPZkNoaWxkcmVuIDw9IHByaW9yaXR5TGV2ZWwpIHtcbiAgICAvLyAgIC8vIElmIHRoZXJlIGFyZSBzaWRlLWVmZmVjdHMgaW4gdGhlc2UgY2hpbGRyZW4gdGhhdCBoYXZlIG5vdCB5ZXQgYmVlblxuICAgIC8vICAgLy8gY29tbWl0dGVkIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgdGhleSBnZXQgcHJvcGVybHkgdHJhbnNmZXJyZWQgdXAuXG4gICAgLy8gICBpZiAoY3VycmVudCAmJiBjdXJyZW50LmNoaWxkICE9PSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCkge1xuICAgIC8vICAgICByZXVzZUNoaWxkcmVuRWZmZWN0cyh3b3JrSW5Qcm9ncmVzcywgY2hpbGQpO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuIG51bGw7XG4gICAgLy8gfVxuXG4gICAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogSGFuZGxlIEhvc3RDb21wb25lbnQgdGFncyBoZXJlIGFzIHdlbGwgYW5kIGNhbGwgcHVzaEhvc3RDb250ZXh0KCk/XG4gICAgLy8gU2VlIFBSIDg1OTAgZGlzY3Vzc2lvbiBmb3IgY29udGV4dFxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAvLyBUT0RPOiBXaGF0IGlmIHRoaXMgaXMgY3VycmVudGx5IGluIHByb2dyZXNzP1xuICAgIC8vIEhvdyBjYW4gdGhhdCBoYXBwZW4/IEhvdyBpcyB0aGlzIG5vdCBiZWluZyBjbG9uZWQ/XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBUT0RPOiBEZWxldGUgbWVtb2l6ZVByb3BzL1N0YXRlIGFuZCBtb3ZlIHRvIHJlY29uY2lsZS9iYWlsb3V0IGluc3RlYWRcbiAgZnVuY3Rpb24gbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV4dFByb3BzO1xuICB9XG5cbiAgZnVuY3Rpb24gbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBuZXh0U3RhdGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV4dFN0YXRlO1xuICAgIC8vIERvbid0IHJlc2V0IHRoZSB1cGRhdGVRdWV1ZSwgaW4gY2FzZSB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBSZXNldHRpbmdcbiAgICAvLyBpcyBoYW5kbGVkIGJ5IHByb2Nlc3NVcGRhdGVRdWV1ZS5cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENhbGxIYW5kbGVyUGhhc2U6XG4gICAgICAgIC8vIFRoaXMgaXMgYSByZXN0YXJ0LiBSZXNldCB0aGUgdGFnIHRvIHRoZSBpbml0aWFsIHBoYXNlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsQ29tcG9uZW50O1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBmYWxsIHRocm91Z2ggc2luY2UgdGhpcyBpcyBub3cgdGhlIHNhbWUuXG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVDYWxsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICAgICAgLy8gQSByZXR1cm4gY29tcG9uZW50IGlzIGp1c3QgYSBwbGFjZWhvbGRlciwgd2UgY2FuIGp1c3QgcnVuIHRocm91Z2ggdGhlXG4gICAgICAgIC8vIG5leHQgb25lIGltbWVkaWF0ZWx5LlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1Vua25vd24gdW5pdCBvZiB3b3JrIHRhZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBiZWdpbkZhaWxlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBoZXJlIHRvIGF2b2lkIGEgcHVzaC9wb3AgY29udGV4dCBtaXNtYXRjaC5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0eXBlIG9mIHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFuIGVycm9yIGVmZmVjdCBzbyB3ZSBjYW4gaGFuZGxlIHRoZSBlcnJvciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZVxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBFcnI7XG5cbiAgICAvLyBUaGlzIGlzIGEgd2VpcmQgY2FzZSB3aGVyZSB3ZSBkbyBcInJlc3VtZVwiIHdvcmsg4oCUIHdvcmsgdGhhdCBmYWlsZWQgb25cbiAgICAvLyBvdXIgZmlyc3QgYXR0ZW1wdC4gQmVjYXVzZSB3ZSBubyBsb25nZXIgaGF2ZSBhIG5vdGlvbiBvZiBcInByb2dyZXNzZWRcbiAgICAvLyBkZWxldGlvbnMsXCIgcmVzZXQgdGhlIGNoaWxkIHRvIHRoZSBjdXJyZW50IGNoaWxkIHRvIG1ha2Ugc3VyZSB3ZSBkZWxldGVcbiAgICAvLyBpdCBhZ2Fpbi4gVE9ETzogRmluZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMsIHBlcmhhcHMgZHVyaW5nIGEgbW9yZVxuICAgIC8vIGdlbmVyYWwgb3ZlcmhhdWwgb2YgZXJyb3IgaGFuZGxpbmcuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkICE9PSBjdXJyZW50LmNoaWxkKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBkb24ndCBiYWlsIG91dCwgd2UncmUgZ29pbmcgYmUgcmVjb21wdXRpbmcgb3VyIGNoaWxkcmVuIHNvIHdlIG5lZWRcbiAgICAvLyB0byBkcm9wIG91ciBlZmZlY3QgbGlzdC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IG51bGw7XG5cbiAgICAvLyBVbm1vdW50IHRoZSBjdXJyZW50IGNoaWxkcmVuIGFzIGlmIHRoZSBjb21wb25lbnQgcmVuZGVyZWQgbnVsbFxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIH1cblxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmVnaW5Xb3JrOiBiZWdpbldvcmssXG4gICAgYmVnaW5GYWlsZWRXb3JrOiBiZWdpbkZhaWxlZFdvcmtcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVyQ29tcGxldGVXb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpIHtcbiAgdmFyIGNyZWF0ZUluc3RhbmNlID0gY29uZmlnLmNyZWF0ZUluc3RhbmNlLFxuICAgICAgY3JlYXRlVGV4dEluc3RhbmNlID0gY29uZmlnLmNyZWF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGFwcGVuZEluaXRpYWxDaGlsZCA9IGNvbmZpZy5hcHBlbmRJbml0aWFsQ2hpbGQsXG4gICAgICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiA9IGNvbmZpZy5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbixcbiAgICAgIHByZXBhcmVVcGRhdGUgPSBjb25maWcucHJlcGFyZVVwZGF0ZSxcbiAgICAgIG11dGF0aW9uID0gY29uZmlnLm11dGF0aW9uLFxuICAgICAgcGVyc2lzdGVuY2UgPSBjb25maWcucGVyc2lzdGVuY2U7XG4gIHZhciBnZXRSb290SG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LmdldFJvb3RIb3N0Q29udGFpbmVyLFxuICAgICAgcG9wSG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGV4dCxcbiAgICAgIGdldEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQuZ2V0SG9zdENvbnRleHQsXG4gICAgICBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcjtcbiAgdmFyIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UgPSBoeWRyYXRpb25Db250ZXh0LnByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsXG4gICAgICBwb3BIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQucG9wSHlkcmF0aW9uU3RhdGU7XG5cblxuICBmdW5jdGlvbiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuICAgIC8vIGFuIFVwZGF0ZUFuZFBsYWNlbWVudC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFya1JlZih3b3JrSW5Qcm9ncmVzcykge1xuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRBbGxSZXR1cm5zKHJldHVybnMsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIG5vZGVbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgfVxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0IHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0EgY2FsbCBjYW5ub3QgaGF2ZSBob3N0IGNvbXBvbmVudCBjaGlsZHJlbi4nKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFJldHVybkNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm5zLnB1c2gobm9kZS50eXBlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdmVDYWxsVG9IYW5kbGVyUGhhc2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGNhbGwgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICFjYWxsID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHJlc29sdmVkIGJ5IG5vdy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIC8vIEZpcnN0IHN0ZXAgb2YgdGhlIGNhbGwgaGFzIGNvbXBsZXRlZC4gTm93IHdlIG5lZWQgdG8gZG8gdGhlIHNlY29uZC5cbiAgICAvLyBUT0RPOiBJdCB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgYSBtdWx0aSBzdGFnZSBjYWxsIHJlcHJlc2VudGVkIGJ5IGFcbiAgICAvLyBzaW5nbGUgY29tcG9uZW50LCBvciBhdCBsZWFzdCB0YWlsIGNhbGwgb3B0aW1pemUgbmVzdGVkIG9uZXMuIEN1cnJlbnRseVxuICAgIC8vIHRoYXQgcmVxdWlyZXMgYWRkaXRpb25hbCBmaWVsZHMgdGhhdCB3ZSBkb24ndCB3YW50IHRvIGFkZCB0byB0aGUgZmliZXIuXG4gICAgLy8gU28gdGhpcyByZXF1aXJlcyBuZXN0ZWQgaGFuZGxlcnMuXG4gICAgLy8gTm90ZTogVGhpcyBkb2Vzbid0IG11dGF0ZSB0aGUgYWx0ZXJuYXRlIG5vZGUuIEkgZG9uJ3QgdGhpbmsgaXQgbmVlZHMgdG9cbiAgICAvLyBzaW5jZSB0aGlzIHN0YWdlIGlzIHJlc2V0IGZvciBldmVyeSBwYXNzLlxuICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxIYW5kbGVyUGhhc2U7XG5cbiAgICAvLyBCdWlsZCB1cCB0aGUgcmV0dXJucy5cbiAgICAvLyBUT0RPOiBDb21wYXJlIHRoaXMgdG8gYSBnZW5lcmF0b3Igb3Igb3BhcXVlIGhlbHBlcnMgbGlrZSBDaGlsZHJlbi5cbiAgICB2YXIgcmV0dXJucyA9IFtdO1xuICAgIGFwcGVuZEFsbFJldHVybnMocmV0dXJucywgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBmbiA9IGNhbGwuaGFuZGxlcjtcbiAgICB2YXIgcHJvcHMgPSBjYWxsLnByb3BzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBmbihwcm9wcywgcmV0dXJucyk7XG5cbiAgICB2YXIgY3VycmVudEZpcnN0Q2hpbGQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5jaGlsZCA6IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudEZpcnN0Q2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFsbENoaWxkcmVuKHBhcmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZUhvc3RDb250YWluZXIgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0Q29tcG9uZW50ID0gdm9pZCAwO1xuICB2YXIgdXBkYXRlSG9zdFRleHQgPSB2b2lkIDA7XG4gIGlmIChtdXRhdGlvbikge1xuICAgIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIpIHtcbiAgICAgIC8vIE11dGF0aW9uIG1vZGVcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7XG4gICAgICAgIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgICAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGlzIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIC8vIElmIHRoZSB0ZXh0IGRpZmZlcnMsIG1hcmsgaXQgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaW4gZG9uZSBpbiBjb21taXRXb3JrLlxuICAgICAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdNdXRhdGluZyByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgIGlmIChlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlcikge1xuICAgICAgLy8gUGVyc2lzdGVudCBob3N0IHRyZWUgbW9kZVxuICAgICAgdmFyIGNsb25lSW5zdGFuY2UgPSBwZXJzaXN0ZW5jZS5jbG9uZUluc3RhbmNlLFxuICAgICAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gcGVyc2lzdGVuY2UuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0ID0gcGVyc2lzdGVuY2UuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4gPSBwZXJzaXN0ZW5jZS5maW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuO1xuXG4gICAgICAvLyBBbiB1bmZvcnR1bmF0ZSBmb3JrIG9mIGFwcGVuZEFsbENoaWxkcmVuIGJlY2F1c2Ugd2UgaGF2ZSB0d28gZGlmZmVyZW50IHBhcmVudCB0eXBlcy5cblxuICAgICAgdmFyIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIgPSBmdW5jdGlvbiAoY29udGFpbmVyQ2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgICAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICAgIH1cbiAgICAgICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbztcbiAgICAgICAgICB2YXIgbmV3Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXIpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lciwgbmV3Q2hpbGRTZXQpKSB7XG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbiA9IG5ld0NoaWxkU2V0O1xuICAgICAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKG5ld0NoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoZSBjb250YWluZXIgdG8gc3dhcCBvdXQgdGhlIGNvbnRhaW5lci5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIHRoZW4gbm9uZSBvZiBvdXIgY2hpbGRyZW4gaGFkIGFueSB1cGRhdGVzLlxuICAgICAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG4gICAgICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgICAgICB2YXIgY3VycmVudEluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCAmJiB1cGRhdGVQYXlsb2FkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcmVjeWNsYWJsZUluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBuZXdJbnN0YW5jZSA9IGNsb25lSW5zdGFuY2UoY3VycmVudEluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHdvcmtJblByb2dyZXNzLCBjaGlsZHJlblVuY2hhbmdlZCwgcmVjeWNsYWJsZUluc3RhbmNlKTtcbiAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4obmV3SW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpKSB7XG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbmV3SW5zdGFuY2U7XG4gICAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gb3RoZXIgZWZmZWN0cyBpbiB0aGlzIHRyZWUsIHdlIG5lZWQgdG8gZmxhZyB0aGlzIG5vZGUgYXMgaGF2aW5nIG9uZS5cbiAgICAgICAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlJ3JlIG5vdCBnb2luZyB0byB1c2UgaXQgZm9yIGFueXRoaW5nLlxuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlIHBhcmVudHMgd29uJ3Qga25vdyB0aGF0IHRoZXJlIGFyZSBuZXcgY2hpbGRyZW4gdG8gcHJvcGFnYXRlIHVwd2FyZHMuXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4obmV3SW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgICAgIC8vIElmIHRoZSB0ZXh0IGNvbnRlbnQgZGlmZmVycywgd2UnbGwgY3JlYXRlIGEgbmV3IHRleHQgaW5zdGFuY2UgZm9yIGl0LlxuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIC8vIFdlJ2xsIGhhdmUgdG8gbWFyayBpdCBhcyBoYXZpbmcgYW4gZWZmZWN0LCBldmVuIHRob3VnaCB3ZSB3b24ndCB1c2UgdGhlIGVmZmVjdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgLy8gVGhpcyBsZXRzIHRoZSBwYXJlbnRzIGtub3cgdGhhdCBhdCBsZWFzdCBvbmUgb2YgdGhlaXIgY2hpbGRyZW4gaGFzIGNoYW5nZWQuXG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGVuYWJsZU5vb3BSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBObyBob3N0IG9wZXJhdGlvbnNcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIgPSBmdW5jdGlvbiAod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdOb29wIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIEdldCB0aGUgbGF0ZXN0IHByb3BzLlxuICAgIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV3UHJvcHMgPT09IG51bGwpIHtcbiAgICAgIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB9IGVsc2UgaWYgKHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lICE9PSBOZXZlciB8fCByZW5kZXJFeHBpcmF0aW9uVGltZSA9PT0gTmV2ZXIpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBwZW5kaW5nIHByb3BzLCB1bmxlc3MgdGhpcyB3YXMgYSBkb3duLXByaW9yaXRpemF0aW9uLlxuICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gbnVsbDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBhcmUgbGVhdmluZyB0aGlzIHN1YnRyZWUsIHNvIHBvcCBjb250ZXh0IGlmIGFueS5cbiAgICAgICAgICBwb3BDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgZmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChmaWJlclJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgICAgZmliZXJSb290LnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgcG9wIHNvIHRoYXQgd2UgY2FuIGRlbGV0ZSBhbnkgcmVtYWluaW5nIGNoaWxkcmVuXG4gICAgICAgICAgICAvLyB0aGF0IHdlcmVuJ3QgaHlkcmF0ZWQuXG4gICAgICAgICAgICBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAvLyBUaGlzIHJlc2V0cyB0aGUgaGFja3kgc3RhdGUgdG8gZml4IGlzTW91bnRlZCBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgICAgIC8vIFRPRE86IERlbGV0ZSB0aGlzIHdoZW4gd2UgZGVsZXRlIGlzTW91bnRlZCBhbmQgZmluZERPTU5vZGUuXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkIHRvXG4gICAgICAgICAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgLy8gSWYgd2UgZ2V0IHVwZGF0ZWQgYmVjYXVzZSBvbmUgb2Ygb3VyIGNoaWxkcmVuIHVwZGF0ZWQsIHdlIGRvbid0XG4gICAgICAgICAgICAvLyBoYXZlIG5ld1Byb3BzIHNvIHdlJ2xsIGhhdmUgdG8gcmV1c2UgdGhlbS5cbiAgICAgICAgICAgIC8vIFRPRE86IFNwbGl0IHRoZSB1cGRhdGUgQVBJIGFzIHNlcGFyYXRlIGZvciB0aGUgcHJvcHMgdnMuIGNoaWxkcmVuLlxuICAgICAgICAgICAgLy8gRXZlbiBiZXR0ZXIgd291bGQgYmUgaWYgY2hpbGRyZW4gd2VyZW4ndCBzcGVjaWFsIGNhc2VkIGF0IGFsbCB0aG8uXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gcHJlcGFyZVVwZGF0ZShpbnN0YW5jZSwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcblxuICAgICAgICAgICAgaWYgKGN1cnJlbnQucmVmICE9PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgISh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgY3JlYXRlSW5zdGFuY2UgdG8gYmVnaW5Xb3JrIGFuZCBrZWVwIGl0IG9uIGEgY29udGV4dFxuICAgICAgICAgICAgLy8gXCJzdGFja1wiIGFzIHRoZSBwYXJlbnQuIFRoZW4gYXBwZW5kIGNoaWxkcmVuIGFzIHdlIGdvIGluIGJlZ2luV29ya1xuICAgICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3ZSB3YW50IHRvIGFkZCB0aGVuIHRvcC0+ZG93biBvclxuICAgICAgICAgICAgLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxuICAgICAgICAgICAgdmFyIHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKHdhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyBhbmQgY3JlYXRlSW5zdGFuY2Ugc3RlcCBpbnRvIHRoZSBiZWdpblBoYXNlXG4gICAgICAgICAgICAgIC8vIHRvIGNvbnNvbGlkYXRlLlxuICAgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGNoYW5nZXMgdG8gdGhlIGh5ZHJhdGVkIG5vZGUgbmVlZHMgdG8gYmUgYXBwbGllZCBhdCB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb21taXQtcGhhc2Ugd2UgbWFyayB0aGlzIGFzIHN1Y2guXG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4oX2luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgICAgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgICAgICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIHN1cHBvcnRzIGF1dG8tZm9jdXMgZm9yIGNlcnRhaW4gZWxlbWVudHMpLlxuICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cbiAgICAgICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKF9pbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBfaW5zdGFuY2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSByZWYgb24gYSBob3N0IG5vZGUgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBuZXdUZXh0ID0gbmV3UHJvcHM7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWRcbiAgICAgICAgICAgIC8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmV3VGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgISh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgX3Jvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dDIgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgX3Jvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dDIsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdmVDYWxsVG9IYW5kbGVyUGhhc2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gUmVzZXQgdGhlIHRhZyB0byBub3cgYmUgYSBmaXJzdCBwaGFzZSBjYWxsLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsQ29tcG9uZW50O1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBEb2VzIG5vdGhpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBGcmFnbWVudDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAvLyBFcnJvciBjYXNlc1xuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBbiBpbmRldGVybWluYXRlIGNvbXBvbmVudCBzaG91bGQgaGF2ZSBiZWNvbWUgZGV0ZXJtaW5hdGUgYmVmb3JlIGNvbXBsZXRpbmcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ1Vua25vd24gdW5pdCBvZiB3b3JrIHRhZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNvbXBsZXRlV29yazogY29tcGxldGVXb3JrXG4gIH07XG59O1xuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIgPSBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xudmFyIGhhc0NhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciQxID0gUmVhY3RFcnJvclV0aWxzLmNsZWFyQ2F1Z2h0RXJyb3I7XG5cblxudmFyIFJlYWN0RmliZXJDb21taXRXb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgY2FwdHVyZUVycm9yKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZSxcbiAgICAgIG11dGF0aW9uID0gY29uZmlnLm11dGF0aW9uLFxuICAgICAgcGVyc2lzdGVuY2UgPSBjb25maWcucGVyc2lzdGVuY2U7XG5cblxuICB2YXIgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyID0gZnVuY3Rpb24gKGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKGN1cnJlbnQsICdjb21wb25lbnRXaWxsVW5tb3VudCcpO1xuICAgIGluc3RhbmNlLnByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgfTtcblxuICAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCB1bm1vdW50aW5nLlxuICBmdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICB7XG4gICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMihudWxsLCBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIsIG51bGwsIGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvciQxKCkpIHtcbiAgICAgICAgdmFyIHVubW91bnRFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICBjYXB0dXJlRXJyb3IoY3VycmVudCwgdW5tb3VudEVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCkge1xuICAgIHZhciByZWYgPSBjdXJyZW50LnJlZjtcbiAgICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIHJlZiwgbnVsbCwgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvciQxKCkpIHtcbiAgICAgICAgICB2YXIgcmVmRXJyb3IgPSBjbGVhckNhdWdodEVycm9yJDEoKTtcbiAgICAgICAgICBjYXB0dXJlRXJyb3IoY3VycmVudCwgcmVmRXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TGlmZUN5Y2xlcyhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkTW91bnQnKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRVcGRhdGUnKTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UucHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKTtcbiAgICAgICAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKF91cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZCAhPT0gbnVsbCA/IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGUgOiBudWxsO1xuICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzKF91cGRhdGVRdWV1ZSwgX2luc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlMiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuICAgICAgICAgIC8vIFRoZXNlIGVmZmVjdHMgc2hvdWxkIG9ubHkgYmUgY29tbWl0dGVkIHdoZW4gY29tcG9uZW50cyBhcmUgZmlyc3QgbW91bnRlZCxcbiAgICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiBmaW5pc2hlZFdvcmsuZWZmZWN0VGFnICYgVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICBjb21taXRNb3VudChfaW5zdGFuY2UyLCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCB0ZXh0LlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggcG9ydGFscy5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcbiAgICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICByZWYoZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZWYoaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIGN1cnJlbnRSZWYgPSBjdXJyZW50LnJlZjtcbiAgICBpZiAoY3VycmVudFJlZiAhPT0gbnVsbCkge1xuICAgICAgY3VycmVudFJlZihudWxsKTtcbiAgICB9XG4gIH1cblxuICAvLyBVc2VyLW9yaWdpbmF0aW5nIGVycm9ycyAobGlmZWN5Y2xlcyBhbmQgcmVmcykgc2hvdWxkIG5vdCBpbnRlcnJ1cHRcbiAgLy8gZGVsZXRpb24sIHNvIGRvbid0IGxldCB0aGVtIHRocm93LiBIb3N0LW9yaWdpbmF0aW5nIGVycm9ycyBzaG91bGRcbiAgLy8gaW50ZXJydXB0IGRlbGV0aW9uLCBzbyBpdCdzIG9rYXlcbiAgZnVuY3Rpb24gY29tbWl0VW5tb3VudChjdXJyZW50KSB7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0VW5tb3VudChjdXJyZW50KTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMoY3VycmVudC5zdGF0ZU5vZGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyByZWN1cnNpdmUuXG4gICAgICAgICAgLy8gV2UgYXJlIGFsc28gbm90IHVzaW5nIHRoaXMgcGFyZW50IGJlY2F1c2VcbiAgICAgICAgICAvLyB0aGUgcG9ydGFsIHdpbGwgZ2V0IHB1c2hlZCBpbW1lZGlhdGVseS5cbiAgICAgICAgICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyICYmIG11dGF0aW9uKSB7XG4gICAgICAgICAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciAmJiBwZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgZW1wdHlQb3J0YWxDb250YWluZXIoY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdE5lc3RlZFVubW91bnRzKHJvb3QpIHtcbiAgICAvLyBXaGlsZSB3ZSdyZSBpbnNpZGUgYSByZW1vdmVkIGhvc3Qgbm9kZSB3ZSBkb24ndCB3YW50IHRvIGNhbGxcbiAgICAvLyByZW1vdmVDaGlsZCBvbiB0aGUgaW5uZXIgbm9kZXMgYmVjYXVzZSB0aGV5J3JlIHJlbW92ZWQgYnkgdGhlIHRvcFxuICAgIC8vIGNhbGwgYW55d2F5LiBXZSBhbHNvIHdhbnQgdG8gY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCBvbiBhbGxcbiAgICAvLyBjb21wb3NpdGVzIGJlZm9yZSB0aGlzIGhvc3Qgbm9kZSBpcyByZW1vdmVkIGZyb20gdGhlIHRyZWUuIFRoZXJlZm9yZVxuICAgIHZhciBub2RlID0gcm9vdDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgdGhleSBtYXkgY29udGFpbiBtb3JlIGNvbXBvc2l0ZSBvciBob3N0IG5vZGVzLlxuICAgICAgLy8gU2tpcCBwb3J0YWxzIGJlY2F1c2UgY29tbWl0VW5tb3VudCgpIGN1cnJlbnRseSB2aXNpdHMgdGhlbSByZWN1cnNpdmVseS5cbiAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsICYmIChcbiAgICAgIC8vIElmIHdlIHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyB1c2luZyBjb21taXRVbm1vdW50IGFib3ZlLlxuICAgICAgLy8gSWYgd2UgZG9uJ3QgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIGhlcmUgaW5zdGVhZC5cbiAgICAgICFtdXRhdGlvbiB8fCBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gcm9vdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gcm9vdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRldGFjaEZpYmVyKGN1cnJlbnQpIHtcbiAgICAvLyBDdXQgb2ZmIHRoZSByZXR1cm4gcG9pbnRlcnMgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLiBJZGVhbGx5LCB3ZVxuICAgIC8vIHNob3VsZCBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAgIC8vIGdldCBHQzplZCBidXQgd2UgZG9uJ3Qga25vdyB3aGljaCBmb3Igc3VyZSB3aGljaCBwYXJlbnQgaXMgdGhlIGN1cnJlbnRcbiAgICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC4gVGhpcyBjaGlsZFxuICAgIC8vIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gICAgY3VycmVudFsncmV0dXJuJ10gPSBudWxsO1xuICAgIGN1cnJlbnQuY2hpbGQgPSBudWxsO1xuICAgIGlmIChjdXJyZW50LmFsdGVybmF0ZSkge1xuICAgICAgY3VycmVudC5hbHRlcm5hdGUuY2hpbGQgPSBudWxsO1xuICAgICAgY3VycmVudC5hbHRlcm5hdGVbJ3JldHVybiddID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBpZiAoIW11dGF0aW9uKSB7XG4gICAgdmFyIGNvbW1pdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgICBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIHZhciByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4gPSBwZXJzaXN0ZW5jZS5yZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4sXG4gICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5jcmVhdGVDb250YWluZXJDaGlsZFNldDtcblxuICAgICAgdmFyIGVtcHR5UG9ydGFsQ29udGFpbmVyID0gZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgdmFyIHBvcnRhbCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuXG4gICAgICAgIHZhciBlbXB0eUNoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVySW5mbyk7XG4gICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBlbXB0eUNoaWxkU2V0KTtcbiAgICAgIH07XG4gICAgICBjb21taXRDb250YWluZXIgPSBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvLFxuICAgICAgICAgICAgICAgICAgX3BlbmRpbmdDaGlsZHJlbiA9IHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW47XG5cbiAgICAgICAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIF9wZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyIHx8IGVuYWJsZU5vb3BSZWNvbmNpbGVyKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50OiBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7fSxcbiAgICAgICAgY29tbWl0UGxhY2VtZW50OiBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7fSxcbiAgICAgICAgY29tbWl0RGVsZXRpb246IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50KTtcbiAgICAgICAgICBkZXRhY2hGaWJlcihjdXJyZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgY29tbWl0V29yazogZnVuY3Rpb24gKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIGNvbW1pdENvbnRhaW5lcihmaW5pc2hlZFdvcmspO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZjogY29tbWl0QXR0YWNoUmVmLFxuICAgICAgICBjb21taXREZXRhY2hSZWY6IGNvbW1pdERldGFjaFJlZlxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdQZXJzaXN0ZW50IHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ05vb3AgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH1cbiAgdmFyIGNvbW1pdE1vdW50ID0gbXV0YXRpb24uY29tbWl0TW91bnQsXG4gICAgICBjb21taXRVcGRhdGUgPSBtdXRhdGlvbi5jb21taXRVcGRhdGUsXG4gICAgICByZXNldFRleHRDb250ZW50ID0gbXV0YXRpb24ucmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFRleHRVcGRhdGUgPSBtdXRhdGlvbi5jb21taXRUZXh0VXBkYXRlLFxuICAgICAgYXBwZW5kQ2hpbGQgPSBtdXRhdGlvbi5hcHBlbmRDaGlsZCxcbiAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIgPSBtdXRhdGlvbi5hcHBlbmRDaGlsZFRvQ29udGFpbmVyLFxuICAgICAgaW5zZXJ0QmVmb3JlID0gbXV0YXRpb24uaW5zZXJ0QmVmb3JlLFxuICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRJbkNvbnRhaW5lckJlZm9yZSxcbiAgICAgIHJlbW92ZUNoaWxkID0gbXV0YXRpb24ucmVtb3ZlQ2hpbGQsXG4gICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZEZyb21Db250YWluZXI7XG5cblxuICBmdW5jdGlvbiBnZXRIb3N0UGFyZW50RmliZXIoZmliZXIpIHtcbiAgICB2YXIgcGFyZW50ID0gZmliZXJbJ3JldHVybiddO1xuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgICByZXR1cm4gcGFyZW50O1xuICAgICAgfVxuICAgICAgcGFyZW50ID0gcGFyZW50WydyZXR1cm4nXTtcbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RSb290IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFBvcnRhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gICAgLy8gV2UncmUgZ29pbmcgdG8gc2VhcmNoIGZvcndhcmQgaW50byB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyBob3N0XG4gICAgLy8gbm9kZS4gVW5mb3J0dW5hdGVseSwgaWYgbXVsdGlwbGUgaW5zZXJ0aW9ucyBhcmUgZG9uZSBpbiBhIHJvdyB3ZSBoYXZlIHRvXG4gICAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICBzaWJsaW5nczogd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IGlzSG9zdFBhcmVudChub2RlWydyZXR1cm4nXSkpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4gICAgICAgICAgLy8gbGFzdCBzaWJsaW5nLlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICB3aGlsZSAobm9kZS50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgbm9kZS50YWcgIT09IEhvc3RUZXh0KSB7XG4gICAgICAgIC8vIElmIGl0IGlzIG5vdCBob3N0IG5vZGUgYW5kLCB3ZSBtaWdodCBoYXZlIGEgaG9zdCBub2RlIGluc2lkZSBpdC5cbiAgICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgICBpZiAobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgLy8gV2UgYWxzbyBza2lwIHBvcnRhbHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgcGFydCBvZiB0aGlzIGhvc3QgdHJlZS5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgPT09IG51bGwgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaG9zdCBub2RlIGlzIHN0YWJsZSBvciBhYm91dCB0byBiZSBwbGFjZWQuXG4gICAgICBpZiAoIShub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkpIHtcbiAgICAgICAgLy8gRm91bmQgaXQhXG4gICAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgaW5zZXJ0IGFsbCBob3N0IG5vZGVzIGludG8gdGhlIHBhcmVudC5cbiAgICB2YXIgcGFyZW50RmliZXIgPSBnZXRIb3N0UGFyZW50RmliZXIoZmluaXNoZWRXb3JrKTtcbiAgICB2YXIgcGFyZW50ID0gdm9pZCAwO1xuICAgIHZhciBpc0NvbnRhaW5lciA9IHZvaWQgMDtcbiAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIGlzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmVudEZpYmVyLmVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgLy8gUmVzZXQgdGhlIHRleHQgY29udGVudCBvZiB0aGUgcGFyZW50IGJlZm9yZSBkb2luZyBhbnkgaW5zZXJ0aW9uc1xuICAgICAgcmVzZXRUZXh0Q29udGVudChwYXJlbnQpO1xuICAgICAgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcbiAgICAgIHBhcmVudEZpYmVyLmVmZmVjdFRhZyAmPSB+Q29udGVudFJlc2V0O1xuICAgIH1cblxuICAgIHZhciBiZWZvcmUgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspO1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgaWYgKGJlZm9yZSkge1xuICAgICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zZXJ0QmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcihwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXBwZW5kQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnNlcnRpb24gaXRzZWxmIGlzIGEgcG9ydGFsLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgdmFyIG5vZGUgPSBjdXJyZW50O1xuXG4gICAgLy8gRWFjaCBpdGVyYXRpb24sIGN1cnJlbnRQYXJlbnQgaXMgcG9wdWxhdGVkIHdpdGggbm9kZSdzIGhvc3QgcGFyZW50IGlmIG5vdFxuICAgIC8vIGN1cnJlbnRQYXJlbnRJc1ZhbGlkLlxuICAgIHZhciBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgIHZhciBjdXJyZW50UGFyZW50ID0gdm9pZCAwO1xuICAgIHZhciBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB2b2lkIDA7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50SXNWYWxpZCkge1xuICAgICAgICB2YXIgcGFyZW50ID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgIGZpbmRQYXJlbnQ6IHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgIShwYXJlbnQgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgIHN3aXRjaCAocGFyZW50LnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50ID0gcGFyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhub2RlKTtcbiAgICAgICAgLy8gQWZ0ZXIgYWxsIHRoZSBjaGlsZHJlbiBoYXZlIHVubW91bnRlZCwgaXQgaXMgbm93IHNhZmUgdG8gcmVtb3ZlIHRoZVxuICAgICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG4gICAgICAgIGlmIChjdXJyZW50UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgICByZW1vdmVDaGlsZEZyb21Db250YWluZXIoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbW92ZUNoaWxkKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb24ndCB2aXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIGFscmVhZHkgdmlzaXRlZCB0aGVtLlxuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgICAgLy8gV2Ugd2lsbCByZWFzc2lnbiBpdCBiYWNrIHdoZW4gd2UgcG9wIHRoZSBwb3J0YWwgb24gdGhlIHdheSB1cC5cbiAgICAgICAgY3VycmVudFBhcmVudCA9IG5vZGUuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2UgcG9ydGFscyBtaWdodCBjb250YWluIGhvc3QgY29tcG9uZW50cy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbW1pdFVubW91bnQobm9kZSk7XG4gICAgICAgIC8vIFZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgbWF5IGZpbmQgbW9yZSBob3N0IGNvbXBvbmVudHMgYmVsb3cuXG4gICAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gY3VycmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIC8vIFdoZW4gd2UgZ28gb3V0IG9mIHRoZSBwb3J0YWwsIHdlIG5lZWQgdG8gcmVzdG9yZSB0aGUgcGFyZW50LlxuICAgICAgICAgIC8vIFNpbmNlIHdlIGRvbid0IGtlZXAgYSBzdGFjayBvZiB0aGVtLCB3ZSB3aWxsIHNlYXJjaCBmb3IgaXQuXG4gICAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXREZWxldGlvbihjdXJyZW50KSB7XG4gICAgLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGFsbCBob3N0IG5vZGVzIGZyb20gdGhlIHBhcmVudC5cbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgICBkZXRhY2hGaWJlcihjdXJyZW50KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFdvcmsoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmIChpbnN0YW5jZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbiAgICAgICAgICAgIHZhciBuZXdQcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICAgICAgICAgICAgLy8gVE9ETzogVHlwZSB0aGUgdXBkYXRlUXVldWUgdG8gYmUgc3BlY2lmaWMgdG8gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgY29tbWl0VXBkYXRlKGluc3RhbmNlLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgICEoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBuZXdUZXh0ID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdUZXh0O1xuICAgICAgICAgIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQoY3VycmVudCkge1xuICAgIHJlc2V0VGV4dENvbnRlbnQoY3VycmVudC5zdGF0ZU5vZGUpO1xuICB9XG5cbiAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgIHJldHVybiB7XG4gICAgICBjb21taXRSZXNldFRleHRDb250ZW50OiBjb21taXRSZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0UGxhY2VtZW50OiBjb21taXRQbGFjZW1lbnQsXG4gICAgICBjb21taXREZWxldGlvbjogY29tbWl0RGVsZXRpb24sXG4gICAgICBjb21taXRXb3JrOiBjb21taXRXb3JrLFxuICAgICAgY29tbWl0TGlmZUN5Y2xlczogY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgIGNvbW1pdEF0dGFjaFJlZjogY29tbWl0QXR0YWNoUmVmLFxuICAgICAgY29tbWl0RGV0YWNoUmVmOiBjb21taXREZXRhY2hSZWZcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gIH1cbn07XG5cbnZhciBOT19DT05URVhUID0ge307XG5cbnZhciBSZWFjdEZpYmVySG9zdENvbnRleHQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRDaGlsZEhvc3RDb250ZXh0ID0gY29uZmlnLmdldENoaWxkSG9zdENvbnRleHQsXG4gICAgICBnZXRSb290SG9zdENvbnRleHQgPSBjb25maWcuZ2V0Um9vdEhvc3RDb250ZXh0O1xuXG5cbiAgdmFyIGNvbnRleHRTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbiAgdmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG5cbiAgZnVuY3Rpb24gcmVxdWlyZWRDb250ZXh0KGMpIHtcbiAgICAhKGMgIT09IE5PX0NPTlRFWFQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Um9vdEhvc3RDb250YWluZXIoKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICByZXR1cm4gcm9vdEluc3RhbmNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgICAvLyBQdXNoIGN1cnJlbnQgcm9vdCBpbnN0YW5jZSBvbnRvIHRoZSBzdGFjaztcbiAgICAvLyBUaGlzIGFsbG93cyB1cyB0byByZXNldCByb290IHdoZW4gcG9ydGFscyBhcmUgcG9wcGVkLlxuICAgIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTtcblxuICAgIHZhciBuZXh0Um9vdENvbnRleHQgPSBnZXRSb290SG9zdENvbnRleHQobmV4dFJvb3RJbnN0YW5jZSk7XG5cbiAgICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEhvc3RDb250ZXh0KCkge1xuICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICByZXR1cm4gY29udGV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICAgIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHZhciBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCwgZmliZXIudHlwZSwgcm9vdEluc3RhbmNlKTtcblxuICAgIC8vIERvbid0IHB1c2ggdGhpcyBGaWJlcidzIGNvbnRleHQgdW5sZXNzIGl0J3MgdW5pcXVlLlxuICAgIGlmIChjb250ZXh0ID09PSBuZXh0Q29udGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dENvbnRleHQsIGZpYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgIC8vIHB1c2hIb3N0Q29udGV4dCgpIG9ubHkgcHVzaGVzIEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIGlmIChjb250ZXh0RmliZXJTdGFja0N1cnNvci5jdXJyZW50ICE9PSBmaWJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0SG9zdENvbnRhaW5lcigpIHtcbiAgICBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCA9IE5PX0NPTlRFWFQ7XG4gICAgcm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCA9IE5PX0NPTlRFWFQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGdldEhvc3RDb250ZXh0OiBnZXRIb3N0Q29udGV4dCxcbiAgICBnZXRSb290SG9zdENvbnRhaW5lcjogZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgcG9wSG9zdENvbnRhaW5lcjogcG9wSG9zdENvbnRhaW5lcixcbiAgICBwb3BIb3N0Q29udGV4dDogcG9wSG9zdENvbnRleHQsXG4gICAgcHVzaEhvc3RDb250YWluZXI6IHB1c2hIb3N0Q29udGFpbmVyLFxuICAgIHB1c2hIb3N0Q29udGV4dDogcHVzaEhvc3RDb250ZXh0LFxuICAgIHJlc2V0SG9zdENvbnRhaW5lcjogcmVzZXRIb3N0Q29udGFpbmVyXG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBzaG91bGRTZXRUZXh0Q29udGVudCA9IGNvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudCxcbiAgICAgIGh5ZHJhdGlvbiA9IGNvbmZpZy5oeWRyYXRpb247XG5cbiAgLy8gSWYgdGhpcyBkb2Vzbid0IGhhdmUgaHlkcmF0aW9uIG1vZGUuXG5cbiAgaWYgKCFoeWRyYXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgZW50ZXJIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9LFxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKCkge30sXG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTogZnVuY3Rpb24gKCkge30sXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9LFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9LFxuICAgICAgcG9wSHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHZhciBjYW5IeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uY2FuSHlkcmF0ZUluc3RhbmNlLFxuICAgICAgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5jYW5IeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nID0gaHlkcmF0aW9uLmdldE5leHRIeWRyYXRhYmxlU2libGluZyxcbiAgICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkID0gaHlkcmF0aW9uLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkLFxuICAgICAgaHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uaHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UsXG4gICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90SHlkcmF0ZUluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTtcblxuICAvLyBUaGUgZGVlcGVzdCBGaWJlciBvbiB0aGUgc3RhY2sgaW52b2x2ZWQgaW4gYSBoeWRyYXRpb24gY29udGV4dC5cbiAgLy8gVGhpcyBtYXkgaGF2ZSBiZWVuIGFuIGluc2VydGlvbiBvciBhIGh5ZHJhdGlvbi5cblxuICB2YXIgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICB2YXIgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gIHZhciBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQocGFyZW50SW5zdGFuY2UpO1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKHJldHVybkZpYmVyLCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlKHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvLCBpbnN0YW5jZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2UocmV0dXJuRmliZXIudHlwZSwgcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcywgcmV0dXJuRmliZXIuc3RhdGVOb2RlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpO1xuICAgIGNoaWxkVG9EZWxldGUuc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgY2hpbGRUb0RlbGV0ZVsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuXG4gICAgLy8gVGhpcyBtaWdodCBzZWVtIGxpa2UgaXQgYmVsb25ncyBvbiBwcm9ncmVzc2VkRmlyc3REZWxldGlvbi4gSG93ZXZlcixcbiAgICAvLyB0aGVzZSBjaGlsZHJlbiBhcmUgbm90IHBhcnQgb2YgdGhlIHJlY29uY2lsaWF0aW9uIGxpc3Qgb2YgY2hpbGRyZW4uXG4gICAgLy8gRXZlbiBpZiB3ZSBhYm9ydCBhbmQgcmVyZWNvbmNpbGUgdGhlIGNoaWxkcmVuLCB0aGF0IHdpbGwgdHJ5IHRvIGh5ZHJhdGVcbiAgICAvLyBhZ2FpbiBhbmQgdGhlIG5vZGVzIGFyZSBzdGlsbCBpbiB0aGUgaG9zdCB0cmVlIHNvIHRoZXNlIHdpbGwgYmVcbiAgICAvLyByZWNyZWF0ZWQuXG4gICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKHJldHVybkZpYmVyLCBmaWJlcikge1xuICAgIGZpYmVyLmVmZmVjdFRhZyB8PSBQbGFjZW1lbnQ7XG4gICAge1xuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIHZhciBfdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIF9wcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3R5cGUsIF9wcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgICAgdmFyIF90ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgX3RleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpIHtcbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgIHZhciBwcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjYW5IeWRyYXRlSW5zdGFuY2UobmV4dEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaWJlci5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgICAgIGlmICh0ZXh0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IHRleHRJbnN0YW5jZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcikge1xuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgaWYgKCFuZXh0SW5zdGFuY2UpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0cnlIeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAgIC8vIFdlIHVzZSB0aGlzIGFzIGEgaGV1cmlzdGljLiBJdCdzIGJhc2VkIG9uIGludHVpdGlvbiBhbmQgbm90IGRhdGEgc28gaXRcbiAgICAgIC8vIG1pZ2h0IGJlIGZsYXdlZCBvciB1bm5lY2Vzc2FyeS5cbiAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBXZSBtYXRjaGVkIHRoZSBuZXh0IG9uZSwgd2UnbGwgbm93IGFzc3VtZSB0aGF0IHRoZSBmaXJzdCBvbmUgd2FzXG4gICAgICAvLyBzdXBlcmZsdW91cyBhbmQgd2UnbGwgZGVsZXRlIGl0LiBTaW5jZSB3ZSBjYW4ndCBlYWdlcmx5IGRlbGV0ZSBpdFxuICAgICAgLy8gd2UnbGwgaGF2ZSB0byBzY2hlZHVsZSBhIGRlbGV0aW9uLiBUbyBkbyB0aGF0LCB0aGlzIG5vZGUgbmVlZHMgYSBkdW1teVxuICAgICAgLy8gZmliZXIgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKTtcbiAgICB9XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQobmV4dEluc3RhbmNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGZpYmVyKTtcbiAgICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICBmaWJlci51cGRhdGVRdWV1ZSA9IHVwZGF0ZVBheWxvYWQ7XG4gICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuXG4gICAgaWYgKHVwZGF0ZVBheWxvYWQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgdmFyIHRleHRDb250ZW50ID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gaHlkcmF0ZVRleHRJbnN0YW5jZSh0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCBmaWJlcik7XG4gICAge1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSBpcyBjYWxsZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZVxuICAgICAgICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG4gICAgICAgIHZhciByZXR1cm5GaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyO1xuICAgICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgICB2YXIgcGFyZW50ID0gZmliZXJbJ3JldHVybiddO1xuICAgIHdoaWxlIChwYXJlbnQgIT09IG51bGwgJiYgcGFyZW50LnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Um9vdCkge1xuICAgICAgcGFyZW50ID0gcGFyZW50WydyZXR1cm4nXTtcbiAgICB9XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBwYXJlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAgIC8vIHRyZWUuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIG5vdCBjdXJyZW50bHkgaHlkcmF0aW5nIGJ1dCB3ZSdyZSBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LCB0aGVuXG4gICAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgICAgLy8gc2libGluZ3MuXG4gICAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGFueSByZW1haW5pbmcgaHlkcmF0YWJsZSBub2Rlcywgd2UgbmVlZCB0byBkZWxldGUgdGhlbSBub3cuXG4gICAgLy8gV2Ugb25seSBkbyB0aGlzIGRlZXBlciB0aGFuIGhlYWQgYW5kIGJvZHkgc2luY2UgdGhleSB0ZW5kIHRvIGhhdmUgcmFuZG9tXG4gICAgLy8gb3RoZXIgbm9kZXMgaW4gdGhlbS4gV2UgYWxzbyBpZ25vcmUgY29tcG9uZW50cyB3aXRoIHB1cmUgdGV4dCBjb250ZW50IGluXG4gICAgLy8gc2lkZSBvZiB0aGVtLlxuICAgIC8vIFRPRE86IEJldHRlciBoZXVyaXN0aWMuXG4gICAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCB0eXBlICE9PSAnaGVhZCcgJiYgdHlwZSAhPT0gJ2JvZHknICYmICFzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkge1xuICAgICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIeWRyYXRpb25TdGF0ZSgpIHtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IG51bGw7XG4gICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW50ZXJIeWRyYXRpb25TdGF0ZTogZW50ZXJIeWRyYXRpb25TdGF0ZSxcbiAgICByZXNldEh5ZHJhdGlvblN0YXRlOiByZXNldEh5ZHJhdGlvblN0YXRlLFxuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlOiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOiBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICBwb3BIeWRyYXRpb25TdGF0ZTogcG9wSHlkcmF0aW9uU3RhdGVcbiAgfTtcbn07XG5cbi8vIFRoaXMgbGV0cyB1cyBob29rIGludG8gRmliZXIgdG8gZGVidWcgd2hhdCBpdCdzIGRvaW5nLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzgwMzMuXG4vLyBUaGlzIGlzIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJLCBub3QgZXZlbiBmb3IgUmVhY3QgRGV2VG9vbHMuXG4vLyBZb3UgbWF5IG9ubHkgaW5qZWN0IGEgZGVidWdUb29sIGlmIHlvdSB3b3JrIG9uIFJlYWN0IEZpYmVyIGl0c2VsZi5cbnZhciBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uID0ge1xuICBkZWJ1Z1Rvb2w6IG51bGxcbn07XG5cbnZhciBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEgPSBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uO1xuXG52YXIgZGVmYXVsdFNob3dEaWFsb2cgPSBmdW5jdGlvbiAoY2FwdHVyZWRFcnJvcikge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBzaG93RGlhbG9nID0gZGVmYXVsdFNob3dEaWFsb2c7XG5cbmZ1bmN0aW9uIGxvZ0NhcHR1cmVkRXJyb3IoY2FwdHVyZWRFcnJvcikge1xuICB2YXIgbG9nRXJyb3IgPSBzaG93RGlhbG9nKGNhcHR1cmVkRXJyb3IpO1xuXG4gIC8vIEFsbG93IGluamVjdGVkIHNob3dEaWFsb2coKSB0byBwcmV2ZW50IGRlZmF1bHQgY29uc29sZS5lcnJvciBsb2dnaW5nLlxuICAvLyBUaGlzIGVuYWJsZXMgcmVuZGVyZXJzIGxpa2UgUmVhY3ROYXRpdmUgdG8gYmV0dGVyIG1hbmFnZSByZWRib3ggYmVoYXZpb3IuXG4gIGlmIChsb2dFcnJvciA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZXJyb3IgPSBjYXB0dXJlZEVycm9yLmVycm9yO1xuICB2YXIgc3VwcHJlc3NMb2dnaW5nID0gZXJyb3IgJiYgZXJyb3Iuc3VwcHJlc3NSZWFjdEVycm9yTG9nZ2luZztcbiAgaWYgKHN1cHByZXNzTG9nZ2luZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeU5hbWUsXG4gICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeUZvdW5kLFxuICAgICAgICB3aWxsUmV0cnkgPSBjYXB0dXJlZEVycm9yLndpbGxSZXRyeTtcblxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDwnICsgY29tcG9uZW50TmFtZSArICc+IGNvbXBvbmVudDonIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG5cbiAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgLy8gZXJyb3JCb3VuZGFyeUZvdW5kIGNoZWNrIGlzIHN1ZmZpY2llbnQ7IGVycm9yQm91bmRhcnlOYW1lIGNoZWNrIGlzIHRvIHNhdGlzZnkgRmxvdy5cbiAgICBpZiAoZXJyb3JCb3VuZGFyeUZvdW5kICYmIGVycm9yQm91bmRhcnlOYW1lKSB7XG4gICAgICBpZiAod2lsbFJldHJ5KSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1JlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoICcgKyAoJ3VzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdUaGlzIGVycm9yIHdhcyBpbml0aWFsbHkgaGFuZGxlZCBieSB0aGUgZXJyb3IgYm91bmRhcnkgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy5cXG4nICsgJ1JlY3JlYXRpbmcgdGhlIHRyZWUgZnJvbSBzY3JhdGNoIGZhaWxlZCBzbyBSZWFjdCB3aWxsIHVubW91bnQgdGhlIHRyZWUuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnQ29uc2lkZXIgYWRkaW5nIGFuIGVycm9yIGJvdW5kYXJ5IHRvIHlvdXIgdHJlZSB0byBjdXN0b21pemUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IuXFxuJyArICdWaXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWVycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG4gICAgfVxuICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPSAnJyArIGNvbXBvbmVudE5hbWVNZXNzYWdlICsgY29tcG9uZW50U3RhY2sgKyAnXFxuXFxuJyArICgnJyArIGVycm9yQm91bmRhcnlNZXNzYWdlKTtcblxuICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIGFuZCBKUyBzdGFjayBiZWNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuICAgIGNvbnNvbGUuZXJyb3IoY29tYmluZWRNZXNzYWdlKTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEgPSBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xudmFyIGhhc0NhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG57XG4gIHZhciBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSBmYWxzZTtcbiAgdmFyIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nKGZhbHNlLCAnQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyAnICsgJ2NvbXBvbmVudC4gVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgJyArICdvciBmb3JjZVVwZGF0ZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiBUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlICcgKyAnY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICB2YXIgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBzd2l0Y2ggKFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UpIHtcbiAgICAgIGNhc2UgJ2dldENoaWxkQ29udGV4dCc6XG4gICAgICAgIGlmIChkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJyk7XG4gICAgICAgIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVuZGVyJzpcbiAgICAgICAgaWYgKGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyB3aXRoaW4gJyArIFwiYHJlbmRlcmAgb3IgYW5vdGhlciBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzIHNob3VsZCBcIiArICdiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyBjb25zdHJ1Y3RvciBzaWRlLWVmZmVjdHMgYXJlICcgKyAnYW4gYW50aS1wYXR0ZXJuLCBidXQgY2FuIGJlIG1vdmVkIHRvIGBjb21wb25lbnRXaWxsTW91bnRgLicpO1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG59XG5cbnZhciBSZWFjdEZpYmVyU2NoZWR1bGVyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgaG9zdENvbnRleHQgPSBSZWFjdEZpYmVySG9zdENvbnRleHQoY29uZmlnKTtcbiAgdmFyIGh5ZHJhdGlvbkNvbnRleHQgPSBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dChjb25maWcpO1xuICB2YXIgcG9wSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgcmVzZXRIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucmVzZXRIb3N0Q29udGFpbmVyO1xuXG4gIHZhciBfUmVhY3RGaWJlckJlZ2luV29yayA9IFJlYWN0RmliZXJCZWdpbldvcmsoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKSxcbiAgICAgIGJlZ2luV29yayA9IF9SZWFjdEZpYmVyQmVnaW5Xb3JrLmJlZ2luV29yayxcbiAgICAgIGJlZ2luRmFpbGVkV29yayA9IF9SZWFjdEZpYmVyQmVnaW5Xb3JrLmJlZ2luRmFpbGVkV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21wbGV0ZVdvID0gUmVhY3RGaWJlckNvbXBsZXRlV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSxcbiAgICAgIGNvbXBsZXRlV29yayA9IF9SZWFjdEZpYmVyQ29tcGxldGVXby5jb21wbGV0ZVdvcms7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ29tbWl0V29yayA9IFJlYWN0RmliZXJDb21taXRXb3JrKGNvbmZpZywgY2FwdHVyZUVycm9yKSxcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFBsYWNlbWVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRQbGFjZW1lbnQsXG4gICAgICBjb21taXREZWxldGlvbiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcmsgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0V29yayxcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgIGNvbW1pdEF0dGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWYgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RGV0YWNoUmVmO1xuXG4gIHZhciBub3cgPSBjb25maWcubm93LFxuICAgICAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrID0gY29uZmlnLnNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayxcbiAgICAgIGNhbmNlbERlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuY2FuY2VsRGVmZXJyZWRDYWxsYmFjayxcbiAgICAgIHVzZVN5bmNTY2hlZHVsaW5nID0gY29uZmlnLnVzZVN5bmNTY2hlZHVsaW5nLFxuICAgICAgcHJlcGFyZUZvckNvbW1pdCA9IGNvbmZpZy5wcmVwYXJlRm9yQ29tbWl0LFxuICAgICAgcmVzZXRBZnRlckNvbW1pdCA9IGNvbmZpZy5yZXNldEFmdGVyQ29tbWl0O1xuXG4gIC8vIFJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdGltZSBpbiBtcy5cblxuICB2YXIgc3RhcnRUaW1lID0gbm93KCk7XG4gIHZhciBtb3N0UmVjZW50Q3VycmVudFRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUoMCk7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgZXhwaXJhdGlvbiB0aW1lIHRoYXQgaW5jb21pbmcgdXBkYXRlcyBzaG91bGQgdXNlLiAoSWYgdGhpc1xuICAvLyBpcyBOb1dvcmssIHVzZSB0aGUgZGVmYXVsdCBzdHJhdGVneTogYXN5bmMgdXBkYXRlcyBpbiBhc3luYyBtb2RlLCBzeW5jXG4gIC8vIHVwZGF0ZXMgaW4gc3luYyBtb2RlLilcbiAgdmFyIGV4cGlyYXRpb25Db250ZXh0ID0gTm9Xb3JrO1xuXG4gIHZhciBpc1dvcmtpbmcgPSBmYWxzZTtcblxuICAvLyBUaGUgbmV4dCB3b3JrIGluIHByb2dyZXNzIGZpYmVyIHRoYXQgd2UncmUgY3VycmVudGx5IHdvcmtpbmcgb24uXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IG51bGw7XG4gIHZhciBuZXh0Um9vdCA9IG51bGw7XG4gIC8vIFRoZSB0aW1lIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgd29yay5cbiAgdmFyIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBUaGUgbmV4dCBmaWJlciB3aXRoIGFuIGVmZmVjdCB0aGF0IHdlJ3JlIGN1cnJlbnRseSBjb21taXR0aW5nLlxuICB2YXIgbmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBmaWJlcnMgaGF2ZSBjYXB0dXJlZCBhbiBlcnJvciB0aGF0IG5lZWQgdG8gYmUgaGFuZGxlZC5cbiAgLy8gV29yayBpcyByZW1vdmVkIGZyb20gdGhpcyBjb2xsZWN0aW9uIGFmdGVyIGNvbXBvbmVudERpZENhdGNoIGlzIGNhbGxlZC5cbiAgdmFyIGNhcHR1cmVkRXJyb3JzID0gbnVsbDtcbiAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBmaWJlcnMgaGF2ZSBmYWlsZWQgZHVyaW5nIHRoZSBjdXJyZW50IGJhdGNoIG9mIHdvcmsuXG4gIC8vIFRoaXMgaXMgYSBkaWZmZXJlbnQgc2V0IHRoYW4gY2FwdHVyZWRFcnJvcnMsIGJlY2F1c2UgaXQgaXMgbm90IHJlc2V0IHVudGlsXG4gIC8vIHRoZSBlbmQgb2YgdGhlIGJhdGNoLiBUaGlzIGlzIG5lZWRlZCB0byBwcm9wYWdhdGUgZXJyb3JzIGNvcnJlY3RseSBpZiBhXG4gIC8vIHN1YnRyZWUgZmFpbHMgbW9yZSB0aGFuIG9uY2UuXG4gIHZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbiAgLy8gRXJyb3IgYm91bmRhcmllcyB0aGF0IGNhcHR1cmVkIGFuIGVycm9yIGR1cmluZyB0aGUgY3VycmVudCBjb21taXQuXG4gIHZhciBjb21taXRQaGFzZUJvdW5kYXJpZXMgPSBudWxsO1xuICB2YXIgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcbiAgdmFyIGRpZEZhdGFsID0gZmFsc2U7XG5cbiAgdmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICB2YXIgaXNVbm1vdW50aW5nID0gZmFsc2U7XG5cbiAgLy8gVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuXG4gIHZhciBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxuICBmdW5jdGlvbiByZXNldENvbnRleHRTdGFjaygpIHtcbiAgICAvLyBSZXNldCB0aGUgc3RhY2tcbiAgICByZXNldCQxKCk7XG4gICAgLy8gUmVzZXQgdGhlIGN1cnNvcnNcbiAgICByZXNldENvbnRleHQoKTtcbiAgICByZXNldEhvc3RDb250YWluZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbEhvc3RFZmZlY3RzKCkge1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgICAgfVxuICAgICAgcmVjb3JkRWZmZWN0KCk7XG5cbiAgICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcbiAgICAgIGlmIChlZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudChuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdERldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHN3aXRjaCBzdGF0ZW1lbnQgaXMgb25seSBjb25jZXJuZWQgYWJvdXQgcGxhY2VtZW50LFxuICAgICAgLy8gdXBkYXRlcywgYW5kIGRlbGV0aW9ucy4gVG8gYXZvaWQgbmVlZGluZyB0byBhZGQgYSBjYXNlIGZvciBldmVyeVxuICAgICAgLy8gcG9zc2libGUgYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlXG4gICAgICAvLyBlZmZlY3QgdGFnIGFuZCBzd2l0Y2ggb24gdGhhdCB2YWx1ZS5cbiAgICAgIHZhciBwcmltYXJ5RWZmZWN0VGFnID0gZWZmZWN0VGFnICYgfihDYWxsYmFjayB8IEVyciB8IENvbnRlbnRSZXNldCB8IFJlZiB8IFBlcmZvcm1lZFdvcmspO1xuICAgICAgc3dpdGNoIChwcmltYXJ5RWZmZWN0VGFnKSB7XG4gICAgICAgIGNhc2UgUGxhY2VtZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgICAgLy8gVE9ETzogZmluZERPTU5vZGUgZG9lc24ndCByZWx5IG9uIHRoaXMgYW55IG1vcmUgYnV0IGlzTW91bnRlZFxuICAgICAgICAgICAgLy8gZG9lcyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlXG4gICAgICAgICAgICAvLyB0byBraWxsIHRoaXMuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFBsYWNlbWVudEFuZFVwZGF0ZTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBQbGFjZW1lbnRcbiAgICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgICAgICB2YXIgX2N1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFVwZGF0ZTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2N1cnJlbnQyID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50MiwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgRGVsZXRpb246XG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbW1pdERlbGV0aW9uKG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgaXNVbm1vdW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgIH1cblxuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxMaWZlQ3ljbGVzKCkge1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiAoVXBkYXRlIHwgQ2FsbGJhY2spKSB7XG4gICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICBjb21taXRBdHRhY2hSZWYobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBFcnIpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEVycm9ySGFuZGxpbmcobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgY2xlYW4gdGhlc2UgdXAgc28gdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHkga2VlcCB0aGVtLlxuICAgICAgLy8gSSdtIG5vdCBhY3R1YWxseSBzdXJlIHRoaXMgbWF0dGVycyBiZWNhdXNlIHdlIGNhbid0IHJlc2V0IGZpcnN0RWZmZWN0XG4gICAgICAvLyBhbmQgbGFzdEVmZmVjdCBzaW5jZSB0aGV5J3JlIG9uIGV2ZXJ5IG5vZGUsIG5vdCBqdXN0IHRoZSBlZmZlY3RmdWxcbiAgICAgIC8vIG9uZXMuIFNvIHdlIGhhdmUgdG8gY2xlYW4gZXZlcnl0aGluZyBhcyB3ZSByZXVzZSBub2RlcyBhbnl3YXkuXG4gICAgICBuZXh0RWZmZWN0Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgcmVzZXQgdGhlIGVmZmVjdFRhZyBoZXJlIHNvIHRoYXQgd2UgY2FuIHJlbHkgb24gZWZmZWN0XG4gICAgICAvLyB0YWdzIHRvIHJlYXNvbiBhYm91dCB0aGUgY3VycmVudCBsaWZlLWN5Y2xlLlxuICAgICAgbmV4dEVmZmVjdCA9IG5leHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBXZSBrZWVwIHRyYWNrIG9mIHRoaXMgc28gdGhhdCBjYXB0dXJlRXJyb3IgY2FuIGNvbGxlY3QgYW55IGJvdW5kYXJpZXNcbiAgICAvLyB0aGF0IGNhcHR1cmUgYW4gZXJyb3IgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuIFRoZSByZWFzb24gdGhlc2UgYXJlbid0XG4gICAgLy8gbG9jYWwgdG8gdGhpcyBmdW5jdGlvbiBpcyBiZWNhdXNlIGVycm9ycyB0aGF0IG9jY3VyIGR1cmluZyBjV1UgYXJlXG4gICAgLy8gY2FwdHVyZWQgZWxzZXdoZXJlLCB0byBwcmV2ZW50IHRoZSB1bm1vdW50IGZyb20gYmVpbmcgaW50ZXJydXB0ZWQuXG4gICAgaXNXb3JraW5nID0gdHJ1ZTtcbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIHN0YXJ0Q29tbWl0VGltZXIoKTtcblxuICAgIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAhKHJvb3QuY3VycmVudCAhPT0gZmluaXNoZWRXb3JrKSA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjb21taXQgdGhlIHNhbWUgdHJlZSBhcyBiZWZvcmUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgcmVsYXRlZCB0byB0aGUgcmV0dXJuIGZpZWxkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA9IGZhbHNlO1xuXG4gICAgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHZhciBmaXJzdEVmZmVjdCA9IHZvaWQgMDtcbiAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAgIC8vIHRoZSByb290IGhhcyBhbiBlZmZlY3QsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuIFRoZVxuICAgICAgLy8gcmVzdWx0aW5nIGxpc3QgaXMgdGhlIHNldCB0aGF0IHdvdWxkIGJlbG9uZyB0byB0aGUgcm9vdCdzIHBhcmVudCwgaWZcbiAgICAgIC8vIGl0IGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgICBpZiAoZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gZWZmZWN0IG9uIHRoZSByb290LlxuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfVxuXG4gICAgcHJlcGFyZUZvckNvbW1pdCgpO1xuXG4gICAgLy8gQ29tbWl0IGFsbCB0aGUgc2lkZS1lZmZlY3RzIHdpdGhpbiBhIHRyZWUuIFdlJ2xsIGRvIHRoaXMgaW4gdHdvIHBhc3Nlcy5cbiAgICAvLyBUaGUgZmlyc3QgcGFzcyBwZXJmb3JtcyBhbGwgdGhlIGhvc3QgaW5zZXJ0aW9ucywgdXBkYXRlcywgZGVsZXRpb25zIGFuZFxuICAgIC8vIHJlZiB1bm1vdW50cy5cbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gICAgc3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9lcnJvciA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgY29tbWl0QWxsSG9zdEVmZmVjdHMsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAhKG5leHRFZmZlY3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgbmV4dCBlZmZlY3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgIGNhcHR1cmVFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IpO1xuICAgICAgICAvLyBDbGVhbi11cFxuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcblxuICAgIHJlc2V0QWZ0ZXJDb21taXQoKTtcblxuICAgIC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUgaXMgbm93IHRoZSBjdXJyZW50IHRyZWUuIFRoaXMgbXVzdCBjb21lIGFmdGVyXG4gICAgLy8gdGhlIGZpcnN0IHBhc3Mgb2YgdGhlIGNvbW1pdCBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbFxuICAgIC8vIGN1cnJlbnQgZHVyaW5nIGNvbXBvbmVudFdpbGxVbm1vdW50LCBidXQgYmVmb3JlIHRoZSBzZWNvbmQgcGFzcywgc28gdGhhdFxuICAgIC8vIHRoZSBmaW5pc2hlZCB3b3JrIGlzIGN1cnJlbnQgZHVyaW5nIGNvbXBvbmVudERpZE1vdW50L1VwZGF0ZS5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG5cbiAgICAvLyBJbiB0aGUgc2Vjb25kIHBhc3Mgd2UnbGwgcGVyZm9ybSBhbGwgbGlmZS1jeWNsZXMgYW5kIHJlZiBjYWxsYmFja3MuXG4gICAgLy8gTGlmZS1jeWNsZXMgaGFwcGVuIGFzIGEgc2VwYXJhdGUgcGFzcyBzbyB0aGF0IGFsbCBwbGFjZW1lbnRzLCB1cGRhdGVzLFxuICAgIC8vIGFuZCBkZWxldGlvbnMgaW4gdGhlIGVudGlyZSB0cmVlIGhhdmUgYWxyZWFkeSBiZWVuIGludm9rZWQuXG4gICAgLy8gVGhpcyBwYXNzIGFsc28gdHJpZ2dlcnMgYW55IHJlbmRlcmVyLXNwZWNpZmljIGluaXRpYWwgZWZmZWN0cy5cbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gICAgc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9kaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9lcnJvcjIgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIGNvbW1pdEFsbExpZmVDeWNsZXMsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIF9kaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yMiA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9kaWRFcnJvcikge1xuICAgICAgICAhKG5leHRFZmZlY3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgbmV4dCBlZmZlY3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgIGNhcHR1cmVFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IyKTtcbiAgICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgaXNXb3JraW5nID0gZmFsc2U7XG4gICAgc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHN0b3BDb21taXRUaW1lcigpO1xuICAgIGlmICh0eXBlb2Ygb25Db21taXRSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkNvbW1pdFJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21taXRXb3JrKGZpbmlzaGVkV29yayk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgY2F1Z2h0IGFueSBlcnJvcnMgZHVyaW5nIHRoaXMgY29tbWl0LCBzY2hlZHVsZSB0aGVpciBib3VuZGFyaWVzXG4gICAgLy8gdG8gdXBkYXRlLlxuICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMpIHtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcy5mb3JFYWNoKHNjaGVkdWxlRXJyb3JSZWNvdmVyeSk7XG4gICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHZhciBfZXJyb3IzID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIG9uVW5jYXVnaHRFcnJvcihfZXJyb3IzKTtcbiAgICB9XG5cbiAgICB2YXIgcmVtYWluaW5nVGltZSA9IHJvb3QuY3VycmVudC5leHBpcmF0aW9uVGltZTtcblxuICAgIGlmIChyZW1haW5pbmdUaW1lID09PSBOb1dvcmspIHtcbiAgICAgIGNhcHR1cmVkRXJyb3JzID0gbnVsbDtcbiAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZW1haW5pbmdUaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyVGltZSkge1xuICAgIGlmIChyZW5kZXJUaW1lICE9PSBOZXZlciAmJiB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTmV2ZXIpIHtcbiAgICAgIC8vIFRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCBhcmUgaGlkZGVuLiBEb24ndCBidWJibGUgdGhlaXJcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHBlbmRpbmcgdXBkYXRlcy5cbiAgICB2YXIgbmV3RXhwaXJhdGlvblRpbWUgPSBnZXRVcGRhdGVFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBDYWxscyBuZWVkIHRvIHZpc2l0IHN0YXRlTm9kZVxuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQuZXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobmV3RXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXdFeHBpcmF0aW9uVGltZSA+IGNoaWxkLmV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgICBuZXdFeHBpcmF0aW9uVGltZSA9IGNoaWxkLmV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IG5ld0V4cGlyYXRpb25UaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAgIC8vIHByb2dyZXNzLlxuICAgICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzWydyZXR1cm4nXTtcbiAgICAgIHZhciBzaWJsaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuXG4gICAgICByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQXBwZW5kIGFsbCB0aGUgZWZmZWN0cyBvZiB0aGUgc3VidHJlZSBhbmQgdGhpcyBmaWJlciBvbnRvIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgcGFyZW50LiBUaGUgY29tcGxldGlvbiBvcmRlciBvZiB0aGUgY2hpbGRyZW4gYWZmZWN0cyB0aGVcbiAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBmaWJlciBoYWQgc2lkZS1lZmZlY3RzLCB3ZSBhcHBlbmQgaXQgQUZURVIgdGhlIGNoaWxkcmVuJ3NcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBXZSBjYW4gcGVyZm9ybSBjZXJ0YWluIHNpZGUtZWZmZWN0cyBlYXJsaWVyIGlmXG4gICAgICAgIC8vIG5lZWRlZCwgYnkgZG9pbmcgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGVmZmVjdCBsaXN0LiBXZSBkb24ndCB3YW50XG4gICAgICAgIC8vIHRvIHNjaGVkdWxlIG91ciBvd24gc2lkZS1lZmZlY3Qgb24gb3VyIG93biBsaXN0IGJlY2F1c2UgaWYgZW5kIHVwXG4gICAgICAgIC8vIHJldXNpbmcgY2hpbGRyZW4gd2UnbGwgc2NoZWR1bGUgdGhpcyBlZmZlY3Qgb250byBpdHNlbGYgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gYXQgdGhlIGVuZC5cbiAgICAgICAgdmFyIGVmZmVjdFRhZyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgLy8gU2tpcCBib3RoIE5vV29yayBhbmQgUGVyZm9ybWVkV29yayB0YWdzIHdoZW4gY3JlYXRpbmcgdGhlIGVmZmVjdCBsaXN0LlxuICAgICAgICAvLyBQZXJmb3JtZWRXb3JrIGVmZmVjdCBpcyByZWFkIGJ5IFJlYWN0IERldlRvb2xzIGJ1dCBzaG91bGRuJ3QgYmUgY29tbWl0dGVkLlxuICAgICAgICBpZiAoZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgICByZXR1cm4gc2libGluZ0ZpYmVyO1xuICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG1vcmUgd29yayBpbiB0aGlzIHJldHVybkZpYmVyLiBDb21wbGV0ZSB0aGUgcmV0dXJuRmliZXIuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cbiAgICAgICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdpdGhvdXQgdGhpcyBleHBsaWNpdCBudWxsIHJldHVybiBGbG93IGNvbXBsYWlucyBvZiBpbnZhbGlkIHJldHVybiB0eXBlXG4gICAgLy8gVE9ETyBSZW1vdmUgdGhlIGFib3ZlIHdoaWxlKHRydWUpIGxvb3BcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgLy8gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICAvLyBTZWUgaWYgYmVnaW5uaW5nIHRoaXMgd29yayBzcGF3bnMgbW9yZSB3b3JrLlxuICAgIHN0YXJ0V29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgLy8gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICAvLyBTZWUgaWYgYmVnaW5uaW5nIHRoaXMgd29yayBzcGF3bnMgbW9yZSB3b3JrLlxuICAgIHN0YXJ0V29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0ID0gYmVnaW5GYWlsZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiB3b3JrTG9vcChleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIHVuaGFuZGxlZCBlcnJvcnMsIHN3aXRjaCB0byB0aGUgc2xvdyB3b3JrIGxvb3AuXG4gICAgICAvLyBUT0RPOiBIb3cgdG8gYXZvaWQgdGhpcyBjaGVjayBpbiB0aGUgZmFzdCBwYXRoPyBNYXliZSB0aGUgcmVuZGVyZXJcbiAgICAgIC8vIGNvdWxkIGtlZXAgdHJhY2sgb2Ygd2hpY2ggcm9vdHMgaGF2ZSB1bmhhbmRsZWQgZXJyb3JzIGFuZCBjYWxsIGFcbiAgICAgIC8vIGZvcmtlZCB2ZXJzaW9uIG9mIHJlbmRlclJvb3QuXG4gICAgICBzbG93V29ya0xvb3BUaGF0Q2hlY2tzRm9yRmFpbGVkV29yayhleHBpcmF0aW9uVGltZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPD0gbW9zdFJlY2VudEN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBGbHVzaCBhbGwgZXhwaXJlZCB3b3JrLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzbG93V29ya0xvb3BUaGF0Q2hlY2tzRm9yRmFpbGVkV29yayhleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPD0gbW9zdFJlY2VudEN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBGbHVzaCBhbGwgZXhwaXJlZCB3b3JrLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChoYXNDYXB0dXJlZEVycm9yKG5leHRVbml0T2ZXb3JrKSkge1xuICAgICAgICAgIC8vIFVzZSBhIGZvcmtlZCB2ZXJzaW9uIG9mIHBlcmZvcm1Vbml0T2ZXb3JrXG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIHJ1bnMgb3V0IG9mIHRpbWUuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgaWYgKGhhc0NhcHR1cmVkRXJyb3IobmV4dFVuaXRPZldvcmspKSB7XG4gICAgICAgICAgLy8gVXNlIGEgZm9ya2VkIHZlcnNpb24gb2YgcGVyZm9ybVVuaXRPZldvcmtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3RDYXRjaEJsb2NrKHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHJlc3RhcnQgdGhlIGVycm9yIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLlxuICAgIC8vIENvbmNlcHR1YWxseSwgd2UncmUgdW53aW5kaW5nIHRoZSBzdGFjay4gV2UgbmVlZCB0byB1bndpbmQgdGhlXG4gICAgLy8gY29udGV4dCBzdGFjaywgdG9vLlxuICAgIHVud2luZENvbnRleHRzKGZhaWxlZFdvcmssIGJvdW5kYXJ5KTtcblxuICAgIC8vIFJlc3RhcnQgdGhlIGVycm9yIGJvdW5kYXJ5IHVzaW5nIGEgZm9ya2VkIHZlcnNpb24gb2ZcbiAgICAvLyBwZXJmb3JtVW5pdE9mV29yayB0aGF0IGRlbGV0ZXMgdGhlIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoZSBlbnRpcmVcbiAgICAvLyBmYWlsZWQgc3VicmVlIHdpbGwgYmUgdW5tb3VudGVkLiBEdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSwgYSBzcGVjaWFsXG4gICAgLy8gbGlmZWN5Y2xlIG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIGVycm9yIGJvdW5kYXJ5LCB3aGljaCB0cmlnZ2Vyc1xuICAgIC8vIGEgcmUtcmVuZGVyLlxuICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsoYm91bmRhcnkpO1xuXG4gICAgLy8gQ29udGludWUgd29ya2luZy5cbiAgICB3b3JrTG9vcChleHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1dvcmtpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJSb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgaXNXb3JraW5nID0gdHJ1ZTtcblxuICAgIC8vIFdlJ3JlIGFib3V0IHRvIG11dGF0ZSB0aGUgd29yay1pbi1wcm9ncmVzcyB0cmVlLiBJZiB0aGUgcm9vdCB3YXMgcGVuZGluZ1xuICAgIC8vIGNvbW1pdCwgaXQgbm8gbG9uZ2VyIGlzOiB3ZSdsbCBuZWVkIHRvIGNvbXBsZXRlIGl0IGFnYWluLlxuICAgIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgc3RhcnRpbmcgZnJvbSBhIGZyZXNoIHN0YWNrLCBvciBpZiB3ZSdyZSByZXN1bWluZyBmcm9tXG4gICAgLy8gcHJldmlvdXNseSB5aWVsZGVkIHdvcmsuXG4gICAgaWYgKHJvb3QgIT09IG5leHRSb290IHx8IGV4cGlyYXRpb25UaW1lICE9PSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgfHwgbmV4dFVuaXRPZldvcmsgPT09IG51bGwpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBzdGFjayBhbmQgc3RhcnQgd29ya2luZyBmcm9tIHRoZSByb290LlxuICAgICAgcmVzZXRDb250ZXh0U3RhY2soKTtcbiAgICAgIG5leHRSb290ID0gcm9vdDtcbiAgICAgIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhuZXh0Um9vdC5jdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKTtcblxuICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgd29ya0xvb3AsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQW4gZXJyb3Igd2FzIHRocm93biBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICB3aGlsZSAoZGlkRXJyb3IpIHtcbiAgICAgIGlmIChkaWRGYXRhbCkge1xuICAgICAgICAvLyBUaGlzIHdhcyBhIGZhdGFsIGVycm9yLiBEb24ndCBhdHRlbXB0IHRvIHJlY292ZXIgZnJvbSBpdC5cbiAgICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFpbGVkV29yayA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgaWYgKGZhaWxlZFdvcmsgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQW4gZXJyb3Igd2FzIHRocm93biBidXQgdGhlcmUncyBubyBjdXJyZW50IHVuaXQgb2Ygd29yay4gVGhpcyBjYW5cbiAgICAgICAgLy8gaGFwcGVuIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIGlmIHRoZXJlJ3MgYSBidWcgaW4gdGhlIHJlbmRlcmVyLlxuICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBcIkNhcHR1cmVcIiB0aGUgZXJyb3IgYnkgZmluZGluZyB0aGUgbmVhcmVzdCBib3VuZGFyeS4gSWYgdGhlcmUgaXMgbm9cbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5LCB3ZSB1c2UgdGhlIHJvb3QuXG4gICAgICB2YXIgYm91bmRhcnkgPSBjYXB0dXJlRXJyb3IoZmFpbGVkV29yaywgZXJyb3IpO1xuICAgICAgIShib3VuZGFyeSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBmb3VuZCBhbiBlcnJvciBib3VuZGFyeS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICAgIC8vIFRoZSBlcnJvciB3ZSBqdXN0IGNhcHR1cmVkIHdhcyBhIGZhdGFsIGVycm9yLiBUaGlzIGhhcHBlbnNcbiAgICAgICAgLy8gd2hlbiB0aGUgZXJyb3IgcHJvcGFnYXRlcyB0byB0aGUgcm9vdCBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICBlcnJvciA9IG51bGw7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIHJlbmRlclJvb3RDYXRjaEJsb2NrLCBudWxsLCByb290LCBmYWlsZWRXb3JrLCBib3VuZGFyeSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UncmUgZmluaXNoZWQgd29ya2luZy4gRXhpdCB0aGUgZXJyb3IgbG9vcC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciB1bmNhdWdodEVycm9yID0gZmlyc3RVbmNhdWdodEVycm9yO1xuXG4gICAgLy8gV2UncmUgZG9uZSBwZXJmb3JtaW5nIHdvcmsuIFRpbWUgdG8gY2xlYW4gdXAuXG4gICAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSk7XG4gICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgaXNXb3JraW5nID0gZmFsc2U7XG4gICAgZGlkRmF0YWwgPSBmYWxzZTtcbiAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4gICAgaWYgKHVuY2F1Z2h0RXJyb3IgIT09IG51bGwpIHtcbiAgICAgIG9uVW5jYXVnaHRFcnJvcih1bmNhdWdodEVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID8gcm9vdC5jdXJyZW50LmFsdGVybmF0ZSA6IG51bGw7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBib3VuZGFyeSB0aGF0IGNhcHR1cmVkIHRoZSBlcnJvciwgb3IgbnVsbCBpZiB0aGUgZXJyb3IgaXMgaWdub3JlZFxuICBmdW5jdGlvbiBjYXB0dXJlRXJyb3IoZmFpbGVkV29yaywgZXJyb3IpIHtcbiAgICAvLyBJdCBpcyBubyBsb25nZXIgdmFsaWQgYmVjYXVzZSB3ZSBleGl0ZWQgdGhlIHVzZXIgY29kZS5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoIGZvciB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeS5cbiAgICB2YXIgYm91bmRhcnkgPSBudWxsO1xuXG4gICAgLy8gUGFzc2VkIHRvIGxvZ0NhcHR1cmVkRXJyb3IoKVxuICAgIHZhciBlcnJvckJvdW5kYXJ5Rm91bmQgPSBmYWxzZTtcbiAgICB2YXIgd2lsbFJldHJ5ID0gZmFsc2U7XG4gICAgdmFyIGVycm9yQm91bmRhcnlOYW1lID0gbnVsbDtcblxuICAgIC8vIEhvc3QgY29udGFpbmVycyBhcmUgYSBzcGVjaWFsIGNhc2UuIElmIHRoZSBmYWlsZWQgd29yayBpdHNlbGYgaXMgYSBob3N0XG4gICAgLy8gY29udGFpbmVyLCB0aGVuIGl0IGFjdHMgYXMgaXRzIG93biBib3VuZGFyeS4gSW4gYWxsIG90aGVyIGNhc2VzLCB3ZVxuICAgIC8vIGlnbm9yZSB0aGUgd29yayBpdHNlbGYgYW5kIG9ubHkgc2VhcmNoIHRocm91Z2ggdGhlIHBhcmVudHMuXG4gICAgaWYgKGZhaWxlZFdvcmsudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgYm91bmRhcnkgPSBmYWlsZWRXb3JrO1xuXG4gICAgICBpZiAoaXNGYWlsZWRCb3VuZGFyeShmYWlsZWRXb3JrKSkge1xuICAgICAgICAvLyBJZiB0aGlzIHJvb3QgYWxyZWFkeSBmYWlsZWQsIHRoZXJlIG11c3QgaGF2ZSBiZWVuIGFuIGVycm9yIHdoZW5cbiAgICAgICAgLy8gYXR0ZW1wdGluZyB0byB1bm1vdW50IGl0LiBUaGlzIGlzIGEgd29yc3QtY2FzZSBzY2VuYXJpbyBhbmRcbiAgICAgICAgLy8gc2hvdWxkIG9ubHkgYmUgcG9zc2libGUgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGUgPSBmYWlsZWRXb3JrWydyZXR1cm4nXTtcbiAgICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lKG5vZGUpO1xuXG4gICAgICAgICAgICAvLyBGb3VuZCBhbiBlcnJvciBib3VuZGFyeSFcbiAgICAgICAgICAgIGJvdW5kYXJ5ID0gbm9kZTtcbiAgICAgICAgICAgIHdpbGxSZXRyeSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICAgIC8vIFRyZWF0IHRoZSByb290IGxpa2UgYSBuby1vcCBlcnJvciBib3VuZGFyeVxuICAgICAgICAgIGJvdW5kYXJ5ID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KG5vZGUpKSB7XG4gICAgICAgICAgLy8gVGhpcyBib3VuZGFyeSBpcyBhbHJlYWR5IGluIGEgZmFpbGVkIHN0YXRlLlxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHVubW91bnRpbmcsIHRoYXQgbWVhbnMgdGhpcyBlcnJvciB3YXNcbiAgICAgICAgICAvLyB0aHJvd24gd2hpbGUgdW5tb3VudGluZyBhIGZhaWxlZCBzdWJ0cmVlLiBXZSBzaG91bGQgaWdub3JlXG4gICAgICAgICAgLy8gdGhlIGVycm9yLlxuICAgICAgICAgIGlmIChpc1VubW91bnRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBjb21taXQgcGhhc2UsIHdlIHNob3VsZCBjaGVjayB0byBzZWUgaWZcbiAgICAgICAgICAvLyB0aGlzIGJvdW5kYXJ5IGFscmVhZHkgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoaXMgY29tbWl0LlxuICAgICAgICAgIC8vIFRoaXMgY2FzZSBleGlzdHMgYmVjYXVzZSBtdWx0aXBsZSBlcnJvcnMgY2FuIGJlIHRocm93biBkdXJpbmdcbiAgICAgICAgICAvLyBhIHNpbmdsZSBjb21taXQgd2l0aG91dCBpbnRlcnJ1cHRpb24uXG4gICAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyAhPT0gbnVsbCAmJiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzLmhhcyhub2RlKSB8fCBub2RlLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUuYWx0ZXJuYXRlKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHNvLCB3ZSBzaG91bGQgaWdub3JlIHRoaXMgZXJyb3IuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUaGUgZXJyb3Igc2hvdWxkIHByb3BhZ2F0ZSB0byB0aGUgbmV4dCBib3VuZGFyeSAt4oCUIHdlIGtlZXAgbG9va2luZy5cbiAgICAgICAgICBib3VuZGFyeSA9IG51bGw7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJvdW5kYXJ5ICE9PSBudWxsKSB7XG4gICAgICAvLyBBZGQgdG8gdGhlIGNvbGxlY3Rpb24gb2YgZmFpbGVkIGJvdW5kYXJpZXMuIFRoaXMgbGV0cyB1cyBrbm93IHRoYXRcbiAgICAgIC8vIHN1YnNlcXVlbnQgZXJyb3JzIGluIHRoaXMgc3VidHJlZSBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuICAgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgPT09IG51bGwpIHtcbiAgICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIGZhaWxlZEJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcblxuICAgICAgLy8gVGhpcyBtZXRob2QgaXMgdW5zYWZlIG91dHNpZGUgb2YgdGhlIGJlZ2luIGFuZCBjb21wbGV0ZSBwaGFzZXMuXG4gICAgICAvLyBXZSBtaWdodCBiZSBpbiB0aGUgY29tbWl0IHBoYXNlIHdoZW4gYW4gZXJyb3IgaXMgY2FwdHVyZWQuXG4gICAgICAvLyBUaGUgcmlzayBpcyB0aGF0IHRoZSByZXR1cm4gcGF0aCBmcm9tIHRoaXMgRmliZXIgbWF5IG5vdCBiZSBhY2N1cmF0ZS5cbiAgICAgIC8vIFRoYXQgcmlzayBpcyBhY2NlcHRhYmxlIGdpdmVuIHRoZSBiZW5lZml0IG9mIHByb3ZpZGluZyB1c2VycyBtb3JlIGNvbnRleHQuXG4gICAgICB2YXIgX2NvbXBvbmVudFN0YWNrID0gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihmYWlsZWRXb3JrKTtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmFpbGVkV29yayk7XG5cbiAgICAgIC8vIEFkZCB0byB0aGUgY29sbGVjdGlvbiBvZiBjYXB0dXJlZCBlcnJvcnMuIFRoaXMgaXMgc3RvcmVkIGFzIGEgZ2xvYmFsXG4gICAgICAvLyBtYXAgb2YgZXJyb3JzIGFuZCB0aGVpciBjb21wb25lbnQgc3RhY2sgbG9jYXRpb24ga2V5ZWQgYnkgdGhlIGJvdW5kYXJpZXNcbiAgICAgIC8vIHRoYXQgY2FwdHVyZSB0aGVtLiBXZSBtb3N0bHkgdXNlIHRoaXMgTWFwIGFzIGEgU2V0OyBpdCdzIGEgTWFwIG9ubHkgdG9cbiAgICAgIC8vIGF2b2lkIGFkZGluZyBhIGZpZWxkIHRvIEZpYmVyIHRvIHN0b3JlIHRoZSBlcnJvci5cbiAgICAgIGlmIChjYXB0dXJlZEVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICBjYXB0dXJlZEVycm9ycyA9IG5ldyBNYXAoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhcHR1cmVkRXJyb3IgPSB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IF9jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjazogX2NvbXBvbmVudFN0YWNrLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGVycm9yQm91bmRhcnk6IGVycm9yQm91bmRhcnlGb3VuZCA/IGJvdW5kYXJ5LnN0YXRlTm9kZSA6IG51bGwsXG4gICAgICAgIGVycm9yQm91bmRhcnlGb3VuZDogZXJyb3JCb3VuZGFyeUZvdW5kLFxuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZTogZXJyb3JCb3VuZGFyeU5hbWUsXG4gICAgICAgIHdpbGxSZXRyeTogd2lsbFJldHJ5XG4gICAgICB9O1xuXG4gICAgICBjYXB0dXJlZEVycm9ycy5zZXQoYm91bmRhcnksIGNhcHR1cmVkRXJyb3IpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsb2dDYXB0dXJlZEVycm9yKGNhcHR1cmVkRXJyb3IpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBQcmV2ZW50IGN5Y2xlIGlmIGxvZ0NhcHR1cmVkRXJyb3IoKSB0aHJvd3MuXG4gICAgICAgIC8vIEEgY3ljbGUgbWF5IHN0aWxsIG9jY3VyIGlmIGxvZ0NhcHR1cmVkRXJyb3IgcmVuZGVycyBhIGNvbXBvbmVudCB0aGF0IHRocm93cy5cbiAgICAgICAgdmFyIHN1cHByZXNzTG9nZ2luZyA9IGUgJiYgZS5zdXBwcmVzc1JlYWN0RXJyb3JMb2dnaW5nO1xuICAgICAgICBpZiAoIXN1cHByZXNzTG9nZ2luZykge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIGNvbW1pdCBwaGFzZSwgZGVmZXIgc2NoZWR1bGluZyBhbiB1cGRhdGUgb24gdGhlXG4gICAgICAvLyBib3VuZGFyeSB1bnRpbCBhZnRlciB0aGUgY29tbWl0IGlzIGNvbXBsZXRlXG4gICAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmFkZChib3VuZGFyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHNjaGVkdWxlIGFuIHVwZGF0ZSBub3cuXG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMgYWN0dWFsbHkgbmVjZXNzYXJ5IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlPyBJcyBpdFxuICAgICAgICAvLyBwb3NzaWJsZSB0byB1bndpbmQgYW5kIGNvbnRpbnVlIHJlbmRlcmluZyBhdCB0aGUgc2FtZSBwcmlvcml0eSxcbiAgICAgICAgLy8gd2l0aG91dCBjb3JydXB0aW5nIGludGVybmFsIHN0YXRlP1xuICAgICAgICBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoYm91bmRhcnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJvdW5kYXJ5O1xuICAgIH0gZWxzZSBpZiAoZmlyc3RVbmNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICAvLyBJZiBubyBib3VuZGFyeSBpcyBmb3VuZCwgd2UnbGwgbmVlZCB0byB0aHJvdyB0aGUgZXJyb3JcbiAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0NhcHR1cmVkRXJyb3IoZmliZXIpIHtcbiAgICAvLyBUT0RPOiBjYXB0dXJlZEVycm9ycyBzaG91bGQgc3RvcmUgdGhlIGJvdW5kYXJ5IGluc3RhbmNlLCB0byBhdm9pZCBuZWVkaW5nXG4gICAgLy8gdG8gY2hlY2sgdGhlIGFsdGVybmF0ZS5cbiAgICByZXR1cm4gY2FwdHVyZWRFcnJvcnMgIT09IG51bGwgJiYgKGNhcHR1cmVkRXJyb3JzLmhhcyhmaWJlcikgfHwgZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNhcHR1cmVkRXJyb3JzLmhhcyhmaWJlci5hbHRlcm5hdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFpbGVkQm91bmRhcnkoZmliZXIpIHtcbiAgICAvLyBUT0RPOiBmYWlsZWRCb3VuZGFyaWVzIHNob3VsZCBzdG9yZSB0aGUgYm91bmRhcnkgaW5zdGFuY2UsIHRvIGF2b2lkXG4gICAgLy8gbmVlZGluZyB0byBjaGVjayB0aGUgYWx0ZXJuYXRlLlxuICAgIHJldHVybiBmYWlsZWRCb3VuZGFyaWVzICE9PSBudWxsICYmIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHwgZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RXJyb3JIYW5kbGluZyhlZmZlY3RmdWxGaWJlcikge1xuICAgIHZhciBjYXB0dXJlZEVycm9yID0gdm9pZCAwO1xuICAgIGlmIChjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCkge1xuICAgICAgY2FwdHVyZWRFcnJvciA9IGNhcHR1cmVkRXJyb3JzLmdldChlZmZlY3RmdWxGaWJlcik7XG4gICAgICBjYXB0dXJlZEVycm9yc1snZGVsZXRlJ10oZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgaWYgKGNhcHR1cmVkRXJyb3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoZWZmZWN0ZnVsRmliZXIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgZWZmZWN0ZnVsRmliZXIgPSBlZmZlY3RmdWxGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgY2FwdHVyZWRFcnJvciA9IGNhcHR1cmVkRXJyb3JzLmdldChlZmZlY3RmdWxGaWJlcik7XG4gICAgICAgICAgY2FwdHVyZWRFcnJvcnNbJ2RlbGV0ZSddKGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICEoY2FwdHVyZWRFcnJvciAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ05vIGVycm9yIGZvciBnaXZlbiB1bml0IG9mIHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBzd2l0Y2ggKGVmZmVjdGZ1bEZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZWZmZWN0ZnVsRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiBjYXB0dXJlZEVycm9yLmNvbXBvbmVudFN0YWNrXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWxsb3cgdGhlIGJvdW5kYXJ5IHRvIGhhbmRsZSB0aGUgZXJyb3IsIHVzdWFsbHkgYnkgc2NoZWR1bGluZ1xuICAgICAgICAvLyBhbiB1cGRhdGUgdG8gaXRzZWxmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGNhcHR1cmVkRXJyb3IuZXJyb3IsIGluZm8pO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBpZiAoZmlyc3RVbmNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bndpbmRDb250ZXh0cyhmcm9tLCB0bykge1xuICAgIHZhciBub2RlID0gZnJvbTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHRvIHx8IG5vZGUuYWx0ZXJuYXRlID09PSB0bykge1xuICAgICAgICBzdG9wRmFpbGVkV29ya1RpbWVyKG5vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIobm9kZSk7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpIHtcbiAgICAvLyBHaXZlbiB0aGUgY3VycmVudCBjbG9jayB0aW1lLCByZXR1cm5zIGFuIGV4cGlyYXRpb24gdGltZS4gV2UgdXNlIHJvdW5kaW5nXG4gICAgLy8gdG8gYmF0Y2ggbGlrZSB1cGRhdGVzIHRvZ2V0aGVyLlxuICAgIC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gfjEwMDBtcy4gMTIwMG1zIG1heC5cbiAgICB2YXIgY3VycmVudFRpbWUgPSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGV4cGlyYXRpb25NcyA9IDEwMDA7XG4gICAgdmFyIGJ1Y2tldFNpemVNcyA9IDIwMDtcbiAgICByZXR1cm4gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25NcywgYnVja2V0U2l6ZU1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpIHtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSB2b2lkIDA7XG4gICAgaWYgKGV4cGlyYXRpb25Db250ZXh0ICE9PSBOb1dvcmspIHtcbiAgICAgIC8vIEFuIGV4cGxpY2l0IGV4cGlyYXRpb24gY29udGV4dCB3YXMgc2V0O1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICB9IGVsc2UgaWYgKGlzV29ya2luZykge1xuICAgICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgICAvLyBVcGRhdGVzIHRoYXQgb2NjdXIgZHVyaW5nIHRoZSBjb21taXQgcGhhc2Ugc2hvdWxkIGhhdmUgc3luYyBwcmlvcml0eVxuICAgICAgICAvLyBieSBkZWZhdWx0LlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGRhdGVzIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIHNob3VsZCBleHBpcmUgYXQgdGhlIHNhbWUgdGltZSBhc1xuICAgICAgICAvLyB0aGUgd29yayB0aGF0IGlzIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQsIGFuZCB3ZSdyZSBub3QgY3VycmVudGx5XG4gICAgICAvLyBwZXJmb3JtaW5nIHdvcmsuIENhbGN1bGF0ZSBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAodXNlU3luY1NjaGVkdWxpbmcgJiYgIShmaWJlci5pbnRlcm5hbENvbnRleHRUYWcgJiBBc3luY1VwZGF0ZXMpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzeW5jIHVwZGF0ZVxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGFzeW5jIHVwZGF0ZVxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cGlyYXRpb25UaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHJldHVybiBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBleHBpcmF0aW9uVGltZSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tSb290TmVlZHNDbGVhcmluZyhyb290LCBmaWJlciwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoIWlzV29ya2luZyAmJiByb290ID09PSBuZXh0Um9vdCAmJiBleHBpcmF0aW9uVGltZSA8IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gUmVzdGFydCB0aGUgcm9vdCBmcm9tIHRoZSB0b3AuXG4gICAgICBpZiAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnRlcnJ1cHRpb24uIChVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy4pXG4gICAgICAgIGludGVycnVwdGVkQnkgPSBmaWJlcjtcbiAgICAgIH1cbiAgICAgIG5leHRSb290ID0gbnVsbDtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgICAgIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBleHBpcmF0aW9uVGltZSwgaXNFcnJvclJlY292ZXJ5KSB7XG4gICAgcmVjb3JkU2NoZWR1bGVVcGRhdGUoKTtcblxuICAgIHtcbiAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgICAgICB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyhpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSBlYWNoIG5vZGUnc1xuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKG5vZGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBub2RlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgbm9kZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICBub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBjaGVja1Jvb3ROZWVkc0NsZWFyaW5nKHJvb3QsIGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGNoZWNrUm9vdE5lZWRzQ2xlYXJpbmcocm9vdCwgZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWlzRXJyb3JSZWNvdmVyeSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkKGZpYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVFcnJvclJlY292ZXJ5KGZpYmVyKSB7XG4gICAgc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgU3luYywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkge1xuICAgIC8vIFN1YnRyYWN0IGluaXRpYWwgdGltZSBzbyBpdCBmaXRzIGluc2lkZSAzMmJpdHNcbiAgICB2YXIgbXMgPSBub3coKSAtIHN0YXJ0VGltZTtcbiAgICBtb3N0UmVjZW50Q3VycmVudFRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUobXMpO1xuICAgIHJldHVybiBtb3N0UmVjZW50Q3VycmVudFRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZlcnJlZFVwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwaXJhdGlvbkNvbnRleHQgPSBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmNVcGRhdGVzKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IFN5bmM7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogRXZlcnl0aGluZyBiZWxvdyB0aGlzIGlzIHdyaXR0ZW4gYXMgaWYgaXQgaGFzIGJlZW4gbGlmdGVkIHRvIHRoZVxuICAvLyByZW5kZXJlcnMuIEknbGwgZG8gdGhpcyBpbiBhIGZvbGxvdy11cC5cblxuICAvLyBMaW5rZWQtbGlzdCBvZiByb290c1xuICB2YXIgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgdmFyIGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcblxuICB2YXIgY2FsbGJhY2tFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgdmFyIGNhbGxiYWNrSUQgPSAtMTtcbiAgdmFyIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIHZhciBuZXh0Rmx1c2hlZFJvb3QgPSBudWxsO1xuICB2YXIgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgdmFyIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG4gIHZhciBoYXNVbmhhbmRsZWRFcnJvciA9IGZhbHNlO1xuICB2YXIgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xuICB2YXIgZGVhZGxpbmUgPSBudWxsO1xuXG4gIHZhciBpc0JhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuICB2YXIgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IGZhbHNlO1xuXG4gIC8vIFVzZSB0aGVzZSB0byBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3Agb2YgbmVzdGVkIHVwZGF0ZXNcbiAgdmFyIE5FU1RFRF9VUERBVEVfTElNSVQgPSAxMDAwO1xuICB2YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXG4gIHZhciB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yayA9IDE7XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFja1dpdGhFeHBpcmF0aW9uKGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgIT09IE5vV29yaykge1xuICAgICAgLy8gQSBjYWxsYmFjayBpcyBhbHJlYWR5IHNjaGVkdWxlZC4gQ2hlY2sgaXRzIGV4cGlyYXRpb24gdGltZSAodGltZW91dCkuXG4gICAgICBpZiAoZXhwaXJhdGlvblRpbWUgPiBjYWxsYmFja0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIEV4aXN0aW5nIGNhbGxiYWNrIGhhcyBzdWZmaWNpZW50IHRpbWVvdXQuIEV4aXQuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEV4aXN0aW5nIGNhbGxiYWNrIGhhcyBpbnN1ZmZpY2llbnQgdGltZW91dC4gQ2FuY2VsIGFuZCBzY2hlZHVsZSBhXG4gICAgICAgIC8vIG5ldyBvbmUuXG4gICAgICAgIGNhbmNlbERlZmVycmVkQ2FsbGJhY2soY2FsbGJhY2tJRCk7XG4gICAgICB9XG4gICAgICAvLyBUaGUgcmVxdWVzdCBjYWxsYmFjayB0aW1lciBpcyBhbHJlYWR5IHJ1bm5pbmcuIERvbid0IHN0YXJ0IGEgbmV3IG9uZS5cbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRSZXF1ZXN0Q2FsbGJhY2tUaW1lcigpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgYSB0aW1lb3V0IGZvciB0aGUgZ2l2ZW4gZXhwaXJhdGlvbiB0aW1lLlxuICAgIHZhciBjdXJyZW50TXMgPSBub3coKSAtIHN0YXJ0VGltZTtcbiAgICB2YXIgZXhwaXJhdGlvbk1zID0gZXhwaXJhdGlvblRpbWVUb01zKGV4cGlyYXRpb25UaW1lKTtcbiAgICB2YXIgdGltZW91dCA9IGV4cGlyYXRpb25NcyAtIGN1cnJlbnRNcztcblxuICAgIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICBjYWxsYmFja0lEID0gc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrKHBlcmZvcm1Bc3luY1dvcmssIHsgdGltZW91dDogdGltZW91dCB9KTtcbiAgfVxuXG4gIC8vIHJlcXVlc3RXb3JrIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHdoZW5ldmVyIGEgcm9vdCByZWNlaXZlcyBhbiB1cGRhdGUuXG4gIC8vIEl0J3MgdXAgdG8gdGhlIHJlbmRlcmVyIHRvIGNhbGwgcmVuZGVyUm9vdCBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUuXG4gIGZ1bmN0aW9uIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IHJlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgcm9vdCB0byB0aGUgc2NoZWR1bGUuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyByb290IGlzIGFscmVhZHkgcGFydCBvZiB0aGUgc2NoZWR1bGUuXG4gICAgaWYgKHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBub3QgYWxyZWFkeSBzY2hlZHVsZWQuIEFkZCBpdC5cbiAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBzY2hlZHVsZWQsIGJ1dCBpdHMgcHJpb3JpdHkgbWF5IGhhdmUgaW5jcmVhc2VkLlxuICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGV4cGlyYXRpb25UaW1lIDwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eS5cbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlbmRlcmluZykge1xuICAgICAgLy8gUHJldmVudCByZWVudHJhbmN5LiBSZW1haW5pbmcgd29yayB3aWxsIGJlIHNjaGVkdWxlZCBhdCB0aGUgZW5kIG9mXG4gICAgICAvLyB0aGUgY3VycmVudGx5IHJlbmRlcmluZyBiYXRjaC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIC8vIEZsdXNoIHdvcmsgYXQgdGhlIGVuZCBvZiB0aGUgYmF0Y2guXG4gICAgICBpZiAoaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgICAvLyAuLi51bmxlc3Mgd2UncmUgaW5zaWRlIHVuYmF0Y2hlZFVwZGF0ZXMsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkXG4gICAgICAgIC8vIGZsdXNoIGl0IG5vdy5cbiAgICAgICAgbmV4dEZsdXNoZWRSb290ID0gcm9vdDtcbiAgICAgICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogR2V0IHJpZCBvZiBTeW5jIGFuZCB1c2UgY3VycmVudCB0aW1lP1xuICAgIGlmIChleHBpcmF0aW9uVGltZSA9PT0gU3luYykge1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbihleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKSB7XG4gICAgdmFyIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSBOb1dvcms7XG4gICAgdmFyIGhpZ2hlc3RQcmlvcml0eVJvb3QgPSBudWxsO1xuXG4gICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHdoaWxlIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAgICAgLy8gVGhpcyByb290IG5vIGxvbmdlciBoYXMgd29yay4gUmVtb3ZlIGl0IGZyb20gdGhlIHNjaGVkdWxlci5cblxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgY2hlY2sgaXMgcmVkdWRhbnQsIGJ1dCBGbG93IGlzIGNvbmZ1c2VkIGJ5IHRoZSBicmFuY2hcbiAgICAgICAgICAvLyBiZWxvdyB3aGVyZSB3ZSBzZXQgbGFzdFNjaGVkdWxlZFJvb3QgdG8gbnVsbCwgZXZlbiB0aG91Z2ggd2UgYnJlYWtcbiAgICAgICAgICAvLyBmcm9tIHRoZSBsb29wIHJpZ2h0IGFmdGVyLlxuICAgICAgICAgICEocHJldmlvdXNTY2hlZHVsZWRSb290ICE9PSBudWxsICYmIGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGEgcHJldmlvdXMgYW5kIGxhc3Qgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBpZiAocm9vdCA9PT0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGZpcnN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHZhciBuZXh0ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChoaWdoZXN0UHJpb3JpdHlXb3JrID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPCBoaWdoZXN0UHJpb3JpdHlXb3JrKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LCBpZiBpdCdzIGhpZ2hlclxuICAgICAgICAgICAgaGlnaGVzdFByaW9yaXR5V29yayA9IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgICAgICAgaGlnaGVzdFByaW9yaXR5Um9vdCA9IHJvb3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgICAgcm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbmV4dCByb290IGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyByb290LCB0aGlzIGlzIGEgbmVzdGVkXG4gICAgLy8gdXBkYXRlLiBUbyBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AsIGluY3JlbWVudCB0aGUgbmVzdGVkIHVwZGF0ZSBjb3VudC5cbiAgICB2YXIgcHJldmlvdXNGbHVzaGVkUm9vdCA9IG5leHRGbHVzaGVkUm9vdDtcbiAgICBpZiAocHJldmlvdXNGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBwcmV2aW91c0ZsdXNoZWRSb290ID09PSBoaWdoZXN0UHJpb3JpdHlSb290KSB7XG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCB3aGVuZXZlciB3ZSBzd2l0Y2ggcm9vdHMuXG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgfVxuICAgIG5leHRGbHVzaGVkUm9vdCA9IGhpZ2hlc3RQcmlvcml0eVJvb3Q7XG4gICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IGhpZ2hlc3RQcmlvcml0eVdvcms7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtQXN5bmNXb3JrKGRsKSB7XG4gICAgcGVyZm9ybVdvcmsoTm9Xb3JrLCBkbCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtV29yayhtaW5FeHBpcmF0aW9uVGltZSwgZGwpIHtcbiAgICBkZWFkbGluZSA9IGRsO1xuXG4gICAgLy8gS2VlcCB3b3JraW5nIG9uIHJvb3RzIHVudGlsIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrLCBvciB1bnRpbCB0aGUgd2UgcmVhY2hcbiAgICAvLyB0aGUgZGVhZGxpbmUuXG4gICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcblxuICAgIGlmIChlbmFibGVVc2VyVGltaW5nQVBJICYmIGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGlkRXhwaXJlID0gbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA8IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKTtcbiAgICAgIHN0b3BSZXF1ZXN0Q2FsbGJhY2tUaW1lcihkaWRFeHBpcmUpO1xuICAgIH1cblxuICAgIHdoaWxlIChuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwgJiYgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChtaW5FeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPD0gbWluRXhwaXJhdGlvblRpbWUpICYmICFkZWFkbGluZURpZEV4cGlyZSkge1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIC8vIEZpbmQgdGhlIG5leHQgaGlnaGVzdCBwcmlvcml0eSB3b3JrLlxuICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICB9XG5cbiAgICAvLyBXZSdyZSBkb25lIGZsdXNoaW5nIHdvcmsuIEVpdGhlciB3ZSByYW4gb3V0IG9mIHRpbWUgaW4gdGhpcyBjYWxsYmFjayxcbiAgICAvLyBvciB0aGVyZSdzIG5vIG1vcmUgd29yayBsZWZ0IHdpdGggc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAgIC8vIElmIHdlJ3JlIGluc2lkZSBhIGNhbGxiYWNrLCBzZXQgdGhpcyB0byBmYWxzZSBzaW5jZSB3ZSBqdXN0IGNvbXBsZXRlZCBpdC5cbiAgICBpZiAoZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgICBjYWxsYmFja0lEID0gLTE7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3Mgd29yayBsZWZ0IG92ZXIsIHNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrLlxuICAgIGlmIChuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lICE9PSBOb1dvcmspIHtcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2tXaXRoRXhwaXJhdGlvbihuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICAvLyBDbGVhbi11cC5cbiAgICBkZWFkbGluZSA9IG51bGw7XG4gICAgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cbiAgICBpZiAoaGFzVW5oYW5kbGVkRXJyb3IpIHtcbiAgICAgIHZhciBfZXJyb3I0ID0gdW5oYW5kbGVkRXJyb3I7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IGZhbHNlO1xuICAgICAgdGhyb3cgX2Vycm9yNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtV29ya09uUm9vdChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdwZXJmb3JtV29ya09uUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgaXNSZW5kZXJpbmcgPSB0cnVlO1xuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhc3luYyB3b3JrIG9yIHN5bmMvZXhwaXJlZCB3b3JrLlxuICAgIC8vIFRPRE86IFBhc3MgY3VycmVudCB0aW1lIGFzIGFyZ3VtZW50IHRvIHJlbmRlclJvb3QsIGNvbW1pdFJvb3RcbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPD0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpKSB7XG4gICAgICAvLyBGbHVzaCBzeW5jIHdvcmsuXG4gICAgICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBpZiAoZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IGNvbXBsZXRlLiBXZSBjYW4gY29tbWl0IGl0LlxuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KGZpbmlzaGVkV29yayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIGZpbmlzaGVkV29yayA9IHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDb21taXQgaXQuXG4gICAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luYyB3b3JrLlxuICAgICAgdmFyIF9maW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChfZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgcm9vdCBpcyBhbHJlYWR5IGNvbXBsZXRlLiBXZSBjYW4gY29tbWl0IGl0LlxuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KF9maW5pc2hlZFdvcmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICBfZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChfZmluaXNoZWRXb3JrICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2UndmUgY29tcGxldGVkIHRoZSByb290LiBDaGVjayB0aGUgZGVhZGxpbmUgb25lIG1vcmUgdGltZVxuICAgICAgICAgIC8vIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgIGlmICghc2hvdWxkWWllbGQoKSkge1xuICAgICAgICAgICAgLy8gU3RpbGwgdGltZSBsZWZ0LiBDb21taXQgdGhlIHJvb3QuXG4gICAgICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChfZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUncyBubyB0aW1lIGxlZnQuIE1hcmsgdGhpcyByb290IGFzIGNvbXBsZXRlLiBXZSdsbCBjb21lXG4gICAgICAgICAgICAvLyBiYWNrIGFuZCBjb21taXQgaXQgbGF0ZXIuXG4gICAgICAgICAgICByb290LmZpbmlzaGVkV29yayA9IF9maW5pc2hlZFdvcms7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIFdoZW4gd29ya2luZyBvbiBhc3luYyB3b3JrLCB0aGUgcmVjb25jaWxlciBhc2tzIHRoZSByZW5kZXJlciBpZiBpdCBzaG91bGRcbiAgLy8geWllbGQgZXhlY3V0aW9uLiBGb3IgRE9NLCB3ZSBpbXBsZW1lbnQgdGhpcyB3aXRoIHJlcXVlc3RJZGxlQ2FsbGJhY2suXG4gIGZ1bmN0aW9uIHNob3VsZFlpZWxkKCkge1xuICAgIGlmIChkZWFkbGluZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGVhZGxpbmUudGltZVJlbWFpbmluZygpID4gdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmspIHtcbiAgICAgIC8vIERpc3JlZ2FyZCBkZWFkbGluZS5kaWRUaW1lb3V0LiBPbmx5IGV4cGlyZWQgd29yayBzaG91bGQgYmUgZmx1c2hlZFxuICAgICAgLy8gZHVyaW5nIGEgdGltZW91dC4gVGhpcyBwYXRoIGlzIG9ubHkgaGl0IGZvciBub24tZXhwaXJlZCB3b3JrLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBUT0RPOiBOb3QgaGFwcHkgYWJvdXQgdGhpcyBob29rLiBDb25jZXB0dWFsbHksIHJlbmRlclJvb3Qgc2hvdWxkIHJldHVybiBhXG4gIC8vIHR1cGxlIG9mIChpc1JlYWR5Rm9yQ29tbWl0LCBkaWRFcnJvciwgZXJyb3IpXG4gIGZ1bmN0aW9uIG9uVW5jYXVnaHRFcnJvcihlcnJvcikge1xuICAgICEobmV4dEZsdXNoZWRSb290ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBiZSB3b3JraW5nIG9uIGEgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAvLyBVbnNjaGVkdWxlIHRoaXMgcm9vdCBzbyB3ZSBkb24ndCB3b3JrIG9uIGl0IGFnYWluIHVudGlsIHRoZXJlJ3NcbiAgICAvLyBhbm90aGVyIHVwZGF0ZS5cbiAgICBuZXh0Rmx1c2hlZFJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSB0cnVlO1xuICAgICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3QgaW5zaWRlXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICAgIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICAgIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgICAgIHBlcmZvcm1Xb3JrKFN5bmMsIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIHVuYmF0Y2hlZFVwZGF0ZXMoZm4pIHtcbiAgICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbigpO1xuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IHdpdGhpblxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gZmx1c2hTeW5jKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzeW5jVXBkYXRlcyhmbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICAgICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIEl0IGNhbm5vdCBiZSBjYWxsZWQgd2hlbiBSZWFjdCBpcyBhbHJlYWR5IHJlbmRlcmluZy4nKSA6IHZvaWQgMDtcbiAgICAgIHBlcmZvcm1Xb3JrKFN5bmMsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcHV0ZUFzeW5jRXhwaXJhdGlvbjogY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyOiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgIHNjaGVkdWxlV29yazogc2NoZWR1bGVXb3JrLFxuICAgIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcbiAgICB1bmJhdGNoZWRVcGRhdGVzOiB1bmJhdGNoZWRVcGRhdGVzLFxuICAgIGZsdXNoU3luYzogZmx1c2hTeW5jLFxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzXG4gIH07XG59O1xuXG57XG4gIHZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gZmFsc2U7XG59XG5cbi8vIDAgaXMgUFJPRCwgMSBpcyBERVYuXG4vLyBNaWdodCBhZGQgUFJPRklMRSBsYXRlci5cblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQocGFyZW50Q29tcG9uZW50KTtcbiAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG4gIHJldHVybiBpc0NvbnRleHRQcm92aWRlcihmaWJlcikgPyBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBwYXJlbnRDb250ZXh0KSA6IHBhcmVudENvbnRleHQ7XG59XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQxID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgZ2V0UHVibGljSW5zdGFuY2UgPSBjb25maWcuZ2V0UHVibGljSW5zdGFuY2U7XG5cbiAgdmFyIF9SZWFjdEZpYmVyU2NoZWR1bGVyID0gUmVhY3RGaWJlclNjaGVkdWxlcihjb25maWcpLFxuICAgICAgY29tcHV0ZUFzeW5jRXhwaXJhdGlvbiA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmNvbXB1dGVBc3luY0V4cGlyYXRpb24sXG4gICAgICBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixcbiAgICAgIHNjaGVkdWxlV29yayA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLnNjaGVkdWxlV29yayxcbiAgICAgIGJhdGNoZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICB1bmJhdGNoZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIudW5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIGZsdXNoU3luYyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmZsdXNoU3luYyxcbiAgICAgIGRlZmVycmVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmRlZmVycmVkVXBkYXRlcztcblxuICBmdW5jdGlvbiBzY2hlZHVsZVRvcExldmVsVXBkYXRlKGN1cnJlbnQsIGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAge1xuICAgICAgaWYgKFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPT09ICdyZW5kZXInICYmIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcykge1xuICAgICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAge1xuICAgICAgd2FybmluZyhjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsICdyZW5kZXIoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSB2b2lkIDA7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRvcC1sZXZlbCBlbGVtZW50IGlzIGFuIGFzeW5jIHdyYXBwZXIgY29tcG9uZW50LiBJZiBzbyxcbiAgICAvLyB0cmVhdCB1cGRhdGVzIHRvIHRoZSByb290IGFzIGFzeW5jLiBUaGlzIGlzIGEgYml0IHdlaXJkIGJ1dCBsZXRzIHVzXG4gICAgLy8gYXZvaWQgYSBzZXBhcmF0ZSBgcmVuZGVyQXN5bmNgIEFQSS5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIGVsZW1lbnQgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlICE9IG51bGwgJiYgZWxlbWVudC50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQgPT09IHRydWUpIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudCk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgIHBhcnRpYWxTdGF0ZTogeyBlbGVtZW50OiBlbGVtZW50IH0sXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGN1cnJlbnQsIHVwZGF0ZSk7XG4gICAgc2NoZWR1bGVXb3JrKGN1cnJlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpIHtcbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVySW5mbywgaHlkcmF0ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBoeWRyYXRlKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICAgICAgLy8gVE9ETzogSWYgdGhpcyBpcyBhIG5lc3RlZCBjb250YWluZXIsIHRoaXMgd29uJ3QgYmUgdGhlIHJvb3QuXG4gICAgICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50O1xuXG4gICAgICB7XG4gICAgICAgIGlmIChSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uTW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25VcGRhdGVDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICAgICAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIH0sXG5cblxuICAgIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcblxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgICBkZWZlcnJlZFVwZGF0ZXM6IGRlZmVycmVkVXBkYXRlcyxcblxuICAgIGZsdXNoU3luYzogZmx1c2hTeW5jLFxuXG4gICAgZ2V0UHVibGljUm9vdEluc3RhbmNlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgICAgIGlmICghY29udGFpbmVyRmliZXIuY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICB9LFxuXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlOiBmaW5kSG9zdEluc3RhbmNlLFxuXG4gICAgZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHM6IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhmaWJlcik7XG4gICAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG4gICAgfSxcbiAgICBpbmplY3RJbnRvRGV2VG9vbHM6IGZ1bmN0aW9uIChkZXZUb29sc0NvbmZpZykge1xuICAgICAgdmFyIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID0gZGV2VG9vbHNDb25maWcuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7XG5cbiAgICAgIHJldHVybiBpbmplY3RJbnRlcm5hbHMoX2Fzc2lnbih7fSwgZGV2VG9vbHNDb25maWcsIHtcbiAgICAgICAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIHJldHVybiBmaW5kSG9zdEluc3RhbmNlKGZpYmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIGlmICghZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIE1pZ2h0IG5vdCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgcmVuZGVyZXIuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0RmliZXJSZWNvbmNpbGVyJDFcbn0pO1xuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMyA9ICggUmVhY3RGaWJlclJlY29uY2lsZXIkMiAmJiBSZWFjdEZpYmVyUmVjb25jaWxlciQxICkgfHwgUmVhY3RGaWJlclJlY29uY2lsZXIkMjtcblxuLy8gVE9ETzogYnVuZGxlIEZsb3cgdHlwZXMgd2l0aCB0aGUgcGFja2FnZS5cblxuXG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0UmVjb25jaWxlciA9IFJlYWN0RmliZXJSZWNvbmNpbGVyJDNbJ2RlZmF1bHQnXSA/IFJlYWN0RmliZXJSZWNvbmNpbGVyJDNbJ2RlZmF1bHQnXSA6IFJlYWN0RmliZXJSZWNvbmNpbGVyJDM7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLFxuLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleToga2V5ID09IG51bGwgPyBudWxsIDogJycgKyBrZXksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gIH07XG59XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjIuMCc7XG5cbi8vIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBzdG9yaW5nIHRoZSB0aW1lIGZvciB0aGUgc3RhcnQgb2YgdGhlIGZyYW1lLCB0aGVuXG4vLyBzY2hlZHVsaW5nIGEgcG9zdE1lc3NhZ2Ugd2hpY2ggZ2V0cyBzY2hlZHVsZWQgYWZ0ZXIgcGFpbnQuIFdpdGhpbiB0aGVcbi8vIHBvc3RNZXNzYWdlIGhhbmRsZXIgZG8gYXMgbXVjaCB3b3JrIGFzIHBvc3NpYmxlIHVudGlsIHRpbWUgKyBmcmFtZSByYXRlLlxuLy8gQnkgc2VwYXJhdGluZyB0aGUgaWRsZSBjYWxsIGludG8gYSBzZXBhcmF0ZSBldmVudCB0aWNrIHdlIGVuc3VyZSB0aGF0XG4vLyBsYXlvdXQsIHBhaW50IGFuZCBvdGhlciBicm93c2VyIHdvcmsgaXMgY291bnRlZCBhZ2FpbnN0IHRoZSBhdmFpbGFibGUgdGltZS5cbi8vIFRoZSBmcmFtZSByYXRlIGlzIGR5bmFtaWNhbGx5IGFkanVzdGVkLlxuXG57XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzJyk7XG4gIH1cbn1cblxudmFyIGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG52YXIgbm93ID0gdm9pZCAwO1xuaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbi8vIFRPRE86IFRoZXJlJ3Mgbm8gd2F5IHRvIGNhbmNlbCwgYmVjYXVzZSBGaWJlciBkb2Vzbid0IGF0bS5cbnZhciBySUMgPSB2b2lkIDA7XG52YXIgY0lDID0gdm9pZCAwO1xuXG5pZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBySUMgPSBmdW5jdGlvbiAoZnJhbWVDYWxsYmFjaykge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZyYW1lQ2FsbGJhY2soe1xuICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgY0lDID0gZnVuY3Rpb24gKHRpbWVvdXRJRCkge1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SUQpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgcmVxdWVzdElkbGVDYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgY2FuY2VsSWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gIC8vIFBvbHlmaWxsIHJlcXVlc3RJZGxlQ2FsbGJhY2sgYW5kIGNhbmNlbElkbGVDYWxsYmFja1xuXG4gIHZhciBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IG51bGw7XG4gIHZhciBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIHRpbWVvdXRUaW1lID0gLTE7XG5cbiAgdmFyIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICB2YXIgZnJhbWVEZWFkbGluZSA9IDA7XG4gIC8vIFdlIHN0YXJ0IG91dCBhc3N1bWluZyB0aGF0IHdlIHJ1biBhdCAzMGZwcyBidXQgdGhlbiB0aGUgaGV1cmlzdGljIHRyYWNraW5nXG4gIC8vIHdpbGwgYWRqdXN0IHRoaXMgdmFsdWUgdG8gYSBmYXN0ZXIgZnBzIGlmIHdlIGdldCBtb3JlIGZyZXF1ZW50IGFuaW1hdGlvblxuICAvLyBmcmFtZXMuXG4gIHZhciBwcmV2aW91c0ZyYW1lVGltZSA9IDMzO1xuICB2YXIgYWN0aXZlRnJhbWVUaW1lID0gMzM7XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmVPYmplY3Q7XG4gIGlmIChoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdykge1xuICAgIGZyYW1lRGVhZGxpbmVPYmplY3QgPSB7XG4gICAgICBkaWRUaW1lb3V0OiBmYWxzZSxcbiAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgaWYgd2UgaGF2ZSBhIHBlcmZvcm1hbmNlIHRpbWVyIHRoYXQgdGhlIHJBRiBjYWxsYmFja1xuICAgICAgICAvLyBnZXRzIGEgcGVyZm9ybWFuY2UgdGltZXIgdmFsdWUuIE5vdCBzdXJlIGlmIHRoaXMgaXMgYWx3YXlzIHRydWUuXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBmcmFtZURlYWRsaW5lIC0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHJldHVybiByZW1haW5pbmcgPiAwID8gcmVtYWluaW5nIDogMDtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGZyYW1lRGVhZGxpbmVPYmplY3QgPSB7XG4gICAgICBkaWRUaW1lb3V0OiBmYWxzZSxcbiAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gRGF0ZS5ub3coKVxuICAgICAgICB2YXIgcmVtYWluaW5nID0gZnJhbWVEZWFkbGluZSAtIERhdGUubm93KCk7XG4gICAgICAgIHJldHVybiByZW1haW5pbmcgPiAwID8gcmVtYWluaW5nIDogMDtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gV2UgdXNlIHRoZSBwb3N0TWVzc2FnZSB0cmljayB0byBkZWZlciBpZGxlIHdvcmsgdW50aWwgYWZ0ZXIgdGhlIHJlcGFpbnQuXG4gIHZhciBtZXNzYWdlS2V5ID0gJ19fcmVhY3RJZGxlQ2FsbGJhY2skJyArIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xuICB2YXIgaWRsZVRpY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuc291cmNlICE9PSB3aW5kb3cgfHwgZXZlbnQuZGF0YSAhPT0gbWVzc2FnZUtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gbm93KCk7XG4gICAgaWYgKGZyYW1lRGVhZGxpbmUgLSBjdXJyZW50VGltZSA8PSAwKSB7XG4gICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdCBpbiB0aGlzIGlkbGUgcGVyaW9kLiBDaGVjayBpZiB0aGUgY2FsbGJhY2sgaGFzXG4gICAgICAvLyBhIHRpbWVvdXQgYW5kIHdoZXRoZXIgaXQncyBiZWVuIGV4Y2VlZGVkLlxuICAgICAgaWYgKHRpbWVvdXRUaW1lICE9PSAtMSAmJiB0aW1lb3V0VGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgICAvLyBFeGNlZWRlZCB0aGUgdGltZW91dC4gSW52b2tlIHRoZSBjYWxsYmFjayBldmVuIHRob3VnaCB0aGVyZSdzIG5vXG4gICAgICAgIC8vIHRpbWUgbGVmdC5cbiAgICAgICAgZnJhbWVEZWFkbGluZU9iamVjdC5kaWRUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIHRpbWVvdXQuXG4gICAgICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGFub3RoZXIgYW5pbWF0aW9uIGNhbGxiYWNrIHNvIHdlIHJldHJ5IGxhdGVyLlxuICAgICAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRpb25UaWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFeGl0IHdpdGhvdXQgaW52b2tpbmcgdGhlIGNhbGxiYWNrLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXJlJ3Mgc3RpbGwgdGltZSBsZWZ0IGluIHRoaXMgaWRsZSBwZXJpb2QuXG4gICAgICBmcmFtZURlYWRsaW5lT2JqZWN0LmRpZFRpbWVvdXQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aW1lb3V0VGltZSA9IC0xO1xuICAgIHZhciBjYWxsYmFjayA9IHNjaGVkdWxlZFJJQ0NhbGxiYWNrO1xuICAgIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKGZyYW1lRGVhZGxpbmVPYmplY3QpO1xuICAgIH1cbiAgfTtcbiAgLy8gQXNzdW1lcyB0aGF0IHdlIGhhdmUgYWRkRXZlbnRMaXN0ZW5lciBpbiB0aGlzIGVudmlyb25tZW50LiBNaWdodCBuZWVkXG4gIC8vIHNvbWV0aGluZyBiZXR0ZXIgZm9yIG9sZCBJRS5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpZGxlVGljaywgZmFsc2UpO1xuXG4gIHZhciBhbmltYXRpb25UaWNrID0gZnVuY3Rpb24gKHJhZlRpbWUpIHtcbiAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIG5leHRGcmFtZVRpbWUgPSByYWZUaW1lIC0gZnJhbWVEZWFkbGluZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAobmV4dEZyYW1lVGltZSA8IGFjdGl2ZUZyYW1lVGltZSAmJiBwcmV2aW91c0ZyYW1lVGltZSA8IGFjdGl2ZUZyYW1lVGltZSkge1xuICAgICAgaWYgKG5leHRGcmFtZVRpbWUgPCA4KSB7XG4gICAgICAgIC8vIERlZmVuc2l2ZSBjb2RpbmcuIFdlIGRvbid0IHN1cHBvcnQgaGlnaGVyIGZyYW1lIHJhdGVzIHRoYW4gMTIwaHouXG4gICAgICAgIC8vIElmIHdlIGdldCBsb3dlciB0aGFuIHRoYXQsIGl0IGlzIHByb2JhYmx5IGEgYnVnLlxuICAgICAgICBuZXh0RnJhbWVUaW1lID0gODtcbiAgICAgIH1cbiAgICAgIC8vIElmIG9uZSBmcmFtZSBnb2VzIGxvbmcsIHRoZW4gdGhlIG5leHQgb25lIGNhbiBiZSBzaG9ydCB0byBjYXRjaCB1cC5cbiAgICAgIC8vIElmIHR3byBmcmFtZXMgYXJlIHNob3J0IGluIGEgcm93LCB0aGVuIHRoYXQncyBhbiBpbmRpY2F0aW9uIHRoYXQgd2VcbiAgICAgIC8vIGFjdHVhbGx5IGhhdmUgYSBoaWdoZXIgZnJhbWUgcmF0ZSB0aGFuIHdoYXQgd2UncmUgY3VycmVudGx5IG9wdGltaXppbmcuXG4gICAgICAvLyBXZSBhZGp1c3Qgb3VyIGhldXJpc3RpYyBkeW5hbWljYWxseSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIHdlJ3JlXG4gICAgICAvLyBydW5uaW5nIG9uIDEyMGh6IGRpc3BsYXkgb3IgOTBoeiBWUiBkaXNwbGF5LlxuICAgICAgLy8gVGFrZSB0aGUgbWF4IG9mIHRoZSB0d28gaW4gY2FzZSBvbmUgb2YgdGhlbSB3YXMgYW4gYW5vbWFseSBkdWUgdG9cbiAgICAgIC8vIG1pc3NlZCBmcmFtZSBkZWFkbGluZXMuXG4gICAgICBhY3RpdmVGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lIDwgcHJldmlvdXNGcmFtZVRpbWUgPyBwcmV2aW91c0ZyYW1lVGltZSA6IG5leHRGcmFtZVRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzRnJhbWVUaW1lID0gbmV4dEZyYW1lVGltZTtcbiAgICB9XG4gICAgZnJhbWVEZWFkbGluZSA9IHJhZlRpbWUgKyBhY3RpdmVGcmFtZVRpbWU7XG4gICAgaWYgKCFpc0lkbGVTY2hlZHVsZWQpIHtcbiAgICAgIGlzSWRsZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICB3aW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZUtleSwgJyonKTtcbiAgICB9XG4gIH07XG5cbiAgcklDID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2Ugb25seSBzY2hlZHVsZSBvbmUgY2FsbGJhY2sgYXQgYSB0aW1lIGJlY2F1c2UgdGhhdCdzXG4gICAgLy8gaG93IEZpYmVyIHVzZXMgaXQuXG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBpZiAob3B0aW9ucyAhPSBudWxsICYmIHR5cGVvZiBvcHRpb25zLnRpbWVvdXQgPT09ICdudW1iZXInKSB7XG4gICAgICB0aW1lb3V0VGltZSA9IG5vdygpICsgb3B0aW9ucy50aW1lb3V0O1xuICAgIH1cbiAgICBpZiAoIWlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQpIHtcbiAgICAgIC8vIElmIHJBRiBkaWRuJ3QgYWxyZWFkeSBzY2hlZHVsZSBvbmUsIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBmcmFtZS5cbiAgICAgIC8vIFRPRE86IElmIHRoaXMgckFGIGRvZXNuJ3QgbWF0ZXJpYWxpemUgYmVjYXVzZSB0aGUgYnJvd3NlciB0aHJvdHRsZXMsIHdlXG4gICAgICAvLyBtaWdodCB3YW50IHRvIHN0aWxsIGhhdmUgc2V0VGltZW91dCB0cmlnZ2VyIHJJQyBhcyBhIGJhY2t1cCB0byBlbnN1cmVcbiAgICAgIC8vIHRoYXQgd2Uga2VlcCBwZXJmb3JtaW5nIHdvcmsuXG4gICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRpb25UaWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG5cbiAgY0lDID0gZnVuY3Rpb24gKCkge1xuICAgIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgICBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB0aW1lb3V0VGltZSA9IC0xO1xuICB9O1xufSBlbHNlIHtcbiAgcklDID0gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2s7XG4gIGNJQyA9IHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2s7XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbi8vIGlzQXR0cmlidXRlTmFtZVNhZmUoKSBpcyBjdXJyZW50bHkgZHVwbGljYXRlZCBpbiBET01NYXJrdXBPcGVyYXRpb25zLlxuLy8gVE9ETzogRmluZCBhIGJldHRlciBwbGFjZSBmb3IgdGhpcy5cbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzaG91bGRJZ25vcmVWYWx1ZSgpIGlzIGN1cnJlbnRseSBkdXBsaWNhdGVkIGluIERPTU1hcmt1cE9wZXJhdGlvbnMuXG4vLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHBsYWNlIGZvciB0aGlzLlxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cblxuXG5cblxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSBcImV4cGVjdGVkXCIgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuXG4gKiBTb21lIHByb3BlcnRpZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QgfHwgcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG5cbiAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbnVsbDtcblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgLy8gV2UgaGFkIGFuIGF0dHJpYnV0ZSBidXQgc2hvdWxkbid0IGhhdmUgaGFkIG9uZSwgc28gcmVhZCBpdFxuICAgICAgICAgICAgLy8gZm9yIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgICAgLy8gdGhlIGZhY3QgdGhhdCB3ZSBoYXZlIGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBleHBlY3RlZC5cbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRXZlbiBpZiB0aGlzIHByb3BlcnR5IHVzZXMgYSBuYW1lc3BhY2Ugd2UgdXNlIGdldEF0dHJpYnV0ZVxuICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgYXNzdW1lIGl0cyBuYW1lc3BhY2VkIG5hbWUgaXMgdGhlIHNhbWUgYXMgb3VyIGNvbmZpZy5cbiAgICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gaW4gb3VyIGNvbmZpZyBhdG0uXG4gICAgICAgICAgc3RyaW5nVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIGV4cGVjdGVkKSkge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gbnVsbCA/IGV4cGVjdGVkIDogc3RyaW5nVmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nVmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBhdHRyaWJ1dGUgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSB0aGlyZCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy4gU29tZVxuICogYXR0cmlidXRlcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcblxuICBpZiAocHJvcGVydHlJbmZvICYmIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpIHtcbiAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkgPyB2YWx1ZSA6IG51bGwpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyArIHZhbHVlKTtcbiAgfVxuXG4gIHtcbiAgICBcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZXMgYW4gYXR0cmlidXRlcyBmcm9tIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUpIHtcbiAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG59XG5cbi8qKlxuICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IG51bGxcbn07XG5cbntcbiAgdmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgYnV0dG9uOiB0cnVlLFxuICAgIGNoZWNrYm94OiB0cnVlLFxuICAgIGltYWdlOiB0cnVlLFxuICAgIGhpZGRlbjogdHJ1ZSxcbiAgICByYWRpbzogdHJ1ZSxcbiAgICByZXNldDogdHJ1ZSxcbiAgICBzdWJtaXQ6IHRydWVcbiAgfTtcblxuICB2YXIgcHJvcFR5cGVzID0ge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9LFxuICAgIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAgICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAgICovXG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBnZXRTdGFjaykge1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgcHJvcHMsICdwcm9wJywgdGFnTmFtZSwgZ2V0U3RhY2spO1xuICB9O1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKSB7XG4gIHZhciB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIHVzZXNDaGVja2VkID8gcHJvcHMuY2hlY2tlZCAhPSBudWxsIDogcHJvcHMudmFsdWUgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnR5cGUgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzIChzZXR0aW5nIC52YWx1ZVxuICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcbiAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAuc3RlcCBiZWZvcmUgLnZhbHVlIChzZXR0aW5nIC52YWx1ZSBiZWZvcmUgLnN0ZXBcbiAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcbiAgICBzdGVwOiB1bmRlZmluZWQsXG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAubWluICYgLm1heCBiZWZvcmUgLnZhbHVlICh0byBlbnN1cmUgcHJvcGVyIG9yZGVyXG4gICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxuICAgIG1pbjogdW5kZWZpbmVkLFxuICAgIG1heDogdW5kZWZpbmVkXG4gIH0sIHByb3BzLCB7XG4gICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMpO1xuXG4gICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSxcbiAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsICdjaGVja2VkJywgY2hlY2tlZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICB2YXIgY29udHJvbGxlZCA9IGlzQ29udHJvbGxlZChwcm9wcyk7XG5cbiAgICBpZiAoIW5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmIGNvbnRyb2xsZWQgJiYgIWRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhbiB1bmNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSBjb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgICAgZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiAhY29udHJvbGxlZCAmJiAhZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGEgY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIHVuY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIGNvbnRyb2xsZWQgdG8gdW5jb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMlcycsIHByb3BzLnR5cGUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMygpKTtcbiAgICAgIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHVwZGF0ZUNoZWNrZWQoZWxlbWVudCwgcHJvcHMpO1xuXG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGlmICh2YWx1ZSA9PT0gMCAmJiBub2RlLnZhbHVlID09PSAnJykge1xuICAgICAgbm9kZS52YWx1ZSA9ICcwJztcbiAgICAgIC8vIE5vdGU6IElFOSByZXBvcnRzIGEgbnVtYmVyIGlucHV0cyBhcyAndGV4dCcsIHNvIGNoZWNrIHByb3BzIGluc3RlYWQuXG4gICAgfSBlbHNlIGlmIChwcm9wcy50eXBlID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gU2ltdWxhdGUgYGlucHV0LnZhbHVlQXNOdW1iZXJgLiBJRTkgZG9lcyBub3Qgc3VwcG9ydCBpdFxuICAgICAgdmFyIHZhbHVlQXNOdW1iZXIgPSBwYXJzZUZsb2F0KG5vZGUudmFsdWUpIHx8IDA7XG5cbiAgICAgIGlmIChcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdmFsdWUgIT0gdmFsdWVBc051bWJlciB8fFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB2YWx1ZSA9PSB2YWx1ZUFzTnVtYmVyICYmIG5vZGUudmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgICBub2RlLnZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudmFsdWUgIT09ICcnICsgdmFsdWUpIHtcbiAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICBub2RlLnZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHByb3BzLnZhbHVlID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIC8vIEluIENocm9tZSwgYXNzaWduaW5nIGRlZmF1bHRWYWx1ZSB0byBjZXJ0YWluIGlucHV0IHR5cGVzIHRyaWdnZXJzIGlucHV0IHZhbGlkYXRpb24uXG4gICAgICAvLyBGb3IgbnVtYmVyIGlucHV0cywgdGhlIGRpc3BsYXkgdmFsdWUgbG9zZXMgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMuIEZvciBlbWFpbCBpbnB1dHMsXG4gICAgICAvLyBDaHJvbWUgcmFpc2VzIFwiVGhlIHNwZWNpZmllZCB2YWx1ZSA8eD4gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzc1wiLlxuICAgICAgLy9cbiAgICAgIC8vIEhlcmUgd2UgY2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0VmFsdWUgaGFzIGFjdHVhbGx5IGNoYW5nZWQsIGF2b2lkaW5nIHRoZXNlIHByb2JsZW1zXG4gICAgICAvLyB3aGVuIHRoZSB1c2VyIGlzIGlucHV0dGluZyB0ZXh0XG4gICAgICAvL1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzXG4gICAgICBpZiAobm9kZS5kZWZhdWx0VmFsdWUgIT09ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlKSB7XG4gICAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcy5jaGVja2VkID09IG51bGwgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICEhcHJvcHMuZGVmYXVsdENoZWNrZWQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuXG4gIC8vIERldGFjaCB2YWx1ZSBmcm9tIGRlZmF1bHRWYWx1ZS4gV2Ugd29uJ3QgZG8gYW55dGhpbmcgaWYgd2UncmUgd29ya2luZyBvblxuICAvLyBzdWJtaXQgb3IgcmVzZXQgaW5wdXRzIGFzIHRob3NlIHZhbHVlcyAmIGRlZmF1bHRWYWx1ZXMgYXJlIGxpbmtlZC4gVGhleVxuICAvLyBhcmUgbm90IHJlc2V0YWJsZSBub2RlcyBzbyB0aGlzIG9wZXJhdGlvbiBkb2Vzbid0IG1hdHRlciBhbmQgYWN0dWFsbHlcbiAgLy8gcmVtb3ZlcyBicm93c2VyLWRlZmF1bHQgdmFsdWVzIChlZyBcIlN1Ym1pdCBRdWVyeVwiKSB3aGVuIG5vIHZhbHVlIGlzXG4gIC8vIHByb3ZpZGVkLlxuXG4gIHN3aXRjaCAocHJvcHMudHlwZSkge1xuICAgIGNhc2UgJ3N1Ym1pdCc6XG4gICAgY2FzZSAncmVzZXQnOlxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnY29sb3InOlxuICAgIGNhc2UgJ2RhdGUnOlxuICAgIGNhc2UgJ2RhdGV0aW1lJzpcbiAgICBjYXNlICdkYXRldGltZS1sb2NhbCc6XG4gICAgY2FzZSAnbW9udGgnOlxuICAgIGNhc2UgJ3RpbWUnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgLy8gVGhpcyBmaXhlcyB0aGUgbm8tc2hvdyBpc3N1ZSBvbiBpT1MgU2FmYXJpIGFuZCBBbmRyb2lkIENocm9tZTpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzIzM1xuICAgICAgbm9kZS52YWx1ZSA9ICcnO1xuICAgICAgbm9kZS52YWx1ZSA9IG5vZGUuZGVmYXVsdFZhbHVlO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlLnZhbHVlO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICAvLyBOb3JtYWxseSwgd2UnZCBqdXN0IGRvIGBub2RlLmNoZWNrZWQgPSBub2RlLmNoZWNrZWRgIHVwb24gaW5pdGlhbCBtb3VudCwgbGVzcyB0aGlzIGJ1Z1xuICAvLyB0aGlzIGlzIG5lZWRlZCB0byB3b3JrIGFyb3VuZCBhIGNocm9tZSBidWcgd2hlcmUgc2V0dGluZyBkZWZhdWx0Q2hlY2tlZFxuICAvLyB3aWxsIHNvbWV0aW1lcyBpbmZsdWVuY2UgdGhlIHZhbHVlIG9mIGNoZWNrZWQgKGV2ZW4gYWZ0ZXIgZGV0YWNobWVudCkuXG4gIC8vIFJlZmVyZW5jZTogaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NjA4NDE2XG4gIC8vIFdlIG5lZWQgdG8gdGVtcG9yYXJpbHkgdW5zZXQgbmFtZSB0byBhdm9pZCBkaXNydXB0aW5nIHJhZGlvIGJ1dHRvbiBncm91cHMuXG4gIHZhciBuYW1lID0gbm9kZS5uYW1lO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSAnJztcbiAgfVxuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gbmFtZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB1cGRhdGVXcmFwcGVyKG5vZGUsIHByb3BzKTtcbiAgdXBkYXRlTmFtZWRDb3VzaW5zKG5vZGUsIHByb3BzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTmFtZWRDb3VzaW5zKHJvb3ROb2RlLCBwcm9wcykge1xuICB2YXIgbmFtZSA9IHByb3BzLm5hbWU7XG4gIGlmIChwcm9wcy50eXBlID09PSAncmFkaW8nICYmIG5hbWUgIT0gbnVsbCkge1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybS4gSXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gdGhlXG4gICAgLy8gZG9jdW1lbnQuIExldCdzIGp1c3QgdXNlIHRoZSBsb2NhbCBgcXVlcnlTZWxlY3RvckFsbGAgdG8gZW5zdXJlIHdlIGRvbid0XG4gICAgLy8gbWlzcyBhbnl0aGluZy5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHJhZGlvIGJ1dHRvbnMgd2l0aCBub24tUmVhY3Qgb25lcy5cbiAgICAgIHZhciBvdGhlclByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJQcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NSW5wdXQ6IE1peGluZyBSZWFjdCBhbmQgbm9uLVJlYWN0IHJhZGlvIGlucHV0cyB3aXRoIHRoZSBzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogdm9pZCAwO1xuXG4gICAgICAvLyBXZSBuZWVkIHVwZGF0ZSB0aGUgdHJhY2tlZCB2YWx1ZSBvbiB0aGUgbmFtZWQgY291c2luIHNpbmNlIHRoZSB2YWx1ZVxuICAgICAgLy8gd2FzIGNoYW5nZWQgYnV0IHRoZSBpbnB1dCBzYXcgbm8gZXZlbnQgb3IgdmFsdWUgc2V0XG4gICAgICB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChvdGhlck5vZGUpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIHVwZGF0ZVdyYXBwZXIob3RoZXJOb2RlLCBvdGhlclByb3BzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIC8vIFdlIGNhbiBzaWxlbnRseSBza2lwIHRoZW0gYmVjYXVzZSBpbnZhbGlkIERPTSBuZXN0aW5nIHdhcm5pbmdcbiAgLy8gY2F0Y2hlcyB0aGVzZSBjYXNlcyBpbiBGaWJlci5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgY29udGVudCArPSBjaGlsZDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gIHtcbiAgICB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXG4gIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgcHJvcHMudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHsgY2hpbGRyZW46IHVuZGVmaW5lZCB9LCBwcm9wcyk7XG4gIHZhciBjb250ZW50ID0gZmxhdHRlbkNoaWxkcmVuKHByb3BzLmNoaWxkcmVuKTtcblxuICBpZiAoY29udGVudCkge1xuICAgIGhvc3RQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gIH1cblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDMgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxue1xuICB2YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICB2YXIgb3duZXJOYW1lID0gZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDMoKTtcbiAgaWYgKG93bmVyTmFtZSkge1xuICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxudmFyIHZhbHVlUHJvcE5hbWVzID0gWyd2YWx1ZScsICdkZWZhdWx0VmFsdWUnXTtcblxuLyoqXG4gKiBWYWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpIHtcbiAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ3NlbGVjdCcsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDQpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKTtcbiAgICBpZiAocHJvcHMubXVsdGlwbGUgJiYgIWlzQXJyYXkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYW4gYXJyYXkgaWYgJyArICdgbXVsdGlwbGVgIGlzIHRydWUuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH0gZWxzZSBpZiAoIXByb3BzLm11bHRpcGxlICYmIGlzQXJyYXkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYCVzYCBwcm9wIHN1cHBsaWVkIHRvIDxzZWxlY3Q+IG11c3QgYmUgYSBzY2FsYXIgJyArICd2YWx1ZSBpZiBgbXVsdGlwbGVgIGlzIGZhbHNlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlT3B0aW9ucyhub2RlLCBtdWx0aXBsZSwgcHJvcFZhbHVlLCBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgdmFyIG9wdGlvbnMgPSBub2RlLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWVzID0gcHJvcFZhbHVlO1xuICAgIHZhciBzZWxlY3RlZFZhbHVlID0ge307XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gUHJlZml4IHRvIGF2b2lkIGNoYW9zIHdpdGggc3BlY2lhbCBrZXlzLlxuICAgICAgc2VsZWN0ZWRWYWx1ZVsnJCcgKyBzZWxlY3RlZFZhbHVlc1tpXV0gPSB0cnVlO1xuICAgIH1cbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgb3B0aW9ucy5sZW5ndGg7IF9pKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkoJyQnICsgb3B0aW9uc1tfaV0udmFsdWUpO1xuICAgICAgaWYgKG9wdGlvbnNbX2ldLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW19pXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgICAgaWYgKHNlbGVjdGVkICYmIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICBvcHRpb25zW19pXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgdmFyIF9zZWxlY3RlZFZhbHVlID0gJycgKyBwcm9wVmFsdWU7XG4gICAgdmFyIGRlZmF1bHRTZWxlY3RlZCA9IG51bGw7XG4gICAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgb3B0aW9ucy5sZW5ndGg7IF9pMisrKSB7XG4gICAgICBpZiAob3B0aW9uc1tfaTJdLnZhbHVlID09PSBfc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW19pMl0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICBpZiAoc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgICAgb3B0aW9uc1tfaTJdLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRlZmF1bHRTZWxlY3RlZCA9PT0gbnVsbCAmJiAhb3B0aW9uc1tfaTJdLmRpc2FibGVkKSB7XG4gICAgICAgIGRlZmF1bHRTZWxlY3RlZCA9IG9wdGlvbnNbX2kyXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGRlZmF1bHRTZWxlY3RlZCAhPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFNlbGVjdGVkLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHNlbGVjdD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgb3B0aW9uYWxseSBzZXR0aW5nIHRoZVxuICogcHJvcHMgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuIElmIGBtdWx0aXBsZWAgaXMgZmFsc2UsIHRoZSBwcm9wIG11c3QgYmUgYVxuICogc3RyaW5nYWJsZS4gSWYgYG11bHRpcGxlYCBpcyB0cnVlLCB0aGUgcHJvcCBtdXN0IGJlIGFuIGFycmF5IG9mIHN0cmluZ2FibGVzLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGNoYW5nZSB0aGVcbiAqIHNlbGVjdGVkIG9wdGlvbiB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgcmVuZGVyZWQgb3B0aW9ucy5cbiAqXG4gKiBJZiBpdCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBvcHRpb25zIHdpbGwgbm90XG4gKiB1cGRhdGUgaW4gcmVzcG9uc2UgdG8gdXNlciBhY3Rpb25zLiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIG9wdGlvbnMgdG8gdXBkYXRlLlxuICpcbiAqIElmIGBkZWZhdWx0VmFsdWVgIGlzIHByb3ZpZGVkLCBhbnkgb3B0aW9ucyB3aXRoIHRoZSBzdXBwbGllZCB2YWx1ZXMgd2lsbCBiZVxuICogc2VsZWN0ZWQuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgcmV0dXJuIF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZFxuICB9KTtcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKTtcbiAgfVxuXG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBwcm9wcy5kZWZhdWx0VmFsdWUsXG4gICAgd2FzTXVsdGlwbGU6ICEhcHJvcHMubXVsdGlwbGVcbiAgfTtcblxuICB7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnU2VsZWN0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBzZWxlY3QgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5tdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0VXBkYXRlV3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIC8vIEFmdGVyIHRoZSBpbml0aWFsIG1vdW50LCB3ZSBjb250cm9sIHNlbGVjdGVkLW5lc3MgbWFudWFsbHkgc28gZG9uJ3QgcGFzc1xuICAvLyB0aGlzIHZhbHVlIGRvd25cbiAgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSA9IHVuZGVmaW5lZDtcblxuICB2YXIgd2FzTXVsdGlwbGUgPSBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSA9ICEhcHJvcHMubXVsdGlwbGU7XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSAhIXByb3BzLm11bHRpcGxlKSB7XG4gICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLm11bHRpcGxlID8gW10gOiAnJywgZmFsc2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FyblZhbERlZmF1bHRWYWwgPSBmYWxzZTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIGB2YWx1ZWAsIGFuZFxuICogYGRlZmF1bHRWYWx1ZWAuIFRoaXMgZGlmZmVycyBmcm9tIHRoZSB0cmFkaXRpb25hbCBET00gQVBJIGJlY2F1c2UgdmFsdWUgaXNcbiAqIHVzdWFsbHkgc2V0IGFzIFBDREFUQSBjaGlsZHJlbi5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBhZmZlY3QgdGhlXG4gKiB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbFxuICogbm90IHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCB3aXRoIGFuIGVtcHR5IHZhbHVlLCB0aGUgcHJvcFxuICogYGRlZmF1bHRWYWx1ZWAgaWYgc3BlY2lmaWVkLCBvciB0aGUgY2hpbGRyZW4gY29udGVudCAoZGVwcmVjYXRlZCkuXG4gKi9cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBkb2VzIG5vdCBtYWtlIHNlbnNlIG9uIDx0ZXh0YXJlYT4uJykgOiB2b2lkIDA7XG5cbiAgLy8gQWx3YXlzIHNldCBjaGlsZHJlbiB0byB0aGUgc2FtZSB0aGluZy4gSW4gSUU5LCB0aGUgc2VsZWN0aW9uIHJhbmdlIHdpbGxcbiAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC4gIFdlIGNvdWxkIGFkZCBhIGNoZWNrIGluIHNldFRleHRDb250ZW50XG4gIC8vIHRvIG9ubHkgc2V0IHRoZSB2YWx1ZSBpZi93aGVuIHRoZSB2YWx1ZSBkaWZmZXJzIGZyb20gdGhlIG5vZGUgdmFsdWUgKHdoaWNoIHdvdWxkXG4gIC8vIGNvbXBsZXRlbHkgc29sdmUgdGhpcyBJRTkgYnVnKSwgYnV0IFNlYmFzdGlhbitTb3BoaWUgc2VlbWVkIHRvIGxpa2UgdGhpc1xuICAvLyBzb2x1dGlvbi4gVGhlIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQncyBmb3JjZWRcbiAgLy8gdG8gYmUgYSBzdHJpbmcuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgY2hpbGRyZW46ICcnICsgbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZVxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoJ3RleHRhcmVhJywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSk7XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWxEZWZhdWx0VmFsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGV4dGFyZWEgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHRleHRhcmVhICcgKyAnYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbERlZmF1bHRWYWwgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBpbml0aWFsVmFsdWUgPSBwcm9wcy52YWx1ZTtcblxuICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICBpZiAoaW5pdGlhbFZhbHVlID09IG51bGwpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgIC8vIFRPRE8gKHl1bmdzdGVycyk6IFJlbW92ZSBzdXBwb3J0IGZvciBjaGlsZHJlbiBjb250ZW50IGluIDx0ZXh0YXJlYT4uXG4gICAgdmFyIGNoaWxkcmVuID0gcHJvcHMuY2hpbGRyZW47XG4gICAgaWYgKGNoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBpbnN0ZWFkIG9mIHNldHRpbmcgJyArICdjaGlsZHJlbiBvbiA8dGV4dGFyZWE+LicpO1xuICAgICAgfVxuICAgICAgIShkZWZhdWx0VmFsdWUgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdJZiB5b3Ugc3VwcGx5IGBkZWZhdWx0VmFsdWVgIG9uIGEgPHRleHRhcmVhPiwgZG8gbm90IHBhc3MgY2hpbGRyZW4uJykgOiB2b2lkIDA7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgIShjaGlsZHJlbi5sZW5ndGggPD0gMSkgPyBpbnZhcmlhbnQoZmFsc2UsICc8dGV4dGFyZWE+IGNhbiBvbmx5IGhhdmUgYXQgbW9zdCBvbmUgY2hpbGQuJykgOiB2b2lkIDA7XG4gICAgICAgIGNoaWxkcmVuID0gY2hpbGRyZW5bMF07XG4gICAgICB9XG5cbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnICsgY2hpbGRyZW47XG4gICAgfVxuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgZGVmYXVsdFZhbHVlID0gJyc7XG4gICAgfVxuICAgIGluaXRpYWxWYWx1ZSA9IGRlZmF1bHRWYWx1ZTtcbiAgfVxuXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6ICcnICsgaW5pdGlhbFZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgIHZhciBuZXdWYWx1ZSA9ICcnICsgdmFsdWU7XG5cbiAgICAvLyBUbyBhdm9pZCBzaWRlIGVmZmVjdHMgKHN1Y2ggYXMgbG9zaW5nIHRleHQgc2VsZWN0aW9uKSwgb25seSBzZXQgdmFsdWUgaWYgY2hhbmdlZFxuICAgIGlmIChuZXdWYWx1ZSAhPT0gbm9kZS52YWx1ZSkge1xuICAgICAgbm9kZS52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICB9XG4gIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgIG5vZGUuZGVmYXVsdFZhbHVlID0gcHJvcHMuZGVmYXVsdFZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIC8vIFRoaXMgaXMgaW4gcG9zdE1vdW50IGJlY2F1c2Ugd2UgbmVlZCBhY2Nlc3MgdG8gdGhlIERPTSBub2RlLCB3aGljaCBpcyBub3RcbiAgLy8gYXZhaWxhYmxlIHVudGlsIGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIG1vdW50ZWQuXG4gIHZhciB0ZXh0Q29udGVudCA9IG5vZGUudGV4dENvbnRlbnQ7XG5cbiAgLy8gT25seSBzZXQgbm9kZS52YWx1ZSBpZiB0ZXh0Q29udGVudCBpcyBlcXVhbCB0byB0aGUgZXhwZWN0ZWRcbiAgLy8gaW5pdGlhbCB2YWx1ZS4gSW4gSUUxMC9JRTExIHRoZXJlIGlzIGEgYnVnIHdoZXJlIHRoZSBwbGFjZWhvbGRlciBhdHRyaWJ1dGVcbiAgLy8gd2lsbCBwb3B1bGF0ZSB0ZXh0Q29udGVudCBhcyB3ZWxsLlxuICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMDE1MjUvXG4gIGlmICh0ZXh0Q29udGVudCA9PT0gbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSkge1xuICAgIG5vZGUudmFsdWUgPSB0ZXh0Q29udGVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKTtcbn1cblxudmFyIEhUTUxfTkFNRVNQQUNFJDEgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCc7XG52YXIgTUFUSF9OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTCc7XG52YXIgU1ZHX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cbnZhciBOYW1lc3BhY2VzID0ge1xuICBodG1sOiBIVE1MX05BTUVTUEFDRSQxLFxuICBtYXRobWw6IE1BVEhfTkFNRVNQQUNFLFxuICBzdmc6IFNWR19OQU1FU1BBQ0Vcbn07XG5cbi8vIEFzc3VtZXMgdGhlcmUgaXMgbm8gcGFyZW50IG5hbWVzcGFjZS5cbmZ1bmN0aW9uIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3N2Zyc6XG4gICAgICByZXR1cm4gU1ZHX05BTUVTUEFDRTtcbiAgICBjYXNlICdtYXRoJzpcbiAgICAgIHJldHVybiBNQVRIX05BTUVTUEFDRTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFJDE7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKSB7XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT0gbnVsbCB8fCBwYXJlbnROYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFJDEpIHtcbiAgICAvLyBObyAob3IgZGVmYXVsdCkgcGFyZW50IG5hbWVzcGFjZTogcG90ZW50aWFsIGVudHJ5IHBvaW50LlxuICAgIHJldHVybiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PT0gU1ZHX05BTUVTUEFDRSAmJiB0eXBlID09PSAnZm9yZWlnbk9iamVjdCcpIHtcbiAgICAvLyBXZSdyZSBsZWF2aW5nIFNWRy5cbiAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxuICAvLyBCeSBkZWZhdWx0LCBwYXNzIG5hbWVzcGFjZSBiZWxvdy5cbiAgcmV0dXJuIHBhcmVudE5hbWVzcGFjZTtcbn1cblxuLyogZ2xvYmFscyBNU0FwcCAqL1xuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHdoaWNoIGhhcyAndW5zYWZlJyBwcml2aWxlZ2VzIChyZXF1aXJlZCBieSB3aW5kb3dzOCBhcHBzKVxuICovXG52YXIgY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIGlmICh0eXBlb2YgTVNBcHAgIT09ICd1bmRlZmluZWQnICYmIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmdW5jKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuYztcbiAgfVxufTtcblxuLy8gU1ZHIHRlbXAgY29udGFpbmVyIGZvciBJRSBsYWNraW5nIGlubmVySFRNTFxudmFyIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gdm9pZCAwO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZVxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0SW5uZXJIVE1MID0gY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbihmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAvLyBJRSBkb2VzIG5vdCBoYXZlIGlubmVySFRNTCBmb3IgU1ZHIG5vZGVzLCBzbyBpbnN0ZWFkIHdlIGluamVjdCB0aGVcbiAgLy8gbmV3IG1hcmt1cCBpbiBhIHRlbXAgbm9kZSBhbmQgdGhlbiBtb3ZlIHRoZSBjaGlsZCBub2RlcyBhY3Jvc3MgaW50b1xuICAvLyB0aGUgdGFyZ2V0IG5vZGVcblxuICBpZiAobm9kZS5uYW1lc3BhY2VVUkkgPT09IE5hbWVzcGFjZXMuc3ZnICYmICEoJ2lubmVySFRNTCcgaW4gbm9kZSkpIHtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHJldXNhYmxlU1ZHQ29udGFpbmVyIHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyLmlubmVySFRNTCA9ICc8c3ZnPicgKyBodG1sICsgJzwvc3ZnPic7XG4gICAgdmFyIHN2Z05vZGUgPSByZXVzYWJsZVNWR0NvbnRhaW5lci5maXJzdENoaWxkO1xuICAgIHdoaWxlIChub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgd2hpbGUgKHN2Z05vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5hcHBlbmRDaGlsZChzdmdOb2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFNldCB0aGUgdGV4dENvbnRlbnQgcHJvcGVydHkgb2YgYSBub2RlLCBlbnN1cmluZyB0aGF0IHdoaXRlc3BhY2UgaXMgcHJlc2VydmVkXG4gKiBldmVuIGluIElFOC4gaW5uZXJUZXh0IGlzIGEgcG9vciBzdWJzdGl0dXRlIGZvciB0ZXh0Q29udGVudCBhbmQsIGFtb25nIG1hbnlcbiAqIGlzc3VlcywgaW5zZXJ0cyA8YnI+IGluc3RlYWQgb2YgdGhlIGxpdGVyYWwgbmV3bGluZSBjaGFycy4gaW5uZXJIVE1MIGJlaGF2ZXNcbiAqIGFzIGl0IHNob3VsZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgaWYgKHRleHQpIHtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDtcblxuICAgIGlmIChmaXJzdENoaWxkICYmIGZpcnN0Q2hpbGQgPT09IG5vZGUubGFzdENoaWxkICYmIGZpcnN0Q2hpbGQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICBub2RlLnRleHRDb250ZW50ID0gdGV4dDtcbn07XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICBib3JkZXJJbWFnZVdpZHRoOiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGNvbHVtbnM6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcblxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSA9IGVtcHR5RnVuY3Rpb247XG5cbntcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIGNhbWVsaXplU3R5bGVOYW1lKG5hbWUpLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCBcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4lcycsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJyksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkRm9ySW5maW5pdHlWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlJDEgPSB3YXJuVmFsaWRTdHlsZTtcblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cblxuLyoqXG4gKiBUaGlzIGNyZWF0ZXMgYSBzdHJpbmcgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBlcXVpdmFsZW50IHRvIHRoZSBzdHlsZVxuICogYXR0cmlidXRlIGdlbmVyYXRlZCBieSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuIEl0IGJ5LXBhc3NlcyB3YXJuaW5ncyBhbmRcbiAqIHNlY3VyaXR5IGNoZWNrcyBzbyBpdCdzIG5vdCBzYWZlIHRvIHVzZSB0aGlzIHZhbHVlIGZvciBhbnl0aGluZyBvdGhlciB0aGFuXG4gKiBjb21wYXJpc29uLiBJdCBpcyBvbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKHN0eWxlcykge1xuICB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICB2YXIgZGVsaW1pdGVyID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGVsaW1pdGVyICsgaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpO1xuXG4gICAgICAgIGRlbGltaXRlciA9ICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICovXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZXMsIGdldFN0YWNrKSB7XG4gIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICAgIH1cbiAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxudmFyIEhUTUwkMSA9ICdfX2h0bWwnO1xuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMsIGdldFN0YWNrKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1t0YWddKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIHRhZywgZ2V0U3RhY2soKSkgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwkMSBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHdhcm5pbmcocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4lcycsIGdldFN0YWNrKCkpO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgd2hpdGVsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgIHZhciBhcmlhTmFtZSA9ICdhcmlhLScgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIGNvcnJlY3ROYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAockFSSUEudGVzdChuYW1lKSkge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMSgpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIHdoaXRlbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gICdjbGFzcyc6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICAnZGVmYXVsdCc6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgJ2Zvcic6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcblxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICAnaW4nOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICAndHlwZW9mJzogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtJDIoKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbntcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xuICB2YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbi4vO1xuICB2YXIgSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYID0gL15vblteQS1aXS87XG4gIHZhciByQVJJQSQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKS1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG4gIHZhciByQVJJQUNhbWVsJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydHkkMSA9IGZ1bmN0aW9uICh0YWdOYW1lLCBuYW1lLCB2YWx1ZSwgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkkMS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllcyQxW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c2luJyB8fCBsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNvdXQnKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgdXNlcyBvbkZvY3VzIGFuZCBvbkJsdXIgaW5zdGVhZCBvZiBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQuICcgKyAnQWxsIFJlYWN0IGV2ZW50cyBhcmUgbm9ybWFsaXplZCB0byBidWJibGUsIHNvIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dCAnICsgJ2FyZSBub3QgbmVlZGVkL3N1cHBvcnRlZCBieSBSZWFjdC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBXZSBjYW4ndCByZWx5IG9uIHRoZSBldmVudCBzeXN0ZW0gYmVpbmcgaW5qZWN0ZWQgb24gdGhlIHNlcnZlci5cbiAgICBpZiAoY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG4gICAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKEVWRU5UX05BTUVfUkVHRVgudGVzdChuYW1lKSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVW5rbm93biBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIEl0IHdpbGwgYmUgaWdub3JlZC4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBhcmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBTbyB3ZSBjYW4ndCB0ZWxsIGlmIHRoZSBldmVudCBuYW1lIGlzIGNvcnJlY3QgZm9yIHN1cmUsIGJ1dCB3ZSBjYW4gZmlsdGVyXG4gICAgICAvLyBvdXQga25vd24gYmFkIG9uZXMgbGlrZSBgb25jbGlja2AuIFdlIGNhbid0IHN1Z2dlc3QgYSBzcGVjaWZpYyByZXBsYWNlbWVudCB0aG91Z2guXG4gICAgICBpZiAoSU5WQUxJRF9FVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiAnICsgJ1JlYWN0IGV2ZW50cyB1c2UgdGhlIGNhbWVsQ2FzZSBuYW1pbmcgY29udmVudGlvbiwgZm9yIGV4YW1wbGUgYG9uQ2xpY2tgLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIExldCB0aGUgQVJJQSBhdHRyaWJ1dGUgaG9vayB2YWxpZGF0ZSBBUklBIGF0dHJpYnV0ZXNcbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpbm5lcmh0bWwnKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRGlyZWN0bHkgc2V0dGluZyBwcm9wZXJ0eSBgaW5uZXJIVE1MYCBpcyBub3QgcGVybWl0dGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCBsb29rdXAgZG9jdW1lbnRhdGlvbiBvbiBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2FyaWEnKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGBhcmlhYCBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UgaW4gUmVhY3QuICcgKyAnUGFzcyBpbmRpdmlkdWFsIGBhcmlhLWAgYXR0cmlidXRlcyBpbnN0ZWFkLicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lzJyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBhIGAlc2AgZm9yIGEgc3RyaW5nIGF0dHJpYnV0ZSBgaXNgLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLiVzJywgdHlwZW9mIHZhbHVlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgaXNOYU4odmFsdWUpKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVjZWl2ZWQgTmFOIGZvciB0aGUgYCVzYCBhdHRyaWJ1dGUuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGlzUmVzZXJ2ZWQgPSBpc1Jlc2VydmVkUHJvcChuYW1lKTtcblxuICAgIC8vIEtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIG1hdGNoIHRoZSBjYXNpbmcgc3BlY2lmaWVkIGluIHRoZSBwcm9wZXJ0eSBjb25maWcuXG4gICAgaWYgKHBvc3NpYmxlU3RhbmRhcmROYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkpIHtcbiAgICAgIHZhciBzdGFuZGFyZE5hbWUgPSBwb3NzaWJsZVN0YW5kYXJkTmFtZXNbbG93ZXJDYXNlZE5hbWVdO1xuICAgICAgaWYgKHN0YW5kYXJkTmFtZSAhPT0gbmFtZSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBET00gcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghaXNSZXNlcnZlZCAmJiBuYW1lICE9PSBsb3dlckNhc2VkTmFtZSkge1xuICAgICAgLy8gVW5rbm93biBhdHRyaWJ1dGVzIHNob3VsZCBoYXZlIGxvd2VyY2FzZSBjYXNpbmcgc2luY2UgdGhhdCdzIGhvdyB0aGV5XG4gICAgICAvLyB3aWxsIGJlIGNhc2VkIGFueXdheSB3aXRoIHNlcnZlciByZW5kZXJpbmcuXG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZG9lcyBub3QgcmVjb2duaXplIHRoZSBgJXNgIHByb3Agb24gYSBET00gZWxlbWVudC4gSWYgeW91ICcgKyAnaW50ZW50aW9uYWxseSB3YW50IGl0IHRvIGFwcGVhciBpbiB0aGUgRE9NIGFzIGEgY3VzdG9tICcgKyAnYXR0cmlidXRlLCBzcGVsbCBpdCBhcyBsb3dlcmNhc2UgYCVzYCBpbnN0ZWFkLiAnICsgJ0lmIHlvdSBhY2NpZGVudGFsbHkgcGFzc2VkIGl0IGZyb20gYSBwYXJlbnQgY29tcG9uZW50LCByZW1vdmUgJyArICdpdCBmcm9tIHRoZSBET00gZWxlbWVudC4lcycsIG5hbWUsIGxvd2VyQ2FzZWROYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nICYmICFzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUobmFtZSkpIHtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LiVzJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVjZWl2ZWQgYCVzYCBmb3IgYSBub24tYm9vbGVhbiBhdHRyaWJ1dGUgYCVzYC5cXG5cXG4nICsgJ0lmIHlvdSB3YW50IHRvIHdyaXRlIGl0IHRvIHRoZSBET00sIHBhc3MgYSBzdHJpbmcgaW5zdGVhZDogJyArICclcz1cIiVzXCIgb3IgJXM9e3ZhbHVlLnRvU3RyaW5nKCl9LlxcblxcbicgKyAnSWYgeW91IHVzZWQgdG8gY29uZGl0aW9uYWxseSBvbWl0IGl0IHdpdGggJXM9e2NvbmRpdGlvbiAmJiB2YWx1ZX0sICcgKyAncGFzcyAlcz17Y29uZGl0aW9uID8gdmFsdWUgOiB1bmRlZmluZWR9IGluc3RlYWQuJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIG5hbWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH1cbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBOb3cgdGhhdCB3ZSd2ZSB2YWxpZGF0ZWQgY2FzaW5nLCBkbyBub3QgdmFsaWRhdGVcbiAgICAvLyBkYXRhIHR5cGVzIGZvciByZXNlcnZlZCBwcm9wc1xuICAgIGlmIChpc1Jlc2VydmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBXYXJuIHdoZW4gYSBrbm93biBhdHRyaWJ1dGUgaXMgYSBiYWQgdHlwZVxuICAgIGlmICghc2hvdWxkU2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKSkge1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcbn1cblxudmFyIHdhcm5Vbmtub3duUHJvcGVydGllcyA9IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0sIGNhblVzZUV2ZW50U3lzdGVtKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcywgY2FuVXNlRXZlbnRTeXN0ZW0pIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuVW5rbm93blByb3BlcnRpZXModHlwZSwgcHJvcHMsIGNhblVzZUV2ZW50U3lzdGVtKTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSBmYWxzZTtcbnZhciBkaWRXYXJuU2hhZHlET00gPSBmYWxzZTtcblxudmFyIERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MID0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJztcbnZhciBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgPSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJztcbnZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG52YXIgQVVUT0ZPQ1VTID0gJ2F1dG9Gb2N1cyc7XG52YXIgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MID0gJ19faHRtbCc7XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9IE5hbWVzcGFjZXMuaHRtbDtcblxuXG52YXIgZ2V0U3RhY2sgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zKCcnKTtcblxue1xuICBnZXRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMjtcblxuICB2YXIgd2FybmVkVW5rbm93blRhZ3MgPSB7XG4gICAgLy8gQ2hyb21lIGlzIHRoZSBvbmx5IG1ham9yIGJyb3dzZXIgbm90IHNoaXBwaW5nIDx0aW1lPi4gQnV0IGFzIG9mIEp1bHlcbiAgICAvLyAyMDE3IGl0IGludGVuZHMgdG8gc2hpcCBpdCBkdWUgdG8gd2lkZXNwcmVhZCB1c2FnZS4gV2UgaW50ZW50aW9uYWxseVxuICAgIC8vICpkb24ndCogd2FybiBmb3IgPHRpbWU+IGV2ZW4gaWYgaXQncyB1bnJlY29nbml6ZWQgYnkgQ2hyb21lIGJlY2F1c2VcbiAgICAvLyBpdCBzb29uIHdpbGwgYmUsIGFuZCBtYW55IGFwcHMgaGF2ZSBiZWVuIHVzaW5nIGl0IGFueXdheS5cbiAgICB0aW1lOiB0cnVlLFxuICAgIC8vIFRoZXJlIGFyZSB3b3JraW5nIHBvbHlmaWxscyBmb3IgPGRpYWxvZz4uIExldCBwZW9wbGUgdXNlIGl0LlxuICAgIGRpYWxvZzogdHJ1ZVxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMsIC8qIGNhblVzZUV2ZW50U3lzdGVtICovdHJ1ZSk7XG4gIH07XG5cbiAgLy8gSFRNTCBwYXJzaW5nIG5vcm1hbGl6ZXMgQ1IgYW5kIENSTEYgdG8gTEYuXG4gIC8vIEl0IGFsc28gY2FuIHR1cm4gXFx1MDAwMCBpbnRvIFxcdUZGRkQgaW5zaWRlIGF0dHJpYnV0ZXMuXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zaW5nbGUtcGFnZS5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuICAvLyBJZiB3ZSBoYXZlIGEgbWlzbWF0Y2gsIGl0IG1pZ2h0IGJlIGNhdXNlZCBieSB0aGF0LlxuICAvLyBXZSB3aWxsIHN0aWxsIHBhdGNoIHVwIGluIHRoaXMgY2FzZSBidXQgbm90IGZpcmUgdGhlIHdhcm5pbmcuXG4gIHZhciBOT1JNQUxJWkVfTkVXTElORVNfUkVHRVggPSAvXFxyXFxuPy9nO1xuICB2YXIgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xcdTAwMDB8XFx1RkZGRC9nO1xuXG4gIHZhciBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIG1hcmt1cFN0cmluZyA9IHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnID8gbWFya3VwIDogJycgKyBtYXJrdXA7XG4gICAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChzZXJ2ZXJUZXh0LCBjbGllbnRUZXh0KSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVGV4dCk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID09PSBub3JtYWxpemVkQ2xpZW50VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1RleHQgY29udGVudCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6IFwiJXNcIiBDbGllbnQ6IFwiJXNcIicsIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0LCBub3JtYWxpemVkQ2xpZW50VGV4dCk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VmFsdWUpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVmFsdWUgPT09IG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Byb3AgYCVzYCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6ICVzIENsaWVudDogJXMnLCBwcm9wTmFtZSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZFNlcnZlclZhbHVlKSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZENsaWVudFZhbHVlKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZXMpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGF0dHJpYnV0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4dHJhIGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyOiAlcycsIG5hbWVzKTtcbiAgfTtcblxuICB2YXIgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyID09PSBmYWxzZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYGZhbHNlYC5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lciwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZSB0aGUgSFRNTCBhbmQgcmVhZCBpdCBiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgSFRNTCBzdHJpbmcgc28gdGhhdCBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAgdmFyIG5vcm1hbGl6ZUhUTUwgPSBmdW5jdGlvbiAocGFyZW50LCBodG1sKSB7XG4gICAgLy8gV2UgY291bGQgaGF2ZSBjcmVhdGVkIGEgc2VwYXJhdGUgZG9jdW1lbnQgaGVyZSB0byBhdm9pZFxuICAgIC8vIHJlLWluaXRpYWxpemluZyBjdXN0b20gZWxlbWVudHMgaWYgdGhleSBleGlzdC4gQnV0IHRoaXMgYnJlYWtzXG4gICAgLy8gaG93IDxub3NjcmlwdD4gaXMgYmVpbmcgaGFuZGxlZC4gU28gd2UgdXNlIHRoZSBzYW1lIGRvY3VtZW50LlxuICAgIC8vIFNlZSB0aGUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMTE1Ny5cbiAgICB2YXIgdGVzdEVsZW1lbnQgPSBwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSA/IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpIDogcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHBhcmVudC5uYW1lc3BhY2VVUkksIHBhcmVudC50YWdOYW1lKTtcbiAgICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiB0ZXN0RWxlbWVudC5pbm5lckhUTUw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBpc0RvY3VtZW50T3JGcmFnbWVudCA9IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudE9yRnJhZ21lbnQgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG59XG5cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChub2RlKSB7XG4gIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gIC8vIEp1c3Qgc2V0IGl0IHVzaW5nIHRoZSBvbmNsaWNrIHByb3BlcnR5IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBtYW5hZ2UgYW55XG4gIC8vIGJvb2trZWVwaW5nIGZvciBpdC4gTm90IHN1cmUgaWYgd2UgbmVlZCB0byBjbGVhciBpdCB3aGVuIHRoZSBsaXN0ZW5lciBpc1xuICAvLyByZW1vdmVkLlxuICAvLyBUT0RPOiBPbmx5IGRvIHRoaXMgZm9yIHRoZSByZWxldmFudCBTYWZhcmlzIG1heWJlP1xuICBub2RlLm9uY2xpY2sgPSBlbXB0eUZ1bmN0aW9uO1xufVxuXG5mdW5jdGlvbiBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsIGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBuZXh0UHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGZvciAodmFyIHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBuZXh0UHJvcCwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgaW5pdGlhbCB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICB2YXIgY2FuU2V0VGV4dENvbnRlbnQgPSB0YWcgIT09ICd0ZXh0YXJlYScgfHwgbmV4dFByb3AgIT09ICcnO1xuICAgICAgICBpZiAoY2FuU2V0VGV4dENvbnRlbnQpIHtcbiAgICAgICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBzZXRUZXh0Q29udGVudChkb21FbGVtZW50LCAnJyArIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIFdlIHBvbHlmaWxsIGl0IHNlcGFyYXRlbHkgb24gdGhlIGNsaWVudCBkdXJpbmcgY29tbWl0LlxuICAgICAgLy8gV2UgYmxhY2tsaXN0IGl0IGhlcmUgcmF0aGVyIHRoYW4gaW4gdGhlIHByb3BlcnR5IGxpc3QgYmVjYXVzZSB3ZSBlbWl0IGl0IGluIFNTUi5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIC8vIFRPRE86IEhhbmRsZSB3YXNDdXN0b21Db21wb25lbnRUYWdcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVQYXlsb2FkLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHByb3BLZXkgPSB1cGRhdGVQYXlsb2FkW2ldO1xuICAgIHZhciBwcm9wVmFsdWUgPSB1cGRhdGVQYXlsb2FkW2kgKyAxXTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIHNldFRleHRDb250ZW50KGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQsIHBhcmVudE5hbWVzcGFjZSkge1xuICAvLyBXZSBjcmVhdGUgdGFncyBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZWlyIHBhcmVudCBjb250YWluZXIsIGV4Y2VwdCBIVE1MXG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgdmFyIGRvbUVsZW1lbnQ7XG4gIHZhciBuYW1lc3BhY2VVUkkgPSBwYXJlbnROYW1lc3BhY2U7XG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgbmFtZXNwYWNlVVJJID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAge1xuICAgICAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpO1xuICAgICAgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuICAgICAgd2FybmluZyhpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCB0eXBlID09PSB0eXBlLnRvTG93ZXJDYXNlKCksICc8JXMgLz4gaXMgdXNpbmcgdXBwZXJjYXNlIEhUTUwuIEFsd2F5cyB1c2UgbG93ZXJjYXNlIEhUTUwgdGFncyAnICsgJ2luIFJlYWN0LicsIHR5cGUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc2NyaXB0Jykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LmlubmVySFRNTCA9ICc8c2NyaXB0PjwnICsgJy9zY3JpcHQ+JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIHlpZWxkIGEgc2NyaXB0IGVsZW1lbnQuXG4gICAgICB2YXIgZmlyc3RDaGlsZCA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgZG9tRWxlbWVudCA9IGRpdi5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgYGNyZWF0ZUVsZW1lbnRgIHNob3VsZCBiZSB1cGRhdGVkIGZvciBXZWIgQ29tcG9uZW50c1xuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlLCB7IGlzOiBwcm9wcy5pcyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VwYXJhdGUgZWxzZSBicmFuY2ggaW5zdGVhZCBvZiB1c2luZyBgcHJvcHMuaXMgfHwgdW5kZWZpbmVkYCBhYm92ZSBiZWNhdXNlIG9mIGEgRmlyZWZveCBidWcuXG4gICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC82ODk2XG4gICAgICAvLyBhbmQgZGlzY3Vzc2lvbiBpbiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjc2MjQwXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0eXBlKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgaWYgKCFpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF0nICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2FybmVkVW5rbm93blRhZ3MsIHR5cGUpKSB7XG4gICAgICAgIHdhcm5lZFVua25vd25UYWdzW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSB0YWcgPCVzPiBpcyB1bnJlY29nbml6ZWQgaW4gdGhpcyBicm93c2VyLiAnICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBSZWFjdCBjb21wb25lbnQsIHN0YXJ0IGl0cyBuYW1lIHdpdGggJyArICdhbiB1cHBlcmNhc2UgbGV0dGVyLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSQxKHRleHQsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpLmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuXG5mdW5jdGlvbiBzZXRJbml0aWFsUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcgJiYgIWRpZFdhcm5TaGFkeURPTSAmJiBkb21FbGVtZW50LnNoYWR5Um9vdCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGlzIHVzaW5nIHNoYWR5IERPTS4gVXNpbmcgc2hhZHkgRE9NIHdpdGggUmVhY3QgY2FuICcgKyAnY2F1c2UgdGhpbmdzIHRvIGJyZWFrIHN1YnRseS4nLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSgpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgZGlkV2FyblNoYWR5RE9NID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuICB2YXIgcHJvcHM7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRzW2V2ZW50XSwgZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFJlc2V0JywgJ3Jlc2V0JywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BTdWJtaXQnLCAnc3VibWl0JywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spO1xuXG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbi8vIENhbGN1bGF0ZSB0aGUgZGlmZiBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0cy5cbmZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gIHZhciBsYXN0UHJvcHM7XG4gIHZhciBuZXh0UHJvcHM7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxhc3RQcm9wcyA9IGxhc3RSYXdQcm9wcztcbiAgICAgIG5leHRQcm9wcyA9IG5leHRSYXdQcm9wcztcbiAgICAgIGlmICh0eXBlb2YgbGFzdFByb3BzLm9uQ2xpY2sgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG5leHRQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgbmV4dFByb3BzLCBnZXRTdGFjayk7XG5cbiAgdmFyIHByb3BLZXk7XG4gIHZhciBzdHlsZU5hbWU7XG4gIHZhciBzdHlsZVVwZGF0ZXMgPSBudWxsO1xuICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB2YXIgbGFzdFN0eWxlID0gbGFzdFByb3BzW3Byb3BLZXldO1xuICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgfHwgcHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIE5vb3AuIFRoaXMgaXMgaGFuZGxlZCBieSB0aGUgY2xlYXIgdGV4dCBtZWNoYW5pc20uXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBOb29wLiBJdCBkb2Vzbid0IHdvcmsgb24gdXBkYXRlcyBhbnl3YXkuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIGZpYmVyIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYWxsIG90aGVyIGRlbGV0ZWQgcHJvcGVydGllcyB3ZSBhZGQgaXQgdG8gdGhlIHF1ZXVlLiBXZSB1c2VcbiAgICAgIC8vIHRoZSB3aGl0ZWxpc3QgaW4gdGhlIGNvbW1pdCBwaGFzZSBpbnN0ZWFkLlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG51bGwpO1xuICAgIH1cbiAgfVxuICBmb3IgKHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIHZhciBsYXN0UHJvcCA9IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZC5wdXNoKHByb3BLZXksIHN0eWxlVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wID8gbGFzdFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dEh0bWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBJdCBtaWdodCBiZSB0b28gbGF0ZSB0byBjbGVhciB0aGlzIGlmIHdlIGhhdmUgY2hpbGRyZW5cbiAgICAgICAgLy8gaW5zZXJ0ZWQgYWxyZWFkeS5cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAobGFzdFByb3AgIT09IG5leHRQcm9wICYmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgLy8gV2UgZWFnZXJseSBsaXN0ZW4gdG8gdGhpcyBldmVuIHRob3VnaCB3ZSBoYXZlbid0IGNvbW1pdHRlZCB5ZXQuXG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkICYmIGxhc3RQcm9wICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBwcm9wcyBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFueSBvdGhlciBwcm9wZXJ0eSB3ZSBhbHdheXMgYWRkIGl0IHRvIHRoZSBxdWV1ZSBhbmQgdGhlbiB3ZVxuICAgICAgLy8gZmlsdGVyIGl0IG91dCB1c2luZyB0aGUgd2hpdGVsaXN0IGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChTVFlMRSwgc3R5bGVVcGRhdGVzKTtcbiAgfVxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuLy8gQXBwbHkgdGhlIGRpZmYuXG5mdW5jdGlvbiB1cGRhdGVQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcykge1xuICAvLyBVcGRhdGUgY2hlY2tlZCAqYmVmb3JlKiBuYW1lLlxuICAvLyBJbiB0aGUgbWlkZGxlIG9mIGFuIHVwZGF0ZSwgaXQgaXMgcG9zc2libGUgdG8gaGF2ZSBtdWx0aXBsZSBjaGVja2VkLlxuICAvLyBXaGVuIGEgY2hlY2tlZCByYWRpbyB0cmllcyB0byBjaGFuZ2UgbmFtZSwgYnJvd3NlciBtYWtlcyBhbm90aGVyIHJhZGlvJ3MgY2hlY2tlZCBmYWxzZS5cbiAgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiBuZXh0UmF3UHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuZXh0UmF3UHJvcHMubmFtZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlQ2hlY2tlZChkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICB9XG5cbiAgdmFyIHdhc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbGFzdFJhd1Byb3BzKTtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICAvLyBBcHBseSB0aGUgZGlmZi5cbiAgdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICAvLyBUT0RPOiBFbnN1cmUgdGhhdCBhbiB1cGRhdGUgZ2V0cyBzY2hlZHVsZWQgaWYgYW55IG9mIHRoZSBzcGVjaWFsIHByb3BzXG4gIC8vIGNoYW5nZWQuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVXBkYXRlIHRoZSB3cmFwcGVyIGFyb3VuZCBpbnB1dHMgKmFmdGVyKiB1cGRhdGluZyBwcm9wcy4gVGhpcyBoYXMgdG9cbiAgICAgIC8vIGhhcHBlbiBhZnRlciBgdXBkYXRlRE9NUHJvcGVydGllc2AuIE90aGVyd2lzZSBIVE1MNSBpbnB1dCB2YWxpZGF0aW9uc1xuICAgICAgLy8gcmFpc2Ugd2FybmluZ3MgYW5kIHByZXZlbnQgdGhlIG5ldyB2YWx1ZSBmcm9tIGJlaW5nIGFzc2lnbmVkLlxuICAgICAgdXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgdXBkYXRlV3JhcHBlciQxKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgcG9zdFVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIHJhd1Byb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHtcbiAgICB2YXIgc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nID0gcmF3UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMV0gPT09IHRydWU7XG4gICAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcgJiYgIWRpZFdhcm5TaGFkeURPTSAmJiBkb21FbGVtZW50LnNoYWR5Um9vdCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGlzIHVzaW5nIHNoYWR5IERPTS4gVXNpbmcgc2hhZHkgRE9NIHdpdGggUmVhY3QgY2FuICcgKyAnY2F1c2UgdGhpbmdzIHRvIGJyZWFrIHN1YnRseS4nLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSgpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgZGlkV2FyblNoYWR5RE9NID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRzW2V2ZW50XSwgZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW1nJzpcbiAgICBjYXNlICdpbWFnZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFJlc2V0JywgJ3Jlc2V0JywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BTdWJtaXQnLCAnc3VibWl0JywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFRvZ2dsZScsICd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIHZhbGlkYXRlUHJvcHMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgcmF3UHJvcHMsIGdldFN0YWNrKTtcblxuICB7XG4gICAgdmFyIGV4dHJhQXR0cmlidXRlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIGF0dHJpYnV0ZXMgPSBkb21FbGVtZW50LmF0dHJpYnV0ZXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmFtZSA9IGF0dHJpYnV0ZXNbaV0ubmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgIC8vIEJ1aWx0LWluIFNTUiBhdHRyaWJ1dGUgaXMgd2hpdGVsaXN0ZWRcbiAgICAgICAgY2FzZSAnZGF0YS1yZWFjdHJvb3QnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICAgIGNhc2UgJ3ZhbHVlJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NlbGVjdGVkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAvLyBJbnRlbnRpb25hbGx5IHVzZSB0aGUgb3JpZ2luYWwgbmFtZS5cbiAgICAgICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMDY3Ni5cbiAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzLmFkZChhdHRyaWJ1dGVzW2ldLm5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVQYXlsb2FkID0gbnVsbDtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiByYXdQcm9wcykge1xuICAgIGlmICghcmF3UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3AgPSByYXdQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIEZvciB0ZXh0IGNvbnRlbnQgY2hpbGRyZW4gd2UgY29tcGFyZSBhZ2FpbnN0IHRleHRDb250ZW50LiBUaGlzXG4gICAgICAvLyBtaWdodCBtYXRjaCBhZGRpdGlvbmFsIEhUTUwgdGhhdCBpcyBoaWRkZW4gd2hlbiB3ZSByZWFkIGl0IHVzaW5nXG4gICAgICAvLyB0ZXh0Q29udGVudC4gRS5nLiBcImZvb1wiIHdpbGwgbWF0Y2ggXCJmPHNwYW4+b288L3NwYW4+XCIgYnV0IHRoYXQgc3RpbGxcbiAgICAgIC8vIHNhdGlzZmllcyBvdXIgcmVxdWlyZW1lbnQuIE91ciByZXF1aXJlbWVudCBpcyBub3QgdG8gcHJvZHVjZSBwZXJmZWN0XG4gICAgICAvLyBIVE1MIGFuZCBhdHRyaWJ1dGVzLiBJZGVhbGx5IHdlIHNob3VsZCBwcmVzZXJ2ZSBzdHJ1Y3R1cmUgYnV0IGl0J3NcbiAgICAgIC8vIG9rIG5vdCB0byBpZiB0aGUgdmlzaWJsZSBjb250ZW50IGlzIHN0aWxsIGVub3VnaCB0byBpbmRpY2F0ZSB3aGF0XG4gICAgICAvLyBldmVuIGxpc3RlbmVycyB0aGVzZSBub2RlcyBtaWdodCBiZSB3aXJlZCB1cCB0by5cbiAgICAgIC8vIFRPRE86IFdhcm4gaWYgdGhlcmUgaXMgbW9yZSB0aGFuIGEgc2luZ2xlIHRleHROb2RlIGFzIGEgY2hpbGQuXG4gICAgICAvLyBUT0RPOiBTaG91bGQgd2UgdXNlIGRvbUVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgdG8gY29tcGFyZT9cbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkb21FbGVtZW50LnRleHRDb250ZW50ICE9PSAnJyArIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgJycgKyBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVmFsaWRhdGUgdGhhdCB0aGUgcHJvcGVydGllcyBjb3JyZXNwb25kIHRvIHRoZWlyIGV4cGVjdGVkIHZhbHVlcy5cbiAgICAgIHZhciBzZXJ2ZXJWYWx1ZTtcbiAgICAgIHZhciBwcm9wZXJ0eUluZm87XG4gICAgICBpZiAoc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcuIFdlJ3JlIGlnbm9yaW5nIGFsbCB0aGVzZSB3YXJuaW5ncy5cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEgfHxcbiAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgLy8gVE9ETzogT25seSBpZ25vcmUgdGhlbSBvbiBjb250cm9sbGVkIHRhZ3MuXG4gICAgICBwcm9wS2V5ID09PSAndmFsdWUnIHx8IHByb3BLZXkgPT09ICdjaGVja2VkJyB8fCBwcm9wS2V5ID09PSAnc2VsZWN0ZWQnKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgICAgdmFyIHJhd0h0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIHx8ICcnIDogJyc7XG4gICAgICAgIHZhciBzZXJ2ZXJIVE1MID0gZG9tRWxlbWVudC5pbm5lckhUTUw7XG4gICAgICAgIHZhciBleHBlY3RlZEhUTUwgPSBub3JtYWxpemVIVE1MKGRvbUVsZW1lbnQsIHJhd0h0bWwpO1xuICAgICAgICBpZiAoZXhwZWN0ZWRIVE1MICE9PSBzZXJ2ZXJIVE1MKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlckhUTUwsIGV4cGVjdGVkSFRNTCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5KTtcbiAgICAgICAgdmFyIGV4cGVjdGVkU3R5bGUgPSBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMobmV4dFByb3ApO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGRvbUVsZW1lbnQuZ2V0QXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICBpZiAoZXhwZWN0ZWRTdHlsZSAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIGV4cGVjdGVkU3R5bGUpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZFNldEF0dHJpYnV0ZShwcm9wS2V5LCBuZXh0UHJvcCkpIHtcbiAgICAgICAgaWYgKHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhwcm9wS2V5KSkge1xuICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gcGFyZW50TmFtZXNwYWNlO1xuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICBvd25OYW1lc3BhY2UgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodGFnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHtcbiAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgaWYgKGV4dHJhQXR0cmlidXRlTmFtZXMuc2l6ZSA+IDAgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgd2FybkZvckV4dHJhQXR0cmlidXRlcyhleHRyYUF0dHJpYnV0ZU5hbWVzKTtcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIC8vIEZvciBpbnB1dCBhbmQgdGV4dGFyZWEgd2UgY3VycmVudCBhbHdheXMgc2V0IHRoZSB2YWx1ZSBwcm9wZXJ0eSBhdFxuICAgICAgLy8gcG9zdCBtb3VudCB0byBmb3JjZSBpdCB0byBkaXZlcmdlIGZyb20gYXR0cmlidXRlcy4gSG93ZXZlciwgZm9yXG4gICAgICAvLyBvcHRpb24gYW5kIHNlbGVjdCB3ZSBkb24ndCBxdWl0ZSBkbyB0aGUgc2FtZSB0aGluZyBhbmQgc2VsZWN0XG4gICAgICAvLyBpcyBub3QgcmVzaWxpZW50IHRvIHRoZSBET00gc3RhdGUgY2hhbmdpbmcgc28gd2UgZG9uJ3QgZG8gdGhhdCBoZXJlLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgbm90IGRvaW5nIHRoaXMgZm9yIGlucHV0IGFuZCB0ZXh0YXJlYS5cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBpZiAodHlwZW9mIHJhd1Byb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRUZXh0JDEodGV4dE5vZGUsIHRleHQpIHtcbiAgdmFyIGlzRGlmZmVyZW50ID0gdGV4dE5vZGUubm9kZVZhbHVlICE9PSB0ZXh0O1xuICByZXR1cm4gaXNEaWZmZXJlbnQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDEodGV4dE5vZGUsIHRleHQpIHtcbiAge1xuICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSh0ZXh0Tm9kZS5ub2RlVmFsdWUsIHRleHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMShwYXJlbnROb2RlLCBjaGlsZCkge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIDwlcz4gaW4gPCVzPi4nLCBjaGlsZC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMShwYXJlbnROb2RlLCBjaGlsZCkge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRGlkIG5vdCBleHBlY3Qgc2VydmVyIEhUTUwgdG8gY29udGFpbiB0aGUgdGV4dCBub2RlIFwiJXNcIiBpbiA8JXM+LicsIGNoaWxkLm5vZGVWYWx1ZSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMShwYXJlbnROb2RlLCB0YWcsIHByb3BzKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgPCVzPiBpbiA8JXM+LicsIHRhZywgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMShwYXJlbnROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgIC8vIFdlIGV4cGVjdCB0byBpbnNlcnQgZW1wdHkgdGV4dCBub2RlcyBzaW5jZSB0aGV5J3JlIG5vdCByZXByZXNlbnRlZCBpblxuICAgICAgLy8gdGhlIEhUTUwuXG4gICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBzcGVjaWFsIGNhc2UgaWYgd2UgY2FuIGp1c3QgYXZvaWQgaW5zZXJ0aW5nIGVtcHR5XG4gICAgICAvLyB0ZXh0IG5vZGVzLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgbWF0Y2hpbmcgdGV4dCBub2RlIGZvciBcIiVzXCIgaW4gPCVzPi4nLCB0ZXh0LCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUoZG9tRWxlbWVudCwgdGFnLCBwcm9wcykge1xuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgfVxufVxuXG52YXIgUmVhY3RET01GaWJlckNvbXBvbmVudCA9IE9iamVjdC5mcmVlemUoe1xuXHRjcmVhdGVFbGVtZW50OiBjcmVhdGVFbGVtZW50JDEsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSQxLFxuXHRzZXRJbml0aWFsUHJvcGVydGllczogc2V0SW5pdGlhbFByb3BlcnRpZXMkMSxcblx0ZGlmZlByb3BlcnRpZXM6IGRpZmZQcm9wZXJ0aWVzJDEsXG5cdHVwZGF0ZVByb3BlcnRpZXM6IHVwZGF0ZVByb3BlcnRpZXMkMSxcblx0ZGlmZkh5ZHJhdGVkUHJvcGVydGllczogZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxLFxuXHRkaWZmSHlkcmF0ZWRUZXh0OiBkaWZmSHlkcmF0ZWRUZXh0JDEsXG5cdHdhcm5Gb3JVbm1hdGNoZWRUZXh0OiB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxLFxuXHR3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50OiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEsXG5cdHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQ6IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMSxcblx0d2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50OiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMSxcblx0d2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0OiB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMSxcblx0cmVzdG9yZUNvbnRyb2xsZWRTdGF0ZTogcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZVxufSk7XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyQxID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGNoaWxkVGFnID09IG51bGwsICd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnKTtcbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW52YWxpZFBhcmVudE9yQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcbiAgICBpZiAoIWludmFsaWRQYXJlbnRPckFuY2VzdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuY2VzdG9yVGFnID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO1xuICAgIHZhciBhZGRlbmR1bSA9IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNigpO1xuXG4gICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgYWRkZW5kdW07XG4gICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICB2YXIgd2hpdGVzcGFjZUluZm8gPSAnJztcbiAgICBpZiAoY2hpbGRUYWcgPT09ICcjdGV4dCcpIHtcbiAgICAgIGlmICgvXFxTLy50ZXN0KGNoaWxkVGV4dCkpIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdXaGl0ZXNwYWNlIHRleHQgbm9kZXMnO1xuICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9IFwiIE1ha2Ugc3VyZSB5b3UgZG9uJ3QgaGF2ZSBhbnkgZXh0cmEgd2hpdGVzcGFjZSBiZXR3ZWVuIHRhZ3Mgb24gXCIgKyAnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICB9XG5cbiAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICB9XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzJXMlcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgd2hpdGVzcGFjZUluZm8sIGluZm8sIGFkZGVuZHVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVE9ETzogdHVybiB0aGlzIGludG8gYSBuYW1lZCBleHBvcnRcbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvJDE7XG5cbiAgLy8gRm9yIHRlc3RpbmdcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyQxID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbnZhciBjcmVhdGVUZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlJDE7XG52YXIgc2V0SW5pdGlhbFByb3BlcnRpZXMgPSBzZXRJbml0aWFsUHJvcGVydGllcyQxO1xudmFyIGRpZmZQcm9wZXJ0aWVzID0gZGlmZlByb3BlcnRpZXMkMTtcbnZhciB1cGRhdGVQcm9wZXJ0aWVzID0gdXBkYXRlUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMgPSBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkVGV4dCA9IGRpZmZIeWRyYXRlZFRleHQkMTtcbnZhciB3YXJuRm9yVW5tYXRjaGVkVGV4dCA9IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxO1xudmFyIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCA9IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCA9IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxO1xudmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSB2YWxpZGF0ZURPTU5lc3RpbmckMS51cGRhdGVkQW5jZXN0b3JJbmZvO1xudmFyIHByZWNhY2hlRmliZXJOb2RlID0gcHJlY2FjaGVGaWJlck5vZGUkMTtcbnZhciB1cGRhdGVGaWJlclByb3BzID0gdXBkYXRlRmliZXJQcm9wcyQxO1xuXG5cbntcbiAgdmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG4gIGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nIHx8IE1hcC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgTWFwLnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQgIT09ICdmdW5jdGlvbicgfHwgU2V0LnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmNsZWFyICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZGVwZW5kcyBvbiBNYXAgYW5kIFNldCBidWlsdC1pbiB0eXBlcy4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzJyk7XG4gIH1cbn1cblxuaW5qZWN0aW9uJDMuaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudChSZWFjdERPTUZpYmVyQ29tcG9uZW50KTtcblxudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuICEhcHJvcHMuYXV0b0ZvY3VzO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIERPTVJlbmRlcmVyID0gcmVhY3RSZWNvbmNpbGVyKHtcbiAgZ2V0Um9vdEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gICAgdmFyIG5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICB2YXIgbm9kZVR5cGUgPSByb290Q29udGFpbmVySW5zdGFuY2Uubm9kZVR5cGU7XG4gICAgc3dpdGNoIChub2RlVHlwZSkge1xuICAgICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAgICB7XG4gICAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgbmFtZXNwYWNlID0gcm9vdCA/IHJvb3QubmFtZXNwYWNlVVJJIDogZ2V0Q2hpbGROYW1lc3BhY2UobnVsbCwgJycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gY29udGFpbmVyLm5hbWVzcGFjZVVSSSB8fCBudWxsO1xuICAgICAgICAgIHR5cGUgPSBjb250YWluZXIudGFnTmFtZTtcbiAgICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIHZhciB2YWxpZGF0ZWRUYWcgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgX2FuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdmFsaWRhdGVkVGFnLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcbiAgfSxcbiAgZ2V0Q2hpbGRIb3N0Q29udGV4dDogZnVuY3Rpb24gKHBhcmVudEhvc3RDb250ZXh0LCB0eXBlKSB7XG4gICAge1xuICAgICAgdmFyIHBhcmVudEhvc3RDb250ZXh0RGV2ID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgICB2YXIgX25hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudEhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICB2YXIgX2FuY2VzdG9ySW5mbzIgPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICByZXR1cm4geyBuYW1lc3BhY2U6IF9uYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbzIgfTtcbiAgICB9XG4gICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHJldHVybiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpO1xuICB9LFxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9LFxuICBwcmVwYXJlRm9yQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICAgIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKTtcbiAgICBzZXRFbmFibGVkKGZhbHNlKTtcbiAgfSxcbiAgcmVzZXRBZnRlckNvbW1pdDogZnVuY3Rpb24gKCkge1xuICAgIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24pO1xuICAgIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbiAgICBzZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO1xuICAgIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xuICB9LFxuICBjcmVhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICB7XG4gICAgICAvLyBUT0RPOiB0YWtlIG5hbWVzcGFjZSBpbnRvIGFjY291bnQgd2hlbiB2YWxpZGF0aW5nLlxuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMSh0eXBlLCBudWxsLCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgICAgfVxuICAgICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICAgIH1cbiAgICB2YXIgZG9tRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgcGFyZW50TmFtZXNwYWNlKTtcbiAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICByZXR1cm4gZG9tRWxlbWVudDtcbiAgfSxcbiAgYXBwZW5kSW5pdGlhbENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9LFxuICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICByZXR1cm4gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gIH0sXG4gIHByZXBhcmVVcGRhdGU6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgICB7XG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIGlmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gIT09IHR5cGVvZiBvbGRQcm9wcy5jaGlsZHJlbiAmJiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICB9LFxuICBzaG91bGRTZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0YXJlYScgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT09IG51bGwgJiYgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiAhIXByb3BzLmhpZGRlbjtcbiAgfSxcbiAgY3JlYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgdGV4dCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICB9XG4gICAgdmFyIHRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0Tm9kZSk7XG4gICAgcmV0dXJuIHRleHROb2RlO1xuICB9LFxuXG5cbiAgbm93OiBub3csXG5cbiAgbXV0YXRpb246IHtcbiAgICBjb21taXRNb3VudDogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBkb21FbGVtZW50LmZvY3VzKCk7XG4gICAgfSxcbiAgICBjb21taXRVcGRhdGU6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvcHMgaGFuZGxlIHNvIHRoYXQgd2Uga25vdyB3aGljaCBwcm9wcyBhcmUgdGhlIG9uZXMgd2l0aFxuICAgICAgLy8gd2l0aCBjdXJyZW50IGV2ZW50IGhhbmRsZXJzLlxuICAgICAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7XG4gICAgICAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgRE9NIG5vZGUuXG4gICAgICB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgfSxcbiAgICByZXNldFRleHRDb250ZW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCkge1xuICAgICAgZG9tRWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICAgIH0sXG4gICAgY29tbWl0VGV4dFVwZGF0ZTogZnVuY3Rpb24gKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH0sXG4gICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgfSxcbiAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGh5ZHJhdGlvbjoge1xuICAgIGNhbkh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgdHlwZS50b0xvd2VyQ2FzZSgpICE9PSBpbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyBoYXMgbm93IGJlZW4gcmVmaW5lZCB0byBhbiBlbGVtZW50IG5vZGUuXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfSxcbiAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0ZXh0ID09PSAnJyB8fCBpbnN0YW5jZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIC8vIEVtcHR5IHN0cmluZ3MgYXJlIG5vdCBwYXJzZWQgYnkgSFRNTCBzbyB0aGVyZSB3b24ndCBiZSBhIGNvcnJlY3QgbWF0Y2ggaGVyZS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIGhhcyBub3cgYmVlbiByZWZpbmVkIHRvIGEgdGV4dCBub2RlLlxuICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH0sXG4gICAgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nOiBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICAgIHZhciBub2RlID0gaW5zdGFuY2UubmV4dFNpYmxpbmc7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5vZGUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5vZGUubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBub2RlID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSkge1xuICAgICAgdmFyIG5leHQgPSBwYXJlbnRJbnN0YW5jZS5maXJzdENoaWxkO1xuICAgICAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgICAgIHdoaWxlIChuZXh0ICYmIG5leHQubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBuZXh0Lm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV4dDtcbiAgICB9LFxuICAgIGh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgaW5zdGFuY2UpO1xuICAgICAgLy8gVE9ETzogUG9zc2libHkgZGVmZXIgdGhpcyB1bnRpbCB0aGUgY29tbWl0IHBoYXNlIHdoZXJlIGFsbCB0aGUgZXZlbnRzXG4gICAgICAvLyBnZXQgYXR0YWNoZWQuXG4gICAgICB1cGRhdGVGaWJlclByb3BzKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgICB2YXIgcGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCBwYXJlbnROYW1lc3BhY2UsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgfSxcbiAgICBoeWRyYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAodGV4dEluc3RhbmNlLCB0ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0SW5zdGFuY2UpO1xuICAgICAgcmV0dXJuIGRpZmZIeWRyYXRlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICB9LFxuICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RIeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudENvbnRhaW5lciwgdHlwZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHRleHQpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudENvbnRhaW5lciwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2s6IHJJQyxcbiAgY2FuY2VsRGVmZXJyZWRDYWxsYmFjazogY0lDLFxuXG4gIHVzZVN5bmNTY2hlZHVsaW5nOiAhZW5hYmxlQXN5bmNTY2hlZHVsaW5nQnlEZWZhdWx0SW5SZWFjdERPTVxufSk7XG5cbmluamVjdGlvbiQ0LmluamVjdEZpYmVyQmF0Y2hlZFVwZGF0ZXMoRE9NUmVuZGVyZXIuYmF0Y2hlZFVwZGF0ZXMpO1xuXG52YXIgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgY2hpbGRyZW4sIGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlLCBjYWxsYmFjaykge1xuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcblxuICB7XG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyICYmIGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgaG9zdEluc3RhbmNlID0gRE9NUmVuZGVyZXIuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIuY3VycmVudCk7XG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIHdhcm5pbmcoaG9zdEluc3RhbmNlLnBhcmVudE5vZGUgPT09IGNvbnRhaW5lciwgJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoaXMgJyArICdjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyAnUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSB0byBlbXB0eSBhIGNvbnRhaW5lci4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCA9ICEhY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKHJvb3RFbCAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKSk7XG5cbiAgICB3YXJuaW5nKCFoYXNOb25Sb290UmVhY3RDaGlsZCB8fCBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0LCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKTtcblxuICAgIHdhcm5pbmcoY29udGFpbmVyLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJywgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICBpZiAoIXJvb3QpIHtcbiAgICB2YXIgc2hvdWxkSHlkcmF0ZSA9IGZvcmNlSHlkcmF0ZSB8fCBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKTtcbiAgICAvLyBGaXJzdCBjbGVhciBhbnkgZXhpc3RpbmcgY29udGVudC5cbiAgICBpZiAoIXNob3VsZEh5ZHJhdGUpIHtcbiAgICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgICAgIHZhciByb290U2libGluZyA9IHZvaWQgMDtcbiAgICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghd2FybmVkICYmIHJvb3RTaWJsaW5nLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdFNpYmxpbmcuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKSB7XG4gICAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHJvb3RTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgaWYgKHNob3VsZEh5ZHJhdGUgJiYgIWZvcmNlSHlkcmF0ZSAmJiAhd2FybmVkQWJvdXRIeWRyYXRlQVBJKSB7XG4gICAgICAgIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IHRydWU7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAncmVuZGVyKCk6IENhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgdG8gaHlkcmF0ZSBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwICcgKyAnd2lsbCBzdG9wIHdvcmtpbmcgaW4gUmVhY3QgdjE3LiBSZXBsYWNlIHRoZSBSZWFjdERPTS5yZW5kZXIoKSBjYWxsICcgKyAnd2l0aCBSZWFjdERPTS5oeWRyYXRlKCkgaWYgeW91IHdhbnQgUmVhY3QgdG8gYXR0YWNoIHRvIHRoZSBzZXJ2ZXIgSFRNTC4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5ld1Jvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBzaG91bGRIeWRyYXRlKTtcbiAgICByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBuZXdSb290O1xuICAgIC8vIEluaXRpYWwgbW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuICAgIERPTVJlbmRlcmVyLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCBuZXdSb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBET01SZW5kZXJlci5nZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG4gIC8vIFRPRE86IHBhc3MgUmVhY3RET00gcG9ydGFsIGltcGxlbWVudGF0aW9uIGFzIHRoaXJkIGFyZ3VtZW50XG4gIHJldHVybiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVyLCBudWxsLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBSZWFjdFJvb3QoY29udGFpbmVyLCBoeWRyYXRlKSB7XG4gIHZhciByb290ID0gRE9NUmVuZGVyZXIuY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lciwgaHlkcmF0ZSk7XG4gIHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lciA9IHJvb3Q7XG59XG5SZWFjdFJvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJvb3QgPSB0aGlzLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblJlYWN0Um9vdC5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKG51bGwsIHJvb3QsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cbnZhciBSZWFjdERPTSA9IHtcbiAgY3JlYXRlUG9ydGFsOiBjcmVhdGVQb3J0YWwsXG5cbiAgZmluZERPTU5vZGU6IGZ1bmN0aW9uIChjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgICB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB3YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXI7XG4gICAgICAgIHdhcm5pbmcod2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUob3duZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgICBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBpbnN0ID0gZ2V0KGNvbXBvbmVudE9yRWxlbWVudCk7XG4gICAgaWYgKGluc3QpIHtcbiAgICAgIHJldHVybiBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlKGluc3QpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IGFwcGVhcnMgdG8gYmUgbmVpdGhlciBSZWFjdENvbXBvbmVudCBub3IgRE9NTm9kZS4gS2V5czogJXMnLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKTtcbiAgICB9XG4gIH0sXG4gIGh5ZHJhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogdGhyb3cgb3Igd2FybiBpZiB3ZSBjb3VsZG4ndCBoeWRyYXRlP1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBlbGVtZW50LCBjb250YWluZXIsIHRydWUsIGNhbGxiYWNrKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBlbGVtZW50LCBjb250YWluZXIsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgaGFzKHBhcmVudENvbXBvbmVudCkpID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcblxuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcikge1xuICAgICAge1xuICAgICAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciByZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPSByb290RWwgJiYgIWdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpO1xuICAgICAgICB3YXJuaW5nKCFyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QsIFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVubW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuICAgICAgRE9NUmVuZGVyZXIudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG51bGwsIGNvbnRhaW5lciwgZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvLyBJZiB5b3UgY2FsbCB1bm1vdW50Q29tcG9uZW50QXROb2RlIHR3aWNlIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHlvdSdsbFxuICAgICAgLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICB2YXIgX3Jvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShfcm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShfcm9vdEVsKSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSAmJiBpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lci5wYXJlbnROb2RlKSAmJiAhIWNvbnRhaW5lci5wYXJlbnROb2RlLl9yZWFjdFJvb3RDb250YWluZXI7XG5cbiAgICAgICAgd2FybmluZyghaGFzTm9uUm9vdFJlYWN0Q2hpbGQsIFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cblxuICAvLyBUZW1wb3JhcnkgYWxpYXMgc2luY2Ugd2UgYWxyZWFkeSBzaGlwcGVkIFJlYWN0IDE2IFJDIHdpdGggaXQuXG4gIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy5cbiAgdW5zdGFibGVfY3JlYXRlUG9ydGFsOiBjcmVhdGVQb3J0YWwsXG5cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gIHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlczogRE9NUmVuZGVyZXIuZGVmZXJyZWRVcGRhdGVzLFxuXG4gIGZsdXNoU3luYzogRE9NUmVuZGVyZXIuZmx1c2hTeW5jLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgLy8gRm9yIFRhcEV2ZW50UGx1Z2luIHdoaWNoIGlzIHBvcHVsYXIgaW4gb3BlbiBzb3VyY2VcbiAgICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIsXG4gICAgLy8gVXNlZCBieSB0ZXN0LXV0aWxzXG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnRQbHVnaW5SZWdpc3RyeSxcbiAgICBFdmVudFByb3BhZ2F0b3JzOiBFdmVudFByb3BhZ2F0b3JzLFxuICAgIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudDogUmVhY3RDb250cm9sbGVkQ29tcG9uZW50LFxuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZTogUmVhY3RET01Db21wb25lbnRUcmVlLFxuICAgIFJlYWN0RE9NRXZlbnRMaXN0ZW5lcjogUmVhY3RET01FdmVudExpc3RlbmVyXG4gIH1cbn07XG5cbmlmIChlbmFibGVDcmVhdGVSb290KSB7XG4gIFJlYWN0RE9NLmNyZWF0ZVJvb3QgPSBmdW5jdGlvbiBjcmVhdGVSb290KGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIHZhciBoeWRyYXRlID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0ZSA9PT0gdHJ1ZTtcbiAgICByZXR1cm4gbmV3IFJlYWN0Um9vdChjb250YWluZXIsIGh5ZHJhdGUpO1xuICB9O1xufVxuXG52YXIgZm91bmREZXZUb29scyA9IERPTVJlbmRlcmVyLmluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgYnVuZGxlVHlwZTogMSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuICByZW5kZXJlclBhY2thZ2VOYW1lOiAncmVhY3QtZG9tJ1xufSk7XG5cbntcbiAgaWYgKCFmb3VuZERldlRvb2xzICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgIHZhciBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgIC8vIERvbid0IHdhcm4gaW4gZXhvdGljIGNhc2VzIGxpa2UgY2hyb21lLWV4dGVuc2lvbjovLy5cbiAgICAgIGlmICgvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCclY0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnICsgKHByb3RvY29sID09PSAnZmlsZTonID8gJ1xcbllvdSBtaWdodCBuZWVkIHRvIHVzZSBhIGxvY2FsIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGZpbGU6Ly8pOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMtZmFxJyA6ICcnKSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbnZhciBSZWFjdERPTSQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0RE9NXG59KTtcblxudmFyIFJlYWN0RE9NJDMgPSAoIFJlYWN0RE9NJDIgJiYgUmVhY3RET00gKSB8fCBSZWFjdERPTSQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdERvbSA9IFJlYWN0RE9NJDNbJ2RlZmF1bHQnXSA/IFJlYWN0RE9NJDNbJ2RlZmF1bHQnXSA6IFJlYWN0RE9NJDM7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3REb207XG4gIH0pKCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwiaW1wb3J0IFdlYkNvbXBvbmVudHMgZnJvbSAnQHdlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzL3dlYmNvbXBvbmVudHMtbGl0ZS5qcyc7XG5cbnZhciBnZXRCcmVha3BvaW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUod2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKSwgJzpiZWZvcmUnKS5nZXRQcm9wZXJ0eVZhbHVlKCdjb250ZW50JykucmVwbGFjZSgvXCIvZywgJycpO1xufTtcblxuZnVuY3Rpb24gYnJlYWtwb2ludChicmVha3BvaW50LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoZ2V0QnJlYWtwb2ludCgpID09PSBicmVha3BvaW50KSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICAkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRCcmVha3BvaW50KCkgPT09IGJyZWFrcG9pbnQpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0QnJlYWtwb2ludCgpID09PSBicmVha3BvaW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2t0b3AoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGJyZWFrcG9pbnQoXCJkZXNrdG9wXCIsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gdGFibGV0KGNhbGxiYWNrKSB7XG4gIHJldHVybiBicmVha3BvaW50KFwidGFibGV0XCIsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcGhvbmUoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGJyZWFrcG9pbnQoXCJwaG9uZVwiLCBjYWxsYmFjayk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9nbG9iYWwvY2xpZW50LmpzIiwiKGZ1bmN0aW9uKCl7LypcblxuIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbid1c2Ugc3RyaWN0Jzt2YXIgcCxxPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdz09PXRoaXM/dGhpczpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsJiZudWxsIT1nbG9iYWw/Z2xvYmFsOnRoaXMsYmE9XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnRpZXM/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKGEsYixjKXthIT1BcnJheS5wcm90b3R5cGUmJmEhPU9iamVjdC5wcm90b3R5cGUmJihhW2JdPWMudmFsdWUpfTtmdW5jdGlvbiBjYSgpe2NhPWZ1bmN0aW9uKCl7fTtxLlN5bWJvbHx8KHEuU3ltYm9sPWRhKX12YXIgZGE9ZnVuY3Rpb24oKXt2YXIgYT0wO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm5cImpzY29tcF9zeW1ib2xfXCIrKGJ8fFwiXCIpK2ErK319KCk7XG5mdW5jdGlvbiBlYSgpe2NhKCk7dmFyIGE9cS5TeW1ib2wuaXRlcmF0b3I7YXx8KGE9cS5TeW1ib2wuaXRlcmF0b3I9cS5TeW1ib2woXCJpdGVyYXRvclwiKSk7XCJmdW5jdGlvblwiIT10eXBlb2YgQXJyYXkucHJvdG90eXBlW2FdJiZiYShBcnJheS5wcm90b3R5cGUsYSx7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGZhKHRoaXMpfX0pO2VhPWZ1bmN0aW9uKCl7fX1mdW5jdGlvbiBmYShhKXt2YXIgYj0wO3JldHVybiBoYShmdW5jdGlvbigpe3JldHVybiBiPGEubGVuZ3RoP3tkb25lOiExLHZhbHVlOmFbYisrXX06e2RvbmU6ITB9fSl9ZnVuY3Rpb24gaGEoYSl7ZWEoKTthPXtuZXh0OmF9O2FbcS5TeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3JldHVybiBhfWZ1bmN0aW9uIGlhKGEpe2VhKCk7dmFyIGI9YVtTeW1ib2wuaXRlcmF0b3JdO3JldHVybiBiP2IuY2FsbChhKTpmYShhKX1cbmZ1bmN0aW9uIGphKGEpe2Zvcih2YXIgYixjPVtdOyEoYj1hLm5leHQoKSkuZG9uZTspYy5wdXNoKGIudmFsdWUpO3JldHVybiBjfVxuKGZ1bmN0aW9uKCl7aWYoIWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTthLmluaXRFdmVudChcImZvb1wiLCEwLCEwKTthLnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIGEuZGVmYXVsdFByZXZlbnRlZH0oKSl7dmFyIGE9RXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0O0V2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdD1mdW5jdGlvbigpe3RoaXMuY2FuY2VsYWJsZSYmKGEuY2FsbCh0aGlzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImRlZmF1bHRQcmV2ZW50ZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuITB9LGNvbmZpZ3VyYWJsZTohMH0pKX19dmFyIGI9L1RyaWRlbnQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7aWYoIXdpbmRvdy5DdXN0b21FdmVudHx8YiYmXCJmdW5jdGlvblwiIT09dHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCl3aW5kb3cuQ3VzdG9tRXZlbnQ9ZnVuY3Rpb24oYSxiKXtiPWJ8fHt9O3ZhciBjPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG5jLmluaXRDdXN0b21FdmVudChhLCEhYi5idWJibGVzLCEhYi5jYW5jZWxhYmxlLGIuZGV0YWlsKTtyZXR1cm4gY30sd2luZG93LkN1c3RvbUV2ZW50LnByb3RvdHlwZT13aW5kb3cuRXZlbnQucHJvdG90eXBlO2lmKCF3aW5kb3cuRXZlbnR8fGImJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB3aW5kb3cuRXZlbnQpe3ZhciBjPXdpbmRvdy5FdmVudDt3aW5kb3cuRXZlbnQ9ZnVuY3Rpb24oYSxiKXtiPWJ8fHt9O3ZhciBjPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7Yy5pbml0RXZlbnQoYSwhIWIuYnViYmxlcywhIWIuY2FuY2VsYWJsZSk7cmV0dXJuIGN9O2lmKGMpZm9yKHZhciBkIGluIGMpd2luZG93LkV2ZW50W2RdPWNbZF07d2luZG93LkV2ZW50LnByb3RvdHlwZT1jLnByb3RvdHlwZX1pZighd2luZG93Lk1vdXNlRXZlbnR8fGImJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB3aW5kb3cuTW91c2VFdmVudCl7Yj13aW5kb3cuTW91c2VFdmVudDt3aW5kb3cuTW91c2VFdmVudD1mdW5jdGlvbihhLFxuYil7Yj1ifHx7fTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7Yy5pbml0TW91c2VFdmVudChhLCEhYi5idWJibGVzLCEhYi5jYW5jZWxhYmxlLGIudmlld3x8d2luZG93LGIuZGV0YWlsLGIuc2NyZWVuWCxiLnNjcmVlblksYi5jbGllbnRYLGIuY2xpZW50WSxiLmN0cmxLZXksYi5hbHRLZXksYi5zaGlmdEtleSxiLm1ldGFLZXksYi5idXR0b24sYi5yZWxhdGVkVGFyZ2V0KTtyZXR1cm4gY307aWYoYilmb3IoZCBpbiBiKXdpbmRvdy5Nb3VzZUV2ZW50W2RdPWJbZF07d2luZG93Lk1vdXNlRXZlbnQucHJvdG90eXBlPWIucHJvdG90eXBlfUFycmF5LmZyb218fChBcnJheS5mcm9tPWZ1bmN0aW9uKGEpe3JldHVybltdLnNsaWNlLmNhbGwoYSl9KTtPYmplY3QuYXNzaWdufHwoT2JqZWN0LmFzc2lnbj1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxkPTAsZTtkPGMubGVuZ3RoO2QrKylpZihlPWNbZF0pZm9yKHZhciBmPVxuYSxtPWUsbj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtKSx3PTA7dzxuLmxlbmd0aDt3KyspZT1uW3ddLGZbZV09bVtlXTtyZXR1cm4gYX0pfSkod2luZG93LldlYkNvbXBvbmVudHMpOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gYihhLGIpe3N3aXRjaChhLm5vZGVUeXBlKXtjYXNlIE5vZGUuRE9DVU1FTlRfTk9ERTpyZXR1cm4gdy5jYWxsKGEsYik7Y2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6cmV0dXJuIEkuY2FsbChhLGIpO2RlZmF1bHQ6cmV0dXJuIG4uY2FsbChhLGIpfX12YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQsZD0hKGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKS5jbG9uZU5vZGUoKWluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCksZT0hMTsvVHJpZGVudC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYil7aWYoYSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpZm9yKHZhciBkO2Q9YS5maXJzdENoaWxkOyljLmNhbGwodGhpcyxkLGIpO2Vsc2UgYy5jYWxsKHRoaXMsYSxiKTtyZXR1cm4gYX1lPSEwO3ZhciBiPU5vZGUucHJvdG90eXBlLmNsb25lTm9kZTtcbk5vZGUucHJvdG90eXBlLmNsb25lTm9kZT1mdW5jdGlvbihhKXthPWIuY2FsbCh0aGlzLGEpO3RoaXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50JiYoYS5fX3Byb3RvX189RG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUpO3JldHVybiBhfTtEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsPUhUTUxFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsO0RvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3I9SFRNTEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3I7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUse25vZGVUeXBlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFfSxjb25maWd1cmFibGU6ITB9LGxvY2FsTmFtZTp7Z2V0OmZ1bmN0aW9uKCl7fSxjb25maWd1cmFibGU6ITB9LG5vZGVOYW1lOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIiNkb2N1bWVudC1mcmFnbWVudFwifSxcbmNvbmZpZ3VyYWJsZTohMH19KTt2YXIgYz1Ob2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmU7Tm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlPWE7dmFyIGQ9Tm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQ7Tm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQ9ZnVuY3Rpb24oYil7YiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQ/YS5jYWxsKHRoaXMsYixudWxsKTpkLmNhbGwodGhpcyxiKTtyZXR1cm4gYn07dmFyIGY9Tm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQsaD1Ob2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQ7Tm9kZS5wcm90b3R5cGUucmVwbGFjZUNoaWxkPWZ1bmN0aW9uKGIsYyl7YiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQ/KGEuY2FsbCh0aGlzLGIsYyksZi5jYWxsKHRoaXMsYykpOmguY2FsbCh0aGlzLGIsYyk7cmV0dXJuIGN9O0RvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVEb2N1bWVudEZyYWdtZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jcmVhdGVFbGVtZW50KFwiZGZcIik7XG5hLl9fcHJvdG9fXz1Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZTtyZXR1cm4gYX07dmFyIGc9RG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGU7RG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGU9ZnVuY3Rpb24oYSxiKXtiPWcuY2FsbCh0aGlzLGEsYnx8ITEpO2EgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50JiYoYi5fX3Byb3RvX189RG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUpO3JldHVybiBifX0oKTt2YXIgZj1Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGUsaD1Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCxnPURvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlLGs9Tm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQsbD1Ob2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCxtPU5vZGUucHJvdG90eXBlLnJlcGxhY2VDaGlsZCxuPUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwsdz1Eb2N1bWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCxJPURvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwsXG5aYT1mdW5jdGlvbigpe2lmKCFjKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIiksYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7Yi5jb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO2EuY29udGVudC5hcHBlbmRDaGlsZChiKTthPWEuY2xvbmVOb2RlKCEwKTtyZXR1cm4gMD09PWEuY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aHx8MD09PWEuY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGh8fGR9fSgpO2lmKGMpe3ZhciB0PWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcInRlbXBsYXRlXCIpLG5hPSEwLGFhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTthYS50ZXh0Q29udGVudD1cInRlbXBsYXRle2Rpc3BsYXk6bm9uZTt9XCI7dmFyIFQ9ZG9jdW1lbnQuaGVhZDtULmluc2VydEJlZm9yZShhYSxULmZpcnN0RWxlbWVudENoaWxkKTtcbmEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoSFRNTEVsZW1lbnQucHJvdG90eXBlKTt2YXIgVT0hZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5oYXNPd25Qcm9wZXJ0eShcImlubmVySFRNTFwiKTthLkQ9ZnVuY3Rpb24oYil7aWYoIWIuY29udGVudCl7Yi5jb250ZW50PXQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2Zvcih2YXIgYztjPWIuZmlyc3RDaGlsZDspbC5jYWxsKGIuY29udGVudCxjKTtpZihVKWIuX19wcm90b19fPWEucHJvdG90eXBlO2Vsc2UgaWYoYi5jbG9uZU5vZGU9ZnVuY3Rpb24oYil7cmV0dXJuIGEuYSh0aGlzLGIpfSxuYSl0cnl7bmMoYiksb2MoYil9Y2F0Y2goTmcpe25hPSExfWEuSihiLmNvbnRlbnQpfX07dmFyIG5jPWZ1bmN0aW9uKGIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiaW5uZXJIVE1MXCIse2dldDpmdW5jdGlvbigpe2Zvcih2YXIgYT1cIlwiLGI9dGhpcy5jb250ZW50LmZpcnN0Q2hpbGQ7YjtiPWIubmV4dFNpYmxpbmcpYSs9Yi5vdXRlckhUTUx8fFxuYi5kYXRhLnJlcGxhY2UoR2UscGMpO3JldHVybiBhfSxzZXQ6ZnVuY3Rpb24oYil7dC5ib2R5LmlubmVySFRNTD1iO2ZvcihhLkoodCk7dGhpcy5jb250ZW50LmZpcnN0Q2hpbGQ7KWsuY2FsbCh0aGlzLmNvbnRlbnQsdGhpcy5jb250ZW50LmZpcnN0Q2hpbGQpO2Zvcig7dC5ib2R5LmZpcnN0Q2hpbGQ7KWwuY2FsbCh0aGlzLmNvbnRlbnQsdC5ib2R5LmZpcnN0Q2hpbGQpfSxjb25maWd1cmFibGU6ITB9KX0sb2M9ZnVuY3Rpb24oYSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJvdXRlckhUTUxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI8dGVtcGxhdGU+XCIrdGhpcy5pbm5lckhUTUwrXCI8L3RlbXBsYXRlPlwifSxzZXQ6ZnVuY3Rpb24oYSl7aWYodGhpcy5wYXJlbnROb2RlKXt0LmJvZHkuaW5uZXJIVE1MPWE7Zm9yKGE9dGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTt0LmJvZHkuZmlyc3RDaGlsZDspbC5jYWxsKGEsdC5ib2R5LmZpcnN0Q2hpbGQpO20uY2FsbCh0aGlzLnBhcmVudE5vZGUsXG5hLHRoaXMpfWVsc2UgdGhyb3cgRXJyb3IoXCJGYWlsZWQgdG8gc2V0IHRoZSAnb3V0ZXJIVE1MJyBwcm9wZXJ0eSBvbiAnRWxlbWVudCc6IFRoaXMgZWxlbWVudCBoYXMgbm8gcGFyZW50IG5vZGUuXCIpO30sY29uZmlndXJhYmxlOiEwfSl9O25jKGEucHJvdG90eXBlKTtvYyhhLnByb3RvdHlwZSk7YS5KPWZ1bmN0aW9uKGMpe2M9YihjLFwidGVtcGxhdGVcIik7Zm9yKHZhciBkPTAsZT1jLmxlbmd0aCxmO2Q8ZSYmKGY9Y1tkXSk7ZCsrKWEuRChmKX07ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixmdW5jdGlvbigpe2EuSihkb2N1bWVudCl9KTtEb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudD1mdW5jdGlvbigpe3ZhciBiPWguYXBwbHkodGhpcyxhcmd1bWVudHMpO1widGVtcGxhdGVcIj09PWIubG9jYWxOYW1lJiZhLkQoYik7cmV0dXJuIGJ9O3ZhciBHZT0vWyZcXHUwMEEwPD5dL2cscGM9ZnVuY3Rpb24oYSl7c3dpdGNoKGEpe2Nhc2UgXCImXCI6cmV0dXJuXCImYW1wO1wiO1xuY2FzZSBcIjxcIjpyZXR1cm5cIiZsdDtcIjtjYXNlIFwiPlwiOnJldHVyblwiJmd0O1wiO2Nhc2UgXCJcXHUwMGEwXCI6cmV0dXJuXCImbmJzcDtcIn19fWlmKGN8fFphKXthLmE9ZnVuY3Rpb24oYSxiKXt2YXIgYz1mLmNhbGwoYSwhMSk7dGhpcy5EJiZ0aGlzLkQoYyk7YiYmKGwuY2FsbChjLmNvbnRlbnQsZi5jYWxsKGEuY29udGVudCwhMCkpLCRhKGMuY29udGVudCxhLmNvbnRlbnQpKTtyZXR1cm4gY307dmFyICRhPWZ1bmN0aW9uKGMsZCl7aWYoZC5xdWVyeVNlbGVjdG9yQWxsJiYoZD1iKGQsXCJ0ZW1wbGF0ZVwiKSwwIT09ZC5sZW5ndGgpKXtjPWIoYyxcInRlbXBsYXRlXCIpO2Zvcih2YXIgZT0wLGY9Yy5sZW5ndGgsaCxnO2U8ZjtlKyspZz1kW2VdLGg9Y1tlXSxhJiZhLkQmJmEuRChnKSxtLmNhbGwoaC5wYXJlbnROb2RlLEhlLmNhbGwoZywhMCksaCl9fSxIZT1Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGU9ZnVuY3Rpb24oYil7aWYoIWUmJmQmJnRoaXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KWlmKGIpdmFyIGM9XG5JZS5jYWxsKHRoaXMub3duZXJEb2N1bWVudCx0aGlzLCEwKTtlbHNlIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2Vsc2UgdGhpcy5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZcInRlbXBsYXRlXCI9PT10aGlzLmxvY2FsTmFtZT9jPWEuYSh0aGlzLGIpOmM9Zi5jYWxsKHRoaXMsYik7YiYmJGEoYyx0aGlzKTtyZXR1cm4gY30sSWU9RG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGU9ZnVuY3Rpb24oYixjKXtjPWN8fCExO2lmKFwidGVtcGxhdGVcIj09PWIubG9jYWxOYW1lKXJldHVybiBhLmEoYixjKTt2YXIgZD1nLmNhbGwodGhpcyxiLGMpO2MmJiRhKGQsYik7cmV0dXJuIGR9fWMmJih3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudD1hKX0pKCk7dmFyIGthO0FycmF5LmlzQXJyYXk/a2E9QXJyYXkuaXNBcnJheTprYT1mdW5jdGlvbihhKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSl9O3ZhciBsYT1rYTt2YXIgbWE9MCxvYSxwYT1cInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdz93aW5kb3c6dm9pZCAwLHFhPXBhfHx7fSxyYT1xYS5NdXRhdGlvbk9ic2VydmVyfHxxYS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLHNhPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgVWludDhDbGFtcGVkQXJyYXkmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgaW1wb3J0U2NyaXB0cyYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBNZXNzYWdlQ2hhbm5lbDtmdW5jdGlvbiB0YSgpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2Ygb2E/ZnVuY3Rpb24oKXtvYSh1YSl9OnZhKCl9ZnVuY3Rpb24gd2EoKXt2YXIgYT0wLGI9bmV3IHJhKHVhKSxjPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO2Iub2JzZXJ2ZShjLHtjaGFyYWN0ZXJEYXRhOiEwfSk7cmV0dXJuIGZ1bmN0aW9uKCl7Yy5kYXRhPWE9KythJTJ9fVxuZnVuY3Rpb24geGEoKXt2YXIgYT1uZXcgTWVzc2FnZUNoYW5uZWw7YS5wb3J0MS5vbm1lc3NhZ2U9dWE7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEucG9ydDIucG9zdE1lc3NhZ2UoMCl9fWZ1bmN0aW9uIHZhKCl7dmFyIGE9c2V0VGltZW91dDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYSh1YSwxKX19dmFyIHlhPUFycmF5KDFFMyk7ZnVuY3Rpb24gdWEoKXtmb3IodmFyIGE9MDthPG1hO2ErPTIpKDAseWFbYV0pKHlhW2ErMV0pLHlhW2FdPXZvaWQgMCx5YVthKzFdPXZvaWQgMDttYT0wfXZhciB6YSxBYTtcbmlmKFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygc2VsZiYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBwcm9jZXNzJiZcIltvYmplY3QgcHJvY2Vzc11cIj09PXt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykpQWE9ZnVuY3Rpb24oKXtyZXR1cm4gcHJvY2Vzcy5qYih1YSl9O2Vsc2V7dmFyIEJhO2lmKHJhKUJhPXdhKCk7ZWxzZXt2YXIgQ2E7aWYoc2EpQ2E9eGEoKTtlbHNle3ZhciBEYTtpZih2b2lkIDA9PT1wYSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHJlcXVpcmUpdHJ5e3ZhciBFYT1yZXF1aXJlKFwidmVydHhcIik7b2E9RWEubGJ8fEVhLmtiO0RhPXRhKCl9Y2F0Y2goYSl7RGE9dmEoKX1lbHNlIERhPXZhKCk7Q2E9RGF9QmE9Q2F9QWE9QmF9emE9QWE7ZnVuY3Rpb24gRmEoYSxiKXt5YVttYV09YTt5YVttYSsxXT1iO21hKz0yOzI9PT1tYSYmemEoKX07ZnVuY3Rpb24gR2EoYSxiKXt2YXIgYz10aGlzLGQ9bmV3IHRoaXMuY29uc3RydWN0b3IoSGEpO3ZvaWQgMD09PWRbSWFdJiZKYShkKTt2YXIgZT1jLmc7aWYoZSl7dmFyIGY9YXJndW1lbnRzW2UtMV07RmEoZnVuY3Rpb24oKXtyZXR1cm4gS2EoZSxkLGYsYy5mKX0pfWVsc2UgTGEoYyxkLGEsYik7cmV0dXJuIGR9O2Z1bmN0aW9uIE1hKGEpe2lmKGEmJlwib2JqZWN0XCI9PT10eXBlb2YgYSYmYS5jb25zdHJ1Y3Rvcj09PXRoaXMpcmV0dXJuIGE7dmFyIGI9bmV3IHRoaXMoSGEpO05hKGIsYSk7cmV0dXJuIGJ9O3ZhciBJYT1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO2Z1bmN0aW9uIEhhKCl7fXZhciBQYT1uZXcgT2E7ZnVuY3Rpb24gUWEoYSl7dHJ5e3JldHVybiBhLnRoZW59Y2F0Y2goYil7cmV0dXJuIFBhLmVycm9yPWIsUGF9fWZ1bmN0aW9uIFJhKGEsYixjLGQpe3RyeXthLmNhbGwoYixjLGQpfWNhdGNoKGUpe3JldHVybiBlfX1mdW5jdGlvbiBTYShhLGIsYyl7RmEoZnVuY3Rpb24oYSl7dmFyIGQ9ITEsZj1SYShjLGIsZnVuY3Rpb24oYyl7ZHx8KGQ9ITAsYiE9PWM/TmEoYSxjKTpyKGEsYykpfSxmdW5jdGlvbihiKXtkfHwoZD0hMCx1KGEsYikpfSk7IWQmJmYmJihkPSEwLHUoYSxmKSl9LGEpfWZ1bmN0aW9uIFRhKGEsYil7MT09PWIuZz9yKGEsYi5mKToyPT09Yi5nP3UoYSxiLmYpOkxhKGIsdm9pZCAwLGZ1bmN0aW9uKGIpe3JldHVybiBOYShhLGIpfSxmdW5jdGlvbihiKXtyZXR1cm4gdShhLGIpfSl9XG5mdW5jdGlvbiBVYShhLGIsYyl7Yi5jb25zdHJ1Y3Rvcj09PWEuY29uc3RydWN0b3ImJmM9PT1HYSYmYi5jb25zdHJ1Y3Rvci5yZXNvbHZlPT09TWE/VGEoYSxiKTpjPT09UGE/KHUoYSxQYS5lcnJvciksUGEuZXJyb3I9bnVsbCk6dm9pZCAwPT09Yz9yKGEsYik6XCJmdW5jdGlvblwiPT09dHlwZW9mIGM/U2EoYSxiLGMpOnIoYSxiKX1mdW5jdGlvbiBOYShhLGIpe2lmKGE9PT1iKXUoYSxuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKSk7ZWxzZXt2YXIgYz10eXBlb2YgYjtudWxsPT09Ynx8XCJvYmplY3RcIiE9PWMmJlwiZnVuY3Rpb25cIiE9PWM/cihhLGIpOlVhKGEsYixRYShiKSl9fWZ1bmN0aW9uIFZhKGEpe2EucGEmJmEucGEoYS5mKTtXYShhKX1mdW5jdGlvbiByKGEsYil7dm9pZCAwPT09YS5nJiYoYS5mPWIsYS5nPTEsMCE9PWEuSS5sZW5ndGgmJkZhKFdhLGEpKX1cbmZ1bmN0aW9uIHUoYSxiKXt2b2lkIDA9PT1hLmcmJihhLmc9MixhLmY9YixGYShWYSxhKSl9ZnVuY3Rpb24gTGEoYSxiLGMsZCl7dmFyIGU9YS5JLGY9ZS5sZW5ndGg7YS5wYT1udWxsO2VbZl09YjtlW2YrMV09YztlW2YrMl09ZDswPT09ZiYmYS5nJiZGYShXYSxhKX1mdW5jdGlvbiBXYShhKXt2YXIgYj1hLkksYz1hLmc7aWYoMCE9PWIubGVuZ3RoKXtmb3IodmFyIGQsZSxmPWEuZixoPTA7aDxiLmxlbmd0aDtoKz0zKWQ9YltoXSxlPWJbaCtjXSxkP0thKGMsZCxlLGYpOmUoZik7YS5JLmxlbmd0aD0wfX1mdW5jdGlvbiBPYSgpe3RoaXMuZXJyb3I9bnVsbH12YXIgWGE9bmV3IE9hO1xuZnVuY3Rpb24gS2EoYSxiLGMsZCl7dmFyIGU9XCJmdW5jdGlvblwiPT09dHlwZW9mIGM7aWYoZSl7dHJ5e3ZhciBmPWMoZCl9Y2F0Y2gobCl7WGEuZXJyb3I9bCxmPVhhfWlmKGY9PT1YYSl7dmFyIGg9ITA7dmFyIGc9Zi5lcnJvcjtmLmVycm9yPW51bGx9ZWxzZSB2YXIgaz0hMDtpZihiPT09Zil7dShiLG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuXCIpKTtyZXR1cm59fWVsc2UgZj1kLGs9ITA7dm9pZCAwPT09Yi5nJiYoZSYmaz9OYShiLGYpOmg/dShiLGcpOjE9PT1hP3IoYixmKToyPT09YSYmdShiLGYpKX1mdW5jdGlvbiBZYShhLGIpe3RyeXtiKGZ1bmN0aW9uKGIpe05hKGEsYil9LGZ1bmN0aW9uKGIpe3UoYSxiKX0pfWNhdGNoKGMpe3UoYSxjKX19dmFyIGFiPTA7ZnVuY3Rpb24gSmEoYSl7YVtJYV09YWIrKzthLmc9dm9pZCAwO2EuZj12b2lkIDA7YS5JPVtdfTtmdW5jdGlvbiBiYihhLGIpe3RoaXMuR2E9YTt0aGlzLkE9bmV3IGEoSGEpO3RoaXMuQVtJYV18fEphKHRoaXMuQSk7aWYobGEoYikpaWYodGhpcy5TPXRoaXMubGVuZ3RoPWIubGVuZ3RoLHRoaXMuZj1BcnJheSh0aGlzLmxlbmd0aCksMD09PXRoaXMubGVuZ3RoKXIodGhpcy5BLHRoaXMuZik7ZWxzZXt0aGlzLmxlbmd0aD10aGlzLmxlbmd0aHx8MDtmb3IoYT0wO3ZvaWQgMD09PXRoaXMuZyYmYTxiLmxlbmd0aDthKyspY2IodGhpcyxiW2FdLGEpOzA9PT10aGlzLlMmJnIodGhpcy5BLHRoaXMuZil9ZWxzZSB1KHRoaXMuQSxFcnJvcihcIkFycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheVwiKSl9XG5mdW5jdGlvbiBjYihhLGIsYyl7dmFyIGQ9YS5HYSxlPWQucmVzb2x2ZTtlPT09TWE/KGU9UWEoYiksZT09PUdhJiZ2b2lkIDAhPT1iLmc/ZGIoYSxiLmcsYyxiLmYpOlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBlPyhhLlMtLSxhLmZbY109Yik6ZD09PXY/KGQ9bmV3IGQoSGEpLFVhKGQsYixlKSxlYihhLGQsYykpOmViKGEsbmV3IGQoZnVuY3Rpb24oYSl7cmV0dXJuIGEoYil9KSxjKSk6ZWIoYSxlKGIpLGMpfWZ1bmN0aW9uIGRiKGEsYixjLGQpe3ZhciBlPWEuQTt2b2lkIDA9PT1lLmcmJihhLlMtLSwyPT09Yj91KGUsZCk6YS5mW2NdPWQpOzA9PT1hLlMmJnIoZSxhLmYpfWZ1bmN0aW9uIGViKGEsYixjKXtMYShiLHZvaWQgMCxmdW5jdGlvbihiKXtyZXR1cm4gZGIoYSwxLGMsYil9LGZ1bmN0aW9uKGIpe3JldHVybiBkYihhLDIsYyxiKX0pfTtmdW5jdGlvbiBmYihhKXtyZXR1cm4obmV3IGJiKHRoaXMsYSkpLkF9O2Z1bmN0aW9uIGdiKGEpe3ZhciBiPXRoaXM7cmV0dXJuIGxhKGEpP25ldyBiKGZ1bmN0aW9uKGMsZCl7Zm9yKHZhciBlPWEubGVuZ3RoLGY9MDtmPGU7ZisrKWIucmVzb2x2ZShhW2ZdKS50aGVuKGMsZCl9KTpuZXcgYihmdW5jdGlvbihhLGIpe3JldHVybiBiKG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuXCIpKX0pfTtmdW5jdGlvbiBoYihhKXt2YXIgYj1uZXcgdGhpcyhIYSk7dShiLGEpO3JldHVybiBifTtmdW5jdGlvbiB2KGEpe3RoaXNbSWFdPWFiKys7dGhpcy5mPXRoaXMuZz12b2lkIDA7dGhpcy5JPVtdO2lmKEhhIT09YSl7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3JcIik7aWYodGhpcyBpbnN0YW5jZW9mIHYpWWEodGhpcyxhKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7fX12LnByb3RvdHlwZT17Y29uc3RydWN0b3I6dix0aGVuOkdhLGE6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudGhlbihudWxsLGEpfX07LypcblxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbndpbmRvdy5Qcm9taXNlfHwod2luZG93LlByb21pc2U9dix2LnByb3RvdHlwZVtcImNhdGNoXCJdPXYucHJvdG90eXBlLmEsdi5wcm90b3R5cGUudGhlbj12LnByb3RvdHlwZS50aGVuLHYuYWxsPWZiLHYucmFjZT1nYix2LnJlc29sdmU9TWEsdi5yZWplY3Q9aGIpOyhmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEsYil7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudClyZXR1cm4gbmV3IEN1c3RvbUV2ZW50KGEsYik7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtjLmluaXRDdXN0b21FdmVudChhLCEhYi5idWJibGVzLCEhYi5jYW5jZWxhYmxlLGIuZGV0YWlsKTtyZXR1cm4gY31mdW5jdGlvbiBjKGEpe2lmKG0pcmV0dXJuIGEub3duZXJEb2N1bWVudCE9PWRvY3VtZW50P2Eub3duZXJEb2N1bWVudDpudWxsO3ZhciBiPWEuX19pbXBvcnREb2M7aWYoIWImJmEucGFyZW50Tm9kZSl7Yj1hLnBhcmVudE5vZGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGIuY2xvc2VzdCliPWIuY2xvc2VzdChcImxpbmtbcmVsPWltcG9ydF1cIik7ZWxzZSBmb3IoOyFnKGIpJiYoYj1iLnBhcmVudE5vZGUpOyk7YS5fX2ltcG9ydERvYz1ifXJldHVybiBifWZ1bmN0aW9uIGQoYSl7dmFyIGI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtbcmVsPWltcG9ydF06bm90KFtpbXBvcnQtZGVwZW5kZW5jeV0pXCIpLFxuYz1iLmxlbmd0aDtjP2woYixmdW5jdGlvbihiKXtyZXR1cm4gaChiLGZ1bmN0aW9uKCl7MD09PS0tYyYmYSgpfSl9KTphKCl9ZnVuY3Rpb24gZShhKXtmdW5jdGlvbiBiKCl7XCJsb2FkaW5nXCIhPT1kb2N1bWVudC5yZWFkeVN0YXRlJiZkb2N1bWVudC5ib2R5JiYoZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixiKSxhKCkpfWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsYik7YigpfWZ1bmN0aW9uIGYoYSl7ZShmdW5jdGlvbigpe3JldHVybiBkKGZ1bmN0aW9uKCl7cmV0dXJuIGEmJmEoKX0pfSl9ZnVuY3Rpb24gaChhLGIpe2lmKGEuX19sb2FkZWQpYiYmYigpO2Vsc2UgaWYoXCJzY3JpcHRcIj09PWEubG9jYWxOYW1lJiYhYS5zcmN8fFwic3R5bGVcIj09PWEubG9jYWxOYW1lJiYhYS5maXJzdENoaWxkKWEuX19sb2FkZWQ9ITAsYiYmYigpO2Vsc2V7dmFyIGM9ZnVuY3Rpb24oZCl7YS5yZW1vdmVFdmVudExpc3RlbmVyKGQudHlwZSxcbmMpO2EuX19sb2FkZWQ9ITA7YiYmYigpfTthLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsYyk7YWEmJlwic3R5bGVcIj09PWEubG9jYWxOYW1lfHxhLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGMpfX1mdW5jdGlvbiBnKGEpe3JldHVybiBhLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJlwibGlua1wiPT09YS5sb2NhbE5hbWUmJlwiaW1wb3J0XCI9PT1hLnJlbH1mdW5jdGlvbiBrKCl7dmFyIGE9dGhpczt0aGlzLmE9e307dGhpcy5iPTA7dGhpcy5oPW5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKGIpe3JldHVybiBhLlFhKGIpfSk7dGhpcy5oLm9ic2VydmUoZG9jdW1lbnQuaGVhZCx7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9KTt0aGlzLmMoZG9jdW1lbnQpfWZ1bmN0aW9uIGwoYSxiLGMpe3ZhciBkPWE/YS5sZW5ndGg6MCxlPWM/LTE6MTtmb3IoYz1jP2QtMTowO2M8ZCYmMDw9YztjKz1lKWIoYVtjXSxjKX12YXIgbT1cImltcG9ydFwiaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIiksXG5uPW51bGw7ITE9PT1cImN1cnJlbnRTY3JpcHRcImluIGRvY3VtZW50JiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQsXCJjdXJyZW50U2NyaXB0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiBufHwoXCJjb21wbGV0ZVwiIT09ZG9jdW1lbnQucmVhZHlTdGF0ZT9kb2N1bWVudC5zY3JpcHRzW2RvY3VtZW50LnNjcmlwdHMubGVuZ3RoLTFdOm51bGwpfSxjb25maWd1cmFibGU6ITB9KTt2YXIgdz0vKHVybFxcKCkoW14pXSopKFxcKSkvZyxJPS8oQGltcG9ydFtcXHNdKyg/IXVybFxcKCkpKFteO10qKSg7KS9nLFphPS8oPGxpbmtbXj5dKikocmVsPVsnfFwiXT9zdHlsZXNoZWV0Wyd8XCJdP1tePl0qPikvZyx0PXtLYTpmdW5jdGlvbihhLGIpe2EuaHJlZiYmYS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsdC5ZKGEuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxiKSk7YS5zcmMmJmEuc2V0QXR0cmlidXRlKFwic3JjXCIsdC5ZKGEuZ2V0QXR0cmlidXRlKFwic3JjXCIpLGIpKTtpZihcInN0eWxlXCI9PT1hLmxvY2FsTmFtZSl7dmFyIGM9XG50LnVhKGEudGV4dENvbnRlbnQsYix3KTthLnRleHRDb250ZW50PXQudWEoYyxiLEkpfX0sdWE6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhLnJlcGxhY2UoYyxmdW5jdGlvbihhLGMsZCxlKXthPWQucmVwbGFjZSgvW1wiJ10vZyxcIlwiKTtiJiYoYT10LlkoYSxiKSk7cmV0dXJuIGMrXCInXCIrYStcIidcIitlfSl9LFk6ZnVuY3Rpb24oYSxiKXtpZih2b2lkIDA9PT10LmNhKXt0LmNhPSExO3RyeXt2YXIgYz1uZXcgVVJMKFwiYlwiLFwiaHR0cDovL2FcIik7Yy5wYXRobmFtZT1cImMlMjBkXCI7dC5jYT1cImh0dHA6Ly9hL2MlMjBkXCI9PT1jLmhyZWZ9Y2F0Y2gocGMpe319aWYodC5jYSlyZXR1cm4obmV3IFVSTChhLGIpKS5ocmVmO2M9dC5EYTtjfHwoYz1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJ0ZW1wXCIpLHQuRGE9YyxjLm1hPWMuY3JlYXRlRWxlbWVudChcImJhc2VcIiksYy5oZWFkLmFwcGVuZENoaWxkKGMubWEpLGMubGE9Yy5jcmVhdGVFbGVtZW50KFwiYVwiKSk7Yy5tYS5ocmVmPVxuYjtjLmxhLmhyZWY9YTtyZXR1cm4gYy5sYS5ocmVmfHxhfX0sbmE9e2FzeW5jOiEwLGxvYWQ6ZnVuY3Rpb24oYSxiLGMpe2lmKGEpaWYoYS5tYXRjaCgvXmRhdGE6Lykpe2E9YS5zcGxpdChcIixcIik7dmFyIGQ9YVsxXTtkPS0xPGFbMF0uaW5kZXhPZihcIjtiYXNlNjRcIik/YXRvYihkKTpkZWNvZGVVUklDb21wb25lbnQoZCk7YihkKX1lbHNle3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtlLm9wZW4oXCJHRVRcIixhLG5hLmFzeW5jKTtlLm9ubG9hZD1mdW5jdGlvbigpe3ZhciBhPWUucmVzcG9uc2VVUkx8fGUuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMb2NhdGlvblwiKTthJiYwPT09YS5pbmRleE9mKFwiL1wiKSYmKGE9KGxvY2F0aW9uLm9yaWdpbnx8bG9jYXRpb24ucHJvdG9jb2wrXCIvL1wiK2xvY2F0aW9uLmhvc3QpK2EpO3ZhciBkPWUucmVzcG9uc2V8fGUucmVzcG9uc2VUZXh0OzMwND09PWUuc3RhdHVzfHwwPT09ZS5zdGF0dXN8fDIwMDw9ZS5zdGF0dXMmJjMwMD5lLnN0YXR1cz9iKGQsYSk6YyhkKX07XG5lLnNlbmQoKX1lbHNlIGMoXCJlcnJvcjogaHJlZiBtdXN0IGJlIHNwZWNpZmllZFwiKX19LGFhPS9UcmlkZW50Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpfHwvRWRnZVxcL1xcZC4vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO2sucHJvdG90eXBlLmM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczthPWEucXVlcnlTZWxlY3RvckFsbChcImxpbmtbcmVsPWltcG9ydF1cIik7bChhLGZ1bmN0aW9uKGEpe3JldHVybiBiLkwoYSl9KX07ay5wcm90b3R5cGUuTD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9YS5ocmVmO2lmKHZvaWQgMCE9PXRoaXMuYVtjXSl7dmFyIGQ9dGhpcy5hW2NdO2QmJmQuX19sb2FkZWQmJihhLmltcG9ydD1kLHRoaXMubyhhKSl9ZWxzZSB0aGlzLmIrKyx0aGlzLmFbY109XCJwZW5kaW5nXCIsbmEubG9hZChjLGZ1bmN0aW9uKGEsZCl7YT1iLlJhKGEsZHx8Yyk7Yi5hW2NdPWE7Yi5iLS07Yi5jKGEpO2Iuc2EoKX0sZnVuY3Rpb24oKXtiLmFbY109bnVsbDtiLmItLTtiLnNhKCl9KX07XG5rLnByb3RvdHlwZS5SYT1mdW5jdGlvbihhLGIpe2lmKCFhKXJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7YWEmJihhPWEucmVwbGFjZShaYSxmdW5jdGlvbihhLGIsYyl7cmV0dXJuLTE9PT1hLmluZGV4T2YoXCJ0eXBlPVwiKT9iK1wiIHR5cGU9aW1wb3J0LWRpc2FibGUgXCIrYzphfSkpO3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtjLmlubmVySFRNTD1hO2lmKGMuY29udGVudClhPWMuY29udGVudDtlbHNlIGZvcihhPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtjLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYy5maXJzdENoaWxkKTtpZihjPWEucXVlcnlTZWxlY3RvcihcImJhc2VcIikpYj10LlkoYy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGIpLGMucmVtb3ZlQXR0cmlidXRlKFwiaHJlZlwiKTtjPWEucXVlcnlTZWxlY3RvckFsbCgnbGlua1tyZWw9aW1wb3J0XSwgbGlua1tyZWw9c3R5bGVzaGVldF1baHJlZl1bdHlwZT1pbXBvcnQtZGlzYWJsZV0sXFxuICAgIHN0eWxlOm5vdChbdHlwZV0pLCBsaW5rW3JlbD1zdHlsZXNoZWV0XVtocmVmXTpub3QoW3R5cGVdKSxcXG4gICAgc2NyaXB0Om5vdChbdHlwZV0pLCBzY3JpcHRbdHlwZT1cImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIl0sXFxuICAgIHNjcmlwdFt0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCJdJyk7XG52YXIgZD0wO2woYyxmdW5jdGlvbihhKXtoKGEpO3QuS2EoYSxiKTthLnNldEF0dHJpYnV0ZShcImltcG9ydC1kZXBlbmRlbmN5XCIsXCJcIik7XCJzY3JpcHRcIj09PWEubG9jYWxOYW1lJiYhYS5zcmMmJmEudGV4dENvbnRlbnQmJihhLnNldEF0dHJpYnV0ZShcInNyY1wiLFwiZGF0YTp0ZXh0L2phdmFzY3JpcHQ7Y2hhcnNldD11dGYtOCxcIitlbmNvZGVVUklDb21wb25lbnQoYS50ZXh0Q29udGVudCsoXCJcXG4vLyMgc291cmNlVVJMPVwiK2IrKGQ/XCItXCIrZDpcIlwiKStcIi5qc1xcblwiKSkpLGEudGV4dENvbnRlbnQ9XCJcIixkKyspfSk7cmV0dXJuIGF9O2sucHJvdG90eXBlLnNhPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztpZighdGhpcy5iKXt0aGlzLmguZGlzY29ubmVjdCgpO3RoaXMuZmxhdHRlbihkb2N1bWVudCk7dmFyIGI9ITEsYz0hMSxkPWZ1bmN0aW9uKCl7YyYmYiYmKGEuYyhkb2N1bWVudCksYS5ifHwoYS5oLm9ic2VydmUoZG9jdW1lbnQuaGVhZCx7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9KSxhLlBhKCkpKX07XG50aGlzLldhKGZ1bmN0aW9uKCl7Yz0hMDtkKCl9KTt0aGlzLlNhKGZ1bmN0aW9uKCl7Yj0hMDtkKCl9KX19O2sucHJvdG90eXBlLmZsYXR0ZW49ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczthPWEucXVlcnlTZWxlY3RvckFsbChcImxpbmtbcmVsPWltcG9ydF1cIik7bChhLGZ1bmN0aW9uKGEpe3ZhciBjPWIuYVthLmhyZWZdOyhhLmltcG9ydD1jKSYmYy5ub2RlVHlwZT09PU5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSYmKGIuYVthLmhyZWZdPWEsYS5yZWFkeVN0YXRlPVwibG9hZGluZ1wiLGEuaW1wb3J0PWEsYi5mbGF0dGVuKGMpLGEuYXBwZW5kQ2hpbGQoYykpfSl9O2sucHJvdG90eXBlLlNhPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoZSl7aWYoZTxkKXt2YXIgZj1jW2VdLGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtmLnJlbW92ZUF0dHJpYnV0ZShcImltcG9ydC1kZXBlbmRlbmN5XCIpO2woZi5hdHRyaWJ1dGVzLGZ1bmN0aW9uKGEpe3JldHVybiBnLnNldEF0dHJpYnV0ZShhLm5hbWUsXG5hLnZhbHVlKX0pO249ZztmLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGcsZik7aChnLGZ1bmN0aW9uKCl7bj1udWxsO2IoZSsxKX0pfWVsc2UgYSgpfXZhciBjPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzY3JpcHRbaW1wb3J0LWRlcGVuZGVuY3ldXCIpLGQ9Yy5sZW5ndGg7YigwKX07ay5wcm90b3R5cGUuV2E9ZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInN0eWxlW2ltcG9ydC1kZXBlbmRlbmN5XSxcXG4gICAgbGlua1tyZWw9c3R5bGVzaGVldF1baW1wb3J0LWRlcGVuZGVuY3ldXCIpLGQ9Yi5sZW5ndGg7aWYoZCl7dmFyIGU9YWEmJiEhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImxpbmtbcmVsPXN0eWxlc2hlZXRdW2hyZWZdW3R5cGU9aW1wb3J0LWRpc2FibGVdXCIpO2woYixmdW5jdGlvbihiKXtoKGIsZnVuY3Rpb24oKXtiLnJlbW92ZUF0dHJpYnV0ZShcImltcG9ydC1kZXBlbmRlbmN5XCIpOzA9PT0tLWQmJmEoKX0pO2lmKGUmJmIucGFyZW50Tm9kZSE9PVxuZG9jdW1lbnQuaGVhZCl7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChiLmxvY2FsTmFtZSk7Zi5fX2FwcGxpZWRFbGVtZW50PWI7Zi5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJpbXBvcnQtcGxhY2Vob2xkZXJcIik7Yi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShmLGIubmV4dFNpYmxpbmcpO2ZvcihmPWMoYik7ZiYmYyhmKTspZj1jKGYpO2YucGFyZW50Tm9kZSE9PWRvY3VtZW50LmhlYWQmJihmPW51bGwpO2RvY3VtZW50LmhlYWQuaW5zZXJ0QmVmb3JlKGIsZik7Yi5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpfX0pfWVsc2UgYSgpfTtrLnByb3RvdHlwZS5QYT1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tyZWw9aW1wb3J0XVwiKTtsKGIsZnVuY3Rpb24oYil7cmV0dXJuIGEubyhiKX0sITApfTtrLnByb3RvdHlwZS5vPWZ1bmN0aW9uKGEpe2EuX19sb2FkZWR8fChhLl9fbG9hZGVkPSEwLGEuaW1wb3J0JiYoYS5pbXBvcnQucmVhZHlTdGF0ZT1cblwiY29tcGxldGVcIiksYS5kaXNwYXRjaEV2ZW50KGIoYS5pbXBvcnQ/XCJsb2FkXCI6XCJlcnJvclwiLHtidWJibGVzOiExLGNhbmNlbGFibGU6ITEsZGV0YWlsOnZvaWQgMH0pKSl9O2sucHJvdG90eXBlLlFhPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7bChhLGZ1bmN0aW9uKGEpe3JldHVybiBsKGEuYWRkZWROb2RlcyxmdW5jdGlvbihhKXthJiZhLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJihnKGEpP2IuTChhKTpiLmMoYSkpfSl9KX07aWYobSl7dmFyIFQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtbcmVsPWltcG9ydF1cIik7bChULGZ1bmN0aW9uKGEpe2EuaW1wb3J0JiZcImxvYWRpbmdcIj09PWEuaW1wb3J0LnJlYWR5U3RhdGV8fChhLl9fbG9hZGVkPSEwKX0pO1Q9ZnVuY3Rpb24oYSl7YT1hLnRhcmdldDtnKGEpJiYoYS5fX2xvYWRlZD0hMCl9O2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsVCwhMCk7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsXG5ULCEwKX1lbHNle3ZhciBVPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsXCJiYXNlVVJJXCIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSgoIVV8fFUuY29uZmlndXJhYmxlP05vZGU6RWxlbWVudCkucHJvdG90eXBlLFwiYmFzZVVSSVwiLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgYT1nKHRoaXMpP3RoaXM6Yyh0aGlzKTtyZXR1cm4gYT9hLmhyZWY6VSYmVS5nZXQ/VS5nZXQuY2FsbCh0aGlzKTooZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIil8fHdpbmRvdy5sb2NhdGlvbikuaHJlZn0sY29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITB9KTtlKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBrfSl9ZihmdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGIoXCJIVE1MSW1wb3J0c0xvYWRlZFwiLHtjYW5jZWxhYmxlOiEwLGJ1YmJsZXM6ITAsZGV0YWlsOnZvaWQgMH0pKX0pO2EudXNlTmF0aXZlPW07YS53aGVuUmVhZHk9ZjthLmltcG9ydEZvckVsZW1lbnQ9XG5jfSkod2luZG93LkhUTUxJbXBvcnRzPXdpbmRvdy5IVE1MSW1wb3J0c3x8e30pOy8qXG5cbiBDb3B5cmlnaHQgKGMpIDIwMTQgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG53aW5kb3cuV2ViQ29tcG9uZW50cz13aW5kb3cuV2ViQ29tcG9uZW50c3x8e2ZsYWdzOnt9fTt2YXIgaWI9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3NyYyo9XCJ3ZWJjb21wb25lbnRzLWxpdGUuanNcIl0nKSxqYj0vd2MtKC4rKS8seD17fTtpZigheC5ub09wdHMpe2xvY2F0aW9uLnNlYXJjaC5zbGljZSgxKS5zcGxpdChcIiZcIikuZm9yRWFjaChmdW5jdGlvbihhKXthPWEuc3BsaXQoXCI9XCIpO3ZhciBiO2FbMF0mJihiPWFbMF0ubWF0Y2goamIpKSYmKHhbYlsxXV09YVsxXXx8ITApfSk7aWYoaWIpZm9yKHZhciBrYj0wLGxiO2xiPWliLmF0dHJpYnV0ZXNba2JdO2tiKyspXCJzcmNcIiE9PWxiLm5hbWUmJih4W2xiLm5hbWVdPWxiLnZhbHVlfHwhMCk7aWYoeC5sb2cmJngubG9nLnNwbGl0KXt2YXIgbWI9eC5sb2cuc3BsaXQoXCIsXCIpO3gubG9nPXt9O21iLmZvckVhY2goZnVuY3Rpb24oYSl7eC5sb2dbYV09ITB9KX1lbHNlIHgubG9nPXt9fVxud2luZG93LldlYkNvbXBvbmVudHMuZmxhZ3M9eDt2YXIgbmI9eC5zaGFkeWRvbTtuYiYmKHdpbmRvdy5TaGFkeURPTT13aW5kb3cuU2hhZHlET018fHt9LHdpbmRvdy5TaGFkeURPTS5mb3JjZT1uYik7dmFyIG9iPXgucmVnaXN0ZXJ8fHguY2U7b2ImJndpbmRvdy5jdXN0b21FbGVtZW50cyYmKHdpbmRvdy5jdXN0b21FbGVtZW50cy5mb3JjZVBvbHlmaWxsPW9iKTsvKlxuXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xudmFyIHk9d2luZG93LlNoYWR5RE9NfHx7fTt5Lk1hPSEoIUVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvd3x8IU5vZGUucHJvdG90eXBlLmdldFJvb3ROb2RlKTt2YXIgcGI9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSxcImZpcnN0Q2hpbGRcIik7eS5NPSEhKHBiJiZwYi5jb25maWd1cmFibGUmJnBiLmdldCk7eS50YT15LmZvcmNlfHwheS5NYTtmdW5jdGlvbiBxYihhKXtyZXR1cm4gYS5fX3NoYWR5JiZ2b2lkIDAhPT1hLl9fc2hhZHkuZmlyc3RDaGlsZH1mdW5jdGlvbiB6KGEpe3JldHVyblwiU2hhZHlSb290XCI9PT1hLkFhfWZ1bmN0aW9uIHJiKGEpe2E9YS5nZXRSb290Tm9kZSgpO2lmKHooYSkpcmV0dXJuIGF9dmFyIHNiPUVsZW1lbnQucHJvdG90eXBlLHRiPXNiLm1hdGNoZXN8fHNiLm1hdGNoZXNTZWxlY3Rvcnx8c2IubW96TWF0Y2hlc1NlbGVjdG9yfHxzYi5tc01hdGNoZXNTZWxlY3Rvcnx8c2Iub01hdGNoZXNTZWxlY3Rvcnx8c2Iud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuZnVuY3Rpb24gdWIoYSxiKXtpZihhJiZiKWZvcih2YXIgYz1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiKSxkPTAsZTtkPGMubGVuZ3RoJiYoZT1jW2RdKTtkKyspe3ZhciBmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYixlKTtmJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxlLGYpfX1mdW5jdGlvbiB2YihhLGIpe2Zvcih2YXIgYz1bXSxkPTE7ZDxhcmd1bWVudHMubGVuZ3RoOysrZCljW2QtMV09YXJndW1lbnRzW2RdO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspdWIoYSxjW2RdKTtyZXR1cm4gYX1mdW5jdGlvbiB3YihhLGIpe2Zvcih2YXIgYyBpbiBiKWFbY109YltjXX12YXIgeGI9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIikseWI9MCx6Yj1bXTsobmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKXtmb3IoO3piLmxlbmd0aDspdHJ5e3piLnNoaWZ0KCkoKX1jYXRjaChhKXt0aHJvdyB4Yi50ZXh0Q29udGVudD15YisrLGE7fX0pKS5vYnNlcnZlKHhiLHtjaGFyYWN0ZXJEYXRhOiEwfSk7XG5mdW5jdGlvbiBBYihhKXt6Yi5wdXNoKGEpO3hiLnRleHRDb250ZW50PXliKyt9dmFyIEJiPSEhZG9jdW1lbnQuY29udGFpbnM7ZnVuY3Rpb24gQ2IoYSxiKXtmb3IoO2I7KXtpZihiPT1hKXJldHVybiEwO2I9Yi5wYXJlbnROb2RlfXJldHVybiExfTt2YXIgRGI9W10sRWI7ZnVuY3Rpb24gRmIoYSl7RWJ8fChFYj0hMCxBYihHYikpO0RiLnB1c2goYSl9ZnVuY3Rpb24gR2IoKXtFYj0hMTtmb3IodmFyIGE9ISFEYi5sZW5ndGg7RGIubGVuZ3RoOylEYi5zaGlmdCgpKCk7cmV0dXJuIGF9R2IubGlzdD1EYjtmdW5jdGlvbiBIYigpe3RoaXMuYT0hMTt0aGlzLmFkZGVkTm9kZXM9W107dGhpcy5yZW1vdmVkTm9kZXM9W107dGhpcy5WPW5ldyBTZXR9ZnVuY3Rpb24gSWIoYSl7YS5hfHwoYS5hPSEwLEFiKGZ1bmN0aW9uKCl7SmIoYSl9KSl9ZnVuY3Rpb24gSmIoYSl7aWYoYS5hKXthLmE9ITE7dmFyIGI9YS50YWtlUmVjb3JkcygpO2IubGVuZ3RoJiZhLlYuZm9yRWFjaChmdW5jdGlvbihhKXthKGIpfSl9fUhiLnByb3RvdHlwZS50YWtlUmVjb3Jkcz1mdW5jdGlvbigpe2lmKHRoaXMuYWRkZWROb2Rlcy5sZW5ndGh8fHRoaXMucmVtb3ZlZE5vZGVzLmxlbmd0aCl7dmFyIGE9W3thZGRlZE5vZGVzOnRoaXMuYWRkZWROb2RlcyxyZW1vdmVkTm9kZXM6dGhpcy5yZW1vdmVkTm9kZXN9XTt0aGlzLmFkZGVkTm9kZXM9W107dGhpcy5yZW1vdmVkTm9kZXM9W107cmV0dXJuIGF9cmV0dXJuW119O1xuZnVuY3Rpb24gS2IoYSxiKXthLl9fc2hhZHk9YS5fX3NoYWR5fHx7fTthLl9fc2hhZHkuTnx8KGEuX19zaGFkeS5OPW5ldyBIYik7YS5fX3NoYWR5Lk4uVi5hZGQoYik7dmFyIGM9YS5fX3NoYWR5Lk47cmV0dXJue0VhOmIsQzpjLEhhOmEsdGFrZVJlY29yZHM6ZnVuY3Rpb24oKXtyZXR1cm4gYy50YWtlUmVjb3JkcygpfX19ZnVuY3Rpb24gTGIoYSl7dmFyIGI9YSYmYS5DO2ImJihiLlYuZGVsZXRlKGEuRWEpLGIuVi5zaXplfHwoYS5IYS5fX3NoYWR5Lk49bnVsbCkpfVxuZnVuY3Rpb24gTWIoYSxiKXt2YXIgYz1iLmdldFJvb3ROb2RlKCk7cmV0dXJuIGEubWFwKGZ1bmN0aW9uKGEpe3ZhciBiPWM9PT1hLnRhcmdldC5nZXRSb290Tm9kZSgpO2lmKGImJmEuYWRkZWROb2Rlcyl7aWYoYj1BcnJheS5mcm9tKGEuYWRkZWROb2RlcykuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBjPT09YS5nZXRSb290Tm9kZSgpfSksYi5sZW5ndGgpcmV0dXJuIGE9T2JqZWN0LmNyZWF0ZShhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImFkZGVkTm9kZXNcIix7dmFsdWU6Yixjb25maWd1cmFibGU6ITB9KSxhfWVsc2UgaWYoYilyZXR1cm4gYX0pLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYX0pfTt2YXIgQT17fSxOYj1FbGVtZW50LnByb3RvdHlwZS5pbnNlcnRCZWZvcmUsT2I9RWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQsUGI9RWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLFFiPUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSxSYj1FbGVtZW50LnByb3RvdHlwZS5jbG9uZU5vZGUsU2I9RG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGUsVGI9RWxlbWVudC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcixVYj1FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyLFZiPVdpbmRvdy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcixXYj1XaW5kb3cucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIsWGI9RWxlbWVudC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCxZYj1FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yLFpiPUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwsJGI9Tm9kZS5wcm90b3R5cGUuY29udGFpbnN8fFxuSFRNTEVsZW1lbnQucHJvdG90eXBlLmNvbnRhaW5zO0EuYXBwZW5kQ2hpbGQ9RWxlbWVudC5wcm90b3R5cGUuYXBwZW5kQ2hpbGQ7QS5pbnNlcnRCZWZvcmU9TmI7QS5yZW1vdmVDaGlsZD1PYjtBLnNldEF0dHJpYnV0ZT1QYjtBLnJlbW92ZUF0dHJpYnV0ZT1RYjtBLmNsb25lTm9kZT1SYjtBLmltcG9ydE5vZGU9U2I7QS5hZGRFdmVudExpc3RlbmVyPVRiO0EucmVtb3ZlRXZlbnRMaXN0ZW5lcj1VYjtBLmFiPVZiO0EuYmI9V2I7QS5kaXNwYXRjaEV2ZW50PVhiO0EucXVlcnlTZWxlY3Rvcj1ZYjtBLnF1ZXJ5U2VsZWN0b3JBbGw9WmI7QS5jb250YWlucz0kYjt2YXIgYWM9L1smXFx1MDBBMFwiXS9nLGJjPS9bJlxcdTAwQTA8Pl0vZztmdW5jdGlvbiBjYyhhKXtzd2l0Y2goYSl7Y2FzZSBcIiZcIjpyZXR1cm5cIiZhbXA7XCI7Y2FzZSBcIjxcIjpyZXR1cm5cIiZsdDtcIjtjYXNlIFwiPlwiOnJldHVyblwiJmd0O1wiO2Nhc2UgJ1wiJzpyZXR1cm5cIiZxdW90O1wiO2Nhc2UgXCJcXHUwMGEwXCI6cmV0dXJuXCImbmJzcDtcIn19ZnVuY3Rpb24gZGMoYSl7Zm9yKHZhciBiPXt9LGM9MDtjPGEubGVuZ3RoO2MrKyliW2FbY11dPSEwO3JldHVybiBifXZhciBlYz1kYyhcImFyZWEgYmFzZSBiciBjb2wgY29tbWFuZCBlbWJlZCBociBpbWcgaW5wdXQga2V5Z2VuIGxpbmsgbWV0YSBwYXJhbSBzb3VyY2UgdHJhY2sgd2JyXCIuc3BsaXQoXCIgXCIpKSxmYz1kYyhcInN0eWxlIHNjcmlwdCB4bXAgaWZyYW1lIG5vZW1iZWQgbm9mcmFtZXMgcGxhaW50ZXh0IG5vc2NyaXB0XCIuc3BsaXQoXCIgXCIpKTtcbmZ1bmN0aW9uIGdjKGEsYil7XCJ0ZW1wbGF0ZVwiPT09YS5sb2NhbE5hbWUmJihhPWEuY29udGVudCk7Zm9yKHZhciBjPVwiXCIsZD1iP2IoYSk6YS5jaGlsZE5vZGVzLGU9MCxmPWQubGVuZ3RoLGg7ZTxmJiYoaD1kW2VdKTtlKyspe2E6e3ZhciBnPWg7dmFyIGs9YTt2YXIgbD1iO3N3aXRjaChnLm5vZGVUeXBlKXtjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOmZvcih2YXIgbT1nLmxvY2FsTmFtZSxuPVwiPFwiK20sdz1nLmF0dHJpYnV0ZXMsST0wO2s9d1tJXTtJKyspbis9XCIgXCIray5uYW1lKyc9XCInK2sudmFsdWUucmVwbGFjZShhYyxjYykrJ1wiJztuKz1cIj5cIjtnPWVjW21dP246bitnYyhnLGwpK1wiPC9cIittK1wiPlwiO2JyZWFrIGE7Y2FzZSBOb2RlLlRFWFRfTk9ERTpnPWcuZGF0YTtnPWsmJmZjW2subG9jYWxOYW1lXT9nOmcucmVwbGFjZShiYyxjYyk7YnJlYWsgYTtjYXNlIE5vZGUuQ09NTUVOVF9OT0RFOmc9XCJcXHgzYyEtLVwiK2cuZGF0YStcIi0tXFx4M2VcIjticmVhayBhO2RlZmF1bHQ6dGhyb3cgd2luZG93LmNvbnNvbGUuZXJyb3IoZyksXG5FcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTt9fWMrPWd9cmV0dXJuIGN9O3ZhciBCPXt9LEM9ZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihkb2N1bWVudCxOb2RlRmlsdGVyLlNIT1dfQUxMLG51bGwsITEpLEQ9ZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihkb2N1bWVudCxOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxudWxsLCExKTtmdW5jdGlvbiBoYyhhKXt2YXIgYj1bXTtDLmN1cnJlbnROb2RlPWE7Zm9yKGE9Qy5maXJzdENoaWxkKCk7YTspYi5wdXNoKGEpLGE9Qy5uZXh0U2libGluZygpO3JldHVybiBifUIucGFyZW50Tm9kZT1mdW5jdGlvbihhKXtDLmN1cnJlbnROb2RlPWE7cmV0dXJuIEMucGFyZW50Tm9kZSgpfTtCLmZpcnN0Q2hpbGQ9ZnVuY3Rpb24oYSl7Qy5jdXJyZW50Tm9kZT1hO3JldHVybiBDLmZpcnN0Q2hpbGQoKX07Qi5sYXN0Q2hpbGQ9ZnVuY3Rpb24oYSl7Qy5jdXJyZW50Tm9kZT1hO3JldHVybiBDLmxhc3RDaGlsZCgpfTtCLnByZXZpb3VzU2libGluZz1mdW5jdGlvbihhKXtDLmN1cnJlbnROb2RlPWE7cmV0dXJuIEMucHJldmlvdXNTaWJsaW5nKCl9O1xuQi5uZXh0U2libGluZz1mdW5jdGlvbihhKXtDLmN1cnJlbnROb2RlPWE7cmV0dXJuIEMubmV4dFNpYmxpbmcoKX07Qi5jaGlsZE5vZGVzPWhjO0IucGFyZW50RWxlbWVudD1mdW5jdGlvbihhKXtELmN1cnJlbnROb2RlPWE7cmV0dXJuIEQucGFyZW50Tm9kZSgpfTtCLmZpcnN0RWxlbWVudENoaWxkPWZ1bmN0aW9uKGEpe0QuY3VycmVudE5vZGU9YTtyZXR1cm4gRC5maXJzdENoaWxkKCl9O0IubGFzdEVsZW1lbnRDaGlsZD1mdW5jdGlvbihhKXtELmN1cnJlbnROb2RlPWE7cmV0dXJuIEQubGFzdENoaWxkKCl9O0IucHJldmlvdXNFbGVtZW50U2libGluZz1mdW5jdGlvbihhKXtELmN1cnJlbnROb2RlPWE7cmV0dXJuIEQucHJldmlvdXNTaWJsaW5nKCl9O0IubmV4dEVsZW1lbnRTaWJsaW5nPWZ1bmN0aW9uKGEpe0QuY3VycmVudE5vZGU9YTtyZXR1cm4gRC5uZXh0U2libGluZygpfTtcbkIuY2hpbGRyZW49ZnVuY3Rpb24oYSl7dmFyIGI9W107RC5jdXJyZW50Tm9kZT1hO2ZvcihhPUQuZmlyc3RDaGlsZCgpO2E7KWIucHVzaChhKSxhPUQubmV4dFNpYmxpbmcoKTtyZXR1cm4gYn07Qi5pbm5lckhUTUw9ZnVuY3Rpb24oYSl7cmV0dXJuIGdjKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGhjKGEpfSl9O0IudGV4dENvbnRlbnQ9ZnVuY3Rpb24oYSl7c3dpdGNoKGEubm9kZVR5cGUpe2Nhc2UgTm9kZS5FTEVNRU5UX05PREU6Y2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6YT1kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGEsTm9kZUZpbHRlci5TSE9XX1RFWFQsbnVsbCwhMSk7Zm9yKHZhciBiPVwiXCIsYztjPWEubmV4dE5vZGUoKTspYis9Yy5ub2RlVmFsdWU7cmV0dXJuIGI7ZGVmYXVsdDpyZXR1cm4gYS5ub2RlVmFsdWV9fTt2YXIgaWM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSxcImlubmVySFRNTFwiKXx8T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsXCJpbm5lckhUTUxcIiksamM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiaW5lcnRcIiksa2M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihEb2N1bWVudC5wcm90b3R5cGUsXCJhY3RpdmVFbGVtZW50XCIpLGxjPXtwYXJlbnRFbGVtZW50OntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5wYXJlbnROb2RlO2EmJmEubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGE9bnVsbCk7cmV0dXJuIHZvaWQgMCE9PWE/YTpCLnBhcmVudEVsZW1lbnQodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH0scGFyZW50Tm9kZTp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkucGFyZW50Tm9kZTtcbnJldHVybiB2b2lkIDAhPT1hP2E6Qi5wYXJlbnROb2RlKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LG5leHRTaWJsaW5nOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5uZXh0U2libGluZztyZXR1cm4gdm9pZCAwIT09YT9hOkIubmV4dFNpYmxpbmcodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH0scHJldmlvdXNTaWJsaW5nOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc7cmV0dXJuIHZvaWQgMCE9PWE/YTpCLnByZXZpb3VzU2libGluZyh0aGlzKX0sY29uZmlndXJhYmxlOiEwfSxjbGFzc05hbWU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwifSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGEpfSxjb25maWd1cmFibGU6ITB9LG5leHRFbGVtZW50U2libGluZzp7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5fX3NoYWR5JiZcbnZvaWQgMCE9PXRoaXMuX19zaGFkeS5uZXh0U2libGluZyl7Zm9yKHZhciBhPXRoaXMubmV4dFNpYmxpbmc7YSYmYS5ub2RlVHlwZSE9PU5vZGUuRUxFTUVOVF9OT0RFOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9cmV0dXJuIEIubmV4dEVsZW1lbnRTaWJsaW5nKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LHByZXZpb3VzRWxlbWVudFNpYmxpbmc6e2dldDpmdW5jdGlvbigpe2lmKHRoaXMuX19zaGFkeSYmdm9pZCAwIT09dGhpcy5fX3NoYWR5LnByZXZpb3VzU2libGluZyl7Zm9yKHZhciBhPXRoaXMucHJldmlvdXNTaWJsaW5nO2EmJmEubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERTspYT1hLnByZXZpb3VzU2libGluZztyZXR1cm4gYX1yZXR1cm4gQi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKHRoaXMpfSxjb25maWd1cmFibGU6ITB9fSxtYz17Y2hpbGROb2Rlczp7Z2V0OmZ1bmN0aW9uKCl7aWYocWIodGhpcykpe2lmKCF0aGlzLl9fc2hhZHkuY2hpbGROb2Rlcyl7dGhpcy5fX3NoYWR5LmNoaWxkTm9kZXM9XG5bXTtmb3IodmFyIGE9dGhpcy5maXJzdENoaWxkO2E7YT1hLm5leHRTaWJsaW5nKXRoaXMuX19zaGFkeS5jaGlsZE5vZGVzLnB1c2goYSl9dmFyIGI9dGhpcy5fX3NoYWR5LmNoaWxkTm9kZXN9ZWxzZSBiPUIuY2hpbGROb2Rlcyh0aGlzKTtiLml0ZW09ZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19O3JldHVybiBifSxjb25maWd1cmFibGU6ITB9LGNoaWxkRWxlbWVudENvdW50OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGh9LGNvbmZpZ3VyYWJsZTohMH0sZmlyc3RDaGlsZDp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkuZmlyc3RDaGlsZDtyZXR1cm4gdm9pZCAwIT09YT9hOkIuZmlyc3RDaGlsZCh0aGlzKX0sY29uZmlndXJhYmxlOiEwfSxsYXN0Q2hpbGQ6e2dldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX19zaGFkeSYmdGhpcy5fX3NoYWR5Lmxhc3RDaGlsZDtyZXR1cm4gdm9pZCAwIT09YT9hOkIubGFzdENoaWxkKHRoaXMpfSxcbmNvbmZpZ3VyYWJsZTohMH0sdGV4dENvbnRlbnQ6e2dldDpmdW5jdGlvbigpe2lmKHFiKHRoaXMpKXtmb3IodmFyIGE9W10sYj0wLGM9dGhpcy5jaGlsZE5vZGVzLGQ7ZD1jW2JdO2IrKylkLm5vZGVUeXBlIT09Tm9kZS5DT01NRU5UX05PREUmJmEucHVzaChkLnRleHRDb250ZW50KTtyZXR1cm4gYS5qb2luKFwiXCIpfXJldHVybiBCLnRleHRDb250ZW50KHRoaXMpfSxzZXQ6ZnVuY3Rpb24oYSl7c3dpdGNoKHRoaXMubm9kZVR5cGUpe2Nhc2UgTm9kZS5FTEVNRU5UX05PREU6Y2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6Zm9yKDt0aGlzLmZpcnN0Q2hpbGQ7KXRoaXMucmVtb3ZlQ2hpbGQodGhpcy5maXJzdENoaWxkKTsoMDxhLmxlbmd0aHx8dGhpcy5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFKSYmdGhpcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKSk7YnJlYWs7ZGVmYXVsdDp0aGlzLm5vZGVWYWx1ZT1hfX0sY29uZmlndXJhYmxlOiEwfSxmaXJzdEVsZW1lbnRDaGlsZDp7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5fX3NoYWR5JiZcbnZvaWQgMCE9PXRoaXMuX19zaGFkeS5maXJzdENoaWxkKXtmb3IodmFyIGE9dGhpcy5maXJzdENoaWxkO2EmJmEubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERTspYT1hLm5leHRTaWJsaW5nO3JldHVybiBhfXJldHVybiBCLmZpcnN0RWxlbWVudENoaWxkKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LGxhc3RFbGVtZW50Q2hpbGQ6e2dldDpmdW5jdGlvbigpe2lmKHRoaXMuX19zaGFkeSYmdm9pZCAwIT09dGhpcy5fX3NoYWR5Lmxhc3RDaGlsZCl7Zm9yKHZhciBhPXRoaXMubGFzdENoaWxkO2EmJmEubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERTspYT1hLnByZXZpb3VzU2libGluZztyZXR1cm4gYX1yZXR1cm4gQi5sYXN0RWxlbWVudENoaWxkKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LGNoaWxkcmVuOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYTtxYih0aGlzKT9hPUFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCh0aGlzLmNoaWxkTm9kZXMsZnVuY3Rpb24oYSl7cmV0dXJuIGEubm9kZVR5cGU9PT1cbk5vZGUuRUxFTUVOVF9OT0RFfSk6YT1CLmNoaWxkcmVuKHRoaXMpO2EuaXRlbT1mdW5jdGlvbihiKXtyZXR1cm4gYVtiXX07cmV0dXJuIGF9LGNvbmZpZ3VyYWJsZTohMH0saW5uZXJIVE1MOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT1cInRlbXBsYXRlXCI9PT10aGlzLmxvY2FsTmFtZT90aGlzLmNvbnRlbnQ6dGhpcztyZXR1cm4gcWIodGhpcyk/Z2MoYSk6Qi5pbm5lckhUTUwoYSl9LHNldDpmdW5jdGlvbihhKXtmb3IodmFyIGI9XCJ0ZW1wbGF0ZVwiPT09dGhpcy5sb2NhbE5hbWU/dGhpcy5jb250ZW50OnRoaXM7Yi5maXJzdENoaWxkOyliLnJlbW92ZUNoaWxkKGIuZmlyc3RDaGlsZCk7dmFyIGM9dGhpcy5sb2NhbE5hbWU7YyYmXCJ0ZW1wbGF0ZVwiIT09Y3x8KGM9XCJkaXZcIik7Yz1qYy5jcmVhdGVFbGVtZW50KGMpO2ZvcihpYyYmaWMuc2V0P2ljLnNldC5jYWxsKGMsYSk6Yy5pbm5lckhUTUw9YTtjLmZpcnN0Q2hpbGQ7KWIuYXBwZW5kQ2hpbGQoYy5maXJzdENoaWxkKX0sY29uZmlndXJhYmxlOiEwfX0sXG5xYz17c2hhZG93Um9vdDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19zaGFkeSYmdGhpcy5fX3NoYWR5LlVhfHxudWxsfSxjb25maWd1cmFibGU6ITB9fSxyYz17YWN0aXZlRWxlbWVudDp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9a2MmJmtjLmdldD9rYy5nZXQuY2FsbChkb2N1bWVudCk6eS5NP3ZvaWQgMDpkb2N1bWVudC5hY3RpdmVFbGVtZW50O2lmKGEmJmEubm9kZVR5cGUpe3ZhciBiPSEheih0aGlzKTtpZih0aGlzPT09ZG9jdW1lbnR8fGImJnRoaXMuaG9zdCE9PWEmJkEuY29udGFpbnMuY2FsbCh0aGlzLmhvc3QsYSkpe2ZvcihiPXJiKGEpO2ImJmIhPT10aGlzOylhPWIuaG9zdCxiPXJiKGEpO2E9dGhpcz09PWRvY3VtZW50P2I/bnVsbDphOmI9PT10aGlzP2E6bnVsbH1lbHNlIGE9bnVsbH1lbHNlIGE9bnVsbDtyZXR1cm4gYX0sc2V0OmZ1bmN0aW9uKCl7fSxjb25maWd1cmFibGU6ITB9fTtcbmZ1bmN0aW9uIEUoYSxiLGMpe2Zvcih2YXIgZCBpbiBiKXt2YXIgZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEsZCk7ZSYmZS5jb25maWd1cmFibGV8fCFlJiZjP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQsYltkXSk6YyYmY29uc29sZS53YXJuKFwiQ291bGQgbm90IGRlZmluZVwiLGQsXCJvblwiLGEpfX1mdW5jdGlvbiBGKGEpe0UoYSxsYyk7RShhLG1jKTtFKGEscmMpfXZhciBzYz15Lk0/ZnVuY3Rpb24oKXt9OmZ1bmN0aW9uKGEpe2EuX19zaGFkeSYmYS5fX3NoYWR5LkJhfHwoYS5fX3NoYWR5PWEuX19zaGFkeXx8e30sYS5fX3NoYWR5LkJhPSEwLEUoYSxsYywhMCkpfSx0Yz15Lk0/ZnVuY3Rpb24oKXt9OmZ1bmN0aW9uKGEpe2EuX19zaGFkeSYmYS5fX3NoYWR5LnphfHwoYS5fX3NoYWR5PWEuX19zaGFkeXx8e30sYS5fX3NoYWR5LnphPSEwLEUoYSxtYywhMCksRShhLHFjLCEwKSl9O2Z1bmN0aW9uIHVjKGEsYixjKXtzYyhhKTtjPWN8fG51bGw7YS5fX3NoYWR5PWEuX19zaGFkeXx8e307Yi5fX3NoYWR5PWIuX19zaGFkeXx8e307YyYmKGMuX19zaGFkeT1jLl9fc2hhZHl8fHt9KTthLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nPWM/Yy5fX3NoYWR5LnByZXZpb3VzU2libGluZzpiLmxhc3RDaGlsZDt2YXIgZD1hLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nO2QmJmQuX19zaGFkeSYmKGQuX19zaGFkeS5uZXh0U2libGluZz1hKTsoZD1hLl9fc2hhZHkubmV4dFNpYmxpbmc9YykmJmQuX19zaGFkeSYmKGQuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc9YSk7YS5fX3NoYWR5LnBhcmVudE5vZGU9YjtjP2M9PT1iLl9fc2hhZHkuZmlyc3RDaGlsZCYmKGIuX19zaGFkeS5maXJzdENoaWxkPWEpOihiLl9fc2hhZHkubGFzdENoaWxkPWEsYi5fX3NoYWR5LmZpcnN0Q2hpbGR8fChiLl9fc2hhZHkuZmlyc3RDaGlsZD1hKSk7Yi5fX3NoYWR5LmNoaWxkTm9kZXM9bnVsbH1cbmZ1bmN0aW9uIHZjKGEpe2lmKCFhLl9fc2hhZHl8fHZvaWQgMD09PWEuX19zaGFkeS5maXJzdENoaWxkKXthLl9fc2hhZHk9YS5fX3NoYWR5fHx7fTthLl9fc2hhZHkuZmlyc3RDaGlsZD1CLmZpcnN0Q2hpbGQoYSk7YS5fX3NoYWR5Lmxhc3RDaGlsZD1CLmxhc3RDaGlsZChhKTt0YyhhKTtmb3IodmFyIGI9YS5fX3NoYWR5LmNoaWxkTm9kZXM9Qi5jaGlsZE5vZGVzKGEpLGM9MCxkO2M8Yi5sZW5ndGgmJihkPWJbY10pO2MrKylkLl9fc2hhZHk9ZC5fX3NoYWR5fHx7fSxkLl9fc2hhZHkucGFyZW50Tm9kZT1hLGQuX19zaGFkeS5uZXh0U2libGluZz1iW2MrMV18fG51bGwsZC5fX3NoYWR5LnByZXZpb3VzU2libGluZz1iW2MtMV18fG51bGwsc2MoZCl9fTtmdW5jdGlvbiB3YyhhLGIsYyl7aWYoYj09PWEpdGhyb3cgRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kQ2hpbGQnIG9uICdOb2RlJzogVGhlIG5ldyBjaGlsZCBlbGVtZW50IGNvbnRhaW5zIHRoZSBwYXJlbnQuXCIpO2lmKGMpe3ZhciBkPWMuX19zaGFkeSYmYy5fX3NoYWR5LnBhcmVudE5vZGU7aWYodm9pZCAwIT09ZCYmZCE9PWF8fHZvaWQgMD09PWQmJkIucGFyZW50Tm9kZShjKSE9PWEpdGhyb3cgRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnaW5zZXJ0QmVmb3JlJyBvbiAnTm9kZSc6IFRoZSBub2RlIGJlZm9yZSB3aGljaCB0aGUgbmV3IG5vZGUgaXMgdG8gYmUgaW5zZXJ0ZWQgaXMgbm90IGEgY2hpbGQgb2YgdGhpcyBub2RlLlwiKTt9aWYoYz09PWIpcmV0dXJuIGI7Yi5wYXJlbnROb2RlJiZ4YyhiLnBhcmVudE5vZGUsYik7ZD1yYihhKTt2YXIgZTtpZihlPWQpYTp7aWYoIWIuX19ub0luc2VydGlvblBvaW50KXt2YXIgZjtcInNsb3RcIj09PWIubG9jYWxOYW1lP2Y9W2JdOlxuYi5xdWVyeVNlbGVjdG9yQWxsJiYoZj1iLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzbG90XCIpKTtpZihmJiZmLmxlbmd0aCl7ZT1mO2JyZWFrIGF9fWU9dm9pZCAwfShmPWUpJiZkLkgucHVzaC5hcHBseShkLkgsW10uY29uY2F0KGYgaW5zdGFuY2VvZiBBcnJheT9mOmphKGlhKGYpKSkpO2QmJihcInNsb3RcIj09PWEubG9jYWxOYW1lfHxmKSYmeWMoZCk7aWYocWIoYSkpe2Q9Yzt0YyhhKTthLl9fc2hhZHk9YS5fX3NoYWR5fHx7fTt2b2lkIDAhPT1hLl9fc2hhZHkuZmlyc3RDaGlsZCYmKGEuX19zaGFkeS5jaGlsZE5vZGVzPW51bGwpO2lmKGIubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpe2Y9Yi5jaGlsZE5vZGVzO2ZvcihlPTA7ZTxmLmxlbmd0aDtlKyspdWMoZltlXSxhLGQpO2IuX19zaGFkeT1iLl9fc2hhZHl8fHt9O2Q9dm9pZCAwIT09Yi5fX3NoYWR5LmZpcnN0Q2hpbGQ/bnVsbDp2b2lkIDA7Yi5fX3NoYWR5LmZpcnN0Q2hpbGQ9Yi5fX3NoYWR5Lmxhc3RDaGlsZD1cbmQ7Yi5fX3NoYWR5LmNoaWxkTm9kZXM9ZH1lbHNlIHVjKGIsYSxkKTtpZih6YyhhKSl7eWMoYS5fX3NoYWR5LnJvb3QpO3ZhciBoPSEwfWVsc2UgYS5fX3NoYWR5LnJvb3QmJihoPSEwKX1ofHwoaD16KGEpP2EuaG9zdDphLGM/KGM9QWMoYyksQS5pbnNlcnRCZWZvcmUuY2FsbChoLGIsYykpOkEuYXBwZW5kQ2hpbGQuY2FsbChoLGIpKTtCYyhhLGIpO3JldHVybiBifVxuZnVuY3Rpb24geGMoYSxiKXtpZihiLnBhcmVudE5vZGUhPT1hKXRocm93IEVycm9yKFwiVGhlIG5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIG5vZGU6IFwiK2IpO3ZhciBjPXJiKGIpO2lmKHFiKGEpKXtiLl9fc2hhZHk9Yi5fX3NoYWR5fHx7fTthLl9fc2hhZHk9YS5fX3NoYWR5fHx7fTtiPT09YS5fX3NoYWR5LmZpcnN0Q2hpbGQmJihhLl9fc2hhZHkuZmlyc3RDaGlsZD1iLl9fc2hhZHkubmV4dFNpYmxpbmcpO2I9PT1hLl9fc2hhZHkubGFzdENoaWxkJiYoYS5fX3NoYWR5Lmxhc3RDaGlsZD1iLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nKTt2YXIgZD1iLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nLGU9Yi5fX3NoYWR5Lm5leHRTaWJsaW5nO2QmJihkLl9fc2hhZHk9ZC5fX3NoYWR5fHx7fSxkLl9fc2hhZHkubmV4dFNpYmxpbmc9ZSk7ZSYmKGUuX19zaGFkeT1lLl9fc2hhZHl8fHt9LGUuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc9ZCk7Yi5fX3NoYWR5LnBhcmVudE5vZGU9XG5iLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nPWIuX19zaGFkeS5uZXh0U2libGluZz12b2lkIDA7dm9pZCAwIT09YS5fX3NoYWR5LmNoaWxkTm9kZXMmJihhLl9fc2hhZHkuY2hpbGROb2Rlcz1udWxsKTtpZih6YyhhKSl7eWMoYS5fX3NoYWR5LnJvb3QpO3ZhciBmPSEwfX1DYyhiKTtpZihjKXsoZD1hJiZcInNsb3RcIj09PWEubG9jYWxOYW1lKSYmKGY9ITApO0RjKGMpO2U9Yy5sO2Zvcih2YXIgaCBpbiBlKWZvcih2YXIgZz1lW2hdLGs9MDtrPGcubGVuZ3RoO2srKyl7dmFyIGw9Z1trXTtpZihDYihiLGwpKXtnLnNwbGljZShrLDEpO3ZhciBtPWMucy5pbmRleE9mKGwpOzA8PW0mJmMucy5zcGxpY2UobSwxKTtrLS07aWYobT1sLl9fc2hhZHkuSylmb3IobD0wO2w8bS5sZW5ndGg7bCsrKXt2YXIgbj1tW2xdLHc9Qi5wYXJlbnROb2RlKG4pO3cmJkEucmVtb3ZlQ2hpbGQuY2FsbCh3LG4pfW09ITB9fShtfHxkKSYmeWMoYyl9Znx8KGY9eihhKT9hLmhvc3Q6YSwoIWEuX19zaGFkeS5yb290JiZcblwic2xvdFwiIT09Yi5sb2NhbE5hbWV8fGY9PT1CLnBhcmVudE5vZGUoYikpJiZBLnJlbW92ZUNoaWxkLmNhbGwoZixiKSk7QmMoYSxudWxsLGIpO3JldHVybiBifWZ1bmN0aW9uIENjKGEpe2lmKGEuX19zaGFkeSYmdm9pZCAwIT09YS5fX3NoYWR5LmthKWZvcih2YXIgYj1hLmNoaWxkTm9kZXMsYz0wLGQ9Yi5sZW5ndGgsZTtjPGQmJihlPWJbY10pO2MrKylDYyhlKTthLl9fc2hhZHkmJihhLl9fc2hhZHkua2E9dm9pZCAwKX1mdW5jdGlvbiBBYyhhKXt2YXIgYj1hO2EmJlwic2xvdFwiPT09YS5sb2NhbE5hbWUmJihiPShiPWEuX19zaGFkeSYmYS5fX3NoYWR5LkspJiZiLmxlbmd0aD9iWzBdOkFjKGEubmV4dFNpYmxpbmcpKTtyZXR1cm4gYn1mdW5jdGlvbiB6YyhhKXtyZXR1cm4oYT1hJiZhLl9fc2hhZHkmJmEuX19zaGFkeS5yb290KSYmRWMoYSl9XG5mdW5jdGlvbiBGYyhhLGIpe2lmKFwic2xvdFwiPT09YilhPWEucGFyZW50Tm9kZSx6YyhhKSYmeWMoYS5fX3NoYWR5LnJvb3QpO2Vsc2UgaWYoXCJzbG90XCI9PT1hLmxvY2FsTmFtZSYmXCJuYW1lXCI9PT1iJiYoYj1yYihhKSkpe3ZhciBjPWEuQ2EsZD1HYyhhKTtpZihkIT09Yyl7Yz1iLmxbY107dmFyIGU9Yy5pbmRleE9mKGEpOzA8PWUmJmMuc3BsaWNlKGUsMSk7Yz1iLmxbZF18fChiLmxbZF09W10pO2MucHVzaChhKTsxPGMubGVuZ3RoJiYoYi5sW2RdPUhjKGMpKX15YyhiKX19ZnVuY3Rpb24gQmMoYSxiLGMpe2lmKGE9YS5fX3NoYWR5JiZhLl9fc2hhZHkuTiliJiZhLmFkZGVkTm9kZXMucHVzaChiKSxjJiZhLnJlbW92ZWROb2Rlcy5wdXNoKGMpLEliKGEpfVxuZnVuY3Rpb24gSWMoYSl7aWYoYSYmYS5ub2RlVHlwZSl7YS5fX3NoYWR5PWEuX19zaGFkeXx8e307dmFyIGI9YS5fX3NoYWR5LmthO3ZvaWQgMD09PWImJih6KGEpP2I9YTpiPShiPWEucGFyZW50Tm9kZSk/SWMoYik6YSxBLmNvbnRhaW5zLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGEpJiYoYS5fX3NoYWR5LmthPWIpKTtyZXR1cm4gYn19ZnVuY3Rpb24gSmMoYSxiLGMpe3ZhciBkPVtdO0tjKGEuY2hpbGROb2RlcyxiLGMsZCk7cmV0dXJuIGR9ZnVuY3Rpb24gS2MoYSxiLGMsZCl7Zm9yKHZhciBlPTAsZj1hLmxlbmd0aCxoO2U8ZiYmKGg9YVtlXSk7ZSsrKXt2YXIgZztpZihnPWgubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSl7Zz1oO3ZhciBrPWIsbD1jLG09ZCxuPWsoZyk7biYmbS5wdXNoKGcpO2wmJmwobik/Zz1uOihLYyhnLmNoaWxkTm9kZXMsayxsLG0pLGc9dm9pZCAwKX1pZihnKWJyZWFrfX12YXIgTGM9bnVsbDtcbmZ1bmN0aW9uIE1jKGEsYixjKXtMY3x8KExjPXdpbmRvdy5TaGFkeUNTUyYmd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltKTtMYyYmXCJjbGFzc1wiPT09Yj9MYy5zZXRFbGVtZW50Q2xhc3MoYSxjKTooQS5zZXRBdHRyaWJ1dGUuY2FsbChhLGIsYyksRmMoYSxiKSl9ZnVuY3Rpb24gTmMoYSxiKXtpZihhLm93bmVyRG9jdW1lbnQhPT1kb2N1bWVudClyZXR1cm4gQS5pbXBvcnROb2RlLmNhbGwoZG9jdW1lbnQsYSxiKTt2YXIgYz1BLmltcG9ydE5vZGUuY2FsbChkb2N1bWVudCxhLCExKTtpZihiKXthPWEuY2hpbGROb2RlcztiPTA7Zm9yKHZhciBkO2I8YS5sZW5ndGg7YisrKWQ9TmMoYVtiXSwhMCksYy5hcHBlbmRDaGlsZChkKX1yZXR1cm4gY307dmFyIE9jPVwiX19ldmVudFdyYXBwZXJzXCIrRGF0ZS5ub3coKSxQYz17Ymx1cjohMCxmb2N1czohMCxmb2N1c2luOiEwLGZvY3Vzb3V0OiEwLGNsaWNrOiEwLGRibGNsaWNrOiEwLG1vdXNlZG93bjohMCxtb3VzZWVudGVyOiEwLG1vdXNlbGVhdmU6ITAsbW91c2Vtb3ZlOiEwLG1vdXNlb3V0OiEwLG1vdXNlb3ZlcjohMCxtb3VzZXVwOiEwLHdoZWVsOiEwLGJlZm9yZWlucHV0OiEwLGlucHV0OiEwLGtleWRvd246ITAsa2V5dXA6ITAsY29tcG9zaXRpb25zdGFydDohMCxjb21wb3NpdGlvbnVwZGF0ZTohMCxjb21wb3NpdGlvbmVuZDohMCx0b3VjaHN0YXJ0OiEwLHRvdWNoZW5kOiEwLHRvdWNobW92ZTohMCx0b3VjaGNhbmNlbDohMCxwb2ludGVyb3ZlcjohMCxwb2ludGVyZW50ZXI6ITAscG9pbnRlcmRvd246ITAscG9pbnRlcm1vdmU6ITAscG9pbnRlcnVwOiEwLHBvaW50ZXJjYW5jZWw6ITAscG9pbnRlcm91dDohMCxwb2ludGVybGVhdmU6ITAsZ290cG9pbnRlcmNhcHR1cmU6ITAsbG9zdHBvaW50ZXJjYXB0dXJlOiEwLFxuZHJhZ3N0YXJ0OiEwLGRyYWc6ITAsZHJhZ2VudGVyOiEwLGRyYWdsZWF2ZTohMCxkcmFnb3ZlcjohMCxkcm9wOiEwLGRyYWdlbmQ6ITAsRE9NQWN0aXZhdGU6ITAsRE9NRm9jdXNJbjohMCxET01Gb2N1c091dDohMCxrZXlwcmVzczohMH07ZnVuY3Rpb24gUWMoYSxiKXt2YXIgYz1bXSxkPWE7Zm9yKGE9YT09PXdpbmRvdz93aW5kb3c6YS5nZXRSb290Tm9kZSgpO2Q7KWMucHVzaChkKSxkPWQuYXNzaWduZWRTbG90P2QuYXNzaWduZWRTbG90OmQubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUmJmQuaG9zdCYmKGJ8fGQhPT1hKT9kLmhvc3Q6ZC5wYXJlbnROb2RlO2NbYy5sZW5ndGgtMV09PT1kb2N1bWVudCYmYy5wdXNoKHdpbmRvdyk7cmV0dXJuIGN9XG5mdW5jdGlvbiBSYyhhLGIpe2lmKCF6KXJldHVybiBhO2E9UWMoYSwhMCk7Zm9yKHZhciBjPTAsZCxlLGYsaDtjPGIubGVuZ3RoO2MrKylpZihkPWJbY10sZj1kPT09d2luZG93P3dpbmRvdzpkLmdldFJvb3ROb2RlKCksZiE9PWUmJihoPWEuaW5kZXhPZihmKSxlPWYpLCF6KGYpfHwtMTxoKXJldHVybiBkfVxudmFyIFNjPXtnZXQgY29tcG9zZWQoKXshMSE9PXRoaXMuaXNUcnVzdGVkJiZ2b2lkIDA9PT10aGlzLlomJih0aGlzLlo9UGNbdGhpcy50eXBlXSk7cmV0dXJuIHRoaXMuWnx8ITF9LGNvbXBvc2VkUGF0aDpmdW5jdGlvbigpe3RoaXMubmF8fCh0aGlzLm5hPVFjKHRoaXMuX190YXJnZXQsdGhpcy5jb21wb3NlZCkpO3JldHVybiB0aGlzLm5hfSxnZXQgdGFyZ2V0KCl7cmV0dXJuIFJjKHRoaXMuY3VycmVudFRhcmdldCx0aGlzLmNvbXBvc2VkUGF0aCgpKX0sZ2V0IHJlbGF0ZWRUYXJnZXQoKXtpZighdGhpcy5hYSlyZXR1cm4gbnVsbDt0aGlzLm9hfHwodGhpcy5vYT1RYyh0aGlzLmFhLCEwKSk7cmV0dXJuIFJjKHRoaXMuY3VycmVudFRhcmdldCx0aGlzLm9hKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7RXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO3RoaXMuJD0hMH0sc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7RXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO1xudGhpcy4kPXRoaXMueWE9ITB9fTtmdW5jdGlvbiBUYyhhKXtmdW5jdGlvbiBiKGIsZCl7Yj1uZXcgYShiLGQpO2IuWj1kJiYhIWQuY29tcG9zZWQ7cmV0dXJuIGJ9d2IoYixhKTtiLnByb3RvdHlwZT1hLnByb3RvdHlwZTtyZXR1cm4gYn12YXIgVWM9e2ZvY3VzOiEwLGJsdXI6ITB9O2Z1bmN0aW9uIFZjKGEpe3JldHVybiBhLl9fdGFyZ2V0IT09YS50YXJnZXR8fGEuYWEhPT1hLnJlbGF0ZWRUYXJnZXR9ZnVuY3Rpb24gV2MoYSxiLGMpe2lmKGM9Yi5fX2hhbmRsZXJzJiZiLl9faGFuZGxlcnNbYS50eXBlXSYmYi5fX2hhbmRsZXJzW2EudHlwZV1bY10pZm9yKHZhciBkPTAsZTsoZT1jW2RdKSYmKCFWYyhhKXx8YS50YXJnZXQhPT1hLnJlbGF0ZWRUYXJnZXQpJiYoZS5jYWxsKGIsYSksIWEueWEpO2QrKyk7fVxuZnVuY3Rpb24gWGMoYSl7dmFyIGI9YS5jb21wb3NlZFBhdGgoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImN1cnJlbnRUYXJnZXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGR9LGNvbmZpZ3VyYWJsZTohMH0pO2Zvcih2YXIgYz1iLmxlbmd0aC0xOzA8PWM7Yy0tKXt2YXIgZD1iW2NdO1djKGEsZCxcImNhcHR1cmVcIik7aWYoYS4kKXJldHVybn1PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImV2ZW50UGhhc2VcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEV2ZW50LkFUX1RBUkdFVH19KTt2YXIgZTtmb3IoYz0wO2M8Yi5sZW5ndGg7YysrKXtkPWJbY107dmFyIGY9ZC5fX3NoYWR5JiZkLl9fc2hhZHkucm9vdDtpZigwPT09Y3x8ZiYmZj09PWUpaWYoV2MoYSxkLFwiYnViYmxlXCIpLGQhPT13aW5kb3cmJihlPWQuZ2V0Um9vdE5vZGUoKSksYS4kKWJyZWFrfX1cbmZ1bmN0aW9uIFljKGEsYixjLGQsZSxmKXtmb3IodmFyIGg9MDtoPGEubGVuZ3RoO2grKyl7dmFyIGc9YVtoXSxrPWcudHlwZSxsPWcuY2FwdHVyZSxtPWcub25jZSxuPWcucGFzc2l2ZTtpZihiPT09Zy5ub2RlJiZjPT09ayYmZD09PWwmJmU9PT1tJiZmPT09bilyZXR1cm4gaH1yZXR1cm4tMX1cbmZ1bmN0aW9uIFpjKGEsYixjKXtpZihiKXtpZihjJiZcIm9iamVjdFwiPT09dHlwZW9mIGMpe3ZhciBkPSEhYy5jYXB0dXJlO3ZhciBlPSEhYy5vbmNlO3ZhciBmPSEhYy5wYXNzaXZlfWVsc2UgZD0hIWMsZj1lPSExO3ZhciBoPWMmJmMuYmF8fHRoaXMsZz1iW09jXTtpZihnKXtpZigtMTxZYyhnLGgsYSxkLGUsZikpcmV0dXJufWVsc2UgYltPY109W107Zz1mdW5jdGlvbihkKXtlJiZ0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxiLGMpO2QuX190YXJnZXR8fCRjKGQpO2lmKGghPT10aGlzKXt2YXIgZj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGQsXCJjdXJyZW50VGFyZ2V0XCIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShkLFwiY3VycmVudFRhcmdldFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaH0sY29uZmlndXJhYmxlOiEwfSl9aWYoZC5jb21wb3NlZHx8LTE8ZC5jb21wb3NlZFBhdGgoKS5pbmRleE9mKGgpKWlmKFZjKGQpJiZkLnRhcmdldD09PWQucmVsYXRlZFRhcmdldClkLmV2ZW50UGhhc2U9PT1cbkV2ZW50LkJVQkJMSU5HX1BIQVNFJiZkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO2Vsc2UgaWYoZC5ldmVudFBoYXNlPT09RXZlbnQuQ0FQVFVSSU5HX1BIQVNFfHxkLmJ1YmJsZXN8fGQudGFyZ2V0PT09aHx8aCBpbnN0YW5jZW9mIFdpbmRvdyl7dmFyIGc9XCJvYmplY3RcIj09PXR5cGVvZiBiJiZiLmhhbmRsZUV2ZW50P2IuaGFuZGxlRXZlbnQoZCk6Yi5jYWxsKGgsZCk7aCE9PXRoaXMmJihmPyhPYmplY3QuZGVmaW5lUHJvcGVydHkoZCxcImN1cnJlbnRUYXJnZXRcIixmKSxmPW51bGwpOmRlbGV0ZSBkLmN1cnJlbnRUYXJnZXQpO3JldHVybiBnfX07YltPY10ucHVzaCh7bm9kZTp0aGlzLHR5cGU6YSxjYXB0dXJlOmQsb25jZTplLHBhc3NpdmU6ZixjYjpnfSk7VWNbYV0/KHRoaXMuX19oYW5kbGVycz10aGlzLl9faGFuZGxlcnN8fHt9LHRoaXMuX19oYW5kbGVyc1thXT10aGlzLl9faGFuZGxlcnNbYV18fHtjYXB0dXJlOltdLGJ1YmJsZTpbXX0sdGhpcy5fX2hhbmRsZXJzW2FdW2Q/XG5cImNhcHR1cmVcIjpcImJ1YmJsZVwiXS5wdXNoKGcpKToodGhpcyBpbnN0YW5jZW9mIFdpbmRvdz9BLmFiOkEuYWRkRXZlbnRMaXN0ZW5lcikuY2FsbCh0aGlzLGEsZyxjKX19XG5mdW5jdGlvbiBhZChhLGIsYyl7aWYoYil7aWYoYyYmXCJvYmplY3RcIj09PXR5cGVvZiBjKXt2YXIgZD0hIWMuY2FwdHVyZTt2YXIgZT0hIWMub25jZTt2YXIgZj0hIWMucGFzc2l2ZX1lbHNlIGQ9ISFjLGY9ZT0hMTt2YXIgaD1jJiZjLmJhfHx0aGlzLGc9dm9pZCAwO3ZhciBrPW51bGw7dHJ5e2s9YltPY119Y2F0Y2gobCl7fWsmJihlPVljKGssaCxhLGQsZSxmKSwtMTxlJiYoZz1rLnNwbGljZShlLDEpWzBdLmNiLGsubGVuZ3RofHwoYltPY109dm9pZCAwKSkpOyh0aGlzIGluc3RhbmNlb2YgV2luZG93P0EuYmI6QS5yZW1vdmVFdmVudExpc3RlbmVyKS5jYWxsKHRoaXMsYSxnfHxiLGMpO2cmJlVjW2FdJiZ0aGlzLl9faGFuZGxlcnMmJnRoaXMuX19oYW5kbGVyc1thXSYmKGE9dGhpcy5fX2hhbmRsZXJzW2FdW2Q/XCJjYXB0dXJlXCI6XCJidWJibGVcIl0sZz1hLmluZGV4T2YoZyksLTE8ZyYmYS5zcGxpY2UoZywxKSl9fVxuZnVuY3Rpb24gYmQoKXtmb3IodmFyIGEgaW4gVWMpd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYSxmdW5jdGlvbihhKXthLl9fdGFyZ2V0fHwoJGMoYSksWGMoYSkpfSwhMCl9ZnVuY3Rpb24gJGMoYSl7YS5fX3RhcmdldD1hLnRhcmdldDthLmFhPWEucmVsYXRlZFRhcmdldDtpZih5Lk0pe3ZhciBiPU9iamVjdC5nZXRQcm90b3R5cGVPZihhKTtpZighYi5oYXNPd25Qcm9wZXJ0eShcIl9fcGF0Y2hQcm90b1wiKSl7dmFyIGM9T2JqZWN0LmNyZWF0ZShiKTtjLmZiPWI7dWIoYyxTYyk7Yi5fX3BhdGNoUHJvdG89Y31hLl9fcHJvdG9fXz1iLl9fcGF0Y2hQcm90b31lbHNlIHViKGEsU2MpfXZhciBjZD1UYyh3aW5kb3cuRXZlbnQpLGRkPVRjKHdpbmRvdy5DdXN0b21FdmVudCksZWQ9VGMod2luZG93Lk1vdXNlRXZlbnQpO2Z1bmN0aW9uIGZkKGEsYil7cmV0dXJue2luZGV4OmEsTzpbXSxVOmJ9fVxuZnVuY3Rpb24gZ2QoYSxiLGMsZCl7dmFyIGU9MCxmPTAsaD0wLGc9MCxrPU1hdGgubWluKGItZSxkLWYpO2lmKDA9PWUmJjA9PWYpYTp7Zm9yKGg9MDtoPGs7aCsrKWlmKGFbaF0hPT1jW2hdKWJyZWFrIGE7aD1rfWlmKGI9PWEubGVuZ3RoJiZkPT1jLmxlbmd0aCl7Zz1hLmxlbmd0aDtmb3IodmFyIGw9Yy5sZW5ndGgsbT0wO208ay1oJiZoZChhWy0tZ10sY1stLWxdKTspbSsrO2c9bX1lKz1oO2YrPWg7Yi09ZztkLT1nO2lmKDA9PWItZSYmMD09ZC1mKXJldHVybltdO2lmKGU9PWIpe2ZvcihiPWZkKGUsMCk7ZjxkOyliLk8ucHVzaChjW2YrK10pO3JldHVybltiXX1pZihmPT1kKXJldHVybltmZChlLGItZSldO2s9ZTtoPWY7ZD1kLWgrMTtnPWItaysxO2I9QXJyYXkoZCk7Zm9yKGw9MDtsPGQ7bCsrKWJbbF09QXJyYXkoZyksYltsXVswXT1sO2ZvcihsPTA7bDxnO2wrKyliWzBdW2xdPWw7Zm9yKGw9MTtsPGQ7bCsrKWZvcihtPTE7bTxnO20rKylpZihhW2srbS0xXT09PWNbaCtsLTFdKWJbbF1bbV09XG5iW2wtMV1bbS0xXTtlbHNle3ZhciBuPWJbbC0xXVttXSsxLHc9YltsXVttLTFdKzE7YltsXVttXT1uPHc/bjp3fWs9Yi5sZW5ndGgtMTtoPWJbMF0ubGVuZ3RoLTE7ZD1iW2tdW2hdO2ZvcihhPVtdOzA8a3x8MDxoOykwPT1rPyhhLnB1c2goMiksaC0tKTowPT1oPyhhLnB1c2goMyksay0tKTooZz1iW2stMV1baC0xXSxsPWJbay0xXVtoXSxtPWJba11baC0xXSxuPWw8bT9sPGc/bDpnOm08Zz9tOmcsbj09Zz8oZz09ZD9hLnB1c2goMCk6KGEucHVzaCgxKSxkPWcpLGstLSxoLS0pOm49PWw/KGEucHVzaCgzKSxrLS0sZD1sKTooYS5wdXNoKDIpLGgtLSxkPW0pKTthLnJldmVyc2UoKTtiPXZvaWQgMDtrPVtdO2ZvcihoPTA7aDxhLmxlbmd0aDtoKyspc3dpdGNoKGFbaF0pe2Nhc2UgMDpiJiYoay5wdXNoKGIpLGI9dm9pZCAwKTtlKys7ZisrO2JyZWFrO2Nhc2UgMTpifHwoYj1mZChlLDApKTtiLlUrKztlKys7Yi5PLnB1c2goY1tmXSk7ZisrO2JyZWFrO2Nhc2UgMjpifHwoYj1mZChlLDApKTtcbmIuVSsrO2UrKzticmVhaztjYXNlIDM6Ynx8KGI9ZmQoZSwwKSksYi5PLnB1c2goY1tmXSksZisrfWImJmsucHVzaChiKTtyZXR1cm4ga31mdW5jdGlvbiBoZChhLGIpe3JldHVybiBhPT09Yn07dmFyIGlkPXt9O2Z1bmN0aW9uIEcoYSxiLGMpe2lmKGEhPT1pZCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjb25zdHJ1Y3RvclwiKTthPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTthLl9fcHJvdG9fXz1HLnByb3RvdHlwZTthLkFhPVwiU2hhZHlSb290XCI7dmMoYik7dmMoYSk7YS5ob3N0PWI7YS5hPWMmJmMubW9kZTtiLl9fc2hhZHk9Yi5fX3NoYWR5fHx7fTtiLl9fc2hhZHkucm9vdD1hO2IuX19zaGFkeS5VYT1cImNsb3NlZFwiIT09YS5hP2E6bnVsbDthLlQ9ITE7YS5zPVtdO2EubD17fTthLkg9W107Yz1CLmNoaWxkTm9kZXMoYik7Zm9yKHZhciBkPTAsZT1jLmxlbmd0aDtkPGU7ZCsrKUEucmVtb3ZlQ2hpbGQuY2FsbChiLGNbZF0pO3JldHVybiBhfUcucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUpO2Z1bmN0aW9uIHljKGEpe2EuVHx8KGEuVD0hMCxGYihmdW5jdGlvbigpe3JldHVybiBqZChhKX0pKX1cbmZ1bmN0aW9uIGpkKGEpe2Zvcih2YXIgYjthOyl7YS5UJiYoYj1hKTthOnt2YXIgYz1hO2E9Yy5ob3N0LmdldFJvb3ROb2RlKCk7aWYoeihhKSlmb3IodmFyIGQ9Yy5ob3N0LmNoaWxkTm9kZXMsZT0wO2U8ZC5sZW5ndGg7ZSsrKWlmKGM9ZFtlXSxcInNsb3RcIj09Yy5sb2NhbE5hbWUpYnJlYWsgYTthPXZvaWQgMH19YiYmYi5fcmVuZGVyUm9vdCgpfVxuRy5wcm90b3R5cGUuX3JlbmRlclJvb3Q9ZnVuY3Rpb24oKXt0aGlzLlQ9ITE7RGModGhpcyk7Zm9yKHZhciBhPTAsYjthPHRoaXMucy5sZW5ndGg7YSsrKXtiPXRoaXMuc1thXTt2YXIgYz1iLl9fc2hhZHkuYXNzaWduZWROb2RlcztiLl9fc2hhZHkuYXNzaWduZWROb2Rlcz1bXTtiLl9fc2hhZHkuSz1bXTtpZihiLl9fc2hhZHkucWE9Yylmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtlLl9fc2hhZHkuZ2E9ZS5fX3NoYWR5LmFzc2lnbmVkU2xvdDtlLl9fc2hhZHkuYXNzaWduZWRTbG90PT09YiYmKGUuX19zaGFkeS5hc3NpZ25lZFNsb3Q9bnVsbCl9fWZvcihiPXRoaXMuaG9zdC5maXJzdENoaWxkO2I7Yj1iLm5leHRTaWJsaW5nKWtkKHRoaXMsYik7Zm9yKGE9MDthPHRoaXMucy5sZW5ndGg7YSsrKXtiPXRoaXMuc1thXTtpZighYi5fX3NoYWR5LmFzc2lnbmVkTm9kZXMubGVuZ3RoKWZvcihjPWIuZmlyc3RDaGlsZDtjO2M9Yy5uZXh0U2libGluZylrZCh0aGlzLFxuYyxiKTtjPWIucGFyZW50Tm9kZTsoYz1jLl9fc2hhZHkmJmMuX19zaGFkeS5yb290KSYmRWMoYykmJmMuX3JlbmRlclJvb3QoKTtsZCh0aGlzLGIuX19zaGFkeS5LLGIuX19zaGFkeS5hc3NpZ25lZE5vZGVzKTtpZihjPWIuX19zaGFkeS5xYSl7Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLl9fc2hhZHkuZ2E9bnVsbDtiLl9fc2hhZHkucWE9bnVsbDtjLmxlbmd0aD5iLl9fc2hhZHkuYXNzaWduZWROb2Rlcy5sZW5ndGgmJihiLl9fc2hhZHkuaWE9ITApfWIuX19zaGFkeS5pYSYmKGIuX19zaGFkeS5pYT0hMSxtZCh0aGlzLGIpKX1hPXRoaXMucztiPVtdO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspZD1hW2NdLnBhcmVudE5vZGUsZC5fX3NoYWR5JiZkLl9fc2hhZHkucm9vdHx8ISgwPmIuaW5kZXhPZihkKSl8fGIucHVzaChkKTtmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKXtjPWJbYV07ZD1jPT09dGhpcz90aGlzLmhvc3Q6YztlPVtdO2M9Yy5jaGlsZE5vZGVzO2Zvcih2YXIgZj0wO2Y8XG5jLmxlbmd0aDtmKyspe3ZhciBoPWNbZl07aWYoXCJzbG90XCI9PWgubG9jYWxOYW1lKXtoPWguX19zaGFkeS5LO2Zvcih2YXIgZz0wO2c8aC5sZW5ndGg7ZysrKWUucHVzaChoW2ddKX1lbHNlIGUucHVzaChoKX1jPXZvaWQgMDtmPUIuY2hpbGROb2RlcyhkKTtoPWdkKGUsZS5sZW5ndGgsZixmLmxlbmd0aCk7Zm9yKHZhciBrPWc9MDtnPGgubGVuZ3RoJiYoYz1oW2ddKTtnKyspe2Zvcih2YXIgbD0wLG07bDxjLk8ubGVuZ3RoJiYobT1jLk9bbF0pO2wrKylCLnBhcmVudE5vZGUobSk9PT1kJiZBLnJlbW92ZUNoaWxkLmNhbGwoZCxtKSxmLnNwbGljZShjLmluZGV4K2ssMSk7ay09Yy5VfWZvcihrPTA7azxoLmxlbmd0aCYmKGM9aFtrXSk7aysrKWZvcihnPWZbYy5pbmRleF0sbD1jLmluZGV4O2w8Yy5pbmRleCtjLlU7bCsrKW09ZVtsXSxBLmluc2VydEJlZm9yZS5jYWxsKGQsbSxnKSxmLnNwbGljZShsLDAsbSl9fTtcbmZ1bmN0aW9uIGtkKGEsYixjKXtiLl9fc2hhZHk9Yi5fX3NoYWR5fHx7fTt2YXIgZD1iLl9fc2hhZHkuZ2E7Yi5fX3NoYWR5LmdhPW51bGw7Y3x8KGM9KGE9YS5sW2Iuc2xvdHx8XCJfX2NhdGNoYWxsXCJdKSYmYVswXSk7Yz8oYy5fX3NoYWR5LmFzc2lnbmVkTm9kZXMucHVzaChiKSxiLl9fc2hhZHkuYXNzaWduZWRTbG90PWMpOmIuX19zaGFkeS5hc3NpZ25lZFNsb3Q9dm9pZCAwO2QhPT1iLl9fc2hhZHkuYXNzaWduZWRTbG90JiZiLl9fc2hhZHkuYXNzaWduZWRTbG90JiYoYi5fX3NoYWR5LmFzc2lnbmVkU2xvdC5fX3NoYWR5LmlhPSEwKX1mdW5jdGlvbiBsZChhLGIsYyl7Zm9yKHZhciBkPTAsZTtkPGMubGVuZ3RoJiYoZT1jW2RdKTtkKyspaWYoXCJzbG90XCI9PWUubG9jYWxOYW1lKXt2YXIgZj1lLl9fc2hhZHkuYXNzaWduZWROb2RlcztmJiZmLmxlbmd0aCYmbGQoYSxiLGYpfWVsc2UgYi5wdXNoKGNbZF0pfVxuZnVuY3Rpb24gbWQoYSxiKXtBLmRpc3BhdGNoRXZlbnQuY2FsbChiLG5ldyBFdmVudChcInNsb3RjaGFuZ2VcIikpO2IuX19zaGFkeS5hc3NpZ25lZFNsb3QmJm1kKGEsYi5fX3NoYWR5LmFzc2lnbmVkU2xvdCl9ZnVuY3Rpb24gRGMoYSl7aWYoYS5ILmxlbmd0aCl7Zm9yKHZhciBiPWEuSCxjLGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXTtlLl9fc2hhZHk9ZS5fX3NoYWR5fHx7fTt2YyhlKTt2YyhlLnBhcmVudE5vZGUpO3ZhciBmPUdjKGUpO2EubFtmXT8oYz1jfHx7fSxjW2ZdPSEwLGEubFtmXS5wdXNoKGUpKTphLmxbZl09W2VdO2Eucy5wdXNoKGUpfWlmKGMpZm9yKHZhciBoIGluIGMpYS5sW2hdPUhjKGEubFtoXSk7YS5IPVtdfX1mdW5jdGlvbiBHYyhhKXt2YXIgYj1hLm5hbWV8fGEuZ2V0QXR0cmlidXRlKFwibmFtZVwiKXx8XCJfX2NhdGNoYWxsXCI7cmV0dXJuIGEuQ2E9Yn1cbmZ1bmN0aW9uIEhjKGEpe3JldHVybiBhLnNvcnQoZnVuY3Rpb24oYSxjKXthPW5kKGEpO2Zvcih2YXIgYj1uZChjKSxlPTA7ZTxhLmxlbmd0aDtlKyspe2M9YVtlXTt2YXIgZj1iW2VdO2lmKGMhPT1mKXJldHVybiBhPUFycmF5LmZyb20oYy5wYXJlbnROb2RlLmNoaWxkTm9kZXMpLGEuaW5kZXhPZihjKS1hLmluZGV4T2YoZil9fSl9ZnVuY3Rpb24gbmQoYSl7dmFyIGI9W107ZG8gYi51bnNoaWZ0KGEpO3doaWxlKGE9YS5wYXJlbnROb2RlKTtyZXR1cm4gYn1mdW5jdGlvbiBFYyhhKXtEYyhhKTtyZXR1cm4hIWEucy5sZW5ndGh9Ry5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIsYyl7XCJvYmplY3RcIiE9PXR5cGVvZiBjJiYoYz17Y2FwdHVyZTohIWN9KTtjLmJhPXRoaXM7dGhpcy5ob3N0LmFkZEV2ZW50TGlzdGVuZXIoYSxiLGMpfTtcbkcucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiLGMpe1wib2JqZWN0XCIhPT10eXBlb2YgYyYmKGM9e2NhcHR1cmU6ISFjfSk7Yy5iYT10aGlzO3RoaXMuaG9zdC5yZW1vdmVFdmVudExpc3RlbmVyKGEsYixjKX07Ry5wcm90b3R5cGUuZ2V0RWxlbWVudEJ5SWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIEpjKHRoaXMsZnVuY3Rpb24oYil7cmV0dXJuIGIuaWQ9PWF9LGZ1bmN0aW9uKGEpe3JldHVybiEhYX0pWzBdfHxudWxsfTt2YXIgb2Q9Ry5wcm90b3R5cGU7RShvZCxtYywhMCk7RShvZCxyYywhMCk7ZnVuY3Rpb24gcGQoYSl7dmFyIGI9YS5nZXRSb290Tm9kZSgpO3ooYikmJmpkKGIpO3JldHVybiBhLl9fc2hhZHkmJmEuX19zaGFkeS5hc3NpZ25lZFNsb3R8fG51bGx9XG52YXIgcWQ9e2FkZEV2ZW50TGlzdGVuZXI6WmMuYmluZCh3aW5kb3cpLHJlbW92ZUV2ZW50TGlzdGVuZXI6YWQuYmluZCh3aW5kb3cpfSxyZD17YWRkRXZlbnRMaXN0ZW5lcjpaYyxyZW1vdmVFdmVudExpc3RlbmVyOmFkLGFwcGVuZENoaWxkOmZ1bmN0aW9uKGEpe3JldHVybiB3Yyh0aGlzLGEpfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gd2ModGhpcyxhLGIpfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihhKXtyZXR1cm4geGModGhpcyxhKX0scmVwbGFjZUNoaWxkOmZ1bmN0aW9uKGEsYil7d2ModGhpcyxhLGIpO3hjKHRoaXMsYik7cmV0dXJuIGF9LGNsb25lTm9kZTpmdW5jdGlvbihhKXtpZihcInRlbXBsYXRlXCI9PXRoaXMubG9jYWxOYW1lKXZhciBiPUEuY2xvbmVOb2RlLmNhbGwodGhpcyxhKTtlbHNlIGlmKGI9QS5jbG9uZU5vZGUuY2FsbCh0aGlzLCExKSxhKXthPXRoaXMuY2hpbGROb2Rlcztmb3IodmFyIGM9MCxkO2M8YS5sZW5ndGg7YysrKWQ9YVtjXS5jbG9uZU5vZGUoITApLFxuYi5hcHBlbmRDaGlsZChkKX1yZXR1cm4gYn0sZ2V0Um9vdE5vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gSWModGhpcyl9LGNvbnRhaW5zOmZ1bmN0aW9uKGEpe3JldHVybiBDYih0aGlzLGEpfSxnZXQgaXNDb25uZWN0ZWQoKXt2YXIgYT10aGlzLm93bmVyRG9jdW1lbnQ7aWYoQmImJkEuY29udGFpbnMuY2FsbChhLHRoaXMpfHxhLmRvY3VtZW50RWxlbWVudCYmQS5jb250YWlucy5jYWxsKGEuZG9jdW1lbnRFbGVtZW50LHRoaXMpKXJldHVybiEwO2ZvcihhPXRoaXM7YSYmIShhIGluc3RhbmNlb2YgRG9jdW1lbnQpOylhPWEucGFyZW50Tm9kZXx8KGEgaW5zdGFuY2VvZiBHP2EuaG9zdDp2b2lkIDApO3JldHVybiEhKGEmJmEgaW5zdGFuY2VvZiBEb2N1bWVudCl9LGRpc3BhdGNoRXZlbnQ6ZnVuY3Rpb24oYSl7R2IoKTtyZXR1cm4gQS5kaXNwYXRjaEV2ZW50LmNhbGwodGhpcyxhKX19LHNkPXtnZXQgYXNzaWduZWRTbG90KCl7cmV0dXJuIHBkKHRoaXMpfX0sdGQ9e3F1ZXJ5U2VsZWN0b3I6ZnVuY3Rpb24oYSl7cmV0dXJuIEpjKHRoaXMsXG5mdW5jdGlvbihiKXtyZXR1cm4gdGIuY2FsbChiLGEpfSxmdW5jdGlvbihhKXtyZXR1cm4hIWF9KVswXXx8bnVsbH0scXVlcnlTZWxlY3RvckFsbDpmdW5jdGlvbihhKXtyZXR1cm4gSmModGhpcyxmdW5jdGlvbihiKXtyZXR1cm4gdGIuY2FsbChiLGEpfSl9fSx1ZD17YXNzaWduZWROb2RlczpmdW5jdGlvbihhKXtpZihcInNsb3RcIj09PXRoaXMubG9jYWxOYW1lKXt2YXIgYj10aGlzLmdldFJvb3ROb2RlKCk7eihiKSYmamQoYik7cmV0dXJuIHRoaXMuX19zaGFkeT8oYSYmYS5mbGF0dGVuP3RoaXMuX19zaGFkeS5LOnRoaXMuX19zaGFkeS5hc3NpZ25lZE5vZGVzKXx8W106W119fX0sdmQ9dmIoe3NldEF0dHJpYnV0ZTpmdW5jdGlvbihhLGIpe01jKHRoaXMsYSxiKX0scmVtb3ZlQXR0cmlidXRlOmZ1bmN0aW9uKGEpe0EucmVtb3ZlQXR0cmlidXRlLmNhbGwodGhpcyxhKTtGYyh0aGlzLGEpfSxhdHRhY2hTaGFkb3c6ZnVuY3Rpb24oYSl7aWYoIXRoaXMpdGhyb3dcIk11c3QgcHJvdmlkZSBhIGhvc3QuXCI7XG5pZighYSl0aHJvd1wiTm90IGVub3VnaCBhcmd1bWVudHMuXCI7cmV0dXJuIG5ldyBHKGlkLHRoaXMsYSl9LGdldCBzbG90KCl7cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwic2xvdFwiKX0sc2V0IHNsb3QoYSl7TWModGhpcyxcInNsb3RcIixhKX0sZ2V0IGFzc2lnbmVkU2xvdCgpe3JldHVybiBwZCh0aGlzKX19LHRkLHVkKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh2ZCxxYyk7dmFyIHdkPXZiKHtpbXBvcnROb2RlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIE5jKGEsYil9LGdldEVsZW1lbnRCeUlkOmZ1bmN0aW9uKGEpe3JldHVybiBKYyh0aGlzLGZ1bmN0aW9uKGIpe3JldHVybiBiLmlkPT1hfSxmdW5jdGlvbihhKXtyZXR1cm4hIWF9KVswXXx8bnVsbH19LHRkKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3ZCx7X2FjdGl2ZUVsZW1lbnQ6cmMuYWN0aXZlRWxlbWVudH0pO1xudmFyIHhkPUhUTUxFbGVtZW50LnByb3RvdHlwZS5ibHVyLHlkPXZiKHtibHVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkucm9vdDsoYT1hJiZhLmFjdGl2ZUVsZW1lbnQpP2EuYmx1cigpOnhkLmNhbGwodGhpcyl9fSk7ZnVuY3Rpb24gSChhLGIpe2Zvcih2YXIgYz1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sZj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsZSk7Zi52YWx1ZT9hW2VdPWYudmFsdWU6T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZSxmKX19O2lmKHkudGEpe3ZhciBTaGFkeURPTT17aW5Vc2U6eS50YSxwYXRjaDpmdW5jdGlvbihhKXtyZXR1cm4gYX0saXNTaGFkeVJvb3Q6eixlbnF1ZXVlOkZiLGZsdXNoOkdiLHNldHRpbmdzOnksZmlsdGVyTXV0YXRpb25zOk1iLG9ic2VydmVDaGlsZHJlbjpLYix1bm9ic2VydmVDaGlsZHJlbjpMYixuYXRpdmVNZXRob2RzOkEsbmF0aXZlVHJlZTpCfTt3aW5kb3cuU2hhZHlET009U2hhZHlET007d2luZG93LkV2ZW50PWNkO3dpbmRvdy5DdXN0b21FdmVudD1kZDt3aW5kb3cuTW91c2VFdmVudD1lZDtiZCgpO3ZhciB6ZD13aW5kb3cuY3VzdG9tRWxlbWVudHMmJndpbmRvdy5jdXN0b21FbGVtZW50cy5uYXRpdmVIVE1MRWxlbWVudHx8SFRNTEVsZW1lbnQ7SCh3aW5kb3cuTm9kZS5wcm90b3R5cGUscmQpO0god2luZG93LldpbmRvdy5wcm90b3R5cGUscWQpO0god2luZG93LlRleHQucHJvdG90eXBlLHNkKTtIKHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSx0ZCk7SCh3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUsXG52ZCk7SCh3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLHdkKTt3aW5kb3cuSFRNTFNsb3RFbGVtZW50JiZIKHdpbmRvdy5IVE1MU2xvdEVsZW1lbnQucHJvdG90eXBlLHVkKTtIKHpkLnByb3RvdHlwZSx5ZCk7eS5NJiYoRih3aW5kb3cuTm9kZS5wcm90b3R5cGUpLEYod2luZG93LlRleHQucHJvdG90eXBlKSxGKHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSksRih3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUpLEYoemQucHJvdG90eXBlKSxGKHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUpLHdpbmRvdy5IVE1MU2xvdEVsZW1lbnQmJkYod2luZG93LkhUTUxTbG90RWxlbWVudC5wcm90b3R5cGUpKTt3aW5kb3cuU2hhZG93Um9vdD1HfTt2YXIgQWQ9bmV3IFNldChcImFubm90YXRpb24teG1sIGNvbG9yLXByb2ZpbGUgZm9udC1mYWNlIGZvbnQtZmFjZS1zcmMgZm9udC1mYWNlLXVyaSBmb250LWZhY2UtZm9ybWF0IGZvbnQtZmFjZS1uYW1lIG1pc3NpbmctZ2x5cGhcIi5zcGxpdChcIiBcIikpO2Z1bmN0aW9uIEJkKGEpe3ZhciBiPUFkLmhhcyhhKTthPS9eW2Etel1bLjAtOV9hLXpdKi1bXFwtLjAtOV9hLXpdKiQvLnRlc3QoYSk7cmV0dXJuIWImJmF9ZnVuY3Rpb24gSihhKXt2YXIgYj1hLmlzQ29ubmVjdGVkO2lmKHZvaWQgMCE9PWIpcmV0dXJuIGI7Zm9yKDthJiYhKGEuX19DRV9pc0ltcG9ydERvY3VtZW50fHxhIGluc3RhbmNlb2YgRG9jdW1lbnQpOylhPWEucGFyZW50Tm9kZXx8KHdpbmRvdy5TaGFkb3dSb290JiZhIGluc3RhbmNlb2YgU2hhZG93Um9vdD9hLmhvc3Q6dm9pZCAwKTtyZXR1cm4hKCFhfHwhKGEuX19DRV9pc0ltcG9ydERvY3VtZW50fHxhIGluc3RhbmNlb2YgRG9jdW1lbnQpKX1cbmZ1bmN0aW9uIENkKGEsYil7Zm9yKDtiJiZiIT09YSYmIWIubmV4dFNpYmxpbmc7KWI9Yi5wYXJlbnROb2RlO3JldHVybiBiJiZiIT09YT9iLm5leHRTaWJsaW5nOm51bGx9XG5mdW5jdGlvbiBLKGEsYixjKXtjPXZvaWQgMD09PWM/bmV3IFNldDpjO2Zvcih2YXIgZD1hO2Q7KXtpZihkLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBlPWQ7YihlKTt2YXIgZj1lLmxvY2FsTmFtZTtpZihcImxpbmtcIj09PWYmJlwiaW1wb3J0XCI9PT1lLmdldEF0dHJpYnV0ZShcInJlbFwiKSl7ZD1lLmltcG9ydDtpZihkIGluc3RhbmNlb2YgTm9kZSYmIWMuaGFzKGQpKWZvcihjLmFkZChkKSxkPWQuZmlyc3RDaGlsZDtkO2Q9ZC5uZXh0U2libGluZylLKGQsYixjKTtkPUNkKGEsZSk7Y29udGludWV9ZWxzZSBpZihcInRlbXBsYXRlXCI9PT1mKXtkPUNkKGEsZSk7Y29udGludWV9aWYoZT1lLl9fQ0Vfc2hhZG93Um9vdClmb3IoZT1lLmZpcnN0Q2hpbGQ7ZTtlPWUubmV4dFNpYmxpbmcpSyhlLGIsYyl9ZD1kLmZpcnN0Q2hpbGQ/ZC5maXJzdENoaWxkOkNkKGEsZCl9fWZ1bmN0aW9uIEwoYSxiLGMpe2FbYl09Y307ZnVuY3Rpb24gRGQoKXt0aGlzLmE9bmV3IE1hcDt0aGlzLm89bmV3IE1hcDt0aGlzLmg9W107dGhpcy5jPSExfWZ1bmN0aW9uIEVkKGEsYixjKXthLmEuc2V0KGIsYyk7YS5vLnNldChjLmNvbnN0cnVjdG9yLGMpfWZ1bmN0aW9uIEZkKGEsYil7YS5jPSEwO2EuaC5wdXNoKGIpfWZ1bmN0aW9uIEdkKGEsYil7YS5jJiZLKGIsZnVuY3Rpb24oYil7cmV0dXJuIGEuYihiKX0pfURkLnByb3RvdHlwZS5iPWZ1bmN0aW9uKGEpe2lmKHRoaXMuYyYmIWEuX19DRV9wYXRjaGVkKXthLl9fQ0VfcGF0Y2hlZD0hMDtmb3IodmFyIGI9MDtiPHRoaXMuaC5sZW5ndGg7YisrKXRoaXMuaFtiXShhKX19O2Z1bmN0aW9uIE0oYSxiKXt2YXIgYz1bXTtLKGIsZnVuY3Rpb24oYSl7cmV0dXJuIGMucHVzaChhKX0pO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspe3ZhciBkPWNbYl07MT09PWQuX19DRV9zdGF0ZT9hLmNvbm5lY3RlZENhbGxiYWNrKGQpOkhkKGEsZCl9fVxuZnVuY3Rpb24gTihhLGIpe3ZhciBjPVtdO0soYixmdW5jdGlvbihhKXtyZXR1cm4gYy5wdXNoKGEpfSk7Zm9yKGI9MDtiPGMubGVuZ3RoO2IrKyl7dmFyIGQ9Y1tiXTsxPT09ZC5fX0NFX3N0YXRlJiZhLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGQpfX1cbmZ1bmN0aW9uIE8oYSxiLGMpe2M9dm9pZCAwPT09Yz97fTpjO3ZhciBkPWMuJGF8fG5ldyBTZXQsZT1jLndhfHxmdW5jdGlvbihiKXtyZXR1cm4gSGQoYSxiKX0sZj1bXTtLKGIsZnVuY3Rpb24oYil7aWYoXCJsaW5rXCI9PT1iLmxvY2FsTmFtZSYmXCJpbXBvcnRcIj09PWIuZ2V0QXR0cmlidXRlKFwicmVsXCIpKXt2YXIgYz1iLmltcG9ydDtjIGluc3RhbmNlb2YgTm9kZSYmKGMuX19DRV9pc0ltcG9ydERvY3VtZW50PSEwLGMuX19DRV9oYXNSZWdpc3RyeT0hMCk7YyYmXCJjb21wbGV0ZVwiPT09Yy5yZWFkeVN0YXRlP2MuX19DRV9kb2N1bWVudExvYWRIYW5kbGVkPSEwOmIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbigpe3ZhciBjPWIuaW1wb3J0O2lmKCFjLl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCl7Yy5fX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQ9ITA7dmFyIGY9bmV3IFNldChkKTtmLmRlbGV0ZShjKTtPKGEsYyx7JGE6Zix3YTplfSl9fSl9ZWxzZSBmLnB1c2goYil9LGQpO2lmKGEuYylmb3IoYj1cbjA7YjxmLmxlbmd0aDtiKyspYS5iKGZbYl0pO2ZvcihiPTA7YjxmLmxlbmd0aDtiKyspZShmW2JdKX1cbmZ1bmN0aW9uIEhkKGEsYil7aWYodm9pZCAwPT09Yi5fX0NFX3N0YXRlKXt2YXIgYz1iLm93bmVyRG9jdW1lbnQ7aWYoYy5kZWZhdWx0Vmlld3x8Yy5fX0NFX2lzSW1wb3J0RG9jdW1lbnQmJmMuX19DRV9oYXNSZWdpc3RyeSlpZihjPWEuYS5nZXQoYi5sb2NhbE5hbWUpKXtjLmNvbnN0cnVjdGlvblN0YWNrLnB1c2goYik7dmFyIGQ9Yy5jb25zdHJ1Y3Rvcjt0cnl7dHJ5e2lmKG5ldyBkIT09Yil0aHJvdyBFcnJvcihcIlRoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvciBkaWQgbm90IHByb2R1Y2UgdGhlIGVsZW1lbnQgYmVpbmcgdXBncmFkZWQuXCIpO31maW5hbGx5e2MuY29uc3RydWN0aW9uU3RhY2sucG9wKCl9fWNhdGNoKGgpe3Rocm93IGIuX19DRV9zdGF0ZT0yLGg7fWIuX19DRV9zdGF0ZT0xO2IuX19DRV9kZWZpbml0aW9uPWM7aWYoYy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spZm9yKGM9Yy5vYnNlcnZlZEF0dHJpYnV0ZXMsZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLFxuZj1iLmdldEF0dHJpYnV0ZShlKTtudWxsIT09ZiYmYS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYixlLG51bGwsZixudWxsKX1KKGIpJiZhLmNvbm5lY3RlZENhbGxiYWNrKGIpfX19RGQucHJvdG90eXBlLmNvbm5lY3RlZENhbGxiYWNrPWZ1bmN0aW9uKGEpe3ZhciBiPWEuX19DRV9kZWZpbml0aW9uO2IuY29ubmVjdGVkQ2FsbGJhY2smJmIuY29ubmVjdGVkQ2FsbGJhY2suY2FsbChhKX07RGQucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrPWZ1bmN0aW9uKGEpe3ZhciBiPWEuX19DRV9kZWZpbml0aW9uO2IuZGlzY29ubmVjdGVkQ2FsbGJhY2smJmIuZGlzY29ubmVjdGVkQ2FsbGJhY2suY2FsbChhKX07XG5EZC5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YS5fX0NFX2RlZmluaXRpb247Zi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2smJi0xPGYub2JzZXJ2ZWRBdHRyaWJ1dGVzLmluZGV4T2YoYikmJmYuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwoYSxiLGMsZCxlKX07ZnVuY3Rpb24gSWQoYSl7dmFyIGI9ZG9jdW1lbnQ7dGhpcy5qPWE7dGhpcy5hPWI7dGhpcy5DPXZvaWQgMDtPKHRoaXMuaix0aGlzLmEpO1wibG9hZGluZ1wiPT09dGhpcy5hLnJlYWR5U3RhdGUmJih0aGlzLkM9bmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5iLmJpbmQodGhpcykpLHRoaXMuQy5vYnNlcnZlKHRoaXMuYSx7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9KSl9ZnVuY3Rpb24gSmQoYSl7YS5DJiZhLkMuZGlzY29ubmVjdCgpfUlkLnByb3RvdHlwZS5iPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYS5yZWFkeVN0YXRlO1wiaW50ZXJhY3RpdmVcIiE9PWImJlwiY29tcGxldGVcIiE9PWJ8fEpkKHRoaXMpO2ZvcihiPTA7YjxhLmxlbmd0aDtiKyspZm9yKHZhciBjPWFbYl0uYWRkZWROb2RlcyxkPTA7ZDxjLmxlbmd0aDtkKyspTyh0aGlzLmosY1tkXSl9O2Z1bmN0aW9uIEtkKCl7dmFyIGE9dGhpczt0aGlzLmI9dGhpcy5hPXZvaWQgMDt0aGlzLmM9bmV3IFByb21pc2UoZnVuY3Rpb24oYil7YS5iPWI7YS5hJiZiKGEuYSl9KX1LZC5wcm90b3R5cGUucmVzb2x2ZT1mdW5jdGlvbihhKXtpZih0aGlzLmEpdGhyb3cgRXJyb3IoXCJBbHJlYWR5IHJlc29sdmVkLlwiKTt0aGlzLmE9YTt0aGlzLmImJnRoaXMuYihhKX07ZnVuY3Rpb24gUChhKXt0aGlzLmRhPSExO3RoaXMuaj1hO3RoaXMuaGE9bmV3IE1hcDt0aGlzLmVhPWZ1bmN0aW9uKGEpe3JldHVybiBhKCl9O3RoaXMuUj0hMTt0aGlzLmZhPVtdO3RoaXMuRmE9bmV3IElkKGEpfVxuUC5wcm90b3R5cGUuZGVmaW5lPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztpZighKGIgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9ycyBtdXN0IGJlIGZ1bmN0aW9ucy5cIik7aWYoIUJkKGEpKXRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBlbGVtZW50IG5hbWUgJ1wiK2ErXCInIGlzIG5vdCB2YWxpZC5cIik7aWYodGhpcy5qLmEuZ2V0KGEpKXRocm93IEVycm9yKFwiQSBjdXN0b20gZWxlbWVudCB3aXRoIG5hbWUgJ1wiK2ErXCInIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZC5cIik7aWYodGhpcy5kYSl0aHJvdyBFcnJvcihcIkEgY3VzdG9tIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBkZWZpbmVkLlwiKTt0aGlzLmRhPSEwO3RyeXt2YXIgZD1mdW5jdGlvbihhKXt2YXIgYj1lW2FdO2lmKHZvaWQgMCE9PWImJiEoYiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl0aHJvdyBFcnJvcihcIlRoZSAnXCIrYStcIicgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbnJldHVybiBifSxlPWIucHJvdG90eXBlO2lmKCEoZSBpbnN0YW5jZW9mIE9iamVjdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZSBpcyBub3QgYW4gb2JqZWN0LlwiKTt2YXIgZj1kKFwiY29ubmVjdGVkQ2FsbGJhY2tcIik7dmFyIGg9ZChcImRpc2Nvbm5lY3RlZENhbGxiYWNrXCIpO3ZhciBnPWQoXCJhZG9wdGVkQ2FsbGJhY2tcIik7dmFyIGs9ZChcImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1wiKTt2YXIgbD1iLm9ic2VydmVkQXR0cmlidXRlc3x8W119Y2F0Y2gobSl7cmV0dXJufWZpbmFsbHl7dGhpcy5kYT0hMX1iPXtsb2NhbE5hbWU6YSxjb25zdHJ1Y3RvcjpiLGNvbm5lY3RlZENhbGxiYWNrOmYsZGlzY29ubmVjdGVkQ2FsbGJhY2s6aCxhZG9wdGVkQ2FsbGJhY2s6ZyxhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6ayxvYnNlcnZlZEF0dHJpYnV0ZXM6bCxjb25zdHJ1Y3Rpb25TdGFjazpbXX07RWQodGhpcy5qLGEsYik7dGhpcy5mYS5wdXNoKGIpO1xudGhpcy5SfHwodGhpcy5SPSEwLHRoaXMuZWEoZnVuY3Rpb24oKXtyZXR1cm4gTGQoYyl9KSl9O2Z1bmN0aW9uIExkKGEpe2lmKCExIT09YS5SKXthLlI9ITE7Zm9yKHZhciBiPWEuZmEsYz1bXSxkPW5ldyBNYXAsZT0wO2U8Yi5sZW5ndGg7ZSsrKWQuc2V0KGJbZV0ubG9jYWxOYW1lLFtdKTtPKGEuaixkb2N1bWVudCx7d2E6ZnVuY3Rpb24oYil7aWYodm9pZCAwPT09Yi5fX0NFX3N0YXRlKXt2YXIgZT1iLmxvY2FsTmFtZSxmPWQuZ2V0KGUpO2Y/Zi5wdXNoKGIpOmEuai5hLmdldChlKSYmYy5wdXNoKGIpfX19KTtmb3IoZT0wO2U8Yy5sZW5ndGg7ZSsrKUhkKGEuaixjW2VdKTtmb3IoOzA8Yi5sZW5ndGg7KXt2YXIgZj1iLnNoaWZ0KCk7ZT1mLmxvY2FsTmFtZTtmPWQuZ2V0KGYubG9jYWxOYW1lKTtmb3IodmFyIGg9MDtoPGYubGVuZ3RoO2grKylIZChhLmosZltoXSk7KGU9YS5oYS5nZXQoZSkpJiZlLnJlc29sdmUodm9pZCAwKX19fVxuUC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe2lmKGE9dGhpcy5qLmEuZ2V0KGEpKXJldHVybiBhLmNvbnN0cnVjdG9yfTtQLnByb3RvdHlwZS53aGVuRGVmaW5lZD1mdW5jdGlvbihhKXtpZighQmQoYSkpcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBTeW50YXhFcnJvcihcIidcIithK1wiJyBpcyBub3QgYSB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lLlwiKSk7dmFyIGI9dGhpcy5oYS5nZXQoYSk7aWYoYilyZXR1cm4gYi5jO2I9bmV3IEtkO3RoaXMuaGEuc2V0KGEsYik7dGhpcy5qLmEuZ2V0KGEpJiYhdGhpcy5mYS5zb21lKGZ1bmN0aW9uKGIpe3JldHVybiBiLmxvY2FsTmFtZT09PWF9KSYmYi5yZXNvbHZlKHZvaWQgMCk7cmV0dXJuIGIuY307UC5wcm90b3R5cGUuVGE9ZnVuY3Rpb24oYSl7SmQodGhpcy5GYSk7dmFyIGI9dGhpcy5lYTt0aGlzLmVhPWZ1bmN0aW9uKGMpe3JldHVybiBhKGZ1bmN0aW9uKCl7cmV0dXJuIGIoYyl9KX19O1xud2luZG93LkN1c3RvbUVsZW1lbnRSZWdpc3RyeT1QO1AucHJvdG90eXBlLmRlZmluZT1QLnByb3RvdHlwZS5kZWZpbmU7UC5wcm90b3R5cGUuZ2V0PVAucHJvdG90eXBlLmdldDtQLnByb3RvdHlwZS53aGVuRGVmaW5lZD1QLnByb3RvdHlwZS53aGVuRGVmaW5lZDtQLnByb3RvdHlwZS5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrPVAucHJvdG90eXBlLlRhO3ZhciBNZD13aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQsTmQ9d2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50TlMsT2Q9d2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlLFBkPXdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUucHJlcGVuZCxRZD13aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmFwcGVuZCxSZD13aW5kb3cuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucHJlcGVuZCxTZD13aW5kb3cuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUuYXBwZW5kLFRkPXdpbmRvdy5Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGUsVWQ9d2luZG93Lk5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkLFZkPXdpbmRvdy5Ob2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUsV2Q9d2luZG93Lk5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkLFhkPXdpbmRvdy5Ob2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQsWWQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuTm9kZS5wcm90b3R5cGUsXG5cInRleHRDb250ZW50XCIpLFpkPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3csJGQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUsXCJpbm5lckhUTUxcIiksYWU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSxiZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLGNlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUsZGU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZU5TLGVlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUyxmZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlTlMsZ2U9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmluc2VydEFkamFjZW50RWxlbWVudCxoZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucHJlcGVuZCxpZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYXBwZW5kLFxuamU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmJlZm9yZSxrZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYWZ0ZXIsbGU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VXaXRoLG1lPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmUsbmU9d2luZG93LkhUTUxFbGVtZW50LG9lPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZSxcImlubmVySFRNTFwiKSxwZT13aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLmluc2VydEFkamFjZW50RWxlbWVudDt2YXIgcWU9bmV3IGZ1bmN0aW9uKCl7fTtmdW5jdGlvbiByZSgpe3ZhciBhPXNlO3dpbmRvdy5IVE1MRWxlbWVudD1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXt2YXIgYj10aGlzLmNvbnN0cnVjdG9yLGQ9YS5vLmdldChiKTtpZighZCl0aHJvdyBFcnJvcihcIlRoZSBjdXN0b20gZWxlbWVudCBiZWluZyBjb25zdHJ1Y3RlZCB3YXMgbm90IHJlZ2lzdGVyZWQgd2l0aCBgY3VzdG9tRWxlbWVudHNgLlwiKTt2YXIgZT1kLmNvbnN0cnVjdGlvblN0YWNrO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gZT1NZC5jYWxsKGRvY3VtZW50LGQubG9jYWxOYW1lKSxPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxiLnByb3RvdHlwZSksZS5fX0NFX3N0YXRlPTEsZS5fX0NFX2RlZmluaXRpb249ZCxhLmIoZSksZTtkPWUubGVuZ3RoLTE7dmFyIGY9ZVtkXTtpZihmPT09cWUpdGhyb3cgRXJyb3IoXCJUaGUgSFRNTEVsZW1lbnQgY29uc3RydWN0b3Igd2FzIGVpdGhlciBjYWxsZWQgcmVlbnRyYW50bHkgZm9yIHRoaXMgY29uc3RydWN0b3Igb3IgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlwiKTtcbmVbZF09cWU7T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsYi5wcm90b3R5cGUpO2EuYihmKTtyZXR1cm4gZn1iLnByb3RvdHlwZT1uZS5wcm90b3R5cGU7cmV0dXJuIGJ9KCl9O2Z1bmN0aW9uIHRlKGEsYixjKXtmdW5jdGlvbiBkKGIpe3JldHVybiBmdW5jdGlvbihjKXtmb3IodmFyIGQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDsrK2UpZFtlLTBdPWFyZ3VtZW50c1tlXTtlPVtdO2Zvcih2YXIgZj1bXSxsPTA7bDxkLmxlbmd0aDtsKyspe3ZhciBtPWRbbF07bSBpbnN0YW5jZW9mIEVsZW1lbnQmJkoobSkmJmYucHVzaChtKTtpZihtIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudClmb3IobT1tLmZpcnN0Q2hpbGQ7bTttPW0ubmV4dFNpYmxpbmcpZS5wdXNoKG0pO2Vsc2UgZS5wdXNoKG0pfWIuYXBwbHkodGhpcyxkKTtmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKU4oYSxmW2RdKTtpZihKKHRoaXMpKWZvcihkPTA7ZDxlLmxlbmd0aDtkKyspZj1lW2RdLGYgaW5zdGFuY2VvZiBFbGVtZW50JiZNKGEsZil9fXZvaWQgMCE9PWMuWCYmKGIucHJlcGVuZD1kKGMuWCkpO3ZvaWQgMCE9PWMuYXBwZW5kJiYoYi5hcHBlbmQ9ZChjLmFwcGVuZCkpfTtmdW5jdGlvbiB1ZSgpe3ZhciBhPXNlO0woRG9jdW1lbnQucHJvdG90eXBlLFwiY3JlYXRlRWxlbWVudFwiLGZ1bmN0aW9uKGIpe2lmKHRoaXMuX19DRV9oYXNSZWdpc3RyeSl7dmFyIGM9YS5hLmdldChiKTtpZihjKXJldHVybiBuZXcgYy5jb25zdHJ1Y3Rvcn1iPU1kLmNhbGwodGhpcyxiKTthLmIoYik7cmV0dXJuIGJ9KTtMKERvY3VtZW50LnByb3RvdHlwZSxcImltcG9ydE5vZGVcIixmdW5jdGlvbihiLGMpe2I9T2QuY2FsbCh0aGlzLGIsYyk7dGhpcy5fX0NFX2hhc1JlZ2lzdHJ5P08oYSxiKTpHZChhLGIpO3JldHVybiBifSk7TChEb2N1bWVudC5wcm90b3R5cGUsXCJjcmVhdGVFbGVtZW50TlNcIixmdW5jdGlvbihiLGMpe2lmKHRoaXMuX19DRV9oYXNSZWdpc3RyeSYmKG51bGw9PT1ifHxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj09PWIpKXt2YXIgZD1hLmEuZ2V0KGMpO2lmKGQpcmV0dXJuIG5ldyBkLmNvbnN0cnVjdG9yfWI9TmQuY2FsbCh0aGlzLGIsYyk7YS5iKGIpO3JldHVybiBifSk7XG50ZShhLERvY3VtZW50LnByb3RvdHlwZSx7WDpQZCxhcHBlbmQ6UWR9KX07ZnVuY3Rpb24gdmUoKXt2YXIgYT1zZTtmdW5jdGlvbiBiKGIsZCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJ0ZXh0Q29udGVudFwiLHtlbnVtZXJhYmxlOmQuZW51bWVyYWJsZSxjb25maWd1cmFibGU6ITAsZ2V0OmQuZ2V0LHNldDpmdW5jdGlvbihiKXtpZih0aGlzLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUpZC5zZXQuY2FsbCh0aGlzLGIpO2Vsc2V7dmFyIGM9dm9pZCAwO2lmKHRoaXMuZmlyc3RDaGlsZCl7dmFyIGU9dGhpcy5jaGlsZE5vZGVzLGc9ZS5sZW5ndGg7aWYoMDxnJiZKKHRoaXMpKXtjPUFycmF5KGcpO2Zvcih2YXIgaz0wO2s8ZztrKyspY1trXT1lW2tdfX1kLnNldC5jYWxsKHRoaXMsYik7aWYoYylmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKU4oYSxjW2JdKX19fSl9TChOb2RlLnByb3RvdHlwZSxcImluc2VydEJlZm9yZVwiLGZ1bmN0aW9uKGIsZCl7aWYoYiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShiLmNoaWxkTm9kZXMpO1xuYj1WZC5jYWxsKHRoaXMsYixkKTtpZihKKHRoaXMpKWZvcihkPTA7ZDxjLmxlbmd0aDtkKyspTShhLGNbZF0pO3JldHVybiBifWM9SihiKTtkPVZkLmNhbGwodGhpcyxiLGQpO2MmJk4oYSxiKTtKKHRoaXMpJiZNKGEsYik7cmV0dXJuIGR9KTtMKE5vZGUucHJvdG90eXBlLFwiYXBwZW5kQ2hpbGRcIixmdW5jdGlvbihiKXtpZihiIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGIuY2hpbGROb2Rlcyk7Yj1VZC5jYWxsKHRoaXMsYik7aWYoSih0aGlzKSlmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKylNKGEsY1tlXSk7cmV0dXJuIGJ9Yz1KKGIpO2U9VWQuY2FsbCh0aGlzLGIpO2MmJk4oYSxiKTtKKHRoaXMpJiZNKGEsYik7cmV0dXJuIGV9KTtMKE5vZGUucHJvdG90eXBlLFwiY2xvbmVOb2RlXCIsZnVuY3Rpb24oYil7Yj1UZC5jYWxsKHRoaXMsYik7dGhpcy5vd25lckRvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnk/TyhhLGIpOlxuR2QoYSxiKTtyZXR1cm4gYn0pO0woTm9kZS5wcm90b3R5cGUsXCJyZW1vdmVDaGlsZFwiLGZ1bmN0aW9uKGIpe3ZhciBjPUooYiksZT1XZC5jYWxsKHRoaXMsYik7YyYmTihhLGIpO3JldHVybiBlfSk7TChOb2RlLnByb3RvdHlwZSxcInJlcGxhY2VDaGlsZFwiLGZ1bmN0aW9uKGIsZCl7aWYoYiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShiLmNoaWxkTm9kZXMpO2I9WGQuY2FsbCh0aGlzLGIsZCk7aWYoSih0aGlzKSlmb3IoTihhLGQpLGQ9MDtkPGMubGVuZ3RoO2QrKylNKGEsY1tkXSk7cmV0dXJuIGJ9Yz1KKGIpO3ZhciBmPVhkLmNhbGwodGhpcyxiLGQpLGg9Sih0aGlzKTtoJiZOKGEsZCk7YyYmTihhLGIpO2gmJk0oYSxiKTtyZXR1cm4gZn0pO1lkJiZZZC5nZXQ/YihOb2RlLnByb3RvdHlwZSxZZCk6RmQoYSxmdW5jdGlvbihhKXtiKGEse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe2Zvcih2YXIgYT1cbltdLGI9MDtiPHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7YisrKWEucHVzaCh0aGlzLmNoaWxkTm9kZXNbYl0udGV4dENvbnRlbnQpO3JldHVybiBhLmpvaW4oXCJcIil9LHNldDpmdW5jdGlvbihhKXtmb3IoO3RoaXMuZmlyc3RDaGlsZDspV2QuY2FsbCh0aGlzLHRoaXMuZmlyc3RDaGlsZCk7VWQuY2FsbCh0aGlzLGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEpKX19KX0pfTtmdW5jdGlvbiB3ZShhKXt2YXIgYj1FbGVtZW50LnByb3RvdHlwZTtmdW5jdGlvbiBjKGIpe3JldHVybiBmdW5jdGlvbihjKXtmb3IodmFyIGQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDsrK2UpZFtlLTBdPWFyZ3VtZW50c1tlXTtlPVtdO2Zvcih2YXIgZz1bXSxrPTA7azxkLmxlbmd0aDtrKyspe3ZhciBsPWRba107bCBpbnN0YW5jZW9mIEVsZW1lbnQmJkoobCkmJmcucHVzaChsKTtpZihsIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudClmb3IobD1sLmZpcnN0Q2hpbGQ7bDtsPWwubmV4dFNpYmxpbmcpZS5wdXNoKGwpO2Vsc2UgZS5wdXNoKGwpfWIuYXBwbHkodGhpcyxkKTtmb3IoZD0wO2Q8Zy5sZW5ndGg7ZCsrKU4oYSxnW2RdKTtpZihKKHRoaXMpKWZvcihkPTA7ZDxlLmxlbmd0aDtkKyspZz1lW2RdLGcgaW5zdGFuY2VvZiBFbGVtZW50JiZNKGEsZyl9fXZvaWQgMCE9PWplJiYoYi5iZWZvcmU9YyhqZSkpO3ZvaWQgMCE9PWplJiYoYi5hZnRlcj1jKGtlKSk7dm9pZCAwIT09XG5sZSYmTChiLFwicmVwbGFjZVdpdGhcIixmdW5jdGlvbihiKXtmb3IodmFyIGM9W10sZD0wO2Q8YXJndW1lbnRzLmxlbmd0aDsrK2QpY1tkLTBdPWFyZ3VtZW50c1tkXTtkPVtdO2Zvcih2YXIgaD1bXSxnPTA7ZzxjLmxlbmd0aDtnKyspe3ZhciBrPWNbZ107ayBpbnN0YW5jZW9mIEVsZW1lbnQmJkooaykmJmgucHVzaChrKTtpZihrIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudClmb3Ioaz1rLmZpcnN0Q2hpbGQ7aztrPWsubmV4dFNpYmxpbmcpZC5wdXNoKGspO2Vsc2UgZC5wdXNoKGspfWc9Sih0aGlzKTtsZS5hcHBseSh0aGlzLGMpO2ZvcihjPTA7YzxoLmxlbmd0aDtjKyspTihhLGhbY10pO2lmKGcpZm9yKE4oYSx0aGlzKSxjPTA7YzxkLmxlbmd0aDtjKyspaD1kW2NdLGggaW5zdGFuY2VvZiBFbGVtZW50JiZNKGEsaCl9KTt2b2lkIDAhPT1tZSYmTChiLFwicmVtb3ZlXCIsZnVuY3Rpb24oKXt2YXIgYj1KKHRoaXMpO21lLmNhbGwodGhpcyk7YiYmTihhLHRoaXMpfSl9O2Z1bmN0aW9uIHhlKCl7dmFyIGE9c2U7ZnVuY3Rpb24gYihiLGMpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiaW5uZXJIVE1MXCIse2VudW1lcmFibGU6Yy5lbnVtZXJhYmxlLGNvbmZpZ3VyYWJsZTohMCxnZXQ6Yy5nZXQsc2V0OmZ1bmN0aW9uKGIpe3ZhciBkPXRoaXMsZT12b2lkIDA7Sih0aGlzKSYmKGU9W10sSyh0aGlzLGZ1bmN0aW9uKGEpe2EhPT1kJiZlLnB1c2goYSl9KSk7Yy5zZXQuY2FsbCh0aGlzLGIpO2lmKGUpZm9yKHZhciBmPTA7ZjxlLmxlbmd0aDtmKyspe3ZhciBsPWVbZl07MT09PWwuX19DRV9zdGF0ZSYmYS5kaXNjb25uZWN0ZWRDYWxsYmFjayhsKX10aGlzLm93bmVyRG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeT9PKGEsdGhpcyk6R2QoYSx0aGlzKTtyZXR1cm4gYn19KX1mdW5jdGlvbiBjKGIsYyl7TChiLFwiaW5zZXJ0QWRqYWNlbnRFbGVtZW50XCIsZnVuY3Rpb24oYixkKXt2YXIgZT1KKGQpO2I9Yy5jYWxsKHRoaXMsYixkKTtlJiZOKGEsZCk7SihiKSYmTShhLGQpO1xucmV0dXJuIGJ9KX1aZCYmTChFbGVtZW50LnByb3RvdHlwZSxcImF0dGFjaFNoYWRvd1wiLGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9fQ0Vfc2hhZG93Um9vdD1hPVpkLmNhbGwodGhpcyxhKX0pOyRkJiYkZC5nZXQ/YihFbGVtZW50LnByb3RvdHlwZSwkZCk6b2UmJm9lLmdldD9iKEhUTUxFbGVtZW50LnByb3RvdHlwZSxvZSk6RmQoYSxmdW5jdGlvbihhKXtiKGEse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBUZC5jYWxsKHRoaXMsITApLmlubmVySFRNTH0sc2V0OmZ1bmN0aW9uKGEpe3ZhciBiPVwidGVtcGxhdGVcIj09PXRoaXMubG9jYWxOYW1lLGM9Yj90aGlzLmNvbnRlbnQ6dGhpcyxkPU1kLmNhbGwoZG9jdW1lbnQsdGhpcy5sb2NhbE5hbWUpO2ZvcihkLmlubmVySFRNTD1hOzA8Yy5jaGlsZE5vZGVzLmxlbmd0aDspV2QuY2FsbChjLGMuY2hpbGROb2Rlc1swXSk7Zm9yKGE9Yj9kLmNvbnRlbnQ6ZDswPGEuY2hpbGROb2Rlcy5sZW5ndGg7KVVkLmNhbGwoYyxcbmEuY2hpbGROb2Rlc1swXSl9fSl9KTtMKEVsZW1lbnQucHJvdG90eXBlLFwic2V0QXR0cmlidXRlXCIsZnVuY3Rpb24oYixjKXtpZigxIT09dGhpcy5fX0NFX3N0YXRlKXJldHVybiBiZS5jYWxsKHRoaXMsYixjKTt2YXIgZD1hZS5jYWxsKHRoaXMsYik7YmUuY2FsbCh0aGlzLGIsYyk7Yz1hZS5jYWxsKHRoaXMsYik7YS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcyxiLGQsYyxudWxsKX0pO0woRWxlbWVudC5wcm90b3R5cGUsXCJzZXRBdHRyaWJ1dGVOU1wiLGZ1bmN0aW9uKGIsYyxmKXtpZigxIT09dGhpcy5fX0NFX3N0YXRlKXJldHVybiBlZS5jYWxsKHRoaXMsYixjLGYpO3ZhciBkPWRlLmNhbGwodGhpcyxiLGMpO2VlLmNhbGwodGhpcyxiLGMsZik7Zj1kZS5jYWxsKHRoaXMsYixjKTthLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLGMsZCxmLGIpfSk7TChFbGVtZW50LnByb3RvdHlwZSxcInJlbW92ZUF0dHJpYnV0ZVwiLGZ1bmN0aW9uKGIpe2lmKDEhPT10aGlzLl9fQ0Vfc3RhdGUpcmV0dXJuIGNlLmNhbGwodGhpcyxcbmIpO3ZhciBjPWFlLmNhbGwodGhpcyxiKTtjZS5jYWxsKHRoaXMsYik7bnVsbCE9PWMmJmEuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsYixjLG51bGwsbnVsbCl9KTtMKEVsZW1lbnQucHJvdG90eXBlLFwicmVtb3ZlQXR0cmlidXRlTlNcIixmdW5jdGlvbihiLGMpe2lmKDEhPT10aGlzLl9fQ0Vfc3RhdGUpcmV0dXJuIGZlLmNhbGwodGhpcyxiLGMpO3ZhciBkPWRlLmNhbGwodGhpcyxiLGMpO2ZlLmNhbGwodGhpcyxiLGMpO3ZhciBlPWRlLmNhbGwodGhpcyxiLGMpO2QhPT1lJiZhLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLGMsZCxlLGIpfSk7cGU/YyhIVE1MRWxlbWVudC5wcm90b3R5cGUscGUpOmdlP2MoRWxlbWVudC5wcm90b3R5cGUsZ2UpOmNvbnNvbGUud2FybihcIkN1c3RvbSBFbGVtZW50czogYEVsZW1lbnQjaW5zZXJ0QWRqYWNlbnRFbGVtZW50YCB3YXMgbm90IHBhdGNoZWQuXCIpO3RlKGEsRWxlbWVudC5wcm90b3R5cGUse1g6aGUsYXBwZW5kOmllfSk7d2UoYSl9XG47dmFyIHllPXdpbmRvdy5jdXN0b21FbGVtZW50cztpZigheWV8fHllLmZvcmNlUG9seWZpbGx8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHllLmRlZmluZXx8XCJmdW5jdGlvblwiIT10eXBlb2YgeWUuZ2V0KXt2YXIgc2U9bmV3IERkO3JlKCk7dWUoKTt0ZShzZSxEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSx7WDpSZCxhcHBlbmQ6U2R9KTt2ZSgpO3hlKCk7ZG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeT0hMDt2YXIgY3VzdG9tRWxlbWVudHM9bmV3IFAoc2UpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csXCJjdXN0b21FbGVtZW50c1wiLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpjdXN0b21FbGVtZW50c30pfTtmdW5jdGlvbiB6ZSgpe3RoaXMuZW5kPXRoaXMuc3RhcnQ9MDt0aGlzLnJ1bGVzPXRoaXMucGFyZW50PXRoaXMucHJldmlvdXM9bnVsbDt0aGlzLmNzc1RleHQ9dGhpcy5wYXJzZWRDc3NUZXh0PVwiXCI7dGhpcy5hdFJ1bGU9ITE7dGhpcy50eXBlPTA7dGhpcy5wYXJzZWRTZWxlY3Rvcj10aGlzLnNlbGVjdG9yPXRoaXMua2V5ZnJhbWVzTmFtZT1cIlwifVxuZnVuY3Rpb24gQWUoYSl7YT1hLnJlcGxhY2UoQmUsXCJcIikucmVwbGFjZShDZSxcIlwiKTt2YXIgYj1EZSxjPWEsZD1uZXcgemU7ZC5zdGFydD0wO2QuZW5kPWMubGVuZ3RoO2Zvcih2YXIgZT1kLGY9MCxoPWMubGVuZ3RoO2Y8aDtmKyspaWYoXCJ7XCI9PT1jW2ZdKXtlLnJ1bGVzfHwoZS5ydWxlcz1bXSk7dmFyIGc9ZSxrPWcucnVsZXNbZy5ydWxlcy5sZW5ndGgtMV18fG51bGw7ZT1uZXcgemU7ZS5zdGFydD1mKzE7ZS5wYXJlbnQ9ZztlLnByZXZpb3VzPWs7Zy5ydWxlcy5wdXNoKGUpfWVsc2VcIn1cIj09PWNbZl0mJihlLmVuZD1mKzEsZT1lLnBhcmVudHx8ZCk7cmV0dXJuIGIoZCxhKX1cbmZ1bmN0aW9uIERlKGEsYil7dmFyIGM9Yi5zdWJzdHJpbmcoYS5zdGFydCxhLmVuZC0xKTthLnBhcnNlZENzc1RleHQ9YS5jc3NUZXh0PWMudHJpbSgpO2EucGFyZW50JiYoYz1iLnN1YnN0cmluZyhhLnByZXZpb3VzP2EucHJldmlvdXMuZW5kOmEucGFyZW50LnN0YXJ0LGEuc3RhcnQtMSksYz1FZShjKSxjPWMucmVwbGFjZShGZSxcIiBcIiksYz1jLnN1YnN0cmluZyhjLmxhc3RJbmRleE9mKFwiO1wiKSsxKSxjPWEucGFyc2VkU2VsZWN0b3I9YS5zZWxlY3Rvcj1jLnRyaW0oKSxhLmF0UnVsZT0wPT09Yy5pbmRleE9mKFwiQFwiKSxhLmF0UnVsZT8wPT09Yy5pbmRleE9mKFwiQG1lZGlhXCIpP2EudHlwZT1KZTpjLm1hdGNoKEtlKSYmKGEudHlwZT1MZSxhLmtleWZyYW1lc05hbWU9YS5zZWxlY3Rvci5zcGxpdChGZSkucG9wKCkpOmEudHlwZT0wPT09Yy5pbmRleE9mKFwiLS1cIik/TWU6TmUpO2lmKGM9YS5ydWxlcylmb3IodmFyIGQ9MCxlPWMubGVuZ3RoLGY7ZDxlJiYoZj1jW2RdKTtkKyspRGUoZixcbmIpO3JldHVybiBhfWZ1bmN0aW9uIEVlKGEpe3JldHVybiBhLnJlcGxhY2UoL1xcXFwoWzAtOWEtZl17MSw2fSlcXHMvZ2ksZnVuY3Rpb24oYSxjKXthPWM7Zm9yKGM9Ni1hLmxlbmd0aDtjLS07KWE9XCIwXCIrYTtyZXR1cm5cIlxcXFxcIithfSl9XG5mdW5jdGlvbiBPZShhLGIsYyl7Yz12b2lkIDA9PT1jP1wiXCI6Yzt2YXIgZD1cIlwiO2lmKGEuY3NzVGV4dHx8YS5ydWxlcyl7dmFyIGU9YS5ydWxlcyxmO2lmKGY9ZSlmPWVbMF0sZj0hKGYmJmYuc2VsZWN0b3ImJjA9PT1mLnNlbGVjdG9yLmluZGV4T2YoXCItLVwiKSk7aWYoZil7Zj0wO2Zvcih2YXIgaD1lLmxlbmd0aCxnO2Y8aCYmKGc9ZVtmXSk7ZisrKWQ9T2UoZyxiLGQpfWVsc2UgYj9iPWEuY3NzVGV4dDooYj1hLmNzc1RleHQsYj1iLnJlcGxhY2UoUGUsXCJcIikucmVwbGFjZShRZSxcIlwiKSxiPWIucmVwbGFjZShSZSxcIlwiKS5yZXBsYWNlKFNlLFwiXCIpKSwoZD1iLnRyaW0oKSkmJihkPVwiICBcIitkK1wiXFxuXCIpfWQmJihhLnNlbGVjdG9yJiYoYys9YS5zZWxlY3RvcitcIiB7XFxuXCIpLGMrPWQsYS5zZWxlY3RvciYmKGMrPVwifVxcblxcblwiKSk7cmV0dXJuIGN9XG52YXIgTmU9MSxMZT03LEplPTQsTWU9MUUzLEJlPS9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9naW0sQ2U9L0BpbXBvcnRbXjtdKjsvZ2ltLFBlPS8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/KD86WztcXG5dfCQpL2dpbSxRZT0vKD86XlteO1xcLVxcc31dKyk/LS1bXjt7fV0qPzpbXnt9O10qP3tbXn1dKj99KD86WztcXG5dfCQpPy9naW0sUmU9L0BhcHBseVxccypcXCg/W14pO10qXFwpP1xccyooPzpbO1xcbl18JCk/L2dpbSxTZT0vW147Ol0qPzpbXjtdKj92YXJcXChbXjtdKlxcKSg/Ols7XFxuXXwkKT8vZ2ltLEtlPS9eQFteXFxzXSprZXlmcmFtZXMvLEZlPS9cXHMrL2c7dmFyIFE9ISh3aW5kb3cuU2hhZHlET00mJndpbmRvdy5TaGFkeURPTS5pblVzZSksVGU7ZnVuY3Rpb24gVWUoYSl7VGU9YSYmYS5zaGltY3NzcHJvcGVydGllcz8hMTpRfHwhKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvNjAxfEVkZ2VcXC8xNS8pfHwhd2luZG93LkNTU3x8IUNTUy5zdXBwb3J0c3x8IUNTUy5zdXBwb3J0cyhcImJveC1zaGFkb3dcIixcIjAgMCAwIHZhcigtLWZvbylcIikpfXdpbmRvdy5TaGFkeUNTUyYmdm9pZCAwIT09d2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcz9UZT13aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzOndpbmRvdy5TaGFkeUNTUz8oVWUod2luZG93LlNoYWR5Q1NTKSx3aW5kb3cuU2hhZHlDU1M9dm9pZCAwKTpVZSh3aW5kb3cuV2ViQ29tcG9uZW50cyYmd2luZG93LldlYkNvbXBvbmVudHMuZmxhZ3MpO3ZhciBSPVRlO3ZhciBWZT0vKD86XnxbO1xcc3tdXFxzKikoLS1bXFx3LV0qPylcXHMqOlxccyooPzooKD86Jyg/OlxcXFwnfC4pKj8nfFwiKD86XFxcXFwifC4pKj9cInxcXChbXildKj9cXCl8W159O3tdKSspfFxceyhbXn1dKilcXH0oPzooPz1bO1xcc31dKXwkKSkvZ2ksV2U9Lyg/Ol58XFxXKylAYXBwbHlcXHMqXFwoPyhbXik7XFxuXSopXFwpPy9naSxYZT0vKC0tW1xcdy1dKylcXHMqKFs6LDspXXwkKS9naSxZZT0vKGFuaW1hdGlvblxccyo6KXwoYW5pbWF0aW9uLW5hbWVcXHMqOikvLFplPS9AbWVkaWFcXHMoLiopLywkZT0vXFx7W159XSpcXH0vZzt2YXIgYWY9bmV3IFNldDtmdW5jdGlvbiBiZihhLGIpe2lmKCFhKXJldHVyblwiXCI7XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYoYT1BZShhKSk7YiYmY2YoYSxiKTtyZXR1cm4gT2UoYSxSKX1mdW5jdGlvbiBkZihhKXshYS5fX2Nzc1J1bGVzJiZhLnRleHRDb250ZW50JiYoYS5fX2Nzc1J1bGVzPUFlKGEudGV4dENvbnRlbnQpKTtyZXR1cm4gYS5fX2Nzc1J1bGVzfHxudWxsfWZ1bmN0aW9uIGVmKGEpe3JldHVybiEhYS5wYXJlbnQmJmEucGFyZW50LnR5cGU9PT1MZX1mdW5jdGlvbiBjZihhLGIsYyxkKXtpZihhKXt2YXIgZT0hMSxmPWEudHlwZTtpZihkJiZmPT09SmUpe3ZhciBoPWEuc2VsZWN0b3IubWF0Y2goWmUpO2gmJih3aW5kb3cubWF0Y2hNZWRpYShoWzFdKS5tYXRjaGVzfHwoZT0hMCkpfWY9PT1OZT9iKGEpOmMmJmY9PT1MZT9jKGEpOmY9PT1NZSYmKGU9ITApO2lmKChhPWEucnVsZXMpJiYhZSl7ZT0wO2Y9YS5sZW5ndGg7Zm9yKHZhciBnO2U8ZiYmKGc9YVtlXSk7ZSsrKWNmKGcsYixjLGQpfX19XG5mdW5jdGlvbiBmZihhLGIsYyxkKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7YiYmZS5zZXRBdHRyaWJ1dGUoXCJzY29wZVwiLGIpO2UudGV4dENvbnRlbnQ9YTtnZihlLGMsZCk7cmV0dXJuIGV9dmFyIFM9bnVsbDtmdW5jdGlvbiBnZihhLGIsYyl7Yj1ifHxkb2N1bWVudC5oZWFkO2IuaW5zZXJ0QmVmb3JlKGEsYyYmYy5uZXh0U2libGluZ3x8Yi5maXJzdENoaWxkKTtTP2EuY29tcGFyZURvY3VtZW50UG9zaXRpb24oUyk9PT1Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyYmKFM9YSk6Uz1hfVxuZnVuY3Rpb24gaGYoYSxiKXt2YXIgYz1hLmluZGV4T2YoXCJ2YXIoXCIpO2lmKC0xPT09YylyZXR1cm4gYihhLFwiXCIsXCJcIixcIlwiKTthOnt2YXIgZD0wO3ZhciBlPWMrMztmb3IodmFyIGY9YS5sZW5ndGg7ZTxmO2UrKylpZihcIihcIj09PWFbZV0pZCsrO2Vsc2UgaWYoXCIpXCI9PT1hW2VdJiYwPT09LS1kKWJyZWFrIGE7ZT0tMX1kPWEuc3Vic3RyaW5nKGMrNCxlKTtjPWEuc3Vic3RyaW5nKDAsYyk7YT1oZihhLnN1YnN0cmluZyhlKzEpLGIpO2U9ZC5pbmRleE9mKFwiLFwiKTtyZXR1cm4tMT09PWU/YihjLGQudHJpbSgpLFwiXCIsYSk6YihjLGQuc3Vic3RyaW5nKDAsZSkudHJpbSgpLGQuc3Vic3RyaW5nKGUrMSkudHJpbSgpLGEpfWZ1bmN0aW9uIGpmKGEsYil7UT9hLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYik6d2luZG93LlNoYWR5RE9NLm5hdGl2ZU1ldGhvZHMuc2V0QXR0cmlidXRlLmNhbGwoYSxcImNsYXNzXCIsYil9XG5mdW5jdGlvbiBWKGEpe3ZhciBiPWEubG9jYWxOYW1lLGM9XCJcIjtiPy0xPGIuaW5kZXhPZihcIi1cIil8fChjPWIsYj1hLmdldEF0dHJpYnV0ZSYmYS5nZXRBdHRyaWJ1dGUoXCJpc1wiKXx8XCJcIik6KGI9YS5pcyxjPWEuZXh0ZW5kcyk7cmV0dXJue2lzOmIsUDpjfX07ZnVuY3Rpb24ga2YoKXt9ZnVuY3Rpb24gbGYoYSxiLGMpe3ZhciBkPVc7YS5fX3N0eWxlU2NvcGVkP2EuX19zdHlsZVNjb3BlZD1udWxsOm1mKGQsYSxifHxcIlwiLGMpfWZ1bmN0aW9uIG1mKGEsYixjLGQpe2Iubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmbmYoYixjLGQpO2lmKGI9XCJ0ZW1wbGF0ZVwiPT09Yi5sb2NhbE5hbWU/KGIuY29udGVudHx8Yi5nYikuY2hpbGROb2RlczpiLmNoaWxkcmVufHxiLmNoaWxkTm9kZXMpZm9yKHZhciBlPTA7ZTxiLmxlbmd0aDtlKyspbWYoYSxiW2VdLGMsZCl9XG5mdW5jdGlvbiBuZihhLGIsYyl7aWYoYilpZihhLmNsYXNzTGlzdCljPyhhLmNsYXNzTGlzdC5yZW1vdmUoXCJzdHlsZS1zY29wZVwiKSxhLmNsYXNzTGlzdC5yZW1vdmUoYikpOihhLmNsYXNzTGlzdC5hZGQoXCJzdHlsZS1zY29wZVwiKSxhLmNsYXNzTGlzdC5hZGQoYikpO2Vsc2UgaWYoYS5nZXRBdHRyaWJ1dGUpe3ZhciBkPWEuZ2V0QXR0cmlidXRlKG9mKTtjP2QmJihiPWQucmVwbGFjZShcInN0eWxlLXNjb3BlXCIsXCJcIikucmVwbGFjZShiLFwiXCIpLGpmKGEsYikpOmpmKGEsKGQ/ZCtcIiBcIjpcIlwiKStcInN0eWxlLXNjb3BlIFwiK2IpfX1mdW5jdGlvbiBwZihhLGIsYyl7dmFyIGQ9VyxlPWEuX19jc3NCdWlsZDtRfHxcInNoYWR5XCI9PT1lP2I9YmYoYixjKTooYT1WKGEpLGI9cWYoZCxiLGEuaXMsYS5QLGMpK1wiXFxuXFxuXCIpO3JldHVybiBiLnRyaW0oKX1cbmZ1bmN0aW9uIHFmKGEsYixjLGQsZSl7dmFyIGY9cmYoYyxkKTtjPWM/c2YrYzpcIlwiO3JldHVybiBiZihiLGZ1bmN0aW9uKGIpe2IuY3x8KGIuc2VsZWN0b3I9Yi5tPXRmKGEsYixhLmIsYyxmKSxiLmM9ITApO2UmJmUoYixjLGYpfSl9ZnVuY3Rpb24gcmYoYSxiKXtyZXR1cm4gYj9cIltpcz1cIithK1wiXVwiOmF9ZnVuY3Rpb24gdGYoYSxiLGMsZCxlKXt2YXIgZj1iLnNlbGVjdG9yLnNwbGl0KHVmKTtpZighZWYoYikpe2I9MDtmb3IodmFyIGg9Zi5sZW5ndGgsZztiPGgmJihnPWZbYl0pO2IrKylmW2JdPWMuY2FsbChhLGcsZCxlKX1yZXR1cm4gZi5qb2luKHVmKX1mdW5jdGlvbiB2ZihhKXtyZXR1cm4gYS5yZXBsYWNlKHdmLGZ1bmN0aW9uKGEsYyxkKXstMTxkLmluZGV4T2YoXCIrXCIpP2Q9ZC5yZXBsYWNlKC9cXCsvZyxcIl9fX1wiKTotMTxkLmluZGV4T2YoXCJfX19cIikmJihkPWQucmVwbGFjZSgvX19fL2csXCIrXCIpKTtyZXR1cm5cIjpcIitjK1wiKFwiK2QrXCIpXCJ9KX1cbmtmLnByb3RvdHlwZS5iPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD0hMTthPWEudHJpbSgpO3ZhciBlPXdmLnRlc3QoYSk7ZSYmKGE9YS5yZXBsYWNlKHdmLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm5cIjpcIitiK1wiKFwiK2MucmVwbGFjZSgvXFxzL2csXCJcIikrXCIpXCJ9KSxhPXZmKGEpKTthPWEucmVwbGFjZSh4Zix5ZitcIiAkMVwiKTthPWEucmVwbGFjZSh6ZixmdW5jdGlvbihhLGUsZyl7ZHx8KGE9QWYoZyxlLGIsYyksZD1kfHxhLnN0b3AsZT1hLkphLGc9YS52YWx1ZSk7cmV0dXJuIGUrZ30pO2UmJihhPXZmKGEpKTtyZXR1cm4gYX07XG5mdW5jdGlvbiBBZihhLGIsYyxkKXt2YXIgZT1hLmluZGV4T2YoQmYpOzA8PWEuaW5kZXhPZih5Zik/YT1DZihhLGQpOjAhPT1lJiYoYT1jP0RmKGEsYyk6YSk7Yz0hMTswPD1lJiYoYj1cIlwiLGM9ITApO2lmKGMpe3ZhciBmPSEwO2MmJihhPWEucmVwbGFjZShFZixmdW5jdGlvbihhLGIpe3JldHVyblwiID4gXCIrYn0pKX1hPWEucmVwbGFjZShGZixmdW5jdGlvbihhLGIsYyl7cmV0dXJuJ1tkaXI9XCInK2MrJ1wiXSAnK2IrXCIsIFwiK2IrJ1tkaXI9XCInK2MrJ1wiXSd9KTtyZXR1cm57dmFsdWU6YSxKYTpiLHN0b3A6Zn19ZnVuY3Rpb24gRGYoYSxiKXthPWEuc3BsaXQoR2YpO2FbMF0rPWI7cmV0dXJuIGEuam9pbihHZil9XG5mdW5jdGlvbiBDZihhLGIpe3ZhciBjPWEubWF0Y2goSGYpO3JldHVybihjPWMmJmNbMl0udHJpbSgpfHxcIlwiKT9jWzBdLm1hdGNoKElmKT9hLnJlcGxhY2UoSGYsZnVuY3Rpb24oYSxjLGYpe3JldHVybiBiK2Z9KTpjLnNwbGl0KElmKVswXT09PWI/YzpKZjphLnJlcGxhY2UoeWYsYil9ZnVuY3Rpb24gS2YoYSl7YS5zZWxlY3Rvcj09PUxmJiYoYS5zZWxlY3Rvcj1cImh0bWxcIil9a2YucHJvdG90eXBlLmM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEubWF0Y2goQmYpP3RoaXMuYihhLE1mKTpEZihhLnRyaW0oKSxNZil9O3EuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoa2YucHJvdG90eXBlLHthOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cInN0eWxlLXNjb3BlXCJ9fX0pO1xudmFyIHdmPS86KG50aFstXFx3XSspXFwoKFteKV0rKVxcKS8sTWY9XCI6bm90KC5zdHlsZS1zY29wZSlcIix1Zj1cIixcIix6Zj0vKF58W1xccz4rfl0rKSgoPzpcXFsuKz9cXF18W15cXHM+K349W10pKykvZyxJZj0vW1suOiMqXS8seWY9XCI6aG9zdFwiLExmPVwiOnJvb3RcIixCZj1cIjo6c2xvdHRlZFwiLHhmPW5ldyBSZWdFeHAoXCJeKFwiK0JmK1wiKVwiKSxIZj0vKDpob3N0KSg/OlxcKCgoPzpcXChbXikoXSpcXCl8W14pKF0qKSs/KVxcKSkvLEVmPS8oPzo6OnNsb3R0ZWQpKD86XFwoKCg/OlxcKFteKShdKlxcKXxbXikoXSopKz8pXFwpKS8sRmY9LyguKik6ZGlyXFwoKD86KGx0cnxydGwpKVxcKS8sc2Y9XCIuXCIsR2Y9XCI6XCIsb2Y9XCJjbGFzc1wiLEpmPVwic2hvdWxkX25vdF9tYXRjaFwiLFc9bmV3IGtmO2Z1bmN0aW9uIE5mKGEsYixjLGQpe3RoaXMudz1hfHxudWxsO3RoaXMuYj1ifHxudWxsO3RoaXMuamE9Y3x8W107dGhpcy5HPW51bGw7dGhpcy5QPWR8fFwiXCI7dGhpcy5hPXRoaXMudT10aGlzLkI9bnVsbH1mdW5jdGlvbiBYKGEpe3JldHVybiBhP2EuX19zdHlsZUluZm86bnVsbH1mdW5jdGlvbiBPZihhLGIpe3JldHVybiBhLl9fc3R5bGVJbmZvPWJ9TmYucHJvdG90eXBlLmM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53fTtOZi5wcm90b3R5cGUuX2dldFN0eWxlUnVsZXM9TmYucHJvdG90eXBlLmM7dmFyIFBmLFFmPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZTtQZj1RZi5tYXRjaGVzfHxRZi5tYXRjaGVzU2VsZWN0b3J8fFFmLm1vek1hdGNoZXNTZWxlY3Rvcnx8UWYubXNNYXRjaGVzU2VsZWN0b3J8fFFmLm9NYXRjaGVzU2VsZWN0b3J8fFFmLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjt2YXIgUmY9bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChcIlRyaWRlbnRcIik7ZnVuY3Rpb24gU2YoKXt9ZnVuY3Rpb24gVGYoYSl7dmFyIGI9e30sYz1bXSxkPTA7Y2YoYSxmdW5jdGlvbihhKXtVZihhKTthLmluZGV4PWQrKzthPWEuaS5jc3NUZXh0O2Zvcih2YXIgYztjPVhlLmV4ZWMoYSk7KXt2YXIgZT1jWzFdO1wiOlwiIT09Y1syXSYmKGJbZV09ITApfX0sZnVuY3Rpb24oYSl7Yy5wdXNoKGEpfSk7YS5iPWM7YT1bXTtmb3IodmFyIGUgaW4gYilhLnB1c2goZSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBVZihhKXtpZighYS5pKXt2YXIgYj17fSxjPXt9O1ZmKGEsYykmJihiLnY9YyxhLnJ1bGVzPW51bGwpO2IuY3NzVGV4dD1hLnBhcnNlZENzc1RleHQucmVwbGFjZSgkZSxcIlwiKS5yZXBsYWNlKFZlLFwiXCIpO2EuaT1ifX1mdW5jdGlvbiBWZihhLGIpe3ZhciBjPWEuaTtpZihjKXtpZihjLnYpcmV0dXJuIE9iamVjdC5hc3NpZ24oYixjLnYpLCEwfWVsc2V7Yz1hLnBhcnNlZENzc1RleHQ7Zm9yKHZhciBkO2E9VmUuZXhlYyhjKTspe2Q9KGFbMl18fGFbM10pLnRyaW0oKTtpZihcImluaGVyaXRcIiE9PWR8fFwidW5zZXRcIiE9PWQpYlthWzFdLnRyaW0oKV09ZDtkPSEwfXJldHVybiBkfX1cbmZ1bmN0aW9uIFdmKGEsYixjKXtiJiYoYj0wPD1iLmluZGV4T2YoXCI7XCIpP1hmKGEsYixjKTpoZihiLGZ1bmN0aW9uKGIsZSxmLGgpe2lmKCFlKXJldHVybiBiK2g7KGU9V2YoYSxjW2VdLGMpKSYmXCJpbml0aWFsXCIhPT1lP1wiYXBwbHktc2hpbS1pbmhlcml0XCI9PT1lJiYoZT1cImluaGVyaXRcIik6ZT1XZihhLGNbZl18fGYsYyl8fGY7cmV0dXJuIGIrKGV8fFwiXCIpK2h9KSk7cmV0dXJuIGImJmIudHJpbSgpfHxcIlwifVxuZnVuY3Rpb24gWGYoYSxiLGMpe2I9Yi5zcGxpdChcIjtcIik7Zm9yKHZhciBkPTAsZSxmO2Q8Yi5sZW5ndGg7ZCsrKWlmKGU9YltkXSl7V2UubGFzdEluZGV4PTA7aWYoZj1XZS5leGVjKGUpKWU9V2YoYSxjW2ZbMV1dLGMpO2Vsc2UgaWYoZj1lLmluZGV4T2YoXCI6XCIpLC0xIT09Zil7dmFyIGg9ZS5zdWJzdHJpbmcoZik7aD1oLnRyaW0oKTtoPVdmKGEsaCxjKXx8aDtlPWUuc3Vic3RyaW5nKDAsZikraH1iW2RdPWUmJmUubGFzdEluZGV4T2YoXCI7XCIpPT09ZS5sZW5ndGgtMT9lLnNsaWNlKDAsLTEpOmV8fFwiXCJ9cmV0dXJuIGIuam9pbihcIjtcIil9XG5mdW5jdGlvbiBZZihhLGIpe3ZhciBjPXt9LGQ9W107Y2YoYSxmdW5jdGlvbihhKXthLml8fFVmKGEpO3ZhciBlPWEubXx8YS5wYXJzZWRTZWxlY3RvcjtiJiZhLmkudiYmZSYmUGYuY2FsbChiLGUpJiYoVmYoYSxjKSxhPWEuaW5kZXgsZT1wYXJzZUludChhLzMyLDEwKSxkW2VdPShkW2VdfHwwKXwxPDxhJTMyKX0sbnVsbCwhMCk7cmV0dXJue3Y6YyxrZXk6ZH19XG5mdW5jdGlvbiBaZihhLGIsYyxkKXtiLml8fFVmKGIpO2lmKGIuaS52KXt2YXIgZT1WKGEpO2E9ZS5pcztlPWUuUDtlPWE/cmYoYSxlKTpcImh0bWxcIjt2YXIgZj1iLnBhcnNlZFNlbGVjdG9yLGg9XCI6aG9zdCA+ICpcIj09PWZ8fFwiaHRtbFwiPT09ZixnPTA9PT1mLmluZGV4T2YoXCI6aG9zdFwiKSYmIWg7XCJzaGFkeVwiPT09YyYmKGg9Zj09PWUrXCIgPiAqLlwiK2V8fC0xIT09Zi5pbmRleE9mKFwiaHRtbFwiKSxnPSFoJiYwPT09Zi5pbmRleE9mKGUpKTtcInNoYWRvd1wiPT09YyYmKGg9XCI6aG9zdCA+ICpcIj09PWZ8fFwiaHRtbFwiPT09ZixnPWcmJiFoKTtpZihofHxnKWM9ZSxnJiYoUSYmIWIubSYmKGIubT10ZihXLGIsVy5iLGE/c2YrYTpcIlwiLGUpKSxjPWIubXx8ZSksZCh7WGE6YyxPYTpnLGliOmh9KX19XG5mdW5jdGlvbiAkZihhLGIpe3ZhciBjPXt9LGQ9e30sZT1iJiZiLl9fY3NzQnVpbGQ7Y2YoYixmdW5jdGlvbihiKXtaZihhLGIsZSxmdW5jdGlvbihlKXtQZi5jYWxsKGEuaGJ8fGEsZS5YYSkmJihlLk9hP1ZmKGIsYyk6VmYoYixkKSl9KX0sbnVsbCwhMCk7cmV0dXJue1ZhOmQsTmE6Y319XG5mdW5jdGlvbiBhZyhhLGIsYyxkKXt2YXIgZT1WKGIpLGY9cmYoZS5pcyxlLlApLGg9bmV3IFJlZ0V4cChcIig/Ol58W14uI1s6XSlcIisoYi5leHRlbmRzP1wiXFxcXFwiK2Yuc2xpY2UoMCwtMSkrXCJcXFxcXVwiOmYpK1wiKCR8Wy46W1xcXFxzPit+XSlcIik7ZT1YKGIpLnc7dmFyIGc9YmcoZSxkKTtyZXR1cm4gcGYoYixlLGZ1bmN0aW9uKGIpe3ZhciBlPVwiXCI7Yi5pfHxVZihiKTtiLmkuY3NzVGV4dCYmKGU9WGYoYSxiLmkuY3NzVGV4dCxjKSk7Yi5jc3NUZXh0PWU7aWYoIVEmJiFlZihiKSYmYi5jc3NUZXh0KXt2YXIgaz1lPWIuY3NzVGV4dDtudWxsPT1iLnJhJiYoYi5yYT1ZZS50ZXN0KGUpKTtpZihiLnJhKWlmKG51bGw9PWIuVyl7Yi5XPVtdO2Zvcih2YXIgbiBpbiBnKWs9Z1tuXSxrPWsoZSksZSE9PWsmJihlPWssYi5XLnB1c2gobikpfWVsc2V7Zm9yKG49MDtuPGIuVy5sZW5ndGg7KytuKWs9Z1tiLldbbl1dLGU9ayhlKTtrPWV9Yi5jc3NUZXh0PWs7Yi5tPWIubXx8Yi5zZWxlY3RvcjtlPVwiLlwiK2Q7XG5uPWIubS5zcGxpdChcIixcIik7az0wO2Zvcih2YXIgdz1uLmxlbmd0aCxJO2s8dyYmKEk9bltrXSk7aysrKW5ba109SS5tYXRjaChoKT9JLnJlcGxhY2UoZixlKTplK1wiIFwiK0k7Yi5zZWxlY3Rvcj1uLmpvaW4oXCIsXCIpfX0pfWZ1bmN0aW9uIGJnKGEsYil7YT1hLmI7dmFyIGM9e307aWYoIVEmJmEpZm9yKHZhciBkPTAsZT1hW2RdO2Q8YS5sZW5ndGg7ZT1hWysrZF0pe3ZhciBmPWUsaD1iO2YuaD1uZXcgUmVnRXhwKGYua2V5ZnJhbWVzTmFtZSxcImdcIik7Zi5hPWYua2V5ZnJhbWVzTmFtZStcIi1cIitoO2YubT1mLm18fGYuc2VsZWN0b3I7Zi5zZWxlY3Rvcj1mLm0ucmVwbGFjZShmLmtleWZyYW1lc05hbWUsZi5hKTtjW2Uua2V5ZnJhbWVzTmFtZV09Y2coZSl9cmV0dXJuIGN9ZnVuY3Rpb24gY2coYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybiBiLnJlcGxhY2UoYS5oLGEuYSl9fVxuZnVuY3Rpb24gZGcoYSxiKXt2YXIgYz1lZyxkPWRmKGEpO2EudGV4dENvbnRlbnQ9YmYoZCxmdW5jdGlvbihhKXt2YXIgZD1hLmNzc1RleHQ9YS5wYXJzZWRDc3NUZXh0O2EuaSYmYS5pLmNzc1RleHQmJihkPWQucmVwbGFjZShQZSxcIlwiKS5yZXBsYWNlKFFlLFwiXCIpLGEuY3NzVGV4dD1YZihjLGQsYikpfSl9cS5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhTZi5wcm90b3R5cGUse2E6e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVyblwieC1zY29wZVwifX19KTt2YXIgZWc9bmV3IFNmO3ZhciBmZz17fSxnZz13aW5kb3cuY3VzdG9tRWxlbWVudHM7aWYoZ2cmJiFRKXt2YXIgaGc9Z2cuZGVmaW5lO2dnLmRlZmluZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIiBTaGFkeSBET00gc3R5bGVzIGZvciBcIithK1wiIFwiKSxlPWRvY3VtZW50LmhlYWQ7ZS5pbnNlcnRCZWZvcmUoZCwoUz9TLm5leHRTaWJsaW5nOm51bGwpfHxlLmZpcnN0Q2hpbGQpO1M9ZDtmZ1thXT1kO3JldHVybiBoZy5jYWxsKGdnLGEsYixjKX19O2Z1bmN0aW9uIGlnKCl7dGhpcy5jYWNoZT17fX1pZy5wcm90b3R5cGUuc3RvcmU9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5jYWNoZVthXXx8W107ZS5wdXNoKHt2OmIsc3R5bGVFbGVtZW50OmMsdTpkfSk7MTAwPGUubGVuZ3RoJiZlLnNoaWZ0KCk7dGhpcy5jYWNoZVthXT1lfTtpZy5wcm90b3R5cGUuZmV0Y2g9ZnVuY3Rpb24oYSxiLGMpe2lmKGE9dGhpcy5jYWNoZVthXSlmb3IodmFyIGQ9YS5sZW5ndGgtMTswPD1kO2QtLSl7dmFyIGU9YVtkXSxmO2E6e2ZvcihmPTA7ZjxjLmxlbmd0aDtmKyspe3ZhciBoPWNbZl07aWYoZS52W2hdIT09YltoXSl7Zj0hMTticmVhayBhfX1mPSEwfWlmKGYpcmV0dXJuIGV9fTtmdW5jdGlvbiBqZygpe31cbmZ1bmN0aW9uIGtnKGEpe2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz1hW2JdO2lmKGMudGFyZ2V0IT09ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZjLnRhcmdldCE9PWRvY3VtZW50LmhlYWQpZm9yKHZhciBkPTA7ZDxjLmFkZGVkTm9kZXMubGVuZ3RoO2QrKyl7dmFyIGU9Yy5hZGRlZE5vZGVzW2RdO2lmKGUubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSl7dmFyIGY9ZS5nZXRSb290Tm9kZSgpO3ZhciBoPWU7dmFyIGc9W107aC5jbGFzc0xpc3Q/Zz1BcnJheS5mcm9tKGguY2xhc3NMaXN0KTpoIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQmJmguaGFzQXR0cmlidXRlKFwiY2xhc3NcIikmJihnPWguZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikuc3BsaXQoL1xccysvKSk7aD1nO2c9aC5pbmRleE9mKFcuYSk7aWYoKGg9LTE8Zz9oW2crMV06XCJcIikmJmY9PT1lLm93bmVyRG9jdW1lbnQpbGYoZSxoLCEwKTtlbHNlIGlmKGYubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUmJlxuKGY9Zi5ob3N0KSlpZihmPVYoZikuaXMsaD09PWYpZm9yKGU9d2luZG93LlNoYWR5RE9NLm5hdGl2ZU1ldGhvZHMucXVlcnlTZWxlY3RvckFsbC5jYWxsKGUsXCI6bm90KC5cIitXLmErXCIpXCIpLGY9MDtmPGUubGVuZ3RoO2YrKyluZihlW2ZdLGgpO2Vsc2UgaCYmbGYoZSxoLCEwKSxsZihlLGYpfX19fVxuaWYoIVEpe3ZhciBsZz1uZXcgTXV0YXRpb25PYnNlcnZlcihrZyksbWc9ZnVuY3Rpb24oYSl7bGcub2JzZXJ2ZShhLHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pfTtpZih3aW5kb3cuY3VzdG9tRWxlbWVudHMmJiF3aW5kb3cuY3VzdG9tRWxlbWVudHMucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayltZyhkb2N1bWVudCk7ZWxzZXt2YXIgbmc9ZnVuY3Rpb24oKXttZyhkb2N1bWVudC5ib2R5KX07d2luZG93LkhUTUxJbXBvcnRzP3dpbmRvdy5IVE1MSW1wb3J0cy53aGVuUmVhZHkobmcpOnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2lmKFwibG9hZGluZ1wiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSl7dmFyIGE9ZnVuY3Rpb24oKXtuZygpO2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsYSl9O2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsYSl9ZWxzZSBuZygpfSl9amc9ZnVuY3Rpb24oKXtrZyhsZy50YWtlUmVjb3JkcygpKX19XG52YXIgb2c9amc7dmFyIHBnPXt9O3ZhciBxZz1Qcm9taXNlLnJlc29sdmUoKTtmdW5jdGlvbiByZyhhKXtpZihhPXBnW2FdKWEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uPWEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9ufHwwLGEuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uPWEuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9ufHwwLGEuX2FwcGx5U2hpbU5leHRWZXJzaW9uPShhLl9hcHBseVNoaW1OZXh0VmVyc2lvbnx8MCkrMX1mdW5jdGlvbiBzZyhhKXtyZXR1cm4gYS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb249PT1hLl9hcHBseVNoaW1OZXh0VmVyc2lvbn1mdW5jdGlvbiB0ZyhhKXthLl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbj1hLl9hcHBseVNoaW1OZXh0VmVyc2lvbjthLmJ8fChhLmI9ITAscWcudGhlbihmdW5jdGlvbigpe2EuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uPWEuX2FwcGx5U2hpbU5leHRWZXJzaW9uO2EuYj0hMX0pKX07dmFyIHVnPW51bGwsdmc9d2luZG93LkhUTUxJbXBvcnRzJiZ3aW5kb3cuSFRNTEltcG9ydHMud2hlblJlYWR5fHxudWxsLHdnO2Z1bmN0aW9uIHhnKGEpe3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe3ZnP3ZnKGEpOih1Z3x8KHVnPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGEpe3dnPWF9KSxcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlP3dnKCk6ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixmdW5jdGlvbigpe1wiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJndnKCl9KSksdWcudGhlbihmdW5jdGlvbigpe2EmJmEoKX0pKX0pfTt2YXIgeWc9bmV3IGlnO2Z1bmN0aW9uIFkoKXt2YXIgYT10aGlzO3RoaXMuTD17fTt0aGlzLmM9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O3ZhciBiPW5ldyB6ZTtiLnJ1bGVzPVtdO3RoaXMuaD1PZih0aGlzLmMsbmV3IE5mKGIpKTt0aGlzLm89ITE7dGhpcy5iPXRoaXMuYT1udWxsO3hnKGZ1bmN0aW9uKCl7emcoYSl9KX1wPVkucHJvdG90eXBlO3AueGE9ZnVuY3Rpb24oKXtvZygpfTtwLkxhPWZ1bmN0aW9uKGEpe3JldHVybiBkZihhKX07cC5aYT1mdW5jdGlvbihhKXtyZXR1cm4gYmYoYSl9O1xucC5wcmVwYXJlVGVtcGxhdGU9ZnVuY3Rpb24oYSxiLGMpe2lmKCFhLmgpe2EuaD0hMDthLm5hbWU9YjthLmV4dGVuZHM9YztwZ1tiXT1hO3ZhciBkPShkPWEuY29udGVudC5xdWVyeVNlbGVjdG9yKFwic3R5bGVcIikpP2QuZ2V0QXR0cmlidXRlKFwiY3NzLWJ1aWxkXCIpfHxcIlwiOlwiXCI7dmFyIGU9W107Zm9yKHZhciBmPWEuY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVcIiksaD0wO2g8Zi5sZW5ndGg7aCsrKXt2YXIgZz1mW2hdO2lmKGcuaGFzQXR0cmlidXRlKFwic2hhZHktdW5zY29wZWRcIikpe2lmKCFRKXt2YXIgaz1nLnRleHRDb250ZW50O2FmLmhhcyhrKXx8KGFmLmFkZChrKSxrPWcuY2xvbmVOb2RlKCEwKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGspKTtnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZyl9fWVsc2UgZS5wdXNoKGcudGV4dENvbnRlbnQpLGcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnKX1lPWUuam9pbihcIlwiKS50cmltKCk7Yz17aXM6YixleHRlbmRzOmMsZWI6ZH07XG5RfHxsZihhLmNvbnRlbnQsYik7emcodGhpcyk7Zj1XZS50ZXN0KGUpfHxWZS50ZXN0KGUpO1dlLmxhc3RJbmRleD0wO1ZlLmxhc3RJbmRleD0wO2U9QWUoZSk7ZiYmUiYmdGhpcy5hJiZ0aGlzLmEudHJhbnNmb3JtUnVsZXMoZSxiKTthLl9zdHlsZUFzdD1lO2Eubz1kO2Q9W107Unx8KGQ9VGYoYS5fc3R5bGVBc3QpKTtpZighZC5sZW5ndGh8fFIpZT1RP2EuY29udGVudDpudWxsLGI9ZmdbYl0sZj1wZihjLGEuX3N0eWxlQXN0KSxiPWYubGVuZ3RoP2ZmKGYsYy5pcyxlLGIpOnZvaWQgMCxhLmE9YjthLmM9ZH19O1xuZnVuY3Rpb24gQWcoYSl7IWEuYiYmd2luZG93LlNoYWR5Q1NTJiZ3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2UmJihhLmI9d2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlLGEuYi50cmFuc2Zvcm1DYWxsYmFjaz1mdW5jdGlvbihiKXthLnZhKGIpfSxhLmIudmFsaWRhdGVDYWxsYmFjaz1mdW5jdGlvbigpe3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpeyhhLmIuZW5xdWV1ZWR8fGEubykmJmEuRigpfSl9KX1mdW5jdGlvbiB6ZyhhKXshYS5hJiZ3aW5kb3cuU2hhZHlDU1MmJndpbmRvdy5TaGFkeUNTUy5BcHBseVNoaW0mJihhLmE9d2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbSxhLmEuaW52YWxpZENhbGxiYWNrPXJnKTtBZyhhKX1cbnAuRj1mdW5jdGlvbigpe3pnKHRoaXMpO2lmKHRoaXMuYil7dmFyIGE9dGhpcy5iLnByb2Nlc3NTdHlsZXMoKTtpZih0aGlzLmIuZW5xdWV1ZWQpe2lmKFIpZm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuYi5nZXRTdHlsZUZvckN1c3RvbVN0eWxlKGFbYl0pO2lmKGMmJlImJnRoaXMuYSl7dmFyIGQ9ZGYoYyk7emcodGhpcyk7dGhpcy5hLnRyYW5zZm9ybVJ1bGVzKGQpO2MudGV4dENvbnRlbnQ9YmYoZCl9fWVsc2UgZm9yKEJnKHRoaXMsdGhpcy5jLHRoaXMuaCksYj0wO2I8YS5sZW5ndGg7YisrKShjPXRoaXMuYi5nZXRTdHlsZUZvckN1c3RvbVN0eWxlKGFbYl0pKSYmZGcoYyx0aGlzLmguQik7dGhpcy5iLmVucXVldWVkPSExO3RoaXMubyYmIVImJnRoaXMuc3R5bGVEb2N1bWVudCgpfX19O1xucC5zdHlsZUVsZW1lbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1WKGEpLmlzLGQ9WChhKTtpZighZCl7dmFyIGU9VihhKTtkPWUuaXM7ZT1lLlA7dmFyIGY9ZmdbZF07ZD1wZ1tkXTtpZihkKXt2YXIgaD1kLl9zdHlsZUFzdDt2YXIgZz1kLmN9ZD1PZihhLG5ldyBOZihoLGYsZyxlKSl9YSE9PXRoaXMuYyYmKHRoaXMubz0hMCk7YiYmKGQuRz1kLkd8fHt9LE9iamVjdC5hc3NpZ24oZC5HLGIpKTtpZihSKXtpZihkLkcpe2I9ZC5HO2Zvcih2YXIgayBpbiBiKW51bGw9PT1rP2Euc3R5bGUucmVtb3ZlUHJvcGVydHkoayk6YS5zdHlsZS5zZXRQcm9wZXJ0eShrLGJba10pfWlmKCgoaz1wZ1tjXSl8fGE9PT10aGlzLmMpJiZrJiZrLmEmJiFzZyhrKSl7aWYoc2coayl8fGsuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uIT09ay5fYXBwbHlTaGltTmV4dFZlcnNpb24pemcodGhpcyksdGhpcy5hJiZ0aGlzLmEudHJhbnNmb3JtUnVsZXMoay5fc3R5bGVBc3QsYyksay5hLnRleHRDb250ZW50PXBmKGEsXG5kLncpLHRnKGspO1EmJihjPWEuc2hhZG93Um9vdCkmJihjLnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZVwiKS50ZXh0Q29udGVudD1wZihhLGQudykpO2Qudz1rLl9zdHlsZUFzdH19ZWxzZSBpZihCZyh0aGlzLGEsZCksZC5qYSYmZC5qYS5sZW5ndGgpe2M9ZDtrPVYoYSkuaXM7ZD0oYj15Zy5mZXRjaChrLGMuQixjLmphKSk/Yi5zdHlsZUVsZW1lbnQ6bnVsbDtoPWMudTsoZz1iJiZiLnUpfHwoZz10aGlzLkxba109KHRoaXMuTFtrXXx8MCkrMSxnPWsrXCItXCIrZyk7Yy51PWc7Zz1jLnU7ZT1lZztlPWQ/ZC50ZXh0Q29udGVudHx8XCJcIjphZyhlLGEsYy5CLGcpO2Y9WChhKTt2YXIgbD1mLmE7bCYmIVEmJmwhPT1kJiYobC5fdXNlQ291bnQtLSwwPj1sLl91c2VDb3VudCYmbC5wYXJlbnROb2RlJiZsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobCkpO1E/Zi5hPyhmLmEudGV4dENvbnRlbnQ9ZSxkPWYuYSk6ZSYmKGQ9ZmYoZSxnLGEuc2hhZG93Um9vdCxmLmIpKTpkP2QucGFyZW50Tm9kZXx8KFJmJiZcbi0xPGUuaW5kZXhPZihcIkBtZWRpYVwiKSYmKGQudGV4dENvbnRlbnQ9ZSksZ2YoZCxudWxsLGYuYikpOmUmJihkPWZmKGUsZyxudWxsLGYuYikpO2QmJihkLl91c2VDb3VudD1kLl91c2VDb3VudHx8MCxmLmEhPWQmJmQuX3VzZUNvdW50KyssZi5hPWQpO2c9ZDtRfHwoZD1jLnUsZj1lPWEuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIsaCYmKGY9ZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxccyp4LXNjb3BlXFxcXHMqXCIraCtcIlxcXFxzKlwiLFwiZ1wiKSxcIiBcIikpLGYrPShmP1wiIFwiOlwiXCIpK1wieC1zY29wZSBcIitkLGUhPT1mJiZqZihhLGYpKTtifHx5Zy5zdG9yZShrLGMuQixnLGMudSl9fTtmdW5jdGlvbiBDZyhhLGIpe3JldHVybihiPWIuZ2V0Um9vdE5vZGUoKS5ob3N0KT9YKGIpP2I6Q2coYSxiKTphLmN9XG5mdW5jdGlvbiBCZyhhLGIsYyl7YT1DZyhhLGIpO3ZhciBkPVgoYSk7YT1PYmplY3QuY3JlYXRlKGQuQnx8bnVsbCk7dmFyIGU9JGYoYixjLncpO2I9WWYoZC53LGIpLnY7T2JqZWN0LmFzc2lnbihhLGUuTmEsYixlLlZhKTtiPWMuRztmb3IodmFyIGYgaW4gYilpZigoZT1iW2ZdKXx8MD09PWUpYVtmXT1lO2Y9ZWc7Yj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhKTtmb3IoZT0wO2U8Yi5sZW5ndGg7ZSsrKWQ9YltlXSxhW2RdPVdmKGYsYVtkXSxhKTtjLkI9YX1wLnN0eWxlRG9jdW1lbnQ9ZnVuY3Rpb24oYSl7dGhpcy5zdHlsZVN1YnRyZWUodGhpcy5jLGEpfTtcbnAuc3R5bGVTdWJ0cmVlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5zaGFkb3dSb290OyhjfHxhPT09dGhpcy5jKSYmdGhpcy5zdHlsZUVsZW1lbnQoYSxiKTtpZihiPWMmJihjLmNoaWxkcmVufHxjLmNoaWxkTm9kZXMpKWZvcihhPTA7YTxiLmxlbmd0aDthKyspdGhpcy5zdHlsZVN1YnRyZWUoYlthXSk7ZWxzZSBpZihhPWEuY2hpbGRyZW58fGEuY2hpbGROb2Rlcylmb3IoYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMuc3R5bGVTdWJ0cmVlKGFbYl0pfTtwLnZhPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1kZihhKTtjZihjLGZ1bmN0aW9uKGEpe2lmKFEpS2YoYSk7ZWxzZXt2YXIgYz1XO2Euc2VsZWN0b3I9YS5wYXJzZWRTZWxlY3RvcjtLZihhKTthLnNlbGVjdG9yPWEubT10ZihjLGEsYy5jLHZvaWQgMCx2b2lkIDApfVImJih6ZyhiKSxiLmEmJmIuYS50cmFuc2Zvcm1SdWxlKGEpKX0pO1I/YS50ZXh0Q29udGVudD1iZihjKTp0aGlzLmgudy5ydWxlcy5wdXNoKGMpfTtcbnAuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlPWZ1bmN0aW9uKGEsYil7dmFyIGM7Unx8KGM9KFgoYSl8fFgoQ2codGhpcyxhKSkpLkJbYl0pO3JldHVybihjPWN8fHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEpLmdldFByb3BlcnR5VmFsdWUoYikpP2MudHJpbSgpOlwiXCJ9O3AuWWE9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmdldFJvb3ROb2RlKCk7Yj1iP2Iuc3BsaXQoL1xccy8pOltdO2M9Yy5ob3N0JiZjLmhvc3QubG9jYWxOYW1lO2lmKCFjKXt2YXIgZD1hLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO2lmKGQpe2Q9ZC5zcGxpdCgvXFxzLyk7Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspaWYoZFtlXT09PVcuYSl7Yz1kW2UrMV07YnJlYWt9fX1jJiZiLnB1c2goVy5hLGMpO1J8fChjPVgoYSkpJiZjLnUmJmIucHVzaChlZy5hLGMudSk7amYoYSxiLmpvaW4oXCIgXCIpKX07cC5JYT1mdW5jdGlvbihhKXtyZXR1cm4gWChhKX07WS5wcm90b3R5cGUuZmx1c2g9WS5wcm90b3R5cGUueGE7XG5ZLnByb3RvdHlwZS5wcmVwYXJlVGVtcGxhdGU9WS5wcm90b3R5cGUucHJlcGFyZVRlbXBsYXRlO1kucHJvdG90eXBlLnN0eWxlRWxlbWVudD1ZLnByb3RvdHlwZS5zdHlsZUVsZW1lbnQ7WS5wcm90b3R5cGUuc3R5bGVEb2N1bWVudD1ZLnByb3RvdHlwZS5zdHlsZURvY3VtZW50O1kucHJvdG90eXBlLnN0eWxlU3VidHJlZT1ZLnByb3RvdHlwZS5zdHlsZVN1YnRyZWU7WS5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlPVkucHJvdG90eXBlLmdldENvbXB1dGVkU3R5bGVWYWx1ZTtZLnByb3RvdHlwZS5zZXRFbGVtZW50Q2xhc3M9WS5wcm90b3R5cGUuWWE7WS5wcm90b3R5cGUuX3N0eWxlSW5mb0Zvck5vZGU9WS5wcm90b3R5cGUuSWE7WS5wcm90b3R5cGUudHJhbnNmb3JtQ3VzdG9tU3R5bGVGb3JEb2N1bWVudD1ZLnByb3RvdHlwZS52YTtZLnByb3RvdHlwZS5nZXRTdHlsZUFzdD1ZLnByb3RvdHlwZS5MYTtZLnByb3RvdHlwZS5zdHlsZUFzdFRvU3RyaW5nPVkucHJvdG90eXBlLlphO1xuWS5wcm90b3R5cGUuZmx1c2hDdXN0b21TdHlsZXM9WS5wcm90b3R5cGUuRjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhZLnByb3RvdHlwZSx7bmF0aXZlU2hhZG93OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUX19LG5hdGl2ZUNzczp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFJ9fX0pO3ZhciBaPW5ldyBZLERnLEVnO3dpbmRvdy5TaGFkeUNTUyYmKERnPXdpbmRvdy5TaGFkeUNTUy5BcHBseVNoaW0sRWc9d2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlKTt3aW5kb3cuU2hhZHlDU1M9e1Njb3BpbmdTaGltOloscHJlcGFyZVRlbXBsYXRlOmZ1bmN0aW9uKGEsYixjKXtaLkYoKTtaLnByZXBhcmVUZW1wbGF0ZShhLGIsYyl9LHN0eWxlU3VidHJlZTpmdW5jdGlvbihhLGIpe1ouRigpO1ouc3R5bGVTdWJ0cmVlKGEsYil9LHN0eWxlRWxlbWVudDpmdW5jdGlvbihhKXtaLkYoKTtaLnN0eWxlRWxlbWVudChhKX0sc3R5bGVEb2N1bWVudDpmdW5jdGlvbihhKXtaLkYoKTtaLnN0eWxlRG9jdW1lbnQoYSl9LGdldENvbXB1dGVkU3R5bGVWYWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybiBaLmdldENvbXB1dGVkU3R5bGVWYWx1ZShhLGIpfSxuYXRpdmVDc3M6UixuYXRpdmVTaGFkb3c6UX07RGcmJih3aW5kb3cuU2hhZHlDU1MuQXBwbHlTaGltPURnKTtcbkVnJiYod2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlPUVnKTt2YXIgRmc9d2luZG93LmN1c3RvbUVsZW1lbnRzLEdnPXdpbmRvdy5IVE1MSW1wb3J0cyxIZz13aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudDt3aW5kb3cuV2ViQ29tcG9uZW50cz13aW5kb3cuV2ViQ29tcG9uZW50c3x8e307aWYoRmcmJkZnLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2spe3ZhciBJZyxKZz1mdW5jdGlvbigpe2lmKElnKXtIZy5KJiZIZy5KKHdpbmRvdy5kb2N1bWVudCk7dmFyIGE9SWc7SWc9bnVsbDthKCk7cmV0dXJuITB9fSxLZz1HZy53aGVuUmVhZHk7RmcucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayhmdW5jdGlvbihhKXtJZz1hO0tnKEpnKX0pO0dnLndoZW5SZWFkeT1mdW5jdGlvbihhKXtLZyhmdW5jdGlvbigpe0pnKCk/R2cud2hlblJlYWR5KGEpOmEoKX0pfX1cbkdnLndoZW5SZWFkeShmdW5jdGlvbigpe3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe3dpbmRvdy5XZWJDb21wb25lbnRzLnJlYWR5PSEwO2RvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiV2ViQ29tcG9uZW50c1JlYWR5XCIse2J1YmJsZXM6ITB9KSl9KX0pO3ZhciBMZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7TGcudGV4dENvbnRlbnQ9XCJib2R5IHt0cmFuc2l0aW9uOiBvcGFjaXR5IGVhc2UtaW4gMC4yczsgfSBcXG5ib2R5W3VucmVzb2x2ZWRdIHtvcGFjaXR5OiAwOyBkaXNwbGF5OiBibG9jazsgb3ZlcmZsb3c6IGhpZGRlbjsgcG9zaXRpb246IHJlbGF0aXZlOyB9IFxcblwiO3ZhciBNZz1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaGVhZFwiKTtNZy5pbnNlcnRCZWZvcmUoTGcsTWcuZmlyc3RDaGlsZCk7fSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViY29tcG9uZW50cy1saXRlLmpzLm1hcFxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy93ZWJjb21wb25lbnRzLWxpdGUuanMiLCJ2YXIgZztcclxuXHJcbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXHJcbmcgPSAoZnVuY3Rpb24oKSB7XHJcblx0cmV0dXJuIHRoaXM7XHJcbn0pKCk7XHJcblxyXG50cnkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxyXG5cdGcgPSBnIHx8IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKSB8fCAoMSxldmFsKShcInRoaXNcIik7XHJcbn0gY2F0Y2goZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIilcclxuXHRcdGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCByZWFjdEluaXQgZnJvbSAnLi4vcmVhY3RJbml0JztcblxuY2xhc3MgSGVhZGluZyBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG5cdHJlbmRlcigpIHtcblx0XHR2YXIgSGVhZGluZ1RhZyA9IGAke3RoaXMucHJvcHMuc2l6ZX1gO1xuXG5cdFx0cmV0dXJuIChcblx0XHRcdDxkaXY+XG5cdFx0XHRcdDxIZWFkaW5nVGFnPlxuXHQgICAgICAgIHt0aGlzLnByb3BzLmhlYWRpbmd9XG5cdFx0XHRcdDwvSGVhZGluZ1RhZz5cbiAgICBcdFx0PHA+e3RoaXMucHJvcHMuc3VidGV4dH08L3A+XG5cdFx0XHRcdHt0aGlzLnByb3BzLmhhc2hyICYmXG5cdFx0XHRcdFx0PGhyIC8+XG5cdFx0XHRcdH1cblx0XHRcdDwvZGl2PlxuXHRcdCk7XG5cdH1cbn1cblxucmVhY3RJbml0KFwiLnJlYWN0LWhlYWRpbmdcIiwgSGVhZGluZyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9jb21wb25lbnRzL3JlYWN0SGVhZGluZy9jbGllbnQuanN4IiwiaW1wb3J0IHsgRWxlbWVudCBhcyBQb2x5bWVyRWxlbWVudCB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50JztcbmltcG9ydCB2aWV3IGZyb20gJy4vdHRhLXVuZGVybGluZWQtdGV4dC5odG1sJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVFRBVW5kZXJsaW5lZFRleHQgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgaXMoKSB7XG4gICAgcmV0dXJuIFwidHRhLXVuZGVybGluZWQtdGV4dFwiO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gdmlldztcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRleHQ6IHtcbiAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB9LFxuICAgICAgaGFzSHI6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxuLy8gUmVnaXN0ZXIgY3VzdG9tIGVsZW1lbnQgY2xhc3Mgd2l0aCBicm93c2VyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoVFRBVW5kZXJsaW5lZFRleHQuaXMsIFRUQVVuZGVybGluZWRUZXh0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2VsZW1lbnRzL3R0YS11bmRlcmxpbmVkLXRleHQvdHRhLXVuZGVybGluZWQtdGV4dC5qcyIsImltcG9ydCB7IEVsZW1lbnRNaXhpbiB9IGZyb20gJy4vbGliL21peGlucy9lbGVtZW50LW1peGluLmpzJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZ1xuICogZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sXG4gKiBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uLlxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAcG9seW1lclxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5FbGVtZW50TWl4aW5cbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXInc1xuICogICBrZXkgbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZyxcbiAqICAgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbiwgYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvblxuICovXG5jb25zdCBFbGVtZW50ID0gRWxlbWVudE1peGluKEhUTUxFbGVtZW50KTtcbmV4cG9ydCB7IEVsZW1lbnQgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyByb290UGF0aCBhcyByb290UGF0aCQwIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCAqIGFzIGNhc2VNYXAkMCBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBjYW1lbFRvRGFzaENhc2UgfSBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBjc3NGcm9tTW9kdWxlSW1wb3J0cywgY3NzRnJvbVRlbXBsYXRlIH0gZnJvbSAnLi4vdXRpbHMvc3R5bGUtZ2F0aGVyLmpzJztcbmltcG9ydCB7IHJlc29sdmVVcmwgYXMgcmVzb2x2ZVVybCQwIH0gZnJvbSAnLi4vdXRpbHMvcmVzb2x2ZS11cmwuanMnO1xuaW1wb3J0IHsgRG9tTW9kdWxlIH0gZnJvbSAnLi4vZWxlbWVudHMvZG9tLW1vZHVsZS5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUVmZmVjdHMgfSBmcm9tICcuL3Byb3BlcnR5LWVmZmVjdHMuanMnO1xuXG5leHBvcnQgY29uc3QgRWxlbWVudE1peGluID0gZGVkdXBpbmdNaXhpbihiYXNlID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtiYXNlfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqL1xuICBjb25zdCBwb2x5bWVyRWxlbWVudEJhc2UgPSBQcm9wZXJ0eUVmZmVjdHMoYmFzZSk7XG5cbiAgbGV0IGNhc2VNYXAgPSBjYXNlTWFwJDA7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBwcm9wZXJ0aWVzYCBvYmplY3Qgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3I6XG4gICAqICgxKSBzdXBlciBjaGFpbiBtaXhlcyB0b2d0aGVyIHRvIG1ha2UgYHByb3BlcnRpZXNGb3JDbGFzc2Agd2hpY2ggaXNcbiAgICogdGhlbiB1c2VkIHRvIG1ha2UgYG9ic2VydmVkQXR0cmlidXRlc2AuXG4gICAqICgyKSBwcm9wZXJ0aWVzIGVmZmVjdHMgYW5kIG9ic2VydmVycyBhcmUgY3JlYXRlZCBmcm9tIGl0IGF0IGBmaW5hbGl6ZWAgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIG93biBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25Qcm9wZXJ0aWVzJywga2xhc3MpKSkge1xuICAgICAga2xhc3MuX19vd25Qcm9wZXJ0aWVzID1cbiAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgncHJvcGVydGllcycsIGtsYXNzKSkgP1xuICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3BlcnRpZXMgOiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGtsYXNzLl9fb3duUHJvcGVydGllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgb2JzZXJ2ZXJzYCBhcnJheSBzcGVjaWZpY2FsbHkgb24gYGtsYXNzYC4gVXNlIGZvclxuICAgKiBzZXR0aW5nIHVwIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBvd24gb2JzZXJ2ZXJzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcykge1xuICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX293bk9ic2VydmVycycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fb3duT2JzZXJ2ZXJzID1cbiAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnb2JzZXJ2ZXJzJywga2xhc3MpKSA/XG4gICAgICAgIC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykub2JzZXJ2ZXJzIDogW107XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX293bk9ic2VydmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXhlcyBgcHJvcHNgIGludG8gYGZsYXR0ZW5lZFByb3BzYCBidXQgdXBncmFkZXMgc2hvcnRoYW5kIHR5cGVcbiAgICogc3ludGF4IHRvIHsgdHlwZTogVHlwZX0uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmbGF0dGVuZWRQcm9wcyBCYWcgdG8gY29sbGVjdCBmbGF0dGVuZWQgcHJvcGVydGllcyBpbnRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydGllcyB0byBhZGQgdG8gYGZsYXR0ZW5lZFByb3BzYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBpbnB1dCBgZmxhdHRlbmVkUHJvcHNgIGJhZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmxhdHRlblByb3BlcnRpZXMoZmxhdHRlbmVkUHJvcHMsIHByb3BzKSB7XG4gICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgbGV0IG8gPSBwcm9wc1twXTtcbiAgICAgIGlmICh0eXBlb2YgbyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG8gPSB7IHR5cGU6IG8gfTtcbiAgICAgIH1cbiAgICAgIGZsYXR0ZW5lZFByb3BzW3BdID0gbztcbiAgICB9XG4gICAgcmV0dXJuIGZsYXR0ZW5lZFByb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmbGF0dGVuZWQgbGlzdCBvZiBwcm9wZXJ0aWVzIG1peGVkIHRvZ2V0aGVyIGZyb20gdGhlIGNoYWluIG9mIGFsbFxuICAgKiBjb25zdHJ1Y3RvcidzIGBjb25maWcucHJvcGVydGllc2AuIFRoaXMgbGlzdCBpcyB1c2VkIHRvIGNyZWF0ZVxuICAgKiAoMSkgb2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgKiAoMikgY2xhc3MgcHJvcGVydHkgZGVmYXVsdCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEByZXR1cm4ge1BvbHltZXJFbGVtZW50UHJvcGVydGllc30gRmxhdHRlbmVkIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3NcbiAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBhIHByb3BlcnR5IGZvciBzb21lIHJlYXNvbj9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcykge1xuICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2NsYXNzUHJvcGVydGllcycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzID1cbiAgICAgIGZsYXR0ZW5Qcm9wZXJ0aWVzKHt9LCBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpKTtcbiAgICAgIGxldCBzdXBlckN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoa2xhc3MucHJvdG90eXBlKS5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChzdXBlckN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9seW1lckVsZW1lbnQpIHtcbiAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIE9iamVjdC5jcmVhdGUocHJvcGVydGllc0ZvckNsYXNzKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovKHN1cGVyQ3RvcikpKSxcbiAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydGllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAqIFRoaXMgbGlzdCBpcyBjcmVhdGVkIGFzIGFuIG9wdGltaXphdGlvbiBzaW5jZSBpdCBpcyBhIHN1YnNldCBvZlxuICAgKiB0aGUgbGlzdCByZXR1cm5lZCBmcm9tIGBwcm9wZXJ0aWVzRm9yQ2xhc3NgLlxuICAgKiBUaGlzIGxpc3QgaXMgdXNlZCBpbiBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCB0byBzZXQgcHJvcGVydHkgZGVmYXVsdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqICAgdGhhdCBoYXZlIGRlZmF1bHQgdmFsdWVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMnLCBrbGFzcykpKSB7XG4gICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyA9IG51bGw7XG4gICAgICBsZXQgcHJvcHMgPSBwcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICBsZXQgaW5mbyA9IHByb3BzW3BdO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBpbmZvKSB7XG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgPSBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyB8fCB7fTtcbiAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0c1twXSA9IGluZm87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGBrbGFzc2AgaGFzIGZpbmFsaXplZC4gQ2FsbGVkIGluIGBFbGVtZW50Q2xhc3MuZmluYWxpemUoKWBcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWxsIG1ldGFwcm9ncmFtbWluZyBmb3IgdGhpcyBjbGFzcyBoYXMgYmVlblxuICAgKiAgIGNvbXBsZXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzQ2xhc3NGaW5hbGl6ZWQoa2xhc3MpIHtcbiAgICByZXR1cm4ga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19maW5hbGl6ZWQnLCBrbGFzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgLiBFbnN1cmVzIHRoaXMgYGtsYXNzYCBhbmRcbiAgICogKmFsbCBzdXBlcmNsYXNzZXMqIGFyZSBmaW5hbGl6ZWQgYnkgdHJhdmVyc2luZyB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAqIGFuZCBjYWxsaW5nIGBrbGFzcy5maW5hbGl6ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIoa2xhc3MpIHtcbiAgICBsZXQgcHJvdG8gPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3RvdHlwZTtcbiAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICBzdXBlckN0b3IuZmluYWxpemUoKTtcbiAgICB9XG4gICAgZmluYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyBhIGBrbGFzc2AgYmFzZWQgb24gYSBzdGFpYyBga2xhc3MuY29uZmlnYCBvYmplY3QgYW5kXG4gICAqIGEgYHRlbXBsYXRlYC4gVGhpcyBpbmNsdWRlcyBjcmVhdGluZyBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICogZm9yIHByb3BlcnRpZXMgaW4gYGNvbmZpZ2AgYW5kIHRoZSBgdGVtcGxhdGVgIGFzIHdlbGwgYXMgcHJlcGFyaW5nIHRoZVxuICAgKiBgdGVtcGxhdGVgIGZvciBzdGFtcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzKGtsYXNzKSB7XG4gICAga2xhc3MuX19maW5hbGl6ZWQgPSB0cnVlO1xuICAgIGxldCBwcm90byA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykucHJvdG90eXBlO1xuICAgIGlmIChrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ2lzJywga2xhc3MpKSAmJiBrbGFzcy5pcykge1xuICAgICAgcmVnaXN0ZXIocHJvdG8pO1xuICAgIH1cbiAgICBsZXQgcHJvcHMgPSBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wcyk7XG4gICAgfVxuICAgIGxldCBvYnNlcnZlcnMgPSBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcyk7XG4gICAgaWYgKG9ic2VydmVycykge1xuICAgICAgZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgcHJvcHMpO1xuICAgIH1cbiAgICAvLyBub3RlOiBjcmVhdGUgXCJ3b3JraW5nXCIgdGVtcGxhdGUgdGhhdCBpcyBmaW5hbGl6ZWQgYXQgaW5zdGFuY2UgdGltZVxuICAgIGxldCB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBsZXQgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHQuaW5uZXJIVE1MID0gdGVtcGxhdGU7XG4gICAgICAgIHRlbXBsYXRlID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfVxuICAgICAgcHJvdG8uX3RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYHByb3BlcnRpZXNgIG9iamVjdC5cbiAgICogTGV2ZXJhZ2VzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIGNyZWF0ZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICogc3VwcG9ydGluZywgb2JzZXJ2ZXJzLCByZWZsZWN0aW5nIHRvIGF0dHJpYnV0ZXMsIGNoYW5nZSBub3RpZmljYXRpb24sXG4gICAqIGNvbXB1dGVkIHByb3BlcnRpZXMsIGFuZCByZWFkIG9ubHkgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgICBhbmQgZWZmZWN0cyB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBGbGF0dGVuZWQgYmFnIG9mIHByb3BlcnR5IGRlc2NyaXB0b3JzIGZvclxuICAgKiAgICB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGxldCBwIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGNyZWF0ZVByb3BlcnR5RnJvbUNvbmZpZyhwcm90bywgcCwgcHJvcGVydGllc1twXSwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYG9ic2VydmVyc2AgYXJyYXkuXG4gICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgb2JzZXJ2ZXJzLlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVycyBGbGF0dGVuZWQgYXJyYXkgb2Ygb2JzZXJ2ZXIgZGVzY3JpcHRvcnMgZm9yXG4gICAqICAgdGhpcyBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZHluYW1pY0ZucyBPYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBhbnkgcHJvcGVydGllc1xuICAgKiAgIHRoYXQgYXJlIGZ1bmN0aW9ucyBhbmQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdCB3aGVuIHRoZSBmdW5jdGlvblxuICAgKiAgIHJlZmVyZW5jZSBpcyBjaGFuZ2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZU9ic2VydmVycyhwcm90bywgb2JzZXJ2ZXJzLCBkeW5hbWljRm5zKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgb2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm90by5fY3JlYXRlTWV0aG9kT2JzZXJ2ZXIob2JzZXJ2ZXJzW2ldLCBkeW5hbWljRm5zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBlZmZlY3RzIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBOb3RlLCBvbmNlIGEgcHJvcGVydHkgaGFzIGJlZW4gc2V0IHRvXG4gICAqIGByZWFkT25seWAsIGBjb21wdXRlZGAsIGByZWZsZWN0VG9BdHRyaWJ1dGVgLCBvciBgbm90aWZ5YFxuICAgKiB0aGVzZSB2YWx1ZXMgbWF5IG5vdCBiZSBjaGFuZ2VkLiBGb3IgZXhhbXBsZSwgYSBzdWJjbGFzcyBjYW5ub3RcbiAgICogYWx0ZXIgdGhlc2Ugc2V0dGluZ3MuIEhvd2V2ZXIsIGFkZGl0aW9uYWwgYG9ic2VydmVyc2AgbWF5IGJlIGFkZGVkXG4gICAqIGJ5IHN1YmNsYXNzZXMuXG4gICAqXG4gICAqIFRoZSBpbmZvIG9iamVjdCBzaG91bGQgbWF5IGNvbnRhaW4gcHJvcGVydHkgbWV0YWRhdGEgYXMgZm9sbG93czpcbiAgICpcbiAgICogKiBgdHlwZWA6IHtmdW5jdGlvbn0gdHlwZSB0byB3aGljaCBhbiBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIHByb3BlcnR5XG4gICAqIGlzIGRlc2VyaWFsaXplZC4gTm90ZSB0aGUgcHJvcGVydHkgaXMgY2FtZWwtY2FzZWQgZnJvbSBhIGRhc2gtY2FzZWRcbiAgICogYXR0cmlidXRlLiBGb3IgZXhhbXBsZSwgJ2Zvby1iYXInIGF0dHJpYnV0ZSBpcyBkZXJzaWFsaXplZCB0byBhXG4gICAqIHByb3BlcnR5IG5hbWVkICdmb29CYXInLlxuICAgKlxuICAgKiAqIGByZWFkT25seWA6IHtib29sZWFufSBjcmVhdGVzIGEgcmVhZE9ubHkgcHJvcGVydHkgYW5kXG4gICAqIG1ha2VzIGEgcHJpdmF0ZSBzZXR0ZXIgZm9yIHRoZSBwcml2YXRlIG9mIHRoZSBmb3JtICdfc2V0Rm9vJyBmb3IgYVxuICAgKiBwcm9wZXJ0eSAnZm9vJyxcbiAgICpcbiAgICogKiBgY29tcHV0ZWRgOiB7c3RyaW5nfSBjcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkuIEEgY29tcHV0ZWQgcHJvcGVydHlcbiAgICogYWxzbyBhdXRvbWF0aWNhbGx5IGlzIHNldCB0byBgcmVhZE9ubHk6IHRydWVgLiBUaGUgdmFsdWUgaXMgY2FsY3VsYXRlZFxuICAgKiBieSBydW5uaW5nIGEgbWV0aG9kIGFuZCBhcmd1bWVudHMgcGFyc2VkIGZyb20gdGhlIGdpdmVuIHN0cmluZy4gRm9yXG4gICAqIGV4YW1wbGUgJ2NvbXB1dGUoZm9vKScgd2lsbCBjb21wdXRlIGEgZ2l2ZW4gcHJvcGVydHkgd2hlbiB0aGVcbiAgICogJ2ZvbycgcHJvcGVydHkgY2hhbmdlcyBieSBleGVjdXRpbmcgdGhlICdjb21wdXRlJyBtZXRob2QuIFRoaXMgbWV0aG9kXG4gICAqIG11c3QgcmV0dXJuIHRoZSBjb21wdXRlZCB2YWx1ZS5cbiAgICpcbiAgICogKiBgcmVmbGVjdFRvQXR0cml1dGVgOiB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJlZmxlY3RlZFxuICAgKiB0byBhbiBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS4gTm90ZSwgdGhlIGF0dHJpYnV0ZSBpcyBkYXNoLWNhc2VkXG4gICAqIHNvIGEgcHJvcGVydHkgbmFtZWQgJ2Zvb0JhcicgaXMgcmVmbGVjdGVkIGFzICdmb28tYmFyJy5cbiAgICpcbiAgICogKiBgbm90aWZ5YDoge2Jvb2xlYW59IHNlbmRzIGEgbm9uLWJ1YmJsaW5nIG5vdGlmaWNhdGlvbiBldmVudCB3aGVuXG4gICAqIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSBwcm9wZXJ0eSBuYW1lZCAnZm9vJyBzZW5kcyBhblxuICAgKiBldmVudCBuYW1lZCAnZm9vLWNoYW5nZWQnIHdpdGggYGV2ZW50LmRldGFpbGAgc2V0IHRvIHRoZSB2YWx1ZSBvZlxuICAgKiB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqICogb2JzZXJ2ZXI6IHtzdHJpbmd9IG5hbWUgb2YgYSBtZXRob2QgdGhhdCBydW5zIHdoZW4gdGhlIHByb3BlcnR5XG4gICAqIGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmUgKHZhbHVlLCBwcmV2aW91c1ZhbHVlKS5cbiAgICpcbiAgICogTm90ZTogVXNlcnMgbWF5IHdhbnQgY29udHJvbCBvdmVyIG1vZGlmeWluZyBwcm9wZXJ0eVxuICAgKiBlZmZlY3RzIHZpYSBzdWJjbGFzc2luZy4gRm9yIGV4YW1wbGUsIGEgdXNlciBtaWdodCB3YW50IHRvIG1ha2UgYVxuICAgKiByZWZsZWN0VG9BdHRyaWJ1dGUgcHJvcGVydHkgbm90IGRvIHNvIGluIGEgc3ViY2xhc3MuIFdlJ3ZlIGNob3NlbiB0b1xuICAgKiBkaXNhYmxlIHRoaXMgYmVjYXVzZSBpdCBsZWFkcyB0byBhZGRpdGlvbmFsIGNvbXBsaWNhdGlvbi5cbiAgICogRm9yIGV4YW1wbGUsIGEgcmVhZE9ubHkgZWZmZWN0IGdlbmVyYXRlcyBhIHNwZWNpYWwgc2V0dGVyLiBJZiBhIHN1YmNsYXNzXG4gICAqIGRpc2FibGVzIHRoZSBlZmZlY3QsIHRoZSBzZXR0ZXIgd291bGQgZmFpbCB1bmV4cGVjdGVkbHkuXG4gICAqIEJhc2VkIG9uIGZlZWRiYWNrLCB3ZSBtYXkgd2FudCB0byB0cnkgdG8gbWFrZSBlZmZlY3RzIG1vcmUgbWFsbGVhYmxlXG4gICAqIGFuZC9vciBwcm92aWRlIGFuIGFkdmFuY2VkIGFwaSBmb3IgbWFuaXB1bGF0aW5nIHRoZW0uXG4gICAqIEFsc28gY29uc2lkZXIgYWRkaW5nIHdhcm5pbmdzIHdoZW4gYW4gZWZmZWN0IGNhbm5vdCBiZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIEluZm8gb2JqZWN0IGZyb20gd2hpY2ggdG8gY3JlYXRlIHByb3BlcnR5IGVmZmVjdHMuXG4gICAqIFN1cHBvcnRlZCBrZXlzOlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWxsUHJvcHMgRmxhdHRlbmVkIG1hcCBvZiBhbGwgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoaXNcbiAgICogICBlbGVtZW50IChpbmNsdWRpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIG5hbWUsIGluZm8sIGFsbFByb3BzKSB7XG4gICAgLy8gY29tcHV0ZWQgZm9yY2VzIHJlYWRPbmx5Li4uXG4gICAgaWYgKGluZm8uY29tcHV0ZWQpIHtcbiAgICAgIGluZm8ucmVhZE9ubHkgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBOb3RlLCBzaW5jZSBhbGwgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZE9ubHksIHRoaXMgcHJldmVudHNcbiAgICAvLyBhZGRpbmcgYWRkaXRpb25hbCBjb21wdXRlZCBwcm9wZXJ0eSBlZmZlY3RzICh3aGljaCBsZWFkcyB0byBhIGNvbmZ1c2luZ1xuICAgIC8vIHNldHVwIHdoZXJlIG11bHRpcGxlIHRyaWdnZXJzIGZvciBzZXR0aW5nIGEgcHJvcGVydHkpXG4gICAgLy8gV2hpbGUgd2UgZG8gaGF2ZSBgaGFzQ29tcHV0ZWRFZmZlY3RgIHRoaXMgaXMgc2V0IG9uIHRoZSBwcm9wZXJ0eSdzXG4gICAgLy8gZGVwZW5kZW5jaWVzIHJhdGhlciB0aGFuIGl0c2VsZi5cbiAgICBpZiAoaW5mby5jb21wdXRlZCAgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkobmFtZSwgaW5mby5jb21wdXRlZCwgYWxsUHJvcHMpO1xuICAgIH1cbiAgICBpZiAoaW5mby5yZWFkT25seSAmJiAhcHJvdG8uX2hhc1JlYWRPbmx5RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShuYW1lLCAhaW5mby5jb21wdXRlZCk7XG4gICAgfVxuICAgIGlmIChpbmZvLnJlZmxlY3RUb0F0dHJpYnV0ZSAmJiAhcHJvdG8uX2hhc1JlZmxlY3RFZmZlY3QobmFtZSkpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgaWYgKGluZm8ubm90aWZ5ICYmICFwcm90by5faGFzTm90aWZ5RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBhZGQgb2JzZXJ2ZXJcbiAgICBpZiAoaW5mby5vYnNlcnZlcikge1xuICAgICAgcHJvdG8uX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIobmFtZSwgaW5mby5vYnNlcnZlciwgYWxsUHJvcHNbaW5mby5vYnNlcnZlcl0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGFuIGVsZW1lbnQgYHByb3RvYCB0byBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gYHRlbXBsYXRlYC5cbiAgICogVGhlIGVsZW1lbnQgbmFtZSBgaXNgIGFuZCBleHRlbmRzIGBleHRgIG11c3QgYmUgc3BlY2lmaWVkIGZvciBTaGFkeUNTU1xuICAgKiBzdHlsZSBzY29waW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcHJvY2VzcyBhbmQgYmluZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBVUkwgYWdhaW5zdCB3aGljaCB0byByZXNvbHZlIHVybHMgaW5cbiAgICogICBzdHlsZSBlbGVtZW50IGNzc1RleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlzIFRhZyBuYW1lIChvciB0eXBlIGV4dGVuc2lvbiBuYW1lKSBmb3IgdGhpcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gZXh0IEZvciB0eXBlIGV4dGVuc2lvbnMsIHRoZSB0YWcgbmFtZSB0aGF0IHdhcyBleHRlbmRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVUZW1wbGF0ZShwcm90bywgdGVtcGxhdGUsIGJhc2VVUkksIGlzLCBleHQpIHtcbiAgICAvLyBzdXBwb3J0IGBpbmNsdWRlPVwibW9kdWxlLW5hbWVcImBcbiAgICBsZXQgY3NzVGV4dCA9XG4gICAgICBjc3NGcm9tTW9kdWxlSW1wb3J0cyhpcykgK1xuICAgICAgY3NzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBiYXNlVVJJKTtcbiAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgbGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzVGV4dDtcbiAgICAgIHRlbXBsYXRlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICB3aW5kb3cuU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBpcywgZXh0KTtcbiAgICB9XG4gICAgcHJvdG8uX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQHVucmVzdHJpY3RlZFxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAqL1xuICBjbGFzcyBQb2x5bWVyRWxlbWVudCBleHRlbmRzIHBvbHltZXJFbGVtZW50QmFzZSB7XG5cbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBDdXN0b20gRWxlbWVudHMgVjEgQVBJLiAgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJuc1xuICAgICAqIGEgbGlzdCBvZiBkYXNoLWNhc2VkIGF0dHJpYnV0ZXMgYmFzZWQgb24gYSBmbGF0dGVuaW5nIG9mIGFsbCBwcm9wZXJ0aWVzXG4gICAgICogZGVjbGFyZWQgaW4gYHN0YXRpYyBnZXQgcHJvcGVydGllcygpYCBmb3IgdGhpcyBlbGVtZW50IGFuZCBhbnlcbiAgICAgKiBzdXBlcmNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gT2JzZXJ2ZWQgYXR0cmlidXRlIGxpc3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX29ic2VydmVkQXR0cmlidXRlcycsIHRoaXMpKSkge1xuICAgICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgICBsZXQgcHJvcGVydGllcyA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKGNhbWVsVG9EYXNoQ2FzZShwcm9wKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcyA9IGxpc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlIGlzIGNyZWF0ZWQgdG9cbiAgICAgKiBlbnN1cmUgdGhhdCBjbGFzcyBmaW5hbGl6YXRpb24gd29yayBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAgICogTWF5IGJlIGNhbGxlZCBieSB1c2VycyB0byBlYWdlcmx5IHBlcmZvcm0gY2xhc3MgZmluYWxpemF0aW9uIHdvcmtcbiAgICAgKiBwcmlvciB0byB0aGUgY3JlYXRpb24gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBDbGFzcyBmaW5hbGl6YXRpb24gd29yayBnZW5lcmFsbHkgaW5jbHVkZXMgbWV0YS1wcm9ncmFtbWluZyBzdWNoIGFzXG4gICAgICogY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBhbnkgcHJvcGVydHkgZWZmZWN0IG1ldGFkYXRhIG5lZWRlZCBmb3JcbiAgICAgKiB0aGUgZmVhdHVyZXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemUoKSB7XG4gICAgICBpZiAoIWhhc0NsYXNzRmluYWxpemVkKHRoaXMpKSB7XG4gICAgICAgIGZpbmFsaXplQ2xhc3NBbmRTdXBlcih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgc3RhbXBlZCBpbnRvIHRoaXMgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqXG4gICAgICogSWYgYSBgc3RhdGljIGdldCBpcygpYCBnZXR0ZXIgaXMgZGVmaW5lZCwgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICAgKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgYDx0ZW1wbGF0ZT5gIGluIGEgYGRvbS1tb2R1bGVgIHdob3NlIGBpZGBcbiAgICAgKiBtYXRjaGVzIHRoaXMgZWxlbWVudCdzIGBpc2AuXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgdG8gcmV0dXJuIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgICAqIChpbiB3aGljaCBjYXNlIHRoZSBgaXNgIGdldHRlciBpcyB1bm5lY2Vzc2FyeSkuIFRoZSB0ZW1wbGF0ZSByZXR1cm5lZFxuICAgICAqIG1heSBiZSBlaXRoZXIgYW4gYEhUTUxUZW1wbGF0ZUVsZW1lbnRgIG9yIGEgc3RyaW5nIHRoYXQgd2lsbCBiZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgcGFyc2VkIGludG8gYSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3aGVuIHN1YmNsYXNzaW5nLCBpZiB0aGUgc3VwZXIgY2xhc3Mgb3ZlcnJvZGUgdGhlIGRlZmF1bHRcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gcHJvdmlkZSBhbiBhbHRlcm5hdGVcbiAgICAgKiB0ZW1wbGF0ZSB2aWEgYSBgZG9tLW1vZHVsZWAsIGl0IHNob3VsZCBvdmVycmlkZSB0aGlzIGdldHRlciBhbmRcbiAgICAgKiByZXR1cm4gYFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKWAuXG4gICAgICpcbiAgICAgKiBJZiBhIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gbW9kaWZ5IHRoZSBzdXBlciBjbGFzcyB0ZW1wbGF0ZSwgaXQgc2hvdWxkXG4gICAgICogY2xvbmUgaXQgcmF0aGVyIHRoYW4gbW9kaWZ5IGl0IGluIHBsYWNlLiAgSWYgdGhlIGdldHRlciBkb2VzIGV4cGVuc2l2ZVxuICAgICAqIHdvcmsgc3VjaCBhcyBjbG9uaW5nL21vZGlmeWluZyBhIHRlbXBsYXRlLCBpdCBzaG91bGQgbWVtb2l6ZSB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZTpcbiAgICAgKlxuICAgICAqICAgbGV0IG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICogICBjbGFzcyBNeVN1YkNsYXNzIGV4dGVuZHMgTXlTdXBlckNsYXNzIHtcbiAgICAgKiAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgKiAgICAgICBpZiAoIW1lbW9pemVkVGVtcGxhdGUpIHtcbiAgICAgKiAgICAgICAgIG1lbW9pemVkVGVtcGxhdGUgPSBzdXBlci50ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICAgICAgICBsZXQgc3ViQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAqICAgICAgICAgc3ViQ29udGVudC50ZXh0Q29udGVudCA9ICdUaGlzIGNhbWUgZnJvbSBNeVN1YkNsYXNzJztcbiAgICAgKiAgICAgICAgIG1lbW9pemVkVGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChzdWJDb250ZW50KTtcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgICAgcmV0dXJuIG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxUZW1wbGF0ZUVsZW1lbnR8c3RyaW5nfSBUZW1wbGF0ZSB0byBiZSBzdGFtcGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfdGVtcGxhdGUnLCB0aGlzKSkpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydChcbiAgICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciovICh0aGlzKS5pcywgJ3RlbXBsYXRlJykgfHxcbiAgICAgICAgICAvLyBub3RlOiBpbXBsZW1lbnRlZCBzbyBhIHN1YmNsYXNzIGNhbiByZXRyaWV2ZSB0aGUgc3VwZXJcbiAgICAgICAgICAvLyB0ZW1wbGF0ZTsgY2FsbCB0aGUgc3VwZXIgaW1wbCB0aGlzIHdheSBzbyB0aGF0IGB0aGlzYCBwb2ludHNcbiAgICAgICAgICAvLyB0byB0aGUgc3VwZXJjbGFzcy5cbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci50ZW1wbGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRoIG1hdGNoaW5nIHRoZSB1cmwgZnJvbSB3aGljaCB0aGUgZWxlbWVudCB3YXMgaW1wb3J0ZWQuXG4gICAgICogVGhpcyBwYXRoIGlzIHVzZWQgdG8gcmVzb2x2ZSB1cmwncyBpbiB0ZW1wbGF0ZSBzdHlsZSBjc3NUZXh0LlxuICAgICAqIFRoZSBgaW1wb3J0UGF0aGAgcHJvcGVydHkgaXMgYWxzbyBzZXQgb24gZWxlbWVudCBpbnN0YW5jZXMgYW5kIGNhbiBiZVxuICAgICAqIHVzZWQgdG8gY3JlYXRlIGJpbmRpbmdzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgcGF0aC5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgcGF0aCBtYXRjaGluZyB0aGUgdXJsIGNvbnRhaW5pbmcgYSBgZG9tLW1vZHVsZWAgZWxlbWVudFxuICAgICAqIG1hdGNoaW5nIHRoaXMgZWxlbWVudCdzIHN0YXRpYyBgaXNgIHByb3BlcnR5LlxuICAgICAqIE5vdGUsIHRoaXMgcGF0aCBzaG91bGQgY29udGFpbiBhIHRyYWlsaW5nIGAvYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGltcG9ydCBwYXRoIGZvciB0aGlzIGVsZW1lbnQgY2xhc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGltcG9ydFBhdGgoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX2ltcG9ydFBhdGgnLCB0aGlzKSkpIHtcbiAgICAgICAgICBjb25zdCBtb2R1bGUgPSBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydCgvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAodGhpcykuaXMpO1xuICAgICAgICAgIHRoaXMuX2ltcG9ydFBhdGggPSBtb2R1bGUgPyBtb2R1bGUuYXNzZXRwYXRoIDogJycgfHxcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2ltcG9ydFBhdGg7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fdGVtcGxhdGU7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMuX2ltcG9ydFBhdGg7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMucm9vdFBhdGg7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMuaW1wb3J0UGF0aDtcbiAgICAgIC8qKiBAdHlwZSB7U3RhbXBlZFRlbXBsYXRlIHwgSFRNTEVsZW1lbnQgfCBTaGFkb3dSb290fSAqL1xuICAgICAgdGhpcy5yb290O1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIU5vZGU+fSAqL1xuICAgICAgdGhpcy4kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgdG8gZW5zdXJlIGNsYXNzXG4gICAgICogbWV0YXByb2dyYW1taW5nIHJlbGF0ZWQgdG8gcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzIGhhc1xuICAgICAqIGNvbXBsZXRlZCAoY2FsbHMgYGZpbmFsaXplYCkuXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIGluaXRpYWxpemVzIGFueSBwcm9wZXJ0eSBkZWZhdWx0cyBwcm92aWRlZCB2aWEgYHZhbHVlYCBpblxuICAgICAqIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgIGluc3RhbmNlQ291bnQrKztcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuZmluYWxpemUoKTtcbiAgICAgIGNvbnN0IGltcG9ydFBhdGggPSB0aGlzLmNvbnN0cnVjdG9yLmltcG9ydFBhdGg7XG4gICAgICAvLyBub3RlOiBmaW5hbGl6ZSB0ZW1wbGF0ZSB3aGVuIHdlIGhhdmUgYWNjZXNzIHRvIGBsb2NhbE5hbWVgIHRvXG4gICAgICAvLyBhdm9pZCBkZXBlbmRlbmNlIG9uIGBpc2AgZm9yIHBvbHlmaWxsaW5nIHN0eWxpbmcuXG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiYgIXRoaXMuX3RlbXBsYXRlLl9fcG9seW1lckZpbmFsaXplZCkge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBiYXNlVVJJID1cbiAgICAgICAgICBpbXBvcnRQYXRoID8gcmVzb2x2ZVVybCQwKGltcG9ydFBhdGgpIDogJyc7XG4gICAgICAgIGZpbmFsaXplVGVtcGxhdGUoLyoqIEB0eXBlIHshUG9seW1lckVsZW1lbnR9ICovKHRoaXMuX19wcm90b19fKSwgdGhpcy5fdGVtcGxhdGUsIGJhc2VVUkksXG4gICAgICAgICAgLyoqQHR5cGUgeyFIVE1MRWxlbWVudH0qLyh0aGlzKS5sb2NhbE5hbWUpO1xuICAgICAgfVxuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICAvLyBzZXQgcGF0aCBkZWZhdWx0c1xuICAgICAgdGhpcy5yb290UGF0aCA9IHJvb3RQYXRoJDA7XG4gICAgICB0aGlzLmltcG9ydFBhdGggPSBpbXBvcnRQYXRoO1xuICAgICAgLy8gYXBwbHkgcHJvcGVydHkgZGVmYXVsdHMuLi5cbiAgICAgIGxldCBwJCA9IHByb3BlcnR5RGVmYXVsdHNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIGlmICghcCQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgcCBpbiBwJCkge1xuICAgICAgICBsZXQgaW5mbyA9IHAkW3BdO1xuICAgICAgICAvLyBEb24ndCBzZXQgZGVmYXVsdCB2YWx1ZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIG93biBwcm9wZXJ0eSwgd2hpY2hcbiAgICAgICAgLy8gaGFwcGVucyB3aGVuIGEgYHByb3BlcnRpZXNgIHByb3BlcnR5IHdpdGggZGVmYXVsdCBidXQgbm8gZWZmZWN0cyBoYWRcbiAgICAgICAgLy8gYSBwcm9wZXJ0eSBzZXQgKGUuZy4gYm91bmQpIGJ5IGl0cyBob3N0IGJlZm9yZSB1cGdyYWRlXG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHR5cGVvZiBpbmZvLnZhbHVlID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgaW5mby52YWx1ZS5jYWxsKHRoaXMpIDpcbiAgICAgICAgICAgIGluZm8udmFsdWU7XG4gICAgICAgICAgLy8gU2V0IHZpYSBgX3NldFByb3BlcnR5YCBpZiB0aGVyZSBpcyBhbiBhY2Nlc3NvciwgdG8gZW5hYmxlXG4gICAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHJlYWRPbmx5IHByb3BlcnR5IGRlZmF1bHRzXG4gICAgICAgICAgaWYgKHRoaXMuX2hhc0FjY2Vzc29yKHApKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW3BdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgKiBgY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZW5hYmxlcyB0aGUgcHJvcGVydHkgZWZmZWN0cyBzeXN0ZW0gYW5kXG4gICAgICogZmx1c2hlcyBhbnkgcGVuZGluZyBwcm9wZXJ0aWVzLCBhbmQgdXBkYXRlcyBzaGltbWVkIENTUyBwcm9wZXJ0aWVzXG4gICAgICogd2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZy9jdXN0b20gcHJvcGVydGllcyBwb2x5ZmlsbC5cbiAgICAgKlxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgKiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cblxuICAgIC8qKlxuICAgICAqIFN0YW1wcyB0aGUgZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fdGVtcGxhdGUpO1xuICAgICAgICB0aGlzLiQgPSB0aGlzLnJvb3QuJDtcbiAgICAgIH1cbiAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBgUHJvcGVydHlFZmZlY3RzYCdzIGBfcmVhZHlDbGllbnRzYCBjYWxsLiBBdHRhY2hlc1xuICAgICAqIGVsZW1lbnQgZG9tIGJ5IGNhbGxpbmcgYF9hdHRhY2hEb21gIHdpdGggdGhlIGRvbSBzdGFtcGVkIGZyb20gdGhlXG4gICAgICogZWxlbWVudCdzIHRlbXBsYXRlIHZpYSBgX3N0YW1wVGVtcGxhdGVgLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3NcbiAgICAgKiBjbGllbnQgZG9tIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50IHByaW9yIHRvIGFueSBvYnNlcnZlcnNcbiAgICAgKiBydW5uaW5nLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3JlYWR5Q2xpZW50cygpIHtcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9hdHRhY2hEb20oLyoqIEB0eXBlIHtTdGFtcGVkVGVtcGxhdGV9ICovKHRoaXMucm9vdCkpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHN1cGVyLl9yZWFkeUNsaWVudHMgaGVyZSBzZXRzIHRoZSBjbGllbnRzIGluaXRpYWxpemVkIGZsYWcuXG4gICAgICAvLyBXZSBtdXN0IHdhaXQgdG8gZG8gdGhpcyB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGNyZWF0ZWQvYXR0YWNoZWRcbiAgICAgIC8vIHNvIHRoYXQgdGhpcyBmbGFnIGNhbiBiZSBjaGVja2VkIHRvIHByZXZlbnQgbm90aWZpY2F0aW9ucyBmaXJlZFxuICAgICAgLy8gZHVyaW5nIHRoaXMgcHJvY2VzcyBmcm9tIGJlaW5nIGhhbmRsZWQgYmVmb3JlIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgc3VwZXIuX3JlYWR5Q2xpZW50cygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYW4gZWxlbWVudCdzIHN0YW1wZWQgZG9tIHRvIGl0c2VsZi4gQnkgZGVmYXVsdCxcbiAgICAgKiB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgYHNoYWRvd1Jvb3RgIGFuZCBhZGRzIHRoZSBkb20gdG8gaXQuXG4gICAgICogSG93ZXZlciwgdGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWxsb3cgYW4gZWxlbWVudFxuICAgICAqIHRvIHB1dCBpdHMgZG9tIGluIGFub3RoZXIgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdSZXR1cm59XG4gICAgICogQHBhcmFtIHtTdGFtcGVkVGVtcGxhdGV9IGRvbSB0byBhdHRhY2ggdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7U2hhZG93Um9vdH0gbm9kZSB0byB3aGljaCB0aGUgZG9tIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAqL1xuICAgIF9hdHRhY2hEb20oZG9tKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRvd0RPTSBub3QgYXZhaWxhYmxlLiAnICtcbiAgICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBtb3ZlIHRvIGNvbXBpbGUtdGltZSBjb25kaXRpb25hbCB3aGVuIHN1cHBvcnRlZFxuICAgICAgICAnUG9seW1lci5FbGVtZW50IGNhbiBjcmVhdGUgZG9tIGFzIGNoaWxkcmVuIGluc3RlYWQgb2YgaW4gJyArXG4gICAgICAgICdTaGFkb3dET00gYnkgc2V0dGluZyBgdGhpcy5yb290ID0gdGhpcztcXGAgYmVmb3JlIFxcYHJlYWR5XFxgLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBhdHRyaWJ1dGVzIGRlY2xhcmVkIGluIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YSBhcmVcbiAgICAgKiBkZXNlcmlhbGl6ZWQgdXNpbmcgdGhlaXIgYHR5cGVgIGluZm9ybWF0aW9uIHRvIHByb3BlcnRpZXMgb2YgdGhlXG4gICAgICogc2FtZSBuYW1lLiAgXCJEYXNoLWNhc2VkXCIgYXR0cmlidXRlcyBhcmUgZGVzZXJpYWx6ZWQgdG8gXCJjYW1lbENhc2VcIlxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKG5hbWUpO1xuICAgICAgICBsZXQgdHlwZSA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKVtwcm9wZXJ0eV0udHlwZTtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0eSBzaGltLCBjYXVzZXMgYWxsXG4gICAgICogc2hpbW1lZCBzdHlsZXMgaW4gdGhpcyBlbGVtZW50IChhbmQgaXRzIHN1YnRyZWUpIHRvIGJlIHVwZGF0ZWRcbiAgICAgKiBiYXNlZCBvbiBjdXJyZW50IGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3B0aW9uYWwgcGFyYW1ldGVyIG92ZXJyaWRlcyBpbmxpbmUgY3VzdG9tIHByb3BlcnR5IHN0eWxlcyB3aXRoIGFuXG4gICAgICogb2JqZWN0IG9mIHByb3BlcnRpZXMgd2hlcmUgdGhlIGtleXMgYXJlIENTUyBwcm9wZXJ0aWVzLCBhbmQgdGhlIHZhbHVlc1xuICAgICAqIGFyZSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogRXhhbXBsZTogYHRoaXMudXBkYXRlU3R5bGVzKHsnLS1jb2xvcic6ICdibHVlJ30pYFxuICAgICAqXG4gICAgICogVGhlc2UgcHJvcGVydGllcyBhcmUgcmV0YWluZWQgdW5sZXNzIGEgdmFsdWUgb2YgYG51bGxgIGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBCYWcgb2YgY3VzdG9tIHByb3BlcnR5IGtleS92YWx1ZXMgdG9cbiAgICAgKiAgIGFwcGx5IHRvIHRoaXMgZWxlbWVudC5cbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICB1cGRhdGVTdHlsZXMocHJvcGVydGllcykge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVTdWJ0cmVlKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSwgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV3cml0ZXMgYSBnaXZlbiBVUkwgcmVsYXRpdmUgdG8gYSBiYXNlIFVSTC4gVGhlIGJhc2UgVVJMIGRlZmF1bHRzIHRvXG4gICAgICogdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBkb2N1bWVudCBjb250YWluaW5nIHRoZSBgZG9tLW1vZHVsZWAgZm9yXG4gICAgICogdGhpcyBlbGVtZW50LiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZSBVUkwgYmVmb3JlIGFuZCBhZnRlclxuICAgICAqIGJ1bmRsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJhc2UgT3B0aW9uYWwgYmFzZSBVUkwgdG8gcmVzb2x2ZSBhZ2FpbnN0LCBkZWZhdWx0c1xuICAgICAqIHRvIHRoZSBlbGVtZW50J3MgYGltcG9ydFBhdGhgXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXdyaXR0ZW4gVVJMIHJlbGF0aXZlIHRvIGJhc2VcbiAgICAgKi9cbiAgICByZXNvbHZlVXJsKHVybCwgYmFzZSkge1xuICAgICAgaWYgKCFiYXNlICYmIHRoaXMuaW1wb3J0UGF0aCkge1xuICAgICAgICBiYXNlID0gcmVzb2x2ZVVybCQwKHRoaXMuaW1wb3J0UGF0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZVVybCQwKHVybCwgYmFzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yc2AgdG8gYWRkIG1hcCBvZiBkeW5hbWljIGZ1bmN0aW9ucyBvblxuICAgICAqIHRlbXBsYXRlIGluZm8sIGZvciBjb25zdW1wdGlvbiBieSBgUHJvcGVydHlFZmZlY3RzYCB0ZW1wbGF0ZSBiaW5kaW5nXG4gICAgICogY29kZS4gVGhpcyBtYXAgZGV0ZXJtaW5lcyB3aGljaCBtZXRob2QgdGVtcGxhdGVzIHNob3VsZCBoYXZlIGFjY2Vzc29yc1xuICAgICAqIGNyZWF0ZWQgZm9yIHRoZW0uXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyA9IHRlbXBsYXRlSW5mby5keW5hbWljRm5zIHx8IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgIHJldHVybiBzdXBlci5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFBvbHltZXJFbGVtZW50O1xufSk7XG5cbmV4cG9ydCBsZXQgaW5zdGFuY2VDb3VudCA9IDA7XG5leHBvcnQgY29uc3QgcmVnaXN0cmF0aW9ucyA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gX3JlZ0xvZyhwcm90b3R5cGUpIHtcbiAgY29uc29sZS5sb2coJ1snICsgcHJvdG90eXBlLmlzICsgJ106IHJlZ2lzdGVyZWQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHByb3RvdHlwZSkge1xuICByZWdpc3RyYXRpb25zLnB1c2gocHJvdG90eXBlKTtcbiAgdW5kZWZpbmVkICYmIF9yZWdMb2cocHJvdG90eXBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGR1bXBSZWdpc3RyYXRpb25zKCkge1xuICByZWdpc3RyYXRpb25zLmZvckVhY2goX3JlZ0xvZyk7XG59XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVTdHlsZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRG9jdW1lbnQocHJvcHMpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmpzIiwiaW1wb3J0IHsgcmVzb2x2ZUNzcyB9IGZyb20gJy4vcmVzb2x2ZS11cmwuanMnO1xuXG5jb25zdCBNT0RVTEVfU1RZTEVfTElOS19TRUxFQ1RPUiA9ICdsaW5rW3JlbD1pbXBvcnRdW3R5cGV+PWNzc10nO1xuY29uc3QgSU5DTFVERV9BVFRSID0gJ2luY2x1ZGUnO1xuXG5mdW5jdGlvbiBpbXBvcnRNb2R1bGUobW9kdWxlSWQpIHtcbiAgY29uc3QgLyoqIFBvbHltZXIuRG9tTW9kdWxlICovIFBvbHltZXJEb21Nb2R1bGUgPSBjdXN0b21FbGVtZW50cy5nZXQoJ2RvbS1tb2R1bGUnKTtcbiAgaWYgKCFQb2x5bWVyRG9tTW9kdWxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIFBvbHltZXJEb21Nb2R1bGUuaW1wb3J0KG1vZHVsZUlkKTtcbn1cblxuLyoqIEB0eXBlZGVmIHt7YXNzZXRwYXRoOiBzdHJpbmd9fSAqL1xubGV0IHRlbXBsYXRlV2l0aEFzc2V0UGF0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbU1vZHVsZXMobW9kdWxlSWRzKSB7XG4gIGxldCBtb2R1bGVzID0gbW9kdWxlSWRzLnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBmb3IgKGxldCBpPTA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY3NzVGV4dCArPSBjc3NGcm9tTW9kdWxlKG1vZHVsZXNbaV0pO1xuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbU1vZHVsZShtb2R1bGVJZCkge1xuICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gIGlmIChtICYmIG0uX2Nzc1RleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIG1vZHVsZSBpbXBvcnRzOiA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+XG4gICAgbGV0IGNzc1RleHQgPSBfY3NzRnJvbU1vZHVsZUltcG9ydHMobSk7XG4gICAgLy8gaW5jbHVkZSBjc3MgZnJvbSB0aGUgZmlyc3QgdGVtcGxhdGUgaW4gdGhlIG1vZHVsZVxuICAgIGxldCB0ID0gbS5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgIGlmICh0KSB7XG4gICAgICBjc3NUZXh0ICs9IGNzc0Zyb21UZW1wbGF0ZSh0LCAvKiogQHR5cGUge3RlbXBsYXRlV2l0aEFzc2V0UGF0aH0gKi8obSkuYXNzZXRwYXRoKTtcbiAgICB9XG4gICAgbS5fY3NzVGV4dCA9IGNzc1RleHQgfHwgbnVsbDtcbiAgfVxuICBpZiAoIW0pIHtcbiAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmaW5kIHN0eWxlIGRhdGEgaW4gbW9kdWxlIG5hbWVkJywgbW9kdWxlSWQpO1xuICB9XG4gIHJldHVybiBtICYmIG0uX2Nzc1RleHQgfHwgJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tVGVtcGxhdGUodGVtcGxhdGUsIGJhc2VVUkkpIHtcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgLy8gaWYgZWxlbWVudCBpcyBhIHRlbXBsYXRlLCBnZXQgY29udGVudCBmcm9tIGl0cyAuY29udGVudFxuICBsZXQgZSQgPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyk7XG4gIGZvciAobGV0IGk9MDsgaSA8IGUkLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGUgPSBlJFtpXTtcbiAgICAvLyBzdXBwb3J0IHN0eWxlIHNoYXJpbmcgYnkgYWxsb3dpbmcgc3R5bGVzIHRvIFwiaW5jbHVkZVwiXG4gICAgLy8gb3RoZXIgZG9tLW1vZHVsZXMgdGhhdCBjb250YWluIHN0eWxpbmdcbiAgICBsZXQgaW5jbHVkZSA9IGUuZ2V0QXR0cmlidXRlKElOQ0xVREVfQVRUUik7XG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIGNzc1RleHQgKz0gY3NzRnJvbU1vZHVsZXMoaW5jbHVkZSk7XG4gICAgfVxuICAgIGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKTtcbiAgICBjc3NUZXh0ICs9IGJhc2VVUkkgP1xuICAgICAgcmVzb2x2ZUNzcyhlLnRleHRDb250ZW50LCBiYXNlVVJJKSA6IGUudGV4dENvbnRlbnQ7XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGVJZCkge1xuICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gIHJldHVybiBtID8gX2Nzc0Zyb21Nb2R1bGVJbXBvcnRzKG0pIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlKSB7XG4gIGxldCBjc3NUZXh0ID0gJyc7XG4gIGxldCBwJCA9IG1vZHVsZS5xdWVyeVNlbGVjdG9yQWxsKE1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SKTtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcCQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcCA9IHAkW2ldO1xuICAgIGlmIChwLmltcG9ydCkge1xuICAgICAgbGV0IGltcG9ydERvYyA9IHAuaW1wb3J0O1xuICAgICAgLy8gTk9URTogcG9seWZpbGwgYWZmb3JkYW5jZS5cbiAgICAgIC8vIHVuZGVyIHRoZSBIVE1MSW1wb3J0cyBwb2x5ZmlsbCwgdGhlcmUgd2lsbCBiZSBubyAnYm9keScsXG4gICAgICAvLyBidXQgdGhlIGltcG9ydCBwc2V1ZG8tZG9jIGNhbiBiZSB1c2VkIGRpcmVjdGx5LlxuICAgICAgbGV0IGNvbnRhaW5lciA9IGltcG9ydERvYy5ib2R5ID8gaW1wb3J0RG9jLmJvZHkgOiBpbXBvcnREb2M7XG4gICAgICBjc3NUZXh0ICs9XG4gICAgICAgIHJlc29sdmVDc3MoY29udGFpbmVyLnRleHRDb250ZW50LFxuICAgICAgICAgIGltcG9ydERvYy5iYXNlVVJJKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc3R5bGUtZ2F0aGVyLmpzIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IHJlc29sdmVVcmwsIHBhdGhGcm9tVXJsIH0gZnJvbSAnLi4vdXRpbHMvcmVzb2x2ZS11cmwuanMnO1xuXG5sZXQgbW9kdWxlcyA9IHt9O1xubGV0IGxjTW9kdWxlcyA9IHt9O1xuZnVuY3Rpb24gZmluZE1vZHVsZShpZCkge1xuICByZXR1cm4gbW9kdWxlc1tpZF0gfHwgbGNNb2R1bGVzW2lkLnRvTG93ZXJDYXNlKCldO1xufVxuXG5mdW5jdGlvbiBzdHlsZU91dHNpZGVUZW1wbGF0ZUNoZWNrKGluc3QpIHtcbiAgaWYgKGluc3QucXVlcnlTZWxlY3Rvcignc3R5bGUnKSkge1xuICAgIGNvbnNvbGUud2FybignZG9tLW1vZHVsZSAlcyBoYXMgc3R5bGUgb3V0c2lkZSB0ZW1wbGF0ZScsIGluc3QuaWQpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGBkb20tbW9kdWxlYCBlbGVtZW50IHJlZ2lzdGVycyB0aGUgZG9tIGl0IGNvbnRhaW5zIHRvIHRoZSBuYW1lIGdpdmVuXG4gKiBieSB0aGUgbW9kdWxlJ3MgaWQgYXR0cmlidXRlLiBJdCBwcm92aWRlcyBhIHVuaWZpZWQgZGF0YWJhc2Ugb2YgZG9tXG4gKiBhY2Nlc3NpYmxlIHZpYSBpdHMgc3RhdGljIGBpbXBvcnRgIEFQSS5cbiAqXG4gKiBBIGtleSB1c2UgY2FzZSBvZiBgZG9tLW1vZHVsZWAgaXMgZm9yIHByb3ZpZGluZyBjdXN0b20gZWxlbWVudCBgPHRlbXBsYXRlPmBzXG4gKiB2aWEgSFRNTCBpbXBvcnRzIHRoYXQgYXJlIHBhcnNlZCBieSB0aGUgbmF0aXZlIEhUTUwgcGFyc2VyLCB0aGF0IGNhbiBiZVxuICogcmVsb2NhdGVkIGR1cmluZyBhIGJ1bmRsaW5nIHBhc3MgYW5kIHN0aWxsIGxvb2tlZCB1cCBieSBgaWRgLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDxkb20tbW9kdWxlIGlkPVwiZm9vXCI+XG4gKiAgICAgICA8aW1nIHNyYz1cInN0dWZmLnBuZ1wiPlxuICogICAgIDwvZG9tLW1vZHVsZT5cbiAqXG4gKiBUaGVuIGluIGNvZGUgaW4gc29tZSBvdGhlciBsb2NhdGlvbiB0aGF0IGNhbm5vdCBhY2Nlc3MgdGhlIGRvbS1tb2R1bGUgYWJvdmVcbiAqXG4gKiAgICAgbGV0IGltZyA9IGN1c3RvbUVsZW1lbnRzLmdldCgnZG9tLW1vZHVsZScpLmltcG9ydCgnZm9vJywgJ2ltZycpO1xuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IHRoYXQgcHJvdmlkZXMgYSByZWdpc3RyeSBvZiByZWxvY2F0YWJsZSBET00gY29udGVudFxuICogICBieSBgaWRgIHRoYXQgaXMgYWdub3N0aWMgdG8gYnVuZGxpbmcuXG4gKiBAdW5yZXN0cmljdGVkXG4gKi9cbmNsYXNzIERvbU1vZHVsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnaWQnXTsgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGVsZW1lbnQgc3BlY2lmaWVkIGJ5IHRoZSBjc3MgYHNlbGVjdG9yYCBpbiB0aGUgbW9kdWxlXG4gICAqIHJlZ2lzdGVyZWQgYnkgYGlkYC4gRm9yIGV4YW1wbGUsIHRoaXMuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgaWQgb2YgdGhlIGRvbS1tb2R1bGUgaW4gd2hpY2ggdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHNlbGVjdG9yIFRoZSBjc3Mgc2VsZWN0b3IgYnkgd2hpY2ggdG8gZmluZCB0aGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7RWxlbWVudH0gUmV0dXJucyB0aGUgZWxlbWVudCB3aGljaCBtYXRjaGVzIGBzZWxlY3RvcmAgaW4gdGhlXG4gICAqIG1vZHVsZSByZWdpc3RlcmVkIGF0IHRoZSBzcGVjaWZpZWQgYGlkYC5cbiAgICovXG4gIHN0YXRpYyBpbXBvcnQoaWQsIHNlbGVjdG9yKSB7XG4gICAgaWYgKGlkKSB7XG4gICAgICBsZXQgbSA9IGZpbmRNb2R1bGUoaWQpO1xuICAgICAgaWYgKG0gJiYgc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIG0ucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnJlZ2lzdGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhYnNvbHV0ZSBVUkwgb2YgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoaXMgYGRvbS1tb2R1bGVgLlxuICAgKlxuICAgKiBUaGlzIHZhbHVlIHdpbGwgZGlmZmVyIGZyb20gdGhpcyBlbGVtZW50J3MgYG93bmVyRG9jdW1lbnRgIGluIHRoZVxuICAgKiBmb2xsb3dpbmcgd2F5czpcbiAgICogLSBUYWtlcyBpbnRvIGFjY291bnQgYW55IGBhc3NldHBhdGhgIGF0dHJpYnV0ZSBhZGRlZCBkdXJpbmcgYnVuZGxpbmdcbiAgICogICB0byBpbmRpY2F0ZSB0aGUgb3JpZ2luYWwgbG9jYXRpb24gcmVsYXRpdmUgdG8gdGhlIGJ1bmRsZWQgbG9jYXRpb25cbiAgICogLSBVc2VzIHRoZSBIVE1MSW1wb3J0cyBwb2x5ZmlsbCdzIGBpbXBvcnRGb3JFbGVtZW50YCBBUEkgdG8gZW5zdXJlXG4gICAqICAgdGhlIHBhdGggaXMgcmVsYXRpdmUgdG8gdGhlIGltcG9ydCBkb2N1bWVudCdzIGxvY2F0aW9uIHNpbmNlXG4gICAqICAgYG93bmVyRG9jdW1lbnRgIGlzIG5vdCBjdXJyZW50bHkgcG9seWZpbGxlZFxuICAgKi9cbiAgZ2V0IGFzc2V0cGF0aCgpIHtcbiAgICAvLyBEb24ndCBvdmVycmlkZSBleGlzdGluZyBhc3NldHBhdGguXG4gICAgaWYgKCF0aGlzLl9fYXNzZXRwYXRoKSB7XG4gICAgICAvLyBub3RlOiBhc3NldHBhdGggc2V0IHZpYSBhbiBhdHRyaWJ1dGUgbXVzdCBiZSByZWxhdGl2ZSB0byB0aGlzXG4gICAgICAvLyBlbGVtZW50J3MgbG9jYXRpb247IGFjY29tb2RhdGUgcG9seWZpbGxlZCBIVE1MSW1wb3J0c1xuICAgICAgY29uc3Qgb3duZXIgPSB3aW5kb3cuSFRNTEltcG9ydHMgJiYgSFRNTEltcG9ydHMuaW1wb3J0Rm9yRWxlbWVudCA/XG4gICAgICAgIEhUTUxJbXBvcnRzLmltcG9ydEZvckVsZW1lbnQodGhpcykgfHwgZG9jdW1lbnQgOiB0aGlzLm93bmVyRG9jdW1lbnQ7XG4gICAgICBjb25zdCB1cmwgPSByZXNvbHZlVXJsKFxuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZSgnYXNzZXRwYXRoJykgfHwgJycsIG93bmVyLmJhc2VVUkkpO1xuICAgICAgdGhpcy5fX2Fzc2V0cGF0aCA9IHBhdGhGcm9tVXJsKHVybCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fYXNzZXRwYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZG9tLW1vZHVsZSBhdCBhIGdpdmVuIGlkLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWRcbiAgICogd2hlbiBhIGRvbS1tb2R1bGUgaXMgaW1wZXJhdGl2ZWx5IGNyZWF0ZWQuIEZvclxuICAgKiBleGFtcGxlLCBgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZG9tLW1vZHVsZScpLnJlZ2lzdGVyKCdmb28nKWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaWQgVGhlIGlkIGF0IHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSBkb20tbW9kdWxlLlxuICAgKi9cbiAgcmVnaXN0ZXIoaWQpIHtcbiAgICBpZCA9IGlkIHx8IHRoaXMuaWQ7XG4gICAgaWYgKGlkKSB7XG4gICAgICB0aGlzLmlkID0gaWQ7XG4gICAgICAvLyBzdG9yZSBpZCBzZXBhcmF0ZSBmcm9tIGxvd2VyY2FzZWQgaWQgc28gdGhhdFxuICAgICAgLy8gaW4gYWxsIGNhc2VzIG1peGVkQ2FzZSBpZCB3aWxsIHN0b3JlZCBkaXN0aW5jdGx5XG4gICAgICAvLyBhbmQgbG93ZXJjYXNlIHZlcnNpb24gaXMgYSBmYWxsYmFja1xuICAgICAgbW9kdWxlc1tpZF0gPSB0aGlzO1xuICAgICAgbGNNb2R1bGVzW2lkLnRvTG93ZXJDYXNlKCldID0gdGhpcztcbiAgICAgIHN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2sodGhpcyk7XG4gICAgfVxuICB9XG59XG5cbkRvbU1vZHVsZS5wcm90b3R5cGVbJ21vZHVsZXMnXSA9IG1vZHVsZXM7XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZG9tLW1vZHVsZScsIERvbU1vZHVsZSk7XG5cbmV4cG9ydCB7IERvbU1vZHVsZSB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IHJvb3QgYXMgcm9vdCQwLCBpc0FuY2VzdG9yLCBpc0Rlc2NlbmRhbnQsIGdldCBhcyBnZXQkMCwgdHJhbnNsYXRlLCBpc1BhdGggYXMgaXNQYXRoJDAsIHNldCBhcyBzZXQkMCwgbm9ybWFsaXplIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwIGZyb20gJy4uL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IGNhbWVsVG9EYXNoQ2FzZSBhcyBjYW1lbFRvRGFzaENhc2UkMCwgZGFzaFRvQ2FtZWxDYXNlIH0gZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlBY2Nlc3NvcnMgfSBmcm9tICcuL3Byb3BlcnR5LWFjY2Vzc29ycy5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVN0YW1wIH0gZnJvbSAnLi90ZW1wbGF0ZS1zdGFtcC5qcyc7XG5pbXBvcnQgeyBzYW5pdGl6ZURPTVZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuXG4vKiogQGNvbnN0IHtPYmplY3R9ICovXG5jb25zdCBDYXNlTWFwID0gY2FzZU1hcDtcblxuLy8gTW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHVuaXF1ZSBJRCB1c2VkIGZvciBkZS1kdXBpbmcgZWZmZWN0cyB0cmlnZ2VyZWRcbi8vIGZyb20gbXVsdGlwbGUgcHJvcGVydGllcyBpbiB0aGUgc2FtZSB0dXJuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIFByb3BlcnR5IGVmZmVjdCB0eXBlczsgZWZmZWN0cyBhcmUgc3RvcmVkIG9uIHRoZSBwcm90b3R5cGUgdXNpbmcgdGhlc2Uga2V5c1xuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVFlQRVMgPSB7XG4gIENPTVBVVEU6ICdfX2NvbXB1dGVFZmZlY3RzJyxcbiAgUkVGTEVDVDogJ19fcmVmbGVjdEVmZmVjdHMnLFxuICBOT1RJRlk6ICdfX25vdGlmeUVmZmVjdHMnLFxuICBQUk9QQUdBVEU6ICdfX3Byb3BhZ2F0ZUVmZmVjdHMnLFxuICBPQlNFUlZFOiAnX19vYnNlcnZlRWZmZWN0cycsXG4gIFJFQURfT05MWTogJ19fcmVhZE9ubHknXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBuYW1lOiAoc3RyaW5nIHwgdW5kZWZpbmVkKSxcbiAqIHN0cnVjdHVyZWQ6IChib29sZWFuIHwgdW5kZWZpbmVkKSxcbiAqIHdpbGRjYXJkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBEYXRhVHJpZ2dlcjsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIGluZm86ID8sXG4gKiB0cmlnZ2VyOiAoIURhdGFUcmlnZ2VyIHwgdW5kZWZpbmVkKSxcbiAqIGZuOiAoIUZ1bmN0aW9uIHwgdW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IERhdGFFZmZlY3Q7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5sZXQgUHJvcGVydHlFZmZlY3RzVHlwZTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IHRoZSBtb2RlbCBoYXMgYW4gb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFRoZSBtb2RlbCBtYXkgYmUgYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuXG4gKlxuICogUHJvcGVydHkgZWZmZWN0cyBhcmUgc3RvcmVkIGFzIGFycmF5cyBvZiBlZmZlY3RzIGJ5IHByb3BlcnR5IGluIGEgbWFwLFxuICogYnkgbmFtZWQgdHlwZSBvbiB0aGUgbW9kZWwuIGUuZy5cbiAqXG4gKiAgIF9fY29tcHV0ZUVmZmVjdHM6IHtcbiAqICAgICBmb286IFsgLi4uIF0sXG4gKiAgICAgYmFyOiBbIC4uLiBdXG4gKiAgIH1cbiAqXG4gKiBJZiB0aGUgbW9kZWwgZG9lcyBub3QgeWV0IGhhdmUgYW4gZWZmZWN0IG1hcCBmb3IgdGhlIHR5cGUsIG9uZSBpcyBjcmVhdGVkXG4gKiBhbmQgcmV0dXJuZWQuICBJZiBpdCBkb2VzLCBidXQgaXQgaXMgbm90IGFuIG93biBwcm9wZXJ0eSAoaS5lLiB0aGVcbiAqIHByb3RvdHlwZSBoYWQgZWZmZWN0cyksIHRoZSB0aGUgbWFwIGlzIGRlZXBseSBjbG9uZWQgYW5kIHRoZSBjb3B5IGlzXG4gKiBzZXQgb24gdGhlIG1vZGVsIGFuZCByZXR1cm5lZCwgcmVhZHkgZm9yIG5ldyBlZmZlY3RzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFByb3BlcnR5IGVmZmVjdCB0eXBlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvd24tcHJvcGVydHkgbWFwIG9mIGVmZmVjdHMgZm9yIHRoZSBnaXZlbiB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnN1cmVPd25FZmZlY3RNYXAobW9kZWwsIHR5cGUpIHtcbiAgbGV0IGVmZmVjdHMgPSBtb2RlbFt0eXBlXTtcbiAgaWYgKCFlZmZlY3RzKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0ge307XG4gIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0gT2JqZWN0LmNyZWF0ZShtb2RlbFt0eXBlXSk7XG4gICAgZm9yIChsZXQgcCBpbiBlZmZlY3RzKSB7XG4gICAgICBsZXQgcHJvdG9GeCA9IGVmZmVjdHNbcF07XG4gICAgICBsZXQgaW5zdEZ4ID0gZWZmZWN0c1twXSA9IEFycmF5KHByb3RvRngubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxwcm90b0Z4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluc3RGeFtpXSA9IHByb3RvRnhbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlZmZlY3RzO1xufVxuXG4vLyAtLSBlZmZlY3RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBSdW5zIGFsbCBlZmZlY3RzIG9mIGEgZ2l2ZW4gdHlwZSBmb3IgdGhlIGdpdmVuIHNldCBvZiBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdD19IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVmZmVjdCByYW4gZm9yIHRoaXMgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkVmZmVjdHMoaW5zdCwgZWZmZWN0cywgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSB7XG4gIGlmIChlZmZlY3RzKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIGxldCBpZCA9IGRlZHVwZUlkKys7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgaWYgKHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBlZmZlY3RzLCBpZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSkge1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSdW5zIGEgbGlzdCBvZiBlZmZlY3RzIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3RzIE9iamVjdCBtYXAgb2YgcHJvcGVydHktdG8tQXJyYXkgb2YgZWZmZWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGRlZHVwZUlkIENvdW50ZXIgdXNlZCBmb3IgZGUtZHVwaW5nIGVmZmVjdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIE5hbWUgb2YgY2hhbmdlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHsqfSBwcm9wcyBDaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Kn0gb2xkUHJvcHMgT2xkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0geyo9fSBleHRyYUFyZ3MgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBwYXNzIHRvIGVmZmVjdCBmdW5jdGlvblxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlZmZlY3QgcmFuIGZvciB0aGlzIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZWZmZWN0cywgZGVkdXBlSWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykge1xuICBsZXQgcmFuID0gZmFsc2U7XG4gIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IHJvb3QkMChwcm9wKSA6IHByb3A7XG4gIGxldCBmeHMgPSBlZmZlY3RzW3Jvb3RQcm9wZXJ0eV07XG4gIGlmIChmeHMpIHtcbiAgICBmb3IgKGxldCBpPTAsIGw9ZnhzLmxlbmd0aCwgZng7IChpPGwpICYmIChmeD1meHNbaV0pOyBpKyspIHtcbiAgICAgIGlmICgoIWZ4LmluZm8gfHwgZnguaW5mby5sYXN0UnVuICE9PSBkZWR1cGVJZCkgJiZcbiAgICAgICAgICAoIWhhc1BhdGhzIHx8IHBhdGhNYXRjaGVzVHJpZ2dlcihwcm9wLCBmeC50cmlnZ2VyKSkpIHtcbiAgICAgICAgaWYgKGZ4LmluZm8pIHtcbiAgICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBkZWR1cGVJZDtcbiAgICAgICAgfVxuICAgICAgICBmeC5mbihpbnN0LCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGZ4LmluZm8sIGhhc1BhdGhzLCBleHRyYUFyZ3MpO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmFuO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHByb3BlcnR5L3BhdGggdGhhdCBoYXMgY2hhbmdlZCBtYXRjaGVzIHRoZSB0cmlnZ2VyXG4gKiBjcml0ZXJpYSBmb3IgYW4gZWZmZWN0LiAgQSB0cmlnZ2VyIGlzIGEgZGVzY3JpcHRvciB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHN0cnVjdHVyZSwgd2hpY2ggbWF0Y2hlcyB0aGUgZGVzY3JpcHRvcnMgcmV0dXJuZWQgZnJvbSBgcGFyc2VBcmdgLlxuICogZS5nLiBmb3IgYGZvby5iYXIuKmA6XG4gKiBgYGBcbiAqIHRyaWdnZXI6IHtcbiAqICAgbmFtZTogJ2EuYicsXG4gKiAgIHN0cnVjdHVyZWQ6IHRydWUsXG4gKiAgIHdpbGRjYXJkOiB0cnVlXG4gKiB9XG4gKiBgYGBcbiAqIElmIG5vIHRyaWdnZXIgaXMgZ2l2ZW4sIHRoZSBwYXRoIGlzIGRlZW1lZCB0byBtYXRjaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIG9yIHByb3BlcnR5IHRoYXQgY2hhbmdlZFxuICogQHBhcmFtIHtEYXRhVHJpZ2dlcn0gdHJpZ2dlciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwYXRoIG1hdGNoZWQgdGhlIHRyaWdnZXJcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoZXNUcmlnZ2VyKHBhdGgsIHRyaWdnZXIpIHtcbiAgaWYgKHRyaWdnZXIpIHtcbiAgICBsZXQgdHJpZ2dlclBhdGggPSB0cmlnZ2VyLm5hbWU7XG4gICAgcmV0dXJuICh0cmlnZ2VyUGF0aCA9PSBwYXRoKSB8fFxuICAgICAgKHRyaWdnZXIuc3RydWN0dXJlZCAmJiBpc0FuY2VzdG9yKHRyaWdnZXJQYXRoLCBwYXRoKSkgfHxcbiAgICAgICh0cmlnZ2VyLndpbGRjYXJkICYmIGlzRGVzY2VuZGFudCh0cmlnZ2VyUGF0aCwgcGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJvYnNlcnZlclwiIGVmZmVjdC5cbiAqXG4gKiBDYWxscyB0aGUgbWV0aG9kIHdpdGggYGluZm8ubWV0aG9kTmFtZWAgb24gdGhlIGluc3RhbmNlLCBwYXNzaW5nIHRoZVxuICogbmV3IGFuZCBvbGQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuT2JzZXJ2ZXJFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICBsZXQgZm4gPSBpbnN0W2luZm8ubWV0aG9kTmFtZV07XG4gIGxldCBjaGFuZ2VkUHJvcCA9IGluZm8ucHJvcGVydHk7XG4gIGlmIChmbikge1xuICAgIGZuLmNhbGwoaW5zdCwgaW5zdC5fX2RhdGFbY2hhbmdlZFByb3BdLCBvbGRQcm9wc1tjaGFuZ2VkUHJvcF0pO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2Fybignb2JzZXJ2ZXIgbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgXCJub3RpZnlcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogd2lsbCBkaXNwYXRjaCBwYXRoIG5vdGlmaWNhdGlvbiBldmVudHMgaW4gdGhlIGNhc2UgdGhhdCB0aGUgcHJvcGVydHlcbiAqIGNoYW5nZWQgd2FzIGEgcGF0aCBhbmQgdGhlIHJvb3QgcHJvcGVydHkgZm9yIHRoYXQgcGF0aCBkaWRuJ3QgaGF2ZSBhXG4gKiBcIm5vdGlmeVwiIGVmZmVjdC4gIFRoaXMgaXMgdG8gbWFpbnRhaW4gMS4wIGJlaGF2aW9yIHRoYXQgZGlkIG5vdCByZXF1aXJlXG4gKiBgbm90aWZ5OiB0cnVlYCB0byBlbnN1cmUgb2JqZWN0IHN1Yi1wcm9wZXJ0eSBub3RpZmljYXRpb25zIHdlcmVcbiAqIHNlbnQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICogQHBhcmFtIHtPYmplY3R9IG5vdGlmeVByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIHRvIG5vdGlmeVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdHMoaW5zdCwgbm90aWZ5UHJvcHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgLy8gTm90aWZ5XG4gIGxldCBmeHMgPSBpbnN0W1RZUEVTLk5PVElGWV07XG4gIGxldCBub3RpZmllZDtcbiAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgLy8gVHJ5IG5vcm1hbCBub3RpZnkgZWZmZWN0czsgaWYgbm9uZSwgZmFsbCBiYWNrIHRvIHRyeSBwYXRoIG5vdGlmaWNhdGlvblxuICBmb3IgKGxldCBwcm9wIGluIG5vdGlmeVByb3BzKSB7XG4gICAgaWYgKG5vdGlmeVByb3BzW3Byb3BdKSB7XG4gICAgICBpZiAoZnhzICYmIHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBmeHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgICBub3RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGhhc1BhdGhzICYmIG5vdGlmeVBhdGgoaW5zdCwgcHJvcCwgcHJvcHMpKSB7XG4gICAgICAgIG5vdGlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRmx1c2ggaG9zdCBpZiB3ZSBhY3R1YWxseSBub3RpZmllZCBhbmQgaG9zdCB3YXMgYmF0Y2hpbmdcbiAgLy8gQW5kIHRoZSBob3N0IGhhcyBhbHJlYWR5IGluaXRpYWxpemVkIGNsaWVudHM7IHRoaXMgcHJldmVudHNcbiAgLy8gYW4gaXNzdWUgd2l0aCBhIGhvc3Qgb2JzZXJ2aW5nIGRhdGEgY2hhbmdlcyBiZWZvcmUgY2xpZW50cyBhcmUgcmVhZHkuXG4gIGxldCBob3N0O1xuICBpZiAobm90aWZpZWQgJiYgKGhvc3QgPSBpbnN0Ll9fZGF0YUhvc3QpICYmIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKSB7XG4gICAgaG9zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoZXMge3Byb3BlcnR5fS1jaGFuZ2VkIGV2ZW50cyB3aXRoIHBhdGggaW5mb3JtYXRpb24gaW4gdGhlIGRldGFpbFxuICogb2JqZWN0IHRvIGluZGljYXRlIGEgc3ViLXBhdGggb2YgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdGhhdCB3YXMgY2hhbmdlZFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0aCB3YXMgbm90aWZpZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVBhdGgoaW5zdCwgcGF0aCwgcHJvcHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IHJvb3QkMChwYXRoKTtcbiAgaWYgKHJvb3RQcm9wZXJ0eSAhPT0gcGF0aCkge1xuICAgIGxldCBldmVudE5hbWUgPSBjYW1lbFRvRGFzaENhc2UkMChyb290UHJvcGVydHkpICsgJy1jaGFuZ2VkJztcbiAgICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgcHJvcHNbcGF0aF0sIHBhdGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgdG8gaW5kaWNhdGUgYSBwcm9wZXJ0eSAob3IgcGF0aClcbiAqIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kICgne3Byb3BlcnR5fS1jaGFuZ2VkJylcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBjaGFuZ2VkIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHBhdGggSWYgYSBzdWItcGF0aCBvZiB0aGlzIHByb3BlcnR5IGNoYW5nZWQsIHRoZSBwYXRoXG4gKiAgIHRoYXQgY2hhbmdlZCAob3B0aW9uYWwpLlxuICogQHByaXZhdGVcbiAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpIHtcbiAgbGV0IGRldGFpbCA9IHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcXVldWVQcm9wZXJ0eTogdHJ1ZVxuICB9O1xuICBpZiAocGF0aCkge1xuICAgIGRldGFpbC5wYXRoID0gcGF0aDtcbiAgfVxuICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oaW5zdCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCB9KSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJub3RpZnlcIiBlZmZlY3QuXG4gKlxuICogRGlzcGF0Y2hlcyBhIG5vbi1idWJibGluZyBldmVudCBuYW1lZCBgaW5mby5ldmVudE5hbWVgIG9uIHRoZSBpbnN0YW5jZVxuICogd2l0aCBhIGRldGFpbCBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gcm9vdCQwKHByb3BlcnR5KSA6IHByb3BlcnR5O1xuICBsZXQgcGF0aCA9IHJvb3RQcm9wZXJ0eSAhPSBwcm9wZXJ0eSA/IHByb3BlcnR5IDogbnVsbDtcbiAgbGV0IHZhbHVlID0gcGF0aCA/IGdldCQwKGluc3QsIHBhdGgpIDogaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAocGF0aCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBwcm9wc1twcm9wZXJ0eV07ICAvLyBzcGVjaWZpY2FsbHkgZm9yIC5zcGxpY2VzXG4gIH1cbiAgZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBpbmZvLmV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZnVuY3Rpb24gZm9yIDItd2F5IG5vdGlmaWNhdGlvbiBldmVudHMuIFJlY2VpdmVzIGNvbnRleHRcbiAqIGluZm9ybWF0aW9uIGNhcHR1cmVkIGluIHRoZSBgYWRkTm90aWZ5TGlzdGVuZXJgIGNsb3N1cmUgZnJvbSB0aGVcbiAqIGBfX25vdGlmeUxpc3RlbmVyc2AgbWV0YWRhdGEuXG4gKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG5vdGlmaWVkIHByb3BlcnR5IHRvIHRoZSBob3N0IHByb3BlcnR5IG9yIHBhdGguICBJZlxuICogdGhlIGV2ZW50IGNvbnRhaW5lZCBwYXRoIGluZm9ybWF0aW9uLCB0cmFuc2xhdGUgdGhhdCBwYXRoIHRvIHRoZSBob3N0XG4gKiBzY29wZSdzIG5hbWUgZm9yIHRoYXQgcGF0aCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudCBOb3RpZmljYXRpb24gZXZlbnQgKGUuZy4gJzxwcm9wZXJ0eT4tY2hhbmdlZCcpXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSBoYW5kbGluZyB0aGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZnJvbVByb3AgQ2hpbGQgZWxlbWVudCBwcm9wZXJ0eSB0aGF0IHdhcyBib3VuZFxuICogQHBhcmFtIHtzdHJpbmd9IHRvUGF0aCBIb3N0IHByb3BlcnR5L3BhdGggdGhhdCB3YXMgYm91bmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVnYXRlIFdoZXRoZXIgdGhlIGJpbmRpbmcgd2FzIG5lZ2F0ZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbihldmVudCwgaW5zdCwgZnJvbVByb3AsIHRvUGF0aCwgbmVnYXRlKSB7XG4gIGxldCB2YWx1ZTtcbiAgbGV0IGRldGFpbCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhldmVudC5kZXRhaWwpO1xuICBsZXQgZnJvbVBhdGggPSBkZXRhaWwgJiYgZGV0YWlsLnBhdGg7XG4gIGlmIChmcm9tUGF0aCkge1xuICAgIHRvUGF0aCA9IHRyYW5zbGF0ZShmcm9tUHJvcCwgdG9QYXRoLCBmcm9tUGF0aCk7XG4gICAgdmFsdWUgPSBkZXRhaWwgJiYgZGV0YWlsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZXZlbnQudGFyZ2V0W2Zyb21Qcm9wXTtcbiAgfVxuICB2YWx1ZSA9IG5lZ2F0ZSA/ICF2YWx1ZSA6IHZhbHVlO1xuICBpZiAoIWluc3RbVFlQRVMuUkVBRF9PTkxZXSB8fCAhaW5zdFtUWVBFUy5SRUFEX09OTFldW3RvUGF0aF0pIHtcbiAgICBpZiAoaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHRvUGF0aCwgdmFsdWUsIHRydWUsIEJvb2xlYW4oZnJvbVBhdGgpKVxuICAgICAgJiYgKCFkZXRhaWwgfHwgIWRldGFpbC5xdWV1ZVByb3BlcnR5KSkge1xuICAgICAgaW5zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcInJlZmxlY3RcIiBlZmZlY3QuXG4gKlxuICogU2V0cyB0aGUgYXR0cmlidXRlIG5hbWVkIGBpbmZvLmF0dHJOYW1lYCB0byB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5SZWZsZWN0RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgbGV0IHZhbHVlID0gaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAoc2FuaXRpemVET01WYWx1ZSkge1xuICAgIHZhbHVlID0gc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgaW5mby5hdHRyTmFtZSwgJ2F0dHJpYnV0ZScsIC8qKiBAdHlwZSB7Tm9kZX0gKi8oaW5zdCkpO1xuICB9XG4gIGluc3QuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGluZm8uYXR0ck5hbWUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSdW5zIFwiY29tcHV0ZWRcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogY29udGludWVzIHRvIHJ1biBjb21wdXRlZCBlZmZlY3RzIGJhc2VkIG9uIHRoZSBvdXRwdXQgb2YgZWFjaCBwYXNzIHVudGlsXG4gKiB0aGVyZSBhcmUgbm8gbW9yZSBuZXdseSBjb21wdXRlZCBwcm9wZXJ0aWVzLiAgVGhpcyBlbnN1cmVzIHRoYXQgYWxsXG4gKiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBieSB0aGUgaW5pdGlhbCBzZXQgb2YgY2hhbmdlcyBhcmVcbiAqIGNvbXB1dGVkIGJlZm9yZSBvdGhlciBlZmZlY3RzIChiaW5kaW5nIHByb3BhZ2F0aW9uLCBvYnNlcnZlcnMsIGFuZCBub3RpZnkpXG4gKiBydW4uXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHshT2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0cyhpbnN0LCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICBsZXQgY29tcHV0ZUVmZmVjdHMgPSBpbnN0W1RZUEVTLkNPTVBVVEVdO1xuICBpZiAoY29tcHV0ZUVmZmVjdHMpIHtcbiAgICBsZXQgaW5wdXRQcm9wcyA9IGNoYW5nZWRQcm9wcztcbiAgICB3aGlsZSAocnVuRWZmZWN0cyhpbnN0LCBjb21wdXRlRWZmZWN0cywgaW5wdXRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihvbGRQcm9wcywgaW5zdC5fX2RhdGFPbGQpO1xuICAgICAgT2JqZWN0LmFzc2lnbihjaGFuZ2VkUHJvcHMsIGluc3QuX19kYXRhUGVuZGluZyk7XG4gICAgICBpbnB1dFByb3BzID0gaW5zdC5fX2RhdGFQZW5kaW5nO1xuICAgICAgaW5zdC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcImNvbXB1dGVkIHByb3BlcnR5XCIgZWZmZWN0IGJ5IHJ1bm5pbmcgdGhlIG1ldGhvZCB3aXRoIHRoZVxuICogdmFsdWVzIG9mIHRoZSBhcmd1bWVudHMgc3BlY2lmaWVkIGluIHRoZSBgaW5mb2Agb2JqZWN0IGFuZCBzZXR0aW5nIHRoZVxuICogcmV0dXJuIHZhbHVlIHRvIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Db21wdXRlZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIGxldCByZXN1bHQgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbyk7XG4gIGxldCBjb21wdXRlZFByb3AgPSBpbmZvLm1ldGhvZEluZm87XG4gIGlmIChpbnN0Ll9fZGF0YUhhc0FjY2Vzc29yICYmIGluc3QuX19kYXRhSGFzQWNjZXNzb3JbY29tcHV0ZWRQcm9wXSkge1xuICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eShjb21wdXRlZFByb3AsIHJlc3VsdCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdFtjb21wdXRlZFByb3BdID0gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgcGF0aCBjaGFuZ2VzIGJhc2VkIG9uIHBhdGggbGlua3Mgc2V0IHVwIHVzaW5nIHRoZSBgbGlua1BhdGhzYFxuICogQVBJLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdob3NlIHByb3BzIGFyZSBjaGFuZ2luZ1xuICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8KHN0cmluZ3xudW1iZXIpPn0gcGF0aCBQYXRoIHRoYXQgaGFzIGNoYW5nZWRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgY2hhbmdlZCBwYXRoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTGlua2VkUGF0aHMoaW5zdCwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IGxpbmtzID0gaW5zdC5fX2RhdGFMaW5rZWRQYXRocztcbiAgaWYgKGxpbmtzKSB7XG4gICAgbGV0IGxpbms7XG4gICAgZm9yIChsZXQgYSBpbiBsaW5rcykge1xuICAgICAgbGV0IGIgPSBsaW5rc1thXTtcbiAgICAgIGlmIChpc0Rlc2NlbmRhbnQoYSwgcGF0aCkpIHtcbiAgICAgICAgbGluayA9IHRyYW5zbGF0ZShhLCBiLCBwYXRoKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGxpbmssIHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZXNjZW5kYW50KGIsIHBhdGgpKSB7XG4gICAgICAgIGxpbmsgPSB0cmFuc2xhdGUoYiwgYSwgcGF0aCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChsaW5rLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIC0tIGJpbmRpbmdzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBZGRzIGJpbmRpbmcgbWV0YWRhdGEgdG8gdGhlIGN1cnJlbnQgYG5vZGVJbmZvYCwgYW5kIGJpbmRpbmcgZWZmZWN0c1xuICogZm9yIGFsbCBwYXJ0IGRlcGVuZGVuY2llcyB0byBgdGVtcGxhdGVJbmZvYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gKiAgIHJ1bm5pbmcgb25cbiAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmQgQmluZGluZyBraW5kLCBlaXRoZXIgJ3Byb3BlcnR5JywgJ2F0dHJpYnV0ZScsIG9yICd0ZXh0J1xuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBUYXJnZXQgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHshQXJyYXk8IUJpbmRpbmdQYXJ0Pn0gcGFydHMgQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZz19IGxpdGVyYWwgTGl0ZXJhbCB0ZXh0IHN1cnJvdW5kaW5nIGJpbmRpbmcgcGFydHMgKHNwZWNpZmllZFxuICogICBvbmx5IGZvciAncHJvcGVydHknIGJpbmRpbmdzLCBzaW5jZSB0aGVzZSBtdXN0IGJlIGluaXRpYWxpemVkIGFzIHBhcnRcbiAqICAgb2YgYm9vdC11cClcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZEJpbmRpbmcoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwpIHtcbiAgLy8gQ3JlYXRlIGJpbmRpbmcgbWV0YWRhdGEgYW5kIGFkZCB0byBub2RlSW5mb1xuICBub2RlSW5mby5iaW5kaW5ncyA9IG5vZGVJbmZvLmJpbmRpbmdzIHx8IFtdO1xuICBsZXQgLyoqIEJpbmRpbmcgKi8gYmluZGluZyA9IHsga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCwgaXNDb21wb3VuZDogKHBhcnRzLmxlbmd0aCAhPT0gMSkgfTtcbiAgbm9kZUluZm8uYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgLy8gQWRkIGxpc3RlbmVyIGluZm8gdG8gYmluZGluZyBtZXRhZGF0YVxuICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykpIHtcbiAgICBsZXQge2V2ZW50LCBuZWdhdGV9ID0gYmluZGluZy5wYXJ0c1swXTtcbiAgICBiaW5kaW5nLmxpc3RlbmVyRXZlbnQgPSBldmVudCB8fCAoQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UodGFyZ2V0KSArICctY2hhbmdlZCcpO1xuICAgIGJpbmRpbmcubGlzdGVuZXJOZWdhdGUgPSBuZWdhdGU7XG4gIH1cbiAgLy8gQWRkIFwicHJvcGFnYXRlXCIgcHJvcGVydHkgZWZmZWN0cyB0byB0ZW1wbGF0ZUluZm9cbiAgbGV0IGluZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5sZW5ndGg7XG4gIGZvciAobGV0IGk9MDsgaTxiaW5kaW5nLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzW2ldO1xuICAgIHBhcnQuY29tcG91bmRJbmRleCA9IGk7XG4gICAgYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgYmluZGluZywgcGFydCwgaW5kZXgpO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBwcm9wZXJ0eSBlZmZlY3RzIHRvIHRoZSBnaXZlbiBgdGVtcGxhdGVJbmZvYCBmb3IgdGhlIGdpdmVuIGJpbmRpbmdcbiAqIHBhcnQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ2xhc3MgdGhhdCBgX3BhcnNlVGVtcGxhdGVgIGlzIGN1cnJlbnRseVxuICogICBydW5uaW5nIG9uXG4gKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGludG8gYG5vZGVJbmZvTGlzdGAgZm9yIHRoaXMgbm9kZVxuICovXG5mdW5jdGlvbiBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCkge1xuICBpZiAoIXBhcnQubGl0ZXJhbCkge1xuICAgIGlmIChiaW5kaW5nLmtpbmQgPT09ICdhdHRyaWJ1dGUnICYmIGJpbmRpbmcudGFyZ2V0WzBdID09PSAnLScpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHNldCBhdHRyaWJ1dGUgJyArIGJpbmRpbmcudGFyZ2V0ICtcbiAgICAgICAgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBzdGFydGluZyBjaGFyYWN0ZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IHBhcnQuZGVwZW5kZW5jaWVzO1xuICAgICAgbGV0IGluZm8gPSB7IGluZGV4LCBiaW5kaW5nLCBwYXJ0LCBldmFsdWF0b3I6IGNvbnN0cnVjdG9yIH07XG4gICAgICBmb3IgKGxldCBqPTA7IGo8ZGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCB0cmlnZ2VyID0gZGVwZW5kZW5jaWVzW2pdO1xuICAgICAgICBpZiAodHlwZW9mIHRyaWdnZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0cmlnZ2VyID0gcGFyc2VBcmcodHJpZ2dlcik7XG4gICAgICAgICAgdHJpZ2dlci53aWxkY2FyZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IuX2FkZFRlbXBsYXRlUHJvcGVydHlFZmZlY3QodGVtcGxhdGVJbmZvLCB0cmlnZ2VyLnJvb3RQcm9wZXJ0eSwge1xuICAgICAgICAgIGZuOiBydW5CaW5kaW5nRWZmZWN0LFxuICAgICAgICAgIGluZm8sIHRyaWdnZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJiaW5kaW5nXCIgKHByb3BlcnR5L3BhdGggYmluZGluZykgZWZmZWN0LlxuICpcbiAqIE5vdGUgdGhhdCBiaW5kaW5nIHN5bnRheCBpcyBvdmVycmlkYWJsZSB2aWEgYF9wYXJzZUJpbmRpbmdzYCBhbmRcbiAqIGBfZXZhbHVhdGVCaW5kaW5nYC4gIFRoaXMgbWV0aG9kIHdpbGwgY2FsbCBgX2V2YWx1YXRlQmluZGluZ2AgZm9yIGFueVxuICogbm9uLWxpdGVyYWwgcGFydHMgcmV0dXJuZWQgZnJvbSBgX3BhcnNlQmluZGluZ3NgLiAgSG93ZXZlcixcbiAqIHRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIF9wYXRoXyBiaW5kaW5ncyB2aWEgY3VzdG9tIGJpbmRpbmcgcGFydHMsXG4gKiBhcyB0aGlzIGlzIHNwZWNpZmljIHRvIFBvbHltZXIncyBwYXRoIGJpbmRpbmcgc3ludGF4LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0ge0FycmF5fSBub2RlTGlzdCBMaXN0IG9mIG5vZGVzIGFzc29jaWF0ZWQgd2l0aCBgbm9kZUluZm9MaXN0YCB0ZW1wbGF0ZVxuICogICBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuQmluZGluZ0VmZmVjdChpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzLCBub2RlTGlzdCkge1xuICBsZXQgbm9kZSA9IG5vZGVMaXN0W2luZm8uaW5kZXhdO1xuICBsZXQgYmluZGluZyA9IGluZm8uYmluZGluZztcbiAgbGV0IHBhcnQgPSBpbmZvLnBhcnQ7XG4gIC8vIFN1YnBhdGggbm90aWZpY2F0aW9uOiB0cmFuc2Zvcm0gcGF0aCBhbmQgc2V0IHRvIGNsaWVudFxuICAvLyBlLmcuOiBmb289XCJ7e29iai5zdWJ9fVwiLCBwYXRoOiAnb2JqLnN1Yi5wcm9wJywgc2V0ICdmb28ucHJvcCc9b2JqLnN1Yi5wcm9wXG4gIGlmIChoYXNQYXRocyAmJiBwYXJ0LnNvdXJjZSAmJiAocGF0aC5sZW5ndGggPiBwYXJ0LnNvdXJjZS5sZW5ndGgpICYmXG4gICAgICAoYmluZGluZy5raW5kID09ICdwcm9wZXJ0eScpICYmICFiaW5kaW5nLmlzQ29tcG91bmQgJiZcbiAgICAgIG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvcltiaW5kaW5nLnRhcmdldF0pIHtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc1twYXRoXTtcbiAgICBwYXRoID0gdHJhbnNsYXRlKHBhcnQuc291cmNlLCBiaW5kaW5nLnRhcmdldCwgcGF0aCk7XG4gICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICBpbnN0Ll9lbnF1ZXVlQ2xpZW50KG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgdmFsdWUgPSBpbmZvLmV2YWx1YXRvci5fZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgIC8vIFByb3BhZ2F0ZSB2YWx1ZSB0byBjaGlsZFxuICAgIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhbiBcImJpbmRpbmdcIiAoYmluZGluZykgZWZmZWN0IHRvIGEgbm9kZSxcbiAqIGVpdGhlciBhcyBhIHByb3BlcnR5IG9yIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSBvd25pbmcgdGhlIGJpbmRpbmcgZWZmZWN0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGFyZ2V0IG5vZGUgZm9yIGJpbmRpbmdcbiAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlCaW5kaW5nVmFsdWUoaW5zdCwgbm9kZSwgYmluZGluZywgcGFydCwgdmFsdWUpIHtcbiAgdmFsdWUgPSBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KTtcbiAgaWYgKHNhbml0aXplRE9NVmFsdWUpIHtcbiAgICB2YWx1ZSA9IHNhbml0aXplRE9NVmFsdWUodmFsdWUsIGJpbmRpbmcudGFyZ2V0LCBiaW5kaW5nLmtpbmQsIG5vZGUpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAvLyBBdHRyaWJ1dGUgYmluZGluZ1xuICAgIGluc3QuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8obm9kZSksIHZhbHVlLCBiaW5kaW5nLnRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJvcGVydHkgYmluZGluZ1xuICAgIGxldCBwcm9wID0gYmluZGluZy50YXJnZXQ7XG4gICAgaWYgKG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wXSkge1xuICAgICAgaWYgKCFub2RlW1RZUEVTLlJFQURfT05MWV0gfHwgIW5vZGVbVFlQRVMuUkVBRF9PTkxZXVtwcm9wXSkge1xuICAgICAgICBpZiAobm9kZS5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3AsIHZhbHVlKSkge1xuICAgICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgIHtcbiAgICAgIGluc3QuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIFwiYmluZGluZ1wiIGVmZmVjdCB2YWx1ZSBiYXNlZCBvbiBjb21wb3VuZCAmIG5lZ2F0aW9uXG4gKiBlZmZlY3QgbWV0YWRhdGEsIGFzIHdlbGwgYXMgaGFuZGxpbmcgZm9yIHNwZWNpYWwtY2FzZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhlIHZhbHVlIHdpbGwgYmUgc2V0IHRvXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEByZXR1cm4geyp9IFRyYW5zZm9ybWVkIHZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUJpbmRpbmdWYWx1ZShub2RlLCB2YWx1ZSwgYmluZGluZywgcGFydCkge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZVtiaW5kaW5nLnRhcmdldF07XG4gICAgc3RvcmFnZVtwYXJ0LmNvbXBvdW5kSW5kZXhdID0gdmFsdWU7XG4gICAgdmFsdWUgPSBzdG9yYWdlLmpvaW4oJycpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgIT09ICdhdHRyaWJ1dGUnKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzZXJpYWxpemUgYHVuZGVmaW5lZGAgdG8gYFwidW5kZWZpbmVkXCJgXG4gICAgaWYgKGJpbmRpbmcudGFyZ2V0ID09PSAndGV4dENvbnRlbnQnIHx8XG4gICAgICAgIChub2RlLmxvY2FsTmFtZSA9PSAnaW5wdXQnICYmIGJpbmRpbmcudGFyZ2V0ID09ICd2YWx1ZScpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBiaW5kaW5nJ3MgbWV0YWRhdGEgbWVldHMgYWxsIHRoZSByZXF1aXJlbWVudHMgdG8gYWxsb3dcbiAqIDItd2F5IGJpbmRpbmcsIGFuZCB0aGVyZWZvcmUgYSBgPHByb3BlcnR5Pi1jaGFuZ2VkYCBldmVudCBsaXN0ZW5lciBzaG91bGQgYmVcbiAqIGFkZGVkOlxuICogLSB1c2VkIGN1cmx5IGJyYWNlc1xuICogLSBpcyBhIHByb3BlcnR5IChub3QgYXR0cmlidXRlKSBiaW5kaW5nXG4gKiAtIGlzIG5vdCBhIHRleHRDb250ZW50IGJpbmRpbmdcbiAqIC0gaXMgbm90IGNvbXBvdW5kXG4gKlxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIDItd2F5IGxpc3RlbmVyIHNob3VsZCBiZSBhZGRlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykge1xuICByZXR1cm4gQm9vbGVhbihiaW5kaW5nLnRhcmdldCkgJiZcbiAgICAgICAgIGJpbmRpbmcua2luZCAhPSAnYXR0cmlidXRlJyAmJlxuICAgICAgICAgYmluZGluZy5raW5kICE9ICd0ZXh0JyAmJlxuICAgICAgICAgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgICAgYmluZGluZy5wYXJ0c1swXS5tb2RlID09PSAneyc7XG59XG5cbi8qKlxuICogU2V0dXAgY29tcG91bmQgYmluZGluZyBzdG9yYWdlIHN0cnVjdHVyZXMsIG5vdGlmeSBsaXN0ZW5lcnMsIGFuZCBkYXRhSG9zdFxuICogcmVmZXJlbmNlcyBvbnRvIHRoZSBib3VuZCBub2RlTGlzdC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRoYXQgYmFzIGJlZW4gcHJldmlvdXNseSBib3VuZFxuICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBCaW5kaW5ncyhpbnN0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgZGF0YUhvc3QsIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gIGxldCB7bm9kZUxpc3QsIG5vZGVJbmZvTGlzdH0gPSB0ZW1wbGF0ZUluZm87XG4gIGlmIChub2RlSW5mb0xpc3QubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaW5mbyA9IG5vZGVJbmZvTGlzdFtpXTtcbiAgICAgIGxldCBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgICBsZXQgYmluZGluZ3MgPSBpbmZvLmJpbmRpbmdzO1xuICAgICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZyk7XG4gICAgICAgICAgYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuX19kYXRhSG9zdCA9IGluc3Q7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYF9fZGF0YUNvbXBvdW5kU3RvcmFnZWAgbG9jYWwgc3RvcmFnZSBvbiBhIGJvdW5kIG5vZGUgd2l0aFxuICogaW5pdGlhbCBsaXRlcmFsIGRhdGEgZm9yIGNvbXBvdW5kIGJpbmRpbmdzLCBhbmQgc2V0cyB0aGUgam9pbmVkXG4gKiBsaXRlcmFsIHBhcnRzIHRvIHRoZSBib3VuZCBwcm9wZXJ0eS5cbiAqXG4gKiBXaGVuIGNoYW5nZXMgdG8gY29tcG91bmQgcGFydHMgb2NjdXIsIHRoZXkgYXJlIGZpcnN0IHNldCBpbnRvIHRoZSBjb21wb3VuZFxuICogc3RvcmFnZSBhcnJheSBmb3IgdGhhdCBwcm9wZXJ0eSwgYW5kIHRoZW4gdGhlIGFycmF5IGlzIGpvaW5lZCB0byByZXN1bHQgaW5cbiAqIHRoZSBmaW5hbCB2YWx1ZSBzZXQgdG8gdGhlIHByb3BlcnR5L2F0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgQm91bmQgbm9kZSB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgLy8gQ3JlYXRlIGNvbXBvdW5kIHN0b3JhZ2UgbWFwXG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fFxuICAgICAgKG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlID0ge30pO1xuICAgIGxldCBwYXJ0cyA9IGJpbmRpbmcucGFydHM7XG4gICAgLy8gQ29weSBsaXRlcmFscyBmcm9tIHBhcnRzIGludG8gc3RvcmFnZSBmb3IgdGhpcyBiaW5kaW5nXG4gICAgbGV0IGxpdGVyYWxzID0gbmV3IEFycmF5KHBhcnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaj0wOyBqPHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsaXRlcmFsc1tqXSA9IHBhcnRzW2pdLmxpdGVyYWw7XG4gICAgfVxuICAgIGxldCB0YXJnZXQgPSBiaW5kaW5nLnRhcmdldDtcbiAgICBzdG9yYWdlW3RhcmdldF0gPSBsaXRlcmFscztcbiAgICAvLyBDb25maWd1cmUgcHJvcGVydGllcyB3aXRoIHRoZWlyIGxpdGVyYWwgcGFydHNcbiAgICBpZiAoYmluZGluZy5saXRlcmFsICYmIGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSB7XG4gICAgICBub2RlW3RhcmdldF0gPSBiaW5kaW5nLmxpdGVyYWw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkcyBhIDItd2F5IGJpbmRpbmcgbm90aWZpY2F0aW9uIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlIHNwZWNpZmllZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIENoaWxkIGVsZW1lbnQgdG8gYWRkIGxpc3RlbmVyIHRvXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSB0byBoYW5kbGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5saXN0ZW5lckV2ZW50KSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmxpc3RlbmVyRXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihlLCBpbnN0LCBiaW5kaW5nLnRhcmdldCwgcGFydC5zb3VyY2UsIHBhcnQubmVnYXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyAtLSBmb3IgbWV0aG9kLWJhc2VkIGVmZmVjdHMgKGNvbXBsZXhPYnNlcnZlciAmIGNvbXB1dGVkKSAtLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyBmb3IgZWFjaCBhcmd1bWVudCBpbiB0aGUgbWV0aG9kIHNpZ25hdHVyZSAoYW5kXG4gKiBvcHRpb25hbGx5LCBmb3IgdGhlIG1ldGhvZCBuYW1lIGlmIGBkeW5hbWljYCBpcyB0cnVlKSB0aGF0IGNhbGxzIHRoZVxuICogcHJvdmlkZWQgZWZmZWN0IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudCB8IE9iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIG9mIHByb3BlcnR5IGVmZmVjdCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVmZmVjdEZuIEZ1bmN0aW9uIHRvIHJ1biB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcbiAqIEBwYXJhbSB7Kj19IG1ldGhvZEluZm8gRWZmZWN0LXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGJlIGluY2x1ZGVkIGluXG4gKiAgIG1ldGhvZCBlZmZlY3QgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LiBOb3RlLFxuICogICBkZWZhdWx0cyB0byB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgc3RhdGljIChzaWcuc3RhdGljIGlzIHRydWUpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRWZmZWN0KG1vZGVsLCBzaWcsIHR5cGUsIGVmZmVjdEZuLCBtZXRob2RJbmZvLCBkeW5hbWljRm4pIHtcbiAgZHluYW1pY0ZuID0gc2lnLnN0YXRpYyB8fCAoZHluYW1pY0ZuICYmXG4gICAgKHR5cGVvZiBkeW5hbWljRm4gIT09ICdvYmplY3QnIHx8IGR5bmFtaWNGbltzaWcubWV0aG9kTmFtZV0pKTtcbiAgbGV0IGluZm8gPSB7XG4gICAgbWV0aG9kTmFtZTogc2lnLm1ldGhvZE5hbWUsXG4gICAgYXJnczogc2lnLmFyZ3MsXG4gICAgbWV0aG9kSW5mbyxcbiAgICBkeW5hbWljRm5cbiAgfTtcbiAgZm9yIChsZXQgaT0wLCBhcmc7IChpPHNpZy5hcmdzLmxlbmd0aCkgJiYgKGFyZz1zaWcuYXJnc1tpXSk7IGkrKykge1xuICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChhcmcucm9vdFByb3BlcnR5LCB0eXBlLCB7XG4gICAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mbywgdHJpZ2dlcjogYXJnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGR5bmFtaWNGbikge1xuICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChzaWcubWV0aG9kTmFtZSwgdHlwZSwge1xuICAgICAgZm46IGVmZmVjdEZuLCBpbmZvOiBpbmZvXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCB3aXRoIGFyZ3VtZW50cyBtYXJzaGFsZWQgZnJvbSBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZVxuICogYmFzZWQgb24gdGhlIG1ldGhvZCBzaWduYXR1cmUgY29udGFpbmVkIGluIHRoZSBlZmZlY3QgbWV0YWRhdGEuXG4gKlxuICogTXVsdGktcHJvcGVydHkgb2JzZXJ2ZXJzLCBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICogZnVuY3Rpb25zIGNhbGwgdGhpcyBmdW5jdGlvbiB0byBpbnZva2UgdGhlIG1ldGhvZCwgdGhlbiB1c2UgdGhlIHJldHVyblxuICogdmFsdWUgYWNjb3JkaW5nbHkuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbWV0aG9kIGludm9jYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICBsZXQgY29udGV4dCA9IGluc3QuX21ldGhvZEhvc3QgfHwgaW5zdDtcbiAgbGV0IGZuID0gY29udGV4dFtpbmZvLm1ldGhvZE5hbWVdO1xuICBpZiAoZm4pIHtcbiAgICBsZXQgYXJncyA9IG1hcnNoYWxBcmdzKGluc3QuX19kYXRhLCBpbmZvLmFyZ3MsIHByb3BlcnR5LCBwcm9wcyk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2FybignbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgfVxufVxuXG5jb25zdCBlbXB0eUFycmF5ID0gW107XG5cbi8vIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdXNlZCBmb3IgYmluZGluZ1xuY29uc3QgSURFTlQgID0gJyg/OicgKyAnW2EtekEtWl8kXVtcXFxcdy46JFxcXFwtKl0qJyArICcpJztcbmNvbnN0IE5VTUJFUiA9ICcoPzonICsgJ1stK10/WzAtOV0qXFxcXC4/WzAtOV0rKD86W2VFXVstK10/WzAtOV0rKT8nICsgJyknO1xuY29uc3QgU1FVT1RFX1NUUklORyA9ICcoPzonICsgJ1xcJyg/OlteXFwnXFxcXFxcXFxdfFxcXFxcXFxcLikqXFwnJyArICcpJztcbmNvbnN0IERRVU9URV9TVFJJTkcgPSAnKD86JyArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFwuKSpcIicgKyAnKSc7XG5jb25zdCBTVFJJTkcgPSAnKD86JyArIFNRVU9URV9TVFJJTkcgKyAnfCcgKyBEUVVPVEVfU1RSSU5HICsgJyknO1xuY29uc3QgQVJHVU1FTlQgPSAnKD86KCcgKyBJREVOVCArICd8JyArIE5VTUJFUiArICd8JyArICBTVFJJTkcgKyAnKVxcXFxzKicgKyAnKSc7XG5jb25zdCBBUkdVTUVOVFMgPSAnKD86JyArIEFSR1VNRU5UICsgJyg/OixcXFxccyonICsgQVJHVU1FTlQgKyAnKSonICsgJyknO1xuY29uc3QgQVJHVU1FTlRfTElTVCA9ICcoPzonICsgJ1xcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIEFSR1VNRU5UUyArICc/JyArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFwpXFxcXHMqJyArICcpJztcbmNvbnN0IEJJTkRJTkcgPSAnKCcgKyBJREVOVCArICdcXFxccyonICsgQVJHVU1FTlRfTElTVCArICc/JyArICcpJzsgLy8gR3JvdXAgM1xuY29uc3QgT1BFTl9CUkFDS0VUID0gJyhcXFxcW1xcXFxbfHt7KScgKyAnXFxcXHMqJztcbmNvbnN0IENMT1NFX0JSQUNLRVQgPSAnKD86XV18fX0pJztcbmNvbnN0IE5FR0FURSA9ICcoPzooISlcXFxccyopPyc7IC8vIEdyb3VwIDJcbmNvbnN0IEVYUFJFU1NJT04gPSBPUEVOX0JSQUNLRVQgKyBORUdBVEUgKyBCSU5ESU5HICsgQ0xPU0VfQlJBQ0tFVDtcbmNvbnN0IGJpbmRpbmdSZWdleCA9IG5ldyBSZWdFeHAoRVhQUkVTU0lPTiwgXCJnXCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHN0cmluZyBmcm9tIGJpbmRpbmcgcGFydHMgb2YgYWxsIHRoZSBsaXRlcmFsIHBhcnRzXG4gKlxuICogQHBhcmFtIHshQXJyYXk8QmluZGluZ1BhcnQ+fSBwYXJ0cyBBbGwgcGFydHMgdG8gc3RyaW5naWZ5XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyBtYWRlIGZyb20gdGhlIGxpdGVyYWwgcGFydHNcbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cykge1xuICBsZXQgcyA9ICcnO1xuICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbGl0ZXJhbCA9IHBhcnRzW2ldLmxpdGVyYWw7XG4gICAgcyArPSBsaXRlcmFsIHx8ICcnO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHN0cmluZyBmb3IgYSBtZXRob2Qgc2lnbmF0dXJlLCBhbmQgcmV0dXJucyBhIG1ldGFkYXRhXG4gKiBkZXNjcmliaW5nIHRoZSBtZXRob2QgaW4gdGVybXMgb2YgYG1ldGhvZE5hbWVgLCBgc3RhdGljYCAod2hldGhlciBhbGwgdGhlXG4gKiBhcmd1bWVudHMgYXJlIGxpdGVyYWxzKSwgYW5kIGFuIGFycmF5IG9mIGBhcmdzYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHs/TWV0aG9kU2lnbmF0dXJlfSBUaGUgbWV0aG9kIG1ldGFkYXRhIG9iamVjdCBpZiBhIG1ldGhvZCBleHByZXNzaW9uIHdhc1xuICogICBmb3VuZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU1ldGhvZChleHByZXNzaW9uKSB7XG4gIC8vIHRyaWVzIHRvIG1hdGNoIHZhbGlkIGphdmFzY3JpcHQgcHJvcGVydHkgbmFtZXNcbiAgbGV0IG0gPSBleHByZXNzaW9uLm1hdGNoKC8oW15cXHNdKz8pXFwoKFtcXHNcXFNdKilcXCkvKTtcbiAgaWYgKG0pIHtcbiAgICBsZXQgbWV0aG9kTmFtZSA9IG1bMV07XG4gICAgbGV0IHNpZyA9IHsgbWV0aG9kTmFtZSwgc3RhdGljOiB0cnVlLCBhcmdzOiBlbXB0eUFycmF5IH07XG4gICAgaWYgKG1bMl0udHJpbSgpKSB7XG4gICAgICAvLyByZXBsYWNlIGVzY2FwZWQgY29tbWFzIHdpdGggY29tbWEgZW50aXR5LCBzcGxpdCBvbiB1bi1lc2NhcGVkIGNvbW1hc1xuICAgICAgbGV0IGFyZ3MgPSBtWzJdLnJlcGxhY2UoL1xcXFwsL2csICcmY29tbWE7Jykuc3BsaXQoJywnKTtcbiAgICAgIHJldHVybiBwYXJzZUFyZ3MoYXJncywgc2lnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBhbmQgc2V0cyB0aGUgYGFyZ3NgIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZFxuICogc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdC4gU2V0cyB0aGUgYHN0YXRpY2AgcHJvcGVydHkgdG8gZmFsc2UgaWYgYW55XG4gKiBhcmd1bWVudCBpcyBhIG5vbi1saXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IGFyZ0xpc3QgQXJyYXkgb2YgYXJndW1lbnQgbmFtZXNcbiAqIEBwYXJhbSB7IU1ldGhvZFNpZ25hdHVyZX0gc2lnIE1ldGhvZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcmV0dXJuIHshTWV0aG9kU2lnbmF0dXJlfSBUaGUgdXBkYXRlZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZ3MoYXJnTGlzdCwgc2lnKSB7XG4gIHNpZy5hcmdzID0gYXJnTGlzdC5tYXAoZnVuY3Rpb24ocmF3QXJnKSB7XG4gICAgbGV0IGFyZyA9IHBhcnNlQXJnKHJhd0FyZyk7XG4gICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgc2lnLnN0YXRpYyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9LCB0aGlzKTtcbiAgcmV0dXJuIHNpZztcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gaW5kaXZpZHVhbCBhcmd1bWVudCwgYW5kIHJldHVybnMgYW4gYXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqICAge1xuICogICAgIHZhbHVlOiAncHJvcCcsICAgICAgICAvLyBwcm9wZXJ0eS9wYXRoIG9yIGxpdGVyYWwgdmFsdWVcbiAqICAgICBsaXRlcmFsOiBmYWxzZSwgICAgICAgLy8gd2hldGhlciBhcmd1bWVudCBpcyBhIGxpdGVyYWxcbiAqICAgICBzdHJ1Y3R1cmVkOiBmYWxzZSwgICAgLy8gd2hldGhlciB0aGUgcHJvcGVydHkgaXMgYSBwYXRoXG4gKiAgICAgcm9vdFByb3BlcnR5OiAncHJvcCcsIC8vIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoXG4gKiAgICAgd2lsZGNhcmQ6IGZhbHNlICAgICAgIC8vIHdoZXRoZXIgdGhlIGFyZ3VtZW50IHdhcyBhIHdpbGRjYXJkICcuKicgcGF0aFxuICogICB9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJhd0FyZyBUaGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICogQHJldHVybiB7IU1ldGhvZEFyZ30gQXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZyhyYXdBcmcpIHtcbiAgLy8gY2xlYW4gdXAgd2hpdGVzcGFjZVxuICBsZXQgYXJnID0gcmF3QXJnLnRyaW0oKVxuICAgIC8vIHJlcGxhY2UgY29tbWEgZW50aXR5IHdpdGggY29tbWFcbiAgICAucmVwbGFjZSgvJmNvbW1hOy9nLCAnLCcpXG4gICAgLy8gcmVwYWlyIGV4dHJhIGVzY2FwZSBzZXF1ZW5jZXM7IG5vdGUgb25seSBjb21tYXMgc3RyaWN0bHkgbmVlZFxuICAgIC8vIGVzY2FwaW5nLCBidXQgd2UgYWxsb3cgYW55IG90aGVyIGNoYXIgdG8gYmUgZXNjYXBlZCBzaW5jZSBpdHNcbiAgICAvLyBsaWtlbHkgdXNlcnMgd2lsbCBkbyB0aGlzXG4gICAgLnJlcGxhY2UoL1xcXFwoLikvZywgJ1xcJDEnKVxuICAgIDtcbiAgLy8gYmFzaWMgYXJndW1lbnQgZGVzY3JpcHRvclxuICBsZXQgYSA9IHtcbiAgICBuYW1lOiBhcmcsXG4gICAgdmFsdWU6ICcnLFxuICAgIGxpdGVyYWw6IGZhbHNlXG4gIH07XG4gIC8vIGRldGVjdCBsaXRlcmFsIHZhbHVlIChtdXN0IGJlIFN0cmluZyBvciBOdW1iZXIpXG4gIGxldCBmYyA9IGFyZ1swXTtcbiAgaWYgKGZjID09PSAnLScpIHtcbiAgICBmYyA9IGFyZ1sxXTtcbiAgfVxuICBpZiAoZmMgPj0gJzAnICYmIGZjIDw9ICc5Jykge1xuICAgIGZjID0gJyMnO1xuICB9XG4gIHN3aXRjaChmYykge1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOlxuICAgICAgYS52YWx1ZSA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBhLnZhbHVlID0gTnVtYmVyKGFyZyk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgLy8gaWYgbm90IGxpdGVyYWwsIGxvb2sgZm9yIHN0cnVjdHVyZWQgcGF0aFxuICBpZiAoIWEubGl0ZXJhbCkge1xuICAgIGEucm9vdFByb3BlcnR5ID0gcm9vdCQwKGFyZyk7XG4gICAgLy8gZGV0ZWN0IHN0cnVjdHVyZWQgcGF0aCAoaGFzIGRvdHMpXG4gICAgYS5zdHJ1Y3R1cmVkID0gaXNQYXRoJDAoYXJnKTtcbiAgICBpZiAoYS5zdHJ1Y3R1cmVkKSB7XG4gICAgICBhLndpbGRjYXJkID0gKGFyZy5zbGljZSgtMikgPT0gJy4qJyk7XG4gICAgICBpZiAoYS53aWxkY2FyZCkge1xuICAgICAgICBhLm5hbWUgPSBhcmcuc2xpY2UoMCwgLTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBHYXRoZXIgdGhlIGFyZ3VtZW50IHZhbHVlcyBmb3IgYSBtZXRob2Qgc3BlY2lmaWVkIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICogb2YgYXJndW1lbnQgbWV0YWRhdGEuXG4gKlxuICogVGhlIGBwYXRoYCBhbmQgYHZhbHVlYCBhcmd1bWVudHMgYXJlIHVzZWQgdG8gZmlsbCBpbiB3aWxkY2FyZCBkZXNjcmlwdG9yXG4gKiB3aGVuIHRoZSBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIGFzIGEgcmVzdWx0IG9mIGEgcGF0aCBub3RpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgSW5zdGFuY2UgZGF0YSBzdG9yYWdlIG9iamVjdCB0byByZWFkIHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHshQXJyYXk8IU1ldGhvZEFyZz59IGFyZ3MgQXJyYXkgb2YgYXJndW1lbnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFByb3BlcnR5L3BhdGggbmFtZSB0aGF0IHRyaWdnZXJlZCB0aGUgbWV0aG9kIGVmZmVjdFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBBcnJheSBvZiBhcmd1bWVudCB2YWx1ZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1hcnNoYWxBcmdzKGRhdGEsIGFyZ3MsIHBhdGgsIHByb3BzKSB7XG4gIGxldCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChsZXQgaT0wLCBsPWFyZ3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgIGxldCBhcmcgPSBhcmdzW2ldO1xuICAgIGxldCBuYW1lID0gYXJnLm5hbWU7XG4gICAgbGV0IHY7XG4gICAgaWYgKGFyZy5saXRlcmFsKSB7XG4gICAgICB2ID0gYXJnLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnLnN0cnVjdHVyZWQpIHtcbiAgICAgICAgdiA9IGdldCQwKGRhdGEsIG5hbWUpO1xuICAgICAgICAvLyB3aGVuIGRhdGEgaXMgbm90IHN0b3JlZCBlLmcuIGBzcGxpY2VzYFxuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdiA9IHByb3BzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gZGF0YVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZy53aWxkY2FyZCkge1xuICAgICAgLy8gT25seSBzZW5kIHRoZSBhY3R1YWwgcGF0aCBjaGFuZ2VkIGluZm8gaWYgdGhlIGNoYW5nZSB0aGF0XG4gICAgICAvLyBjYXVzZWQgdGhlIG9ic2VydmVyIHRvIHJ1biBtYXRjaGVkIHRoZSB3aWxkY2FyZFxuICAgICAgbGV0IGJhc2VDaGFuZ2VkID0gKG5hbWUuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMCk7XG4gICAgICBsZXQgbWF0Y2hlcyA9IChwYXRoLmluZGV4T2YobmFtZSkgPT09IDAgJiYgIWJhc2VDaGFuZ2VkKTtcbiAgICAgIHZhbHVlc1tpXSA9IHtcbiAgICAgICAgcGF0aDogbWF0Y2hlcyA/IHBhdGggOiBuYW1lLFxuICAgICAgICB2YWx1ZTogbWF0Y2hlcyA/IHByb3BzW3BhdGhdIDogdixcbiAgICAgICAgYmFzZTogdlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2ldID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gZGF0YSBhcGlcblxuLyoqXG4gKiBTZW5kcyBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9ucyAoYC5zcGxpY2VzYCBhbmQgYC5sZW5ndGhgKVxuICpcbiAqIE5vdGU6IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG5vcm1hbGl6ZWQgcGF0aHNcbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRvIHNlbmQgbm90aWZpY2F0aW9ucyB0b1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRoZSBtdXRhdGlvbnMgb2NjdXJyZWQgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3RpZnlTcGxpY2VzKGluc3QsIGFycmF5LCBwYXRoLCBzcGxpY2VzKSB7XG4gIGxldCBzcGxpY2VzUGF0aCA9IHBhdGggKyAnLnNwbGljZXMnO1xuICBpbnN0Lm5vdGlmeVBhdGgoc3BsaWNlc1BhdGgsIHsgaW5kZXhTcGxpY2VzOiBzcGxpY2VzIH0pO1xuICBpbnN0Lm5vdGlmeVBhdGgocGF0aCArICcubGVuZ3RoJywgYXJyYXkubGVuZ3RoKTtcbiAgLy8gTnVsbCBoZXJlIHRvIGFsbG93IHBvdGVudGlhbGx5IGxhcmdlIHNwbGljZSByZWNvcmRzIHRvIGJlIEdDJ2VkLlxuICBpbnN0Ll9fZGF0YVtzcGxpY2VzUGF0aF0gPSB7aW5kZXhTcGxpY2VzOiBudWxsfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3BsaWNlIHJlY29yZCBhbmQgc2VuZHMgYW4gYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbiBmb3JcbiAqIHRoZSBkZXNjcmliZWQgbXV0YXRpb25cbiAqXG4gKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBJbnN0YW5jZSB0byBzZW5kIG5vdGlmaWNhdGlvbnMgdG9cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXJyYXkgdGhhdCB3YXMgbXV0YXRlZFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRoZSBhcnJheSBtdXRhdGlvbiBvY2N1cnJlZFxuICogQHBhcmFtIHtudW1iZXJ9IGFkZGVkQ291bnQgTnVtYmVyIG9mIGFkZGVkIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fSByZW1vdmVkIEFycmF5IG9mIHJlbW92ZWQgaXRlbXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVNwbGljZShpbnN0LCBhcnJheSwgcGF0aCwgaW5kZXgsIGFkZGVkQ291bnQsIHJlbW92ZWQpIHtcbiAgbm90aWZ5U3BsaWNlcyhpbnN0LCBhcnJheSwgcGF0aCwgW3tcbiAgICBpbmRleDogaW5kZXgsXG4gICAgYWRkZWRDb3VudDogYWRkZWRDb3VudCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIG9iamVjdDogYXJyYXksXG4gICAgdHlwZTogJ3NwbGljZSdcbiAgfV0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gdXBwZXItY2FzZWQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN0cmluZyB0byB1cHBlcmNhc2VcbiAqIEByZXR1cm4ge3N0cmluZ30gVXBwZXJjYXNlZCBzdHJpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwcGVyKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xufVxuXG5leHBvcnQgY29uc3QgUHJvcGVydHlFZmZlY3RzID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtzdXBlckNsYXNzfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY29uc3QgcHJvcGVydHlFZmZlY3RzQmFzZSA9IFRlbXBsYXRlU3RhbXAoUHJvcGVydHlBY2Nlc3NvcnMoc3VwZXJDbGFzcykpO1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqIEBleHRlbmRzIHtwcm9wZXJ0eUVmZmVjdHNCYXNlfVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUVmZmVjdHMgZXh0ZW5kcyBwcm9wZXJ0eUVmZmVjdHNCYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5O1xuICAgICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHM7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZTtcbiAgICAgIC8qKiBAdHlwZSB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG4gICAgICB0aGlzLl9fZGF0YUhvc3Q7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVRlbXA7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUNsaWVudHNJbml0aWFsaXplZDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19jb21wdXRlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlZmxlY3RFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fbm90aWZ5RWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3Byb3BhZ2F0ZUVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19vYnNlcnZlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlYWRPbmx5O1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXI7XG4gICAgICAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovXG4gICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgIH1cblxuICAgIGdldCBQUk9QRVJUWV9FRkZFQ1RfVFlQRVMoKSB7XG4gICAgICByZXR1cm4gVFlQRVM7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICBob3N0U3RhY2sucmVnaXN0ZXJIb3N0KHRoaXMpO1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSBmYWxzZTtcbiAgICAgIC8vIE1heSBiZSBzZXQgb24gaW5zdGFuY2UgcHJpb3IgdG8gdXBncmFkZVxuICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fCBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFIb3N0ID0gdGhpcy5fX2RhdGFIb3N0IHx8IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFcbiAgICAgKiBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiBvZiBpbml0aWFsaXppbmcgcHJvcGVydGllcyBmcm9tXG4gICAgICogdGhlIHByb3RvdHlwZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBpbml0aWFsaXplIG9uIHRoZSBwcm90b3R5cGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgdGhpcy5fX2RhdGEgPSBPYmplY3QuY3JlYXRlKHByb3BzKTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIGF2b2lkIHNldHRpbmdcbiAgICAgKiBgX3NldFByb3BlcnR5YCdzIGBzaG91bGROb3RpZnk6IHRydWVgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgbGV0IHJlYWRPbmx5ID0gdGhpc1tUWVBFUy5SRUFEX09OTFldO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoIXJlYWRPbmx5IHx8ICFyZWFkT25seVtwcm9wXSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHRoaXMuX19kYXRhUGVuZGluZyB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHRoaXMuX19kYXRhT2xkIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BdID0gdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm90b3R5cGUgc2V0dXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGFkZFByb3BlcnR5RWZmZWN0YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICB0aGlzLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCB0eXBlID09IFRZUEVTLlJFQURfT05MWSk7XG4gICAgICAvLyBlZmZlY3RzIGFyZSBhY2N1bXVsYXRlZCBpbnRvIGFycmF5cyBwZXIgcHJvcGVydHkgYmFzZWQgb24gdHlwZVxuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgaWYgKCFlZmZlY3RzKSB7XG4gICAgICAgIGVmZmVjdHMgPSB0aGlzW3R5cGVdW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgfVxuICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcHJvcGVydHkgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoZSBlZmZlY3Qgd2FzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdCB0byByZW1vdmVcbiAgICAgKi9cbiAgICBfcmVtb3ZlUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgbGV0IGlkeCA9IGVmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGVmZmVjdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBwcm9wZXJ0eSBlZmZlY3RcbiAgICAgKiBvZiBhIGNlcnRhaW4gdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgbGV0IGVmZmVjdHMgPSB0aGlzW3R5cGVdO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZWZmZWN0cyAmJiBlZmZlY3RzW3Byb3BlcnR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcInJlYWQgb25seVwiXG4gICAgICogYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUFEX09OTFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJub3RpZnlcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc05vdGlmeUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWZsZWN0IHRvIGF0dHJpYnV0ZVwiXG4gICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzUmVmbGVjdEVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUZMRUNUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwiY29tcHV0ZWRcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc0NvbXB1dGVkRWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLkNPTVBVVEUpO1xuICAgIH1cblxuICAgIC8vIFJ1bnRpbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHBlbmRpbmcgcHJvcGVydHkgb3IgcGF0aC4gIElmIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoIGluXG4gICAgICogcXVlc3Rpb24gaGFkIG5vIGFjY2Vzc29yLCB0aGUgcGF0aCBpcyBzZXQsIG90aGVyd2lzZSBpdCBpcyBlbnF1ZXVlZFxuICAgICAqIHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzb2xhdGVzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGZ1bmN0aW9uYWxpdHkgbmVjZXNzYXJ5XG4gICAgICogZm9yIHRoZSBwdWJsaWMgQVBJIChgc2V0YCwgYHNldFByb3BlcnRpZXNgLCBgbm90aWZ5UGF0aGAsIGFuZCBwcm9wZXJ0eVxuICAgICAqIGNoYW5nZSBsaXN0ZW5lcnMgdmlhIHt7Li4ufX0gYmluZGluZ3MpLCBzdWNoIHRoYXQgaXQgaXMgb25seSBkb25lXG4gICAgICogd2hlbiBwYXRocyBlbnRlciB0aGUgc3lzdGVtLCBhbmQgbm90IGF0IGV2ZXJ5IHByb3BhZ2F0aW9uIHN0ZXAuICBJdFxuICAgICAqIGFsc28gc2V0cyBhIGBfX2RhdGFIYXNQYXRoc2AgZmxhZyBvbiB0aGUgaW5zdGFuY2Ugd2hpY2ggaXMgdXNlZCB0b1xuICAgICAqIGZhc3QtcGF0aCBzbG93ZXIgcGF0aC1tYXRjaGluZyBjb2RlIGluIHRoZSBwcm9wZXJ0eSBlZmZlY3RzIGhvc3QgcGF0aHMuXG4gICAgICpcbiAgICAgKiBgcGF0aGAgY2FuIGJlIGEgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2YgcGF0aCBwYXJ0cyBhcyBhY2NlcHRlZCBieSB0aGVcbiAgICAgKiBwdWJsaWMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8bnVtYmVyfHN0cmluZz59IHBhdGggUGF0aCB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBTZXQgdG8gdHJ1ZSBpZiB0aGlzIGNoYW5nZSBzaG91bGRcbiAgICAgKiAgY2F1c2UgYSBwcm9wZXJ0eSBub3RpZmljYXRpb24gZXZlbnQgZGlzcGF0Y2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1BhdGhOb3RpZmljYXRpb24gSWYgdGhlIHBhdGggYmVpbmcgc2V0IGlzIGEgcGF0aFxuICAgICAqICAgbm90aWZpY2F0aW9uIG9mIGFuIGFscmVhZHkgY2hhbmdlZCB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBhIHJlcXVlc3RcbiAgICAgKiAgIHRvIHNldCBhbmQgbm90aWZ5IHRoZSBjaGFuZ2UuICBJbiB0aGUgbGF0dGVyIGBmYWxzZWAgY2FzZSwgYSBkaXJ0eVxuICAgICAqICAgY2hlY2sgaXMgcGVyZm9ybWVkIGFuZCB0aGVuIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHBhdGggYmVmb3JlXG4gICAgICogICBlbnF1ZXVpbmcgdGhlIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkvcGF0aCB3YXMgZW5xdWV1ZWQgaW5cbiAgICAgKiAgIHRoZSBwZW5kaW5nIGNoYW5nZXMgYmFnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCBzaG91bGROb3RpZnksIGlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgaWYgKGlzUGF0aE5vdGlmaWNhdGlvbiB8fFxuICAgICAgICAgIHJvb3QkMChBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aFswXSA6IHBhdGgpICE9PSBwYXRoKSB7XG4gICAgICAgIC8vIERpcnR5IGNoZWNrIGNoYW5nZXMgYmVpbmcgc2V0IHRvIGEgcGF0aCBhZ2FpbnN0IHRoZSBhY3R1YWwgb2JqZWN0LFxuICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgcGF0aHMgaW50byB0aGUgc3lzdGVtOyBmcm9tIGhlcmVcbiAgICAgICAgLy8gdGhlIG9ubHkgZGlydHkgY2hlY2tzIGFyZSBhZ2FpbnN0IHRoZSBgX19kYXRhVGVtcGAgY2FjaGUgdG8gcHJldmVudFxuICAgICAgICAvLyBkdXBsaWNhdGUgd29yayBpbiB0aGUgc2FtZSB0dXJuIG9ubHkuIE5vdGUsIGlmIHRoaXMgd2FzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgIC8vIG9mIGEgY2hhbmdlIGFscmVhZHkgc2V0IHRvIGEgcGF0aCAoaXNQYXRoTm90aWZpY2F0aW9uOiB0cnVlKSxcbiAgICAgICAgLy8gd2UgYWx3YXlzIGxldCB0aGUgY2hhbmdlIHRocm91Z2ggYW5kIHNraXAgdGhlIGBzZXRgIHNpbmNlIGl0IHdhc1xuICAgICAgICAvLyBhbHJlYWR5IGRpcnR5IGNoZWNrZWQgYXQgdGhlIHBvaW50IG9mIGVudHJ5IGFuZCB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG4gICAgICAgIGlmICghaXNQYXRoTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgbGV0IG9sZCA9IGdldCQwKHRoaXMsIHBhdGgpO1xuICAgICAgICAgIHBhdGggPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHNldCQwKHRoaXMsIHBhdGgsIHZhbHVlKSk7XG4gICAgICAgICAgLy8gVXNlIHByb3BlcnR5LWFjY2Vzc29yJ3Mgc2ltcGxlciBkaXJ0eSBjaGVja1xuICAgICAgICAgIGlmICghcGF0aCB8fCAhc3VwZXIuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHBhdGgsIHZhbHVlLCBvbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSkpIHtcbiAgICAgICAgICBjb21wdXRlTGlua2VkUGF0aHModGhpcywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3BhdGhdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eSgvKipAdHlwZXtzdHJpbmd9Ki8ocGF0aCksIHZhbHVlLCBzaG91bGROb3RpZnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSB2YWx1ZSB0byBhIG5vbi1Qb2x5bWVyIGVsZW1lbnQvbm9kZSdzIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG1ha2VzIGEgYmVzdC1lZmZvcnQgYXQgYmluZGluZyBpbnRlcm9wOlxuICAgICAqIFNvbWUgbmF0aXZlIGVsZW1lbnQgcHJvcGVydGllcyBoYXZlIHNpZGUtZWZmZWN0cyB3aGVuXG4gICAgICogcmUtc2V0dGluZyB0aGUgc2FtZSB2YWx1ZSAoZS5nLiBzZXR0aW5nIGA8aW5wdXQ+LnZhbHVlYCByZXNldHMgdGhlXG4gICAgICogY3Vyc29yIHBvc2l0aW9uKSwgc28gd2UgZG8gYSBkaXJ0eS1jaGVjayBiZWZvcmUgc2V0dGluZyB0aGUgdmFsdWUuXG4gICAgICogSG93ZXZlciwgZm9yIGJldHRlciBpbnRlcm9wIHdpdGggbm9uLVBvbHltZXIgY3VzdG9tIGVsZW1lbnRzIHRoYXRcbiAgICAgKiBhY2NlcHQgb2JqZWN0cywgd2UgZXhwbGljaXRseSByZS1zZXQgb2JqZWN0IGNoYW5nZXMgY29taW5nIGZyb20gdGhlXG4gICAgICogUG9seW1lciB3b3JsZCAod2hpY2ggbWF5IGluY2x1ZGUgZGVlcCBvYmplY3QgY2hhbmdlcyB3aXRob3V0IHRoZVxuICAgICAqIHRvcCByZWZlcmVuY2UgY2hhbmdpbmcpLCBlcnJpbmcgb24gdGhlIHNpZGUgb2YgcHJvdmlkaW5nIG1vcmVcbiAgICAgKiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGFsdGVybmF0ZSBhcHByb2FjaGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHNldCBhIHByb3BlcnR5IG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIC8vIEl0IGlzIGEganVkZ21lbnQgY2FsbCB0aGF0IHJlc2V0dGluZyBwcmltaXRpdmVzIGlzXG4gICAgICAvLyBcImJhZFwiIGFuZCByZXNldHRpbmdzIG9iamVjdHMgaXMgYWxzbyBcImdvb2RcIjsgYWx0ZXJuYXRpdmVseSB3ZSBjb3VsZFxuICAgICAgLy8gaW1wbGVtZW50IGEgd2hpdGVsaXN0IG9mIHRhZyAmIHByb3BlcnR5IHZhbHVlcyB0aGF0IHNob3VsZCBuZXZlclxuICAgICAgLy8gYmUgcmVzZXQgKGUuZy4gPGlucHV0Pi52YWx1ZSAmJiA8c2VsZWN0Pi52YWx1ZSlcbiAgICAgIGlmICh2YWx1ZSAhPT0gbm9kZVtwcm9wXSB8fCB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgYFByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBpbnRyb2R1Y2Ugc3BlY2lhbFxuICAgICAqIGRpcnR5IGNoZWNrIGxvZ2ljIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydHkgJiB2YWx1ZSBiZWluZyBzZXQ6XG4gICAgICpcbiAgICAgKiAxLiBBbnkgdmFsdWUgc2V0IHRvIGEgcGF0aCAoZS5nLiAnb2JqLnByb3AnOiA0MiBvciAnb2JqLnByb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YVRlbXBgXG4gICAgICogMi4gT2JqZWN0IHNldCB0byBzaW1wbGUgcHJvcGVydHkgKGUuZy4gJ3Byb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgIGFuZCBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0XG4gICAgICogICAgYF9fZGF0YVRlbXBgIGJ5IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYF9zaG91bGRQcm9wZXJ0eUNoYW5nZWBcbiAgICAgKiAzLiBQcmltaXRpdmUgdmFsdWUgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IDQyKVxuICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGBfX2RhdGFgXG4gICAgICpcbiAgICAgKiBUaGUgZGlydHktY2hlY2sgaXMgaW1wb3J0YW50IHRvIHByZXZlbnQgY3ljbGVzIGR1ZSB0byB0d28td2F5XG4gICAgICogbm90aWZpY2F0aW9uLCBidXQgcGF0aHMgYW5kIG9iamVjdHMgYXJlIG9ubHkgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGFueVxuICAgICAqIHByZXZpb3VzIHZhbHVlIHNldCBkdXJpbmcgdGhpcyB0dXJuIHZpYSBhIFwidGVtcG9yYXJ5IGNhY2hlXCIgdGhhdCBpc1xuICAgICAqIGNsZWFyZWQgd2hlbiB0aGUgbGFzdCBgX3Byb3BlcnRpZXNDaGFnZWRgIGV4aXRzLiBUaGlzIGlzIHNvOlxuICAgICAqIGEuIGFueSBjYWNoZWQgYXJyYXkgcGF0aHMgKGUuZy4gJ2FycmF5LjMucHJvcCcpIG1heSBiZSBpbnZhbGlkYXRlZFxuICAgICAqICAgIGR1ZSB0byBhcnJheSBtdXRhdGlvbnMgbGlrZSBzaGlmdC91bnNoaWZ0L3NwbGljZTsgdGhpcyBpcyBmaW5lXG4gICAgICogICAgc2luY2UgcGF0aCBjaGFuZ2VzIGFyZSBkaXJ0eS1jaGVja2VkIGF0IHVzZXIgZW50cnkgcG9pbnRzIGxpa2UgYHNldGBcbiAgICAgKiBiLiBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBvbmx5IGxhc3RzIG9uZSB0dXJuIHRvIGFsbG93IHRoZSB1c2VyXG4gICAgICogICAgdG8gbXV0YXRlIHRoZSBvYmplY3QgaW4tcGxhY2UgYW5kIHJlLXNldCBpdCB3aXRoIHRoZSBzYW1lIGlkZW50aXR5XG4gICAgICogICAgYW5kIGhhdmUgYWxsIHN1Yi1wcm9wZXJ0aWVzIHJlLXByb3BhZ2F0ZWQgaW4gYSBzdWJzZXF1ZW50IHR1cm4uXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcCBjYWNoZSBpcyBub3QgbmVjZXNzYXJpbHkgc3VmZmljaWVudCB0byBwcmV2ZW50IGludmFsaWQgYXJyYXlcbiAgICAgKiBwYXRocywgc2luY2UgYSBzcGxpY2UgY2FuIGhhcHBlbiBkdXJpbmcgdGhlIHNhbWUgdHVybiAod2l0aCBwYXRob2xvZ2ljYWxcbiAgICAgKiB1c2VyIGNvZGUpOyB3ZSBjb3VsZCBpbnRyb2R1Y2UgYSBcImZpeHVwXCIgZm9yIHRlbXBvcmFyaWx5IGNhY2hlZCBhcnJheVxuICAgICAqIHBhdGhzIGlmIG5lZWRlZDogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvNDIyN1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGROb3RpZnkgVHJ1ZSBpZiBwcm9wZXJ0eSBzaG91bGQgZmlyZSBub3RpZmljYXRpb25cbiAgICAgKiAgIGV2ZW50IChhcHBsaWVzIG9ubHkgZm9yIGBub3RpZnk6IHRydWVgIHByb3BlcnRpZXMpXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHNob3VsZE5vdGlmeSkge1xuICAgICAgbGV0IGlzUGF0aCA9IHRoaXMuX19kYXRhSGFzUGF0aHMgJiYgaXNQYXRoJDAocHJvcGVydHkpO1xuICAgICAgbGV0IHByZXZQcm9wcyA9IGlzUGF0aCA/IHRoaXMuX19kYXRhVGVtcCA6IHRoaXMuX19kYXRhO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgcHJldlByb3BzW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgIGlmICghKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXRocyBhcmUgc3RvcmVkIGluIHRlbXBvcmFyeSBjYWNoZSAoY2xlYXJlZCBhdCBlbmQgb2YgdHVybiksXG4gICAgICAgIC8vIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nLCBhbGwgb3RoZXJzIHN0b3JlZCBpbiBfX2RhdGFcbiAgICAgICAgaWYgKGlzUGF0aCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgY2hhbmdlcyBnbyBpbnRvIHBlbmRpbmcgcHJvcGVydHkgYmFnLCBwYXNzZWQgdG8gX3Byb3BlcnRpZXNDaGFuZ2VkXG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgLy8gVHJhY2sgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3RpZnkgc2VwYXJhdGVseVxuICAgICAgICBpZiAoaXNQYXRoIHx8ICh0aGlzW1RZUEVTLk5PVElGWV0gJiYgdGhpc1tUWVBFUy5OT1RJRlldW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gdGhpcy5fX2RhdGFUb05vdGlmeSB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5W3Byb3BlcnR5XSA9IHNob3VsZE5vdGlmeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgYWxsIGFjY2Vzc29ycyBzZXQgYHNob3VsZE5vdGlmeWBcbiAgICAgKiB0byB0cnVlLCBmb3IgcGVyLXByb3BlcnR5IG5vdGlmaWNhdGlvbiB0cmFja2luZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCB0cnVlKSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcmAncyBkZWZhdWx0IGFzeW5jIHF1ZXVpbmcgb2ZcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYDogaWYgYF9fZGF0YVJlYWR5YCBpcyBmYWxzZSAoaGFzIG5vdCB5ZXQgYmVlblxuICAgICAqIG1hbnVhbGx5IGZsdXNoZWQpLCB0aGUgZnVuY3Rpb24gbm8tb3BzOyBvdGhlcndpc2UgZmx1c2hlc1xuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIHN5bmNocm9ub3VzbHkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2xpZW50IG9uIGEgbGlzdCBvZiBwZW5kaW5nIGNsaWVudHMsIHdob3NlXG4gICAgICogcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2VzIGNhbiBsYXRlciBiZSBmbHVzaGVkIHZpYSBhIGNhbGwgdG9cbiAgICAgKiBgX2ZsdXNoQ2xpZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpZW50IFByb3BlcnR5RWZmZWN0cyBjbGllbnQgdG8gZW5xdWV1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZW5xdWV1ZUNsaWVudChjbGllbnQpIHtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzIHx8IFtdO1xuICAgICAgaWYgKGNsaWVudCAhPT0gdGhpcykge1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGFueSBjbGllbnRzIHByZXZpb3VzbHkgZW5xdWV1ZWQgdmlhIGBfZW5xdWV1ZUNsaWVudGAsIGNhdXNpbmdcbiAgICAgKiB0aGVpciBgX2ZsdXNoUHJvcGVydGllc2AgbWV0aG9kIHRvIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZmx1c2hDbGllbnRzKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlYWR5Q2xpZW50cygpO1xuICAgICAgICAvLyBPdmVycmlkZSBwb2ludCB3aGVyZSBhY2Nlc3NvcnMgYXJlIHR1cm5lZCBvbjsgaW1wb3J0YW50bHksXG4gICAgICAgIC8vIHRoaXMgaXMgYWZ0ZXIgY2xpZW50cyBoYXZlIGZ1bGx5IHJlYWRpZWQsIHByb3ZpZGluZyBhIGd1YXJhbnRlZVxuICAgICAgICAvLyB0aGF0IGFueSBwcm9wZXJ0eSBlZmZlY3RzIG9jY3VyIG9ubHkgYWZ0ZXIgYWxsIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IFdlIGVuc3VyZSBjbGllbnRzIGVpdGhlciBlbmFibGUgb3IgZmx1c2ggYXMgYXBwcm9wcmlhdGUuIFRoaXNcbiAgICAvLyBoYW5kbGVzIHR3byBjb3JuZXIgY2FzZXM6XG4gICAgLy8gKDEpIGNsaWVudHMgZmx1c2ggcHJvcGVybHkgd2hlbiBjb25uZWN0ZWQvZW5hYmxlZCBiZWZvcmUgdGhlIGhvc3RcbiAgICAvLyBlbmFibGVzOyBlLmcuXG4gICAgLy8gICAoYSkgVGVtcGxhdGl6ZSBzdGFtcHMgd2l0aCBubyBwcm9wZXJ0aWVzIGFuZCBkb2VzIG5vdCBmbHVzaCBhbmRcbiAgICAvLyAgIChiKSB0aGUgaW5zdGFuY2UgaXMgaW5zZXJ0ZWQgaW50byBkb20gYW5kXG4gICAgLy8gICAoYykgdGhlbiB0aGUgaW5zdGFuY2UgZmx1c2hlcy5cbiAgICAvLyAoMikgY2xpZW50cyBlbmFibGUgcHJvcGVybHkgd2hlbiBub3QgY29ubmVjdGVkL2VuYWJsZWQgd2hlbiB0aGUgaG9zdFxuICAgIC8vIGZsdXNoZXM7IGUuZy5cbiAgICAvLyAgIChhKSBhIHRlbXBsYXRlIGlzIHJ1bnRpbWUgc3RhbXBlZCBhbmQgbm90IHlldCBjb25uZWN0ZWQvZW5hYmxlZFxuICAgIC8vICAgKGIpIGEgaG9zdCBzZXRzIGEgcHJvcGVydHksIGNhdXNpbmcgc3RhbXBlZCBkb20gdG8gZmx1c2hcbiAgICAvLyAgIChjKSB0aGUgc3RhbXBlZCBkb20gZW5hYmxlcy5cbiAgICBfX2VuYWJsZU9yRmx1c2hDbGllbnRzKCkge1xuICAgICAgbGV0IGNsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzO1xuICAgICAgaWYgKGNsaWVudHMpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgY2xpZW50ID0gY2xpZW50c1tpXTtcbiAgICAgICAgICBpZiAoIWNsaWVudC5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgICAgICBjbGllbnQuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaWVudC5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICBjbGllbnQuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW55IGluaXRpYWwgc2V0dXAgb24gY2xpZW50IGRvbS4gQ2FsbGVkIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgKiBgX2ZsdXNoUHJvcGVydGllc2AgY2FsbCBvbiBjbGllbnQgZG9tIGFuZCBiZWZvcmUgYW55IGVsZW1lbnRcbiAgICAgKiBvYnNlcnZlcnMgYXJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgdGhpcy5fX2VuYWJsZU9yRmx1c2hDbGllbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGJhZyBvZiBwcm9wZXJ0eSBjaGFuZ2VzIHRvIHRoaXMgaW5zdGFuY2UsIGFuZFxuICAgICAqIHN5bmNocm9ub3VzbHkgcHJvY2Vzc2VzIGFsbCBlZmZlY3RzIG9mIHRoZSBwcm9wZXJ0aWVzIGFzIGEgYmF0Y2guXG4gICAgICpcbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtdXN0IGJlIHNpbXBsZSBwcm9wZXJ0aWVzLCBub3QgcGF0aHMuICBCYXRjaGVkXG4gICAgICogcGF0aCBwcm9wYWdhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBvbmUgb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2hvc2Uga2V5IGlzXG4gICAgICogICBhIHByb3BlcnR5IGFuZCB2YWx1ZSBpcyB0aGUgbmV3IHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXRSZWFkT25seSBXaGVuIHRydWUsIGFueSBwcml2YXRlIHZhbHVlcyBzZXQgaW5cbiAgICAgKiAgIGBwcm9wc2Agd2lsbCBiZSBzZXQuIEJ5IGRlZmF1bHQsIGBzZXRQcm9wZXJ0aWVzYCB3aWxsIG5vdCBzZXRcbiAgICAgKiAgIGByZWFkT25seTogdHJ1ZWAgcm9vdCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXRQcm9wZXJ0aWVzKHByb3BzLCBzZXRSZWFkT25seSkge1xuICAgICAgZm9yIChsZXQgcGF0aCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoc2V0UmVhZE9ubHkgfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldW3BhdGhdKSB7XG4gICAgICAgICAgLy9UT0RPKGtzY2hhYWYpOiBleHBsaWNpdGx5IGRpc2FsbG93IHBhdGhzIGluIHNldFByb3BlcnR5P1xuICAgICAgICAgIC8vIHdpbGRjYXJkIG9ic2VydmVycyBjdXJyZW50bHkgb25seSBwYXNzIHRoZSBmaXJzdCBjaGFuZ2VkIHBhdGhcbiAgICAgICAgICAvLyBpbiB0aGUgYGluZm9gIG9iamVjdCwgYW5kIHlvdSBjb3VsZCBkbyBzb21lIG9kZCB0aGluZ3MgYmF0Y2hpbmdcbiAgICAgICAgICAvLyBwYXRocywgZS5nLiB7J2Zvby5iYXInOiB7Li4ufSwgJ2Zvbyc6IG51bGx9XG4gICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHByb3BzW3BhdGhdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCBzbyB0aGF0IHByb3BlcnR5IGFjY2Vzc29yXG4gICAgICogc2lkZSBlZmZlY3RzIGFyZSBub3QgZW5hYmxlZCB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGZ1bGx5IHJlYWR5LlxuICAgICAqIEFsc28gY2FsbHMgYF9mbHVzaENsaWVudHNgIGNhbGxiYWNrIHRvIGVuc3VyZSBjbGllbnQgZG9tIGlzIGVuYWJsZWRcbiAgICAgKiB0aGF0IHdhcyBub3QgZW5hYmxlZCBhcyBhIHJlc3VsdCBvZiBmbHVzaGluZyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCBgc3VwZXIucmVhZHkoKWAgaXMgbm90IGNhbGxlZCBoZXJlIGFzIGl0XG4gICAgICAvLyBpbW1lZGlhdGVseSB0dXJucyBvbiBhY2Nlc3NvcnMuIEluc3RlYWQsIHdlIHdhaXQgdW50aWwgYHJlYWR5Q2xpZW50c2BcbiAgICAgIC8vIHRvIGVuYWJsZSBhY2Nlc3NvcnMgdG8gcHJvdmlkZSBhIGd1YXJhbnRlZSB0aGF0IGNsaWVudHMgYXJlIHJlYWR5XG4gICAgICAvLyBiZWZvcmUgcHJvY2Vzc2luZyBhbnkgYWNjZXNzb3JzIHNpZGUgZWZmZWN0cy5cbiAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgLy8gSWYgbm8gZGF0YSB3YXMgcGVuZGluZywgYF9mbHVzaFByb3BlcnRpZXNgIHdpbGwgbm90IGBmbHVzaENsaWVudHNgXG4gICAgICAvLyBzbyBlbnN1cmUgdGhpcyBpcyBkb25lLlxuICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIH1cbiAgICAgIC8vIEJlZm9yZSByZWFkeSwgY2xpZW50IG5vdGlmaWNhdGlvbnMgZG8gbm90IHRyaWdnZXIgX2ZsdXNoUHJvcGVydGllcy5cbiAgICAgIC8vIFRoZXJlZm9yZSBhIGZsdXNoIGlzIG5lY2Vzc2FyeSBoZXJlIGlmIGRhdGEgaGFzIGJlZW4gc2V0LlxuICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGBQcm9wZXJ0eUFjY2Vzc29yc2AncyBwcm9wZXJ0aWVzIGNoYW5nZWQgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBSdW5zIGVhY2ggY2xhc3Mgb2YgZWZmZWN0cyBmb3IgdGhlIGJhdGNoIG9mIGNoYW5nZWQgcHJvcGVydGllcyBpblxuICAgICAqIGEgc3BlY2lmaWMgb3JkZXIgKGNvbXB1dGUsIHByb3BhZ2F0ZSwgcmVmbGVjdCwgb2JzZXJ2ZSwgbm90aWZ5KS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHtcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIGxldCBjID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hhbmdlZFByb3BzIHx8IHt9KTtcbiAgICAgIC8vIHdpbmRvdy5kZWJ1ZyAmJiBjb25zb2xlLmdyb3VwKHRoaXMubG9jYWxOYW1lICsgJyMnICsgdGhpcy5pZCArICc6ICcgKyBjKTtcbiAgICAgIC8vIGlmICh3aW5kb3cuZGVidWcpIHsgZGVidWdnZXI7IH1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGxldCBoYXNQYXRocyA9IHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICAvLyBDb21wdXRlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkNvbXB1dGVkRWZmZWN0cyh0aGlzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBDbGVhciBub3RpZnkgcHJvcGVydGllcyBwcmlvciB0byBwb3NzaWJsZSByZWVudHJ5IChwcm9wYWdhdGUsIG9ic2VydmUpLFxuICAgICAgLy8gYnV0IGFmdGVyIGNvbXB1dGluZyBlZmZlY3RzIGhhdmUgYSBjaGFuY2UgdG8gYWRkIHRvIHRoZW1cbiAgICAgIGxldCBub3RpZnlQcm9wcyA9IHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgIC8vIFByb3BhZ2F0ZSBwcm9wZXJ0aWVzIHRvIGNsaWVudHNcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBGbHVzaCBjbGllbnRzXG4gICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIC8vIFJlZmxlY3QgcHJvcGVydGllc1xuICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlJFRkxFQ1RdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBPYnNlcnZlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5PQlNFUlZFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gTm90aWZ5IHByb3BlcnRpZXMgdG8gaG9zdFxuICAgICAgaWYgKG5vdGlmeVByb3BzKSB7XG4gICAgICAgIHJ1bk5vdGlmeUVmZmVjdHModGhpcywgbm90aWZ5UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIHRlbXBvcmFyeSBjYWNoZSBhdCBlbmQgb2YgdHVyblxuICAgICAgaWYgKHRoaXMuX19kYXRhQ291bnRlciA9PSAxKSB7XG4gICAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgfVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXBFbmQodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwcm9wYWdhdGUgYW55IHByb3BlcnR5IGNoYW5nZXMgdG8gc3RhbXBlZCB0ZW1wbGF0ZSBub2Rlc1xuICAgICAqIG1hbmFnZWQgYnkgdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgaWYgKHRoaXNbVFlQRVMuUFJPUEFHQVRFXSkge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuUFJPUEFHQVRFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgfVxuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICB3aGlsZSAodGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcyxcbiAgICAgICAgICBoYXNQYXRocywgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXNlcyBvbmUgZGF0YSBwYXRoIGFzIGFub3RoZXIsIHN1Y2ggdGhhdCBwYXRoIG5vdGlmaWNhdGlvbnMgZnJvbSBvbmVcbiAgICAgKiBhcmUgcm91dGVkIHRvIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSB0byBUYXJnZXQgcGF0aCB0byBsaW5rLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBmcm9tIFNvdXJjZSBwYXRoIHRvIGxpbmsuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGxpbmtQYXRocyh0bywgZnJvbSkge1xuICAgICAgdG8gPSBub3JtYWxpemUodG8pO1xuICAgICAgZnJvbSA9IG5vcm1hbGl6ZShmcm9tKTtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzIHx8IHt9O1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1t0b10gPSBmcm9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkYXRhIHBhdGggYWxpYXMgcHJldmlvdXNseSBlc3RhYmxpc2hlZCB3aXRoIGBfbGlua1BhdGhzYC5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoZSBwYXRoIHRvIHVubGluayBzaG91bGQgYmUgdGhlIHRhcmdldCAoYHRvYCkgdXNlZCB3aGVuXG4gICAgICogbGlua2luZyB0aGUgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBUYXJnZXQgcGF0aCB0byB1bmxpbmsuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVubGlua1BhdGhzKHBhdGgpIHtcbiAgICAgIHBhdGggPSBub3JtYWxpemUocGF0aCk7XG4gICAgICBpZiAodGhpcy5fX2RhdGFMaW5rZWRQYXRocykge1xuICAgICAgICBkZWxldGUgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1twYXRoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgdGhhdCBhbiBhcnJheSBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgdGhpcy5pdGVtcyA9IFsge25hbWU6ICdKaW0nfSwge25hbWU6ICdUb2RkJ30sIHtuYW1lOiAnQmlsbCd9IF07XG4gICAgICogICAgIC4uLlxuICAgICAqICAgICB0aGlzLml0ZW1zLnNwbGljZSgxLCAxLCB7bmFtZTogJ1NhbSd9KTtcbiAgICAgKiAgICAgdGhpcy5pdGVtcy5wdXNoKHtuYW1lOiAnQm9iJ30pO1xuICAgICAqICAgICB0aGlzLm5vdGlmeVNwbGljZXMoJ2l0ZW1zJywgW1xuICAgICAqICAgICAgIHsgaW5kZXg6IDEsIHJlbW92ZWQ6IFt7bmFtZTogJ1RvZGQnfV0sIGFkZGVkQ291bnQ6IDEsIG9iZWN0OiB0aGlzLml0ZW1zLCB0eXBlOiAnc3BsaWNlJyB9LFxuICAgICAqICAgICAgIHsgaW5kZXg6IDMsIHJlbW92ZWQ6IFtdLCBhZGRlZENvdW50OiAxLCBvYmplY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnfVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3BsaWNlcyBBcnJheSBvZiBzcGxpY2UgcmVjb3JkcyBpbmRpY2F0aW5nIG9yZGVyZWRcbiAgICAgKiAgIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCB0byB0aGUgYXJyYXkuIEVhY2ggcmVjb3JkIHNob3VsZCBoYXZlIHRoZVxuICAgICAqICAgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgKiAgICAqIGluZGV4OiBpbmRleCBhdCB3aGljaCB0aGUgY2hhbmdlIG9jY3VycmVkXG4gICAgICogICAgKiByZW1vdmVkOiBhcnJheSBvZiBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgaW5kZXhcbiAgICAgKiAgICAqIGFkZGVkQ291bnQ6IG51bWJlciBvZiBuZXcgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICAgICAqICAgICogb2JqZWN0OiBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkgaW4gcXVlc3Rpb25cbiAgICAgKiAgICAqIHR5cGU6IHRoZSBzdHJpbmcgbGl0ZXJhbCAnc3BsaWNlJ1xuICAgICAqXG4gICAgICogICBOb3RlIHRoYXQgc3BsaWNlIHJlY29yZHMgX211c3RfIGJlIG5vcm1hbGl6ZWQgc3VjaCB0aGF0IHRoZXkgYXJlXG4gICAgICogICByZXBvcnRlZCBpbiBpbmRleCBvcmRlciAocmF3IHJlc3VsdHMgZnJvbSBgT2JqZWN0Lm9ic2VydmVgIGFyZSBub3RcbiAgICAgKiAgIG9yZGVyZWQgYW5kIG11c3QgYmUgbm9ybWFsaXplZC9tZXJnZWQgYmVmb3JlIG5vdGlmeWluZykuXG4gICAgICogQHB1YmxpY1xuICAgICovXG4gICAgbm90aWZ5U3BsaWNlcyhwYXRoLCBzcGxpY2VzKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBub3RpZnlTcGxpY2VzKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHNwbGljZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgcmVhZGluZyBhIHZhbHVlIGZyb20gYSBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW4gZGVyZWZlcmVuY2luZyB1bmRlZmluZWRcbiAgICAgKiBwYXRocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byByZWFkLiAgVGhlIHBhdGggbWF5IGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZS5nLiBgZm9vLmJhci5iYXpgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgdXNlcnMuMTIubmFtZWAgb3IgYFsndXNlcnMnLCAxMiwgJ25hbWUnXWApLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCB0aGUgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgKiAgIGlzIHVuZGVmaW5lZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0KHBhdGgsIHJvb3QpIHtcbiAgICAgIHJldHVybiBnZXQkMChyb290IHx8IHRoaXMsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3Igc2V0dGluZyBhIHZhbHVlIHRvIGEgcGF0aCBhbmQgbm90aWZ5aW5nIGFueVxuICAgICAqIGVsZW1lbnRzIGJvdW5kIHRvIHRoZSBzYW1lIHBhdGguXG4gICAgICpcbiAgICAgKiBOb3RlLCBpZiBhbnkgcGFydCBpbiB0aGUgcGF0aCBleGNlcHQgZm9yIHRoZSBsYXN0IGlzIHVuZGVmaW5lZCxcbiAgICAgKiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW5cbiAgICAgKiBkZXJlZmVyZW5jaW5nIHVuZGVmaW5lZCBwYXRocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byB3cml0ZS4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYCdmb28uYmFyLmJheidgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgJ3VzZXJzLjEyLm5hbWUnYCBvciBgWyd1c2VycycsIDEyLCAnbmFtZSddYCkuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiAgIFdoZW4gc3BlY2lmaWVkLCBubyBub3RpZmljYXRpb24gd2lsbCBvY2N1ci5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBzZXQocGF0aCwgdmFsdWUsIHJvb3QpIHtcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIHNldCQwKHJvb3QsIHBhdGgsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bLyoqIEB0eXBlIHtzdHJpbmd9ICovKHBhdGgpXSkge1xuICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgaXRlbXMgb250byB0aGUgZW5kIG9mIHRoZSBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnB1c2hgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBwdXNoIG9udG8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdXNoKHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucHVzaCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBsZW4sIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZW5kIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcG9wKHBhdGgpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBoYWRMZW5ndGggPSBCb29sZWFuKGFycmF5Lmxlbmd0aCk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucG9wKCk7XG4gICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBhcnJheS5sZW5ndGgsIDAsIFtyZXRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRpbmcgZnJvbSB0aGUgc3RhcnQgaW5kZXggc3BlY2lmaWVkLCByZW1vdmVzIDAgb3IgbW9yZSBpdGVtc1xuICAgICAqIGZyb20gdGhlIGFycmF5IGFuZCBpbnNlcnRzIDAgb3IgbW9yZSBuZXcgaXRlbXMgaW4gdGhlaXIgcGxhY2UuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgSW5kZXggZnJvbSB3aGljaCB0byBzdGFydCByZW1vdmluZy9pbnNlcnRpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGV0ZUNvdW50IE51bWJlciBvZiBpdGVtcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW50byBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgcmVtb3ZlZCBpdGVtcy5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3BsaWNlKHBhdGgsIHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGggOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAvLyBOb3JtYWxpemUgZmFuY3kgbmF0aXZlIHNwbGljZSBoYW5kbGluZyBvZiBjcmF6eSBzdGFydCB2YWx1ZXNcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBhcnJheS5sZW5ndGggLSBNYXRoLmZsb29yKC1zdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBsZXQgcmV0ID0gYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCB8fCByZXQubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBzdGFydCwgaXRlbXMubGVuZ3RoLCByZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2hpZnQocGF0aCkge1xuICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oZ2V0JDAodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgIGxldCByZXQgPSBhcnJheS5zaGlmdCgpO1xuICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgMCwgMCwgW3JldF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGluZm8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB1bnNoaWZ0KHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCBpdGVtcy5sZW5ndGgsIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoYXQgYSBwYXRoIGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICB0aGlzLml0ZW0udXNlci5uYW1lID0gJ0JvYic7XG4gICAgICogICAgIHRoaXMubm90aWZ5UGF0aCgnaXRlbS51c2VyLm5hbWUnKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgVmFsdWUgYXQgdGhlIHBhdGggKG9wdGlvbmFsKS5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBub3RpZnlQYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIGxldCBwcm9wUGF0aDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gR2V0IHZhbHVlIGlmIG5vdCBzdXBwbGllZFxuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIHZhbHVlID0gZ2V0JDAodGhpcywgcGF0aCwgaW5mbyk7XG4gICAgICAgIHByb3BQYXRoID0gaW5mby5wYXRoO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBwYXRoIGlmIG5lZWRlZFxuICAgICAgICBwcm9wUGF0aCA9IG5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BQYXRoID0gLyoqIEB0eXBle3N0cmluZ30gKi8ocGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHByb3BQYXRoLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwcm90ZWN0ZWRTZXR0ZXIgQ3JlYXRlcyBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyXG4gICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgICBpZiAocHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICAgIHRoaXNbJ19zZXQnICsgdXBwZXIocHJvcGVydHkpXSA9IC8qKiBAdGhpcyB7UHJvcGVydHlFZmZlY3RzfSAqL2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUHJvcGVydHlPYnNlcnZlcmAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZHluYW1pY0ZuIFdoZXRoZXIgdGhlIG1ldGhvZCBuYW1lIHNob3VsZCBiZSBpbmNsdWRlZCBhc1xuICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pIHtcbiAgICAgIGxldCBpbmZvID0geyBwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuOiBCb29sZWFuKGR5bmFtaWNGbikgfTtcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5PQlNFUlZFLCB7XG4gICAgICAgIGZuOiBydW5PYnNlcnZlckVmZmVjdCwgaW5mbywgdHJpZ2dlcjoge25hbWU6IHByb3BlcnR5fVxuICAgICAgfSk7XG4gICAgICBpZiAoZHluYW1pY0ZuKSB7XG4gICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KG1ldGhvZE5hbWUsIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBtZXRob2ROYW1lfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlTWV0aG9kT2JzZXJ2ZXJgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgb2JzZXJ2ZXIgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuT0JTRVJWRSwgcnVuTWV0aG9kRWZmZWN0LCBudWxsLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZLCB7XG4gICAgICAgIGZuOiBydW5Ob3RpZnlFZmZlY3QsXG4gICAgICAgIGluZm86IHtcbiAgICAgICAgICBldmVudE5hbWU6IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSArICctY2hhbmdlZCcsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICBsZXQgYXR0ciA9IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KTtcbiAgICAgIGlmIChhdHRyWzBdID09PSAnLScpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSAnICsgcHJvcGVydHkgKyAnIGNhbm5vdCBiZSByZWZsZWN0ZWQgdG8gYXR0cmlidXRlICcgK1xuICAgICAgICAgIGF0dHIgKyAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgc3RhcnRpbmcgYXR0cmlidXRlIG5hbWUuIFVzZSBhIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eSB0aGlzZWFkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFRkxFQ1QsIHtcbiAgICAgICAgICBmbjogcnVuUmVmbGVjdEVmZmVjdCxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBhdHRyTmFtZTogYXR0clxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZUNvbXB1dGVkUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgY29tcHV0ZWQgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuQ09NUFVURSwgcnVuQ29tcHV0ZWRFZmZlY3QsIHByb3BlcnR5LCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8vIC0tIHN0YXRpYyBjbGFzcyBtZXRob2RzIC0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhbiBhY2Nlc3NvciBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHksIGFuZCBhZGRzXG4gICAgICogdG8gYSBsaXN0IG9mIFwicHJvcGVydHkgZWZmZWN0c1wiIHRoYXQgd2lsbCBydW4gd2hlbiB0aGUgYWNjZXNzb3IgZm9yXG4gICAgICogdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpcyBzZXQuICBFZmZlY3RzIGFyZSBncm91cGVkIGJ5IFwidHlwZVwiLCB3aGljaFxuICAgICAqIHJvdWdobHkgY29ycmVzcG9uZHMgdG8gYSBwaGFzZSBpbiBlZmZlY3QgcHJvY2Vzc2luZy4gIFRoZSBlZmZlY3RcbiAgICAgKiBtZXRhZGF0YSBzaG91bGQgYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtOlxuICAgICAqXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBmbjogZWZmZWN0RnVuY3Rpb24sIC8vIFJlZmVyZW5jZSB0byBmdW5jdGlvbiB0byBjYWxsIHRvIHBlcmZvcm0gZWZmZWN0XG4gICAgICogICAgICAgaW5mbzogeyAuLi4gfSAgICAgICAvLyBFZmZlY3QgbWV0YWRhdGEgcGFzc2VkIHRvIGZ1bmN0aW9uXG4gICAgICogICAgICAgdHJpZ2dlcjogeyAgICAgICAgICAvLyBPcHRpb25hbCB0cmlnZ2VyaW5nIG1ldGFkYXRhOyBpZiBub3QgcHJvdmlkZWRcbiAgICAgKiAgICAgICAgIG5hbWU6IHN0cmluZyAgICAgIC8vIHRoZSBwcm9wZXJ0eSBpcyB0cmVhdGVkIGFzIGEgd2lsZGNhcmRcbiAgICAgKiAgICAgICAgIHN0cnVjdHVyZWQ6IGJvb2xlYW5cbiAgICAgKiAgICAgICAgIHdpbGRjYXJkOiBib29sZWFuXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBFZmZlY3RzIGFyZSBjYWxsZWQgZnJvbSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIGJ5XG4gICAgICogdHlwZTpcbiAgICAgKlxuICAgICAqIDEuIENPTVBVVEVcbiAgICAgKiAyLiBQUk9QQUdBVEVcbiAgICAgKiAzLiBSRUZMRUNUXG4gICAgICogNC4gT0JTRVJWRVxuICAgICAqIDUuIE5PVElGWVxuICAgICAqXG4gICAgICogRWZmZWN0IGZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gICAgICpcbiAgICAgKiAgICAgZWZmZWN0RnVuY3Rpb24oaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGFkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlLXByb3BlcnR5IG9ic2VydmVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICogICBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG11bHRpLXByb3BlcnR5IFwibWV0aG9kIG9ic2VydmVyXCIgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gICAgICogZXhwcmVzc2lvbiwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nIGluIHRoZSBmb3JtIG9mIGEgbm9ybWFsIEphdmFzY3JpcHRcbiAgICAgKiBmdW5jdGlvbiBzaWduYXR1cmU6IGAnbWV0aG9kTmFtZShhcmcxLCBbLi4uLCBhcmduXSknYC4gIEVhY2ggYXJndW1lbnRcbiAgICAgKiBzaG91bGQgY29ycmVzcG9uZCB0byBhIHByb3BlcnR5IG9yIHBhdGggaW4gdGhlIGNvbnRleHQgb2YgdGhpc1xuICAgICAqIHByb3RvdHlwZSAob3IgaW5zdGFuY2UpLCBvciBtYXkgYmUgYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byBkaXNwYXRjaCBgPHByb3BlcnR5Pi1jaGFuZ2VkYFxuICAgICAqIGV2ZW50cyB0byBub3RpZnkgb2YgY2hhbmdlcyB0byB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlYWQtb25seSBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVG8gc2V0IHRoZSBwcm9wZXJ0eSwgdXNlIHRoZSBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgQVBJLlxuICAgICAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyIChlLmcuIGBfc2V0TXlQcm9wKClgIGZvclxuICAgICAqIHByb3BlcnR5IGBteVByb3BgKSwgcGFzcyBgdHJ1ZWAgZm9yIGBwcm90ZWN0ZWRTZXR0ZXJgLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgdGhlIHByb3BlcnR5IHdpbGwgaGF2ZSBvdGhlciBwcm9wZXJ0eSBlZmZlY3RzLCB0aGlzIG1ldGhvZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QsIGJlZm9yZSBhZGRpbmcgb3RoZXIgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgc2V0dGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdG8gcmVmbGVjdCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgKiB0byBhIChkYXNoLWNhc2VkKSBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgc2V0IHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICogbWV0aG9kIGRlc2NyaWJlZCBieSB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGVhY2ggdGltZSBvbmUgb3IgbW9yZVxuICAgICAqIGFyZ3VtZW50cyB0byB0aGUgbWV0aG9kIGNoYW5nZXMuICBUaGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgYSBzdHJpbmdcbiAgICAgKiBpbiB0aGUgZm9ybSBvZiBhIG5vcm1hbCBKYXZhc2NyaXB0IGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgKiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAgICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIHRvIGVuc3VyZSBiaW5kaW5nIGVmZmVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgKiBmb3IgdGhlbSwgYW5kIHRoZW4gZW5zdXJlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIGNyZWF0ZWQgZm9yIGFueVxuICAgICAqIGRlcGVuZGVudCBwcm9wZXJ0aWVzIGluIHRoZSB0ZW1wbGF0ZS4gIEJpbmRpbmcgZWZmZWN0cyBmb3IgYm91bmRcbiAgICAgKiB0ZW1wbGF0ZXMgYXJlIHN0b3JlZCBpbiBhIGxpbmtlZCBsaXN0IG9uIHRoZSBpbnN0YW5jZSBzbyB0aGF0XG4gICAgICogdGVtcGxhdGVzIGNhbiBiZSBlZmZpY2llbnRseSBzdGFtcGVkIGFuZCB1bnN0YW1wZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAqICAgYmluZGluZ3NcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gLS0gYmluZGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYmluZFRlbXBsYXRlYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIHRoZSBwcm90b3R5cGUgKGZvciBwcm90b3R5cGljYWwgdGVtcGxhdGVcbiAgICAgKiBiaW5kaW5nLCB0byBhdm9pZCBjcmVhdGluZyBhY2Nlc3NvcnMgZXZlcnkgaW5zdGFuY2UpIG9uY2UgcGVyIHByb3RvdHlwZSxcbiAgICAgKiBhbmQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgcnVudGltZUJpbmRpbmc6IHRydWVgIGJ5IGBfc3RhbXBUZW1wbGF0ZWAgdG9cbiAgICAgKiBjcmVhdGUgYW5kIGxpbmsgYW4gaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgICogcGFydGljdWxhciBzdGFtcGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgY29udGFpbmluZyBiaW5kaW5nXG4gICAgICogICBiaW5kaW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluc3RhbmNlQmluZGluZyBXaGVuIGZhbHNlIChkZWZhdWx0KSwgcGVyZm9ybXNcbiAgICAgKiAgIFwicHJvdG90eXBpY2FsXCIgYmluZGluZyBvZiB0aGUgdGVtcGxhdGUgYW5kIG92ZXJ3cml0ZXMgYW55IHByZXZpb3VzbHlcbiAgICAgKiAgIGJvdW5kIHRlbXBsYXRlIGZvciB0aGUgY2xhc3MuIFdoZW4gdHJ1ZSAoYXMgcGFzc2VkIGZyb21cbiAgICAgKiAgIGBfc3RhbXBUZW1wbGF0ZWApLCB0aGUgdGVtcGxhdGUgaW5mbyBpcyBpbnN0YW5jZWQgYW5kIGxpbmtlZCBpbnRvXG4gICAgICogICB0aGUgbGlzdCBvZiBib3VuZCB0ZW1wbGF0ZXMuXG4gICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gVGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0OyBmb3IgYHJ1bnRpbWVCaW5kaW5nYCxcbiAgICAgKiAgIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSBpbmZvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIGluc3RhbmNlQmluZGluZykge1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IHdhc1ByZUJvdW5kID0gdGhpcy5fX3RlbXBsYXRlSW5mbyA9PSB0ZW1wbGF0ZUluZm87XG4gICAgICAvLyBPcHRpbWl6YXRpb246IHNpbmNlIHRoaXMgaXMgY2FsbGVkIHR3aWNlIGZvciBwcm90by1ib3VuZCB0ZW1wbGF0ZXMsXG4gICAgICAvLyBkb24ndCBhdHRlbXB0IHRvIHJlY3JlYXRlIGFjY2Vzc29ycyBpZiB0aGlzIHRlbXBsYXRlIHdhcyBwcmUtYm91bmRcbiAgICAgIGlmICghd2FzUHJlQm91bmQpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlQmluZGluZykge1xuICAgICAgICAvLyBGb3IgaW5zdGFuY2UtdGltZSBiaW5kaW5nLCBjcmVhdGUgaW5zdGFuY2Ugb2YgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAgLy8gYW5kIGxpbmsgaW50byBsaXN0IG9mIHRlbXBsYXRlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyhPYmplY3QuY3JlYXRlKHRlbXBsYXRlSW5mbykpO1xuICAgICAgICB0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQgPSB3YXNQcmVCb3VuZDtcbiAgICAgICAgaWYgKCF3YXNQcmVCb3VuZCAmJiB0aGlzLl9fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCB8fCB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID0gbGFzdC5uZXh0VGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IGxhc3Q7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX190ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHByb3BlcnR5IGVmZmVjdCB0byB0aGUgZ2l2ZW4gdGVtcGxhdGUgbWV0YWRhdGEsIHdoaWNoIGlzIHJ1blxuICAgICAqIGF0IHRoZSBcInByb3BhZ2F0ZVwiIHN0YWdlIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHdoZW4gdGhlIHRlbXBsYXRlXG4gICAgICogaGFzIGJlZW4gYm91bmQgdG8gdGhlIGVsZW1lbnQgdmlhIGBfYmluZFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgZWZmZWN0YCBvYmplY3Qgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgaW4gYF9hZGRQcm9wZXJ0eUVmZmVjdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIHRvIGFkZCBlZmZlY3QgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBfYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHByb3AsIGVmZmVjdCkge1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICAgICAgaG9zdFByb3BzW3Byb3BdID0gdHJ1ZTtcbiAgICAgIGxldCBlZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyA9IHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMgfHwge307XG4gICAgICBsZXQgcHJvcEVmZmVjdHMgPSBlZmZlY3RzW3Byb3BdID0gZWZmZWN0c1twcm9wXSB8fCBbXTtcbiAgICAgIHByb3BFZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFtcHMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGFuZCBwZXJmb3JtcyBpbnN0YW5jZS10aW1lIHNldHVwIGZvclxuICAgICAqIFBvbHltZXIgdGVtcGxhdGUgZmVhdHVyZXMsIGluY2x1ZGluZyBkYXRhIGJpbmRpbmdzLCBkZWNsYXJhdGl2ZSBldmVudFxuICAgICAqIGxpc3RlbmVycywgYW5kIHRoZSBgdGhpcy4kYCBtYXAgb2YgYGlkYCdzIHRvIG5vZGVzLiAgQSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqIGlzIHJldHVybmVkIGNvbnRhaW5pbmcgdGhlIHN0YW1wZWQgRE9NLCByZWFkeSBmb3IgaW5zZXJ0aW9uIGludG8gdGhlXG4gICAgICogRE9NLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZTsgaG93ZXZlciBub3RlIHRoYXQgZHVlIHRvXG4gICAgICogYHNoYWR5Y3NzYCBwb2x5ZmlsbCBsaW1pdGF0aW9ucywgb25seSBzdHlsZXMgZnJvbSB0ZW1wbGF0ZXMgcHJlcGFyZWRcbiAgICAgKiB1c2luZyBgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlYCB3aWxsIGJlIGNvcnJlY3RseSBwb2x5ZmlsbGVkIChzY29wZWRcbiAgICAgKiB0byB0aGUgc2hhZG93IHJvb3QgYW5kIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzKSwgYW5kIG5vdGUgdGhhdFxuICAgICAqIGBTaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVgIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBlbGVtZW50LiBBcyBzdWNoLFxuICAgICAqIGFueSBzdHlsZXMgcmVxdWlyZWQgYnkgaW4gcnVudGltZS1zdGFtcGVkIHRlbXBsYXRlcyBtdXN0IGJlIGluY2x1ZGVkXG4gICAgICogaW4gdGhlIG1haW4gZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIC8vIEVuc3VyZXMgdGhhdCBjcmVhdGVkIGRvbSBpcyBgX2VucXVldWVDbGllbnRgJ2QgdG8gdGhpcyBlbGVtZW50IHNvXG4gICAgICAvLyB0aGF0IGl0IGNhbiBiZSBmbHVzaGVkIG9uIG5leHQgY2FsbCB0byBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgIGhvc3RTdGFjay5iZWdpbkhvc3RpbmcodGhpcyk7XG4gICAgICBsZXQgZG9tID0gc3VwZXIuX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgaG9zdFN0YWNrLmVuZEhvc3RpbmcodGhpcyk7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyh0aGlzLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIHRydWUpKTtcbiAgICAgIC8vIEFkZCB0ZW1wbGF0ZS1pbnN0YW5jZS1zcGVjaWZpYyBkYXRhIHRvIGluc3RhbmNlZCB0ZW1wbGF0ZUluZm9cbiAgICAgIHRlbXBsYXRlSW5mby5ub2RlTGlzdCA9IGRvbS5ub2RlTGlzdDtcbiAgICAgIC8vIENhcHR1cmUgY2hpbGQgbm9kZXMgdG8gYWxsb3cgdW5zdGFtcGluZyBvZiBub24tcHJvdG90eXBpY2FsIHRlbXBsYXRlc1xuICAgICAgaWYgKCF0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbj1kb20uZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9tLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIDItd2F5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0IGZvciBiaW5kaW5nc1xuICAgICAgc2V0dXBCaW5kaW5ncyh0aGlzLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgLy8gRmx1c2ggcHJvcGVydGllcyBpbnRvIHRlbXBsYXRlIG5vZGVzIGlmIGFscmVhZHkgYm9vdGVkXG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMsIHRoaXMuX19kYXRhLCBudWxsLFxuICAgICAgICAgIGZhbHNlLCB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuZCB1bmJpbmRzIHRoZSBub2RlcyBwcmV2aW91c2x5IGNvbnRhaW5lZCBpbiB0aGUgcHJvdmlkZWRcbiAgICAgKiBEb2N1bWVudEZyYWdtZW50IHJldHVybmVkIGZyb20gYF9zdGFtcFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVN0YW1wZWRUZW1wbGF0ZX0gZG9tIERvY3VtZW50RnJhZ21lbnQgcHJldmlvdXNseSByZXR1cm5lZFxuICAgICAqICAgZnJvbSBgX3N0YW1wVGVtcGxhdGVgIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZXMgdG8gYmUgcmVtb3ZlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlQm91bmREb20oZG9tKSB7XG4gICAgICAvLyBVbmxpbmsgdGVtcGxhdGUgaW5mb1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IGRvbS50ZW1wbGF0ZUluZm87XG4gICAgICBpZiAodGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID1cbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbykge1xuICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID09IHRlbXBsYXRlSW5mbykge1xuICAgICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCA9IHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBzdGFtcGVkIG5vZGVzXG4gICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGk9MDsgaTxub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnNpbmcgYmluZGluZ3MgZnJvbSBgVGV4dE5vZGVgJ3MnIGB0ZXh0Q29udGVudGAuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgbGV0IG5vdGVkID0gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3Mobm9kZS50ZXh0Q29udGVudCwgdGVtcGxhdGVJbmZvKTtcbiAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdGV4dENvbnRlbnQgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICAgIC8vIE5PVEU6IGRlZmF1bHQgdG8gYSBzcGFjZSBoZXJlIHNvIHRoZSB0ZXh0Tm9kZSByZW1haW5zOyBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgLy8gKElFKSBldmFjaXBhdGUgYW4gZW1wdHkgdGV4dE5vZGUgZm9sbG93aW5nIGNsb25lTm9kZS9pbXBvcnROb2RlLlxuICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB8fCAnICc7XG4gICAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAndGV4dCcsICd0ZXh0Q29udGVudCcsIHBhcnRzKTtcbiAgICAgICAgICBub3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogcGFyc2luZyBiaW5kaW5ncyBmcm9tIGF0dHJpYnV0ZXMuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3ModmFsdWUsIHRlbXBsYXRlSW5mbyk7XG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgLy8gQXR0cmlidXRlIG9yIHByb3BlcnR5XG4gICAgICAgIGxldCBvcmlnTmFtZSA9IG5hbWU7XG4gICAgICAgIGxldCBraW5kID0gJ3Byb3BlcnR5JztcbiAgICAgICAgaWYgKG5hbWVbbmFtZS5sZW5ndGgtMV0gPT0gJyQnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIGtpbmQgPSAnYXR0cmlidXRlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIGF0dHJpYnV0ZSBiaW5kaW5ncyB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgIGxldCBsaXRlcmFsID0gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cyk7XG4gICAgICAgIGlmIChsaXRlcmFsICYmIGtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBsaXRlcmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBhdHRyaWJ1dGUgYmVmb3JlIHJlbW92aW5nLCBzaW5jZSBJRSB3b24ndCBhbGxvdyByZW1vdmluZ1xuICAgICAgICAvLyBgdmFsdWVgIGF0dHJpYnV0ZSBpZiBpdCBwcmV2aW91c2x5IGhhZCBhIHZhbHVlIChjYW4ndFxuICAgICAgICAvLyB1bmNvbmRpdGlvbmFsbHkgc2V0ICcnIGJlZm9yZSByZW1vdmluZyBzaW5jZSBhdHRyaWJ1dGVzIHdpdGggYCRgXG4gICAgICAgIC8vIGNhbid0IGJlIHNldCB1c2luZyBzZXRBdHRyaWJ1dGUpXG4gICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiBvcmlnTmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG9yaWdOYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFubm90YXRpb25cbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUob3JpZ05hbWUpO1xuICAgICAgICAvLyBDYXNlIGhhY2tlcnk6IGF0dHJpYnV0ZXMgYXJlIGxvd2VyLWNhc2UsIGJ1dCBiaW5kIHRhcmdldHNcbiAgICAgICAgLy8gKHByb3BlcnRpZXMpIGFyZSBjYXNlIHNlbnNpdGl2ZS4gR2FtYml0IGlzIHRvIG1hcCBkYXNoLWNhc2UgdG9cbiAgICAgICAgLy8gY2FtZWwtY2FzZTogYGZvby1iYXJgIGJlY29tZXMgYGZvb0JhcmAuXG4gICAgICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5ncyBhcmUgZXhjZXB0ZWQuXG4gICAgICAgIGlmIChraW5kID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgbmFtZSA9IGRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIG5hbWUsIHBhcnRzLCBsaXRlcmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogYmluZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IGEgbmVzdGVkIHRlbXBsYXRlIGRlcGVuZHMgb24gdG8gdGhlIHRlbXBsYXRlXG4gICAgICogYXMgYF9ob3N0Xzxwcm9wZXJ0eT5gLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgbm90ZWQgPSBzdXBlci5fcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgLy8gTWVyZ2UgaG9zdCBwcm9wcyBpbnRvIG91dGVyIHRlbXBsYXRlIGFuZCBhZGQgYmluZGluZ3NcbiAgICAgIGxldCBob3N0UHJvcHMgPSBub2RlSW5mby50ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgbGV0IG1vZGUgPSAneyc7XG4gICAgICBmb3IgKGxldCBzb3VyY2UgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFt7IG1vZGUsIHNvdXJjZSwgZGVwZW5kZW5jaWVzOiBbc291cmNlXSB9XTtcbiAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAncHJvcGVydHknLCAnX2hvc3RfJyArIHNvdXJjZSwgcGFydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwYXJzZSB0ZXh0IGluIGEgdGVtcGxhdGUgKGVpdGhlciBhdHRyaWJ1dGUgdmFsdWVzIG9yXG4gICAgICogdGV4dENvbnRlbnQpIGludG8gYmluZGluZyBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEFueSBvdmVycmlkZXMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBiaW5kaW5nIHBhcnRcbiAgICAgKiBtZXRhZGF0YSAgcmVwcmVzZW50aW5nIG9uZSBvciBtb3JlIGJpbmRpbmdzIGZvdW5kIGluIHRoZSBwcm92aWRlZCB0ZXh0XG4gICAgICogYW5kIGFueSBcImxpdGVyYWxcIiB0ZXh0IGluIGJldHdlZW4uICBBbnkgbm9uLWxpdGVyYWwgcGFydHMgd2lsbCBiZSBwYXNzZWRcbiAgICAgKiB0byBgX2V2YWx1YXRlQmluZGluZ2Agd2hlbiBhbnkgZGVwZW5kZW5jaWVzIGNoYW5nZS4gIFRoZSBvbmx5IHJlcXVpcmVkXG4gICAgICogZmllbGRzIG9mIGVhY2ggXCJwYXJ0XCIgaW4gdGhlIHJldHVybmVkIGFycmF5IGFyZSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogLSBgZGVwZW5kZW5jaWVzYCAtIEFycmF5IGNvbnRhaW5pbmcgdHJpZ2dlciBtZXRhZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgYmluZGluZyB0byB1cGRhdGVcbiAgICAgKiAtIGBsaXRlcmFsYCAtIFN0cmluZyBjb250YWluaW5nIHRleHQgaWYgdGhlIHBhcnQgcmVwcmVzZW50cyBhIGxpdGVyYWw7XG4gICAgICogICBpbiB0aGlzIGNhc2Ugbm8gYGRlcGVuZGVuY2llc2AgYXJlIG5lZWRlZFxuICAgICAqXG4gICAgICogQWRkaXRpb25hbCBtZXRhZGF0YSBmb3IgdXNlIGJ5IGBfZXZhbHVhdGVCaW5kaW5nYCBtYXkgYmUgcHJvdmlkZWQgaW5cbiAgICAgKiBlYWNoIHBhcnQgb2JqZWN0IGFzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhhbmRsZXMgdGhlIGZvbGxvd2luZyB0eXBlcyBvZiBiaW5kaW5nc1xuICAgICAqIChvbmUgb3IgbW9yZSBtYXkgYmUgaW50ZXJtaXhlZCB3aXRoIGxpdGVyYWwgc3RyaW5ncyk6XG4gICAgICogLSBQcm9wZXJ0eSBiaW5kaW5nOiBgW1twcm9wXV1gXG4gICAgICogLSBQYXRoIGJpbmRpbmc6IGBbW29iamVjdC5wcm9wXV1gXG4gICAgICogLSBOZWdhdGVkIHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3M6IGBbWyFwcm9wXV1gIG9yIGBbWyFvYmplY3QucHJvcF1dYFxuICAgICAqIC0gVHdvLXdheSBwcm9wZXJ0eSBvciBwYXRoIGJpbmRpbmdzIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBge3twcm9wfX1gLCBge3tvYmplY3QucHJvcH19YCwgYHt7IXByb3B9fWAgb3IgYHt7IW9iamVjdC5wcm9wfX1gXG4gICAgICogLSBJbmxpbmUgY29tcHV0ZWQgbWV0aG9kIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBgW1tjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWAsIGBbWyFjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGFyc2UgZnJvbSBhdHRyaWJ1dGUgb3IgdGV4dENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIEN1cnJlbnQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHtBcnJheTwhQmluZGluZ1BhcnQ+fSBBcnJheSBvZiBiaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZUJpbmRpbmdzKHRleHQsIHRlbXBsYXRlSW5mbykge1xuICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtO1xuICAgICAgLy8gRXhhbXBsZTogXCJsaXRlcmFsMXt7cHJvcH19bGl0ZXJhbDJbWyFjb21wdXRlKGZvbyxiYXIpXV1maW5hbFwiXG4gICAgICAvLyBSZWdleCBtYXRjaGVzOlxuICAgICAgLy8gICAgICAgIEl0ZXJhdGlvbiAxOiAgSXRlcmF0aW9uIDI6XG4gICAgICAvLyBtWzFdOiAne3snICAgICAgICAgICdbWydcbiAgICAgIC8vIG1bMl06ICcnICAgICAgICAgICAgJyEnXG4gICAgICAvLyBtWzNdOiAncHJvcCcgICAgICAgICdjb21wdXRlKGZvbyxiYXIpJ1xuICAgICAgd2hpbGUgKChtID0gYmluZGluZ1JlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFkZCBsaXRlcmFsIHBhcnRcbiAgICAgICAgaWYgKG0uaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtsaXRlcmFsOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgbS5pbmRleCl9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYmluZGluZyBwYXJ0XG4gICAgICAgIGxldCBtb2RlID0gbVsxXVswXTtcbiAgICAgICAgbGV0IG5lZ2F0ZSA9IEJvb2xlYW4obVsyXSk7XG4gICAgICAgIGxldCBzb3VyY2UgPSBtWzNdLnRyaW0oKTtcbiAgICAgICAgbGV0IGN1c3RvbUV2ZW50ID0gZmFsc2UsIG5vdGlmeUV2ZW50ID0gJycsIGNvbG9uID0gLTE7XG4gICAgICAgIGlmIChtb2RlID09ICd7JyAmJiAoY29sb24gPSBzb3VyY2UuaW5kZXhPZignOjonKSkgPiAwKSB7XG4gICAgICAgICAgbm90aWZ5RXZlbnQgPSBzb3VyY2Uuc3Vic3RyaW5nKGNvbG9uICsgMik7XG4gICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBjb2xvbik7XG4gICAgICAgICAgY3VzdG9tRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWduYXR1cmUgPSBwYXJzZU1ldGhvZChzb3VyY2UpO1xuICAgICAgICBsZXQgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAvLyBJbmxpbmUgY29tcHV0ZWQgZnVuY3Rpb25cbiAgICAgICAgICBsZXQge2FyZ3MsIG1ldGhvZE5hbWV9ID0gc2lnbmF0dXJlO1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucztcbiAgICAgICAgICBpZiAoZHluYW1pY0ZucyAmJiBkeW5hbWljRm5zW21ldGhvZE5hbWVdIHx8IHNpZ25hdHVyZS5zdGF0aWMpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgc2lnbmF0dXJlLmR5bmFtaWNGbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFByb3BlcnR5IG9yIHBhdGhcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZSwgbW9kZSwgbmVnYXRlLCBjdXN0b21FdmVudCwgc2lnbmF0dXJlLCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgZXZlbnQ6IG5vdGlmeUV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0SW5kZXggPSBiaW5kaW5nUmVnZXgubGFzdEluZGV4O1xuICAgICAgfVxuICAgICAgLy8gQWRkIGEgZmluYWwgbGl0ZXJhbCBwYXJ0XG4gICAgICBpZiAobGFzdEluZGV4ICYmIGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaXRlcmFsID0gdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4KTtcbiAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGxpdGVyYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gZXZhbHVhdGUgYSBwcmV2aW91c2x5IHBhcnNlZCBiaW5kaW5nIHBhcnQgYmFzZWQgb24gYSBzZXQgb2ZcbiAgICAgKiBvbmUgb3IgbW9yZSBjaGFuZ2VkIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dGhpc30gaW5zdCBFbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgc2NvcGUgZm9yXG4gICAgICogICBiaW5kaW5nIGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7QmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCB0aGF0IHRyaWdnZXJlZCB0aGlzIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSB0aGUgYmluZGluZyBwYXJ0IGV2YWx1YXRlZCB0b1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgX2V2YWx1YXRlQmluZGluZyhpbnN0LCBwYXJ0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBpZiAocGFydC5zaWduYXR1cmUpIHtcbiAgICAgICAgdmFsdWUgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBwYXJ0LnNpZ25hdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdGggIT0gcGFydC5zb3VyY2UpIHtcbiAgICAgICAgdmFsdWUgPSBnZXQkMChpbnN0LCBwYXJ0LnNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzUGF0aHMgJiYgaXNQYXRoJDAocGF0aCkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldCQwKGluc3QsIHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gaW5zdC5fX2RhdGFbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0Lm5lZ2F0ZSkge1xuICAgICAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIG1ha2UgYSB0eXBpbmcgZm9yIGNsb3N1cmUgOlBcbiAgUHJvcGVydHlFZmZlY3RzVHlwZSA9IFByb3BlcnR5RWZmZWN0cztcblxuICByZXR1cm4gUHJvcGVydHlFZmZlY3RzO1xufSk7XG5cbi8qKlxuICogSGVscGVyIGFwaSBmb3IgZW5xdWVpbmcgY2xpZW50IGRvbSBjcmVhdGVkIGJ5IGEgaG9zdCBlbGVtZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQgZWxlbWVudHMgYXJlIGZsdXNoZWQgdmlhIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aGVuXG4gKiBgY29ubmVjdGVkQ2FsbGJhY2tgIGlzIGNhbGxlZC4gRWxlbWVudHMgYXR0YWNoIHRoZWlyIGNsaWVudCBkb20gdG9cbiAqIHRoZW1zZWx2ZXMgYXQgYHJlYWR5YCB0aW1lIHdoaWNoIHJlc3VsdHMgZnJvbSB0aGlzIGZpcnN0IGZsdXNoLlxuICogVGhpcyBwcm92aWRlcyBhbiBvcmRlcmluZyBndWFyYW50ZWUgdGhhdCB0aGUgY2xpZW50IGRvbSBhbiBlbGVtZW50XG4gKiBjcmVhdGVzIGlzIGZsdXNoZWQgYmVmb3JlIHRoZSBlbGVtZW50IGl0c2VsZiAoaS5lLiBjbGllbnQgYHJlYWR5YFxuICogZmlyZXMgYmVmb3JlIGhvc3QgYHJlYWR5YCkuXG4gKlxuICogSG93ZXZlciwgaWYgYF9mbHVzaFByb3BlcnRpZXNgIGlzIGNhbGxlZCAqYmVmb3JlKiBhbiBlbGVtZW50IGlzIGNvbm5lY3RlZCxcbiAqIGFzIGZvciBleGFtcGxlIGBUZW1wbGF0aXplYCBkb2VzLCB0aGlzIG9yZGVyaW5nIGd1YXJhbnRlZSBjYW5ub3QgYmVcbiAqIHNhdGlzZmllZCBiZWNhdXNlIG5vIGVsZW1lbnRzIGFyZSBjb25uZWN0ZWQuIChOb3RlOiBCb3VuZCBlbGVtZW50cyB0aGF0XG4gKiByZWNlaXZlIGRhdGEgZG8gYmVjb21lIGVucXVldWVkIGNsaWVudHMgYW5kIGFyZSBwcm9wZXJseSBvcmRlcmVkIGJ1dFxuICogdW5ib3VuZCBlbGVtZW50cyBhcmUgbm90LilcbiAqXG4gKiBUbyBtYWludGFpbiB0aGUgZGVzaXJlZCBcImNsaWVudCBiZWZvcmUgaG9zdFwiIG9yZGVyaW5nIGd1YXJhbnRlZSBmb3IgdGhpc1xuICogY2FzZSB3ZSByZWx5IG9uIHRoZSBcImhvc3Qgc3RhY2suIENsaWVudCBub2RlcyByZWdpc3RlcnMgdGhlbXNlbHZlcyB3aXRoXG4gKiB0aGUgY3JlYXRpbmcgaG9zdCBlbGVtZW50IHdoZW4gY3JlYXRlZC4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsIGNsaWVudCBkb21cbiAqIGlzIHJlYWRpZWQgaW4gdGhlIHByb3BlciBvcmRlciwgbWFpbnRhaW5pbmcgdGhlIGRlc2lyZWQgZ3VhcmFudGVlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmxldCBob3N0U3RhY2sgPSB7XG5cbiAgc3RhY2s6IFtdLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYWRkIHRvIGhvc3RTdGFja1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgcmVnaXN0ZXJIb3N0KGluc3QpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIGxldCBob3N0ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXTtcbiAgICAgIGhvc3QuX2VucXVldWVDbGllbnQoaW5zdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYmVnaW4gaG9zdGluZ1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgYmVnaW5Ib3N0aW5nKGluc3QpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goaW5zdCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5zdCBJbnN0YW5jZSB0byBlbmQgaG9zdGluZ1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgZW5kSG9zdGluZyhpbnN0KSB7XG4gICAgbGV0IHN0YWNrTGVuID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgaWYgKHN0YWNrTGVuICYmIHRoaXMuc3RhY2tbc3RhY2tMZW4tMV0gPT0gaW5zdCkge1xuICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktZWZmZWN0cy5qcyIsImltcG9ydCAnLi9ib290LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmluZGV4T2YoJy4nKSA+PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm9vdChwYXRoKSB7XG4gIGxldCBkb3RJbmRleCA9IHBhdGguaW5kZXhPZignLicpO1xuICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZG90SW5kZXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB7XG4gIC8vICAgICBiYXNlLnN0YXJ0c1dpdGgocGF0aCArICcuJyk7XG4gIHJldHVybiBiYXNlLmluZGV4T2YocGF0aCArICcuJykgPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Rlc2NlbmRhbnQoYmFzZSwgcGF0aCkge1xuICAvLyAgICAgcGF0aC5zdGFydHNXaXRoKGJhc2UgKyAnLicpO1xuICByZXR1cm4gcGF0aC5pbmRleE9mKGJhc2UgKyAnLicpID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKGJhc2UsIG5ld0Jhc2UsIHBhdGgpIHtcbiAgcmV0dXJuIG5ld0Jhc2UgKyBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXMoYmFzZSwgcGF0aCkge1xuICByZXR1cm4gKGJhc2UgPT09IHBhdGgpIHx8XG4gICAgICAgICBpc0FuY2VzdG9yKGJhc2UsIHBhdGgpIHx8XG4gICAgICAgICBpc0Rlc2NlbmRhbnQoYmFzZSwgcGF0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYXJncyA9IHBhdGhbaV0udG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgZm9yIChsZXQgaj0wOyBqPGFyZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhcmdzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXQocGF0aCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBub3JtYWxpemUocGF0aCkuc3BsaXQoJy4nKTtcbiAgfVxuICByZXR1cm4gcGF0aC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQocm9vdCwgcGF0aCwgaW5mbykge1xuICBsZXQgcHJvcCA9IHJvb3Q7XG4gIGxldCBwYXJ0cyA9IHNwbGl0KHBhdGgpO1xuICAvLyBMb29wIG92ZXIgcGF0aCBwYXJ0c1swLi5uLTFdIGFuZCBkZXJlZmVyZW5jZVxuICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXByb3ApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBwcm9wID0gcHJvcFtwYXJ0XTtcbiAgfVxuICBpZiAoaW5mbykge1xuICAgIGluZm8ucGF0aCA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgfVxuICByZXR1cm4gcHJvcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChyb290LCBwYXRoLCB2YWx1ZSkge1xuICBsZXQgcHJvcCA9IHJvb3Q7XG4gIGxldCBwYXJ0cyA9IHNwbGl0KHBhdGgpO1xuICBsZXQgbGFzdCA9IHBhcnRzW3BhcnRzLmxlbmd0aC0xXTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBMb29wIG92ZXIgcGF0aCBwYXJ0c1swLi5uLTJdIGFuZCBkZXJlZmVyZW5jZVxuICAgIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgcHJvcCA9IHByb3BbcGFydF07XG4gICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgdmFsdWUgdG8gb2JqZWN0IGF0IGVuZCBvZiBwYXRoXG4gICAgcHJvcFtsYXN0XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFNpbXBsZSBwcm9wZXJ0eSBzZXRcbiAgICBwcm9wW3BhdGhdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzRGVlcCA9IGlzUGF0aDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9wYXRoLmpzIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwJDAgZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuXG5sZXQgY2FzZU1hcCA9IGNhc2VNYXAkMDtcblxubGV0IG1pY3JvdGFzayA9IG1pY3JvVGFzaztcblxuLy8gU2F2ZSBtYXAgb2YgbmF0aXZlIHByb3BlcnRpZXM7IHRoaXMgZm9ybXMgYSBibGFja2xpc3Qgb3IgcHJvcGVydGllc1xuLy8gdGhhdCB3b24ndCBoYXZlIHRoZWlyIHZhbHVlcyBcInNhdmVkXCIgYnkgYHNhdmVBY2Nlc3NvclZhbHVlYCwgc2luY2Vcbi8vIHJlYWRpbmcgZnJvbSBhbiBIVE1MRWxlbWVudCBhY2Nlc3NvciBmcm9tIHRoZSBjb250ZXh0IG9mIGEgcHJvdG90eXBlIHRocm93c1xuY29uc3QgbmF0aXZlUHJvcGVydGllcyA9IHt9O1xubGV0IHByb3RvID0gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xud2hpbGUgKHByb3RvKSB7XG4gIGxldCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcbiAgZm9yIChsZXQgaT0wOyBpPHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgbmF0aXZlUHJvcGVydGllc1twcm9wc1tpXV0gPSB0cnVlO1xuICB9XG4gIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHNhdmUgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIG92ZXJyaWRkZW4gd2l0aFxuICogYW4gYWNjZXNzb3IuIElmIHRoZSBgbW9kZWxgIGlzIGEgcHJvdG90eXBlLCB0aGUgdmFsdWVzIHdpbGwgYmUgc2F2ZWRcbiAqIGluIGBfX2RhdGFQcm90b2AsIGFuZCBpdCdzIHVwIHRvIHRoZSB1c2VyIChvciBkb3duc3RyZWFtIG1peGluKSB0b1xuICogZGVjaWRlIGhvdy93aGVuIHRvIHNldCB0aGVzZSB2YWx1ZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3NvcnMuXG4gKiBJZiBgbW9kZWxgIGlzIGFscmVhZHkgYW4gaW5zdGFuY2UgKGl0IGhhcyBhIGBfX2RhdGFgIHByb3BlcnR5KSwgdGhlblxuICogdGhlIHZhbHVlIHdpbGwgYmUgc2V0IGFzIGEgcGVuZGluZyBwcm9wZXJ0eSwgbWVhbmluZyB0aGUgdXNlciBzaG91bGRcbiAqIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgIHRvIHRha2UgZWZmZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmVBY2Nlc3NvclZhbHVlKG1vZGVsLCBwcm9wZXJ0eSkge1xuICAvLyBEb24ndCByZWFkL3N0b3JlIHZhbHVlIGZvciBhbnkgbmF0aXZlIHByb3BlcnRpZXMgc2luY2UgdGhleSBjb3VsZCB0aHJvd1xuICBpZiAoIW5hdGl2ZVByb3BlcnRpZXNbcHJvcGVydHldKSB7XG4gICAgbGV0IHZhbHVlID0gbW9kZWxbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobW9kZWwuX19kYXRhKSB7XG4gICAgICAgIC8vIEFkZGluZyBhY2Nlc3NvciB0byBpbnN0YW5jZTsgdXBkYXRlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBJdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGNhbGwgX2ZsdXNoUHJvcGVydGllc1xuICAgICAgICBtb2RlbC5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gcHJvdG87IHNhdmUgcHJvdG8ncyB2YWx1ZSBmb3IgaW5zdGFuY2UtdGltZSB1c2VcbiAgICAgICAgaWYgKCFtb2RlbC5fX2RhdGFQcm90bykge1xuICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZGF0YVByb3RvJywgbW9kZWwpKSkge1xuICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0gT2JqZWN0LmNyZWF0ZShtb2RlbC5fX2RhdGFQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuX19kYXRhUHJvdG9bcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBQcm9wZXJ0eUFjY2Vzc29ycyA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5QWNjZXNzb3JzfVxuICAgKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUFjY2Vzc29ycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgYWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHN0YW5kYXJkXG4gICAgICogc3RhdGljIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogQXR0cmlidXRlIG5hbWVzIGFyZSBtYXBwZWQgdG8gcHJvcGVydHkgbmFtZXMgdXNpbmcgdGhlIGBkYXNoLWNhc2VgIHRvXG4gICAgICogYGNhbWVsQ2FzZWAgY29udmVudGlvblxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnRpZXNGb3JBdHRyaWJ1dGVzKCkge1xuICAgICAgbGV0IGEkID0gdGhpcy5vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBhJC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUHJvcGVydHlBY2Nlc3NvcihjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShhJFtpXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19zZXJpYWxpemluZztcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdGhpcy5fX2RhdGFDb3VudGVyO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFFbmFibGVkO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFSZWFkeTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhSW52YWxpZDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhT2xkO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVByb3RvO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHM7XG4gICAgICB0aGlzLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgbmF0aXZlIEN1c3RvbSBFbGVtZW50cyBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCB0b1xuICAgICAqIHNldCBhbiBhdHRyaWJ1dGUgdmFsdWUgdG8gYSBwcm9wZXJ0eSB2aWEgYF9hdHRyaWJ1dGVUb1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlIHRoYXQgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIE5ldyBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgKlxuICAgICAqIFByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlIHBvaW50IGZvciBwZXJmb3JtaW5nIGFueSBzZXR1cCB3b3JrIHByaW9yXG4gICAgICogdG8gaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eSBhY2Nlc3NvciBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFFbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YUludmFsaWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhID0ge307XG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFPbGQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyh0aGlzLl9fZGF0YVByb3RvKTtcbiAgICAgICAgdGhpcy5fX2RhdGFQcm90byA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBDYXB0dXJlIGluc3RhbmNlIHByb3BlcnRpZXM7IHRoZXNlIHdpbGwgYmUgc2V0IGludG8gYWNjZXNzb3JzXG4gICAgICAvLyBkdXJpbmcgZmlyc3QgZmx1c2guIERvbid0IHNldCB0aGVtIGhlcmUsIHNpbmNlIHdlIHdhbnRcbiAgICAgIC8vIHRoZXNlIHRvIG92ZXJ3cml0ZSBkZWZhdWx0cy9jb25zdHJ1Y3RvciBhc3NpZ25tZW50c1xuICAgICAgZm9yIChsZXQgcCBpbiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wc1twXSA9IHRoaXNbcF07XG4gICAgICAgICAgZGVsZXRlIHRoaXNbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXQgaW5zdGFuY2UgdGltZSB3aXRoIGJhZyBvZiBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqIGJ5IGFjY2Vzc29ycyBvbiB0aGUgcHJvdG90eXBlIHdoZW4gYWNjZXNzb3JzIHdlcmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICogc2V0dGVyIGF0IGluc3RhbmNlIHRpbWUuICBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBhbiBvdmVycmlkZVxuICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnR5IHZhbHVlcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwLCBwcm9wc1twXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF0IHJlYWR5IHRpbWUgd2l0aCBiYWcgb2YgaW5zdGFuY2UgcHJvcGVydGllcyB0aGF0IG92ZXJ3cm90ZVxuICAgICAqIGFjY2Vzc29ycyB3aGVuIHRoZSBlbGVtZW50IHVwZ3JhZGVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgKiBzZXR0ZXIgYXQgcmVhZHkgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICogcG9pbnQgZm9yIGN1c3RvbWl6aW5nIG9yIHByb3ZpZGluZyBtb3JlIGVmZmljaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqICAgd2hlbiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoZSBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gYXR0cmlidXRlLiBJZiBpdCBkb2VzIG5vdCxcbiAgICAgKiBhc3NpZ25zIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIE5hbWUgb2YgYXR0cmlidXRlIHRvIGVuc3VyZSBpcyBzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgX2Vuc3VyZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsIGF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGFuIGF0dHJpYnV0ZSB0byBpdHMgYXNzb2NpYXRlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG9cbiAgICAgKiBhIHR5cGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHsqPX0gdHlwZSB0eXBlIHRvIGRlc2VyaWFsaXplIHRvLlxuICAgICAqL1xuICAgIF9hdHRyaWJ1dGVUb1Byb3BlcnR5KGF0dHJpYnV0ZSwgdmFsdWUsIHR5cGUpIHtcbiAgICAgIC8vIERvbid0IGRlc2VyaWFsaXplIGJhY2sgdG8gcHJvcGVydHkgaWYgY3VycmVudGx5IHJlZmxlY3RpbmdcbiAgICAgIGlmICghdGhpcy5fX3NlcmlhbGl6aW5nKSB7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKGF0dHJpYnV0ZSk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gdGhpcy5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICovXG4gICAgX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IHRydWU7XG4gICAgICB2YWx1ZSA9IChhcmd1bWVudHMubGVuZ3RoIDwgMykgPyB0aGlzW3Byb3BlcnR5XSA6IHZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsXG4gICAgICAgIGF0dHJpYnV0ZSB8fCBjYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSkpO1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHR5cGVkIHZhbHVlIHRvIGFuIEhUTUwgYXR0cmlidXRlIG9uIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgdHlwZWRcbiAgICAgKiB2YWx1ZSB0byBhIHN0cmluZy4gIElmIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZCAodGhpcyBpcyB0aGUgZGVmYXVsdCBmb3IgYm9vbGVhblxuICAgICAqIHR5cGUgYGZhbHNlYCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzZXQgYXR0cmlidXRlIHRvLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gc2VyaWFsaXplIHRvLlxuICAgICAqL1xuICAgIF92YWx1ZVRvTm9kZUF0dHJpYnV0ZShub2RlLCB2YWx1ZSwgYXR0cmlidXRlKSB7XG4gICAgICBsZXQgc3RyID0gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHN0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFBvbHltZXIgd2hlbiBzZXR0aW5nIEpTIHByb3BlcnR5IHZhbHVlcyB0b1xuICAgICAqIEhUTUwgYXR0cmlidXRlcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgc2VyaWFsaXphdGlvbiBmb3IgY3VzdG9tIHR5cGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBTdHJpbmcgc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBfc2VyaWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPyAnJyA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUudG9TdHJpbmcoKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgUG9seW1lciB3aGVuIHJlYWRpbmcgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzIHRvXG4gICAgICogSlMgcHJvcGVydGllcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgZGVzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gYHR5cGVgcy4gIE5vdGUsXG4gICAgICogdGhlIGB0eXBlYCBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGB0eXBlYCBmaWVsZCBwcm92aWRlZCBpbiB0aGVcbiAgICAgKiBgcHJvcGVydGllc2AgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGEgZ2l2ZW4gcHJvcGVydHksIGFuZCBpc1xuICAgICAqIGJ5IGNvbnZlbnRpb24gdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoZSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgaXMgdXNlZCBhcyBhIHNlbnRpbmVsIHZhbHVlIHRvXG4gICAgICogaW5kaWNhdGUgdGhlIGF0dHJpYnV0ZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlIHRvIGRlc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgVHlwZSB0byBkZXNlcmlhbGl6ZSB0aGUgc3RyaW5nIHRvLlxuICAgICAqIEByZXR1cm4geyp9IFR5cGVkIHZhbHVlIGRlc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgKi9cbiAgICAgIGxldCBvdXRWYWx1ZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICBvdXRWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgIG91dFZhbHVlID0gKHZhbHVlICE9PSBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3V0VmFsdWUgPSBKU09OLnBhcnNlKC8qKiBAdHlwZSBzdHJpbmcgKi8odmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgIC8vIGFsbG93IG5vbi1KU09OIGxpdGVyYWxzIGxpa2UgU3RyaW5ncyBhbmQgTnVtYmVyc1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IEpTT04ucGFyc2UoLyoqIEB0eXBlIHN0cmluZyAqLyh2YWx1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2goeCkge1xuICAgICAgICAgICAgb3V0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBQb2x5bWVyOjpBdHRyaWJ1dGVzOiBjb3VsZG4ndCBkZWNvZGUgQXJyYXkgYXMgSlNPTjogJHt2YWx1ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgIG91dFZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG91dFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRWYWx1ZTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldHRlci9nZXR0ZXIgcGFpciBmb3IgdGhlIG5hbWVkIHByb3BlcnR5IHdpdGggaXRzIG93blxuICAgICAqIGxvY2FsIHN0b3JhZ2UuICBUaGUgZ2V0dGVyIHJldHVybnMgdGhlIHZhbHVlIGluIHRoZSBsb2NhbCBzdG9yYWdlLFxuICAgICAqIGFuZCB0aGUgc2V0dGVyIGNhbGxzIGBfc2V0UHJvcGVydHlgLCB3aGljaCB1cGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlXG4gICAgICogZm9yIHRoZSBwcm9wZXJ0eSBhbmQgZW5xdWV1ZXMgYSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgb24gYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuICBDYWxsaW5nXG4gICAgICogdGhpcyBtZXRob2QgbWF5IG92ZXJ3cml0ZSBhIHByb3BlcnR5IHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb25cbiAgICAgKiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGJ5IGNyZWF0aW5nIHRoZSBhY2Nlc3Nvci4gIFdoZW4gY2FsbGluZyBvblxuICAgICAqIGEgcHJvdG90eXBlLCBhbnkgb3ZlcndyaXR0ZW4gdmFsdWVzIGFyZSBzYXZlZCBpbiBgX19kYXRhUHJvdG9gLFxuICAgICAqIGFuZCBpdCBpcyB1cCB0byB0aGUgc3ViY2xhc3NlciB0byBkZWNpZGUgaG93L3doZW4gdG8gc2V0IHRob3NlXG4gICAgICogcHJvcGVydGllcyBiYWNrIGludG8gdGhlIGFjY2Vzc29yLiAgV2hlbiBjYWxsaW5nIG9uIGFuIGluc3RhbmNlLFxuICAgICAqIHRoZSBvdmVyd3JpdHRlbiB2YWx1ZSBpcyBzZXQgdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YCwgYW5kIHRoZVxuICAgICAqIHVzZXIgc2hvdWxkIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgXG4gICAgICogZm9yIHRoZSB2YWx1ZXMgdG8gdGFrZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWFkT25seSBXaGVuIHRydWUsIG5vIHNldHRlciBpcyBjcmVhdGVkOyB0aGVcbiAgICAgKiAgIHByb3RlY3RlZCBgX3NldFByb3BlcnR5YCBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gc2V0IHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgcmVhZE9ubHkpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19kYXRhSGFzQWNjZXNzb3InKSkge1xuICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldKSB7XG4gICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgc2F2ZUFjY2Vzc29yVmFsdWUodGhpcywgcHJvcGVydHkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAgICAgICAgIC8qKiBAdGhpcyB7UHJvcGVydHlBY2Nlc3NvcnN9ICovXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvKiogQHRoaXMge1Byb3BlcnR5QWNjZXNzb3JzfSAqL1xuICAgICAgICAgIHNldDogcmVhZE9ubHkgPyBmdW5jdGlvbigpIHt9IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGlicmFyeSBjcmVhdGVkIGFuIGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gYWNjZXNzb3Igd2FzIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBfaGFzQWNjZXNzb3IocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yICYmIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHkgKHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWApXG4gICAgICogYW5kIGVucXVldWVzIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBhIHByb3BlcnR5LCByZWNvcmRzIHRoZSBwcmV2aW91cyB2YWx1ZSxcbiAgICAgKiBhbmQgYWRkcyBpdCB0byB0aGUgc2V0IG9mIFwicGVuZGluZyBjaGFuZ2VzXCIgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay4gIFRoaXMgbWV0aG9kIGRvZXMgbm90IGVucXVldWUgdGhlXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgY2hhbmdlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgbGV0IG9sZCA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YU9sZCAmJiAhKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IG9sZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaGFzIGEgcGVuZGluZyBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaXNQcm9wZXJ0eVBlbmRpbmcocHJvcCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fX2RhdGFQZW5kaW5nICYmIChwcm9wIGluIHRoaXMuX19kYXRhUGVuZGluZykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBwcm9wZXJ0aWVzIGFzIGludmFsaWQsIGFuZCBlbnF1ZXVlcyBhbiBhc3luY1xuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbnZhbGlkYXRlUHJvcGVydGllcygpIHtcbiAgICAgIGlmICghdGhpcy5fX2RhdGFJbnZhbGlkICYmIHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgbWljcm90YXNrLnJ1bigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhSW52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdG8gZW5hYmxlIHByb3BlcnR5IGFjY2Vzc29yIHByb2Nlc3NpbmcuIEJlZm9yZSB0aGlzIG1ldGhvZCBpc1xuICAgICAqIGNhbGxlZCBhY2Nlc3NvciB2YWx1ZXMgd2lsbCBiZSBzZXQgYnV0IHNpZGUgZWZmZWN0cyBhcmVcbiAgICAgKiBxdWV1ZWQuIFdoZW4gY2FsbGVkLCBhbnkgcGVuZGluZyBzaWRlIGVmZmVjdHMgb2NjdXIgaW1tZWRpYXRlbHkuXG4gICAgICogRm9yIGVsZW1lbnRzLCBnZW5lcmFsbHkgYGNvbm5lY3RlZENhbGxiYWNrYCBpcyBhIG5vcm1hbCBzcG90IHRvIGRvIHNvLlxuICAgICAqIEl0IGlzIHNhZmUgdG8gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyBhcyBpdCBvbmx5IHR1cm5zIG9uXG4gICAgICogcHJvcGVydHkgYWNjZXNzb3JzIG9uY2UuXG4gICAgICovXG4gICAgX2VuYWJsZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX19kYXRhRW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9fZGF0YUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzKSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpO1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkeSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjayB3aXRoIHRoZSBjdXJyZW50IHNldCBvZlxuICAgICAqIHBlbmRpbmcgY2hhbmdlcyAoYW5kIG9sZCB2YWx1ZXMgcmVjb3JkZWQgd2hlbiBwZW5kaW5nIGNoYW5nZXMgd2VyZVxuICAgICAqIHNldCksIGFuZCByZXNldHMgdGhlIHBlbmRpbmcgc2V0IG9mIGNoYW5nZXMuIEdlbmVyYWxseSwgdGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgbm90IGJlIGNhbGxlZCBpbiB1c2VyIGNvZGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZmx1c2hQcm9wZXJ0aWVzKCkge1xuICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZyAmJiB0aGlzLl9fZGF0YU9sZCkge1xuICAgICAgICBsZXQgY2hhbmdlZFByb3BzID0gdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXIrKztcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc0NoYW5nZWQodGhpcy5fX2RhdGEsIGNoYW5nZWRQcm9wcywgdGhpcy5fX2RhdGFPbGQpO1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXItLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgY2FsbGJhY2sgY2FsbGVkIHRoZSBmaXJzdCB0aW1lIHByb3BlcnRpZXMgYXJlIGJlaW5nIGZsdXNoZWQuXG4gICAgICogUHJpb3IgdG8gYHJlYWR5YCwgYWxsIHByb3BlcnR5IHNldHMgdGhyb3VnaCBhY2Nlc3NvcnMgYXJlIHF1ZXVlZCBhbmRcbiAgICAgKiB0aGVpciBlZmZlY3RzIGFyZSBmbHVzaGVkIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMuXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBpbXBsZW1lbnQgYmVoYXZpb3IgdGhhdCBpc1xuICAgICAqIGRlcGVuZGVudCBvbiB0aGUgZWxlbWVudCBoYXZpbmcgaXRzIHByb3BlcnRpZXMgaW5pdGlhbGl6ZWQsIGUuZy5cbiAgICAgKiBmcm9tIGRlZmF1bHRzIChpbml0aWFsaXplZCBmcm9tIGBjb25zdHJ1Y3RvcmAsIGBfaW5pdGlhbGl6ZVByb3BlcnRpZXNgKSxcbiAgICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCwgb3IgdmFsdWVzIHByb3BhZ2F0ZWQgZnJvbSBob3N0IGUuZy4gdmlhXG4gICAgICogYmluZGluZ3MuICBgc3VwZXIucmVhZHkoKWAgbXVzdCBiZSBjYWxsZWQgdG8gZW5zdXJlIHRoZSBkYXRhIHN5c3RlbVxuICAgICAqIGJlY29tZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgLy8gUnVuIG5vcm1hbCBmbHVzaFxuICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYW55IHByb3BlcnRpZXMgd2l0aCBhY2Nlc3NvcnMgY3JlYXRlZCB2aWFcbiAgICAgKiBgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3JgIGhhdmUgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGN1cnJlbnRQcm9wcyBCYWcgb2YgYWxsIGN1cnJlbnQgYWNjZXNzb3IgdmFsdWVzXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAqICAgY2FsbCB0byBgX3Byb3BlcnRpZXNDaGFuZ2VkYFxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgaW4gYGNoYW5nZWRQcm9wc2BcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Byb3BlcnRpZXNDaGFuZ2VkKGN1cnJlbnRQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHByb3BlcnR5IHZhbHVlIHNob3VsZCBiZVxuICAgICAqIGNvbnNpZGVyZWQgYXMgYSBjaGFuZ2UgYW5kIGNhdXNlIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFja1xuICAgICAqIHRvIGJlIGVucXVldWVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIHByaW1pdGl2ZSB0eXBlcyBpZiBhXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrIGZhaWxzLCBhbmQgcmV0dXJucyBgdHJ1ZWAgZm9yIGFsbCBPYmplY3QvQXJyYXlzLlxuICAgICAqIFRoZSBtZXRob2QgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGBOYU5gLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZS5nLiBwcm92aWRlIHN0cmljdGVyIGNoZWNraW5nIGZvclxuICAgICAqIE9iamVjdHMvQXJyYXlzIHdoZW4gdXNpbmcgaW1tdXRhYmxlIHBhdHRlcm5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiAgIGFuZCBlbnF1ZXVlIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICAgICAgKG9sZCAhPT0gdmFsdWUgJiZcbiAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyAob2xkPT1OYU4sIHZhbHVlPT1OYU4pIGFsd2F5cyByZXR1cm5zIGZhbHNlXG4gICAgICAgICAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKSlcbiAgICAgICk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gUHJvcGVydHlBY2Nlc3NvcnM7XG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1hY2Nlc3NvcnMuanMiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8qKiBAdHlwZWRlZiB7e3J1bjogZnVuY3Rpb24oZnVuY3Rpb24oKSwgbnVtYmVyPSk6bnVtYmVyLCBjYW5jZWw6IGZ1bmN0aW9uKG51bWJlcil9fSAqL1xubGV0IEFzeW5jSW50ZXJmYWNlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8vIE1pY3JvdGFzayBpbXBsZW1lbnRlZCB1c2luZyBNdXRhdGlvbiBPYnNlcnZlclxubGV0IG1pY3JvdGFza0N1cnJIYW5kbGUgPSAwO1xubGV0IG1pY3JvdGFza0xhc3RIYW5kbGUgPSAwO1xubGV0IG1pY3JvdGFza0NhbGxiYWNrcyA9IFtdO1xubGV0IG1pY3JvdGFza05vZGVDb250ZW50ID0gMDtcbmxldCBtaWNyb3Rhc2tOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xubmV3IHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyKG1pY3JvdGFza0ZsdXNoKS5vYnNlcnZlKG1pY3JvdGFza05vZGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0ZsdXNoKCkge1xuICBjb25zdCBsZW4gPSBtaWNyb3Rhc2tDYWxsYmFja3MubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbGV0IGNiID0gbWljcm90YXNrQ2FsbGJhY2tzW2ldO1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7IHRocm93IGU7IH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBtaWNyb3Rhc2tDYWxsYmFja3Muc3BsaWNlKDAsIGxlbik7XG4gIG1pY3JvdGFza0xhc3RIYW5kbGUgKz0gbGVuO1xufVxuXG5leHBvcnQgY29uc3QgdGltZU91dCA9IHtcbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdWItbW9kdWxlIHdpdGggdGhlIGFzeW5jIGludGVyZmFjZSBwcm92aWRpbmcgdGhlIHByb3ZpZGVkXG4gICAqIGRlbGF5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSBUaW1lIHRvIHdhaXQgYmVmb3JlIGNhbGxpbmcgY2FsbGJhY2tzIGluIG1zXG4gICAqIEByZXR1cm4ge0FzeW5jSW50ZXJmYWNlfSBBbiBhc3luYyB0aW1lb3V0IGludGVyZmFjZVxuICAgKi9cbiAgYWZ0ZXIoZGVsYXkpIHtcbiAgICByZXR1cm4gIHtcbiAgICAgIHJ1bihmbikgeyByZXR1cm4gc2V0VGltZW91dChmbiwgZGVsYXkpOyB9LFxuICAgICAgY2FuY2VsOiB3aW5kb3cuY2xlYXJUaW1lb3V0LmJpbmQod2luZG93KVxuICAgIH07XG4gIH0sXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBpbiB0aGUgbmV4dCB0YXNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuOiB3aW5kb3cuc2V0VGltZW91dC5iaW5kKHdpbmRvdyksXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgdGltZU91dGAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICovXG4gIGNhbmNlbDogd2luZG93LmNsZWFyVGltZW91dC5iaW5kKHdpbmRvdylcbn07XG5cbmV4cG9ydCBjb25zdCBhbmltYXRpb25GcmFtZSA9IHtcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuYW5pbWF0aW9uRnJhbWVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW46IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpLFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYGFuaW1hdGlvbkZyYW1lYCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKi9cbiAgY2FuY2VsOiB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUuYmluZCh3aW5kb3cpXG59O1xuXG5leHBvcnQgY29uc3QgaWRsZVBlcmlvZCA9IHtcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IGByZXF1ZXN0SWRsZUNhbGxiYWNrYCB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmlkbGVQZXJpb2RcbiAgICogQHBhcmFtIHtmdW5jdGlvbihJZGxlRGVhZGxpbmUpfSBmbiBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bihmbikge1xuICAgIHJldHVybiB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayA/XG4gICAgICB3aW5kb3cucmVxdWVzdElkbGVDYWxsYmFjayhmbikgOlxuICAgICAgd2luZG93LnNldFRpbWVvdXQoZm4sIDE2KTtcbiAgfSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBpZGxlUGVyaW9kYCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuaWRsZVBlcmlvZFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKi9cbiAgY2FuY2VsKGhhbmRsZSkge1xuICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2sgP1xuICAgICAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayhoYW5kbGUpIDpcbiAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IG1pY3JvVGFzayA9IHtcblxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgbWljcm90YXNrIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGNhbGxiYWNrKSB7XG4gICAgbWljcm90YXNrTm9kZS50ZXh0Q29udGVudCA9IG1pY3JvdGFza05vZGVDb250ZW50Kys7XG4gICAgbWljcm90YXNrQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBtaWNyb3Rhc2tDdXJySGFuZGxlKys7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBtaWNyb1Rhc2tgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5taWNyb1Rhc2tcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICovXG4gIGNhbmNlbChoYW5kbGUpIHtcbiAgICBjb25zdCBpZHggPSBoYW5kbGUgLSBtaWNyb3Rhc2tMYXN0SGFuZGxlO1xuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgaWYgKCFtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYXN5bmMgaGFuZGxlOiAnICsgaGFuZGxlKTtcbiAgICAgIH1cbiAgICAgIG1pY3JvdGFza0NhbGxiYWNrc1tpZHhdID0gbnVsbDtcbiAgICB9XG4gIH1cblxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5qcyIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuXG4vLyAxLnggYmFja3dhcmRzLWNvbXBhdGlibGUgYXV0by13cmFwcGVyIGZvciB0ZW1wbGF0ZSB0eXBlIGV4dGVuc2lvbnNcbi8vIFRoaXMgaXMgYSBjbGVhciBsYXllcmluZyB2aW9sYXRpb24gYW5kIGdpdmVzIGZhdm9yZWQtbmF0aW9uIHN0YXR1cyB0b1xuLy8gZG9tLWlmIGFuZCBkb20tcmVwZWF0IHRlbXBsYXRlcy4gIFRoaXMgaXMgYSBjb25jZWl0IHdlJ3JlIGNob29zaW5nIHRvIGtlZXBcbi8vIGEuKSB0byBlYXNlIDEueCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBkdWUgdG8gbG9zcyBvZiBgaXNgLCBhbmRcbi8vIGIuKSB0byBtYWludGFpbiBpZi9yZXBlYXQgY2FwYWJpbGl0eSBpbiBwYXJzZXItY29uc3RyYWluZWQgZWxlbWVudHNcbi8vICAgICAoZS5nLiB0YWJsZSwgc2VsZWN0KSBpbiBsaWV1IG9mIG5hdGl2ZSBDRSB0eXBlIGV4dGVuc2lvbnMgd2l0aG91dFxuLy8gICAgIG1hc3NpdmUgbmV3IGludmVudGlvbiBpbiB0aGlzIHNwYWNlIChlLmcuIGRpcmVjdGl2ZSBzeXN0ZW0pXG5jb25zdCB0ZW1wbGF0ZUV4dGVuc2lvbnMgPSB7XG4gICdkb20taWYnOiB0cnVlLFxuICAnZG9tLXJlcGVhdCc6IHRydWVcbn07XG5mdW5jdGlvbiB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSkge1xuICBsZXQgaXMgPSBub2RlLmdldEF0dHJpYnV0ZSgnaXMnKTtcbiAgaWYgKGlzICYmIHRlbXBsYXRlRXh0ZW5zaW9uc1tpc10pIHtcbiAgICBsZXQgdCA9IG5vZGU7XG4gICAgdC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgbm9kZSA9IHQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KGlzKTtcbiAgICB0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIHQpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQodCk7XG4gICAgd2hpbGUodC5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUodC5hdHRyaWJ1dGVzWzBdLm5hbWUsIHQuYXR0cmlidXRlc1swXS52YWx1ZSk7XG4gICAgICB0LnJlbW92ZUF0dHJpYnV0ZSh0LmF0dHJpYnV0ZXNbMF0ubmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5kVGVtcGxhdGVOb2RlKHJvb3QsIG5vZGVJbmZvKSB7XG4gIC8vIHJlY3Vyc2l2ZWx5IGFzY2VuZCB0cmVlIHVudGlsIHdlIGhpdCByb290XG4gIGxldCBwYXJlbnQgPSBub2RlSW5mby5wYXJlbnRJbmZvICYmIGZpbmRUZW1wbGF0ZU5vZGUocm9vdCwgbm9kZUluZm8ucGFyZW50SW5mbyk7XG4gIC8vIHVud2luZCB0aGUgc3RhY2ssIHJldHVybmluZyB0aGUgaW5kZXhlZCBub2RlIGF0IGVhY2ggbGV2ZWxcbiAgaWYgKHBhcmVudCkge1xuICAgIC8vIG5vdGU6IG1hcmdpbmFsbHkgZmFzdGVyIHRoYW4gaW5kZXhpbmcgdmlhIGNoaWxkTm9kZXNcbiAgICAvLyAoaHR0cDovL2pzcGVyZi5jb20vY2hpbGRub2Rlcy1sb29rdXApXG4gICAgZm9yIChsZXQgbj1wYXJlbnQuZmlyc3RDaGlsZCwgaT0wOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChub2RlSW5mby5wYXJlbnRJbmRleCA9PT0gaSsrKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxufVxuXG4vLyBjb25zdHJ1Y3QgYCRgIG1hcCAoZnJvbSBpZCBhbm5vdGF0aW9ucylcbmZ1bmN0aW9uIGFwcGx5SWRUb01hcChpbnN0LCBtYXAsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby5pZCkge1xuICAgIG1hcFtub2RlSW5mby5pZF0gPSBub2RlO1xuICB9XG59XG5cbi8vIGluc3RhbGwgZXZlbnQgbGlzdGVuZXJzIChmcm9tIGV2ZW50IGFubm90YXRpb25zKVxuZnVuY3Rpb24gYXBwbHlFdmVudExpc3RlbmVyKGluc3QsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby5ldmVudHMgJiYgbm9kZUluZm8uZXZlbnRzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGo9MCwgZSQ9bm9kZUluZm8uZXZlbnRzLCBlOyAoajxlJC5sZW5ndGgpICYmIChlPWUkW2pdKTsgaisrKSB7XG4gICAgICBpbnN0Ll9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGUubmFtZSwgZS52YWx1ZSwgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8vIHB1c2ggY29uZmlndXJhdGlvbiByZWZlcmVuY2VzIGF0IGNvbmZpZ3VyZSB0aW1lXG5mdW5jdGlvbiBhcHBseVRlbXBsYXRlQ29udGVudChpbnN0LCBub2RlLCBub2RlSW5mbykge1xuICBpZiAobm9kZUluZm8udGVtcGxhdGVJbmZvKSB7XG4gICAgbm9kZS5fdGVtcGxhdGVJbmZvID0gbm9kZUluZm8udGVtcGxhdGVJbmZvO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVFdmVudEhhbmRsZXIoY29udGV4dCwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICBjb250ZXh0ID0gY29udGV4dC5fbWV0aG9kSG9zdCB8fCBjb250ZXh0O1xuICBsZXQgaGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoY29udGV4dFttZXRob2ROYW1lXSkge1xuICAgICAgY29udGV4dFttZXRob2ROYW1lXShlLCBlLmRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignbGlzdGVuZXIgbWV0aG9kIGAnICsgbWV0aG9kTmFtZSArICdgIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFuZGxlcjtcbn1cblxuZXhwb3J0IGNvbnN0IFRlbXBsYXRlU3RhbXAgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9UZW1wbGF0ZVN0YW1wfVxuICAgKi9cbiAgY2xhc3MgVGVtcGxhdGVTdGFtcCBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgLyoqXG4gICAgICogU2NhbnMgYSB0ZW1wbGF0ZSB0byBwcm9kdWNlIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogVGVtcGxhdGUtc3BlY2lmaWMgbWV0YWRhdGEgYXJlIHN0b3JlZCBpbiB0aGUgb2JqZWN0IHJldHVybmVkLCBhbmQgbm9kZS1cbiAgICAgKiBzcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIG9iamVjdHMgaW4gaXRzIGZsYXR0ZW5lZCBgbm9kZUluZm9MaXN0YFxuICAgICAqIGFycmF5LiAgT25seSBub2RlcyBpbiB0aGUgdGVtcGxhdGUgdGhhdCB3ZXJlIHBhcnNlZCBhcyBub2RlcyBvZlxuICAgICAqIGludGVyZXN0IGNvbnRhaW4gYW4gb2JqZWN0IGluIGBub2RlSW5mb0xpc3RgLiAgRWFjaCBgbm9kZUluZm9gIG9iamVjdFxuICAgICAqIGNvbnRhaW5zIGFuIGBpbmRleGAgKGBjaGlsZE5vZGVzYCBpbmRleCBpbiBwYXJlbnQpIGFuZCBvcHRpb25hbGx5XG4gICAgICogYHBhcmVudGAsIHdoaWNoIHBvaW50cyB0byBub2RlIGluZm8gb2YgaXRzIHBhcmVudCAoaW5jbHVkaW5nIGl0cyBpbmRleCkuXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0IHJldHVybmVkIGZyb20gdGhpcyBtZXRob2QgaGFzIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBzdHJ1Y3R1cmUgKG1hbnkgZmllbGRzIG9wdGlvbmFsKTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogICB7XG4gICAgICogICAgIC8vIEZsYXR0ZW5lZCBsaXN0IG9mIG5vZGUgbWV0YWRhdGEgKGZvciBub2RlcyB0aGF0IGdlbmVyYXRlZCBtZXRhZGF0YSlcbiAgICAgKiAgICAgbm9kZUluZm9MaXN0OiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgLy8gYGlkYCBhdHRyaWJ1dGUgZm9yIGFueSBub2RlcyB3aXRoIGlkJ3MgZm9yIGdlbmVyYXRpbmcgYCRgIG1hcFxuICAgICAqICAgICAgICAgaWQ6IHtzdHJpbmd9LFxuICAgICAqICAgICAgICAgLy8gYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBtZXRhZGF0YVxuICAgICAqICAgICAgICAgZXZlbnRzOiBbXG4gICAgICogICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICBuYW1lOiB7c3RyaW5nfSwgICAvLyBldmVudCBuYW1lXG4gICAgICogICAgICAgICAgICAgdmFsdWU6IHtzdHJpbmd9LCAgLy8gaGFuZGxlciBtZXRob2QgbmFtZVxuICAgICAqICAgICAgICAgICB9LCAuLi5cbiAgICAgKiAgICAgICAgIF0sXG4gICAgICogICAgICAgICAvLyBOb3RlcyB3aGVuIHRoZSB0ZW1wbGF0ZSBjb250YWluZWQgYSBgPHNsb3Q+YCBmb3Igc2hhZHkgRE9NXG4gICAgICogICAgICAgICAvLyBvcHRpbWl6YXRpb24gcHVycG9zZXNcbiAgICAgKiAgICAgICAgIGhhc0luc2VydGlvblBvaW50OiB7Ym9vbGVhbn0sXG4gICAgICogICAgICAgICAvLyBGb3IgbmVzdGVkIGA8dGVtcGxhdGU+YGAgbm9kZXMsIG5lc3RlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqICAgICAgICAgdGVtcGxhdGVJbmZvOiB7b2JqZWN0fSwgLy8gbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICogICAgICAgICAvLyBNZXRhZGF0YSB0byBhbGxvdyBlZmZpY2llbnQgcmV0cmlldmFsIG9mIGluc3RhbmNlZCBub2RlXG4gICAgICogICAgICAgICAvLyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgbWV0YWRhdGFcbiAgICAgKiAgICAgICAgIHBhcmVudEluZm86IHtudW1iZXJ9LCAgIC8vIHJlZmVyZW5jZSB0byBwYXJlbnQgbm9kZUluZm8+XG4gICAgICogICAgICAgICBwYXJlbnRJbmRleDoge251bWJlcn0sICAvLyBpbmRleCBpbiBwYXJlbnQncyBgY2hpbGROb2Rlc2AgY29sbGVjdGlvblxuICAgICAqICAgICAgICAgaW5mb0luZGV4OiB7bnVtYmVyfSwgICAgLy8gaW5kZXggb2YgdGhpcyBgbm9kZUluZm9gIGluIGB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0YFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAgLi4uXG4gICAgICogICAgIF0sXG4gICAgICogICAgIC8vIFdoZW4gdHJ1ZSwgdGhlIHRlbXBsYXRlIGhhZCB0aGUgYHN0cmlwLXdoaXRlc3BhY2VgIGF0dHJpYnV0ZVxuICAgICAqICAgICAvLyBvciB3YXMgbmVzdGVkIGluIGEgdGVtcGxhdGUgd2l0aCB0aGF0IHNldHRpbmdcbiAgICAgKiAgICAgc3RyaXBXaGl0ZXNwYWNlOiB7Ym9vbGVhbn0sXG4gICAgICogICAgIC8vIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBuZXN0ZWQgdGVtcGxhdGUgY29udGVudCBpcyBtb3ZlZCBpbnRvXG4gICAgICogICAgIC8vIGEgZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmVkIGhlcmU7IHRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvXG4gICAgICogICAgIC8vIGF2b2lkIHRoZSBjb3N0IG9mIG5lc3RlZCB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgICogICAgIGNvbnRlbnQ6IHtEb2N1bWVudEZyYWdtZW50fVxuICAgICAqICAgfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qga2lja3Mgb2ZmIGEgcmVjdXJzaXZlIHRyZWV3YWxrIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgICBfcGFyc2VUZW1wbGF0ZSA8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAgX3BhcnNlVGVtcGxhdGVDb250ZW50ICAgICAgICAgICAgICB8XG4gICAgICogICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZSAgPC0tLS0tLS0tLS0tLXwtLStcbiAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlIC0tKyAgfFxuICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyAtLS0tLS0tLS0rXG4gICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlc1xuICAgICAqICAgICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWRkIGN1c3RvbSBtZXRhZGF0YSBhYm91dCB0ZW1wbGF0ZXNcbiAgICAgKiB0byBlaXRoZXIgYHRlbXBsYXRlSW5mb2Agb3IgYG5vZGVJbmZvYC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgYmUgZGVzdHJ1Y3RpdmUgdG8gdGhlIHRlbXBsYXRlLCBpbiB0aGF0XG4gICAgICogZS5nLiBldmVudCBhbm5vdGF0aW9ucyBtYXkgYmUgcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm89fSBvdXRlclRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmcm9tIHRoZSBvdXRlclxuICAgICAqICAgdGVtcGxhdGUsIGZvciBwYXJzaW5nIG5lc3RlZCB0ZW1wbGF0ZXNcbiAgICAgKiBAcmV0dXJuIHshVGVtcGxhdGVJbmZvfSBQYXJzZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUsIG91dGVyVGVtcGxhdGVJbmZvKSB7XG4gICAgICAvLyBzaW5jZSBhIHRlbXBsYXRlIG1heSBiZSByZS11c2VkLCBtZW1vLWl6ZSBtZXRhZGF0YVxuICAgICAgaWYgKCF0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvID0ge307XG4gICAgICAgIHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QgPSBbXTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSA9XG4gICAgICAgICAgKG91dGVyVGVtcGxhdGVJbmZvICYmIG91dGVyVGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSkgfHxcbiAgICAgICAgICB0ZW1wbGF0ZS5oYXNBdHRyaWJ1dGUoJ3N0cmlwLXdoaXRlc3BhY2UnKTtcbiAgICAgICAgdGhpcy5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywge3BhcmVudDogbnVsbH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXBsYXRlLl90ZW1wbGF0ZUluZm87XG4gICAgfVxuXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlKHRlbXBsYXRlLmNvbnRlbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBub2RlIGFuZCBhZGRzIHRlbXBsYXRlIGFuZCBub2RlIG1ldGFkYXRhIGJhc2VkIG9uXG4gICAgICogdGhlIGN1cnJlbnQgbm9kZSwgYW5kIGl0cyBgY2hpbGROb2Rlc2AgYW5kIGBhdHRyaWJ1dGVzYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFkZCBjdXN0b20gbm9kZSBvciB0ZW1wbGF0ZSBzcGVjaWZpY1xuICAgICAqIG1ldGFkYXRhIGJhc2VkIG9uIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgbm90ZWQ7XG4gICAgICBsZXQgZWxlbWVudCA9IC8qKiBAdHlwZSBFbGVtZW50ICovKG5vZGUpO1xuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdwcmVzZXJ2ZS1jb250ZW50JykpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICAgICAgLy8gRm9yIFNoYWR5RG9tIG9wdGltaXphdGlvbiwgaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgdGVtcGxhdGVJbmZvLmhhc0luc2VydGlvblBvaW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZXMgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIGNoaWxkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gcm9vdCBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyB3cmFwcyB3aGl0ZWxpc3RlZCBsZWdhY3kgdGVtcGxhdGUgZXh0ZW5zaW9uc1xuICAgICAqIChgaXM9XCJkb20taWZcImAgYW5kIGBpcz1cImRvbS1yZXBlYXRcImApIHdpdGggdGhlaXIgZXF1aXZhbGVudCBlbGVtZW50XG4gICAgICogd3JhcHBlcnMsIGNvbGxhcHNlcyB0ZXh0IG5vZGVzLCBhbmQgc3RyaXBzIHdoaXRlc3BhY2UgZnJvbSB0aGUgdGVtcGxhdGVcbiAgICAgKiBpZiB0aGUgYHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlc3BhY2VgIHNldHRpbmcgd2FzIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSByb290IFJvb3Qgbm9kZSB3aG9zZSBgY2hpbGROb2Rlc2Agd2lsbCBiZSBwYXJzZWRcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXMocm9vdCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgZm9yIChsZXQgbm9kZT1yb290LmZpcnN0Q2hpbGQsIHBhcmVudEluZGV4PTAsIG5leHQ7IG5vZGU7IG5vZGU9bmV4dCkge1xuICAgICAgICAvLyBXcmFwIHRlbXBsYXRlc1xuICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgIG5vZGUgPSB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29sbGFwc2UgYWRqYWNlbnQgdGV4dE5vZGVzOiBmaXhlcyBhbiBJRSBpc3N1ZSB0aGF0IGNhbiBjYXVzZVxuICAgICAgICAvLyB0ZXh0IG5vZGVzIHRvIGJlIGluZXhwbGljYWJseSBzcGxpdCA9KFxuICAgICAgICAvLyBub3RlIHRoYXQgcm9vdC5ub3JtYWxpemUoKSBzaG91bGQgd29yayBidXQgZG9lcyBub3Qgc28gd2UgZG8gdGhpc1xuICAgICAgICAvLyBtYW51YWxseS5cbiAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIGxldCAvKiogTm9kZSAqLyBuID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAobiAmJiAobi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpKSB7XG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ICs9IG4udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBuZXh0ID0gbi5uZXh0U2libGluZztcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgICAgICBuID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3B0aW9uYWxseSBzdHJpcCB3aGl0ZXNwYWNlXG4gICAgICAgICAgaWYgKHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UgJiYgIW5vZGUudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZEluZm8gPSB7IHBhcmVudEluZGV4LCBwYXJlbnRJbmZvOiBub2RlSW5mbyB9O1xuICAgICAgICBpZiAodGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBjaGlsZEluZm8pKSB7XG4gICAgICAgICAgY2hpbGRJbmZvLmluZm9JbmRleCA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QucHVzaCgvKiogQHR5cGUgeyFOb2RlSW5mb30gKi8oY2hpbGRJbmZvKSkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluY3JlbWVudCBpZiBub3QgcmVtb3ZlZFxuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgcGFyZW50SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBjb250ZW50IGZvciB0aGUgZ2l2ZW4gbmVzdGVkIGA8dGVtcGxhdGU+YC5cbiAgICAgKlxuICAgICAqIE5lc3RlZCB0ZW1wbGF0ZSBpbmZvIGlzIHN0b3JlZCBhcyBgdGVtcGxhdGVJbmZvYCBpbiB0aGUgY3VycmVudCBub2RlJ3NcbiAgICAgKiBgbm9kZUluZm9gLiBgdGVtcGxhdGUuY29udGVudGAgaXMgcmVtb3ZlZCBhbmQgc3RvcmVkIGluIGB0ZW1wbGF0ZUluZm9gLlxuICAgICAqIEl0IHdpbGwgdGhlbiBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGhvc3QgdG8gc2V0IGl0IGJhY2sgdG8gdGhlXG4gICAgICogdGVtcGxhdGUgYW5kIGZvciB1c2VycyBzdGFtcGluZyBuZXN0ZWQgdGVtcGxhdGVzIHRvIHVzZSB0aGVcbiAgICAgKiBgX2NvbnRlbnRGb3JUZW1wbGF0ZWAgbWV0aG9kIHRvIHJldHJpZXZlIHRoZSBjb250ZW50IGZvciB0aGlzIHRlbXBsYXRlXG4gICAgICogKGFuIG9wdGltaXphdGlvbiB0byBhdm9pZCB0aGUgY29zdCBvZiBjbG9uaW5nIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlIChhIDx0ZW1wbGF0ZT4pXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogICB0aGF0IGluY2x1ZGVzIHRoZSB0ZW1wbGF0ZSBgbm9kZWBcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgb3V0ZXJUZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5fcGFyc2VUZW1wbGF0ZShub2RlLCBvdXRlclRlbXBsYXRlSW5mbyk7XG4gICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlSW5mby5jb250ZW50ID1cbiAgICAgICAgbm9kZS5jb250ZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlLmNvbnRlbnQpO1xuICAgICAgbm9kZUluZm8udGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIG5vZGUgYXR0cmlidXRlcyBhbmQgYWRkcyBub2RlIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKiBmb3Igbm9kZXMgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAvLyBNYWtlIGNvcHkgb2Ygb3JpZ2luYWwgYXR0cmlidXRlIGxpc3QsIHNpbmNlIHRoZSBvcmRlciBtYXkgY2hhbmdlXG4gICAgICAvLyBhcyBhdHRyaWJ1dGVzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZFxuICAgICAgbGV0IG5vdGVkID0gZmFsc2U7XG4gICAgICBsZXQgYXR0cnMgPSBBcnJheS5mcm9tKG5vZGUuYXR0cmlidXRlcyk7XG4gICAgICBmb3IgKGxldCBpPWF0dHJzLmxlbmd0aC0xLCBhOyAoYT1hdHRyc1tpXSk7IGktLSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGEubmFtZSwgYS52YWx1ZSkgfHwgbm90ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc2luZ2xlIHRlbXBsYXRlIG5vZGUgYXR0cmlidXRlIGFuZCBhZGRzIG5vZGUgbWV0YWRhdGEgdG9cbiAgICAgKiBgbm9kZUluZm9gIGZvciBhdHRyaWJ1dGVzIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBhZGRzIG1ldGFkYXRhIGZvciBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIGF0dHJpYnV0ZXNcbiAgICAgKiBhbmQgYGlkYCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAvLyBldmVudHMgKG9uLSopXG4gICAgICBpZiAobmFtZS5zbGljZSgwLCAzKSA9PT0gJ29uLScpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIG5vZGVJbmZvLmV2ZW50cyA9IG5vZGVJbmZvLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgbm9kZUluZm8uZXZlbnRzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUuc2xpY2UoMyksXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gc3RhdGljIGlkXG4gICAgICBlbHNlIGlmIChuYW1lID09PSAnaWQnKSB7XG4gICAgICAgIG5vZGVJbmZvLmlkID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBjb250ZW50YCBkb2N1bWVudCBmcmFnbWVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBQb2x5bWVyIHBlcmZvcm1zIGFuIG9wdGltaXphdGlvbiB0byBjYWNoZSBuZXN0ZWRcbiAgICAgKiB0ZW1wbGF0ZSBjb250ZW50IHRvIGF2b2lkIHRoZSBjb3N0IG9mIGNsb25pbmcgZGVlcGx5IG5lc3RlZCB0ZW1wbGF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgcmV0cmlldmVzIHRoZSBjYWNoZWQgY29udGVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcmV0cmlldmUgYGNvbnRlbnRgIGZvclxuICAgICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9IENvbnRlbnQgZnJhZ21lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NvbnRlbnRGb3JUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudFdpdGhJbmZvfSAqLyAodGVtcGxhdGUpLl90ZW1wbGF0ZUluZm87XG4gICAgICByZXR1cm4gKHRlbXBsYXRlSW5mbyAmJiB0ZW1wbGF0ZUluZm8uY29udGVudCkgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGNvbnRlbnQgYW5kIHJldHVybnMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqIGNvbnRhaW5pbmcgdGhlIGNsb25lZCBkb20uXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgaXMgcGFyc2VkIChvbmNlIGFuZCBtZW1vaXplZCkgdXNpbmcgdGhpcyBsaWJyYXJ5J3NcbiAgICAgKiB0ZW1wbGF0ZSBwYXJzaW5nIGZlYXR1cmVzLCBhbmQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyB2YWx1ZS1hZGRlZFxuICAgICAqIGZlYXR1cmVzOlxuICAgICAqICogQWRkcyBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAqICogR2VuZXJhdGVzIGFuIFwiaWQgbWFwXCIgZm9yIGFsbCBub2RlcyB3aXRoIGlkJ3MgdW5kZXIgYCRgIG9uIHJldHVybmVkXG4gICAgICogICBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqICogUGFzc2VzIHRlbXBsYXRlIGluZm8gaW5jbHVkaW5nIGBjb250ZW50YCBiYWNrIHRvIHRlbXBsYXRlcyBhc1xuICAgICAqICAgYF90ZW1wbGF0ZUluZm9gIChhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0byBhdm9pZCBkZWVwIHRlbXBsYXRlXG4gICAgICogICBjbG9uaW5nKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBtZW1vaXplZCB0ZW1wbGF0ZSBwYXJzaW5nIHByb2Nlc3MgaXMgZGVzdHJ1Y3RpdmUgdG8gdGhlXG4gICAgICogdGVtcGxhdGU6IGF0dHJpYnV0ZXMgZm9yIGJpbmRpbmdzIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgYXJlXG4gICAgICogcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiBub3RlcywgYW5kIGFueSBuZXN0ZWQgYDx0ZW1wbGF0ZT4uY29udGVudGBcbiAgICAgKiBpcyByZW1vdmVkIGFuZCBzdG9yZWQgaW4gbm90ZXMgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgKi9cbiAgICBfc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgLy8gUG9seWZpbGwgc3VwcG9ydDogYm9vdHN0cmFwIHRoZSB0ZW1wbGF0ZSBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlblxuICAgICAgaWYgKHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb250ZW50ICYmXG4gICAgICAgICAgd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQgJiYgSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSkge1xuICAgICAgICBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKHRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGxldCBub2RlSW5mbyA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3Q7XG4gICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlSW5mby5jb250ZW50IHx8IHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgICBsZXQgZG9tID0gLyoqIEB0eXBlIERvY3VtZW50RnJhZ21lbnQgKi8gKGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSkpO1xuICAgICAgLy8gTk9URTogU2hhZHlEb20gb3B0aW1pemF0aW9uIGluZGljYXRpbmcgdGhlcmUgaXMgYW4gaW5zZXJ0aW9uIHBvaW50XG4gICAgICBkb20uX19ub0luc2VydGlvblBvaW50ID0gIXRlbXBsYXRlSW5mby5oYXNJbnNlcnRpb25Qb2ludDtcbiAgICAgIGxldCBub2RlcyA9IGRvbS5ub2RlTGlzdCA9IG5ldyBBcnJheShub2RlSW5mby5sZW5ndGgpO1xuICAgICAgZG9tLiQgPSB7fTtcbiAgICAgIGZvciAobGV0IGk9MCwgbD1ub2RlSW5mby5sZW5ndGgsIGluZm87IChpPGwpICYmIChpbmZvPW5vZGVJbmZvW2ldKTsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV0gPSBmaW5kVGVtcGxhdGVOb2RlKGRvbSwgaW5mbyk7XG4gICAgICAgIGFwcGx5SWRUb01hcCh0aGlzLCBkb20uJCwgbm9kZSwgaW5mbyk7XG4gICAgICAgIGFwcGx5VGVtcGxhdGVDb250ZW50KHRoaXMsIG5vZGUsIGluZm8pO1xuICAgICAgICBhcHBseUV2ZW50TGlzdGVuZXIodGhpcywgbm9kZSwgaW5mbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHshU3RhbXBlZFRlbXBsYXRlfSAqLyhkb20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgYnkgbWV0aG9kIG5hbWUgZm9yIHRoZSBldmVudCBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBhIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCBsb29rcyB1cCB0aGUgbWV0aG9kXG4gICAgICogbmFtZSBhdCBoYW5kbGluZyB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYWRkIGxpc3RlbmVyIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2RcbiAgICAgKiBAcGFyYW0geyo9fSBjb250ZXh0IENvbnRleHQgdGhlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiAoZGVmYXVsdHNcbiAgICAgKiAgIHRvIGBub2RlYClcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gR2VuZXJhdGVkIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG5vZGU7XG4gICAgICBsZXQgaGFuZGxlciA9IGNyZWF0ZU5vZGVFdmVudEhhbmRsZXIoY29udGV4dCwgZXZlbnROYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFkZCBldmVudCBsaXN0ZW5lciB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gYWRkXG4gICAgICovXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBwb2ludCBmb3IgYWRkaW5nIGN1c3RvbSBvciBzaW11bGF0ZWQgZXZlbnQgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gICAgICovXG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFRlbXBsYXRlU3RhbXA7XG5cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy90ZW1wbGF0ZS1zdGFtcC5qcyIsIm1vZHVsZS5leHBvcnRzID0gXCI8c3R5bGU+XFxuICBociB7XFxuICAgICAgYm9yZGVyOiAwLjVweCBzb2xpZDtcXG4gIH1cXG48L3N0eWxlPlxcblxcbjxkaXY+W1t0ZXh0XV08L2Rpdj5cXG5cXG48aHI+XFxuXCJcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL2VsZW1lbnRzL3R0YS11bmRlcmxpbmVkLXRleHQvdHRhLXVuZGVybGluZWQtdGV4dC5odG1sXG4vLyBtb2R1bGUgaWQgPSA0OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9