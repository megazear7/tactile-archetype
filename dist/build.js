/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 53);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_legacy_legacy_element_mixin_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_legacy_templatizer_behavior_js__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_elements_dom_bind_js__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_elements_dom_repeat_js__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__lib_elements_dom_if_js__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__lib_elements_array_selector_js__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__lib_elements_custom_style_js__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__lib_legacy_mutable_data_behavior_js__ = __webpack_require__(72);









const Base = Object(__WEBPACK_IMPORTED_MODULE_0__lib_legacy_legacy_element_mixin_js__["a" /* LegacyElementMixin */])(HTMLElement).prototype;
/* harmony export (immutable) */ __webpack_exports__["a"] = Base;



/***/ }),
/* 1 */
/***/ (function(module, exports) {

window.JSCompiler_renameProperty = function(prop, obj) { return prop; }

/** @namespace */
let Polymer;


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomApi */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return matchesSelector; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_flattened_nodes_observer_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__ = __webpack_require__(28);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["b"]; });
/* unused harmony reexport addDebouncer */





const p = Element.prototype;
/**
 * @const {function(this:Element, string): boolean}
 */
const normalizedMatchesSelector = p.matches || p.matchesSelector ||
  p.mozMatchesSelector || p.msMatchesSelector ||
  p.oMatchesSelector || p.webkitMatchesSelector;

/**
 * Cross-platform `element.matches` shim.
 *
 * @function matchesSelector
 * @memberof Polymer.dom
 * @param {!Element} node Node to check selector against
 * @param {string} selector Selector to match
 * @return {boolean} True if node matched selector
 */
const matchesSelector = function(node, selector) {
  return normalizedMatchesSelector.call(node, selector);
};

/**
 * Node API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is a `Node`.
 */
class DomApi {

  /**
   * @param {Node} node Node for which to create a Polymer.dom helper object.
   */
  constructor(node) {
    this.node = node;
  }

  /**
   * Returns an instance of `Polymer.FlattenedNodesObserver` that
   * listens for node changes on this element.
   *
   * @param {Function} callback Called when direct or distributed children
   *   of this element changes
   * @return {Polymer.FlattenedNodesObserver} Observer instance
   */
  observeNodes(callback) {
    return new __WEBPACK_IMPORTED_MODULE_2__utils_flattened_nodes_observer_js__["a" /* FlattenedNodesObserver */](this.node, callback);
  }

  /**
   * Disconnects an observer previously created via `observeNodes`
   *
   * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
   *   to disconnect.
   */
  unobserveNodes(observerHandle) {
    observerHandle.disconnect();
  }

  /**
   * Provided as a backwards-compatible API only.  This method does nothing.
   */
  notifyObserver() {}

  /**
   * Returns true if the provided node is contained with this element's
   * light-DOM children or shadow root, including any nested shadow roots
   * of children therein.
   *
   * @param {Node} node Node to test
   * @return {boolean} Returns true if the given `node` is contained within
   *   this element's light or shadow DOM.
   */
  deepContains(node) {
    if (this.node.contains(node)) {
      return true;
    }
    let n = node;
    let doc = node.ownerDocument;
    // walk from node to `this` or `document`
    while (n && n !== doc && n !== this.node) {
      // use logical parentnode, or native ShadowRoot host
      n = n.parentNode || n.host;
    }
    return n === this.node;
  }

  /**
   * Returns the root node of this node.  Equivalent to `getRoodNode()`.
   *
   * @return {Node} Top most element in the dom tree in which the node
   * exists. If the node is connected to a document this is either a
   * shadowRoot or the document; otherwise, it may be the node
   * itself or a node or document fragment containing it.
   */
  getOwnerRoot() {
    return this.node.getRootNode();
  }

  /**
   * For slot elements, returns the nodes assigned to the slot; otherwise
   * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
   *
   * @return {Array<Node>} Array of assigned nodes
   */
  getDistributedNodes() {
    return (this.node.localName === 'slot') ?
      this.node.assignedNodes({flatten: true}) :
      [];
  }

  /**
   * Returns an array of all slots this element was distributed to.
   *
   * @return {Array<HTMLSlotElement>} Description
   */
  getDestinationInsertionPoints() {
    let ip$ = [];
    let n = this.node.assignedSlot;
    while (n) {
      ip$.push(n);
      n = n.assignedSlot;
    }
    return ip$;
  }

  /**
   * Calls `importNode` on the `ownerDocument` for this node.
   *
   * @param {Node} node Node to import
   * @param {boolean} deep True if the node should be cloned deeply during
   *   import
   * @return {Node} Clone of given node imported to this owner document
   */
  importNode(node, deep) {
    let doc = this.node instanceof Document ? this.node :
      this.node.ownerDocument;
    return doc.importNode(node, deep);
  }

  /**
   * @return {Array} Returns a flattened list of all child nodes and nodes assigned
   * to child slots.
   */
  getEffectiveChildNodes() {
    return __WEBPACK_IMPORTED_MODULE_2__utils_flattened_nodes_observer_js__["a" /* FlattenedNodesObserver */].getFlattenedNodes(this.node);
  }

  /**
   * Returns a filtered list of flattened child elements for this element based
   * on the given selector.
   *
   * @param {string} selector Selector to filter nodes against
   * @return {Array<HTMLElement>} List of flattened child elements
   */
  queryDistributedElements(selector) {
    let c$ = this.getEffectiveChildNodes();
    let list = [];
    for (let i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
      if ((c.nodeType === Node.ELEMENT_NODE) &&
          matchesSelector(c, selector)) {
        list.push(c);
      }
    }
    return list;
  }

  /**
   * For shadow roots, returns the currently focused element within this
   * shadow root.
   *
   * @return {Node|undefined} Currently focused element
   */
  get activeElement() {
    let node = this.node;
    return node._activeElement !== undefined ? node._activeElement : node.activeElement;
  }
}

function forwardMethods(proto, methods) {
  for (let i=0; i < methods.length; i++) {
    let method = methods[i];
    proto[method] = /** @this {DomApi} */ function() {
      return this.node[method].apply(this.node, arguments);
    };
  }
}

function forwardReadOnlyProperties(proto, properties) {
  for (let i=0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        return /** @type {DomApi} */ (this).node[name];
      },
      configurable: true
    });
  }
}

function forwardProperties(proto, properties) {
  for (let i=0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        return /** @type {DomApi} */ (this).node[name];
      },
      set: function(value) {
        /** @type {DomApi} */ (this).node[name] = value;
      },
      configurable: true
    });
  }
}

forwardMethods(DomApi.prototype, [
  'cloneNode', 'appendChild', 'insertBefore', 'removeChild',
  'replaceChild', 'setAttribute', 'removeAttribute',
  'querySelector', 'querySelectorAll'
]);

forwardReadOnlyProperties(DomApi.prototype, [
  'parentNode', 'firstChild', 'lastChild',
  'nextSibling', 'previousSibling', 'firstElementChild',
  'lastElementChild', 'nextElementSibling', 'previousElementSibling',
  'childNodes', 'children', 'classList'
]);

forwardProperties(DomApi.prototype, [
  'textContent', 'innerHTML'
]);


/**
 * Event API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is an `Event`.
 */
class EventApi {
  constructor(event) {
    this.event = event;
  }

  /**
   * Returns the first node on the `composedPath` of this event.
   *
   * @return {Node} The node this event was dispatched to
   */
  get rootTarget() {
    return this.event.composedPath()[0];
  }

  /**
   * Returns the local (re-targeted) target for this event.
   *
   * @return {Node} The local (re-targeted) target for this event.
   */
  get localTarget() {
    return this.event.target;
  }

  /**
   * Returns the `composedPath` for this event.
   */
  get path() {
    return this.event.composedPath();
  }
}



const dom = function(obj) {
  obj = obj || document;
  if (!obj.__domApi) {
    let helper;
    if (obj instanceof Event) {
      helper = new EventApi(obj);
    } else {
      helper = new DomApi(obj);
    }
    obj.__domApi = helper;
  }
  return obj.__domApi;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = dom;







/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__class_js__ = __webpack_require__(64);


const Polymer = function(info) {
  // if input is a `class` (aka a function with a prototype), use the prototype
  // remember that the `constructor` will never be called
  let klass;
  if (typeof info === 'function') {
    klass = info;
  } else {
    klass = Object(__WEBPACK_IMPORTED_MODULE_0__class_js__["a" /* Class */])(info);
  }
  customElements.define(klass.is, /** @type {!HTMLElement} */(klass));
  return klass;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = Polymer;



/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


// unique global id for deduping mixins.
let dedupeId = 0;

/**
 * @constructor
 * @extends {Function}
 */
function MixinFunction(){}
/** @type {(WeakMap | undefined)} */
MixinFunction.prototype.__mixinApplications;
/** @type {(Object | undefined)} */
MixinFunction.prototype.__mixinSet;

const dedupingMixin = function(mixin) {
  let mixinApplications = /** @type {!MixinFunction} */(mixin).__mixinApplications;
  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    /** @type {!MixinFunction} */(mixin).__mixinApplications = mixinApplications;
  }
  // maintain a unique id for each mixin
  let mixinDedupeId = dedupeId++;
  function dedupingMixin(base) {
    let baseSet = /** @type {!MixinFunction} */(base).__mixinSet;
    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }
    let map = mixinApplications;
    let extended = map.get(base);
    if (!extended) {
      extended = /** @type {!Function} */(mixin)(base);
      map.set(base, extended);
    }
    // copy inherited mixin set from the extended class, or the base class
    // NOTE: we avoid use of Set here because some browser (IE11)
    // cannot extend a base Set via the constructor.
    let mixinSet = Object.create(/** @type {!MixinFunction} */(extended).__mixinSet || baseSet || null);
    mixinSet[mixinDedupeId] = true;
    /** @type {!MixinFunction} */(extended).__mixinSet = mixinSet;
    return extended;
  }

  return dedupingMixin;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = dedupingMixin;



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Element; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_mixins_element_mixin_js__ = __webpack_require__(24);


/**
 * Base class that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @constructor
 * @implements {Polymer_ElementMixin}
 * @extends HTMLElement
 * @appliesMixin Polymer.ElementMixin
 * @summary Custom element base class that provides the core API for Polymer's
 *   key meta-programming features including template stamping, data-binding,
 *   attribute deserialization, and property change observation
 */
const Element = Object(__WEBPACK_IMPORTED_MODULE_0__lib_mixins_element_mixin_js__["a" /* ElementMixin */])(HTMLElement);



/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
let AsyncInterface; // eslint-disable-line no-unused-vars

// Microtask implemented using Mutation Observer
let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});

function microtaskFlush() {
  const len = microtaskCallbacks.length;
  for (let i = 0; i < len; i++) {
    let cb = microtaskCallbacks[i];
    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(() => { throw e; });
      }
    }
  }
  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}

const timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} delay Time to wait before calling callbacks in ms
   * @return {AsyncInterface} An async timeout interface
   */
  after(delay) {
    return  {
      run(fn) { return setTimeout(fn, delay); },
      cancel: window.clearTimeout.bind(window)
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof Polymer.Async.timeOut
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.setTimeout.bind(window),
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.clearTimeout.bind(window)
};
/* harmony export (immutable) */ __webpack_exports__["b"] = timeOut;


const animationFrame = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof Polymer.Async.animationFrame
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.requestAnimationFrame.bind(window),
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.cancelAnimationFrame.bind(window)
};
/* unused harmony export animationFrame */


const idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {function(IdleDeadline)} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestIdleCallback ?
      window.requestIdleCallback(fn) :
      window.setTimeout(fn, 16);
  },
  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel(handle) {
    window.cancelIdleCallback ?
      window.cancelIdleCallback(handle) :
      window.clearTimeout(handle);
  }
};
/* unused harmony export idlePeriod */


const microTask = {

  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof Polymer.Async.microTask
   * @param {Function} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    microtaskNode.textContent = microtaskNodeContent++;
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },

  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof Polymer.Async.microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle;
    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }
      microtaskCallbacks[idx] = null;
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = microTask;



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["dashToCamelCase"] = dashToCamelCase;
/* harmony export (immutable) */ __webpack_exports__["camelToDashCase"] = camelToDashCase;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


const caseMap = {};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH = /([A-Z])/g;

function dashToCamelCase(dash) {
  return caseMap[dash] || (
    caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL,
      (m) => m[1].toUpperCase()
    )
  );
}

function camelToDashCase(camel) {
  return caseMap[camel] || (
    caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase()
  );
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(46);


const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {
      /*
       * You can use these generic variables in your elements for easy theming.
       * For example, if all your elements use \`--primary-text-color\` as its main
       * color, then switching from a light to a dark theme is just a matter of
       * changing the value of \`--primary-text-color\` in your application.
       */
      --primary-text-color: var(--light-theme-text-color);
      --primary-background-color: var(--light-theme-background-color);
      --secondary-text-color: var(--light-theme-secondary-color);
      --disabled-text-color: var(--light-theme-disabled-color);
      --divider-color: var(--light-theme-divider-color);
      --error-color: var(--paper-deep-orange-a700);

      /*
       * Primary and accent colors. Also see color.html for more colors.
       */
      --primary-color: var(--paper-indigo-500);
      --light-primary-color: var(--paper-indigo-100);
      --dark-primary-color: var(--paper-indigo-700);

      --accent-color: var(--paper-pink-a200);
      --light-accent-color: var(--paper-pink-a100);
      --dark-accent-color: var(--paper-pink-a400);


      /*
       * Material Design Light background theme
       */
      --light-theme-background-color: #ffffff;
      --light-theme-base-color: #000000;
      --light-theme-text-color: var(--paper-grey-900);
      --light-theme-secondary-color: #737373;  /* for secondary text and icons */
      --light-theme-disabled-color: #9b9b9b;  /* disabled/hint text */
      --light-theme-divider-color: #dbdbdb;

      /*
       * Material Design Dark background theme
       */
      --dark-theme-background-color: var(--paper-grey-900);
      --dark-theme-base-color: #ffffff;
      --dark-theme-text-color: #ffffff;
      --dark-theme-secondary-color: #bcbcbc;  /* for secondary text and icons */
      --dark-theme-disabled-color: #646464;  /* disabled/hint text */
      --dark-theme-divider-color: #3c3c3c;

      /*
       * Deprecated values because of their confusing names.
       */
      --text-primary-color: var(--dark-theme-text-color);
      --default-primary-color: var(--primary-color);
    }
  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      --layout: {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
      };

      --layout-inline: {
        display: -ms-inline-flexbox;
        display: -webkit-inline-flex;
        display: inline-flex;
      };

      --layout-horizontal: {
        @apply --layout;

        -ms-flex-direction: row;
        -webkit-flex-direction: row;
        flex-direction: row;
      };

      --layout-horizontal-reverse: {
        @apply --layout;

        -ms-flex-direction: row-reverse;
        -webkit-flex-direction: row-reverse;
        flex-direction: row-reverse;
      };

      --layout-vertical: {
        @apply --layout;

        -ms-flex-direction: column;
        -webkit-flex-direction: column;
        flex-direction: column;
      };

      --layout-vertical-reverse: {
        @apply --layout;

        -ms-flex-direction: column-reverse;
        -webkit-flex-direction: column-reverse;
        flex-direction: column-reverse;
      };

      --layout-wrap: {
        -ms-flex-wrap: wrap;
        -webkit-flex-wrap: wrap;
        flex-wrap: wrap;
      };

      --layout-wrap-reverse: {
        -ms-flex-wrap: wrap-reverse;
        -webkit-flex-wrap: wrap-reverse;
        flex-wrap: wrap-reverse;
      };

      --layout-flex-auto: {
        -ms-flex: 1 1 auto;
        -webkit-flex: 1 1 auto;
        flex: 1 1 auto;
      };

      --layout-flex-none: {
        -ms-flex: none;
        -webkit-flex: none;
        flex: none;
      };

      --layout-flex: {
        -ms-flex: 1 1 0.000000001px;
        -webkit-flex: 1;
        flex: 1;
        -webkit-flex-basis: 0.000000001px;
        flex-basis: 0.000000001px;
      };

      --layout-flex-2: {
        -ms-flex: 2;
        -webkit-flex: 2;
        flex: 2;
      };

      --layout-flex-3: {
        -ms-flex: 3;
        -webkit-flex: 3;
        flex: 3;
      };

      --layout-flex-4: {
        -ms-flex: 4;
        -webkit-flex: 4;
        flex: 4;
      };

      --layout-flex-5: {
        -ms-flex: 5;
        -webkit-flex: 5;
        flex: 5;
      };

      --layout-flex-6: {
        -ms-flex: 6;
        -webkit-flex: 6;
        flex: 6;
      };

      --layout-flex-7: {
        -ms-flex: 7;
        -webkit-flex: 7;
        flex: 7;
      };

      --layout-flex-8: {
        -ms-flex: 8;
        -webkit-flex: 8;
        flex: 8;
      };

      --layout-flex-9: {
        -ms-flex: 9;
        -webkit-flex: 9;
        flex: 9;
      };

      --layout-flex-10: {
        -ms-flex: 10;
        -webkit-flex: 10;
        flex: 10;
      };

      --layout-flex-11: {
        -ms-flex: 11;
        -webkit-flex: 11;
        flex: 11;
      };

      --layout-flex-12: {
        -ms-flex: 12;
        -webkit-flex: 12;
        flex: 12;
      };

      /* alignment in cross axis */

      --layout-start: {
        -ms-flex-align: start;
        -webkit-align-items: flex-start;
        align-items: flex-start;
      };

      --layout-center: {
        -ms-flex-align: center;
        -webkit-align-items: center;
        align-items: center;
      };

      --layout-end: {
        -ms-flex-align: end;
        -webkit-align-items: flex-end;
        align-items: flex-end;
      };

      --layout-baseline: {
        -ms-flex-align: baseline;
        -webkit-align-items: baseline;
        align-items: baseline;
      };

      /* alignment in main axis */

      --layout-start-justified: {
        -ms-flex-pack: start;
        -webkit-justify-content: flex-start;
        justify-content: flex-start;
      };

      --layout-center-justified: {
        -ms-flex-pack: center;
        -webkit-justify-content: center;
        justify-content: center;
      };

      --layout-end-justified: {
        -ms-flex-pack: end;
        -webkit-justify-content: flex-end;
        justify-content: flex-end;
      };

      --layout-around-justified: {
        -ms-flex-pack: distribute;
        -webkit-justify-content: space-around;
        justify-content: space-around;
      };

      --layout-justified: {
        -ms-flex-pack: justify;
        -webkit-justify-content: space-between;
        justify-content: space-between;
      };

      --layout-center-center: {
        @apply --layout-center;
        @apply --layout-center-justified;
      };

      /* self alignment */

      --layout-self-start: {
        -ms-align-self: flex-start;
        -webkit-align-self: flex-start;
        align-self: flex-start;
      };

      --layout-self-center: {
        -ms-align-self: center;
        -webkit-align-self: center;
        align-self: center;
      };

      --layout-self-end: {
        -ms-align-self: flex-end;
        -webkit-align-self: flex-end;
        align-self: flex-end;
      };

      --layout-self-stretch: {
        -ms-align-self: stretch;
        -webkit-align-self: stretch;
        align-self: stretch;
      };

      --layout-self-baseline: {
        -ms-align-self: baseline;
        -webkit-align-self: baseline;
        align-self: baseline;
      };

      /* multi-line alignment in main axis */

      --layout-start-aligned: {
        -ms-flex-line-pack: start;  /* IE10 */
        -ms-align-content: flex-start;
        -webkit-align-content: flex-start;
        align-content: flex-start;
      };

      --layout-end-aligned: {
        -ms-flex-line-pack: end;  /* IE10 */
        -ms-align-content: flex-end;
        -webkit-align-content: flex-end;
        align-content: flex-end;
      };

      --layout-center-aligned: {
        -ms-flex-line-pack: center;  /* IE10 */
        -ms-align-content: center;
        -webkit-align-content: center;
        align-content: center;
      };

      --layout-between-aligned: {
        -ms-flex-line-pack: justify;  /* IE10 */
        -ms-align-content: space-between;
        -webkit-align-content: space-between;
        align-content: space-between;
      };

      --layout-around-aligned: {
        -ms-flex-line-pack: distribute;  /* IE10 */
        -ms-align-content: space-around;
        -webkit-align-content: space-around;
        align-content: space-around;
      };

      /*******************************
                Other Layout
      *******************************/

      --layout-block: {
        display: block;
      };

      --layout-invisible: {
        visibility: hidden !important;
      };

      --layout-relative: {
        position: relative;
      };

      --layout-fit: {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      };

      --layout-scroll: {
        -webkit-overflow-scrolling: touch;
        overflow: auto;
      };

      --layout-fullbleed: {
        margin: 0;
        height: 100vh;
      };

      /* fixed position */

      --layout-fixed-top: {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
      };

      --layout-fixed-right: {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
      };

      --layout-fixed-bottom: {
        position: fixed;
        right: 0;
        bottom: 0;
        left: 0;
      };

      --layout-fixed-left: {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
      };

    }
  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return settings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return rootPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return sanitizeDOMValue; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__resolve_url_js__ = __webpack_require__(11);



/**
 * Legacy settings.
 * @namespace
 * @memberof Polymer
 */
const settings = undefined || {};
const useShadow = !(window.ShadyDOM);
/* unused harmony export useShadow */

const useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
/* unused harmony export useNativeCSSProperties */

const useNativeCustomElements = !(window.customElements.polyfillWrapFlushCallback);
/* unused harmony export useNativeCustomElements */



/**
 * Globally settable property that is automatically assigned to
 * `Polymer.ElementMixin` instances, useful for binding in templates to
 * make URL's relative to an application's root.  Defaults to the main
 * document URL, but can be overridden by users.  It may be useful to set
 * `Polymer.rootPath` to provide a stable application mount path when
 * using client side routing.
 *
 * @memberof Polymer
 */
let rootPath = undefined ||
  Object(__WEBPACK_IMPORTED_MODULE_1__resolve_url_js__["a" /* pathFromUrl */])(document.baseURI || window.location.href);



const setRootPath = function(path) {
  rootPath = path;
};
/* unused harmony export setRootPath */


/**
 * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:
 *
 *     Polymer = {
 *       sanitizeDOMValue: function(value, name, type, node) { ... }
 *     }
 *
 * Where:
 *
 * `value` is the value to sanitize.
 * `name` is the name of an attribute or property (for example, href).
 * `type` indicates where the value is being inserted: one of property, attribute, or text.
 * `node` is the node where the value is being inserted.
 *
 * @type {(function(*,string,string,Node):*)|undefined}
 * @memberof Polymer
 */
let sanitizeDOMValue = undefined;



const setSanitizeDOMValue = function(newSanitizeDOMValue) {
  sanitizeDOMValue = newSanitizeDOMValue;
};
/* unused harmony export setSanitizeDOMValue */



/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return resolveCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return resolveUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return pathFromUrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  // Lazy feature detection.
  if (workingURL === undefined) {
    workingURL = false;
    try {
      const u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = (u.href === 'http://a/c%20d');
    } catch (e) {
      // silently fail
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    return (new URL(url, baseURI)).href;
  }
  // Fallback to creating an anchor into a disconnected document.
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;

}

/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
    return pre + '\'' +
      resolveUrl(url.replace(/["']/g, ''), baseURI) +
      '\'' + post;
  });
}

/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}






/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = isPath;
/* harmony export (immutable) */ __webpack_exports__["g"] = root;
/* harmony export (immutable) */ __webpack_exports__["b"] = isAncestor;
/* harmony export (immutable) */ __webpack_exports__["c"] = isDescendant;
/* harmony export (immutable) */ __webpack_exports__["i"] = translate;
/* harmony export (immutable) */ __webpack_exports__["e"] = matches;
/* harmony export (immutable) */ __webpack_exports__["f"] = normalize;
/* unused harmony export split */
/* harmony export (immutable) */ __webpack_exports__["a"] = get;
/* harmony export (immutable) */ __webpack_exports__["h"] = set;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


function isPath(path) {
  return path.indexOf('.') >= 0;
}

function root(path) {
  let dotIndex = path.indexOf('.');
  if (dotIndex === -1) {
    return path;
  }
  return path.slice(0, dotIndex);
}

function isAncestor(base, path) {
  //     base.startsWith(path + '.');
  return base.indexOf(path + '.') === 0;
}

function isDescendant(base, path) {
  //     path.startsWith(base + '.');
  return path.indexOf(base + '.') === 0;
}

function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}

function matches(base, path) {
  return (base === path) ||
         isAncestor(base, path) ||
         isDescendant(base, path);
}

function normalize(path) {
  if (Array.isArray(path)) {
    let parts = [];
    for (let i=0; i<path.length; i++) {
      let args = path[i].toString().split('.');
      for (let j=0; j<args.length; j++) {
        parts.push(args[j]);
      }
    }
    return parts.join('.');
  } else {
    return path;
  }
}

function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split('.');
  }
  return path.toString().split('.');
}

function get(root, path, info) {
  let prop = root;
  let parts = split(path);
  // Loop over path parts[0..n-1] and dereference
  for (let i=0; i<parts.length; i++) {
    if (!prop) {
      return;
    }
    let part = parts[i];
    prop = prop[part];
  }
  if (info) {
    info.path = parts.join('.');
  }
  return prop;
}

function set(root, path, value) {
  let prop = root;
  let parts = split(path);
  let last = parts[parts.length-1];
  if (parts.length > 1) {
    // Loop over path parts[0..n-2] and dereference
    for (let i=0; i<parts.length-1; i++) {
      let part = parts[i];
      prop = prop[part];
      if (!prop) {
        return;
      }
    }
    // Set value to object at end of path
    prop[last] = value;
  } else {
    // Simple property set
    prop[path] = value;
  }
  return parts.join('.');
}

const isDeep = isPath;
/* unused harmony export isDeep */



/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["deepTargetFind"] = deepTargetFind;
/* harmony export (immutable) */ __webpack_exports__["_findOriginalTarget"] = _findOriginalTarget;
/* harmony export (immutable) */ __webpack_exports__["_handleNative"] = _handleNative;
/* harmony export (immutable) */ __webpack_exports__["_handleTouchAction"] = _handleTouchAction;
/* harmony export (immutable) */ __webpack_exports__["addListener"] = addListener;
/* harmony export (immutable) */ __webpack_exports__["removeListener"] = removeListener;
/* harmony export (immutable) */ __webpack_exports__["_add"] = _add;
/* harmony export (immutable) */ __webpack_exports__["_remove"] = _remove;
/* harmony export (immutable) */ __webpack_exports__["register"] = register;
/* harmony export (immutable) */ __webpack_exports__["_findRecognizerByEvent"] = _findRecognizerByEvent;
/* harmony export (immutable) */ __webpack_exports__["setTouchAction"] = setTouchAction;
/* harmony export (immutable) */ __webpack_exports__["_fire"] = _fire;
/* harmony export (immutable) */ __webpack_exports__["prevent"] = prevent;
/* harmony export (immutable) */ __webpack_exports__["resetMouseCanceller"] = resetMouseCanceller;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__async_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__debounce_js__ = __webpack_require__(14);




// detect native touch action support
let HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
let GESTURE_KEY = '__polymerGestures';
let HANDLED_OBJ = '__polymerGesturesHandled';
let TOUCH_ACTION = '__polymerGesturesTouchAction';
// radius for tap and track
let TAP_DISTANCE = 25;
let TRACK_DISTANCE = 5;
// number of last N track positions to keep
let TRACK_LENGTH = 2;

// Disabling "mouse" handlers for 2500ms is enough
let MOUSE_TIMEOUT = 2500;
let MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
let MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
let MOUSE_HAS_BUTTONS = (function() {
  try {
    return new MouseEvent('test', {buttons: 1}).buttons === 1;
  } catch (e) {
    return false;
  }
})();

/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
// check for passive event listeners
let SUPPORTS_PASSIVE = false;
(function() {
  try {
    let opts = Object.defineProperty({}, 'passive', {get: function() {SUPPORTS_PASSIVE = true;}});
    window.addEventListener('test', null, opts);
    window.removeEventListener('test', null, opts);
  } catch(e) {}
})();

// Check for touch-only devices
let IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

let GestureRecognizer = function(){}; // eslint-disable-line no-unused-vars
GestureRecognizer.prototype.reset = function(){};
/** @type {function(MouseEvent) | undefined} */
GestureRecognizer.prototype.mousedown;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mousemove;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mouseup;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchstart;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchmove;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchend;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.click;

// touch will make synthetic mouse events
// `preventDefault` on touchend will cancel them,
// but this breaks `<input>` focus and link clicks
// disable mouse handlers for MOUSE_TIMEOUT ms after
// a touchend to ignore synthetic mouse events
let mouseCanceller = function(mouseEvent) {
  // Check for sourceCapabilities, used to distinguish synthetic events
  // if mouseEvent did not come from a device that fires touch events,
  // it was made by a real mouse and should be counted
  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
  let sc = mouseEvent.sourceCapabilities;
  if (sc && !sc.firesTouchEvents) {
    return;
  }
  // skip synthetic mouse events
  mouseEvent[HANDLED_OBJ] = {skip: true};
  // disable "ghost clicks"
  if (mouseEvent.type === 'click') {
    let path = mouseEvent.composedPath && mouseEvent.composedPath();
    if (path) {
      for (let i = 0; i < path.length; i++) {
        if (path[i] === POINTERSTATE.mouse.target) {
          return;
        }
      }
    }
    mouseEvent.preventDefault();
    mouseEvent.stopPropagation();
  }
};

/**
 * @param {boolean=} setup True to add, false to remove.
 */
function setupTeardownMouseCanceller(setup) {
  let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
  for (let i = 0, en; i < events.length; i++) {
    en = events[i];
    if (setup) {
      document.addEventListener(en, mouseCanceller, true);
    } else {
      document.removeEventListener(en, mouseCanceller, true);
    }
  }
}

function ignoreMouse(e) {
  if (!POINTERSTATE.mouse.mouseIgnoreJob) {
    setupTeardownMouseCanceller(true);
  }
  let unset = function() {
    setupTeardownMouseCanceller();
    POINTERSTATE.mouse.target = null;
    POINTERSTATE.mouse.mouseIgnoreJob = null;
  };
  POINTERSTATE.mouse.target = e.composedPath()[0];
  POINTERSTATE.mouse.mouseIgnoreJob = __WEBPACK_IMPORTED_MODULE_2__debounce_js__["a" /* Debouncer */].debounce(
        POINTERSTATE.mouse.mouseIgnoreJob
      , __WEBPACK_IMPORTED_MODULE_1__async_js__["b" /* timeOut */].after(MOUSE_TIMEOUT)
      , unset);
}

/**
 * @param {MouseEvent} ev event to test for left mouse button down
 * @return {boolean} has left mouse button down
 */
function hasLeftMouseButton(ev) {
  let type = ev.type;
  // exit early if the event is not a mouse event
  if (MOUSE_EVENTS.indexOf(type) === -1) {
    return false;
  }
  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
  if (type === 'mousemove') {
    // allow undefined for testing events
    let buttons = ev.buttons === undefined ? 1 : ev.buttons;
    if ((ev instanceof window.MouseEvent) && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    // buttons is a bitmask, check that the left button bit is set (1)
    return Boolean(buttons & 1);
  } else {
    // allow undefined for testing events
    let button = ev.button === undefined ? 0 : ev.button;
    // ev.button is 0 in mousedown/mouseup/click for left button activation
    return button === 0;
  }
}

function isSyntheticClick(ev) {
  if (ev.type === 'click') {
    // ev.detail is 0 for HTMLElement.click in most browsers
    if (ev.detail === 0) {
      return true;
    }
    // in the worst case, check that the x/y position of the click is within
    // the bounding box of the target of the event
    // Thanks IE 10 >:(
    let t = _findOriginalTarget(ev);
    // make sure the target of the event is an element so we can use getBoundingClientRect,
    // if not, just assume it is a synthetic click
    if (!t.nodeType || /** @type {Element} */(t).nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    let bcr = /** @type {Element} */(t).getBoundingClientRect();
    // use page x/y to account for scrolling
    let x = ev.pageX, y = ev.pageY;
    // ev is a synthetic click if the position is outside the bounding box of the target
    return !((x >= bcr.left && x <= bcr.right) && (y >= bcr.top && y <= bcr.bottom));
  }
  return false;
}

let POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};

function firstTouchAction(ev) {
  let ta = 'auto';
  let path = ev.composedPath && ev.composedPath();
  if (path) {
    for (let i = 0, n; i < path.length; i++) {
      n = path[i];
      if (n[TOUCH_ACTION]) {
        ta = n[TOUCH_ACTION];
        break;
      }
    }
  }
  return ta;
}

function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener('mousemove', movefn);
  document.addEventListener('mouseup', upfn);
}

function untrackDocument(stateObj) {
  document.removeEventListener('mousemove', stateObj.movefn);
  document.removeEventListener('mouseup', stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}

// use a document-wide touchend listener to start the ghost-click prevention mechanism
// Use passive event listeners, if supported, to not affect scrolling performance
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? {passive: true} : false);

const gestures = {};
/* harmony export (immutable) */ __webpack_exports__["gestures"] = gestures;

const recognizers = [];
/* harmony export (immutable) */ __webpack_exports__["recognizers"] = recognizers;


function deepTargetFind(x, y) {
  let node = document.elementFromPoint(x, y);
  let next = node;
  // this code path is only taken when native ShadowDOM is used
  // if there is a shadowroot, it may have a node at x/y
  // if there is not a shadowroot, exit the loop
  while (next && next.shadowRoot && !window.ShadyDOM) {
    // if there is a node at x/y in the shadowroot, look deeper
    let oldNext = next;
    next = next.shadowRoot.elementFromPoint(x, y);
    // on Safari, elementFromPoint may return the shadowRoot host
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}

function _findOriginalTarget(ev) {
  // shadowdom
  if (ev.composedPath) {
    return /** @type {EventTarget} */(ev.composedPath()[0]);
  }
  // shadydom
  return ev.target;
}

function _handleNative(ev) {
  let handled;
  let type = ev.type;
  let node = ev.currentTarget;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  let gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.slice(0, 5) === 'touch') {
      ev = /** @type {TouchEvent} */(ev); // eslint-disable-line no-self-assign
      let t = ev.changedTouches[0];
      if (type === 'touchstart') {
        // only handle the first finger
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === 'touchstart' || type === 'touchmove') {
          _handleTouchAction(ev);
        }
      }
    }
  }
  handled = ev[HANDLED_OBJ];
  // used to ignore synthetic mouse events
  if (handled.skip) {
    return;
  }
  // reset recognizer state
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  // enforce gesture recognizer order
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      handled[r.name] = true;
      r[type](ev);
    }
  }
}

function _handleTouchAction(ev) {
  let t = ev.changedTouches[0];
  let type = ev.type;
  if (type === 'touchstart') {
    POINTERSTATE.touch.x = t.clientX;
    POINTERSTATE.touch.y = t.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === 'touchmove') {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    let ta = firstTouchAction(ev);
    let prevent = false;
    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
    if (!ev.cancelable) {
      // scrolling is happening
    } else if (ta === 'none') {
      prevent = true;
    } else if (ta === 'pan-x') {
      prevent = dy > dx;
    } else if (ta === 'pan-y') {
      prevent = dx > dy;
    }
    if (prevent) {
      ev.preventDefault();
    } else {
      prevent('track');
    }
  }
}

function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}

function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}

function _add(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (let i = 0, dep, gd; i < deps.length; i++) {
    dep = deps[i];
    // don't add mouse handlers on iOS because they cause gray selection overlays
    if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = {_count: 0};
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative);
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}

function _remove(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (gobj) {
    for (let i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative);
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}

function register(recog) {
  recognizers.push(recog);
  for (let i = 0; i < recog.emits.length; i++) {
    gestures[recog.emits[i]] = recog;
  }
}

function _findRecognizerByEvent(evName) {
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    for (let j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}

function setTouchAction(node, value) {
  if (HAS_NATIVE_TA) {
    node.style.touchAction = value;
  }
  node[TOUCH_ACTION] = value;
}

function _fire(target, type, detail) {
  let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  target.dispatchEvent(ev);
  // forward `preventDefault` in a clean way
  if (ev.defaultPrevented) {
    let preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}

function prevent(evName) {
  let recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}

function resetMouseCanceller() {
  if (POINTERSTATE.mouse.mouseIgnoreJob) {
    POINTERSTATE.mouse.mouseIgnoreJob.flush();
  }
}

/* eslint-disable valid-jsdoc */

register({
  name: 'downup',
  deps: ['mousedown', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['down', 'up'],

  info: {
    movefn: null,
    upfn: null
  },

  /** @this {GestureRecognizer} */
  reset: function() {
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn(e) {
      if (!hasLeftMouseButton(e)) {
        self._fire('up', t, e);
        untrackDocument(self.info);
      }
    };
    let upfn = function upfn(e) {
      if (hasLeftMouseButton(e)) {
        self._fire('up', t, e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    this._fire('down', t, e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function(e) {
    this._fire('down', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function(e) {
    this._fire('up', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @param {string} type
   * @param {EventTarget} target
   * @param {Event} event
   * @param {Function} preventer
   */
  _fire: function(type, target, event, preventer) {
    _fire(target, type, {
      x: event.clientX,
      y: event.clientY,
      sourceEvent: event,
      preventer: preventer,
      prevent: function(e) {
        return prevent(e);
      }
    });
  }
});

register({
  name: 'track',
  touchAction: 'none',
  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['track'],

  info: {
    x: 0,
    y: 0,
    state: 'start',
    started: false,
    moves: [],
    /** @this {GestureRecognizer} */
    addMove: function(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },

  /** @this {GestureRecognizer} */
  reset: function() {
    this.info.state = 'start';
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {number} x
   * @param {number} y
   * @return {boolean}
   */
  hasMovedEnough: function(x, y) {
    if (this.info.prevent) {
      return false;
    }
    if (this.info.started) {
      return true;
    }
    let dx = Math.abs(this.info.x - x);
    let dy = Math.abs(this.info.y - y);
    return (dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn(e) {
      let x = e.clientX, y = e.clientY;
      if (self.hasMovedEnough(x, y)) {
        // first move is 'start', subsequent moves are 'move', mouseup is 'end'
        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';
        if (self.info.state === 'start') {
          // if and only if tracking, always prevent tap
          prevent('tap');
        }
        self.info.addMove({x: x, y: y});
        if (!hasLeftMouseButton(e)) {
          // always _fire "end"
          self.info.state = 'end';
          untrackDocument(self.info);
        }
        self._fire(t, e);
        self.info.started = true;
      }
    };
    let upfn = function upfn(e) {
      if (self.info.started) {
        movefn(e);
      }

      // remove the temporary listeners
      untrackDocument(self.info);
    };
    // add temporary document listeners as mouse retargets
    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function(e) {
    let ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchmove: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    let x = ct.clientX, y = ct.clientY;
    if (this.hasMovedEnough(x, y)) {
      if (this.info.state === 'start') {
        // if and only if tracking, always prevent tap
        prevent('tap');
      }
      this.info.addMove({x: x, y: y});
      this._fire(t, ct);
      this.info.state = 'track';
      this.info.started = true;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    // only trackend if track was started and not aborted
    if (this.info.started) {
      // reset started state on up
      this.info.state = 'end';
      this.info.addMove({x: ct.clientX, y: ct.clientY});
      this._fire(t, ct, e);
    }
  },

  /**
   * @this {GestureRecognizer}
   * @param {EventTarget} target
   * @param {Touch} touch
   */
  _fire: function(target, touch) {
    let secondlast = this.info.moves[this.info.moves.length - 2];
    let lastmove = this.info.moves[this.info.moves.length - 1];
    let dx = lastmove.x - this.info.x;
    let dy = lastmove.y - this.info.y;
    let ddx, ddy = 0;
    if (secondlast) {
      ddx = lastmove.x - secondlast.x;
      ddy = lastmove.y - secondlast.y;
    }
    _fire(target, 'track', {
      state: this.info.state,
      x: touch.clientX,
      y: touch.clientY,
      dx: dx,
      dy: dy,
      ddx: ddx,
      ddy: ddy,
      sourceEvent: touch,
      hover: function() {
        return deepTargetFind(touch.clientX, touch.clientY);
      }
    });
  }

});

register({
  name: 'tap',
  deps: ['mousedown', 'click', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['click', 'touchend']
  },
  emits: ['tap'],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  /** @this {GestureRecognizer} */
  reset: function() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  /** @this {GestureRecognizer} */
  save: function(e) {
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function(e) {
    if (hasLeftMouseButton(e)) {
      this.save(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  click: function(e) {
    if (hasLeftMouseButton(e)) {
      this.forward(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function(e) {
    this.save(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function(e) {
    this.forward(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {Event | Touch} e
   * @param {Event=} preventer
   */
  forward: function(e, preventer) {
    let dx = Math.abs(e.clientX - this.info.x);
    let dy = Math.abs(e.clientY - this.info.y);
    // find original target from `preventer` for TouchEvents, or `e` for MouseEvents
    let t = _findOriginalTarget((preventer || e));
    // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
    if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {
      // prevent taps from being generated if an event has canceled them
      if (!this.info.prevent) {
        _fire(t, 'tap', {
          x: e.clientX,
          y: e.clientY,
          sourceEvent: e,
          preventer: preventer
        });
      }
    }
  }
});

const findOriginalTarget = _findOriginalTarget;
/* harmony export (immutable) */ __webpack_exports__["findOriginalTarget"] = findOriginalTarget;

const add = addListener;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;

const remove = removeListener;
/* harmony export (immutable) */ __webpack_exports__["remove"] = remove;



/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Debouncer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__async_js__ = __webpack_require__(6);




/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
let AsyncModule; // eslint-disable-line no-unused-vars

/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 * @memberof Polymer
 */
class Debouncer {
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncModule} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   */
  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   */
  cancel() {
    if (this.isActive()) {
      this._asyncModule.cancel(this._timer);
      this._timer = null;
    }
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   */
  flush() {
    if (this.isActive()) {
      this.cancel();
      this._callback();
    }
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
/**
 * Creates a debouncer if no debouncer is passed as a parameter
 * or it cancels an active debouncer otherwise. The following
 * example shows how a debouncer can be called multiple times within a
 * microtask and "debounced" such that the provided callback function is
 * called once. Add this method to a custom element:
 *
 * _debounceWork() {
 *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
 *       Polymer.Async.microTask, () => {
 *     this._doWork();
 *   });
 * }
 *
 * If the `_debounceWork` method is called multiple times within the same
 * microtask, the `_doWork` function will be called only once at the next
 * microtask checkpoint.
 *
 * Note: In testing it is often convenient to avoid asynchrony. To accomplish
 * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
 * `Polymer.flush`. For example, extend the above example by adding
 * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
 * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
 * the debouncer has completed.
 *
 * @param {Debouncer?} debouncer Debouncer object.
 * @param {!AsyncModule} asyncModule Object with Async interface
 * @param {function()} callback Callback to run.
 * @return {!Debouncer} Returns a debouncer object.
 */
  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer) {
      debouncer.cancel();
    } else {
      debouncer = new Debouncer();
    }
    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }
}




/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_mixin_js__ = __webpack_require__(4);


// Common implementation for mixin & behavior
function mutablePropertyChange(inst, property, value, old, mutableData) {
  let isObject;
  if (mutableData) {
    isObject = (typeof value === 'object' && value !== null);
    // Pull `old` for Objects from temp cache, but treat `null` as a primitive
    if (isObject) {
      old = inst.__dataTemp[property];
    }
  }
  // Strict equality check, but return false for NaN===NaN
  let shouldChange = (old !== value && (old === old || value === value));
  // Objects are stored in temporary cache (cleared at end of
  // turn), which is used for dirty-checking
  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }
  return shouldChange;
}

const MutableData = Object(__WEBPACK_IMPORTED_MODULE_0__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_MutableData}
   */
  class MutableData extends superClass {
    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }

  }
  /** @type {boolean} */
  MutableData.prototype.mutableData = false;

  return MutableData;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = MutableData;


const OptionalMutableData = Object(__WEBPACK_IMPORTED_MODULE_0__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @mixinClass
   * @polymer
   * @implements {Polymer_OptionalMutableData}
   */
  class OptionalMutableData extends superClass {

    static get properties() {
      return {
        /**
         * Instance-level flag for configuring the dirty-checking strategy
         * for this element.  When true, Objects and Arrays will skip dirty
         * checking, otherwise strict equality checking will be used.
         */
        mutableData: Boolean
      };
    }

    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * When `this.mutableData` is true on this instance, this method
     * pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  }

  return OptionalMutableData;

});
/* harmony export (immutable) */ __webpack_exports__["b"] = OptionalMutableData;


// Export for use by legacy behavior
MutableData._mutablePropertyChange = mutablePropertyChange;


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);


/**
 * Chrome uses an older version of DOM Level 3 Keyboard Events
 *
 * Most keys are labeled as text, but some are Unicode codepoints.
 * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
 */
var KEY_IDENTIFIER = {
  'U+0008': 'backspace',
  'U+0009': 'tab',
  'U+001B': 'esc',
  'U+0020': 'space',
  'U+007F': 'del'
};

/**
 * Special table for KeyboardEvent.keyCode.
 * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
 * than that.
 *
 * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
 */
var KEY_CODE = {
  8: 'backspace',
  9: 'tab',
  13: 'enter',
  27: 'esc',
  33: 'pageup',
  34: 'pagedown',
  35: 'end',
  36: 'home',
  32: 'space',
  37: 'left',
  38: 'up',
  39: 'right',
  40: 'down',
  46: 'del',
  106: '*'
};

/**
 * MODIFIER_KEYS maps the short name for modifier keys used in a key
 * combo string to the property name that references those same keys
 * in a KeyboardEvent instance.
 */
var MODIFIER_KEYS = {
  'shift': 'shiftKey',
  'ctrl': 'ctrlKey',
  'alt': 'altKey',
  'meta': 'metaKey'
};

/**
 * KeyboardEvent.key is mostly represented by printable character made by
 * the keyboard, with unprintable keys labeled nicely.
 *
 * However, on OS X, Alt+char can make a Unicode character that follows an
 * Apple-specific mapping. In this case, we fall back to .keyCode.
 */
var KEY_CHAR = /[a-z0-9*]/;

/**
 * Matches a keyIdentifier string.
 */
var IDENT_CHAR = /U\+/;

/**
 * Matches arrow keys in Gecko 27.0+
 */
var ARROW_KEY = /^arrow/;

/**
 * Matches space keys everywhere (notably including IE10's exceptional name
 * `spacebar`).
 */
var SPACE_KEY = /^space(bar)?/;

/**
 * Matches ESC key.
 *
 * Value from: http://w3c.github.io/uievents-key/#key-Escape
 */
var ESC_KEY = /^escape$/;

/**
 * Transforms the key.
 * @param {string} key The KeyBoardEvent.key
 * @param {Boolean} [noSpecialChars] Limits the transformation to
 * alpha-numeric characters.
 */
function transformKey(key, noSpecialChars) {
  var validKey = '';
  if (key) {
    var lKey = key.toLowerCase();
    if (lKey === ' ' || SPACE_KEY.test(lKey)) {
      validKey = 'space';
    } else if (ESC_KEY.test(lKey)) {
      validKey = 'esc';
    } else if (lKey.length == 1) {
      if (!noSpecialChars || KEY_CHAR.test(lKey)) {
        validKey = lKey;
      }
    } else if (ARROW_KEY.test(lKey)) {
      validKey = lKey.replace('arrow', '');
    } else if (lKey == 'multiply') {
      // numpad '*' can map to Multiply on IE/Windows
      validKey = '*';
    } else {
      validKey = lKey;
    }
  }
  return validKey;
}

function transformKeyIdentifier(keyIdent) {
  var validKey = '';
  if (keyIdent) {
    if (keyIdent in KEY_IDENTIFIER) {
      validKey = KEY_IDENTIFIER[keyIdent];
    } else if (IDENT_CHAR.test(keyIdent)) {
      keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
      validKey = String.fromCharCode(keyIdent).toLowerCase();
    } else {
      validKey = keyIdent.toLowerCase();
    }
  }
  return validKey;
}

function transformKeyCode(keyCode) {
  var validKey = '';
  if (Number(keyCode)) {
    if (keyCode >= 65 && keyCode <= 90) {
      // ascii a-z
      // lowercase is 32 offset from uppercase
      validKey = String.fromCharCode(32 + keyCode);
    } else if (keyCode >= 112 && keyCode <= 123) {
      // function keys f1-f12
      validKey = 'f' + (keyCode - 112 + 1);
    } else if (keyCode >= 48 && keyCode <= 57) {
      // top 0-9 keys
      validKey = String(keyCode - 48);
    } else if (keyCode >= 96 && keyCode <= 105) {
      // num pad 0-9
      validKey = String(keyCode - 96);
    } else {
      validKey = KEY_CODE[keyCode];
    }
  }
  return validKey;
}

/**
  * Calculates the normalized key for a KeyboardEvent.
  * @param {KeyboardEvent} keyEvent
  * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
  * transformation to alpha-numeric chars. This is useful with key
  * combinations like shift + 2, which on FF for MacOS produces
  * keyEvent.key = @
  * To get 2 returned, set noSpecialChars = true
  * To get @ returned, set noSpecialChars = false
 */
function normalizedKeyForEvent(keyEvent, noSpecialChars) {
  // Fall back from .key, to .detail.key for artifical keyboard events,
  // and then to deprecated .keyIdentifier and .keyCode.
  if (keyEvent.key) {
    return transformKey(keyEvent.key, noSpecialChars);
  }
  if (keyEvent.detail && keyEvent.detail.key) {
    return transformKey(keyEvent.detail.key, noSpecialChars);
  }
  return transformKeyIdentifier(keyEvent.keyIdentifier) ||
    transformKeyCode(keyEvent.keyCode) || '';
}

function keyComboMatchesEvent(keyCombo, event) {
  // For combos with modifiers we support only alpha-numeric keys
  var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
  return keyEvent === keyCombo.key &&
    (!keyCombo.hasModifiers || (
      !!event.shiftKey === !!keyCombo.shiftKey &&
      !!event.ctrlKey === !!keyCombo.ctrlKey &&
      !!event.altKey === !!keyCombo.altKey &&
      !!event.metaKey === !!keyCombo.metaKey)
    );
}

function parseKeyComboString(keyComboString) {
  if (keyComboString.length === 1) {
    return {
      combo: keyComboString,
      key: keyComboString,
      event: 'keydown'
    };
  }
  return keyComboString.split('+').reduce(function(parsedKeyCombo, keyComboPart) {
    var eventParts = keyComboPart.split(':');
    var keyName = eventParts[0];
    var event = eventParts[1];

    if (keyName in MODIFIER_KEYS) {
      parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
      parsedKeyCombo.hasModifiers = true;
    } else {
      parsedKeyCombo.key = keyName;
      parsedKeyCombo.event = event || 'keydown';
    }

    return parsedKeyCombo;
  }, {
    combo: keyComboString.split(':').shift()
  });
}

function parseEventString(eventString) {
  return eventString.trim().split(' ').map(function(keyComboString) {
    return parseKeyComboString(keyComboString);
  });
}

const IronA11yKeysBehavior = {
  properties: {
    /**
     * The EventTarget that will be firing relevant KeyboardEvents. Set it to
     * `null` to disable the listeners.
     * @type {?EventTarget}
     */
    keyEventTarget: {
      type: Object,
      value: function() {
        return this;
      }
    },

    /**
     * If true, this property will cause the implementing element to
     * automatically stop propagation on any handled KeyboardEvents.
     */
    stopKeyboardEventPropagation: {
      type: Boolean,
      value: false
    },

    _boundKeyHandlers: {
      type: Array,
      value: function() {
        return [];
      }
    },

    // We use this due to a limitation in IE10 where instances will have
    // own properties of everything on the "prototype".
    _imperativeKeyBindings: {
      type: Object,
      value: function() {
        return {};
      }
    }
  },

  observers: [
    '_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'
  ],


  /**
   * To be used to express what combination of keys  will trigger the relative
   * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
   * @type {!Object}
   */
  keyBindings: {},

  registered: function() {
    this._prepKeyBindings();
  },

  attached: function() {
    this._listenKeyEventListeners();
  },

  detached: function() {
    this._unlistenKeyEventListeners();
  },

  /**
   * Can be used to imperatively add a key binding to the implementing
   * element. This is the imperative equivalent of declaring a keybinding
   * in the `keyBindings` prototype property.
   *
   * @param {string} eventString
   * @param {string} handlerName
   */
  addOwnKeyBinding: function(eventString, handlerName) {
    this._imperativeKeyBindings[eventString] = handlerName;
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * When called, will remove all imperatively-added key bindings.
   */
  removeOwnKeyBindings: function() {
    this._imperativeKeyBindings = {};
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * Returns true if a keyboard event matches `eventString`.
   *
   * @param {KeyboardEvent} event
   * @param {string} eventString
   * @return {boolean}
   */
  keyboardEventMatchesKeys: function(event, eventString) {
    var keyCombos = parseEventString(eventString);
    for (var i = 0; i < keyCombos.length; ++i) {
      if (keyComboMatchesEvent(keyCombos[i], event)) {
        return true;
      }
    }
    return false;
  },

  _collectKeyBindings: function() {
    var keyBindings = this.behaviors.map(function(behavior) {
      return behavior.keyBindings;
    });

    if (keyBindings.indexOf(this.keyBindings) === -1) {
      keyBindings.push(this.keyBindings);
    }

    return keyBindings;
  },

  _prepKeyBindings: function() {
    this._keyBindings = {};

    this._collectKeyBindings().forEach(function(keyBindings) {
      for (var eventString in keyBindings) {
        this._addKeyBinding(eventString, keyBindings[eventString]);
      }
    }, this);

    for (var eventString in this._imperativeKeyBindings) {
      this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
    }

    // Give precedence to combos with modifiers to be checked first.
    for (var eventName in this._keyBindings) {
      this._keyBindings[eventName].sort(function (kb1, kb2) {
        var b1 = kb1[0].hasModifiers;
        var b2 = kb2[0].hasModifiers;
        return (b1 === b2) ? 0 : b1 ? -1 : 1;
      })
    }
  },

  _addKeyBinding: function(eventString, handlerName) {
    parseEventString(eventString).forEach(function(keyCombo) {
      this._keyBindings[keyCombo.event] =
        this._keyBindings[keyCombo.event] || [];

      this._keyBindings[keyCombo.event].push([
        keyCombo,
        handlerName
      ]);
    }, this);
  },

  _resetKeyEventListeners: function() {
    this._unlistenKeyEventListeners();

    if (this.isAttached) {
      this._listenKeyEventListeners();
    }
  },

  _listenKeyEventListeners: function() {
    if (!this.keyEventTarget) {
      return;
    }
    Object.keys(this._keyBindings).forEach(function(eventName) {
      var keyBindings = this._keyBindings[eventName];
      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

      this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
    }, this);
  },

  _unlistenKeyEventListeners: function() {
    var keyHandlerTuple;
    var keyEventTarget;
    var eventName;
    var boundKeyHandler;

    while (this._boundKeyHandlers.length) {
      // My kingdom for block-scope binding and destructuring assignment..
      keyHandlerTuple = this._boundKeyHandlers.pop();
      keyEventTarget = keyHandlerTuple[0];
      eventName = keyHandlerTuple[1];
      boundKeyHandler = keyHandlerTuple[2];

      keyEventTarget.removeEventListener(eventName, boundKeyHandler);
    }
  },

  _onKeyBindingEvent: function(keyBindings, event) {
    if (this.stopKeyboardEventPropagation) {
      event.stopPropagation();
    }

    // if event has been already prevented, don't do anything
    if (event.defaultPrevented) {
      return;
    }

    for (var i = 0; i < keyBindings.length; i++) {
      var keyCombo = keyBindings[i][0];
      var handlerName = keyBindings[i][1];
      if (keyComboMatchesEvent(keyCombo, event)) {
        this._triggerKeyHandler(keyCombo, handlerName, event);
        // exit the loop if eventDefault was prevented
        if (event.defaultPrevented) {
          return;
        }
      }
    }
  },

  _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {
    var detail = Object.create(keyCombo);
    detail.keyboardEvent = keyboardEvent;
    var event = new CustomEvent(keyCombo.event, {
      detail: detail,
      cancelable: true
    });
    this[handlerName].call(this, event);
    if (event.defaultPrevented) {
      keyboardEvent.preventDefault();
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronA11yKeysBehavior;



/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__font_roboto_roboto_js__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__font_roboto_roboto_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__font_roboto_roboto_js__);


const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      /* Shared Styles */
      --paper-font-common-base: {
        font-family: 'Roboto', 'Noto', sans-serif;
        -webkit-font-smoothing: antialiased;
      };

      --paper-font-common-code: {
        font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
        -webkit-font-smoothing: antialiased;
      };

      --paper-font-common-expensive-kerning: {
        text-rendering: optimizeLegibility;
      };

      --paper-font-common-nowrap: {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      };

      /* Material Font Styles */

      --paper-font-display4: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 112px;
        font-weight: 300;
        letter-spacing: -.044em;
        line-height: 120px;
      };

      --paper-font-display3: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 56px;
        font-weight: 400;
        letter-spacing: -.026em;
        line-height: 60px;
      };

      --paper-font-display2: {
        @apply --paper-font-common-base;

        font-size: 45px;
        font-weight: 400;
        letter-spacing: -.018em;
        line-height: 48px;
      };

      --paper-font-display1: {
        @apply --paper-font-common-base;

        font-size: 34px;
        font-weight: 400;
        letter-spacing: -.01em;
        line-height: 40px;
      };

      --paper-font-headline: {
        @apply --paper-font-common-base;

        font-size: 24px;
        font-weight: 400;
        letter-spacing: -.012em;
        line-height: 32px;
      };

      --paper-font-title: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 20px;
        font-weight: 500;
        line-height: 28px;
      };

      --paper-font-subhead: {
        @apply --paper-font-common-base;

        font-size: 16px;
        font-weight: 400;
        line-height: 24px;
      };

      --paper-font-body2: {
        @apply --paper-font-common-base;

        font-size: 14px;
        font-weight: 500;
        line-height: 24px;
      };

      --paper-font-body1: {
        @apply --paper-font-common-base;

        font-size: 14px;
        font-weight: 400;
        line-height: 20px;
      };

      --paper-font-caption: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 12px;
        font-weight: 400;
        letter-spacing: 0.011em;
        line-height: 20px;
      };

      --paper-font-menu: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 13px;
        font-weight: 500;
        line-height: 24px;
      };

      --paper-font-button: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 14px;
        font-weight: 500;
        letter-spacing: 0.018em;
        line-height: 24px;
        text-transform: uppercase;
      };

      --paper-font-code2: {
        @apply --paper-font-common-code;

        font-size: 14px;
        font-weight: 700;
        line-height: 20px;
      };

      --paper-font-code1: {
        @apply --paper-font-common-code;

        font-size: 14px;
        font-weight: 500;
        line-height: 20px;
      };

    }

  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




const IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function() {
        return !this.shadowRoot && !__WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */];
      }
    }
  },

  observers: [
    '_changedControlState(focused, disabled)'
  ],

  ready: function() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (__WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */]) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */(Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).localTarget);
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, {sourceEvent: event}, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronControlState;



/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_ripple_paper_ripple_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_button_state_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





const PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object,
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_button_state_js__["b" /* IronButtonStateImpl */]._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this._rippleContainer || this);
        var target = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */(target))) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function() {
    return /** @type {!PaperRippleElement} */ (
        document.createElement('paper-ripple'));
  },

  _noinkChanged: function(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperRippleBehavior;



/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return nativeShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return nativeCssVariables; });
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



let nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
let nativeCssVariables;

/**
 * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings
 */
function calcCssVariables(settings) {
  if (settings && settings['shimcssproperties']) {
    nativeCssVariables = false;
  } else {
    // chrome 49 has semi-working css vars, check if box-shadow works
    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
    // However, shim css custom properties are only supported with ShadyDOM enabled,
    // so fall back on native if we do not detect ShadyDOM
    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/
    nativeCssVariables = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) &&
      window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));
  }
}

if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {
  nativeCssVariables = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS);
  // reset window variable to let ShadyCSS API take its place
  window.ShadyCSS = undefined;
} else {
  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
}

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export StyleNode */
/* harmony export (immutable) */ __webpack_exports__["a"] = parse;
/* harmony export (immutable) */ __webpack_exports__["b"] = stringify;
/* unused harmony export removeCustomPropAssignment */
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/*
Extremely simple css parser. Intended to be not more than what we need
and definitely not necessarily correct =).
*/



/** @unrestricted */
class StyleNode {
  constructor() {
    /** @type {number} */
    this['start'] = 0;
    /** @type {number} */
    this['end'] = 0;
    /** @type {StyleNode} */
    this['previous'] = null;
    /** @type {StyleNode} */
    this['parent'] = null;
    /** @type {Array<StyleNode>} */
    this['rules'] = null;
    /** @type {string} */
    this['parsedCssText'] = '';
    /** @type {string} */
    this['cssText'] = '';
    /** @type {boolean} */
    this['atRule'] = false;
    /** @type {number} */
    this['type'] = 0;
    /** @type {string} */
    this['keyframesName'] = '';
    /** @type {string} */
    this['selector'] = '';
    /** @type {string} */
    this['parsedSelector'] = '';
  }
}



// given a string of css, return a simple rule tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function parse(text) {
  text = clean(text);
  return parseCss(lex(text), text);
}

// remove stuff we don't care about that may hinder parsing
/**
 * @param {string} cssText
 * @return {string}
 */
function clean(cssText) {
  return cssText.replace(RX.comments, '').replace(RX.port, '');
}

// super simple {...} lexer that returns a node tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function lex(text) {
  let root = new StyleNode();
  root['start'] = 0;
  root['end'] = text.length
  let n = root;
  for (let i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n['rules']) {
        n['rules'] = [];
      }
      let p = n;
      let previous = p['rules'][p['rules'].length - 1] || null;
      n = new StyleNode();
      n['start'] = i + 1;
      n['parent'] = p;
      n['previous'] = previous;
      p['rules'].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n['end'] = i + 1;
      n = n['parent'] || root;
    }
  }
  return root;
}

// add selectors/cssText to node tree
/**
 * @param {StyleNode} node
 * @param {string} text
 * @return {StyleNode}
 */
function parseCss(node, text) {
  let t = text.substring(node['start'], node['end'] - 1);
  node['parsedCssText'] = node['cssText'] = t.trim();
  if (node['parent']) {
    let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];
    t = text.substring(ss, node['start'] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, ' ');
    // TODO(sorvell): ad hoc; make selector include only after last ;
    // helps with mixin syntax
    t = t.substring(t.lastIndexOf(';') + 1);
    let s = node['parsedSelector'] = node['selector'] = t.trim();
    node['atRule'] = (s.indexOf(AT_START) === 0);
    // note, support a subset of rule types...
    if (node['atRule']) {
      if (s.indexOf(MEDIA_START) === 0) {
        node['type'] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node['type'] = types.KEYFRAMES_RULE;
        node['keyframesName'] =
          node['selector'].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node['type'] = types.MIXIN_RULE;
      } else {
        node['type'] = types.STYLE_RULE;
      }
    }
  }
  let r$ = node['rules'];
  if (r$) {
    for (let i = 0, l = r$.length, r;
      (i < l) && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }
  return node;
}

/**
 * conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
 * expanded form that doesn't require trailing space `\000033`
 * @param {string} s
 * @return {string}
 */
function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
    let code = arguments[1],
      repeat = 6 - code.length;
    while (repeat--) {
      code = '0' + code;
    }
    return '\\' + code;
  });
}

/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */
function stringify(node, preserveProperties, text = '') {
  // calc rule cssText
  let cssText = '';
  if (node['cssText'] || node['rules']) {
    let r$ = node['rules'];
    if (r$ && !_hasMixinRules(r$)) {
      for (let i = 0, l = r$.length, r;
        (i < l) && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node['cssText'] :
        removeCustomProps(node['cssText']);
      cssText = cssText.trim();
      if (cssText) {
        cssText = '  ' + cssText + '\n';
      }
    }
  }
  // emit rule if there is cssText
  if (cssText) {
    if (node['selector']) {
      text += node['selector'] + ' ' + OPEN_BRACE + '\n';
    }
    text += cssText;
    if (node['selector']) {
      text += CLOSE_BRACE + '\n\n';
    }
  }
  return text;
}

/**
 * @param {Array<StyleNode>} rules
 * @return {boolean}
 */
function _hasMixinRules(rules) {
  let r = rules[0];
  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropAssignment(cssText) {
  return cssText
    .replace(RX.customProp, '')
    .replace(RX.mixinProp, '');
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropApply(cssText) {
  return cssText
    .replace(RX.mixinApply, '')
    .replace(RX.varApply, '');
}

/** @enum {number} */
const types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1000
}
/* harmony export (immutable) */ __webpack_exports__["c"] = types;


const OPEN_BRACE = '{';
const CLOSE_BRACE = '}';

// helper regexp's
const RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
}

const VAR_START = '--';
const MEDIA_START = '@media';
const AT_START = '@';


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
/* harmony export (immutable) */ __webpack_exports__["c"] = VAR_ASSIGN;

const MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
/* harmony export (immutable) */ __webpack_exports__["b"] = MIXIN_MATCH;

const VAR_CONSUMED = /(--[\w-]+)\s*([:,;)]|$)/gi;
/* unused harmony export VAR_CONSUMED */

const ANIMATION_MATCH = /(animation\s*:)|(animation-name\s*:)/;
/* unused harmony export ANIMATION_MATCH */

const MEDIA_MATCH = /@media\s(.*)/;
/* harmony export (immutable) */ __webpack_exports__["a"] = MEDIA_MATCH;

const IS_VAR = /^--/;
/* unused harmony export IS_VAR */

const BRACKETED = /\{[^}]*\}/g;
/* unused harmony export BRACKETED */

const HOST_PREFIX = '(?:^|[^.#[:])';
/* unused harmony export HOST_PREFIX */

const HOST_SUFFIX = '($|[.:[\\s>+~])';
/* unused harmony export HOST_SUFFIX */



/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = updateNativeProperties;
/* harmony export (immutable) */ __webpack_exports__["b"] = getComputedStyleValue;
/* harmony export (immutable) */ __webpack_exports__["a"] = detectMixin;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_regex_js__ = __webpack_require__(22);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/





/**
 * @param {Element} element
 * @param {Object=} properties
 */
function updateNativeProperties(element, properties) {
  // remove previous properties
  for (let p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}

/**
 * @param {Element} element
 * @param {string} property
 * @return {string}
 */
function getComputedStyleValue(element, property) {
  /**
   * @const {string}
   */
  const value = window.getComputedStyle(element).getPropertyValue(property);
  if (!value) {
    return '';
  } else {
    return value.trim();
  }
}

/**
 * return true if `cssText` contains a mixin definition or consumption
 * @param {string} cssText
 * @return {boolean}
 */
function detectMixin(cssText) {
  const has = __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["b" /* MIXIN_MATCH */].test(cssText) || __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["c" /* VAR_ASSIGN */].test(cssText);
  // reset state of the regexes
  __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["b" /* MIXIN_MATCH */].lastIndex = 0;
  __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["c" /* VAR_ASSIGN */].lastIndex = 0;
  return has;
}


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export instanceCount */
/* unused harmony export _regLog */
/* unused harmony export register */
/* unused harmony export dumpRegistrations */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__property_effects_js__ = __webpack_require__(26);










const ElementMixin = Object(__WEBPACK_IMPORTED_MODULE_2__utils_mixin_js__["a" /* dedupingMixin */])(base => {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_PropertyEffects}
   */
  const polymerElementBase = Object(__WEBPACK_IMPORTED_MODULE_7__property_effects_js__["a" /* PropertyEffects */])(base);

  let caseMap = __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__;

  /**
   * Returns the `properties` object specifically on `klass`. Use for:
   * (1) super chain mixes togther to make `propertiesForClass` which is
   * then used to make `observedAttributes`.
   * (2) properties effects and observers are created from it at `finalize` time.
   *
   * @param {HTMLElement} klass Element class
   * @return {Object} Object containing own properties for this class
   * @private
   */
  function ownPropertiesForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__ownProperties', klass))) {
      klass.__ownProperties =
        klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
        /** @type PolymerElementConstructor */ (klass).properties : {};
    }
    return klass.__ownProperties;
  }

  /**
   * Returns the `observers` array specifically on `klass`. Use for
   * setting up observers.
   *
   * @param {HTMLElement} klass Element class
   * @return {Array} Array containing own observers for this class
   * @private
   */
  function ownObserversForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__ownObservers', klass))) {
      klass.__ownObservers =
        klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
        /** @type PolymerElementConstructor */ (klass).observers : [];
    }
    return klass.__ownObservers;
  }

  /**
   * Mixes `props` into `flattenedProps` but upgrades shorthand type
   * syntax to { type: Type}.
   *
   * @param {Object} flattenedProps Bag to collect flattened properties into
   * @param {Object} props Bag of properties to add to `flattenedProps`
   * @return {Object} The input `flattenedProps` bag
   * @private
   */
  function flattenProperties(flattenedProps, props) {
    for (let p in props) {
      let o = props[p];
      if (typeof o == 'function') {
        o = { type: o };
      }
      flattenedProps[p] = o;
    }
    return flattenedProps;
  }

  /**
   * Returns a flattened list of properties mixed together from the chain of all
   * constructor's `config.properties`. This list is used to create
   * (1) observedAttributes,
   * (2) class property default values
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   * @suppress {missingProperties} class.prototype is not a property for some reason?
   * @private
   */
  function propertiesForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__classProperties', klass))) {
      klass.__classProperties =
      flattenProperties({}, ownPropertiesForClass(klass));
      let superCtor = Object.getPrototypeOf(klass.prototype).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        klass.__classProperties = Object.assign(
          Object.create(propertiesForClass(/** @type PolymerElementConstructor */(superCtor))),
          klass.__classProperties);
      }
    }
    return klass.__classProperties;
  }

  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `propertiesForClass`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */
  function propertyDefaultsForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
      klass.__classPropertyDefaults = null;
      let props = propertiesForClass(klass);
      for (let p in props) {
        let info = props[p];
        if ('value' in info) {
          klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
          klass.__classPropertyDefaults[p] = info;
        }
      }
    }
    return klass.__classPropertyDefaults;
  }

  /**
   * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
   * @param {PolymerElementConstructor} klass Element class
   * @return {boolean} True if all metaprogramming for this class has been
   *   completed
   * @private
   */
  function hasClassFinalized(klass) {
    return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
  }

  /**
   * Called by `ElementClass.finalize()`. Ensures this `klass` and
   * *all superclasses* are finalized by traversing the prototype chain
   * and calling `klass.finalize()`.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClassAndSuper(klass) {
    let proto = /** @type PolymerElementConstructor */ (klass).prototype;
    let superCtor = Object.getPrototypeOf(proto).constructor;
    if (superCtor.prototype instanceof PolymerElement) {
      superCtor.finalize();
    }
    finalizeClass(klass);
  }

  /**
   * Configures a `klass` based on a staic `klass.config` object and
   * a `template`. This includes creating accessors and effects
   * for properties in `config` and the `template` as well as preparing the
   * `template` for stamping.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClass(klass) {
    klass.__finalized = true;
    let proto = /** @type PolymerElementConstructor */ (klass).prototype;
    if (klass.hasOwnProperty(
      JSCompiler_renameProperty('is', klass)) && klass.is) {
      register(proto);
    }
    let props = ownPropertiesForClass(klass);
    if (props) {
      finalizeProperties(proto, props);
    }
    let observers = ownObserversForClass(klass);
    if (observers) {
      finalizeObservers(proto, observers, props);
    }
    // note: create "working" template that is finalized at instance time
    let template = /** @type PolymerElementConstructor */ (klass).template;
    if (template) {
      if (typeof template === 'string') {
        let t = document.createElement('template');
        t.innerHTML = template;
        template = t;
      } else {
        template = template.cloneNode(true);
      }
      proto._template = template;
    }
  }

  /**
   * Configures a `proto` based on a `properties` object.
   * Leverages `PropertyEffects` to create property accessors and effects
   * supporting, observers, reflecting to attributes, change notification,
   * computed properties, and read only properties.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *    and effects to
   * @param {Object} properties Flattened bag of property descriptors for
   *    this class
   * @private
   */
  function finalizeProperties(proto, properties) {
    for (let p in properties) {
      createPropertyFromConfig(proto, p, properties[p], properties);
    }
  }

  /**
   * Configures a `proto` based on a `observers` array.
   * Leverages `PropertyEffects` to create observers.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {Object} observers Flattened array of observer descriptors for
   *   this class
   * @param {Object} dynamicFns Object containing keys for any properties
   *   that are functions and should trigger the effect when the function
   *   reference is changed
   * @private
   */
  function finalizeObservers(proto, observers, dynamicFns) {
    for (let i=0; i < observers.length; i++) {
      proto._createMethodObserver(observers[i], dynamicFns);
    }
  }

  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should may contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is dersialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * also automatically is set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttriute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   * Also consider adding warnings when an effect cannot be changed.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @private
   */
  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    }
    // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.
    if (info.computed  && !proto._hasReadOnlyEffect(name)) {
      proto._createComputedProperty(name, info.computed, allProps);
    }
    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    }
    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    }
    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    }
    // always add observer
    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
  }

  /**
   * Configures an element `proto` to function with a given `template`.
   * The element name `is` and extends `ext` must be specified for ShadyCSS
   * style scoping.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {!HTMLTemplateElement} template Template to process and bind
   * @param {string} baseURI URL against which to resolve urls in
   *   style element cssText
   * @param {string} is Tag name (or type extension name) for this element
   * @param {string=} ext For type extensions, the tag name that was extended
   * @private
   */
  function finalizeTemplate(proto, template, baseURI, is, ext) {
    // support `include="module-name"`
    let cssText =
      Object(__WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__["a" /* cssFromModuleImports */])(is) +
      Object(__WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__["c" /* cssFromTemplate */])(template, baseURI);
    if (cssText) {
      let style = document.createElement('style');
      style.textContent = cssText;
      template.content.insertBefore(style, template.content.firstChild);
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is, ext);
    }
    proto._bindTemplate(template);
  }

  /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   */
  class PolymerElement extends polymerElementBase {

    /**
     * Standard Custom Elements V1 API.  The default implementation returns
     * a list of dash-cased attributes based on a flattening of all properties
     * declared in `static get properties()` for this element and any
     * superclasses.
     *
     * @return {Array} Observed attribute list
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
        let list = [];
        let properties = propertiesForClass(this);
        for (let prop in properties) {
          list.push(Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["camelToDashCase"])(prop));
        }
        this.__observedAttributes = list;
      }
      return this.__observedAttributes;
    }

    /**
     * Called automatically when the first element instance is created to
     * ensure that class finalization work has been completed.
     * May be called by users to eagerly perform class finalization work
     * prior to the creation of the first element instance.
     *
     * Class finalization work generally includes meta-programming such as
     * creating property accessors and any property effect metadata needed for
     * the features used.
     *
     * @public
     */
    static finalize() {
      if (!hasClassFinalized(this)) {
        finalizeClassAndSuper(this);
      }
    }

    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation
     * will return the first `<template>` in a `dom-module` whose `id`
     * matches this element's `is`.
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * may be either an `HTMLTemplateElement` or a string that will be
     * automatically parsed into a template.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `Polymer.DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {HTMLTemplateElement|string} Template to be stamped
     */
    static get template() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
        this._template = __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */].import(
          /** @type PolymerElementConstructor*/ (this).is, 'template') ||
          // note: implemented so a subclass can retrieve the super
          // template; call the super impl this way so that `this` points
          // to the superclass.
          Object.getPrototypeOf(/** @type PolymerElementConstructor*/ (this).prototype).constructor.template;
      }
      return this._template;
    }

    /**
     * Path matching the url from which the element was imported.
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     * Defaults to the path matching the url containing a `dom-module` element
     * matching this element's static `is` property.
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     */
    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
          const module = __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */].import(/** @type PolymerElementConstructor */ (this).is);
          this._importPath = module ? module.assetpath : '' ||
          Object.getPrototypeOf(/** @type PolymerElementConstructor*/ (this).prototype).constructor.importPath;
      }
      return this._importPath;
    }

    constructor() {
      super();
      /** @type {HTMLTemplateElement} */
      this._template;
      /** @type {string} */
      this._importPath;
      /** @type {string} */
      this.rootPath;
      /** @type {string} */
      this.importPath;
      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */
      this.root;
      /** @type {!Object<string, !Node>} */
      this.$;
    }

    /**
     * Overrides the default `Polymer.PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @override
     * @suppress {invalidCasts}
     */
    _initializeProperties() {
      instanceCount++;
      this.constructor.finalize();
      const importPath = this.constructor.importPath;
      // note: finalize template when we have access to `localName` to
      // avoid dependence on `is` for polyfilling styling.
      if (this._template && !this._template.__polymerFinalized) {
        this._template.__polymerFinalized = true;
        const baseURI =
          importPath ? Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(importPath) : '';
        finalizeTemplate(/** @type {!PolymerElement} */(this.__proto__), this._template, baseURI,
          /**@type {!HTMLElement}*/(this).localName);
      }
      super._initializeProperties();
      // set path defaults
      this.rootPath = __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__["b" /* rootPath */];
      this.importPath = importPath;
      // apply property defaults...
      let p$ = propertyDefaultsForClass(this.constructor);
      if (!p$) {
        return;
      }
      for (let p in p$) {
        let info = p$[p];
        // Don't set default value if there is already an own property, which
        // happens when a `properties` property with default but no effects had
        // a property set (e.g. bound) by its host before upgrade
        if (!this.hasOwnProperty(p)) {
          let value = typeof info.value == 'function' ?
            info.value.call(this) :
            info.value;
          // Set via `_setProperty` if there is an accessor, to enable
          // initializing readOnly property defaults
          if (this._hasAccessor(p)) {
            this._setPendingProperty(p, value, true);
          } else {
            this[p] = value;
          }
        }
      }
    }

    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @suppress {invalidCasts}
     */
    connectedCallback() {
      if (window.ShadyCSS && this._template) {
        window.ShadyCSS.styleElement(/** @type {!HTMLElement} */(this));
      }
      this._enableProperties();
    }

    /**
     * Provides a default implementation of the standard Custom Elements
     * `disconnectedCallback`.
     */
    disconnectedCallback() {}

    /**
     * Stamps the element template.
     *
     * @override
     */
    ready() {
      if (this._template) {
        this.root = this._stampTemplate(this._template);
        this.$ = this.root.$;
      }
      super.ready();
    }

    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @override
     */
    _readyClients() {
      if (this._template) {
        this.root = this._attachDom(/** @type {StampedTemplate} */(this.root));
      }
      // The super._readyClients here sets the clients initialized flag.
      // We must wait to do this until after client dom is created/attached
      // so that this flag can be checked to prevent notifications fired
      // during this process from being handled before clients are ready.
      super._readyClients();
    }


    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */
    _attachDom(dom) {
      if (this.attachShadow) {
        if (dom) {
          if (!this.shadowRoot) {
            this.attachShadow({mode: 'open'});
          }
          this.shadowRoot.appendChild(dom);
          return this.shadowRoot;
        }
        return null;
      } else {
        throw new Error('ShadowDOM not available. ' +
          // TODO(sorvell): move to compile-time conditional when supported
        'Polymer.Element can create dom as children instead of in ' +
        'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
      }
    }

    /**
     * Provides a default implementation of the standard Custom Elements
     * `attributeChangedCallback`.
     *
     * By default, attributes declared in `properties` metadata are
     * deserialized using their `type` information to properties of the
     * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
     * properties.
     *
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @override
     */
    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        let property = caseMap.dashToCamelCase(name);
        let type = propertiesForClass(this.constructor)[property].type;
        if (!this._hasReadOnlyEffect(property)) {
          this._attributeToProperty(name, value, type);
        }
      }
    }

    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @suppress {invalidCasts}
     */
    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(this), properties);
      }
    }

    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */
    resolveUrl(url, base) {
      if (!base && this.importPath) {
        base = Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(this.importPath);
      }
      return Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(url, base);
    }

    /**
     * Overrides `PropertyAccessors` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @override
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
      return super._parseTemplateContent(template, templateInfo, nodeInfo);
    }

  }

  return PolymerElement;
});
/* harmony export (immutable) */ __webpack_exports__["a"] = ElementMixin;


let instanceCount = 0;
const registrations = [];
/* unused harmony export registrations */


function _regLog(prototype) {
  console.log('[' + prototype.is + ']: registered');
}

function register(prototype) {
  registrations.push(prototype);
  undefined && _regLog(prototype);
}

function dumpRegistrations() {
  registrations.forEach(_regLog);
}

const updateStyles = function(props) {
  if (window.ShadyCSS) {
    window.ShadyCSS.styleDocument(props);
  }
};
/* unused harmony export updateStyles */



/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DomModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__ = __webpack_require__(11);



let modules = {};
let lcModules = {};
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}

function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}

/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */
class DomModule extends HTMLElement {

  static get observedAttributes() { return ['id']; }

  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   */
  static import(id, selector) {
    if (id) {
      let m = findModule(id);
      if (m && selector) {
        return m.querySelector(selector);
      }
      return m;
    }
    return null;
  }

  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this.register();
    }
  }

  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */
  get assetpath() {
    // Don't override existing assetpath.
    if (!this.__assetpath) {
      // note: assetpath set via an attribute must be relative to this
      // element's location; accomodate polyfilled HTMLImports
      const owner = window.HTMLImports && HTMLImports.importForElement ?
        HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = Object(__WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__["c" /* resolveUrl */])(
        this.getAttribute('assetpath') || '', owner.baseURI);
      this.__assetpath = Object(__WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__["a" /* pathFromUrl */])(url);
    }
    return this.__assetpath;
  }

  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   */
  register(id) {
    id = id || this.id;
    if (id) {
      this.id = id;
      // store id separate from lowercased id so that
      // in all cases mixedCase id will stored distinctly
      // and lowercase version is a fallback
      modules[id] = this;
      lcModules[id.toLowerCase()] = this;
      styleOutsideTemplateCheck(this);
    }
  }
}

DomModule.prototype['modules'] = modules;

customElements.define('dom-module', DomModule);




/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_path_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__property_accessors_js__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__template_stamp_js__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_settings_js__ = __webpack_require__(10);









/** @const {Object} */
const CaseMap = __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__;

// Monotonically increasing unique ID used for de-duping effects triggered
// from multiple properties in the same turn
let dedupeId = 0;

/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */
const TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};

/**
 * @typedef {{
 * name: (string | undefined),
 * structured: (boolean | undefined),
 * wildcard: (boolean | undefined)
 * }}
 */
let DataTrigger; //eslint-disable-line no-unused-vars

/**
 * @typedef {{
 * info: ?,
 * trigger: (!DataTrigger | undefined),
 * fn: (!Function | undefined)
 * }}
 */
let DataEffect; //eslint-disable-line no-unused-vars

let PropertyEffectsType; //eslint-disable-line no-unused-vars

/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @return {Object} The own-property map of effects for the given type
 * @private
 */
function ensureOwnEffectMap(model, type) {
  let effects = model[type];
  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);
    for (let p in effects) {
      let protoFx = effects[p];
      let instFx = effects[p] = Array(protoFx.length);
      for (let i=0; i<protoFx.length; i++) {
        instFx[i] = protoFx[i];
      }
    }
  }
  return effects;
}

// -- effects ----------------------------------------------

/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {Object} props Bag of current property changes
 * @param {Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    let ran = false;
    let id = dedupeId++;
    for (let prop in props) {
      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
        ran = true;
      }
    }
    return ran;
  }
  return false;
}

/**
 * Runs a list of effects for a given property.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  let ran = false;
  let rootProperty = hasPaths ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(prop) : prop;
  let fxs = effects[rootProperty];
  if (fxs) {
    for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) &&
          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }
        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }
  return ran;
}

/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */
function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    let triggerPath = trigger.name;
    return (triggerPath == path) ||
      (trigger.structured && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["b" /* isAncestor */])(triggerPath, path)) ||
      (trigger.wildcard && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(triggerPath, path));
  } else {
    return true;
  }
}

/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runObserverEffect(inst, property, props, oldProps, info) {
  let fn = inst[info.methodName];
  let changedProp = info.property;
  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.methodName + '` not defined');
  }
}

/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  // Notify
  let fxs = inst[TYPES.NOTIFY];
  let notified;
  let id = dedupeId++;
  // Try normal notify effects; if none, fall back to try path notification
  for (let prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  }
  // Flush host if we actually notified and host was batching
  // And the host has already initialized clients; this prevents
  // an issue with a host observing data changes before clients are ready.
  let host;
  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}

/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */
function notifyPath(inst, path, props) {
  let rootProperty = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(path);
  if (rootProperty !== path) {
    let eventName = Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["camelToDashCase"])(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }
  return false;
}

/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} eventName The name of the event to send ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property changed, the path
 *   that changed (optional).
 * @private
 * @suppress {invalidCasts}
 */
function dispatchNotifyEvent(inst, eventName, value, path) {
  let detail = {
    value: value,
    queueProperty: true
  };
  if (path) {
    detail.path = path;
  }
  /** @type {!HTMLElement} */(inst).dispatchEvent(new CustomEvent(eventName, { detail }));
}

/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  let rootProperty = hasPaths ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(property) : property;
  let path = rootProperty != property ? property : null;
  let value = path ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, path) : inst.__data[property];
  if (path && value === undefined) {
    value = props[property];  // specifically for .splices
  }
  dispatchNotifyEvent(inst, info.eventName, value, path);
}

/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!PropertyEffectsType} inst Host element instance handling the notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @private
 */
function handleNotification(event, inst, fromProp, toPath, negate) {
  let value;
  let detail = /** @type {Object} */(event.detail);
  let fromPath = detail && detail.path;
  if (fromPath) {
    toPath = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.target[fromProp];
  }
  value = negate ? !value : value;
  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))
      && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}

/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runReflectEffect(inst, property, props, oldProps, info) {
  let value = inst.__data[property];
  if (__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */]) {
    value = Object(__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */])(value, info.attrName, 'attribute', /** @type {Node} */(inst));
  }
  inst._propertyToAttribute(property, info.attrName, value);
}

/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {!Object} changedProps Bag of changed properties
 * @param {!Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  let computeEffects = inst[TYPES.COMPUTE];
  if (computeEffects) {
    let inputProps = changedProps;
    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
      Object.assign(oldProps, inst.__dataOld);
      Object.assign(changedProps, inst.__dataPending);
      inputProps = inst.__dataPending;
      inst.__dataPending = null;
    }
  }
}

/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runComputedEffect(inst, property, props, oldProps, info) {
  let result = runMethodEffect(inst, property, props, oldProps, info);
  let computedProp = info.methodInfo;
  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
  }
}

/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!PropertyEffectsType} inst The instance whose props are changing
 * @param {string | !Array<(string|number)>} path Path that has changed
 * @param {*} value Value of changed path
 * @private
 */
function computeLinkedPaths(inst, path, value) {
  let links = inst.__dataLinkedPaths;
  if (links) {
    let link;
    for (let a in links) {
      let b = links[a];
      if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(a, path)) {
        link = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(a, b, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(b, path)) {
        link = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(b, a, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
}

// -- bindings ----------------------------------------------

/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @private
 */
function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  // Create binding metadata and add to nodeInfo
  nodeInfo.bindings = nodeInfo.bindings || [];
  let /** Binding */ binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };
  nodeInfo.bindings.push(binding);
  // Add listener info to binding metadata
  if (shouldAddListener(binding)) {
    let {event, negate} = binding.parts[0];
    binding.listenerEvent = event || (CaseMap.camelToDashCase(target) + '-changed');
    binding.listenerNegate = negate;
  }
  // Add "propagate" property effects to templateInfo
  let index = templateInfo.nodeInfoList.length;
  for (let i=0; i<binding.parts.length; i++) {
    let part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}

/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 */
function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target +
        ' because "-" is not a valid attribute starting character');
    } else {
      let dependencies = part.dependencies;
      let info = { index, binding, part, evaluator: constructor };
      for (let j=0; j<dependencies.length; j++) {
        let trigger = dependencies[j];
        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }
        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info, trigger
        });
      }
    }
  }
}

/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @private
 */
function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  let node = nodeList[info.index];
  let binding = info.binding;
  let part = info.part;
  // Subpath notification: transform path and set to client
  // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
  if (hasPaths && part.source && (path.length > part.source.length) &&
      (binding.kind == 'property') && !binding.isCompound &&
      node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    let value = props[path];
    path = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(part.source, binding.target, path);
    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
    // Propagate value to child
    applyBindingValue(inst, node, binding, part, value);
  }
}

/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!PropertyEffectsType} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @private
 */
function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);
  if (__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */]) {
    value = Object(__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */])(value, binding.target, binding.kind, node);
  }
  if (binding.kind == 'attribute') {
    // Attribute binding
    inst._valueToNodeAttribute(/** @type {Element} */(node), value, binding.target);
  } else {
    // Property binding
    let prop = binding.target;
    if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else  {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}

/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */
function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }
  if (binding.kind !== 'attribute') {
    // Some browsers serialize `undefined` to `"undefined"`
    if (binding.target === 'textContent' ||
        (node.localName == 'input' && binding.target == 'value')) {
      value = value == undefined ? '' : value;
    }
  }
  return value;
}

/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */
function shouldAddListener(binding) {
  return Boolean(binding.target) &&
         binding.kind != 'attribute' &&
         binding.kind != 'text' &&
         !binding.isCompound &&
         binding.parts[0].mode === '{';
}

/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!PropertyEffectsType} inst Instance that bas been previously bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @private
 */
function setupBindings(inst, templateInfo) {
  // Setup compound storage, dataHost, and notify listeners
  let {nodeList, nodeInfoList} = templateInfo;
  if (nodeInfoList.length) {
    for (let i=0; i < nodeInfoList.length; i++) {
      let info = nodeInfoList[i];
      let node = nodeList[i];
      let bindings = info.bindings;
      if (bindings) {
        for (let i=0; i<bindings.length; i++) {
          let binding = bindings[i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }
      node.__dataHost = inst;
    }
  }
}

/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @private
 */
function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    // Create compound storage map
    let storage = node.__dataCompoundStorage ||
      (node.__dataCompoundStorage = {});
    let parts = binding.parts;
    // Copy literals from parts into storage for this binding
    let literals = new Array(parts.length);
    for (let j=0; j<parts.length; j++) {
      literals[j] = parts[j].literal;
    }
    let target = binding.target;
    storage[target] = literals;
    // Configure properties with their literal parts
    if (binding.literal && binding.kind == 'property') {
      node[target] = binding.literal;
    }
  }
}

/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!PropertyEffectsType} inst Host element instance to handle notification event
 * @param {Binding} binding Binding metadata
 * @private
 */
function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    let part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function(e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
}

// -- for method-based effects (complexObserver & computed) --------------

/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @private
 */
function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || (dynamicFn &&
    (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));
  let info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo,
    dynamicFn
  };
  for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn, info: info, trigger: arg
      });
    }
  }
  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn, info: info
    });
  }
}

/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */
function runMethodEffect(inst, property, props, oldProps, info) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  let context = inst._methodHost || inst;
  let fn = context[info.methodName];
  if (fn) {
    let args = marshalArgs(inst.__data, info.args, property, props);
    return fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}

const emptyArray = [];

// Regular expressions used for binding
const IDENT  = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
const NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
const SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
const DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' +  STRING + ')\\s*' + ')';
const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
const ARGUMENT_LIST = '(?:' + '\\(\\s*' +
                              '(?:' + ARGUMENTS + '?' + ')' +
                            '\\)\\s*' + ')';
const BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
const OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
const CLOSE_BRACKET = '(?:]]|}})';
const NEGATE = '(?:(!)\\s*)?'; // Group 2
const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");

/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */
function literalFromParts(parts) {
  let s = '';
  for (let i=0; i<parts.length; i++) {
    let literal = parts[i].literal;
    s += literal || '';
  }
  return s;
}

/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */
function parseMethod(expression) {
  // tries to match valid javascript property names
  let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m) {
    let methodName = m[1];
    let sig = { methodName, static: true, args: emptyArray };
    if (m[2].trim()) {
      // replace escaped commas with comma entity, split on un-escaped commas
      let args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }
  return null;
}

/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */
function parseArgs(argList, sig) {
  sig.args = argList.map(function(rawArg) {
    let arg = parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}

/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */
function parseArg(rawArg) {
  // clean up whitespace
  let arg = rawArg.trim()
    // replace comma entity with comma
    .replace(/&comma;/g, ',')
    // repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '\$1')
    ;
  // basic argument descriptor
  let a = {
    name: arg,
    value: '',
    literal: false
  };
  // detect literal value (must be String or Number)
  let fc = arg[0];
  if (fc === '-') {
    fc = arg[1];
  }
  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }
  switch(fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;
    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  }
  // if not literal, look for structured path
  if (!a.literal) {
    a.rootProperty = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(arg);
    // detect structured path (has dots)
    a.structured = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(arg);
    if (a.structured) {
      a.wildcard = (arg.slice(-2) == '.*');
      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }
  return a;
}

/**
 * Gather the argument values for a method specified in the provided array
 * of argument metadata.
 *
 * The `path` and `value` arguments are used to fill in wildcard descriptor
 * when the method is being called as a result of a path notification.
 *
 * @param {Object} data Instance data storage object to read properties from
 * @param {!Array<!MethodArg>} args Array of argument metadata
 * @param {string} path Property/path name that triggered the method effect
 * @param {Object} props Bag of current property changes
 * @return {Array<*>} Array of argument values
 * @private
 */
function marshalArgs(data, args, path, props) {
  let values = [];
  for (let i=0, l=args.length; i<l; i++) {
    let arg = args[i];
    let name = arg.name;
    let v;
    if (arg.literal) {
      v = arg.value;
    } else {
      if (arg.structured) {
        v = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(data, name);
        // when data is not stored e.g. `splices`
        if (v === undefined) {
          v = props[name];
        }
      } else {
        v = data[name];
      }
    }
    if (arg.wildcard) {
      // Only send the actual path changed info if the change that
      // caused the observer to run matched the wildcard
      let baseChanged = (name.indexOf(path + '.') === 0);
      let matches = (path.indexOf(name) === 0 && !baseChanged);
      values[i] = {
        path: matches ? path : name,
        value: matches ? props[path] : v,
        base: v
      };
    } else {
      values[i] = v;
    }
  }
  return values;
}

// data api

/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @private
 */
function notifySplices(inst, array, path, splices) {
  let splicesPath = path + '.splices';
  inst.notifyPath(splicesPath, { indexSplices: splices });
  inst.notifyPath(path + '.length', array.length);
  // Null here to allow potentially large splice records to be GC'ed.
  inst.__data[splicesPath] = {indexSplices: null};
}

/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @private
 */
function notifySplice(inst, array, path, index, addedCount, removed) {
  notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}

/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}

const PropertyEffects = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   */
  const propertyEffectsBase = Object(__WEBPACK_IMPORTED_MODULE_5__template_stamp_js__["a" /* TemplateStamp */])(Object(__WEBPACK_IMPORTED_MODULE_4__property_accessors_js__["a" /* PropertyAccessors */])(superClass));

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */
  class PropertyEffects extends propertyEffectsBase {

    constructor() {
      super();
      /** @type {boolean} */
      this.__dataClientsReady;
      /** @type {Array} */
      this.__dataPendingClients;
      /** @type {Object} */
      this.__dataToNotify;
      /** @type {Object} */
      this.__dataLinkedPaths;
      /** @type {boolean} */
      this.__dataHasPaths;
      /** @type {Object} */
      this.__dataCompoundStorage;
      /** @type {Polymer_PropertyEffects} */
      this.__dataHost;
      /** @type {!Object} */
      this.__dataTemp;
      /** @type {boolean} */
      this.__dataClientsInitialized;
      /** @type {!Object} */
      this.__data;
      /** @type {!Object} */
      this.__dataPending;
      /** @type {!Object} */
      this.__dataOld;
      /** @type {Object} */
      this.__computeEffects;
      /** @type {Object} */
      this.__reflectEffects;
      /** @type {Object} */
      this.__notifyEffects;
      /** @type {Object} */
      this.__propagateEffects;
      /** @type {Object} */
      this.__observeEffects;
      /** @type {Object} */
      this.__readOnly;
      /** @type {number} */
      this.__dataCounter;
      /** @type {!TemplateInfo} */
      this.__templateInfo;
    }

    get PROPERTY_EFFECT_TYPES() {
      return TYPES;
    }

    _initializeProperties() {
      super._initializeProperties();
      hostStack.registerHost(this);
      this.__dataClientsReady = false;
      this.__dataPendingClients = null;
      this.__dataToNotify = null;
      this.__dataLinkedPaths = null;
      this.__dataHasPaths = false;
      // May be set on instance prior to upgrade
      this.__dataCompoundStorage = this.__dataCompoundStorage || null;
      this.__dataHost = this.__dataHost || null;
      this.__dataTemp = {};
      this.__dataClientsInitialized = false;
    }

    /**
     * Overrides `Polymer.PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     */
    _initializeProtoProperties(props) {
      this.__data = Object.create(props);
      this.__dataPending = Object.create(props);
      this.__dataOld = {};
    }

    /**
     * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     */
    _initializeInstanceProperties(props) {
      let readOnly = this[TYPES.READ_ONLY];
      for (let prop in props) {
        if (!readOnly || !readOnly[prop]) {
          this.__dataPending = this.__dataPending || {};
          this.__dataOld = this.__dataOld || {};
          this.__data[prop] = this.__dataPending[prop] = props[prop];
        }
      }
    }

    // Prototype setup ----------------------------------------

    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @protected
     */
    _addPropertyEffect(property, type, effect) {
      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
      // effects are accumulated into arrays per property based on type
      let effects = ensureOwnEffectMap(this, type)[property];
      if (!effects) {
        effects = this[type][property] = [];
      }
      effects.push(effect);
    }

    /**
     * Removes the given property effect.
     *
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     */
    _removePropertyEffect(property, type, effect) {
      let effects = ensureOwnEffectMap(this, type)[property];
      let idx = effects.indexOf(effect);
      if (idx >= 0) {
        effects.splice(idx, 1);
      }
    }

    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasPropertyEffect(property, type) {
      let effects = this[type];
      return Boolean(effects && effects[property]);
    }

    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasReadOnlyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.READ_ONLY);
    }

    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasNotifyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.NOTIFY);
    }

    /**
     * Returns whether the current prototype/instance has a "reflect to attribute"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasReflectEffect(property) {
      return this._hasPropertyEffect(property, TYPES.REFLECT);
    }

    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasComputedEffect(property) {
      return this._hasPropertyEffect(property, TYPES.COMPUTE);
    }

    // Runtime ----------------------------------------

    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */
    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
      if (isPathNotification ||
          Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(Array.isArray(path) ? path[0] : path) !== path) {
        // Dirty check changes being set to a path against the actual object,
        // since this is the entry point for paths into the system; from here
        // the only dirty checks are against the `__dataTemp` cache to prevent
        // duplicate work in the same turn only. Note, if this was a notification
        // of a change already set to a path (isPathNotification: true),
        // we always let the change through and skip the `set` since it was
        // already dirty checked at the point of entry and the underlying
        // object has already been updated
        if (!isPathNotification) {
          let old = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path);
          path = /** @type {string} */ (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["h" /* set */])(this, path, value));
          // Use property-accessor's simpler dirty check
          if (!path || !super._shouldPropertyChange(path, value, old)) {
            return false;
          }
        }
        this.__dataHasPaths = true;
        if (this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify)) {
          computeLinkedPaths(this, path, value);
          return true;
        }
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
          return this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify);
        } else {
          this[path] = value;
        }
      }
      return false;
    }

    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @param {Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @protected
     */
    _setUnmanagedPropertyToNode(node, prop, value) {
      // It is a judgment call that resetting primitives is
      // "bad" and resettings objects is also "good"; alternatively we could
      // implement a whitelist of tag & property values that should never
      // be reset (e.g. <input>.value && <select>.value)
      if (value !== node[prop] || typeof value == 'object') {
        node[prop] = value;
      }
    }

    /**
     * Overrides the `PropertyAccessors` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChaged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     * @override
     */
    _setPendingProperty(property, value, shouldNotify) {
      let isPath = this.__dataHasPaths && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(property);
      let prevProps = isPath ? this.__dataTemp : this.__data;
      if (this._shouldPropertyChange(property, value, prevProps[property])) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        // Ensure old is captured from the last turn
        if (!(property in this.__dataOld)) {
          this.__dataOld[property] = this.__data[property];
        }
        // Paths are stored in temporary cache (cleared at end of turn),
        // which is used for dirty-checking, all others stored in __data
        if (isPath) {
          this.__dataTemp[property] = value;
        } else {
          this.__data[property] = value;
        }
        // All changes go into pending property bag, passed to _propertiesChanged
        this.__dataPending[property] = value;
        // Track properties that should notify separately
        if (isPath || (this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property])) {
          this.__dataToNotify = this.__dataToNotify || {};
          this.__dataToNotify[property] = shouldNotify;
        }
        return true;
      }
      return false;
    }

    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     */
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value, true)) {
        this._invalidateProperties();
      }
    }

    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     */
    _invalidateProperties() {
      if (this.__dataReady) {
        this._flushProperties();
      }
    }

    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @param {Object} client PropertyEffects client to enqueue
     * @protected
     */
    _enqueueClient(client) {
      this.__dataPendingClients = this.__dataPendingClients || [];
      if (client !== this) {
        this.__dataPendingClients.push(client);
      }
    }

    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @protected
     */
    _flushClients() {
      if (!this.__dataClientsReady) {
        this.__dataClientsReady = true;
        this._readyClients();
        // Override point where accessors are turned on; importantly,
        // this is after clients have fully readied, providing a guarantee
        // that any property effects occur only after all clients are ready.
        this.__dataReady = true;
      } else {
        this.__enableOrFlushClients();
      }
    }

    // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.
    __enableOrFlushClients() {
      let clients = this.__dataPendingClients;
      if (clients) {
        this.__dataPendingClients = null;
        for (let i=0; i < clients.length; i++) {
          let client = clients[i];
          if (!client.__dataEnabled) {
            client._enableProperties();
          } else if (client.__dataPending) {
            client._flushProperties();
          }
        }
      }
    }

    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @protected
     */
    _readyClients() {
      this.__enableOrFlushClients();
    }

    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @public
     */
    setProperties(props, setReadOnly) {
      for (let path in props) {
        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
          //TODO(kschaaf): explicitly disallow paths in setProperty?
          // wildcard observers currently only pass the first changed path
          // in the `info` object, and you could do some odd things batching
          // paths, e.g. {'foo.bar': {...}, 'foo': null}
          this._setPendingPropertyOrPath(path, props[path], true);
        }
      }
      this._invalidateProperties();
    }

    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     */
    ready() {
      // It is important that `super.ready()` is not called here as it
      // immediately turns on accessors. Instead, we wait until `readyClients`
      // to enable accessors to provide a guarantee that clients are ready
      // before processing any accessors side effects.
      this._flushProperties();
      // If no data was pending, `_flushProperties` will not `flushClients`
      // so ensure this is done.
      if (!this.__dataClientsReady) {
        this._flushClients();
      }
      // Before ready, client notifications do not trigger _flushProperties.
      // Therefore a flush is necessary here if data has been set.
      if (this.__dataPending) {
        this._flushProperties();
      }
    }

    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     */
    _propertiesChanged(currentProps, changedProps, oldProps) {
      // ----------------------------
      // let c = Object.getOwnPropertyNames(changedProps || {});
      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
      // if (window.debug) { debugger; }
      // ----------------------------
      let hasPaths = this.__dataHasPaths;
      this.__dataHasPaths = false;
      // Compute properties
      runComputedEffects(this, changedProps, oldProps, hasPaths);
      // Clear notify properties prior to possible reentry (propagate, observe),
      // but after computing effects have a chance to add to them
      let notifyProps = this.__dataToNotify;
      this.__dataToNotify = null;
      // Propagate properties to clients
      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
      // Flush clients
      this._flushClients();
      // Reflect properties
      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
      // Observe properties
      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
      // Notify properties to host
      if (notifyProps) {
        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
      }
      // Clear temporary cache at end of turn
      if (this.__dataCounter == 1) {
        this.__dataTemp = {};
      }
      // ----------------------------
      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
      // ----------------------------
    }

    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @protected
     */
    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
      if (this[TYPES.PROPAGATE]) {
        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
      }
      let templateInfo = this.__templateInfo;
      while (templateInfo) {
        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,
          hasPaths, templateInfo.nodeList);
        templateInfo = templateInfo.nextTemplateInfo;
      }
    }

    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @public
     */
    linkPaths(to, from) {
      to = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(to);
      from = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(from);
      this.__dataLinkedPaths = this.__dataLinkedPaths || {};
      this.__dataLinkedPaths[to] = from;
    }

    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @public
     */
    unlinkPaths(path) {
      path = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(path);
      if (this.__dataLinkedPaths) {
        delete this.__dataLinkedPaths[path];
      }
    }

    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     * @public
    */
    notifySplices(path, splices) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      notifySplices(this, array, info.path, splices);
    }

    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */
    get(path, root) {
      return Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(root || this, path);
    }

    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @public
    */
    set(path, value, root) {
      if (root) {
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["h" /* set */])(root, path, value);
      } else {
        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */(path)]) {
          if (this._setPendingPropertyOrPath(path, value, true)) {
            this._invalidateProperties();
          }
        }
      }
    }

    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */
    push(path, ...items) {
      let info = {path: ''};
      let array = /** @type {Array}*/(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let len = array.length;
      let ret = array.push(...items);
      if (items.length) {
        notifySplice(this, array, info.path, len, items.length, []);
      }
      return ret;
    }

    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    pop(path) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let hadLength = Boolean(array.length);
      let ret = array.pop();
      if (hadLength) {
        notifySplice(this, array, info.path, array.length, 0, [ret]);
      }
      return ret;
    }

    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {Array} Array of removed items.
     * @public
     */
    splice(path, start, deleteCount, ...items) {
      let info = {path : ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      // Normalize fancy native splice handling of crazy start values
      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else {
        start = Math.floor(start);
      }
      if (!start) {
        start = 0;
      }
      let ret = array.splice(start, deleteCount, ...items);
      if (items.length || ret.length) {
        notifySplice(this, array, info.path, start, items.length, ret);
      }
      return ret;
    }

    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    shift(path) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let hadLength = Boolean(array.length);
      let ret = array.shift();
      if (hadLength) {
        notifySplice(this, array, info.path, 0, 0, [ret]);
      }
      return ret;
    }

    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */
    unshift(path, ...items) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let ret = array.unshift(...items);
      if (items.length) {
        notifySplice(this, array, info.path, 0, items.length, []);
      }
      return ret;
    }

    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @public
    */
    notifyPath(path, value) {
      /** @type {string} */
      let propPath;
      if (arguments.length == 1) {
        // Get value if not supplied
        let info = {path: ''};
        value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info);
        propPath = info.path;
      } else if (Array.isArray(path)) {
        // Normalize path if needed
        propPath = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(path);
      } else {
        propPath = /** @type{string} */(path);
      }
      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
        this._invalidateProperties();
      }
    }

    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @protected
     */
    _createReadOnlyProperty(property, protectedSetter) {
      this._addPropertyEffect(property, TYPES.READ_ONLY);
      if (protectedSetter) {
        this['_set' + upper(property)] = /** @this {PropertyEffects} */function(value) {
          this._setProperty(property, value);
        };
      }
    }

    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @param {string} methodName Name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @protected
     */
    _createPropertyObserver(property, methodName, dynamicFn) {
      let info = { property, methodName, dynamicFn: Boolean(dynamicFn) };
      this._addPropertyEffect(property, TYPES.OBSERVE, {
        fn: runObserverEffect, info, trigger: {name: property}
      });
      if (dynamicFn) {
        this._addPropertyEffect(methodName, TYPES.OBSERVE, {
          fn: runObserverEffect, info, trigger: {name: methodName}
        });
      }
    }

    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */
    _createMethodObserver(expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed observer expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
    }

    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @protected
     */
    _createNotifyingProperty(property) {
      this._addPropertyEffect(property, TYPES.NOTIFY, {
        fn: runNotifyEffect,
        info: {
          eventName: CaseMap.camelToDashCase(property) + '-changed',
          property: property
        }
      });
    }

    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @protected
     */
    _createReflectedProperty(property) {
      let attr = CaseMap.camelToDashCase(property);
      if (attr[0] === '-') {
        console.warn('Property ' + property + ' cannot be reflected to attribute ' +
          attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
      } else {
        this._addPropertyEffect(property, TYPES.REFLECT, {
          fn: runReflectEffect,
          info: {
            attrName: attr
          }
        });
      }
    }

    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */
    _createComputedProperty(property, expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed computed expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
    }

    // -- static class methods ------------

    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @protected
     */
    static addPropertyEffect(property, type, effect) {
      this.prototype._addPropertyEffect(property, type, effect);
    }

    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string} methodName Name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @protected
     */
    static createPropertyObserver(property, methodName, dynamicFn) {
      this.prototype._createPropertyObserver(property, methodName, dynamicFn);
    }

    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal Javascript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */
    static createMethodObserver(expression, dynamicFn) {
      this.prototype._createMethodObserver(expression, dynamicFn);
    }

    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @protected
     */
    static createNotifyingProperty(property) {
      this.prototype._createNotifyingProperty(property);
    }

    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @protected
     */
    static createReadOnlyProperty(property, protectedSetter) {
      this.prototype._createReadOnlyProperty(property, protectedSetter);
    }

    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @protected
     */
    static createReflectedProperty(property) {
      this.prototype._createReflectedProperty(property);
    }

    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal Javascript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @protected
     */
    static createComputedProperty(property, expression, dynamicFn) {
      this.prototype._createComputedProperty(property, expression, dynamicFn);
    }

    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {Object} Template metadata object
     * @protected
     */
    static bindTemplate(template) {
      return this.prototype._bindTemplate(template);
    }

    // -- binding ----------------------------------------------

    /**
     * Equivalent to static `bindTemplate` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @param {HTMLTemplateElement} template Template containing binding
     *   bindings
     * @param {boolean=} instanceBinding When false (default), performs
     *   "prototypical" binding of the template and overwrites any previously
     *   bound template for the class. When true (as passed from
     *   `_stampTemplate`), the template info is instanced and linked into
     *   the list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     *   this is an instance of the prototypical template info
     * @protected
     */
    _bindTemplate(template, instanceBinding) {
      let templateInfo = this.constructor._parseTemplate(template);
      let wasPreBound = this.__templateInfo == templateInfo;
      // Optimization: since this is called twice for proto-bound templates,
      // don't attempt to recreate accessors if this template was pre-bound
      if (!wasPreBound) {
        for (let prop in templateInfo.propertyEffects) {
          this._createPropertyAccessor(prop);
        }
      }
      if (instanceBinding) {
        // For instance-time binding, create instance of template metadata
        // and link into list of templates if necessary
        templateInfo = /** @type {!TemplateInfo} */(Object.create(templateInfo));
        templateInfo.wasPreBound = wasPreBound;
        if (!wasPreBound && this.__templateInfo) {
          let last = this.__templateInfoLast || this.__templateInfo;
          this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
          templateInfo.previousTemplateInfo = last;
          return templateInfo;
        }
      }
      return this.__templateInfo = templateInfo;
    }

    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @protected
     */
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
      hostProps[prop] = true;
      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
      let propEffects = effects[prop] = effects[prop] || [];
      propEffects.push(effect);
    }

    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */
    _stampTemplate(template) {
      // Ensures that created dom is `_enqueueClient`'d to this element so
      // that it can be flushed on next call to `_flushProperties`
      hostStack.beginHosting(this);
      let dom = super._stampTemplate(template);
      hostStack.endHosting(this);
      let templateInfo = /** @type {!TemplateInfo} */(this._bindTemplate(template, true));
      // Add template-instance-specific data to instanced templateInfo
      templateInfo.nodeList = dom.nodeList;
      // Capture child nodes to allow unstamping of non-prototypical templates
      if (!templateInfo.wasPreBound) {
        let nodes = templateInfo.childNodes = [];
        for (let n=dom.firstChild; n; n=n.nextSibling) {
          nodes.push(n);
        }
      }
      dom.templateInfo = templateInfo;
      // Setup compound storage, 2-way listeners, and dataHost for bindings
      setupBindings(this, templateInfo);
      // Flush properties into template nodes if already booted
      if (this.__dataReady) {
        runEffects(this, templateInfo.propertyEffects, this.__data, null,
          false, templateInfo.nodeList);
      }
      return dom;
    }

    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @protected
     */
    _removeBoundDom(dom) {
      // Unlink template info
      let templateInfo = dom.templateInfo;
      if (templateInfo.previousTemplateInfo) {
        templateInfo.previousTemplateInfo.nextTemplateInfo =
          templateInfo.nextTemplateInfo;
      }
      if (templateInfo.nextTemplateInfo) {
        templateInfo.nextTemplateInfo.previousTemplateInfo =
          templateInfo.previousTemplateInfo;
      }
      if (this.__templateInfoLast == templateInfo) {
        this.__templateInfoLast = templateInfo.previousTemplateInfo;
      }
      templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
      // Remove stamped nodes
      let nodes = templateInfo.childNodes;
      for (let i=0; i<nodes.length; i++) {
        let node = nodes[i];
        node.parentNode.removeChild(node);
      }
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @override
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = super._parseTemplateNode(node, templateInfo, nodeInfo);
      if (node.nodeType === Node.TEXT_NODE) {
        let parts = this._parseBindings(node.textContent, templateInfo);
        if (parts) {
          // Initialize the textContent with any literal parts
          // NOTE: default to a space here so the textNode remains; some browsers
          // (IE) evacipate an empty textNode following cloneNode/importNode.
          node.textContent = literalFromParts(parts) || ' ';
          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
          noted = true;
        }
      }
      return noted;
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @override
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      let parts = this._parseBindings(value, templateInfo);
      if (parts) {
        // Attribute or property
        let origName = name;
        let kind = 'property';
        if (name[name.length-1] == '$') {
          name = name.slice(0, -1);
          kind = 'attribute';
        }
        // Initialize attribute bindings with any literal parts
        let literal = literalFromParts(parts);
        if (literal && kind == 'attribute') {
          node.setAttribute(name, literal);
        }
        // Clear attribute before removing, since IE won't allow removing
        // `value` attribute if it previously had a value (can't
        // unconditionally set '' before removing since attributes with `$`
        // can't be set using setAttribute)
        if (node.localName === 'input' && origName === 'value') {
          node.setAttribute(origName, '');
        }
        // Remove annotation
        node.removeAttribute(origName);
        // Case hackery: attributes are lower-case, but bind targets
        // (properties) are case sensitive. Gambit is to map dash-case to
        // camel-case: `foo-bar` becomes `fooBar`.
        // Attribute bindings are excepted.
        if (kind === 'property') {
          name = Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["dashToCamelCase"])(name);
        }
        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
        return true;
      } else {
        return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);
      }
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @override
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
      let noted = super._parseTemplateNestedTemplate(node, templateInfo, nodeInfo);
      // Merge host props into outer template and add bindings
      let hostProps = nodeInfo.templateInfo.hostProps;
      let mode = '{';
      for (let source in hostProps) {
        let parts = [{ mode, source, dependencies: [source] }];
        addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
      }
      return noted;
    }

    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     */
    static _parseBindings(text, templateInfo) {
      let parts = [];
      let lastIndex = 0;
      let m;
      // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
      // Regex matches:
      //        Iteration 1:  Iteration 2:
      // m[1]: '{{'          '[['
      // m[2]: ''            '!'
      // m[3]: 'prop'        'compute(foo,bar)'
      while ((m = bindingRegex.exec(text)) !== null) {
        // Add literal part
        if (m.index > lastIndex) {
          parts.push({literal: text.slice(lastIndex, m.index)});
        }
        // Add binding part
        let mode = m[1][0];
        let negate = Boolean(m[2]);
        let source = m[3].trim();
        let customEvent = false, notifyEvent = '', colon = -1;
        if (mode == '{' && (colon = source.indexOf('::')) > 0) {
          notifyEvent = source.substring(colon + 2);
          source = source.substring(0, colon);
          customEvent = true;
        }
        let signature = parseMethod(source);
        let dependencies = [];
        if (signature) {
          // Inline computed function
          let {args, methodName} = signature;
          for (let i=0; i<args.length; i++) {
            let arg = args[i];
            if (!arg.literal) {
              dependencies.push(arg);
            }
          }
          let dynamicFns = templateInfo.dynamicFns;
          if (dynamicFns && dynamicFns[methodName] || signature.static) {
            dependencies.push(methodName);
            signature.dynamicFn = true;
          }
        } else {
          // Property or path
          dependencies.push(source);
        }
        parts.push({
          source, mode, negate, customEvent, signature, dependencies,
          event: notifyEvent
        });
        lastIndex = bindingRegex.lastIndex;
      }
      // Add a final literal part
      if (lastIndex && lastIndex < text.length) {
        let literal = text.substring(lastIndex);
        if (literal) {
          parts.push({
            literal: literal
          });
        }
      }
      if (parts.length) {
        return parts;
      } else {
        return null;
      }
    }

    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {this} inst Element that should be used as scope for
     *   binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     */
    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
      let value;
      if (part.signature) {
        value = runMethodEffect(inst, path, props, oldProps, part.signature);
      } else if (path != part.source) {
        value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, part.source);
      } else {
        if (hasPaths && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(path)) {
          value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, path);
        } else {
          value = inst.__data[path];
        }
      }
      if (part.negate) {
        value = !value;
      }
      return value;
    }

  }

  // make a typing for closure :P
  PropertyEffectsType = PropertyEffects;

  return PropertyEffects;
});
/* harmony export (immutable) */ __webpack_exports__["a"] = PropertyEffects;


/**
 * Helper api for enqueing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */
let hostStack = {

  stack: [],

  /**
   * @param {*} inst Instance to add to hostStack
   * @this {hostStack}
   */
  registerHost(inst) {
    if (this.stack.length) {
      let host = this.stack[this.stack.length-1];
      host._enqueueClient(inst);
    }
  },

  /**
   * @param {*} inst Instance to begin hosting
   * @this {hostStack}
   */
  beginHosting(inst) {
    this.stack.push(inst);
  },

  /**
   * @param {*} inst Instance to end hosting
   * @this {hostStack}
   */
  endHosting(inst) {
    let stackLen = this.stack.length;
    if (stackLen && this.stack[stackLen-1] == inst) {
      this.stack.pop();
    }
  }

};


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export beforeNextRender */
/* harmony export (immutable) */ __webpack_exports__["a"] = afterNextRender;
/* unused harmony export flush */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


let scheduled = false;
let beforeRenderQueue = [];
let afterRenderQueue = [];

function schedule() {
  scheduled = true;
  // before next render
  requestAnimationFrame(function() {
    scheduled = false;
    flushQueue(beforeRenderQueue);
    // after the render
    setTimeout(function() {
      runQueue(afterRenderQueue);
    });
  });
}

function flushQueue(queue) {
  while (queue.length) {
    callMethod(queue.shift());
  }
}

function runQueue(queue) {
  for (let i=0, l=queue.length; i < l; i++) {
    callMethod(queue.shift());
  }
}

function callMethod(info) {
  const context = info[0];
  const callback = info[1];
  const args = info[2];
  try {
    callback.apply(context, args);
  } catch(e) {
    setTimeout(() => {
      throw e;
    });
  }
}

function flush() {
  while (beforeRenderQueue.length || afterRenderQueue.length) {
    flushQueue(beforeRenderQueue);
    flushQueue(afterRenderQueue);
  }
  scheduled = false;
}

function beforeNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  beforeRenderQueue.push([context, callback, args]);
}

function afterNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  afterRenderQueue.push([context, callback, args]);
}




/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


let debouncerQueue = [];

const enqueueDebouncer = function(debouncer) {
  debouncerQueue.push(debouncer);
};
/* harmony export (immutable) */ __webpack_exports__["a"] = enqueueDebouncer;


function flushDebouncers() {
  const didFlush = Boolean(debouncerQueue.length);
  while (debouncerQueue.length) {
    try {
      debouncerQueue.shift().flush();
    } catch(e) {
      setTimeout(() => {
        throw e;
      });
    }
  }
  return didFlush;
}

const flush = function() {
  let shadyDOM, debouncers;
  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();
    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }
    debouncers = flushDebouncers();
  } while (shadyDOM || debouncers);
};
/* harmony export (immutable) */ __webpack_exports__["b"] = flush;



/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Templatize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TemplateInstanceBase; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__ = __webpack_require__(15);




// Base class for HTMLTemplateElement extension that has property effects
// machinery for propagating host properties to children. This is an ES5
// class only because Babel (incorrectly) requires super() in the class
// constructor even though no `this` is used and it returns an instance.
let newInstance = null;
/**
 * @constructor
 * @extends {HTMLTemplateElement}
 */
function HTMLTemplateElementExtension() { return newInstance; }
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 * @extends {HTMLTemplateElementExtension}
 */
const DataTemplate = Object(__WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__["a" /* PropertyEffects */])(HTMLTemplateElementExtension);
/**
 * @constructor
 * @implements {Polymer_MutableData}
 * @extends {DataTemplate}
 */
const MutableDataTemplate = Object(__WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__["a" /* MutableData */])(DataTemplate);

// Applies a DataTemplate subclass to a <template> instance
function upgradeTemplate(template, constructor) {
  newInstance = template;
  Object.setPrototypeOf(template, constructor.prototype);
  new constructor();
  newInstance = null;
}

// Base class for TemplateInstance's
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 */
const base = Object(__WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__["a" /* PropertyEffects */])(class {});

/**
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @unrestricted
 */
class TemplateInstanceBase extends base {
  constructor(props) {
    super();
    this._configureProperties(props);
    this.root = this._stampTemplate(this.__dataHost);
    // Save list of stamped children
    let children = this.children = [];
    for (let n = this.root.firstChild; n; n=n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = this;
    }
    if (this.__templatizeOwner.__hideTemplateChildren__) {
      this._showHideChildren(true);
    }
    // Flush props only when props are passed if instance props exist
    // or when there isn't instance props.
    let options = this.__templatizeOptions;
    if ((props && options.instanceProps) || !options.instanceProps) {
      this._enableProperties();
    }
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   */
  _configureProperties(props) {
    let options = this.__templatizeOptions;
    if (props) {
      for (let iprop in options.instanceProps) {
        if (iprop in props) {
          this._setPendingProperty(iprop, props[iprop]);
        }
      }
    }
    for (let hprop in this.__hostProps) {
      this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
    }
  }
  /**
   * Forwards a host property to this instance.  This method should be
   * called on instances from the `options.forwardHostProp` callback
   * to propagate changes of host properties to each instance.
   *
   * Note this method enqueues the change, which are flushed as a batch.
   *
   * @param {string} prop Property or path name
   * @param {*} value Value of the property to forward
   */
  forwardHostProp(prop, value) {
    if (this._setPendingPropertyOrPath(prop, value, false, true)) {
      this.__dataHost._enqueueClient(this);
    }
  }
  /**
   * @override
   */
  _addEventListenerToNode(node, eventName, handler) {
    if (this._methodHost && this.__templatizeOptions.parentModel) {
      // If this instance should be considered a parent model, decorate
      // events this template instance as `model`
      this._methodHost._addEventListenerToNode(node, eventName, (e) => {
        e.model = this;
        handler(e);
      });
    } else {
      // Otherwise delegate to the template's host (which could be)
      // another template instance
      let templateHost = this.__dataHost.__dataHost;
      if (templateHost) {
        templateHost._addEventListenerToNode(node, eventName, handler);
      }
    }
  }
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hide Set to true to hide the children;
   * set to false to show them.
   * @protected
   */
  _showHideChildren(hide) {
    let c = this.children;
    for (let i=0; i<c.length; i++) {
      let n = c[i];
      // Ignore non-changes
      if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
        if (n.nodeType === Node.TEXT_NODE) {
          if (hide) {
            n.__polymerTextContent__ = n.textContent;
            n.textContent = '';
          } else {
            n.textContent = n.__polymerTextContent__;
          }
        } else if (n.style) {
          if (hide) {
            n.__polymerDisplay__ = n.style.display;
            n.style.display = 'none';
          } else {
            n.style.display = n.__polymerDisplay__;
          }
        }
      }
      n.__hideTemplateChildren__ = hide;
      if (n._showHideChildren) {
        n._showHideChildren(hide);
      }
    }
  }
  /**
   * Overrides default property-effects implementation to intercept
   * textContent bindings while children are "hidden" and cache in
   * private storage for later retrieval.
   *
   * @override
   */
  _setUnmanagedPropertyToNode(node, prop, value) {
    if (node.__hideTemplateChildren__ &&
        node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
      node.__polymerTextContent__ = value;
    } else {
      super._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
  /**
   * Find the parent model of this template instance.  The parent model
   * is either another templatize instance that had option `parentModel: true`,
   * or else the host element.
   *
   * @return {Polymer_PropertyEffects} The parent model of this instance
   */
  get parentModel() {
    let model = this.__parentModel;
    if (!model) {
      let options;
      model = this;
      do {
        // A template instance's `__dataHost` is a <template>
        // `model.__dataHost.__dataHost` is the template's host
        model = model.__dataHost.__dataHost;
      } while ((options = model.__templatizeOptions) && !options.parentModel);
      this.__parentModel = model;
    }
    return model;
  }
}

/** @type {!DataTemplate} */
TemplateInstanceBase.prototype.__dataHost;
/** @type {!TemplatizeOptions} */
TemplateInstanceBase.prototype.__templatizeOptions;
/** @type {!Polymer_PropertyEffects} */
TemplateInstanceBase.prototype._methodHost;
/** @type {!Object} */
TemplateInstanceBase.prototype.__templatizeOwner;
/** @type {!Object} */
TemplateInstanceBase.prototype.__hostProps;

/**
 * @constructor
 * @extends {TemplateInstanceBase}
 * @implements {Polymer_MutableData}
 */
const MutableTemplateInstanceBase = Object(__WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__["a" /* MutableData */])(TemplateInstanceBase);

function findMethodHost(template) {
  // Technically this should be the owner of the outermost template.
  // In shadow dom, this is always getRootNode().host, but we can
  // approximate this via cooperation with our dataHost always setting
  // `_methodHost` as long as there were bindings (or id's) on this
  // instance causing it to get a dataHost.
  let templateHost = template.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}

/* eslint-disable valid-jsdoc */
/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function createTemplatizerClass(template, templateInfo, options) {
  // Anonymous class created by the templatize
  let base = options.mutableData ?
    MutableTemplateInstanceBase : TemplateInstanceBase;
  /**
   * @constructor
   * @extends {base}
   */
  let klass = class extends base { };
  klass.prototype.__templatizeOptions = options;
  klass.prototype._bindTemplate(template);
  addNotifyEffects(klass, template, templateInfo, options);
  return klass;
}

/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function addPropagateEffects(template, templateInfo, options) {
  let userForwardHostProp = options.forwardHostProp;
  if (userForwardHostProp) {
    // Provide data API and property effects on memoized template class
    let klass = templateInfo.templatizeTemplateClass;
    if (!klass) {
      let base = options.mutableData ? MutableDataTemplate : DataTemplate;
      klass = templateInfo.templatizeTemplateClass =
        class TemplatizedTemplate extends base {};
      // Add template - >instances effects
      // and host <- template effects
      let hostProps = templateInfo.hostProps;
      for (let prop in hostProps) {
        klass.prototype._addPropertyEffect('_host_' + prop,
          klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
          {fn: createForwardHostPropEffect(prop, userForwardHostProp)});
        klass.prototype._createNotifyingProperty('_host_' + prop);
      }
    }
    upgradeTemplate(template, klass);
    // Mix any pre-bound data into __data; no need to flush this to
    // instances since they pull from the template at instance-time
    if (template.__dataProto) {
      // Note, generally `__dataProto` could be chained, but it's guaranteed
      // to not be since this is a vanilla template we just added effects to
      Object.assign(template.__data, template.__dataProto);
    }
    // Clear any pending data for performance
    template.__dataTemp = {};
    template.__dataPending = null;
    template.__dataOld = null;
    template._enableProperties();
  }
}
/* eslint-enable valid-jsdoc */

function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template, prop, props) {
    userForwardHostProp.call(template.__templatizeOwner,
      prop.substring('_host_'.length), props[prop]);
  };
}

function addNotifyEffects(klass, template, templateInfo, options) {
  let hostProps = templateInfo.hostProps || {};
  for (let iprop in options.instanceProps) {
    delete hostProps[iprop];
    let userNotifyInstanceProp = options.notifyInstanceProp;
    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(iprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        {fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)});
    }
  }
  if (options.forwardHostProp && template.__dataHost) {
    for (let hprop in hostProps) {
      klass.prototype._addPropertyEffect(hprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        {fn: createNotifyHostPropEffect()});
    }
  }
}

function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(inst.__templatizeOwner,
      inst, prop, props[prop]);
  };
}

function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
  };
}

/**
 * Module for preparing and stamping instances of templates that utilize
 * Polymer's data-binding and declarative event listener features.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     let TemplateClass = Polymer.Templatize.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = new TemplateClass({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
 *     this.shadowRoot.appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * The `options` dictionary passed to `templatize` allows for customizing
 * features of the generated template class, including how outer-scope host
 * properties should be forwarded into template instances, how any instance
 * properties added into the template's scope should be notified out to
 * the host, and whether the instance should be decorated as a "parent model"
 * of any event handlers.
 *
 *     // Customze property forwarding and event model decoration
 *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
 *       parentModel: true,
 *       instanceProps: {...},
 *       forwardHostProp(property, value) {...},
 *       notifyInstanceProp(instance, property, value) {...},
 *     });
 *
 *
 * @namespace
 * @memberof Polymer
 * @summary Module for preparing and stamping instances of templates
 *   utilizing Polymer templating features.
 */

const Templatize = {

  /**
   * Returns an anonymous `Polymer.PropertyEffects` class bound to the
   * `<template>` provided.  Instancing the class will result in the
   * template being stamped into document fragment stored as the instance's
   * `root` property, after which it can be appended to the DOM.
   *
   * Templates may utilize all Polymer data-binding features as well as
   * declarative event listeners.  Event listeners and inline computing
   * functions in the template will be called on the host of the template.
   *
   * The constructor returned takes a single argument dictionary of initial
   * property values to propagate into template bindings.  Additionally
   * host properties can be forwarded in, and instance properties can be
   * notified out by providing optional callbacks in the `options` dictionary.
   *
   * Valid configuration in `options` are as follows:
   *
   * - `forwardHostProp(property, value)`: Called when a property referenced
   *   in the template changed on the template's host. As this library does
   *   not retain references to templates instanced by the user, it is the
   *   templatize owner's responsibility to forward host property changes into
   *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
   *    method on the generated class should be called to forward host
   *   properties into the template to prevent unnecessary property-changed
   *   notifications. Any properties referenced in the template that are not
   *   defined in `instanceProps` will be notified up to the template's host
   *   automatically.
   * - `instanceProps`: Dictionary of property names that will be added
   *   to the instance by the templatize owner.  These properties shadow any
   *   host properties, and changes within the template to these properties
   *   will result in `notifyInstanceProp` being called.
   * - `mutableData`: When `true`, the generated class will skip strict
   *   dirty-checking for objects and arrays (always consider them to be
   *   "dirty").
   * - `notifyInstanceProp(instance, property, value)`: Called when
   *   an instance property changes.  Users may choose to call `notifyPath`
   *   on e.g. the owner to notify the change.
   * - `parentModel`: When `true`, events handled by declarative event listeners
   *   (`on-event="handler"`) will be decorated with a `model` property pointing
   *   to the template instance that stamped it.  It will also be returned
   *   from `instance.parentModel` in cases where template instance nesting
   *   causes an inner model to shadow an outer model.
   *
   * Note that the class returned from `templatize` is generated only once
   * for a given `<template>` using `options` from the first call for that
   * template, and the cached class is returned for all subsequent calls to
   * `templatize` for that template.  As such, `options` callbacks should not
   * close over owner-specific properties since only the first `options` is
   * used; rather, callbacks are called bound to the `owner`, and so context
   * needed from the callbacks (such as references to `instances` stamped)
   * should be stored on the `owner` such that they can be retrieved via `this`.
   *
   * @memberof Polymer.Templatize
   * @param {!HTMLTemplateElement} template Template to templatize
   * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
   *   any optional callbacks will be bound to this owner.
   * @param {Object=} options Options dictionary (see summary for details)
   * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
   *   provided
   * @suppress {invalidCasts}
   */
  templatize(template, owner, options) {
    options = /** @type {!TemplatizeOptions} */(options || {});
    if (template.__templatizeOwner) {
      throw new Error('A <template> can only be templatized once');
    }
    template.__templatizeOwner = owner;
    let templateInfo = owner.constructor._parseTemplate(template);
    // Get memoized base class for the prototypical template, which
    // includes property effects for binding template & forwarding
    let baseClass = templateInfo.templatizeInstanceClass;
    if (!baseClass) {
      baseClass = createTemplatizerClass(template, templateInfo, options);
      templateInfo.templatizeInstanceClass = baseClass;
    }
    // Host property forwarding must be installed onto template instance
    addPropagateEffects(template, templateInfo, options);
    // Subclass base class and add reference for this specific template
    let klass = class TemplateInstance extends baseClass {};
    klass.prototype._methodHost = findMethodHost(template);
    klass.prototype.__dataHost = template;
    klass.prototype.__templatizeOwner = owner;
    klass.prototype.__hostProps = templateInfo.hostProps;
    return /** @type {function(new:TemplateInstanceBase)} */(klass);
  },

  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model is an instance of
   * `TemplateInstanceBase`, and should be used to manipulate data
   * associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @memberof Polymer.Templatize
   * @param {HTMLTemplateElement} template The model will be returned for
   *   elements stamped from this template
   * @param {Node} node Node for which to return a template model.
   * @return {TemplateInstanceBase} Template instance representing the
   *   binding scope for the element
   */
  modelForElement(template, node) {
    let model;
    while (node) {
      // An element with a __templatizeInstance marks the top boundary
      // of a scope; walk up until we find one, and then ensure that
      // its __dataHost matches `this`, meaning this dom-repeat stamped it
      if ((model = node.__templatizeInstance)) {
        // Found an element stamped by another template; keep walking up
        // from its __dataHost
        if (model.__dataHost != template) {
          node = model.__dataHost;
        } else {
          return model;
        }
      } else {
        // Still in a template scope, keep going up until
        // a __templatizeInstance is found
        node = node.parentNode;
      }
    }
    return null;
  }
};





/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_control_state_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





const IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: [
    '_focusChanged(focused)',
    '_activeChanged(active, ariaActiveAttribute)'
  ],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler',
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function() {
    if (this.toggles) {
     // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant(/** @type {Node} */(target)))
      return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant(/** @type {Node} */(target)))
      return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function() {
    this.async(function() {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute,
                        active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["b"] = IronButtonStateImpl;


const IronButtonState = [
  __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */],
  IronButtonStateImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = IronButtonState;



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_meta_iron_meta_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);






Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        @apply --layout-inline;
        @apply --layout-center-center;
        position: relative;

        vertical-align: middle;

        fill: var(--iron-icon-fill-color, currentcolor);
        stroke: var(--iron-icon-stroke-color, none);

        width: var(--iron-icon-width, 24px);
        height: var(--iron-icon-height, 24px);
        @apply --iron-icon;
      }

      :host([hidden]) {
        display: none;
      }
    </style>
`,

  is: 'iron-icon',

  properties: {

    /**
     * The name of the icon to use. The name should be of the form:
     * `iconset_name:icon_name`.
     */
    icon: {
      type: String
    },

    /**
     * The name of the theme to used, if one is specified by the
     * iconset.
     */
    theme: {
      type: String
    },

    /**
     * If using iron-icon without an iconset, you can set the src to be
     * the URL of an individual icon image file. Note that this will take
     * precedence over a given icon attribute.
     */
    src: {
      type: String
    },

    /**
     * @type {!Polymer.IronMeta}
     */
    _meta: {
      value: __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__["a" /* Base */].create('iron-meta', {type: 'iconset'})
    }

  },

  observers: [
    '_updateIcon(_meta, isAttached)',
    '_updateIcon(theme, isAttached)',
    '_srcChanged(src, isAttached)',
    '_iconChanged(icon, isAttached)'
  ],

  _DEFAULT_ICONSET: 'icons',

  _iconChanged: function(icon) {
    var parts = (icon || '').split(':');
    this._iconName = parts.pop();
    this._iconsetName = parts.pop() || this._DEFAULT_ICONSET;
    this._updateIcon();
  },

  _srcChanged: function(src) {
    this._updateIcon();
  },

  _usesIconset: function() {
    return this.icon || !this.src;
  },

  /** @suppress {visibility} */
  _updateIcon: function() {
    if (this._usesIconset()) {
      if (this._img && this._img.parentNode) {
        Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.root).removeChild(this._img);
      }
      if (this._iconName === "") {
        if (this._iconset) {
          this._iconset.removeIcon(this);
        }
      } else if (this._iconsetName && this._meta) {
        this._iconset = /** @type {?Polymer.Iconset} */ (
          this._meta.byKey(this._iconsetName));
        if (this._iconset) {
          this._iconset.applyIcon(this, this._iconName, this.theme);
          this.unlisten(window, 'iron-iconset-added', '_updateIcon');
        } else {
          this.listen(window, 'iron-iconset-added', '_updateIcon');
        }
      }
    } else {
      if (this._iconset) {
        this._iconset.removeIcon(this);
      }
      if (!this._img) {
        this._img = document.createElement('img');
        this._img.style.width = '100%';
        this._img.style.height = '100%';
        this._img.draggable = false;
      }
      this._img.src = this.src;
      Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.root).appendChild(this._img);
    }
  }
});


/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IronMeta; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);



/**
 * @constructor
 * @param {{type: (string|null), key: (string|null), value: *}} options
 */
function IronMeta(options) {
  this.type = (options && options.type) || 'default';
  this.key = options && options.key;
  if ('value' in options) {
    this.value = options.value;
  }
}

IronMeta.types = {};

IronMeta.prototype = {
  get value() {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      return IronMeta.types[type] && IronMeta.types[type][key];
    }
  },

  set value(value) {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      type = IronMeta.types[type] = IronMeta.types[type] || {};
      if (value == null) {
        delete type[key];
      } else {
        type[key] = value;
      }
    }
  },

  get list() {
    var type = this.type;

    if (type) {
      return Object.keys(IronMeta.types[this.type]).map(function(key) {
        return metaDatas[this.type][key];
      }, this);
    }
  },

  byKey: function(key) {
    this.key = key;
    return this.value;
  }
};



var metaDatas = IronMeta.types;

Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({

  is: 'iron-meta',

  properties: {

    /**
     * The type of meta-data.  All meta-data of the same type is stored
     * together.
     * @type {string}
     */
    type: {
      type: String,
      value: 'default',
    },

    /**
     * The key used to store `value` under the `type` namespace.
     * @type {?string}
     */
    key: {
      type: String,
    },

    /**
     * The meta-data to store or retrieve.
     * @type {*}
     */
    value: {
      type: String,
      notify: true,
    },

    /**
     * If true, `value` is set to the iron-meta instance itself.
     */
     self: {
      type: Boolean,
      observer: '_selfChanged'
    },

    __meta: {
      type: Boolean,
      computed: '__computeMeta(type, key, value)'
    }
  },

  hostAttributes: {
    hidden: true
  },

  __computeMeta: function(type, key, value) {
    var meta = new IronMeta({
      type: type,
      key: key
    });

    if (value !== undefined && value !== meta.value) {
      meta.value = value;
    } else if (this.value !== meta.value) {
      this.value = meta.value;
    }

    return meta;
  },

  get list() {
    return this.__meta && this.__meta.list;
  },

  _selfChanged: function(self) {
    if (self) {
      this.value = this;
    }
  },

  /**
   * Retrieves meta data value by key.
   *
   * @method byKey
   * @param {string} key The key of the meta-data to be returned.
   * @return {*}
   */
  byKey: function(key) {
    return new IronMeta({
      type: this.type,
      key: key
    }).value;
  }
});


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__ = __webpack_require__(18);





const PaperInkyFocusBehaviorImpl = {
  observers: [
    '_focusedChanged(receivedFocusFromKeyboard)'
  ],

  _focusedChanged: function(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function() {
    var ripple = __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */]._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};
/* harmony export (immutable) */ __webpack_exports__["b"] = PaperInkyFocusBehaviorImpl;


const PaperInkyFocusBehavior = [
  __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["a" /* IronButtonState */],
  __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__["a" /* IronControlState */],
  __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */],
  PaperInkyFocusBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperInkyFocusBehavior;



/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["ajax"] = ajax;
/* harmony export (immutable) */ __webpack_exports__["ajaxGet"] = ajaxGet;
/* harmony export (immutable) */ __webpack_exports__["ajaxPost"] = ajaxPost;
/* harmony export (immutable) */ __webpack_exports__["ajaxPut"] = ajaxPut;
/* harmony export (immutable) */ __webpack_exports__["ajaxDelete"] = ajaxDelete;
function ajax(url, data, method, headers, successCallback, errorCallback) {
  var config = {
    method: method,
    headers: headers
  };

  if (typeof data != "undefined") {
    config.body = JSON.stringify(data);
  }

  fetch(url, config).then(response => {
    if (response.ok) {
      return Promise.resolve(response);
    } else {
      return Promise.reject(new Error('Failed to post data'));
    }
  }).then(response => response.json()) // parse response as JSON
  .then(data => {
    if (typeof successCallback === "function") {
      successCallback(data);
    }
  }).catch(function (error) {
    console.log(`Error: ${error.message}`);

    if (typeof errorCallback === "function") {
      errorCallback(error);
    }
  });
}
function ajaxGet(url, successCallback, errorCallback) {
  var headers = new Headers();
  ajax(url, undefined, "GET", headers, successCallback, errorCallback);
}
function ajaxPost(url, data, successCallback, errorCallback) {
  var headers = new Headers();
  headers.append("Content-Type", "application/json");
  ajax(url, data, "POST", headers, successCallback, errorCallback);
}
function ajaxPut(url, data, successCallback, errorCallback) {
  var headers = new Headers();
  headers.append("Content-Type", "application/json");
  ajax(url, data, "PUT", headers, successCallback, errorCallback);
}
function ajaxDelete(url, successCallback, errorCallback) {
  var headers = new Headers();
  ajax(url, undefined, "DELETE", headers, successCallback, errorCallback);
}

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);





var Utility = {
  distance: function(x1, y1, x2, y2) {
    var xDelta = (x1 - x2);
    var yDelta = (y1 - y2);

    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
  },

  now: window.performance && window.performance.now ?
      window.performance.now.bind(window.performance) : Date.now
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function ElementMetrics(element) {
  this.element = element;
  this.width = this.boundingRect.width;
  this.height = this.boundingRect.height;

  this.size = Math.max(this.width, this.height);
}

ElementMetrics.prototype = {
  get boundingRect () {
    return this.element.getBoundingClientRect();
  },

  furthestCornerDistanceFrom: function(x, y) {
    var topLeft = Utility.distance(x, y, 0, 0);
    var topRight = Utility.distance(x, y, this.width, 0);
    var bottomLeft = Utility.distance(x, y, 0, this.height);
    var bottomRight = Utility.distance(x, y, this.width, this.height);

    return Math.max(topLeft, topRight, bottomLeft, bottomRight);
  }
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function Ripple(element) {
  this.element = element;
  this.color = window.getComputedStyle(element).color;

  this.wave = document.createElement('div');
  this.waveContainer = document.createElement('div');
  this.wave.style.backgroundColor = this.color;
  this.wave.classList.add('wave');
  this.waveContainer.classList.add('wave-container');
  Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.waveContainer).appendChild(this.wave);

  this.resetInteractionState();
}

Ripple.MAX_RADIUS = 300;

Ripple.prototype = {
  get recenters() {
    return this.element.recenters;
  },

  get center() {
    return this.element.center;
  },

  get mouseDownElapsed() {
    var elapsed;

    if (!this.mouseDownStart) {
      return 0;
    }

    elapsed = Utility.now() - this.mouseDownStart;

    if (this.mouseUpStart) {
      elapsed -= this.mouseUpElapsed;
    }

    return elapsed;
  },

  get mouseUpElapsed() {
    return this.mouseUpStart ?
      Utility.now () - this.mouseUpStart : 0;
  },

  get mouseDownElapsedSeconds() {
    return this.mouseDownElapsed / 1000;
  },

  get mouseUpElapsedSeconds() {
    return this.mouseUpElapsed / 1000;
  },

  get mouseInteractionSeconds() {
    return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
  },

  get initialOpacity() {
    return this.element.initialOpacity;
  },

  get opacityDecayVelocity() {
    return this.element.opacityDecayVelocity;
  },

  get radius() {
    var width2 = this.containerMetrics.width * this.containerMetrics.width;
    var height2 = this.containerMetrics.height * this.containerMetrics.height;
    var waveRadius = Math.min(
      Math.sqrt(width2 + height2),
      Ripple.MAX_RADIUS
    ) * 1.1 + 5;

    var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
    var timeNow = this.mouseInteractionSeconds / duration;
    var size = waveRadius * (1 - Math.pow(80, -timeNow));

    return Math.abs(size);
  },

  get opacity() {
    if (!this.mouseUpStart) {
      return this.initialOpacity;
    }

    return Math.max(
      0,
      this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity
    );
  },

  get outerOpacity() {
    // Linear increase in background opacity, capped at the opacity
    // of the wavefront (waveOpacity).
    var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
    var waveOpacity = this.opacity;

    return Math.max(
      0,
      Math.min(outerOpacity, waveOpacity)
    );
  },

  get isOpacityFullyDecayed() {
    return this.opacity < 0.01 &&
      this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isRestingAtMaxRadius() {
    return this.opacity >= this.initialOpacity &&
      this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isAnimationComplete() {
    return this.mouseUpStart ?
      this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
  },

  get translationFraction() {
    return Math.min(
      1,
      this.radius / this.containerMetrics.size * 2 / Math.sqrt(2)
    );
  },

  get xNow() {
    if (this.xEnd) {
      return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
    }

    return this.xStart;
  },

  get yNow() {
    if (this.yEnd) {
      return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
    }

    return this.yStart;
  },

  get isMouseDown() {
    return this.mouseDownStart && !this.mouseUpStart;
  },

  resetInteractionState: function() {
    this.maxRadius = 0;
    this.mouseDownStart = 0;
    this.mouseUpStart = 0;

    this.xStart = 0;
    this.yStart = 0;
    this.xEnd = 0;
    this.yEnd = 0;
    this.slideDistance = 0;

    this.containerMetrics = new ElementMetrics(this.element);
  },

  draw: function() {
    var scale;
    var translateString;
    var dx;
    var dy;

    this.wave.style.opacity = this.opacity;

    scale = this.radius / (this.containerMetrics.size / 2);
    dx = this.xNow - (this.containerMetrics.width / 2);
    dy = this.yNow - (this.containerMetrics.height / 2);


    // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
    // https://bugs.webkit.org/show_bug.cgi?id=98538
    this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
    this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
    this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
    this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
  },

  /** @param {Event=} event */
  downAction: function(event) {
    var xCenter = this.containerMetrics.width / 2;
    var yCenter = this.containerMetrics.height / 2;

    this.resetInteractionState();
    this.mouseDownStart = Utility.now();

    if (this.center) {
      this.xStart = xCenter;
      this.yStart = yCenter;
      this.slideDistance = Utility.distance(
        this.xStart, this.yStart, this.xEnd, this.yEnd
      );
    } else {
      this.xStart = event ?
          event.detail.x - this.containerMetrics.boundingRect.left :
          this.containerMetrics.width / 2;
      this.yStart = event ?
          event.detail.y - this.containerMetrics.boundingRect.top :
          this.containerMetrics.height / 2;
    }

    if (this.recenters) {
      this.xEnd = xCenter;
      this.yEnd = yCenter;
      this.slideDistance = Utility.distance(
        this.xStart, this.yStart, this.xEnd, this.yEnd
      );
    }

    this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
      this.xStart,
      this.yStart
    );

    this.waveContainer.style.top =
      (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
    this.waveContainer.style.left =
      (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

    this.waveContainer.style.width = this.containerMetrics.size + 'px';
    this.waveContainer.style.height = this.containerMetrics.size + 'px';
  },

  /** @param {Event=} event */
  upAction: function(event) {
    if (!this.isMouseDown) {
      return;
    }

    this.mouseUpStart = Utility.now();
  },

  remove: function() {
    Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.waveContainer.parentNode).removeChild(
      this.waveContainer
    );
  }
};

Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: block;
        position: absolute;
        border-radius: inherit;
        overflow: hidden;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;

        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,
         * creating a node (with a position:absolute) in the middle of an event
         * handler "interrupts" that event handler (which happens when the
         * ripple is created on demand) */
        pointer-events: none;
      }

      :host([animating]) {
        /* This resolves a rendering issue in Chrome (as of 40) where the
           ripple is not properly clipped by its parent (which may have
           rounded corners). See: http://jsbin.com/temexa/4

           Note: We only apply this style conditionally. Otherwise, the browser
           will create a new compositing layer for every ripple element on the
           page, and that would be bad. */
        -webkit-transform: translate(0, 0);
        transform: translate3d(0, 0, 0);
      }

      #background,
      #waves,
      .wave-container,
      .wave {
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      #background,
      .wave {
        opacity: 0;
      }

      #waves,
      .wave {
        overflow: hidden;
      }

      .wave-container,
      .wave {
        border-radius: 50%;
      }

      :host(.circle) #background,
      :host(.circle) #waves {
        border-radius: 50%;
      }

      :host(.circle) .wave-container {
        overflow: hidden;
      }
    </style>

    <div id="background"></div>
    <div id="waves"></div>
`,

  is: 'paper-ripple',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */]
  ],

  properties: {
    /**
     * The initial opacity set on the wave.
     *
     * @attribute initialOpacity
     * @type number
     * @default 0.25
     */
    initialOpacity: {
      type: Number,
      value: 0.25
    },

    /**
     * How fast (opacity per second) the wave fades out.
     *
     * @attribute opacityDecayVelocity
     * @type number
     * @default 0.8
     */
    opacityDecayVelocity: {
      type: Number,
      value: 0.8
    },

    /**
     * If true, ripples will exhibit a gravitational pull towards
     * the center of their container as they fade away.
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    recenters: {
      type: Boolean,
      value: false
    },

    /**
     * If true, ripples will center inside its container
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    center: {
      type: Boolean,
      value: false
    },

    /**
     * A list of the visual ripples.
     *
     * @attribute ripples
     * @type Array
     * @default []
     */
    ripples: {
      type: Array,
      value: function() {
        return [];
      }
    },

    /**
     * True when there are visible ripples animating within the
     * element.
     */
    animating: {
      type: Boolean,
      readOnly: true,
      reflectToAttribute: true,
      value: false
    },

    /**
     * If true, the ripple will remain in the "down" state until `holdDown`
     * is set to false again.
     */
    holdDown: {
      type: Boolean,
      value: false,
      observer: '_holdDownChanged'
    },

    /**
     * If true, the ripple will not generate a ripple effect
     * via pointer interaction.
     * Calling ripple's imperative api like `simulatedRipple` will
     * still generate the ripple effect.
     */
    noink: {
      type: Boolean,
      value: false
    },

    _animating: {
      type: Boolean
    },

    _boundAnimate: {
      type: Function,
      value: function() {
        return this.animate.bind(this);
      }
    }
  },

  get target () {
    return this.keyEventTarget;
  },

  keyBindings: {
    'enter:keydown': '_onEnterKeydown',
    'space:keydown': '_onSpaceKeydown',
    'space:keyup': '_onSpaceKeyup'
  },

  attached: function() {
    // Set up a11yKeysBehavior to listen to key events on the target,
    // so that space and enter activate the ripple even if the target doesn't
    // handle key events. The key handlers deal with `noink` themselves.
    if (this.parentNode.nodeType == 11) { // DOCUMENT_FRAGMENT_NODE
      this.keyEventTarget = Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).getOwnerRoot().host;
    } else {
      this.keyEventTarget = this.parentNode;
    }
    var keyEventTarget = /** @type {!EventTarget} */ (this.keyEventTarget);
    this.listen(keyEventTarget, 'up', 'uiUpAction');
    this.listen(keyEventTarget, 'down', 'uiDownAction');
  },

  detached: function() {
    this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
    this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
    this.keyEventTarget = null;
  },

  get shouldKeepAnimating () {
    for (var index = 0; index < this.ripples.length; ++index) {
      if (!this.ripples[index].isAnimationComplete) {
        return true;
      }
    }

    return false;
  },

  simulatedRipple: function() {
    this.downAction(null);

    // Please see polymer/polymer#1305
    this.async(function() {
      this.upAction();
    }, 1);
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiDownAction: function(event) {
    if (!this.noink) {
      this.downAction(event);
    }
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  downAction: function(event) {
    if (this.holdDown && this.ripples.length > 0) {
      return;
    }

    var ripple = this.addRipple();

    ripple.downAction(event);

    if (!this._animating) {
      this._animating = true;
      this.animate();
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiUpAction: function(event) {
    if (!this.noink) {
      this.upAction(event);
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  upAction: function(event) {
    if (this.holdDown) {
      return;
    }

    this.ripples.forEach(function(ripple) {
      ripple.upAction(event);
    });

    this._animating = true;
    this.animate();
  },

  onAnimationComplete: function() {
    this._animating = false;
    this.$.background.style.backgroundColor = null;
    this.fire('transitionend');
  },

  addRipple: function() {
    var ripple = new Ripple(this);

    Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.$.waves).appendChild(ripple.waveContainer);
    this.$.background.style.backgroundColor = ripple.color;
    this.ripples.push(ripple);

    this._setAnimating(true);

    return ripple;
  },

  removeRipple: function(ripple) {
    var rippleIndex = this.ripples.indexOf(ripple);

    if (rippleIndex < 0) {
      return;
    }

    this.ripples.splice(rippleIndex, 1);

    ripple.remove();

    if (!this.ripples.length) {
      this._setAnimating(false);
    }
  },

  /**
   * This conflicts with Element#antimate().
   * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
   * @suppress {checkTypes}
   */
  animate: function() {
    if (!this._animating) {
      return;
    }
    var index;
    var ripple;

    for (index = 0; index < this.ripples.length; ++index) {
      ripple = this.ripples[index];

      ripple.draw();

      this.$.background.style.opacity = ripple.outerOpacity;

      if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
        this.removeRipple(ripple);
      }
    }

    if (!this.shouldKeepAnimating && this.ripples.length === 0) {
      this.onAnimationComplete();
    } else {
      window.requestAnimationFrame(this._boundAnimate);
    }
  },

  _onEnterKeydown: function() {
    this.uiDownAction();
    this.async(this.uiUpAction, 1);
  },

  _onSpaceKeydown: function() {
    this.uiDownAction();
  },

  _onSpaceKeyup: function() {
    this.uiUpAction();
  },

  // note: holdDown does not respect noink since it can be a focus based
  // effect.
  _holdDownChanged: function(newVal, oldVal) {
    if (oldVal === undefined) {
      return;
    }
    if (newVal) {
      this.downAction();
    } else {
      this.upAction();
    }
  }

  /**
  Fired when the animation finishes.
  This is useful if you want to wait until
  the ripple animation finishes to perform some action.

  @event transitionend
  @param {{node: Object}} detail Contains the animated node.
  */
});


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_shadycss_entrypoints_apply_shim_js__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_element_mixin_js__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixins_gesture_event_listeners_js__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_import_href_js__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_render_status_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_unresolved_js__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_unresolved_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__utils_unresolved_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_gestures_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_debounce_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_async_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__utils_path_js__ = __webpack_require__(12);













let styleInterface = window.ShadyCSS;

const LegacyElementMixin = Object(__WEBPACK_IMPORTED_MODULE_3__utils_mixin_js__["a" /* dedupingMixin */])((base) => {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_ElementMixin}
   * @implements {Polymer_GestureEventListeners}
   */
  const legacyElementBase = Object(__WEBPACK_IMPORTED_MODULE_2__mixins_gesture_event_listeners_js__["a" /* GestureEventListeners */])(Object(__WEBPACK_IMPORTED_MODULE_1__mixins_element_mixin_js__["a" /* ElementMixin */])(base));

  /**
   * Map of simple names to touch action names
   * @dict
   */
  const DIRECTION_MAP = {
    'x': 'pan-x',
    'y': 'pan-y',
    'none': 'none',
    'all': 'auto'
  };

  /**
   * @polymer
   * @mixinClass
   * @extends {legacyElementBase}
   * @implements {Polymer_LegacyElementMixin}
   * @unrestricted
   */
  class LegacyElement extends legacyElementBase {

    constructor() {
      super();
      this.root = this;
      /** @type {boolean} */
      this.isAttached;
      /** @type {WeakMap<!Element, !Object<string, !Function>>} */
      this.__boundListeners;
      /** @type {Object<string, Function>} */
      this._debouncers;
      this.created();
    }

    /**
     * Legacy callback called during the `constructor`, for overriding
     * by the user.
     */
    created() {}

    /**
     * Provides an implementation of `connectedCallback`
     * which adds Polymer legacy API's `attached` method.
     * @override
     */
    connectedCallback() {
      super.connectedCallback();
      this.isAttached = true;
      this.attached();
    }

    /**
     * Legacy callback called during `connectedCallback`, for overriding
     * by the user.
     */
    attached() {}

    /**
     * Provides an implementation of `disconnectedCallback`
     * which adds Polymer legacy API's `detached` method.
     * @override
     */
    disconnectedCallback() {
      super.disconnectedCallback();
      this.isAttached = false;
      this.detached();
    }

    /**
     * Legacy callback called during `disconnectedCallback`, for overriding
     * by the user.
     */
    detached() {}

    /**
     * Provides an override implementation of `attributeChangedCallback`
     * which adds the Polymer legacy API's `attributeChanged` method.
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @override
     */
    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        super.attributeChangedCallback(name, old, value);
        this.attributeChanged(name, old, value);
      }
    }

    /**
     * Legacy callback called during `attributeChangedChallback`, for overriding
     * by the user.
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     */
    attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

    /**
     * Overrides the default `Polymer.PropertyEffects` implementation to
     * add support for class initialization via the `_registered` callback.
     * This is called only when the first instance of the element is created.
     *
     * @override
     */
    _initializeProperties() {
      let proto = Object.getPrototypeOf(this);
      if (!proto.hasOwnProperty('__hasRegisterFinished')) {
        proto.__hasRegisterFinished = true;
        this._registered();
      }
      super._initializeProperties();
    }

    /**
     * Called automatically when an element is initializing.
     * Users may override this method to perform class registration time
     * work. The implementation should ensure the work is performed
     * only once for the class.
     * @protected
     */
    _registered() {}

    /**
     * Overrides the default `Polymer.PropertyEffects` implementation to
     * add support for installing `hostAttributes` and `listeners`.
     *
     * @override
     */
    ready() {
      this._ensureAttributes();
      this._applyListeners();
      super.ready();
    }

    /**
     * Ensures an element has required attributes. Called when the element
     * is being readied via `ready`. Users should override to set the
     * element's required attributes. The implementation should be sure
     * to check and not override existing attributes added by
     * the user of the element. Typically, setting attributes should be left
     * to the element user and not done here; reasonable exceptions include
     * setting aria roles and focusability.
     * @protected
     */
    _ensureAttributes() {}

    /**
     * Adds element event listeners. Called when the element
     * is being readied via `ready`. Users should override to
     * add any required element event listeners.
     * In performance critical elements, the work done here should be kept
     * to a minimum since it is done before the element is rendered. In
     * these elements, consider adding listeners asychronously so as not to
     * block render.
     * @protected
     */
    _applyListeners() {}

    /**
     * Converts a typed JavaScript value to a string.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features. To customize
     * how properties are serialized to attributes for attribute bindings and
     * `reflectToAttribute: true` properties as well as this method, override
     * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
     *
     * @param {*} value Value to deserialize
     * @return {string | undefined} Serialized value
     */
    serialize(value) {
      return this._serializeValue(value);
    }

    /**
     * Converts a string to a typed JavaScript value.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.  To customize
     * how attributes are deserialized to properties for in
     * `attributeChangedCallback`, override `_deserializeValue` method
     * provided by `Polymer.PropertyAccessors`.
     *
     * @param {string} value String to deserialize
     * @param {*} type Type to deserialize the string to
     * @return {*} Returns the deserialized value in the `type` given.
     */
    deserialize(value, type) {
      return this._deserializeValue(value, type);
    }

    /**
     * Serializes a property to its associated attribute.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect.
     * @param {*=} value Property value to refect.
     */
    reflectPropertyToAttribute(property, attribute, value) {
      this._propertyToAttribute(property, attribute, value);
    }

    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     *
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @param {Element} node Element to set attribute to.
     */
    serializeValueToAttribute(value, attribute, node) {
      this._valueToNodeAttribute(/** @type {Element} */ (node || this), value, attribute);
    }

    /**
     * Copies own properties (including accessor descriptors) from a source
     * object to a target object.
     *
     * @param {Object} prototype Target object to copy properties to.
     * @param {Object} api Source object to copy properties from.
     * @return {Object} prototype object that was passed as first argument.
     */
    extend(prototype, api) {
      if (!(prototype && api)) {
        return prototype || api;
      }
      let n$ = Object.getOwnPropertyNames(api);
      for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {
        let pd = Object.getOwnPropertyDescriptor(api, n);
        if (pd) {
          Object.defineProperty(prototype, n, pd);
        }
      }
      return prototype;
    }

    /**
     * Copies props from a source object to a target object.
     *
     * Note, this method uses a simple `for...in` strategy for enumerating
     * properties.  To ensure only `ownProperties` are copied from source
     * to target and that accessor implementations are copied, use `extend`.
     *
     * @param {Object} target Target object to copy properties to.
     * @param {Object} source Source object to copy properties from.
     * @return {Object} Target object that was passed as first argument.
     */
    mixin(target, source) {
      for (let i in source) {
        target[i] = source[i];
      }
      return target;
    }

    /**
     * Sets the prototype of an object.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     * @param {Object} object The object on which to set the prototype.
     * @param {Object} prototype The prototype that will be set on the given
     * `object`.
     * @return {Object} Returns the given `object` with its prototype set
     * to the given `prototype` object.
     */
    chainObject(object, prototype) {
      if (object && prototype && object !== prototype) {
        object.__proto__ = prototype;
      }
      return object;
    }

    /* **** Begin Template **** */

    /**
     * Calls `importNode` on the `content` of the `template` specified and
     * returns a document fragment containing the imported content.
     *
     * @param {HTMLTemplateElement} template HTML template element to instance.
     * @return {DocumentFragment} Document fragment containing the imported
     *   template content.
    */
    instanceTemplate(template) {
      let content = this.constructor._contentForTemplate(template);
      let dom = /** @type {DocumentFragment} */
        (document.importNode(content, true));
      return dom;
    }

    /* **** Begin Events **** */



    /**
     * Dispatches a custom event with an optional detail value.
     *
     * @param {string} type Name of event type.
     * @param {*=} detail Detail value containing event-specific
     *   payload.
     * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
     *  options Object specifying options.  These may include:
     *  `bubbles` (boolean, defaults to `true`),
     *  `cancelable` (boolean, defaults to false), and
     *  `node` on which to fire the event (HTMLElement, defaults to `this`).
     * @return {Event} The new event that was fired.
     */
    fire(type, detail, options) {
      options = options || {};
      detail = (detail === null || detail === undefined) ? {} : detail;
      let event = new Event(type, {
        bubbles: options.bubbles === undefined ? true : options.bubbles,
        cancelable: Boolean(options.cancelable),
        composed: options.composed === undefined ? true: options.composed
      });
      event.detail = detail;
      let node = options.node || this;
      node.dispatchEvent(event);
      return event;
    }

    /**
     * Convenience method to add an event listener on a given element,
     * late bound to a named method on this element.
     *
     * @param {Element} node Element to add event listener to.
     * @param {string} eventName Name of event to listen for.
     * @param {string} methodName Name of handler method on `this` to call.
     */
    listen(node, eventName, methodName) {
      node = /** @type {!Element} */ (node || this);
      let hbl = this.__boundListeners ||
        (this.__boundListeners = new WeakMap());
      let bl = hbl.get(node);
      if (!bl) {
        bl = {};
        hbl.set(node, bl);
      }
      let key = eventName + methodName;
      if (!bl[key]) {
        bl[key] = this._addMethodEventListenerToNode(
          node, eventName, methodName, this);
      }
    }

    /**
     * Convenience method to remove an event listener from a given element,
     * late bound to a named method on this element.
     *
     * @param {Element} node Element to remove event listener from.
     * @param {string} eventName Name of event to stop listening to.
     * @param {string} methodName Name of handler method on `this` to not call
     anymore.
     */
    unlisten(node, eventName, methodName) {
      node = /** @type {!Element} */ (node || this);
      let bl = this.__boundListeners && this.__boundListeners.get(node);
      let key = eventName + methodName;
      let handler = bl && bl[key];
      if (handler) {
        this._removeEventListenerFromNode(node, eventName, handler);
        bl[key] = null;
      }
    }

    /**
     * Override scrolling behavior to all direction, one direction, or none.
     *
     * Valid scroll directions:
     *   - 'all': scroll in any direction
     *   - 'x': scroll only in the 'x' direction
     *   - 'y': scroll only in the 'y' direction
     *   - 'none': disable scrolling for this node
     *
     * @param {string=} direction Direction to allow scrolling
     * Defaults to `all`.
     * @param {Element=} node Element to apply scroll direction setting.
     * Defaults to `this`.
     */
    setScrollDirection(direction, node) {
      Object(__WEBPACK_IMPORTED_MODULE_8__utils_gestures_js__["setTouchAction"])( (node || this), DIRECTION_MAP[direction] || 'auto');
    }
    /* **** End Events **** */

    /**
     * Convenience method to run `querySelector` on this local DOM scope.
     *
     * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
     *
     * @param {string} slctr Selector to run on this local DOM scope
     * @return {Element} Element found by the selector, or null if not found.
     */
    $$(slctr) {
      return this.root.querySelector(slctr);
    }

    /**
     * Return the element whose local dom within which this element
     * is contained. This is a shorthand for
     * `this.getRootNode().host`.
     * @this {Element}
     */
    get domHost() {
      let root = this.getRootNode();
      return (root instanceof DocumentFragment) ? /** @type {ShadowRoot} */ (root).host : root;
    }

    /**
     * Force this element to distribute its children to its local dom.
     * This should not be necessary as of Polymer 2.0.2 and is provided only
     * for backwards compatibility.
     */
    distributeContent() {
      if (window.ShadyDOM && this.shadowRoot) {
        ShadyDOM.flush();
      }
    }

    /**
     * Returns a list of nodes that are the effective childNodes. The effective
     * childNodes list is the same as the element's childNodes except that
     * any `<content>` elements are replaced with the list of nodes distributed
     * to the `<content>`, the result of its `getDistributedNodes` method.
     * @this {Element}
     * @return {Array<Node>} List of effctive child nodes.
     */
    getEffectiveChildNodes() {
      return (
        /** @type {Polymer.DomApi} */ (Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["a" /* dom */])(this)).getEffectiveChildNodes()
      );
    }

    /**
     * Returns a list of nodes distributed within this element that match
     * `selector`. These can be dom children or elements distributed to
     * children that are insertion points.
     * @param {string} selector Selector to run.
     * @this {Element}
     * @return {Array<Node>} List of distributed elements that match selector.
     */
    queryDistributedElements(selector) {
      return (
        /** @type {Polymer.DomApi} */ (Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["a" /* dom */])(this)).queryDistributedElements(selector)
      );
    }

    /**
     * Returns a list of elements that are the effective children. The effective
     * children list is the same as the element's children except that
     * any `<content>` elements are replaced with the list of elements
     * distributed to the `<content>`.
     *
     * @return {Array<Node>} List of effctive children.
     */
    getEffectiveChildren() {
      let list = this.getEffectiveChildNodes();
      return list.filter(function(/** @type {Node} */ n) {
        return (n.nodeType === Node.ELEMENT_NODE);
      });
    }

    /**
     * Returns a string of text content that is the concatenation of the
     * text content's of the element's effective childNodes (the elements
     * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
     *
     * @return {string} List of effctive children.
     */
    getEffectiveTextContent() {
      let cn = this.getEffectiveChildNodes();
      let tc = [];
      for (let i=0, c; (c = cn[i]); i++) {
        if (c.nodeType !== Node.COMMENT_NODE) {
          tc.push(c.textContent);
        }
      }
      return tc.join('');
    }

    /**
     * Returns the first effective childNode within this element that
     * match `selector`. These can be dom child nodes or elements distributed
     * to children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {Object<Node>} First effective child node that matches selector.
     */
    queryEffectiveChildren(selector) {
      let e$ = this.queryDistributedElements(selector);
      return e$ && e$[0];
    }

    /**
     * Returns a list of effective childNodes within this element that
     * match `selector`. These can be dom child nodes or elements distributed
     * to children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {Array<Node>} List of effective child nodes that match selector.
     */
    queryAllEffectiveChildren(selector) {
      return this.queryDistributedElements(selector);
    }

    /**
     * Returns a list of nodes distributed to this element's `<slot>`.
     *
     * If this element contains more than one `<slot>` in its local DOM,
     * an optional selector may be passed to choose the desired content.
     *
     * @param {string=} slctr CSS selector to choose the desired
     *   `<slot>`.  Defaults to `content`.
     * @return {Array<Node>} List of distributed nodes for the `<slot>`.
     */
    getContentChildNodes(slctr) {
      let content = this.root.querySelector(slctr || 'slot');
      return content ? /** @type {Polymer.DomApi} */(Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["a" /* dom */])(content)).getDistributedNodes() : [];
    }

    /**
     * Returns a list of element children distributed to this element's
     * `<slot>`.
     *
     * If this element contains more than one `<slot>` in its
     * local DOM, an optional selector may be passed to choose the desired
     * content.  This method differs from `getContentChildNodes` in that only
     * elements are returned.
     *
     * @param {string=} slctr CSS selector to choose the desired
     *   `<content>`.  Defaults to `content`.
     * @return {Array<HTMLElement>} List of distributed nodes for the
     *   `<slot>`.
     * @suppress {invalidCasts}
     */
    getContentChildren(slctr) {
      return /** @type {Array<HTMLElement>} */(this.getContentChildNodes(slctr).filter(function(n) {
        return (n.nodeType === Node.ELEMENT_NODE);
      }));
    }

    /**
     * Checks whether an element is in this element's light DOM tree.
     *
     * @param {?Node} node The element to be checked.
     * @this {Element}
     * @return {boolean} true if node is in this element's light DOM tree.
     */
    isLightDescendant(node) {
      return this !== node && this.contains(node) &&
          this.getRootNode() === node.getRootNode();
    }

    /**
     * Checks whether an element is in this element's local DOM tree.
     *
     * @param {Element=} node The element to be checked.
     * @return {boolean} true if node is in this element's local DOM tree.
     */
    isLocalDescendant(node) {
      return this.root === node.getRootNode();
    }

    // NOTE: should now be handled by ShadyCss library.
    scopeSubtree(container, shouldObserve) { // eslint-disable-line no-unused-vars
    }

    /**
     * Returns the computed style value for the given property.
     * @param {string} property The css property name.
     * @return {string} Returns the computed css property value for the given
     * `property`.
     */
    getComputedStyleValue(property) {
      return styleInterface.getComputedStyleValue(this, property);
    }

    // debounce

    /**
     * Call `debounce` to collapse multiple requests for a named task into
     * one invocation which is made after the wait time has elapsed with
     * no new request.  If no wait time is given, the callback will be called
     * at microtask timing (guaranteed before paint).
     *
     *     debouncedClickAction(e) {
     *       // will not call `processClick` more than once per 100ms
     *       this.debounce('click', function() {
     *        this.processClick();
     *       } 100);
     *     }
     *
     * @param {string} jobName String to indentify the debounce job.
     * @param {function()} callback Function that is called (with `this`
     *   context) when the wait time elapses.
     * @param {number} wait Optional wait time in milliseconds (ms) after the
     *   last signal that must elapse before invoking `callback`
     * @return {Object} Returns a debouncer object on which exists the
     * following methods: `isActive()` returns true if the debouncer is
     * active; `cancel()` cancels the debouncer if it is active;
     * `flush()` immediately invokes the debounced callback if the debouncer
     * is active.
     */
    debounce(jobName, callback, wait) {
      this._debouncers = this._debouncers || {};
      return this._debouncers[jobName] = __WEBPACK_IMPORTED_MODULE_9__utils_debounce_js__["a" /* Debouncer */].debounce(
            this._debouncers[jobName]
          , wait > 0 ? __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["b" /* timeOut */].after(wait) : __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["a" /* microTask */]
          , callback.bind(this));
    }

    /**
     * Returns whether a named debouncer is active.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     * @return {boolean} Whether the debouncer is active (has not yet fired).
     */
    isDebouncerActive(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      return !!(debouncer && debouncer.isActive());
    }

    /**
     * Immediately calls the debouncer `callback` and inactivates it.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     */
    flushDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.flush();
      }
    }

    /**
     * Cancels an active debouncer.  The `callback` will not be called.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     */
    cancelDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.cancel();
      }
    }

    /**
     * Runs a callback function asyncronously.
     *
     * By default (if no waitTime is specified), async callbacks are run at
     * microtask timing, which will occur before paint.
     *
     * @param {Function} callback The callback function to run, bound to `this`.
     * @param {number=} waitTime Time to wait before calling the
     *   `callback`.  If unspecified or 0, the callback will be run at microtask
     *   timing (before paint).
     * @return {number} Handle that may be used to cancel the async job.
     */
    async(callback, waitTime) {
      return waitTime > 0 ? __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["b" /* timeOut */].run(callback.bind(this), waitTime) :
          ~__WEBPACK_IMPORTED_MODULE_10__utils_async_js__["a" /* microTask */].run(callback.bind(this));
    }

    /**
     * Cancels an async operation started with `async`.
     *
     * @param {number} handle Handle returned from original `async` call to
     *   cancel.
     */
    cancelAsync(handle) {
      handle < 0 ? __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["a" /* microTask */].cancel(~handle) :
          __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["b" /* timeOut */].cancel(handle);
    }

    // other

    /**
     * Convenience method for creating an element and configuring it.
     *
     * @param {string} tag HTML element tag to create.
     * @param {Object} props Object of properties to configure on the
     *    instance.
     * @return {Element} Newly created and configured element.
     */
    create(tag, props) {
      let elt = document.createElement(tag);
      if (props) {
        if (elt.setProperties) {
          elt.setProperties(props);
        } else {
          for (let n in props) {
            elt[n] = props[n];
          }
        }
      }
      return elt;
    }

    /**
     * Convenience method for importing an HTML document imperatively.
     *
     * This method creates a new `<link rel="import">` element with
     * the provided URL and appends it to the document to start loading.
     * In the `onload` callback, the `import` property of the `link`
     * element will contain the imported document contents.
     *
     * @param {string} href URL to document to load.
     * @param {Function} onload Callback to notify when an import successfully
     *   loaded.
     * @param {Function} onerror Callback to notify when an import
     *   unsuccessfully loaded.
     * @param {boolean} optAsync True if the import should be loaded `async`.
     *   Defaults to `false`.
     * @return {HTMLLinkElement} The link element for the URL to be loaded.
     */
    importHref(href, onload, onerror, optAsync) { // eslint-disable-line no-unused-vars
      let loadFn = onload ? onload.bind(this) : null;
      let errorFn = onerror ? onerror.bind(this) : null;
      return Object(__WEBPACK_IMPORTED_MODULE_4__utils_import_href_js__["a" /* importHref */])(href, loadFn, errorFn, optAsync);
    }

    /**
     * Polyfill for Element.prototype.matches, which is sometimes still
     * prefixed.
     *
     * @param {string} selector Selector to test.
     * @param {Element=} node Element to test the selector against.
     * @return {boolean} Whether the element matches the selector.
     */
    elementMatches(selector, node) {
      return Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["c" /* matchesSelector */])( (node || this), selector);
    }

    /**
     * Toggles an HTML attribute on or off.
     *
     * @param {string} name HTML attribute name
     * @param {boolean=} bool Boolean to force the attribute on or off.
     *    When unspecified, the state of the attribute will be reversed.
     * @param {Element=} node Node to target.  Defaults to `this`.
     */
    toggleAttribute(name, bool, node) {
      node = /** @type {Element} */ (node || this);
      if (arguments.length == 1) {
        bool = !node.hasAttribute(name);
      }
      if (bool) {
        node.setAttribute(name, '');
      } else {
        node.removeAttribute(name);
      }
    }


    /**
     * Toggles a CSS class on or off.
     *
     * @param {string} name CSS class name
     * @param {boolean=} bool Boolean to force the class on or off.
     *    When unspecified, the state of the class will be reversed.
     * @param {Element=} node Node to target.  Defaults to `this`.
     */
    toggleClass(name, bool, node) {
      node = /** @type {Element} */ (node || this);
      if (arguments.length == 1) {
        bool = !node.classList.contains(name);
      }
      if (bool) {
        node.classList.add(name);
      } else {
        node.classList.remove(name);
      }
    }

    /**
     * Cross-platform helper for setting an element's CSS `transform` property.
     *
     * @param {string} transformText Transform setting.
     * @param {Element=} node Element to apply the transform to.
     * Defaults to `this`
     */
    transform(transformText, node) {
      node = /** @type {Element} */ (node || this);
      node.style.webkitTransform = transformText;
      node.style.transform = transformText;
    }

    /**
     * Cross-platform helper for setting an element's CSS `translate3d`
     * property.
     *
     * @param {number} x X offset.
     * @param {number} y Y offset.
     * @param {number} z Z offset.
     * @param {Element=} node Element to apply the transform to.
     * Defaults to `this`.
     */
    translate3d(x, y, z, node) {
      node = /** @type {Element} */ (node || this);
      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
    }

    /**
     * Removes an item from an array, if it exists.
     *
     * If the array is specified by path, a change notification is
     * generated, so that observers, data bindings and computed
     * properties watching that path can update.
     *
     * If the array is passed directly, **no change
     * notification is generated**.
     *
     * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
     *   (or the array itself).
     * @param {*} item Item to remove.
     * @return {Array} Array containing item removed.
     */
    arrayDelete(arrayOrPath, item) {
      let index;
      if (Array.isArray(arrayOrPath)) {
        index = arrayOrPath.indexOf(item);
        if (index >= 0) {
          return arrayOrPath.splice(index, 1);
        }
      } else {
        let arr = Object(__WEBPACK_IMPORTED_MODULE_11__utils_path_js__["a" /* get */])(this, arrayOrPath);
        index = arr.indexOf(item);
        if (index >= 0) {
          return this.splice(arrayOrPath, index, 1);
        }
      }
      return null;
    }

    // logging

    /**
     * Facades `console.log`/`warn`/`error` as override point.
     *
     * @param {string} level One of 'log', 'warn', 'error'
     * @param {Array} args Array of strings or objects to log
     */
    _logger(level, args) {
      // accept ['foo', 'bar'] and [['foo', 'bar']]
      if (Array.isArray(args) && args.length === 1) {
        args = args[0];
      }
      switch(level) {
        case 'log':
        case 'warn':
        case 'error':
          console[level](...args);
      }
    }

    /**
     * Facades `console.log` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     */
    _log(...args) {
      this._logger('log', args);
    }

    /**
     * Facades `console.warn` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     */
    _warn(...args) {
      this._logger('warn', args);
    }

    /**
     * Facades `console.error` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     */
    _error(...args) {
      this._logger('error', args);
    }

    /**
     * Formats a message using the element type an a method name.
     *
     * @param {string} methodName Method name to associate with message
     * @param {...*} args Array of strings or objects to log
     * @return {Array} Array with formatting information for `console`
     *   logging.
     */
    _logf(methodName, ...args) {
      return ['[%s::%s]', this.is, methodName, ...args];
    }

  }

  LegacyElement.prototype.is = '';

  return LegacyElement;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = LegacyElementMixin;



/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["f"] = toCssText;
/* harmony export (immutable) */ __webpack_exports__["e"] = rulesForStyle;
/* unused harmony export isKeyframesSelector */
/* harmony export (immutable) */ __webpack_exports__["a"] = forEachRule;
/* unused harmony export applyCss */
/* unused harmony export createScopeStyle */
/* unused harmony export applyStylePlaceHolder */
/* unused harmony export applyStyle */
/* unused harmony export isTargetedBuild */
/* unused harmony export getCssBuildType */
/* harmony export (immutable) */ __webpack_exports__["d"] = processVariableAndFallback;
/* unused harmony export setElementClassRaw */
/* harmony export (immutable) */ __webpack_exports__["c"] = getIsExtends;
/* harmony export (immutable) */ __webpack_exports__["b"] = gatherStyleText;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_settings_js__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_parse_js__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_regex_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__unscoped_style_handler_js__ = __webpack_require__(57);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/




 // eslint-disable-line no-unused-vars



/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 * @return {string}
 */
function toCssText (rules, callback) {
  if (!rules) {
    return '';
  }
  if (typeof rules === 'string') {
    rules = Object(__WEBPACK_IMPORTED_MODULE_1__css_parse_js__["a" /* parse */])(rules);
  }
  if (callback) {
    forEachRule(rules, callback);
  }
  return Object(__WEBPACK_IMPORTED_MODULE_1__css_parse_js__["b" /* stringify */])(rules, __WEBPACK_IMPORTED_MODULE_0__style_settings_js__["a" /* nativeCssVariables */]);
}

/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */
function rulesForStyle(style) {
  if (!style['__cssRules'] && style.textContent) {
    style['__cssRules'] = Object(__WEBPACK_IMPORTED_MODULE_1__css_parse_js__["a" /* parse */])(style.textContent);
  }
  return style['__cssRules'] || null;
}

// Tests if a rule is a keyframes selector, which looks almost exactly
// like a normal selector but is not (it has nothing to do with scoping
// for example).
/**
 * @param {StyleNode} rule
 * @return {boolean}
 */
function isKeyframesSelector(rule) {
  return Boolean(rule['parent']) &&
  rule['parent']['type'] === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].KEYFRAMES_RULE;
}

/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */
function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }
  let skipRules = false;
  let type = node['type'];
  if (onlyActiveRules) {
    if (type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].MEDIA_RULE) {
      let matchMedia = node['selector'].match(__WEBPACK_IMPORTED_MODULE_2__common_regex_js__["a" /* MEDIA_MATCH */]);
      if (matchMedia) {
        // if rule is a non matching @media rule, skip subrules
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }
  if (type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback &&
    type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].MIXIN_RULE) {
    skipRules = true;
  }
  let r$ = node['rules'];
  if (r$ && !skipRules) {
    for (let i=0, l=r$.length, r; (i<l) && (r=r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
}

// add a string of cssText to the document.
/**
 * @param {string} cssText
 * @param {string} moniker
 * @param {Node} target
 * @param {Node} contextNode
 * @return {HTMLStyleElement}
 */
function applyCss(cssText, moniker, target, contextNode) {
  let style = createScopeStyle(cssText, moniker);
  applyStyle(style, target, contextNode);
  return style;
}

/**
 * @param {string} cssText
 * @param {string} moniker
 * @return {HTMLStyleElement}
 */
function createScopeStyle(cssText, moniker) {
  let style = /** @type {HTMLStyleElement} */(document.createElement('style'));
  if (moniker) {
    style.setAttribute('scope', moniker);
  }
  style.textContent = cssText;
  return style;
}

/**
 * Track the position of the last added style for placing placeholders
 * @type {Node}
 */
let lastHeadApplyNode = null;

// insert a comment node as a styling position placeholder.
/**
 * @param {string} moniker
 * @return {!Comment}
 */
function applyStylePlaceHolder(moniker) {
  let placeHolder = document.createComment(' Shady DOM styles for ' +
    moniker + ' ');
  let after = lastHeadApplyNode ?
    lastHeadApplyNode['nextSibling'] : null;
  let scope = document.head;
  scope.insertBefore(placeHolder, after || scope.firstChild);
  lastHeadApplyNode = placeHolder;
  return placeHolder;
}

/**
 * @param {HTMLStyleElement} style
 * @param {?Node} target
 * @param {?Node} contextNode
 */
function applyStyle(style, target, contextNode) {
  target = target || document.head;
  let after = (contextNode && contextNode.nextSibling) ||
    target.firstChild;
  target.insertBefore(style, after);
  if (!lastHeadApplyNode) {
    lastHeadApplyNode = style;
  } else {
    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode
    let position = style.compareDocumentPosition(lastHeadApplyNode);
    if (position === Node.DOCUMENT_POSITION_PRECEDING) {
      lastHeadApplyNode = style;
    }
  }
}

/**
 * @param {string} buildType
 * @return {boolean}
 */
function isTargetedBuild(buildType) {
  return __WEBPACK_IMPORTED_MODULE_0__style_settings_js__["b" /* nativeShadow */] ? buildType === 'shadow' : buildType === 'shady';
}

/**
 * @param {Element} element
 * @return {?string}
 */
function getCssBuildType(element) {
  return element.getAttribute('css-build');
}

/**
 * Walk from text[start] matching parens and
 * returns position of the outer end paren
 * @param {string} text
 * @param {number} start
 * @return {number}
 */
function findMatchingParen(text, start) {
  let level = 0;
  for (let i=start, l=text.length; i < l; i++) {
    if (text[i] === '(') {
      level++;
    } else if (text[i] === ')') {
      if (--level === 0) {
        return i;
      }
    }
  }
  return -1;
}

/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */
function processVariableAndFallback(str, callback) {
  // find 'var('
  let start = str.indexOf('var(');
  if (start === -1) {
    // no var?, everything is prefix
    return callback(str, '', '', '');
  }
  //${prefix}var(${inner})${suffix}
  let end = findMatchingParen(str, start + 3);
  let inner = str.substring(start + 4, end);
  let prefix = str.substring(0, start);
  // suffix may have other variables
  let suffix = processVariableAndFallback(str.substring(end + 1), callback);
  let comma = inner.indexOf(',');
  // value and fallback args should be trimmed to match in property lookup
  if (comma === -1) {
    // variable, no fallback
    return callback(prefix, inner.trim(), '', suffix);
  }
  // var(${value},${fallback})
  let value = inner.substring(0, comma).trim();
  let fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}

/**
 * @param {Element} element
 * @param {string} value
 */
function setElementClassRaw(element, value) {
  // use native setAttribute provided by ShadyDOM when setAttribute is patched
  if (__WEBPACK_IMPORTED_MODULE_0__style_settings_js__["b" /* nativeShadow */]) {
    element.setAttribute('class', value);
  } else {
    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);
  }
}

/**
 * @param {Element | {is: string, extends: string}} element
 * @return {{is: string, typeExtension: string}}
 */
function getIsExtends(element) {
  let localName = element['localName'];
  let is = '', typeExtension = '';
  /*
  NOTE: technically, this can be wrong for certain svg elements
  with `-` in the name like `<font-face>`
  */
  if (localName) {
    if (localName.indexOf('-') > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = (element.getAttribute && element.getAttribute('is')) || '';
    }
  } else {
    is = /** @type {?} */(element).is;
    typeExtension = /** @type {?} */(element).extends;
  }
  return {is, typeExtension};
}

/**
 * @param {Element|DocumentFragment} element
 * @return {string}
 */
function gatherStyleText(element) {
  /** @type {!Array<string>} */
  const styleTextParts = [];
  const styles = /** @type {!NodeList<!HTMLStyleElement>} */(element.querySelectorAll('style'));
  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];
    if (Object(__WEBPACK_IMPORTED_MODULE_3__unscoped_style_handler_js__["a" /* isUnscopedStyle */])(style)) {
      if (!__WEBPACK_IMPORTED_MODULE_0__style_settings_js__["b" /* nativeShadow */]) {
        Object(__WEBPACK_IMPORTED_MODULE_3__unscoped_style_handler_js__["b" /* processUnscopedStyle */])(style);
        style.parentNode.removeChild(style);
      }
    } else {
      styleTextParts.push(style.textContent);
      style.parentNode.removeChild(style);
    }
  }
  return styleTextParts.join('').trim();
}

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * @const {!Object<string, !HTMLTemplateElement>}
 */
const templateMap = {};
/* harmony default export */ __webpack_exports__["a"] = (templateMap);


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = documentWait;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/** @type {Promise<void>} */
let readyPromise = null;

/** @type {?function(?function())} */
let whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;

/** @type {function()} */
let resolveFn;

/**
 * @param {?function()} callback
 */
function documentWait(callback) {
  requestAnimationFrame(function() {
    if (whenReady) {
      whenReady(callback)
    } else {
      if (!readyPromise) {
        readyPromise = new Promise((resolve) => {resolveFn = resolve});
        if (document.readyState === 'complete') {
          resolveFn();
        } else {
          document.addEventListener('readystatechange', () => {
            if (document.readyState === 'complete') {
              resolveFn();
            }
          });
        }
      }
      readyPromise.then(function(){ callback && callback(); });
    }
  });
}


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CustomStyleProvider */
/* unused harmony export CustomStyleInterfaceInterface */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__document_wait_js__ = __webpack_require__(39);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/





/**
 * @typedef {HTMLStyleElement | {getStyle: function():HTMLStyleElement}}
 */
let CustomStyleProvider;

const SEEN_MARKER = '__seenByShadyCSS';
const CACHED_STYLE = '__shadyCSSCachedStyle';

/** @type {?function(!HTMLStyleElement)} */
let transformFn = null;

/** @type {?function()} */
let validateFn = null;

/**
This interface is provided to add document-level <style> elements to ShadyCSS for processing.
These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties

To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`

In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
This function will be called when calculating styles.

An example usage of the document-level styling api can be found in `examples/document-style-lib.js`

@unrestricted
*/
class CustomStyleInterface {
  constructor() {
    /** @type {!Array<!CustomStyleProvider>} */
    this['customStyles'] = [];
    this['enqueued'] = false;
  }
  /**
   * Queue a validation for new custom styles to batch style recalculations
   */
  enqueueDocumentValidation() {
    if (this['enqueued'] || !validateFn) {
      return;
    }
    this['enqueued'] = true;
    Object(__WEBPACK_IMPORTED_MODULE_0__document_wait_js__["a" /* default */])(validateFn);
  }
  /**
   * @param {!HTMLStyleElement} style
   */
  addCustomStyle(style) {
    if (!style[SEEN_MARKER]) {
      style[SEEN_MARKER] = true;
      this['customStyles'].push(style);
      this.enqueueDocumentValidation();
    }
  }
  /**
   * @param {!CustomStyleProvider} customStyle
   * @return {HTMLStyleElement}
   */
  getStyleForCustomStyle(customStyle) {
    if (customStyle[CACHED_STYLE]) {
      return customStyle[CACHED_STYLE];
    }
    let style;
    if (customStyle['getStyle']) {
      style = customStyle['getStyle']();
    } else {
      style = customStyle;
    }
    return style;
  }
  /**
   * @return {!Array<!CustomStyleProvider>}
   */
  processStyles() {
    const cs = this['customStyles'];
    for (let i = 0; i < cs.length; i++) {
      const customStyle = cs[i];
      if (customStyle[CACHED_STYLE]) {
        continue;
      }
      const style = this.getStyleForCustomStyle(customStyle);
      if (style) {
        // HTMLImports polyfill may have cloned the style into the main document,
        // which is referenced with __appliedElement.
        const styleToTransform = /** @type {!HTMLStyleElement} */(style['__appliedElement'] || style);
        if (transformFn) {
          transformFn(styleToTransform);
        }
        customStyle[CACHED_STYLE] = styleToTransform;
      }
    }
    return cs;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CustomStyleInterface;


CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype['processStyles'] = CustomStyleInterface.prototype.processStyles;

Object.defineProperties(CustomStyleInterface.prototype, {
  'transformCallback': {
    /** @return {?function(!HTMLStyleElement)} */
    get() {
      return transformFn;
    },
    /** @param {?function(!HTMLStyleElement)} fn */
    set(fn) {
      transformFn = fn;
    }
  },
  'validateCallback': {
    /** @return {?function()} */
    get() {
      return validateFn;
    },
    /**
     * @param {?function()} fn
     * @this {CustomStyleInterface}
     */
    set(fn) {
      let needsEnqueue = false;
      if (!validateFn) {
        needsEnqueue = true;
      }
      validateFn = fn;
      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    },
  }
})

/** @typedef {{
 * customStyles: !Array<!CustomStyleProvider>,
 * addCustomStyle: function(!CustomStyleProvider),
 * getStyleForCustomStyle: function(!CustomStyleProvider): HTMLStyleElement,
 * findStyles: function(),
 * transformCallback: ?function(!HTMLStyleElement),
 * validateCallback: ?function()
 * }}
 */
let CustomStyleInterfaceInterface;


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = cssFromModules;
/* unused harmony export cssFromModule */
/* harmony export (immutable) */ __webpack_exports__["c"] = cssFromTemplate;
/* harmony export (immutable) */ __webpack_exports__["a"] = cssFromModuleImports;
/* unused harmony export _cssFromModuleImports */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__resolve_url_js__ = __webpack_require__(11);


const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
const INCLUDE_ATTR = 'include';

function importModule(moduleId) {
  const /** Polymer.DomModule */ PolymerDomModule = customElements.get('dom-module');
  if (!PolymerDomModule) {
    return null;
  }
  return PolymerDomModule.import(moduleId);
}

/** @typedef {{assetpath: string}} */
let templateWithAssetPath; // eslint-disable-line no-unused-vars

function cssFromModules(moduleIds) {
  let modules = moduleIds.trim().split(/\s+/);
  let cssText = '';
  for (let i=0; i < modules.length; i++) {
    cssText += cssFromModule(modules[i]);
  }
  return cssText;
}

function cssFromModule(moduleId) {
  let m = importModule(moduleId);
  if (m && m._cssText === undefined) {
    // module imports: <link rel="import" type="css">
    let cssText = _cssFromModuleImports(m);
    // include css from the first template in the module
    let t = m.querySelector('template');
    if (t) {
      cssText += cssFromTemplate(t, /** @type {templateWithAssetPath} */(m).assetpath);
    }
    m._cssText = cssText || null;
  }
  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
  }
  return m && m._cssText || '';
}

function cssFromTemplate(template, baseURI) {
  let cssText = '';
  // if element is a template, get content from its .content
  let e$ = template.content.querySelectorAll('style');
  for (let i=0; i < e$.length; i++) {
    let e = e$[i];
    // support style sharing by allowing styles to "include"
    // other dom-modules that contain styling
    let include = e.getAttribute(INCLUDE_ATTR);
    if (include) {
      cssText += cssFromModules(include);
    }
    e.parentNode.removeChild(e);
    cssText += baseURI ?
      Object(__WEBPACK_IMPORTED_MODULE_0__resolve_url_js__["b" /* resolveCss */])(e.textContent, baseURI) : e.textContent;
  }
  return cssText;
}

function cssFromModuleImports(moduleId) {
  let m = importModule(moduleId);
  return m ? _cssFromModuleImports(m) : '';
}

function _cssFromModuleImports(module) {
  let cssText = '';
  let p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (let i=0; i < p$.length; i++) {
    let p = p$[i];
    if (p.import) {
      let importDoc = p.import;
      // NOTE: polyfill affordance.
      // under the HTMLImports polyfill, there will be no 'body',
      // but the import pseudo-doc can be used directly.
      let container = importDoc.body ? importDoc.body : importDoc;
      cssText +=
        Object(__WEBPACK_IMPORTED_MODULE_0__resolve_url_js__["b" /* resolveCss */])(container.textContent,
          importDoc.baseURI);
    }
  }
  return cssText;
}


/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_gestures_js__ = __webpack_require__(13);




/**
 * @const {Polymer.Gestures}
 */
const gestures = __WEBPACK_IMPORTED_MODULE_2__utils_gestures_js__;

const GestureEventListeners = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_GestureEventListeners}
   */
  class GestureEventListeners extends superClass {

    _addEventListenerToNode(node, eventName, handler) {
      if (!gestures.addListener(node, eventName, handler)) {
        super._addEventListenerToNode(node, eventName, handler);
      }
    }

    _removeEventListenerFromNode(node, eventName, handler) {
      if (!gestures.removeListener(node, eventName, handler)) {
        super._removeEventListenerFromNode(node, eventName, handler);
      }
    }

  }

  return GestureEventListeners;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = GestureEventListeners;



/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return calculateSplices; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3;

// Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.
function calcEditDistances(current, currentStart, currentEnd,
                            old, oldStart, oldEnd) {
  // "Deletion" columns
  let rowCount = oldEnd - oldStart + 1;
  let columnCount = currentEnd - currentStart + 1;
  let distances = new Array(rowCount);

  // "Addition" rows. Initialize null column.
  for (let i = 0; i < rowCount; i++) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  }

  // Initialize null row
  for (let j = 0; j < columnCount; j++)
    distances[0][j] = j;

  for (let i = 1; i < rowCount; i++) {
    for (let j = 1; j < columnCount; j++) {
      if (equals(current[currentStart + j - 1], old[oldStart + i - 1]))
        distances[i][j] = distances[i - 1][j - 1];
      else {
        let north = distances[i - 1][j] + 1;
        let west = distances[i][j - 1] + 1;
        distances[i][j] = north < west ? north : west;
      }
    }
  }

  return distances;
}

// This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.
function spliceOperationsFromEditDistances(distances) {
  let i = distances.length - 1;
  let j = distances[0].length - 1;
  let current = distances[i][j];
  let edits = [];
  while (i > 0 || j > 0) {
    if (i == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j == 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }
    let northWest = distances[i - 1][j - 1];
    let west = distances[i - 1][j];
    let north = distances[i][j - 1];

    let min;
    if (west < north)
      min = west < northWest ? west : northWest;
    else
      min = north < northWest ? north : northWest;

    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }

  edits.reverse();
  return edits;
}

/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */

/**
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 *
 * @param {Array} current The current "changed" array for which to
 * calculate splices.
 * @param {number} currentStart Starting index in the `current` array for
 * which splices are calculated.
 * @param {number} currentEnd Ending index in the `current` array for
 * which splices are calculated.
 * @param {Array} old The original "unchanged" array to compare `current`
 * against to determine splices.
 * @param {number} oldStart Starting index in the `old` array for
 * which splices are calculated.
 * @param {number} oldEnd Ending index in the `old` array for
 * which splices are calculated.
 * @return {Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */
function calcSplices(current, currentStart, currentEnd,
                      old, oldStart, oldEnd) {
  let prefixCount = 0;
  let suffixCount = 0;
  let splice;

  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0)
    prefixCount = sharedPrefix(current, old, minLength);

  if (currentEnd == current.length && oldEnd == old.length)
    suffixCount = sharedSuffix(current, old, minLength - prefixCount);

  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;

  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
    return [];

  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd)
      splice.removed.push(old[oldStart++]);

    return [ splice ];
  } else if (oldStart == oldEnd)
    return [ newSplice(currentStart, [], currentEnd - currentStart) ];

  let ops = spliceOperationsFromEditDistances(
      calcEditDistances(current, currentStart, currentEnd,
                             old, oldStart, oldEnd));

  splice = undefined;
  let splices = [];
  let index = currentStart;
  let oldIndex = oldStart;
  for (let i = 0; i < ops.length; i++) {
    switch(ops[i]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = undefined;
        }

        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }

  if (splice) {
    splices.push(splice);
  }
  return splices;
}

function sharedPrefix(current, old, searchLength) {
  for (let i = 0; i < searchLength; i++)
    if (!equals(current[i], old[i]))
      return i;
  return searchLength;
}

function sharedSuffix(current, old, searchLength) {
  let index1 = current.length;
  let index2 = old.length;
  let count = 0;
  while (count < searchLength && equals(current[--index1], old[--index2]))
    count++;

  return count;
}

function calculateSplices(current, previous) {
  return calcSplices(current, 0, current.length, previous, 0,
                          previous.length);
}

function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}




/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lit_html__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ajax_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_paper_dialog_paper_dialog__ = __webpack_require__(73);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_paper_button_paper_button__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_iron_icon_iron_icon__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polymer_paper_icon_button_paper_icon_button__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_paper_input_paper_input__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__polymer_paper_checkbox_paper_checkbox__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__polymer_iron_icons_iron_icons__ = __webpack_require__(98);










class TactileEditable extends __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__["a" /* Element */] {
  static get is() {
    return "tactile-editable";
  }

  static get properties() {
    return {
      path: {
        type: String
      },
      compType: {
        type: String
      },
      inline: {
        type: Boolean,
        default: true
      }
    };
  }

  constructor() {
    super();
    this.attachShadow({
      mode: "open"
    });
  }

  connectedCallback() {
    Object(__WEBPACK_IMPORTED_MODULE_2__ajax_js__["ajaxGet"])(this.path + ".json", component => {
      this.component = component;
      var tactileMode = document.querySelector("tactile-mode");
      this.editMode = tactileMode.mode;
      this.render();
      tactileMode.addEventListener("switched-to-edit", () => {
        this.editMode = true;
        this.render();
      });
      tactileMode.addEventListener("switched-to-publish", () => {
        this.editMode = false;
        this.render();
      });
    });
  }

  render() {
    var editContent = ``;
    var blockContent = ``;
    var otherContent = ``;

    if (this.editMode) {
      editContent = __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
      <paper-dialog modal style="min-width: 600px;">
        ${this._createMessage()}
        ${this._createInputs()}
        ${this._createButtons()}
      </paper-dialog>
      ${this._editStyles()}
      `;
    }

    if (!this.inline && this.editMode) {
      blockContent = __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
      <span class="inline-buttons">
        ${this.component.author.title}
        ${this._createConfigureableButtons()}
      </span>
      <div style="position: relative;">
        <paper-ripple></paper-ripple>
        <slot></slot>
      </div>
      ${this._blockStyles()}
      `;
    } else {
      otherContent = __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`<slot></slot>`;
    }

    Object(__WEBPACK_IMPORTED_MODULE_1_lit_html__["b" /* render */])(__WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
    ${editContent}
    ${blockContent}
    ${otherContent}
    `, this.shadowRoot);

    this._attachInlineEventHandlers();
  }

  openDialog(callback) {
    var paperDialog = this.shadowRoot.querySelector("paper-dialog");
    paperDialog.open();

    this._attachClosedHandlers(callback);

    this._attachDialogButtonHandlers(callback);
  }

  formValues() {
    var values = {};
    this.shadowRoot.querySelectorAll("paper-input").forEach(input => {
      if (typeof input.value !== "undefined") {
        values[input.name] = input.value;
      } else {
        values[input.name] = "";
      }
    });
    this.shadowRoot.querySelectorAll("paper-checkbox").forEach(input => {
      if (typeof input.value !== "undefined") {
        console.log(input.active);
        values[input.name] = input.active;
      } else {
        values[input.name] = false;
      }
    });
    return values;
  }

  _blockStyles() {
    return __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
    <style>
      :host {
        display: block;
      }
    </style>
    `;
  }

  _editStyles() {
    return __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
    <style>
        :host {
          margin: -2px;
          border: 2px solid rgba(0,0,0,0);
          cursor: pointer;
        }
        :host(:hover) {
          border: 2px solid #ddd;
        }
        .inline-buttons {
          cursor: auto;
          background-color: #ddd;
          position: absolute;
          z-index: 1;
          transition: visibility 0s, opacity 0.2s linear;
          color: #555;
          padding: 7px;
          box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
        }
        .inline-buttons paper-icon-button {
          border-radius: 100%;
        }
        .tactile-inline-button {
          cursor: pointer;
          padding-top: 5px;
        }
        .tactile-inline-button:hover {
          color: #111;
        }
      </style>
    `;
  }

  _attachClosedHandlers(callback) {
    var paperDialog = this.shadowRoot.querySelector("paper-dialog");

    var dialogClosed = event => {
      if (event.detail.confirmed) {
        Object(__WEBPACK_IMPORTED_MODULE_2__ajax_js__["ajaxPost"])(this.path, this.formValues());
      }

      paperDialog.removeEventListener("iron-overlay-closed", dialogClosed);
      callback(event.detail.confirmed);
    };

    paperDialog.addEventListener("iron-overlay-closed", dialogClosed);
  }

  _attachDialogButtonHandlers(callback) {
    Array.from(this.shadowRoot.querySelectorAll("paper-button.tactile-delete")).forEach(button => {
      button.addEventListener("click", e => {
        Object(__WEBPACK_IMPORTED_MODULE_2__ajax_js__["ajaxDelete"])(this.path, callback);
      });
    });
  }

  _attachInlineEventHandlers() {
    var addButton = this.shadowRoot.querySelector(".tactile-add");

    if (addButton) {
      addButton.addEventListener("click", e => {
        e.stopPropagation();
        var path = this.path + "/" + e.target.dataset.path;
        var template = JSON.parse(e.target.dataset.template);
        Object(__WEBPACK_IMPORTED_MODULE_2__ajax_js__["ajaxPut"])(path, template); // TODO just reinitialize the component using the handlebars template.

        window.location.reload();
      });
    }

    var inlineButtons = this.shadowRoot.querySelector(".inline-buttons");

    if (inlineButtons) {
      inlineButtons.style.visibility = "hidden";
      inlineButtons.style.opacity = "0";
      this.addEventListener("mouseenter", () => {
        inlineButtons.style.visibility = "visible";
        inlineButtons.style.opacity = "1";
      });
      this.addEventListener("mouseleave", () => {
        inlineButtons.style.visibility = "hidden";
        inlineButtons.style.opacity = "0";
      });
    }
  }

  _createInputs() {
    var inputs = [];
    this.component.author.attrs.forEach(input => {
      if (input.type === "String") {
        inputs.push(__WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`<paper-input
                name=${input.name}
                label=${input.title}
                value=${this.component[input.name]}></paper-input>`);
      } else if (input.type === "Boolean") {
        if (this.component[input.name]) {
          inputs.push(__WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`<paper-checkbox name=${input.name} checked>${input.title}</paper-checkbox>`);
        } else {
          inputs.push(__WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`<paper-checkbox name=${input.name}>${input.title}</paper-checkbox>`);
        }
      }
    });
    return inputs;
  }

  _createMessage() {
    return __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
      <h2>${this.component.author.title}</h2>
      <p>${this.component.author.description}</p>`;
  }

  _createConfigureableButtons() {
    var buttons = [];
    this.component.author.attrs.forEach(input => {
      if (input.type === "Add") {
        var button = __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`<div
                            class="tactile-inline-button tactile-add"
                            data-path=${input.path}
                            data-template=${JSON.stringify(input.template)}
                            data-comp-type=${input.compType}>
                            ${input.title}
                          </div>`;
        buttons.push(button);
      }
    });
    return buttons;
  }

  _createButtons() {
    var extraButtons = [];

    if (!this.component.author.preventDelete && !this.component.preventDelete) {
      var deleteButton = __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
        <paper-button class="tactile-delete" data-path=${this.path}>Delete</paper-button>
      `;
    }

    return __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
      <div class="buttons">
        ${extraButtons}
        ${deleteButton}
        <paper-button dialog-dismiss>Decline</paper-button>
        <paper-button dialog-confirm autofocus>Accept</paper-button>
      </div>`;
  }

}
/* harmony export (immutable) */ __webpack_exports__["default"] = TactileEditable;
 // Register custom element class with browser

customElements.define(TactileEditable.is, TactileEditable);

/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = render;
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * TypeScript has a problem with precompiling templates literals
 * https://github.com/Microsoft/TypeScript/issues/17956
 *
 * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and
 * TypeScript to verify correctness.
 */
const envCachesTemplates = ((t) => t() === t())(() => ((s) => s) ``);
// The first argument to JS template tags retain identity across multiple
// calls to a tag for the same literal, so we can cache work done per literal
// in a Map.
const templates = new Map();
const svgTemplates = new Map();
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */
const html = (strings, ...values) => litTag(strings, values, templates, false);
/* harmony export (immutable) */ __webpack_exports__["a"] = html;

/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 */
const svg = (strings, ...values) => litTag(strings, values, svgTemplates, true);
/* unused harmony export svg */

function litTag(strings, values, templates, isSvg) {
    const key = envCachesTemplates ?
        strings :
        strings.join('{{--uniqueness-workaround--}}');
    let template = templates.get(key);
    if (template === undefined) {
        template = new Template(strings, isSvg);
        templates.set(key, template);
    }
    return new TemplateResult(template, values);
}
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */
class TemplateResult {
    constructor(template, values) {
        this.template = template;
        this.values = values;
    }
}
/* unused harmony export TemplateResult */

/**
 * Renders a template to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 */
function render(result, container, partCallback = defaultPartCallback) {
    let instance = container.__templateInstance;
    // Repeat render, just call update()
    if (instance !== undefined && instance.template === result.template &&
        instance._partCallback === partCallback) {
        instance.update(result.values);
        return;
    }
    // First render, create a new TemplateInstance and append it
    instance = new TemplateInstance(result.template, partCallback);
    container.__templateInstance = instance;
    const fragment = instance._clone();
    instance.update(result.values);
    let child;
    while ((child = container.lastChild)) {
        container.removeChild(child);
    }
    container.appendChild(fragment);
}
/**
 * An expression marker with embedded unique key to avoid
 * https://github.com/PolymerLabs/lit-html/issues/62
 */
const attributeMarker = `{{lit-${Math.random()}}}`;
/**
 * Regex to scan the string preceding an expression to see if we're in a text
 * context, and not an attribute context.
 *
 * This works by seeing if we have a `>` not followed by a `<`. If there is a
 * `<` closer to the end of the strings, then we're inside a tag.
 */
const textRegex = />[^<]*$/;
const hasTagsRegex = /[^<]*/;
const textMarkerContent = '_-lit-html-_';
const textMarker = `<!--${textMarkerContent}-->`;
const attrOrTextRegex = new RegExp(`${attributeMarker}|${textMarker}`);
/**
 * A placeholder for a dynamic expression in an HTML template.
 *
 * There are two built-in part types: AttributePart and NodePart. NodeParts
 * always represent a single dynamic expression, while AttributeParts may
 * represent as many expressions are contained in the attribute.
 *
 * A Template's parts are mutable, so parts can be replaced or modified
 * (possibly to implement different template semantics). The contract is that
 * parts can only be replaced, not removed, added or reordered, and parts must
 * always consume the correct number of values in their `update()` method.
 *
 * TODO(justinfagnani): That requirement is a little fragile. A
 * TemplateInstance could instead be more careful about which values it gives
 * to Part.update().
 */
class TemplatePart {
    constructor(type, index, name, rawName, strings) {
        this.type = type;
        this.index = index;
        this.name = name;
        this.rawName = rawName;
        this.strings = strings;
    }
}
/* unused harmony export TemplatePart */

class Template {
    constructor(strings, svg = false) {
        this.parts = [];
        this.svg = svg;
        this.element = document.createElement('template');
        this.element.innerHTML = this._getHtml(strings, svg);
        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
        const walker = document.createTreeWalker(this.element.content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
               NodeFilter.SHOW_TEXT */, null, false);
        let index = -1;
        let partIndex = 0;
        const nodesToRemove = [];
        // The actual previous node, accounting for removals: if a node is removed
        // it will never be the previousNode.
        let previousNode;
        // Used to set previousNode at the top of the loop.
        let currentNode;
        while (walker.nextNode()) {
            index++;
            previousNode = currentNode;
            const node = currentNode = walker.currentNode;
            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                if (!node.hasAttributes()) {
                    continue;
                }
                const attributes = node.attributes;
                for (let i = 0; i < attributes.length; i++) {
                    const attribute = attributes.item(i);
                    const attributeStrings = attribute.value.split(attrOrTextRegex);
                    if (attributeStrings.length > 1) {
                        // Get the template literal section leading up to the first
                        // expression in this attribute attribute
                        const attributeString = strings[partIndex];
                        // Trim the trailing literal value if this is an interpolation
                        const rawNameString = attributeString.substring(0, attributeString.length - attributeStrings[0].length);
                        // Find the attribute name
                        const rawName = rawNameString.match(/((?:\w|[.\-_$])+)=["']?$/)[1];
                        this.parts.push(new TemplatePart('attribute', index, attribute.name, rawName, attributeStrings));
                        node.removeAttribute(attribute.name);
                        partIndex += attributeStrings.length - 1;
                        i--;
                    }
                }
            }
            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                const nodeValue = node.nodeValue;
                const strings = nodeValue.split(attributeMarker);
                if (strings.length > 1) {
                    const parent = node.parentNode;
                    const lastIndex = strings.length - 1;
                    // We have a part for each match found
                    partIndex += lastIndex;
                    // We keep this current node, but reset its content to the last
                    // literal part. We insert new literal nodes before this so that the
                    // tree walker keeps its position correctly.
                    node.textContent = strings[lastIndex];
                    // Generate a new text node for each literal section
                    // These nodes are also used as the markers for node parts
                    for (let i = 0; i < lastIndex; i++) {
                        parent.insertBefore(document.createTextNode(strings[i]), node);
                        this.parts.push(new TemplatePart('node', index++));
                    }
                }
                else {
                    // Strip whitespace-only nodes, only between elements, or at the
                    // beginning or end of elements.
                    const previousSibling = node.previousSibling;
                    const nextSibling = node.nextSibling;
                    if ((previousSibling === null ||
                        previousSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&
                        (nextSibling === null ||
                            nextSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&
                        nodeValue.trim() === '') {
                        nodesToRemove.push(node);
                        currentNode = previousNode;
                        index--;
                    }
                }
            }
            else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&
                node.nodeValue === textMarkerContent) {
                const parent = node.parentNode;
                // If we don't have a previous node add a marker node.
                // If the previousSibling is removed, because it's another part
                // placholder, or empty text, add a marker node.
                if (node.previousSibling === null ||
                    node.previousSibling !== previousNode) {
                    parent.insertBefore(new Text(), node);
                }
                else {
                    index--;
                }
                this.parts.push(new TemplatePart('node', index++));
                nodesToRemove.push(node);
                // If we don't have a next node add a marker node.
                // We don't have to check if the next node is going to be removed,
                // because that node will induce a marker if so.
                if (node.nextSibling === null) {
                    parent.insertBefore(new Text(), node);
                }
                else {
                    index--;
                }
                currentNode = previousNode;
                partIndex++;
            }
        }
        // Remove text binding nodes after the walk to not disturb the TreeWalker
        for (const n of nodesToRemove) {
            n.parentNode.removeChild(n);
        }
    }
    /**
     * Returns a string of HTML used to create a <template> element.
     */
    _getHtml(strings, svg) {
        const l = strings.length;
        const a = [];
        let isTextBinding = false;
        for (let i = 0; i < l - 1; i++) {
            const s = strings[i];
            a.push(s);
            // We're in a text position if the previous string matches the
            // textRegex. If it doesn't and the previous string has no tags, then
            // we use the previous text position state.
            isTextBinding = s.match(textRegex) !== null ||
                (s.match(hasTagsRegex) !== null && isTextBinding);
            a.push(isTextBinding ? textMarker : attributeMarker);
        }
        a.push(strings[l - 1]);
        const html = a.join('');
        return svg ? `<svg>${html}</svg>` : html;
    }
}
/* unused harmony export Template */

const getValue = (part, value) => {
    // `null` as the value of a Text node will render the string 'null'
    // so we convert it to undefined
    if (value != null && value.__litDirective === true) {
        value = value(part);
    }
    return value === null ? undefined : value;
};
/* unused harmony export getValue */

const directive = (f) => {
    f.__litDirective = true;
    return f;
};
/* unused harmony export directive */

class AttributePart {
    constructor(instance, element, name, strings) {
        this.instance = instance;
        this.element = element;
        this.name = name;
        this.strings = strings;
        this.size = strings.length - 1;
    }
    setValue(values, startIndex) {
        const strings = this.strings;
        let text = '';
        for (let i = 0; i < strings.length; i++) {
            text += strings[i];
            if (i < strings.length - 1) {
                const v = getValue(this, values[startIndex + i]);
                if (v &&
                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {
                    for (const t of v) {
                        // TODO: we need to recursively call getValue into iterables...
                        text += t;
                    }
                }
                else {
                    text += v;
                }
            }
        }
        this.element.setAttribute(this.name, text);
    }
}
/* unused harmony export AttributePart */

class NodePart {
    constructor(instance, startNode, endNode) {
        this.instance = instance;
        this.startNode = startNode;
        this.endNode = endNode;
        this._previousValue = undefined;
    }
    setValue(value) {
        value = getValue(this, value);
        if (value === null ||
            !(typeof value === 'object' || typeof value === 'function')) {
            // Handle primitive values
            // If the value didn't change, do nothing
            if (value === this._previousValue) {
                return;
            }
            this._setText(value);
        }
        else if (value instanceof TemplateResult) {
            this._setTemplateResult(value);
        }
        else if (Array.isArray(value) || value[Symbol.iterator]) {
            this._setIterable(value);
        }
        else if (value instanceof Node) {
            this._setNode(value);
        }
        else if (value.then !== undefined) {
            this._setPromise(value);
        }
        else {
            // Fallback, will render the string representation
            this._setText(value);
        }
    }
    _insert(node) {
        this.endNode.parentNode.insertBefore(node, this.endNode);
    }
    _setNode(value) {
        this.clear();
        this._insert(value);
        this._previousValue = value;
    }
    _setText(value) {
        const node = this.startNode.nextSibling;
        if (node === this.endNode.previousSibling &&
            node.nodeType === Node.TEXT_NODE) {
            // If we only have a single text node between the markers, we can just
            // set its value, rather than replacing it.
            // TODO(justinfagnani): Can we just check if _previousValue is
            // primitive?
            node.textContent = value;
        }
        else {
            this._setNode(document.createTextNode(value === undefined ? '' : value));
        }
        this._previousValue = value;
    }
    _setTemplateResult(value) {
        let instance;
        if (this._previousValue &&
            this._previousValue.template === value.template) {
            instance = this._previousValue;
        }
        else {
            instance =
                new TemplateInstance(value.template, this.instance._partCallback);
            this._setNode(instance._clone());
            this._previousValue = instance;
        }
        instance.update(value.values);
    }
    _setIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If _previousValue is an array, then the previous render was of an
        // iterable and _previousValue will contain the NodeParts from the previous
        // render. If _previousValue is not an array, clear this part and make a new
        // array for NodeParts.
        if (!Array.isArray(this._previousValue)) {
            this.clear();
            this._previousValue = [];
        }
        // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render
        const itemParts = this._previousValue;
        let partIndex = 0;
        for (const item of value) {
            // Try to reuse an existing part
            let itemPart = itemParts[partIndex];
            // If no existing part, create a new one
            if (itemPart === undefined) {
                // If we're creating the first item part, it's startNode should be the
                // container's startNode
                let itemStart = this.startNode;
                // If we're not creating the first part, create a new separator marker
                // node, and fix up the previous part's endNode to point to it
                if (partIndex > 0) {
                    const previousPart = itemParts[partIndex - 1];
                    itemStart = previousPart.endNode = document.createTextNode('');
                    this._insert(itemStart);
                }
                itemPart = new NodePart(this.instance, itemStart, this.endNode);
                itemParts.push(itemPart);
            }
            itemPart.setValue(item);
            partIndex++;
        }
        if (partIndex === 0) {
            this.clear();
            this._previousValue = undefined;
        }
        else if (partIndex < itemParts.length) {
            const lastPart = itemParts[partIndex - 1];
            // Truncate the parts array so _previousValue reflects the current state
            itemParts.length = partIndex;
            this.clear(lastPart.endNode.previousSibling);
            lastPart.endNode = this.endNode;
        }
    }
    _setPromise(value) {
        value.then((v) => {
            if (this._previousValue === value) {
                this.setValue(v);
            }
        });
        this._previousValue = value;
    }
    clear(startNode = this.startNode) {
        let node;
        while ((node = startNode.nextSibling) !== this.endNode) {
            node.parentNode.removeChild(node);
        }
    }
}
/* unused harmony export NodePart */

const defaultPartCallback = (instance, templatePart, node) => {
    if (templatePart.type === 'attribute') {
        return new AttributePart(instance, node, templatePart.name, templatePart.strings);
    }
    else if (templatePart.type === 'node') {
        return new NodePart(instance, node, node.nextSibling);
    }
    throw new Error(`Unknown part type ${templatePart.type}`);
};
/* unused harmony export defaultPartCallback */

/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */
class TemplateInstance {
    constructor(template, partCallback = defaultPartCallback) {
        this._parts = [];
        this.template = template;
        this._partCallback = partCallback;
    }
    update(values) {
        let valueIndex = 0;
        for (const part of this._parts) {
            if (part.size === undefined) {
                part.setValue(values[valueIndex]);
                valueIndex++;
            }
            else {
                part.setValue(values, valueIndex);
                valueIndex += part.size;
            }
        }
    }
    _clone() {
        const fragment = document.importNode(this.template.element.content, true);
        if (this.template.parts.length > 0) {
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
            // null
            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT */, null, false);
            const parts = this.template.parts;
            let index = 0;
            let partIndex = 0;
            let templatePart = parts[0];
            let node = walker.nextNode();
            while (node != null && partIndex < parts.length) {
                if (index === templatePart.index) {
                    this._parts.push(this._partCallback(this, templatePart, node));
                    templatePart = parts[++partIndex];
                }
                else {
                    index++;
                    node = walker.nextNode();
                }
            }
        }
        if (this.template.svg) {
            const svgElement = fragment.firstChild;
            fragment.removeChild(svgElement);
            const nodes = svgElement.childNodes;
            for (let i = 0; i < nodes.length; i++) {
                fragment.appendChild(nodes.item(i));
            }
        }
        return fragment;
    }
}
/* unused harmony export TemplateInstance */

//# sourceMappingURL=lit-html.js.map

/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      /* Material Design color palette for Google products */

      --google-red-100: #f4c7c3;
      --google-red-300: #e67c73;
      --google-red-500: #db4437;
      --google-red-700: #c53929;

      --google-blue-100: #c6dafc;
      --google-blue-300: #7baaf7;
      --google-blue-500: #4285f4;
      --google-blue-700: #3367d6;

      --google-green-100: #b7e1cd;
      --google-green-300: #57bb8a;
      --google-green-500: #0f9d58;
      --google-green-700: #0b8043;

      --google-yellow-100: #fce8b2;
      --google-yellow-300: #f7cb4d;
      --google-yellow-500: #f4b400;
      --google-yellow-700: #f09300;

      --google-grey-100: #f5f5f5;
      --google-grey-300: #e0e0e0;
      --google-grey-500: #9e9e9e;
      --google-grey-700: #616161;

      /* Material Design color palette from online spec document */

      --paper-red-50: #ffebee;
      --paper-red-100: #ffcdd2;
      --paper-red-200: #ef9a9a;
      --paper-red-300: #e57373;
      --paper-red-400: #ef5350;
      --paper-red-500: #f44336;
      --paper-red-600: #e53935;
      --paper-red-700: #d32f2f;
      --paper-red-800: #c62828;
      --paper-red-900: #b71c1c;
      --paper-red-a100: #ff8a80;
      --paper-red-a200: #ff5252;
      --paper-red-a400: #ff1744;
      --paper-red-a700: #d50000;

      --paper-pink-50: #fce4ec;
      --paper-pink-100: #f8bbd0;
      --paper-pink-200: #f48fb1;
      --paper-pink-300: #f06292;
      --paper-pink-400: #ec407a;
      --paper-pink-500: #e91e63;
      --paper-pink-600: #d81b60;
      --paper-pink-700: #c2185b;
      --paper-pink-800: #ad1457;
      --paper-pink-900: #880e4f;
      --paper-pink-a100: #ff80ab;
      --paper-pink-a200: #ff4081;
      --paper-pink-a400: #f50057;
      --paper-pink-a700: #c51162;

      --paper-purple-50: #f3e5f5;
      --paper-purple-100: #e1bee7;
      --paper-purple-200: #ce93d8;
      --paper-purple-300: #ba68c8;
      --paper-purple-400: #ab47bc;
      --paper-purple-500: #9c27b0;
      --paper-purple-600: #8e24aa;
      --paper-purple-700: #7b1fa2;
      --paper-purple-800: #6a1b9a;
      --paper-purple-900: #4a148c;
      --paper-purple-a100: #ea80fc;
      --paper-purple-a200: #e040fb;
      --paper-purple-a400: #d500f9;
      --paper-purple-a700: #aa00ff;

      --paper-deep-purple-50: #ede7f6;
      --paper-deep-purple-100: #d1c4e9;
      --paper-deep-purple-200: #b39ddb;
      --paper-deep-purple-300: #9575cd;
      --paper-deep-purple-400: #7e57c2;
      --paper-deep-purple-500: #673ab7;
      --paper-deep-purple-600: #5e35b1;
      --paper-deep-purple-700: #512da8;
      --paper-deep-purple-800: #4527a0;
      --paper-deep-purple-900: #311b92;
      --paper-deep-purple-a100: #b388ff;
      --paper-deep-purple-a200: #7c4dff;
      --paper-deep-purple-a400: #651fff;
      --paper-deep-purple-a700: #6200ea;

      --paper-indigo-50: #e8eaf6;
      --paper-indigo-100: #c5cae9;
      --paper-indigo-200: #9fa8da;
      --paper-indigo-300: #7986cb;
      --paper-indigo-400: #5c6bc0;
      --paper-indigo-500: #3f51b5;
      --paper-indigo-600: #3949ab;
      --paper-indigo-700: #303f9f;
      --paper-indigo-800: #283593;
      --paper-indigo-900: #1a237e;
      --paper-indigo-a100: #8c9eff;
      --paper-indigo-a200: #536dfe;
      --paper-indigo-a400: #3d5afe;
      --paper-indigo-a700: #304ffe;

      --paper-blue-50: #e3f2fd;
      --paper-blue-100: #bbdefb;
      --paper-blue-200: #90caf9;
      --paper-blue-300: #64b5f6;
      --paper-blue-400: #42a5f5;
      --paper-blue-500: #2196f3;
      --paper-blue-600: #1e88e5;
      --paper-blue-700: #1976d2;
      --paper-blue-800: #1565c0;
      --paper-blue-900: #0d47a1;
      --paper-blue-a100: #82b1ff;
      --paper-blue-a200: #448aff;
      --paper-blue-a400: #2979ff;
      --paper-blue-a700: #2962ff;

      --paper-light-blue-50: #e1f5fe;
      --paper-light-blue-100: #b3e5fc;
      --paper-light-blue-200: #81d4fa;
      --paper-light-blue-300: #4fc3f7;
      --paper-light-blue-400: #29b6f6;
      --paper-light-blue-500: #03a9f4;
      --paper-light-blue-600: #039be5;
      --paper-light-blue-700: #0288d1;
      --paper-light-blue-800: #0277bd;
      --paper-light-blue-900: #01579b;
      --paper-light-blue-a100: #80d8ff;
      --paper-light-blue-a200: #40c4ff;
      --paper-light-blue-a400: #00b0ff;
      --paper-light-blue-a700: #0091ea;

      --paper-cyan-50: #e0f7fa;
      --paper-cyan-100: #b2ebf2;
      --paper-cyan-200: #80deea;
      --paper-cyan-300: #4dd0e1;
      --paper-cyan-400: #26c6da;
      --paper-cyan-500: #00bcd4;
      --paper-cyan-600: #00acc1;
      --paper-cyan-700: #0097a7;
      --paper-cyan-800: #00838f;
      --paper-cyan-900: #006064;
      --paper-cyan-a100: #84ffff;
      --paper-cyan-a200: #18ffff;
      --paper-cyan-a400: #00e5ff;
      --paper-cyan-a700: #00b8d4;

      --paper-teal-50: #e0f2f1;
      --paper-teal-100: #b2dfdb;
      --paper-teal-200: #80cbc4;
      --paper-teal-300: #4db6ac;
      --paper-teal-400: #26a69a;
      --paper-teal-500: #009688;
      --paper-teal-600: #00897b;
      --paper-teal-700: #00796b;
      --paper-teal-800: #00695c;
      --paper-teal-900: #004d40;
      --paper-teal-a100: #a7ffeb;
      --paper-teal-a200: #64ffda;
      --paper-teal-a400: #1de9b6;
      --paper-teal-a700: #00bfa5;

      --paper-green-50: #e8f5e9;
      --paper-green-100: #c8e6c9;
      --paper-green-200: #a5d6a7;
      --paper-green-300: #81c784;
      --paper-green-400: #66bb6a;
      --paper-green-500: #4caf50;
      --paper-green-600: #43a047;
      --paper-green-700: #388e3c;
      --paper-green-800: #2e7d32;
      --paper-green-900: #1b5e20;
      --paper-green-a100: #b9f6ca;
      --paper-green-a200: #69f0ae;
      --paper-green-a400: #00e676;
      --paper-green-a700: #00c853;

      --paper-light-green-50: #f1f8e9;
      --paper-light-green-100: #dcedc8;
      --paper-light-green-200: #c5e1a5;
      --paper-light-green-300: #aed581;
      --paper-light-green-400: #9ccc65;
      --paper-light-green-500: #8bc34a;
      --paper-light-green-600: #7cb342;
      --paper-light-green-700: #689f38;
      --paper-light-green-800: #558b2f;
      --paper-light-green-900: #33691e;
      --paper-light-green-a100: #ccff90;
      --paper-light-green-a200: #b2ff59;
      --paper-light-green-a400: #76ff03;
      --paper-light-green-a700: #64dd17;

      --paper-lime-50: #f9fbe7;
      --paper-lime-100: #f0f4c3;
      --paper-lime-200: #e6ee9c;
      --paper-lime-300: #dce775;
      --paper-lime-400: #d4e157;
      --paper-lime-500: #cddc39;
      --paper-lime-600: #c0ca33;
      --paper-lime-700: #afb42b;
      --paper-lime-800: #9e9d24;
      --paper-lime-900: #827717;
      --paper-lime-a100: #f4ff81;
      --paper-lime-a200: #eeff41;
      --paper-lime-a400: #c6ff00;
      --paper-lime-a700: #aeea00;

      --paper-yellow-50: #fffde7;
      --paper-yellow-100: #fff9c4;
      --paper-yellow-200: #fff59d;
      --paper-yellow-300: #fff176;
      --paper-yellow-400: #ffee58;
      --paper-yellow-500: #ffeb3b;
      --paper-yellow-600: #fdd835;
      --paper-yellow-700: #fbc02d;
      --paper-yellow-800: #f9a825;
      --paper-yellow-900: #f57f17;
      --paper-yellow-a100: #ffff8d;
      --paper-yellow-a200: #ffff00;
      --paper-yellow-a400: #ffea00;
      --paper-yellow-a700: #ffd600;

      --paper-amber-50: #fff8e1;
      --paper-amber-100: #ffecb3;
      --paper-amber-200: #ffe082;
      --paper-amber-300: #ffd54f;
      --paper-amber-400: #ffca28;
      --paper-amber-500: #ffc107;
      --paper-amber-600: #ffb300;
      --paper-amber-700: #ffa000;
      --paper-amber-800: #ff8f00;
      --paper-amber-900: #ff6f00;
      --paper-amber-a100: #ffe57f;
      --paper-amber-a200: #ffd740;
      --paper-amber-a400: #ffc400;
      --paper-amber-a700: #ffab00;

      --paper-orange-50: #fff3e0;
      --paper-orange-100: #ffe0b2;
      --paper-orange-200: #ffcc80;
      --paper-orange-300: #ffb74d;
      --paper-orange-400: #ffa726;
      --paper-orange-500: #ff9800;
      --paper-orange-600: #fb8c00;
      --paper-orange-700: #f57c00;
      --paper-orange-800: #ef6c00;
      --paper-orange-900: #e65100;
      --paper-orange-a100: #ffd180;
      --paper-orange-a200: #ffab40;
      --paper-orange-a400: #ff9100;
      --paper-orange-a700: #ff6500;

      --paper-deep-orange-50: #fbe9e7;
      --paper-deep-orange-100: #ffccbc;
      --paper-deep-orange-200: #ffab91;
      --paper-deep-orange-300: #ff8a65;
      --paper-deep-orange-400: #ff7043;
      --paper-deep-orange-500: #ff5722;
      --paper-deep-orange-600: #f4511e;
      --paper-deep-orange-700: #e64a19;
      --paper-deep-orange-800: #d84315;
      --paper-deep-orange-900: #bf360c;
      --paper-deep-orange-a100: #ff9e80;
      --paper-deep-orange-a200: #ff6e40;
      --paper-deep-orange-a400: #ff3d00;
      --paper-deep-orange-a700: #dd2c00;

      --paper-brown-50: #efebe9;
      --paper-brown-100: #d7ccc8;
      --paper-brown-200: #bcaaa4;
      --paper-brown-300: #a1887f;
      --paper-brown-400: #8d6e63;
      --paper-brown-500: #795548;
      --paper-brown-600: #6d4c41;
      --paper-brown-700: #5d4037;
      --paper-brown-800: #4e342e;
      --paper-brown-900: #3e2723;

      --paper-grey-50: #fafafa;
      --paper-grey-100: #f5f5f5;
      --paper-grey-200: #eeeeee;
      --paper-grey-300: #e0e0e0;
      --paper-grey-400: #bdbdbd;
      --paper-grey-500: #9e9e9e;
      --paper-grey-600: #757575;
      --paper-grey-700: #616161;
      --paper-grey-800: #424242;
      --paper-grey-900: #212121;

      --paper-blue-grey-50: #eceff1;
      --paper-blue-grey-100: #cfd8dc;
      --paper-blue-grey-200: #b0bec5;
      --paper-blue-grey-300: #90a4ae;
      --paper-blue-grey-400: #78909c;
      --paper-blue-grey-500: #607d8b;
      --paper-blue-grey-600: #546e7a;
      --paper-blue-grey-700: #455a64;
      --paper-blue-grey-800: #37474f;
      --paper-blue-grey-900: #263238;

      /* opacity for dark text on a light background */
      --dark-divider-opacity: 0.12;
      --dark-disabled-opacity: 0.38; /* or hint text or icon */
      --dark-secondary-opacity: 0.54;
      --dark-primary-opacity: 0.87;

      /* opacity for light text on a dark background */
      --light-divider-opacity: 0.12;
      --light-disabled-opacity: 0.3; /* or hint text or icon */
      --light-secondary-opacity: 0.7;
      --light-primary-opacity: 1.0;

    }

  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      --shadow-transition: {
        transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
      };

      --shadow-none: {
        box-shadow: none;
      };

      /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */

      --shadow-elevation-2dp: {
        box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                    0 1px 5px 0 rgba(0, 0, 0, 0.12),
                    0 3px 1px -2px rgba(0, 0, 0, 0.2);
      };

      --shadow-elevation-3dp: {
        box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14),
                    0 1px 8px 0 rgba(0, 0, 0, 0.12),
                    0 3px 3px -2px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-4dp: {
        box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                    0 1px 10px 0 rgba(0, 0, 0, 0.12),
                    0 2px 4px -1px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-6dp: {
        box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                    0 1px 18px 0 rgba(0, 0, 0, 0.12),
                    0 3px 5px -1px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-8dp: {
        box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
                    0 3px 14px 2px rgba(0, 0, 0, 0.12),
                    0 5px 5px -3px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-12dp: {
        box-shadow: 0 12px 16px 1px rgba(0, 0, 0, 0.14),
                    0 4px 22px 3px rgba(0, 0, 0, 0.12),
                    0 6px 7px -4px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-16dp: {
        box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14),
                    0  6px 30px 5px rgba(0, 0, 0, 0.12),
                    0  8px 10px -5px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-24dp: {
        box-shadow: 0 24px 38px 3px rgba(0, 0, 0, 0.14),
                    0 9px 46px 8px rgba(0, 0, 0, 0.12),
                    0 11px 15px -7px rgba(0, 0, 0, 0.4);
      };
    }
  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__ = __webpack_require__(5);



const IronFormElementBehavior = {

  properties: {
    /**
     * Fired when the element is added to an `iron-form`.
     *
     * @event iron-form-element-register
     */

    /**
     * Fired when the element is removed from an `iron-form`.
     *
     * @event iron-form-element-unregister
     */
     
    /**
     * The name of this element.
     */
    name: {
      type: String
    },

    /**
     * The value for this element.
     */
    value: {
      notify: true,
      type: String
    },

    /**
     * Set to true to mark the input as required. If used in a form, a
     * custom element that uses this behavior should also use
     * Polymer.IronValidatableBehavior and define a custom validation method.
     * Otherwise, a `required` element will always be considered valid.
     * It's also strongly recommended to provide a visual style for the element
     * when its value is invalid.
     */
    required: {
      type: Boolean,
      value: false
    },

    /**
     * The form that the element is registered to.
     */
    _parentForm: {
      type: Object
    }
  },

  attached: __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */] ? null : function() {
    // Note: the iron-form that this element belongs to will set this
    // element's _parentForm property when handling this event.
    this.fire('iron-form-element-register');
  },

  detached: __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */] ? null : function() {
    if (this._parentForm) {
      this._parentForm.fire('iron-form-element-unregister', {target: this});
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronFormElementBehavior;



/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export IronValidatableBehaviorMeta */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_meta_iron_meta_js__ = __webpack_require__(32);


let IronValidatableBehaviorMeta = null;

const IronValidatableBehavior = {

  properties: {
    /**
     * Name of the validator to use.
     */
    validator: {
      type: String
    },

    /**
     * True if the last call to `validate` is invalid.
     */
    invalid: {
      notify: true,
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_invalidChanged'
    },
  },

  registered: function() {
    IronValidatableBehaviorMeta = new __WEBPACK_IMPORTED_MODULE_1__iron_meta_iron_meta_js__["a" /* IronMeta */]({type: 'validator'});
  },

  _invalidChanged: function() {
    if (this.invalid) {
      this.setAttribute('aria-invalid', 'true');
    } else {
      this.removeAttribute('aria-invalid');
    }
  },

  /* Recompute this every time it's needed, because we don't know if the
   * underlying IronValidatableBehaviorMeta has changed. */
  get _validator() {
    return IronValidatableBehaviorMeta &&
        IronValidatableBehaviorMeta.byKey(this.validator);
  },

  /**
   * @return {boolean} True if the validator `validator` exists.
   */
  hasValidator: function() {
    return this._validator != null;
  },

  /**
   * Returns true if the `value` is valid, and updates `invalid`. If you want
   * your element to have custom validation logic, do not override this method;
   * override `_getValidity(value)` instead.

   * @param {Object} value Deprecated: The value to be validated. By default,
   * it is passed to the validator's `validate()` function, if a validator is set.
   * If this argument is not specified, then the element's `value` property
   * is used, if it exists.
   * @return {boolean} True if `value` is valid.
   */
  validate: function(value) {
    // If this is an element that also has a value property, and there was
    // no explicit value argument passed, use the element's property instead.
    if (value === undefined && this.value !== undefined)
      this.invalid = !this._getValidity(this.value);
    else
      this.invalid = !this._getValidity(value);
    return !this.invalid;
  },

  /**
   * Returns true if `value` is valid.  By default, it is passed
   * to the validator's `validate()` function, if a validator is set. You
   * should override this method if you want to implement custom validity
   * logic for your element.
   *
   * @param {Object} value The value to be validated.
   * @return {boolean} True if `value` is valid.
   */

  _getValidity: function(value) {
    if (this.hasValidator()) {
      return this._validator.validate(value);
    }
    return true;
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronValidatableBehavior;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);



const PaperInputAddonBehavior = {
  attached: function() {
    // Workaround for https://github.com/webcomponents/shadydom/issues/96
    Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["b" /* flush */])();
    this.fire('addon-attached');
  },

  /**
   * The function called by `<paper-input-container>` when the input value or validity changes.
   * @param {{
   *   inputElement: (Element|undefined),
   *   value: (string|undefined),
   *   invalid: boolean
   * }} state -
   *     inputElement: The input element.
   *     value: The input value.
   *     invalid: True if the input value is invalid.
   */
  update: function(state) {
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperInputAddonBehavior;



/***/ }),
/* 51 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_checked_element_behavior_iron_checked_element_behavior_js__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_inky_focus_behavior_js__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_ripple_behavior_js__ = __webpack_require__(19);





const PaperCheckedElementBehaviorImpl = {
  /**
   * Synchronizes the element's checked state with its ripple effect.
   */
  _checkedChanged: function() {
    __WEBPACK_IMPORTED_MODULE_1__iron_checked_element_behavior_iron_checked_element_behavior_js__["b" /* IronCheckedElementBehaviorImpl */]._checkedChanged.call(this);
    if (this.hasRipple()) {
      if (this.checked) {
        this._ripple.setAttribute('checked', '');
      } else {
        this._ripple.removeAttribute('checked');
      }
    }
  },

  /**
   * Synchronizes the element's `active` and `checked` state.
   */
  _buttonStateChanged: function() {
    __WEBPACK_IMPORTED_MODULE_3__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */]._buttonStateChanged.call(this);
    if (this.disabled) {
      return;
    }
    if (this.isAttached) {
      this.checked = this.active;
    }
  }
};
/* unused harmony export PaperCheckedElementBehaviorImpl */


const PaperCheckedElementBehavior = [
  __WEBPACK_IMPORTED_MODULE_2__paper_inky_focus_behavior_js__["a" /* PaperInkyFocusBehavior */],
  __WEBPACK_IMPORTED_MODULE_1__iron_checked_element_behavior_iron_checked_element_behavior_js__["a" /* IronCheckedElementBehavior */],
  PaperCheckedElementBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperCheckedElementBehavior;



/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_paper_toggle_button_paper_toggle_button__ = __webpack_require__(100);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lit_html__ = __webpack_require__(45);



class TactileMode extends __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__["a" /* Element */] {
  static get is() {
    return "tactile-mode";
  }

  static get template() {
    return "<paper-toggle-button>Edit</paper-toggle-button>";
  }

  connectedCallback() {
    super.connectedCallback();
    this.toggle = this.shadowRoot.querySelector("paper-toggle-button");
    this.toggle.addEventListener("iron-change", () => {
      if (this.toggle.checked) {
        this.dispatchEvent(new CustomEvent('switched-to-edit'));
      } else {
        this.dispatchEvent(new CustomEvent('switched-to-publish'));
      }
    });
  }

  switchToEdit() {
    this.toggle.checked = true;
  }

  switchToPublish() {
    this.toggle.checked = false;
  }

  get mode() {
    return this.toggle.checked;
  }

}
/* harmony export (immutable) */ __webpack_exports__["default"] = TactileMode;
 // Register custom element class with browser

customElements.define(TactileMode.is, TactileMode);

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(34);
__webpack_require__(54);
__webpack_require__(44);
__webpack_require__(52);
module.exports = __webpack_require__(101);


/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_paper_ripple_paper_ripple__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tactile_editable_js__ = __webpack_require__(44);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tactile_mode_js__ = __webpack_require__(52);




function watchForComponentClicks(event) {
  // This stops user from interacting with page in author mode
  event.stopPropagation();
  event.preventDefault();
  var component = event.target.closest("tactile-editable");

  if (component) {
    component.openDialog(watchForComponentClicks);
    document.removeEventListener("click", watchForComponentClicks);
  }
}

;

function watchForComponentClicks(event) {
  // This stops user from interacting with page in author mode
  event.stopPropagation();
  event.preventDefault();
  var tactileEditable = event.target.closest("tactile-editable");

  if (tactileEditable) {
    document.removeEventListener("click", watchForComponentClicks);
    tactileEditable.openDialog(function (requiresRefresh = true) {
      document.addEventListener("click", watchForComponentClicks); // TODO just reload the component, not the entire page.

      if (requiresRefresh) {
        window.location.reload();
      }
    });
  }
}

;

function setupEditMode() {
  document.addEventListener("click", watchForComponentClicks);
  document.body.classList.add("edit");
  window.sessionStorage.setItem("tactile-mode", "edit");
}

function setupPublishMode() {
  document.removeEventListener("click", watchForComponentClicks);
  document.body.classList.remove("edit");
  window.sessionStorage.setItem("tactile-mode", "publish");
}

document.addEventListener("DOMContentLoaded", event => {
  if (document.body.classList.contains('edit')) {
    var tactileMode = document.querySelector("tactile-mode");
    tactileMode.addEventListener("switched-to-edit", () => {
      setupEditMode();
    });
    tactileMode.addEventListener("switched-to-publish", () => {
      setupPublishMode();
    });
    var mode = window.sessionStorage.getItem("tactile-mode");

    if (mode === "edit") {
      tactileMode.switchToEdit();
    } else {
      tactileMode.switchToPublish();
    }
  }
});

/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_apply_shim_js__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_template_map_js__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_style_util_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_document_wait_js__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_common_utils_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_custom_style_interface_js__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_style_settings_js__ = __webpack_require__(20);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/









 // eslint-disable-line no-unused-vars


/** @const {ApplyShim} */
const applyShim = new __WEBPACK_IMPORTED_MODULE_0__src_apply_shim_js__["a" /* default */]();

class ApplyShimInterface {
  constructor() {
    /** @type {?CustomStyleInterfaceInterface} */
    this.customStyleInterface = null;
    Object(__WEBPACK_IMPORTED_MODULE_4__src_document_wait_js__["a" /* default */])(() => {
      this.ensure();
    });
    applyShim['invalidCallback'] = __WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["a" /* invalidate */];
  }
  ensure() {
    if (this.customStyleInterface) {
      return;
    }
    this.customStyleInterface = window.ShadyCSS.CustomStyleInterface;
    if (this.customStyleInterface) {
      this.customStyleInterface['transformCallback'] = (style) => {
        applyShim.transformCustomStyle(style);
      };
      this.customStyleInterface['validateCallback'] = () => {
        requestAnimationFrame(() => {
          if (this.customStyleInterface['enqueued']) {
            this.flushCustomStyles();
          }
        });
      }
    }
  }
  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   */
  prepareTemplate(template, elementName) {
    this.ensure();
    __WEBPACK_IMPORTED_MODULE_1__src_template_map_js__["a" /* default */][elementName] = template;
    let ast = applyShim.transformTemplate(template, elementName);
    // save original style ast to use for revalidating instances
    template['_styleAst'] = ast;
  }
  flushCustomStyles() {
    this.ensure();
    if (!this.customStyleInterface) {
      return;
    }
    let styles = this.customStyleInterface['processStyles']();
    if (!this.customStyleInterface['enqueued']) {
      return;
    }
    for (let i = 0; i < styles.length; i++ ) {
      let cs = styles[i];
      let style = this.customStyleInterface['getStyleForCustomStyle'](cs);
      if (style) {
        applyShim.transformCustomStyle(style);
      }
    }
    this.customStyleInterface['enqueued'] = false;
  }
  /**
   * @param {HTMLElement} element
   * @param {Object=} properties
   */
  styleSubtree(element, properties) {
    this.ensure();
    if (properties) {
      Object(__WEBPACK_IMPORTED_MODULE_5__src_common_utils_js__["c" /* updateNativeProperties */])(element, properties);
    }
    if (element.shadowRoot) {
      this.styleElement(element);
      let shadowChildren = element.shadowRoot.children || element.shadowRoot.childNodes;
      for (let i = 0; i < shadowChildren.length; i++) {
        this.styleSubtree(/** @type {HTMLElement} */(shadowChildren[i]));
      }
    } else {
      let children = element.children || element.childNodes;
      for (let i = 0; i < children.length; i++) {
        this.styleSubtree(/** @type {HTMLElement} */(children[i]));
      }
    }
  }
  /**
   * @param {HTMLElement} element
   */
  styleElement(element) {
    this.ensure();
    let {is} = Object(__WEBPACK_IMPORTED_MODULE_2__src_style_util_js__["c" /* getIsExtends */])(element);
    let template = __WEBPACK_IMPORTED_MODULE_1__src_template_map_js__["a" /* default */][is];
    if (template && !__WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["c" /* templateIsValid */](template)) {
      // only revalidate template once
      if (!__WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["d" /* templateIsValidating */](template)) {
        this.prepareTemplate(template, is);
        __WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["b" /* startValidatingTemplate */](template);
      }
      // update this element instance
      let root = element.shadowRoot;
      if (root) {
        let style = /** @type {HTMLStyleElement} */(root.querySelector('style'));
        if (style) {
          // reuse the template's style ast, it has all the original css text
          style['__cssRules'] = template['_styleAst'];
          style.textContent = Object(__WEBPACK_IMPORTED_MODULE_2__src_style_util_js__["f" /* toCssText */])(template['_styleAst'])
        }
      }
    }
  }
  /**
   * @param {Object=} properties
   */
  styleDocument(properties) {
    this.ensure();
    this.styleSubtree(document.body, properties);
  }
}

if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
  const applyShimInterface = new ApplyShimInterface();
  let CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;

  window.ShadyCSS = {
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate(template, elementName, elementExtends) { // eslint-disable-line no-unused-vars
      applyShimInterface.flushCustomStyles();
      applyShimInterface.prepareTemplate(template, elementName)
    },

    /**
     * @param {!HTMLElement} element
     * @param {Object=} properties
     */
    styleSubtree(element, properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleSubtree(element, properties);
    },

    /**
     * @param {!HTMLElement} element
     */
    styleElement(element) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleElement(element);
    },

    /**
     * @param {Object=} properties
     */
    styleDocument(properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleDocument(properties);
    },

    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue(element, property) {
      return Object(__WEBPACK_IMPORTED_MODULE_5__src_common_utils_js__["b" /* getComputedStyleValue */])(element, property);
    },
    nativeCss: __WEBPACK_IMPORTED_MODULE_7__src_style_settings_js__["a" /* nativeCssVariables */],
    nativeShadow: __WEBPACK_IMPORTED_MODULE_7__src_style_settings_js__["b" /* nativeShadow */]
  };

  if (CustomStyleInterface) {
    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
  }
}

window.ShadyCSS.ApplyShim = applyShim;

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_util_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_regex_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_utils_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__css_parse_js__ = __webpack_require__(21);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/*
 * The apply shim simulates the behavior of `@apply` proposed at
 * https://tabatkins.github.io/specs/css-apply-rule/.
 * The approach is to convert a property like this:
 *
 *    --foo: {color: red; background: blue;}
 *
 * to this:
 *
 *    --foo_-_color: red;
 *    --foo_-_background: blue;
 *
 * Then where `@apply --foo` is used, that is converted to:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background);
 *
 * This approach generally works but there are some issues and limitations.
 * Consider, for example, that somewhere *between* where `--foo` is set and used,
 * another element sets it to:
 *
 *    --foo: { border: 2px solid red; }
 *
 * We must now ensure that the color and background from the previous setting
 * do not apply. This is accomplished by changing the property set to this:
 *
 *    --foo_-_border: 2px solid red;
 *    --foo_-_color: initial;
 *    --foo_-_background: initial;
 *
 * This works but introduces one new issue.
 * Consider this setup at the point where the `@apply` is used:
 *
 *    background: orange;
 *    `@apply` --foo;
 *
 * In this case the background will be unset (initial) rather than the desired
 * `orange`. We address this by altering the property set to use a fallback
 * value like this:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background, orange);
 *    border: var(--foo_-_border);
 *
 * Note that the default is retained in the property set and the `background` is
 * the desired `orange`. This leads us to a limitation.
 *
 * Limitation 1:

 * Only properties in the rule where the `@apply`
 * is used are considered as default values.
 * If another rule matches the element and sets `background` with
 * less specificity than the rule in which `@apply` appears,
 * the `background` will not be set.
 *
 * Limitation 2:
 *
 * When using Polymer's `updateStyles` api, new properties may not be set for
 * `@apply` properties.

*/






 // eslint-disable-line no-unused-vars

const APPLY_NAME_CLEAN = /;\s*/m;
const INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;

// separator used between mixin-name and mixin-property-name when producing properties
// NOTE: plain '-' may cause collisions in user styles
const MIXIN_VAR_SEP = '_-_';

/**
 * @typedef {!Object<string, string>}
 */
let PropertyEntry; // eslint-disable-line no-unused-vars

/**
 * @typedef {!Object<string, boolean>}
 */
let DependantsEntry; // eslint-disable-line no-unused-vars

/** @typedef {{
 *    properties: PropertyEntry,
 *    dependants: DependantsEntry
 * }}
 */
let MixinMapEntry; // eslint-disable-line no-unused-vars

// map of mixin to property names
// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}
class MixinMap {
  constructor() {
    /** @type {!Object<string, !MixinMapEntry>} */
    this._map = {};
  }
  /**
   * @param {string} name
   * @param {!PropertyEntry} props
   */
  set(name, props) {
    name = name.trim();
    this._map[name] = {
      properties: props,
      dependants: {}
    }
  }
  /**
   * @param {string} name
   * @return {MixinMapEntry}
   */
  get(name) {
    name = name.trim();
    return this._map[name] || null;
  }
}

/**
 * Callback for when an element is marked invalid
 * @type {?function(string)}
 */
let invalidCallback = null;

/** @unrestricted */
class ApplyShim {
  constructor() {
    /** @type {?string} */
    this._currentElement = null;
    /** @type {HTMLMetaElement} */
    this._measureElement = null;
    this._map = new MixinMap();
  }
  /**
   * return true if `cssText` contains a mixin definition or consumption
   * @param {string} cssText
   * @return {boolean}
   */
  detectMixin(cssText) {
    return Object(__WEBPACK_IMPORTED_MODULE_2__common_utils_js__["a" /* detectMixin */])(cssText);
  }

  /**
   * Gather styles into one style for easier processing
   * @param {!HTMLTemplateElement} template
   * @return {HTMLStyleElement}
   */
  gatherStyles(template) {
    const styleText = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["b" /* gatherStyleText */])(template.content);
    if (styleText) {
      const style = /** @type {!HTMLStyleElement} */(document.createElement('style'));
      style.textContent = styleText;
      template.content.insertBefore(style, template.content.firstChild);
      return style;
    }
    return null;
  }
  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @return {StyleNode}
   */
  transformTemplate(template, elementName) {
    if (template._gatheredStyle === undefined) {
      template._gatheredStyle = this.gatherStyles(template);
    }
    /** @type {HTMLStyleElement} */
    const style = template._gatheredStyle;
    return style ? this.transformStyle(style, elementName) : null;
  }
  /**
   * @param {!HTMLStyleElement} style
   * @param {string} elementName
   * @return {StyleNode}
   */
  transformStyle(style, elementName = '') {
    let ast = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["e" /* rulesForStyle */])(style);
    this.transformRules(ast, elementName);
    style.textContent = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["f" /* toCssText */])(ast);
    return ast;
  }
  /**
   * @param {!HTMLStyleElement} style
   * @return {StyleNode}
   */
  transformCustomStyle(style) {
    let ast = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["e" /* rulesForStyle */])(style);
    Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["a" /* forEachRule */])(ast, (rule) => {
      if (rule['selector'] === ':root') {
        rule['selector'] = 'html';
      }
      this.transformRule(rule);
    })
    style.textContent = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["f" /* toCssText */])(ast);
    return ast;
  }
  /**
   * @param {StyleNode} rules
   * @param {string} elementName
   */
  transformRules(rules, elementName) {
    this._currentElement = elementName;
    Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["a" /* forEachRule */])(rules, (r) => {
      this.transformRule(r);
    });
    this._currentElement = null;
  }
  /**
   * @param {!StyleNode} rule
   */
  transformRule(rule) {
    rule['cssText'] = this.transformCssText(rule['parsedCssText']);
    // :root was only used for variable assignment in property shim,
    // but generates invalid selectors with real properties.
    // replace with `:host > *`, which serves the same effect
    if (rule['selector'] === ':root') {
      rule['selector'] = ':host > *';
    }
  }
  /**
   * @param {string} cssText
   * @return {string}
   */
  transformCssText(cssText) {
    // produce variables
    cssText = cssText.replace(__WEBPACK_IMPORTED_MODULE_1__common_regex_js__["c" /* VAR_ASSIGN */], (matchText, propertyName, valueProperty, valueMixin) =>
      this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin));
    // consume mixins
    return this._consumeCssProperties(cssText);
  }
  /**
   * @param {string} property
   * @return {string}
   */
  _getInitialValueForProperty(property) {
    if (!this._measureElement) {
      this._measureElement = /** @type {HTMLMetaElement} */(document.createElement('meta'));
      this._measureElement.setAttribute('apply-shim-measure', '');
      this._measureElement.style.all = 'initial';
      document.head.appendChild(this._measureElement);
    }
    return window.getComputedStyle(this._measureElement).getPropertyValue(property);
  }
  /**
   * replace mixin consumption with variable consumption
   * @param {string} text
   * @return {string}
   */
  _consumeCssProperties(text) {
    /** @type {Array} */
    let m = null;
    // loop over text until all mixins with defintions have been applied
    while((m = __WEBPACK_IMPORTED_MODULE_1__common_regex_js__["b" /* MIXIN_MATCH */].exec(text))) {
      let matchText = m[0];
      let mixinName = m[1];
      let idx = m.index;
      // collect properties before apply to be "defaults" if mixin might override them
      // match includes a "prefix", so find the start and end positions of @apply
      let applyPos = idx + matchText.indexOf('@apply');
      let afterApplyPos = idx + matchText.length;
      // find props defined before this @apply
      let textBeforeApply = text.slice(0, applyPos);
      let textAfterApply = text.slice(afterApplyPos);
      let defaults = this._cssTextToMap(textBeforeApply);
      let replacement = this._atApplyToCssProperties(mixinName, defaults);
      // use regex match position to replace mixin, keep linear processing time
      text = `${textBeforeApply}${replacement}${textAfterApply}`;
      // move regex search to _after_ replacement
      __WEBPACK_IMPORTED_MODULE_1__common_regex_js__["b" /* MIXIN_MATCH */].lastIndex = idx + replacement.length;
    }
    return text;
  }
  /**
   * produce variable consumption at the site of mixin consumption
   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))
   * Example:
   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)
   *
   * @param {string} mixinName
   * @param {Object} fallbacks
   * @return {string}
   */
  _atApplyToCssProperties(mixinName, fallbacks) {
    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
    let vars = [];
    let mixinEntry = this._map.get(mixinName);
    // if we depend on a mixin before it is created
    // make a sentinel entry in the map to add this element as a dependency for when it is defined.
    if (!mixinEntry) {
      this._map.set(mixinName, {});
      mixinEntry = this._map.get(mixinName);
    }
    if (mixinEntry) {
      if (this._currentElement) {
        mixinEntry.dependants[this._currentElement] = true;
      }
      let p, parts, f;
      for (p in mixinEntry.properties) {
        f = fallbacks && fallbacks[p];
        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
        if (f) {
          parts.push(',', f);
        }
        parts.push(')');
        vars.push(parts.join(''));
      }
    }
    return vars.join('; ');
  }

  /**
   * @param {string} property
   * @param {string} value
   * @return {string}
   */
  _replaceInitialOrInherit(property, value) {
    let match = INITIAL_INHERIT.exec(value);
    if (match) {
      if (match[1]) {
        // initial
        // replace `initial` with the concrete initial value for this property
        value = this._getInitialValueForProperty(property);
      } else {
        // inherit
        // with this purposfully illegal value, the variable will be invalid at
        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)
        // and for inheriting values, will behave similarly
        // we cannot support the same behavior for non inheriting values like 'border'
        value = 'apply-shim-inherit';
      }
    }
    return value;
  }

  /**
   * "parse" a mixin definition into a map of properties and values
   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')
   * @param {string} text
   * @return {!Object<string, string>}
   */
  _cssTextToMap(text) {
    let props = text.split(';');
    let property, value;
    let out = {};
    for (let i = 0, p, sp; i < props.length; i++) {
      p = props[i];
      if (p) {
        sp = p.split(':');
        // ignore lines that aren't definitions like @media
        if (sp.length > 1) {
          property = sp[0].trim();
          // some properties may have ':' in the value, like data urls
          value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));
          out[property] = value;
        }
      }
    }
    return out;
  }

  /**
   * @param {MixinMapEntry} mixinEntry
   */
  _invalidateMixinEntry(mixinEntry) {
    if (!invalidCallback) {
      return;
    }
    for (let elementName in mixinEntry.dependants) {
      if (elementName !== this._currentElement) {
        invalidCallback(elementName);
      }
    }
  }

  /**
   * @param {string} matchText
   * @param {string} propertyName
   * @param {?string} valueProperty
   * @param {?string} valueMixin
   * @return {string}
   */
  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
    // handle case where property value is a mixin
    if (valueProperty) {
      // form: --mixin2: var(--mixin1), where --mixin1 is in the map
      Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["d" /* processVariableAndFallback */])(valueProperty, (prefix, value) => {
        if (value && this._map.get(value)) {
          valueMixin = `@apply ${value};`
        }
      });
    }
    if (!valueMixin) {
      return matchText;
    }
    let mixinAsProperties = this._consumeCssProperties(valueMixin);
    let prefix = matchText.slice(0, matchText.indexOf('--'));
    let mixinValues = this._cssTextToMap(mixinAsProperties);
    let combinedProps = mixinValues;
    let mixinEntry = this._map.get(propertyName);
    let oldProps = mixinEntry && mixinEntry.properties;
    if (oldProps) {
      // NOTE: since we use mixin, the map of properties is updated here
      // and this is what we want.
      combinedProps = Object.assign(Object.create(oldProps), mixinValues);
    } else {
      this._map.set(propertyName, combinedProps);
    }
    let out = [];
    let p, v;
    // set variables defined by current mixin
    let needToInvalidate = false;
    for (p in combinedProps) {
      v = mixinValues[p];
      // if property not defined by current mixin, set initial
      if (v === undefined) {
        v = 'initial';
      }
      if (oldProps && !(p in oldProps)) {
        needToInvalidate = true;
      }
      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);
    }
    if (needToInvalidate) {
      this._invalidateMixinEntry(mixinEntry);
    }
    if (mixinEntry) {
      mixinEntry.properties = combinedProps;
    }
    // because the mixinMap is global, the mixin might conflict with
    // a different scope's simple variable definition:
    // Example:
    // some style somewhere:
    // --mixin1:{ ... }
    // --mixin2: var(--mixin1);
    // some other element:
    // --mixin1: 10px solid red;
    // --foo: var(--mixin1);
    // In this case, we leave the original variable definition in place.
    if (valueProperty) {
      prefix = `${matchText};${prefix}`;
    }
    return `${prefix}${out.join('; ')};`;
  }
}

/* exports */
ApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;
ApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;
ApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;
ApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;
Object.defineProperty(ApplyShim.prototype, 'invalidCallback', {
  /** @return {?function(string)} */
  get() {
    return invalidCallback;
  },
  /** @param {?function(string)} cb */
  set(cb) {
    invalidCallback = cb;
  }
});

/* harmony default export */ __webpack_exports__["a"] = (ApplyShim);

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = processUnscopedStyle;
/* harmony export (immutable) */ __webpack_exports__["a"] = isUnscopedStyle;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/** @type {!Set<string>} */
const styleTextSet = new Set();

const scopingAttribute = 'shady-unscoped';
/* unused harmony export scopingAttribute */


/**
 * Add a specifically-marked style to the document directly, and only one copy of that style.
 *
 * @param {!HTMLStyleElement} style
 * @return {undefined}
 */
function processUnscopedStyle(style) {
  const text = style.textContent;
  if (!styleTextSet.has(text)) {
    styleTextSet.add(text);
    const newStyle = style.cloneNode(true);
    document.head.appendChild(newStyle);
  }
}

/**
 * Check if a style is supposed to be unscoped
 * @param {!HTMLStyleElement} style
 * @return {boolean} true if the style has the unscoping attribute
 */
function isUnscopedStyle(style) {
  return style.hasAttribute(scopingAttribute);
}

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = invalidate;
/* unused harmony export invalidateTemplate */
/* unused harmony export isValid */
/* harmony export (immutable) */ __webpack_exports__["c"] = templateIsValid;
/* unused harmony export isValidating */
/* harmony export (immutable) */ __webpack_exports__["d"] = templateIsValidating;
/* unused harmony export startValidating */
/* harmony export (immutable) */ __webpack_exports__["b"] = startValidatingTemplate;
/* unused harmony export elementsAreInvalid */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__template_map_js__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_parse_js__ = __webpack_require__(21);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



 // eslint-disable-line no-unused-vars

/*
 * Utilities for handling invalidating apply-shim mixins for a given template.
 *
 * The invalidation strategy involves keeping track of the "current" version of a template's mixins, and updating that count when a mixin is invalidated.
 * The template
 */

/** @const {string} */
const CURRENT_VERSION = '_applyShimCurrentVersion';

/** @const {string} */
const NEXT_VERSION = '_applyShimNextVersion';

/** @const {string} */
const VALIDATING_VERSION = '_applyShimValidatingVersion';

/**
 * @const {Promise<void>}
 */
const promise = Promise.resolve();

/**
 * @param {string} elementName
 */
function invalidate(elementName){
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  if (template) {
    invalidateTemplate(template);
  }
}

/**
 * This function can be called multiple times to mark a template invalid
 * and signal that the style inside must be regenerated.
 *
 * Use `startValidatingTemplate` to begin an asynchronous validation cycle.
 * During that cycle, call `templateIsValidating` to see if the template must
 * be revalidated
 * @param {HTMLTemplateElement} template
 */
function invalidateTemplate(template) {
  // default the current version to 0
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
  // ensure the "validating for" flag exists
  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
  // increment the next version
  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValid(elementName) {
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  if (template) {
    return templateIsValid(template);
  }
  return true;
}

/**
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValidating(elementName) {
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  if (template) {
    return templateIsValidating(template);
  }
  return false;
}

/**
 * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.
 * If false, the template must be validated.
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}

/**
 * the template is marked as `validating` for one microtask so that all instances
 * found in the tree crawl of `applyStyle` will update themselves,
 * but the template will only be updated once.
 * @param {string} elementName
*/
function startValidating(elementName) {
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  startValidatingTemplate(template);
}

/**
 * Begin an asynchronous invalidation cycle.
 * This should be called after every validation of a template
 *
 * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`
 * @param {HTMLTemplateElement} template
 */
function startValidatingTemplate(template) {
  // remember that the current "next version" is the reason for this validation cycle
  template[VALIDATING_VERSION] = template[NEXT_VERSION];
  // however, there only needs to be one async task to clear the counters
  if (!template._validating) {
    template._validating = true;
    promise.then(function() {
      // sync the current version to let future invalidations cause a refresh cycle
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

/**
 * @return {boolean}
 */
function elementsAreInvalid() {
  for (let elementName in __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */]) {
    let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
    if (!templateIsValid(template)) {
      return true;
    }
  }
  return false;
}

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_async_js__ = __webpack_require__(6);





let caseMap = __WEBPACK_IMPORTED_MODULE_2__utils_case_map_js__;

let microtask = __WEBPACK_IMPORTED_MODULE_3__utils_async_js__["a" /* microTask */];

// Save map of native properties; this forms a blacklist or properties
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws
const nativeProperties = {};
let proto = HTMLElement.prototype;
while (proto) {
  let props = Object.getOwnPropertyNames(proto);
  for (let i=0; i<props.length; i++) {
    nativeProperties[props[i]] = true;
  }
  proto = Object.getPrototypeOf(proto);
}

/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @private
 */
function saveAccessorValue(model, property) {
  // Don't read/store value for any native properties since they could throw
  if (!nativeProperties[property]) {
    let value = model[property];
    if (value !== undefined) {
      if (model.__data) {
        // Adding accessor to instance; update the property
        // It is the user's responsibility to call _flushProperties
        model._setPendingProperty(property, value);
      } else {
        // Adding accessor to proto; save proto's value for instance-time use
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }
        model.__dataProto[property] = value;
      }
    }
  }
}

const PropertyAccessors = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends HTMLElement
   * @unrestricted
   */
  class PropertyAccessors extends superClass {

    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     */
    static createPropertiesForAttributes() {
      let a$ = this.observedAttributes;
      for (let i=0; i < a$.length; i++) {
        this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[i]));
      }
    }

    constructor() {
      super();
      /** @type {boolean} */
      this.__serializing;
      /** @type {number} */
      this.__dataCounter;
      /** @type {boolean} */
      this.__dataEnabled;
      /** @type {boolean} */
      this.__dataReady;
      /** @type {boolean} */
      this.__dataInvalid;
      /** @type {!Object} */
      this.__data;
      /** @type {Object} */
      this.__dataPending;
      /** @type {Object} */
      this.__dataOld;
      /** @type {Object} */
      this.__dataProto;
      /** @type {Object} */
      this.__dataHasAccessor;
      /** @type {Object} */
      this.__dataInstanceProps;
      this._initializeProperties();
    }

    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     */
    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        this._attributeToProperty(name, value);
      }
    }

    /**
     * Initializes the local storage for property accessors.
     *
     * Provided as an override point for performing any setup work prior
     * to initializing the property accessor system.
     *
     * @protected
     */
    _initializeProperties() {
      this.__serializing = false;
      this.__dataCounter = 0;
      this.__dataEnabled = false;
      this.__dataReady = false;
      this.__dataInvalid = false;
      this.__data = {};
      this.__dataPending = null;
      this.__dataOld = null;
      if (this.__dataProto) {
        this._initializeProtoProperties(this.__dataProto);
        this.__dataProto = null;
      }
      // Capture instance properties; these will be set into accessors
      // during first flush. Don't set them here, since we want
      // these to overwrite defaults/constructor assignments
      for (let p in this.__dataHasAccessor) {
        if (this.hasOwnProperty(p)) {
          this.__dataInstanceProps = this.__dataInstanceProps || {};
          this.__dataInstanceProps[p] = this[p];
          delete this[p];
        }
      }
    }

    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @protected
     */
    _initializeProtoProperties(props) {
      for (let p in props) {
        this._setProperty(p, props[p]);
      }
    }

    /**
     * Called at ready time with bag of instance properties that overwrote
     * accessors when the element upgraded.
     *
     * The default implementation sets these properties back into the
     * setter at ready time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @protected
     */
    _initializeInstanceProperties(props) {
      Object.assign(this, props);
    }

    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     */
    _ensureAttribute(attribute, value) {
      if (!this.hasAttribute(attribute)) {
        this._valueToNodeAttribute(this, value, attribute);
      }
    }

    /**
     * Deserializes an attribute to its associated property.
     *
     * This method calls the `_deserializeValue` method to convert the string to
     * a typed value.
     *
     * @param {string} attribute Name of attribute to deserialize.
     * @param {?string} value of the attribute.
     * @param {*=} type type to deserialize to.
     */
    _attributeToProperty(attribute, value, type) {
      // Don't deserialize back to property if currently reflecting
      if (!this.__serializing) {
        let property = caseMap.dashToCamelCase(attribute);
        this[property] = this._deserializeValue(value, type);
      }
    }

    /**
     * Serializes a property to its associated attribute.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect.
     * @param {*=} value Property value to refect.
     */
    _propertyToAttribute(property, attribute, value) {
      this.__serializing = true;
      value = (arguments.length < 3) ? this[property] : value;
      this._valueToNodeAttribute(this, value,
        attribute || caseMap.camelToDashCase(property));
      this.__serializing = false;
    }

    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * This method calls the `_serializeValue` method to convert the typed
     * value to a string.  If the `_serializeValue` method returns `undefined`,
     * the attribute will be removed (this is the default for boolean
     * type `false`).
     *
     * @param {Element} node Element to set attribute to.
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     */
    _valueToNodeAttribute(node, value, attribute) {
      let str = this._serializeValue(value);
      if (str === undefined) {
        node.removeAttribute(attribute);
      } else {
        node.setAttribute(attribute, str);
      }
    }

    /**
     * Converts a typed JavaScript value to a string.
     *
     * This method is called by Polymer when setting JS property values to
     * HTML attributes.  Users may override this method on Polymer element
     * prototypes to provide serialization for custom types.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property value.
     */
    _serializeValue(value) {
      /* eslint-disable no-fallthrough */
      switch (typeof value) {
        case 'boolean':
          return value ? '' : undefined;

        case 'object':
          if (value instanceof Date) {
            return value.toString();
          } else if (value) {
            try {
              return JSON.stringify(value);
            } catch(x) {
              return '';
            }
          }

        default:
          return value != null ? value.toString() : undefined;
      }
    }

    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     * Note: The return value of `undefined` is used as a sentinel value to
     * indicate the attribute should be removed.
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     */
    _deserializeValue(value, type) {
      /**
       * @type {*}
       */
      let outValue;
      switch (type) {
        case Number:
          outValue = Number(value);
          break;

        case Boolean:
          outValue = (value !== null);
          break;

        case Object:
          try {
            outValue = JSON.parse(/** @type string */(value));
          } catch(x) {
            // allow non-JSON literals like Strings and Numbers
          }
          break;

        case Array:
          try {
            outValue = JSON.parse(/** @type string */(value));
          } catch(x) {
            outValue = null;
            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
          }
          break;

        case Date:
          outValue = new Date(value);
          break;

        case String:
        default:
          outValue = value;
          break;
      }

      return outValue;
    }
    /* eslint-enable no-fallthrough */

    /**
     * Creates a setter/getter pair for the named property with its own
     * local storage.  The getter returns the value in the local storage,
     * and the setter calls `_setProperty`, which updates the local storage
     * for the property and enqueues a `_propertiesChanged` callback.
     *
     * This method may be called on a prototype or an instance.  Calling
     * this method may overwrite a property value that already exists on
     * the prototype/instance by creating the accessor.  When calling on
     * a prototype, any overwritten values are saved in `__dataProto`,
     * and it is up to the subclasser to decide how/when to set those
     * properties back into the accessor.  When calling on an instance,
     * the overwritten value is set via `_setPendingProperty`, and the
     * user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     *
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created; the
     *   protected `_setProperty` function must be used to set the property
     * @protected
     */
    _createPropertyAccessor(property, readOnly) {
      if (!this.hasOwnProperty('__dataHasAccessor')) {
        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
      }
      if (!this.__dataHasAccessor[property]) {
        this.__dataHasAccessor[property] = true;
        saveAccessorValue(this, property);
        Object.defineProperty(this, property, {
          /* eslint-disable valid-jsdoc */
          /** @this {PropertyAccessors} */
          get: function() {
            return this.__data[property];
          },
          /** @this {PropertyAccessors} */
          set: readOnly ? function() {} : function(value) {
            this._setProperty(property, value);
          }
          /* eslint-enable */
        });
      }
    }

    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     */
    _hasAccessor(property) {
      return this.__dataHasAccessor && this.__dataHasAccessor[property];
    }

    /**
     * Updates the local storage for a property (via `_setPendingProperty`)
     * and enqueues a `_proeprtiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @protected
     */
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value)) {
        this._invalidateProperties();
      }
    }

    /**
     * Updates the local storage for a property, records the previous value,
     * and adds it to the set of "pending changes" that will be passed to the
     * `_propertiesChanged` callback.  This method does not enqueue the
     * `_propertiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {boolean} Returns true if the property changed
     * @protected
     */
    _setPendingProperty(property, value) {
      let old = this.__data[property];
      let changed = this._shouldPropertyChange(property, value, old);
      if (changed) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        // Ensure old is captured from the last turn
        if (this.__dataOld && !(property in this.__dataOld)) {
          this.__dataOld[property] = old;
        }
        this.__data[property] = value;
        this.__dataPending[property] = value;
      }
      return changed;
    }

    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     */
    _isPropertyPending(prop) {
      return Boolean(this.__dataPending && (prop in this.__dataPending));
    }

    /**
     * Marks the properties as invalid, and enqueues an async
     * `_propertiesChanged` callback.
     *
     * @protected
     */
    _invalidateProperties() {
      if (!this.__dataInvalid && this.__dataReady) {
        this.__dataInvalid = true;
        microtask.run(() => {
          if (this.__dataInvalid) {
            this.__dataInvalid = false;
            this._flushProperties();
          }
        });
      }
    }

    /**
     * Call to enable property accessor processing. Before this method is
     * called accessor values will be set but side effects are
     * queued. When called, any pending side effects occur immediately.
     * For elements, generally `connectedCallback` is a normal spot to do so.
     * It is safe to call this method multiple times as it only turns on
     * property accessors once.
     */
    _enableProperties() {
      if (!this.__dataEnabled) {
        this.__dataEnabled = true;
        if (this.__dataInstanceProps) {
          this._initializeInstanceProperties(this.__dataInstanceProps);
          this.__dataInstanceProps = null;
        }
        this.ready();
      }
    }

    /**
     * Calls the `_propertiesChanged` callback with the current set of
     * pending changes (and old values recorded when pending changes were
     * set), and resets the pending set of changes. Generally, this method
     * should not be called in user code.
     *
     *
     * @protected
     */
    _flushProperties() {
      if (this.__dataPending && this.__dataOld) {
        let changedProps = this.__dataPending;
        this.__dataPending = null;
        this.__dataCounter++;
        this._propertiesChanged(this.__data, changedProps, this.__dataOld);
        this.__dataCounter--;
      }
    }

    /**
     * Lifecycle callback called the first time properties are being flushed.
     * Prior to `ready`, all property sets through accessors are queued and
     * their effects are flushed after this method returns.
     *
     * Users may override this function to implement behavior that is
     * dependent on the element having its properties initialized, e.g.
     * from defaults (initialized from `constructor`, `_initializeProperties`),
     * `attributeChangedCallback`, or values propagated from host e.g. via
     * bindings.  `super.ready()` must be called to ensure the data system
     * becomes enabled.
     *
     * @public
     */
    ready() {
      this.__dataReady = true;
      // Run normal flush
      this._flushProperties();
    }

    /**
     * Callback called when any properties with accessors created via
     * `_createPropertyAccessor` have been set.
     *
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {!Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {!Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @protected
     */
    _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars
    }

    /**
     * Method called to determine whether a property value should be
     * considered as a change and cause the `_propertiesChanged` callback
     * to be enqueued.
     *
     * The default implementation returns `true` for primitive types if a
     * strict equality check fails, and returns `true` for all Object/Arrays.
     * The method always returns false for `NaN`.
     *
     * Override this method to e.g. provide stricter checking for
     * Objects/Arrays when using immutable patterns.
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     *   and enqueue a `_proeprtiesChanged` callback
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return (
        // Strict equality check
        (old !== value &&
         // This ensures (old==NaN, value==NaN) always returns false
         (old === old || value === value))
      );
    }

  }

  return PropertyAccessors;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = PropertyAccessors;



/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(4);



// 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)
const templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};
function wrapTemplateExtension(node) {
  let is = node.getAttribute('is');
  if (is && templateExtensions[is]) {
    let t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);
    while(t.attributes.length) {
      node.setAttribute(t.attributes[0].name, t.attributes[0].value);
      t.removeAttribute(t.attributes[0].name);
    }
  }
  return node;
}

function findTemplateNode(root, nodeInfo) {
  // recursively ascend tree until we hit root
  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
  // unwind the stack, returning the indexed node at each level
  if (parent) {
    // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
}

// construct `$` map (from id annotations)
function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
}

// install event listeners (from event annotations)
function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
}

// push configuration references at configure time
function applyTemplateContent(inst, node, nodeInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
  }
}

function createNodeEventHandler(context, eventName, methodName) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  context = context._methodHost || context;
  let handler = function(e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };
  return handler;
}

const TemplateStamp = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */
  class TemplateStamp extends superClass {

    /**
     * Scans a template to produce template metadata.
     *
     * Template-specific metadata are stored in the object returned, and node-
     * specific metadata are stored in objects in its flattened `nodeInfoList`
     * array.  Only nodes in the template that were parsed as nodes of
     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
     * contains an `index` (`childNodes` index in parent) and optionally
     * `parent`, which points to node info of its parent (including its index).
     *
     * The template metadata object returned from this method has the following
     * structure (many fields optional):
     *
     * ```js
     *   {
     *     // Flattened list of node metadata (for nodes that generated metadata)
     *     nodeInfoList: [
     *       {
     *         // `id` attribute for any nodes with id's for generating `$` map
     *         id: {string},
     *         // `on-event="handler"` metadata
     *         events: [
     *           {
     *             name: {string},   // event name
     *             value: {string},  // handler method name
     *           }, ...
     *         ],
     *         // Notes when the template contained a `<slot>` for shady DOM
     *         // optimization purposes
     *         hasInsertionPoint: {boolean},
     *         // For nested `<template>`` nodes, nested template metadata
     *         templateInfo: {object}, // nested template metadata
     *         // Metadata to allow efficient retrieval of instanced node
     *         // corresponding to this metadata
     *         parentInfo: {number},   // reference to parent nodeInfo>
     *         parentIndex: {number},  // index in parent's `childNodes` collection
     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
     *       },
     *       ...
     *     ],
     *     // When true, the template had the `strip-whitespace` attribute
     *     // or was nested in a template with that setting
     *     stripWhitespace: {boolean},
     *     // For nested templates, nested template content is moved into
     *     // a document fragment stored here; this is an optimization to
     *     // avoid the cost of nested template cloning
     *     content: {DocumentFragment}
     *   }
     * ```
     *
     * This method kicks off a recursive treewalk as follows:
     *
     * ```
     *    _parseTemplate <---------------------+
     *      _parseTemplateContent              |
     *        _parseTemplateNode  <------------|--+
     *          _parseTemplateNestedTemplate --+  |
     *          _parseTemplateChildNodes ---------+
     *          _parseTemplateNodeAttributes
     *            _parseTemplateNodeAttribute
     *
     * ```
     *
     * These methods may be overridden to add custom metadata about templates
     * to either `templateInfo` or `nodeInfo`.
     *
     * Note that this method may be destructive to the template, in that
     * e.g. event annotations may be removed after being noted in the
     * template metadata.
     *
     * @param {!HTMLTemplateElement} template Template to parse
     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
     *   template, for parsing nested templates
     * @return {!TemplateInfo} Parsed template metadata
     */
    static _parseTemplate(template, outerTemplateInfo) {
      // since a template may be re-used, memo-ize metadata
      if (!template._templateInfo) {
        let templateInfo = template._templateInfo = {};
        templateInfo.nodeInfoList = [];
        templateInfo.stripWhiteSpace =
          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||
          template.hasAttribute('strip-whitespace');
        this._parseTemplateContent(template, templateInfo, {parent: null});
      }
      return template._templateInfo;
    }

    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
    }

    /**
     * Parses template node and adds template and node metadata based on
     * the current node, and its `childNodes` and `attributes`.
     *
     * This method may be overridden to add custom node or template specific
     * metadata based on this node.
     *
     * @param {Node} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted;
      let element = /** @type Element */(node);
      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
      } else if (element.localName === 'slot') {
        // For ShadyDom optimization, indicating there is an insertion point
        templateInfo.hasInsertionPoint = true;
      }
      if (element.firstChild) {
        noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
      }
      if (element.hasAttributes && element.hasAttributes()) {
        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
      }
      return noted;
    }

    /**
     * Parses template child nodes for the given root node.
     *
     * This method also wraps whitelisted legacy template extensions
     * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
     * wrappers, collapses text nodes, and strips whitespace from the template
     * if the `templateInfo.stripWhitespace` setting was provided.
     *
     * @param {Node} root Root node whose `childNodes` will be parsed
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     */
    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
      for (let node=root.firstChild, parentIndex=0, next; node; node=next) {
        // Wrap templates
        if (node.localName == 'template') {
          node = wrapTemplateExtension(node);
        }
        // collapse adjacent textNodes: fixes an IE issue that can cause
        // text nodes to be inexplicably split =(
        // note that root.normalize() should work but does not so we do this
        // manually.
        next = node.nextSibling;
        if (node.nodeType === Node.TEXT_NODE) {
          let /** Node */ n = next;
          while (n && (n.nodeType === Node.TEXT_NODE)) {
            node.textContent += n.textContent;
            next = n.nextSibling;
            root.removeChild(n);
            n = next;
          }
          // optionally strip whitespace
          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
            root.removeChild(node);
            continue;
          }
        }
        let childInfo = { parentIndex, parentInfo: nodeInfo };
        if (this._parseTemplateNode(node, templateInfo, childInfo)) {
          childInfo.infoIndex = templateInfo.nodeInfoList.push(/** @type {!NodeInfo} */(childInfo)) - 1;
        }
        // Increment if not removed
        if (node.parentNode) {
          parentIndex++;
        }
      }
    }

    /**
     * Parses template content for the given nested `<template>`.
     *
     * Nested template info is stored as `templateInfo` in the current node's
     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
     * It will then be the responsibility of the host to set it back to the
     * template and for users stamping nested templates to use the
     * `_contentForTemplate` method to retrieve the content for this template
     * (an optimization to avoid the cost of cloning nested template content).
     *
     * @param {HTMLTemplateElement} node Node to parse (a <template>)
     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
     *   that includes the template `node`
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
      let templateInfo = this._parseTemplate(node, outerTemplateInfo);
      let content = templateInfo.content =
        node.content.ownerDocument.createDocumentFragment();
      content.appendChild(node.content);
      nodeInfo.templateInfo = templateInfo;
      return true;
    }

    /**
     * Parses template node attributes and adds node metadata to `nodeInfo`
     * for nodes of interest.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
      // Make copy of original attribute list, since the order may change
      // as attributes are added and removed
      let noted = false;
      let attrs = Array.from(node.attributes);
      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {
        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
      }
      return noted;
    }

    /**
     * Parses a single template node attribute and adds node metadata to
     * `nodeInfo` for attributes of interest.
     *
     * This implementation adds metadata for `on-event="handler"` attributes
     * and `id` attributes.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      // events (on-*)
      if (name.slice(0, 3) === 'on-') {
        node.removeAttribute(name);
        nodeInfo.events = nodeInfo.events || [];
        nodeInfo.events.push({
          name: name.slice(3),
          value
        });
        return true;
      }
      // static id
      else if (name === 'id') {
        nodeInfo.id = value;
        return true;
      }
      return false;
    }

    /**
     * Returns the `content` document fragment for a given template.
     *
     * For nested templates, Polymer performs an optimization to cache nested
     * template content to avoid the cost of cloning deeply nested templates.
     * This method retrieves the cached content for a given template.
     *
     * @param {HTMLTemplateElement} template Template to retrieve `content` for
     * @return {DocumentFragment} Content fragment
     */
    static _contentForTemplate(template) {
      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;
      return (templateInfo && templateInfo.content) || template.content;
    }

    /**
     * Clones the provided template content and returns a document fragment
     * containing the cloned dom.
     *
     * The template is parsed (once and memoized) using this library's
     * template parsing features, and provides the following value-added
     * features:
     * * Adds declarative event listeners for `on-event="handler"` attributes
     * * Generates an "id map" for all nodes with id's under `$` on returned
     *   document fragment
     * * Passes template info including `content` back to templates as
     *   `_templateInfo` (a performance optimization to avoid deep template
     *   cloning)
     *
     * Note that the memoized template parsing process is destructive to the
     * template: attributes for bindings and declarative event listeners are
     * removed after being noted in notes, and any nested `<template>.content`
     * is removed and stored in notes as well.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     */
    _stampTemplate(template) {
      // Polyfill support: bootstrap the template if it has not already been
      if (template && !template.content &&
          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
        HTMLTemplateElement.decorate(template);
      }
      let templateInfo = this.constructor._parseTemplate(template);
      let nodeInfo = templateInfo.nodeInfoList;
      let content = templateInfo.content || template.content;
      let dom = /** @type DocumentFragment */ (document.importNode(content, true));
      // NOTE: ShadyDom optimization indicating there is an insertion point
      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
      let nodes = dom.nodeList = new Array(nodeInfo.length);
      dom.$ = {};
      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {
        let node = nodes[i] = findTemplateNode(dom, info);
        applyIdToMap(this, dom.$, node, info);
        applyTemplateContent(this, node, info);
        applyEventListener(this, node, info);
      }
      return /** @type {!StampedTemplate} */(dom);
    }

    /**
     * Adds an event listener by method name for the event provided.
     *
     * This method generates a handler function that looks up the method
     * name at handling time.
     *
     * @param {Node} node Node to add listener on
     * @param {string} eventName Name of event
     * @param {string} methodName Name of method
     * @param {*=} context Context the method will be called on (defaults
     *   to `node`)
     * @return {Function} Generated handler function
     */
    _addMethodEventListenerToNode(node, eventName, methodName, context) {
      context = context || node;
      let handler = createNodeEventHandler(context, eventName, methodName);
      this._addEventListenerToNode(node, eventName, handler);
      return handler;
    }

    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {Node} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {Function} handler Listener function to add
     */
    _addEventListenerToNode(node, eventName, handler) {
      node.addEventListener(eventName, handler);
    }

    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {Node} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {Function} handler Listener function to remove
     */
    _removeEventListenerFromNode(node, eventName, handler) {
      node.removeEventListener(eventName, handler);
    }

  }

  return TemplateStamp;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = TemplateStamp;



/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


// run a callback when HTMLImports are ready or immediately if
// this api is not available.
function whenImportsReady(cb) {
  if (window.HTMLImports) {
    HTMLImports.whenReady(cb);
  } else {
    cb();
  }
}

const importHref = function(href, onload, onerror, optAsync) {
  let link = /** @type {HTMLLinkElement} */
    (document.head.querySelector('link[href="' + href + '"][import-href]'));
  if (!link) {
    link = /** @type {HTMLLinkElement} */ (document.createElement('link'));
    link.rel = 'import';
    link.href = href;
    link.setAttribute('import-href', '');
  }
  // always ensure link has `async` attribute if user specified one,
  // even if it was previously not async. This is considered less confusing.
  if (optAsync) {
    link.setAttribute('async', '');
  }
  // NOTE: the link may now be in 3 states: (1) pending insertion,
  // (2) inflight, (3) already laoded. In each case, we need to add
  // event listeners to process callbacks.
  let cleanup = function() {
    link.removeEventListener('load', loadListener);
    link.removeEventListener('error', errorListener);
  };
  let loadListener = function(event) {
    cleanup();
    // In case of a successful load, cache the load event on the link so
    // that it can be used to short-circuit this method in the future when
    // it is called with the same href param.
    link.__dynamicImportLoaded = true;
    if (onload) {
      whenImportsReady(() => {
        onload(event);
      });
    }
  };
  let errorListener = function(event) {
    cleanup();
    // In case of an error, remove the link from the document so that it
    // will be automatically created again the next time `importHref` is
    // called.
    if (link.parentNode) {
      link.parentNode.removeChild(link);
    }
    if (onerror) {
      whenImportsReady(() => {
        onerror(event);
      });
    }
  };
  link.addEventListener('load', loadListener);
  link.addEventListener('error', errorListener);
  if (link.parentNode == null) {
    document.head.appendChild(link);
  // if the link already loaded, dispatch a fake load event
  // so that listeners are called and get a proper event argument.
  } else if (link.__dynamicImportLoaded) {
    link.dispatchEvent(new Event('load'));
  }
  return link;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = importHref;



/***/ }),
/* 62 */
/***/ (function(module, exports) {

function resolve() {
  document.body.removeAttribute('unresolved');
}

if (document.readyState === 'interactive' || document.readyState === 'complete') {
  resolve();
} else {
  window.addEventListener('DOMContentLoaded', resolve);
}


/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FlattenedNodesObserver; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array_splice_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__async_js__ = __webpack_require__(6);




/**
 * Returns true if `node` is a slot element
 * @param {HTMLElement} node Node to test.
 * @return {boolean} Returns true if the given `node` is a slot
 * @private
 */
function isSlot(node) {
  return (node.localName === 'slot');
}

/**
 * Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`. The list of flattened nodes consists
 * of a node's children and, for any children that are `<slot>` elements,
 * the expanded flattened list of `assignedNodes`.
 * For example, if the observed node has children `<a></a><slot></slot><b></b>`
 * and the `<slot>` has one `<div>` assigned to it, then the flattened
 * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
 * `<slot>` elements assigned to it, these are flattened as well.
 *
 * The provided `callback` is called whenever any change to this list
 * of flattened nodes occurs, where an addition or removal of a node is
 * considered a change. The `callback` is called with one argument, an object
 * containing an array of any `addedNodes` and `removedNodes`.
 *
 * Note: the callback is called asynchronous to any changes
 * at a microtask checkpoint. This is because observation is performed using
 * `MutationObserver` and the `<slot>` element's `slotchange` event which
 * are asynchronous.
 *
 * @memberof Polymer
 * @summary Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`.
 */
class FlattenedNodesObserver {

  /**
   * Returns the list of flattened nodes for the given `node`.
   * This list consists of a node's children and, for any children
   * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
   * @return {Array} The list of flattened nodes for the given `node`.
  */
  static getFlattenedNodes(node) {
    if (isSlot(node)) {
      return /** @type {HTMLSlotElement} */ (node).assignedNodes({flatten: true});
    } else {
      return Array.from(node.childNodes).map(node => {
        if (isSlot(node)) {
          return /** @type {HTMLSlotElement} */ (node).assignedNodes({flatten: true});
        } else {
          return [node];
        }
      }).reduce((a, b) => a.concat(b), []);
    }
  }

  /**
   * @param {Node} target Node on which to listen for changes.
   * @param {Function} callback Function called when there are additions
   * or removals from the target's list of flattened nodes.
  */
  constructor(target, callback) {
    /** @type {MutationObserver} */
    this._shadyChildrenObserver = null;
    /** @type {MutationObserver} */
    this._nativeChildrenObserver = null;
    this._connected = false;
    this._target = target;
    this.callback = callback;
    this._effectiveNodes = [];
    this._observer = null;
    this._scheduled = false;
    /** @type {function()} */
    this._boundSchedule = () => {
      this._schedule();
    };
    this.connect();
    this._schedule();
  }

  /**
   * Activates an observer. This method is automatically called when
   * a `FlattenedNodesObserver` is created. It should only be called to
   * re-activate an observer that has been deactivated via the `disconnect` method.
   */
  connect() {
    if (isSlot(this._target)) {
      this._listenSlots([this._target]);
    } else {
      this._listenSlots(this._target.children);
      if (window.ShadyDOM) {
        this._shadyChildrenObserver =
          ShadyDOM.observeChildren(this._target, (mutations) => {
            this._processMutations(mutations);
          });
      } else {
        this._nativeChildrenObserver =
          new MutationObserver((mutations) => {
            this._processMutations(mutations);
          });
        this._nativeChildrenObserver.observe(this._target, {childList: true});
      }
    }
    this._connected = true;
  }

  /**
   * Deactivates the flattened nodes observer. After calling this method
   * the observer callback will not be called when changes to flattened nodes
   * occur. The `connect` method may be subsequently called to reactivate
   * the observer.
   */
  disconnect() {
    if (isSlot(this._target)) {
      this._unlistenSlots([this._target]);
    } else {
      this._unlistenSlots(this._target.children);
      if (window.ShadyDOM && this._shadyChildrenObserver) {
        ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
        this._shadyChildrenObserver = null;
      } else if (this._nativeChildrenObserver) {
        this._nativeChildrenObserver.disconnect();
        this._nativeChildrenObserver = null;
      }
    }
    this._connected = false;
  }

  _schedule() {
    if (!this._scheduled) {
      this._scheduled = true;
      __WEBPACK_IMPORTED_MODULE_2__async_js__["a" /* microTask */].run(() => this.flush());
    }
  }

  _processMutations(mutations) {
    this._processSlotMutations(mutations);
    this.flush();
  }

  _processSlotMutations(mutations) {
    if (mutations) {
      for (let i=0; i < mutations.length; i++) {
        let mutation = mutations[i];
        if (mutation.addedNodes) {
          this._listenSlots(mutation.addedNodes);
        }
        if (mutation.removedNodes) {
          this._unlistenSlots(mutation.removedNodes);
        }
      }
    }
  }

  /**
   * Flushes the observer causing any pending changes to be immediately
   * delivered the observer callback. By default these changes are delivered
   * asynchronously at the next microtask checkpoint.
   *
   * @return {boolean} Returns true if any pending changes caused the observer
   * callback to run.
   */
  flush() {
    if (!this._connected) {
      return false;
    }
    if (window.ShadyDOM) {
      ShadyDOM.flush();
    }
    if (this._nativeChildrenObserver) {
      this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
    } else if (this._shadyChildrenObserver) {
      this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
    }
    this._scheduled = false;
    let info = {
      target: this._target,
      addedNodes: [],
      removedNodes: []
    };
    let newNodes = this.constructor.getFlattenedNodes(this._target);
    let splices = Object(__WEBPACK_IMPORTED_MODULE_1__array_splice_js__["a" /* calculateSplices */])(newNodes,
      this._effectiveNodes);
    // process removals
    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {
        info.removedNodes.push(n);
      }
    }
    // process adds
    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (let j=s.index; j < s.index + s.addedCount; j++) {
        info.addedNodes.push(newNodes[j]);
      }
    }
    // update cache
    this._effectiveNodes = newNodes;
    let didFlush = false;
    if (info.addedNodes.length || info.removedNodes.length) {
      didFlush = true;
      this.callback.call(this._target, info);
    }
    return didFlush;
  }

  _listenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      let n = nodeList[i];
      if (isSlot(n)) {
        n.addEventListener('slotchange', this._boundSchedule);
      }
    }
  }

  _unlistenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      let n = nodeList[i];
      if (isSlot(n)) {
        n.removeEventListener('slotchange', this._boundSchedule);
      }
    }
  }

}




/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export mixinBehaviors */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__legacy_element_mixin_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__elements_dom_module_js__ = __webpack_require__(25);



let metaProps = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  // meta objects
  behaviors: true
};

/**
 * Applies a "legacy" behavior or array of behaviors to the provided class.
 *
 * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
 * to ensure that any legacy behaviors can rely on legacy Polymer API on
 * the underlying element.
 *
 * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
 * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
 * @return {function(new:HTMLElement)} Returns a new Element class extended by the
 * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
 * @memberof Polymer
 * @suppress {invalidCasts, checkTypes}
 */
function mixinBehaviors(behaviors, klass) {
  if (!behaviors) {
    return /** @type {HTMLElement} */(klass);
  }
  // NOTE: ensure the bahevior is extending a class with
  // legacy element api. This is necessary since behaviors expect to be able
  // to access 1.x legacy api.
  klass = Object(__WEBPACK_IMPORTED_MODULE_0__legacy_element_mixin_js__["a" /* LegacyElementMixin */])(klass);
  if (!Array.isArray(behaviors)) {
    behaviors = [behaviors];
  }
  let superBehaviors = klass.prototype.behaviors;
  // get flattened, deduped list of behaviors *not* already on super class
  behaviors = flattenBehaviors(behaviors, null, superBehaviors);
  // mixin new behaviors
  klass = _mixinBehaviors(behaviors, klass);
  if (superBehaviors) {
    behaviors = superBehaviors.concat(behaviors);
  }
  // Set behaviors on prototype for BC...
  klass.prototype.behaviors = behaviors;
  return klass;
}

// NOTE:
// 1.x
// Behaviors were mixed in *in reverse order* and de-duped on the fly.
// The rule was that behavior properties were copied onto the element
// prototype if and only if the property did not already exist.
// Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
// (1), B, (2), A, (3) C. This means prototype properties win over
// B properties win over A win over C. This mirrors what would happen
// with inheritance if element extended B extended A extended C.
//
// Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
// `behaviors` array was [C, A, B].
// Behavior lifecycle methods were called in behavior array order
// followed by the element, e.g. (1) C.created, (2) A.created,
// (3) B.created, (4) element.created. There was no support for
// super, and "super-behavior" methods were callable only by name).
//
// 2.x
// Behaviors are made into proper mixins which live in the
// element's prototype chain. Behaviors are placed in the element prototype
// eldest to youngest and de-duped youngest to oldest:
// So, first [A, B, C, A, B] becomes [C, A, B] then,
// the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
// (3) class(A), (4) class(B), (5) class(Polymer({...})).
// Result:
// This means element properties win over B properties win over A win
// over C. (same as 1.x)
// If lifecycle is called (super then me), order is
// (1) C.created, (2) A.created, (3) B.created, (4) element.created
// (again same as 1.x)
function _mixinBehaviors(behaviors, klass) {
  for (let i=0; i<behaviors.length; i++) {
    let b = behaviors[i];
    if (b) {
      klass = Array.isArray(b) ? _mixinBehaviors(b, klass) :
        GenerateClassFromInfo(b, klass);
    }
  }
  return klass;
}

/**
 * @param {Array} behaviors List of behaviors to flatten.
 * @param {Array=} list Target list to flatten behaviors into.
 * @param {Array=} exclude List of behaviors to exclude from the list.
 * @return {!Array} Returns the list of flattened behaviors.
 */
function flattenBehaviors(behaviors, list, exclude) {
  list = list || [];
  for (let i=behaviors.length-1; i >= 0; i--) {
    let b = behaviors[i];
    if (b) {
      if (Array.isArray(b)) {
        flattenBehaviors(b, list);
      } else {
        // dedup
        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
          list.unshift(b);
        }
      }
    } else {
      console.warn('behavior is null, check for missing or 404 import');
    }
  }
  return list;
}

/**
 * @param {!PolymerInit} info Polymer info object
 * @param {function(new:HTMLElement)} Base base class to extend with info object
 * @return {function(new:HTMLElement)} Generated class
 * @suppress {checkTypes}
 * @private
 */
function GenerateClassFromInfo(info, Base) {

  class PolymerGenerated extends Base {

    static get properties() {
      return info.properties;
    }

    static get observers() {
      return info.observers;
    }

    /**
     * @return {HTMLTemplateElement} template for this class
     */
    static get template() {
      // get template first from any imperative set in `info._template`
      return info._template ||
        // next look in dom-module associated with this element's is.
        __WEBPACK_IMPORTED_MODULE_1__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_1__elements_dom_module_js__["a" /* DomModule */].import(this.is, 'template') ||
        // next look for superclass template (note: use superclass symbol
        // to ensure correct `this.is`)
        Base.template ||
        // finally fall back to `_template` in element's protoype.
        this.prototype._template ||
        null;
    }

    created() {
      super.created();
      if (info.created) {
        info.created.call(this);
      }
    }

    _registered() {
      super._registered();
      /* NOTE: `beforeRegister` is called here for bc, but the behavior
       is different than in 1.x. In 1.0, the method was called *after*
       mixing prototypes together but *before* processing of meta-objects.
       However, dynamic effects can still be set here and can be done either
       in `beforeRegister` or `registered`. It is no longer possible to set
       `is` in `beforeRegister` as you could in 1.x.
      */
      if (info.beforeRegister) {
        info.beforeRegister.call(Object.getPrototypeOf(this));
      }
      if (info.registered) {
        info.registered.call(Object.getPrototypeOf(this));
      }
    }

    _applyListeners() {
      super._applyListeners();
      if (info.listeners) {
        for (let l in info.listeners) {
          this._addMethodEventListenerToNode(this, l, info.listeners[l]);
        }
      }
    }

    // note: exception to "super then me" rule;
    // do work before calling super so that super attributes
    // only apply if not already set.
    _ensureAttributes() {
      if (info.hostAttributes) {
        for (let a in info.hostAttributes) {
          this._ensureAttribute(a, info.hostAttributes[a]);
        }
      }
      super._ensureAttributes();
    }

    ready() {
      super.ready();
      if (info.ready) {
        info.ready.call(this);
      }
    }

    attached() {
      super.attached();
      if (info.attached) {
        info.attached.call(this);
      }
    }

    detached() {
      super.detached();
      if (info.detached) {
        info.detached.call(this);
      }
    }

    attributeChanged(name, old, value) {
      super.attributeChanged(name, old, value);
      if (info.attributeChanged) {
        info.attributeChanged.call(this, name, old, value);
      }
   }
  }

  PolymerGenerated.generatedFrom = info;

  for (let p in info) {
    // NOTE: cannot copy `metaProps` methods onto prototype at least because
    // `super.ready` must be called and is not included in the user fn.
    if (!(p in metaProps)) {
      let pd = Object.getOwnPropertyDescriptor(info, p);
      if (pd) {
        Object.defineProperty(PolymerGenerated.prototype, p, pd);
      }
    }
  }

  return PolymerGenerated;
}

const Class = function(info) {
  if (!info) {
    console.warn('Polymer.Class requires `info` argument');
  }
  let klass = GenerateClassFromInfo(info, info.behaviors ?
    // note: mixinBehaviors ensures `LegacyElementMixin`.
    mixinBehaviors(info.behaviors, HTMLElement) :
    Object(__WEBPACK_IMPORTED_MODULE_0__legacy_element_mixin_js__["a" /* LegacyElementMixin */])(HTMLElement));
  // decorate klass with registration info
  klass.is = info.is;
  return klass;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = Class;





/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Templatizer */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__ = __webpack_require__(29);


let TemplateInstanceBase = __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__["a" /* TemplateInstanceBase */]; // eslint-disable-line

/**
 * @typedef {{
 *   _templatizerTemplate: HTMLTemplateElement,
 *   _parentModel: boolean,
 *   _instanceProps: Object,
 *   _forwardHostPropV2: Function,
 *   _notifyInstancePropV2: Function,
 *   ctor: TemplateInstanceBase
 * }}
 */
let TemplatizerUser; // eslint-disable-line

/**
 * The `Polymer.Templatizer` behavior adds methods to generate instances of
 * templates that are each managed by an anonymous `Polymer.PropertyEffects`
 * instance where data-bindings in the stamped template content are bound to
 * accessors on itself.
 *
 * This behavior is provided in Polymer 2.x as a hybrid-element convenience
 * only.  For non-hybrid usage, the `Polymer.Templatize` library
 * should be used instead.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     this.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = this.stamp({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. light DOM
 *     Polymer.dom(this).appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * Users of `Templatizer` may need to implement the following abstract
 * API's to determine how properties and paths from the host should be
 * forwarded into to instances:
 *
 *     _forwardHostPropV2: function(prop, value)
 *
 * Likewise, users may implement these additional abstract API's to determine
 * how instance-specific properties that change on the instance should be
 * forwarded out to the host, if necessary.
 *
 *     _notifyInstancePropV2: function(inst, prop, value)
 *
 * In order to determine which properties are instance-specific and require
 * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
 * object containing keys for each instance prop, for example:
 *
 *     _instanceProps: {
 *       item: true,
 *       index: true
 *     }
 *
 * Any properties used in the template that are not defined in _instanceProp
 * will be forwarded out to the Templatize `owner` automatically.
 *
 * Users may also implement the following abstract function to show or
 * hide any DOM generated using `stamp`:
 *
 *     _showHideChildren: function(shouldHide)
 *
 * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
 * as the implementations will need to differ from the callbacks required
 * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
 * between versions 1.x and 2.x.
 *
 * @polymerBehavior
 * @memberof Polymer
 */
let Templatizer = {

  /**
   * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
   * for the provided template.  This method should be called once per
   * template to prepare an element for stamping the template, followed
   * by `stamp` to create new instances of the template.
   *
   * @param {HTMLTemplateElement} template Template to prepare
   * @param {boolean=} mutableData When `true`, the generated class will skip
   *   strict dirty-checking for objects and arrays (always consider them to
   *   be "dirty"). Defaults to false.
   * @this {TemplatizerUser}
   */
  templatize(template, mutableData) {
    this._templatizerTemplate = template;
    this.ctor = __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__["b" /* Templatize */].templatize(template, this, {
      mutableData: Boolean(mutableData),
      parentModel: this._parentModel,
      instanceProps: this._instanceProps,
      forwardHostProp: this._forwardHostPropV2,
      notifyInstanceProp: this._notifyInstancePropV2
    });
  },

  /**
   * Creates an instance of the template prepared by `templatize`.  The object
   * returned is an instance of the anonymous class generated by `templatize`
   * whose `root` property is a document fragment containing newly cloned
   * template content, and which has property accessors corresponding to
   * properties referenced in template bindings.
   *
   * @param {Object=} model Object containing initial property values to
   *   populate into the template bindings.
   * @return {TemplateInstanceBase} Returns the created instance of
   * the template prepared by `templatize`.
   * @this {TemplatizerUser}
   */
  stamp(model) {
    return new this.ctor(model);
  },

  /**
   * Returns the template "model" (`TemplateInstance`) associated with
   * a given element, which serves as the binding scope for the template
   * instance the element is contained in.  A template model should be used
   * to manipulate data associated with this template instance.
   *
   * @param {HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   * @this {TemplatizerUser}
   */
  modelForElement(el) {
    return __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__["b" /* Templatize */].modelForElement(this._templatizerTemplate, el);
  }
};




/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomBind */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mixins_gesture_event_listeners_js__ = __webpack_require__(42);





/**
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @implements {Polymer_OptionalMutableData}
 * @implements {Polymer_GestureEventListeners}
 */
const domBindBase =
  Object(__WEBPACK_IMPORTED_MODULE_3__mixins_gesture_event_listeners_js__["a" /* GestureEventListeners */])(
    Object(__WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__["b" /* OptionalMutableData */])(
      Object(__WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__["a" /* PropertyEffects */])(HTMLElement)));

/**
 * Custom element to allow using Polymer's template features (data binding,
 * declarative event listeners, etc.) in the main document without defining
 * a new custom element.
 *
 * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
 * element, which will immediately stamp the wrapped template into the main
 * document and bind elements to the `dom-bind` element itself as the
 * binding scope.
 *
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @appliesMixin Polymer.OptionalMutableData
 * @appliesMixin Polymer.GestureEventListeners
 * @extends {domBindBase}
 * @memberof Polymer
 * @summary Custom element to allow using Polymer's template features (data
 *   binding, declarative event listeners, etc.) in the main document.
 */
class DomBind extends domBindBase {

  static get observedAttributes() { return ['mutable-data']; }

  constructor() {
    super();
    this.root = null;
    this.$ = null;
    this.__children = null;
  }

  // assumes only one observed attribute
  attributeChangedCallback() {
    this.mutableData = true;
  }

  connectedCallback() {
    this.render();
  }

  disconnectedCallback() {
    this.__removeChildren();
  }

  __insertChildren() {
    this.parentNode.insertBefore(this.root, this);
  }

  __removeChildren() {
    if (this.__children) {
      for (let i=0; i<this.__children.length; i++) {
        this.root.appendChild(this.__children[i]);
      }
    }
  }

  /**
   * Forces the element to render its content. This is typically only
   * necessary to call if HTMLImports with the async attribute are used.
   */
  render() {
    let template;
    if (!this.__children) {
      template = /** @type {HTMLTemplateElement} */(template || this.querySelector('template'));
      if (!template) {
        // Wait until childList changes and template should be there by then
        let observer = new MutationObserver(() => {
          template = /** @type {HTMLTemplateElement} */(this.querySelector('template'));
          if (template) {
            observer.disconnect();
            this.render();
          } else {
            throw new Error('dom-bind requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return;
      }
      this.root = this._stampTemplate(template);
      this.$ = this.root.$;
      this.__children = [];
      for (let n=this.root.firstChild; n; n=n.nextSibling) {
        this.__children[this.__children.length] = n;
      }
      this._enableProperties();
    }
    this.__insertChildren();
    this.dispatchEvent(new CustomEvent('dom-change', {
      bubbles: true,
      composed: true
    }));
  }

}

customElements.define('dom-bind', DomBind);




/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomRepeat */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mixins_mutable_data_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_path_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_async_js__ = __webpack_require__(6);








let TemplateInstanceBase = __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["a" /* TemplateInstanceBase */]; // eslint-disable-line

/**
 * @constructor
 * @implements {Polymer_OptionalMutableData}
 * @extends {Polymer.Element}
 */
const domRepeatBase = Object(__WEBPACK_IMPORTED_MODULE_4__mixins_mutable_data_js__["b" /* OptionalMutableData */])(__WEBPACK_IMPORTED_MODULE_0__polymer_element_js__["a" /* Element */]);

/**
 * The `<dom-repeat>` element will automatically stamp and binds one instance
 * of template content to each object in a user-provided array.
 * `dom-repeat` accepts an `items` property, and one instance of the template
 * is stamped for each item into the DOM at the location of the `dom-repeat`
 * element.  The `item` property will be set on each instance's binding
 * scope, thus templates should bind to sub-properties of `item`.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 *   <script>
 *     Polymer({
 *       is: 'employee-list',
 *       ready: function() {
 *         this.employees = [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *         ];
 *       }
 *     });
 *   < /script>
 *
 * </dom-module>
 * ```
 *
 * Notifications for changes to items sub-properties will be forwarded to template
 * instances, which will update via the normal structured data notification system.
 *
 * Mutations to the `items` array itself should be made using the Array
 * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
 * `unshift`), and template instances will be kept in sync with the data in the
 * array.
 *
 * Events caught by event handlers within the `dom-repeat` template will be
 * decorated with a `model` property, which represents the binding scope for
 * each template instance.  The model is an instance of Polymer.Base, and should
 * be used to manipulate data on the instance, for example
 * `event.model.set('item.checked', true);`.
 *
 * Alternatively, the model for a template instance for an element stamped by
 * a `dom-repeat` can be obtained using the `modelForElement` API on the
 * `dom-repeat` that stamped it, for example
 * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
 * This may be useful for manipulating instance data of event targets obtained
 * by event handlers on parents of the `dom-repeat` (event delegation).
 *
 * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
 * `filter` and/or `sort` property.  This may be a string that names a function on
 * the host, or a function may be assigned to the property directly.  The functions
 * should implemented following the standard `Array` filter/sort API.
 *
 * In order to re-run the filter or sort functions based on changes to sub-fields
 * of `items`, the `observe` property may be set as a space-separated list of
 * `item` sub-fields that should cause a re-filter/sort when modified.  If
 * the filter or sort function depends on properties not contained in `items`,
 * the user should observe changes to those properties and call `render` to update
 * the view based on the dependency change.
 *
 * For example, for an `dom-repeat` with a filter of the following:
 *
 * ```js
 * isEngineer: function(item) {
 *     return item.type == 'engineer' || item.manager.type == 'engineer';
 * }
 * ```
 *
 * Then the `observe` property should be configured as follows:
 *
 * ```html
 * <template is="dom-repeat" items="{{employees}}"
 *           filter="isEngineer" observe="type manager.type">
 * ```
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @extends {domRepeatBase}
 * @appliesMixin Polymer.OptionalMutableData
 * @summary Custom element for stamping instance of a template bound to
 *   items in an array.
 */
class DomRepeat extends domRepeatBase {

  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'dom-repeat'; }

  static get template() { return null; }

  static get properties() {

    /**
     * Fired whenever DOM is added or removed by this template (by
     * default, rendering occurs lazily).  To force immediate rendering, call
     * `render`.
     *
     * @event dom-change
     */
    return {

      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },

      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: 'item'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the sorted and filtered list of rendered items.
       * Note, for the index in the `this.items` array, use the value of the
       * `itemsIndexAs` property.
       */
      indexAs: {
        type: String,
        value: 'index'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the `this.items` array. Note, for the index of
       * this instance in the sorted and filtered list of rendered items,
       * use the value of the `indexAs` property.
       */
      itemsIndexAs: {
        type: String,
        value: 'itemsIndex'
      },

      /**
       * A function that should determine the sort order of the items.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.sort`.
       * Using a sort function has no effect on the underlying `items` array.
       */
      sort: {
        type: Function,
        observer: '__sortChanged'
      },

      /**
       * A function that can be used to filter items out of the view.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.filter`.
       * Using a filter function has no effect on the underlying `items` array.
       */
      filter: {
        type: Function,
        observer: '__filterChanged'
      },

      /**
       * When using a `filter` or `sort` function, the `observe` property
       * should be set to a space-separated list of the names of item
       * sub-fields that should trigger a re-sort or re-filter when changed.
       * These should generally be fields of `item` that the sort or filter
       * function depends on.
       */
      observe: {
        type: String,
        observer: '__observeChanged'
      },

      /**
       * When using a `filter` or `sort` function, the `delay` property
       * determines a debounce time after a change to observed item
       * properties that must pass before the filter or sort is re-run.
       * This is useful in rate-limiting shuffing of the view when
       * item changes may be frequent.
       */
      delay: Number,

      /**
       * Count of currently rendered items after `filter` (if any) has been applied.
       * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
       * set of template instances is rendered.
       *
       */
      renderedItemCount: {
        type: Number,
        notify: true,
        readOnly: true
      },

      /**
       * Defines an initial count of template instances to render after setting
       * the `items` array, before the next paint, and puts the `dom-repeat`
       * into "chunking mode".  The remaining items will be created and rendered
       * incrementally at each animation frame therof until all instances have
       * been rendered.
       */
      initialCount: {
        type: Number,
        observer: '__initializeChunking'
      },

      /**
       * When `initialCount` is used, this property defines a frame rate to
       * target by throttling the number of instances rendered each frame to
       * not exceed the budget for the target frame rate.  Setting this to a
       * higher number will allow lower latency and higher throughput for
       * things like event handlers, but will result in a longer time for the
       * remaining items to complete rendering.
       */
      targetFramerate: {
        type: Number,
        value: 20
      },

      _targetFrameTime: {
        type: Number,
        computed: '__computeFrameTime(targetFramerate)'
      }

    };

  }

  static get observers() {
    return [ '__itemsChanged(items.*)' ];
  }

  constructor() {
    super();
    this.__instances = [];
    this.__limit = Infinity;
    this.__pool = [];
    this.__renderDebouncer = null;
    this.__itemsIdxToInstIdx = {};
    this.__chunkCount = null;
    this.__lastChunkTime = null;
    this.__sortFn = null;
    this.__filterFn = null;
    this.__observePaths = null;
    this.__ctor = null;
    this.__isDetached = true;
    this.template = null;
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isDetached = true;
    for (let i=0; i<this.__instances.length; i++) {
      this.__detachInstance(i);
    }
  }

  connectedCallback() {
    super.connectedCallback();
    // only perform attachment if the element was previously detached.
    if (this.__isDetached) {
      this.__isDetached = false;
      let parent = this.parentNode;
      for (let i=0; i<this.__instances.length; i++) {
        this.__attachInstance(i, parent);
      }
    }
  }

  __ensureTemplatized() {
    // Templatizing (generating the instance constructor) needs to wait
    // until ready, since won't have its template content handed back to
    // it until then
    if (!this.__ctor) {
      let template = this.template = this.querySelector('template');
      if (!template) {
        // // Wait until childList changes and template should be there by then
        let observer = new MutationObserver(() => {
          if (this.querySelector('template')) {
            observer.disconnect();
            this.__render();
          } else {
            throw new Error('dom-repeat requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return false;
      }
      // Template instance props that should be excluded from forwarding
      let instanceProps = {};
      instanceProps[this.as] = true;
      instanceProps[this.indexAs] = true;
      instanceProps[this.itemsIndexAs] = true;
      this.__ctor = __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["b" /* Templatize */].templatize(template, this, {
        mutableData: this.mutableData,
        parentModel: true,
        instanceProps: instanceProps,
        /**
         * @this {this}
         * @param {string} prop Property to set
         * @param {*} value Value to set property to
         */
        forwardHostProp: function(prop, value) {
          let i$ = this.__instances;
          for (let i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {
            inst.forwardHostProp(prop, value);
          }
        },
        /**
         * @this {this}
         * @param {Object} inst Instance to notify
         * @param {string} prop Property to notify
         * @param {*} value Value to notify
         */
        notifyInstanceProp: function(inst, prop, value) {
          if (Object(__WEBPACK_IMPORTED_MODULE_5__utils_path_js__["e" /* matches */])(this.as, prop)) {
            let idx = inst[this.itemsIndexAs];
            if (prop == this.as) {
              this.items[idx] = value;
            }
            let path = Object(__WEBPACK_IMPORTED_MODULE_5__utils_path_js__["i" /* translate */])(this.as, 'items.' + idx, prop);
            this.notifyPath(path, value);
          }
        }
      });
    }
    return true;
  }

  __getMethodHost() {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    return this.__dataHost._methodHost || this.__dataHost;
  }

  __sortChanged(sort) {
    let methodHost = this.__getMethodHost();
    this.__sortFn = sort && (typeof sort == 'function' ? sort :
      function() { return methodHost[sort].apply(methodHost, arguments); });
    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }

  __filterChanged(filter) {
    let methodHost = this.__getMethodHost();
    this.__filterFn = filter && (typeof filter == 'function' ? filter :
      function() { return methodHost[filter].apply(methodHost, arguments); });
    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }

  __computeFrameTime(rate) {
    return Math.ceil(1000/rate);
  }

  __initializeChunking() {
    if (this.initialCount) {
      this.__limit = this.initialCount;
      this.__chunkCount = this.initialCount;
      this.__lastChunkTime = performance.now();
    }
  }

  __tryRenderChunk() {
    // Debounced so that multiple calls through `_render` between animation
    // frames only queue one new rAF (e.g. array mutation & chunked render)
    if (this.items && this.__limit < this.items.length) {
      this.__debounceRender(this.__requestRenderChunk);
    }
  }

  __requestRenderChunk() {
    requestAnimationFrame(()=>this.__renderChunk());
  }

  __renderChunk() {
    // Simple auto chunkSize throttling algorithm based on feedback loop:
    // measure actual time between frames and scale chunk count by ratio
    // of target/actual frame time
    let currChunkTime = performance.now();
    let ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
    this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
    this.__limit += this.__chunkCount;
    this.__lastChunkTime = currChunkTime;
    this.__debounceRender(this.__render);
  }

  __observeChanged() {
    this.__observePaths = this.observe &&
      this.observe.replace('.*', '.').split(' ');
  }

  __itemsChanged(change) {
    if (this.items && !Array.isArray(this.items)) {
      console.warn('dom-repeat expected array for `items`, found', this.items);
    }
    // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
    // path to that instance synchronously (retuns false for non-item paths)
    if (!this.__handleItemPath(change.path, change.value)) {
      // Otherwise, the array was reset ('items') or spliced ('items.splices'),
      // so queue a full refresh
      this.__initializeChunking();
      this.__debounceRender(this.__render);
    }
  }

  __handleObservedPaths(path) {
    if (this.__observePaths) {
      path = path.substring(path.indexOf('.') + 1);
      let paths = this.__observePaths;
      for (let i=0; i<paths.length; i++) {
        if (path.indexOf(paths[i]) === 0) {
          this.__debounceRender(this.__render, this.delay);
          return true;
        }
      }
    }
  }

  /**
   * @param {function(this:DomRepeat)} fn Function to debounce.
   * @param {number=} delay Delay in ms to debounce by.
   */
  __debounceRender(fn, delay = 0) {
    this.__renderDebouncer = __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__["a" /* Debouncer */].debounce(
          this.__renderDebouncer
        , delay > 0 ? __WEBPACK_IMPORTED_MODULE_6__utils_async_js__["b" /* timeOut */].after(delay) : __WEBPACK_IMPORTED_MODULE_6__utils_async_js__["a" /* microTask */]
        , fn.bind(this));
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["a" /* enqueueDebouncer */])(this.__renderDebouncer);
  }

  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   */
  render() {
    // Queue this repeater, then flush all in order
    this.__debounceRender(this.__render);
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["b" /* flush */])();
  }

  __render() {
    if (!this.__ensureTemplatized()) {
      // No template found yet
      return;
    }
    this.__applyFullRefresh();
    // Reset the pool
    // TODO(kschaaf): Reuse pool across turns and nested templates
    // Now that objects/arrays are re-evaluated when set, we can safely
    // reuse pooled instances across turns, however we still need to decide
    // semantics regarding how long to hold, how many to hold, etc.
    this.__pool.length = 0;
    // Set rendered item count
    this._setRenderedItemCount(this.__instances.length);
    // Notify users
    this.dispatchEvent(new CustomEvent('dom-change', {
      bubbles: true,
      composed: true
    }));
    // Check to see if we need to render more items
    this.__tryRenderChunk();
  }

  __applyFullRefresh() {
    let items = this.items || [];
    let isntIdxToItemsIdx = new Array(items.length);
    for (let i=0; i<items.length; i++) {
      isntIdxToItemsIdx[i] = i;
    }
    // Apply user filter
    if (this.__filterFn) {
      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) =>
        this.__filterFn(items[i], idx, array));
    }
    // Apply user sort
    if (this.__sortFn) {
      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));
    }
    // items->inst map kept for item path forwarding
    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
    let instIdx = 0;
    // Generate instances and assign items
    const limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
    for (; instIdx<limit; instIdx++) {
      let inst = this.__instances[instIdx];
      let itemIdx = isntIdxToItemsIdx[instIdx];
      let item = items[itemIdx];
      itemsIdxToInstIdx[itemIdx] = instIdx;
      if (inst && instIdx < this.__limit) {
        inst._setPendingProperty(this.as, item);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        this.__insertInstance(item, instIdx, itemIdx);
      }
    }
    // Remove any extra instances from previous state
    for (let i=this.__instances.length-1; i>=instIdx; i--) {
      this.__detachAndRemoveInstance(i);
    }
  }

  __detachInstance(idx) {
    let inst = this.__instances[idx];
    for (let i=0; i<inst.children.length; i++) {
      let el = inst.children[i];
      inst.root.appendChild(el);
    }
    return inst;
  }

  __attachInstance(idx, parent) {
    let inst = this.__instances[idx];
    parent.insertBefore(inst.root, this);
  }

  __detachAndRemoveInstance(idx) {
    let inst = this.__detachInstance(idx);
    if (inst) {
      this.__pool.push(inst);
    }
    this.__instances.splice(idx, 1);
  }

  __stampInstance(item, instIdx, itemIdx) {
    let model = {};
    model[this.as] = item;
    model[this.indexAs] = instIdx;
    model[this.itemsIndexAs] = itemIdx;
    return new this.__ctor(model);
  }

  __insertInstance(item, instIdx, itemIdx) {
    let inst = this.__pool.pop();
    if (inst) {
      // TODO(kschaaf): If the pool is shared across turns, hostProps
      // need to be re-set to reused instances in addition to item
      inst._setPendingProperty(this.as, item);
      inst._setPendingProperty(this.indexAs, instIdx);
      inst._setPendingProperty(this.itemsIndexAs, itemIdx);
      inst._flushProperties();
    } else {
      inst = this.__stampInstance(item, instIdx, itemIdx);
    }
    let beforeRow = this.__instances[instIdx + 1];
    let beforeNode = beforeRow ? beforeRow.children[0] : this;
    this.parentNode.insertBefore(inst.root, beforeNode);
    this.__instances[instIdx] = inst;
    return inst;
  }

  // Implements extension point from Templatize mixin
  _showHideChildren(hidden) {
    for (let i=0; i<this.__instances.length; i++) {
      this.__instances[i]._showHideChildren(hidden);
    }
  }

  // Called as a side effect of a host items.<key>.<path> path change,
  // responsible for notifying item.<path> changes to inst for key
  __handleItemPath(path, value) {
    let itemsPath = path.slice(6); // 'items.'.length == 6
    let dot = itemsPath.indexOf('.');
    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
    // If path was index into array...
    if (itemsIdx == parseInt(itemsIdx, 10)) {
      let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot+1);
      // If the path is observed, it will trigger a full refresh
      this.__handleObservedPaths(itemSubPath);
      // Note, even if a rull refresh is triggered, always do the path
      // notification because unless mutableData is used for dom-repeat
      // and all elements in the instance subtree, a full refresh may
      // not trigger the proper update.
      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
      let inst = this.__instances[instIdx];
      if (inst) {
        let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
        // This is effectively `notifyPath`, but avoids some of the overhead
        // of the public API
        inst._setPendingPropertyOrPath(itemPath, value, false, true);
        inst._flushProperties();
      }
      return true;
    }
  }

  /**
   * Returns the item associated with a given element stamped by
   * this `dom-repeat`.
   *
   * Note, to modify sub-properties of the item,
   * `modelForElement(el).set('item.<sub-prop>', value)`
   * should be used.
   *
   * @param {HTMLElement} el Element for which to return the item.
   * @return {*} Item associated with the element.
   */
  itemForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.as];
  }

  /**
   * Returns the inst index for a given element stamped by this `dom-repeat`.
   * If `sort` is provided, the index will reflect the sorted order (rather
   * than the original array order).
   *
   * @param {HTMLElement} el Element for which to return the index.
   * @return {*} Row index associated with the element (note this may
   *   not correspond to the array index if a user `sort` is applied).
   */
  indexForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.indexAs];
  }

  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model is an instance of `Polymer.Base`, and
   * should be used to manipulate data associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @param {HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   */
  modelForElement(el) {
    return __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["b" /* Templatize */].modelForElement(this.template, el);
  }

}

customElements.define(DomRepeat.is, DomRepeat);




/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomIf */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_async_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_path_js__ = __webpack_require__(12);







/**
 * The `<dom-if>` element will stamp a light-dom `<template>` child when
 * the `if` property becomes truthy, and the template can use Polymer
 * data-binding and declarative event features when used in the context of
 * a Polymer element's template.
 *
 * When `if` becomes falsey, the stamped content is hidden but not
 * removed from dom. When `if` subsequently becomes truthy again, the content
 * is simply re-shown. This approach is used due to its favorable performance
 * characteristics: the expense of creating template content is paid only
 * once and lazily.
 *
 * Set the `restamp` property to true to force the stamped content to be
 * created / destroyed when the `if` condition changes.
 *
 * @customElement
 * @polymer
 * @extends Polymer.Element
 * @memberof Polymer
 * @summary Custom element that conditionally stamps and hides or removes
 *   template content based on a boolean flag.
 */
class DomIf extends __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__["a" /* Element */] {

  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'dom-if'; }

  static get template() { return null; }

  static get properties() {

    return {

      /**
       * Fired whenever DOM is added or removed/hidden by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */

      /**
       * A boolean indicating whether this template should stamp.
       */
      if: {
        type: Boolean,
        observer: '__debounceRender'
      },

      /**
       * When true, elements will be removed from DOM and discarded when `if`
       * becomes false and re-created and added back to the DOM when `if`
       * becomes true.  By default, stamped elements will be hidden but left
       * in the DOM when `if` becomes false, which is generally results
       * in better performance.
       */
      restamp: {
        type: Boolean,
        observer: '__debounceRender'
      }

    };

  }

  constructor() {
    super();
    this.__renderDebouncer = null;
    this.__invalidProps = null;
    this.__instance = null;
    this._lastIf = false;
    this.__ctor = null;
  }

  __debounceRender() {
    // Render is async for 2 reasons:
    // 1. To eliminate dom creation trashing if user code thrashes `if` in the
    //    same turn. This was more common in 1.x where a compound computed
    //    property could result in the result changing multiple times, but is
    //    mitigated to a large extent by batched property processing in 2.x.
    // 2. To avoid double object propagation when a bag including values bound
    //    to the `if` property as well as one or more hostProps could enqueue
    //    the <dom-if> to flush before the <template>'s host property
    //    forwarding. In that scenario creating an instance would result in
    //    the host props being set once, and then the enqueued changes on the
    //    template would set properties a second time, potentially causing an
    //    object to be set to an instance more than once.  Creating the
    //    instance async from flushing data ensures this doesn't happen. If
    //    we wanted a sync option in the future, simply having <dom-if> flush
    //    (or clear) its template's pending host properties before creating
    //    the instance would also avoid the problem.
    this.__renderDebouncer = __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__["a" /* Debouncer */].debounce(
          this.__renderDebouncer
        , __WEBPACK_IMPORTED_MODULE_4__utils_async_js__["a" /* microTask */]
        , () => this.__render());
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["a" /* enqueueDebouncer */])(this.__renderDebouncer);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    if (!this.parentNode ||
        (this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&
         !this.parentNode.host)) {
      this.__teardownInstance();
    }
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.if) {
      this.__debounceRender();
    }
  }

  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   */
  render() {
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["b" /* flush */])();
  }

  __render() {
    if (this.if) {
      if (!this.__ensureInstance()) {
        // No template found yet
        return;
      }
      this._showHideChildren();
    } else if (this.restamp) {
      this.__teardownInstance();
    }
    if (!this.restamp && this.__instance) {
      this._showHideChildren();
    }
    if (this.if != this._lastIf) {
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
      this._lastIf = this.if;
    }
  }

  __ensureInstance() {
    let parentNode = this.parentNode;
    // Guard against element being detached while render was queued
    if (parentNode) {
      if (!this.__ctor) {
        let template = this.querySelector('template');
        if (!template) {
          // Wait until childList changes and template should be there by then
          let observer = new MutationObserver(() => {
            if (this.querySelector('template')) {
              observer.disconnect();
              this.__render();
            } else {
              throw new Error('dom-if requires a <template> child');
            }
          });
          observer.observe(this, {childList: true});
          return false;
        }
        this.__ctor = __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["b" /* Templatize */].templatize(template, this, {
          // dom-if templatizer instances require `mutable: true`, as
          // `__syncHostProperties` relies on that behavior to sync objects
          mutableData: true,
          /**
           * @param {string} prop Property to forward
           * @param {*} value Value of property
           * @this {this}
           */
          forwardHostProp: function(prop, value) {
            if (this.__instance) {
              if (this.if) {
                this.__instance.forwardHostProp(prop, value);
              } else {
                // If we have an instance but are squelching host property
                // forwarding due to if being false, note the invalidated
                // properties so `__syncHostProperties` can sync them the next
                // time `if` becomes true
                this.__invalidProps = this.__invalidProps || Object.create(null);
                this.__invalidProps[Object(__WEBPACK_IMPORTED_MODULE_5__utils_path_js__["g" /* root */])(prop)] = true;
              }
            }
          }
        });
      }
      if (!this.__instance) {
        this.__instance = new this.__ctor();
        parentNode.insertBefore(this.__instance.root, this);
      } else {
        this.__syncHostProperties();
        let c$ = this.__instance.children;
        if (c$ && c$.length) {
          // Detect case where dom-if was re-attached in new position
          let lastChild = this.previousSibling;
          if (lastChild !== c$[c$.length-1]) {
            for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
              parentNode.insertBefore(n, this);
            }
          }
        }
      }
    }
    return true;
  }

  __syncHostProperties() {
    let props = this.__invalidProps;
    if (props) {
      for (let prop in props) {
        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
      }
      this.__invalidProps = null;
      this.__instance._flushProperties();
    }
  }

  __teardownInstance() {
    if (this.__instance) {
      let c$ = this.__instance.children;
      if (c$ && c$.length) {
        // use first child parent, for case when dom-if may have been detached
        let parent = c$[0].parentNode;
        for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
          parent.removeChild(n);
        }
      }
      this.__instance = null;
      this.__invalidProps = null;
    }
  }

  _showHideChildren() {
    let hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance) {
      this.__instance._showHideChildren(hidden);
    }
  }

}

customElements.define(DomIf.is, DomIf);




/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ArraySelectorMixin */
/* unused harmony export ArraySelector */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_array_splice_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mixins_element_mixin_js__ = __webpack_require__(24);





/**
 * Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array such that path changes to the
 * master array (at the host) element or elsewhere via data-binding) are
 * correctly propagated to items in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * @polymer
 * @mixinFunction
 * @appliesMixin Polymer.ElementMixin
 * @memberof Polymer
 * @summary Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array
 */
let ArraySelectorMixin = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_ElementMixin}
   */
  let elementBase = Object(__WEBPACK_IMPORTED_MODULE_3__mixins_element_mixin_js__["a" /* ElementMixin */])(superClass);

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_ArraySelectorMixin}
   * @unrestricted
   */
  class ArraySelectorMixin extends elementBase {

    static get properties() {

      return {

        /**
         * An array containing items from which selection will be made.
         */
        items: {
          type: Array,
        },

        /**
         * When `true`, multiple items may be selected at once (in this case,
         * `selected` is an array of currently selected items).  When `false`,
         * only one item may be selected at a time.
         */
        multi: {
          type: Boolean,
          value: false,
        },

        /**
         * When `multi` is true, this is an array that contains any selected.
         * When `multi` is false, this is the currently selected item, or `null`
         * if no item is selected.
         * @type {?(Object|Array<!Object>)}
         */
        selected: {
          type: Object,
          notify: true
        },

        /**
         * When `multi` is false, this is the currently selected item, or `null`
         * if no item is selected.
         * @type {?Object}
         */
        selectedItem: {
          type: Object,
          notify: true
        },

        /**
         * When `true`, calling `select` on an item that is already selected
         * will deselect the item.
         */
        toggle: {
          type: Boolean,
          value: false
        }

      };
    }

    static get observers() {
      return ['__updateSelection(multi, items.*)'];
    }

    constructor() {
      super();
      this.__lastItems = null;
      this.__lastMulti = null;
      this.__selectedMap = null;
    }

    __updateSelection(multi, itemsInfo) {
      let path = itemsInfo.path;
      if (path == 'items') {
        // Case 1 - items array changed, so diff against previous array and
        // deselect any removed items and adjust selected indices
        let newItems = itemsInfo.base || [];
        let lastItems = this.__lastItems;
        let lastMulti = this.__lastMulti;
        if (multi !== lastMulti) {
          this.clearSelection();
        }
        if (lastItems) {
          let splices = Object(__WEBPACK_IMPORTED_MODULE_2__utils_array_splice_js__["a" /* calculateSplices */])(newItems, lastItems);
          this.__applySplices(splices);
        }
        this.__lastItems = newItems;
        this.__lastMulti = multi;
      } else if (itemsInfo.path == 'items.splices') {
        // Case 2 - got specific splice information describing the array mutation:
        // deselect any removed items and adjust selected indices
        this.__applySplices(itemsInfo.value.indexSplices);
      } else {
        // Case 3 - an array element was changed, so deselect the previous
        // item for that index if it was previously selected
        let part = path.slice('items.'.length);
        let idx = parseInt(part, 10);
        if ((part.indexOf('.') < 0) && part == idx) {
          this.__deselectChangedIdx(idx);
        }
      }
    }

    __applySplices(splices) {
      let selected = this.__selectedMap;
      // Adjust selected indices and mark removals
      for (let i=0; i<splices.length; i++) {
        let s = splices[i];
        selected.forEach((idx, item) => {
          if (idx < s.index) {
            // no change
          } else if (idx >= s.index + s.removed.length) {
            // adjust index
            selected.set(item, idx + s.addedCount - s.removed.length);
          } else {
            // remove index
            selected.set(item, -1);
          }
        });
        for (let j=0; j<s.addedCount; j++) {
          let idx = s.index + j;
          if (selected.has(this.items[idx])) {
            selected.set(this.items[idx], idx);
          }
        }
      }
      // Update linked paths
      this.__updateLinks();
      // Remove selected items that were removed from the items array
      let sidx = 0;
      selected.forEach((idx, item) => {
        if (idx < 0) {
          if (this.multi) {
            this.splice('selected', sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
          selected.delete(item);
        } else {
          sidx++;
        }
      });
    }

    __updateLinks() {
      this.__dataLinkedPaths = {};
      if (this.multi) {
        let sidx = 0;
        this.__selectedMap.forEach(idx => {
          if (idx >= 0) {
            this.linkPaths('items.' + idx, 'selected.' + sidx++);
          }
        });
      } else {
        this.__selectedMap.forEach(idx => {
          this.linkPaths('selected', 'items.' + idx);
          this.linkPaths('selectedItem', 'items.' + idx);
        });
      }
    }

    /**
     * Clears the selection state.
     *
     */
    clearSelection() {
      // Unbind previous selection
      this.__dataLinkedPaths = {};
      // The selected map stores 3 pieces of information:
      // key: items array object
      // value: items array index
      // order: selected array index
      this.__selectedMap = new Map();
      // Initialize selection
      this.selected = this.multi ? [] : null;
      this.selectedItem = null;
    }

    /**
     * Returns whether the item is currently selected.
     *
     * @param {*} item Item from `items` array to test
     * @return {boolean} Whether the item is selected
     */
    isSelected(item) {
      return this.__selectedMap.has(item);
    }

    /**
     * Returns whether the item is currently selected.
     *
     * @param {number} idx Index from `items` array to test
     * @return {boolean} Whether the item is selected
     */
    isIndexSelected(idx) {
      return this.isSelected(this.items[idx]);
    }

    __deselectChangedIdx(idx) {
      let sidx = this.__selectedIndexForItemIndex(idx);
      if (sidx >= 0) {
        let i = 0;
        this.__selectedMap.forEach((idx, item) => {
          if (sidx == i++) {
            this.deselect(item);
          }
        });
      }
    }

    __selectedIndexForItemIndex(idx) {
      let selected = this.__dataLinkedPaths['items.' + idx];
      if (selected) {
        return parseInt(selected.slice('selected.'.length), 10);
      }
    }

    /**
     * Deselects the given item if it is already selected.
     *
     * @param {*} item Item from `items` array to deselect
     */
    deselect(item) {
      let idx = this.__selectedMap.get(item);
      if (idx >= 0) {
        this.__selectedMap.delete(item);
        let sidx;
        if (this.multi) {
          sidx = this.__selectedIndexForItemIndex(idx);
        }
        this.__updateLinks();
        if (this.multi) {
          this.splice('selected', sidx, 1);
        } else {
          this.selected = this.selectedItem = null;
        }
      }
    }

    /**
     * Deselects the given index if it is already selected.
     *
     * @param {number} idx Index from `items` array to deselect
     */
    deselectIndex(idx) {
      this.deselect(this.items[idx]);
    }

    /**
     * Selects the given item.  When `toggle` is true, this will automatically
     * deselect the item if already selected.
     *
     * @param {*} item Item from `items` array to select
     */
    select(item) {
      this.selectIndex(this.items.indexOf(item));
    }

    /**
     * Selects the given index.  When `toggle` is true, this will automatically
     * deselect the item if already selected.
     *
     * @param {number} idx Index from `items` array to select
     */
    selectIndex(idx) {
      let item = this.items[idx];
      if (!this.isSelected(item)) {
        if (!this.multi) {
          this.__selectedMap.clear();
        }
        this.__selectedMap.set(item, idx);
        this.__updateLinks();
        if (this.multi) {
          this.push('selected', item);
        } else {
          this.selected = this.selectedItem = item;
        }
      } else if (this.toggle) {
        this.deselectIndex(idx);
      }
    }

  }

  return ArraySelectorMixin;

});



/**
 * @constructor
 * @extends {Polymer.Element}
 * @implements {Polymer_ArraySelectorMixin}
 */
let baseArraySelector = ArraySelectorMixin(__WEBPACK_IMPORTED_MODULE_0__polymer_element_js__["a" /* Element */]);

/**
 * Element implementing the `Polymer.ArraySelector` mixin, which records
 * dynamic associations between item paths in a master `items` array and a
 * `selected` array such that path changes to the master array (at the host)
 * element or elsewhere via data-binding) are correctly propagated to items
 * in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *         <button on-click="toggleSelection">Select</button>
 *     </template>
 *
 *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
 *
 *     <div> Selected employees: </div>
 *     <template is="dom-repeat" items="{{selected}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 * </dom-module>
 * ```
 *
 * ```js
 * Polymer({
 *   is: 'employee-list',
 *   ready() {
 *     this.employees = [
 *         {first: 'Bob', last: 'Smith'},
 *         {first: 'Sally', last: 'Johnson'},
 *         ...
 *     ];
 *   },
 *   toggleSelection(e) {
 *     let item = this.$.employeeList.itemForElement(e.target);
 *     this.$.selector.select(item);
 *   }
 * });
 * ```
 *
 * @polymer
 * @customElement
 * @extends {baseArraySelector}
 * @appliesMixin Polymer.ArraySelectorMixin
 * @memberof Polymer
 * @summary Custom element that links paths between an input `items` array and
 *   an output `selected` item or array based on calls to its selection API.
 */
class ArraySelector extends baseArraySelector {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'array-selector'; }
}
customElements.define(ArraySelector.is, ArraySelector);



/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CustomStyle */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_shadycss_entrypoints_custom_style_interface_js__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_style_gather_js__ = __webpack_require__(41);



const attr = 'include';

const CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

/**
 * Custom element for defining styles in the main document that can take
 * advantage of [shady DOM](https://github.com/webcomponents/shadycss) shims
 * for style encapsulation, custom properties, and custom mixins.
 *
 * - Document styles defined in a `<custom-style>` are shimmed to ensure they
 *   do not leak into local DOM when running on browsers without native
 *   Shadow DOM.
 * - Custom properties can be defined in a `<custom-style>`. Use the `html` selector
 *   to define custom properties that apply to all custom elements.
 * - Custom mixins can be defined in a `<custom-style>`, if you import the optional
 *   [apply shim](https://github.com/webcomponents/shadycss#about-applyshim)
 *   (`shadycss/apply-shim.html`).
 *
 * To use:
 *
 * - Import `custom-style.html`.
 * - Place a `<custom-style>` element in the main document, wrapping an inline `<style>` tag that
 *   contains the CSS rules you want to shim.
 *
 * For example:
 *
 * ```
 * <!-- import apply shim--only required if using mixins -->
 * <link rel="import href="bower_components/shadycss/apply-shim.html">
 * <!-- import custom-style element -->
 * <link rel="import" href="bower_components/polymer/lib/elements/custom-style.html">
 * ...
 * <custom-style>
 *   <style>
 *     html {
 *       --custom-color: blue;
 *       --custom-mixin: {
 *         font-weight: bold;
 *         color: red;
 *       };
 *     }
 *   </style>
 * </custom-style>
 * ```
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element for defining styles in the main document that can
 *   take advantage of Polymer's style scoping and custom properties shims.
 */
class CustomStyle extends HTMLElement {
  constructor() {
    super();
    this._style = null;
    CustomStyleInterface.addCustomStyle(this);
  }
  /**
   * Returns the light-DOM `<style>` child this element wraps.  Upon first
   * call any style modules referenced via the `include` attribute will be
   * concatenated to this element's `<style>`.
   *
   * @return {HTMLStyleElement} This element's light-DOM `<style>`
   */
  getStyle() {
    if (this._style) {
      return this._style;
    }
    const style = /** @type {HTMLStyleElement} */(this.querySelector('style'));
    if (!style) {
      return null;
    }
    this._style = style;
    const include = style.getAttribute(attr);
    if (include) {
      style.removeAttribute(attr);
      style.textContent = Object(__WEBPACK_IMPORTED_MODULE_1__utils_style_gather_js__["b" /* cssFromModules */])(include) + style.textContent;
    }
    return this._style;
  }
}

window.customElements.define('custom-style', CustomStyle);



/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_custom_style_interface_js__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_style_settings_js__ = __webpack_require__(20);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/







const customStyleInterface = new __WEBPACK_IMPORTED_MODULE_0__src_custom_style_interface_js__["a" /* default */]();

if (!window.ShadyCSS) {
  window.ShadyCSS = {
    /**
     * @param {HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate(template, elementName, elementExtends) {}, // eslint-disable-line no-unused-vars

    /**
     * @param {Element} element
     * @param {Object=} properties
     */
    styleSubtree(element, properties) {
      customStyleInterface.processStyles();
      Object(__WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__["c" /* updateNativeProperties */])(element, properties);
    },

    /**
     * @param {Element} element
     */
    styleElement(element) { // eslint-disable-line no-unused-vars
      customStyleInterface.processStyles();
    },

    /**
     * @param {Object=} properties
     */
    styleDocument(properties) {
      customStyleInterface.processStyles();
      Object(__WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__["c" /* updateNativeProperties */])(document.body, properties);
    },

    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue(element, property) {
      return Object(__WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__["b" /* getComputedStyleValue */])(element, property);
    },
    nativeCss: __WEBPACK_IMPORTED_MODULE_2__src_style_settings_js__["a" /* nativeCssVariables */],
    nativeShadow: __WEBPACK_IMPORTED_MODULE_2__src_style_settings_js__["b" /* nativeShadow */]
  }
}

window.ShadyCSS.CustomStyleInterface = customStyleInterface;

/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixins_mutable_data_js__ = __webpack_require__(15);


let mutablePropertyChange;
(
  /** @suppress {missingProperties} */
  (function() {
  mutablePropertyChange = __WEBPACK_IMPORTED_MODULE_0__mixins_mutable_data_js__["a" /* MutableData */]._mutablePropertyChange;
}))();

const MutableDataBehavior = {

  /**
   * Overrides `Polymer.PropertyEffects` to provide option for skipping
   * strict equality checking for Objects and Arrays.
   *
   * This method pulls the value to dirty check against from the `__dataTemp`
   * cache (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @protected
   */
  _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, true);
  }
};
/* unused harmony export MutableDataBehavior */


const OptionalMutableDataBehavior = {

  properties: {
    /**
     * Instance-level flag for configuring the dirty-checking strategy
     * for this element.  When true, Objects and Arrays will skip dirty
     * checking, otherwise strict equality checking will be used.
     */
    mutableData: Boolean
  },

  /**
   * Overrides `Polymer.PropertyEffects` to skip strict equality checking
   * for Objects and Arrays.
   *
   * Pulls the value to dirty check against from the `__dataTemp` cache
   * (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @this {this}
   * @protected
   */
  _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, this.mutableData);
  }
};
/* unused harmony export OptionalMutableDataBehavior */



/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__neon_animation_neon_animation_runner_behavior_js__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_dialog_behavior_paper_dialog_behavior_js__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_dialog_behavior_paper_dialog_shared_styles_js__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);






Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style include="paper-dialog-shared-styles"></style>
    <slot></slot>
`,

  is: 'paper-dialog',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_dialog_behavior_paper_dialog_behavior_js__["a" /* PaperDialogBehavior */],
    __WEBPACK_IMPORTED_MODULE_1__neon_animation_neon_animation_runner_behavior_js__["a" /* NeonAnimationRunnerBehavior */]
  ],

  listeners: {
    'neon-animation-finish': '_onNeonAnimationFinish'
  },

  _renderOpened: function() {
    this.cancelAnimation();
    this.playAnimation('entry');
  },

  _renderClosed: function() {
    this.cancelAnimation();
    this.playAnimation('exit');
  },

  _onNeonAnimationFinish: function() {
    if (this.opened) {
      this._finishRenderOpened();
    } else {
      this._finishRenderClosed();
    }
  }
});


/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__neon_animatable_behavior_js__ = __webpack_require__(75);



const NeonAnimationRunnerBehaviorImpl = {

  _configureAnimations: function(configs) {
    var results = [];
    if (configs.length > 0) {
      for (var config, index = 0; config = configs[index]; index++) {
        var neonAnimation = document.createElement(config.name);
        // is this element actually a neon animation?
        if (neonAnimation.isNeonAnimation) {
          var result = null;
          // configuration or play could fail if polyfills aren't loaded
          try {
            result = neonAnimation.configure(config);
            // Check if we have an Effect rather than an Animation
            if (typeof result.cancel != 'function') {
              result = document.timeline.play(result);
            }
          } catch (e) {
            result = null;
            console.warn('Couldnt play', '(', config.name, ').', e);
          }
          if (result) {
            results.push({
              neonAnimation: neonAnimation,
              config: config,
              animation: result,
            });
          }
        } else {
          console.warn(this.is + ':', config.name, 'not found!');
        }
      }
    }
    return results;
  },

  _shouldComplete: function(activeEntries) {
    var finished = true;
    for (var i = 0; i < activeEntries.length; i++) {
      if (activeEntries[i].animation.playState != 'finished') {
        finished = false;
        break;
      }
    }
    return finished;
  },

  _complete: function(activeEntries) {
    for (var i = 0; i < activeEntries.length; i++) {
      activeEntries[i].neonAnimation.complete(activeEntries[i].config);
    }
    for (var i = 0; i < activeEntries.length; i++) {
      activeEntries[i].animation.cancel();
    }
  },

  /**
   * Plays an animation with an optional `type`.
   * @param {string=} type
   * @param {!Object=} cookie
   */
  playAnimation: function(type, cookie) {
    var configs = this.getAnimationConfig(type);
    if (!configs) {
      return;
    }
    this._active = this._active || {};
    if (this._active[type]) {
      this._complete(this._active[type]);
      delete this._active[type];
    }

    var activeEntries = this._configureAnimations(configs);

    if (activeEntries.length == 0) {
      this.fire('neon-animation-finish', cookie, {bubbles: false});
      return;
    }

    this._active[type] = activeEntries;

    for (var i = 0; i < activeEntries.length; i++) {
      activeEntries[i].animation.onfinish = function() {
        if (this._shouldComplete(activeEntries)) {
          this._complete(activeEntries);
          delete this._active[type];
          this.fire('neon-animation-finish', cookie, {bubbles: false});
        }
      }.bind(this);
    }
  },

  /**
   * Cancels the currently running animations.
   */
  cancelAnimation: function() {
    for (var k in this._animations) {
      this._animations[k].cancel();
    }
    this._animations = {};
  }
};
/* unused harmony export NeonAnimationRunnerBehaviorImpl */


const NeonAnimationRunnerBehavior = [
  __WEBPACK_IMPORTED_MODULE_1__neon_animatable_behavior_js__["a" /* NeonAnimatableBehavior */],
  NeonAnimationRunnerBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = NeonAnimationRunnerBehavior;



/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);


const NeonAnimatableBehavior = {

  properties: {

    /**
     * Animation configuration. See README for more info.
     */
    animationConfig: {
      type: Object
    },

    /**
     * Convenience property for setting an 'entry' animation. Do not set `animationConfig.entry`
     * manually if using this. The animated node is set to `this` if using this property.
     */
    entryAnimation: {
      observer: '_entryAnimationChanged',
      type: String
    },

    /**
     * Convenience property for setting an 'exit' animation. Do not set `animationConfig.exit`
     * manually if using this. The animated node is set to `this` if using this property.
     */
    exitAnimation: {
      observer: '_exitAnimationChanged',
      type: String
    }

  },

  _entryAnimationChanged: function() {
    this.animationConfig = this.animationConfig || {};
    this.animationConfig['entry'] = [{
      name: this.entryAnimation,
      node: this
    }];
  },

  _exitAnimationChanged: function() {
    this.animationConfig = this.animationConfig || {};
    this.animationConfig['exit'] = [{
      name: this.exitAnimation,
      node: this
    }];
  },

  _copyProperties: function(config1, config2) {
    // shallowly copy properties from config2 to config1
    for (var property in config2) {
      config1[property] = config2[property];
    }
  },

  _cloneConfig: function(config) {
    var clone = {
      isClone: true
    };
    this._copyProperties(clone, config);
    return clone;
  },

  _getAnimationConfigRecursive: function(type, map, allConfigs) {
    if (!this.animationConfig) {
      return;
    }

    if(this.animationConfig.value && typeof this.animationConfig.value === 'function') {
      this._warn(this._logf('playAnimation', "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
      return;
    }

    // type is optional
    var thisConfig;
    if (type) {
      thisConfig = this.animationConfig[type];
    } else {
      thisConfig = this.animationConfig;
    }

    if (!Array.isArray(thisConfig)) {
      thisConfig = [thisConfig];
    }

    // iterate animations and recurse to process configurations from child nodes
    if (thisConfig) {
      for (var config, index = 0; config = thisConfig[index]; index++) {
        if (config.animatable) {
          config.animatable._getAnimationConfigRecursive(config.type || type, map, allConfigs);
        } else {
          if (config.id) {
            var cachedConfig = map[config.id];
            if (cachedConfig) {
              // merge configurations with the same id, making a clone lazily
              if (!cachedConfig.isClone) {
                map[config.id] = this._cloneConfig(cachedConfig);
                cachedConfig = map[config.id];
              }
              this._copyProperties(cachedConfig, config);
            } else {
              // put any configs with an id into a map
              map[config.id] = config;
            }
          } else {
            allConfigs.push(config);
          }
        }
      }
    }
  },

  /**
   * An element implementing `Polymer.NeonAnimationRunnerBehavior` calls this method to configure
   * an animation with an optional type. Elements implementing `Polymer.NeonAnimatableBehavior`
   * should define the property `animationConfig`, which is either a configuration object
   * or a map of animation type to array of configuration objects.
   */
  getAnimationConfig: function(type) {
    var map = {};
    var allConfigs = [];
    this._getAnimationConfigRecursive(type, map, allConfigs);
    // append the configurations saved in the map to the array
    for (var key in map) {
      allConfigs.push(map[key]);
    }
    return allConfigs;
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = NeonAnimatableBehavior;



/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_overlay_behavior_iron_overlay_behavior_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




const PaperDialogBehaviorImpl = {

  hostAttributes: {
    'role': 'dialog',
    'tabindex': '-1'
  },

  properties: {

    /**
     * If `modal` is true, this implies `no-cancel-on-outside-click`, `no-cancel-on-esc-key` and `with-backdrop`.
     */
    modal: {
      type: Boolean,
      value: false
    },

    __readied: {
      type: Boolean,
      value: false
    }

  },

  observers: [
    '_modalChanged(modal, __readied)'
  ],

  listeners: {
    'tap': '_onDialogClick'
  },

  ready: function() {
    // Only now these properties can be read.
    this.__prevNoCancelOnOutsideClick = this.noCancelOnOutsideClick;
    this.__prevNoCancelOnEscKey = this.noCancelOnEscKey;
    this.__prevWithBackdrop = this.withBackdrop;
    this.__readied = true;
  },

  _modalChanged: function(modal, readied) {
    // modal implies noCancelOnOutsideClick, noCancelOnEscKey and withBackdrop.
    // We need to wait for the element to be ready before we can read the
    // properties values.
    if (!readied) {
      return;
    }

    if (modal) {
      this.__prevNoCancelOnOutsideClick = this.noCancelOnOutsideClick;
      this.__prevNoCancelOnEscKey = this.noCancelOnEscKey;
      this.__prevWithBackdrop = this.withBackdrop;
      this.noCancelOnOutsideClick = true;
      this.noCancelOnEscKey = true;
      this.withBackdrop = true;
    } else {
      // If the value was changed to false, let it false.
      this.noCancelOnOutsideClick = this.noCancelOnOutsideClick &&
        this.__prevNoCancelOnOutsideClick;
      this.noCancelOnEscKey = this.noCancelOnEscKey &&
        this.__prevNoCancelOnEscKey;
      this.withBackdrop = this.withBackdrop && this.__prevWithBackdrop;
    }
  },

  _updateClosingReasonConfirmed: function(confirmed) {
    this.closingReason = this.closingReason || {};
    this.closingReason.confirmed = confirmed;
  },

  /**
   * Will dismiss the dialog if user clicked on an element with dialog-dismiss
   * or dialog-confirm attribute.
   */
  _onDialogClick: function(event) {
    // Search for the element with dialog-confirm or dialog-dismiss,
    // from the root target until this (excluded).
    var path = Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).path;
    for (var i = 0, l = path.indexOf(this); i < l; i++) {
      var target = path[i];
      if (target.hasAttribute && (target.hasAttribute('dialog-dismiss') || target.hasAttribute('dialog-confirm'))) {
        this._updateClosingReasonConfirmed(target.hasAttribute('dialog-confirm'));
        this.close();
        event.stopPropagation();
        break;
      }
    }
  }

};
/* unused harmony export PaperDialogBehaviorImpl */


const PaperDialogBehavior = [__WEBPACK_IMPORTED_MODULE_1__iron_overlay_behavior_iron_overlay_behavior_js__["a" /* IronOverlayBehavior */], PaperDialogBehaviorImpl];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperDialogBehavior;



/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_fit_behavior_iron_fit_behavior_js__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_resizable_behavior_iron_resizable_behavior_js__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__iron_overlay_manager_js__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__iron_focusables_helper_js__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);







const IronOverlayBehaviorImpl = {

  properties: {

    /**
     * True if the overlay is currently displayed.
     */
    opened: {
      observer: '_openedChanged',
      type: Boolean,
      value: false,
      notify: true
    },

    /**
     * True if the overlay was canceled when it was last closed.
     */
    canceled: {
      observer: '_canceledChanged',
      readOnly: true,
      type: Boolean,
      value: false
    },

    /**
     * Set to true to display a backdrop behind the overlay. It traps the focus
     * within the light DOM of the overlay.
     */
    withBackdrop: {
      observer: '_withBackdropChanged',
      type: Boolean
    },

    /**
     * Set to true to disable auto-focusing the overlay or child nodes with
     * the `autofocus` attribute` when the overlay is opened.
     */
    noAutoFocus: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to disable canceling the overlay with the ESC key.
     */
    noCancelOnEscKey: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to disable canceling the overlay by clicking outside it.
     */
    noCancelOnOutsideClick: {
      type: Boolean,
      value: false
    },

    /**
     * Contains the reason(s) this overlay was last closed (see `iron-overlay-closed`).
     * `IronOverlayBehavior` provides the `canceled` reason; implementers of the
     * behavior can provide other reasons in addition to `canceled`.
     */
    closingReason: {
      // was a getter before, but needs to be a property so other
      // behaviors can override this.
      type: Object
    },

    /**
     * Set to true to enable restoring of focus when overlay is closed.
     */
    restoreFocusOnClose: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to keep overlay always on top.
     */
    alwaysOnTop: {
      type: Boolean
    },

    /**
     * Shortcut to access to the overlay manager.
     * @private
     * @type {Polymer.IronOverlayManagerClass}
     */
    _manager: {
      type: Object,
      value: __WEBPACK_IMPORTED_MODULE_3__iron_overlay_manager_js__["a" /* IronOverlayManager */]
    },

    /**
     * The node being focused.
     * @type {?Node}
     */
    _focusedChild: {
      type: Object
    }

  },

  listeners: {
    'iron-resize': '_onIronResize'
  },

  /**
   * The backdrop element.
   * @type {Element}
   */
  get backdropElement() {
    return this._manager.backdropElement;
  },

  /**
   * Returns the node to give focus to.
   * @type {Node}
   */
  get _focusNode() {
    return this._focusedChild || Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).querySelector('[autofocus]') || this;
  },

  /**
   * Array of nodes that can receive focus (overlay included), ordered by `tabindex`.
   * This is used to retrieve which is the first and last focusable nodes in order
   * to wrap the focus for overlays `with-backdrop`.
   *
   * If you know what is your content (specifically the first and last focusable children),
   * you can override this method to return only `[firstFocusable, lastFocusable];`
   * @type {Array<Node>}
   * @protected
   */
  get _focusableNodes() {
    return __WEBPACK_IMPORTED_MODULE_4__iron_focusables_helper_js__["a" /* IronFocusablesHelper */].getTabbableNodes(this);
  },

  ready: function() {
    // Used to skip calls to notifyResize and refit while the overlay is animating.
    this.__isAnimating = false;
    // with-backdrop needs tabindex to be set in order to trap the focus.
    // If it is not set, IronOverlayBehavior will set it, and remove it if with-backdrop = false.
    this.__shouldRemoveTabIndex = false;
    // Used for wrapping the focus on TAB / Shift+TAB.
    this.__firstFocusableNode = this.__lastFocusableNode = null;
    // Used by __onNextAnimationFrame to cancel any previous callback.
    this.__raf = null;
    // Focused node before overlay gets opened. Can be restored on close.
    this.__restoreFocusNode = null;
    this._ensureSetup();
  },

  attached: function() {
    // Call _openedChanged here so that position can be computed correctly.
    if (this.opened) {
      this._openedChanged(this.opened);
    }
    this._observer = Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).observeNodes(this._onNodesChange);
  },

  detached: function() {
    Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).unobserveNodes(this._observer);
    this._observer = null;
    if (this.__raf) {
      window.cancelAnimationFrame(this.__raf);
      this.__raf = null;
    }
    this._manager.removeOverlay(this);
  },

  /**
   * Toggle the opened state of the overlay.
   */
  toggle: function() {
    this._setCanceled(false);
    this.opened = !this.opened;
  },

  /**
   * Open the overlay.
   */
  open: function() {
    this._setCanceled(false);
    this.opened = true;
  },

  /**
   * Close the overlay.
   */
  close: function() {
    this._setCanceled(false);
    this.opened = false;
  },

  /**
   * Cancels the overlay.
   * @param {Event=} event The original event
   */
  cancel: function(event) {
    var cancelEvent = this.fire('iron-overlay-canceled', event, {cancelable: true});
    if (cancelEvent.defaultPrevented) {
      return;
    }

    this._setCanceled(true);
    this.opened = false;
  },

  /**
   * Invalidates the cached tabbable nodes. To be called when any of the focusable
   * content changes (e.g. a button is disabled).
   */
  invalidateTabbables: function() {
    this.__firstFocusableNode = this.__lastFocusableNode = null;
  },

  _ensureSetup: function() {
    if (this._overlaySetup) {
      return;
    }
    this._overlaySetup = true;
    this.style.outline = 'none';
    this.style.display = 'none';
  },

  /**
   * Called when `opened` changes.
   * @param {boolean=} opened
   * @protected
   */
  _openedChanged: function(opened) {
    if (opened) {
      this.removeAttribute('aria-hidden');
    } else {
      this.setAttribute('aria-hidden', 'true');
    }

    // Defer any animation-related code on attached
    // (_openedChanged gets called again on attached).
    if (!this.isAttached) {
      return;
    }

    this.__isAnimating = true;

    // Use requestAnimationFrame for non-blocking rendering.
    this.__onNextAnimationFrame(this.__openedChanged);
  },

  _canceledChanged: function() {
    this.closingReason = this.closingReason || {};
    this.closingReason.canceled = this.canceled;
  },

  _withBackdropChanged: function() {
    // If tabindex is already set, no need to override it.
    if (this.withBackdrop && !this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '-1');
      this.__shouldRemoveTabIndex = true;
    } else if (this.__shouldRemoveTabIndex) {
      this.removeAttribute('tabindex');
      this.__shouldRemoveTabIndex = false;
    }
    if (this.opened && this.isAttached) {
      this._manager.trackBackdrop();
    }
  },

  /**
   * tasks which must occur before opening; e.g. making the element visible.
   * @protected
   */
  _prepareRenderOpened: function() {
    // Store focused node.
    this.__restoreFocusNode = this._manager.deepActiveElement;

    // Needed to calculate the size of the overlay so that transitions on its size
    // will have the correct starting points.
    this._preparePositioning();
    this.refit();
    this._finishPositioning();

    // Safari will apply the focus to the autofocus element when displayed
    // for the first time, so we make sure to return the focus where it was.
    if (this.noAutoFocus && document.activeElement === this._focusNode) {
      this._focusNode.blur();
      this.__restoreFocusNode.focus();
    }
  },

  /**
   * Tasks which cause the overlay to actually open; typically play an animation.
   * @protected
   */
  _renderOpened: function() {
    this._finishRenderOpened();
  },

  /**
   * Tasks which cause the overlay to actually close; typically play an animation.
   * @protected
   */
  _renderClosed: function() {
    this._finishRenderClosed();
  },

  /**
   * Tasks to be performed at the end of open action. Will fire `iron-overlay-opened`.
   * @protected
   */
  _finishRenderOpened: function() {
    this.notifyResize();
    this.__isAnimating = false;

    this.fire('iron-overlay-opened');
  },

  /**
   * Tasks to be performed at the end of close action. Will fire `iron-overlay-closed`.
   * @protected
   */
  _finishRenderClosed: function() {
    // Hide the overlay.
    this.style.display = 'none';
    // Reset z-index only at the end of the animation.
    this.style.zIndex = '';
    this.notifyResize();
    this.__isAnimating = false;
    this.fire('iron-overlay-closed', this.closingReason);
  },

  _preparePositioning: function() {
    this.style.transition = this.style.webkitTransition = 'none';
    this.style.transform = this.style.webkitTransform = 'none';
    this.style.display = '';
  },

  _finishPositioning: function() {
    // First, make it invisible & reactivate animations.
    this.style.display = 'none';
    // Force reflow before re-enabling animations so that they don't start.
    // Set scrollTop to itself so that Closure Compiler doesn't remove this.
    this.scrollTop = this.scrollTop;
    this.style.transition = this.style.webkitTransition = '';
    this.style.transform = this.style.webkitTransform = '';
    // Now that animations are enabled, make it visible again
    this.style.display = '';
    // Force reflow, so that following animations are properly started.
    // Set scrollTop to itself so that Closure Compiler doesn't remove this.
    this.scrollTop = this.scrollTop;
  },

  /**
   * Applies focus according to the opened state.
   * @protected
   */
  _applyFocus: function() {
    if (this.opened) {
      if (!this.noAutoFocus) {
        this._focusNode.focus();
      }
    }
    else {
      this._focusNode.blur();
      this._focusedChild = null;
      // Restore focus.
      if (this.restoreFocusOnClose && this.__restoreFocusNode) {
        this.__restoreFocusNode.focus();
      }
      this.__restoreFocusNode = null;
      // If many overlays get closed at the same time, one of them would still
      // be the currentOverlay even if already closed, and would call _applyFocus
      // infinitely, so we check for this not to be the current overlay.
      var currentOverlay = this._manager.currentOverlay();
      if (currentOverlay && this !== currentOverlay) {
        currentOverlay._applyFocus();
      }
    }
  },

  /**
   * Cancels (closes) the overlay. Call when click happens outside the overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureClick: function(event) {
    if (!this.noCancelOnOutsideClick) {
      this.cancel(event);
    }
  },

  /**
   * Keeps track of the focused child. If withBackdrop, traps focus within overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureFocus: function (event) {
    if (!this.withBackdrop) {
      return;
    }
    var path = Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).path;
    if (path.indexOf(this) === -1) {
      event.stopPropagation();
      this._applyFocus();
    } else {
      this._focusedChild = path[0];
    }
  },

  /**
   * Handles the ESC key event and cancels (closes) the overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureEsc: function(event) {
    if (!this.noCancelOnEscKey) {
      this.cancel(event);
    }
  },

  /**
   * Handles TAB key events to track focus changes.
   * Will wrap focus for overlays withBackdrop.
   * @param {!Event} event
   * @protected
   */
  _onCaptureTab: function(event) {
    if (!this.withBackdrop) {
      return;
    }
    this.__ensureFirstLastFocusables();
    // TAB wraps from last to first focusable.
    // Shift + TAB wraps from first to last focusable.
    var shift = event.shiftKey;
    var nodeToCheck = shift ? this.__firstFocusableNode : this.__lastFocusableNode;
    var nodeToSet = shift ? this.__lastFocusableNode : this.__firstFocusableNode;
    var shouldWrap = false;
    if (nodeToCheck === nodeToSet) {
      // If nodeToCheck is the same as nodeToSet, it means we have an overlay
      // with 0 or 1 focusables; in either case we still need to trap the
      // focus within the overlay.
      shouldWrap = true;
    } else {
      // In dom=shadow, the manager will receive focus changes on the main
      // root but not the ones within other shadow roots, so we can't rely on
      // _focusedChild, but we should check the deepest active element.
      var focusedNode = this._manager.deepActiveElement;
      // If the active element is not the nodeToCheck but the overlay itself,
      // it means the focus is about to go outside the overlay, hence we
      // should prevent that (e.g. user opens the overlay and hit Shift+TAB).
      shouldWrap = (focusedNode === nodeToCheck || focusedNode === this);
    }

    if (shouldWrap) {
      // When the overlay contains the last focusable element of the document
      // and it's already focused, pressing TAB would move the focus outside
      // the document (e.g. to the browser search bar). Similarly, when the
      // overlay contains the first focusable element of the document and it's
      // already focused, pressing Shift+TAB would move the focus outside the
      // document (e.g. to the browser search bar).
      // In both cases, we would not receive a focus event, but only a blur.
      // In order to achieve focus wrapping, we prevent this TAB event and
      // force the focus. This will also prevent the focus to temporarily move
      // outside the overlay, which might cause scrolling.
      event.preventDefault();
      this._focusedChild = nodeToSet;
      this._applyFocus();
    }
  },

  /**
   * Refits if the overlay is opened and not animating.
   * @protected
   */
  _onIronResize: function() {
    if (this.opened && !this.__isAnimating) {
      this.__onNextAnimationFrame(this.refit);
    }
  },

  /**
   * Will call notifyResize if overlay is opened.
   * Can be overridden in order to avoid multiple observers on the same node.
   * @protected
   */
  _onNodesChange: function() {
    if (this.opened && !this.__isAnimating) {
      // It might have added focusable nodes, so invalidate cached values.
      this.invalidateTabbables();
      this.notifyResize();
    }
  },

  /**
   * Will set first and last focusable nodes if any of them is not set.
   * @private
   */
  __ensureFirstLastFocusables: function() {
    if (!this.__firstFocusableNode || !this.__lastFocusableNode) {
      var focusableNodes = this._focusableNodes;
      this.__firstFocusableNode = focusableNodes[0];
      this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];
    }
  },

  /**
   * Tasks executed when opened changes: prepare for the opening, move the
   * focus, update the manager, render opened/closed.
   * @private
   */
  __openedChanged: function() {
    if (this.opened) {
      // Make overlay visible, then add it to the manager.
      this._prepareRenderOpened();
      this._manager.addOverlay(this);
      // Move the focus to the child node with [autofocus].
      this._applyFocus();

      this._renderOpened();
    } else {
      // Remove overlay, then restore the focus before actually closing.
      this._manager.removeOverlay(this);
      this._applyFocus();

      this._renderClosed();
    }
  },

  /**
   * Executes a callback on the next animation frame, overriding any previous
   * callback awaiting for the next animation frame. e.g.
   * `__onNextAnimationFrame(callback1) && __onNextAnimationFrame(callback2)`;
   * `callback1` will never be invoked.
   * @param {!Function} callback Its `this` parameter is the overlay itself.
   * @private
   */
  __onNextAnimationFrame: function(callback) {
    if (this.__raf) {
      window.cancelAnimationFrame(this.__raf);
    }
    var self = this;
    this.__raf = window.requestAnimationFrame(function nextAnimationFrame() {
      self.__raf = null;
      callback.call(self);
    });
  }

};
/* unused harmony export IronOverlayBehaviorImpl */


const IronOverlayBehavior = [__WEBPACK_IMPORTED_MODULE_1__iron_fit_behavior_iron_fit_behavior_js__["a" /* IronFitBehavior */], __WEBPACK_IMPORTED_MODULE_2__iron_resizable_behavior_iron_resizable_behavior_js__["a" /* IronResizableBehavior */], IronOverlayBehaviorImpl];
/* harmony export (immutable) */ __webpack_exports__["a"] = IronOverlayBehavior;



/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);



const IronFitBehavior = {

  properties: {

    /**
     * The element that will receive a `max-height`/`width`. By default it is the same as `this`,
     * but it can be set to a child element. This is useful, for example, for implementing a
     * scrolling region inside the element.
     * @type {!Element}
     */
    sizingTarget: {
      type: Object,
      value: function() {
        return this;
      }
    },

    /**
     * The element to fit `this` into.
     */
    fitInto: {
      type: Object,
      value: window
    },

    /**
     * Will position the element around the positionTarget without overlapping it.
     */
    noOverlap: {
      type: Boolean
    },

    /**
     * The element that should be used to position the element. If not set, it will
     * default to the parent node.
     * @type {!Element}
     */
    positionTarget: {
      type: Element
    },

    /**
     * The orientation against which to align the element horizontally
     * relative to the `positionTarget`. Possible values are "left", "right", "auto".
     */
    horizontalAlign: {
      type: String
    },

    /**
     * The orientation against which to align the element vertically
     * relative to the `positionTarget`. Possible values are "top", "bottom", "auto".
     */
    verticalAlign: {
      type: String
    },

    /**
     * If true, it will use `horizontalAlign` and `verticalAlign` values as preferred alignment
     * and if there's not enough space, it will pick the values which minimize the cropping.
     */
    dynamicAlign: {
      type: Boolean
    },

    /**
     * A pixel value that will be added to the position calculated for the
     * given `horizontalAlign`, in the direction of alignment. You can think
     * of it as increasing or decreasing the distance to the side of the
     * screen given by `horizontalAlign`.
     *
     * If `horizontalAlign` is "left", this offset will increase or decrease
     * the distance to the left side of the screen: a negative offset will
     * move the dropdown to the left; a positive one, to the right.
     *
     * Conversely if `horizontalAlign` is "right", this offset will increase
     * or decrease the distance to the right side of the screen: a negative
     * offset will move the dropdown to the right; a positive one, to the left.
     */
    horizontalOffset: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * A pixel value that will be added to the position calculated for the
     * given `verticalAlign`, in the direction of alignment. You can think
     * of it as increasing or decreasing the distance to the side of the
     * screen given by `verticalAlign`.
     *
     * If `verticalAlign` is "top", this offset will increase or decrease
     * the distance to the top side of the screen: a negative offset will
     * move the dropdown upwards; a positive one, downwards.
     *
     * Conversely if `verticalAlign` is "bottom", this offset will increase
     * or decrease the distance to the bottom side of the screen: a negative
     * offset will move the dropdown downwards; a positive one, upwards.
     */
    verticalOffset: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * Set to true to auto-fit on attach.
     */
    autoFitOnAttach: {
      type: Boolean,
      value: false
    },

    /** @type {?Object} */
    _fitInfo: {
      type: Object
    }
  },

  get _fitWidth() {
    var fitWidth;
    if (this.fitInto === window) {
      fitWidth = this.fitInto.innerWidth;
    } else {
      fitWidth = this.fitInto.getBoundingClientRect().width;
    }
    return fitWidth;
  },

  get _fitHeight() {
    var fitHeight;
    if (this.fitInto === window) {
      fitHeight = this.fitInto.innerHeight;
    } else {
      fitHeight = this.fitInto.getBoundingClientRect().height;
    }
    return fitHeight;
  },

  get _fitLeft() {
    var fitLeft;
    if (this.fitInto === window) {
      fitLeft = 0;
    } else {
      fitLeft = this.fitInto.getBoundingClientRect().left;
    }
    return fitLeft;
  },

  get _fitTop() {
    var fitTop;
    if (this.fitInto === window) {
      fitTop = 0;
    } else {
      fitTop = this.fitInto.getBoundingClientRect().top;
    }
    return fitTop;
  },

  /**
   * The element that should be used to position the element,
   * if no position target is configured.
   */
  get _defaultPositionTarget() {
    var parent = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).parentNode;

    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      parent = parent.host;
    }

    return parent;
  },

  /**
   * The horizontal align value, accounting for the RTL/LTR text direction.
   */
  get _localeHorizontalAlign() {
    if (this._isRTL) {
      // In RTL, "left" becomes "right".
      if (this.horizontalAlign === 'right') {
        return 'left';
      }
      if (this.horizontalAlign === 'left') {
        return 'right';
      }
    }
    return this.horizontalAlign;
  },

  attached: function() {
    // Memoize this to avoid expensive calculations & relayouts.
    // Make sure we do it only once
    if (typeof this._isRTL === 'undefined') {
      this._isRTL = window.getComputedStyle(this).direction == 'rtl';
    }
    this.positionTarget = this.positionTarget || this._defaultPositionTarget;
    if (this.autoFitOnAttach) {
      if (window.getComputedStyle(this).display === 'none') {
        setTimeout(function() {
          this.fit();
        }.bind(this));
      } else {
        // NOTE: shadydom applies distribution asynchronously
        // for performance reasons webcomponents/shadydom#120
        // Flush to get correct layout info.
        window.ShadyDOM && ShadyDOM.flush();
        this.fit();
      }
    }
  },

  detached: function() {
    if (this.__deferredFit) {
      clearTimeout(this.__deferredFit);
      this.__deferredFit = null;
    }
  },

  /**
   * Positions and fits the element into the `fitInto` element.
   */
  fit: function() {
    this.position();
    this.constrain();
    this.center();
  },

  /**
   * Memoize information needed to position and size the target element.
   * @suppress {deprecated}
   */
  _discoverInfo: function() {
    if (this._fitInfo) {
      return;
    }
    var target = window.getComputedStyle(this);
    var sizer = window.getComputedStyle(this.sizingTarget);

    this._fitInfo = {
      inlineStyle: {
        top: this.style.top || '',
        left: this.style.left || '',
        position: this.style.position || ''
      },
      sizerInlineStyle: {
        maxWidth: this.sizingTarget.style.maxWidth || '',
        maxHeight: this.sizingTarget.style.maxHeight || '',
        boxSizing: this.sizingTarget.style.boxSizing || ''
      },
      positionedBy: {
        vertically: target.top !== 'auto' ? 'top' : (target.bottom !== 'auto' ?
          'bottom' : null),
        horizontally: target.left !== 'auto' ? 'left' : (target.right !== 'auto' ?
          'right' : null)
      },
      sizedBy: {
        height: sizer.maxHeight !== 'none',
        width: sizer.maxWidth !== 'none',
        minWidth: parseInt(sizer.minWidth, 10) || 0,
        minHeight: parseInt(sizer.minHeight, 10) || 0
      },
      margin: {
        top: parseInt(target.marginTop, 10) || 0,
        right: parseInt(target.marginRight, 10) || 0,
        bottom: parseInt(target.marginBottom, 10) || 0,
        left: parseInt(target.marginLeft, 10) || 0
      }
    };
  },

  /**
   * Resets the target element's position and size constraints, and clear
   * the memoized data.
   */
  resetFit: function() {
    var info = this._fitInfo || {};
    for (var property in info.sizerInlineStyle) {
      this.sizingTarget.style[property] = info.sizerInlineStyle[property];
    }
    for (var property in info.inlineStyle) {
      this.style[property] = info.inlineStyle[property];
    }

    this._fitInfo = null;
  },

  /**
   * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after
   * the element or the `fitInto` element has been resized, or if any of the
   * positioning properties (e.g. `horizontalAlign, verticalAlign`) is updated.
   * It preserves the scroll position of the sizingTarget.
   */
  refit: function() {
    var scrollLeft = this.sizingTarget.scrollLeft;
    var scrollTop = this.sizingTarget.scrollTop;
    this.resetFit();
    this.fit();
    this.sizingTarget.scrollLeft = scrollLeft;
    this.sizingTarget.scrollTop = scrollTop;
  },

  /**
   * Positions the element according to `horizontalAlign, verticalAlign`.
   */
  position: function() {
    if (!this.horizontalAlign && !this.verticalAlign) {
      // needs to be centered, and it is done after constrain.
      return;
    }
    this._discoverInfo();

    this.style.position = 'fixed';
    // Need border-box for margin/padding.
    this.sizingTarget.style.boxSizing = 'border-box';
    // Set to 0, 0 in order to discover any offset caused by parent stacking contexts.
    this.style.left = '0px';
    this.style.top = '0px';

    var rect = this.getBoundingClientRect();
    var positionRect = this.__getNormalizedRect(this.positionTarget);
    var fitRect = this.__getNormalizedRect(this.fitInto);

    var margin = this._fitInfo.margin;

    // Consider the margin as part of the size for position calculations.
    var size = {
      width: rect.width + margin.left + margin.right,
      height: rect.height + margin.top + margin.bottom
    };

    var position = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, size, positionRect,
      fitRect);

    var left = position.left + margin.left;
    var top = position.top + margin.top;

    // We first limit right/bottom within fitInto respecting the margin,
    // then use those values to limit top/left.
    var right = Math.min(fitRect.right - margin.right, left + rect.width);
    var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);

    // Keep left/top within fitInto respecting the margin.
    left = Math.max(fitRect.left + margin.left,
      Math.min(left, right - this._fitInfo.sizedBy.minWidth));
    top = Math.max(fitRect.top + margin.top,
      Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));

    // Use right/bottom to set maxWidth/maxHeight, and respect minWidth/minHeight.
    this.sizingTarget.style.maxWidth = Math.max(right - left, this._fitInfo.sizedBy.minWidth) + 'px';
    this.sizingTarget.style.maxHeight = Math.max(bottom - top, this._fitInfo.sizedBy.minHeight) + 'px';

    // Remove the offset caused by any stacking context.
    this.style.left = (left - rect.left) + 'px';
    this.style.top = (top - rect.top) + 'px';
  },

  /**
   * Constrains the size of the element to `fitInto` by setting `max-height`
   * and/or `max-width`.
   */
  constrain: function() {
    if (this.horizontalAlign || this.verticalAlign) {
      return;
    }
    this._discoverInfo();

    var info = this._fitInfo;
    // position at (0px, 0px) if not already positioned, so we can measure the natural size.
    if (!info.positionedBy.vertically) {
      this.style.position = 'fixed';
      this.style.top = '0px';
    }
    if (!info.positionedBy.horizontally) {
      this.style.position = 'fixed';
      this.style.left = '0px';
    }

    // need border-box for margin/padding
    this.sizingTarget.style.boxSizing = 'border-box';
    // constrain the width and height if not already set
    var rect = this.getBoundingClientRect();
    if (!info.sizedBy.height) {
      this.__sizeDimension(rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');
    }
    if (!info.sizedBy.width) {
      this.__sizeDimension(rect, info.positionedBy.horizontally, 'left', 'right', 'Width');
    }
  },

  /**
   * @protected
   * @deprecated
   */
  _sizeDimension: function(rect, positionedBy, start, end, extent) {
    this.__sizeDimension(rect, positionedBy, start, end, extent);
  },

  /**
   * @private
   */
  __sizeDimension: function(rect, positionedBy, start, end, extent) {
    var info = this._fitInfo;
    var fitRect = this.__getNormalizedRect(this.fitInto);
    var max = extent === 'Width' ? fitRect.width : fitRect.height;
    var flip = (positionedBy === end);
    var offset = flip ? max - rect[end] : rect[start];
    var margin = info.margin[flip ? start : end];
    var offsetExtent = 'offset' + extent;
    var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
    this.sizingTarget.style['max' + extent] = (max - margin - offset - sizingOffset) + 'px';
  },

  /**
   * Centers horizontally and vertically if not already positioned. This also sets
   * `position:fixed`.
   */
  center: function() {
    if (this.horizontalAlign || this.verticalAlign) {
      return;
    }
    this._discoverInfo();

    var positionedBy = this._fitInfo.positionedBy;
    if (positionedBy.vertically && positionedBy.horizontally) {
      // Already positioned.
      return;
    }
    // Need position:fixed to center
    this.style.position = 'fixed';
    // Take into account the offset caused by parents that create stacking
    // contexts (e.g. with transform: translate3d). Translate to 0,0 and
    // measure the bounding rect.
    if (!positionedBy.vertically) {
      this.style.top = '0px';
    }
    if (!positionedBy.horizontally) {
      this.style.left = '0px';
    }
    // It will take in consideration margins and transforms
    var rect = this.getBoundingClientRect();
    var fitRect = this.__getNormalizedRect(this.fitInto);
    if (!positionedBy.vertically) {
      var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;
      this.style.top = top + 'px';
    }
    if (!positionedBy.horizontally) {
      var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;
      this.style.left = left + 'px';
    }
  },

  __getNormalizedRect: function(target) {
    if (target === document.documentElement || target === window) {
      return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight,
        right: window.innerWidth,
        bottom: window.innerHeight
      };
    }
    return target.getBoundingClientRect();
  },

  __getCroppedArea: function(position, size, fitRect) {
    var verticalCrop = Math.min(0, position.top) + Math.min(0, fitRect.bottom - (position.top + size.height));
    var horizontalCrop = Math.min(0, position.left) + Math.min(0, fitRect.right - (position.left + size.width));
    return Math.abs(verticalCrop) * size.width + Math.abs(horizontalCrop) * size.height;
  },


  __getPosition: function(hAlign, vAlign, size, positionRect, fitRect) {
    // All the possible configurations.
    // Ordered as top-left, top-right, bottom-left, bottom-right.
    var positions = [{
      verticalAlign: 'top',
      horizontalAlign: 'left',
      top: positionRect.top + this.verticalOffset,
      left: positionRect.left + this.horizontalOffset
    }, {
      verticalAlign: 'top',
      horizontalAlign: 'right',
      top: positionRect.top + this.verticalOffset,
      left: positionRect.right - size.width - this.horizontalOffset
    }, {
      verticalAlign: 'bottom',
      horizontalAlign: 'left',
      top: positionRect.bottom - size.height - this.verticalOffset,
      left: positionRect.left + this.horizontalOffset
    }, {
      verticalAlign: 'bottom',
      horizontalAlign: 'right',
      top: positionRect.bottom - size.height - this.verticalOffset,
      left: positionRect.right - size.width - this.horizontalOffset
    }];

    if (this.noOverlap) {
      // Duplicate.
      for (var i = 0, l = positions.length; i < l; i++) {
        var copy = {};
        for (var key in positions[i]) {
          copy[key] = positions[i][key];
        }
        positions.push(copy);
      }
      // Horizontal overlap only.
      positions[0].top = positions[1].top += positionRect.height;
      positions[2].top = positions[3].top -= positionRect.height;
      // Vertical overlap only.
      positions[4].left = positions[6].left += positionRect.width;
      positions[5].left = positions[7].left -= positionRect.width;
    }

    // Consider auto as null for coding convenience.
    vAlign = vAlign === 'auto' ? null : vAlign;
    hAlign = hAlign === 'auto' ? null : hAlign;

    var position;
    for (var i = 0; i < positions.length; i++) {
      var pos = positions[i];

      // If both vAlign and hAlign are defined, return exact match.
      // For dynamicAlign and noOverlap we'll have more than one candidate, so
      // we'll have to check the croppedArea to make the best choice.
      if (!this.dynamicAlign && !this.noOverlap &&
        pos.verticalAlign === vAlign && pos.horizontalAlign === hAlign) {
        position = pos;
        break;
      }

      // Align is ok if alignment preferences are respected. If no preferences,
      // it is considered ok.
      var alignOk = (!vAlign || pos.verticalAlign === vAlign) &&
        (!hAlign || pos.horizontalAlign === hAlign);

      // Filter out elements that don't match the alignment (if defined).
      // With dynamicAlign, we need to consider all the positions to find the
      // one that minimizes the cropped area.
      if (!this.dynamicAlign && !alignOk) {
        continue;
      }

      position = position || pos;
      pos.croppedArea = this.__getCroppedArea(pos, size, fitRect);
      var diff = pos.croppedArea - position.croppedArea;
      // Check which crops less. If it crops equally, check if align is ok.
      if (diff < 0 || (diff === 0 && alignOk)) {
        position = pos;
      }
      // If not cropped and respects the align requirements, keep it.
      // This allows to prefer positions overlapping horizontally over the
      // ones overlapping vertically.
      if (position.croppedArea === 0 && alignOk) {
        break;
      }
    }

    return position;
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronFitBehavior;



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_utils_settings_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




const IronResizableBehavior = {
  properties: {
    /**
     * The closest ancestor element that implements `IronResizableBehavior`.
     */
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged'
    },

    /**
     * True if this element is currently notifying its descendant elements of
     * resize.
     */
    _notifyingDescendant: {
      type: Boolean,
      value: false
    }
  },

  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },

  created: function() {
    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
  },

  attached: function() {
    this._requestResizeNotifications();
  },

  detached: function() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      window.removeEventListener('resize', this._boundNotifyResize);
    }

    this._parentResizable = null;
  },

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize: function() {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function(resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);

    this._fireResize();
  },

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   */
  assignParentResizable: function(parentResizable) {
    this._parentResizable = parentResizable;
  },

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   */
  stopResizeNotificationsFor: function(target) {
    var index = this._interestedResizables.indexOf(target);

    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
    }
  },

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify: function(element) { return true; },

  _onDescendantIronResize: function(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }

    // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
    // otherwise non-bubbling event "just work." We do it manually here for
    // the case where Polymer is not using shadow roots for whatever reason:
    if (!__WEBPACK_IMPORTED_MODULE_1__polymer_lib_utils_settings_js__["a" /* Settings */].useShadow) {
      this._fireResize();
    }
  },

  _fireResize: function() {
    this.fire('iron-resize', null, {
      node: this,
      bubbles: false
    });
  },

  _onIronRequestResizeNotifications: function(event) {
    var target = /** @type {!EventTarget} */ (Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).rootTarget);
    if (target === this) {
      return;
    }

    if (this._interestedResizables.indexOf(target) === -1) {
      this._interestedResizables.push(target);
      this.listen(target, 'iron-resize', '_onDescendantIronResize');
    }

    target.assignParentResizable(this);
    this._notifyDescendant(target);

    event.stopPropagation();
  },

  _parentResizableChanged: function(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },

  _notifyDescendant: function(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  },
  
  _requestResizeNotifications: function() {
    if (!this.isAttached)
      return;
    
    // NOTE(valdrin) In CustomElements v1 with native HTMLImports, the order
    // of imports affects the order of `attached` callbacks (see webcomponents/custom-elements#15).
    // This might cause a child to notify parents too early (as the parent
    // still has to be upgraded), resulting in a parent not able to keep track
    // of the `_interestedResizables`. To solve this, we wait for the document
    // to be done loading before firing the event.
    if (document.readyState === 'loading') {
      var _requestResizeNotifications = this._requestResizeNotifications.bind(this);
      document.addEventListener('readystatechange', function readystatechanged() {
        document.removeEventListener('readystatechange', readystatechanged);
        _requestResizeNotifications();
      });
    } else {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      } 
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronResizableBehavior;



/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_overlay_backdrop_js__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_utils_gestures_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);






const IronOverlayManagerClass = function() {
  /**
   * Used to keep track of the opened overlays.
   * @private {Array<Element>}
   */
  this._overlays = [];

  /**
   * iframes have a default z-index of 100,
   * so this default should be at least that.
   * @private {number}
   */
  this._minimumZ = 101;

  /**
   * Memoized backdrop element.
   * @private {Element|null}
   */
  this._backdropElement = null;

  // Enable document-wide tap recognizer.
  // NOTE: Use useCapture=true to avoid accidentally prevention of the closing
  // of an overlay via event.stopPropagation(). The only way to prevent
  // closing of an overlay should be through its APIs.
  // NOTE: enable tap on <html> to workaround Polymer/polymer#4459
  __WEBPACK_IMPORTED_MODULE_3__polymer_lib_utils_gestures_js__["add"](document.documentElement, 'tap', null);
  document.addEventListener('tap', this._onCaptureClick.bind(this), true);
  document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
  document.addEventListener('keydown', this._onCaptureKeyDown.bind(this), true);
};
/* unused harmony export IronOverlayManagerClass */


IronOverlayManagerClass.prototype = {

  constructor: IronOverlayManagerClass,

  /**
   * The shared backdrop element.
   * @type {!Element} backdropElement
   */
  get backdropElement() {
    if (!this._backdropElement) {
      this._backdropElement = document.createElement('iron-overlay-backdrop');
    }
    return this._backdropElement;
  },

  /**
   * The deepest active element.
   * @type {!Element} activeElement the active element
   */
  get deepActiveElement() {
    // document.activeElement can be null
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
    // In case of null, default it to document.body.
    var active = document.activeElement || document.body;
    while (active.root && Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(active.root).activeElement) {
      active = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(active.root).activeElement;
    }
    return active;
  },

  /**
   * Brings the overlay at the specified index to the front.
   * @param {number} i
   * @private
   */
  _bringOverlayAtIndexToFront: function(i) {
    var overlay = this._overlays[i];
    if (!overlay) {
      return;
    }
    var lastI = this._overlays.length - 1;
    var currentOverlay = this._overlays[lastI];
    // Ensure always-on-top overlay stays on top.
    if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      lastI--;
    }
    // If already the top element, return.
    if (i >= lastI) {
      return;
    }
    // Update z-index to be on top.
    var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
    if (this._getZ(overlay) <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }

    // Shift other overlays behind the new on top.
    while (i < lastI) {
      this._overlays[i] = this._overlays[i + 1];
      i++;
    }
    this._overlays[lastI] = overlay;
  },

  /**
   * Adds the overlay and updates its z-index if it's opened, or removes it if it's closed.
   * Also updates the backdrop z-index.
   * @param {!Element} overlay
   */
  addOrRemoveOverlay: function(overlay) {
    if (overlay.opened) {
      this.addOverlay(overlay);
    } else {
      this.removeOverlay(overlay);
    }
  },

  /**
   * Tracks overlays for z-index and focus management.
   * Ensures the last added overlay with always-on-top remains on top.
   * @param {!Element} overlay
   */
  addOverlay: function(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i >= 0) {
      this._bringOverlayAtIndexToFront(i);
      this.trackBackdrop();
      return;
    }
    var insertionIndex = this._overlays.length;
    var currentOverlay = this._overlays[insertionIndex - 1];
    var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);
    var newZ = this._getZ(overlay);

    // Ensure always-on-top overlay stays on top.
    if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      // This bumps the z-index of +2.
      this._applyOverlayZ(currentOverlay, minimumZ);
      insertionIndex--;
      // Update minimumZ to match previous overlay's z-index.
      var previousOverlay = this._overlays[insertionIndex - 1];
      minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
    }

    // Update z-index and insert overlay.
    if (newZ <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }
    this._overlays.splice(insertionIndex, 0, overlay);

    this.trackBackdrop();
  },

  /**
   * @param {!Element} overlay
   */
  removeOverlay: function(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i === -1) {
      return;
    }
    this._overlays.splice(i, 1);

    this.trackBackdrop();
  },

  /**
   * Returns the current overlay.
   * @return {Element|undefined}
   */
  currentOverlay: function() {
    var i = this._overlays.length - 1;
    return this._overlays[i];
  },

  /**
   * Returns the current overlay z-index.
   * @return {number}
   */
  currentOverlayZ: function() {
    return this._getZ(this.currentOverlay());
  },

  /**
   * Ensures that the minimum z-index of new overlays is at least `minimumZ`.
   * This does not effect the z-index of any existing overlays.
   * @param {number} minimumZ
   */
  ensureMinimumZ: function(minimumZ) {
    this._minimumZ = Math.max(this._minimumZ, minimumZ);
  },

  focusOverlay: function() {
    var current = /** @type {?} */ (this.currentOverlay());
    if (current) {
      current._applyFocus();
    }
  },

  /**
   * Updates the backdrop z-index.
   */
  trackBackdrop: function() {
    var overlay = this._overlayWithBackdrop();
    // Avoid creating the backdrop if there is no overlay with backdrop.
    if (!overlay && !this._backdropElement) {
      return;
    }
    this.backdropElement.style.zIndex = this._getZ(overlay) - 1;
    this.backdropElement.opened = !!overlay;
    // Property observers are not fired until element is attached
    // in Polymer 2.x, so we ensure element is attached if needed.
    // https://github.com/Polymer/polymer/issues/4526
    this.backdropElement.prepare();
  },

  /**
   * @return {Array<Element>}
   */
  getBackdrops: function() {
    var backdrops = [];
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        backdrops.push(this._overlays[i]);
      }
    }
    return backdrops;
  },

  /**
   * Returns the z-index for the backdrop.
   * @return {number}
   */
  backdropZ: function() {
    return this._getZ(this._overlayWithBackdrop()) - 1;
  },

  /**
   * Returns the first opened overlay that has a backdrop.
   * @return {Element|undefined}
   * @private
   */
  _overlayWithBackdrop: function() {
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        return this._overlays[i];
      }
    }
  },

  /**
   * Calculates the minimum z-index for the overlay.
   * @param {Element=} overlay
   * @private
   */
  _getZ: function(overlay) {
    var z = this._minimumZ;
    if (overlay) {
      var z1 = Number(overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);
      // Check if is a number
      // Number.isNaN not supported in IE 10+
      if (z1 === z1) {
        z = z1;
      }
    }
    return z;
  },

  /**
   * @param {!Element} element
   * @param {number|string} z
   * @private
   */
  _setZ: function(element, z) {
    element.style.zIndex = z;
  },

  /**
   * @param {!Element} overlay
   * @param {number} aboveZ
   * @private
   */
  _applyOverlayZ: function(overlay, aboveZ) {
    this._setZ(overlay, aboveZ + 2);
  },

  /**
   * Returns the deepest overlay in the path.
   * @param {Array<Element>=} path
   * @return {Element|undefined}
   * @suppress {missingProperties}
   * @private
   */
  _overlayInPath: function(path) {
    path = path || [];
    for (var i = 0; i < path.length; i++) {
      if (path[i]._manager === this) {
        return path[i];
      }
    }
  },

  /**
   * Ensures the click event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureClick: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    // Check if clicked outside of top overlay.
    if (overlay && this._overlayInPath(Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).path) !== overlay) {
      overlay._onCaptureClick(event);
    }
  },

  /**
   * Ensures the focus event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureFocus: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    if (overlay) {
      overlay._onCaptureFocus(event);
    }
  },

  /**
   * Ensures TAB and ESC keyboard events are delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureKeyDown: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    if (overlay) {
      if (__WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */].keyboardEventMatchesKeys(event, 'esc')) {
        overlay._onCaptureEsc(event);
      } else if (__WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */].keyboardEventMatchesKeys(event, 'tab')) {
        overlay._onCaptureTab(event);
      }
    }
  },

  /**
   * Returns if the overlay1 should be behind overlay2.
   * @param {!Element} overlay1
   * @param {!Element} overlay2
   * @return {boolean}
   * @suppress {missingProperties}
   * @private
   */
  _shouldBeBehindOverlay: function(overlay1, overlay2) {
    return !overlay1.alwaysOnTop && overlay2.alwaysOnTop;
  }
};

const IronOverlayManager = new IronOverlayManagerClass();
/* harmony export (immutable) */ __webpack_exports__["a"] = IronOverlayManager;



/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--iron-overlay-backdrop-background-color, #000);
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
        @apply --iron-overlay-backdrop;
      }

      :host(.opened) {
        opacity: var(--iron-overlay-backdrop-opacity, 0.6);
        pointer-events: auto;
        @apply --iron-overlay-backdrop-opened;
      }
    </style>

    <slot></slot>
`,

  is: 'iron-overlay-backdrop',

  properties: {

    /**
     * Returns true if the backdrop is opened.
     */
    opened: {
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_openedChanged'
    }

  },

  listeners: {
    'transitionend': '_onTransitionend'
  },

  created: function() {
    // Used to cancel previous requestAnimationFrame calls when opened changes.
    this.__openedRaf = null;
  },

  attached: function() {
    this.opened && this._openedChanged(this.opened);
  },

  /**
   * Appends the backdrop to document body if needed.
   */
  prepare: function() {
    if (this.opened && !this.parentNode) {
      Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(document.body).appendChild(this);
    }
  },

  /**
   * Shows the backdrop.
   */
  open: function() {
    this.opened = true;
  },

  /**
   * Hides the backdrop.
   */
  close: function() {
    this.opened = false;
  },

  /**
   * Removes the backdrop from document body if needed.
   */
  complete: function() {
    if (!this.opened && this.parentNode === document.body) {
      Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.parentNode).removeChild(this);
    }
  },

  _onTransitionend: function(event) {
    if (event && event.target === this) {
      this.complete();
    }
  },

  /**
   * @param {boolean} opened
   * @private
   */
  _openedChanged: function(opened) {
    if (opened) {
      // Auto-attach.
      this.prepare();
    } else {
      // Animation might be disabled via the mixin or opacity custom property.
      // If it is disabled in other ways, it's up to the user to call complete.
      var cs = window.getComputedStyle(this);
      if (cs.transitionDuration === '0s' || cs.opacity == 0) {
        this.complete();
      }
    }

    if (!this.isAttached) {
      return;
    }

    // Always cancel previous requestAnimationFrame.
    if (this.__openedRaf) {
      window.cancelAnimationFrame(this.__openedRaf);
      this.__openedRaf = null;
    }
    // Force relayout to ensure proper transitions.
    this.scrollTop = this.scrollTop;
    this.__openedRaf = window.requestAnimationFrame(function() {
      this.__openedRaf = null;
      this.toggleClass('opened', this.opened);
    }.bind(this));
  }
});


/***/ }),
/* 82 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);



var p = Element.prototype;
var matches = p.matches || p.matchesSelector || p.mozMatchesSelector ||
  p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

const IronFocusablesHelper = {

  /**
   * Returns a sorted array of tabbable nodes, including the root node.
   * It searches the tabbable nodes in the light and shadow dom of the chidren,
   * sorting the result by tabindex.
   * @param {!Node} node
   * @return {Array<HTMLElement>}
   */
  getTabbableNodes: function(node) {
    var result = [];
    // If there is at least one element with tabindex > 0, we need to sort
    // the final array by tabindex.
    var needsSortByTabIndex = this._collectTabbableNodes(node, result);
    if (needsSortByTabIndex) {
      return this._sortByTabIndex(result);
    }
    return result;
  },

  /**
   * Returns if a element is focusable.
   * @param {!HTMLElement} element
   * @return {boolean}
   */
  isFocusable: function(element) {
    // From http://stackoverflow.com/a/1600194/4228703:
    // There isn't a definite list, it's up to the browser. The only
    // standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,
    // according to which the only elements that have a focus() method are
    // HTMLInputElement,  HTMLSelectElement, HTMLTextAreaElement and
    // HTMLAnchorElement. This notably omits HTMLButtonElement and
    // HTMLAreaElement.
    // Referring to these tests with tabbables in different browsers
    // http://allyjs.io/data-tables/focusable.html

    // Elements that cannot be focused if they have [disabled] attribute.
    if (matches.call(element, 'input, select, textarea, button, object')) {
      return matches.call(element, ':not([disabled])');
    }
    // Elements that can be focused even if they have [disabled] attribute.
    return matches.call(element,
      'a[href], area[href], iframe, [tabindex], [contentEditable]');
  },

  /**
   * Returns if a element is tabbable. To be tabbable, a element must be
   * focusable, visible, and with a tabindex !== -1.
   * @param {!HTMLElement} element
   * @return {boolean}
   */
  isTabbable: function(element) {
    return this.isFocusable(element) &&
      matches.call(element, ':not([tabindex="-1"])') &&
      this._isVisible(element);
  },

  /**
   * Returns the normalized element tabindex. If not focusable, returns -1.
   * It checks for the attribute "tabindex" instead of the element property
   * `tabIndex` since browsers assign different values to it.
   * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
   * @param {!HTMLElement} element
   * @return {!number}
   * @private
   */
  _normalizedTabIndex: function(element) {
    if (this.isFocusable(element)) {
      var tabIndex = element.getAttribute('tabindex') || 0;
      return Number(tabIndex);
    }
    return -1;
  },

  /**
   * Searches for nodes that are tabbable and adds them to the `result` array.
   * Returns if the `result` array needs to be sorted by tabindex.
   * @param {!Node} node The starting point for the search; added to `result`
   * if tabbable.
   * @param {!Array<HTMLElement>} result
   * @return {boolean}
   * @private
   */
  _collectTabbableNodes: function(node, result) {
    // If not an element or not visible, no need to explore children.
    if (node.nodeType !== Node.ELEMENT_NODE || !this._isVisible(node)) {
      return false;
    }
    var element = /** @type {HTMLElement} */ (node);
    var tabIndex = this._normalizedTabIndex(element);
    var needsSort = tabIndex > 0;
    if (tabIndex >= 0) {
      result.push(element);
    }

    // In ShadowDOM v1, tab order is affected by the order of distrubution.
    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];
    // in ShadowDOM v0 tab order is not affected by the distrubution order,
    // in fact getTabbableNodes(#root) returns [#B, #A].
    //  <div id="root">
    //   <!-- shadow -->
    //     <slot name="a">
    //     <slot name="b">
    //   <!-- /shadow -->
    //   <input id="A" slot="a">
    //   <input id="B" slot="b" tabindex="1">
    //  </div>
    // TODO(valdrin) support ShadowDOM v1 when upgrading to Polymer v2.0.
    var children;
    if (element.localName === 'content' || element.localName === 'slot') {
      children = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(element).getDistributedNodes();
    } else {
      // Use shadow root if possible, will check for distributed nodes.
      children = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(element.root || element).children;
    }
    for (var i = 0; i < children.length; i++) {
      // Ensure method is always invoked to collect tabbable children.
      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;
    }
    return needsSort;
  },

  /**
   * Returns false if the element has `visibility: hidden` or `display: none`
   * @param {!HTMLElement} element
   * @return {boolean}
   * @private
   */
  _isVisible: function(element) {
    // Check inline style first to save a re-flow. If looks good, check also
    // computed style.
    var style = element.style;
    if (style.visibility !== 'hidden' && style.display !== 'none') {
      style = window.getComputedStyle(element);
      return (style.visibility !== 'hidden' && style.display !== 'none');
    }
    return false;
  },

  /**
   * Sorts an array of tabbable elements by tabindex. Returns a new array.
   * @param {!Array<HTMLElement>} tabbables
   * @return {Array<HTMLElement>}
   * @private
   */
  _sortByTabIndex: function(tabbables) {
    // Implement a merge sort as Array.prototype.sort does a non-stable sort
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
    var len = tabbables.length;
    if (len < 2) {
      return tabbables;
    }
    var pivot = Math.ceil(len / 2);
    var left = this._sortByTabIndex(tabbables.slice(0, pivot));
    var right = this._sortByTabIndex(tabbables.slice(pivot));
    return this._mergeSortByTabIndex(left, right);
  },

  /**
   * Merge sort iterator, merges the two arrays into one, sorted by tab index.
   * @param {!Array<HTMLElement>} left
   * @param {!Array<HTMLElement>} right
   * @return {Array<HTMLElement>}
   * @private
   */
  _mergeSortByTabIndex: function(left, right) {
    var result = [];
    while ((left.length > 0) && (right.length > 0)) {
      if (this._hasLowerTabOrder(left[0], right[0])) {
        result.push(right.shift());
      } else {
        result.push(left.shift());
      }
    }

    return result.concat(left, right);
  },

  /**
   * Returns if element `a` has lower tab order compared to element `b`
   * (both elements are assumed to be focusable and tabbable).
   * Elements with tabindex = 0 have lower tab order compared to elements
   * with tabindex > 0.
   * If both have same tabindex, it returns false.
   * @param {!HTMLElement} a
   * @param {!HTMLElement} b
   * @return {boolean}
   * @private
   */
  _hasLowerTabOrder: function(a, b) {
    // Normalize tabIndexes
    // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
    var ati = Math.max(a.tabIndex, 0);
    var bti = Math.max(b.tabIndex, 0);
    return (ati === 0 || bti === 0) ? bti > ati : ati > bti;
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronFocusablesHelper;



/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__paper_styles_shadow_js__ = __webpack_require__(47);





const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-dialog-shared-styles">
  <template>
    <style>
      :host {
        display: block;
        margin: 24px 40px;

        background: var(--paper-dialog-background-color, var(--primary-background-color));
        color: var(--paper-dialog-color, var(--primary-text-color));

        @apply --paper-font-body1;
        @apply --shadow-elevation-16dp;
        @apply --paper-dialog;
      }

      :host > ::slotted(*) {
        margin-top: 20px;
        padding: 0 24px;
      }

      :host > ::slotted(.no-padding) {
        padding: 0;
      }

      /* In 1.x, this selector was \`:host > ::content h2\`. In 2.x <slot> allows
      to select direct children only, which increases the weight of this
      selector, so we have to move it before first-child/last-child selectors */
      :host > ::slotted(h2) {
        position: relative;
        margin: 0;

        @apply --paper-font-title;
        @apply --paper-dialog-title;
      }

      :host > ::slotted(*:first-child) {
        margin-top: 24px;
      }

      :host > ::slotted(*:last-child) {
        margin-bottom: 24px;
      }

      :host > ::slotted(.buttons) {
        position: relative;
        padding: 8px 8px 8px 24px;
        margin: 0;

        color: var(--paper-dialog-button-color, var(--primary-color));

        @apply --layout-horizontal;
        @apply --layout-end-justified;
      }
    </style>
  </template>
</dom-module>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 84 */
/***/ (function(module, exports) {

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,300,300italic,400italic,500,500italic,700,700italic" crossorigin="anonymous">
`;
document.head.appendChild($_documentContainer);


/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_button_behavior_js__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_element_styles_paper_material_styles_js__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);





const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-button">
  <template strip-whitespace="">
    <style include="paper-material-styles">
      /* Need to specify the same specificity as the styles imported from paper-material. */
      :host {
        @apply --layout-inline;
        @apply --layout-center-center;
        position: relative;
        box-sizing: border-box;
        min-width: 5.14em;
        margin: 0 0.29em;
        background: transparent;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-tap-highlight-color: transparent;
        font: inherit;
        text-transform: uppercase;
        outline-width: 0;
        border-radius: 3px;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        cursor: pointer;
        z-index: 0;
        padding: 0.7em 0.57em;

        @apply --paper-font-common-base;
        @apply --paper-button;
      }

      :host([elevation="1"]) {
        @apply --paper-material-elevation-1;
      }

      :host([elevation="2"]) {
        @apply --paper-material-elevation-2;
      }

      :host([elevation="3"]) {
        @apply --paper-material-elevation-3;
      }

      :host([elevation="4"]) {
        @apply --paper-material-elevation-4;
      }

      :host([elevation="5"]) {
        @apply --paper-material-elevation-5;
      }

      :host([hidden]) {
        display: none !important;
      }

      :host([raised].keyboard-focus) {
        font-weight: bold;
        @apply --paper-button-raised-keyboard-focus;
      }

      :host(:not([raised]).keyboard-focus) {
        font-weight: bold;
        @apply --paper-button-flat-keyboard-focus;
      }

      :host([disabled]) {
        background: #eaeaea;
        color: #a8a8a8;
        cursor: auto;
        pointer-events: none;

        @apply --paper-button-disabled;
      }

      :host([animated]) {
        @apply --shadow-transition;
      }

      paper-ripple {
        color: var(--paper-button-ink-color);
      }
    </style>

    <slot></slot>
  </template>

  
</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-button',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_button_behavior_js__["a" /* PaperButtonBehavior */]
  ],

  properties: {
    /**
     * If true, the button should be styled with a shadow.
     */
    raised: {
      type: Boolean,
      reflectToAttribute: true,
      value: false,
      observer: '_calculateElevation'
    }
  },

  _calculateElevation: function() {
    if (!this.raised) {
      this._setElevation(0);
    } else {
      __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_button_behavior_js__["b" /* PaperButtonBehaviorImpl */]._calculateElevation.apply(this);
    }
  }

  /**
  Fired when the animation finishes.
  This is useful if you want to wait until
  the ripple animation finishes to perform some action.

  @event transitionend
  Event param: {{node: Object}} detail Contains the animated node.
  */
});


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__ = __webpack_require__(18);





const PaperButtonBehaviorImpl = {
  properties: {
    /**
     * The z-depth of this element, from 0-5. Setting to 0 will remove the
     * shadow, and each increasing number greater than 0 will be "deeper"
     * than the last.
     *
     * @attribute elevation
     * @type number
     * @default 1
     */
    elevation: {
      type: Number,
      reflectToAttribute: true,
      readOnly: true
    }
  },

  observers: [
    '_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)',
    '_computeKeyboardClass(receivedFocusFromKeyboard)'
  ],

  hostAttributes: {
    role: 'button',
    tabindex: '0',
    animated: true
  },

  _calculateElevation: function() {
    var e = 1;
    if (this.disabled) {
      e = 0;
    } else if (this.active || this.pressed) {
      e = 4;
    } else if (this.receivedFocusFromKeyboard) {
      e = 3;
    }
    this._setElevation(e);
  },

  _computeKeyboardClass: function(receivedFocusFromKeyboard) {
    this.toggleClass('keyboard-focus', receivedFocusFromKeyboard);
  },

  /**
   * In addition to `IronButtonState` behavior, when space key goes down,
   * create a ripple down effect.
   *
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["b" /* IronButtonStateImpl */]._spaceKeyDownHandler.call(this, event);
    // Ensure that there is at most one ripple when the space key is held down.
    if (this.hasRipple() && this.getRipple().ripples.length < 1) {
      this._ripple.uiDownAction();
    }
  },

  /**
   * In addition to `IronButtonState` behavior, when space key goes up,
   * create a ripple up effect.
   *
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["b" /* IronButtonStateImpl */]._spaceKeyUpHandler.call(this, event);
    if (this.hasRipple()) {
      this._ripple.uiUpAction();
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["b"] = PaperButtonBehaviorImpl;


const PaperButtonBehavior = [
  __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["a" /* IronButtonState */],
  __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__["a" /* IronControlState */],
  __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */],
  PaperButtonBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperButtonBehavior;



/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shadow_js__ = __webpack_require__(47);


const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-material-styles">
  <template>
    <style>
      :host, html {
        --paper-material: {
          display: block;
          position: relative;
        };
        --paper-material-elevation-1: {
          @apply --shadow-elevation-2dp;
        };
        --paper-material-elevation-2: {
          @apply --shadow-elevation-4dp;
        };
        --paper-material-elevation-3: {
          @apply --shadow-elevation-6dp;
        };
        --paper-material-elevation-4: {
          @apply --shadow-elevation-8dp;
        };
        --paper-material-elevation-5: {
          @apply --shadow-elevation-16dp;
        };
      }
      :host(.paper-material), .paper-material {
        @apply --paper-material;
      }
      :host(.paper-material[elevation="1"]), .paper-material[elevation="1"] {
        @apply --paper-material-elevation-1;
      }
      :host(.paper-material[elevation="2"]), .paper-material[elevation="2"] {
        @apply --paper-material-elevation-2;
      }
      :host(.paper-material[elevation="3"]), .paper-material[elevation="3"] {
        @apply --paper-material-elevation-3;
      }
      :host(.paper-material[elevation="4"]), .paper-material[elevation="4"] {
        @apply --paper-material-elevation-4;
      }
      :host(.paper-material[elevation="5"]), .paper-material[elevation="5"] {
        @apply --paper-material-elevation-5;
      }
    </style>
  </template>
</dom-module>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_icon_iron_icon_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_inky_focus_behavior_js__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);





const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-icon-button">
  <template strip-whitespace="">
    <style>
      :host {
        display: inline-block;
        position: relative;
        padding: 8px;
        outline: none;
        -webkit-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        cursor: pointer;
        z-index: 0;
        line-height: 1;

        width: 40px;
        height: 40px;

        /* NOTE: Both values are needed, since some phones require the value to be \`transparent\`. */
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-tap-highlight-color: transparent;

        /* Because of polymer/2558, this style has lower specificity than * */
        box-sizing: border-box !important;

        @apply --paper-icon-button;
      }

      :host #ink {
        color: var(--paper-icon-button-ink-color, var(--primary-text-color));
        opacity: 0.6;
      }

      :host([disabled]) {
        color: var(--paper-icon-button-disabled-text, var(--disabled-text-color));
        pointer-events: none;
        cursor: auto;

        @apply --paper-icon-button-disabled;
      }

      :host([hidden]) {
        display: none !important;
      }

      :host(:hover) {
        @apply --paper-icon-button-hover;
      }

      iron-icon {
        --iron-icon-width: 100%;
        --iron-icon-height: 100%;
      }
    </style>

    <iron-icon id="icon" src="[[src]]" icon="[[icon]]" alt\$="[[alt]]"></iron-icon>
  </template>

  
</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-icon-button',

  hostAttributes: {
    role: 'button',
    tabindex: '0'
  },

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_inky_focus_behavior_js__["a" /* PaperInkyFocusBehavior */]
  ],

  properties: {
    /**
     * The URL of an image for the icon. If the src property is specified,
     * the icon property should not be.
     */
    src: {
      type: String
    },

    /**
     * Specifies the icon name or index in the set of icons available in
     * the icon's icon set. If the icon property is specified,
     * the src property should not be.
     */
    icon: {
      type: String
    },

    /**
     * Specifies the alternate text for the button, for accessibility.
     */
    alt: {
      type: String,
      observer: "_altChanged"
    }
  },

  _altChanged: function(newValue, oldValue) {
    var label = this.getAttribute('aria-label');

    // Don't stomp over a user-set aria-label.
    if (!label || oldValue == label) {
      this.setAttribute('aria-label', newValue);
    }
  }
});


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_form_element_behavior_iron_form_element_behavior_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_input_iron_input_js__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_input_behavior_js__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__paper_input_char_counter_js__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__paper_input_container_js__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__paper_input_error_js__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__polymer_lib_elements_dom_module_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__polymer_polymer_element_js__ = __webpack_require__(5);










const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-input">
  <template>
    <style>
      :host {
        display: block;
      }

      :host([focused]) {
        outline: none;
      }

      :host([hidden]) {
        display: none !important;
      }

      input {
        position: relative; /* to make a stacking context */
        outline: none;
        box-shadow: none;
        padding: 0;
        width: 100%;
        max-width: 100%;
        background: transparent;
        border: none;
        color: var(--paper-input-container-input-color, var(--primary-text-color));
        -webkit-appearance: none;
        text-align: inherit;
        vertical-align: bottom;

        /* Firefox sets a min-width on the input, which can cause layout issues */
        min-width: 0;

        @apply --paper-font-subhead;
        @apply --paper-input-container-input;
      }

      input::-webkit-outer-spin-button,
      input::-webkit-inner-spin-button {
        @apply --paper-input-container-input-webkit-spinner;
      }

      input::-webkit-clear-button {
        @apply --paper-input-container-input-webkit-clear;
      }

      input::-webkit-input-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      input:-moz-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      input::-moz-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      input::-ms-clear {
        @apply --paper-input-container-ms-clear;
      }

      input:-ms-input-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      label {
        pointer-events: none;
      }
    </style>

    <paper-input-container id="container" no-label-float="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate\$="[[autoValidate]]" disabled\$="[[disabled]]" invalid="[[invalid]]">

      <slot name="prefix" slot="prefix"></slot>

      <label hidden\$="[[!label]]" aria-hidden="true" for="input" slot="label">[[label]]</label>

      <span id="template-placeholder"></span>

      <slot name="suffix" slot="suffix"></slot>

      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error aria-live="assertive" slot="add-on">[[errorMessage]]</paper-input-error>
      </template>

      <template is="dom-if" if="[[charCounter]]">
        <paper-input-char-counter slot="add-on"></paper-input-char-counter>
      </template>

    </paper-input-container>
  </template>

  <!-- This is a fresh new hell to make this element hybrid. Basically, in 2.0
    we lost is=, so the example same template can't be used with iron-input 1.0 and 2.0.
    Expect some conditional code (especially in the tests).
   -->
  <template id="v0">
    <input is="iron-input" id="input" slot="input" aria-labelledby\$="[[_ariaLabelledBy]]" aria-describedby\$="[[_ariaDescribedBy]]" disabled\$="[[disabled]]" title\$="[[title]]" bind-value="{{value}}" invalid="{{invalid}}" prevent-invalid-input="[[preventInvalidInput]]" allowed-pattern="[[allowedPattern]]" validator="[[validator]]" type\$="[[type]]" pattern\$="[[pattern]]" required\$="[[required]]" autocomplete\$="[[autocomplete]]" autofocus\$="[[autofocus]]" inputmode\$="[[inputmode]]" minlength\$="[[minlength]]" maxlength\$="[[maxlength]]" min\$="[[min]]" max\$="[[max]]" step\$="[[step]]" name\$="[[name]]" placeholder\$="[[placeholder]]" readonly\$="[[readonly]]" list\$="[[list]]" size\$="[[size]]" autocapitalize\$="[[autocapitalize]]" autocorrect\$="[[autocorrect]]" on-change="_onChange" tabindex\$="[[tabIndex]]" autosave\$="[[autosave]]" results\$="[[results]]" accept\$="[[accept]]" multiple\$="[[multiple]]">
  </template>

  <template id="v1">
    <!-- Need to bind maxlength so that the paper-input-char-counter works correctly -->
    <iron-input bind-value="{{value}}" id="input" slot="input" maxlength\$="[[maxlength]]" allowed-pattern="[[allowedPattern]]" invalid="{{invalid}}" validator="[[validator]]">
      <input id="nativeInput" aria-labelledby\$="[[_ariaLabelledBy]]" aria-describedby\$="[[_ariaDescribedBy]]" disabled\$="[[disabled]]" title\$="[[title]]" type\$="[[type]]" pattern\$="[[pattern]]" required\$="[[required]]" autocomplete\$="[[autocomplete]]" autofocus\$="[[autofocus]]" inputmode\$="[[inputmode]]" minlength\$="[[minlength]]" maxlength\$="[[maxlength]]" min\$="[[min]]" max\$="[[max]]" step\$="[[step]]" name\$="[[name]]" placeholder\$="[[placeholder]]" readonly\$="[[readonly]]" list\$="[[list]]" size\$="[[size]]" autocapitalize\$="[[autocapitalize]]" autocorrect\$="[[autocorrect]]" on-change="_onChange" tabindex\$="[[tabIndex]]" autosave\$="[[autosave]]" results\$="[[results]]" accept\$="[[accept]]" multiple\$="[[multiple]]">
    </iron-input>
  </template>

</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_7__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-input',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_3__paper_input_behavior_js__["a" /* PaperInputBehavior */],
    __WEBPACK_IMPORTED_MODULE_1__iron_form_element_behavior_iron_form_element_behavior_js__["a" /* IronFormElementBehavior */]
  ],

  beforeRegister: function() {
    // We need to tell which kind of of template to stamp based on
    // what kind of `iron-input` we got, but because of polyfills and
    // custom elements differences between v0 and v1, the safest bet is
    // to check a particular method we know the iron-input#2.x can have.
    // If it doesn't have it, then it's an iron-input#1.x.
    var ironInput = document.createElement('iron-input');
    var version = typeof ironInput._initSlottedInput == 'function' ? 'v1' : 'v0';
    var template = __WEBPACK_IMPORTED_MODULE_8__polymer_lib_elements_dom_module_js__["a" /* DomModule */].import('paper-input', 'template');
    var inputTemplate = __WEBPACK_IMPORTED_MODULE_8__polymer_lib_elements_dom_module_js__["a" /* DomModule */].import('paper-input', 'template#' + version);
    var inputPlaceholder = template.content.querySelector('#template-placeholder');
    if (inputPlaceholder) {
      inputPlaceholder.parentNode.replaceChild(inputTemplate.content, inputPlaceholder);
    }
    // else it's already been processed, probably in superclass
  },

  /**
   * Returns a reference to the focusable element. Overridden from PaperInputBehavior
   * to correctly focus the native input.
   */
  get _focusableElement() {
    return __WEBPACK_IMPORTED_MODULE_9__polymer_polymer_element_js__["a" /* Element */] ? this.inputElement._inputElement : this.inputElement;
  },

  // Note: This event is only available in the 1.0 version of this element.
  // In 2.0, the functionality of `_onIronInputReady` is done in
  // PaperInputBehavior::attached.
  listeners: {
    'iron-input-ready': '_onIronInputReady'
  },

  _onIronInputReady: function() {
    if (this.inputElement &&
        this._typesThatHaveText.indexOf(this.$.nativeInput.type) !== -1) {
      this.alwaysFloatLabel = true;
    }

    // Only validate when attached if the input already has a value.
    if (!!this.inputElement.bindValue) {
      this.$.container._handleValueAndAutoValidate(this.inputElement);
    }
  },
});


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_announcer_iron_a11y_announcer_js__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_validatable_behavior_iron_validatable_behavior_js__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
      }
    </style>
    <slot id="content"></slot>
`,

  is: 'iron-input',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__iron_validatable_behavior_iron_validatable_behavior_js__["a" /* IronValidatableBehavior */]
  ],

  /**
   * Fired whenever `validate()` is called.
   *
   * @event iron-input-validate
   */

  properties: {

    /**
     * Use this property instead of `value` for two-way data binding, or to
     * set a default value for the input. **Do not** use the distributed
     * input's `value` property to set a default value.
     */
    bindValue: {
      type: String
    },

    /**
     * Computed property that echoes `bindValue` (mostly used for Polymer 1.0
     * backcompatibility, if you were one-way binding to the Polymer 1.0
     * `input is="iron-input"` value attribute).
     */
    value: {
      computed: '_computeValue(bindValue)'
    },

    /**
     * Regex-like list of characters allowed as input; all characters not in the list
     * will be rejected. The recommended format should be a list of allowed characters,
     * for example, `[a-zA-Z0-9.+-!;:]`.
     *
     * This pattern represents the allowed characters for the field; as the user inputs text,
     * each individual character will be checked against the pattern (rather than checking
     * the entire value as a whole). If a character is not a match, it will be rejected.
     *
     * Pasted input will have each character checked individually; if any character
     * doesn't match `allowedPattern`, the entire pasted string will be rejected.
     *
     * Note: if you were using `iron-input` in 1.0, you were also required to
     * set `prevent-invalid-input`. This is no longer needed as of Polymer 2.0,
     * and will be set automatically for you if an `allowedPattern` is provided.
     *
     */
    allowedPattern: {
      type: String
    },

    /**
     * Set to true to auto-validate the input value as you type.
     */
    autoValidate: {
      type: Boolean,
      value: false
    }
  },

  observers: [
    '_bindValueChanged(bindValue, _inputElement)'
  ],

  listeners: {
    'input': '_onInput',
    'keypress': '_onKeypress'
  },

  created: function() {
    __WEBPACK_IMPORTED_MODULE_1__iron_a11y_announcer_iron_a11y_announcer_js__["a" /* IronA11yAnnouncer */].requestAvailability();
    this._previousValidInput = '';
    this._patternAlreadyChecked = false;
  },

  attached: function() {
    // If the input is added at a later time, update the internal reference.
    this._observer = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).observeNodes(function(info) {
      this._initSlottedInput();
    }.bind(this));
  },

  detached: function() {
    if (this._observer) {
      Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).unobserveNodes(this._observer);
      this._observer = null;
    }
  },

  /**
   * Returns the distributed <input> element.
   */
  get inputElement () {
    return this._inputElement;
  },

  _initSlottedInput: function() {
    this._inputElement = this.getEffectiveChildren()[0];

    if (this.inputElement && this.inputElement.value) {
      this.bindValue = this.inputElement.value;
    }

    this.fire('iron-input-ready');
  },

  get _patternRegExp() {
    var pattern;
    if (this.allowedPattern) {
      pattern = new RegExp(this.allowedPattern);
    } else {
      switch (this.type) {
        case 'number':
          pattern = /[0-9.,e-]/;
          break;
      }
    }
    return pattern;
  },

  /**
   * @suppress {checkTypes}
   */
  _bindValueChanged: function(bindValue, inputElement) {
    // The observer could have run before attached() when we have actually initialized
    // this property.
    if (!inputElement) {
      return;
    }

    if (bindValue === undefined) {
      inputElement.value = null;
    } else if (bindValue !== inputElement.value){
      this.inputElement.value = bindValue;
    }

    if (this.autoValidate) {
      this.validate();
    }

    // manually notify because we don't want to notify until after setting value
    this.fire('bind-value-changed', {value: bindValue});
  },

  _onInput: function() {
    // Need to validate each of the characters pasted if they haven't
    // been validated inside `_onKeypress` already.
    if (this.allowedPattern && !this._patternAlreadyChecked) {
      var valid = this._checkPatternValidity();
      if (!valid) {
        this._announceInvalidCharacter('Invalid string of characters not entered.');
        this.inputElement.value = this._previousValidInput;
      }
    }
    this.bindValue = this._previousValidInput = this.inputElement.value;
    this._patternAlreadyChecked = false;
  },

  _isPrintable: function(event) {
    // What a control/printable character is varies wildly based on the browser.
    // - most control characters (arrows, backspace) do not send a `keypress` event
    //   in Chrome, but the *do* on Firefox
    // - in Firefox, when they do send a `keypress` event, control chars have
    //   a charCode = 0, keyCode = xx (for ex. 40 for down arrow)
    // - printable characters always send a keypress event.
    // - in Firefox, printable chars always have a keyCode = 0. In Chrome, the keyCode
    //   always matches the charCode.
    // None of this makes any sense.

    // For these keys, ASCII code == browser keycode.
    var anyNonPrintable =
      (event.keyCode == 8)   ||  // backspace
      (event.keyCode == 9)   ||  // tab
      (event.keyCode == 13)  ||  // enter
      (event.keyCode == 27);     // escape

    // For these keys, make sure it's a browser keycode and not an ASCII code.
    var mozNonPrintable =
      (event.keyCode == 19)  ||  // pause
      (event.keyCode == 20)  ||  // caps lock
      (event.keyCode == 45)  ||  // insert
      (event.keyCode == 46)  ||  // delete
      (event.keyCode == 144) ||  // num lock
      (event.keyCode == 145) ||  // scroll lock
      (event.keyCode > 32 && event.keyCode < 41)   || // page up/down, end, home, arrows
      (event.keyCode > 111 && event.keyCode < 124); // fn keys

    return !anyNonPrintable && !(event.charCode == 0 && mozNonPrintable);
  },

  _onKeypress: function(event) {
    if (!this.allowedPattern && this.type !== 'number') {
      return;
    }
    var regexp = this._patternRegExp;
    if (!regexp) {
      return;
    }

    // Handle special keys and backspace
    if (event.metaKey || event.ctrlKey || event.altKey) {
      return;
    }

    // Check the pattern either here or in `_onInput`, but not in both.
    this._patternAlreadyChecked = true;

    var thisChar = String.fromCharCode(event.charCode);
    if (this._isPrintable(event) && !regexp.test(thisChar)) {
      event.preventDefault();
      this._announceInvalidCharacter('Invalid character ' + thisChar + ' not entered.');
    }
  },

  _checkPatternValidity: function() {
    var regexp = this._patternRegExp;
    if (!regexp) {
      return true;
    }
    for (var i = 0; i < this.inputElement.value.length; i++) {
      if (!regexp.test(this.inputElement.value[i])) {
        return false;
      }
    }
    return true;
  },

  /**
   * Returns true if `value` is valid. The validator provided in `validator` will be used first,
   * then any constraints.
   * @return {boolean} True if the value is valid.
   */
  validate: function() {
    if (!this.inputElement) {
      this.invalid = false;
      return true;
    }

    // Use the nested input's native validity.
    var valid =  this.inputElement.checkValidity();

    // Only do extra checking if the browser thought this was valid.
    if (valid) {
      // Empty, required input is invalid
      if (this.required && this.bindValue === '') {
        valid = false;
      } else if (this.hasValidator()) {
        valid = __WEBPACK_IMPORTED_MODULE_2__iron_validatable_behavior_iron_validatable_behavior_js__["a" /* IronValidatableBehavior */].validate.call(this, this.bindValue);
      }
    }

    this.invalid = !valid;
    this.fire('iron-input-validate');
    return valid;
  },

  _announceInvalidCharacter: function(message) {
    this.fire('iron-announce', { text: message });
  },

  _computeValue: function(bindValue) {
    return bindValue;
  }
});


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);



const IronA11yAnnouncer = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
        position: fixed;
        clip: rect(0px,0px,0px,0px);
      }
    </style>
    <div aria-live\$="[[mode]]">[[_text]]</div>
`,

  is: 'iron-a11y-announcer',

  properties: {

    /**
     * The value of mode is used to set the `aria-live` attribute
     * for the element that will be announced. Valid values are: `off`,
     * `polite` and `assertive`.
     */
    mode: {
      type: String,
      value: 'polite'
    },

    _text: {
      type: String,
      value: ''
    }
  },

  created: function() {
    if (!IronA11yAnnouncer.instance) {
      IronA11yAnnouncer.instance = this;
    }

    document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
  },

  /**
   * Cause a text string to be announced by screen readers.
   *
   * @param {string} text The text that should be announced.
   */
  announce: function(text) {
    this._text = '';
    this.async(function() {
      this._text = text;
    }, 100);
  },

  _onIronAnnounce: function(event) {
    if (event.detail && event.detail.text) {
      this.announce(event.detail.text);
    }
  }
});
/* harmony export (immutable) */ __webpack_exports__["a"] = IronA11yAnnouncer;


IronA11yAnnouncer.instance = null;

IronA11yAnnouncer.requestAvailability = function() {
  if (!IronA11yAnnouncer.instance) {
    IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
  }

  document.body.appendChild(IronA11yAnnouncer.instance);
};


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_control_state_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_polymer_element_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





const PaperInputHelper = {};
/* unused harmony export PaperInputHelper */

PaperInputHelper.NextLabelID = 1;
PaperInputHelper.NextAddonID = 1;

const PaperInputBehaviorImpl = {

  properties: {
    /**
     * Fired when the input changes due to user interaction.
     *
     * @event change
     */

    /**
     * The label for this input. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * `<label>`'s content and `hidden` property, e.g.
     * `<label hidden$="[[!label]]">[[label]]</label>` in your `template`
     */
    label: {
      type: String
    },

    /**
     * The value for this input. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<iron-input>`'s `bindValue`
     * property, or the value property of your input that is `notify:true`.
     */
    value: {
      notify: true,
      type: String
    },

    /**
     * Set to true to disable this input. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * both the `<paper-input-container>`'s and the input's `disabled` property.
     */
    disabled: {
      type: Boolean,
      value: false
    },

    /**
     * Returns true if the value is invalid. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to both the
     * `<paper-input-container>`'s and the input's `invalid` property.
     *
     * If `autoValidate` is true, the `invalid` attribute is managed automatically,
     * which can clobber attempts to manage it manually.
     */
    invalid: {
      type: Boolean,
      value: false,
      notify: true
    },

    /**
     * Set this to specify the pattern allowed by `preventInvalidInput`. If
     * you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `allowedPattern`
     * property.
     */
    allowedPattern: {
      type: String
    },

    /**
     * The type of the input. The supported types are `text`, `number` and `password`.
     * If you're using PaperInputBehavior to implement your own paper-input-like element,
     * bind this to the `<input is="iron-input">`'s `type` property.
     */
    type: {
      type: String
    },

    /**
     * The datalist of the input (if any). This should match the id of an existing `<datalist>`.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `list` property.
     */
    list: {
      type: String
    },

    /**
     * A pattern to validate the `input` with. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<input is="iron-input">`'s `pattern` property.
     */
    pattern: {
      type: String
    },

    /**
     * Set to true to mark the input as required. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<input is="iron-input">`'s `required` property.
     */
    required: {
      type: Boolean,
      value: false
    },

    /**
     * The error message to display when the input is invalid. If you're using
     * PaperInputBehavior to implement your own paper-input-like element,
     * bind this to the `<paper-input-error>`'s content, if using.
     */
    errorMessage: {
      type: String
    },

    /**
     * Set to true to show a character counter.
     */
    charCounter: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to disable the floating label. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<paper-input-container>`'s `noLabelFloat` property.
     */
    noLabelFloat: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to always float the label. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<paper-input-container>`'s `alwaysFloatLabel` property.
     */
    alwaysFloatLabel: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to auto-validate the input value. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<paper-input-container>`'s `autoValidate` property.
     */
    autoValidate: {
      type: Boolean,
      value: false
    },

    /**
     * Name of the validator to use. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<input is="iron-input">`'s `validator` property.
     */
    validator: {
      type: String
    },

    // HTMLInputElement attributes for binding if needed

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autocomplete` property.
     */
    autocomplete: {
      type: String,
      value: 'off'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autofocus` property.
     */
    autofocus: {
      type: Boolean,
      observer: '_autofocusChanged'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `inputmode` property.
     */
    inputmode: {
      type: String
    },

    /**
     * The minimum length of the input value.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `minlength` property.
     */
    minlength: {
      type: Number
    },

    /**
     * The maximum length of the input value.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `maxlength` property.
     */
    maxlength: {
      type: Number
    },

    /**
     * The minimum (numeric or date-time) input value.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `min` property.
     */
    min: {
      type: String
    },

    /**
     * The maximum (numeric or date-time) input value.
     * Can be a String (e.g. `"2000-01-01"`) or a Number (e.g. `2`).
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `max` property.
     */
    max: {
      type: String
    },

    /**
     * Limits the numeric or date-time increments.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `step` property.
     */
    step: {
      type: String
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `name` property.
     */
    name: {
      type: String
    },

    /**
     * A placeholder string in addition to the label. If this is set, the label will always float.
     */
    placeholder: {
      type: String,
      // need to set a default so _computeAlwaysFloatLabel is run
      value: ''
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `readonly` property.
     */
    readonly: {
      type: Boolean,
      value: false
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `size` property.
     */
    size: {
      type: Number
    },

    // Nonstandard attributes for binding if needed

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autocapitalize` property.
     */
    autocapitalize: {
      type: String,
      value: 'none'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autocorrect` property.
     */
    autocorrect: {
      type: String,
      value: 'off'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autosave` property,
     * used with type=search.
     */
    autosave: {
      type: String
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `results` property,
     * used with type=search.
     */
    results: {
      type: Number
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `accept` property,
     * used with type=file.
     */
    accept: {
      type: String
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the`<input is="iron-input">`'s `multiple` property,
     * used with type=file.
     */
    multiple: {
      type: Boolean
    },

    _ariaDescribedBy: {
      type: String,
      value: ''
    },

    _ariaLabelledBy: {
      type: String,
      value: ''
    }

  },

  listeners: {
    'addon-attached': '_onAddonAttached',
  },

  keyBindings: {
    'shift+tab:keydown': '_onShiftTabDown'
  },

  hostAttributes: {
    tabindex: 0
  },

  /**
   * Returns a reference to the input element.
   */
  get inputElement() {
    return this.$.input;
  },

  /**
   * Returns a reference to the focusable element.
   */
  get _focusableElement() {
    return this.inputElement;
  },

  created: function() {
    // These types have some default placeholder text; overlapping
    // the label on top of it looks terrible. Auto-float the label in this case.
    this._typesThatHaveText = ["date", "datetime", "datetime-local", "month",
        "time", "week", "file"];
  },

  attached: function() {
    this._updateAriaLabelledBy();

    // In the 2.0 version of the element, this is handled in `onIronInputReady`,
    // i.e. after the native input has finished distributing. In the 1.0 version,
    // the input is in the shadow tree, so it's already available.
    if (!__WEBPACK_IMPORTED_MODULE_3__polymer_polymer_element_js__["a" /* Element */] && this.inputElement &&
        this._typesThatHaveText.indexOf(this.inputElement.type) !== -1) {
      this.alwaysFloatLabel = true;
    }
  },

  _appendStringWithSpace: function(str, more) {
    if (str) {
      str = str + ' ' + more;
    } else {
      str = more;
    }
    return str;
  },

  _onAddonAttached: function(event) {
    var target = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).rootTarget;
    if (target.id) {
      this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
    } else {
      var id = 'paper-input-add-on-' + PaperInputHelper.NextAddonID++;
      target.id = id;
      this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
    }
  },

  /**
   * Validates the input element and sets an error style if needed.
   *
   * @return {boolean}
   */
  validate: function() {
    return this.inputElement.validate();
  },

  /**
   * Forward focus to inputElement. Overriden from IronControlState.
   */
  _focusBlurHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_control_state_js__["a" /* IronControlState */]._focusBlurHandler.call(this, event);

    // Forward the focus to the nested input.
    if (this.focused && !this._shiftTabPressed && this._focusableElement) {
      this._focusableElement.focus();
    }
  },

  /**
   * Handler that is called when a shift+tab keypress is detected by the menu.
   *
   * @param {CustomEvent} event A key combination event.
   */
  _onShiftTabDown: function(event) {
    var oldTabIndex = this.getAttribute('tabindex');
    this._shiftTabPressed = true;
    this.setAttribute('tabindex', '-1');
    this.async(function() {
      this.setAttribute('tabindex', oldTabIndex);
      this._shiftTabPressed = false;
    }, 1);
  },

  /**
   * If `autoValidate` is true, then validates the element.
   */
  _handleAutoValidate: function() {
    if (this.autoValidate)
      this.validate();
  },

  /**
   * Restores the cursor to its original position after updating the value.
   * @param {string} newValue The value that should be saved.
   */
  updateValueAndPreserveCaret: function(newValue) {
    // Not all elements might have selection, and even if they have the
    // right properties, accessing them might throw an exception (like for
    // <input type=number>)
    try {
      var start = this.inputElement.selectionStart;
      this.value = newValue;

      // The cursor automatically jumps to the end after re-setting the value,
      // so restore it to its original position.
      this.inputElement.selectionStart = start;
      this.inputElement.selectionEnd = start;
    } catch (e) {
      // Just set the value and give up on the caret.
      this.value = newValue;
    }
  },

  _computeAlwaysFloatLabel: function(alwaysFloatLabel, placeholder) {
    return placeholder || alwaysFloatLabel;
  },

  _updateAriaLabelledBy: function() {
    var label = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.root).querySelector('label');
    if (!label) {
      this._ariaLabelledBy = '';
      return;
    }
    var labelledBy;
    if (label.id) {
      labelledBy = label.id;
    } else {
      labelledBy = 'paper-input-label-' + PaperInputHelper.NextLabelID++;
      label.id = labelledBy;
    }
    this._ariaLabelledBy = labelledBy;
  },

  _onChange:function(event) {
    // In the Shadow DOM, the `change` event is not leaked into the
    // ancestor tree, so we must do this manually.
    // See https://w3c.github.io/webcomponents/spec/shadow/#events-that-are-not-leaked-into-ancestor-trees.
    if (this.shadowRoot) {
      this.fire(event.type, {sourceEvent: event}, {
        node: this,
        bubbles: event.bubbles,
        cancelable: event.cancelable
      });
    }
  },

  _autofocusChanged: function() {
    // Firefox doesn't respect the autofocus attribute if it's applied after
    // the page is loaded (Chrome/WebKit do respect it), preventing an
    // autofocus attribute specified in markup from taking effect when the
    // element is upgraded. As a workaround, if the autofocus property is set,
    // and the focus hasn't already been moved elsewhere, we take focus.
    if (this.autofocus && this._focusableElement) {

      // In IE 11, the default document.activeElement can be the page's
      // outermost html element, but there are also cases (under the
      // polyfill?) in which the activeElement is not a real HTMLElement, but
      // just a plain object. We identify the latter case as having no valid
      // activeElement.
      var activeElement = document.activeElement;
      var isActiveElementValid = activeElement instanceof HTMLElement;

      // Has some other element has already taken the focus?
      var isSomeElementActive = isActiveElementValid &&
          activeElement !== document.body &&
          activeElement !== document.documentElement; /* IE 11 */
      if (!isSomeElementActive) {
        // No specific element has taken the focus yet, so we can take it.
        this._focusableElement.focus();
      }
    }
  }
};
/* unused harmony export PaperInputBehaviorImpl */


const PaperInputBehavior = [
  __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_control_state_js__["a" /* IronControlState */],
  __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */],
  PaperInputBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperInputBehavior;



/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_input_addon_behavior_js__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);




Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
        float: right;

        @apply --paper-font-caption;
        @apply --paper-input-char-counter;
      }

      :host([hidden]) {
        display: none !important;
      }

      :host-context([dir="rtl"]) {
        float: left;
      }
    </style>

    <span>[[_charCounterStr]]</span>
`,

  is: 'paper-input-char-counter',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_input_addon_behavior_js__["a" /* PaperInputAddonBehavior */]
  ],

  properties: {
    _charCounterStr: {
      type: String,
      value: '0'
    }
  },

  /**
   * This overrides the update function in PaperInputAddonBehavior.
   * @param {{
   *   inputElement: (Element|undefined),
   *   value: (string|undefined),
   *   invalid: boolean
   * }} state -
   *     inputElement: The input element.
   *     value: The input value.
   *     invalid: True if the input value is invalid.
   */
  update: function(state) {
    if (!state.inputElement) {
      return;
    }

    state.value = state.value || '';

    var counter = state.value.toString().length.toString();

    if (state.inputElement.hasAttribute('maxlength')) {
      counter += '/' + state.inputElement.getAttribute('maxlength');
    }

    this._charCounterStr = counter;
  }
});


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_lib_utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);







Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: block;
        padding: 8px 0;

        --paper-input-container-shared-input-style: {
          position: relative; /* to make a stacking context */
          outline: none;
          box-shadow: none;
          padding: 0;
          width: 100%;
          max-width: 100%;
          background: transparent;
          border: none;
          color: var(--paper-input-container-input-color, var(--primary-text-color));
          -webkit-appearance: none;
          text-align: inherit;
          vertical-align: bottom;

          @apply --paper-font-subhead;
        };

        @apply --paper-input-container;
      }

      :host([inline]) {
        display: inline-block;
      }

      :host([disabled]) {
        pointer-events: none;
        opacity: 0.33;

        @apply --paper-input-container-disabled;
      }

      :host([hidden]) {
        display: none !important;
      }

      [hidden] {
        display: none !important;
      }

      .floated-label-placeholder {
        @apply --paper-font-caption;
      }

      .underline {
        height: 2px;
        position: relative;
      }

      .focused-line {
        @apply --layout-fit;
        border-bottom: 2px solid var(--paper-input-container-focus-color, var(--primary-color));

        -webkit-transform-origin: center center;
        transform-origin: center center;
        -webkit-transform: scale3d(0,1,1);
        transform: scale3d(0,1,1);

        @apply --paper-input-container-underline-focus;
      }

      .underline.is-highlighted .focused-line {
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply --paper-transition-easing;
      }

      .underline.is-invalid .focused-line {
        border-color: var(--paper-input-container-invalid-color, var(--error-color));
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply --paper-transition-easing;
      }

      .unfocused-line {
        @apply --layout-fit;
        border-bottom: 1px solid var(--paper-input-container-color, var(--secondary-text-color));
        @apply --paper-input-container-underline;
      }

      :host([disabled]) .unfocused-line {
        border-bottom: 1px dashed;
        border-color: var(--paper-input-container-color, var(--secondary-text-color));
        @apply --paper-input-container-underline-disabled;
      }

      .input-wrapper {
        @apply --layout-horizontal;
        @apply --layout-center;
        position: relative;
      }

      .input-content {
        @apply --layout-flex-auto;
        @apply --layout-relative;
        max-width: 100%;
      }

      .input-content ::slotted(label),
      .input-content ::slotted(.paper-input-label) {
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
        width: 100%;
        font: inherit;
        color: var(--paper-input-container-color, var(--secondary-text-color));
        -webkit-transition: -webkit-transform 0.25s, width 0.25s;
        transition: transform 0.25s, width 0.25s;
        -webkit-transform-origin: left top;
        transform-origin: left top;

        @apply --paper-font-common-nowrap;
        @apply --paper-font-subhead;
        @apply --paper-input-container-label;
        @apply --paper-transition-easing;
      }

      .input-content.label-is-floating ::slotted(label),
      .input-content.label-is-floating ::slotted(.paper-input-label) {
        -webkit-transform: translateY(-75%) scale(0.75);
        transform: translateY(-75%) scale(0.75);

        /* Since we scale to 75/100 of the size, we actually have 100/75 of the
        original space now available */
        width: 133%;

        @apply --paper-input-container-label-floating;
      }

      :host-context([dir="rtl"]) .input-content.label-is-floating ::slotted(label),
      :host-context([dir="rtl"]) .input-content.label-is-floating ::slotted(.paper-input-label) {
        /* TODO(noms): Figure out why leaving the width at 133% before the animation
         * actually makes
         * it wider on the right side, not left side, as you would expect in RTL */
        width: 100%;
        -webkit-transform-origin: right top;
        transform-origin: right top;
      }

      .input-content.label-is-highlighted ::slotted(label),
      .input-content.label-is-highlighted ::slotted(.paper-input-label) {
        color: var(--paper-input-container-focus-color, var(--primary-color));

        @apply --paper-input-container-label-focus;
      }

      .input-content.is-invalid ::slotted(label),
      .input-content.is-invalid ::slotted(.paper-input-label) {
        color: var(--paper-input-container-invalid-color, var(--error-color));
      }

      .input-content.label-is-hidden ::slotted(label),
      .input-content.label-is-hidden ::slotted(.paper-input-label) {
        visibility: hidden;
      }

      .input-content ::slotted(iron-input) {
        @apply --paper-input-container-shared-input-style;
      }
      
      .input-content ::slotted(input),
      .input-content ::slotted(textarea),
      .input-content ::slotted(iron-autogrow-textarea),
      .input-content ::slotted(.paper-input-input) {
        @apply --paper-input-container-shared-input-style;
        @apply --paper-input-container-input;
      }

      .input-content ::slotted(input)::-webkit-outer-spin-button,
      .input-content ::slotted(input)::-webkit-inner-spin-button {
        @apply --paper-input-container-input-webkit-spinner;
      }
      
      .input-content.focused ::slotted(input),
      .input-content.focused ::slotted(textarea),
      .input-content.focused ::slotted(iron-autogrow-textarea),
      .input-content.focused ::slotted(.paper-input-input) {
        @apply --paper-input-container-input-focus;
      }

      .input-content.is-invalid ::slotted(input),
      .input-content.is-invalid ::slotted(textarea),
      .input-content.is-invalid ::slotted(iron-autogrow-textarea),
      .input-content.is-invalid ::slotted(.paper-input-input) {
        @apply --paper-input-container-input-invalid;
      }
      
      .prefix ::slotted(*) {
        display: inline-block;
        @apply --paper-font-subhead;
        @apply --layout-flex-none;
        @apply --paper-input-prefix;
      }

      .suffix ::slotted(*) {
        display: inline-block;
        @apply --paper-font-subhead;
        @apply --layout-flex-none;

        @apply --paper-input-suffix;
      }

      /* Firefox sets a min-width on the input, which can cause layout issues */
      .input-content ::slotted(input) {
        min-width: 0;
      }

      .input-content ::slotted(textarea) {
        resize: none;
      }

      .add-on-content {
        position: relative;
      }

      .add-on-content.is-invalid ::slotted(*) {
        color: var(--paper-input-container-invalid-color, var(--error-color));
      }

      .add-on-content.is-highlighted ::slotted(*) {
        color: var(--paper-input-container-focus-color, var(--primary-color));
      }
    </style>

    <div class="floated-label-placeholder" aria-hidden="true" hidden="[[noLabelFloat]]">&nbsp;</div>

    <div class="input-wrapper">
      <span class="prefix"><slot name="prefix"></slot></span>

      <div class\$="[[_computeInputContentClass(noLabelFloat,alwaysFloatLabel,focused,invalid,_inputHasContent)]]" id="labelAndInputContainer">
        <slot name="label"></slot>
        <slot name="input"></slot>
      </div>

      <span class="suffix"><slot name="suffix"></slot></span>
    </div>

    <div class\$="[[_computeUnderlineClass(focused,invalid)]]">
      <div class="unfocused-line"></div>
      <div class="focused-line"></div>
    </div>

    <div class\$="[[_computeAddOnContentClass(focused,invalid)]]">
      <slot name="add-on"></slot>
    </div>
`,

  is: 'paper-input-container',

  properties: {
    /**
     * Set to true to disable the floating label. The label disappears when the input value is
     * not null.
     */
    noLabelFloat: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to always float the floating label.
     */
    alwaysFloatLabel: {
      type: Boolean,
      value: false
    },

    /**
     * The attribute to listen for value changes on.
     */
    attrForValue: {
      type: String,
      value: 'bind-value'
    },

    /**
     * Set to true to auto-validate the input value when it changes.
     */
    autoValidate: {
      type: Boolean,
      value: false
    },

    /**
     * True if the input is invalid. This property is set automatically when the input value
     * changes if auto-validating, or when the `iron-input-validate` event is heard from a child.
     */
    invalid: {
      observer: '_invalidChanged',
      type: Boolean,
      value: false
    },

    /**
     * True if the input has focus.
     */
    focused: {
      readOnly: true,
      type: Boolean,
      value: false,
      notify: true
    },

    _addons: {
      type: Array
      // do not set a default value here intentionally - it will be initialized lazily when a
      // distributed child is attached, which may occur before configuration for this element
      // in polyfill.
    },

    _inputHasContent: {
      type: Boolean,
      value: false
    },

    _inputSelector: {
      type: String,
      value: 'input,iron-input,textarea,.paper-input-input'
    },

    _boundOnFocus: {
      type: Function,
      value: function() {
        return this._onFocus.bind(this);
      }
    },

    _boundOnBlur: {
      type: Function,
      value: function() {
        return this._onBlur.bind(this);
      }
    },

    _boundOnInput: {
      type: Function,
      value: function() {
        return this._onInput.bind(this);
      }
    },

    _boundValueChanged: {
      type: Function,
      value: function() {
        return this._onValueChanged.bind(this);
      }
    }
  },

  listeners: {
    'addon-attached': '_onAddonAttached',
    'iron-input-validate': '_onIronInputValidate'
  },

  get _valueChangedEvent() {
    return this.attrForValue + '-changed';
  },

  get _propertyForValue() {
    return Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_utils_case_map_js__["dashToCamelCase"])(this.attrForValue);
  },

  get _inputElement() {
    return Object(__WEBPACK_IMPORTED_MODULE_6__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).querySelector(this._inputSelector);
  },

  get _inputElementValue() {
    return this._inputElement[this._propertyForValue] || this._inputElement.value;
  },

  ready: function() {
    if (!this._addons) {
      this._addons = [];
    }
    this.addEventListener('focus', this._boundOnFocus, true);
    this.addEventListener('blur', this._boundOnBlur, true);
  },

  attached: function() {
    if (this.attrForValue) {
      this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged);
    } else {
      this.addEventListener('input', this._onInput);
    }

    // Only validate when attached if the input already has a value.
    if (this._inputElementValue && this._inputElementValue != '') {
      this._handleValueAndAutoValidate(this._inputElement);
    } else {
      this._handleValue(this._inputElement);
    }
  },

  _onAddonAttached: function(event) {
    if (!this._addons) {
      this._addons = [];
    }
    var target = event.target;
    if (this._addons.indexOf(target) === -1) {
      this._addons.push(target);
      if (this.isAttached) {
        this._handleValue(this._inputElement);
      }
    }
  },

  _onFocus: function() {
    this._setFocused(true);
  },

  _onBlur: function() {
    this._setFocused(false);
    this._handleValueAndAutoValidate(this._inputElement);
  },

  _onInput: function(event) {
    this._handleValueAndAutoValidate(event.target);
  },

  _onValueChanged: function(event) {
    var input = event.target;

    // Problem: if the input is required but has no text entered, we should
    // only validate it on blur (so that an empty form doesn't come up red
    // immediately; however, in this handler, we don't know whether this is
    // the booting up value or a value in the future. I am assuming that the
    // case  we care about manifests itself when the value is undefined.
    // If this causes future problems, we need to do something like track whether
    // the iron-input-ready event has fired, and this handler came before that.

    if (input.value === undefined) {
      return;
    }

    this._handleValueAndAutoValidate(event.target);
  },

  _handleValue: function(inputElement) {
    var value = this._inputElementValue;

    // type="number" hack needed because this.value is empty until it's valid
    if (value || value === 0 || (inputElement.type === 'number' && !inputElement.checkValidity())) {
      this._inputHasContent = true;
    } else {
      this._inputHasContent = false;
    }

    this.updateAddons({
      inputElement: inputElement,
      value: value,
      invalid: this.invalid
    });
  },

  _handleValueAndAutoValidate: function(inputElement) {
    if (this.autoValidate && inputElement) {
      var valid;

      if (inputElement.validate) {
        valid = inputElement.validate(this._inputElementValue);
      } else {
        valid = inputElement.checkValidity();
      }
      this.invalid = !valid;
    }

    // Call this last to notify the add-ons.
    this._handleValue(inputElement);
  },

  _onIronInputValidate: function(event) {
    this.invalid = this._inputElement.invalid;
  },

  _invalidChanged: function() {
    if (this._addons) {
      this.updateAddons({invalid: this.invalid});
    }
  },

  /**
   * Call this to update the state of add-ons.
   * @param {Object} state Add-on state.
   */
  updateAddons: function(state) {
    for (var addon, index = 0; addon = this._addons[index]; index++) {
      addon.update(state);
    }
  },

  _computeInputContentClass: function(noLabelFloat, alwaysFloatLabel, focused, invalid, _inputHasContent) {
    var cls = 'input-content';
    if (!noLabelFloat) {
      var label = this.querySelector('label');

      if (alwaysFloatLabel || _inputHasContent) {
        cls += ' label-is-floating';
        // If the label is floating, ignore any offsets that may have been
        // applied from a prefix element.
        this.$.labelAndInputContainer.style.position = 'static';

        if (invalid) {
          cls += ' is-invalid';
        } else if (focused) {
          cls += " label-is-highlighted";
        }
      } else {
        // When the label is not floating, it should overlap the input element.
        if (label) {
          this.$.labelAndInputContainer.style.position = 'relative';
        }
        if (invalid) {
          cls += ' is-invalid';
        }
      }
    } else {
      if (_inputHasContent) {
        cls += ' label-is-hidden';
      }
      if (invalid) {
        cls += ' is-invalid';
      }
    }
    if (focused) {
      cls += ' focused';
    }
    return cls;
  },

  _computeUnderlineClass: function(focused, invalid) {
    var cls = 'underline';
    if (invalid) {
      cls += ' is-invalid';
    } else if (focused) {
      cls += ' is-highlighted'
    }
    return cls;
  },

  _computeAddOnContentClass: function(focused, invalid) {
    var cls = 'add-on-content';
    if (invalid) {
      cls += ' is-invalid';
    } else if (focused) {
      cls += ' is-highlighted'
    }
    return cls;
  }
});


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_input_addon_behavior_js__ = __webpack_require__(50);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);





Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
        visibility: hidden;

        color: var(--paper-input-container-invalid-color, var(--error-color));

        @apply --paper-font-caption;
        @apply --paper-input-error;
        position: absolute;
        left:0;
        right:0;
      }

      :host([invalid]) {
        visibility: visible;
      };
    </style>

    <slot></slot>
`,

  is: 'paper-input-error',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_3__paper_input_addon_behavior_js__["a" /* PaperInputAddonBehavior */]
  ],

  properties: {
    /**
     * True if the error is showing.
     */
    invalid: {
      readOnly: true,
      reflectToAttribute: true,
      type: Boolean
    }
  },

  /**
   * This overrides the update function in PaperInputAddonBehavior.
   * @param {{
   *   inputElement: (Element|undefined),
   *   value: (string|undefined),
   *   invalid: boolean
   * }} state -
   *     inputElement: The input element.
   *     value: The input value.
   *     invalid: True if the input value is invalid.
   */
  update: function(state) {
    this._setInvalid(state.invalid);
  }
});


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_checked_element_behavior_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_utils_render_status_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__paper_behaviors_paper_inky_focus_behavior_js__ = __webpack_require__(33);






const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-checkbox">
  <template strip-whitespace="">
    <style>
      :host {
        display: inline-block;
        white-space: nowrap;
        cursor: pointer;
        --calculated-paper-checkbox-size: var(--paper-checkbox-size, 18px);
        /* -1px is a sentinel for the default and is replaced in \`attached\`. */
        --calculated-paper-checkbox-ink-size: var(--paper-checkbox-ink-size, -1px);
        @apply --paper-font-common-base;
        line-height: 0;
        -webkit-tap-highlight-color: transparent;
      }

      :host([hidden]) {
        display: none !important;
      }

      :host(:focus) {
        outline: none;
      }

      .hidden {
        display: none;
      }

      #checkboxContainer {
        display: inline-block;
        position: relative;
        width: var(--calculated-paper-checkbox-size);
        height: var(--calculated-paper-checkbox-size);
        min-width: var(--calculated-paper-checkbox-size);
        margin: var(--paper-checkbox-margin, initial);
        vertical-align: var(--paper-checkbox-vertical-align, middle);
        background-color: var(--paper-checkbox-unchecked-background-color, transparent);
      }

      #ink {
        position: absolute;

        /* Center the ripple in the checkbox by negative offsetting it by
         * (inkWidth - rippleWidth) / 2 */
        top: calc(0px - (var(--calculated-paper-checkbox-ink-size) - var(--calculated-paper-checkbox-size)) / 2);
        left: calc(0px - (var(--calculated-paper-checkbox-ink-size) - var(--calculated-paper-checkbox-size)) / 2);
        width: var(--calculated-paper-checkbox-ink-size);
        height: var(--calculated-paper-checkbox-ink-size);
        color: var(--paper-checkbox-unchecked-ink-color, var(--primary-text-color));
        opacity: 0.6;
        pointer-events: none;
      }

      :host-context([dir="rtl"]) #ink {
        right: calc(0px - (var(--calculated-paper-checkbox-ink-size) - var(--calculated-paper-checkbox-size)) / 2);
        left: auto;
      }

      #ink[checked] {
        color: var(--paper-checkbox-checked-ink-color, var(--primary-color));
      }

      #checkbox {
        position: relative;
        box-sizing: border-box;
        height: 100%;
        border: solid 2px;
        border-color: var(--paper-checkbox-unchecked-color, var(--primary-text-color));
        border-radius: 2px;
        pointer-events: none;
        -webkit-transition: background-color 140ms, border-color 140ms;
        transition: background-color 140ms, border-color 140ms;
      }

      /* checkbox checked animations */
      #checkbox.checked #checkmark {
        -webkit-animation: checkmark-expand 140ms ease-out forwards;
        animation: checkmark-expand 140ms ease-out forwards;
      }

      @-webkit-keyframes checkmark-expand {
        0% {
          -webkit-transform: scale(0, 0) rotate(45deg);
        }
        100% {
          -webkit-transform: scale(1, 1) rotate(45deg);
        }
      }

      @keyframes checkmark-expand {
        0% {
          transform: scale(0, 0) rotate(45deg);
        }
        100% {
          transform: scale(1, 1) rotate(45deg);
        }
      }

      #checkbox.checked {
        background-color: var(--paper-checkbox-checked-color, var(--primary-color));
        border-color: var(--paper-checkbox-checked-color, var(--primary-color));
      }

      #checkmark {
        position: absolute;
        width: 36%;
        height: 70%;
        border-style: solid;
        border-top: none;
        border-left: none;
        border-right-width: calc(2/15 * var(--calculated-paper-checkbox-size));
        border-bottom-width: calc(2/15 * var(--calculated-paper-checkbox-size));
        border-color: var(--paper-checkbox-checkmark-color, white);
        -webkit-transform-origin: 97% 86%;
        transform-origin: 97% 86%;
        box-sizing: content-box; /* protect against page-level box-sizing */
      }

      :host-context([dir="rtl"]) #checkmark {
        -webkit-transform-origin: 50% 14%;
        transform-origin: 50% 14%;
      }

      /* label */
      #checkboxLabel {
        position: relative;
        display: inline-block;
        vertical-align: middle;
        padding-left: var(--paper-checkbox-label-spacing, 8px);
        white-space: normal;
        line-height: normal;
        color: var(--paper-checkbox-label-color, var(--primary-text-color));
        @apply --paper-checkbox-label;
      }

      :host([checked]) #checkboxLabel {
        color: var(--paper-checkbox-label-checked-color, var(--paper-checkbox-label-color, var(--primary-text-color)));
        @apply --paper-checkbox-label-checked;
      }

      :host-context([dir="rtl"]) #checkboxLabel {
        padding-right: var(--paper-checkbox-label-spacing, 8px);
        padding-left: 0;
      }

      #checkboxLabel[hidden] {
        display: none;
      }

      /* disabled state */

      :host([disabled]) #checkbox {
        opacity: 0.5;
        border-color: var(--paper-checkbox-unchecked-color, var(--primary-text-color));
      }

      :host([disabled][checked]) #checkbox {
        background-color: var(--paper-checkbox-unchecked-color, var(--primary-text-color));
        opacity: 0.5;
      }

      :host([disabled]) #checkboxLabel  {
        opacity: 0.65;
      }

      /* invalid state */
      #checkbox.invalid:not(.checked) {
        border-color: var(--paper-checkbox-error-color, var(--error-color));
      }
    </style>

    <div id="checkboxContainer">
      <div id="checkbox" class\$="[[_computeCheckboxClass(checked, invalid)]]">
        <div id="checkmark" class\$="[[_computeCheckmarkClass(checked)]]"></div>
      </div>
    </div>

    <div id="checkboxLabel"><slot></slot></div>
  </template>

  
</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-checkbox',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_checked_element_behavior_js__["a" /* PaperCheckedElementBehavior */]
  ],

  hostAttributes: {
    role: 'checkbox',
    'aria-checked': false,
    tabindex: 0
  },

  properties: {
    /**
     * Fired when the checked state changes due to user interaction.
     *
     * @event change
     */

    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-checked'
    }
  },

  attached: function() {
    // Wait until styles have resolved to check for the default sentinel.
    // See polymer#4009 for more details.
    Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_utils_render_status_js__["a" /* afterNextRender */])(this, function() {
      var inkSize = this.getComputedStyleValue('--calculated-paper-checkbox-ink-size').trim();
      // If unset, compute and set the default `--paper-checkbox-ink-size`.
      if (inkSize === '-1px') {
        var checkboxSizeText = this.getComputedStyleValue('--calculated-paper-checkbox-size').trim();

        var units = checkboxSizeText.match(/[A-Za-z]+$/)[0] || 'px';
        var checkboxSize = parseFloat(checkboxSizeText, 10);
        var defaultInkSize = (8 / 3) * checkboxSize;

        if (units === 'px') {
          defaultInkSize = Math.floor(defaultInkSize);

          // The checkbox and ripple need to have the same parity so that their
          // centers align.
          if (defaultInkSize % 2 !== checkboxSize % 2) {
            defaultInkSize++;
          }
        }

        this.updateStyles({
          '--paper-checkbox-ink-size': defaultInkSize + units,
        });
      }
    });
  },

  _computeCheckboxClass: function(checked, invalid) {
    var className = '';
    if (checked) {
      className += 'checked ';
    }
    if (invalid) {
      className += 'invalid';
    }
    return className;
  },

  _computeCheckmarkClass: function(checked) {
    return checked ? '' : 'hidden';
  },

  // create ripple inside the checkboxContainer
  _createRipple: function() {
    this._rippleContainer = this.$.checkboxContainer;
    return __WEBPACK_IMPORTED_MODULE_5__paper_behaviors_paper_inky_focus_behavior_js__["b" /* PaperInkyFocusBehaviorImpl */]._createRipple.call(this);
  }

});


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_validatable_behavior_iron_validatable_behavior_js__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_form_element_behavior_iron_form_element_behavior_js__ = __webpack_require__(48);




const IronCheckedElementBehaviorImpl = {

  properties: {
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */

    /**
     * Gets or sets the state, `true` is checked and `false` is unchecked.
     */
    checked: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      notify: true,
      observer: '_checkedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: true,
      reflectToAttribute: true
    },

    /* Overriden from Polymer.IronFormElementBehavior */
    value: {
      type: String,
      value: 'on',
      observer: '_valueChanged'
    }
  },

  observers: [
    '_requiredChanged(required)'
  ],

  created: function() {
    // Used by `iron-form` to handle the case that an element with this behavior
    // doesn't have a role of 'checkbox' or 'radio', but should still only be
    // included when the form is serialized if `this.checked === true`.
    this._hasIronCheckedElementBehavior = true;
  },

  /**
   * Returns false if the element is required and not checked, and true otherwise.
   * @param {*=} _value Ignored.
   * @return {boolean} true if `required` is false or if `checked` is true.
   */
  _getValidity: function(_value) {
    return this.disabled || !this.required || this.checked;
  },

  /**
   * Update the aria-required label when `required` is changed.
   */
  _requiredChanged: function() {
    if (this.required) {
      this.setAttribute('aria-required', 'true');
    } else {
      this.removeAttribute('aria-required');
    }
  },

  /**
   * Fire `iron-changed` when the checked state changes.
   */
  _checkedChanged: function() {
    this.active = this.checked;
    this.fire('iron-change');
  },

  /**
   * Reset value to 'on' if it is set to `undefined`.
   */
  _valueChanged: function() {
    if (this.value === undefined || this.value === null) {
      this.value = 'on';
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["b"] = IronCheckedElementBehaviorImpl;


const IronCheckedElementBehavior = [
  __WEBPACK_IMPORTED_MODULE_2__iron_form_element_behavior_iron_form_element_behavior_js__["a" /* IronFormElementBehavior */],
  __WEBPACK_IMPORTED_MODULE_1__iron_validatable_behavior_iron_validatable_behavior_js__["a" /* IronValidatableBehavior */],
  IronCheckedElementBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = IronCheckedElementBehavior;



/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__iron_icon_iron_icon_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_iconset_svg_iron_iconset_svg_js__ = __webpack_require__(99);


const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<iron-iconset-svg name="icons" size="24">
<svg><defs>
<g id="3d-rotation"><path d="M7.52 21.48C4.25 19.94 1.91 16.76 1.55 13H.05C.56 19.16 5.71 24 12 24l.66-.03-3.81-3.81-1.33 1.32zm.89-6.52c-.19 0-.37-.03-.52-.08-.16-.06-.29-.13-.4-.24-.11-.1-.2-.22-.26-.37-.06-.14-.09-.3-.09-.47h-1.3c0 .36.07.68.21.95.14.27.33.5.56.69.24.18.51.32.82.41.3.1.62.15.96.15.37 0 .72-.05 1.03-.15.32-.1.6-.25.83-.44s.42-.43.55-.72c.13-.29.2-.61.2-.97 0-.19-.02-.38-.07-.56-.05-.18-.12-.35-.23-.51-.1-.16-.24-.3-.4-.43-.17-.13-.37-.23-.61-.31.2-.09.37-.2.52-.33.15-.13.27-.27.37-.42.1-.15.17-.3.22-.46.05-.16.07-.32.07-.48 0-.36-.06-.68-.18-.96-.12-.28-.29-.51-.51-.69-.2-.19-.47-.33-.77-.43C9.1 8.05 8.76 8 8.39 8c-.36 0-.69.05-1 .16-.3.11-.57.26-.79.45-.21.19-.38.41-.51.67-.12.26-.18.54-.18.85h1.3c0-.17.03-.32.09-.45s.14-.25.25-.34c.11-.09.23-.17.38-.22.15-.05.3-.08.48-.08.4 0 .7.1.89.31.19.2.29.49.29.86 0 .18-.03.34-.08.49-.05.15-.14.27-.25.37-.11.1-.25.18-.41.24-.16.06-.36.09-.58.09H7.5v1.03h.77c.22 0 .42.02.6.07s.33.13.45.23c.12.11.22.24.29.4.07.16.1.35.1.57 0 .41-.12.72-.35.93-.23.23-.55.33-.95.33zm8.55-5.92c-.32-.33-.7-.59-1.14-.77-.43-.18-.92-.27-1.46-.27H12v8h2.3c.55 0 1.06-.09 1.51-.27.45-.18.84-.43 1.16-.76.32-.33.57-.73.74-1.19.17-.47.26-.99.26-1.57v-.4c0-.58-.09-1.1-.26-1.57-.18-.47-.43-.87-.75-1.2zm-.39 3.16c0 .42-.05.79-.14 1.13-.1.33-.24.62-.43.85-.19.23-.43.41-.71.53-.29.12-.62.18-.99.18h-.91V9.12h.97c.72 0 1.27.23 1.64.69.38.46.57 1.12.57 1.99v.4zM12 0l-.66.03 3.81 3.81 1.33-1.33c3.27 1.55 5.61 4.72 5.96 8.48h1.5C23.44 4.84 18.29 0 12 0z"></path></g>
<g id="accessibility"><path d="M12 2c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm9 7h-6v13h-2v-6h-2v6H9V9H3V7h18v2z"></path></g>
<g id="accessible"><circle cx="12" cy="4" r="2"></circle><path d="M19 13v-2c-1.54.02-3.09-.75-4.07-1.83l-1.29-1.43c-.17-.19-.38-.34-.61-.45-.01 0-.01-.01-.02-.01H13c-.35-.2-.75-.3-1.19-.26C10.76 7.11 10 8.04 10 9.09V15c0 1.1.9 2 2 2h5v5h2v-5.5c0-1.1-.9-2-2-2h-3v-3.45c1.29 1.07 3.25 1.94 5 1.95zm-6.17 5c-.41 1.16-1.52 2-2.83 2-1.66 0-3-1.34-3-3 0-1.31.84-2.41 2-2.83V12.1c-2.28.46-4 2.48-4 4.9 0 2.76 2.24 5 5 5 2.42 0 4.44-1.72 4.9-4h-2.07z"></path></g>
<g id="account-balance"><path d="M4 10v7h3v-7H4zm6 0v7h3v-7h-3zM2 22h19v-3H2v3zm14-12v7h3v-7h-3zm-4.5-9L2 6v2h19V6l-9.5-5z"></path></g>
<g id="account-balance-wallet"><path d="M21 18v1c0 1.1-.9 2-2 2H5c-1.11 0-2-.9-2-2V5c0-1.1.89-2 2-2h14c1.1 0 2 .9 2 2v1h-9c-1.11 0-2 .9-2 2v8c0 1.1.89 2 2 2h9zm-9-2h10V8H12v8zm4-2.5c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="account-box"><path d="M3 5v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2H5c-1.11 0-2 .9-2 2zm12 4c0 1.66-1.34 3-3 3s-3-1.34-3-3 1.34-3 3-3 3 1.34 3 3zm-9 8c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1H6v-1z"></path></g>
<g id="account-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm0 14.2c-2.5 0-4.71-1.28-6-3.22.03-1.99 4-3.08 6-3.08 1.99 0 5.97 1.09 6 3.08-1.29 1.94-3.5 3.22-6 3.22z"></path></g>
<g id="add"><path d="M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6v2z"></path></g>
<g id="add-alert"><path d="M10.01 21.01c0 1.1.89 1.99 1.99 1.99s1.99-.89 1.99-1.99h-3.98zm8.87-4.19V11c0-3.25-2.25-5.97-5.29-6.69v-.72C13.59 2.71 12.88 2 12 2s-1.59.71-1.59 1.59v.72C7.37 5.03 5.12 7.75 5.12 11v5.82L3 18.94V20h18v-1.06l-2.12-2.12zM16 13.01h-3v3h-2v-3H8V11h3V8h2v3h3v2.01z"></path></g>
<g id="add-box"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path></g>
<g id="add-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11h-4v4h-2v-4H7v-2h4V7h2v4h4v2z"></path></g>
<g id="add-circle-outline"><path d="M13 7h-2v4H7v2h4v4h2v-4h4v-2h-4V7zm-1-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="add-shopping-cart"><path d="M11 9h2V6h3V4h-3V1h-2v3H8v2h3v3zm-4 9c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zm10 0c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2zm-9.83-3.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.86-7.01L19.42 4h-.01l-1.1 2-2.76 5H8.53l-.13-.27L6.16 6l-.95-2-.94-2H1v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.13 0-.25-.11-.25-.25z"></path></g>
<g id="alarm"><path d="M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12.5 8H11v6l4.75 2.85.75-1.23-4-2.37V8zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7z"></path></g>
<g id="alarm-add"><path d="M7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm1-11h-2v3H8v2h3v3h2v-3h3v-2h-3V9z"></path></g>
<g id="alarm-off"><path d="M12 6c3.87 0 7 3.13 7 7 0 .84-.16 1.65-.43 2.4l1.52 1.52c.58-1.19.91-2.51.91-3.92 0-4.97-4.03-9-9-9-1.41 0-2.73.33-3.92.91L9.6 6.43C10.35 6.16 11.16 6 12 6zm10-.28l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM2.92 2.29L1.65 3.57 2.98 4.9l-1.11.93 1.42 1.42 1.11-.94.8.8C3.83 8.69 3 10.75 3 13c0 4.97 4.02 9 9 9 2.25 0 4.31-.83 5.89-2.2l2.2 2.2 1.27-1.27L3.89 3.27l-.97-.98zm13.55 16.1C15.26 19.39 13.7 20 12 20c-3.87 0-7-3.13-7-7 0-1.7.61-3.26 1.61-4.47l9.86 9.86zM8.02 3.28L6.6 1.86l-.86.71 1.42 1.42.86-.71z"></path></g>
<g id="alarm-on"><path d="M22 5.72l-4.6-3.86-1.29 1.53 4.6 3.86L22 5.72zM7.88 3.39L6.6 1.86 2 5.71l1.29 1.53 4.59-3.85zM12 4c-4.97 0-9 4.03-9 9s4.02 9 9 9c4.97 0 9-4.03 9-9s-4.03-9-9-9zm0 16c-3.87 0-7-3.13-7-7s3.13-7 7-7 7 3.13 7 7-3.13 7-7 7zm-1.46-5.47L8.41 12.4l-1.06 1.06 3.18 3.18 6-6-1.06-1.06-4.93 4.95z"></path></g>
<g id="all-out"><path d="M16.21 4.16l4 4v-4zm4 12l-4 4h4zm-12 4l-4-4v4zm-4-12l4-4h-4zm12.95-.95c-2.73-2.73-7.17-2.73-9.9 0s-2.73 7.17 0 9.9 7.17 2.73 9.9 0 2.73-7.16 0-9.9zm-1.1 8.8c-2.13 2.13-5.57 2.13-7.7 0s-2.13-5.57 0-7.7 5.57-2.13 7.7 0 2.13 5.57 0 7.7z"></path></g>
<g id="android"><path d="M6 18c0 .55.45 1 1 1h1v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h2v3.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5V19h1c.55 0 1-.45 1-1V8H6v10zM3.5 8C2.67 8 2 8.67 2 9.5v7c0 .83.67 1.5 1.5 1.5S5 17.33 5 16.5v-7C5 8.67 4.33 8 3.5 8zm17 0c-.83 0-1.5.67-1.5 1.5v7c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5v-7c0-.83-.67-1.5-1.5-1.5zm-4.97-5.84l1.3-1.3c.2-.2.2-.51 0-.71-.2-.2-.51-.2-.71 0l-1.48 1.48C13.85 1.23 12.95 1 12 1c-.96 0-1.86.23-2.66.63L7.85.15c-.2-.2-.51-.2-.71 0-.2.2-.2.51 0 .71l1.31 1.31C6.97 3.26 6 5.01 6 7h12c0-1.99-.97-3.75-2.47-4.84zM10 5H9V4h1v1zm5 0h-1V4h1v1z"></path></g>
<g id="announcement"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 9h-2V5h2v6zm0 4h-2v-2h2v2z"></path></g>
<g id="apps"><path d="M4 8h4V4H4v4zm6 12h4v-4h-4v4zm-6 0h4v-4H4v4zm0-6h4v-4H4v4zm6 0h4v-4h-4v4zm6-10v4h4V4h-4zm-6 4h4V4h-4v4zm6 6h4v-4h-4v4zm0 6h4v-4h-4v4z"></path></g>
<g id="archive"><path d="M20.54 5.23l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.16.55L3.46 5.23C3.17 5.57 3 6.02 3 6.5V19c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.48-.17-.93-.46-1.27zM12 17.5L6.5 12H10v-2h4v2h3.5L12 17.5zM5.12 5l.81-1h12l.94 1H5.12z"></path></g>
<g id="arrow-back"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"></path></g>
<g id="arrow-downward"><path d="M20 12l-1.41-1.41L13 16.17V4h-2v12.17l-5.58-5.59L4 12l8 8 8-8z"></path></g>
<g id="arrow-drop-down"><path d="M7 10l5 5 5-5z"></path></g>
<g id="arrow-drop-down-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 12l-4-4h8l-4 4z"></path></g>
<g id="arrow-drop-up"><path d="M7 14l5-5 5 5z"></path></g>
<g id="arrow-forward"><path d="M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z"></path></g>
<g id="arrow-upward"><path d="M4 12l1.41 1.41L11 7.83V20h2V7.83l5.58 5.59L20 12l-8-8-8 8z"></path></g>
<g id="aspect-ratio"><path d="M19 12h-2v3h-3v2h5v-5zM7 9h3V7H5v5h2V9zm14-6H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z"></path></g>
<g id="assessment"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM9 17H7v-7h2v7zm4 0h-2V7h2v10zm4 0h-2v-4h2v4z"></path></g>
<g id="assignment"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm2 14H7v-2h7v2zm3-4H7v-2h10v2zm0-4H7V7h10v2z"></path></g>
<g id="assignment-ind"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 4c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1.4c0-2 4-3.1 6-3.1s6 1.1 6 3.1V19z"></path></g>
<g id="assignment-late"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-6 15h-2v-2h2v2zm0-4h-2V8h2v6zm-1-9c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1z"></path></g>
<g id="assignment-return"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm4 12h-4v3l-5-5 5-5v3h4v4z"></path></g>
<g id="assignment-returned"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm0 15l-5-5h3V9h4v4h3l-5 5z"></path></g>
<g id="assignment-turned-in"><path d="M19 3h-4.18C14.4 1.84 13.3 1 12 1c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm-2 14l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"></path></g>
<g id="attachment"><path d="M2 12.5C2 9.46 4.46 7 7.5 7H18c2.21 0 4 1.79 4 4s-1.79 4-4 4H9.5C8.12 15 7 13.88 7 12.5S8.12 10 9.5 10H17v2H9.41c-.55 0-.55 1 0 1H18c1.1 0 2-.9 2-2s-.9-2-2-2H7.5C5.57 9 4 10.57 4 12.5S5.57 16 7.5 16H17v2H7.5C4.46 18 2 15.54 2 12.5z"></path></g>
<g id="autorenew"><path d="M12 6v3l4-4-4-4v3c-4.42 0-8 3.58-8 8 0 1.57.46 3.03 1.24 4.26L6.7 14.8c-.45-.83-.7-1.79-.7-2.8 0-3.31 2.69-6 6-6zm6.76 1.74L17.3 9.2c.44.84.7 1.79.7 2.8 0 3.31-2.69 6-6 6v-3l-4 4 4 4v-3c4.42 0 8-3.58 8-8 0-1.57-.46-3.03-1.24-4.26z"></path></g>
<g id="backspace"><path d="M22 3H7c-.69 0-1.23.35-1.59.88L0 12l5.41 8.11c.36.53.9.89 1.59.89h15c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-3 12.59L17.59 17 14 13.41 10.41 17 9 15.59 12.59 12 9 8.41 10.41 7 14 10.59 17.59 7 19 8.41 15.41 12 19 15.59z"></path></g>
<g id="backup"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"></path></g>
<g id="block"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM4 12c0-4.42 3.58-8 8-8 1.85 0 3.55.63 4.9 1.69L5.69 16.9C4.63 15.55 4 13.85 4 12zm8 8c-1.85 0-3.55-.63-4.9-1.69L18.31 7.1C19.37 8.45 20 10.15 20 12c0 4.42-3.58 8-8 8z"></path></g>
<g id="book"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"></path></g>
<g id="bookmark"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z"></path></g>
<g id="bookmark-border"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z"></path></g>
<g id="bug-report"><path d="M20 8h-2.81c-.45-.78-1.07-1.45-1.82-1.96L17 4.41 15.59 3l-2.17 2.17C12.96 5.06 12.49 5 12 5c-.49 0-.96.06-1.41.17L8.41 3 7 4.41l1.62 1.63C7.88 6.55 7.26 7.22 6.81 8H4v2h2.09c-.05.33-.09.66-.09 1v1H4v2h2v1c0 .34.04.67.09 1H4v2h2.81c1.04 1.79 2.97 3 5.19 3s4.15-1.21 5.19-3H20v-2h-2.09c.05-.33.09-.66.09-1v-1h2v-2h-2v-1c0-.34-.04-.67-.09-1H20V8zm-6 8h-4v-2h4v2zm0-4h-4v-2h4v2z"></path></g>
<g id="build"><path d="M22.7 19l-9.1-9.1c.9-2.3.4-5-1.5-6.9-2-2-5-2.4-7.4-1.3L9 6 6 9 1.6 4.7C.4 7.1.9 10.1 2.9 12.1c1.9 1.9 4.6 2.4 6.9 1.5l9.1 9.1c.4.4 1 .4 1.4 0l2.3-2.3c.5-.4.5-1.1.1-1.4z"></path></g>
<g id="cached"><path d="M19 8l-4 4h3c0 3.31-2.69 6-6 6-1.01 0-1.97-.25-2.8-.7l-1.46 1.46C8.97 19.54 10.43 20 12 20c4.42 0 8-3.58 8-8h3l-4-4zM6 12c0-3.31 2.69-6 6-6 1.01 0 1.97.25 2.8.7l1.46-1.46C15.03 4.46 13.57 4 12 4c-4.42 0-8 3.58-8 8H1l4 4 4-4H6z"></path></g>
<g id="camera-enhance"><path d="M9 3L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2h-3.17L15 3H9zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-1l1.25-2.75L16 13l-2.75-1.25L12 9l-1.25 2.75L8 13l2.75 1.25z"></path></g>
<g id="cancel"><path d="M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"></path></g>
<g id="card-giftcard"><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z"></path></g>
<g id="card-membership"><path d="M20 2H4c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h4v5l4-2 4 2v-5h4c1.11 0 2-.89 2-2V4c0-1.11-.89-2-2-2zm0 13H4v-2h16v2zm0-5H4V4h16v6z"></path></g>
<g id="card-travel"><path d="M20 6h-3V4c0-1.11-.89-2-2-2H9c-1.11 0-2 .89-2 2v2H4c-1.11 0-2 .89-2 2v11c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zM9 4h6v2H9V4zm11 15H4v-2h16v2zm0-5H4V8h3v2h2V8h6v2h2V8h3v6z"></path></g>
<g id="change-history"><path d="M12 7.77L18.39 18H5.61L12 7.77M12 4L2 20h20L12 4z"></path></g>
<g id="check"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"></path></g>
<g id="check-box"><path d="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g>
<g id="check-box-outline-blank"><path d="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></g>
<g id="check-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"></path></g>
<g id="chevron-left"><path d="M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"></path></g>
<g id="chevron-right"><path d="M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"></path></g>
<g id="chrome-reader-mode"><path d="M13 12h7v1.5h-7zm0-2.5h7V11h-7zm0 5h7V16h-7zM21 4H3c-1.1 0-2 .9-2 2v13c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 15h-9V6h9v13z"></path></g>
<g id="class"><path d="M18 2H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM6 4h5v8l-2.5-1.5L6 12V4z"></path></g>
<g id="clear"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
<g id="close"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"></path></g>
<g id="cloud"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96z"></path></g>
<g id="cloud-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm4.5 14H8c-1.66 0-3-1.34-3-3s1.34-3 3-3l.14.01C8.58 8.28 10.13 7 12 7c2.21 0 4 1.79 4 4h.5c1.38 0 2.5 1.12 2.5 2.5S17.88 16 16.5 16z"></path></g>
<g id="cloud-done"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM10 17l-3.5-3.5 1.41-1.41L10 14.17 15.18 9l1.41 1.41L10 17z"></path></g>
<g id="cloud-download"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM17 13l-5 5-5-5h3V9h4v4h3z"></path></g>
<g id="cloud-off"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4c-1.48 0-2.85.43-4.01 1.17l1.46 1.46C10.21 6.23 11.08 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3 0 1.13-.64 2.11-1.56 2.62l1.45 1.45C23.16 18.16 24 16.68 24 15c0-2.64-2.05-4.78-4.65-4.96zM3 5.27l2.75 2.74C2.56 8.15 0 10.77 0 14c0 3.31 2.69 6 6 6h11.73l2 2L21 20.73 4.27 4 3 5.27zM7.73 10l8 8H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h1.73z"></path></g>
<g id="cloud-queue"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM19 18H6c-2.21 0-4-1.79-4-4s1.79-4 4-4h.71C7.37 7.69 9.48 6 12 6c3.04 0 5.5 2.46 5.5 5.5v.5H19c1.66 0 3 1.34 3 3s-1.34 3-3 3z"></path></g>
<g id="cloud-upload"><path d="M19.35 10.04C18.67 6.59 15.64 4 12 4 9.11 4 6.6 5.64 5.35 8.04 2.34 8.36 0 10.91 0 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96zM14 13v4h-4v-4H7l5-5 5 5h-3z"></path></g>
<g id="code"><path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"></path></g>
<g id="compare-arrows"><path d="M9.01 14H2v2h7.01v3L13 15l-3.99-4v3zm5.98-1v-3H22V8h-7.01V5L11 9l3.99 4z"></path></g>
<g id="content-copy"><path d="M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12V1zm3 4H8c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h11c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm0 16H8V7h11v14z"></path></g>
<g id="content-cut"><path d="M9.64 7.64c.23-.5.36-1.05.36-1.64 0-2.21-1.79-4-4-4S2 3.79 2 6s1.79 4 4 4c.59 0 1.14-.13 1.64-.36L10 12l-2.36 2.36C7.14 14.13 6.59 14 6 14c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4c0-.59-.13-1.14-.36-1.64L12 14l7 7h3v-1L9.64 7.64zM6 8c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm0 12c-1.1 0-2-.89-2-2s.9-2 2-2 2 .89 2 2-.9 2-2 2zm6-7.5c-.28 0-.5-.22-.5-.5s.22-.5.5-.5.5.22.5.5-.22.5-.5.5zM19 3l-6 6 2 2 7-7V3z"></path></g>
<g id="content-paste"><path d="M19 2h-4.18C14.4.84 13.3 0 12 0c-1.3 0-2.4.84-2.82 2H5c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 0c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm7 18H5V4h2v3h10V4h2v16z"></path></g>
<g id="copyright"><path d="M10.08 10.86c.05-.33.16-.62.3-.87s.34-.46.59-.62c.24-.15.54-.22.91-.23.23.01.44.05.63.13.2.09.38.21.52.36s.25.33.34.53.13.42.14.64h1.79c-.02-.47-.11-.9-.28-1.29s-.4-.73-.7-1.01-.66-.5-1.08-.66-.88-.23-1.39-.23c-.65 0-1.22.11-1.7.34s-.88.53-1.2.92-.56.84-.71 1.36S8 11.29 8 11.87v.27c0 .58.08 1.12.23 1.64s.39.97.71 1.35.72.69 1.2.91 1.05.34 1.7.34c.47 0 .91-.08 1.32-.23s.77-.36 1.08-.63.56-.58.74-.94.29-.74.3-1.15h-1.79c-.01.21-.06.4-.15.58s-.21.33-.36.46-.32.23-.52.3c-.19.07-.39.09-.6.1-.36-.01-.66-.08-.89-.23-.25-.16-.45-.37-.59-.62s-.25-.55-.3-.88-.08-.67-.08-1v-.27c0-.35.03-.68.08-1.01zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="create"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04c.39-.39.39-1.02 0-1.41l-2.34-2.34c-.39-.39-1.02-.39-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"></path></g>
<g id="create-new-folder"><path d="M20 6h-8l-2-2H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-1 8h-3v3h-2v-3h-3v-2h3V9h2v3h3v2z"></path></g>
<g id="credit-card"><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"></path></g>
<g id="dashboard"><path d="M3 13h8V3H3v10zm0 8h8v-6H3v6zm10 0h8V11h-8v10zm0-18v6h8V3h-8z"></path></g>
<g id="date-range"><path d="M9 11H7v2h2v-2zm4 0h-2v2h2v-2zm4 0h-2v2h2v-2zm2-7h-1V2h-2v2H8V2H6v2H5c-1.11 0-1.99.9-1.99 2L3 20c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 16H5V9h14v11z"></path></g>
<g id="delete"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zM19 4h-3.5l-1-1h-5l-1 1H5v2h14V4z"></path></g>
<g id="delete-forever"><path d="M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12l1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"></path></g>
<g id="delete-sweep"><path d="M15 16h4v2h-4zm0-8h7v2h-7zm0 4h6v2h-6zM3 18c0 1.1.9 2 2 2h6c1.1 0 2-.9 2-2V8H3v10zM14 5h-3l-1-1H6L5 5H2v2h12z"></path></g>
<g id="description"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 16H8v-2h8v2zm0-4H8v-2h8v2zm-3-5V3.5L18.5 9H13z"></path></g>
<g id="dns"><path d="M20 13H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zM7 19c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM20 3H4c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h16c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1zM7 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="done"><path d="M9 16.2L4.8 12l-1.4 1.4L9 19 21 7l-1.4-1.4L9 16.2z"></path></g>
<g id="done-all"><path d="M18 7l-1.41-1.41-6.34 6.34 1.41 1.41L18 7zm4.24-1.41L11.66 16.17 7.48 12l-1.41 1.41L11.66 19l12-12-1.42-1.41zM.41 13.41L6 19l1.41-1.41L1.83 12 .41 13.41z"></path></g>
<g id="donut-large"><path d="M11 5.08V2c-5 .5-9 4.81-9 10s4 9.5 9 10v-3.08c-3-.48-6-3.4-6-6.92s3-6.44 6-6.92zM18.97 11H22c-.47-5-4-8.53-9-9v3.08C16 5.51 18.54 8 18.97 11zM13 18.92V22c5-.47 8.53-4 9-9h-3.03c-.43 3-2.97 5.49-5.97 5.92z"></path></g>
<g id="donut-small"><path d="M11 9.16V2c-5 .5-9 4.79-9 10s4 9.5 9 10v-7.16c-1-.41-2-1.52-2-2.84s1-2.43 2-2.84zM14.86 11H22c-.48-4.75-4-8.53-9-9v7.16c1 .3 1.52.98 1.86 1.84zM13 14.84V22c5-.47 8.52-4.25 9-9h-7.14c-.34.86-.86 1.54-1.86 1.84z"></path></g>
<g id="drafts"><path d="M21.99 8c0-.72-.37-1.35-.94-1.7L12 1 2.95 6.3C2.38 6.65 2 7.28 2 8v10c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2l-.01-10zM12 13L3.74 7.84 12 3l8.26 4.84L12 13z"></path></g>
<g id="eject"><path d="M5 17h14v2H5zm7-12L5.33 15h13.34z"></path></g>
<g id="error"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"></path></g>
<g id="error-outline"><path d="M11 15h2v2h-2zm0-8h2v6h-2zm.99-5C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="euro-symbol"><path d="M15 18.5c-2.51 0-4.68-1.42-5.76-3.5H15v-2H8.58c-.05-.33-.08-.66-.08-1s.03-.67.08-1H15V9H9.24C10.32 6.92 12.5 5.5 15 5.5c1.61 0 3.09.59 4.23 1.57L21 5.3C19.41 3.87 17.3 3 15 3c-3.92 0-7.24 2.51-8.48 6H3v2h3.06c-.04.33-.06.66-.06 1 0 .34.02.67.06 1H3v2h3.52c1.24 3.49 4.56 6 8.48 6 2.31 0 4.41-.87 6-2.3l-1.78-1.77c-1.13.98-2.6 1.57-4.22 1.57z"></path></g>
<g id="event"><path d="M17 12h-5v5h5v-5zM16 1v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2h-1V1h-2zm3 18H5V8h14v11z"></path></g>
<g id="event-seat"><path d="M4 18v3h3v-3h10v3h3v-6H4zm15-8h3v3h-3zM2 10h3v3H2zm15 3H7V5c0-1.1.9-2 2-2h6c1.1 0 2 .9 2 2v8z"></path></g>
<g id="exit-to-app"><path d="M10.09 15.59L11.5 17l5-5-5-5-1.41 1.41L12.67 11H3v2h9.67l-2.58 2.59zM19 3H5c-1.11 0-2 .9-2 2v4h2V5h14v14H5v-4H3v4c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"></path></g>
<g id="expand-less"><path d="M12 8l-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"></path></g>
<g id="expand-more"><path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></g>
<g id="explore"><path d="M12 10.9c-.61 0-1.1.49-1.1 1.1s.49 1.1 1.1 1.1c.61 0 1.1-.49 1.1-1.1s-.49-1.1-1.1-1.1zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm2.19 12.19L6 18l3.81-8.19L18 6l-3.81 8.19z"></path></g>
<g id="extension"><path d="M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7 1.49 0 2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11z"></path></g>
<g id="face"><path d="M9 11.75c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zm6 0c-.69 0-1.25.56-1.25 1.25s.56 1.25 1.25 1.25 1.25-.56 1.25-1.25-.56-1.25-1.25-1.25zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8 0-.29.02-.58.05-.86 2.36-1.05 4.23-2.98 5.21-5.37C11.07 8.33 14.05 10 17.42 10c.78 0 1.53-.09 2.25-.26.21.71.33 1.47.33 2.26 0 4.41-3.59 8-8 8z"></path></g>
<g id="favorite"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"></path></g>
<g id="favorite-border"><path d="M16.5 3c-1.74 0-3.41.81-4.5 2.09C10.91 3.81 9.24 3 7.5 3 4.42 3 2 5.42 2 8.5c0 3.78 3.4 6.86 8.55 11.54L12 21.35l1.45-1.32C18.6 15.36 22 12.28 22 8.5 22 5.42 19.58 3 16.5 3zm-4.4 15.55l-.1.1-.1-.1C7.14 14.24 4 11.39 4 8.5 4 6.5 5.5 5 7.5 5c1.54 0 3.04.99 3.57 2.36h1.87C13.46 5.99 14.96 5 16.5 5c2 0 3.5 1.5 3.5 3.5 0 2.89-3.14 5.74-7.9 10.05z"></path></g>
<g id="feedback"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-7 12h-2v-2h2v2zm0-4h-2V6h2v4z"></path></g>
<g id="file-download"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></g>
<g id="file-upload"><path d="M9 16h6v-6h4l-7-7-7 7h4zm-4 2h14v2H5z"></path></g>
<g id="filter-list"><path d="M10 18h4v-2h-4v2zM3 6v2h18V6H3zm3 7h12v-2H6v2z"></path></g>
<g id="find-in-page"><path d="M20 19.59V8l-6-6H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c.45 0 .85-.15 1.19-.4l-4.43-4.43c-.8.52-1.74.83-2.76.83-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5c0 1.02-.31 1.96-.83 2.75L20 19.59zM9 13c0 1.66 1.34 3 3 3s3-1.34 3-3-1.34-3-3-3-3 1.34-3 3z"></path></g>
<g id="find-replace"><path d="M11 6c1.38 0 2.63.56 3.54 1.46L12 10h6V4l-2.05 2.05C14.68 4.78 12.93 4 11 4c-3.53 0-6.43 2.61-6.92 6H6.1c.46-2.28 2.48-4 4.9-4zm5.64 9.14c.66-.9 1.12-1.97 1.28-3.14H15.9c-.46 2.28-2.48 4-4.9 4-1.38 0-2.63-.56-3.54-1.46L10 12H4v6l2.05-2.05C7.32 17.22 9.07 18 11 18c1.55 0 2.98-.51 4.14-1.36L20 21.49 21.49 20l-4.85-4.86z"></path></g>
<g id="fingerprint"><path d="M17.81 4.47c-.08 0-.16-.02-.23-.06C15.66 3.42 14 3 12.01 3c-1.98 0-3.86.47-5.57 1.41-.24.13-.54.04-.68-.2-.13-.24-.04-.55.2-.68C7.82 2.52 9.86 2 12.01 2c2.13 0 3.99.47 6.03 1.52.25.13.34.43.21.67-.09.18-.26.28-.44.28zM3.5 9.72c-.1 0-.2-.03-.29-.09-.23-.16-.28-.47-.12-.7.99-1.4 2.25-2.5 3.75-3.27C9.98 4.04 14 4.03 17.15 5.65c1.5.77 2.76 1.86 3.75 3.25.16.22.11.54-.12.7-.23.16-.54.11-.7-.12-.9-1.26-2.04-2.25-3.39-2.94-2.87-1.47-6.54-1.47-9.4.01-1.36.7-2.5 1.7-3.4 2.96-.08.14-.23.21-.39.21zm6.25 12.07c-.13 0-.26-.05-.35-.15-.87-.87-1.34-1.43-2.01-2.64-.69-1.23-1.05-2.73-1.05-4.34 0-2.97 2.54-5.39 5.66-5.39s5.66 2.42 5.66 5.39c0 .28-.22.5-.5.5s-.5-.22-.5-.5c0-2.42-2.09-4.39-4.66-4.39-2.57 0-4.66 1.97-4.66 4.39 0 1.44.32 2.77.93 3.85.64 1.15 1.08 1.64 1.85 2.42.19.2.19.51 0 .71-.11.1-.24.15-.37.15zm7.17-1.85c-1.19 0-2.24-.3-3.1-.89-1.49-1.01-2.38-2.65-2.38-4.39 0-.28.22-.5.5-.5s.5.22.5.5c0 1.41.72 2.74 1.94 3.56.71.48 1.54.71 2.54.71.24 0 .64-.03 1.04-.1.27-.05.53.13.58.41.05.27-.13.53-.41.58-.57.11-1.07.12-1.21.12zM14.91 22c-.04 0-.09-.01-.13-.02-1.59-.44-2.63-1.03-3.72-2.1-1.4-1.39-2.17-3.24-2.17-5.22 0-1.62 1.38-2.94 3.08-2.94 1.7 0 3.08 1.32 3.08 2.94 0 1.07.93 1.94 2.08 1.94s2.08-.87 2.08-1.94c0-3.77-3.25-6.83-7.25-6.83-2.84 0-5.44 1.58-6.61 4.03-.39.81-.59 1.76-.59 2.8 0 .78.07 2.01.67 3.61.1.26-.03.55-.29.64-.26.1-.55-.04-.64-.29-.49-1.31-.73-2.61-.73-3.96 0-1.2.23-2.29.68-3.24 1.33-2.79 4.28-4.6 7.51-4.6 4.55 0 8.25 3.51 8.25 7.83 0 1.62-1.38 2.94-3.08 2.94s-3.08-1.32-3.08-2.94c0-1.07-.93-1.94-2.08-1.94s-2.08.87-2.08 1.94c0 1.71.66 3.31 1.87 4.51.95.94 1.86 1.46 3.27 1.85.27.07.42.35.35.61-.05.23-.26.38-.47.38z"></path></g>
<g id="first-page"><path d="M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"></path></g>
<g id="flag"><path d="M14.4 6L14 4H5v17h2v-7h5.6l.4 2h7V6z"></path></g>
<g id="flight-land"><path d="M2.5 19h19v2h-19zm7.18-5.73l4.35 1.16 5.31 1.42c.8.21 1.62-.26 1.84-1.06.21-.8-.26-1.62-1.06-1.84l-5.31-1.42-2.76-9.02L10.12 2v8.28L5.15 8.95l-.93-2.32-1.45-.39v5.17l1.6.43 5.31 1.43z"></path></g>
<g id="flight-takeoff"><path d="M2.5 19h19v2h-19zm19.57-9.36c-.21-.8-1.04-1.28-1.84-1.06L14.92 10l-6.9-6.43-1.93.51 4.14 7.17-4.97 1.33-1.97-1.54-1.45.39 1.82 3.16.77 1.33 1.6-.43 5.31-1.42 4.35-1.16L21 11.49c.81-.23 1.28-1.05 1.07-1.85z"></path></g>
<g id="flip-to-back"><path d="M9 7H7v2h2V7zm0 4H7v2h2v-2zm0-8c-1.11 0-2 .9-2 2h2V3zm4 12h-2v2h2v-2zm6-12v2h2c0-1.1-.9-2-2-2zm-6 0h-2v2h2V3zM9 17v-2H7c0 1.1.89 2 2 2zm10-4h2v-2h-2v2zm0-4h2V7h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zM5 7H3v12c0 1.1.89 2 2 2h12v-2H5V7zm10-2h2V3h-2v2zm0 12h2v-2h-2v2z"></path></g>
<g id="flip-to-front"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm2 4v-2H3c0 1.1.89 2 2 2zM3 9h2V7H3v2zm12 12h2v-2h-2v2zm4-18H9c-1.11 0-2 .9-2 2v10c0 1.1.89 2 2 2h10c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12H9V5h10v10zm-8 6h2v-2h-2v2zm-4 0h2v-2H7v2z"></path></g>
<g id="folder"><path d="M10 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2h-8l-2-2z"></path></g>
<g id="folder-open"><path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm0 12H4V8h16v10z"></path></g>
<g id="folder-shared"><path d="M20 6h-8l-2-2H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2zm-5 3c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2zm4 8h-8v-1c0-1.33 2.67-2 4-2s4 .67 4 2v1z"></path></g>
<g id="font-download"><path d="M9.93 13.5h4.14L12 7.98zM20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-4.05 16.5l-1.14-3H9.17l-1.12 3H5.96l5.11-13h1.86l5.11 13h-2.09z"></path></g>
<g id="forward"><path d="M12 8V4l8 8-8 8v-4H4V8z"></path></g>
<g id="fullscreen"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zM14 5v2h3v3h2V5h-5z"></path></g>
<g id="fullscreen-exit"><path d="M5 16h3v3h2v-5H5v2zm3-8H5v2h5V5H8v3zm6 11h2v-3h3v-2h-5v5zm2-11V5h-2v5h5V8h-3z"></path></g>
<g id="g-translate"><path d="M20 5h-9.12L10 2H4c-1.1 0-2 .9-2 2v13c0 1.1.9 2 2 2h7l1 3h8c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zM7.17 14.59c-2.25 0-4.09-1.83-4.09-4.09s1.83-4.09 4.09-4.09c1.04 0 1.99.37 2.74 1.07l.07.06-1.23 1.18-.06-.05c-.29-.27-.78-.59-1.52-.59-1.31 0-2.38 1.09-2.38 2.42s1.07 2.42 2.38 2.42c1.37 0 1.96-.87 2.12-1.46H7.08V9.91h3.95l.01.07c.04.21.05.4.05.61 0 2.35-1.61 4-3.92 4zm6.03-1.71c.33.6.74 1.18 1.19 1.7l-.54.53-.65-2.23zm.77-.76h-.99l-.31-1.04h3.99s-.34 1.31-1.56 2.74c-.52-.62-.89-1.23-1.13-1.7zM21 20c0 .55-.45 1-1 1h-7l2-2-.81-2.77.92-.92L17.79 18l.73-.73-2.71-2.68c.9-1.03 1.6-2.25 1.92-3.51H19v-1.04h-3.64V9h-1.04v1.04h-1.96L11.18 6H20c.55 0 1 .45 1 1v13z"></path></g>
<g id="gavel"><path d="M1 21h12v2H1zM5.245 8.07l2.83-2.827 14.14 14.142-2.828 2.828zM12.317 1l5.657 5.656-2.83 2.83-5.654-5.66zM3.825 9.485l5.657 5.657-2.828 2.828-5.657-5.657z"></path></g>
<g id="gesture"><path d="M4.59 6.89c.7-.71 1.4-1.35 1.71-1.22.5.2 0 1.03-.3 1.52-.25.42-2.86 3.89-2.86 6.31 0 1.28.48 2.34 1.34 2.98.75.56 1.74.73 2.64.46 1.07-.31 1.95-1.4 3.06-2.77 1.21-1.49 2.83-3.44 4.08-3.44 1.63 0 1.65 1.01 1.76 1.79-3.78.64-5.38 3.67-5.38 5.37 0 1.7 1.44 3.09 3.21 3.09 1.63 0 4.29-1.33 4.69-6.1H21v-2.5h-2.47c-.15-1.65-1.09-4.2-4.03-4.2-2.25 0-4.18 1.91-4.94 2.84-.58.73-2.06 2.48-2.29 2.72-.25.3-.68.84-1.11.84-.45 0-.72-.83-.36-1.92.35-1.09 1.4-2.86 1.85-3.52.78-1.14 1.3-1.92 1.3-3.28C8.95 3.69 7.31 3 6.44 3 5.12 3 3.97 4 3.72 4.25c-.36.36-.66.66-.88.93l1.75 1.71zm9.29 11.66c-.31 0-.74-.26-.74-.72 0-.6.73-2.2 2.87-2.76-.3 2.69-1.43 3.48-2.13 3.48z"></path></g>
<g id="get-app"><path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"></path></g>
<g id="gif"><path d="M11.5 9H13v6h-1.5zM9 9H6c-.6 0-1 .5-1 1v4c0 .5.4 1 1 1h3c.6 0 1-.5 1-1v-2H8.5v1.5h-2v-3H10V10c0-.5-.4-1-1-1zm10 1.5V9h-4.5v6H16v-2h2v-1.5h-2v-1z"></path></g>
<g id="grade"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></g>
<g id="group-work"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM8 17.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5zM9.5 8c0-1.38 1.12-2.5 2.5-2.5s2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5S9.5 9.38 9.5 8zm6.5 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></g>
<g id="help"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"></path></g>
<g id="help-outline"><path d="M11 18h2v-2h-2v2zm1-16C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zm0-14c-2.21 0-4 1.79-4 4h2c0-1.1.9-2 2-2s2 .9 2 2c0 2-3 1.75-3 5h2c0-2.25 3-2.5 3-5 0-2.21-1.79-4-4-4z"></path></g>
<g id="highlight-off"><path d="M14.59 8L12 10.59 9.41 8 8 9.41 10.59 12 8 14.59 9.41 16 12 13.41 14.59 16 16 14.59 13.41 12 16 9.41 14.59 8zM12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="history"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"></path></g>
<g id="home"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"></path></g>
<g id="hourglass-empty"><path d="M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6zm10 14.5V20H8v-3.5l4-4 4 4zm-4-5l-4-4V4h8v3.5l-4 4z"></path></g>
<g id="hourglass-full"><path d="M6 2v6h.01L6 8.01 10 12l-4 4 .01.01H6V22h12v-5.99h-.01L18 16l-4-4 4-3.99-.01-.01H18V2H6z"></path></g>
<g id="http"><path d="M4.5 11h-2V9H1v6h1.5v-2.5h2V15H6V9H4.5v2zm2.5-.5h1.5V15H10v-4.5h1.5V9H7v1.5zm5.5 0H14V15h1.5v-4.5H17V9h-4.5v1.5zm9-1.5H18v6h1.5v-2h2c.8 0 1.5-.7 1.5-1.5v-1c0-.8-.7-1.5-1.5-1.5zm0 2.5h-2v-1h2v1z"></path></g>
<g id="https"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"></path></g>
<g id="important-devices"><path d="M23 11.01L18 11c-.55 0-1 .45-1 1v9c0 .55.45 1 1 1h5c.55 0 1-.45 1-1v-9c0-.55-.45-.99-1-.99zM23 20h-5v-7h5v7zM20 2H2C.89 2 0 2.89 0 4v12c0 1.1.89 2 2 2h7v2H7v2h8v-2h-2v-2h2v-2H2V4h18v5h2V4c0-1.11-.9-2-2-2zm-8.03 7L11 6l-.97 3H7l2.47 1.76-.94 2.91 2.47-1.8 2.47 1.8-.94-2.91L15 9h-3.03z"></path></g>
<g id="inbox"><path d="M19 3H4.99c-1.11 0-1.98.89-1.98 2L3 19c0 1.1.88 2 1.99 2H19c1.1 0 2-.9 2-2V5c0-1.11-.9-2-2-2zm0 12h-4c0 1.66-1.35 3-3 3s-3-1.34-3-3H4.99V5H19v10z"></path></g>
<g id="indeterminate-check-box"><path d="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"></path></g>
<g id="info"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-6h2v6zm0-8h-2V7h2v2z"></path></g>
<g id="info-outline"><path d="M11 17h2v-6h-2v6zm1-15C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8zM11 9h2V7h-2v2z"></path></g>
<g id="input"><path d="M21 3.01H3c-1.1 0-2 .9-2 2V9h2V4.99h18v14.03H3V15H1v4.01c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98v-14c0-1.11-.9-2-2-2zM11 16l4-4-4-4v3H1v2h10v3z"></path></g>
<g id="invert-colors"><path d="M17.66 7.93L12 2.27 6.34 7.93c-3.12 3.12-3.12 8.19 0 11.31C7.9 20.8 9.95 21.58 12 21.58c2.05 0 4.1-.78 5.66-2.34 3.12-3.12 3.12-8.19 0-11.31zM12 19.59c-1.6 0-3.11-.62-4.24-1.76C6.62 16.69 6 15.19 6 13.59s.62-3.11 1.76-4.24L12 5.1v14.49z"></path></g>
<g id="label"><path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16z"></path></g>
<g id="label-outline"><path d="M17.63 5.84C17.27 5.33 16.67 5 16 5L5 5.01C3.9 5.01 3 5.9 3 7v10c0 1.1.9 1.99 2 1.99L16 19c.67 0 1.27-.33 1.63-.84L22 12l-4.37-6.16zM16 17H5V7h11l3.55 5L16 17z"></path></g>
<g id="language"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm6.93 6h-2.95c-.32-1.25-.78-2.45-1.38-3.56 1.84.63 3.37 1.91 4.33 3.56zM12 4.04c.83 1.2 1.48 2.53 1.91 3.96h-3.82c.43-1.43 1.08-2.76 1.91-3.96zM4.26 14C4.1 13.36 4 12.69 4 12s.1-1.36.26-2h3.38c-.08.66-.14 1.32-.14 2 0 .68.06 1.34.14 2H4.26zm.82 2h2.95c.32 1.25.78 2.45 1.38 3.56-1.84-.63-3.37-1.9-4.33-3.56zm2.95-8H5.08c.96-1.66 2.49-2.93 4.33-3.56C8.81 5.55 8.35 6.75 8.03 8zM12 19.96c-.83-1.2-1.48-2.53-1.91-3.96h3.82c-.43 1.43-1.08 2.76-1.91 3.96zM14.34 14H9.66c-.09-.66-.16-1.32-.16-2 0-.68.07-1.35.16-2h4.68c.09.65.16 1.32.16 2 0 .68-.07 1.34-.16 2zm.25 5.56c.6-1.11 1.06-2.31 1.38-3.56h2.95c-.96 1.65-2.49 2.93-4.33 3.56zM16.36 14c.08-.66.14-1.32.14-2 0-.68-.06-1.34-.14-2h3.38c.16.64.26 1.31.26 2s-.1 1.36-.26 2h-3.38z"></path></g>
<g id="last-page"><path d="M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"></path></g>
<g id="launch"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"></path></g>
<g id="lightbulb-outline"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6C7.8 12.16 7 10.63 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"></path></g>
<g id="line-style"><path d="M3 16h5v-2H3v2zm6.5 0h5v-2h-5v2zm6.5 0h5v-2h-5v2zM3 20h2v-2H3v2zm4 0h2v-2H7v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zM3 12h8v-2H3v2zm10 0h8v-2h-8v2zM3 4v4h18V4H3z"></path></g>
<g id="line-weight"><path d="M3 17h18v-2H3v2zm0 3h18v-1H3v1zm0-7h18v-3H3v3zm0-9v4h18V4H3z"></path></g>
<g id="link"><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"></path></g>
<g id="list"><path d="M3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm4 4h14v-2H7v2zm0 4h14v-2H7v2zM7 7v2h14V7H7z"></path></g>
<g id="lock"><path d="M18 8h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm-6 9c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zm3.1-9H8.9V6c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2z"></path></g>
<g id="lock-open"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6h1.9c0-1.71 1.39-3.1 3.1-3.1 1.71 0 3.1 1.39 3.1 3.1v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zm0 12H6V10h12v10z"></path></g>
<g id="lock-outline"><path d="M12 17c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm6-9h-1V6c0-2.76-2.24-5-5-5S7 3.24 7 6v2H6c-1.1 0-2 .9-2 2v10c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V10c0-1.1-.9-2-2-2zM8.9 6c0-1.71 1.39-3.1 3.1-3.1s3.1 1.39 3.1 3.1v2H8.9V6zM18 20H6V10h12v10z"></path></g>
<g id="low-priority"><path d="M14 5h8v2h-8zm0 5.5h8v2h-8zm0 5.5h8v2h-8zM2 11.5C2 15.08 4.92 18 8.5 18H9v2l3-3-3-3v2h-.5C6.02 16 4 13.98 4 11.5S6.02 7 8.5 7H12V5H8.5C4.92 5 2 7.92 2 11.5z"></path></g>
<g id="loyalty"><path d="M21.41 11.58l-9-9C12.05 2.22 11.55 2 11 2H4c-1.1 0-2 .9-2 2v7c0 .55.22 1.05.59 1.42l9 9c.36.36.86.58 1.41.58.55 0 1.05-.22 1.41-.59l7-7c.37-.36.59-.86.59-1.41 0-.55-.23-1.06-.59-1.42zM5.5 7C4.67 7 4 6.33 4 5.5S4.67 4 5.5 4 7 4.67 7 5.5 6.33 7 5.5 7zm11.77 8.27L13 19.54l-4.27-4.27C8.28 14.81 8 14.19 8 13.5c0-1.38 1.12-2.5 2.5-2.5.69 0 1.32.28 1.77.74l.73.72.73-.73c.45-.45 1.08-.73 1.77-.73 1.38 0 2.5 1.12 2.5 2.5 0 .69-.28 1.32-.73 1.77z"></path></g>
<g id="mail"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path></g>
<g id="markunread"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm0 4l-8 5-8-5V6l8 5 8-5v2z"></path></g>
<g id="markunread-mailbox"><path d="M20 6H10v6H8V4h6V0H6v6H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V8c0-1.1-.9-2-2-2z"></path></g>
<g id="menu"><path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"></path></g>
<g id="more-horiz"><path d="M6 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm12 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm-6 0c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="more-vert"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="motorcycle"><path d="M19.44 9.03L15.41 5H11v2h3.59l2 2H5c-2.8 0-5 2.2-5 5s2.2 5 5 5c2.46 0 4.45-1.69 4.9-4h1.65l2.77-2.77c-.21.54-.32 1.14-.32 1.77 0 2.8 2.2 5 5 5s5-2.2 5-5c0-2.65-1.97-4.77-4.56-4.97zM7.82 15C7.4 16.15 6.28 17 5 17c-1.63 0-3-1.37-3-3s1.37-3 3-3c1.28 0 2.4.85 2.82 2H5v2h2.82zM19 17c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"></path></g>
<g id="move-to-inbox"><path d="M19 3H4.99c-1.11 0-1.98.9-1.98 2L3 19c0 1.1.88 2 1.99 2H19c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 12h-4c0 1.66-1.35 3-3 3s-3-1.34-3-3H4.99V5H19v10zm-3-5h-2V7h-4v3H8l4 4 4-4z"></path></g>
<g id="next-week"><path d="M20 7h-4V5c0-.55-.22-1.05-.59-1.41C15.05 3.22 14.55 3 14 3h-4c-1.1 0-2 .9-2 2v2H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V9c0-1.1-.9-2-2-2zM10 5h4v2h-4V5zm1 13.5l-1-1 3-3-3-3 1-1 4 4-4 4z"></path></g>
<g id="note-add"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm2 14h-3v3h-2v-3H8v-2h3v-3h2v3h3v2zm-3-7V3.5L18.5 9H13z"></path></g>
<g id="offline-pin"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm5 16H7v-2h10v2zm-6.7-4L7 10.7l1.4-1.4 1.9 1.9 5.3-5.3L17 7.3 10.3 14z"></path></g>
<g id="opacity"><path d="M17.66 8L12 2.35 6.34 8C4.78 9.56 4 11.64 4 13.64s.78 4.11 2.34 5.67 3.61 2.35 5.66 2.35 4.1-.79 5.66-2.35S20 15.64 20 13.64 19.22 9.56 17.66 8zM6 14c.01-2 .62-3.27 1.76-4.4L12 5.27l4.24 4.38C17.38 10.77 17.99 12 18 14H6z"></path></g>
<g id="open-in-browser"><path d="M19 4H5c-1.11 0-2 .9-2 2v12c0 1.1.89 2 2 2h4v-2H5V8h14v10h-4v2h4c1.1 0 2-.9 2-2V6c0-1.1-.89-2-2-2zm-7 6l-4 4h3v6h2v-6h3l-4-4z"></path></g>
<g id="open-in-new"><path d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z"></path></g>
<g id="open-with"><path d="M10 9h4V6h3l-5-5-5 5h3v3zm-1 1H6V7l-5 5 5 5v-3h3v-4zm14 2l-5-5v3h-3v4h3v3l5-5zm-9 3h-4v3H7l5 5 5-5h-3v-3z"></path></g>
<g id="pageview"><path d="M11.5 9C10.12 9 9 10.12 9 11.5s1.12 2.5 2.5 2.5 2.5-1.12 2.5-2.5S12.88 9 11.5 9zM20 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-3.21 14.21l-2.91-2.91c-.69.44-1.51.7-2.39.7C9.01 16 7 13.99 7 11.5S9.01 7 11.5 7 16 9.01 16 11.5c0 .88-.26 1.69-.7 2.39l2.91 2.9-1.42 1.42z"></path></g>
<g id="pan-tool"><path d="M23 5.5V20c0 2.2-1.8 4-4 4h-7.3c-1.08 0-2.1-.43-2.85-1.19L1 14.83s1.26-1.23 1.3-1.25c.22-.19.49-.29.79-.29.22 0 .42.06.6.16.04.01 4.31 2.46 4.31 2.46V4c0-.83.67-1.5 1.5-1.5S11 3.17 11 4v7h1V1.5c0-.83.67-1.5 1.5-1.5S15 .67 15 1.5V11h1V2.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5V11h1V5.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5z"></path></g>
<g id="payment"><path d="M20 4H4c-1.11 0-1.99.89-1.99 2L2 18c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6c0-1.11-.89-2-2-2zm0 14H4v-6h16v6zm0-10H4V6h16v2z"></path></g>
<g id="perm-camera-mic"><path d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h7v-2.09c-2.83-.48-5-2.94-5-5.91h2c0 2.21 1.79 4 4 4s4-1.79 4-4h2c0 2.97-2.17 5.43-5 5.91V21h7c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-6 8c0 1.1-.9 2-2 2s-2-.9-2-2V9c0-1.1.9-2 2-2s2 .9 2 2v4z"></path></g>
<g id="perm-contact-calendar"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-7 3c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3zm6 12H6v-1c0-2 4-3.1 6-3.1s6 1.1 6 3.1v1z"></path></g>
<g id="perm-data-setting"><path d="M18.99 11.5c.34 0 .67.03 1 .07L20 0 0 20h11.56c-.04-.33-.07-.66-.07-1 0-4.14 3.36-7.5 7.5-7.5zm3.71 7.99c.02-.16.04-.32.04-.49 0-.17-.01-.33-.04-.49l1.06-.83c.09-.08.12-.21.06-.32l-1-1.73c-.06-.11-.19-.15-.31-.11l-1.24.5c-.26-.2-.54-.37-.85-.49l-.19-1.32c-.01-.12-.12-.21-.24-.21h-2c-.12 0-.23.09-.25.21l-.19 1.32c-.3.13-.59.29-.85.49l-1.24-.5c-.11-.04-.24 0-.31.11l-1 1.73c-.06.11-.04.24.06.32l1.06.83c-.02.16-.03.32-.03.49 0 .17.01.33.03.49l-1.06.83c-.09.08-.12.21-.06.32l1 1.73c.06.11.19.15.31.11l1.24-.5c.26.2.54.37.85.49l.19 1.32c.02.12.12.21.25.21h2c.12 0 .23-.09.25-.21l.19-1.32c.3-.13.59-.29.84-.49l1.25.5c.11.04.24 0 .31-.11l1-1.73c.06-.11.03-.24-.06-.32l-1.07-.83zm-3.71 1.01c-.83 0-1.5-.67-1.5-1.5s.67-1.5 1.5-1.5 1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path></g>
<g id="perm-device-information"><path d="M13 7h-2v2h2V7zm0 4h-2v6h2v-6zm4-9.99L7 1c-1.1 0-2 .9-2 2v18c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V3c0-1.1-.9-1.99-2-1.99zM17 19H7V5h10v14z"></path></g>
<g id="perm-identity"><path d="M12 5.9c1.16 0 2.1.94 2.1 2.1s-.94 2.1-2.1 2.1S9.9 9.16 9.9 8s.94-2.1 2.1-2.1m0 9c2.97 0 6.1 1.46 6.1 2.1v1.1H5.9V17c0-.64 3.13-2.1 6.1-2.1M12 4C9.79 4 8 5.79 8 8s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 9c-2.67 0-8 1.34-8 4v3h16v-3c0-2.66-5.33-4-8-4z"></path></g>
<g id="perm-media"><path d="M2 6H0v5h.01L0 20c0 1.1.9 2 2 2h18v-2H2V6zm20-2h-8l-2-2H6c-1.1 0-1.99.9-1.99 2L4 16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zM7 15l4.5-6 3.5 4.51 2.5-3.01L21 15H7z"></path></g>
<g id="perm-phone-msg"><path d="M20 15.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM12 3v10l3-3h6V3h-9z"></path></g>
<g id="perm-scan-wifi"><path d="M12 3C6.95 3 3.15 4.85 0 7.23L12 22 24 7.25C20.85 4.87 17.05 3 12 3zm1 13h-2v-6h2v6zm-2-8V6h2v2h-2z"></path></g>
<g id="pets"><circle cx="4.5" cy="9.5" r="2.5"></circle><circle cx="9" cy="5.5" r="2.5"></circle><circle cx="15" cy="5.5" r="2.5"></circle><circle cx="19.5" cy="9.5" r="2.5"></circle><path d="M17.34 14.86c-.87-1.02-1.6-1.89-2.48-2.91-.46-.54-1.05-1.08-1.75-1.32-.11-.04-.22-.07-.33-.09-.25-.04-.52-.04-.78-.04s-.53 0-.79.05c-.11.02-.22.05-.33.09-.7.24-1.28.78-1.75 1.32-.87 1.02-1.6 1.89-2.48 2.91-1.31 1.31-2.92 2.76-2.62 4.79.29 1.02 1.02 2.03 2.33 2.32.73.15 3.06-.44 5.54-.44h.18c2.48 0 4.81.58 5.54.44 1.31-.29 2.04-1.31 2.33-2.32.31-2.04-1.3-3.49-2.61-4.8z"></path></g>
<g id="picture-in-picture"><path d="M19 7h-8v6h8V7zm2-4H3c-1.1 0-2 .9-2 2v14c0 1.1.9 1.98 2 1.98h18c1.1 0 2-.88 2-1.98V5c0-1.1-.9-2-2-2zm0 16.01H3V4.98h18v14.03z"></path></g>
<g id="picture-in-picture-alt"><path d="M19 11h-8v6h8v-6zm4 8V4.98C23 3.88 22.1 3 21 3H3c-1.1 0-2 .88-2 1.98V19c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2zm-2 .02H3V4.97h18v14.05z"></path></g>
<g id="play-for-work"><path d="M11 5v5.59H7.5l4.5 4.5 4.5-4.5H13V5h-2zm-5 9c0 3.31 2.69 6 6 6s6-2.69 6-6h-2c0 2.21-1.79 4-4 4s-4-1.79-4-4H6z"></path></g>
<g id="polymer"><path d="M19 4h-4L7.11 16.63 4.5 12 9 4H5L.5 12 5 20h4l7.89-12.63L19.5 12 15 20h4l4.5-8z"></path></g>
<g id="power-settings-new"><path d="M13 3h-2v10h2V3zm4.83 2.17l-1.42 1.42C17.99 7.86 19 9.81 19 12c0 3.87-3.13 7-7 7s-7-3.13-7-7c0-2.19 1.01-4.14 2.58-5.42L6.17 5.17C4.23 6.82 3 9.26 3 12c0 4.97 4.03 9 9 9s9-4.03 9-9c0-2.74-1.23-5.18-3.17-6.83z"></path></g>
<g id="pregnant-woman"><path d="M9 4c0-1.11.89-2 2-2s2 .89 2 2-.89 2-2 2-2-.89-2-2zm7 9c-.01-1.34-.83-2.51-2-3 0-1.66-1.34-3-3-3s-3 1.34-3 3v7h2v5h3v-5h3v-4z"></path></g>
<g id="print"><path d="M19 8H5c-1.66 0-3 1.34-3 3v6h4v4h12v-4h4v-6c0-1.66-1.34-3-3-3zm-3 11H8v-5h8v5zm3-7c-.55 0-1-.45-1-1s.45-1 1-1 1 .45 1 1-.45 1-1 1zm-1-9H6v4h12V3z"></path></g>
<g id="query-builder"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path></g>
<g id="question-answer"><path d="M21 6h-2v9H6v2c0 .55.45 1 1 1h11l4 4V7c0-.55-.45-1-1-1zm-4 6V3c0-.55-.45-1-1-1H3c-.55 0-1 .45-1 1v14l4-4h10c.55 0 1-.45 1-1z"></path></g>
<g id="radio-button-checked"><path d="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="radio-button-unchecked"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z"></path></g>
<g id="receipt"><path d="M18 17H6v-2h12v2zm0-4H6v-2h12v2zm0-4H6V7h12v2zM3 22l1.5-1.5L6 22l1.5-1.5L9 22l1.5-1.5L12 22l1.5-1.5L15 22l1.5-1.5L18 22l1.5-1.5L21 22V2l-1.5 1.5L18 2l-1.5 1.5L15 2l-1.5 1.5L12 2l-1.5 1.5L9 2 7.5 3.5 6 2 4.5 3.5 3 2v20z"></path></g>
<g id="record-voice-over"><circle cx="9" cy="9" r="4"></circle><path d="M9 15c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4zm7.76-9.64l-1.68 1.69c.84 1.18.84 2.71 0 3.89l1.68 1.69c2.02-2.02 2.02-5.07 0-7.27zM20.07 2l-1.63 1.63c2.77 3.02 2.77 7.56 0 10.74L20.07 16c3.9-3.89 3.91-9.95 0-14z"></path></g>
<g id="redeem"><path d="M20 6h-2.18c.11-.31.18-.65.18-1 0-1.66-1.34-3-3-3-1.05 0-1.96.54-2.5 1.35l-.5.67-.5-.68C10.96 2.54 10.05 2 9 2 7.34 2 6 3.34 6 5c0 .35.07.69.18 1H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-5-2c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zM9 4c.55 0 1 .45 1 1s-.45 1-1 1-1-.45-1-1 .45-1 1-1zm11 15H4v-2h16v2zm0-5H4V8h5.08L7 10.83 8.62 12 11 8.76l1-1.36 1 1.36L15.38 12 17 10.83 14.92 8H20v6z"></path></g>
<g id="redo"><path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"></path></g>
<g id="refresh"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></g>
<g id="remove"><path d="M19 13H5v-2h14v2z"></path></g>
<g id="remove-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm5 11H7v-2h10v2z"></path></g>
<g id="remove-circle-outline"><path d="M7 11v2h10v-2H7zm5-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></g>
<g id="remove-shopping-cart"><path d="M22.73 22.73L2.77 2.77 2 2l-.73-.73L0 2.54l4.39 4.39 2.21 4.66-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h7.46l1.38 1.38c-.5.36-.83.95-.83 1.62 0 1.1.89 2 1.99 2 .67 0 1.26-.33 1.62-.84L21.46 24l1.27-1.27zM7.42 15c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h2.36l2 2H7.42zm8.13-2c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H6.54l9.01 9zM7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2z"></path></g>
<g id="reorder"><path d="M3 15h18v-2H3v2zm0 4h18v-2H3v2zm0-8h18V9H3v2zm0-6v2h18V5H3z"></path></g>
<g id="reply"><path d="M10 9V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"></path></g>
<g id="reply-all"><path d="M7 8V5l-7 7 7 7v-3l-4-4 4-4zm6 1V5l-7 7 7 7v-4.1c5 0 8.5 1.6 11 5.1-1-5-4-10-11-11z"></path></g>
<g id="report"><path d="M15.73 3H8.27L3 8.27v7.46L8.27 21h7.46L21 15.73V8.27L15.73 3zM12 17.3c-.72 0-1.3-.58-1.3-1.3 0-.72.58-1.3 1.3-1.3.72 0 1.3.58 1.3 1.3 0 .72-.58 1.3-1.3 1.3zm1-4.3h-2V7h2v6z"></path></g>
<g id="report-problem"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path></g>
<g id="restore"><path d="M13 3c-4.97 0-9 4.03-9 9H1l3.89 3.89.07.14L9 12H6c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.93 0-3.68-.79-4.94-2.06l-1.42 1.42C8.27 19.99 10.51 21 13 21c4.97 0 9-4.03 9-9s-4.03-9-9-9zm-1 5v5l4.28 2.54.72-1.21-3.5-2.08V8H12z"></path></g>
<g id="restore-page"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zm-2 16c-2.05 0-3.81-1.24-4.58-3h1.71c.63.9 1.68 1.5 2.87 1.5 1.93 0 3.5-1.57 3.5-3.5S13.93 9.5 12 9.5c-1.35 0-2.52.78-3.1 1.9l1.6 1.6h-4V9l1.3 1.3C8.69 8.92 10.23 8 12 8c2.76 0 5 2.24 5 5s-2.24 5-5 5z"></path></g>
<g id="room"><path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zm0 9.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z"></path></g>
<g id="rounded-corner"><path d="M19 19h2v2h-2v-2zm0-2h2v-2h-2v2zM3 13h2v-2H3v2zm0 4h2v-2H3v2zm0-8h2V7H3v2zm0-4h2V3H3v2zm4 0h2V3H7v2zm8 16h2v-2h-2v2zm-4 0h2v-2h-2v2zm4 0h2v-2h-2v2zm-8 0h2v-2H7v2zm-4 0h2v-2H3v2zM21 8c0-2.76-2.24-5-5-5h-5v2h5c1.65 0 3 1.35 3 3v5h2V8z"></path></g>
<g id="rowing"><path d="M8.5 14.5L4 19l1.5 1.5L9 17h2l-2.5-2.5zM15 1c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm6 20.01L18 24l-2.99-3.01V19.5l-7.1-7.09c-.31.05-.61.07-.91.07v-2.16c1.66.03 3.61-.87 4.67-2.04l1.4-1.55c.19-.21.43-.38.69-.5.29-.14.62-.23.96-.23h.03C15.99 6.01 17 7.02 17 8.26v5.75c0 .84-.35 1.61-.92 2.16l-3.58-3.58v-2.27c-.63.52-1.43 1.02-2.29 1.39L16.5 18H18l3 3.01z"></path></g>
<g id="save"><path d="M17 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V7l-4-4zm-5 16c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3zm3-10H5V5h10v4z"></path></g>
<g id="schedule"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zM12 20c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8zm.5-13H11v6l5.25 3.15.75-1.23-4.5-2.67z"></path></g>
<g id="search"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path></g>
<g id="select-all"><path d="M3 5h2V3c-1.1 0-2 .9-2 2zm0 8h2v-2H3v2zm4 8h2v-2H7v2zM3 9h2V7H3v2zm10-6h-2v2h2V3zm6 0v2h2c0-1.1-.9-2-2-2zM5 21v-2H3c0 1.1.9 2 2 2zm-2-4h2v-2H3v2zM9 3H7v2h2V3zm2 18h2v-2h-2v2zm8-8h2v-2h-2v2zm0 8c1.1 0 2-.9 2-2h-2v2zm0-12h2V7h-2v2zm0 8h2v-2h-2v2zm-4 4h2v-2h-2v2zm0-16h2V3h-2v2zM7 17h10V7H7v10zm2-8h6v6H9V9z"></path></g>
<g id="send"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"></path></g>
<g id="settings"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"></path></g>
<g id="settings-applications"><path d="M12 10c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm7-7H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-1.75 9c0 .23-.02.46-.05.68l1.48 1.16c.13.11.17.3.08.45l-1.4 2.42c-.09.15-.27.21-.43.15l-1.74-.7c-.36.28-.76.51-1.18.69l-.26 1.85c-.03.17-.18.3-.35.3h-2.8c-.17 0-.32-.13-.35-.29l-.26-1.85c-.43-.18-.82-.41-1.18-.69l-1.74.7c-.16.06-.34 0-.43-.15l-1.4-2.42c-.09-.15-.05-.34.08-.45l1.48-1.16c-.03-.23-.05-.46-.05-.69 0-.23.02-.46.05-.68l-1.48-1.16c-.13-.11-.17-.3-.08-.45l1.4-2.42c.09-.15.27-.21.43-.15l1.74.7c.36-.28.76-.51 1.18-.69l.26-1.85c.03-.17.18-.3.35-.3h2.8c.17 0 .32.13.35.29l.26 1.85c.43.18.82.41 1.18.69l1.74-.7c.16-.06.34 0 .43.15l1.4 2.42c.09.15.05.34-.08.45l-1.48 1.16c.03.23.05.46.05.69z"></path></g>
<g id="settings-backup-restore"><path d="M14 12c0-1.1-.9-2-2-2s-2 .9-2 2 .9 2 2 2 2-.9 2-2zm-2-9c-4.97 0-9 4.03-9 9H0l4 4 4-4H5c0-3.87 3.13-7 7-7s7 3.13 7 7-3.13 7-7 7c-1.51 0-2.91-.49-4.06-1.3l-1.42 1.44C8.04 20.3 9.94 21 12 21c4.97 0 9-4.03 9-9s-4.03-9-9-9z"></path></g>
<g id="settings-bluetooth"><path d="M11 24h2v-2h-2v2zm-4 0h2v-2H7v2zm8 0h2v-2h-2v2zm2.71-18.29L12 0h-1v7.59L6.41 3 5 4.41 10.59 10 5 15.59 6.41 17 11 12.41V20h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 3.83l1.88 1.88L13 7.59V3.83zm1.88 10.46L13 16.17v-3.76l1.88 1.88z"></path></g>
<g id="settings-brightness"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02zM8 16h2.5l1.5 1.5 1.5-1.5H16v-2.5l1.5-1.5-1.5-1.5V8h-2.5L12 6.5 10.5 8H8v2.5L6.5 12 8 13.5V16zm4-7c1.66 0 3 1.34 3 3s-1.34 3-3 3V9z"></path></g>
<g id="settings-cell"><path d="M7 24h2v-2H7v2zm4 0h2v-2h-2v2zm4 0h2v-2h-2v2zM16 .01L8 0C6.9 0 6 .9 6 2v16c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V2c0-1.1-.9-1.99-2-1.99zM16 16H8V4h8v12z"></path></g>
<g id="settings-ethernet"><path d="M7.77 6.76L6.23 5.48.82 12l5.41 6.52 1.54-1.28L3.42 12l4.35-5.24zM7 13h2v-2H7v2zm10-2h-2v2h2v-2zm-6 2h2v-2h-2v2zm6.77-7.52l-1.54 1.28L20.58 12l-4.35 5.24 1.54 1.28L23.18 12l-5.41-6.52z"></path></g>
<g id="settings-input-antenna"><path d="M12 5c-3.87 0-7 3.13-7 7h2c0-2.76 2.24-5 5-5s5 2.24 5 5h2c0-3.87-3.13-7-7-7zm1 9.29c.88-.39 1.5-1.26 1.5-2.29 0-1.38-1.12-2.5-2.5-2.5S9.5 10.62 9.5 12c0 1.02.62 1.9 1.5 2.29v3.3L7.59 21 9 22.41l3-3 3 3L16.41 21 13 17.59v-3.3zM12 1C5.93 1 1 5.93 1 12h2c0-4.97 4.03-9 9-9s9 4.03 9 9h2c0-6.07-4.93-11-11-11z"></path></g>
<g id="settings-input-component"><path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"></path></g>
<g id="settings-input-composite"><path d="M5 2c0-.55-.45-1-1-1s-1 .45-1 1v4H1v6h6V6H5V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2H9v2zm-8 0c0 1.3.84 2.4 2 2.82V23h2v-4.18C6.16 18.4 7 17.3 7 16v-2H1v2zM21 6V2c0-.55-.45-1-1-1s-1 .45-1 1v4h-2v6h6V6h-2zm-8-4c0-.55-.45-1-1-1s-1 .45-1 1v4H9v6h6V6h-2V2zm4 14c0 1.3.84 2.4 2 2.82V23h2v-4.18c1.16-.41 2-1.51 2-2.82v-2h-6v2z"></path></g>
<g id="settings-input-hdmi"><path d="M18 7V4c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v3H5v6l3 6v3h8v-3l3-6V7h-1zM8 4h8v3h-2V5h-1v2h-2V5h-1v2H8V4z"></path></g>
<g id="settings-input-svideo"><path d="M8 11.5c0-.83-.67-1.5-1.5-1.5S5 10.67 5 11.5 5.67 13 6.5 13 8 12.33 8 11.5zm7-5c0-.83-.67-1.5-1.5-1.5h-3C9.67 5 9 5.67 9 6.5S9.67 8 10.5 8h3c.83 0 1.5-.67 1.5-1.5zM8.5 15c-.83 0-1.5.67-1.5 1.5S7.67 18 8.5 18s1.5-.67 1.5-1.5S9.33 15 8.5 15zM12 1C5.93 1 1 5.93 1 12s4.93 11 11 11 11-4.93 11-11S18.07 1 12 1zm0 20c-4.96 0-9-4.04-9-9s4.04-9 9-9 9 4.04 9 9-4.04 9-9 9zm5.5-11c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm-2 5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path></g>
<g id="settings-overscan"><path d="M12.01 5.5L10 8h4l-1.99-2.5zM18 10v4l2.5-1.99L18 10zM6 10l-2.5 2.01L6 14v-4zm8 6h-4l2.01 2.5L14 16zm7-13H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16.01H3V4.99h18v14.02z"></path></g>
<g id="settings-phone"><path d="M13 9h-2v2h2V9zm4 0h-2v2h2V9zm3 6.5c-1.25 0-2.45-.2-3.57-.57-.35-.11-.74-.03-1.02.24l-2.2 2.2c-2.83-1.44-5.15-3.75-6.59-6.58l2.2-2.21c.28-.27.36-.66.25-1.01C8.7 6.45 8.5 5.25 8.5 4c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1 0 9.39 7.61 17 17 17 .55 0 1-.45 1-1v-3.5c0-.55-.45-1-1-1zM19 9v2h2V9h-2z"></path></g>
<g id="settings-power"><path d="M7 24h2v-2H7v2zm4 0h2v-2h-2v2zm2-22h-2v10h2V2zm3.56 2.44l-1.45 1.45C16.84 6.94 18 8.83 18 11c0 3.31-2.69 6-6 6s-6-2.69-6-6c0-2.17 1.16-4.06 2.88-5.12L7.44 4.44C5.36 5.88 4 8.28 4 11c0 4.42 3.58 8 8 8s8-3.58 8-8c0-2.72-1.36-5.12-3.44-6.56zM15 24h2v-2h-2v2z"></path></g>
<g id="settings-remote"><path d="M15 9H9c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h6c.55 0 1-.45 1-1V10c0-.55-.45-1-1-1zm-3 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2zM7.05 6.05l1.41 1.41C9.37 6.56 10.62 6 12 6s2.63.56 3.54 1.46l1.41-1.41C15.68 4.78 13.93 4 12 4s-3.68.78-4.95 2.05zM12 0C8.96 0 6.21 1.23 4.22 3.22l1.41 1.41C7.26 3.01 9.51 2 12 2s4.74 1.01 6.36 2.64l1.41-1.41C17.79 1.23 15.04 0 12 0z"></path></g>
<g id="settings-voice"><path d="M7 24h2v-2H7v2zm5-11c1.66 0 2.99-1.34 2.99-3L15 4c0-1.66-1.34-3-3-3S9 2.34 9 4v6c0 1.66 1.34 3 3 3zm-1 11h2v-2h-2v2zm4 0h2v-2h-2v2zm4-14h-1.7c0 3-2.54 5.1-5.3 5.1S6.7 13 6.7 10H5c0 3.41 2.72 6.23 6 6.72V20h2v-3.28c3.28-.49 6-3.31 6-6.72z"></path></g>
<g id="shop"><path d="M16 6V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H2v13c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V6h-6zm-6-2h4v2h-4V4zM9 18V9l7.5 4L9 18z"></path></g>
<g id="shop-two"><path d="M3 9H1v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2H3V9zm15-4V3c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H5v11c0 1.11.89 2 2 2h14c1.11 0 2-.89 2-2V5h-5zm-6-2h4v2h-4V3zm0 12V8l5.5 3-5.5 4z"></path></g>
<g id="shopping-basket"><path d="M17.21 9l-4.38-6.56c-.19-.28-.51-.42-.83-.42-.32 0-.64.14-.83.43L6.79 9H2c-.55 0-1 .45-1 1 0 .09.01.18.04.27l2.54 9.27c.23.84 1 1.46 1.92 1.46h13c.92 0 1.69-.62 1.93-1.46l2.54-9.27L23 10c0-.55-.45-1-1-1h-4.79zM9 9l3-4.4L15 9H9zm3 8c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"></path></g>
<g id="shopping-cart"><path d="M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2zM1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2H1zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2z"></path></g>
<g id="sort"><path d="M3 18h6v-2H3v2zM3 6v2h18V6H3zm0 7h12v-2H3v2z"></path></g>
<g id="speaker-notes"><path d="M20 2H4c-1.1 0-1.99.9-1.99 2L2 22l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zM8 14H6v-2h2v2zm0-3H6V9h2v2zm0-3H6V6h2v2zm7 6h-5v-2h5v2zm3-3h-8V9h8v2zm0-3h-8V6h8v2z"></path></g>
<g id="speaker-notes-off"><path d="M10.54 11l-.54-.54L7.54 8 6 6.46 2.38 2.84 1.27 1.73 0 3l2.01 2.01L2 22l4-4h9l5.73 5.73L22 22.46 17.54 18l-7-7zM8 14H6v-2h2v2zm-2-3V9l2 2H6zm14-9H4.08L10 7.92V6h8v2h-7.92l1 1H18v2h-4.92l6.99 6.99C21.14 17.95 22 17.08 22 16V4c0-1.1-.9-2-2-2z"></path></g>
<g id="spellcheck"><path d="M12.45 16h2.09L9.43 3H7.57L2.46 16h2.09l1.12-3h5.64l1.14 3zm-6.02-5L8.5 5.48 10.57 11H6.43zm15.16.59l-8.09 8.09L9.83 16l-1.41 1.41 5.09 5.09L23 13l-1.41-1.41z"></path></g>
<g id="star"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"></path></g>
<g id="star-border"><path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4l-3.76 2.27 1-4.28-3.32-2.88 4.38-.38L12 6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"></path></g>
<g id="star-half"><path d="M22 9.24l-7.19-.62L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21 12 17.27 18.18 21l-1.63-7.03L22 9.24zM12 15.4V6.1l1.71 4.04 4.38.38-3.32 2.88 1 4.28L12 15.4z"></path></g>
<g id="stars"><path d="M11.99 2C6.47 2 2 6.48 2 12s4.47 10 9.99 10C17.52 22 22 17.52 22 12S17.52 2 11.99 2zm4.24 16L12 15.45 7.77 18l1.12-4.81-3.73-3.23 4.92-.42L12 5l1.92 4.53 4.92.42-3.73 3.23L16.23 18z"></path></g>
<g id="store"><path d="M20 4H4v2h16V4zm1 10v-2l-1-5H4l-1 5v2h1v6h10v-6h4v6h2v-6h1zm-9 4H6v-4h6v4z"></path></g>
<g id="subdirectory-arrow-left"><path d="M11 9l1.42 1.42L8.83 14H18V4h2v12H8.83l3.59 3.58L11 21l-6-6 6-6z"></path></g>
<g id="subdirectory-arrow-right"><path d="M19 15l-6 6-1.42-1.42L15.17 16H4V4h2v10h9.17l-3.59-3.58L13 9l6 6z"></path></g>
<g id="subject"><path d="M14 17H4v2h10v-2zm6-8H4v2h16V9zM4 15h16v-2H4v2zM4 5v2h16V5H4z"></path></g>
<g id="supervisor-account"><path d="M16.5 12c1.38 0 2.49-1.12 2.49-2.5S17.88 7 16.5 7C15.12 7 14 8.12 14 9.5s1.12 2.5 2.5 2.5zM9 11c1.66 0 2.99-1.34 2.99-3S10.66 5 9 5C7.34 5 6 6.34 6 8s1.34 3 3 3zm7.5 3c-1.83 0-5.5.92-5.5 2.75V19h11v-2.25c0-1.83-3.67-2.75-5.5-2.75zM9 13c-2.33 0-7 1.17-7 3.5V19h7v-2.25c0-.85.33-2.34 2.37-3.47C10.5 13.1 9.66 13 9 13z"></path></g>
<g id="swap-horiz"><path d="M6.99 11L3 15l3.99 4v-3H14v-2H6.99v-3zM21 9l-3.99-4v3H10v2h7.01v3L21 9z"></path></g>
<g id="swap-vert"><path d="M16 17.01V10h-2v7.01h-3L15 21l4-3.99h-3zM9 3L5 6.99h3V14h2V6.99h3L9 3z"></path></g>
<g id="swap-vertical-circle"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zM6.5 9L10 5.5 13.5 9H11v4H9V9H6.5zm11 6L14 18.5 10.5 15H13v-4h2v4h2.5z"></path></g>
<g id="system-update-alt"><path d="M12 16.5l4-4h-3v-9h-2v9H8l4 4zm9-13h-6v1.99h6v14.03H3V5.49h6V3.5H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-14c0-1.1-.9-2-2-2z"></path></g>
<g id="tab"><path d="M21 3H3c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H3V5h10v4h8v10z"></path></g>
<g id="tab-unselected"><path d="M1 9h2V7H1v2zm0 4h2v-2H1v2zm0-8h2V3c-1.1 0-2 .9-2 2zm8 16h2v-2H9v2zm-8-4h2v-2H1v2zm2 4v-2H1c0 1.1.9 2 2 2zM21 3h-8v6h10V5c0-1.1-.9-2-2-2zm0 14h2v-2h-2v2zM9 5h2V3H9v2zM5 21h2v-2H5v2zM5 5h2V3H5v2zm16 16c1.1 0 2-.9 2-2h-2v2zm0-8h2v-2h-2v2zm-8 8h2v-2h-2v2zm4 0h2v-2h-2v2z"></path></g>
<g id="text-format"><path d="M5 17v2h14v-2H5zm4.5-4.2h5l.9 2.2h2.1L12.75 4h-1.5L6.5 15h2.1l.9-2.2zM12 5.98L13.87 11h-3.74L12 5.98z"></path></g>
<g id="theaters"><path d="M18 3v2h-2V3H8v2H6V3H4v18h2v-2h2v2h8v-2h2v2h2V3h-2zM8 17H6v-2h2v2zm0-4H6v-2h2v2zm0-4H6V7h2v2zm10 8h-2v-2h2v2zm0-4h-2v-2h2v2zm0-4h-2V7h2v2z"></path></g>
<g id="thumb-down"><path d="M15 3H6c-.83 0-1.54.5-1.84 1.22l-3.02 7.05c-.09.23-.14.47-.14.73v1.91l.01.01L1 14c0 1.1.9 2 2 2h6.31l-.95 4.57-.03.32c0 .41.17.79.44 1.06L9.83 23l6.59-6.59c.36-.36.58-.86.58-1.41V5c0-1.1-.9-2-2-2zm4 0v12h4V3h-4z"></path></g>
<g id="thumb-up"><path d="M1 21h4V9H1v12zm22-11c0-1.1-.9-2-2-2h-6.31l.95-4.57.03-.32c0-.41-.17-.79-.44-1.06L14.17 1 7.59 7.59C7.22 7.95 7 8.45 7 9v10c0 1.1.9 2 2 2h9c.83 0 1.54-.5 1.84-1.22l3.02-7.05c.09-.23.14-.47.14-.73v-1.91l-.01-.01L23 10z"></path></g>
<g id="thumbs-up-down"><path d="M12 6c0-.55-.45-1-1-1H5.82l.66-3.18.02-.23c0-.31-.13-.59-.33-.8L5.38 0 .44 4.94C.17 5.21 0 5.59 0 6v6.5c0 .83.67 1.5 1.5 1.5h6.75c.62 0 1.15-.38 1.38-.91l2.26-5.29c.07-.17.11-.36.11-.55V6zm10.5 4h-6.75c-.62 0-1.15.38-1.38.91l-2.26 5.29c-.07.17-.11.36-.11.55V18c0 .55.45 1 1 1h5.18l-.66 3.18-.02.24c0 .31.13.59.33.8l.79.78 4.94-4.94c.27-.27.44-.65.44-1.06v-6.5c0-.83-.67-1.5-1.5-1.5z"></path></g>
<g id="timeline"><path d="M23 8c0 1.1-.9 2-2 2-.18 0-.35-.02-.51-.07l-3.56 3.55c.05.16.07.34.07.52 0 1.1-.9 2-2 2s-2-.9-2-2c0-.18.02-.36.07-.52l-2.55-2.55c-.16.05-.34.07-.52.07s-.36-.02-.52-.07l-4.55 4.56c.05.16.07.33.07.51 0 1.1-.9 2-2 2s-2-.9-2-2 .9-2 2-2c.18 0 .35.02.51.07l4.56-4.55C8.02 9.36 8 9.18 8 9c0-1.1.9-2 2-2s2 .9 2 2c0 .18-.02.36-.07.52l2.55 2.55c.16-.05.34-.07.52-.07s.36.02.52.07l3.55-3.56C19.02 8.35 19 8.18 19 8c0-1.1.9-2 2-2s2 .9 2 2z"></path></g>
<g id="toc"><path d="M3 9h14V7H3v2zm0 4h14v-2H3v2zm0 4h14v-2H3v2zm16 0h2v-2h-2v2zm0-10v2h2V7h-2zm0 6h2v-2h-2v2z"></path></g>
<g id="today"><path d="M19 3h-1V1h-2v2H8V1H6v2H5c-1.11 0-1.99.9-1.99 2L3 19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm0 16H5V8h14v11zM7 10h5v5H7z"></path></g>
<g id="toll"><path d="M15 4c-4.42 0-8 3.58-8 8s3.58 8 8 8 8-3.58 8-8-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6zM3 12c0-2.61 1.67-4.83 4-5.65V4.26C3.55 5.15 1 8.27 1 12s2.55 6.85 6 7.74v-2.09c-2.33-.82-4-3.04-4-5.65z"></path></g>
<g id="touch-app"><path d="M9 11.24V7.5C9 6.12 10.12 5 11.5 5S14 6.12 14 7.5v3.74c1.21-.81 2-2.18 2-3.74C16 5.01 13.99 3 11.5 3S7 5.01 7 7.5c0 1.56.79 2.93 2 3.74zm9.84 4.63l-4.54-2.26c-.17-.07-.35-.11-.54-.11H13v-6c0-.83-.67-1.5-1.5-1.5S10 6.67 10 7.5v10.74l-3.43-.72c-.08-.01-.15-.03-.24-.03-.31 0-.59.13-.79.33l-.79.8 4.94 4.94c.27.27.65.44 1.06.44h6.79c.75 0 1.33-.55 1.44-1.28l.75-5.27c.01-.07.02-.14.02-.2 0-.62-.38-1.16-.91-1.38z"></path></g>
<g id="track-changes"><path d="M19.07 4.93l-1.41 1.41C19.1 7.79 20 9.79 20 12c0 4.42-3.58 8-8 8s-8-3.58-8-8c0-4.08 3.05-7.44 7-7.93v2.02C8.16 6.57 6 9.03 6 12c0 3.31 2.69 6 6 6s6-2.69 6-6c0-1.66-.67-3.16-1.76-4.24l-1.41 1.41C15.55 9.9 16 10.9 16 12c0 2.21-1.79 4-4 4s-4-1.79-4-4c0-1.86 1.28-3.41 3-3.86v2.14c-.6.35-1 .98-1 1.72 0 1.1.9 2 2 2s2-.9 2-2c0-.74-.4-1.38-1-1.72V2h-1C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10c0-2.76-1.12-5.26-2.93-7.07z"></path></g>
<g id="translate"><path d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></g>
<g id="trending-down"><path d="M16 18l2.29-2.29-4.88-4.88-4 4L2 7.41 3.41 6l6 6 4-4 6.3 6.29L22 12v6z"></path></g>
<g id="trending-flat"><path d="M22 12l-4-4v3H3v2h15v3z"></path></g>
<g id="trending-up"><path d="M16 6l2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"></path></g>
<g id="turned-in"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2z"></path></g>
<g id="turned-in-not"><path d="M17 3H7c-1.1 0-1.99.9-1.99 2L5 21l7-3 7 3V5c0-1.1-.9-2-2-2zm0 15l-5-2.18L7 18V5h10v13z"></path></g>
<g id="unarchive"><path d="M20.55 5.22l-1.39-1.68C18.88 3.21 18.47 3 18 3H6c-.47 0-.88.21-1.15.55L3.46 5.22C3.17 5.57 3 6.01 3 6.5V19c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2V6.5c0-.49-.17-.93-.45-1.28zM12 9.5l5.5 5.5H14v2h-4v-2H6.5L12 9.5zM5.12 5l.82-1h12l.93 1H5.12z"></path></g>
<g id="undo"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"></path></g>
<g id="unfold-less"><path d="M7.41 18.59L8.83 20 12 16.83 15.17 20l1.41-1.41L12 14l-4.59 4.59zm9.18-13.18L15.17 4 12 7.17 8.83 4 7.41 5.41 12 10l4.59-4.59z"></path></g>
<g id="unfold-more"><path d="M12 5.83L15.17 9l1.41-1.41L12 3 7.41 7.59 8.83 9 12 5.83zm0 12.34L8.83 15l-1.41 1.41L12 21l4.59-4.59L15.17 15 12 18.17z"></path></g>
<g id="update"><path d="M21 10.12h-6.78l2.74-2.82c-2.73-2.7-7.15-2.8-9.88-.1-2.73 2.71-2.73 7.08 0 9.79 2.73 2.71 7.15 2.71 9.88 0C18.32 15.65 19 14.08 19 12.1h2c0 1.98-.88 4.55-2.64 6.29-3.51 3.48-9.21 3.48-12.72 0-3.5-3.47-3.53-9.11-.02-12.58 3.51-3.47 9.14-3.47 12.65 0L21 3v7.12zM12.5 8v4.25l3.5 2.08-.72 1.21L11 13V8h1.5z"></path></g>
<g id="verified-user"><path d="M12 1L3 5v6c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V5l-9-4zm-2 16l-4-4 1.41-1.41L10 14.17l6.59-6.59L18 9l-8 8z"></path></g>
<g id="view-agenda"><path d="M20 13H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1v-6c0-.55-.45-1-1-1zm0-10H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V4c0-.55-.45-1-1-1z"></path></g>
<g id="view-array"><path d="M4 18h3V5H4v13zM18 5v13h3V5h-3zM8 18h9V5H8v13z"></path></g>
<g id="view-carousel"><path d="M7 19h10V4H7v15zm-5-2h4V6H2v11zM18 6v11h4V6h-4z"></path></g>
<g id="view-column"><path d="M10 18h5V5h-5v13zm-6 0h5V5H4v13zM16 5v13h5V5h-5z"></path></g>
<g id="view-day"><path d="M2 21h19v-3H2v3zM20 8H3c-.55 0-1 .45-1 1v6c0 .55.45 1 1 1h17c.55 0 1-.45 1-1V9c0-.55-.45-1-1-1zM2 3v3h19V3H2z"></path></g>
<g id="view-headline"><path d="M4 15h16v-2H4v2zm0 4h16v-2H4v2zm0-8h16V9H4v2zm0-6v2h16V5H4z"></path></g>
<g id="view-list"><path d="M4 14h4v-4H4v4zm0 5h4v-4H4v4zM4 9h4V5H4v4zm5 5h12v-4H9v4zm0 5h12v-4H9v4zM9 5v4h12V5H9z"></path></g>
<g id="view-module"><path d="M4 11h5V5H4v6zm0 7h5v-6H4v6zm6 0h5v-6h-5v6zm6 0h5v-6h-5v6zm-6-7h5V5h-5v6zm6-6v6h5V5h-5z"></path></g>
<g id="view-quilt"><path d="M10 18h5v-6h-5v6zm-6 0h5V5H4v13zm12 0h5v-6h-5v6zM10 5v6h11V5H10z"></path></g>
<g id="view-stream"><path d="M4 18h17v-6H4v6zM4 5v6h17V5H4z"></path></g>
<g id="view-week"><path d="M6 5H3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm14 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1zm-7 0h-3c-.55 0-1 .45-1 1v12c0 .55.45 1 1 1h3c.55 0 1-.45 1-1V6c0-.55-.45-1-1-1z"></path></g>
<g id="visibility"><path d="M12 4.5C7 4.5 2.73 7.61 1 12c1.73 4.39 6 7.5 11 7.5s9.27-3.11 11-7.5c-1.73-4.39-6-7.5-11-7.5zM12 17c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5zm0-8c-1.66 0-3 1.34-3 3s1.34 3 3 3 3-1.34 3-3-1.34-3-3-3z"></path></g>
<g id="visibility-off"><path d="M12 7c2.76 0 5 2.24 5 5 0 .65-.13 1.26-.36 1.83l2.92 2.92c1.51-1.26 2.7-2.89 3.43-4.75-1.73-4.39-6-7.5-11-7.5-1.4 0-2.74.25-3.98.7l2.16 2.16C10.74 7.13 11.35 7 12 7zM2 4.27l2.28 2.28.46.46C3.08 8.3 1.78 10.02 1 12c1.73 4.39 6 7.5 11 7.5 1.55 0 3.03-.3 4.38-.84l.42.42L19.73 22 21 20.73 3.27 3 2 4.27zM7.53 9.8l1.55 1.55c-.05.21-.08.43-.08.65 0 1.66 1.34 3 3 3 .22 0 .44-.03.65-.08l1.55 1.55c-.67.33-1.41.53-2.2.53-2.76 0-5-2.24-5-5 0-.79.2-1.53.53-2.2zm4.31-.78l3.15 3.15.02-.16c0-1.66-1.34-3-3-3l-.17.01z"></path></g>
<g id="warning"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"></path></g>
<g id="watch-later"><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm4.2 14.2L11 13V7h1.5v5.2l4.5 2.7-.8 1.3z"></path></g>
<g id="weekend"><path d="M21 10c-1.1 0-2 .9-2 2v3H5v-3c0-1.1-.9-2-2-2s-2 .9-2 2v5c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2v-5c0-1.1-.9-2-2-2zm-3-5H6c-1.1 0-2 .9-2 2v2.15c1.16.41 2 1.51 2 2.82V14h12v-2.03c0-1.3.84-2.4 2-2.82V7c0-1.1-.9-2-2-2z"></path></g>
<g id="work"><path d="M20 6h-4V4c0-1.11-.89-2-2-2h-4c-1.11 0-2 .89-2 2v2H4c-1.11 0-1.99.89-1.99 2L2 19c0 1.11.89 2 2 2h16c1.11 0 2-.89 2-2V8c0-1.11-.89-2-2-2zm-6 0h-4V4h4v2z"></path></g>
<g id="youtube-searched-for"><path d="M17.01 14h-.8l-.27-.27c.98-1.14 1.57-2.61 1.57-4.23 0-3.59-2.91-6.5-6.5-6.5s-6.5 3-6.5 6.5H2l3.84 4 4.16-4H6.51C6.51 7 8.53 5 11.01 5s4.5 2.01 4.5 4.5c0 2.48-2.02 4.5-4.5 4.5-.65 0-1.26-.14-1.82-.38L7.71 15.1c.97.57 2.09.9 3.3.9 1.61 0 3.08-.59 4.22-1.57l.27.27v.79l5.01 4.99L22 19l-4.99-5z"></path></g>
<g id="zoom-in"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zm2.5-4h-2v2H9v-2H7V9h2V7h1v2h2v1z"></path></g>
<g id="zoom-out"><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14zM7 9h5v1H7z"></path></g>
</defs></svg>
</iron-iconset-svg>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 99 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_meta_iron_meta_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




/**
 * The `iron-iconset-svg` element allows users to define their own icon sets
 * that contain svg icons. The svg icon elements should be children of the
 * `iron-iconset-svg` element. Multiple icons should be given distinct id's.
 *
 * Using svg elements to create icons has a few advantages over traditional
 * bitmap graphics like jpg or png. Icons that use svg are vector based so
 * they are resolution independent and should look good on any device. They
 * are stylable via css. Icons can be themed, colorized, and even animated.
 *
 * Example:
 *
 *     <iron-iconset-svg name="my-svg-icons" size="24">
 *       <svg>
 *         <defs>
 *           <g id="shape">
 *             <rect x="12" y="0" width="12" height="24" />
 *             <circle cx="12" cy="12" r="12" />
 *           </g>
 *         </defs>
 *       </svg>
 *     </iron-iconset-svg>
 *
 * This will automatically register the icon set "my-svg-icons" to the iconset
 * database.  To use these icons from within another element, make a
 * `iron-iconset` element and call the `byId` method
 * to retrieve a given iconset. To apply a particular icon inside an
 * element use the `applyIcon` method. For example:
 *
 *     iconset.applyIcon(iconNode, 'car');
 *
 * @element iron-iconset-svg
 * @demo demo/index.html
 * @implements {Polymer.Iconset}
 */
Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'iron-iconset-svg',

  properties: {

    /**
     * The name of the iconset.
     */
    name: {
      type: String,
      observer: '_nameChanged'
    },

    /**
     * The size of an individual icon. Note that icons must be square.
     */
    size: {
      type: Number,
      value: 24
    },

    /**
     * Set to true to enable mirroring of icons where specified when they are
     * stamped. Icons that should be mirrored should be decorated with a
     * `mirror-in-rtl` attribute.
     *
     * NOTE: For performance reasons, direction will be resolved once per
     * document per iconset, so moving icons in and out of RTL subtrees will
     * not cause their mirrored state to change.
     */
    rtlMirroring: {
      type: Boolean,
      value: false
    }
  },

  created: function() {
    this._meta = new __WEBPACK_IMPORTED_MODULE_1__iron_meta_iron_meta_js__["a" /* IronMeta */]({type: 'iconset', key: null, value: null});
  },

  attached: function() {
    this.style.display = 'none';
  },

  /**
   * Construct an array of all icon names in this iconset.
   *
   * @return {!Array} Array of icon names.
   */
  getIconNames: function() {
    this._icons = this._createIconMap();
    return Object.keys(this._icons).map(function(n) {
      return this.name + ':' + n;
    }, this);
  },

  /**
   * Applies an icon to the given element.
   *
   * An svg icon is prepended to the element's shadowRoot if it exists,
   * otherwise to the element itself.
   *
   * If RTL mirroring is enabled, and the icon is marked to be mirrored in
   * RTL, the element will be tested (once and only once ever for each
   * iconset) to determine the direction of the subtree the element is in.
   * This direction will apply to all future icon applications, although only
   * icons marked to be mirrored will be affected.
   *
   * @method applyIcon
   * @param {Element} element Element to which the icon is applied.
   * @param {string} iconName Name of the icon to apply.
   * @return {?Element} The svg element which renders the icon.
   */
  applyIcon: function(element, iconName) {
    // Remove old svg element
    this.removeIcon(element);
    // install new svg element
    var svg = this._cloneIcon(iconName,
        this.rtlMirroring && this._targetIsRTL(element));
    if (svg) {
      // insert svg element into shadow root, if it exists
      var pde = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(element.root || element);
      pde.insertBefore(svg, pde.childNodes[0]);
      return element._svgIcon = svg;
    }
    return null;
  },

  /**
   * Remove an icon from the given element by undoing the changes effected
   * by `applyIcon`.
   *
   * @param {Element} element The element from which the icon is removed.
   */
  removeIcon: function(element) {
    // Remove old svg element
    if (element._svgIcon) {
      Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(element.root || element).removeChild(element._svgIcon);
      element._svgIcon = null;
    }
  },

  /**
   * Measures and memoizes the direction of the element. Note that this
   * measurement is only done once and the result is memoized for future
   * invocations.
   */
  _targetIsRTL: function(target) {
    if (this.__targetIsRTL == null) {
      if (target && target.nodeType !== Node.ELEMENT_NODE) {
        target = target.host;
      }

      this.__targetIsRTL = target &&
          window.getComputedStyle(target)['direction'] === 'rtl';
    }

    return this.__targetIsRTL;
  },

  /**
   *
   * When name is changed, register iconset metadata
   *
   */
  _nameChanged: function() {
    this._meta.value = null;
    this._meta.key = this.name;
    this._meta.value = this;

    this.async(function() {
      this.fire('iron-iconset-added', this, {node: window});
    });
  },

  /**
   * Create a map of child SVG elements by id.
   *
   * @return {!Object} Map of id's to SVG elements.
   */
  _createIconMap: function() {
    // Objects chained to Object.prototype (`{}`) have members. Specifically,
    // on FF there is a `watch` method that confuses the icon map, so we
    // need to use a null-based object here.
    var icons = Object.create(null);
    Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).querySelectorAll('[id]')
      .forEach(function(icon) {
        icons[icon.id] = icon;
      });
    return icons;
  },

  /**
   * Produce installable clone of the SVG element matching `id` in this
   * iconset, or `undefined` if there is no matching element.
   *
   * @return {Element} Returns an installable clone of the SVG element
   * matching `id`.
   */
  _cloneIcon: function(id, mirrorAllowed) {
    // create the icon map on-demand, since the iconset itself has no discrete
    // signal to know when it's children are fully parsed
    this._icons = this._icons || this._createIconMap();
    return this._prepareSvgClone(this._icons[id], this.size, mirrorAllowed);
  },

  /**
   * @param {Element} sourceSvg
   * @param {number} size
   * @param {Boolean} mirrorAllowed
   * @return {Element}
   */
  _prepareSvgClone: function(sourceSvg, size, mirrorAllowed) {
    if (sourceSvg) {
      var content = sourceSvg.cloneNode(true),
          svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg'),
          viewBox = content.getAttribute('viewBox') || '0 0 ' + size + ' ' + size,
          cssText = 'pointer-events: none; display: block; width: 100%; height: 100%;';

      if (mirrorAllowed && content.hasAttribute('mirror-in-rtl')) {
        cssText += '-webkit-transform:scale(-1,1);transform:scale(-1,1);';
      }

      svg.setAttribute('viewBox', viewBox);
      svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
      svg.setAttribute('focusable', 'false');
      // TODO(dfreedm): `pointer-events: none` works around https://crbug.com/370136
      // TODO(sjmiles): inline style may not be ideal, but avoids requiring a shadow-root
      svg.style.cssText = cssText;
      svg.appendChild(content).removeAttribute('id');
      return svg;
    }
    return null;
  }

});


/***/ }),
/* 100 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_color_js__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__paper_behaviors_paper_checked_element_behavior_js__ = __webpack_require__(51);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polymer_lib_utils_render_status_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_lib_utils_gestures_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__paper_behaviors_paper_ripple_behavior_js__ = __webpack_require__(19);









const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-toggle-button">
  <template strip-whitespace="">

    <style>
      :host {
        display: inline-block;
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --paper-font-common-base;
      }

      :host([disabled]) {
        pointer-events: none;
      }

      :host(:focus) {
        outline:none;
      }

      .toggle-bar {
        position: absolute;
        height: 100%;
        width: 100%;
        border-radius: 8px;
        pointer-events: none;
        opacity: 0.4;
        transition: background-color linear .08s;
        background-color: var(--paper-toggle-button-unchecked-bar-color, #000000);

        @apply --paper-toggle-button-unchecked-bar;
      }

      .toggle-button {
        position: absolute;
        top: -3px;
        left: 0;
        height: 20px;
        width: 20px;
        border-radius: 50%;
        box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.6);
        transition: -webkit-transform linear .08s, background-color linear .08s;
        transition: transform linear .08s, background-color linear .08s;
        will-change: transform;
        background-color: var(--paper-toggle-button-unchecked-button-color, var(--paper-grey-50));

        @apply --paper-toggle-button-unchecked-button;
      }

      .toggle-button.dragging {
        -webkit-transition: none;
        transition: none;
      }

      :host([checked]:not([disabled])) .toggle-bar {
        opacity: 0.5;
        background-color: var(--paper-toggle-button-checked-bar-color, var(--primary-color));

        @apply --paper-toggle-button-checked-bar;
      }

      :host([disabled]) .toggle-bar {
        background-color: #000;
        opacity: 0.12;
      }

      :host([checked]) .toggle-button {
        -webkit-transform: translate(16px, 0);
        transform: translate(16px, 0);
      }

      :host([checked]:not([disabled])) .toggle-button {
        background-color: var(--paper-toggle-button-checked-button-color, var(--primary-color));

        @apply --paper-toggle-button-checked-button;
      }

      :host([disabled]) .toggle-button {
        background-color: #bdbdbd;
        opacity: 1;
      }

      .toggle-ink {
        position: absolute;
        top: -14px;
        left: -14px;
        right: auto;
        bottom: auto;
        width: 48px;
        height: 48px;
        opacity: 0.5;
        pointer-events: none;
        color: var(--paper-toggle-button-unchecked-ink-color, var(--primary-text-color));

        @apply --paper-toggle-button-unchecked-ink;
      }

      :host([checked]) .toggle-ink {
        color: var(--paper-toggle-button-checked-ink-color, var(--primary-color));

        @apply --paper-toggle-button-checked-ink;
      }

      .toggle-container {
        display: inline-block;
        position: relative;
        width: 36px;
        height: 14px;
        /* The toggle button has an absolute position of -3px; The extra 1px
        /* accounts for the toggle button shadow box. */
        margin: 4px 1px;
      }

      .toggle-label {
        position: relative;
        display: inline-block;
        vertical-align: middle;
        padding-left: var(--paper-toggle-button-label-spacing, 8px);
        pointer-events: none;
        color: var(--paper-toggle-button-label-color, var(--primary-text-color));
      }

      /* invalid state */
      :host([invalid]) .toggle-bar {
        background-color: var(--paper-toggle-button-invalid-bar-color, var(--error-color));
      }

      :host([invalid]) .toggle-button {
        background-color: var(--paper-toggle-button-invalid-button-color, var(--error-color));
      }

      :host([invalid]) .toggle-ink {
        color: var(--paper-toggle-button-invalid-ink-color, var(--error-color));
      }
    </style>

    <div class="toggle-container">
      <div id="toggleBar" class="toggle-bar"></div>
      <div id="toggleButton" class="toggle-button"></div>
    </div>

    <div class="toggle-label"><slot></slot></div>

  </template>

  
</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-toggle-button',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_4__paper_behaviors_paper_checked_element_behavior_js__["a" /* PaperCheckedElementBehavior */]
  ],

  hostAttributes: {
    role: 'button',
    'aria-pressed': 'false',
    tabindex: 0
  },

  properties: {
    /**
     * Fired when the checked state changes due to user interaction.
     *
     * @event change
     */
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */
  },

  listeners: {
    track: '_ontrack'
  },

  attached: function() {
    Object(__WEBPACK_IMPORTED_MODULE_6__polymer_lib_utils_render_status_js__["a" /* afterNextRender */])(this, function() {
      Object(__WEBPACK_IMPORTED_MODULE_7__polymer_lib_utils_gestures_js__["setTouchAction"])(this, 'pan-y');
    });
  },

  _ontrack: function(event) {
    var track = event.detail;
    if (track.state === 'start') {
      this._trackStart(track);
    } else if (track.state === 'track') {
      this._trackMove(track);
    } else if (track.state === 'end') {
      this._trackEnd(track);
    }
  },

  _trackStart: function(track) {
    this._width = this.$.toggleBar.offsetWidth / 2;
    /*
     * keep an track-only check state to keep the dragging behavior smooth
     * while toggling activations
     */
    this._trackChecked = this.checked;
    this.$.toggleButton.classList.add('dragging');
  },

  _trackMove: function(track) {
    var dx = track.dx;
    this._x = Math.min(this._width,
        Math.max(0, this._trackChecked ? this._width + dx : dx));
    this.translate3d(this._x + 'px', 0, 0, this.$.toggleButton);
    this._userActivate(this._x > (this._width / 2));
  },

  _trackEnd: function(track) {
    this.$.toggleButton.classList.remove('dragging');
    this.transform('', this.$.toggleButton);
  },

  // customize the element's ripple
  _createRipple: function() {
    this._rippleContainer = this.$.toggleButton;
    var ripple = __WEBPACK_IMPORTED_MODULE_8__paper_behaviors_paper_ripple_behavior_js__["a" /* PaperRippleBehavior */]._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('recenters', '');
    ripple.classList.add('circle', 'toggle-ink');
    return ripple;
  }

});


/***/ }),
/* 101 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js__ = __webpack_require__(102);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js__);


var getBreakpoint = function () {
  return window.getComputedStyle(window.document.querySelector('body'), ':before').getPropertyValue('content').replace(/"/g, '');
};

function breakpoint(breakpoint, callback) {
  if (typeof callback === "function") {
    if (getBreakpoint() === breakpoint) {
      callback();
    }

    $(window).resize(function () {
      if (getBreakpoint() === breakpoint) {
        callback();
      }
    });
  } else {
    return getBreakpoint() === breakpoint;
  }
}

function desktop(callback) {
  return breakpoint("desktop", callback);
}

function tablet(callback) {
  return breakpoint("tablet", callback);
}

function phone(callback) {
  return breakpoint("phone", callback);
}

/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function(){/*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
'use strict';var p,q="undefined"!=typeof window&&window===this?this:"undefined"!=typeof global&&null!=global?global:this,ba="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};function ca(){ca=function(){};q.Symbol||(q.Symbol=da)}var da=function(){var a=0;return function(b){return"jscomp_symbol_"+(b||"")+a++}}();
function ea(){ca();var a=q.Symbol.iterator;a||(a=q.Symbol.iterator=q.Symbol("iterator"));"function"!=typeof Array.prototype[a]&&ba(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return fa(this)}});ea=function(){}}function fa(a){var b=0;return ha(function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}})}function ha(a){ea();a={next:a};a[q.Symbol.iterator]=function(){return this};return a}function ia(a){ea();var b=a[Symbol.iterator];return b?b.call(a):fa(a)}
function ja(a){for(var b,c=[];!(b=a.next()).done;)c.push(b.value);return c}
(function(){if(!function(){var a=document.createEvent("Event");a.initEvent("foo",!0,!0);a.preventDefault();return a.defaultPrevented}()){var a=Event.prototype.preventDefault;Event.prototype.preventDefault=function(){this.cancelable&&(a.call(this),Object.defineProperty(this,"defaultPrevented",{get:function(){return!0},configurable:!0}))}}var b=/Trident/.test(navigator.userAgent);if(!window.CustomEvent||b&&"function"!==typeof window.CustomEvent)window.CustomEvent=function(a,b){b=b||{};var c=document.createEvent("CustomEvent");
c.initCustomEvent(a,!!b.bubbles,!!b.cancelable,b.detail);return c},window.CustomEvent.prototype=window.Event.prototype;if(!window.Event||b&&"function"!==typeof window.Event){var c=window.Event;window.Event=function(a,b){b=b||{};var c=document.createEvent("Event");c.initEvent(a,!!b.bubbles,!!b.cancelable);return c};if(c)for(var d in c)window.Event[d]=c[d];window.Event.prototype=c.prototype}if(!window.MouseEvent||b&&"function"!==typeof window.MouseEvent){b=window.MouseEvent;window.MouseEvent=function(a,
b){b=b||{};var c=document.createEvent("MouseEvent");c.initMouseEvent(a,!!b.bubbles,!!b.cancelable,b.view||window,b.detail,b.screenX,b.screenY,b.clientX,b.clientY,b.ctrlKey,b.altKey,b.shiftKey,b.metaKey,b.button,b.relatedTarget);return c};if(b)for(d in b)window.MouseEvent[d]=b[d];window.MouseEvent.prototype=b.prototype}Array.from||(Array.from=function(a){return[].slice.call(a)});Object.assign||(Object.assign=function(a,b){for(var c=[].slice.call(arguments,1),d=0,e;d<c.length;d++)if(e=c[d])for(var f=
a,m=e,n=Object.getOwnPropertyNames(m),w=0;w<n.length;w++)e=n[w],f[e]=m[e];return a})})(window.WebComponents);(function(){function a(){}function b(a,b){switch(a.nodeType){case Node.DOCUMENT_NODE:return w.call(a,b);case Node.DOCUMENT_FRAGMENT_NODE:return I.call(a,b);default:return n.call(a,b)}}var c="undefined"===typeof HTMLTemplateElement,d=!(document.createDocumentFragment().cloneNode()instanceof DocumentFragment),e=!1;/Trident/.test(navigator.userAgent)&&function(){function a(a,b){if(a instanceof DocumentFragment)for(var d;d=a.firstChild;)c.call(this,d,b);else c.call(this,a,b);return a}e=!0;var b=Node.prototype.cloneNode;
Node.prototype.cloneNode=function(a){a=b.call(this,a);this instanceof DocumentFragment&&(a.__proto__=DocumentFragment.prototype);return a};DocumentFragment.prototype.querySelectorAll=HTMLElement.prototype.querySelectorAll;DocumentFragment.prototype.querySelector=HTMLElement.prototype.querySelector;Object.defineProperties(DocumentFragment.prototype,{nodeType:{get:function(){return Node.DOCUMENT_FRAGMENT_NODE},configurable:!0},localName:{get:function(){},configurable:!0},nodeName:{get:function(){return"#document-fragment"},
configurable:!0}});var c=Node.prototype.insertBefore;Node.prototype.insertBefore=a;var d=Node.prototype.appendChild;Node.prototype.appendChild=function(b){b instanceof DocumentFragment?a.call(this,b,null):d.call(this,b);return b};var f=Node.prototype.removeChild,h=Node.prototype.replaceChild;Node.prototype.replaceChild=function(b,c){b instanceof DocumentFragment?(a.call(this,b,c),f.call(this,c)):h.call(this,b,c);return c};Document.prototype.createDocumentFragment=function(){var a=this.createElement("df");
a.__proto__=DocumentFragment.prototype;return a};var g=Document.prototype.importNode;Document.prototype.importNode=function(a,b){b=g.call(this,a,b||!1);a instanceof DocumentFragment&&(b.__proto__=DocumentFragment.prototype);return b}}();var f=Node.prototype.cloneNode,h=Document.prototype.createElement,g=Document.prototype.importNode,k=Node.prototype.removeChild,l=Node.prototype.appendChild,m=Node.prototype.replaceChild,n=Element.prototype.querySelectorAll,w=Document.prototype.querySelectorAll,I=DocumentFragment.prototype.querySelectorAll,
Za=function(){if(!c){var a=document.createElement("template"),b=document.createElement("template");b.content.appendChild(document.createElement("div"));a.content.appendChild(b);a=a.cloneNode(!0);return 0===a.content.childNodes.length||0===a.content.firstChild.content.childNodes.length||d}}();if(c){var t=document.implementation.createHTMLDocument("template"),na=!0,aa=document.createElement("style");aa.textContent="template{display:none;}";var T=document.head;T.insertBefore(aa,T.firstElementChild);
a.prototype=Object.create(HTMLElement.prototype);var U=!document.createElement("div").hasOwnProperty("innerHTML");a.D=function(b){if(!b.content){b.content=t.createDocumentFragment();for(var c;c=b.firstChild;)l.call(b.content,c);if(U)b.__proto__=a.prototype;else if(b.cloneNode=function(b){return a.a(this,b)},na)try{nc(b),oc(b)}catch(Ng){na=!1}a.J(b.content)}};var nc=function(b){Object.defineProperty(b,"innerHTML",{get:function(){for(var a="",b=this.content.firstChild;b;b=b.nextSibling)a+=b.outerHTML||
b.data.replace(Ge,pc);return a},set:function(b){t.body.innerHTML=b;for(a.J(t);this.content.firstChild;)k.call(this.content,this.content.firstChild);for(;t.body.firstChild;)l.call(this.content,t.body.firstChild)},configurable:!0})},oc=function(a){Object.defineProperty(a,"outerHTML",{get:function(){return"<template>"+this.innerHTML+"</template>"},set:function(a){if(this.parentNode){t.body.innerHTML=a;for(a=this.ownerDocument.createDocumentFragment();t.body.firstChild;)l.call(a,t.body.firstChild);m.call(this.parentNode,
a,this)}else throw Error("Failed to set the 'outerHTML' property on 'Element': This element has no parent node.");},configurable:!0})};nc(a.prototype);oc(a.prototype);a.J=function(c){c=b(c,"template");for(var d=0,e=c.length,f;d<e&&(f=c[d]);d++)a.D(f)};document.addEventListener("DOMContentLoaded",function(){a.J(document)});Document.prototype.createElement=function(){var b=h.apply(this,arguments);"template"===b.localName&&a.D(b);return b};var Ge=/[&\u00A0<>]/g,pc=function(a){switch(a){case "&":return"&amp;";
case "<":return"&lt;";case ">":return"&gt;";case "\u00a0":return"&nbsp;"}}}if(c||Za){a.a=function(a,b){var c=f.call(a,!1);this.D&&this.D(c);b&&(l.call(c.content,f.call(a.content,!0)),$a(c.content,a.content));return c};var $a=function(c,d){if(d.querySelectorAll&&(d=b(d,"template"),0!==d.length)){c=b(c,"template");for(var e=0,f=c.length,h,g;e<f;e++)g=d[e],h=c[e],a&&a.D&&a.D(g),m.call(h.parentNode,He.call(g,!0),h)}},He=Node.prototype.cloneNode=function(b){if(!e&&d&&this instanceof DocumentFragment)if(b)var c=
Ie.call(this.ownerDocument,this,!0);else return this.ownerDocument.createDocumentFragment();else this.nodeType===Node.ELEMENT_NODE&&"template"===this.localName?c=a.a(this,b):c=f.call(this,b);b&&$a(c,this);return c},Ie=Document.prototype.importNode=function(b,c){c=c||!1;if("template"===b.localName)return a.a(b,c);var d=g.call(this,b,c);c&&$a(d,b);return d}}c&&(window.HTMLTemplateElement=a)})();var ka;Array.isArray?ka=Array.isArray:ka=function(a){return"[object Array]"===Object.prototype.toString.call(a)};var la=ka;var ma=0,oa,pa="undefined"!==typeof window?window:void 0,qa=pa||{},ra=qa.MutationObserver||qa.WebKitMutationObserver,sa="undefined"!==typeof Uint8ClampedArray&&"undefined"!==typeof importScripts&&"undefined"!==typeof MessageChannel;function ta(){return"undefined"!==typeof oa?function(){oa(ua)}:va()}function wa(){var a=0,b=new ra(ua),c=document.createTextNode("");b.observe(c,{characterData:!0});return function(){c.data=a=++a%2}}
function xa(){var a=new MessageChannel;a.port1.onmessage=ua;return function(){return a.port2.postMessage(0)}}function va(){var a=setTimeout;return function(){return a(ua,1)}}var ya=Array(1E3);function ua(){for(var a=0;a<ma;a+=2)(0,ya[a])(ya[a+1]),ya[a]=void 0,ya[a+1]=void 0;ma=0}var za,Aa;
if("undefined"===typeof self&&"undefined"!==typeof process&&"[object process]"==={}.toString.call(process))Aa=function(){return process.jb(ua)};else{var Ba;if(ra)Ba=wa();else{var Ca;if(sa)Ca=xa();else{var Da;if(void 0===pa&&"function"==="function")try{var Ea=__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"vertx\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));oa=Ea.lb||Ea.kb;Da=ta()}catch(a){Da=va()}else Da=va();Ca=Da}Ba=Ca}Aa=Ba}za=Aa;function Fa(a,b){ya[ma]=a;ya[ma+1]=b;ma+=2;2===ma&&za()};function Ga(a,b){var c=this,d=new this.constructor(Ha);void 0===d[Ia]&&Ja(d);var e=c.g;if(e){var f=arguments[e-1];Fa(function(){return Ka(e,d,f,c.f)})}else La(c,d,a,b);return d};function Ma(a){if(a&&"object"===typeof a&&a.constructor===this)return a;var b=new this(Ha);Na(b,a);return b};var Ia=Math.random().toString(36).substring(16);function Ha(){}var Pa=new Oa;function Qa(a){try{return a.then}catch(b){return Pa.error=b,Pa}}function Ra(a,b,c,d){try{a.call(b,c,d)}catch(e){return e}}function Sa(a,b,c){Fa(function(a){var d=!1,f=Ra(c,b,function(c){d||(d=!0,b!==c?Na(a,c):r(a,c))},function(b){d||(d=!0,u(a,b))});!d&&f&&(d=!0,u(a,f))},a)}function Ta(a,b){1===b.g?r(a,b.f):2===b.g?u(a,b.f):La(b,void 0,function(b){return Na(a,b)},function(b){return u(a,b)})}
function Ua(a,b,c){b.constructor===a.constructor&&c===Ga&&b.constructor.resolve===Ma?Ta(a,b):c===Pa?(u(a,Pa.error),Pa.error=null):void 0===c?r(a,b):"function"===typeof c?Sa(a,b,c):r(a,b)}function Na(a,b){if(a===b)u(a,new TypeError("You cannot resolve a promise with itself"));else{var c=typeof b;null===b||"object"!==c&&"function"!==c?r(a,b):Ua(a,b,Qa(b))}}function Va(a){a.pa&&a.pa(a.f);Wa(a)}function r(a,b){void 0===a.g&&(a.f=b,a.g=1,0!==a.I.length&&Fa(Wa,a))}
function u(a,b){void 0===a.g&&(a.g=2,a.f=b,Fa(Va,a))}function La(a,b,c,d){var e=a.I,f=e.length;a.pa=null;e[f]=b;e[f+1]=c;e[f+2]=d;0===f&&a.g&&Fa(Wa,a)}function Wa(a){var b=a.I,c=a.g;if(0!==b.length){for(var d,e,f=a.f,h=0;h<b.length;h+=3)d=b[h],e=b[h+c],d?Ka(c,d,e,f):e(f);a.I.length=0}}function Oa(){this.error=null}var Xa=new Oa;
function Ka(a,b,c,d){var e="function"===typeof c;if(e){try{var f=c(d)}catch(l){Xa.error=l,f=Xa}if(f===Xa){var h=!0;var g=f.error;f.error=null}else var k=!0;if(b===f){u(b,new TypeError("A promises callback cannot return that same promise."));return}}else f=d,k=!0;void 0===b.g&&(e&&k?Na(b,f):h?u(b,g):1===a?r(b,f):2===a&&u(b,f))}function Ya(a,b){try{b(function(b){Na(a,b)},function(b){u(a,b)})}catch(c){u(a,c)}}var ab=0;function Ja(a){a[Ia]=ab++;a.g=void 0;a.f=void 0;a.I=[]};function bb(a,b){this.Ga=a;this.A=new a(Ha);this.A[Ia]||Ja(this.A);if(la(b))if(this.S=this.length=b.length,this.f=Array(this.length),0===this.length)r(this.A,this.f);else{this.length=this.length||0;for(a=0;void 0===this.g&&a<b.length;a++)cb(this,b[a],a);0===this.S&&r(this.A,this.f)}else u(this.A,Error("Array Methods must be provided an Array"))}
function cb(a,b,c){var d=a.Ga,e=d.resolve;e===Ma?(e=Qa(b),e===Ga&&void 0!==b.g?db(a,b.g,c,b.f):"function"!==typeof e?(a.S--,a.f[c]=b):d===v?(d=new d(Ha),Ua(d,b,e),eb(a,d,c)):eb(a,new d(function(a){return a(b)}),c)):eb(a,e(b),c)}function db(a,b,c,d){var e=a.A;void 0===e.g&&(a.S--,2===b?u(e,d):a.f[c]=d);0===a.S&&r(e,a.f)}function eb(a,b,c){La(b,void 0,function(b){return db(a,1,c,b)},function(b){return db(a,2,c,b)})};function fb(a){return(new bb(this,a)).A};function gb(a){var b=this;return la(a)?new b(function(c,d){for(var e=a.length,f=0;f<e;f++)b.resolve(a[f]).then(c,d)}):new b(function(a,b){return b(new TypeError("You must pass an array to race."))})};function hb(a){var b=new this(Ha);u(b,a);return b};function v(a){this[Ia]=ab++;this.f=this.g=void 0;this.I=[];if(Ha!==a){if("function"!==typeof a)throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(this instanceof v)Ya(this,a);else throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");}}v.prototype={constructor:v,then:Ga,a:function(a){return this.then(null,a)}};/*

Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.Promise||(window.Promise=v,v.prototype["catch"]=v.prototype.a,v.prototype.then=v.prototype.then,v.all=fb,v.race=gb,v.resolve=Ma,v.reject=hb);(function(a){function b(a,b){if("function"===typeof window.CustomEvent)return new CustomEvent(a,b);var c=document.createEvent("CustomEvent");c.initCustomEvent(a,!!b.bubbles,!!b.cancelable,b.detail);return c}function c(a){if(m)return a.ownerDocument!==document?a.ownerDocument:null;var b=a.__importDoc;if(!b&&a.parentNode){b=a.parentNode;if("function"===typeof b.closest)b=b.closest("link[rel=import]");else for(;!g(b)&&(b=b.parentNode););a.__importDoc=b}return b}function d(a){var b=document.querySelectorAll("link[rel=import]:not([import-dependency])"),
c=b.length;c?l(b,function(b){return h(b,function(){0===--c&&a()})}):a()}function e(a){function b(){"loading"!==document.readyState&&document.body&&(document.removeEventListener("readystatechange",b),a())}document.addEventListener("readystatechange",b);b()}function f(a){e(function(){return d(function(){return a&&a()})})}function h(a,b){if(a.__loaded)b&&b();else if("script"===a.localName&&!a.src||"style"===a.localName&&!a.firstChild)a.__loaded=!0,b&&b();else{var c=function(d){a.removeEventListener(d.type,
c);a.__loaded=!0;b&&b()};a.addEventListener("load",c);aa&&"style"===a.localName||a.addEventListener("error",c)}}function g(a){return a.nodeType===Node.ELEMENT_NODE&&"link"===a.localName&&"import"===a.rel}function k(){var a=this;this.a={};this.b=0;this.h=new MutationObserver(function(b){return a.Qa(b)});this.h.observe(document.head,{childList:!0,subtree:!0});this.c(document)}function l(a,b,c){var d=a?a.length:0,e=c?-1:1;for(c=c?d-1:0;c<d&&0<=c;c+=e)b(a[c],c)}var m="import"in document.createElement("link"),
n=null;!1==="currentScript"in document&&Object.defineProperty(document,"currentScript",{get:function(){return n||("complete"!==document.readyState?document.scripts[document.scripts.length-1]:null)},configurable:!0});var w=/(url\()([^)]*)(\))/g,I=/(@import[\s]+(?!url\())([^;]*)(;)/g,Za=/(<link[^>]*)(rel=['|"]?stylesheet['|"]?[^>]*>)/g,t={Ka:function(a,b){a.href&&a.setAttribute("href",t.Y(a.getAttribute("href"),b));a.src&&a.setAttribute("src",t.Y(a.getAttribute("src"),b));if("style"===a.localName){var c=
t.ua(a.textContent,b,w);a.textContent=t.ua(c,b,I)}},ua:function(a,b,c){return a.replace(c,function(a,c,d,e){a=d.replace(/["']/g,"");b&&(a=t.Y(a,b));return c+"'"+a+"'"+e})},Y:function(a,b){if(void 0===t.ca){t.ca=!1;try{var c=new URL("b","http://a");c.pathname="c%20d";t.ca="http://a/c%20d"===c.href}catch(pc){}}if(t.ca)return(new URL(a,b)).href;c=t.Da;c||(c=document.implementation.createHTMLDocument("temp"),t.Da=c,c.ma=c.createElement("base"),c.head.appendChild(c.ma),c.la=c.createElement("a"));c.ma.href=
b;c.la.href=a;return c.la.href||a}},na={async:!0,load:function(a,b,c){if(a)if(a.match(/^data:/)){a=a.split(",");var d=a[1];d=-1<a[0].indexOf(";base64")?atob(d):decodeURIComponent(d);b(d)}else{var e=new XMLHttpRequest;e.open("GET",a,na.async);e.onload=function(){var a=e.responseURL||e.getResponseHeader("Location");a&&0===a.indexOf("/")&&(a=(location.origin||location.protocol+"//"+location.host)+a);var d=e.response||e.responseText;304===e.status||0===e.status||200<=e.status&&300>e.status?b(d,a):c(d)};
e.send()}else c("error: href must be specified")}},aa=/Trident/.test(navigator.userAgent)||/Edge\/\d./i.test(navigator.userAgent);k.prototype.c=function(a){var b=this;a=a.querySelectorAll("link[rel=import]");l(a,function(a){return b.L(a)})};k.prototype.L=function(a){var b=this,c=a.href;if(void 0!==this.a[c]){var d=this.a[c];d&&d.__loaded&&(a.import=d,this.o(a))}else this.b++,this.a[c]="pending",na.load(c,function(a,d){a=b.Ra(a,d||c);b.a[c]=a;b.b--;b.c(a);b.sa()},function(){b.a[c]=null;b.b--;b.sa()})};
k.prototype.Ra=function(a,b){if(!a)return document.createDocumentFragment();aa&&(a=a.replace(Za,function(a,b,c){return-1===a.indexOf("type=")?b+" type=import-disable "+c:a}));var c=document.createElement("template");c.innerHTML=a;if(c.content)a=c.content;else for(a=document.createDocumentFragment();c.firstChild;)a.appendChild(c.firstChild);if(c=a.querySelector("base"))b=t.Y(c.getAttribute("href"),b),c.removeAttribute("href");c=a.querySelectorAll('link[rel=import], link[rel=stylesheet][href][type=import-disable],\n    style:not([type]), link[rel=stylesheet][href]:not([type]),\n    script:not([type]), script[type="application/javascript"],\n    script[type="text/javascript"]');
var d=0;l(c,function(a){h(a);t.Ka(a,b);a.setAttribute("import-dependency","");"script"===a.localName&&!a.src&&a.textContent&&(a.setAttribute("src","data:text/javascript;charset=utf-8,"+encodeURIComponent(a.textContent+("\n//# sourceURL="+b+(d?"-"+d:"")+".js\n"))),a.textContent="",d++)});return a};k.prototype.sa=function(){var a=this;if(!this.b){this.h.disconnect();this.flatten(document);var b=!1,c=!1,d=function(){c&&b&&(a.c(document),a.b||(a.h.observe(document.head,{childList:!0,subtree:!0}),a.Pa()))};
this.Wa(function(){c=!0;d()});this.Sa(function(){b=!0;d()})}};k.prototype.flatten=function(a){var b=this;a=a.querySelectorAll("link[rel=import]");l(a,function(a){var c=b.a[a.href];(a.import=c)&&c.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&(b.a[a.href]=a,a.readyState="loading",a.import=a,b.flatten(c),a.appendChild(c))})};k.prototype.Sa=function(a){function b(e){if(e<d){var f=c[e],g=document.createElement("script");f.removeAttribute("import-dependency");l(f.attributes,function(a){return g.setAttribute(a.name,
a.value)});n=g;f.parentNode.replaceChild(g,f);h(g,function(){n=null;b(e+1)})}else a()}var c=document.querySelectorAll("script[import-dependency]"),d=c.length;b(0)};k.prototype.Wa=function(a){var b=document.querySelectorAll("style[import-dependency],\n    link[rel=stylesheet][import-dependency]"),d=b.length;if(d){var e=aa&&!!document.querySelector("link[rel=stylesheet][href][type=import-disable]");l(b,function(b){h(b,function(){b.removeAttribute("import-dependency");0===--d&&a()});if(e&&b.parentNode!==
document.head){var f=document.createElement(b.localName);f.__appliedElement=b;f.setAttribute("type","import-placeholder");b.parentNode.insertBefore(f,b.nextSibling);for(f=c(b);f&&c(f);)f=c(f);f.parentNode!==document.head&&(f=null);document.head.insertBefore(b,f);b.removeAttribute("type")}})}else a()};k.prototype.Pa=function(){var a=this,b=document.querySelectorAll("link[rel=import]");l(b,function(b){return a.o(b)},!0)};k.prototype.o=function(a){a.__loaded||(a.__loaded=!0,a.import&&(a.import.readyState=
"complete"),a.dispatchEvent(b(a.import?"load":"error",{bubbles:!1,cancelable:!1,detail:void 0})))};k.prototype.Qa=function(a){var b=this;l(a,function(a){return l(a.addedNodes,function(a){a&&a.nodeType===Node.ELEMENT_NODE&&(g(a)?b.L(a):b.c(a))})})};if(m){var T=document.querySelectorAll("link[rel=import]");l(T,function(a){a.import&&"loading"===a.import.readyState||(a.__loaded=!0)});T=function(a){a=a.target;g(a)&&(a.__loaded=!0)};document.addEventListener("load",T,!0);document.addEventListener("error",
T,!0)}else{var U=Object.getOwnPropertyDescriptor(Node.prototype,"baseURI");Object.defineProperty((!U||U.configurable?Node:Element).prototype,"baseURI",{get:function(){var a=g(this)?this:c(this);return a?a.href:U&&U.get?U.get.call(this):(document.querySelector("base")||window.location).href},configurable:!0,enumerable:!0});e(function(){return new k})}f(function(){return document.dispatchEvent(b("HTMLImportsLoaded",{cancelable:!0,bubbles:!0,detail:void 0}))});a.useNative=m;a.whenReady=f;a.importForElement=
c})(window.HTMLImports=window.HTMLImports||{});/*

 Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.WebComponents=window.WebComponents||{flags:{}};var ib=document.querySelector('script[src*="webcomponents-lite.js"]'),jb=/wc-(.+)/,x={};if(!x.noOpts){location.search.slice(1).split("&").forEach(function(a){a=a.split("=");var b;a[0]&&(b=a[0].match(jb))&&(x[b[1]]=a[1]||!0)});if(ib)for(var kb=0,lb;lb=ib.attributes[kb];kb++)"src"!==lb.name&&(x[lb.name]=lb.value||!0);if(x.log&&x.log.split){var mb=x.log.split(",");x.log={};mb.forEach(function(a){x.log[a]=!0})}else x.log={}}
window.WebComponents.flags=x;var nb=x.shadydom;nb&&(window.ShadyDOM=window.ShadyDOM||{},window.ShadyDOM.force=nb);var ob=x.register||x.ce;ob&&window.customElements&&(window.customElements.forcePolyfill=ob);/*

Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
var y=window.ShadyDOM||{};y.Ma=!(!Element.prototype.attachShadow||!Node.prototype.getRootNode);var pb=Object.getOwnPropertyDescriptor(Node.prototype,"firstChild");y.M=!!(pb&&pb.configurable&&pb.get);y.ta=y.force||!y.Ma;function qb(a){return a.__shady&&void 0!==a.__shady.firstChild}function z(a){return"ShadyRoot"===a.Aa}function rb(a){a=a.getRootNode();if(z(a))return a}var sb=Element.prototype,tb=sb.matches||sb.matchesSelector||sb.mozMatchesSelector||sb.msMatchesSelector||sb.oMatchesSelector||sb.webkitMatchesSelector;
function ub(a,b){if(a&&b)for(var c=Object.getOwnPropertyNames(b),d=0,e;d<c.length&&(e=c[d]);d++){var f=Object.getOwnPropertyDescriptor(b,e);f&&Object.defineProperty(a,e,f)}}function vb(a,b){for(var c=[],d=1;d<arguments.length;++d)c[d-1]=arguments[d];for(d=0;d<c.length;d++)ub(a,c[d]);return a}function wb(a,b){for(var c in b)a[c]=b[c]}var xb=document.createTextNode(""),yb=0,zb=[];(new MutationObserver(function(){for(;zb.length;)try{zb.shift()()}catch(a){throw xb.textContent=yb++,a;}})).observe(xb,{characterData:!0});
function Ab(a){zb.push(a);xb.textContent=yb++}var Bb=!!document.contains;function Cb(a,b){for(;b;){if(b==a)return!0;b=b.parentNode}return!1};var Db=[],Eb;function Fb(a){Eb||(Eb=!0,Ab(Gb));Db.push(a)}function Gb(){Eb=!1;for(var a=!!Db.length;Db.length;)Db.shift()();return a}Gb.list=Db;function Hb(){this.a=!1;this.addedNodes=[];this.removedNodes=[];this.V=new Set}function Ib(a){a.a||(a.a=!0,Ab(function(){Jb(a)}))}function Jb(a){if(a.a){a.a=!1;var b=a.takeRecords();b.length&&a.V.forEach(function(a){a(b)})}}Hb.prototype.takeRecords=function(){if(this.addedNodes.length||this.removedNodes.length){var a=[{addedNodes:this.addedNodes,removedNodes:this.removedNodes}];this.addedNodes=[];this.removedNodes=[];return a}return[]};
function Kb(a,b){a.__shady=a.__shady||{};a.__shady.N||(a.__shady.N=new Hb);a.__shady.N.V.add(b);var c=a.__shady.N;return{Ea:b,C:c,Ha:a,takeRecords:function(){return c.takeRecords()}}}function Lb(a){var b=a&&a.C;b&&(b.V.delete(a.Ea),b.V.size||(a.Ha.__shady.N=null))}
function Mb(a,b){var c=b.getRootNode();return a.map(function(a){var b=c===a.target.getRootNode();if(b&&a.addedNodes){if(b=Array.from(a.addedNodes).filter(function(a){return c===a.getRootNode()}),b.length)return a=Object.create(a),Object.defineProperty(a,"addedNodes",{value:b,configurable:!0}),a}else if(b)return a}).filter(function(a){return a})};var A={},Nb=Element.prototype.insertBefore,Ob=Element.prototype.removeChild,Pb=Element.prototype.setAttribute,Qb=Element.prototype.removeAttribute,Rb=Element.prototype.cloneNode,Sb=Document.prototype.importNode,Tb=Element.prototype.addEventListener,Ub=Element.prototype.removeEventListener,Vb=Window.prototype.addEventListener,Wb=Window.prototype.removeEventListener,Xb=Element.prototype.dispatchEvent,Yb=Element.prototype.querySelector,Zb=Element.prototype.querySelectorAll,$b=Node.prototype.contains||
HTMLElement.prototype.contains;A.appendChild=Element.prototype.appendChild;A.insertBefore=Nb;A.removeChild=Ob;A.setAttribute=Pb;A.removeAttribute=Qb;A.cloneNode=Rb;A.importNode=Sb;A.addEventListener=Tb;A.removeEventListener=Ub;A.ab=Vb;A.bb=Wb;A.dispatchEvent=Xb;A.querySelector=Yb;A.querySelectorAll=Zb;A.contains=$b;var ac=/[&\u00A0"]/g,bc=/[&\u00A0<>]/g;function cc(a){switch(a){case "&":return"&amp;";case "<":return"&lt;";case ">":return"&gt;";case '"':return"&quot;";case "\u00a0":return"&nbsp;"}}function dc(a){for(var b={},c=0;c<a.length;c++)b[a[c]]=!0;return b}var ec=dc("area base br col command embed hr img input keygen link meta param source track wbr".split(" ")),fc=dc("style script xmp iframe noembed noframes plaintext noscript".split(" "));
function gc(a,b){"template"===a.localName&&(a=a.content);for(var c="",d=b?b(a):a.childNodes,e=0,f=d.length,h;e<f&&(h=d[e]);e++){a:{var g=h;var k=a;var l=b;switch(g.nodeType){case Node.ELEMENT_NODE:for(var m=g.localName,n="<"+m,w=g.attributes,I=0;k=w[I];I++)n+=" "+k.name+'="'+k.value.replace(ac,cc)+'"';n+=">";g=ec[m]?n:n+gc(g,l)+"</"+m+">";break a;case Node.TEXT_NODE:g=g.data;g=k&&fc[k.localName]?g:g.replace(bc,cc);break a;case Node.COMMENT_NODE:g="\x3c!--"+g.data+"--\x3e";break a;default:throw window.console.error(g),
Error("not implemented");}}c+=g}return c};var B={},C=document.createTreeWalker(document,NodeFilter.SHOW_ALL,null,!1),D=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT,null,!1);function hc(a){var b=[];C.currentNode=a;for(a=C.firstChild();a;)b.push(a),a=C.nextSibling();return b}B.parentNode=function(a){C.currentNode=a;return C.parentNode()};B.firstChild=function(a){C.currentNode=a;return C.firstChild()};B.lastChild=function(a){C.currentNode=a;return C.lastChild()};B.previousSibling=function(a){C.currentNode=a;return C.previousSibling()};
B.nextSibling=function(a){C.currentNode=a;return C.nextSibling()};B.childNodes=hc;B.parentElement=function(a){D.currentNode=a;return D.parentNode()};B.firstElementChild=function(a){D.currentNode=a;return D.firstChild()};B.lastElementChild=function(a){D.currentNode=a;return D.lastChild()};B.previousElementSibling=function(a){D.currentNode=a;return D.previousSibling()};B.nextElementSibling=function(a){D.currentNode=a;return D.nextSibling()};
B.children=function(a){var b=[];D.currentNode=a;for(a=D.firstChild();a;)b.push(a),a=D.nextSibling();return b};B.innerHTML=function(a){return gc(a,function(a){return hc(a)})};B.textContent=function(a){switch(a.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:a=document.createTreeWalker(a,NodeFilter.SHOW_TEXT,null,!1);for(var b="",c;c=a.nextNode();)b+=c.nodeValue;return b;default:return a.nodeValue}};var ic=Object.getOwnPropertyDescriptor(Element.prototype,"innerHTML")||Object.getOwnPropertyDescriptor(HTMLElement.prototype,"innerHTML"),jc=document.implementation.createHTMLDocument("inert"),kc=Object.getOwnPropertyDescriptor(Document.prototype,"activeElement"),lc={parentElement:{get:function(){var a=this.__shady&&this.__shady.parentNode;a&&a.nodeType!==Node.ELEMENT_NODE&&(a=null);return void 0!==a?a:B.parentElement(this)},configurable:!0},parentNode:{get:function(){var a=this.__shady&&this.__shady.parentNode;
return void 0!==a?a:B.parentNode(this)},configurable:!0},nextSibling:{get:function(){var a=this.__shady&&this.__shady.nextSibling;return void 0!==a?a:B.nextSibling(this)},configurable:!0},previousSibling:{get:function(){var a=this.__shady&&this.__shady.previousSibling;return void 0!==a?a:B.previousSibling(this)},configurable:!0},className:{get:function(){return this.getAttribute("class")||""},set:function(a){this.setAttribute("class",a)},configurable:!0},nextElementSibling:{get:function(){if(this.__shady&&
void 0!==this.__shady.nextSibling){for(var a=this.nextSibling;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.nextSibling;return a}return B.nextElementSibling(this)},configurable:!0},previousElementSibling:{get:function(){if(this.__shady&&void 0!==this.__shady.previousSibling){for(var a=this.previousSibling;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.previousSibling;return a}return B.previousElementSibling(this)},configurable:!0}},mc={childNodes:{get:function(){if(qb(this)){if(!this.__shady.childNodes){this.__shady.childNodes=
[];for(var a=this.firstChild;a;a=a.nextSibling)this.__shady.childNodes.push(a)}var b=this.__shady.childNodes}else b=B.childNodes(this);b.item=function(a){return b[a]};return b},configurable:!0},childElementCount:{get:function(){return this.children.length},configurable:!0},firstChild:{get:function(){var a=this.__shady&&this.__shady.firstChild;return void 0!==a?a:B.firstChild(this)},configurable:!0},lastChild:{get:function(){var a=this.__shady&&this.__shady.lastChild;return void 0!==a?a:B.lastChild(this)},
configurable:!0},textContent:{get:function(){if(qb(this)){for(var a=[],b=0,c=this.childNodes,d;d=c[b];b++)d.nodeType!==Node.COMMENT_NODE&&a.push(d.textContent);return a.join("")}return B.textContent(this)},set:function(a){switch(this.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:for(;this.firstChild;)this.removeChild(this.firstChild);(0<a.length||this.nodeType===Node.ELEMENT_NODE)&&this.appendChild(document.createTextNode(a));break;default:this.nodeValue=a}},configurable:!0},firstElementChild:{get:function(){if(this.__shady&&
void 0!==this.__shady.firstChild){for(var a=this.firstChild;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.nextSibling;return a}return B.firstElementChild(this)},configurable:!0},lastElementChild:{get:function(){if(this.__shady&&void 0!==this.__shady.lastChild){for(var a=this.lastChild;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.previousSibling;return a}return B.lastElementChild(this)},configurable:!0},children:{get:function(){var a;qb(this)?a=Array.prototype.filter.call(this.childNodes,function(a){return a.nodeType===
Node.ELEMENT_NODE}):a=B.children(this);a.item=function(b){return a[b]};return a},configurable:!0},innerHTML:{get:function(){var a="template"===this.localName?this.content:this;return qb(this)?gc(a):B.innerHTML(a)},set:function(a){for(var b="template"===this.localName?this.content:this;b.firstChild;)b.removeChild(b.firstChild);var c=this.localName;c&&"template"!==c||(c="div");c=jc.createElement(c);for(ic&&ic.set?ic.set.call(c,a):c.innerHTML=a;c.firstChild;)b.appendChild(c.firstChild)},configurable:!0}},
qc={shadowRoot:{get:function(){return this.__shady&&this.__shady.Ua||null},configurable:!0}},rc={activeElement:{get:function(){var a=kc&&kc.get?kc.get.call(document):y.M?void 0:document.activeElement;if(a&&a.nodeType){var b=!!z(this);if(this===document||b&&this.host!==a&&A.contains.call(this.host,a)){for(b=rb(a);b&&b!==this;)a=b.host,b=rb(a);a=this===document?b?null:a:b===this?a:null}else a=null}else a=null;return a},set:function(){},configurable:!0}};
function E(a,b,c){for(var d in b){var e=Object.getOwnPropertyDescriptor(a,d);e&&e.configurable||!e&&c?Object.defineProperty(a,d,b[d]):c&&console.warn("Could not define",d,"on",a)}}function F(a){E(a,lc);E(a,mc);E(a,rc)}var sc=y.M?function(){}:function(a){a.__shady&&a.__shady.Ba||(a.__shady=a.__shady||{},a.__shady.Ba=!0,E(a,lc,!0))},tc=y.M?function(){}:function(a){a.__shady&&a.__shady.za||(a.__shady=a.__shady||{},a.__shady.za=!0,E(a,mc,!0),E(a,qc,!0))};function uc(a,b,c){sc(a);c=c||null;a.__shady=a.__shady||{};b.__shady=b.__shady||{};c&&(c.__shady=c.__shady||{});a.__shady.previousSibling=c?c.__shady.previousSibling:b.lastChild;var d=a.__shady.previousSibling;d&&d.__shady&&(d.__shady.nextSibling=a);(d=a.__shady.nextSibling=c)&&d.__shady&&(d.__shady.previousSibling=a);a.__shady.parentNode=b;c?c===b.__shady.firstChild&&(b.__shady.firstChild=a):(b.__shady.lastChild=a,b.__shady.firstChild||(b.__shady.firstChild=a));b.__shady.childNodes=null}
function vc(a){if(!a.__shady||void 0===a.__shady.firstChild){a.__shady=a.__shady||{};a.__shady.firstChild=B.firstChild(a);a.__shady.lastChild=B.lastChild(a);tc(a);for(var b=a.__shady.childNodes=B.childNodes(a),c=0,d;c<b.length&&(d=b[c]);c++)d.__shady=d.__shady||{},d.__shady.parentNode=a,d.__shady.nextSibling=b[c+1]||null,d.__shady.previousSibling=b[c-1]||null,sc(d)}};function wc(a,b,c){if(b===a)throw Error("Failed to execute 'appendChild' on 'Node': The new child element contains the parent.");if(c){var d=c.__shady&&c.__shady.parentNode;if(void 0!==d&&d!==a||void 0===d&&B.parentNode(c)!==a)throw Error("Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.");}if(c===b)return b;b.parentNode&&xc(b.parentNode,b);d=rb(a);var e;if(e=d)a:{if(!b.__noInsertionPoint){var f;"slot"===b.localName?f=[b]:
b.querySelectorAll&&(f=b.querySelectorAll("slot"));if(f&&f.length){e=f;break a}}e=void 0}(f=e)&&d.H.push.apply(d.H,[].concat(f instanceof Array?f:ja(ia(f))));d&&("slot"===a.localName||f)&&yc(d);if(qb(a)){d=c;tc(a);a.__shady=a.__shady||{};void 0!==a.__shady.firstChild&&(a.__shady.childNodes=null);if(b.nodeType===Node.DOCUMENT_FRAGMENT_NODE){f=b.childNodes;for(e=0;e<f.length;e++)uc(f[e],a,d);b.__shady=b.__shady||{};d=void 0!==b.__shady.firstChild?null:void 0;b.__shady.firstChild=b.__shady.lastChild=
d;b.__shady.childNodes=d}else uc(b,a,d);if(zc(a)){yc(a.__shady.root);var h=!0}else a.__shady.root&&(h=!0)}h||(h=z(a)?a.host:a,c?(c=Ac(c),A.insertBefore.call(h,b,c)):A.appendChild.call(h,b));Bc(a,b);return b}
function xc(a,b){if(b.parentNode!==a)throw Error("The node to be removed is not a child of this node: "+b);var c=rb(b);if(qb(a)){b.__shady=b.__shady||{};a.__shady=a.__shady||{};b===a.__shady.firstChild&&(a.__shady.firstChild=b.__shady.nextSibling);b===a.__shady.lastChild&&(a.__shady.lastChild=b.__shady.previousSibling);var d=b.__shady.previousSibling,e=b.__shady.nextSibling;d&&(d.__shady=d.__shady||{},d.__shady.nextSibling=e);e&&(e.__shady=e.__shady||{},e.__shady.previousSibling=d);b.__shady.parentNode=
b.__shady.previousSibling=b.__shady.nextSibling=void 0;void 0!==a.__shady.childNodes&&(a.__shady.childNodes=null);if(zc(a)){yc(a.__shady.root);var f=!0}}Cc(b);if(c){(d=a&&"slot"===a.localName)&&(f=!0);Dc(c);e=c.l;for(var h in e)for(var g=e[h],k=0;k<g.length;k++){var l=g[k];if(Cb(b,l)){g.splice(k,1);var m=c.s.indexOf(l);0<=m&&c.s.splice(m,1);k--;if(m=l.__shady.K)for(l=0;l<m.length;l++){var n=m[l],w=B.parentNode(n);w&&A.removeChild.call(w,n)}m=!0}}(m||d)&&yc(c)}f||(f=z(a)?a.host:a,(!a.__shady.root&&
"slot"!==b.localName||f===B.parentNode(b))&&A.removeChild.call(f,b));Bc(a,null,b);return b}function Cc(a){if(a.__shady&&void 0!==a.__shady.ka)for(var b=a.childNodes,c=0,d=b.length,e;c<d&&(e=b[c]);c++)Cc(e);a.__shady&&(a.__shady.ka=void 0)}function Ac(a){var b=a;a&&"slot"===a.localName&&(b=(b=a.__shady&&a.__shady.K)&&b.length?b[0]:Ac(a.nextSibling));return b}function zc(a){return(a=a&&a.__shady&&a.__shady.root)&&Ec(a)}
function Fc(a,b){if("slot"===b)a=a.parentNode,zc(a)&&yc(a.__shady.root);else if("slot"===a.localName&&"name"===b&&(b=rb(a))){var c=a.Ca,d=Gc(a);if(d!==c){c=b.l[c];var e=c.indexOf(a);0<=e&&c.splice(e,1);c=b.l[d]||(b.l[d]=[]);c.push(a);1<c.length&&(b.l[d]=Hc(c))}yc(b)}}function Bc(a,b,c){if(a=a.__shady&&a.__shady.N)b&&a.addedNodes.push(b),c&&a.removedNodes.push(c),Ib(a)}
function Ic(a){if(a&&a.nodeType){a.__shady=a.__shady||{};var b=a.__shady.ka;void 0===b&&(z(a)?b=a:b=(b=a.parentNode)?Ic(b):a,A.contains.call(document.documentElement,a)&&(a.__shady.ka=b));return b}}function Jc(a,b,c){var d=[];Kc(a.childNodes,b,c,d);return d}function Kc(a,b,c,d){for(var e=0,f=a.length,h;e<f&&(h=a[e]);e++){var g;if(g=h.nodeType===Node.ELEMENT_NODE){g=h;var k=b,l=c,m=d,n=k(g);n&&m.push(g);l&&l(n)?g=n:(Kc(g.childNodes,k,l,m),g=void 0)}if(g)break}}var Lc=null;
function Mc(a,b,c){Lc||(Lc=window.ShadyCSS&&window.ShadyCSS.ScopingShim);Lc&&"class"===b?Lc.setElementClass(a,c):(A.setAttribute.call(a,b,c),Fc(a,b))}function Nc(a,b){if(a.ownerDocument!==document)return A.importNode.call(document,a,b);var c=A.importNode.call(document,a,!1);if(b){a=a.childNodes;b=0;for(var d;b<a.length;b++)d=Nc(a[b],!0),c.appendChild(d)}return c};var Oc="__eventWrappers"+Date.now(),Pc={blur:!0,focus:!0,focusin:!0,focusout:!0,click:!0,dblclick:!0,mousedown:!0,mouseenter:!0,mouseleave:!0,mousemove:!0,mouseout:!0,mouseover:!0,mouseup:!0,wheel:!0,beforeinput:!0,input:!0,keydown:!0,keyup:!0,compositionstart:!0,compositionupdate:!0,compositionend:!0,touchstart:!0,touchend:!0,touchmove:!0,touchcancel:!0,pointerover:!0,pointerenter:!0,pointerdown:!0,pointermove:!0,pointerup:!0,pointercancel:!0,pointerout:!0,pointerleave:!0,gotpointercapture:!0,lostpointercapture:!0,
dragstart:!0,drag:!0,dragenter:!0,dragleave:!0,dragover:!0,drop:!0,dragend:!0,DOMActivate:!0,DOMFocusIn:!0,DOMFocusOut:!0,keypress:!0};function Qc(a,b){var c=[],d=a;for(a=a===window?window:a.getRootNode();d;)c.push(d),d=d.assignedSlot?d.assignedSlot:d.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&d.host&&(b||d!==a)?d.host:d.parentNode;c[c.length-1]===document&&c.push(window);return c}
function Rc(a,b){if(!z)return a;a=Qc(a,!0);for(var c=0,d,e,f,h;c<b.length;c++)if(d=b[c],f=d===window?window:d.getRootNode(),f!==e&&(h=a.indexOf(f),e=f),!z(f)||-1<h)return d}
var Sc={get composed(){!1!==this.isTrusted&&void 0===this.Z&&(this.Z=Pc[this.type]);return this.Z||!1},composedPath:function(){this.na||(this.na=Qc(this.__target,this.composed));return this.na},get target(){return Rc(this.currentTarget,this.composedPath())},get relatedTarget(){if(!this.aa)return null;this.oa||(this.oa=Qc(this.aa,!0));return Rc(this.currentTarget,this.oa)},stopPropagation:function(){Event.prototype.stopPropagation.call(this);this.$=!0},stopImmediatePropagation:function(){Event.prototype.stopImmediatePropagation.call(this);
this.$=this.ya=!0}};function Tc(a){function b(b,d){b=new a(b,d);b.Z=d&&!!d.composed;return b}wb(b,a);b.prototype=a.prototype;return b}var Uc={focus:!0,blur:!0};function Vc(a){return a.__target!==a.target||a.aa!==a.relatedTarget}function Wc(a,b,c){if(c=b.__handlers&&b.__handlers[a.type]&&b.__handlers[a.type][c])for(var d=0,e;(e=c[d])&&(!Vc(a)||a.target!==a.relatedTarget)&&(e.call(b,a),!a.ya);d++);}
function Xc(a){var b=a.composedPath();Object.defineProperty(a,"currentTarget",{get:function(){return d},configurable:!0});for(var c=b.length-1;0<=c;c--){var d=b[c];Wc(a,d,"capture");if(a.$)return}Object.defineProperty(a,"eventPhase",{get:function(){return Event.AT_TARGET}});var e;for(c=0;c<b.length;c++){d=b[c];var f=d.__shady&&d.__shady.root;if(0===c||f&&f===e)if(Wc(a,d,"bubble"),d!==window&&(e=d.getRootNode()),a.$)break}}
function Yc(a,b,c,d,e,f){for(var h=0;h<a.length;h++){var g=a[h],k=g.type,l=g.capture,m=g.once,n=g.passive;if(b===g.node&&c===k&&d===l&&e===m&&f===n)return h}return-1}
function Zc(a,b,c){if(b){if(c&&"object"===typeof c){var d=!!c.capture;var e=!!c.once;var f=!!c.passive}else d=!!c,f=e=!1;var h=c&&c.ba||this,g=b[Oc];if(g){if(-1<Yc(g,h,a,d,e,f))return}else b[Oc]=[];g=function(d){e&&this.removeEventListener(a,b,c);d.__target||$c(d);if(h!==this){var f=Object.getOwnPropertyDescriptor(d,"currentTarget");Object.defineProperty(d,"currentTarget",{get:function(){return h},configurable:!0})}if(d.composed||-1<d.composedPath().indexOf(h))if(Vc(d)&&d.target===d.relatedTarget)d.eventPhase===
Event.BUBBLING_PHASE&&d.stopImmediatePropagation();else if(d.eventPhase===Event.CAPTURING_PHASE||d.bubbles||d.target===h||h instanceof Window){var g="object"===typeof b&&b.handleEvent?b.handleEvent(d):b.call(h,d);h!==this&&(f?(Object.defineProperty(d,"currentTarget",f),f=null):delete d.currentTarget);return g}};b[Oc].push({node:this,type:a,capture:d,once:e,passive:f,cb:g});Uc[a]?(this.__handlers=this.__handlers||{},this.__handlers[a]=this.__handlers[a]||{capture:[],bubble:[]},this.__handlers[a][d?
"capture":"bubble"].push(g)):(this instanceof Window?A.ab:A.addEventListener).call(this,a,g,c)}}
function ad(a,b,c){if(b){if(c&&"object"===typeof c){var d=!!c.capture;var e=!!c.once;var f=!!c.passive}else d=!!c,f=e=!1;var h=c&&c.ba||this,g=void 0;var k=null;try{k=b[Oc]}catch(l){}k&&(e=Yc(k,h,a,d,e,f),-1<e&&(g=k.splice(e,1)[0].cb,k.length||(b[Oc]=void 0)));(this instanceof Window?A.bb:A.removeEventListener).call(this,a,g||b,c);g&&Uc[a]&&this.__handlers&&this.__handlers[a]&&(a=this.__handlers[a][d?"capture":"bubble"],g=a.indexOf(g),-1<g&&a.splice(g,1))}}
function bd(){for(var a in Uc)window.addEventListener(a,function(a){a.__target||($c(a),Xc(a))},!0)}function $c(a){a.__target=a.target;a.aa=a.relatedTarget;if(y.M){var b=Object.getPrototypeOf(a);if(!b.hasOwnProperty("__patchProto")){var c=Object.create(b);c.fb=b;ub(c,Sc);b.__patchProto=c}a.__proto__=b.__patchProto}else ub(a,Sc)}var cd=Tc(window.Event),dd=Tc(window.CustomEvent),ed=Tc(window.MouseEvent);function fd(a,b){return{index:a,O:[],U:b}}
function gd(a,b,c,d){var e=0,f=0,h=0,g=0,k=Math.min(b-e,d-f);if(0==e&&0==f)a:{for(h=0;h<k;h++)if(a[h]!==c[h])break a;h=k}if(b==a.length&&d==c.length){g=a.length;for(var l=c.length,m=0;m<k-h&&hd(a[--g],c[--l]);)m++;g=m}e+=h;f+=h;b-=g;d-=g;if(0==b-e&&0==d-f)return[];if(e==b){for(b=fd(e,0);f<d;)b.O.push(c[f++]);return[b]}if(f==d)return[fd(e,b-e)];k=e;h=f;d=d-h+1;g=b-k+1;b=Array(d);for(l=0;l<d;l++)b[l]=Array(g),b[l][0]=l;for(l=0;l<g;l++)b[0][l]=l;for(l=1;l<d;l++)for(m=1;m<g;m++)if(a[k+m-1]===c[h+l-1])b[l][m]=
b[l-1][m-1];else{var n=b[l-1][m]+1,w=b[l][m-1]+1;b[l][m]=n<w?n:w}k=b.length-1;h=b[0].length-1;d=b[k][h];for(a=[];0<k||0<h;)0==k?(a.push(2),h--):0==h?(a.push(3),k--):(g=b[k-1][h-1],l=b[k-1][h],m=b[k][h-1],n=l<m?l<g?l:g:m<g?m:g,n==g?(g==d?a.push(0):(a.push(1),d=g),k--,h--):n==l?(a.push(3),k--,d=l):(a.push(2),h--,d=m));a.reverse();b=void 0;k=[];for(h=0;h<a.length;h++)switch(a[h]){case 0:b&&(k.push(b),b=void 0);e++;f++;break;case 1:b||(b=fd(e,0));b.U++;e++;b.O.push(c[f]);f++;break;case 2:b||(b=fd(e,0));
b.U++;e++;break;case 3:b||(b=fd(e,0)),b.O.push(c[f]),f++}b&&k.push(b);return k}function hd(a,b){return a===b};var id={};function G(a,b,c){if(a!==id)throw new TypeError("Illegal constructor");a=document.createDocumentFragment();a.__proto__=G.prototype;a.Aa="ShadyRoot";vc(b);vc(a);a.host=b;a.a=c&&c.mode;b.__shady=b.__shady||{};b.__shady.root=a;b.__shady.Ua="closed"!==a.a?a:null;a.T=!1;a.s=[];a.l={};a.H=[];c=B.childNodes(b);for(var d=0,e=c.length;d<e;d++)A.removeChild.call(b,c[d]);return a}G.prototype=Object.create(DocumentFragment.prototype);function yc(a){a.T||(a.T=!0,Fb(function(){return jd(a)}))}
function jd(a){for(var b;a;){a.T&&(b=a);a:{var c=a;a=c.host.getRootNode();if(z(a))for(var d=c.host.childNodes,e=0;e<d.length;e++)if(c=d[e],"slot"==c.localName)break a;a=void 0}}b&&b._renderRoot()}
G.prototype._renderRoot=function(){this.T=!1;Dc(this);for(var a=0,b;a<this.s.length;a++){b=this.s[a];var c=b.__shady.assignedNodes;b.__shady.assignedNodes=[];b.__shady.K=[];if(b.__shady.qa=c)for(var d=0;d<c.length;d++){var e=c[d];e.__shady.ga=e.__shady.assignedSlot;e.__shady.assignedSlot===b&&(e.__shady.assignedSlot=null)}}for(b=this.host.firstChild;b;b=b.nextSibling)kd(this,b);for(a=0;a<this.s.length;a++){b=this.s[a];if(!b.__shady.assignedNodes.length)for(c=b.firstChild;c;c=c.nextSibling)kd(this,
c,b);c=b.parentNode;(c=c.__shady&&c.__shady.root)&&Ec(c)&&c._renderRoot();ld(this,b.__shady.K,b.__shady.assignedNodes);if(c=b.__shady.qa){for(d=0;d<c.length;d++)c[d].__shady.ga=null;b.__shady.qa=null;c.length>b.__shady.assignedNodes.length&&(b.__shady.ia=!0)}b.__shady.ia&&(b.__shady.ia=!1,md(this,b))}a=this.s;b=[];for(c=0;c<a.length;c++)d=a[c].parentNode,d.__shady&&d.__shady.root||!(0>b.indexOf(d))||b.push(d);for(a=0;a<b.length;a++){c=b[a];d=c===this?this.host:c;e=[];c=c.childNodes;for(var f=0;f<
c.length;f++){var h=c[f];if("slot"==h.localName){h=h.__shady.K;for(var g=0;g<h.length;g++)e.push(h[g])}else e.push(h)}c=void 0;f=B.childNodes(d);h=gd(e,e.length,f,f.length);for(var k=g=0;g<h.length&&(c=h[g]);g++){for(var l=0,m;l<c.O.length&&(m=c.O[l]);l++)B.parentNode(m)===d&&A.removeChild.call(d,m),f.splice(c.index+k,1);k-=c.U}for(k=0;k<h.length&&(c=h[k]);k++)for(g=f[c.index],l=c.index;l<c.index+c.U;l++)m=e[l],A.insertBefore.call(d,m,g),f.splice(l,0,m)}};
function kd(a,b,c){b.__shady=b.__shady||{};var d=b.__shady.ga;b.__shady.ga=null;c||(c=(a=a.l[b.slot||"__catchall"])&&a[0]);c?(c.__shady.assignedNodes.push(b),b.__shady.assignedSlot=c):b.__shady.assignedSlot=void 0;d!==b.__shady.assignedSlot&&b.__shady.assignedSlot&&(b.__shady.assignedSlot.__shady.ia=!0)}function ld(a,b,c){for(var d=0,e;d<c.length&&(e=c[d]);d++)if("slot"==e.localName){var f=e.__shady.assignedNodes;f&&f.length&&ld(a,b,f)}else b.push(c[d])}
function md(a,b){A.dispatchEvent.call(b,new Event("slotchange"));b.__shady.assignedSlot&&md(a,b.__shady.assignedSlot)}function Dc(a){if(a.H.length){for(var b=a.H,c,d=0;d<b.length;d++){var e=b[d];e.__shady=e.__shady||{};vc(e);vc(e.parentNode);var f=Gc(e);a.l[f]?(c=c||{},c[f]=!0,a.l[f].push(e)):a.l[f]=[e];a.s.push(e)}if(c)for(var h in c)a.l[h]=Hc(a.l[h]);a.H=[]}}function Gc(a){var b=a.name||a.getAttribute("name")||"__catchall";return a.Ca=b}
function Hc(a){return a.sort(function(a,c){a=nd(a);for(var b=nd(c),e=0;e<a.length;e++){c=a[e];var f=b[e];if(c!==f)return a=Array.from(c.parentNode.childNodes),a.indexOf(c)-a.indexOf(f)}})}function nd(a){var b=[];do b.unshift(a);while(a=a.parentNode);return b}function Ec(a){Dc(a);return!!a.s.length}G.prototype.addEventListener=function(a,b,c){"object"!==typeof c&&(c={capture:!!c});c.ba=this;this.host.addEventListener(a,b,c)};
G.prototype.removeEventListener=function(a,b,c){"object"!==typeof c&&(c={capture:!!c});c.ba=this;this.host.removeEventListener(a,b,c)};G.prototype.getElementById=function(a){return Jc(this,function(b){return b.id==a},function(a){return!!a})[0]||null};var od=G.prototype;E(od,mc,!0);E(od,rc,!0);function pd(a){var b=a.getRootNode();z(b)&&jd(b);return a.__shady&&a.__shady.assignedSlot||null}
var qd={addEventListener:Zc.bind(window),removeEventListener:ad.bind(window)},rd={addEventListener:Zc,removeEventListener:ad,appendChild:function(a){return wc(this,a)},insertBefore:function(a,b){return wc(this,a,b)},removeChild:function(a){return xc(this,a)},replaceChild:function(a,b){wc(this,a,b);xc(this,b);return a},cloneNode:function(a){if("template"==this.localName)var b=A.cloneNode.call(this,a);else if(b=A.cloneNode.call(this,!1),a){a=this.childNodes;for(var c=0,d;c<a.length;c++)d=a[c].cloneNode(!0),
b.appendChild(d)}return b},getRootNode:function(){return Ic(this)},contains:function(a){return Cb(this,a)},get isConnected(){var a=this.ownerDocument;if(Bb&&A.contains.call(a,this)||a.documentElement&&A.contains.call(a.documentElement,this))return!0;for(a=this;a&&!(a instanceof Document);)a=a.parentNode||(a instanceof G?a.host:void 0);return!!(a&&a instanceof Document)},dispatchEvent:function(a){Gb();return A.dispatchEvent.call(this,a)}},sd={get assignedSlot(){return pd(this)}},td={querySelector:function(a){return Jc(this,
function(b){return tb.call(b,a)},function(a){return!!a})[0]||null},querySelectorAll:function(a){return Jc(this,function(b){return tb.call(b,a)})}},ud={assignedNodes:function(a){if("slot"===this.localName){var b=this.getRootNode();z(b)&&jd(b);return this.__shady?(a&&a.flatten?this.__shady.K:this.__shady.assignedNodes)||[]:[]}}},vd=vb({setAttribute:function(a,b){Mc(this,a,b)},removeAttribute:function(a){A.removeAttribute.call(this,a);Fc(this,a)},attachShadow:function(a){if(!this)throw"Must provide a host.";
if(!a)throw"Not enough arguments.";return new G(id,this,a)},get slot(){return this.getAttribute("slot")},set slot(a){Mc(this,"slot",a)},get assignedSlot(){return pd(this)}},td,ud);Object.defineProperties(vd,qc);var wd=vb({importNode:function(a,b){return Nc(a,b)},getElementById:function(a){return Jc(this,function(b){return b.id==a},function(a){return!!a})[0]||null}},td);Object.defineProperties(wd,{_activeElement:rc.activeElement});
var xd=HTMLElement.prototype.blur,yd=vb({blur:function(){var a=this.__shady&&this.__shady.root;(a=a&&a.activeElement)?a.blur():xd.call(this)}});function H(a,b){for(var c=Object.getOwnPropertyNames(b),d=0;d<c.length;d++){var e=c[d],f=Object.getOwnPropertyDescriptor(b,e);f.value?a[e]=f.value:Object.defineProperty(a,e,f)}};if(y.ta){var ShadyDOM={inUse:y.ta,patch:function(a){return a},isShadyRoot:z,enqueue:Fb,flush:Gb,settings:y,filterMutations:Mb,observeChildren:Kb,unobserveChildren:Lb,nativeMethods:A,nativeTree:B};window.ShadyDOM=ShadyDOM;window.Event=cd;window.CustomEvent=dd;window.MouseEvent=ed;bd();var zd=window.customElements&&window.customElements.nativeHTMLElement||HTMLElement;H(window.Node.prototype,rd);H(window.Window.prototype,qd);H(window.Text.prototype,sd);H(window.DocumentFragment.prototype,td);H(window.Element.prototype,
vd);H(window.Document.prototype,wd);window.HTMLSlotElement&&H(window.HTMLSlotElement.prototype,ud);H(zd.prototype,yd);y.M&&(F(window.Node.prototype),F(window.Text.prototype),F(window.DocumentFragment.prototype),F(window.Element.prototype),F(zd.prototype),F(window.Document.prototype),window.HTMLSlotElement&&F(window.HTMLSlotElement.prototype));window.ShadowRoot=G};var Ad=new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));function Bd(a){var b=Ad.has(a);a=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(a);return!b&&a}function J(a){var b=a.isConnected;if(void 0!==b)return b;for(;a&&!(a.__CE_isImportDocument||a instanceof Document);)a=a.parentNode||(window.ShadowRoot&&a instanceof ShadowRoot?a.host:void 0);return!(!a||!(a.__CE_isImportDocument||a instanceof Document))}
function Cd(a,b){for(;b&&b!==a&&!b.nextSibling;)b=b.parentNode;return b&&b!==a?b.nextSibling:null}
function K(a,b,c){c=void 0===c?new Set:c;for(var d=a;d;){if(d.nodeType===Node.ELEMENT_NODE){var e=d;b(e);var f=e.localName;if("link"===f&&"import"===e.getAttribute("rel")){d=e.import;if(d instanceof Node&&!c.has(d))for(c.add(d),d=d.firstChild;d;d=d.nextSibling)K(d,b,c);d=Cd(a,e);continue}else if("template"===f){d=Cd(a,e);continue}if(e=e.__CE_shadowRoot)for(e=e.firstChild;e;e=e.nextSibling)K(e,b,c)}d=d.firstChild?d.firstChild:Cd(a,d)}}function L(a,b,c){a[b]=c};function Dd(){this.a=new Map;this.o=new Map;this.h=[];this.c=!1}function Ed(a,b,c){a.a.set(b,c);a.o.set(c.constructor,c)}function Fd(a,b){a.c=!0;a.h.push(b)}function Gd(a,b){a.c&&K(b,function(b){return a.b(b)})}Dd.prototype.b=function(a){if(this.c&&!a.__CE_patched){a.__CE_patched=!0;for(var b=0;b<this.h.length;b++)this.h[b](a)}};function M(a,b){var c=[];K(b,function(a){return c.push(a)});for(b=0;b<c.length;b++){var d=c[b];1===d.__CE_state?a.connectedCallback(d):Hd(a,d)}}
function N(a,b){var c=[];K(b,function(a){return c.push(a)});for(b=0;b<c.length;b++){var d=c[b];1===d.__CE_state&&a.disconnectedCallback(d)}}
function O(a,b,c){c=void 0===c?{}:c;var d=c.$a||new Set,e=c.wa||function(b){return Hd(a,b)},f=[];K(b,function(b){if("link"===b.localName&&"import"===b.getAttribute("rel")){var c=b.import;c instanceof Node&&(c.__CE_isImportDocument=!0,c.__CE_hasRegistry=!0);c&&"complete"===c.readyState?c.__CE_documentLoadHandled=!0:b.addEventListener("load",function(){var c=b.import;if(!c.__CE_documentLoadHandled){c.__CE_documentLoadHandled=!0;var f=new Set(d);f.delete(c);O(a,c,{$a:f,wa:e})}})}else f.push(b)},d);if(a.c)for(b=
0;b<f.length;b++)a.b(f[b]);for(b=0;b<f.length;b++)e(f[b])}
function Hd(a,b){if(void 0===b.__CE_state){var c=b.ownerDocument;if(c.defaultView||c.__CE_isImportDocument&&c.__CE_hasRegistry)if(c=a.a.get(b.localName)){c.constructionStack.push(b);var d=c.constructor;try{try{if(new d!==b)throw Error("The custom element constructor did not produce the element being upgraded.");}finally{c.constructionStack.pop()}}catch(h){throw b.__CE_state=2,h;}b.__CE_state=1;b.__CE_definition=c;if(c.attributeChangedCallback)for(c=c.observedAttributes,d=0;d<c.length;d++){var e=c[d],
f=b.getAttribute(e);null!==f&&a.attributeChangedCallback(b,e,null,f,null)}J(b)&&a.connectedCallback(b)}}}Dd.prototype.connectedCallback=function(a){var b=a.__CE_definition;b.connectedCallback&&b.connectedCallback.call(a)};Dd.prototype.disconnectedCallback=function(a){var b=a.__CE_definition;b.disconnectedCallback&&b.disconnectedCallback.call(a)};
Dd.prototype.attributeChangedCallback=function(a,b,c,d,e){var f=a.__CE_definition;f.attributeChangedCallback&&-1<f.observedAttributes.indexOf(b)&&f.attributeChangedCallback.call(a,b,c,d,e)};function Id(a){var b=document;this.j=a;this.a=b;this.C=void 0;O(this.j,this.a);"loading"===this.a.readyState&&(this.C=new MutationObserver(this.b.bind(this)),this.C.observe(this.a,{childList:!0,subtree:!0}))}function Jd(a){a.C&&a.C.disconnect()}Id.prototype.b=function(a){var b=this.a.readyState;"interactive"!==b&&"complete"!==b||Jd(this);for(b=0;b<a.length;b++)for(var c=a[b].addedNodes,d=0;d<c.length;d++)O(this.j,c[d])};function Kd(){var a=this;this.b=this.a=void 0;this.c=new Promise(function(b){a.b=b;a.a&&b(a.a)})}Kd.prototype.resolve=function(a){if(this.a)throw Error("Already resolved.");this.a=a;this.b&&this.b(a)};function P(a){this.da=!1;this.j=a;this.ha=new Map;this.ea=function(a){return a()};this.R=!1;this.fa=[];this.Fa=new Id(a)}
P.prototype.define=function(a,b){var c=this;if(!(b instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!Bd(a))throw new SyntaxError("The element name '"+a+"' is not valid.");if(this.j.a.get(a))throw Error("A custom element with name '"+a+"' has already been defined.");if(this.da)throw Error("A custom element is already being defined.");this.da=!0;try{var d=function(a){var b=e[a];if(void 0!==b&&!(b instanceof Function))throw Error("The '"+a+"' callback must be a function.");
return b},e=b.prototype;if(!(e instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");var f=d("connectedCallback");var h=d("disconnectedCallback");var g=d("adoptedCallback");var k=d("attributeChangedCallback");var l=b.observedAttributes||[]}catch(m){return}finally{this.da=!1}b={localName:a,constructor:b,connectedCallback:f,disconnectedCallback:h,adoptedCallback:g,attributeChangedCallback:k,observedAttributes:l,constructionStack:[]};Ed(this.j,a,b);this.fa.push(b);
this.R||(this.R=!0,this.ea(function(){return Ld(c)}))};function Ld(a){if(!1!==a.R){a.R=!1;for(var b=a.fa,c=[],d=new Map,e=0;e<b.length;e++)d.set(b[e].localName,[]);O(a.j,document,{wa:function(b){if(void 0===b.__CE_state){var e=b.localName,f=d.get(e);f?f.push(b):a.j.a.get(e)&&c.push(b)}}});for(e=0;e<c.length;e++)Hd(a.j,c[e]);for(;0<b.length;){var f=b.shift();e=f.localName;f=d.get(f.localName);for(var h=0;h<f.length;h++)Hd(a.j,f[h]);(e=a.ha.get(e))&&e.resolve(void 0)}}}
P.prototype.get=function(a){if(a=this.j.a.get(a))return a.constructor};P.prototype.whenDefined=function(a){if(!Bd(a))return Promise.reject(new SyntaxError("'"+a+"' is not a valid custom element name."));var b=this.ha.get(a);if(b)return b.c;b=new Kd;this.ha.set(a,b);this.j.a.get(a)&&!this.fa.some(function(b){return b.localName===a})&&b.resolve(void 0);return b.c};P.prototype.Ta=function(a){Jd(this.Fa);var b=this.ea;this.ea=function(c){return a(function(){return b(c)})}};
window.CustomElementRegistry=P;P.prototype.define=P.prototype.define;P.prototype.get=P.prototype.get;P.prototype.whenDefined=P.prototype.whenDefined;P.prototype.polyfillWrapFlushCallback=P.prototype.Ta;var Md=window.Document.prototype.createElement,Nd=window.Document.prototype.createElementNS,Od=window.Document.prototype.importNode,Pd=window.Document.prototype.prepend,Qd=window.Document.prototype.append,Rd=window.DocumentFragment.prototype.prepend,Sd=window.DocumentFragment.prototype.append,Td=window.Node.prototype.cloneNode,Ud=window.Node.prototype.appendChild,Vd=window.Node.prototype.insertBefore,Wd=window.Node.prototype.removeChild,Xd=window.Node.prototype.replaceChild,Yd=Object.getOwnPropertyDescriptor(window.Node.prototype,
"textContent"),Zd=window.Element.prototype.attachShadow,$d=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),ae=window.Element.prototype.getAttribute,be=window.Element.prototype.setAttribute,ce=window.Element.prototype.removeAttribute,de=window.Element.prototype.getAttributeNS,ee=window.Element.prototype.setAttributeNS,fe=window.Element.prototype.removeAttributeNS,ge=window.Element.prototype.insertAdjacentElement,he=window.Element.prototype.prepend,ie=window.Element.prototype.append,
je=window.Element.prototype.before,ke=window.Element.prototype.after,le=window.Element.prototype.replaceWith,me=window.Element.prototype.remove,ne=window.HTMLElement,oe=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),pe=window.HTMLElement.prototype.insertAdjacentElement;var qe=new function(){};function re(){var a=se;window.HTMLElement=function(){function b(){var b=this.constructor,d=a.o.get(b);if(!d)throw Error("The custom element being constructed was not registered with `customElements`.");var e=d.constructionStack;if(0===e.length)return e=Md.call(document,d.localName),Object.setPrototypeOf(e,b.prototype),e.__CE_state=1,e.__CE_definition=d,a.b(e),e;d=e.length-1;var f=e[d];if(f===qe)throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
e[d]=qe;Object.setPrototypeOf(f,b.prototype);a.b(f);return f}b.prototype=ne.prototype;return b}()};function te(a,b,c){function d(b){return function(c){for(var d=[],e=0;e<arguments.length;++e)d[e-0]=arguments[e];e=[];for(var f=[],l=0;l<d.length;l++){var m=d[l];m instanceof Element&&J(m)&&f.push(m);if(m instanceof DocumentFragment)for(m=m.firstChild;m;m=m.nextSibling)e.push(m);else e.push(m)}b.apply(this,d);for(d=0;d<f.length;d++)N(a,f[d]);if(J(this))for(d=0;d<e.length;d++)f=e[d],f instanceof Element&&M(a,f)}}void 0!==c.X&&(b.prepend=d(c.X));void 0!==c.append&&(b.append=d(c.append))};function ue(){var a=se;L(Document.prototype,"createElement",function(b){if(this.__CE_hasRegistry){var c=a.a.get(b);if(c)return new c.constructor}b=Md.call(this,b);a.b(b);return b});L(Document.prototype,"importNode",function(b,c){b=Od.call(this,b,c);this.__CE_hasRegistry?O(a,b):Gd(a,b);return b});L(Document.prototype,"createElementNS",function(b,c){if(this.__CE_hasRegistry&&(null===b||"http://www.w3.org/1999/xhtml"===b)){var d=a.a.get(c);if(d)return new d.constructor}b=Nd.call(this,b,c);a.b(b);return b});
te(a,Document.prototype,{X:Pd,append:Qd})};function ve(){var a=se;function b(b,d){Object.defineProperty(b,"textContent",{enumerable:d.enumerable,configurable:!0,get:d.get,set:function(b){if(this.nodeType===Node.TEXT_NODE)d.set.call(this,b);else{var c=void 0;if(this.firstChild){var e=this.childNodes,g=e.length;if(0<g&&J(this)){c=Array(g);for(var k=0;k<g;k++)c[k]=e[k]}}d.set.call(this,b);if(c)for(b=0;b<c.length;b++)N(a,c[b])}}})}L(Node.prototype,"insertBefore",function(b,d){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);
b=Vd.call(this,b,d);if(J(this))for(d=0;d<c.length;d++)M(a,c[d]);return b}c=J(b);d=Vd.call(this,b,d);c&&N(a,b);J(this)&&M(a,b);return d});L(Node.prototype,"appendChild",function(b){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);b=Ud.call(this,b);if(J(this))for(var e=0;e<c.length;e++)M(a,c[e]);return b}c=J(b);e=Ud.call(this,b);c&&N(a,b);J(this)&&M(a,b);return e});L(Node.prototype,"cloneNode",function(b){b=Td.call(this,b);this.ownerDocument.__CE_hasRegistry?O(a,b):
Gd(a,b);return b});L(Node.prototype,"removeChild",function(b){var c=J(b),e=Wd.call(this,b);c&&N(a,b);return e});L(Node.prototype,"replaceChild",function(b,d){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);b=Xd.call(this,b,d);if(J(this))for(N(a,d),d=0;d<c.length;d++)M(a,c[d]);return b}c=J(b);var f=Xd.call(this,b,d),h=J(this);h&&N(a,d);c&&N(a,b);h&&M(a,b);return f});Yd&&Yd.get?b(Node.prototype,Yd):Fd(a,function(a){b(a,{enumerable:!0,configurable:!0,get:function(){for(var a=
[],b=0;b<this.childNodes.length;b++)a.push(this.childNodes[b].textContent);return a.join("")},set:function(a){for(;this.firstChild;)Wd.call(this,this.firstChild);Ud.call(this,document.createTextNode(a))}})})};function we(a){var b=Element.prototype;function c(b){return function(c){for(var d=[],e=0;e<arguments.length;++e)d[e-0]=arguments[e];e=[];for(var g=[],k=0;k<d.length;k++){var l=d[k];l instanceof Element&&J(l)&&g.push(l);if(l instanceof DocumentFragment)for(l=l.firstChild;l;l=l.nextSibling)e.push(l);else e.push(l)}b.apply(this,d);for(d=0;d<g.length;d++)N(a,g[d]);if(J(this))for(d=0;d<e.length;d++)g=e[d],g instanceof Element&&M(a,g)}}void 0!==je&&(b.before=c(je));void 0!==je&&(b.after=c(ke));void 0!==
le&&L(b,"replaceWith",function(b){for(var c=[],d=0;d<arguments.length;++d)c[d-0]=arguments[d];d=[];for(var h=[],g=0;g<c.length;g++){var k=c[g];k instanceof Element&&J(k)&&h.push(k);if(k instanceof DocumentFragment)for(k=k.firstChild;k;k=k.nextSibling)d.push(k);else d.push(k)}g=J(this);le.apply(this,c);for(c=0;c<h.length;c++)N(a,h[c]);if(g)for(N(a,this),c=0;c<d.length;c++)h=d[c],h instanceof Element&&M(a,h)});void 0!==me&&L(b,"remove",function(){var b=J(this);me.call(this);b&&N(a,this)})};function xe(){var a=se;function b(b,c){Object.defineProperty(b,"innerHTML",{enumerable:c.enumerable,configurable:!0,get:c.get,set:function(b){var d=this,e=void 0;J(this)&&(e=[],K(this,function(a){a!==d&&e.push(a)}));c.set.call(this,b);if(e)for(var f=0;f<e.length;f++){var l=e[f];1===l.__CE_state&&a.disconnectedCallback(l)}this.ownerDocument.__CE_hasRegistry?O(a,this):Gd(a,this);return b}})}function c(b,c){L(b,"insertAdjacentElement",function(b,d){var e=J(d);b=c.call(this,b,d);e&&N(a,d);J(b)&&M(a,d);
return b})}Zd&&L(Element.prototype,"attachShadow",function(a){return this.__CE_shadowRoot=a=Zd.call(this,a)});$d&&$d.get?b(Element.prototype,$d):oe&&oe.get?b(HTMLElement.prototype,oe):Fd(a,function(a){b(a,{enumerable:!0,configurable:!0,get:function(){return Td.call(this,!0).innerHTML},set:function(a){var b="template"===this.localName,c=b?this.content:this,d=Md.call(document,this.localName);for(d.innerHTML=a;0<c.childNodes.length;)Wd.call(c,c.childNodes[0]);for(a=b?d.content:d;0<a.childNodes.length;)Ud.call(c,
a.childNodes[0])}})});L(Element.prototype,"setAttribute",function(b,c){if(1!==this.__CE_state)return be.call(this,b,c);var d=ae.call(this,b);be.call(this,b,c);c=ae.call(this,b);a.attributeChangedCallback(this,b,d,c,null)});L(Element.prototype,"setAttributeNS",function(b,c,f){if(1!==this.__CE_state)return ee.call(this,b,c,f);var d=de.call(this,b,c);ee.call(this,b,c,f);f=de.call(this,b,c);a.attributeChangedCallback(this,c,d,f,b)});L(Element.prototype,"removeAttribute",function(b){if(1!==this.__CE_state)return ce.call(this,
b);var c=ae.call(this,b);ce.call(this,b);null!==c&&a.attributeChangedCallback(this,b,c,null,null)});L(Element.prototype,"removeAttributeNS",function(b,c){if(1!==this.__CE_state)return fe.call(this,b,c);var d=de.call(this,b,c);fe.call(this,b,c);var e=de.call(this,b,c);d!==e&&a.attributeChangedCallback(this,c,d,e,b)});pe?c(HTMLElement.prototype,pe):ge?c(Element.prototype,ge):console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");te(a,Element.prototype,{X:he,append:ie});we(a)}
;var ye=window.customElements;if(!ye||ye.forcePolyfill||"function"!=typeof ye.define||"function"!=typeof ye.get){var se=new Dd;re();ue();te(se,DocumentFragment.prototype,{X:Rd,append:Sd});ve();xe();document.__CE_hasRegistry=!0;var customElements=new P(se);Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:customElements})};function ze(){this.end=this.start=0;this.rules=this.parent=this.previous=null;this.cssText=this.parsedCssText="";this.atRule=!1;this.type=0;this.parsedSelector=this.selector=this.keyframesName=""}
function Ae(a){a=a.replace(Be,"").replace(Ce,"");var b=De,c=a,d=new ze;d.start=0;d.end=c.length;for(var e=d,f=0,h=c.length;f<h;f++)if("{"===c[f]){e.rules||(e.rules=[]);var g=e,k=g.rules[g.rules.length-1]||null;e=new ze;e.start=f+1;e.parent=g;e.previous=k;g.rules.push(e)}else"}"===c[f]&&(e.end=f+1,e=e.parent||d);return b(d,a)}
function De(a,b){var c=b.substring(a.start,a.end-1);a.parsedCssText=a.cssText=c.trim();a.parent&&(c=b.substring(a.previous?a.previous.end:a.parent.start,a.start-1),c=Ee(c),c=c.replace(Fe," "),c=c.substring(c.lastIndexOf(";")+1),c=a.parsedSelector=a.selector=c.trim(),a.atRule=0===c.indexOf("@"),a.atRule?0===c.indexOf("@media")?a.type=Je:c.match(Ke)&&(a.type=Le,a.keyframesName=a.selector.split(Fe).pop()):a.type=0===c.indexOf("--")?Me:Ne);if(c=a.rules)for(var d=0,e=c.length,f;d<e&&(f=c[d]);d++)De(f,
b);return a}function Ee(a){return a.replace(/\\([0-9a-f]{1,6})\s/gi,function(a,c){a=c;for(c=6-a.length;c--;)a="0"+a;return"\\"+a})}
function Oe(a,b,c){c=void 0===c?"":c;var d="";if(a.cssText||a.rules){var e=a.rules,f;if(f=e)f=e[0],f=!(f&&f.selector&&0===f.selector.indexOf("--"));if(f){f=0;for(var h=e.length,g;f<h&&(g=e[f]);f++)d=Oe(g,b,d)}else b?b=a.cssText:(b=a.cssText,b=b.replace(Pe,"").replace(Qe,""),b=b.replace(Re,"").replace(Se,"")),(d=b.trim())&&(d="  "+d+"\n")}d&&(a.selector&&(c+=a.selector+" {\n"),c+=d,a.selector&&(c+="}\n\n"));return c}
var Ne=1,Le=7,Je=4,Me=1E3,Be=/\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,Ce=/@import[^;]*;/gim,Pe=/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,Qe=/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,Re=/@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,Se=/[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,Ke=/^@[^\s]*keyframes/,Fe=/\s+/g;var Q=!(window.ShadyDOM&&window.ShadyDOM.inUse),Te;function Ue(a){Te=a&&a.shimcssproperties?!1:Q||!(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/)||!window.CSS||!CSS.supports||!CSS.supports("box-shadow","0 0 0 var(--foo)"))}window.ShadyCSS&&void 0!==window.ShadyCSS.nativeCss?Te=window.ShadyCSS.nativeCss:window.ShadyCSS?(Ue(window.ShadyCSS),window.ShadyCSS=void 0):Ue(window.WebComponents&&window.WebComponents.flags);var R=Te;var Ve=/(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,We=/(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,Xe=/(--[\w-]+)\s*([:,;)]|$)/gi,Ye=/(animation\s*:)|(animation-name\s*:)/,Ze=/@media\s(.*)/,$e=/\{[^}]*\}/g;var af=new Set;function bf(a,b){if(!a)return"";"string"===typeof a&&(a=Ae(a));b&&cf(a,b);return Oe(a,R)}function df(a){!a.__cssRules&&a.textContent&&(a.__cssRules=Ae(a.textContent));return a.__cssRules||null}function ef(a){return!!a.parent&&a.parent.type===Le}function cf(a,b,c,d){if(a){var e=!1,f=a.type;if(d&&f===Je){var h=a.selector.match(Ze);h&&(window.matchMedia(h[1]).matches||(e=!0))}f===Ne?b(a):c&&f===Le?c(a):f===Me&&(e=!0);if((a=a.rules)&&!e){e=0;f=a.length;for(var g;e<f&&(g=a[e]);e++)cf(g,b,c,d)}}}
function ff(a,b,c,d){var e=document.createElement("style");b&&e.setAttribute("scope",b);e.textContent=a;gf(e,c,d);return e}var S=null;function gf(a,b,c){b=b||document.head;b.insertBefore(a,c&&c.nextSibling||b.firstChild);S?a.compareDocumentPosition(S)===Node.DOCUMENT_POSITION_PRECEDING&&(S=a):S=a}
function hf(a,b){var c=a.indexOf("var(");if(-1===c)return b(a,"","","");a:{var d=0;var e=c+3;for(var f=a.length;e<f;e++)if("("===a[e])d++;else if(")"===a[e]&&0===--d)break a;e=-1}d=a.substring(c+4,e);c=a.substring(0,c);a=hf(a.substring(e+1),b);e=d.indexOf(",");return-1===e?b(c,d.trim(),"",a):b(c,d.substring(0,e).trim(),d.substring(e+1).trim(),a)}function jf(a,b){Q?a.setAttribute("class",b):window.ShadyDOM.nativeMethods.setAttribute.call(a,"class",b)}
function V(a){var b=a.localName,c="";b?-1<b.indexOf("-")||(c=b,b=a.getAttribute&&a.getAttribute("is")||""):(b=a.is,c=a.extends);return{is:b,P:c}};function kf(){}function lf(a,b,c){var d=W;a.__styleScoped?a.__styleScoped=null:mf(d,a,b||"",c)}function mf(a,b,c,d){b.nodeType===Node.ELEMENT_NODE&&nf(b,c,d);if(b="template"===b.localName?(b.content||b.gb).childNodes:b.children||b.childNodes)for(var e=0;e<b.length;e++)mf(a,b[e],c,d)}
function nf(a,b,c){if(b)if(a.classList)c?(a.classList.remove("style-scope"),a.classList.remove(b)):(a.classList.add("style-scope"),a.classList.add(b));else if(a.getAttribute){var d=a.getAttribute(of);c?d&&(b=d.replace("style-scope","").replace(b,""),jf(a,b)):jf(a,(d?d+" ":"")+"style-scope "+b)}}function pf(a,b,c){var d=W,e=a.__cssBuild;Q||"shady"===e?b=bf(b,c):(a=V(a),b=qf(d,b,a.is,a.P,c)+"\n\n");return b.trim()}
function qf(a,b,c,d,e){var f=rf(c,d);c=c?sf+c:"";return bf(b,function(b){b.c||(b.selector=b.m=tf(a,b,a.b,c,f),b.c=!0);e&&e(b,c,f)})}function rf(a,b){return b?"[is="+a+"]":a}function tf(a,b,c,d,e){var f=b.selector.split(uf);if(!ef(b)){b=0;for(var h=f.length,g;b<h&&(g=f[b]);b++)f[b]=c.call(a,g,d,e)}return f.join(uf)}function vf(a){return a.replace(wf,function(a,c,d){-1<d.indexOf("+")?d=d.replace(/\+/g,"___"):-1<d.indexOf("___")&&(d=d.replace(/___/g,"+"));return":"+c+"("+d+")"})}
kf.prototype.b=function(a,b,c){var d=!1;a=a.trim();var e=wf.test(a);e&&(a=a.replace(wf,function(a,b,c){return":"+b+"("+c.replace(/\s/g,"")+")"}),a=vf(a));a=a.replace(xf,yf+" $1");a=a.replace(zf,function(a,e,g){d||(a=Af(g,e,b,c),d=d||a.stop,e=a.Ja,g=a.value);return e+g});e&&(a=vf(a));return a};
function Af(a,b,c,d){var e=a.indexOf(Bf);0<=a.indexOf(yf)?a=Cf(a,d):0!==e&&(a=c?Df(a,c):a);c=!1;0<=e&&(b="",c=!0);if(c){var f=!0;c&&(a=a.replace(Ef,function(a,b){return" > "+b}))}a=a.replace(Ff,function(a,b,c){return'[dir="'+c+'"] '+b+", "+b+'[dir="'+c+'"]'});return{value:a,Ja:b,stop:f}}function Df(a,b){a=a.split(Gf);a[0]+=b;return a.join(Gf)}
function Cf(a,b){var c=a.match(Hf);return(c=c&&c[2].trim()||"")?c[0].match(If)?a.replace(Hf,function(a,c,f){return b+f}):c.split(If)[0]===b?c:Jf:a.replace(yf,b)}function Kf(a){a.selector===Lf&&(a.selector="html")}kf.prototype.c=function(a){return a.match(Bf)?this.b(a,Mf):Df(a.trim(),Mf)};q.Object.defineProperties(kf.prototype,{a:{configurable:!0,enumerable:!0,get:function(){return"style-scope"}}});
var wf=/:(nth[-\w]+)\(([^)]+)\)/,Mf=":not(.style-scope)",uf=",",zf=/(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=[])+)/g,If=/[[.:#*]/,yf=":host",Lf=":root",Bf="::slotted",xf=new RegExp("^("+Bf+")"),Hf=/(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,Ef=/(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,Ff=/(.*):dir\((?:(ltr|rtl))\)/,sf=".",Gf=":",of="class",Jf="should_not_match",W=new kf;function Nf(a,b,c,d){this.w=a||null;this.b=b||null;this.ja=c||[];this.G=null;this.P=d||"";this.a=this.u=this.B=null}function X(a){return a?a.__styleInfo:null}function Of(a,b){return a.__styleInfo=b}Nf.prototype.c=function(){return this.w};Nf.prototype._getStyleRules=Nf.prototype.c;var Pf,Qf=window.Element.prototype;Pf=Qf.matches||Qf.matchesSelector||Qf.mozMatchesSelector||Qf.msMatchesSelector||Qf.oMatchesSelector||Qf.webkitMatchesSelector;var Rf=navigator.userAgent.match("Trident");function Sf(){}function Tf(a){var b={},c=[],d=0;cf(a,function(a){Uf(a);a.index=d++;a=a.i.cssText;for(var c;c=Xe.exec(a);){var e=c[1];":"!==c[2]&&(b[e]=!0)}},function(a){c.push(a)});a.b=c;a=[];for(var e in b)a.push(e);return a}
function Uf(a){if(!a.i){var b={},c={};Vf(a,c)&&(b.v=c,a.rules=null);b.cssText=a.parsedCssText.replace($e,"").replace(Ve,"");a.i=b}}function Vf(a,b){var c=a.i;if(c){if(c.v)return Object.assign(b,c.v),!0}else{c=a.parsedCssText;for(var d;a=Ve.exec(c);){d=(a[2]||a[3]).trim();if("inherit"!==d||"unset"!==d)b[a[1].trim()]=d;d=!0}return d}}
function Wf(a,b,c){b&&(b=0<=b.indexOf(";")?Xf(a,b,c):hf(b,function(b,e,f,h){if(!e)return b+h;(e=Wf(a,c[e],c))&&"initial"!==e?"apply-shim-inherit"===e&&(e="inherit"):e=Wf(a,c[f]||f,c)||f;return b+(e||"")+h}));return b&&b.trim()||""}
function Xf(a,b,c){b=b.split(";");for(var d=0,e,f;d<b.length;d++)if(e=b[d]){We.lastIndex=0;if(f=We.exec(e))e=Wf(a,c[f[1]],c);else if(f=e.indexOf(":"),-1!==f){var h=e.substring(f);h=h.trim();h=Wf(a,h,c)||h;e=e.substring(0,f)+h}b[d]=e&&e.lastIndexOf(";")===e.length-1?e.slice(0,-1):e||""}return b.join(";")}
function Yf(a,b){var c={},d=[];cf(a,function(a){a.i||Uf(a);var e=a.m||a.parsedSelector;b&&a.i.v&&e&&Pf.call(b,e)&&(Vf(a,c),a=a.index,e=parseInt(a/32,10),d[e]=(d[e]||0)|1<<a%32)},null,!0);return{v:c,key:d}}
function Zf(a,b,c,d){b.i||Uf(b);if(b.i.v){var e=V(a);a=e.is;e=e.P;e=a?rf(a,e):"html";var f=b.parsedSelector,h=":host > *"===f||"html"===f,g=0===f.indexOf(":host")&&!h;"shady"===c&&(h=f===e+" > *."+e||-1!==f.indexOf("html"),g=!h&&0===f.indexOf(e));"shadow"===c&&(h=":host > *"===f||"html"===f,g=g&&!h);if(h||g)c=e,g&&(Q&&!b.m&&(b.m=tf(W,b,W.b,a?sf+a:"",e)),c=b.m||e),d({Xa:c,Oa:g,ib:h})}}
function $f(a,b){var c={},d={},e=b&&b.__cssBuild;cf(b,function(b){Zf(a,b,e,function(e){Pf.call(a.hb||a,e.Xa)&&(e.Oa?Vf(b,c):Vf(b,d))})},null,!0);return{Va:d,Na:c}}
function ag(a,b,c,d){var e=V(b),f=rf(e.is,e.P),h=new RegExp("(?:^|[^.#[:])"+(b.extends?"\\"+f.slice(0,-1)+"\\]":f)+"($|[.:[\\s>+~])");e=X(b).w;var g=bg(e,d);return pf(b,e,function(b){var e="";b.i||Uf(b);b.i.cssText&&(e=Xf(a,b.i.cssText,c));b.cssText=e;if(!Q&&!ef(b)&&b.cssText){var k=e=b.cssText;null==b.ra&&(b.ra=Ye.test(e));if(b.ra)if(null==b.W){b.W=[];for(var n in g)k=g[n],k=k(e),e!==k&&(e=k,b.W.push(n))}else{for(n=0;n<b.W.length;++n)k=g[b.W[n]],e=k(e);k=e}b.cssText=k;b.m=b.m||b.selector;e="."+d;
n=b.m.split(",");k=0;for(var w=n.length,I;k<w&&(I=n[k]);k++)n[k]=I.match(h)?I.replace(f,e):e+" "+I;b.selector=n.join(",")}})}function bg(a,b){a=a.b;var c={};if(!Q&&a)for(var d=0,e=a[d];d<a.length;e=a[++d]){var f=e,h=b;f.h=new RegExp(f.keyframesName,"g");f.a=f.keyframesName+"-"+h;f.m=f.m||f.selector;f.selector=f.m.replace(f.keyframesName,f.a);c[e.keyframesName]=cg(e)}return c}function cg(a){return function(b){return b.replace(a.h,a.a)}}
function dg(a,b){var c=eg,d=df(a);a.textContent=bf(d,function(a){var d=a.cssText=a.parsedCssText;a.i&&a.i.cssText&&(d=d.replace(Pe,"").replace(Qe,""),a.cssText=Xf(c,d,b))})}q.Object.defineProperties(Sf.prototype,{a:{configurable:!0,enumerable:!0,get:function(){return"x-scope"}}});var eg=new Sf;var fg={},gg=window.customElements;if(gg&&!Q){var hg=gg.define;gg.define=function(a,b,c){var d=document.createComment(" Shady DOM styles for "+a+" "),e=document.head;e.insertBefore(d,(S?S.nextSibling:null)||e.firstChild);S=d;fg[a]=d;return hg.call(gg,a,b,c)}};function ig(){this.cache={}}ig.prototype.store=function(a,b,c,d){var e=this.cache[a]||[];e.push({v:b,styleElement:c,u:d});100<e.length&&e.shift();this.cache[a]=e};ig.prototype.fetch=function(a,b,c){if(a=this.cache[a])for(var d=a.length-1;0<=d;d--){var e=a[d],f;a:{for(f=0;f<c.length;f++){var h=c[f];if(e.v[h]!==b[h]){f=!1;break a}}f=!0}if(f)return e}};function jg(){}
function kg(a){for(var b=0;b<a.length;b++){var c=a[b];if(c.target!==document.documentElement&&c.target!==document.head)for(var d=0;d<c.addedNodes.length;d++){var e=c.addedNodes[d];if(e.nodeType===Node.ELEMENT_NODE){var f=e.getRootNode();var h=e;var g=[];h.classList?g=Array.from(h.classList):h instanceof window.SVGElement&&h.hasAttribute("class")&&(g=h.getAttribute("class").split(/\s+/));h=g;g=h.indexOf(W.a);if((h=-1<g?h[g+1]:"")&&f===e.ownerDocument)lf(e,h,!0);else if(f.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&
(f=f.host))if(f=V(f).is,h===f)for(e=window.ShadyDOM.nativeMethods.querySelectorAll.call(e,":not(."+W.a+")"),f=0;f<e.length;f++)nf(e[f],h);else h&&lf(e,h,!0),lf(e,f)}}}}
if(!Q){var lg=new MutationObserver(kg),mg=function(a){lg.observe(a,{childList:!0,subtree:!0})};if(window.customElements&&!window.customElements.polyfillWrapFlushCallback)mg(document);else{var ng=function(){mg(document.body)};window.HTMLImports?window.HTMLImports.whenReady(ng):requestAnimationFrame(function(){if("loading"===document.readyState){var a=function(){ng();document.removeEventListener("readystatechange",a)};document.addEventListener("readystatechange",a)}else ng()})}jg=function(){kg(lg.takeRecords())}}
var og=jg;var pg={};var qg=Promise.resolve();function rg(a){if(a=pg[a])a._applyShimCurrentVersion=a._applyShimCurrentVersion||0,a._applyShimValidatingVersion=a._applyShimValidatingVersion||0,a._applyShimNextVersion=(a._applyShimNextVersion||0)+1}function sg(a){return a._applyShimCurrentVersion===a._applyShimNextVersion}function tg(a){a._applyShimValidatingVersion=a._applyShimNextVersion;a.b||(a.b=!0,qg.then(function(){a._applyShimCurrentVersion=a._applyShimNextVersion;a.b=!1}))};var ug=null,vg=window.HTMLImports&&window.HTMLImports.whenReady||null,wg;function xg(a){requestAnimationFrame(function(){vg?vg(a):(ug||(ug=new Promise(function(a){wg=a}),"complete"===document.readyState?wg():document.addEventListener("readystatechange",function(){"complete"===document.readyState&&wg()})),ug.then(function(){a&&a()}))})};var yg=new ig;function Y(){var a=this;this.L={};this.c=document.documentElement;var b=new ze;b.rules=[];this.h=Of(this.c,new Nf(b));this.o=!1;this.b=this.a=null;xg(function(){zg(a)})}p=Y.prototype;p.xa=function(){og()};p.La=function(a){return df(a)};p.Za=function(a){return bf(a)};
p.prepareTemplate=function(a,b,c){if(!a.h){a.h=!0;a.name=b;a.extends=c;pg[b]=a;var d=(d=a.content.querySelector("style"))?d.getAttribute("css-build")||"":"";var e=[];for(var f=a.content.querySelectorAll("style"),h=0;h<f.length;h++){var g=f[h];if(g.hasAttribute("shady-unscoped")){if(!Q){var k=g.textContent;af.has(k)||(af.add(k),k=g.cloneNode(!0),document.head.appendChild(k));g.parentNode.removeChild(g)}}else e.push(g.textContent),g.parentNode.removeChild(g)}e=e.join("").trim();c={is:b,extends:c,eb:d};
Q||lf(a.content,b);zg(this);f=We.test(e)||Ve.test(e);We.lastIndex=0;Ve.lastIndex=0;e=Ae(e);f&&R&&this.a&&this.a.transformRules(e,b);a._styleAst=e;a.o=d;d=[];R||(d=Tf(a._styleAst));if(!d.length||R)e=Q?a.content:null,b=fg[b],f=pf(c,a._styleAst),b=f.length?ff(f,c.is,e,b):void 0,a.a=b;a.c=d}};
function Ag(a){!a.b&&window.ShadyCSS&&window.ShadyCSS.CustomStyleInterface&&(a.b=window.ShadyCSS.CustomStyleInterface,a.b.transformCallback=function(b){a.va(b)},a.b.validateCallback=function(){requestAnimationFrame(function(){(a.b.enqueued||a.o)&&a.F()})})}function zg(a){!a.a&&window.ShadyCSS&&window.ShadyCSS.ApplyShim&&(a.a=window.ShadyCSS.ApplyShim,a.a.invalidCallback=rg);Ag(a)}
p.F=function(){zg(this);if(this.b){var a=this.b.processStyles();if(this.b.enqueued){if(R)for(var b=0;b<a.length;b++){var c=this.b.getStyleForCustomStyle(a[b]);if(c&&R&&this.a){var d=df(c);zg(this);this.a.transformRules(d);c.textContent=bf(d)}}else for(Bg(this,this.c,this.h),b=0;b<a.length;b++)(c=this.b.getStyleForCustomStyle(a[b]))&&dg(c,this.h.B);this.b.enqueued=!1;this.o&&!R&&this.styleDocument()}}};
p.styleElement=function(a,b){var c=V(a).is,d=X(a);if(!d){var e=V(a);d=e.is;e=e.P;var f=fg[d];d=pg[d];if(d){var h=d._styleAst;var g=d.c}d=Of(a,new Nf(h,f,g,e))}a!==this.c&&(this.o=!0);b&&(d.G=d.G||{},Object.assign(d.G,b));if(R){if(d.G){b=d.G;for(var k in b)null===k?a.style.removeProperty(k):a.style.setProperty(k,b[k])}if(((k=pg[c])||a===this.c)&&k&&k.a&&!sg(k)){if(sg(k)||k._applyShimValidatingVersion!==k._applyShimNextVersion)zg(this),this.a&&this.a.transformRules(k._styleAst,c),k.a.textContent=pf(a,
d.w),tg(k);Q&&(c=a.shadowRoot)&&(c.querySelector("style").textContent=pf(a,d.w));d.w=k._styleAst}}else if(Bg(this,a,d),d.ja&&d.ja.length){c=d;k=V(a).is;d=(b=yg.fetch(k,c.B,c.ja))?b.styleElement:null;h=c.u;(g=b&&b.u)||(g=this.L[k]=(this.L[k]||0)+1,g=k+"-"+g);c.u=g;g=c.u;e=eg;e=d?d.textContent||"":ag(e,a,c.B,g);f=X(a);var l=f.a;l&&!Q&&l!==d&&(l._useCount--,0>=l._useCount&&l.parentNode&&l.parentNode.removeChild(l));Q?f.a?(f.a.textContent=e,d=f.a):e&&(d=ff(e,g,a.shadowRoot,f.b)):d?d.parentNode||(Rf&&
-1<e.indexOf("@media")&&(d.textContent=e),gf(d,null,f.b)):e&&(d=ff(e,g,null,f.b));d&&(d._useCount=d._useCount||0,f.a!=d&&d._useCount++,f.a=d);g=d;Q||(d=c.u,f=e=a.getAttribute("class")||"",h&&(f=e.replace(new RegExp("\\s*x-scope\\s*"+h+"\\s*","g")," ")),f+=(f?" ":"")+"x-scope "+d,e!==f&&jf(a,f));b||yg.store(k,c.B,g,c.u)}};function Cg(a,b){return(b=b.getRootNode().host)?X(b)?b:Cg(a,b):a.c}
function Bg(a,b,c){a=Cg(a,b);var d=X(a);a=Object.create(d.B||null);var e=$f(b,c.w);b=Yf(d.w,b).v;Object.assign(a,e.Na,b,e.Va);b=c.G;for(var f in b)if((e=b[f])||0===e)a[f]=e;f=eg;b=Object.getOwnPropertyNames(a);for(e=0;e<b.length;e++)d=b[e],a[d]=Wf(f,a[d],a);c.B=a}p.styleDocument=function(a){this.styleSubtree(this.c,a)};
p.styleSubtree=function(a,b){var c=a.shadowRoot;(c||a===this.c)&&this.styleElement(a,b);if(b=c&&(c.children||c.childNodes))for(a=0;a<b.length;a++)this.styleSubtree(b[a]);else if(a=a.children||a.childNodes)for(b=0;b<a.length;b++)this.styleSubtree(a[b])};p.va=function(a){var b=this,c=df(a);cf(c,function(a){if(Q)Kf(a);else{var c=W;a.selector=a.parsedSelector;Kf(a);a.selector=a.m=tf(c,a,c.c,void 0,void 0)}R&&(zg(b),b.a&&b.a.transformRule(a))});R?a.textContent=bf(c):this.h.w.rules.push(c)};
p.getComputedStyleValue=function(a,b){var c;R||(c=(X(a)||X(Cg(this,a))).B[b]);return(c=c||window.getComputedStyle(a).getPropertyValue(b))?c.trim():""};p.Ya=function(a,b){var c=a.getRootNode();b=b?b.split(/\s/):[];c=c.host&&c.host.localName;if(!c){var d=a.getAttribute("class");if(d){d=d.split(/\s/);for(var e=0;e<d.length;e++)if(d[e]===W.a){c=d[e+1];break}}}c&&b.push(W.a,c);R||(c=X(a))&&c.u&&b.push(eg.a,c.u);jf(a,b.join(" "))};p.Ia=function(a){return X(a)};Y.prototype.flush=Y.prototype.xa;
Y.prototype.prepareTemplate=Y.prototype.prepareTemplate;Y.prototype.styleElement=Y.prototype.styleElement;Y.prototype.styleDocument=Y.prototype.styleDocument;Y.prototype.styleSubtree=Y.prototype.styleSubtree;Y.prototype.getComputedStyleValue=Y.prototype.getComputedStyleValue;Y.prototype.setElementClass=Y.prototype.Ya;Y.prototype._styleInfoForNode=Y.prototype.Ia;Y.prototype.transformCustomStyleForDocument=Y.prototype.va;Y.prototype.getStyleAst=Y.prototype.La;Y.prototype.styleAstToString=Y.prototype.Za;
Y.prototype.flushCustomStyles=Y.prototype.F;Object.defineProperties(Y.prototype,{nativeShadow:{get:function(){return Q}},nativeCss:{get:function(){return R}}});var Z=new Y,Dg,Eg;window.ShadyCSS&&(Dg=window.ShadyCSS.ApplyShim,Eg=window.ShadyCSS.CustomStyleInterface);window.ShadyCSS={ScopingShim:Z,prepareTemplate:function(a,b,c){Z.F();Z.prepareTemplate(a,b,c)},styleSubtree:function(a,b){Z.F();Z.styleSubtree(a,b)},styleElement:function(a){Z.F();Z.styleElement(a)},styleDocument:function(a){Z.F();Z.styleDocument(a)},getComputedStyleValue:function(a,b){return Z.getComputedStyleValue(a,b)},nativeCss:R,nativeShadow:Q};Dg&&(window.ShadyCSS.ApplyShim=Dg);
Eg&&(window.ShadyCSS.CustomStyleInterface=Eg);var Fg=window.customElements,Gg=window.HTMLImports,Hg=window.HTMLTemplateElement;window.WebComponents=window.WebComponents||{};if(Fg&&Fg.polyfillWrapFlushCallback){var Ig,Jg=function(){if(Ig){Hg.J&&Hg.J(window.document);var a=Ig;Ig=null;a();return!0}},Kg=Gg.whenReady;Fg.polyfillWrapFlushCallback(function(a){Ig=a;Kg(Jg)});Gg.whenReady=function(a){Kg(function(){Jg()?Gg.whenReady(a):a()})}}
Gg.whenReady(function(){requestAnimationFrame(function(){window.WebComponents.ready=!0;document.dispatchEvent(new CustomEvent("WebComponentsReady",{bubbles:!0}))})});var Lg=document.createElement("style");Lg.textContent="body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";var Mg=document.querySelector("head");Mg.insertBefore(Lg,Mg.firstChild);}).call(this);

//# sourceMappingURL=webcomponents-lite.js.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(103), __webpack_require__(104)))

/***/ }),
/* 103 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 104 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2JjMzg3MWY5NGM0MDc4ZWI5MmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZXNvbHZlLXVybC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcGF0aC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL3R5cG9ncmFwaHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3N0eWxlLXNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY3NzLXBhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXJlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsdXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy90ZW1wbGF0aXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1pY29uL2lyb24taWNvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1tZXRhL2lyb24tbWV0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vdGFjdGlsZS9jbGllbnQvYWpheC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L2xlZ2FjeS1lbGVtZW50LW1peGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvc3R5bGUtdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3RlbXBsYXRlLW1hcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2RvY3VtZW50LXdhaXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYXJyYXktc3BsaWNlLmpzIiwid2VicGFjazovLy8uL3RhY3RpbGUvY2xpZW50L3RhY3RpbGUtZWRpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpdC1odG1sLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9zaGFkb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tZm9ybS1lbGVtZW50LWJlaGF2aW9yL2lyb24tZm9ybS1lbGVtZW50LWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWlucHV0L3BhcGVyLWlucHV0LWFkZG9uLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL3RhY3RpbGUvY2xpZW50L3RhY3RpbGUtbW9kZS5qcyIsIndlYnBhY2s6Ly8vLi90YWN0aWxlL2NsaWVudC9hdXRob3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2FwcGx5LXNoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvdW5zY29wZWQtc3R5bGUtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2FwcGx5LXNoaW0tdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1hY2Nlc3NvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy90ZW1wbGF0ZS1zdGFtcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWRpYWxvZy9wYXBlci1kaWFsb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL25lb24tYW5pbWF0aW9uL25lb24tYW5pbWF0aW9uLXJ1bm5lci1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvbmVvbi1hbmltYXRpb24vbmVvbi1hbmltYXRhYmxlLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1kaWFsb2ctYmVoYXZpb3IvcGFwZXItZGlhbG9nLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW92ZXJsYXktYmVoYXZpb3IvaXJvbi1vdmVybGF5LWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZpdC1iZWhhdmlvci9pcm9uLWZpdC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tb3ZlcmxheS1iZWhhdmlvci9pcm9uLW92ZXJsYXktbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lyb24tb3ZlcmxheS1iYWNrZHJvcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lyb24tZm9jdXNhYmxlcy1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWRpYWxvZy1iZWhhdmlvci9wYXBlci1kaWFsb2ctc2hhcmVkLXN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvZm9udC1yb2JvdG8vcm9ib3RvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1idXR0b24vcGFwZXItYnV0dG9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItYnV0dG9uLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvZWxlbWVudC1zdHlsZXMvcGFwZXItbWF0ZXJpYWwtc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pY29uLWJ1dHRvbi9wYXBlci1pY29uLWJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24taW5wdXQvaXJvbi1pbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1hMTF5LWFubm91bmNlci9pcm9uLWExMXktYW5ub3VuY2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtY2hhci1jb3VudGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC1jb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWlucHV0L3BhcGVyLWlucHV0LWVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1jaGVja2JveC9wYXBlci1jaGVja2JveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24taWNvbnMvaXJvbi1pY29ucy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1pY29uc2V0LXN2Zy9pcm9uLWljb25zZXQtc3ZnLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci10b2dnbGUtYnV0dG9uL3BhcGVyLXRvZ2dsZS1idXR0b24uanMiLCJ3ZWJwYWNrOi8vLy4vZ2xvYmFsL2NsaWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzL3dlYmNvbXBvbmVudHMtbGl0ZS5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiXSwibmFtZXMiOlsiYWpheCIsInVybCIsImRhdGEiLCJtZXRob2QiLCJoZWFkZXJzIiwic3VjY2Vzc0NhbGxiYWNrIiwiZXJyb3JDYWxsYmFjayIsImNvbmZpZyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJvayIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiRXJyb3IiLCJqc29uIiwiY2F0Y2giLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJtZXNzYWdlIiwiYWpheEdldCIsIkhlYWRlcnMiLCJ1bmRlZmluZWQiLCJhamF4UG9zdCIsImFwcGVuZCIsImFqYXhQdXQiLCJhamF4RGVsZXRlIiwiVGFjdGlsZUVkaXRhYmxlIiwiaXMiLCJwcm9wZXJ0aWVzIiwicGF0aCIsInR5cGUiLCJTdHJpbmciLCJjb21wVHlwZSIsImlubGluZSIsIkJvb2xlYW4iLCJkZWZhdWx0IiwiY29uc3RydWN0b3IiLCJhdHRhY2hTaGFkb3ciLCJtb2RlIiwiY29ubmVjdGVkQ2FsbGJhY2siLCJjb21wb25lbnQiLCJ0YWN0aWxlTW9kZSIsImRvY3VtZW50IiwicXVlcnlTZWxlY3RvciIsImVkaXRNb2RlIiwicmVuZGVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsImVkaXRDb250ZW50IiwiYmxvY2tDb250ZW50Iiwib3RoZXJDb250ZW50IiwiX2NyZWF0ZU1lc3NhZ2UiLCJfY3JlYXRlSW5wdXRzIiwiX2NyZWF0ZUJ1dHRvbnMiLCJfZWRpdFN0eWxlcyIsImF1dGhvciIsInRpdGxlIiwiX2NyZWF0ZUNvbmZpZ3VyZWFibGVCdXR0b25zIiwiX2Jsb2NrU3R5bGVzIiwic2hhZG93Um9vdCIsIl9hdHRhY2hJbmxpbmVFdmVudEhhbmRsZXJzIiwib3BlbkRpYWxvZyIsImNhbGxiYWNrIiwicGFwZXJEaWFsb2ciLCJvcGVuIiwiX2F0dGFjaENsb3NlZEhhbmRsZXJzIiwiX2F0dGFjaERpYWxvZ0J1dHRvbkhhbmRsZXJzIiwiZm9ybVZhbHVlcyIsInZhbHVlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiaW5wdXQiLCJ2YWx1ZSIsIm5hbWUiLCJhY3RpdmUiLCJkaWFsb2dDbG9zZWQiLCJldmVudCIsImRldGFpbCIsImNvbmZpcm1lZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJBcnJheSIsImZyb20iLCJidXR0b24iLCJlIiwiYWRkQnV0dG9uIiwic3RvcFByb3BhZ2F0aW9uIiwidGFyZ2V0IiwiZGF0YXNldCIsInRlbXBsYXRlIiwicGFyc2UiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInJlbG9hZCIsImlubGluZUJ1dHRvbnMiLCJzdHlsZSIsInZpc2liaWxpdHkiLCJvcGFjaXR5IiwiaW5wdXRzIiwiYXR0cnMiLCJwdXNoIiwiZGVzY3JpcHRpb24iLCJidXR0b25zIiwiZXh0cmFCdXR0b25zIiwicHJldmVudERlbGV0ZSIsImRlbGV0ZUJ1dHRvbiIsImN1c3RvbUVsZW1lbnRzIiwiZGVmaW5lIiwiVGFjdGlsZU1vZGUiLCJ0b2dnbGUiLCJjaGVja2VkIiwiZGlzcGF0Y2hFdmVudCIsIkN1c3RvbUV2ZW50Iiwic3dpdGNoVG9FZGl0Iiwic3dpdGNoVG9QdWJsaXNoIiwid2F0Y2hGb3JDb21wb25lbnRDbGlja3MiLCJwcmV2ZW50RGVmYXVsdCIsImNsb3Nlc3QiLCJ0YWN0aWxlRWRpdGFibGUiLCJyZXF1aXJlc1JlZnJlc2giLCJzZXR1cEVkaXRNb2RlIiwiY2xhc3NMaXN0IiwiYWRkIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwic2V0dXBQdWJsaXNoTW9kZSIsInJlbW92ZSIsImNvbnRhaW5zIiwiZ2V0SXRlbSIsImdldEJyZWFrcG9pbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwiZ2V0UHJvcGVydHlWYWx1ZSIsInJlcGxhY2UiLCJicmVha3BvaW50IiwiJCIsInJlc2l6ZSIsImRlc2t0b3AiLCJ0YWJsZXQiLCJwaG9uZSJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBMkIsMEJBQTBCLEVBQUU7QUFDdkQseUNBQWlDLGVBQWU7QUFDaEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOERBQXNELCtEQUErRDs7QUFFckg7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQzdENkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7OztBQ1RBLHdEQUF3RCxhQUFhOztBQUVyRTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDaUM7QUFDWTs7QUFFN0M7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsS0FBSztBQUNsQjtB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OztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsV0FBVztBQUN0QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUVBQXVFLGNBQWM7O0FBRXJGO0FBQUE7QUFBQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixZQUFZO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixXQUFXLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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OztBQUVBLENBQUM7QUFBQTtBQUFBOztBQUVEO0FBQ0E7Ozs7Ozs7OztBQzNHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0QsWUFBWTtBQUNaO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxjQUFjO0FBQzNCLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7QUM5YkE7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7O0FDbktBO0FBQ2tCO0FBQ0o7O0FBRWQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsOEJBQThCLEtBQUs7QUFDbkM7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFUTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2ZlI7QUFDK0I7QUFDL0I7QUFDYzs7QUFFZDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQzs7QUFFQTtBQUNBO0FB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ekQ7QUFDRCxDOzs7Ozs7Ozs7OztBQ2hERDtBQUMrQjtBQUNqQjtBQUNJOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUgsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQSxvQzs7Ozs7Ozs7QUN2ZkE7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN2VUE7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FDckVBO0FBQ2tCOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSw2REFBNkQsYUFBYTtBQUMxRTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7QUNsRUE7QUFDbUI7QUFDbkI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBLGlIQUFnRCxrQkFBa0I7QUFDbEUsR0FBRzs7QUFFSDtBQUNBO0FB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QUE7QUFBQTs7Ozs7Ozs7Ozs7QUNsSUE7QUFDOEI7QUFDaEI7O0FBRWQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7OztBQy9GQTtBQUMwQjtBQUNNO0FBQ0g7QUFDRTtBQUNqQjs7QUFFZDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLGlFQUFpRSxpQkFBaUI7QUFDbEY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFBQTtBQUFBOzs7Ozs7Ozs7O0FDN2lCQTtBQUNjOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7O0FDcGpCQTtBQUNtQjtBQUNMOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSwwQ0FBMEMsYUFBYSxFQUFFOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBLDRCQUE0QixhQUFhO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FB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QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7OztBQ2pFQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNOQTtBQUNBO0FBQ3VEO0FBQ3ZEO0FBQ2tCO0FBQ2xCO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7QUNwSUQ7QUFDK0M7QUFDakI7QUFDSDs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDbkRBO0FBQ0E7QUFDaUM7QUFDakM7QUFDa0I7QUFDbEI7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3RIRDtBQUNrQztBQUNsQztBQUM2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDa0I7QUFDRTtBQUNGO0FBQ2xCO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaU1BQWlNLE9BQU8sYUFBYSxTQUFTO0FBQzlOOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTyxzR0FBc0csU0FBUztBQUNwSjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7Ozs7Ozs7Ozs7Ozs7QUM3S0Q7QUFDNEI7QUFDTTtBQUNoQjtBQUNKO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQyxpQkFBaUI7QUFDdEQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG9DQUFvQztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7O0FDeFJEO0FBQytCOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7OztBQ3RFQTtBQUMrQjtBQUNKO0FBQ1Q7QUFDSjtBQUNkO0FBQUE7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixtQkFBbUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7QUMxaEJBO0FBQ0E7QUFDa0M7QUFDaEI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7QUNsRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDa0I7QUFDUTtBQUNaO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4RkFBOEY7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSw4QkFBOEIsNkJBQTZCO0FBQzNEO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUN4akJEO0FBQ0E7QUFDQTtBQUNrQztBQUNoQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUM1REQ7QUFDQTtBQUNzQztBQUNwQjtBQUNRO0FBQ1c7QUFDckM7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7O0FDbFJEO0FBQ2tDO0FBQ0E7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLEdBQUc7QUFDaEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QixrQkFBa0Isb0JBQW9CLEVBQUUsS0FBSyxzQ0FBc0MsbUNBQW1DOztBQUU1YTs7Ozs7Ozs7QUNsTUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7QUNwQkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVSIsImZpbGUiOiI3YmMzODcxZjk0YzQwNzhlYjkyYy5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDUzKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCA3YmMzODcxZjk0YzQwNzhlYjkyYyIsImltcG9ydCB7IExlZ2FjeUVsZW1lbnRNaXhpbiB9IGZyb20gJy4vbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyc7XG5pbXBvcnQgJy4vbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCAnLi9saWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvZG9tLWJpbmQuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvZG9tLWlmLmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvYXJyYXktc2VsZWN0b3IuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuanMnO1xuaW1wb3J0ICcuL2xpYi9sZWdhY3kvbXV0YWJsZS1kYXRhLWJlaGF2aW9yLmpzJztcbmV4cG9ydCBjb25zdCBCYXNlID0gTGVnYWN5RWxlbWVudE1peGluKEhUTUxFbGVtZW50KS5wcm90b3R5cGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL3BvbHltZXIuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwid2luZG93LkpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wLCBvYmopIHsgcmV0dXJuIHByb3A7IH1cblxuLyoqIEBuYW1lc3BhY2UgKi9cbmxldCBQb2x5bWVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0ICcuLi91dGlscy9zZXR0aW5ncy5qcyc7XG5pbXBvcnQgeyBGbGF0dGVuZWROb2Rlc09ic2VydmVyIH0gZnJvbSAnLi4vdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IGZsdXNoIGFzIGZsdXNoJDAsIGVucXVldWVEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9mbHVzaC5qcyc7XG5cbmNvbnN0IHAgPSBFbGVtZW50LnByb3RvdHlwZTtcbi8qKlxuICogQGNvbnN0IHtmdW5jdGlvbih0aGlzOkVsZW1lbnQsIHN0cmluZyk6IGJvb2xlYW59XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZWRNYXRjaGVzU2VsZWN0b3IgPSBwLm1hdGNoZXMgfHwgcC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgcC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICBwLm9NYXRjaGVzU2VsZWN0b3IgfHwgcC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gYGVsZW1lbnQubWF0Y2hlc2Agc2hpbS5cbiAqXG4gKiBAZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yXG4gKiBAbWVtYmVyb2YgUG9seW1lci5kb21cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGUgTm9kZSB0byBjaGVjayBzZWxlY3RvciBhZ2FpbnN0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gbWF0Y2hcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbm9kZSBtYXRjaGVkIHNlbGVjdG9yXG4gKi9cbmNvbnN0IG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBub3JtYWxpemVkTWF0Y2hlc1NlbGVjdG9yLmNhbGwobm9kZSwgc2VsZWN0b3IpO1xufTtcblxuLyoqXG4gKiBOb2RlIEFQSSB3cmFwcGVyIGNsYXNzIHJldHVybmVkIGZyb20gYFBvbHltZXIuZG9tLih0YXJnZXQpYCB3aGVuXG4gKiBgdGFyZ2V0YCBpcyBhIGBOb2RlYC5cbiAqL1xuY2xhc3MgRG9tQXBpIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIFBvbHltZXIuZG9tIGhlbHBlciBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIHRoYXRcbiAgICogbGlzdGVucyBmb3Igbm9kZSBjaGFuZ2VzIG9uIHRoaXMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gZGlyZWN0IG9yIGRpc3RyaWJ1dGVkIGNoaWxkcmVuXG4gICAqICAgb2YgdGhpcyBlbGVtZW50IGNoYW5nZXNcbiAgICogQHJldHVybiB7UG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyfSBPYnNlcnZlciBpbnN0YW5jZVxuICAgKi9cbiAgb2JzZXJ2ZU5vZGVzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0dGVuZWROb2Rlc09ic2VydmVyKHRoaXMubm9kZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGFuIG9ic2VydmVyIHByZXZpb3VzbHkgY3JlYXRlZCB2aWEgYG9ic2VydmVOb2Rlc2BcbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJ9IG9ic2VydmVySGFuZGxlIE9ic2VydmVyIGluc3RhbmNlXG4gICAqICAgdG8gZGlzY29ubmVjdC5cbiAgICovXG4gIHVub2JzZXJ2ZU5vZGVzKG9ic2VydmVySGFuZGxlKSB7XG4gICAgb2JzZXJ2ZXJIYW5kbGUuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVkIGFzIGEgYmFja3dhcmRzLWNvbXBhdGlibGUgQVBJIG9ubHkuICBUaGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqL1xuICBub3RpZnlPYnNlcnZlcigpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgbm9kZSBpcyBjb250YWluZWQgd2l0aCB0aGlzIGVsZW1lbnQnc1xuICAgKiBsaWdodC1ET00gY2hpbGRyZW4gb3Igc2hhZG93IHJvb3QsIGluY2x1ZGluZyBhbnkgbmVzdGVkIHNoYWRvdyByb290c1xuICAgKiBvZiBjaGlsZHJlbiB0aGVyZWluLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byB0ZXN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGNvbnRhaW5lZCB3aXRoaW5cbiAgICogICB0aGlzIGVsZW1lbnQncyBsaWdodCBvciBzaGFkb3cgRE9NLlxuICAgKi9cbiAgZGVlcENvbnRhaW5zKG5vZGUpIHtcbiAgICBpZiAodGhpcy5ub2RlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG4gPSBub2RlO1xuICAgIGxldCBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gd2FsayBmcm9tIG5vZGUgdG8gYHRoaXNgIG9yIGBkb2N1bWVudGBcbiAgICB3aGlsZSAobiAmJiBuICE9PSBkb2MgJiYgbiAhPT0gdGhpcy5ub2RlKSB7XG4gICAgICAvLyB1c2UgbG9naWNhbCBwYXJlbnRub2RlLCBvciBuYXRpdmUgU2hhZG93Um9vdCBob3N0XG4gICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICB9XG4gICAgcmV0dXJuIG4gPT09IHRoaXMubm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IG5vZGUgb2YgdGhpcyBub2RlLiAgRXF1aXZhbGVudCB0byBgZ2V0Um9vZE5vZGUoKWAuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRvcCBtb3N0IGVsZW1lbnQgaW4gdGhlIGRvbSB0cmVlIGluIHdoaWNoIHRoZSBub2RlXG4gICAqIGV4aXN0cy4gSWYgdGhlIG5vZGUgaXMgY29ubmVjdGVkIHRvIGEgZG9jdW1lbnQgdGhpcyBpcyBlaXRoZXIgYVxuICAgKiBzaGFkb3dSb290IG9yIHRoZSBkb2N1bWVudDsgb3RoZXJ3aXNlLCBpdCBtYXkgYmUgdGhlIG5vZGVcbiAgICogaXRzZWxmIG9yIGEgbm9kZSBvciBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIGl0LlxuICAgKi9cbiAgZ2V0T3duZXJSb290KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3Igc2xvdCBlbGVtZW50cywgcmV0dXJucyB0aGUgbm9kZXMgYXNzaWduZWQgdG8gdGhlIHNsb3Q7IG90aGVyd2lzZVxuICAgKiBhbiBlbXB0eSBhcnJheS4gSXQgaXMgZXF1aXZhbGVudCB0byBgPHNsb3Q+LmFkZGlnbmVkTm9kZXMoe2ZsYXR0ZW46dHJ1ZX0pYC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IEFycmF5IG9mIGFzc2lnbmVkIG5vZGVzXG4gICAqL1xuICBnZXREaXN0cmlidXRlZE5vZGVzKCkge1xuICAgIHJldHVybiAodGhpcy5ub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSA/XG4gICAgICB0aGlzLm5vZGUuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pIDpcbiAgICAgIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHNsb3RzIHRoaXMgZWxlbWVudCB3YXMgZGlzdHJpYnV0ZWQgdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PEhUTUxTbG90RWxlbWVudD59IERlc2NyaXB0aW9uXG4gICAqL1xuICBnZXREZXN0aW5hdGlvbkluc2VydGlvblBvaW50cygpIHtcbiAgICBsZXQgaXAkID0gW107XG4gICAgbGV0IG4gPSB0aGlzLm5vZGUuYXNzaWduZWRTbG90O1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpcCQucHVzaChuKTtcbiAgICAgIG4gPSBuLmFzc2lnbmVkU2xvdDtcbiAgICB9XG4gICAgcmV0dXJuIGlwJDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBgaW1wb3J0Tm9kZWAgb24gdGhlIGBvd25lckRvY3VtZW50YCBmb3IgdGhpcyBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBpbXBvcnRcbiAgICogQHBhcmFtIHtib29sZWFufSBkZWVwIFRydWUgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIGNsb25lZCBkZWVwbHkgZHVyaW5nXG4gICAqICAgaW1wb3J0XG4gICAqIEByZXR1cm4ge05vZGV9IENsb25lIG9mIGdpdmVuIG5vZGUgaW1wb3J0ZWQgdG8gdGhpcyBvd25lciBkb2N1bWVudFxuICAgKi9cbiAgaW1wb3J0Tm9kZShub2RlLCBkZWVwKSB7XG4gICAgbGV0IGRvYyA9IHRoaXMubm9kZSBpbnN0YW5jZW9mIERvY3VtZW50ID8gdGhpcy5ub2RlIDpcbiAgICAgIHRoaXMubm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBkb2MuaW1wb3J0Tm9kZShub2RlLCBkZWVwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhIGZsYXR0ZW5lZCBsaXN0IG9mIGFsbCBjaGlsZCBub2RlcyBhbmQgbm9kZXMgYXNzaWduZWRcbiAgICogdG8gY2hpbGQgc2xvdHMuXG4gICAqL1xuICBnZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCkge1xuICAgIHJldHVybiBGbGF0dGVuZWROb2Rlc09ic2VydmVyLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMubm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGZpbHRlcmVkIGxpc3Qgb2YgZmxhdHRlbmVkIGNoaWxkIGVsZW1lbnRzIGZvciB0aGlzIGVsZW1lbnQgYmFzZWRcbiAgICogb24gdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gZmlsdGVyIG5vZGVzIGFnYWluc3RcbiAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fSBMaXN0IG9mIGZsYXR0ZW5lZCBjaGlsZCBlbGVtZW50c1xuICAgKi9cbiAgcXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgbGV0IGMkID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgbGV0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpPTAsIGw9YyQubGVuZ3RoLCBjOyAoaTxsKSAmJiAoYz1jJFtpXSk7IGkrKykge1xuICAgICAgaWYgKChjLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgJiZcbiAgICAgICAgICBtYXRjaGVzU2VsZWN0b3IoYywgc2VsZWN0b3IpKSB7XG4gICAgICAgIGxpc3QucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHNoYWRvdyByb290cywgcmV0dXJucyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCB3aXRoaW4gdGhpc1xuICAgKiBzaGFkb3cgcm9vdC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IEN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICovXG4gIGdldCBhY3RpdmVFbGVtZW50KCkge1xuICAgIGxldCBub2RlID0gdGhpcy5ub2RlO1xuICAgIHJldHVybiBub2RlLl9hY3RpdmVFbGVtZW50ICE9PSB1bmRlZmluZWQgPyBub2RlLl9hY3RpdmVFbGVtZW50IDogbm9kZS5hY3RpdmVFbGVtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRNZXRob2RzKHByb3RvLCBtZXRob2RzKSB7XG4gIGZvciAobGV0IGk9MDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICBwcm90b1ttZXRob2RdID0gLyoqIEB0aGlzIHtEb21BcGl9ICovIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZVttZXRob2RdLmFwcGx5KHRoaXMubm9kZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWFkT25seVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yd2FyZFByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mb3J3YXJkTWV0aG9kcyhEb21BcGkucHJvdG90eXBlLCBbXG4gICdjbG9uZU5vZGUnLCAnYXBwZW5kQ2hpbGQnLCAnaW5zZXJ0QmVmb3JlJywgJ3JlbW92ZUNoaWxkJyxcbiAgJ3JlcGxhY2VDaGlsZCcsICdzZXRBdHRyaWJ1dGUnLCAncmVtb3ZlQXR0cmlidXRlJyxcbiAgJ3F1ZXJ5U2VsZWN0b3InLCAncXVlcnlTZWxlY3RvckFsbCdcbl0pO1xuXG5mb3J3YXJkUmVhZE9ubHlQcm9wZXJ0aWVzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgJ3BhcmVudE5vZGUnLCAnZmlyc3RDaGlsZCcsICdsYXN0Q2hpbGQnLFxuICAnbmV4dFNpYmxpbmcnLCAncHJldmlvdXNTaWJsaW5nJywgJ2ZpcnN0RWxlbWVudENoaWxkJyxcbiAgJ2xhc3RFbGVtZW50Q2hpbGQnLCAnbmV4dEVsZW1lbnRTaWJsaW5nJywgJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnLFxuICAnY2hpbGROb2RlcycsICdjaGlsZHJlbicsICdjbGFzc0xpc3QnXG5dKTtcblxuZm9yd2FyZFByb3BlcnRpZXMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAndGV4dENvbnRlbnQnLCAnaW5uZXJIVE1MJ1xuXSk7XG5cblxuLyoqXG4gKiBFdmVudCBBUEkgd3JhcHBlciBjbGFzcyByZXR1cm5lZCBmcm9tIGBQb2x5bWVyLmRvbS4odGFyZ2V0KWAgd2hlblxuICogYHRhcmdldGAgaXMgYW4gYEV2ZW50YC5cbiAqL1xuY2xhc3MgRXZlbnRBcGkge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBub2RlIG9uIHRoZSBgY29tcG9zZWRQYXRoYCBvZiB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbm9kZSB0aGlzIGV2ZW50IHdhcyBkaXNwYXRjaGVkIHRvXG4gICAqL1xuICBnZXQgcm9vdFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsb2NhbCAocmUtdGFyZ2V0ZWQpIHRhcmdldCBmb3IgdGhpcyBldmVudC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIGxvY2FsIChyZS10YXJnZXRlZCkgdGFyZ2V0IGZvciB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGxvY2FsVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50LnRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgY29tcG9zZWRQYXRoYCBmb3IgdGhpcyBldmVudC5cbiAgICovXG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICB9XG59XG5cbmV4cG9ydCB7IERvbUFwaSB9O1xuXG5leHBvcnQgY29uc3QgZG9tID0gZnVuY3Rpb24ob2JqKSB7XG4gIG9iaiA9IG9iaiB8fCBkb2N1bWVudDtcbiAgaWYgKCFvYmouX19kb21BcGkpIHtcbiAgICBsZXQgaGVscGVyO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgaGVscGVyID0gbmV3IEV2ZW50QXBpKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlbHBlciA9IG5ldyBEb21BcGkob2JqKTtcbiAgICB9XG4gICAgb2JqLl9fZG9tQXBpID0gaGVscGVyO1xuICB9XG4gIHJldHVybiBvYmouX19kb21BcGk7XG59O1xuXG5leHBvcnQgeyBtYXRjaGVzU2VsZWN0b3IgfTtcbmV4cG9ydCB7IGZsdXNoJDAgYXMgZmx1c2ggfTtcbmV4cG9ydCB7IGVucXVldWVEZWJvdW5jZXIgYXMgYWRkRGVib3VuY2VyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ2xhc3MgfSBmcm9tICcuL2NsYXNzLmpzJztcblxuZXhwb3J0IGNvbnN0IFBvbHltZXIgPSBmdW5jdGlvbihpbmZvKSB7XG4gIC8vIGlmIGlucHV0IGlzIGEgYGNsYXNzYCAoYWthIGEgZnVuY3Rpb24gd2l0aCBhIHByb3RvdHlwZSksIHVzZSB0aGUgcHJvdG90eXBlXG4gIC8vIHJlbWVtYmVyIHRoYXQgdGhlIGBjb25zdHJ1Y3RvcmAgd2lsbCBuZXZlciBiZSBjYWxsZWRcbiAgbGV0IGtsYXNzO1xuICBpZiAodHlwZW9mIGluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICBrbGFzcyA9IGluZm87XG4gIH0gZWxzZSB7XG4gICAga2xhc3MgPSBDbGFzcyhpbmZvKTtcbiAgfVxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoa2xhc3MuaXMsIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyhrbGFzcykpO1xuICByZXR1cm4ga2xhc3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vLyB1bmlxdWUgZ2xvYmFsIGlkIGZvciBkZWR1cGluZyBtaXhpbnMuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBNaXhpbkZ1bmN0aW9uKCl7fVxuLyoqIEB0eXBlIHsoV2Vha01hcCB8IHVuZGVmaW5lZCl9ICovXG5NaXhpbkZ1bmN0aW9uLnByb3RvdHlwZS5fX21peGluQXBwbGljYXRpb25zO1xuLyoqIEB0eXBlIHsoT2JqZWN0IHwgdW5kZWZpbmVkKX0gKi9cbk1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5TZXQ7XG5cbmV4cG9ydCBjb25zdCBkZWR1cGluZ01peGluID0gZnVuY3Rpb24obWl4aW4pIHtcbiAgbGV0IG1peGluQXBwbGljYXRpb25zID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4gIGlmICghbWl4aW5BcHBsaWNhdGlvbnMpIHtcbiAgICBtaXhpbkFwcGxpY2F0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnMgPSBtaXhpbkFwcGxpY2F0aW9ucztcbiAgfVxuICAvLyBtYWludGFpbiBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBtaXhpblxuICBsZXQgbWl4aW5EZWR1cGVJZCA9IGRlZHVwZUlkKys7XG4gIGZ1bmN0aW9uIGRlZHVwaW5nTWl4aW4oYmFzZSkge1xuICAgIGxldCBiYXNlU2V0ID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oYmFzZSkuX19taXhpblNldDtcbiAgICBpZiAoYmFzZVNldCAmJiBiYXNlU2V0W21peGluRGVkdXBlSWRdKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgbGV0IG1hcCA9IG1peGluQXBwbGljYXRpb25zO1xuICAgIGxldCBleHRlbmRlZCA9IG1hcC5nZXQoYmFzZSk7XG4gICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgZXh0ZW5kZWQgPSAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8obWl4aW4pKGJhc2UpO1xuICAgICAgbWFwLnNldChiYXNlLCBleHRlbmRlZCk7XG4gICAgfVxuICAgIC8vIGNvcHkgaW5oZXJpdGVkIG1peGluIHNldCBmcm9tIHRoZSBleHRlbmRlZCBjbGFzcywgb3IgdGhlIGJhc2UgY2xhc3NcbiAgICAvLyBOT1RFOiB3ZSBhdm9pZCB1c2Ugb2YgU2V0IGhlcmUgYmVjYXVzZSBzb21lIGJyb3dzZXIgKElFMTEpXG4gICAgLy8gY2Fubm90IGV4dGVuZCBhIGJhc2UgU2V0IHZpYSB0aGUgY29uc3RydWN0b3IuXG4gICAgbGV0IG1peGluU2V0ID0gT2JqZWN0LmNyZWF0ZSgvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCB8fCBiYXNlU2V0IHx8IG51bGwpO1xuICAgIG1peGluU2V0W21peGluRGVkdXBlSWRdID0gdHJ1ZTtcbiAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCA9IG1peGluU2V0O1xuICAgIHJldHVybiBleHRlbmRlZDtcbiAgfVxuXG4gIHJldHVybiBkZWR1cGluZ01peGluO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzXG4vLyBtb2R1bGUgaWQgPSA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnRNaXhpbiB9IGZyb20gJy4vbGliL21peGlucy9lbGVtZW50LW1peGluLmpzJztcblxuLyoqXG4gKiBCYXNlIGNsYXNzIHRoYXQgcHJvdmlkZXMgdGhlIGNvcmUgQVBJIGZvciBQb2x5bWVyJ3MgbWV0YS1wcm9ncmFtbWluZ1xuICogZmVhdHVyZXMgaW5jbHVkaW5nIHRlbXBsYXRlIHN0YW1waW5nLCBkYXRhLWJpbmRpbmcsIGF0dHJpYnV0ZSBkZXNlcmlhbGl6YXRpb24sXG4gKiBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uLlxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAcG9seW1lclxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5FbGVtZW50TWl4aW5cbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXInc1xuICogICBrZXkgbWV0YS1wcm9ncmFtbWluZyBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZyxcbiAqICAgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbiwgYW5kIHByb3BlcnR5IGNoYW5nZSBvYnNlcnZhdGlvblxuICovXG5jb25zdCBFbGVtZW50ID0gRWxlbWVudE1peGluKEhUTUxFbGVtZW50KTtcbmV4cG9ydCB7IEVsZW1lbnQgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcblxuLyoqIEB0eXBlZGVmIHt7cnVuOiBmdW5jdGlvbihmdW5jdGlvbigpLCBudW1iZXI9KTpudW1iZXIsIGNhbmNlbDogZnVuY3Rpb24obnVtYmVyKX19ICovXG5sZXQgQXN5bmNJbnRlcmZhY2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLy8gTWljcm90YXNrIGltcGxlbWVudGVkIHVzaW5nIE11dGF0aW9uIE9ic2VydmVyXG5sZXQgbWljcm90YXNrQ3VyckhhbmRsZSA9IDA7XG5sZXQgbWljcm90YXNrTGFzdEhhbmRsZSA9IDA7XG5sZXQgbWljcm90YXNrQ2FsbGJhY2tzID0gW107XG5sZXQgbWljcm90YXNrTm9kZUNvbnRlbnQgPSAwO1xubGV0IG1pY3JvdGFza05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5uZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobWljcm90YXNrRmx1c2gpLm9ic2VydmUobWljcm90YXNrTm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcblxuZnVuY3Rpb24gbWljcm90YXNrRmx1c2goKSB7XG4gIGNvbnN0IGxlbiA9IG1pY3JvdGFza0NhbGxiYWNrcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgY2IgPSBtaWNyb3Rhc2tDYWxsYmFja3NbaV07XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZTsgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG1pY3JvdGFza0NhbGxiYWNrcy5zcGxpY2UoMCwgbGVuKTtcbiAgbWljcm90YXNrTGFzdEhhbmRsZSArPSBsZW47XG59XG5cbmV4cG9ydCBjb25zdCB0aW1lT3V0ID0ge1xuICAvKipcbiAgICogUmV0dXJucyBhIHN1Yi1tb2R1bGUgd2l0aCB0aGUgYXN5bmMgaW50ZXJmYWNlIHByb3ZpZGluZyB0aGUgcHJvdmlkZWRcbiAgICogZGVsYXkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyBjYWxsYmFja3MgaW4gbXNcbiAgICogQHJldHVybiB7QXN5bmNJbnRlcmZhY2V9IEFuIGFzeW5jIHRpbWVvdXQgaW50ZXJmYWNlXG4gICAqL1xuICBhZnRlcihkZWxheSkge1xuICAgIHJldHVybiAge1xuICAgICAgcnVuKGZuKSB7IHJldHVybiBzZXRUaW1lb3V0KGZuLCBkZWxheSk7IH0sXG4gICAgICBjYW5jZWw6IHdpbmRvdy5jbGVhclRpbWVvdXQuYmluZCh3aW5kb3cpXG4gICAgfTtcbiAgfSxcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGluIHRoZSBuZXh0IHRhc2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW46IHdpbmRvdy5zZXRUaW1lb3V0LmJpbmQod2luZG93KSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGB0aW1lT3V0YCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKi9cbiAgY2FuY2VsOiB3aW5kb3cuY2xlYXJUaW1lb3V0LmJpbmQod2luZG93KVxufTtcblxuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbkZyYW1lID0ge1xuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5hbmltYXRpb25GcmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bjogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyksXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgYW5pbWF0aW9uRnJhbWVgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqL1xuICBjYW5jZWw6IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbn07XG5cbmV4cG9ydCBjb25zdCBpZGxlUGVyaW9kID0ge1xuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuaWRsZVBlcmlvZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKElkbGVEZWFkbGluZSl9IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGZuKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrID9cbiAgICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKGZuKSA6XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmbiwgMTYpO1xuICB9LFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYGlkbGVQZXJpb2RgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5pZGxlUGVyaW9kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayA/XG4gICAgICB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrKGhhbmRsZSkgOlxuICAgICAgd2luZG93LmNsZWFyVGltZW91dChoYW5kbGUpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWljcm9UYXNrID0ge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBtaWNyb3Rhc2sgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5taWNyb1Rhc2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oY2FsbGJhY2spIHtcbiAgICBtaWNyb3Rhc2tOb2RlLnRleHRDb250ZW50ID0gbWljcm90YXNrTm9kZUNvbnRlbnQrKztcbiAgICBtaWNyb3Rhc2tDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIG1pY3JvdGFza0N1cnJIYW5kbGUrKztcbiAgfSxcblxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYG1pY3JvVGFza2AgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKi9cbiAgY2FuY2VsKGhhbmRsZSkge1xuICAgIGNvbnN0IGlkeCA9IGhhbmRsZSAtIG1pY3JvdGFza0xhc3RIYW5kbGU7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBpZiAoIW1pY3JvdGFza0NhbGxiYWNrc1tpZHhdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhc3luYyBoYW5kbGU6ICcgKyBoYW5kbGUpO1xuICAgICAgfVxuICAgICAgbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5jb25zdCBjYXNlTWFwID0ge307XG5jb25zdCBEQVNIX1RPX0NBTUVMID0gLy1bYS16XS9nO1xuY29uc3QgQ0FNRUxfVE9fREFTSCA9IC8oW0EtWl0pL2c7XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXNoVG9DYW1lbENhc2UoZGFzaCkge1xuICByZXR1cm4gY2FzZU1hcFtkYXNoXSB8fCAoXG4gICAgY2FzZU1hcFtkYXNoXSA9IGRhc2guaW5kZXhPZignLScpIDwgMCA/IGRhc2ggOiBkYXNoLnJlcGxhY2UoREFTSF9UT19DQU1FTCxcbiAgICAgIChtKSA9PiBtWzFdLnRvVXBwZXJDYXNlKClcbiAgICApXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW1lbFRvRGFzaENhc2UoY2FtZWwpIHtcbiAgcmV0dXJuIGNhc2VNYXBbY2FtZWxdIHx8IChcbiAgICBjYXNlTWFwW2NhbWVsXSA9IGNhbWVsLnJlcGxhY2UoQ0FNRUxfVE9fREFTSCwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Nhc2UtbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi9jb2xvci5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGN1c3RvbS1zdHlsZT5cbiAgPHN0eWxlIGlzPVwiY3VzdG9tLXN0eWxlXCI+XG4gICAgaHRtbCB7XG4gICAgICAvKlxuICAgICAgICogWW91IGNhbiB1c2UgdGhlc2UgZ2VuZXJpYyB2YXJpYWJsZXMgaW4geW91ciBlbGVtZW50cyBmb3IgZWFzeSB0aGVtaW5nLlxuICAgICAgICogRm9yIGV4YW1wbGUsIGlmIGFsbCB5b3VyIGVsZW1lbnRzIHVzZSBcXGAtLXByaW1hcnktdGV4dC1jb2xvclxcYCBhcyBpdHMgbWFpblxuICAgICAgICogY29sb3IsIHRoZW4gc3dpdGNoaW5nIGZyb20gYSBsaWdodCB0byBhIGRhcmsgdGhlbWUgaXMganVzdCBhIG1hdHRlciBvZlxuICAgICAgICogY2hhbmdpbmcgdGhlIHZhbHVlIG9mIFxcYC0tcHJpbWFyeS10ZXh0LWNvbG9yXFxgIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICAgKi9cbiAgICAgIC0tcHJpbWFyeS10ZXh0LWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS10ZXh0LWNvbG9yKTtcbiAgICAgIC0tcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yKTtcbiAgICAgIC0tc2Vjb25kYXJ5LXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvcik7XG4gICAgICAtLWRpc2FibGVkLXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yKTtcbiAgICAgIC0tZGl2aWRlci1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtZGl2aWRlci1jb2xvcik7XG4gICAgICAtLWVycm9yLWNvbG9yOiB2YXIoLS1wYXBlci1kZWVwLW9yYW5nZS1hNzAwKTtcblxuICAgICAgLypcbiAgICAgICAqIFByaW1hcnkgYW5kIGFjY2VudCBjb2xvcnMuIEFsc28gc2VlIGNvbG9yLmh0bWwgZm9yIG1vcmUgY29sb3JzLlxuICAgICAgICovXG4gICAgICAtLXByaW1hcnktY29sb3I6IHZhcigtLXBhcGVyLWluZGlnby01MDApO1xuICAgICAgLS1saWdodC1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wYXBlci1pbmRpZ28tMTAwKTtcbiAgICAgIC0tZGFyay1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wYXBlci1pbmRpZ28tNzAwKTtcblxuICAgICAgLS1hY2NlbnQtY29sb3I6IHZhcigtLXBhcGVyLXBpbmstYTIwMCk7XG4gICAgICAtLWxpZ2h0LWFjY2VudC1jb2xvcjogdmFyKC0tcGFwZXItcGluay1hMTAwKTtcbiAgICAgIC0tZGFyay1hY2NlbnQtY29sb3I6IHZhcigtLXBhcGVyLXBpbmstYTQwMCk7XG5cblxuICAgICAgLypcbiAgICAgICAqIE1hdGVyaWFsIERlc2lnbiBMaWdodCBiYWNrZ3JvdW5kIHRoZW1lXG4gICAgICAgKi9cbiAgICAgIC0tbGlnaHQtdGhlbWUtYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcbiAgICAgIC0tbGlnaHQtdGhlbWUtYmFzZS1jb2xvcjogIzAwMDAwMDtcbiAgICAgIC0tbGlnaHQtdGhlbWUtdGV4dC1jb2xvcjogdmFyKC0tcGFwZXItZ3JleS05MDApO1xuICAgICAgLS1saWdodC10aGVtZS1zZWNvbmRhcnktY29sb3I6ICM3MzczNzM7ICAvKiBmb3Igc2Vjb25kYXJ5IHRleHQgYW5kIGljb25zICovXG4gICAgICAtLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yOiAjOWI5YjliOyAgLyogZGlzYWJsZWQvaGludCB0ZXh0ICovXG4gICAgICAtLWxpZ2h0LXRoZW1lLWRpdmlkZXItY29sb3I6ICNkYmRiZGI7XG5cbiAgICAgIC8qXG4gICAgICAgKiBNYXRlcmlhbCBEZXNpZ24gRGFyayBiYWNrZ3JvdW5kIHRoZW1lXG4gICAgICAgKi9cbiAgICAgIC0tZGFyay10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci1ncmV5LTkwMCk7XG4gICAgICAtLWRhcmstdGhlbWUtYmFzZS1jb2xvcjogI2ZmZmZmZjtcbiAgICAgIC0tZGFyay10aGVtZS10ZXh0LWNvbG9yOiAjZmZmZmZmO1xuICAgICAgLS1kYXJrLXRoZW1lLXNlY29uZGFyeS1jb2xvcjogI2JjYmNiYzsgIC8qIGZvciBzZWNvbmRhcnkgdGV4dCBhbmQgaWNvbnMgKi9cbiAgICAgIC0tZGFyay10aGVtZS1kaXNhYmxlZC1jb2xvcjogIzY0NjQ2NDsgIC8qIGRpc2FibGVkL2hpbnQgdGV4dCAqL1xuICAgICAgLS1kYXJrLXRoZW1lLWRpdmlkZXItY29sb3I6ICMzYzNjM2M7XG5cbiAgICAgIC8qXG4gICAgICAgKiBEZXByZWNhdGVkIHZhbHVlcyBiZWNhdXNlIG9mIHRoZWlyIGNvbmZ1c2luZyBuYW1lcy5cbiAgICAgICAqL1xuICAgICAgLS10ZXh0LXByaW1hcnktY29sb3I6IHZhcigtLWRhcmstdGhlbWUtdGV4dC1jb2xvcik7XG4gICAgICAtLWRlZmF1bHQtcHJpbWFyeS1jb2xvcjogdmFyKC0tcHJpbWFyeS1jb2xvcik7XG4gICAgfVxuICA8L3N0eWxlPlxuPC9jdXN0b20tc3R5bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8Y3VzdG9tLXN0eWxlPlxuICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICBodG1sIHtcblxuICAgICAgLS1sYXlvdXQ6IHtcbiAgICAgICAgZGlzcGxheTogLW1zLWZsZXhib3g7XG4gICAgICAgIGRpc3BsYXk6IC13ZWJraXQtZmxleDtcbiAgICAgICAgZGlzcGxheTogZmxleDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWlubGluZToge1xuICAgICAgICBkaXNwbGF5OiAtbXMtaW5saW5lLWZsZXhib3g7XG4gICAgICAgIGRpc3BsYXk6IC13ZWJraXQtaW5saW5lLWZsZXg7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1mbGV4O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtaG9yaXpvbnRhbDoge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQ7XG5cbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICAgIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWhvcml6b250YWwtcmV2ZXJzZToge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQ7XG5cbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcbiAgICAgICAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXZlcnRpY2FsOiB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dDtcblxuICAgICAgICAtbXMtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtdmVydGljYWwtcmV2ZXJzZToge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQ7XG5cbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW4tcmV2ZXJzZTtcbiAgICAgICAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogY29sdW1uLXJldmVyc2U7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW4tcmV2ZXJzZTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXdyYXA6IHtcbiAgICAgICAgLW1zLWZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgLXdlYmtpdC1mbGV4LXdyYXA6IHdyYXA7XG4gICAgICAgIGZsZXgtd3JhcDogd3JhcDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXdyYXAtcmV2ZXJzZToge1xuICAgICAgICAtbXMtZmxleC13cmFwOiB3cmFwLXJldmVyc2U7XG4gICAgICAgIC13ZWJraXQtZmxleC13cmFwOiB3cmFwLXJldmVyc2U7XG4gICAgICAgIGZsZXgtd3JhcDogd3JhcC1yZXZlcnNlO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC1hdXRvOiB7XG4gICAgICAgIC1tcy1mbGV4OiAxIDEgYXV0bztcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxIDEgYXV0bztcbiAgICAgICAgZmxleDogMSAxIGF1dG87XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LW5vbmU6IHtcbiAgICAgICAgLW1zLWZsZXg6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtZmxleDogbm9uZTtcbiAgICAgICAgZmxleDogbm9uZTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXg6IHtcbiAgICAgICAgLW1zLWZsZXg6IDEgMSAwLjAwMDAwMDAwMXB4O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDE7XG4gICAgICAgIGZsZXg6IDE7XG4gICAgICAgIC13ZWJraXQtZmxleC1iYXNpczogMC4wMDAwMDAwMDFweDtcbiAgICAgICAgZmxleC1iYXNpczogMC4wMDAwMDAwMDFweDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtMjoge1xuICAgICAgICAtbXMtZmxleDogMjtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAyO1xuICAgICAgICBmbGV4OiAyO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC0zOiB7XG4gICAgICAgIC1tcy1mbGV4OiAzO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDM7XG4gICAgICAgIGZsZXg6IDM7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTQ6IHtcbiAgICAgICAgLW1zLWZsZXg6IDQ7XG4gICAgICAgIC13ZWJraXQtZmxleDogNDtcbiAgICAgICAgZmxleDogNDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtNToge1xuICAgICAgICAtbXMtZmxleDogNTtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA1O1xuICAgICAgICBmbGV4OiA1O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC02OiB7XG4gICAgICAgIC1tcy1mbGV4OiA2O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDY7XG4gICAgICAgIGZsZXg6IDY7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTc6IHtcbiAgICAgICAgLW1zLWZsZXg6IDc7XG4gICAgICAgIC13ZWJraXQtZmxleDogNztcbiAgICAgICAgZmxleDogNztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtODoge1xuICAgICAgICAtbXMtZmxleDogODtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA4O1xuICAgICAgICBmbGV4OiA4O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC05OiB7XG4gICAgICAgIC1tcy1mbGV4OiA5O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDk7XG4gICAgICAgIGZsZXg6IDk7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTEwOiB7XG4gICAgICAgIC1tcy1mbGV4OiAxMDtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxMDtcbiAgICAgICAgZmxleDogMTA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTExOiB7XG4gICAgICAgIC1tcy1mbGV4OiAxMTtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxMTtcbiAgICAgICAgZmxleDogMTE7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTEyOiB7XG4gICAgICAgIC1tcy1mbGV4OiAxMjtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxMjtcbiAgICAgICAgZmxleDogMTI7XG4gICAgICB9O1xuXG4gICAgICAvKiBhbGlnbm1lbnQgaW4gY3Jvc3MgYXhpcyAqL1xuXG4gICAgICAtLWxheW91dC1zdGFydDoge1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogc3RhcnQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtY2VudGVyOiB7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBjZW50ZXI7XG4gICAgICAgIC13ZWJraXQtYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24taXRlbXM6IGNlbnRlcjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWVuZDoge1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogZW5kO1xuICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtYmFzZWxpbmU6IHtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGJhc2VsaW5lO1xuICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBiYXNlbGluZTtcbiAgICAgICAgYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xuICAgICAgfTtcblxuICAgICAgLyogYWxpZ25tZW50IGluIG1haW4gYXhpcyAqL1xuXG4gICAgICAtLWxheW91dC1zdGFydC1qdXN0aWZpZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogc3RhcnQ7XG4gICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1jZW50ZXItanVzdGlmaWVkOiB7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGNlbnRlcjtcbiAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1lbmQtanVzdGlmaWVkOiB7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGVuZDtcbiAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtYXJvdW5kLWp1c3RpZmllZDoge1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBkaXN0cmlidXRlO1xuICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWp1c3RpZmllZDoge1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBqdXN0aWZ5O1xuICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtY2VudGVyLWNlbnRlcjoge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyLWp1c3RpZmllZDtcbiAgICAgIH07XG5cbiAgICAgIC8qIHNlbGYgYWxpZ25tZW50ICovXG5cbiAgICAgIC0tbGF5b3V0LXNlbGYtc3RhcnQ6IHtcbiAgICAgICAgLW1zLWFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgICAgICAgYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXNlbGYtY2VudGVyOiB7XG4gICAgICAgIC1tcy1hbGlnbi1zZWxmOiBjZW50ZXI7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tc2VsZjogY2VudGVyO1xuICAgICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1zZWxmLWVuZDoge1xuICAgICAgICAtbXMtYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gICAgICAgIGFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtc2VsZi1zdHJldGNoOiB7XG4gICAgICAgIC1tcy1hbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICAtd2Via2l0LWFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIGFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1zZWxmLWJhc2VsaW5lOiB7XG4gICAgICAgIC1tcy1hbGlnbi1zZWxmOiBiYXNlbGluZTtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBiYXNlbGluZTtcbiAgICAgICAgYWxpZ24tc2VsZjogYmFzZWxpbmU7XG4gICAgICB9O1xuXG4gICAgICAvKiBtdWx0aS1saW5lIGFsaWdubWVudCBpbiBtYWluIGF4aXMgKi9cblxuICAgICAgLS1sYXlvdXQtc3RhcnQtYWxpZ25lZDoge1xuICAgICAgICAtbXMtZmxleC1saW5lLXBhY2s6IHN0YXJ0OyAgLyogSUUxMCAqL1xuICAgICAgICAtbXMtYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICBhbGlnbi1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZW5kLWFsaWduZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtbGluZS1wYWNrOiBlbmQ7ICAvKiBJRTEwICovXG4gICAgICAgIC1tcy1hbGlnbi1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgICAgYWxpZ24tY29udGVudDogZmxleC1lbmQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1jZW50ZXItYWxpZ25lZDoge1xuICAgICAgICAtbXMtZmxleC1saW5lLXBhY2s6IGNlbnRlcjsgIC8qIElFMTAgKi9cbiAgICAgICAgLW1zLWFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWJldHdlZW4tYWxpZ25lZDoge1xuICAgICAgICAtbXMtZmxleC1saW5lLXBhY2s6IGp1c3RpZnk7ICAvKiBJRTEwICovXG4gICAgICAgIC1tcy1hbGlnbi1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICAtd2Via2l0LWFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1hcm91bmQtYWxpZ25lZDoge1xuICAgICAgICAtbXMtZmxleC1saW5lLXBhY2s6IGRpc3RyaWJ1dGU7ICAvKiBJRTEwICovXG4gICAgICAgIC1tcy1hbGlnbi1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgICBhbGlnbi1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICB9O1xuXG4gICAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAgICAgICAgICAgIE90aGVyIExheW91dFxuICAgICAgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cblxuICAgICAgLS1sYXlvdXQtYmxvY2s6IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1pbnZpc2libGU6IHtcbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuICFpbXBvcnRhbnQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1yZWxhdGl2ZToge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1maXQ6IHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1zY3JvbGw6IHtcbiAgICAgICAgLXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6IHRvdWNoO1xuICAgICAgICBvdmVyZmxvdzogYXV0bztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZ1bGxibGVlZDoge1xuICAgICAgICBtYXJnaW46IDA7XG4gICAgICAgIGhlaWdodDogMTAwdmg7XG4gICAgICB9O1xuXG4gICAgICAvKiBmaXhlZCBwb3NpdGlvbiAqL1xuXG4gICAgICAtLWxheW91dC1maXhlZC10b3A6IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZml4ZWQtcmlnaHQ6IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1maXhlZC1ib3R0b206IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZml4ZWQtbGVmdDoge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgfTtcblxuICAgIH1cbiAgPC9zdHlsZT5cbjwvY3VzdG9tLXN0eWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuaW1wb3J0IHsgcGF0aEZyb21VcmwgfSBmcm9tICcuL3Jlc29sdmUtdXJsLmpzJztcblxuLyoqXG4gKiBMZWdhY3kgc2V0dGluZ3MuXG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICovXG5jb25zdCBzZXR0aW5ncyA9IHVuZGVmaW5lZCB8fCB7fTtcbmV4cG9ydCBjb25zdCB1c2VTaGFkb3cgPSAhKHdpbmRvdy5TaGFkeURPTSk7XG5leHBvcnQgY29uc3QgdXNlTmF0aXZlQ1NTUHJvcGVydGllcyA9IEJvb2xlYW4oIXdpbmRvdy5TaGFkeUNTUyB8fCB3aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzKTtcbmV4cG9ydCBjb25zdCB1c2VOYXRpdmVDdXN0b21FbGVtZW50cyA9ICEod2luZG93LmN1c3RvbUVsZW1lbnRzLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2spO1xuZXhwb3J0IHsgc2V0dGluZ3MgYXMgU2V0dGluZ3MgfTtcblxuLyoqXG4gKiBHbG9iYWxseSBzZXR0YWJsZSBwcm9wZXJ0eSB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG9cbiAqIGBQb2x5bWVyLkVsZW1lbnRNaXhpbmAgaW5zdGFuY2VzLCB1c2VmdWwgZm9yIGJpbmRpbmcgaW4gdGVtcGxhdGVzIHRvXG4gKiBtYWtlIFVSTCdzIHJlbGF0aXZlIHRvIGFuIGFwcGxpY2F0aW9uJ3Mgcm9vdC4gIERlZmF1bHRzIHRvIHRoZSBtYWluXG4gKiBkb2N1bWVudCBVUkwsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB1c2Vycy4gIEl0IG1heSBiZSB1c2VmdWwgdG8gc2V0XG4gKiBgUG9seW1lci5yb290UGF0aGAgdG8gcHJvdmlkZSBhIHN0YWJsZSBhcHBsaWNhdGlvbiBtb3VudCBwYXRoIHdoZW5cbiAqIHVzaW5nIGNsaWVudCBzaWRlIHJvdXRpbmcuXG4gKlxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xubGV0IHJvb3RQYXRoID0gdW5kZWZpbmVkIHx8XG4gIHBhdGhGcm9tVXJsKGRvY3VtZW50LmJhc2VVUkkgfHwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG5leHBvcnQgeyByb290UGF0aCB9O1xuXG5leHBvcnQgY29uc3Qgc2V0Um9vdFBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJvb3RQYXRoID0gcGF0aDtcbn07XG5cbi8qKlxuICogQSBnbG9iYWwgY2FsbGJhY2sgdXNlZCB0byBzYW5pdGl6ZSBhbnkgdmFsdWUgYmVmb3JlIGluc2VydGluZyBpdCBpbnRvIHRoZSBET00uIFRoZSBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4gKlxuICogICAgIFBvbHltZXIgPSB7XG4gKiAgICAgICBzYW5pdGl6ZURPTVZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgbmFtZSwgdHlwZSwgbm9kZSkgeyAuLi4gfVxuICogICAgIH1cbiAqXG4gKiBXaGVyZTpcbiAqXG4gKiBgdmFsdWVgIGlzIHRoZSB2YWx1ZSB0byBzYW5pdGl6ZS5cbiAqIGBuYW1lYCBpcyB0aGUgbmFtZSBvZiBhbiBhdHRyaWJ1dGUgb3IgcHJvcGVydHkgKGZvciBleGFtcGxlLCBocmVmKS5cbiAqIGB0eXBlYCBpbmRpY2F0ZXMgd2hlcmUgdGhlIHZhbHVlIGlzIGJlaW5nIGluc2VydGVkOiBvbmUgb2YgcHJvcGVydHksIGF0dHJpYnV0ZSwgb3IgdGV4dC5cbiAqIGBub2RlYCBpcyB0aGUgbm9kZSB3aGVyZSB0aGUgdmFsdWUgaXMgYmVpbmcgaW5zZXJ0ZWQuXG4gKlxuICogQHR5cGUgeyhmdW5jdGlvbigqLHN0cmluZyxzdHJpbmcsTm9kZSk6Kil8dW5kZWZpbmVkfVxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xubGV0IHNhbml0aXplRE9NVmFsdWUgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCB7IHNhbml0aXplRE9NVmFsdWUgfTtcblxuZXhwb3J0IGNvbnN0IHNldFNhbml0aXplRE9NVmFsdWUgPSBmdW5jdGlvbihuZXdTYW5pdGl6ZURPTVZhbHVlKSB7XG4gIHNhbml0aXplRE9NVmFsdWUgPSBuZXdTYW5pdGl6ZURPTVZhbHVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBDU1NfVVJMX1JYID0gLyh1cmxcXCgpKFteKV0qKShcXCkpL2c7XG5sZXQgQUJTX1VSTCA9IC8oXlxcLyl8KF4jKXwoXltcXHctXFxkXSo6KS87XG5sZXQgd29ya2luZ1VSTDtcbmxldCByZXNvbHZlRG9jO1xuLyoqXG4gKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gVVJMIGFnYWluc3QgdGhlIHByb3ZpZGVkIGBiYXNlVXJpJy5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byByZXNvbHZlXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIFVSTFxuICovXG5mdW5jdGlvbiByZXNvbHZlVXJsKHVybCwgYmFzZVVSSSkge1xuICBpZiAodXJsICYmIEFCU19VUkwudGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICAvLyBMYXp5IGZlYXR1cmUgZGV0ZWN0aW9uLlxuICBpZiAod29ya2luZ1VSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgd29ya2luZ1VSTCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1ID0gbmV3IFVSTCgnYicsICdodHRwOi8vYScpO1xuICAgICAgdS5wYXRobmFtZSA9ICdjJTIwZCc7XG4gICAgICB3b3JraW5nVVJMID0gKHUuaHJlZiA9PT0gJ2h0dHA6Ly9hL2MlMjBkJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgZmFpbFxuICAgIH1cbiAgfVxuICBpZiAoIWJhc2VVUkkpIHtcbiAgICBiYXNlVVJJID0gZG9jdW1lbnQuYmFzZVVSSSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgfVxuICBpZiAod29ya2luZ1VSTCkge1xuICAgIHJldHVybiAobmV3IFVSTCh1cmwsIGJhc2VVUkkpKS5ocmVmO1xuICB9XG4gIC8vIEZhbGxiYWNrIHRvIGNyZWF0aW5nIGFuIGFuY2hvciBpbnRvIGEgZGlzY29ubmVjdGVkIGRvY3VtZW50LlxuICBpZiAoIXJlc29sdmVEb2MpIHtcbiAgICByZXNvbHZlRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCd0ZW1wJyk7XG4gICAgcmVzb2x2ZURvYy5iYXNlID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgcmVzb2x2ZURvYy5oZWFkLmFwcGVuZENoaWxkKHJlc29sdmVEb2MuYmFzZSk7XG4gICAgcmVzb2x2ZURvYy5hbmNob3IgPSByZXNvbHZlRG9jLmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICByZXNvbHZlRG9jLmJvZHkuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5hbmNob3IpO1xuICB9XG4gIHJlc29sdmVEb2MuYmFzZS5ocmVmID0gYmFzZVVSSTtcbiAgcmVzb2x2ZURvYy5hbmNob3IuaHJlZiA9IHVybDtcbiAgcmV0dXJuIHJlc29sdmVEb2MuYW5jaG9yLmhyZWYgfHwgdXJsO1xuXG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYW55IHJlbGF0aXZlIFVSTCdzIGluIHRoZSBnaXZlbiBDU1MgdGV4dCBhZ2FpbnN0IHRoZSBwcm92aWRlZFxuICogYG93bmVyRG9jdW1lbnRgJ3MgYGJhc2VVUklgLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0IENTUyB0ZXh0IHRvIHByb2Nlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFByb2Nlc3NlZCBDU1MgdGV4dCB3aXRoIHJlc29sdmVkIFVSTCdzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDc3MoY3NzVGV4dCwgYmFzZVVSSSkge1xuICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKENTU19VUkxfUlgsIGZ1bmN0aW9uKG0sIHByZSwgdXJsLCBwb3N0KSB7XG4gICAgcmV0dXJuIHByZSArICdcXCcnICtcbiAgICAgIHJlc29sdmVVcmwodXJsLnJlcGxhY2UoL1tcIiddL2csICcnKSwgYmFzZVVSSSkgK1xuICAgICAgJ1xcJycgKyBwb3N0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCBmcm9tIGEgZ2l2ZW4gYHVybGAuIFRoZSBwYXRoIGluY2x1ZGVzIHRoZSB0cmFpbGluZ1xuICogYC9gIGZyb20gdGhlIHVybC5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm4ge3N0cmluZ30gcmVzb2x2ZWQgcGF0aFxuICovXG5mdW5jdGlvbiBwYXRoRnJvbVVybCh1cmwpIHtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUNzcyB9O1xuZXhwb3J0IHsgcmVzb2x2ZVVybCB9O1xuZXhwb3J0IHsgcGF0aEZyb21VcmwgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3Jlc29sdmUtdXJsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5pbmRleE9mKCcuJykgPj0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvb3QocGF0aCkge1xuICBsZXQgZG90SW5kZXggPSBwYXRoLmluZGV4T2YoJy4nKTtcbiAgaWYgKGRvdEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGRvdEluZGV4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQW5jZXN0b3IoYmFzZSwgcGF0aCkge1xuICAvLyAgICAgYmFzZS5zdGFydHNXaXRoKHBhdGggKyAnLicpO1xuICByZXR1cm4gYmFzZS5pbmRleE9mKHBhdGggKyAnLicpID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpIHtcbiAgLy8gICAgIHBhdGguc3RhcnRzV2l0aChiYXNlICsgJy4nKTtcbiAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlICsgJy4nKSA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShiYXNlLCBuZXdCYXNlLCBwYXRoKSB7XG4gIHJldHVybiBuZXdCYXNlICsgcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzKGJhc2UsIHBhdGgpIHtcbiAgcmV0dXJuIChiYXNlID09PSBwYXRoKSB8fFxuICAgICAgICAgaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB8fFxuICAgICAgICAgaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8cGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGFyZ3MgPSBwYXRoW2ldLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgIGZvciAobGV0IGo9MDsgajxhcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXJnc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0KHBhdGgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHBhdGgpLnNwbGl0KCcuJyk7XG4gIH1cbiAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHJvb3QsIHBhdGgsIGluZm8pIHtcbiAgbGV0IHByb3AgPSByb290O1xuICBsZXQgcGFydHMgPSBzcGxpdChwYXRoKTtcbiAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0xXSBhbmQgZGVyZWZlcmVuY2VcbiAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgcHJvcCA9IHByb3BbcGFydF07XG4gIH1cbiAgaWYgKGluZm8pIHtcbiAgICBpbmZvLnBhdGggPSBwYXJ0cy5qb2luKCcuJyk7XG4gIH1cbiAgcmV0dXJuIHByb3A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQocm9vdCwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IHByb3AgPSByb290O1xuICBsZXQgcGFydHMgPSBzcGxpdChwYXRoKTtcbiAgbGV0IGxhc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGgtMV07XG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0yXSBhbmQgZGVyZWZlcmVuY2VcbiAgICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIHByb3AgPSBwcm9wW3BhcnRdO1xuICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU2V0IHZhbHVlIHRvIG9iamVjdCBhdCBlbmQgb2YgcGF0aFxuICAgIHByb3BbbGFzdF0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTaW1wbGUgcHJvcGVydHkgc2V0XG4gICAgcHJvcFtwYXRoXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG59XG5cbmV4cG9ydCBjb25zdCBpc0RlZXAgPSBpc1BhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9wYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5pbXBvcnQgeyB0aW1lT3V0IH0gZnJvbSAnLi9hc3luYy5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuL2RlYm91bmNlLmpzJztcblxuLy8gZGV0ZWN0IG5hdGl2ZSB0b3VjaCBhY3Rpb24gc3VwcG9ydFxubGV0IEhBU19OQVRJVkVfVEEgPSB0eXBlb2YgZG9jdW1lbnQuaGVhZC5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ3N0cmluZyc7XG5sZXQgR0VTVFVSRV9LRVkgPSAnX19wb2x5bWVyR2VzdHVyZXMnO1xubGV0IEhBTkRMRURfT0JKID0gJ19fcG9seW1lckdlc3R1cmVzSGFuZGxlZCc7XG5sZXQgVE9VQ0hfQUNUSU9OID0gJ19fcG9seW1lckdlc3R1cmVzVG91Y2hBY3Rpb24nO1xuLy8gcmFkaXVzIGZvciB0YXAgYW5kIHRyYWNrXG5sZXQgVEFQX0RJU1RBTkNFID0gMjU7XG5sZXQgVFJBQ0tfRElTVEFOQ0UgPSA1O1xuLy8gbnVtYmVyIG9mIGxhc3QgTiB0cmFjayBwb3NpdGlvbnMgdG8ga2VlcFxubGV0IFRSQUNLX0xFTkdUSCA9IDI7XG5cbi8vIERpc2FibGluZyBcIm1vdXNlXCIgaGFuZGxlcnMgZm9yIDI1MDBtcyBpcyBlbm91Z2hcbmxldCBNT1VTRV9USU1FT1VUID0gMjUwMDtcbmxldCBNT1VTRV9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdjbGljayddO1xuLy8gYW4gYXJyYXkgb2YgYml0bWFzayB2YWx1ZXMgZm9yIG1hcHBpbmcgTW91c2VFdmVudC53aGljaCB0byBNb3VzZUV2ZW50LmJ1dHRvbnNcbmxldCBNT1VTRV9XSElDSF9UT19CVVRUT05TID0gWzAsIDEsIDQsIDJdO1xubGV0IE1PVVNFX0hBU19CVVRUT05TID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgTW91c2VFdmVudCgndGVzdCcsIHtidXR0b25zOiAxfSkuYnV0dG9ucyA9PT0gMTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyogZXNsaW50IG5vLWVtcHR5OiBbXCJlcnJvclwiLCB7IFwiYWxsb3dFbXB0eUNhdGNoXCI6IHRydWUgfV0gKi9cbi8vIGNoZWNrIGZvciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyc1xubGV0IFNVUFBPUlRTX1BBU1NJVkUgPSBmYWxzZTtcbihmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBsZXQgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7Z2V0OiBmdW5jdGlvbigpIHtTVVBQT1JUU19QQVNTSVZFID0gdHJ1ZTt9fSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoKGUpIHt9XG59KSgpO1xuXG4vLyBDaGVjayBmb3IgdG91Y2gtb25seSBkZXZpY2VzXG5sZXQgSVNfVE9VQ0hfT05MWSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQKD86W29hXWR8aG9uZSl8QW5kcm9pZC8pO1xuXG5sZXQgR2VzdHVyZVJlY29nbml6ZXIgPSBmdW5jdGlvbigpe307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7fTtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWR9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2Vkb3duO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNlbW92ZTtcbi8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZXVwO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoc3RhcnQ7XG4vKiogQHR5cGUgeyhmdW5jdGlvbihUb3VjaEV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2htb3ZlO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoZW5kO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLmNsaWNrO1xuXG4vLyB0b3VjaCB3aWxsIG1ha2Ugc3ludGhldGljIG1vdXNlIGV2ZW50c1xuLy8gYHByZXZlbnREZWZhdWx0YCBvbiB0b3VjaGVuZCB3aWxsIGNhbmNlbCB0aGVtLFxuLy8gYnV0IHRoaXMgYnJlYWtzIGA8aW5wdXQ+YCBmb2N1cyBhbmQgbGluayBjbGlja3Ncbi8vIGRpc2FibGUgbW91c2UgaGFuZGxlcnMgZm9yIE1PVVNFX1RJTUVPVVQgbXMgYWZ0ZXJcbi8vIGEgdG91Y2hlbmQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbmxldCBtb3VzZUNhbmNlbGxlciA9IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgLy8gQ2hlY2sgZm9yIHNvdXJjZUNhcGFiaWxpdGllcywgdXNlZCB0byBkaXN0aW5ndWlzaCBzeW50aGV0aWMgZXZlbnRzXG4gIC8vIGlmIG1vdXNlRXZlbnQgZGlkIG5vdCBjb21lIGZyb20gYSBkZXZpY2UgdGhhdCBmaXJlcyB0b3VjaCBldmVudHMsXG4gIC8vIGl0IHdhcyBtYWRlIGJ5IGEgcmVhbCBtb3VzZSBhbmQgc2hvdWxkIGJlIGNvdW50ZWRcbiAgLy8gaHR0cDovL3dpY2cuZ2l0aHViLmlvL0lucHV0RGV2aWNlQ2FwYWJpbGl0aWVzLyNkb20taW5wdXRkZXZpY2VjYXBhYmlsaXRpZXMtZmlyZXN0b3VjaGV2ZW50c1xuICBsZXQgc2MgPSBtb3VzZUV2ZW50LnNvdXJjZUNhcGFiaWxpdGllcztcbiAgaWYgKHNjICYmICFzYy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNraXAgc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICBtb3VzZUV2ZW50W0hBTkRMRURfT0JKXSA9IHtza2lwOiB0cnVlfTtcbiAgLy8gZGlzYWJsZSBcImdob3N0IGNsaWNrc1wiXG4gIGlmIChtb3VzZUV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICBsZXQgcGF0aCA9IG1vdXNlRXZlbnQuY29tcG9zZWRQYXRoICYmIG1vdXNlRXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aFtpXSA9PT0gUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtb3VzZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbW91c2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXR1cCBUcnVlIHRvIGFkZCwgZmFsc2UgdG8gcmVtb3ZlLlxuICovXG5mdW5jdGlvbiBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIoc2V0dXApIHtcbiAgbGV0IGV2ZW50cyA9IElTX1RPVUNIX09OTFkgPyBbJ2NsaWNrJ10gOiBNT1VTRV9FVkVOVFM7XG4gIGZvciAobGV0IGkgPSAwLCBlbjsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGVuID0gZXZlbnRzW2ldO1xuICAgIGlmIChzZXR1cCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlbiwgbW91c2VDYW5jZWxsZXIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGVuLCBtb3VzZUNhbmNlbGxlciwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZU1vdXNlKGUpIHtcbiAgaWYgKCFQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IpIHtcbiAgICBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIodHJ1ZSk7XG4gIH1cbiAgbGV0IHVuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKCk7XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IG51bGw7XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iID0gbnVsbDtcbiAgfTtcbiAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYiA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iXG4gICAgICAsIHRpbWVPdXQuYWZ0ZXIoTU9VU0VfVElNRU9VVClcbiAgICAgICwgdW5zZXQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXYgZXZlbnQgdG8gdGVzdCBmb3IgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICogQHJldHVybiB7Ym9vbGVhbn0gaGFzIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAqL1xuZnVuY3Rpb24gaGFzTGVmdE1vdXNlQnV0dG9uKGV2KSB7XG4gIGxldCB0eXBlID0gZXYudHlwZTtcbiAgLy8gZXhpdCBlYXJseSBpZiB0aGUgZXZlbnQgaXMgbm90IGEgbW91c2UgZXZlbnRcbiAgaWYgKE1PVVNFX0VWRU5UUy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBldi5idXR0b24gaXMgbm90IHJlbGlhYmxlIGZvciBtb3VzZW1vdmUgKDAgaXMgb3ZlcmxvYWRlZCBhcyBib3RoIGxlZnQgYnV0dG9uIGFuZCBubyBidXR0b25zKVxuICAvLyBpbnN0ZWFkIHdlIHVzZSBldi5idXR0b25zIChiaXRtYXNrIG9mIGJ1dHRvbnMpIG9yIGZhbGwgYmFjayB0byBldi53aGljaCAoZGVwcmVjYXRlZCwgMCBmb3Igbm8gYnV0dG9ucywgMSBmb3IgbGVmdCBidXR0b24pXG4gIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICBsZXQgYnV0dG9ucyA9IGV2LmJ1dHRvbnMgPT09IHVuZGVmaW5lZCA/IDEgOiBldi5idXR0b25zO1xuICAgIGlmICgoZXYgaW5zdGFuY2VvZiB3aW5kb3cuTW91c2VFdmVudCkgJiYgIU1PVVNFX0hBU19CVVRUT05TKSB7XG4gICAgICBidXR0b25zID0gTU9VU0VfV0hJQ0hfVE9fQlVUVE9OU1tldi53aGljaF0gfHwgMDtcbiAgICB9XG4gICAgLy8gYnV0dG9ucyBpcyBhIGJpdG1hc2ssIGNoZWNrIHRoYXQgdGhlIGxlZnQgYnV0dG9uIGJpdCBpcyBzZXQgKDEpXG4gICAgcmV0dXJuIEJvb2xlYW4oYnV0dG9ucyAmIDEpO1xuICB9IGVsc2Uge1xuICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICBsZXQgYnV0dG9uID0gZXYuYnV0dG9uID09PSB1bmRlZmluZWQgPyAwIDogZXYuYnV0dG9uO1xuICAgIC8vIGV2LmJ1dHRvbiBpcyAwIGluIG1vdXNlZG93bi9tb3VzZXVwL2NsaWNrIGZvciBsZWZ0IGJ1dHRvbiBhY3RpdmF0aW9uXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0NsaWNrKGV2KSB7XG4gIGlmIChldi50eXBlID09PSAnY2xpY2snKSB7XG4gICAgLy8gZXYuZGV0YWlsIGlzIDAgZm9yIEhUTUxFbGVtZW50LmNsaWNrIGluIG1vc3QgYnJvd3NlcnNcbiAgICBpZiAoZXYuZGV0YWlsID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaW4gdGhlIHdvcnN0IGNhc2UsIGNoZWNrIHRoYXQgdGhlIHgveSBwb3NpdGlvbiBvZiB0aGUgY2xpY2sgaXMgd2l0aGluXG4gICAgLy8gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudFxuICAgIC8vIFRoYW5rcyBJRSAxMCA+OihcbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoZXYpO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudCBpcyBhbiBlbGVtZW50IHNvIHdlIGNhbiB1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0LFxuICAgIC8vIGlmIG5vdCwganVzdCBhc3N1bWUgaXQgaXMgYSBzeW50aGV0aWMgY2xpY2tcbiAgICBpZiAoIXQubm9kZVR5cGUgfHwgLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgYmNyID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyB1c2UgcGFnZSB4L3kgdG8gYWNjb3VudCBmb3Igc2Nyb2xsaW5nXG4gICAgbGV0IHggPSBldi5wYWdlWCwgeSA9IGV2LnBhZ2VZO1xuICAgIC8vIGV2IGlzIGEgc3ludGhldGljIGNsaWNrIGlmIHRoZSBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHRhcmdldFxuICAgIHJldHVybiAhKCh4ID49IGJjci5sZWZ0ICYmIHggPD0gYmNyLnJpZ2h0KSAmJiAoeSA+PSBiY3IudG9wICYmIHkgPD0gYmNyLmJvdHRvbSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubGV0IFBPSU5URVJTVEFURSA9IHtcbiAgbW91c2U6IHtcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgbW91c2VJZ25vcmVKb2I6IG51bGxcbiAgfSxcbiAgdG91Y2g6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgaWQ6IC0xLFxuICAgIHNjcm9sbERlY2lkZWQ6IGZhbHNlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpcnN0VG91Y2hBY3Rpb24oZXYpIHtcbiAgbGV0IHRhID0gJ2F1dG8nO1xuICBsZXQgcGF0aCA9IGV2LmNvbXBvc2VkUGF0aCAmJiBldi5jb21wb3NlZFBhdGgoKTtcbiAgaWYgKHBhdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbjsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gPSBwYXRoW2ldO1xuICAgICAgaWYgKG5bVE9VQ0hfQUNUSU9OXSkge1xuICAgICAgICB0YSA9IG5bVE9VQ0hfQUNUSU9OXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YTtcbn1cblxuZnVuY3Rpb24gdHJhY2tEb2N1bWVudChzdGF0ZU9iaiwgbW92ZWZuLCB1cGZuKSB7XG4gIHN0YXRlT2JqLm1vdmVmbiA9IG1vdmVmbjtcbiAgc3RhdGVPYmoudXBmbiA9IHVwZm47XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVmbik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB1cGZuKTtcbn1cblxuZnVuY3Rpb24gdW50cmFja0RvY3VtZW50KHN0YXRlT2JqKSB7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN0YXRlT2JqLm1vdmVmbik7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzdGF0ZU9iai51cGZuKTtcbiAgc3RhdGVPYmoubW92ZWZuID0gbnVsbDtcbiAgc3RhdGVPYmoudXBmbiA9IG51bGw7XG59XG5cbi8vIHVzZSBhIGRvY3VtZW50LXdpZGUgdG91Y2hlbmQgbGlzdGVuZXIgdG8gc3RhcnQgdGhlIGdob3N0LWNsaWNrIHByZXZlbnRpb24gbWVjaGFuaXNtXG4vLyBVc2UgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGlmIHN1cHBvcnRlZCwgdG8gbm90IGFmZmVjdCBzY3JvbGxpbmcgcGVyZm9ybWFuY2VcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaWdub3JlTW91c2UsIFNVUFBPUlRTX1BBU1NJVkUgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZSk7XG5cbmV4cG9ydCBjb25zdCBnZXN0dXJlcyA9IHt9O1xuZXhwb3J0IGNvbnN0IHJlY29nbml6ZXJzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWVwVGFyZ2V0RmluZCh4LCB5KSB7XG4gIGxldCBub2RlID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgbGV0IG5leHQgPSBub2RlO1xuICAvLyB0aGlzIGNvZGUgcGF0aCBpcyBvbmx5IHRha2VuIHdoZW4gbmF0aXZlIFNoYWRvd0RPTSBpcyB1c2VkXG4gIC8vIGlmIHRoZXJlIGlzIGEgc2hhZG93cm9vdCwgaXQgbWF5IGhhdmUgYSBub2RlIGF0IHgveVxuICAvLyBpZiB0aGVyZSBpcyBub3QgYSBzaGFkb3dyb290LCBleGl0IHRoZSBsb29wXG4gIHdoaWxlIChuZXh0ICYmIG5leHQuc2hhZG93Um9vdCAmJiAhd2luZG93LlNoYWR5RE9NKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgYSBub2RlIGF0IHgveSBpbiB0aGUgc2hhZG93cm9vdCwgbG9vayBkZWVwZXJcbiAgICBsZXQgb2xkTmV4dCA9IG5leHQ7XG4gICAgbmV4dCA9IG5leHQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIC8vIG9uIFNhZmFyaSwgZWxlbWVudEZyb21Qb2ludCBtYXkgcmV0dXJuIHRoZSBzaGFkb3dSb290IGhvc3RcbiAgICBpZiAob2xkTmV4dCA9PT0gbmV4dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmluZE9yaWdpbmFsVGFyZ2V0KGV2KSB7XG4gIC8vIHNoYWRvd2RvbVxuICBpZiAoZXYuY29tcG9zZWRQYXRoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7RXZlbnRUYXJnZXR9ICovKGV2LmNvbXBvc2VkUGF0aCgpWzBdKTtcbiAgfVxuICAvLyBzaGFkeWRvbVxuICByZXR1cm4gZXYudGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2hhbmRsZU5hdGl2ZShldikge1xuICBsZXQgaGFuZGxlZDtcbiAgbGV0IHR5cGUgPSBldi50eXBlO1xuICBsZXQgbm9kZSA9IGV2LmN1cnJlbnRUYXJnZXQ7XG4gIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gIGlmICghZ29iaikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZ3MgPSBnb2JqW3R5cGVdO1xuICBpZiAoIWdzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZXZbSEFORExFRF9PQkpdKSB7XG4gICAgZXZbSEFORExFRF9PQkpdID0ge307XG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgNSkgPT09ICd0b3VjaCcpIHtcbiAgICAgIGV2ID0gLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyhldik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgIGxldCB0ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIC8vIG9ubHkgaGFuZGxlIHRoZSBmaXJzdCBmaW5nZXJcbiAgICAgICAgaWYgKGV2LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLmlkID0gdC5pZGVudGlmaWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoUE9JTlRFUlNUQVRFLnRvdWNoLmlkICE9PSB0LmlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFIQVNfTkFUSVZFX1RBKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICBfaGFuZGxlVG91Y2hBY3Rpb24oZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZWQgPSBldltIQU5ETEVEX09CSl07XG4gIC8vIHVzZWQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgaWYgKGhhbmRsZWQuc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyByZXNldCByZWNvZ25pemVyIHN0YXRlXG4gIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgaWYgKGdzW3IubmFtZV0gJiYgIWhhbmRsZWRbci5uYW1lXSkge1xuICAgICAgaWYgKHIuZmxvdyAmJiByLmZsb3cuc3RhcnQuaW5kZXhPZihldi50eXBlKSA+IC0xICYmIHIucmVzZXQpIHtcbiAgICAgICAgci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBlbmZvcmNlIGdlc3R1cmUgcmVjb2duaXplciBvcmRlclxuICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgciA9IHJlY29nbml6ZXJzW2ldO1xuICAgIGlmIChnc1tyLm5hbWVdICYmICFoYW5kbGVkW3IubmFtZV0pIHtcbiAgICAgIGhhbmRsZWRbci5uYW1lXSA9IHRydWU7XG4gICAgICByW3R5cGVdKGV2KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9oYW5kbGVUb3VjaEFjdGlvbihldikge1xuICBsZXQgdCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdO1xuICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2gueCA9IHQuY2xpZW50WDtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2gueSA9IHQuY2xpZW50WTtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgaWYgKFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkID0gdHJ1ZTtcbiAgICBsZXQgdGEgPSBmaXJzdFRvdWNoQWN0aW9uKGV2KTtcbiAgICBsZXQgcHJldmVudCA9IGZhbHNlO1xuICAgIGxldCBkeCA9IE1hdGguYWJzKFBPSU5URVJTVEFURS50b3VjaC54IC0gdC5jbGllbnRYKTtcbiAgICBsZXQgZHkgPSBNYXRoLmFicyhQT0lOVEVSU1RBVEUudG91Y2gueSAtIHQuY2xpZW50WSk7XG4gICAgaWYgKCFldi5jYW5jZWxhYmxlKSB7XG4gICAgICAvLyBzY3JvbGxpbmcgaXMgaGFwcGVuaW5nXG4gICAgfSBlbHNlIGlmICh0YSA9PT0gJ25vbmUnKSB7XG4gICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXgnKSB7XG4gICAgICBwcmV2ZW50ID0gZHkgPiBkeDtcbiAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXknKSB7XG4gICAgICBwcmV2ZW50ID0gZHggPiBkeTtcbiAgICB9XG4gICAgaWYgKHByZXZlbnQpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZlbnQoJ3RyYWNrJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKGdlc3R1cmVzW2V2VHlwZV0pIHtcbiAgICBfYWRkKG5vZGUsIGV2VHlwZSwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGlmIChnZXN0dXJlc1tldlR5cGVdKSB7XG4gICAgX3JlbW92ZShub2RlLCBldlR5cGUsIGhhbmRsZXIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9hZGQobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGxldCByZWNvZ25pemVyID0gZ2VzdHVyZXNbZXZUeXBlXTtcbiAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICBpZiAoIWdvYmopIHtcbiAgICBub2RlW0dFU1RVUkVfS0VZXSA9IGdvYmogPSB7fTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgZGVwLCBnZDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXAgPSBkZXBzW2ldO1xuICAgIC8vIGRvbid0IGFkZCBtb3VzZSBoYW5kbGVycyBvbiBpT1MgYmVjYXVzZSB0aGV5IGNhdXNlIGdyYXkgc2VsZWN0aW9uIG92ZXJsYXlzXG4gICAgaWYgKElTX1RPVUNIX09OTFkgJiYgTU9VU0VfRVZFTlRTLmluZGV4T2YoZGVwKSA+IC0xICYmIGRlcCAhPT0gJ2NsaWNrJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGdkID0gZ29ialtkZXBdO1xuICAgIGlmICghZ2QpIHtcbiAgICAgIGdvYmpbZGVwXSA9IGdkID0ge19jb3VudDogMH07XG4gICAgfVxuICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihkZXAsIF9oYW5kbGVOYXRpdmUpO1xuICAgIH1cbiAgICBnZFtuYW1lXSA9IChnZFtuYW1lXSB8fCAwKSArIDE7XG4gICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAwKSArIDE7XG4gIH1cbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2VHlwZSwgaGFuZGxlcik7XG4gIGlmIChyZWNvZ25pemVyLnRvdWNoQWN0aW9uKSB7XG4gICAgc2V0VG91Y2hBY3Rpb24obm9kZSwgcmVjb2duaXplci50b3VjaEFjdGlvbik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZW1vdmUobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGxldCByZWNvZ25pemVyID0gZ2VzdHVyZXNbZXZUeXBlXTtcbiAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICBpZiAoZ29iaikge1xuICAgIGZvciAobGV0IGkgPSAwLCBkZXAsIGdkOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVwID0gZGVwc1tpXTtcbiAgICAgIGdkID0gZ29ialtkZXBdO1xuICAgICAgaWYgKGdkICYmIGdkW25hbWVdKSB7XG4gICAgICAgIGdkW25hbWVdID0gKGdkW25hbWVdIHx8IDEpIC0gMTtcbiAgICAgICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAxKSAtIDE7XG4gICAgICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZGVwLCBfaGFuZGxlTmF0aXZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZUeXBlLCBoYW5kbGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHJlY29nKSB7XG4gIHJlY29nbml6ZXJzLnB1c2gocmVjb2cpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29nLmVtaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZ2VzdHVyZXNbcmVjb2cuZW1pdHNbaV1dID0gcmVjb2c7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maW5kUmVjb2duaXplckJ5RXZlbnQoZXZOYW1lKSB7XG4gIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgZm9yIChsZXQgaiA9IDAsIG47IGogPCByLmVtaXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBuID0gci5lbWl0c1tqXTtcbiAgICAgIGlmIChuID09PSBldk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VG91Y2hBY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgaWYgKEhBU19OQVRJVkVfVEEpIHtcbiAgICBub2RlLnN0eWxlLnRvdWNoQWN0aW9uID0gdmFsdWU7XG4gIH1cbiAgbm9kZVtUT1VDSF9BQ1RJT05dID0gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmlyZSh0YXJnZXQsIHR5cGUsIGRldGFpbCkge1xuICBsZXQgZXYgPSBuZXcgRXZlbnQodHlwZSwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlLCBjb21wb3NlZDogdHJ1ZSB9KTtcbiAgZXYuZGV0YWlsID0gZGV0YWlsO1xuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG4gIC8vIGZvcndhcmQgYHByZXZlbnREZWZhdWx0YCBpbiBhIGNsZWFuIHdheVxuICBpZiAoZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIGxldCBwcmV2ZW50ZXIgPSBkZXRhaWwucHJldmVudGVyIHx8IGRldGFpbC5zb3VyY2VFdmVudDtcbiAgICBpZiAocHJldmVudGVyICYmIHByZXZlbnRlci5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgcHJldmVudGVyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50KGV2TmFtZSkge1xuICBsZXQgcmVjb2duaXplciA9IF9maW5kUmVjb2duaXplckJ5RXZlbnQoZXZOYW1lKTtcbiAgaWYgKHJlY29nbml6ZXIuaW5mbykge1xuICAgIHJlY29nbml6ZXIuaW5mby5wcmV2ZW50ID0gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRNb3VzZUNhbmNlbGxlcigpIHtcbiAgaWYgKFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYikge1xuICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYi5mbHVzaCgpO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG5cbnJlZ2lzdGVyKHtcbiAgbmFtZTogJ2Rvd251cCcsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnXSxcbiAgZmxvdzoge1xuICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgZW5kOiBbJ21vdXNldXAnLCAndG91Y2hlbmQnXVxuICB9LFxuICBlbWl0czogWydkb3duJywgJ3VwJ10sXG5cbiAgaW5mbzoge1xuICAgIG1vdmVmbjogbnVsbCxcbiAgICB1cGZuOiBudWxsXG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHVudHJhY2tEb2N1bWVudCh0aGlzLmluZm8pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHNlbGYuX2ZpcmUoJ3VwJywgdCwgZSk7XG4gICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZm4gPSBmdW5jdGlvbiB1cGZuKGUpIHtcbiAgICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgc2VsZi5fZmlyZSgndXAnLCB0LCBlKTtcbiAgICAgIH1cbiAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgIH07XG4gICAgdHJhY2tEb2N1bWVudCh0aGlzLmluZm8sIG1vdmVmbiwgdXBmbik7XG4gICAgdGhpcy5fZmlyZSgnZG93bicsIHQsIGUpO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLl9maXJlKCdkb3duJywgX2ZpbmRPcmlnaW5hbFRhcmdldChlKSwgZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLl9maXJlKCd1cCcsIF9maW5kT3JpZ2luYWxUYXJnZXQoZSksIGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXZlbnRlclxuICAgKi9cbiAgX2ZpcmU6IGZ1bmN0aW9uKHR5cGUsIHRhcmdldCwgZXZlbnQsIHByZXZlbnRlcikge1xuICAgIF9maXJlKHRhcmdldCwgdHlwZSwge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICBzb3VyY2VFdmVudDogZXZlbnQsXG4gICAgICBwcmV2ZW50ZXI6IHByZXZlbnRlcixcbiAgICAgIHByZXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHByZXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWdpc3Rlcih7XG4gIG5hbWU6ICd0cmFjaycsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ10sXG4gIGZsb3c6IHtcbiAgICBzdGFydDogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLFxuICAgIGVuZDogWydtb3VzZXVwJywgJ3RvdWNoZW5kJ11cbiAgfSxcbiAgZW1pdHM6IFsndHJhY2snXSxcblxuICBpbmZvOiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHN0YXRlOiAnc3RhcnQnLFxuICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuICAgIG1vdmVzOiBbXSxcbiAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgIGFkZE1vdmU6IGZ1bmN0aW9uKG1vdmUpIHtcbiAgICAgIGlmICh0aGlzLm1vdmVzLmxlbmd0aCA+IFRSQUNLX0xFTkdUSCkge1xuICAgICAgICB0aGlzLm1vdmVzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1vdmVzLnB1c2gobW92ZSk7XG4gICAgfSxcbiAgICBtb3ZlZm46IG51bGwsXG4gICAgdXBmbjogbnVsbCxcbiAgICBwcmV2ZW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluZm8uc3RhdGUgPSAnc3RhcnQnO1xuICAgIHRoaXMuaW5mby5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbmZvLm1vdmVzID0gW107XG4gICAgdGhpcy5pbmZvLnggPSAwO1xuICAgIHRoaXMuaW5mby55ID0gMDtcbiAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICAgIHVudHJhY2tEb2N1bWVudCh0aGlzLmluZm8pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNNb3ZlZEVub3VnaDogZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh0aGlzLmluZm8ucHJldmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgZHggPSBNYXRoLmFicyh0aGlzLmluZm8ueCAtIHgpO1xuICAgIGxldCBkeSA9IE1hdGguYWJzKHRoaXMuaW5mby55IC0geSk7XG4gICAgcmV0dXJuIChkeCA+PSBUUkFDS19ESVNUQU5DRSB8fCBkeSA+PSBUUkFDS19ESVNUQU5DRSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgIGxldCB4ID0gZS5jbGllbnRYLCB5ID0gZS5jbGllbnRZO1xuICAgICAgaWYgKHNlbGYuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgICAgLy8gZmlyc3QgbW92ZSBpcyAnc3RhcnQnLCBzdWJzZXF1ZW50IG1vdmVzIGFyZSAnbW92ZScsIG1vdXNldXAgaXMgJ2VuZCdcbiAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gc2VsZi5pbmZvLnN0YXJ0ZWQgPyAoZS50eXBlID09PSAnbW91c2V1cCcgPyAnZW5kJyA6ICd0cmFjaycpIDogJ3N0YXJ0JztcbiAgICAgICAgaWYgKHNlbGYuaW5mby5zdGF0ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIC8vIGlmIGFuZCBvbmx5IGlmIHRyYWNraW5nLCBhbHdheXMgcHJldmVudCB0YXBcbiAgICAgICAgICBwcmV2ZW50KCd0YXAnKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmluZm8uYWRkTW92ZSh7eDogeCwgeTogeX0pO1xuICAgICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICAgIC8vIGFsd2F5cyBfZmlyZSBcImVuZFwiXG4gICAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gJ2VuZCc7XG4gICAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fZmlyZSh0LCBlKTtcbiAgICAgICAgc2VsZi5pbmZvLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZm4gPSBmdW5jdGlvbiB1cGZuKGUpIHtcbiAgICAgIGlmIChzZWxmLmluZm8uc3RhcnRlZCkge1xuICAgICAgICBtb3ZlZm4oZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgdGVtcG9yYXJ5IGxpc3RlbmVyc1xuICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgfTtcbiAgICAvLyBhZGQgdGVtcG9yYXJ5IGRvY3VtZW50IGxpc3RlbmVycyBhcyBtb3VzZSByZXRhcmdldHNcbiAgICB0cmFja0RvY3VtZW50KHRoaXMuaW5mbywgbW92ZWZuLCB1cGZuKTtcbiAgICB0aGlzLmluZm8ueCA9IGUuY2xpZW50WDtcbiAgICB0aGlzLmluZm8ueSA9IGUuY2xpZW50WTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB0aGlzLmluZm8ueCA9IGN0LmNsaWVudFg7XG4gICAgdGhpcy5pbmZvLnkgPSBjdC5jbGllbnRZO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNobW92ZTogZnVuY3Rpb24oZSkge1xuICAgIGxldCB0ID0gX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIGxldCB4ID0gY3QuY2xpZW50WCwgeSA9IGN0LmNsaWVudFk7XG4gICAgaWYgKHRoaXMuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgIGlmICh0aGlzLmluZm8uc3RhdGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgLy8gaWYgYW5kIG9ubHkgaWYgdHJhY2tpbmcsIGFsd2F5cyBwcmV2ZW50IHRhcFxuICAgICAgICBwcmV2ZW50KCd0YXAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5mby5hZGRNb3ZlKHt4OiB4LCB5OiB5fSk7XG4gICAgICB0aGlzLl9maXJlKHQsIGN0KTtcbiAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICd0cmFjayc7XG4gICAgICB0aGlzLmluZm8uc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgLy8gb25seSB0cmFja2VuZCBpZiB0cmFjayB3YXMgc3RhcnRlZCBhbmQgbm90IGFib3J0ZWRcbiAgICBpZiAodGhpcy5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgIC8vIHJlc2V0IHN0YXJ0ZWQgc3RhdGUgb24gdXBcbiAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICdlbmQnO1xuICAgICAgdGhpcy5pbmZvLmFkZE1vdmUoe3g6IGN0LmNsaWVudFgsIHk6IGN0LmNsaWVudFl9KTtcbiAgICAgIHRoaXMuX2ZpcmUodCwgY3QsIGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2hcbiAgICovXG4gIF9maXJlOiBmdW5jdGlvbih0YXJnZXQsIHRvdWNoKSB7XG4gICAgbGV0IHNlY29uZGxhc3QgPSB0aGlzLmluZm8ubW92ZXNbdGhpcy5pbmZvLm1vdmVzLmxlbmd0aCAtIDJdO1xuICAgIGxldCBsYXN0bW92ZSA9IHRoaXMuaW5mby5tb3Zlc1t0aGlzLmluZm8ubW92ZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGR4ID0gbGFzdG1vdmUueCAtIHRoaXMuaW5mby54O1xuICAgIGxldCBkeSA9IGxhc3Rtb3ZlLnkgLSB0aGlzLmluZm8ueTtcbiAgICBsZXQgZGR4LCBkZHkgPSAwO1xuICAgIGlmIChzZWNvbmRsYXN0KSB7XG4gICAgICBkZHggPSBsYXN0bW92ZS54IC0gc2Vjb25kbGFzdC54O1xuICAgICAgZGR5ID0gbGFzdG1vdmUueSAtIHNlY29uZGxhc3QueTtcbiAgICB9XG4gICAgX2ZpcmUodGFyZ2V0LCAndHJhY2snLCB7XG4gICAgICBzdGF0ZTogdGhpcy5pbmZvLnN0YXRlLFxuICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgIHk6IHRvdWNoLmNsaWVudFksXG4gICAgICBkeDogZHgsXG4gICAgICBkeTogZHksXG4gICAgICBkZHg6IGRkeCxcbiAgICAgIGRkeTogZGR5LFxuICAgICAgc291cmNlRXZlbnQ6IHRvdWNoLFxuICAgICAgaG92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVlcFRhcmdldEZpbmQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbnJlZ2lzdGVyKHtcbiAgbmFtZTogJ3RhcCcsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ2NsaWNrJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnXSxcbiAgZmxvdzoge1xuICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgZW5kOiBbJ2NsaWNrJywgJ3RvdWNoZW5kJ11cbiAgfSxcbiAgZW1pdHM6IFsndGFwJ10sXG4gIGluZm86IHtcbiAgICB4OiBOYU4sXG4gICAgeTogTmFOLFxuICAgIHByZXZlbnQ6IGZhbHNlXG4gIH0sXG4gIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluZm8ueCA9IE5hTjtcbiAgICB0aGlzLmluZm8ueSA9IE5hTjtcbiAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICB9LFxuICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICBzYXZlOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5pbmZvLnggPSBlLmNsaWVudFg7XG4gICAgdGhpcy5pbmZvLnkgPSBlLmNsaWVudFk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgdGhpcy5zYXZlKGUpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAqL1xuICBjbGljazogZnVuY3Rpb24oZSkge1xuICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHRoaXMuZm9yd2FyZChlKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuc2F2ZShlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaGVuZDogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuZm9yd2FyZChlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtFdmVudCB8IFRvdWNofSBlXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBwcmV2ZW50ZXJcbiAgICovXG4gIGZvcndhcmQ6IGZ1bmN0aW9uKGUsIHByZXZlbnRlcikge1xuICAgIGxldCBkeCA9IE1hdGguYWJzKGUuY2xpZW50WCAtIHRoaXMuaW5mby54KTtcbiAgICBsZXQgZHkgPSBNYXRoLmFicyhlLmNsaWVudFkgLSB0aGlzLmluZm8ueSk7XG4gICAgLy8gZmluZCBvcmlnaW5hbCB0YXJnZXQgZnJvbSBgcHJldmVudGVyYCBmb3IgVG91Y2hFdmVudHMsIG9yIGBlYCBmb3IgTW91c2VFdmVudHNcbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoKHByZXZlbnRlciB8fCBlKSk7XG4gICAgLy8gZHgsZHkgY2FuIGJlIE5hTiBpZiBgY2xpY2tgIGhhcyBiZWVuIHNpbXVsYXRlZCBhbmQgdGhlcmUgd2FzIG5vIGBkb3duYCBmb3IgYHN0YXJ0YFxuICAgIGlmIChpc05hTihkeCkgfHwgaXNOYU4oZHkpIHx8IChkeCA8PSBUQVBfRElTVEFOQ0UgJiYgZHkgPD0gVEFQX0RJU1RBTkNFKSB8fCBpc1N5bnRoZXRpY0NsaWNrKGUpKSB7XG4gICAgICAvLyBwcmV2ZW50IHRhcHMgZnJvbSBiZWluZyBnZW5lcmF0ZWQgaWYgYW4gZXZlbnQgaGFzIGNhbmNlbGVkIHRoZW1cbiAgICAgIGlmICghdGhpcy5pbmZvLnByZXZlbnQpIHtcbiAgICAgICAgX2ZpcmUodCwgJ3RhcCcsIHtcbiAgICAgICAgICB4OiBlLmNsaWVudFgsXG4gICAgICAgICAgeTogZS5jbGllbnRZLFxuICAgICAgICAgIHNvdXJjZUV2ZW50OiBlLFxuICAgICAgICAgIHByZXZlbnRlcjogcHJldmVudGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBjb25zdCBmaW5kT3JpZ2luYWxUYXJnZXQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0O1xuZXhwb3J0IGNvbnN0IGFkZCA9IGFkZExpc3RlbmVyO1xuZXhwb3J0IGNvbnN0IHJlbW92ZSA9IHJlbW92ZUxpc3RlbmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCAnLi9taXhpbi5qcyc7XG5pbXBvcnQgJy4vYXN5bmMuanMnO1xuXG4vKiogQHR5cGVkZWYge3tydW46IGZ1bmN0aW9uKGZ1bmN0aW9uKCksIG51bWJlcj0pOm51bWJlciwgY2FuY2VsOiBmdW5jdGlvbihudW1iZXIpfX0gKi9cbmxldCBBc3luY01vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKipcbiAqIEBzdW1tYXJ5IENvbGxhcHNlIG11bHRpcGxlIGNhbGxiYWNrcyBpbnRvIG9uZSBpbnZvY2F0aW9uIGFmdGVyIGEgdGltZXIuXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICovXG5jbGFzcyBEZWJvdW5jZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9hc3luY01vZHVsZSA9IG51bGw7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2NoZWR1bGVyOyB0aGF0IGlzLCBhIG1vZHVsZSB3aXRoIHRoZSBBc3luYyBpbnRlcmZhY2UsXG4gICAqIGEgY2FsbGJhY2sgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIHJ1biBmdW5jdGlvblxuICAgKiBmcm9tIHRoZSBhc3luYyBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IUFzeW5jTW9kdWxlfSBhc3luY01vZHVsZSBPYmplY3Qgd2l0aCBBc3luYyBpbnRlcmZhY2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuLlxuICAgKi9cbiAgc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FzeW5jTW9kdWxlID0gYXN5bmNNb2R1bGU7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLl90aW1lciA9IHRoaXMuX2FzeW5jTW9kdWxlLnJ1bigoKSA9PiB7XG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICB0aGlzLl9jYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLlxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuX2FzeW5jTW9kdWxlLmNhbmNlbCh0aGlzLl90aW1lcik7XG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGbHVzaGVzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLlxuICAgKi9cbiAgZmx1c2goKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgIHRoaXMuX2NhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRlYm91bmNlciBpcyBhY3RpdmUuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWN0aXZlLlxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVyICE9IG51bGw7XG4gIH1cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlciBpZiBubyBkZWJvdW5jZXIgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gKiBvciBpdCBjYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgb3RoZXJ3aXNlLiBUaGUgZm9sbG93aW5nXG4gKiBleGFtcGxlIHNob3dzIGhvdyBhIGRlYm91bmNlciBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiBhXG4gKiBtaWNyb3Rhc2sgYW5kIFwiZGVib3VuY2VkXCIgc3VjaCB0aGF0IHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBpc1xuICogY2FsbGVkIG9uY2UuIEFkZCB0aGlzIG1ldGhvZCB0byBhIGN1c3RvbSBlbGVtZW50OlxuICpcbiAqIF9kZWJvdW5jZVdvcmsoKSB7XG4gKiAgIHRoaXMuX2RlYm91bmNlSm9iID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UodGhpcy5fZGVib3VuY2VKb2IsXG4gKiAgICAgICBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzaywgKCkgPT4ge1xuICogICAgIHRoaXMuX2RvV29yaygpO1xuICogICB9KTtcbiAqIH1cbiAqXG4gKiBJZiB0aGUgYF9kZWJvdW5jZVdvcmtgIG1ldGhvZCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aGluIHRoZSBzYW1lXG4gKiBtaWNyb3Rhc2ssIHRoZSBgX2RvV29ya2AgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIGF0IHRoZSBuZXh0XG4gKiBtaWNyb3Rhc2sgY2hlY2twb2ludC5cbiAqXG4gKiBOb3RlOiBJbiB0ZXN0aW5nIGl0IGlzIG9mdGVuIGNvbnZlbmllbnQgdG8gYXZvaWQgYXN5bmNocm9ueS4gVG8gYWNjb21wbGlzaFxuICogdGhpcyB3aXRoIGEgZGVib3VuY2VyLCB5b3UgY2FuIHVzZSBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyYCBhbmRcbiAqIGBQb2x5bWVyLmZsdXNoYC4gRm9yIGV4YW1wbGUsIGV4dGVuZCB0aGUgYWJvdmUgZXhhbXBsZSBieSBhZGRpbmdcbiAqIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIodGhpcy5fZGVib3VuY2VKb2IpYCBhdCB0aGUgZW5kIG9mIHRoZVxuICogYF9kZWJvdW5jZVdvcmtgIG1ldGhvZC4gVGhlbiBpbiBhIHRlc3QsIGNhbGwgYFBvbHltZXIuZmx1c2hgIHRvIGVuc3VyZVxuICogdGhlIGRlYm91bmNlciBoYXMgY29tcGxldGVkLlxuICpcbiAqIEBwYXJhbSB7RGVib3VuY2VyP30gZGVib3VuY2VyIERlYm91bmNlciBvYmplY3QuXG4gKiBAcGFyYW0geyFBc3luY01vZHVsZX0gYXN5bmNNb2R1bGUgT2JqZWN0IHdpdGggQXN5bmMgaW50ZXJmYWNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAqIEByZXR1cm4geyFEZWJvdW5jZXJ9IFJldHVybnMgYSBkZWJvdW5jZXIgb2JqZWN0LlxuICovXG4gIHN0YXRpYyBkZWJvdW5jZShkZWJvdW5jZXIsIGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgIGlmIChkZWJvdW5jZXIgaW5zdGFuY2VvZiBEZWJvdW5jZXIpIHtcbiAgICAgIGRlYm91bmNlci5jYW5jZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVib3VuY2VyID0gbmV3IERlYm91bmNlcigpO1xuICAgIH1cbiAgICBkZWJvdW5jZXIuc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIGRlYm91bmNlcjtcbiAgfVxufVxuXG5leHBvcnQgeyBEZWJvdW5jZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuXG4vLyBDb21tb24gaW1wbGVtZW50YXRpb24gZm9yIG1peGluICYgYmVoYXZpb3JcbmZ1bmN0aW9uIG11dGFibGVQcm9wZXJ0eUNoYW5nZShpbnN0LCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgbXV0YWJsZURhdGEpIHtcbiAgbGV0IGlzT2JqZWN0O1xuICBpZiAobXV0YWJsZURhdGEpIHtcbiAgICBpc09iamVjdCA9ICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKTtcbiAgICAvLyBQdWxsIGBvbGRgIGZvciBPYmplY3RzIGZyb20gdGVtcCBjYWNoZSwgYnV0IHRyZWF0IGBudWxsYCBhcyBhIHByaW1pdGl2ZVxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgb2xkID0gaW5zdC5fX2RhdGFUZW1wW3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgLy8gU3RyaWN0IGVxdWFsaXR5IGNoZWNrLCBidXQgcmV0dXJuIGZhbHNlIGZvciBOYU49PT1OYU5cbiAgbGV0IHNob3VsZENoYW5nZSA9IChvbGQgIT09IHZhbHVlICYmIChvbGQgPT09IG9sZCB8fCB2YWx1ZSA9PT0gdmFsdWUpKTtcbiAgLy8gT2JqZWN0cyBhcmUgc3RvcmVkIGluIHRlbXBvcmFyeSBjYWNoZSAoY2xlYXJlZCBhdCBlbmQgb2ZcbiAgLy8gdHVybiksIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nXG4gIGlmIChpc09iamVjdCAmJiBzaG91bGRDaGFuZ2UpIHtcbiAgICBpbnN0Ll9fZGF0YVRlbXBbcHJvcGVydHldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHNob3VsZENoYW5nZTtcbn1cblxuZXhwb3J0IGNvbnN0IE11dGFibGVEYXRhID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gICAqL1xuICBjbGFzcyBNdXRhYmxlRGF0YSBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHByb3ZpZGUgb3B0aW9uIGZvciBza2lwcGluZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgXG4gICAgICogY2FjaGUgKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRydWUpO1xuICAgIH1cblxuICB9XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgTXV0YWJsZURhdGEucHJvdG90eXBlLm11dGFibGVEYXRhID0gZmFsc2U7XG5cbiAgcmV0dXJuIE11dGFibGVEYXRhO1xuXG59KTtcblxuZXhwb3J0IGNvbnN0IE9wdGlvbmFsTXV0YWJsZURhdGEgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAcG9seW1lclxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICAgKi9cbiAgY2xhc3MgT3B0aW9uYWxNdXRhYmxlRGF0YSBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbmNlLWxldmVsIGZsYWcgZm9yIGNvbmZpZ3VyaW5nIHRoZSBkaXJ0eS1jaGVja2luZyBzdHJhdGVneVxuICAgICAgICAgKiBmb3IgdGhpcyBlbGVtZW50LiAgV2hlbiB0cnVlLCBPYmplY3RzIGFuZCBBcnJheXMgd2lsbCBza2lwIGRpcnR5XG4gICAgICAgICAqIGNoZWNraW5nLCBvdGhlcndpc2Ugc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIG11dGFibGVEYXRhOiBCb29sZWFuXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHByb3ZpZGUgb3B0aW9uIGZvciBza2lwcGluZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAqXG4gICAgICogV2hlbiBgdGhpcy5tdXRhYmxlRGF0YWAgaXMgdHJ1ZSBvbiB0aGlzIGluc3RhbmNlLCB0aGlzIG1ldGhvZFxuICAgICAqIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYCBjYWNoZVxuICAgICAqIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0aGlzLm11dGFibGVEYXRhKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gT3B0aW9uYWxNdXRhYmxlRGF0YTtcblxufSk7XG5cbi8vIEV4cG9ydCBmb3IgdXNlIGJ5IGxlZ2FjeSBiZWhhdmlvclxuTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZSA9IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9tdXRhYmxlLWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcblxuLyoqXG4gKiBDaHJvbWUgdXNlcyBhbiBvbGRlciB2ZXJzaW9uIG9mIERPTSBMZXZlbCAzIEtleWJvYXJkIEV2ZW50c1xuICpcbiAqIE1vc3Qga2V5cyBhcmUgbGFiZWxlZCBhcyB0ZXh0LCBidXQgc29tZSBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLlxuICogVmFsdWVzIHRha2VuIGZyb206IGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDcvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDcxMjIxL2tleXNldC5odG1sI0tleVNldC1TZXRcbiAqL1xudmFyIEtFWV9JREVOVElGSUVSID0ge1xuICAnVSswMDA4JzogJ2JhY2tzcGFjZScsXG4gICdVKzAwMDknOiAndGFiJyxcbiAgJ1UrMDAxQic6ICdlc2MnLFxuICAnVSswMDIwJzogJ3NwYWNlJyxcbiAgJ1UrMDA3Ric6ICdkZWwnXG59O1xuXG4vKipcbiAqIFNwZWNpYWwgdGFibGUgZm9yIEtleWJvYXJkRXZlbnQua2V5Q29kZS5cbiAqIEtleWJvYXJkRXZlbnQua2V5SWRlbnRpZmllciBpcyBiZXR0ZXIsIGFuZCBLZXlCb2FyZEV2ZW50LmtleSBpcyBldmVuIGJldHRlclxuICogdGhhbiB0aGF0LlxuICpcbiAqIFZhbHVlcyBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC5rZXlDb2RlI1ZhbHVlX29mX2tleUNvZGVcbiAqL1xudmFyIEtFWV9DT0RFID0ge1xuICA4OiAnYmFja3NwYWNlJyxcbiAgOTogJ3RhYicsXG4gIDEzOiAnZW50ZXInLFxuICAyNzogJ2VzYycsXG4gIDMzOiAncGFnZXVwJyxcbiAgMzQ6ICdwYWdlZG93bicsXG4gIDM1OiAnZW5kJyxcbiAgMzY6ICdob21lJyxcbiAgMzI6ICdzcGFjZScsXG4gIDM3OiAnbGVmdCcsXG4gIDM4OiAndXAnLFxuICAzOTogJ3JpZ2h0JyxcbiAgNDA6ICdkb3duJyxcbiAgNDY6ICdkZWwnLFxuICAxMDY6ICcqJ1xufTtcblxuLyoqXG4gKiBNT0RJRklFUl9LRVlTIG1hcHMgdGhlIHNob3J0IG5hbWUgZm9yIG1vZGlmaWVyIGtleXMgdXNlZCBpbiBhIGtleVxuICogY29tYm8gc3RyaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lIHRoYXQgcmVmZXJlbmNlcyB0aG9zZSBzYW1lIGtleXNcbiAqIGluIGEgS2V5Ym9hcmRFdmVudCBpbnN0YW5jZS5cbiAqL1xudmFyIE1PRElGSUVSX0tFWVMgPSB7XG4gICdzaGlmdCc6ICdzaGlmdEtleScsXG4gICdjdHJsJzogJ2N0cmxLZXknLFxuICAnYWx0JzogJ2FsdEtleScsXG4gICdtZXRhJzogJ21ldGFLZXknXG59O1xuXG4vKipcbiAqIEtleWJvYXJkRXZlbnQua2V5IGlzIG1vc3RseSByZXByZXNlbnRlZCBieSBwcmludGFibGUgY2hhcmFjdGVyIG1hZGUgYnlcbiAqIHRoZSBrZXlib2FyZCwgd2l0aCB1bnByaW50YWJsZSBrZXlzIGxhYmVsZWQgbmljZWx5LlxuICpcbiAqIEhvd2V2ZXIsIG9uIE9TIFgsIEFsdCtjaGFyIGNhbiBtYWtlIGEgVW5pY29kZSBjaGFyYWN0ZXIgdGhhdCBmb2xsb3dzIGFuXG4gKiBBcHBsZS1zcGVjaWZpYyBtYXBwaW5nLiBJbiB0aGlzIGNhc2UsIHdlIGZhbGwgYmFjayB0byAua2V5Q29kZS5cbiAqL1xudmFyIEtFWV9DSEFSID0gL1thLXowLTkqXS87XG5cbi8qKlxuICogTWF0Y2hlcyBhIGtleUlkZW50aWZpZXIgc3RyaW5nLlxuICovXG52YXIgSURFTlRfQ0hBUiA9IC9VXFwrLztcblxuLyoqXG4gKiBNYXRjaGVzIGFycm93IGtleXMgaW4gR2Vja28gMjcuMCtcbiAqL1xudmFyIEFSUk9XX0tFWSA9IC9eYXJyb3cvO1xuXG4vKipcbiAqIE1hdGNoZXMgc3BhY2Uga2V5cyBldmVyeXdoZXJlIChub3RhYmx5IGluY2x1ZGluZyBJRTEwJ3MgZXhjZXB0aW9uYWwgbmFtZVxuICogYHNwYWNlYmFyYCkuXG4gKi9cbnZhciBTUEFDRV9LRVkgPSAvXnNwYWNlKGJhcik/LztcblxuLyoqXG4gKiBNYXRjaGVzIEVTQyBrZXkuXG4gKlxuICogVmFsdWUgZnJvbTogaHR0cDovL3czYy5naXRodWIuaW8vdWlldmVudHMta2V5LyNrZXktRXNjYXBlXG4gKi9cbnZhciBFU0NfS0VZID0gL15lc2NhcGUkLztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBLZXlCb2FyZEV2ZW50LmtleVxuICogQHBhcmFtIHtCb29sZWFufSBbbm9TcGVjaWFsQ2hhcnNdIExpbWl0cyB0aGUgdHJhbnNmb3JtYXRpb24gdG9cbiAqIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtS2V5KGtleSwgbm9TcGVjaWFsQ2hhcnMpIHtcbiAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gIGlmIChrZXkpIHtcbiAgICB2YXIgbEtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsS2V5ID09PSAnICcgfHwgU1BBQ0VfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgIHZhbGlkS2V5ID0gJ3NwYWNlJztcbiAgICB9IGVsc2UgaWYgKEVTQ19LRVkudGVzdChsS2V5KSkge1xuICAgICAgdmFsaWRLZXkgPSAnZXNjJztcbiAgICB9IGVsc2UgaWYgKGxLZXkubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmICghbm9TcGVjaWFsQ2hhcnMgfHwgS0VZX0NIQVIudGVzdChsS2V5KSkge1xuICAgICAgICB2YWxpZEtleSA9IGxLZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBUlJPV19LRVkudGVzdChsS2V5KSkge1xuICAgICAgdmFsaWRLZXkgPSBsS2V5LnJlcGxhY2UoJ2Fycm93JywgJycpO1xuICAgIH0gZWxzZSBpZiAobEtleSA9PSAnbXVsdGlwbHknKSB7XG4gICAgICAvLyBudW1wYWQgJyonIGNhbiBtYXAgdG8gTXVsdGlwbHkgb24gSUUvV2luZG93c1xuICAgICAgdmFsaWRLZXkgPSAnKic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkS2V5ID0gbEtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbGlkS2V5O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1LZXlJZGVudGlmaWVyKGtleUlkZW50KSB7XG4gIHZhciB2YWxpZEtleSA9ICcnO1xuICBpZiAoa2V5SWRlbnQpIHtcbiAgICBpZiAoa2V5SWRlbnQgaW4gS0VZX0lERU5USUZJRVIpIHtcbiAgICAgIHZhbGlkS2V5ID0gS0VZX0lERU5USUZJRVJba2V5SWRlbnRdO1xuICAgIH0gZWxzZSBpZiAoSURFTlRfQ0hBUi50ZXN0KGtleUlkZW50KSkge1xuICAgICAga2V5SWRlbnQgPSBwYXJzZUludChrZXlJZGVudC5yZXBsYWNlKCdVKycsICcweCcpLCAxNik7XG4gICAgICB2YWxpZEtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5SWRlbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkS2V5ID0ga2V5SWRlbnQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbGlkS2V5O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1LZXlDb2RlKGtleUNvZGUpIHtcbiAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gIGlmIChOdW1iZXIoa2V5Q29kZSkpIHtcbiAgICBpZiAoa2V5Q29kZSA+PSA2NSAmJiBrZXlDb2RlIDw9IDkwKSB7XG4gICAgICAvLyBhc2NpaSBhLXpcbiAgICAgIC8vIGxvd2VyY2FzZSBpcyAzMiBvZmZzZXQgZnJvbSB1cHBlcmNhc2VcbiAgICAgIHZhbGlkS2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGtleUNvZGUpO1xuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSAxMTIgJiYga2V5Q29kZSA8PSAxMjMpIHtcbiAgICAgIC8vIGZ1bmN0aW9uIGtleXMgZjEtZjEyXG4gICAgICB2YWxpZEtleSA9ICdmJyArIChrZXlDb2RlIC0gMTEyICsgMSk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpIHtcbiAgICAgIC8vIHRvcCAwLTkga2V5c1xuICAgICAgdmFsaWRLZXkgPSBTdHJpbmcoa2V5Q29kZSAtIDQ4KTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gOTYgJiYga2V5Q29kZSA8PSAxMDUpIHtcbiAgICAgIC8vIG51bSBwYWQgMC05XG4gICAgICB2YWxpZEtleSA9IFN0cmluZyhrZXlDb2RlIC0gOTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZEtleSA9IEtFWV9DT0RFW2tleUNvZGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsaWRLZXk7XG59XG5cbi8qKlxuICAqIENhbGN1bGF0ZXMgdGhlIG5vcm1hbGl6ZWQga2V5IGZvciBhIEtleWJvYXJkRXZlbnQuXG4gICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBrZXlFdmVudFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU3BlY2lhbENoYXJzXSBTZXQgdG8gdHJ1ZSB0byBsaW1pdCBrZXlFdmVudC5rZXlcbiAgKiB0cmFuc2Zvcm1hdGlvbiB0byBhbHBoYS1udW1lcmljIGNoYXJzLiBUaGlzIGlzIHVzZWZ1bCB3aXRoIGtleVxuICAqIGNvbWJpbmF0aW9ucyBsaWtlIHNoaWZ0ICsgMiwgd2hpY2ggb24gRkYgZm9yIE1hY09TIHByb2R1Y2VzXG4gICoga2V5RXZlbnQua2V5ID0gQFxuICAqIFRvIGdldCAyIHJldHVybmVkLCBzZXQgbm9TcGVjaWFsQ2hhcnMgPSB0cnVlXG4gICogVG8gZ2V0IEAgcmV0dXJuZWQsIHNldCBub1NwZWNpYWxDaGFycyA9IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZWRLZXlGb3JFdmVudChrZXlFdmVudCwgbm9TcGVjaWFsQ2hhcnMpIHtcbiAgLy8gRmFsbCBiYWNrIGZyb20gLmtleSwgdG8gLmRldGFpbC5rZXkgZm9yIGFydGlmaWNhbCBrZXlib2FyZCBldmVudHMsXG4gIC8vIGFuZCB0aGVuIHRvIGRlcHJlY2F0ZWQgLmtleUlkZW50aWZpZXIgYW5kIC5rZXlDb2RlLlxuICBpZiAoa2V5RXZlbnQua2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybUtleShrZXlFdmVudC5rZXksIG5vU3BlY2lhbENoYXJzKTtcbiAgfVxuICBpZiAoa2V5RXZlbnQuZGV0YWlsICYmIGtleUV2ZW50LmRldGFpbC5rZXkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtS2V5KGtleUV2ZW50LmRldGFpbC5rZXksIG5vU3BlY2lhbENoYXJzKTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtS2V5SWRlbnRpZmllcihrZXlFdmVudC5rZXlJZGVudGlmaWVyKSB8fFxuICAgIHRyYW5zZm9ybUtleUNvZGUoa2V5RXZlbnQua2V5Q29kZSkgfHwgJyc7XG59XG5cbmZ1bmN0aW9uIGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvLCBldmVudCkge1xuICAvLyBGb3IgY29tYm9zIHdpdGggbW9kaWZpZXJzIHdlIHN1cHBvcnQgb25seSBhbHBoYS1udW1lcmljIGtleXNcbiAgdmFyIGtleUV2ZW50ID0gbm9ybWFsaXplZEtleUZvckV2ZW50KGV2ZW50LCBrZXlDb21iby5oYXNNb2RpZmllcnMpO1xuICByZXR1cm4ga2V5RXZlbnQgPT09IGtleUNvbWJvLmtleSAmJlxuICAgICgha2V5Q29tYm8uaGFzTW9kaWZpZXJzIHx8IChcbiAgICAgICEhZXZlbnQuc2hpZnRLZXkgPT09ICEha2V5Q29tYm8uc2hpZnRLZXkgJiZcbiAgICAgICEhZXZlbnQuY3RybEtleSA9PT0gISFrZXlDb21iby5jdHJsS2V5ICYmXG4gICAgICAhIWV2ZW50LmFsdEtleSA9PT0gISFrZXlDb21iby5hbHRLZXkgJiZcbiAgICAgICEhZXZlbnQubWV0YUtleSA9PT0gISFrZXlDb21iby5tZXRhS2V5KVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpIHtcbiAgaWYgKGtleUNvbWJvU3RyaW5nLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21ibzoga2V5Q29tYm9TdHJpbmcsXG4gICAgICBrZXk6IGtleUNvbWJvU3RyaW5nLFxuICAgICAgZXZlbnQ6ICdrZXlkb3duJ1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGtleUNvbWJvU3RyaW5nLnNwbGl0KCcrJykucmVkdWNlKGZ1bmN0aW9uKHBhcnNlZEtleUNvbWJvLCBrZXlDb21ib1BhcnQpIHtcbiAgICB2YXIgZXZlbnRQYXJ0cyA9IGtleUNvbWJvUGFydC5zcGxpdCgnOicpO1xuICAgIHZhciBrZXlOYW1lID0gZXZlbnRQYXJ0c1swXTtcbiAgICB2YXIgZXZlbnQgPSBldmVudFBhcnRzWzFdO1xuXG4gICAgaWYgKGtleU5hbWUgaW4gTU9ESUZJRVJfS0VZUykge1xuICAgICAgcGFyc2VkS2V5Q29tYm9bTU9ESUZJRVJfS0VZU1trZXlOYW1lXV0gPSB0cnVlO1xuICAgICAgcGFyc2VkS2V5Q29tYm8uaGFzTW9kaWZpZXJzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkS2V5Q29tYm8ua2V5ID0ga2V5TmFtZTtcbiAgICAgIHBhcnNlZEtleUNvbWJvLmV2ZW50ID0gZXZlbnQgfHwgJ2tleWRvd24nO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWRLZXlDb21ibztcbiAgfSwge1xuICAgIGNvbWJvOiBrZXlDb21ib1N0cmluZy5zcGxpdCgnOicpLnNoaWZ0KClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpIHtcbiAgcmV0dXJuIGV2ZW50U3RyaW5nLnRyaW0oKS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihrZXlDb21ib1N0cmluZykge1xuICAgIHJldHVybiBwYXJzZUtleUNvbWJvU3RyaW5nKGtleUNvbWJvU3RyaW5nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBJcm9uQTExeUtleXNCZWhhdmlvciA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBFdmVudFRhcmdldCB0aGF0IHdpbGwgYmUgZmlyaW5nIHJlbGV2YW50IEtleWJvYXJkRXZlbnRzLiBTZXQgaXQgdG9cbiAgICAgKiBgbnVsbGAgdG8gZGlzYWJsZSB0aGUgbGlzdGVuZXJzLlxuICAgICAqIEB0eXBlIHs/RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAga2V5RXZlbnRUYXJnZXQ6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoaXMgcHJvcGVydHkgd2lsbCBjYXVzZSB0aGUgaW1wbGVtZW50aW5nIGVsZW1lbnQgdG9cbiAgICAgKiBhdXRvbWF0aWNhbGx5IHN0b3AgcHJvcGFnYXRpb24gb24gYW55IGhhbmRsZWQgS2V5Ym9hcmRFdmVudHMuXG4gICAgICovXG4gICAgc3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBfYm91bmRLZXlIYW5kbGVyczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gV2UgdXNlIHRoaXMgZHVlIHRvIGEgbGltaXRhdGlvbiBpbiBJRTEwIHdoZXJlIGluc3RhbmNlcyB3aWxsIGhhdmVcbiAgICAvLyBvd24gcHJvcGVydGllcyBvZiBldmVyeXRoaW5nIG9uIHRoZSBcInByb3RvdHlwZVwiLlxuICAgIF9pbXBlcmF0aXZlS2V5QmluZGluZ3M6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnMoa2V5RXZlbnRUYXJnZXQsIF9ib3VuZEtleUhhbmRsZXJzKSdcbiAgXSxcblxuXG4gIC8qKlxuICAgKiBUbyBiZSB1c2VkIHRvIGV4cHJlc3Mgd2hhdCBjb21iaW5hdGlvbiBvZiBrZXlzICB3aWxsIHRyaWdnZXIgdGhlIHJlbGF0aXZlXG4gICAqIGNhbGxiYWNrLiBlLmcuIGBrZXlCaW5kaW5nczogeyAnZXNjJzogJ19vbkVzY1ByZXNzZWQnfWBcbiAgICogQHR5cGUgeyFPYmplY3R9XG4gICAqL1xuICBrZXlCaW5kaW5nczoge30sXG5cbiAgcmVnaXN0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FuIGJlIHVzZWQgdG8gaW1wZXJhdGl2ZWx5IGFkZCBhIGtleSBiaW5kaW5nIHRvIHRoZSBpbXBsZW1lbnRpbmdcbiAgICogZWxlbWVudC4gVGhpcyBpcyB0aGUgaW1wZXJhdGl2ZSBlcXVpdmFsZW50IG9mIGRlY2xhcmluZyBhIGtleWJpbmRpbmdcbiAgICogaW4gdGhlIGBrZXlCaW5kaW5nc2AgcHJvdG90eXBlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRTdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAqL1xuICBhZGRPd25LZXlCaW5kaW5nOiBmdW5jdGlvbihldmVudFN0cmluZywgaGFuZGxlck5hbWUpIHtcbiAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddID0gaGFuZGxlck5hbWU7XG4gICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgdGhpcy5fcmVzZXRLZXlFdmVudExpc3RlbmVycygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIGNhbGxlZCwgd2lsbCByZW1vdmUgYWxsIGltcGVyYXRpdmVseS1hZGRlZCBrZXkgYmluZGluZ3MuXG4gICAqL1xuICByZW1vdmVPd25LZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzID0ge307XG4gICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgdGhpcy5fcmVzZXRLZXlFdmVudExpc3RlbmVycygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBrZXlib2FyZCBldmVudCBtYXRjaGVzIGBldmVudFN0cmluZ2AuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50U3RyaW5nXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBrZXlib2FyZEV2ZW50TWF0Y2hlc0tleXM6IGZ1bmN0aW9uKGV2ZW50LCBldmVudFN0cmluZykge1xuICAgIHZhciBrZXlDb21ib3MgPSBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvbWJvcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvc1tpXSwgZXZlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgX2NvbGxlY3RLZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleUJpbmRpbmdzID0gdGhpcy5iZWhhdmlvcnMubWFwKGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgICByZXR1cm4gYmVoYXZpb3Iua2V5QmluZGluZ3M7XG4gICAgfSk7XG5cbiAgICBpZiAoa2V5QmluZGluZ3MuaW5kZXhPZih0aGlzLmtleUJpbmRpbmdzKSA9PT0gLTEpIHtcbiAgICAgIGtleUJpbmRpbmdzLnB1c2godGhpcy5rZXlCaW5kaW5ncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUJpbmRpbmdzO1xuICB9LFxuXG4gIF9wcmVwS2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2tleUJpbmRpbmdzID0ge307XG5cbiAgICB0aGlzLl9jb2xsZWN0S2V5QmluZGluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUJpbmRpbmdzKSB7XG4gICAgICBmb3IgKHZhciBldmVudFN0cmluZyBpbiBrZXlCaW5kaW5ncykge1xuICAgICAgICB0aGlzLl9hZGRLZXlCaW5kaW5nKGV2ZW50U3RyaW5nLCBrZXlCaW5kaW5nc1tldmVudFN0cmluZ10pO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgZm9yICh2YXIgZXZlbnRTdHJpbmcgaW4gdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzKSB7XG4gICAgICB0aGlzLl9hZGRLZXlCaW5kaW5nKGV2ZW50U3RyaW5nLCB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddKTtcbiAgICB9XG5cbiAgICAvLyBHaXZlIHByZWNlZGVuY2UgdG8gY29tYm9zIHdpdGggbW9kaWZpZXJzIHRvIGJlIGNoZWNrZWQgZmlyc3QuXG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHRoaXMuX2tleUJpbmRpbmdzKSB7XG4gICAgICB0aGlzLl9rZXlCaW5kaW5nc1tldmVudE5hbWVdLnNvcnQoZnVuY3Rpb24gKGtiMSwga2IyKSB7XG4gICAgICAgIHZhciBiMSA9IGtiMVswXS5oYXNNb2RpZmllcnM7XG4gICAgICAgIHZhciBiMiA9IGtiMlswXS5oYXNNb2RpZmllcnM7XG4gICAgICAgIHJldHVybiAoYjEgPT09IGIyKSA/IDAgOiBiMSA/IC0xIDogMTtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIF9hZGRLZXlCaW5kaW5nOiBmdW5jdGlvbihldmVudFN0cmluZywgaGFuZGxlck5hbWUpIHtcbiAgICBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUNvbWJvKSB7XG4gICAgICB0aGlzLl9rZXlCaW5kaW5nc1trZXlDb21iby5ldmVudF0gPVxuICAgICAgICB0aGlzLl9rZXlCaW5kaW5nc1trZXlDb21iby5ldmVudF0gfHwgW107XG5cbiAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XS5wdXNoKFtcbiAgICAgICAga2V5Q29tYm8sXG4gICAgICAgIGhhbmRsZXJOYW1lXG4gICAgICBdKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBfcmVzZXRLZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuXG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5fbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH0sXG5cbiAgX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMua2V5RXZlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmtleXModGhpcy5fa2V5QmluZGluZ3MpLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICB2YXIga2V5QmluZGluZ3MgPSB0aGlzLl9rZXlCaW5kaW5nc1tldmVudE5hbWVdO1xuICAgICAgdmFyIGJvdW5kS2V5SGFuZGxlciA9IHRoaXMuX29uS2V5QmluZGluZ0V2ZW50LmJpbmQodGhpcywga2V5QmluZGluZ3MpO1xuXG4gICAgICB0aGlzLl9ib3VuZEtleUhhbmRsZXJzLnB1c2goW3RoaXMua2V5RXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyXSk7XG5cbiAgICAgIHRoaXMua2V5RXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcik7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXlIYW5kbGVyVHVwbGU7XG4gICAgdmFyIGtleUV2ZW50VGFyZ2V0O1xuICAgIHZhciBldmVudE5hbWU7XG4gICAgdmFyIGJvdW5kS2V5SGFuZGxlcjtcblxuICAgIHdoaWxlICh0aGlzLl9ib3VuZEtleUhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgLy8gTXkga2luZ2RvbSBmb3IgYmxvY2stc2NvcGUgYmluZGluZyBhbmQgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50Li5cbiAgICAgIGtleUhhbmRsZXJUdXBsZSA9IHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMucG9wKCk7XG4gICAgICBrZXlFdmVudFRhcmdldCA9IGtleUhhbmRsZXJUdXBsZVswXTtcbiAgICAgIGV2ZW50TmFtZSA9IGtleUhhbmRsZXJUdXBsZVsxXTtcbiAgICAgIGJvdW5kS2V5SGFuZGxlciA9IGtleUhhbmRsZXJUdXBsZVsyXTtcblxuICAgICAga2V5RXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcik7XG4gICAgfVxuICB9LFxuXG4gIF9vbktleUJpbmRpbmdFdmVudDogZnVuY3Rpb24oa2V5QmluZGluZ3MsIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuc3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgZXZlbnQgaGFzIGJlZW4gYWxyZWFkeSBwcmV2ZW50ZWQsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5Q29tYm8gPSBrZXlCaW5kaW5nc1tpXVswXTtcbiAgICAgIHZhciBoYW5kbGVyTmFtZSA9IGtleUJpbmRpbmdzW2ldWzFdO1xuICAgICAgaWYgKGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvLCBldmVudCkpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcktleUhhbmRsZXIoa2V5Q29tYm8sIGhhbmRsZXJOYW1lLCBldmVudCk7XG4gICAgICAgIC8vIGV4aXQgdGhlIGxvb3AgaWYgZXZlbnREZWZhdWx0IHdhcyBwcmV2ZW50ZWRcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX3RyaWdnZXJLZXlIYW5kbGVyOiBmdW5jdGlvbihrZXlDb21ibywgaGFuZGxlck5hbWUsIGtleWJvYXJkRXZlbnQpIHtcbiAgICB2YXIgZGV0YWlsID0gT2JqZWN0LmNyZWF0ZShrZXlDb21ibyk7XG4gICAgZGV0YWlsLmtleWJvYXJkRXZlbnQgPSBrZXlib2FyZEV2ZW50O1xuICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudChrZXlDb21iby5ldmVudCwge1xuICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpc1toYW5kbGVyTmFtZV0uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9mb250LXJvYm90by9yb2JvdG8uanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxjdXN0b20tc3R5bGU+XG4gIDxzdHlsZSBpcz1cImN1c3RvbS1zdHlsZVwiPlxuICAgIGh0bWwge1xuXG4gICAgICAvKiBTaGFyZWQgU3R5bGVzICovXG4gICAgICAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U6IHtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdSb2JvdG8nLCAnTm90bycsIHNhbnMtc2VyaWY7XG4gICAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWNvbW1vbi1jb2RlOiB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnUm9ib3RvIE1vbm8nLCAnQ29uc29sYXMnLCAnTWVubG8nLCBtb25vc3BhY2U7XG4gICAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWNvbW1vbi1leHBlbnNpdmUta2VybmluZzoge1xuICAgICAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWNvbW1vbi1ub3dyYXA6IHtcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICB9O1xuXG4gICAgICAvKiBNYXRlcmlhbCBGb250IFN0eWxlcyAqL1xuXG4gICAgICAtLXBhcGVyLWZvbnQtZGlzcGxheTQ6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tbm93cmFwO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMTEycHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiAzMDA7XG4gICAgICAgIGxldHRlci1zcGFjaW5nOiAtLjA0NGVtO1xuICAgICAgICBsaW5lLWhlaWdodDogMTIwcHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtZGlzcGxheTM6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tbm93cmFwO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogNTZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICAgICAgbGV0dGVyLXNwYWNpbmc6IC0uMDI2ZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiA2MHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWRpc3BsYXkyOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG5cbiAgICAgICAgZm9udC1zaXplOiA0NXB4O1xuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICBsZXR0ZXItc3BhY2luZzogLS4wMThlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDQ4cHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtZGlzcGxheTE6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcblxuICAgICAgICBmb250LXNpemU6IDM0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgICAgIGxldHRlci1zcGFjaW5nOiAtLjAxZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWhlYWRsaW5lOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG5cbiAgICAgICAgZm9udC1zaXplOiAyNHB4O1xuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICBsZXR0ZXItc3BhY2luZzogLS4wMTJlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDMycHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtdGl0bGU6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tbm93cmFwO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDI4cHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtc3ViaGVhZDoge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDI0cHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtYm9keTI6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcblxuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyNHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWJvZHkxOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG5cbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgICAgIH07XG5cbiAgICAgIC0tcGFwZXItZm9udC1jYXB0aW9uOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLW5vd3JhcDtcblxuICAgICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgICAgIGxldHRlci1zcGFjaW5nOiAwLjAxMWVtO1xuICAgICAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgICAgIH07XG5cbiAgICAgIC0tcGFwZXItZm9udC1tZW51OiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLW5vd3JhcDtcblxuICAgICAgICBmb250LXNpemU6IDEzcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyNHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWJ1dHRvbjoge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1ub3dyYXA7XG5cbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICBsZXR0ZXItc3BhY2luZzogMC4wMThlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDI0cHg7XG4gICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtY29kZTI6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tY29kZTtcblxuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWNvZGUxOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWNvZGU7XG5cbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgICAgIH07XG5cbiAgICB9XG5cbiAgPC9zdHlsZT5cbjwvY3VzdG9tLXN0eWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvdHlwb2dyYXBoeS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uQ29udHJvbFN0YXRlID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBlbGVtZW50IGN1cnJlbnRseSBoYXMgZm9jdXMuXG4gICAgICovXG4gICAgZm9jdXNlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIG9ic2VydmVyOiAnX2Rpc2FibGVkQ2hhbmdlZCcsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgX29sZFRhYkluZGV4OiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuXG4gICAgX2JvdW5kRm9jdXNCbHVySGFuZGxlcjoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb2N1c0JsdXJIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9faGFuZGxlRXZlbnRSZXRhcmdldGluZzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnNoYWRvd1Jvb3QgJiYgIUVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfY2hhbmdlZENvbnRyb2xTdGF0ZShmb2N1c2VkLCBkaXNhYmxlZCknXG4gIF0sXG5cbiAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIsIHRydWUpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kRm9jdXNCbHVySGFuZGxlciwgdHJ1ZSk7XG4gIH0sXG5cbiAgX2ZvY3VzQmx1ckhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gSW4gUG9seW1lciAyLjAsIHRoZSBsaWJyYXJ5IHRha2VzIGNhcmUgb2YgcmV0YXJnZXRpbmcgZXZlbnRzLlxuICAgIGlmIChFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRGb2N1c2VkKGV2ZW50LnR5cGUgPT09ICdmb2N1cycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5PVEUoY2RhdGEpOiAgaWYgd2UgYXJlIGluIFNoYWRvd0RPTSBsYW5kLCBgZXZlbnQudGFyZ2V0YCB3aWxsXG4gICAgLy8gZXZlbnR1YWxseSBiZWNvbWUgYHRoaXNgIGR1ZSB0byByZXRhcmdldGluZzsgaWYgd2UgYXJlIG5vdCBpblxuICAgIC8vIFNoYWRvd0RPTSBsYW5kLCBgZXZlbnQudGFyZ2V0YCB3aWxsIGV2ZW50dWFsbHkgYmVjb21lIGB0aGlzYCBkdWVcbiAgICAvLyB0byB0aGUgc2Vjb25kIGNvbmRpdGlvbmFsIHdoaWNoIGZpcmVzIGEgc3ludGhldGljIGV2ZW50ICh0aGF0IGlzIGFsc29cbiAgICAvLyBoYW5kbGVkKS4gSW4gZWl0aGVyIGNhc2UsIHdlIGNhbiBkaXNyZWdhcmQgYGV2ZW50LnBhdGhgLlxuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX3NldEZvY3VzZWQoZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9faGFuZGxlRXZlbnRSZXRhcmdldGluZykge1xuICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8oZG9tKGV2ZW50KS5sb2NhbFRhcmdldCk7XG4gICAgICBpZiAoIXRoaXMuaXNMaWdodERlc2NlbmRhbnQodGFyZ2V0KSkge1xuICAgICAgICB0aGlzLmZpcmUoZXZlbnQudHlwZSwge3NvdXJjZUV2ZW50OiBldmVudH0sIHtcbiAgICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICAgIGJ1YmJsZXM6IGV2ZW50LmJ1YmJsZXMsXG4gICAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX2Rpc2FibGVkQ2hhbmdlZDogZnVuY3Rpb24oZGlzYWJsZWQsIG9sZCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgZGlzYWJsZWQgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB0aGlzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBkaXNhYmxlZCA/ICdub25lJyA6ICcnO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5fb2xkVGFiSW5kZXggPSB0aGlzLnRhYkluZGV4O1xuICAgICAgdGhpcy5fc2V0Rm9jdXNlZChmYWxzZSk7XG4gICAgICB0aGlzLnRhYkluZGV4ID0gLTE7XG4gICAgICB0aGlzLmJsdXIoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29sZFRhYkluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGFiSW5kZXggPSB0aGlzLl9vbGRUYWJJbmRleDtcbiAgICB9XG4gIH0sXG5cbiAgX2NoYW5nZWRDb250cm9sU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIF9jb250cm9sU3RhdGVDaGFuZ2VkIGlzIGFic3RyYWN0LCBmb2xsb3ctb24gYmVoYXZpb3JzIG1heSBpbXBsZW1lbnQgaXRcbiAgICBpZiAodGhpcy5fY29udHJvbFN0YXRlQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fY29udHJvbFN0YXRlQ2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXJpcHBsZS9wYXBlci1yaXBwbGUuanMnO1xuaW1wb3J0IHsgSXJvbkJ1dHRvblN0YXRlSW1wbCB9IGZyb20gJy4uL2lyb24tYmVoYXZpb3JzL2lyb24tYnV0dG9uLXN0YXRlLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBQYXBlclJpcHBsZUJlaGF2aW9yID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGVsZW1lbnQgd2lsbCBub3QgcHJvZHVjZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiBpbnRlcmFjdGVkXG4gICAgICogd2l0aCB2aWEgdGhlIHBvaW50ZXIuXG4gICAgICovXG4gICAgbm9pbms6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBvYnNlcnZlcjogJ19ub2lua0NoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBfcmlwcGxlQ29udGFpbmVyOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIGEgYDxwYXBlci1yaXBwbGU+YCBlbGVtZW50IGlzIGF2YWlsYWJsZSB3aGVuIHRoZSBlbGVtZW50IGlzXG4gICAqIGZvY3VzZWQuXG4gICAqL1xuICBfYnV0dG9uU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5mb2N1c2VkKSB7XG4gICAgICB0aGlzLmVuc3VyZVJpcHBsZSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW4gYWRkaXRpb24gdG8gdGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgaW4gYElyb25CdXR0b25TdGF0ZWAsIGVuc3VyZXNcbiAgICogYSByaXBwbGUgZWZmZWN0IGlzIGNyZWF0ZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBpbiBhIGBwcmVzc2VkYCBzdGF0ZS5cbiAgICovXG4gIF9kb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBJcm9uQnV0dG9uU3RhdGVJbXBsLl9kb3duSGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBpZiAodGhpcy5wcmVzc2VkKSB7XG4gICAgICB0aGlzLmVuc3VyZVJpcHBsZShldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoaXMgZWxlbWVudCBjb250YWlucyBhIHJpcHBsZSBlZmZlY3QuIEZvciBzdGFydHVwIGVmZmljaWVuY3lcbiAgICogdGhlIHJpcHBsZSBlZmZlY3QgaXMgZHluYW1pY2FsbHkgb24gZGVtYW5kIHdoZW4gbmVlZGVkLlxuICAgKiBAcGFyYW0geyFFdmVudD19IG9wdFRyaWdnZXJpbmdFdmVudCAob3B0aW9uYWwpIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICAgKiByaXBwbGUuXG4gICAqL1xuICBlbnN1cmVSaXBwbGU6IGZ1bmN0aW9uKG9wdFRyaWdnZXJpbmdFdmVudCkge1xuICAgIGlmICghdGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgdGhpcy5fcmlwcGxlID0gdGhpcy5fY3JlYXRlUmlwcGxlKCk7XG4gICAgICB0aGlzLl9yaXBwbGUubm9pbmsgPSB0aGlzLm5vaW5rO1xuICAgICAgdmFyIHJpcHBsZUNvbnRhaW5lciA9IHRoaXMuX3JpcHBsZUNvbnRhaW5lciB8fCB0aGlzLnJvb3Q7XG4gICAgICBpZiAocmlwcGxlQ29udGFpbmVyKSB7XG4gICAgICAgIGRvbShyaXBwbGVDb250YWluZXIpLmFwcGVuZENoaWxkKHRoaXMuX3JpcHBsZSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0VHJpZ2dlcmluZ0V2ZW50KSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBldmVudCBoYXBwZW5lZCBpbnNpZGUgb2YgdGhlIHJpcHBsZSBjb250YWluZXJcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGhvc3QgaW5zdGVhZCBvZiB0aGUgcm9vdCBiZWNhdXNlIGRpc3RyaWJ1dGVkIHRleHRcbiAgICAgICAgLy8gbm9kZXMgYXJlIG5vdCB2YWxpZCBldmVudCB0YXJnZXRzXG4gICAgICAgIHZhciBkb21Db250YWluZXIgPSBkb20odGhpcy5fcmlwcGxlQ29udGFpbmVyIHx8IHRoaXMpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZG9tKG9wdFRyaWdnZXJpbmdFdmVudCkucm9vdFRhcmdldDtcbiAgICAgICAgaWYgKGRvbUNvbnRhaW5lci5kZWVwQ29udGFpbnMoIC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KSkpIHtcbiAgICAgICAgICB0aGlzLl9yaXBwbGUudWlEb3duQWN0aW9uKG9wdFRyaWdnZXJpbmdFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudCB1c2VkIGJ5IHRoaXMgZWxlbWVudCB0byBjcmVhdGVcbiAgICogcmlwcGxlIGVmZmVjdHMuIFRoZSBlbGVtZW50J3MgcmlwcGxlIGlzIGNyZWF0ZWQgb24gZGVtYW5kLCB3aGVuXG4gICAqIG5lY2Vzc2FyeSwgYW5kIGNhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCBmb3JjZSB0aGVcbiAgICogcmlwcGxlIHRvIGJlIGNyZWF0ZWQuXG4gICAqL1xuICBnZXRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3JpcHBsZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZWxlbWVudCBjdXJyZW50bHkgY29udGFpbnMgYSByaXBwbGUgZWZmZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9yaXBwbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGVsZW1lbnQncyByaXBwbGUgZWZmZWN0IHZpYSBjcmVhdGluZyBhIGA8cGFwZXItcmlwcGxlPmAuXG4gICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGN1c3RvbWl6ZSB0aGUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFQYXBlclJpcHBsZUVsZW1lbnR9IFJldHVybnMgYSBgPHBhcGVyLXJpcHBsZT5gIGVsZW1lbnQuXG4gICAqL1xuICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshUGFwZXJSaXBwbGVFbGVtZW50fSAqLyAoXG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BhcGVyLXJpcHBsZScpKTtcbiAgfSxcblxuICBfbm9pbmtDaGFuZ2VkOiBmdW5jdGlvbihub2luaykge1xuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICB0aGlzLl9yaXBwbGUubm9pbmsgPSBub2luaztcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItcmlwcGxlLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBsZXQgbmF0aXZlU2hhZG93ID0gISh3aW5kb3dbJ1NoYWR5RE9NJ10gJiYgd2luZG93WydTaGFkeURPTSddWydpblVzZSddKTtcbmV4cG9ydCBsZXQgbmF0aXZlQ3NzVmFyaWFibGVzO1xuXG4vKipcbiAqIEBwYXJhbSB7KFNoYWR5Q1NTT3B0aW9ucyB8IFNoYWR5Q1NTSW50ZXJmYWNlKT19IHNldHRpbmdzXG4gKi9cbmZ1bmN0aW9uIGNhbGNDc3NWYXJpYWJsZXMoc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzWydzaGltY3NzcHJvcGVydGllcyddKSB7XG4gICAgbmF0aXZlQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY2hyb21lIDQ5IGhhcyBzZW1pLXdvcmtpbmcgY3NzIHZhcnMsIGNoZWNrIGlmIGJveC1zaGFkb3cgd29ya3NcbiAgICAvLyBzYWZhcmkgOS4xIGhhcyBhIHJlY2FsYyBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTU3ODJcbiAgICAvLyBIb3dldmVyLCBzaGltIGNzcyBjdXN0b20gcHJvcGVydGllcyBhcmUgb25seSBzdXBwb3J0ZWQgd2l0aCBTaGFkeURPTSBlbmFibGVkLFxuICAgIC8vIHNvIGZhbGwgYmFjayBvbiBuYXRpdmUgaWYgd2UgZG8gbm90IGRldGVjdCBTaGFkeURPTVxuICAgIC8vIEVkZ2UgMTU6IGN1c3RvbSBwcm9wZXJ0aWVzIHVzZWQgaW4gOjpiZWZvcmUgYW5kIDo6YWZ0ZXIgd2lsbCBhbHNvIGJlIHVzZWQgaW4gdGhlIHBhcmVudCBlbGVtZW50XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTI0MTQyNTcvXG4gICAgbmF0aXZlQ3NzVmFyaWFibGVzID0gbmF0aXZlU2hhZG93IHx8IEJvb2xlYW4oIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvNjAxfEVkZ2VcXC8xNS8pICYmXG4gICAgICB3aW5kb3cuQ1NTICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoJ2JveC1zaGFkb3cnLCAnMCAwIDAgdmFyKC0tZm9vKScpKTtcbiAgfVxufVxuXG5pZiAod2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3MgIT09IHVuZGVmaW5lZCkge1xuICBuYXRpdmVDc3NWYXJpYWJsZXMgPSB3aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzO1xufSBlbHNlIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgY2FsY0Nzc1ZhcmlhYmxlcyh3aW5kb3cuU2hhZHlDU1MpO1xuICAvLyByZXNldCB3aW5kb3cgdmFyaWFibGUgdG8gbGV0IFNoYWR5Q1NTIEFQSSB0YWtlIGl0cyBwbGFjZVxuICB3aW5kb3cuU2hhZHlDU1MgPSB1bmRlZmluZWQ7XG59IGVsc2Uge1xuICBjYWxjQ3NzVmFyaWFibGVzKHdpbmRvd1snV2ViQ29tcG9uZW50cyddICYmIHdpbmRvd1snV2ViQ29tcG9uZW50cyddWydmbGFncyddKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvc3R5bGUtc2V0dGluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qXG5FeHRyZW1lbHkgc2ltcGxlIGNzcyBwYXJzZXIuIEludGVuZGVkIHRvIGJlIG5vdCBtb3JlIHRoYW4gd2hhdCB3ZSBuZWVkXG5hbmQgZGVmaW5pdGVseSBub3QgbmVjZXNzYXJpbHkgY29ycmVjdCA9KS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEB1bnJlc3RyaWN0ZWQgKi9cbmNsYXNzIFN0eWxlTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ3N0YXJ0J10gPSAwO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ2VuZCddID0gMDtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzWydwcmV2aW91cyddID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzWydwYXJlbnQnXSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTdHlsZU5vZGU+fSAqL1xuICAgIHRoaXNbJ3J1bGVzJ10gPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3BhcnNlZENzc1RleHQnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ2Nzc1RleHQnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzWydhdFJ1bGUnXSA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ3R5cGUnXSA9IDA7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1sna2V5ZnJhbWVzTmFtZSddID0gJyc7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1snc2VsZWN0b3InXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3BhcnNlZFNlbGVjdG9yJ10gPSAnJztcbiAgfVxufVxuXG5leHBvcnQge1N0eWxlTm9kZX1cblxuLy8gZ2l2ZW4gYSBzdHJpbmcgb2YgY3NzLCByZXR1cm4gYSBzaW1wbGUgcnVsZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gIHRleHQgPSBjbGVhbih0ZXh0KTtcbiAgcmV0dXJuIHBhcnNlQ3NzKGxleCh0ZXh0KSwgdGV4dCk7XG59XG5cbi8vIHJlbW92ZSBzdHVmZiB3ZSBkb24ndCBjYXJlIGFib3V0IHRoYXQgbWF5IGhpbmRlciBwYXJzaW5nXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuKGNzc1RleHQpIHtcbiAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShSWC5jb21tZW50cywgJycpLnJlcGxhY2UoUlgucG9ydCwgJycpO1xufVxuXG4vLyBzdXBlciBzaW1wbGUgey4uLn0gbGV4ZXIgdGhhdCByZXR1cm5zIGEgbm9kZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmZ1bmN0aW9uIGxleCh0ZXh0KSB7XG4gIGxldCByb290ID0gbmV3IFN0eWxlTm9kZSgpO1xuICByb290WydzdGFydCddID0gMDtcbiAgcm9vdFsnZW5kJ10gPSB0ZXh0Lmxlbmd0aFxuICBsZXQgbiA9IHJvb3Q7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gdGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAodGV4dFtpXSA9PT0gT1BFTl9CUkFDRSkge1xuICAgICAgaWYgKCFuWydydWxlcyddKSB7XG4gICAgICAgIG5bJ3J1bGVzJ10gPSBbXTtcbiAgICAgIH1cbiAgICAgIGxldCBwID0gbjtcbiAgICAgIGxldCBwcmV2aW91cyA9IHBbJ3J1bGVzJ11bcFsncnVsZXMnXS5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgbiA9IG5ldyBTdHlsZU5vZGUoKTtcbiAgICAgIG5bJ3N0YXJ0J10gPSBpICsgMTtcbiAgICAgIG5bJ3BhcmVudCddID0gcDtcbiAgICAgIG5bJ3ByZXZpb3VzJ10gPSBwcmV2aW91cztcbiAgICAgIHBbJ3J1bGVzJ10ucHVzaChuKTtcbiAgICB9IGVsc2UgaWYgKHRleHRbaV0gPT09IENMT1NFX0JSQUNFKSB7XG4gICAgICBuWydlbmQnXSA9IGkgKyAxO1xuICAgICAgbiA9IG5bJ3BhcmVudCddIHx8IHJvb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290O1xufVxuXG4vLyBhZGQgc2VsZWN0b3JzL2Nzc1RleHQgdG8gbm9kZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7U3R5bGVOb2RlfVxuICovXG5mdW5jdGlvbiBwYXJzZUNzcyhub2RlLCB0ZXh0KSB7XG4gIGxldCB0ID0gdGV4dC5zdWJzdHJpbmcobm9kZVsnc3RhcnQnXSwgbm9kZVsnZW5kJ10gLSAxKTtcbiAgbm9kZVsncGFyc2VkQ3NzVGV4dCddID0gbm9kZVsnY3NzVGV4dCddID0gdC50cmltKCk7XG4gIGlmIChub2RlWydwYXJlbnQnXSkge1xuICAgIGxldCBzcyA9IG5vZGVbJ3ByZXZpb3VzJ10gPyBub2RlWydwcmV2aW91cyddWydlbmQnXSA6IG5vZGVbJ3BhcmVudCddWydzdGFydCddO1xuICAgIHQgPSB0ZXh0LnN1YnN0cmluZyhzcywgbm9kZVsnc3RhcnQnXSAtIDEpO1xuICAgIHQgPSBfZXhwYW5kVW5pY29kZUVzY2FwZXModCk7XG4gICAgdCA9IHQucmVwbGFjZShSWC5tdWx0aXBsZVNwYWNlcywgJyAnKTtcbiAgICAvLyBUT0RPKHNvcnZlbGwpOiBhZCBob2M7IG1ha2Ugc2VsZWN0b3IgaW5jbHVkZSBvbmx5IGFmdGVyIGxhc3QgO1xuICAgIC8vIGhlbHBzIHdpdGggbWl4aW4gc3ludGF4XG4gICAgdCA9IHQuc3Vic3RyaW5nKHQubGFzdEluZGV4T2YoJzsnKSArIDEpO1xuICAgIGxldCBzID0gbm9kZVsncGFyc2VkU2VsZWN0b3InXSA9IG5vZGVbJ3NlbGVjdG9yJ10gPSB0LnRyaW0oKTtcbiAgICBub2RlWydhdFJ1bGUnXSA9IChzLmluZGV4T2YoQVRfU1RBUlQpID09PSAwKTtcbiAgICAvLyBub3RlLCBzdXBwb3J0IGEgc3Vic2V0IG9mIHJ1bGUgdHlwZXMuLi5cbiAgICBpZiAobm9kZVsnYXRSdWxlJ10pIHtcbiAgICAgIGlmIChzLmluZGV4T2YoTUVESUFfU1RBUlQpID09PSAwKSB7XG4gICAgICAgIG5vZGVbJ3R5cGUnXSA9IHR5cGVzLk1FRElBX1JVTEU7XG4gICAgICB9IGVsc2UgaWYgKHMubWF0Y2goUlgua2V5ZnJhbWVzUnVsZSkpIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuS0VZRlJBTUVTX1JVTEU7XG4gICAgICAgIG5vZGVbJ2tleWZyYW1lc05hbWUnXSA9XG4gICAgICAgICAgbm9kZVsnc2VsZWN0b3InXS5zcGxpdChSWC5tdWx0aXBsZVNwYWNlcykucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMCkge1xuICAgICAgICBub2RlWyd0eXBlJ10gPSB0eXBlcy5NSVhJTl9SVUxFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuU1RZTEVfUlVMRTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHIkID0gbm9kZVsncnVsZXMnXTtcbiAgaWYgKHIkKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSByJC5sZW5ndGgsIHI7XG4gICAgICAoaSA8IGwpICYmIChyID0gciRbaV0pOyBpKyspIHtcbiAgICAgIHBhcnNlQ3NzKHIsIHRleHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBjb252ZXJzaW9uIG9mIHNvcnQgdW5pY29kZSBlc2NhcGVzIHdpdGggc3BhY2VzIGxpa2UgYFxcMzMgYCAoYW5kIGxvbmdlcikgaW50b1xuICogZXhwYW5kZWQgZm9ybSB0aGF0IGRvZXNuJ3QgcmVxdWlyZSB0cmFpbGluZyBzcGFjZSBgXFwwMDAwMzNgXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBfZXhwYW5kVW5pY29kZUVzY2FwZXMocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKFswLTlhLWZdezEsNn0pXFxzL2dpLCBmdW5jdGlvbigpIHtcbiAgICBsZXQgY29kZSA9IGFyZ3VtZW50c1sxXSxcbiAgICAgIHJlcGVhdCA9IDYgLSBjb2RlLmxlbmd0aDtcbiAgICB3aGlsZSAocmVwZWF0LS0pIHtcbiAgICAgIGNvZGUgPSAnMCcgKyBjb2RlO1xuICAgIH1cbiAgICByZXR1cm4gJ1xcXFwnICsgY29kZTtcbiAgfSk7XG59XG5cbi8qKlxuICogc3RyaW5naWZ5IHBhcnNlZCBjc3MuXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFuPX0gcHJlc2VydmVQcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge3N0cmluZz19IHRleHRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlLCBwcmVzZXJ2ZVByb3BlcnRpZXMsIHRleHQgPSAnJykge1xuICAvLyBjYWxjIHJ1bGUgY3NzVGV4dFxuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBpZiAobm9kZVsnY3NzVGV4dCddIHx8IG5vZGVbJ3J1bGVzJ10pIHtcbiAgICBsZXQgciQgPSBub2RlWydydWxlcyddO1xuICAgIGlmIChyJCAmJiAhX2hhc01peGluUnVsZXMociQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHIkLmxlbmd0aCwgcjtcbiAgICAgICAgKGkgPCBsKSAmJiAociA9IHIkW2ldKTsgaSsrKSB7XG4gICAgICAgIGNzc1RleHQgPSBzdHJpbmdpZnkociwgcHJlc2VydmVQcm9wZXJ0aWVzLCBjc3NUZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3NzVGV4dCA9IHByZXNlcnZlUHJvcGVydGllcyA/IG5vZGVbJ2Nzc1RleHQnXSA6XG4gICAgICAgIHJlbW92ZUN1c3RvbVByb3BzKG5vZGVbJ2Nzc1RleHQnXSk7XG4gICAgICBjc3NUZXh0ID0gY3NzVGV4dC50cmltKCk7XG4gICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICBjc3NUZXh0ID0gJyAgJyArIGNzc1RleHQgKyAnXFxuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZW1pdCBydWxlIGlmIHRoZXJlIGlzIGNzc1RleHRcbiAgaWYgKGNzc1RleHQpIHtcbiAgICBpZiAobm9kZVsnc2VsZWN0b3InXSkge1xuICAgICAgdGV4dCArPSBub2RlWydzZWxlY3RvciddICsgJyAnICsgT1BFTl9CUkFDRSArICdcXG4nO1xuICAgIH1cbiAgICB0ZXh0ICs9IGNzc1RleHQ7XG4gICAgaWYgKG5vZGVbJ3NlbGVjdG9yJ10pIHtcbiAgICAgIHRleHQgKz0gQ0xPU0VfQlJBQ0UgKyAnXFxuXFxuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxTdHlsZU5vZGU+fSBydWxlc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gX2hhc01peGluUnVsZXMocnVsZXMpIHtcbiAgbGV0IHIgPSBydWxlc1swXTtcbiAgcmV0dXJuIEJvb2xlYW4ocikgJiYgQm9vbGVhbihyWydzZWxlY3RvciddKSAmJiByWydzZWxlY3RvciddLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZW1vdmVDdXN0b21Qcm9wcyhjc3NUZXh0KSB7XG4gIGNzc1RleHQgPSByZW1vdmVDdXN0b21Qcm9wQXNzaWdubWVudChjc3NUZXh0KTtcbiAgcmV0dXJuIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQoY3NzVGV4dCkge1xuICByZXR1cm4gY3NzVGV4dFxuICAgIC5yZXBsYWNlKFJYLmN1c3RvbVByb3AsICcnKVxuICAgIC5yZXBsYWNlKFJYLm1peGluUHJvcCwgJycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KSB7XG4gIHJldHVybiBjc3NUZXh0XG4gICAgLnJlcGxhY2UoUlgubWl4aW5BcHBseSwgJycpXG4gICAgLnJlcGxhY2UoUlgudmFyQXBwbHksICcnKTtcbn1cblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5leHBvcnQgY29uc3QgdHlwZXMgPSB7XG4gIFNUWUxFX1JVTEU6IDEsXG4gIEtFWUZSQU1FU19SVUxFOiA3LFxuICBNRURJQV9SVUxFOiA0LFxuICBNSVhJTl9SVUxFOiAxMDAwXG59XG5cbmNvbnN0IE9QRU5fQlJBQ0UgPSAneyc7XG5jb25zdCBDTE9TRV9CUkFDRSA9ICd9JztcblxuLy8gaGVscGVyIHJlZ2V4cCdzXG5jb25zdCBSWCA9IHtcbiAgY29tbWVudHM6IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9naW0sXG4gIHBvcnQ6IC9AaW1wb3J0W147XSo7L2dpbSxcbiAgY3VzdG9tUHJvcDogLyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj8oPzpbO1xcbl18JCkvZ2ltLFxuICBtaXhpblByb3A6IC8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/e1tefV0qP30oPzpbO1xcbl18JCk/L2dpbSxcbiAgbWl4aW5BcHBseTogL0BhcHBseVxccypcXCg/W14pO10qXFwpP1xccyooPzpbO1xcbl18JCk/L2dpbSxcbiAgdmFyQXBwbHk6IC9bXjs6XSo/OlteO10qP3ZhclxcKFteO10qXFwpKD86WztcXG5dfCQpPy9naW0sXG4gIGtleWZyYW1lc1J1bGU6IC9eQFteXFxzXSprZXlmcmFtZXMvLFxuICBtdWx0aXBsZVNwYWNlczogL1xccysvZ1xufVxuXG5jb25zdCBWQVJfU1RBUlQgPSAnLS0nO1xuY29uc3QgTUVESUFfU1RBUlQgPSAnQG1lZGlhJztcbmNvbnN0IEFUX1NUQVJUID0gJ0AnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2Nzcy1wYXJzZS5qc1xuLy8gbW9kdWxlIGlkID0gMjFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuZXhwb3J0IGNvbnN0IFZBUl9BU1NJR04gPSAvKD86XnxbO1xcc3tdXFxzKikoLS1bXFx3LV0qPylcXHMqOlxccyooPzooKD86Jyg/OlxcXFwnfC4pKj8nfFwiKD86XFxcXFwifC4pKj9cInxcXChbXildKj9cXCl8W159O3tdKSspfFxceyhbXn1dKilcXH0oPzooPz1bO1xcc31dKXwkKSkvZ2k7XG5leHBvcnQgY29uc3QgTUlYSU5fTUFUQ0ggPSAvKD86XnxcXFcrKUBhcHBseVxccypcXCg/KFteKTtcXG5dKilcXCk/L2dpO1xuZXhwb3J0IGNvbnN0IFZBUl9DT05TVU1FRCA9IC8oLS1bXFx3LV0rKVxccyooWzosOyldfCQpL2dpO1xuZXhwb3J0IGNvbnN0IEFOSU1BVElPTl9NQVRDSCA9IC8oYW5pbWF0aW9uXFxzKjopfChhbmltYXRpb24tbmFtZVxccyo6KS87XG5leHBvcnQgY29uc3QgTUVESUFfTUFUQ0ggPSAvQG1lZGlhXFxzKC4qKS87XG5leHBvcnQgY29uc3QgSVNfVkFSID0gL14tLS87XG5leHBvcnQgY29uc3QgQlJBQ0tFVEVEID0gL1xce1tefV0qXFx9L2c7XG5leHBvcnQgY29uc3QgSE9TVF9QUkVGSVggPSAnKD86XnxbXi4jWzpdKSc7XG5leHBvcnQgY29uc3QgSE9TVF9TVUZGSVggPSAnKCR8Wy46W1xcXFxzPit+XSknO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2NvbW1vbi1yZWdleC5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBNSVhJTl9NQVRDSCwgVkFSX0FTU0lHTiB9IGZyb20gJy4vY29tbW9uLXJlZ2V4LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTmF0aXZlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gIC8vIHJlbW92ZSBwcmV2aW91cyBwcm9wZXJ0aWVzXG4gIGZvciAobGV0IHAgaW4gcHJvcGVydGllcykge1xuICAgIC8vIE5PVEU6IGZvciBiYyB3aXRoIHNoaW0sIGRvbid0IGFwcGx5IG51bGwgdmFsdWVzLlxuICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHAsIHByb3BlcnRpZXNbcF0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgLyoqXG4gICAqIEBjb25zdCB7c3RyaW5nfVxuICAgKi9cbiAgY29uc3QgdmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICB9XG59XG5cbi8qKlxuICogcmV0dXJuIHRydWUgaWYgYGNzc1RleHRgIGNvbnRhaW5zIGEgbWl4aW4gZGVmaW5pdGlvbiBvciBjb25zdW1wdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RNaXhpbihjc3NUZXh0KSB7XG4gIGNvbnN0IGhhcyA9IE1JWElOX01BVENILnRlc3QoY3NzVGV4dCkgfHwgVkFSX0FTU0lHTi50ZXN0KGNzc1RleHQpO1xuICAvLyByZXNldCBzdGF0ZSBvZiB0aGUgcmVnZXhlc1xuICBNSVhJTl9NQVRDSC5sYXN0SW5kZXggPSAwO1xuICBWQVJfQVNTSUdOLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiBoYXM7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgcm9vdFBhdGggYXMgcm9vdFBhdGgkMCB9IGZyb20gJy4uL3V0aWxzL3NldHRpbmdzLmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwJDAgZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgY2FtZWxUb0Rhc2hDYXNlIH0gZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgY3NzRnJvbU1vZHVsZUltcG9ydHMsIGNzc0Zyb21UZW1wbGF0ZSB9IGZyb20gJy4uL3V0aWxzL3N0eWxlLWdhdGhlci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlVXJsIGFzIHJlc29sdmVVcmwkMCB9IGZyb20gJy4uL3V0aWxzL3Jlc29sdmUtdXJsLmpzJztcbmltcG9ydCB7IERvbU1vZHVsZSB9IGZyb20gJy4uL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlFZmZlY3RzIH0gZnJvbSAnLi9wcm9wZXJ0eS1lZmZlY3RzLmpzJztcblxuZXhwb3J0IGNvbnN0IEVsZW1lbnRNaXhpbiA9IGRlZHVwaW5nTWl4aW4oYmFzZSA9PiB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgKi9cbiAgY29uc3QgcG9seW1lckVsZW1lbnRCYXNlID0gUHJvcGVydHlFZmZlY3RzKGJhc2UpO1xuXG4gIGxldCBjYXNlTWFwID0gY2FzZU1hcCQwO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgcHJvcGVydGllc2Agb2JqZWN0IHNwZWNpZmljYWxseSBvbiBga2xhc3NgLiBVc2UgZm9yOlxuICAgKiAoMSkgc3VwZXIgY2hhaW4gbWl4ZXMgdG9ndGhlciB0byBtYWtlIGBwcm9wZXJ0aWVzRm9yQ2xhc3NgIHdoaWNoIGlzXG4gICAqIHRoZW4gdXNlZCB0byBtYWtlIGBvYnNlcnZlZEF0dHJpYnV0ZXNgLlxuICAgKiAoMikgcHJvcGVydGllcyBlZmZlY3RzIGFuZCBvYnNlcnZlcnMgYXJlIGNyZWF0ZWQgZnJvbSBpdCBhdCBgZmluYWxpemVgIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBvd24gcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKSB7XG4gICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fb3duUHJvcGVydGllcycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fb3duUHJvcGVydGllcyA9XG4gICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ3Byb3BlcnRpZXMnLCBrbGFzcykpID9cbiAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm9wZXJ0aWVzIDoge307XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX293blByb3BlcnRpZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYG9ic2VydmVyc2AgYXJyYXkgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3JcbiAgICogc2V0dGluZyB1cCBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgb3duIG9ic2VydmVycyBmb3IgdGhpcyBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gb3duT2JzZXJ2ZXJzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25PYnNlcnZlcnMnLCBrbGFzcykpKSB7XG4gICAgICBrbGFzcy5fX293bk9ic2VydmVycyA9XG4gICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ29ic2VydmVycycsIGtsYXNzKSkgP1xuICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLm9ic2VydmVycyA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4ga2xhc3MuX19vd25PYnNlcnZlcnM7XG4gIH1cblxuICAvKipcbiAgICogTWl4ZXMgYHByb3BzYCBpbnRvIGBmbGF0dGVuZWRQcm9wc2AgYnV0IHVwZ3JhZGVzIHNob3J0aGFuZCB0eXBlXG4gICAqIHN5bnRheCB0byB7IHR5cGU6IFR5cGV9LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZmxhdHRlbmVkUHJvcHMgQmFnIHRvIGNvbGxlY3QgZmxhdHRlbmVkIHByb3BlcnRpZXMgaW50b1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgdG8gYWRkIHRvIGBmbGF0dGVuZWRQcm9wc2BcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgaW5wdXQgYGZsYXR0ZW5lZFByb3BzYCBiYWdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZsYXR0ZW5Qcm9wZXJ0aWVzKGZsYXR0ZW5lZFByb3BzLCBwcm9wcykge1xuICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgIGxldCBvID0gcHJvcHNbcF07XG4gICAgICBpZiAodHlwZW9mIG8gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvID0geyB0eXBlOiBvIH07XG4gICAgICB9XG4gICAgICBmbGF0dGVuZWRQcm9wc1twXSA9IG87XG4gICAgfVxuICAgIHJldHVybiBmbGF0dGVuZWRQcm9wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmxhdHRlbmVkIGxpc3Qgb2YgcHJvcGVydGllcyBtaXhlZCB0b2dldGhlciBmcm9tIHRoZSBjaGFpbiBvZiBhbGxcbiAgICogY29uc3RydWN0b3IncyBgY29uZmlnLnByb3BlcnRpZXNgLiBUaGlzIGxpc3QgaXMgdXNlZCB0byBjcmVhdGVcbiAgICogKDEpIG9ic2VydmVkQXR0cmlidXRlcyxcbiAgICogKDIpIGNsYXNzIHByb3BlcnR5IGRlZmF1bHQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgYSBwcm9wZXJ0eSBmb3Igc29tZSByZWFzb24/XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnRpZXMnLCBrbGFzcykpKSB7XG4gICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyA9XG4gICAgICBmbGF0dGVuUHJvcGVydGllcyh7fSwgb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKSk7XG4gICAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGtsYXNzLnByb3RvdHlwZSkuY29uc3RydWN0b3I7XG4gICAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXNGb3JDbGFzcygvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyhzdXBlckN0b3IpKSksXG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2xhc3MuX19jbGFzc1Byb3BlcnRpZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgcHJvcGVydGllcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgKiBUaGlzIGxpc3QgaXMgY3JlYXRlZCBhcyBhbiBvcHRpbWl6YXRpb24gc2luY2UgaXQgaXMgYSBzdWJzZXQgb2ZcbiAgICogdGhlIGxpc3QgcmV0dXJuZWQgZnJvbSBgcHJvcGVydGllc0ZvckNsYXNzYC5cbiAgICogVGhpcyBsaXN0IGlzIHVzZWQgaW4gYF9pbml0aWFsaXplUHJvcGVydGllc2AgdG8gc2V0IHByb3BlcnR5IGRlZmF1bHRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7UG9seW1lckVsZW1lbnRQcm9wZXJ0aWVzfSBGbGF0dGVuZWQgcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgKiAgIHRoYXQgaGF2ZSBkZWZhdWx0IHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcHJvcGVydHlEZWZhdWx0c0ZvckNsYXNzKGtsYXNzKSB7XG4gICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fY2xhc3NQcm9wZXJ0eURlZmF1bHRzJywga2xhc3MpKSkge1xuICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgPSBudWxsO1xuICAgICAgbGV0IHByb3BzID0gcHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKTtcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgbGV0IGluZm8gPSBwcm9wc1twXTtcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gaW5mbykge1xuICAgICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzID0ga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgfHwge307XG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHNbcF0gPSBpbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBga2xhc3NgIGhhcyBmaW5hbGl6ZWQuIENhbGxlZCBpbiBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFsbCBtZXRhcHJvZ3JhbW1pbmcgZm9yIHRoaXMgY2xhc3MgaGFzIGJlZW5cbiAgICogICBjb21wbGV0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGhhc0NsYXNzRmluYWxpemVkKGtsYXNzKSB7XG4gICAgcmV0dXJuIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZmluYWxpemVkJywga2xhc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYnkgYEVsZW1lbnRDbGFzcy5maW5hbGl6ZSgpYC4gRW5zdXJlcyB0aGlzIGBrbGFzc2AgYW5kXG4gICAqICphbGwgc3VwZXJjbGFzc2VzKiBhcmUgZmluYWxpemVkIGJ5IHRyYXZlcnNpbmcgdGhlIHByb3RvdHlwZSBjaGFpblxuICAgKiBhbmQgY2FsbGluZyBga2xhc3MuZmluYWxpemUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVDbGFzc0FuZFN1cGVyKGtsYXNzKSB7XG4gICAgbGV0IHByb3RvID0gLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm90b3R5cGU7XG4gICAgbGV0IHN1cGVyQ3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykuY29uc3RydWN0b3I7XG4gICAgaWYgKHN1cGVyQ3Rvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBQb2x5bWVyRWxlbWVudCkge1xuICAgICAgc3VwZXJDdG9yLmZpbmFsaXplKCk7XG4gICAgfVxuICAgIGZpbmFsaXplQ2xhc3Moa2xhc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBga2xhc3NgIGJhc2VkIG9uIGEgc3RhaWMgYGtsYXNzLmNvbmZpZ2Agb2JqZWN0IGFuZFxuICAgKiBhIGB0ZW1wbGF0ZWAuIFRoaXMgaW5jbHVkZXMgY3JlYXRpbmcgYWNjZXNzb3JzIGFuZCBlZmZlY3RzXG4gICAqIGZvciBwcm9wZXJ0aWVzIGluIGBjb25maWdgIGFuZCB0aGUgYHRlbXBsYXRlYCBhcyB3ZWxsIGFzIHByZXBhcmluZyB0aGVcbiAgICogYHRlbXBsYXRlYCBmb3Igc3RhbXBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVDbGFzcyhrbGFzcykge1xuICAgIGtsYXNzLl9fZmluYWxpemVkID0gdHJ1ZTtcbiAgICBsZXQgcHJvdG8gPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3RvdHlwZTtcbiAgICBpZiAoa2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdpcycsIGtsYXNzKSkgJiYga2xhc3MuaXMpIHtcbiAgICAgIHJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG4gICAgbGV0IHByb3BzID0gb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZpbmFsaXplUHJvcGVydGllcyhwcm90bywgcHJvcHMpO1xuICAgIH1cbiAgICBsZXQgb2JzZXJ2ZXJzID0gb3duT2JzZXJ2ZXJzRm9yQ2xhc3Moa2xhc3MpO1xuICAgIGlmIChvYnNlcnZlcnMpIHtcbiAgICAgIGZpbmFsaXplT2JzZXJ2ZXJzKHByb3RvLCBvYnNlcnZlcnMsIHByb3BzKTtcbiAgICB9XG4gICAgLy8gbm90ZTogY3JlYXRlIFwid29ya2luZ1wiIHRlbXBsYXRlIHRoYXQgaXMgZmluYWxpemVkIGF0IGluc3RhbmNlIHRpbWVcbiAgICBsZXQgdGVtcGxhdGUgPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0LmlubmVySFRNTCA9IHRlbXBsYXRlO1xuICAgICAgICB0ZW1wbGF0ZSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHByb3RvLl90ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGEgYHByb3RvYCBiYXNlZCBvbiBhIGBwcm9wZXJ0aWVzYCBvYmplY3QuXG4gICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzXG4gICAqIHN1cHBvcnRpbmcsIG9ic2VydmVycywgcmVmbGVjdGluZyB0byBhdHRyaWJ1dGVzLCBjaGFuZ2Ugbm90aWZpY2F0aW9uLFxuICAgKiBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgcmVhZCBvbmx5IHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICogICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgRmxhdHRlbmVkIGJhZyBvZiBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBmb3JcbiAgICogICAgdGhpcyBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChsZXQgcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIHAsIHByb3BlcnRpZXNbcF0sIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGEgYHByb3RvYCBiYXNlZCBvbiBhIGBvYnNlcnZlcnNgIGFycmF5LlxuICAgKiBMZXZlcmFnZXMgYFByb3BlcnR5RWZmZWN0c2AgdG8gY3JlYXRlIG9ic2VydmVycy5cbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlcnMgRmxhdHRlbmVkIGFycmF5IG9mIG9ic2VydmVyIGRlc2NyaXB0b3JzIGZvclxuICAgKiAgIHRoaXMgY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IGR5bmFtaWNGbnMgT2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgYW55IHByb3BlcnRpZXNcbiAgICogICB0aGF0IGFyZSBmdW5jdGlvbnMgYW5kIHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3Qgd2hlbiB0aGUgZnVuY3Rpb25cbiAgICogICByZWZlcmVuY2UgaXMgY2hhbmdlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgZHluYW1pY0Zucykge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IG9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvdG8uX2NyZWF0ZU1ldGhvZE9ic2VydmVyKG9ic2VydmVyc1tpXSwgZHluYW1pY0Zucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgZWZmZWN0cyBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogTm90ZSwgb25jZSBhIHByb3BlcnR5IGhhcyBiZWVuIHNldCB0b1xuICAgKiBgcmVhZE9ubHlgLCBgY29tcHV0ZWRgLCBgcmVmbGVjdFRvQXR0cmlidXRlYCwgb3IgYG5vdGlmeWBcbiAgICogdGhlc2UgdmFsdWVzIG1heSBub3QgYmUgY2hhbmdlZC4gRm9yIGV4YW1wbGUsIGEgc3ViY2xhc3MgY2Fubm90XG4gICAqIGFsdGVyIHRoZXNlIHNldHRpbmdzLiBIb3dldmVyLCBhZGRpdGlvbmFsIGBvYnNlcnZlcnNgIG1heSBiZSBhZGRlZFxuICAgKiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBUaGUgaW5mbyBvYmplY3Qgc2hvdWxkIG1heSBjb250YWluIHByb3BlcnR5IG1ldGFkYXRhIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqICogYHR5cGVgOiB7ZnVuY3Rpb259IHR5cGUgdG8gd2hpY2ggYW4gYXR0cmlidXRlIG1hdGNoaW5nIHRoZSBwcm9wZXJ0eVxuICAgKiBpcyBkZXNlcmlhbGl6ZWQuIE5vdGUgdGhlIHByb3BlcnR5IGlzIGNhbWVsLWNhc2VkIGZyb20gYSBkYXNoLWNhc2VkXG4gICAqIGF0dHJpYnV0ZS4gRm9yIGV4YW1wbGUsICdmb28tYmFyJyBhdHRyaWJ1dGUgaXMgZGVyc2lhbGl6ZWQgdG8gYVxuICAgKiBwcm9wZXJ0eSBuYW1lZCAnZm9vQmFyJy5cbiAgICpcbiAgICogKiBgcmVhZE9ubHlgOiB7Ym9vbGVhbn0gY3JlYXRlcyBhIHJlYWRPbmx5IHByb3BlcnR5IGFuZFxuICAgKiBtYWtlcyBhIHByaXZhdGUgc2V0dGVyIGZvciB0aGUgcHJpdmF0ZSBvZiB0aGUgZm9ybSAnX3NldEZvbycgZm9yIGFcbiAgICogcHJvcGVydHkgJ2ZvbycsXG4gICAqXG4gICAqICogYGNvbXB1dGVkYDoge3N0cmluZ30gY3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBBIGNvbXB1dGVkIHByb3BlcnR5XG4gICAqIGFsc28gYXV0b21hdGljYWxseSBpcyBzZXQgdG8gYHJlYWRPbmx5OiB0cnVlYC4gVGhlIHZhbHVlIGlzIGNhbGN1bGF0ZWRcbiAgICogYnkgcnVubmluZyBhIG1ldGhvZCBhbmQgYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuIEZvclxuICAgKiBleGFtcGxlICdjb21wdXRlKGZvbyknIHdpbGwgY29tcHV0ZSBhIGdpdmVuIHByb3BlcnR5IHdoZW4gdGhlXG4gICAqICdmb28nIHByb3BlcnR5IGNoYW5nZXMgYnkgZXhlY3V0aW5nIHRoZSAnY29tcHV0ZScgbWV0aG9kLiBUaGlzIG1ldGhvZFxuICAgKiBtdXN0IHJldHVybiB0aGUgY29tcHV0ZWQgdmFsdWUuXG4gICAqXG4gICAqICogYHJlZmxlY3RUb0F0dHJpdXRlYDoge2Jvb2xlYW59IElmIHRydWUsIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZWZsZWN0ZWRcbiAgICogdG8gYW4gYXR0cmlidXRlIG9mIHRoZSBzYW1lIG5hbWUuIE5vdGUsIHRoZSBhdHRyaWJ1dGUgaXMgZGFzaC1jYXNlZFxuICAgKiBzbyBhIHByb3BlcnR5IG5hbWVkICdmb29CYXInIGlzIHJlZmxlY3RlZCBhcyAnZm9vLWJhcicuXG4gICAqXG4gICAqICogYG5vdGlmeWA6IHtib29sZWFufSBzZW5kcyBhIG5vbi1idWJibGluZyBub3RpZmljYXRpb24gZXZlbnQgd2hlblxuICAgKiB0aGUgcHJvcGVydHkgY2hhbmdlcy4gRm9yIGV4YW1wbGUsIGEgcHJvcGVydHkgbmFtZWQgJ2Zvbycgc2VuZHMgYW5cbiAgICogZXZlbnQgbmFtZWQgJ2Zvby1jaGFuZ2VkJyB3aXRoIGBldmVudC5kZXRhaWxgIHNldCB0byB0aGUgdmFsdWUgb2ZcbiAgICogdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiAqIG9ic2VydmVyOiB7c3RyaW5nfSBuYW1lIG9mIGEgbWV0aG9kIHRoYXQgcnVucyB3aGVuIHRoZSBwcm9wZXJ0eVxuICAgKiBjaGFuZ2VzLiBUaGUgYXJndW1lbnRzIG9mIHRoZSBtZXRob2QgYXJlICh2YWx1ZSwgcHJldmlvdXNWYWx1ZSkuXG4gICAqXG4gICAqIE5vdGU6IFVzZXJzIG1heSB3YW50IGNvbnRyb2wgb3ZlciBtb2RpZnlpbmcgcHJvcGVydHlcbiAgICogZWZmZWN0cyB2aWEgc3ViY2xhc3NpbmcuIEZvciBleGFtcGxlLCBhIHVzZXIgbWlnaHQgd2FudCB0byBtYWtlIGFcbiAgICogcmVmbGVjdFRvQXR0cmlidXRlIHByb3BlcnR5IG5vdCBkbyBzbyBpbiBhIHN1YmNsYXNzLiBXZSd2ZSBjaG9zZW4gdG9cbiAgICogZGlzYWJsZSB0aGlzIGJlY2F1c2UgaXQgbGVhZHMgdG8gYWRkaXRpb25hbCBjb21wbGljYXRpb24uXG4gICAqIEZvciBleGFtcGxlLCBhIHJlYWRPbmx5IGVmZmVjdCBnZW5lcmF0ZXMgYSBzcGVjaWFsIHNldHRlci4gSWYgYSBzdWJjbGFzc1xuICAgKiBkaXNhYmxlcyB0aGUgZWZmZWN0LCB0aGUgc2V0dGVyIHdvdWxkIGZhaWwgdW5leHBlY3RlZGx5LlxuICAgKiBCYXNlZCBvbiBmZWVkYmFjaywgd2UgbWF5IHdhbnQgdG8gdHJ5IHRvIG1ha2UgZWZmZWN0cyBtb3JlIG1hbGxlYWJsZVxuICAgKiBhbmQvb3IgcHJvdmlkZSBhbiBhZHZhbmNlZCBhcGkgZm9yIG1hbmlwdWxhdGluZyB0aGVtLlxuICAgKiBBbHNvIGNvbnNpZGVyIGFkZGluZyB3YXJuaW5ncyB3aGVuIGFuIGVmZmVjdCBjYW5ub3QgYmUgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyBJbmZvIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNyZWF0ZSBwcm9wZXJ0eSBlZmZlY3RzLlxuICAgKiBTdXBwb3J0ZWQga2V5czpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFsbFByb3BzIEZsYXR0ZW5lZCBtYXAgb2YgYWxsIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGlzXG4gICAqICAgZWxlbWVudCAoaW5jbHVkaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlGcm9tQ29uZmlnKHByb3RvLCBuYW1lLCBpbmZvLCBhbGxQcm9wcykge1xuICAgIC8vIGNvbXB1dGVkIGZvcmNlcyByZWFkT25seS4uLlxuICAgIGlmIChpbmZvLmNvbXB1dGVkKSB7XG4gICAgICBpbmZvLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gTm90ZSwgc2luY2UgYWxsIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIHJlYWRPbmx5LCB0aGlzIHByZXZlbnRzXG4gICAgLy8gYWRkaW5nIGFkZGl0aW9uYWwgY29tcHV0ZWQgcHJvcGVydHkgZWZmZWN0cyAod2hpY2ggbGVhZHMgdG8gYSBjb25mdXNpbmdcbiAgICAvLyBzZXR1cCB3aGVyZSBtdWx0aXBsZSB0cmlnZ2VycyBmb3Igc2V0dGluZyBhIHByb3BlcnR5KVxuICAgIC8vIFdoaWxlIHdlIGRvIGhhdmUgYGhhc0NvbXB1dGVkRWZmZWN0YCB0aGlzIGlzIHNldCBvbiB0aGUgcHJvcGVydHknc1xuICAgIC8vIGRlcGVuZGVuY2llcyByYXRoZXIgdGhhbiBpdHNlbGYuXG4gICAgaWYgKGluZm8uY29tcHV0ZWQgICYmICFwcm90by5faGFzUmVhZE9ubHlFZmZlY3QobmFtZSkpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVDb21wdXRlZFByb3BlcnR5KG5hbWUsIGluZm8uY29tcHV0ZWQsIGFsbFByb3BzKTtcbiAgICB9XG4gICAgaWYgKGluZm8ucmVhZE9ubHkgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkobmFtZSwgIWluZm8uY29tcHV0ZWQpO1xuICAgIH1cbiAgICBpZiAoaW5mby5yZWZsZWN0VG9BdHRyaWJ1dGUgJiYgIXByb3RvLl9oYXNSZWZsZWN0RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIGlmIChpbmZvLm5vdGlmeSAmJiAhcHJvdG8uX2hhc05vdGlmeUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICAvLyBhbHdheXMgYWRkIG9ic2VydmVyXG4gICAgaWYgKGluZm8ub2JzZXJ2ZXIpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKG5hbWUsIGluZm8ub2JzZXJ2ZXIsIGFsbFByb3BzW2luZm8ub2JzZXJ2ZXJdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyBhbiBlbGVtZW50IGBwcm90b2AgdG8gZnVuY3Rpb24gd2l0aCBhIGdpdmVuIGB0ZW1wbGF0ZWAuXG4gICAqIFRoZSBlbGVtZW50IG5hbWUgYGlzYCBhbmQgZXh0ZW5kcyBgZXh0YCBtdXN0IGJlIHNwZWNpZmllZCBmb3IgU2hhZHlDU1NcbiAgICogc3R5bGUgc2NvcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHByb2Nlc3MgYW5kIGJpbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgVVJMIGFnYWluc3Qgd2hpY2ggdG8gcmVzb2x2ZSB1cmxzIGluXG4gICAqICAgc3R5bGUgZWxlbWVudCBjc3NUZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpcyBUYWcgbmFtZSAob3IgdHlwZSBleHRlbnNpb24gbmFtZSkgZm9yIHRoaXMgZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZz19IGV4dCBGb3IgdHlwZSBleHRlbnNpb25zLCB0aGUgdGFnIG5hbWUgdGhhdCB3YXMgZXh0ZW5kZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmFsaXplVGVtcGxhdGUocHJvdG8sIHRlbXBsYXRlLCBiYXNlVVJJLCBpcywgZXh0KSB7XG4gICAgLy8gc3VwcG9ydCBgaW5jbHVkZT1cIm1vZHVsZS1uYW1lXCJgXG4gICAgbGV0IGNzc1RleHQgPVxuICAgICAgY3NzRnJvbU1vZHVsZUltcG9ydHMoaXMpICtcbiAgICAgIGNzc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSk7XG4gICAgaWYgKGNzc1RleHQpIHtcbiAgICAgIGxldCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9IGNzc1RleHQ7XG4gICAgICB0ZW1wbGF0ZS5jb250ZW50Lmluc2VydEJlZm9yZShzdHlsZSwgdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgaXMsIGV4dCk7XG4gICAgfVxuICAgIHByb3RvLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgKi9cbiAgY2xhc3MgUG9seW1lckVsZW1lbnQgZXh0ZW5kcyBwb2x5bWVyRWxlbWVudEJhc2Uge1xuXG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzIFYxIEFQSS4gIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnNcbiAgICAgKiBhIGxpc3Qgb2YgZGFzaC1jYXNlZCBhdHRyaWJ1dGVzIGJhc2VkIG9uIGEgZmxhdHRlbmluZyBvZiBhbGwgcHJvcGVydGllc1xuICAgICAqIGRlY2xhcmVkIGluIGBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKWAgZm9yIHRoaXMgZWxlbWVudCBhbmQgYW55XG4gICAgICogc3VwZXJjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IE9ic2VydmVkIGF0dHJpYnV0ZSBsaXN0XG4gICAgICovXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vYnNlcnZlZEF0dHJpYnV0ZXMnLCB0aGlzKSkpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgbGV0IHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcyk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIGxpc3QucHVzaChjYW1lbFRvRGFzaENhc2UocHJvcCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXMgPSBsaXN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgZmlyc3QgZWxlbWVudCBpbnN0YW5jZSBpcyBjcmVhdGVkIHRvXG4gICAgICogZW5zdXJlIHRoYXQgY2xhc3MgZmluYWxpemF0aW9uIHdvcmsgaGFzIGJlZW4gY29tcGxldGVkLlxuICAgICAqIE1heSBiZSBjYWxsZWQgYnkgdXNlcnMgdG8gZWFnZXJseSBwZXJmb3JtIGNsYXNzIGZpbmFsaXphdGlvbiB3b3JrXG4gICAgICogcHJpb3IgdG8gdGhlIGNyZWF0aW9uIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQ2xhc3MgZmluYWxpemF0aW9uIHdvcmsgZ2VuZXJhbGx5IGluY2x1ZGVzIG1ldGEtcHJvZ3JhbW1pbmcgc3VjaCBhc1xuICAgICAqIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgYW55IHByb3BlcnR5IGVmZmVjdCBtZXRhZGF0YSBuZWVkZWQgZm9yXG4gICAgICogdGhlIGZlYXR1cmVzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgaWYgKCFoYXNDbGFzc0ZpbmFsaXplZCh0aGlzKSkge1xuICAgICAgICBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHN0YW1wZWQgaW50byB0aGlzIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKlxuICAgICAqIElmIGEgYHN0YXRpYyBnZXQgaXMoKWAgZ2V0dGVyIGlzIGRlZmluZWQsIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICogd2lsbCByZXR1cm4gdGhlIGZpcnN0IGA8dGVtcGxhdGU+YCBpbiBhIGBkb20tbW9kdWxlYCB3aG9zZSBgaWRgXG4gICAgICogbWF0Y2hlcyB0aGlzIGVsZW1lbnQncyBgaXNgLlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgZ2V0dGVyIHRvIHJldHVybiBhbiBhcmJpdHJhcnkgdGVtcGxhdGVcbiAgICAgKiAoaW4gd2hpY2ggY2FzZSB0aGUgYGlzYCBnZXR0ZXIgaXMgdW5uZWNlc3NhcnkpLiBUaGUgdGVtcGxhdGUgcmV0dXJuZWRcbiAgICAgKiBtYXkgYmUgZWl0aGVyIGFuIGBIVE1MVGVtcGxhdGVFbGVtZW50YCBvciBhIHN0cmluZyB0aGF0IHdpbGwgYmVcbiAgICAgKiBhdXRvbWF0aWNhbGx5IHBhcnNlZCBpbnRvIGEgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2hlbiBzdWJjbGFzc2luZywgaWYgdGhlIHN1cGVyIGNsYXNzIG92ZXJyb2RlIHRoZSBkZWZhdWx0XG4gICAgICogaW1wbGVtZW50YXRpb24gYW5kIHRoZSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIHByb3ZpZGUgYW4gYWx0ZXJuYXRlXG4gICAgICogdGVtcGxhdGUgdmlhIGEgYGRvbS1tb2R1bGVgLCBpdCBzaG91bGQgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgYW5kXG4gICAgICogcmV0dXJuIGBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQodGhpcy5pcywgJ3RlbXBsYXRlJylgLlxuICAgICAqXG4gICAgICogSWYgYSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIG1vZGlmeSB0aGUgc3VwZXIgY2xhc3MgdGVtcGxhdGUsIGl0IHNob3VsZFxuICAgICAqIGNsb25lIGl0IHJhdGhlciB0aGFuIG1vZGlmeSBpdCBpbiBwbGFjZS4gIElmIHRoZSBnZXR0ZXIgZG9lcyBleHBlbnNpdmVcbiAgICAgKiB3b3JrIHN1Y2ggYXMgY2xvbmluZy9tb2RpZnlpbmcgYSB0ZW1wbGF0ZSwgaXQgc2hvdWxkIG1lbW9pemUgdGhlXG4gICAgICogdGVtcGxhdGUgZm9yIG1heGltdW0gcGVyZm9ybWFuY2U6XG4gICAgICpcbiAgICAgKiAgIGxldCBtZW1vaXplZFRlbXBsYXRlO1xuICAgICAqICAgY2xhc3MgTXlTdWJDbGFzcyBleHRlbmRzIE15U3VwZXJDbGFzcyB7XG4gICAgICogICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICogICAgICAgaWYgKCFtZW1vaXplZFRlbXBsYXRlKSB7XG4gICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlID0gc3VwZXIudGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgICAgICAgbGV0IHN1YkNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgKiAgICAgICAgIHN1YkNvbnRlbnQudGV4dENvbnRlbnQgPSAnVGhpcyBjYW1lIGZyb20gTXlTdWJDbGFzcyc7XG4gICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc3ViQ29udGVudCk7XG4gICAgICogICAgICAgfVxuICAgICAqICAgICAgIHJldHVybiBtZW1vaXplZFRlbXBsYXRlO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MVGVtcGxhdGVFbGVtZW50fHN0cmluZ30gVGVtcGxhdGUgdG8gYmUgc3RhbXBlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX3RlbXBsYXRlJywgdGhpcykpKSB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gRG9tTW9kdWxlICYmIERvbU1vZHVsZS5pbXBvcnQoXG4gICAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykuaXMsICd0ZW1wbGF0ZScpIHx8XG4gICAgICAgICAgLy8gbm90ZTogaW1wbGVtZW50ZWQgc28gYSBzdWJjbGFzcyBjYW4gcmV0cmlldmUgdGhlIHN1cGVyXG4gICAgICAgICAgLy8gdGVtcGxhdGU7IGNhbGwgdGhlIHN1cGVyIGltcGwgdGhpcyB3YXkgc28gdGhhdCBgdGhpc2AgcG9pbnRzXG4gICAgICAgICAgLy8gdG8gdGhlIHN1cGVyY2xhc3MuXG4gICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yKi8gKHRoaXMpLnByb3RvdHlwZSkuY29uc3RydWN0b3IudGVtcGxhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0aCBtYXRjaGluZyB0aGUgdXJsIGZyb20gd2hpY2ggdGhlIGVsZW1lbnQgd2FzIGltcG9ydGVkLlxuICAgICAqIFRoaXMgcGF0aCBpcyB1c2VkIHRvIHJlc29sdmUgdXJsJ3MgaW4gdGVtcGxhdGUgc3R5bGUgY3NzVGV4dC5cbiAgICAgKiBUaGUgYGltcG9ydFBhdGhgIHByb3BlcnR5IGlzIGFsc28gc2V0IG9uIGVsZW1lbnQgaW5zdGFuY2VzIGFuZCBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIGNyZWF0ZSBiaW5kaW5ncyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IHBhdGguXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIHBhdGggbWF0Y2hpbmcgdGhlIHVybCBjb250YWluaW5nIGEgYGRvbS1tb2R1bGVgIGVsZW1lbnRcbiAgICAgKiBtYXRjaGluZyB0aGlzIGVsZW1lbnQncyBzdGF0aWMgYGlzYCBwcm9wZXJ0eS5cbiAgICAgKiBOb3RlLCB0aGlzIHBhdGggc2hvdWxkIGNvbnRhaW4gYSB0cmFpbGluZyBgL2AuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBpbXBvcnQgcGF0aCBmb3IgdGhpcyBlbGVtZW50IGNsYXNzXG4gICAgICovXG4gICAgc3RhdGljIGdldCBpbXBvcnRQYXRoKCkge1xuICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19pbXBvcnRQYXRoJywgdGhpcykpKSB7XG4gICAgICAgICAgY29uc3QgbW9kdWxlID0gRG9tTW9kdWxlICYmIERvbU1vZHVsZS5pbXBvcnQoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKHRoaXMpLmlzKTtcbiAgICAgICAgICB0aGlzLl9pbXBvcnRQYXRoID0gbW9kdWxlID8gbW9kdWxlLmFzc2V0cGF0aCA6ICcnIHx8XG4gICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yKi8gKHRoaXMpLnByb3RvdHlwZSkuY29uc3RydWN0b3IuaW1wb3J0UGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9pbXBvcnRQYXRoO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi9cbiAgICAgIHRoaXMuX3RlbXBsYXRlO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLl9pbXBvcnRQYXRoO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLnJvb3RQYXRoO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLmltcG9ydFBhdGg7XG4gICAgICAvKiogQHR5cGUge1N0YW1wZWRUZW1wbGF0ZSB8IEhUTUxFbGVtZW50IHwgU2hhZG93Um9vdH0gKi9cbiAgICAgIHRoaXMucm9vdDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFOb2RlPn0gKi9cbiAgICAgIHRoaXMuJDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIHRvIGVuc3VyZSBjbGFzc1xuICAgICAqIG1ldGFwcm9ncmFtbWluZyByZWxhdGVkIHRvIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgZWZmZWN0cyBoYXNcbiAgICAgKiBjb21wbGV0ZWQgKGNhbGxzIGBmaW5hbGl6ZWApLlxuICAgICAqXG4gICAgICogSXQgYWxzbyBpbml0aWFsaXplcyBhbnkgcHJvcGVydHkgZGVmYXVsdHMgcHJvdmlkZWQgdmlhIGB2YWx1ZWAgaW5cbiAgICAgKiBgcHJvcGVydGllc2AgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpbnN0YW5jZUNvdW50Kys7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmZpbmFsaXplKCk7XG4gICAgICBjb25zdCBpbXBvcnRQYXRoID0gdGhpcy5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgLy8gbm90ZTogZmluYWxpemUgdGVtcGxhdGUgd2hlbiB3ZSBoYXZlIGFjY2VzcyB0byBgbG9jYWxOYW1lYCB0b1xuICAgICAgLy8gYXZvaWQgZGVwZW5kZW5jZSBvbiBgaXNgIGZvciBwb2x5ZmlsbGluZyBzdHlsaW5nLlxuICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlICYmICF0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuX19wb2x5bWVyRmluYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgYmFzZVVSSSA9XG4gICAgICAgICAgaW1wb3J0UGF0aCA/IHJlc29sdmVVcmwkMChpbXBvcnRQYXRoKSA6ICcnO1xuICAgICAgICBmaW5hbGl6ZVRlbXBsYXRlKC8qKiBAdHlwZSB7IVBvbHltZXJFbGVtZW50fSAqLyh0aGlzLl9fcHJvdG9fXyksIHRoaXMuX3RlbXBsYXRlLCBiYXNlVVJJLFxuICAgICAgICAgIC8qKkB0eXBlIHshSFRNTEVsZW1lbnR9Ki8odGhpcykubG9jYWxOYW1lKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgLy8gc2V0IHBhdGggZGVmYXVsdHNcbiAgICAgIHRoaXMucm9vdFBhdGggPSByb290UGF0aCQwO1xuICAgICAgdGhpcy5pbXBvcnRQYXRoID0gaW1wb3J0UGF0aDtcbiAgICAgIC8vIGFwcGx5IHByb3BlcnR5IGRlZmF1bHRzLi4uXG4gICAgICBsZXQgcCQgPSBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3ModGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICBpZiAoIXAkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHAgaW4gcCQpIHtcbiAgICAgICAgbGV0IGluZm8gPSBwJFtwXTtcbiAgICAgICAgLy8gRG9uJ3Qgc2V0IGRlZmF1bHQgdmFsdWUgaWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBvd24gcHJvcGVydHksIHdoaWNoXG4gICAgICAgIC8vIGhhcHBlbnMgd2hlbiBhIGBwcm9wZXJ0aWVzYCBwcm9wZXJ0eSB3aXRoIGRlZmF1bHQgYnV0IG5vIGVmZmVjdHMgaGFkXG4gICAgICAgIC8vIGEgcHJvcGVydHkgc2V0IChlLmcuIGJvdW5kKSBieSBpdHMgaG9zdCBiZWZvcmUgdXBncmFkZVxuICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB0eXBlb2YgaW5mby52YWx1ZSA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIGluZm8udmFsdWUuY2FsbCh0aGlzKSA6XG4gICAgICAgICAgICBpbmZvLnZhbHVlO1xuICAgICAgICAgIC8vIFNldCB2aWEgYF9zZXRQcm9wZXJ0eWAgaWYgdGhlcmUgaXMgYW4gYWNjZXNzb3IsIHRvIGVuYWJsZVxuICAgICAgICAgIC8vIGluaXRpYWxpemluZyByZWFkT25seSBwcm9wZXJ0eSBkZWZhdWx0c1xuICAgICAgICAgIGlmICh0aGlzLl9oYXNBY2Nlc3NvcihwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1twXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGNvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGVuYWJsZXMgdGhlIHByb3BlcnR5IGVmZmVjdHMgc3lzdGVtIGFuZFxuICAgICAqIGZsdXNoZXMgYW55IHBlbmRpbmcgcHJvcGVydGllcywgYW5kIHVwZGF0ZXMgc2hpbW1lZCBDU1MgcHJvcGVydGllc1xuICAgICAqIHdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcvY3VzdG9tIHByb3BlcnRpZXMgcG9seWZpbGwuXG4gICAgICpcbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MgJiYgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRWxlbWVudCgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcykpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGRpc2Nvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBTdGFtcHMgdGhlIGVsZW1lbnQgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRoaXMuX3RlbXBsYXRlKTtcbiAgICAgICAgdGhpcy4kID0gdGhpcy5yb290LiQ7XG4gICAgICB9XG4gICAgICBzdXBlci5yZWFkeSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5RWZmZWN0c2AncyBgX3JlYWR5Q2xpZW50c2AgY2FsbC4gQXR0YWNoZXNcbiAgICAgKiBlbGVtZW50IGRvbSBieSBjYWxsaW5nIGBfYXR0YWNoRG9tYCB3aXRoIHRoZSBkb20gc3RhbXBlZCBmcm9tIHRoZVxuICAgICAqIGVsZW1lbnQncyB0ZW1wbGF0ZSB2aWEgYF9zdGFtcFRlbXBsYXRlYC4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzXG4gICAgICogY2xpZW50IGRvbSB0byBiZSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCBwcmlvciB0byBhbnkgb2JzZXJ2ZXJzXG4gICAgICogcnVubmluZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9yZWFkeUNsaWVudHMoKSB7XG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5fYXR0YWNoRG9tKC8qKiBAdHlwZSB7U3RhbXBlZFRlbXBsYXRlfSAqLyh0aGlzLnJvb3QpKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBzdXBlci5fcmVhZHlDbGllbnRzIGhlcmUgc2V0cyB0aGUgY2xpZW50cyBpbml0aWFsaXplZCBmbGFnLlxuICAgICAgLy8gV2UgbXVzdCB3YWl0IHRvIGRvIHRoaXMgdW50aWwgYWZ0ZXIgY2xpZW50IGRvbSBpcyBjcmVhdGVkL2F0dGFjaGVkXG4gICAgICAvLyBzbyB0aGF0IHRoaXMgZmxhZyBjYW4gYmUgY2hlY2tlZCB0byBwcmV2ZW50IG5vdGlmaWNhdGlvbnMgZmlyZWRcbiAgICAgIC8vIGR1cmluZyB0aGlzIHByb2Nlc3MgZnJvbSBiZWluZyBoYW5kbGVkIGJlZm9yZSBjbGllbnRzIGFyZSByZWFkeS5cbiAgICAgIHN1cGVyLl9yZWFkeUNsaWVudHMoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGFuIGVsZW1lbnQncyBzdGFtcGVkIGRvbSB0byBpdHNlbGYuIEJ5IGRlZmF1bHQsXG4gICAgICogdGhpcyBtZXRob2QgY3JlYXRlcyBhIGBzaGFkb3dSb290YCBhbmQgYWRkcyB0aGUgZG9tIHRvIGl0LlxuICAgICAqIEhvd2V2ZXIsIHRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFsbG93IGFuIGVsZW1lbnRcbiAgICAgKiB0byBwdXQgaXRzIGRvbSBpbiBhbm90aGVyIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUmV0dXJufVxuICAgICAqIEBwYXJhbSB7U3RhbXBlZFRlbXBsYXRlfSBkb20gdG8gYXR0YWNoIHRvIHRoZSBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge1NoYWRvd1Jvb3R9IG5vZGUgdG8gd2hpY2ggdGhlIGRvbSBoYXMgYmVlbiBhdHRhY2hlZC5cbiAgICAgKi9cbiAgICBfYXR0YWNoRG9tKGRvbSkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoU2hhZG93KSB7XG4gICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkb3dSb290O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkb3dET00gbm90IGF2YWlsYWJsZS4gJyArXG4gICAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogbW92ZSB0byBjb21waWxlLXRpbWUgY29uZGl0aW9uYWwgd2hlbiBzdXBwb3J0ZWRcbiAgICAgICAgJ1BvbHltZXIuRWxlbWVudCBjYW4gY3JlYXRlIGRvbSBhcyBjaGlsZHJlbiBpbnN0ZWFkIG9mIGluICcgK1xuICAgICAgICAnU2hhZG93RE9NIGJ5IHNldHRpbmcgYHRoaXMucm9vdCA9IHRoaXM7XFxgIGJlZm9yZSBcXGByZWFkeVxcYC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHN0YW5kYXJkIEN1c3RvbSBFbGVtZW50c1xuICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgYXR0cmlidXRlcyBkZWNsYXJlZCBpbiBgcHJvcGVydGllc2AgbWV0YWRhdGEgYXJlXG4gICAgICogZGVzZXJpYWxpemVkIHVzaW5nIHRoZWlyIGB0eXBlYCBpbmZvcm1hdGlvbiB0byBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgICAqIHNhbWUgbmFtZS4gIFwiRGFzaC1jYXNlZFwiIGF0dHJpYnV0ZXMgYXJlIGRlc2VyaWFsemVkIHRvIFwiY2FtZWxDYXNlXCJcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICBsZXQgcHJvcGVydHkgPSBjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgbGV0IHR5cGUgPSBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcy5jb25zdHJ1Y3RvcilbcHJvcGVydHldLnR5cGU7XG4gICAgICAgIGlmICghdGhpcy5faGFzUmVhZE9ubHlFZmZlY3QocHJvcGVydHkpKSB7XG4gICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIHRoZSBTaGFkeUNTUyBzY29waW5nIGFuZCBjdXN0b20gcHJvcGVydHkgc2hpbSwgY2F1c2VzIGFsbFxuICAgICAqIHNoaW1tZWQgc3R5bGVzIGluIHRoaXMgZWxlbWVudCAoYW5kIGl0cyBzdWJ0cmVlKSB0byBiZSB1cGRhdGVkXG4gICAgICogYmFzZWQgb24gY3VycmVudCBjdXN0b20gcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhlIG9wdGlvbmFsIHBhcmFtZXRlciBvdmVycmlkZXMgaW5saW5lIGN1c3RvbSBwcm9wZXJ0eSBzdHlsZXMgd2l0aCBhblxuICAgICAqIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHdoZXJlIHRoZSBrZXlzIGFyZSBDU1MgcHJvcGVydGllcywgYW5kIHRoZSB2YWx1ZXNcbiAgICAgKiBhcmUgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6IGB0aGlzLnVwZGF0ZVN0eWxlcyh7Jy0tY29sb3InOiAnYmx1ZSd9KWBcbiAgICAgKlxuICAgICAqIFRoZXNlIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIHVubGVzcyBhIHZhbHVlIG9mIGBudWxsYCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgQmFnIG9mIGN1c3RvbSBwcm9wZXJ0eSBrZXkvdmFsdWVzIHRvXG4gICAgICogICBhcHBseSB0byB0aGlzIGVsZW1lbnQuXG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICovXG4gICAgdXBkYXRlU3R5bGVzKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlU3VidHJlZSgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcyksIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJld3JpdGVzIGEgZ2l2ZW4gVVJMIHJlbGF0aXZlIHRvIGEgYmFzZSBVUkwuIFRoZSBiYXNlIFVSTCBkZWZhdWx0cyB0b1xuICAgICAqIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGUgZG9jdW1lbnQgY29udGFpbmluZyB0aGUgYGRvbS1tb2R1bGVgIGZvclxuICAgICAqIHRoaXMgZWxlbWVudC4gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWUgVVJMIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAgKiBidW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBiYXNlIE9wdGlvbmFsIGJhc2UgVVJMIHRvIHJlc29sdmUgYWdhaW5zdCwgZGVmYXVsdHNcbiAgICAgKiB0byB0aGUgZWxlbWVudCdzIGBpbXBvcnRQYXRoYFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV3cml0dGVuIFVSTCByZWxhdGl2ZSB0byBiYXNlXG4gICAgICovXG4gICAgcmVzb2x2ZVVybCh1cmwsIGJhc2UpIHtcbiAgICAgIGlmICghYmFzZSAmJiB0aGlzLmltcG9ydFBhdGgpIHtcbiAgICAgICAgYmFzZSA9IHJlc29sdmVVcmwkMCh0aGlzLmltcG9ydFBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmVVcmwkMCh1cmwsIGJhc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcnNgIHRvIGFkZCBtYXAgb2YgZHluYW1pYyBmdW5jdGlvbnMgb25cbiAgICAgKiB0ZW1wbGF0ZSBpbmZvLCBmb3IgY29uc3VtcHRpb24gYnkgYFByb3BlcnR5RWZmZWN0c2AgdGVtcGxhdGUgYmluZGluZ1xuICAgICAqIGNvZGUuIFRoaXMgbWFwIGRldGVybWluZXMgd2hpY2ggbWV0aG9kIHRlbXBsYXRlcyBzaG91bGQgaGF2ZSBhY2Nlc3NvcnNcbiAgICAgKiBjcmVhdGVkIGZvciB0aGVtLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyB8fCBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcyk7XG4gICAgICByZXR1cm4gc3VwZXIuX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBQb2x5bWVyRWxlbWVudDtcbn0pO1xuXG5leHBvcnQgbGV0IGluc3RhbmNlQ291bnQgPSAwO1xuZXhwb3J0IGNvbnN0IHJlZ2lzdHJhdGlvbnMgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9yZWdMb2cocHJvdG90eXBlKSB7XG4gIGNvbnNvbGUubG9nKCdbJyArIHByb3RvdHlwZS5pcyArICddOiByZWdpc3RlcmVkJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlcihwcm90b3R5cGUpIHtcbiAgcmVnaXN0cmF0aW9ucy5wdXNoKHByb3RvdHlwZSk7XG4gIHVuZGVmaW5lZCAmJiBfcmVnTG9nKHByb3RvdHlwZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkdW1wUmVnaXN0cmF0aW9ucygpIHtcbiAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKF9yZWdMb2cpO1xufVxuXG5leHBvcnQgY29uc3QgdXBkYXRlU3R5bGVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZURvY3VtZW50KHByb3BzKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmpzXG4vLyBtb2R1bGUgaWQgPSAyNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVVybCwgcGF0aEZyb21VcmwgfSBmcm9tICcuLi91dGlscy9yZXNvbHZlLXVybC5qcyc7XG5cbmxldCBtb2R1bGVzID0ge307XG5sZXQgbGNNb2R1bGVzID0ge307XG5mdW5jdGlvbiBmaW5kTW9kdWxlKGlkKSB7XG4gIHJldHVybiBtb2R1bGVzW2lkXSB8fCBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV07XG59XG5cbmZ1bmN0aW9uIHN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2soaW5zdCkge1xuICBpZiAoaW5zdC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKSB7XG4gICAgY29uc29sZS53YXJuKCdkb20tbW9kdWxlICVzIGhhcyBzdHlsZSBvdXRzaWRlIHRlbXBsYXRlJywgaW5zdC5pZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYGRvbS1tb2R1bGVgIGVsZW1lbnQgcmVnaXN0ZXJzIHRoZSBkb20gaXQgY29udGFpbnMgdG8gdGhlIG5hbWUgZ2l2ZW5cbiAqIGJ5IHRoZSBtb2R1bGUncyBpZCBhdHRyaWJ1dGUuIEl0IHByb3ZpZGVzIGEgdW5pZmllZCBkYXRhYmFzZSBvZiBkb21cbiAqIGFjY2Vzc2libGUgdmlhIGl0cyBzdGF0aWMgYGltcG9ydGAgQVBJLlxuICpcbiAqIEEga2V5IHVzZSBjYXNlIG9mIGBkb20tbW9kdWxlYCBpcyBmb3IgcHJvdmlkaW5nIGN1c3RvbSBlbGVtZW50IGA8dGVtcGxhdGU+YHNcbiAqIHZpYSBIVE1MIGltcG9ydHMgdGhhdCBhcmUgcGFyc2VkIGJ5IHRoZSBuYXRpdmUgSFRNTCBwYXJzZXIsIHRoYXQgY2FuIGJlXG4gKiByZWxvY2F0ZWQgZHVyaW5nIGEgYnVuZGxpbmcgcGFzcyBhbmQgc3RpbGwgbG9va2VkIHVwIGJ5IGBpZGAuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgPGRvbS1tb2R1bGUgaWQ9XCJmb29cIj5cbiAqICAgICAgIDxpbWcgc3JjPVwic3R1ZmYucG5nXCI+XG4gKiAgICAgPC9kb20tbW9kdWxlPlxuICpcbiAqIFRoZW4gaW4gY29kZSBpbiBzb21lIG90aGVyIGxvY2F0aW9uIHRoYXQgY2Fubm90IGFjY2VzcyB0aGUgZG9tLW1vZHVsZSBhYm92ZVxuICpcbiAqICAgICBsZXQgaW1nID0gY3VzdG9tRWxlbWVudHMuZ2V0KCdkb20tbW9kdWxlJykuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBhIHJlZ2lzdHJ5IG9mIHJlbG9jYXRhYmxlIERPTSBjb250ZW50XG4gKiAgIGJ5IGBpZGAgdGhhdCBpcyBhZ25vc3RpYyB0byBidW5kbGluZy5cbiAqIEB1bnJlc3RyaWN0ZWRcbiAqL1xuY2xhc3MgRG9tTW9kdWxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkgeyByZXR1cm4gWydpZCddOyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgZWxlbWVudCBzcGVjaWZpZWQgYnkgdGhlIGNzcyBgc2VsZWN0b3JgIGluIHRoZSBtb2R1bGVcbiAgICogcmVnaXN0ZXJlZCBieSBgaWRgLiBGb3IgZXhhbXBsZSwgdGhpcy5pbXBvcnQoJ2ZvbycsICdpbWcnKTtcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgZG9tLW1vZHVsZSBpbiB3aGljaCB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gc2VsZWN0b3IgVGhlIGNzcyBzZWxlY3RvciBieSB3aGljaCB0byBmaW5kIHRoZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBlbGVtZW50IHdoaWNoIG1hdGNoZXMgYHNlbGVjdG9yYCBpbiB0aGVcbiAgICogbW9kdWxlIHJlZ2lzdGVyZWQgYXQgdGhlIHNwZWNpZmllZCBgaWRgLlxuICAgKi9cbiAgc3RhdGljIGltcG9ydChpZCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGxldCBtID0gZmluZE1vZHVsZShpZCk7XG4gICAgICBpZiAobSAmJiBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFic29sdXRlIFVSTCBvZiB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhpcyBgZG9tLW1vZHVsZWAuXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgd2lsbCBkaWZmZXIgZnJvbSB0aGlzIGVsZW1lbnQncyBgb3duZXJEb2N1bWVudGAgaW4gdGhlXG4gICAqIGZvbGxvd2luZyB3YXlzOlxuICAgKiAtIFRha2VzIGludG8gYWNjb3VudCBhbnkgYGFzc2V0cGF0aGAgYXR0cmlidXRlIGFkZGVkIGR1cmluZyBidW5kbGluZ1xuICAgKiAgIHRvIGluZGljYXRlIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgYnVuZGxlZCBsb2NhdGlvblxuICAgKiAtIFVzZXMgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsJ3MgYGltcG9ydEZvckVsZW1lbnRgIEFQSSB0byBlbnN1cmVcbiAgICogICB0aGUgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IGRvY3VtZW50J3MgbG9jYXRpb24gc2luY2VcbiAgICogICBgb3duZXJEb2N1bWVudGAgaXMgbm90IGN1cnJlbnRseSBwb2x5ZmlsbGVkXG4gICAqL1xuICBnZXQgYXNzZXRwYXRoKCkge1xuICAgIC8vIERvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFzc2V0cGF0aC5cbiAgICBpZiAoIXRoaXMuX19hc3NldHBhdGgpIHtcbiAgICAgIC8vIG5vdGU6IGFzc2V0cGF0aCBzZXQgdmlhIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoaXNcbiAgICAgIC8vIGVsZW1lbnQncyBsb2NhdGlvbjsgYWNjb21vZGF0ZSBwb2x5ZmlsbGVkIEhUTUxJbXBvcnRzXG4gICAgICBjb25zdCBvd25lciA9IHdpbmRvdy5IVE1MSW1wb3J0cyAmJiBIVE1MSW1wb3J0cy5pbXBvcnRGb3JFbGVtZW50ID9cbiAgICAgICAgSFRNTEltcG9ydHMuaW1wb3J0Rm9yRWxlbWVudCh0aGlzKSB8fCBkb2N1bWVudCA6IHRoaXMub3duZXJEb2N1bWVudDtcbiAgICAgIGNvbnN0IHVybCA9IHJlc29sdmVVcmwoXG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdhc3NldHBhdGgnKSB8fCAnJywgb3duZXIuYmFzZVVSSSk7XG4gICAgICB0aGlzLl9fYXNzZXRwYXRoID0gcGF0aEZyb21VcmwodXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19hc3NldHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIHRoZSBkb20tbW9kdWxlIGF0IGEgZ2l2ZW4gaWQuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZFxuICAgKiB3aGVuIGEgZG9tLW1vZHVsZSBpcyBpbXBlcmF0aXZlbHkgY3JlYXRlZC4gRm9yXG4gICAqIGV4YW1wbGUsIGBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkb20tbW9kdWxlJykucmVnaXN0ZXIoJ2ZvbycpYC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBpZCBUaGUgaWQgYXQgd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGRvbS1tb2R1bGUuXG4gICAqL1xuICByZWdpc3RlcihpZCkge1xuICAgIGlkID0gaWQgfHwgdGhpcy5pZDtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgIC8vIHN0b3JlIGlkIHNlcGFyYXRlIGZyb20gbG93ZXJjYXNlZCBpZCBzbyB0aGF0XG4gICAgICAvLyBpbiBhbGwgY2FzZXMgbWl4ZWRDYXNlIGlkIHdpbGwgc3RvcmVkIGRpc3RpbmN0bHlcbiAgICAgIC8vIGFuZCBsb3dlcmNhc2UgdmVyc2lvbiBpcyBhIGZhbGxiYWNrXG4gICAgICBtb2R1bGVzW2lkXSA9IHRoaXM7XG4gICAgICBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xuICAgICAgc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuRG9tTW9kdWxlLnByb3RvdHlwZVsnbW9kdWxlcyddID0gbW9kdWxlcztcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdkb20tbW9kdWxlJywgRG9tTW9kdWxlKTtcblxuZXhwb3J0IHsgRG9tTW9kdWxlIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IHJvb3QgYXMgcm9vdCQwLCBpc0FuY2VzdG9yLCBpc0Rlc2NlbmRhbnQsIGdldCBhcyBnZXQkMCwgdHJhbnNsYXRlLCBpc1BhdGggYXMgaXNQYXRoJDAsIHNldCBhcyBzZXQkMCwgbm9ybWFsaXplIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwIGZyb20gJy4uL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IGNhbWVsVG9EYXNoQ2FzZSBhcyBjYW1lbFRvRGFzaENhc2UkMCwgZGFzaFRvQ2FtZWxDYXNlIH0gZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlBY2Nlc3NvcnMgfSBmcm9tICcuL3Byb3BlcnR5LWFjY2Vzc29ycy5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVN0YW1wIH0gZnJvbSAnLi90ZW1wbGF0ZS1zdGFtcC5qcyc7XG5pbXBvcnQgeyBzYW5pdGl6ZURPTVZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuXG4vKiogQGNvbnN0IHtPYmplY3R9ICovXG5jb25zdCBDYXNlTWFwID0gY2FzZU1hcDtcblxuLy8gTW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHVuaXF1ZSBJRCB1c2VkIGZvciBkZS1kdXBpbmcgZWZmZWN0cyB0cmlnZ2VyZWRcbi8vIGZyb20gbXVsdGlwbGUgcHJvcGVydGllcyBpbiB0aGUgc2FtZSB0dXJuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIFByb3BlcnR5IGVmZmVjdCB0eXBlczsgZWZmZWN0cyBhcmUgc3RvcmVkIG9uIHRoZSBwcm90b3R5cGUgdXNpbmcgdGhlc2Uga2V5c1xuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVFlQRVMgPSB7XG4gIENPTVBVVEU6ICdfX2NvbXB1dGVFZmZlY3RzJyxcbiAgUkVGTEVDVDogJ19fcmVmbGVjdEVmZmVjdHMnLFxuICBOT1RJRlk6ICdfX25vdGlmeUVmZmVjdHMnLFxuICBQUk9QQUdBVEU6ICdfX3Byb3BhZ2F0ZUVmZmVjdHMnLFxuICBPQlNFUlZFOiAnX19vYnNlcnZlRWZmZWN0cycsXG4gIFJFQURfT05MWTogJ19fcmVhZE9ubHknXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBuYW1lOiAoc3RyaW5nIHwgdW5kZWZpbmVkKSxcbiAqIHN0cnVjdHVyZWQ6IChib29sZWFuIHwgdW5kZWZpbmVkKSxcbiAqIHdpbGRjYXJkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBEYXRhVHJpZ2dlcjsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIGluZm86ID8sXG4gKiB0cmlnZ2VyOiAoIURhdGFUcmlnZ2VyIHwgdW5kZWZpbmVkKSxcbiAqIGZuOiAoIUZ1bmN0aW9uIHwgdW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IERhdGFFZmZlY3Q7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5sZXQgUHJvcGVydHlFZmZlY3RzVHlwZTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IHRoZSBtb2RlbCBoYXMgYW4gb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFRoZSBtb2RlbCBtYXkgYmUgYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuXG4gKlxuICogUHJvcGVydHkgZWZmZWN0cyBhcmUgc3RvcmVkIGFzIGFycmF5cyBvZiBlZmZlY3RzIGJ5IHByb3BlcnR5IGluIGEgbWFwLFxuICogYnkgbmFtZWQgdHlwZSBvbiB0aGUgbW9kZWwuIGUuZy5cbiAqXG4gKiAgIF9fY29tcHV0ZUVmZmVjdHM6IHtcbiAqICAgICBmb286IFsgLi4uIF0sXG4gKiAgICAgYmFyOiBbIC4uLiBdXG4gKiAgIH1cbiAqXG4gKiBJZiB0aGUgbW9kZWwgZG9lcyBub3QgeWV0IGhhdmUgYW4gZWZmZWN0IG1hcCBmb3IgdGhlIHR5cGUsIG9uZSBpcyBjcmVhdGVkXG4gKiBhbmQgcmV0dXJuZWQuICBJZiBpdCBkb2VzLCBidXQgaXQgaXMgbm90IGFuIG93biBwcm9wZXJ0eSAoaS5lLiB0aGVcbiAqIHByb3RvdHlwZSBoYWQgZWZmZWN0cyksIHRoZSB0aGUgbWFwIGlzIGRlZXBseSBjbG9uZWQgYW5kIHRoZSBjb3B5IGlzXG4gKiBzZXQgb24gdGhlIG1vZGVsIGFuZCByZXR1cm5lZCwgcmVhZHkgZm9yIG5ldyBlZmZlY3RzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFByb3BlcnR5IGVmZmVjdCB0eXBlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvd24tcHJvcGVydHkgbWFwIG9mIGVmZmVjdHMgZm9yIHRoZSBnaXZlbiB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnN1cmVPd25FZmZlY3RNYXAobW9kZWwsIHR5cGUpIHtcbiAgbGV0IGVmZmVjdHMgPSBtb2RlbFt0eXBlXTtcbiAgaWYgKCFlZmZlY3RzKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0ge307XG4gIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0gT2JqZWN0LmNyZWF0ZShtb2RlbFt0eXBlXSk7XG4gICAgZm9yIChsZXQgcCBpbiBlZmZlY3RzKSB7XG4gICAgICBsZXQgcHJvdG9GeCA9IGVmZmVjdHNbcF07XG4gICAgICBsZXQgaW5zdEZ4ID0gZWZmZWN0c1twXSA9IEFycmF5KHByb3RvRngubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxwcm90b0Z4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluc3RGeFtpXSA9IHByb3RvRnhbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlZmZlY3RzO1xufVxuXG4vLyAtLSBlZmZlY3RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBSdW5zIGFsbCBlZmZlY3RzIG9mIGEgZ2l2ZW4gdHlwZSBmb3IgdGhlIGdpdmVuIHNldCBvZiBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdD19IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVmZmVjdCByYW4gZm9yIHRoaXMgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkVmZmVjdHMoaW5zdCwgZWZmZWN0cywgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSB7XG4gIGlmIChlZmZlY3RzKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIGxldCBpZCA9IGRlZHVwZUlkKys7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgaWYgKHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBlZmZlY3RzLCBpZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSkge1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSdW5zIGEgbGlzdCBvZiBlZmZlY3RzIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3RzIE9iamVjdCBtYXAgb2YgcHJvcGVydHktdG8tQXJyYXkgb2YgZWZmZWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGRlZHVwZUlkIENvdW50ZXIgdXNlZCBmb3IgZGUtZHVwaW5nIGVmZmVjdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIE5hbWUgb2YgY2hhbmdlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHsqfSBwcm9wcyBDaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Kn0gb2xkUHJvcHMgT2xkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0geyo9fSBleHRyYUFyZ3MgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBwYXNzIHRvIGVmZmVjdCBmdW5jdGlvblxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlZmZlY3QgcmFuIGZvciB0aGlzIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZWZmZWN0cywgZGVkdXBlSWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykge1xuICBsZXQgcmFuID0gZmFsc2U7XG4gIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IHJvb3QkMChwcm9wKSA6IHByb3A7XG4gIGxldCBmeHMgPSBlZmZlY3RzW3Jvb3RQcm9wZXJ0eV07XG4gIGlmIChmeHMpIHtcbiAgICBmb3IgKGxldCBpPTAsIGw9ZnhzLmxlbmd0aCwgZng7IChpPGwpICYmIChmeD1meHNbaV0pOyBpKyspIHtcbiAgICAgIGlmICgoIWZ4LmluZm8gfHwgZnguaW5mby5sYXN0UnVuICE9PSBkZWR1cGVJZCkgJiZcbiAgICAgICAgICAoIWhhc1BhdGhzIHx8IHBhdGhNYXRjaGVzVHJpZ2dlcihwcm9wLCBmeC50cmlnZ2VyKSkpIHtcbiAgICAgICAgaWYgKGZ4LmluZm8pIHtcbiAgICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBkZWR1cGVJZDtcbiAgICAgICAgfVxuICAgICAgICBmeC5mbihpbnN0LCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGZ4LmluZm8sIGhhc1BhdGhzLCBleHRyYUFyZ3MpO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmFuO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHByb3BlcnR5L3BhdGggdGhhdCBoYXMgY2hhbmdlZCBtYXRjaGVzIHRoZSB0cmlnZ2VyXG4gKiBjcml0ZXJpYSBmb3IgYW4gZWZmZWN0LiAgQSB0cmlnZ2VyIGlzIGEgZGVzY3JpcHRvciB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHN0cnVjdHVyZSwgd2hpY2ggbWF0Y2hlcyB0aGUgZGVzY3JpcHRvcnMgcmV0dXJuZWQgZnJvbSBgcGFyc2VBcmdgLlxuICogZS5nLiBmb3IgYGZvby5iYXIuKmA6XG4gKiBgYGBcbiAqIHRyaWdnZXI6IHtcbiAqICAgbmFtZTogJ2EuYicsXG4gKiAgIHN0cnVjdHVyZWQ6IHRydWUsXG4gKiAgIHdpbGRjYXJkOiB0cnVlXG4gKiB9XG4gKiBgYGBcbiAqIElmIG5vIHRyaWdnZXIgaXMgZ2l2ZW4sIHRoZSBwYXRoIGlzIGRlZW1lZCB0byBtYXRjaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIG9yIHByb3BlcnR5IHRoYXQgY2hhbmdlZFxuICogQHBhcmFtIHtEYXRhVHJpZ2dlcn0gdHJpZ2dlciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwYXRoIG1hdGNoZWQgdGhlIHRyaWdnZXJcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoZXNUcmlnZ2VyKHBhdGgsIHRyaWdnZXIpIHtcbiAgaWYgKHRyaWdnZXIpIHtcbiAgICBsZXQgdHJpZ2dlclBhdGggPSB0cmlnZ2VyLm5hbWU7XG4gICAgcmV0dXJuICh0cmlnZ2VyUGF0aCA9PSBwYXRoKSB8fFxuICAgICAgKHRyaWdnZXIuc3RydWN0dXJlZCAmJiBpc0FuY2VzdG9yKHRyaWdnZXJQYXRoLCBwYXRoKSkgfHxcbiAgICAgICh0cmlnZ2VyLndpbGRjYXJkICYmIGlzRGVzY2VuZGFudCh0cmlnZ2VyUGF0aCwgcGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJvYnNlcnZlclwiIGVmZmVjdC5cbiAqXG4gKiBDYWxscyB0aGUgbWV0aG9kIHdpdGggYGluZm8ubWV0aG9kTmFtZWAgb24gdGhlIGluc3RhbmNlLCBwYXNzaW5nIHRoZVxuICogbmV3IGFuZCBvbGQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuT2JzZXJ2ZXJFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICBsZXQgZm4gPSBpbnN0W2luZm8ubWV0aG9kTmFtZV07XG4gIGxldCBjaGFuZ2VkUHJvcCA9IGluZm8ucHJvcGVydHk7XG4gIGlmIChmbikge1xuICAgIGZuLmNhbGwoaW5zdCwgaW5zdC5fX2RhdGFbY2hhbmdlZFByb3BdLCBvbGRQcm9wc1tjaGFuZ2VkUHJvcF0pO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2Fybignb2JzZXJ2ZXIgbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgXCJub3RpZnlcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogd2lsbCBkaXNwYXRjaCBwYXRoIG5vdGlmaWNhdGlvbiBldmVudHMgaW4gdGhlIGNhc2UgdGhhdCB0aGUgcHJvcGVydHlcbiAqIGNoYW5nZWQgd2FzIGEgcGF0aCBhbmQgdGhlIHJvb3QgcHJvcGVydHkgZm9yIHRoYXQgcGF0aCBkaWRuJ3QgaGF2ZSBhXG4gKiBcIm5vdGlmeVwiIGVmZmVjdC4gIFRoaXMgaXMgdG8gbWFpbnRhaW4gMS4wIGJlaGF2aW9yIHRoYXQgZGlkIG5vdCByZXF1aXJlXG4gKiBgbm90aWZ5OiB0cnVlYCB0byBlbnN1cmUgb2JqZWN0IHN1Yi1wcm9wZXJ0eSBub3RpZmljYXRpb25zIHdlcmVcbiAqIHNlbnQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICogQHBhcmFtIHtPYmplY3R9IG5vdGlmeVByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIHRvIG5vdGlmeVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdHMoaW5zdCwgbm90aWZ5UHJvcHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgLy8gTm90aWZ5XG4gIGxldCBmeHMgPSBpbnN0W1RZUEVTLk5PVElGWV07XG4gIGxldCBub3RpZmllZDtcbiAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgLy8gVHJ5IG5vcm1hbCBub3RpZnkgZWZmZWN0czsgaWYgbm9uZSwgZmFsbCBiYWNrIHRvIHRyeSBwYXRoIG5vdGlmaWNhdGlvblxuICBmb3IgKGxldCBwcm9wIGluIG5vdGlmeVByb3BzKSB7XG4gICAgaWYgKG5vdGlmeVByb3BzW3Byb3BdKSB7XG4gICAgICBpZiAoZnhzICYmIHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBmeHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgICBub3RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGhhc1BhdGhzICYmIG5vdGlmeVBhdGgoaW5zdCwgcHJvcCwgcHJvcHMpKSB7XG4gICAgICAgIG5vdGlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRmx1c2ggaG9zdCBpZiB3ZSBhY3R1YWxseSBub3RpZmllZCBhbmQgaG9zdCB3YXMgYmF0Y2hpbmdcbiAgLy8gQW5kIHRoZSBob3N0IGhhcyBhbHJlYWR5IGluaXRpYWxpemVkIGNsaWVudHM7IHRoaXMgcHJldmVudHNcbiAgLy8gYW4gaXNzdWUgd2l0aCBhIGhvc3Qgb2JzZXJ2aW5nIGRhdGEgY2hhbmdlcyBiZWZvcmUgY2xpZW50cyBhcmUgcmVhZHkuXG4gIGxldCBob3N0O1xuICBpZiAobm90aWZpZWQgJiYgKGhvc3QgPSBpbnN0Ll9fZGF0YUhvc3QpICYmIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKSB7XG4gICAgaG9zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoZXMge3Byb3BlcnR5fS1jaGFuZ2VkIGV2ZW50cyB3aXRoIHBhdGggaW5mb3JtYXRpb24gaW4gdGhlIGRldGFpbFxuICogb2JqZWN0IHRvIGluZGljYXRlIGEgc3ViLXBhdGggb2YgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdGhhdCB3YXMgY2hhbmdlZFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0aCB3YXMgbm90aWZpZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVBhdGgoaW5zdCwgcGF0aCwgcHJvcHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IHJvb3QkMChwYXRoKTtcbiAgaWYgKHJvb3RQcm9wZXJ0eSAhPT0gcGF0aCkge1xuICAgIGxldCBldmVudE5hbWUgPSBjYW1lbFRvRGFzaENhc2UkMChyb290UHJvcGVydHkpICsgJy1jaGFuZ2VkJztcbiAgICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgcHJvcHNbcGF0aF0sIHBhdGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgdG8gaW5kaWNhdGUgYSBwcm9wZXJ0eSAob3IgcGF0aClcbiAqIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kICgne3Byb3BlcnR5fS1jaGFuZ2VkJylcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBjaGFuZ2VkIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHBhdGggSWYgYSBzdWItcGF0aCBvZiB0aGlzIHByb3BlcnR5IGNoYW5nZWQsIHRoZSBwYXRoXG4gKiAgIHRoYXQgY2hhbmdlZCAob3B0aW9uYWwpLlxuICogQHByaXZhdGVcbiAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpIHtcbiAgbGV0IGRldGFpbCA9IHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcXVldWVQcm9wZXJ0eTogdHJ1ZVxuICB9O1xuICBpZiAocGF0aCkge1xuICAgIGRldGFpbC5wYXRoID0gcGF0aDtcbiAgfVxuICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oaW5zdCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCB9KSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJub3RpZnlcIiBlZmZlY3QuXG4gKlxuICogRGlzcGF0Y2hlcyBhIG5vbi1idWJibGluZyBldmVudCBuYW1lZCBgaW5mby5ldmVudE5hbWVgIG9uIHRoZSBpbnN0YW5jZVxuICogd2l0aCBhIGRldGFpbCBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gcm9vdCQwKHByb3BlcnR5KSA6IHByb3BlcnR5O1xuICBsZXQgcGF0aCA9IHJvb3RQcm9wZXJ0eSAhPSBwcm9wZXJ0eSA/IHByb3BlcnR5IDogbnVsbDtcbiAgbGV0IHZhbHVlID0gcGF0aCA/IGdldCQwKGluc3QsIHBhdGgpIDogaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAocGF0aCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBwcm9wc1twcm9wZXJ0eV07ICAvLyBzcGVjaWZpY2FsbHkgZm9yIC5zcGxpY2VzXG4gIH1cbiAgZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBpbmZvLmV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZnVuY3Rpb24gZm9yIDItd2F5IG5vdGlmaWNhdGlvbiBldmVudHMuIFJlY2VpdmVzIGNvbnRleHRcbiAqIGluZm9ybWF0aW9uIGNhcHR1cmVkIGluIHRoZSBgYWRkTm90aWZ5TGlzdGVuZXJgIGNsb3N1cmUgZnJvbSB0aGVcbiAqIGBfX25vdGlmeUxpc3RlbmVyc2AgbWV0YWRhdGEuXG4gKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG5vdGlmaWVkIHByb3BlcnR5IHRvIHRoZSBob3N0IHByb3BlcnR5IG9yIHBhdGguICBJZlxuICogdGhlIGV2ZW50IGNvbnRhaW5lZCBwYXRoIGluZm9ybWF0aW9uLCB0cmFuc2xhdGUgdGhhdCBwYXRoIHRvIHRoZSBob3N0XG4gKiBzY29wZSdzIG5hbWUgZm9yIHRoYXQgcGF0aCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudCBOb3RpZmljYXRpb24gZXZlbnQgKGUuZy4gJzxwcm9wZXJ0eT4tY2hhbmdlZCcpXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSBoYW5kbGluZyB0aGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZnJvbVByb3AgQ2hpbGQgZWxlbWVudCBwcm9wZXJ0eSB0aGF0IHdhcyBib3VuZFxuICogQHBhcmFtIHtzdHJpbmd9IHRvUGF0aCBIb3N0IHByb3BlcnR5L3BhdGggdGhhdCB3YXMgYm91bmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVnYXRlIFdoZXRoZXIgdGhlIGJpbmRpbmcgd2FzIG5lZ2F0ZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbihldmVudCwgaW5zdCwgZnJvbVByb3AsIHRvUGF0aCwgbmVnYXRlKSB7XG4gIGxldCB2YWx1ZTtcbiAgbGV0IGRldGFpbCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhldmVudC5kZXRhaWwpO1xuICBsZXQgZnJvbVBhdGggPSBkZXRhaWwgJiYgZGV0YWlsLnBhdGg7XG4gIGlmIChmcm9tUGF0aCkge1xuICAgIHRvUGF0aCA9IHRyYW5zbGF0ZShmcm9tUHJvcCwgdG9QYXRoLCBmcm9tUGF0aCk7XG4gICAgdmFsdWUgPSBkZXRhaWwgJiYgZGV0YWlsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZXZlbnQudGFyZ2V0W2Zyb21Qcm9wXTtcbiAgfVxuICB2YWx1ZSA9IG5lZ2F0ZSA/ICF2YWx1ZSA6IHZhbHVlO1xuICBpZiAoIWluc3RbVFlQRVMuUkVBRF9PTkxZXSB8fCAhaW5zdFtUWVBFUy5SRUFEX09OTFldW3RvUGF0aF0pIHtcbiAgICBpZiAoaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHRvUGF0aCwgdmFsdWUsIHRydWUsIEJvb2xlYW4oZnJvbVBhdGgpKVxuICAgICAgJiYgKCFkZXRhaWwgfHwgIWRldGFpbC5xdWV1ZVByb3BlcnR5KSkge1xuICAgICAgaW5zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcInJlZmxlY3RcIiBlZmZlY3QuXG4gKlxuICogU2V0cyB0aGUgYXR0cmlidXRlIG5hbWVkIGBpbmZvLmF0dHJOYW1lYCB0byB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5SZWZsZWN0RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgbGV0IHZhbHVlID0gaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAoc2FuaXRpemVET01WYWx1ZSkge1xuICAgIHZhbHVlID0gc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgaW5mby5hdHRyTmFtZSwgJ2F0dHJpYnV0ZScsIC8qKiBAdHlwZSB7Tm9kZX0gKi8oaW5zdCkpO1xuICB9XG4gIGluc3QuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGluZm8uYXR0ck5hbWUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSdW5zIFwiY29tcHV0ZWRcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogY29udGludWVzIHRvIHJ1biBjb21wdXRlZCBlZmZlY3RzIGJhc2VkIG9uIHRoZSBvdXRwdXQgb2YgZWFjaCBwYXNzIHVudGlsXG4gKiB0aGVyZSBhcmUgbm8gbW9yZSBuZXdseSBjb21wdXRlZCBwcm9wZXJ0aWVzLiAgVGhpcyBlbnN1cmVzIHRoYXQgYWxsXG4gKiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBieSB0aGUgaW5pdGlhbCBzZXQgb2YgY2hhbmdlcyBhcmVcbiAqIGNvbXB1dGVkIGJlZm9yZSBvdGhlciBlZmZlY3RzIChiaW5kaW5nIHByb3BhZ2F0aW9uLCBvYnNlcnZlcnMsIGFuZCBub3RpZnkpXG4gKiBydW4uXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHshT2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0cyhpbnN0LCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICBsZXQgY29tcHV0ZUVmZmVjdHMgPSBpbnN0W1RZUEVTLkNPTVBVVEVdO1xuICBpZiAoY29tcHV0ZUVmZmVjdHMpIHtcbiAgICBsZXQgaW5wdXRQcm9wcyA9IGNoYW5nZWRQcm9wcztcbiAgICB3aGlsZSAocnVuRWZmZWN0cyhpbnN0LCBjb21wdXRlRWZmZWN0cywgaW5wdXRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihvbGRQcm9wcywgaW5zdC5fX2RhdGFPbGQpO1xuICAgICAgT2JqZWN0LmFzc2lnbihjaGFuZ2VkUHJvcHMsIGluc3QuX19kYXRhUGVuZGluZyk7XG4gICAgICBpbnB1dFByb3BzID0gaW5zdC5fX2RhdGFQZW5kaW5nO1xuICAgICAgaW5zdC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcImNvbXB1dGVkIHByb3BlcnR5XCIgZWZmZWN0IGJ5IHJ1bm5pbmcgdGhlIG1ldGhvZCB3aXRoIHRoZVxuICogdmFsdWVzIG9mIHRoZSBhcmd1bWVudHMgc3BlY2lmaWVkIGluIHRoZSBgaW5mb2Agb2JqZWN0IGFuZCBzZXR0aW5nIHRoZVxuICogcmV0dXJuIHZhbHVlIHRvIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Db21wdXRlZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIGxldCByZXN1bHQgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbyk7XG4gIGxldCBjb21wdXRlZFByb3AgPSBpbmZvLm1ldGhvZEluZm87XG4gIGlmIChpbnN0Ll9fZGF0YUhhc0FjY2Vzc29yICYmIGluc3QuX19kYXRhSGFzQWNjZXNzb3JbY29tcHV0ZWRQcm9wXSkge1xuICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eShjb21wdXRlZFByb3AsIHJlc3VsdCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdFtjb21wdXRlZFByb3BdID0gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgcGF0aCBjaGFuZ2VzIGJhc2VkIG9uIHBhdGggbGlua3Mgc2V0IHVwIHVzaW5nIHRoZSBgbGlua1BhdGhzYFxuICogQVBJLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdob3NlIHByb3BzIGFyZSBjaGFuZ2luZ1xuICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8KHN0cmluZ3xudW1iZXIpPn0gcGF0aCBQYXRoIHRoYXQgaGFzIGNoYW5nZWRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgY2hhbmdlZCBwYXRoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTGlua2VkUGF0aHMoaW5zdCwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IGxpbmtzID0gaW5zdC5fX2RhdGFMaW5rZWRQYXRocztcbiAgaWYgKGxpbmtzKSB7XG4gICAgbGV0IGxpbms7XG4gICAgZm9yIChsZXQgYSBpbiBsaW5rcykge1xuICAgICAgbGV0IGIgPSBsaW5rc1thXTtcbiAgICAgIGlmIChpc0Rlc2NlbmRhbnQoYSwgcGF0aCkpIHtcbiAgICAgICAgbGluayA9IHRyYW5zbGF0ZShhLCBiLCBwYXRoKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGxpbmssIHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZXNjZW5kYW50KGIsIHBhdGgpKSB7XG4gICAgICAgIGxpbmsgPSB0cmFuc2xhdGUoYiwgYSwgcGF0aCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChsaW5rLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIC0tIGJpbmRpbmdzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBZGRzIGJpbmRpbmcgbWV0YWRhdGEgdG8gdGhlIGN1cnJlbnQgYG5vZGVJbmZvYCwgYW5kIGJpbmRpbmcgZWZmZWN0c1xuICogZm9yIGFsbCBwYXJ0IGRlcGVuZGVuY2llcyB0byBgdGVtcGxhdGVJbmZvYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gKiAgIHJ1bm5pbmcgb25cbiAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmQgQmluZGluZyBraW5kLCBlaXRoZXIgJ3Byb3BlcnR5JywgJ2F0dHJpYnV0ZScsIG9yICd0ZXh0J1xuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBUYXJnZXQgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHshQXJyYXk8IUJpbmRpbmdQYXJ0Pn0gcGFydHMgQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZz19IGxpdGVyYWwgTGl0ZXJhbCB0ZXh0IHN1cnJvdW5kaW5nIGJpbmRpbmcgcGFydHMgKHNwZWNpZmllZFxuICogICBvbmx5IGZvciAncHJvcGVydHknIGJpbmRpbmdzLCBzaW5jZSB0aGVzZSBtdXN0IGJlIGluaXRpYWxpemVkIGFzIHBhcnRcbiAqICAgb2YgYm9vdC11cClcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZEJpbmRpbmcoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwpIHtcbiAgLy8gQ3JlYXRlIGJpbmRpbmcgbWV0YWRhdGEgYW5kIGFkZCB0byBub2RlSW5mb1xuICBub2RlSW5mby5iaW5kaW5ncyA9IG5vZGVJbmZvLmJpbmRpbmdzIHx8IFtdO1xuICBsZXQgLyoqIEJpbmRpbmcgKi8gYmluZGluZyA9IHsga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCwgaXNDb21wb3VuZDogKHBhcnRzLmxlbmd0aCAhPT0gMSkgfTtcbiAgbm9kZUluZm8uYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgLy8gQWRkIGxpc3RlbmVyIGluZm8gdG8gYmluZGluZyBtZXRhZGF0YVxuICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykpIHtcbiAgICBsZXQge2V2ZW50LCBuZWdhdGV9ID0gYmluZGluZy5wYXJ0c1swXTtcbiAgICBiaW5kaW5nLmxpc3RlbmVyRXZlbnQgPSBldmVudCB8fCAoQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UodGFyZ2V0KSArICctY2hhbmdlZCcpO1xuICAgIGJpbmRpbmcubGlzdGVuZXJOZWdhdGUgPSBuZWdhdGU7XG4gIH1cbiAgLy8gQWRkIFwicHJvcGFnYXRlXCIgcHJvcGVydHkgZWZmZWN0cyB0byB0ZW1wbGF0ZUluZm9cbiAgbGV0IGluZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5sZW5ndGg7XG4gIGZvciAobGV0IGk9MDsgaTxiaW5kaW5nLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzW2ldO1xuICAgIHBhcnQuY29tcG91bmRJbmRleCA9IGk7XG4gICAgYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgYmluZGluZywgcGFydCwgaW5kZXgpO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBwcm9wZXJ0eSBlZmZlY3RzIHRvIHRoZSBnaXZlbiBgdGVtcGxhdGVJbmZvYCBmb3IgdGhlIGdpdmVuIGJpbmRpbmdcbiAqIHBhcnQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ2xhc3MgdGhhdCBgX3BhcnNlVGVtcGxhdGVgIGlzIGN1cnJlbnRseVxuICogICBydW5uaW5nIG9uXG4gKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGludG8gYG5vZGVJbmZvTGlzdGAgZm9yIHRoaXMgbm9kZVxuICovXG5mdW5jdGlvbiBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCkge1xuICBpZiAoIXBhcnQubGl0ZXJhbCkge1xuICAgIGlmIChiaW5kaW5nLmtpbmQgPT09ICdhdHRyaWJ1dGUnICYmIGJpbmRpbmcudGFyZ2V0WzBdID09PSAnLScpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHNldCBhdHRyaWJ1dGUgJyArIGJpbmRpbmcudGFyZ2V0ICtcbiAgICAgICAgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBzdGFydGluZyBjaGFyYWN0ZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IHBhcnQuZGVwZW5kZW5jaWVzO1xuICAgICAgbGV0IGluZm8gPSB7IGluZGV4LCBiaW5kaW5nLCBwYXJ0LCBldmFsdWF0b3I6IGNvbnN0cnVjdG9yIH07XG4gICAgICBmb3IgKGxldCBqPTA7IGo8ZGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCB0cmlnZ2VyID0gZGVwZW5kZW5jaWVzW2pdO1xuICAgICAgICBpZiAodHlwZW9mIHRyaWdnZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0cmlnZ2VyID0gcGFyc2VBcmcodHJpZ2dlcik7XG4gICAgICAgICAgdHJpZ2dlci53aWxkY2FyZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IuX2FkZFRlbXBsYXRlUHJvcGVydHlFZmZlY3QodGVtcGxhdGVJbmZvLCB0cmlnZ2VyLnJvb3RQcm9wZXJ0eSwge1xuICAgICAgICAgIGZuOiBydW5CaW5kaW5nRWZmZWN0LFxuICAgICAgICAgIGluZm8sIHRyaWdnZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJiaW5kaW5nXCIgKHByb3BlcnR5L3BhdGggYmluZGluZykgZWZmZWN0LlxuICpcbiAqIE5vdGUgdGhhdCBiaW5kaW5nIHN5bnRheCBpcyBvdmVycmlkYWJsZSB2aWEgYF9wYXJzZUJpbmRpbmdzYCBhbmRcbiAqIGBfZXZhbHVhdGVCaW5kaW5nYC4gIFRoaXMgbWV0aG9kIHdpbGwgY2FsbCBgX2V2YWx1YXRlQmluZGluZ2AgZm9yIGFueVxuICogbm9uLWxpdGVyYWwgcGFydHMgcmV0dXJuZWQgZnJvbSBgX3BhcnNlQmluZGluZ3NgLiAgSG93ZXZlcixcbiAqIHRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIF9wYXRoXyBiaW5kaW5ncyB2aWEgY3VzdG9tIGJpbmRpbmcgcGFydHMsXG4gKiBhcyB0aGlzIGlzIHNwZWNpZmljIHRvIFBvbHltZXIncyBwYXRoIGJpbmRpbmcgc3ludGF4LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0ge0FycmF5fSBub2RlTGlzdCBMaXN0IG9mIG5vZGVzIGFzc29jaWF0ZWQgd2l0aCBgbm9kZUluZm9MaXN0YCB0ZW1wbGF0ZVxuICogICBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuQmluZGluZ0VmZmVjdChpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzLCBub2RlTGlzdCkge1xuICBsZXQgbm9kZSA9IG5vZGVMaXN0W2luZm8uaW5kZXhdO1xuICBsZXQgYmluZGluZyA9IGluZm8uYmluZGluZztcbiAgbGV0IHBhcnQgPSBpbmZvLnBhcnQ7XG4gIC8vIFN1YnBhdGggbm90aWZpY2F0aW9uOiB0cmFuc2Zvcm0gcGF0aCBhbmQgc2V0IHRvIGNsaWVudFxuICAvLyBlLmcuOiBmb289XCJ7e29iai5zdWJ9fVwiLCBwYXRoOiAnb2JqLnN1Yi5wcm9wJywgc2V0ICdmb28ucHJvcCc9b2JqLnN1Yi5wcm9wXG4gIGlmIChoYXNQYXRocyAmJiBwYXJ0LnNvdXJjZSAmJiAocGF0aC5sZW5ndGggPiBwYXJ0LnNvdXJjZS5sZW5ndGgpICYmXG4gICAgICAoYmluZGluZy5raW5kID09ICdwcm9wZXJ0eScpICYmICFiaW5kaW5nLmlzQ29tcG91bmQgJiZcbiAgICAgIG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvcltiaW5kaW5nLnRhcmdldF0pIHtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc1twYXRoXTtcbiAgICBwYXRoID0gdHJhbnNsYXRlKHBhcnQuc291cmNlLCBiaW5kaW5nLnRhcmdldCwgcGF0aCk7XG4gICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICBpbnN0Ll9lbnF1ZXVlQ2xpZW50KG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgdmFsdWUgPSBpbmZvLmV2YWx1YXRvci5fZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgIC8vIFByb3BhZ2F0ZSB2YWx1ZSB0byBjaGlsZFxuICAgIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhbiBcImJpbmRpbmdcIiAoYmluZGluZykgZWZmZWN0IHRvIGEgbm9kZSxcbiAqIGVpdGhlciBhcyBhIHByb3BlcnR5IG9yIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSBvd25pbmcgdGhlIGJpbmRpbmcgZWZmZWN0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGFyZ2V0IG5vZGUgZm9yIGJpbmRpbmdcbiAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlCaW5kaW5nVmFsdWUoaW5zdCwgbm9kZSwgYmluZGluZywgcGFydCwgdmFsdWUpIHtcbiAgdmFsdWUgPSBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KTtcbiAgaWYgKHNhbml0aXplRE9NVmFsdWUpIHtcbiAgICB2YWx1ZSA9IHNhbml0aXplRE9NVmFsdWUodmFsdWUsIGJpbmRpbmcudGFyZ2V0LCBiaW5kaW5nLmtpbmQsIG5vZGUpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAvLyBBdHRyaWJ1dGUgYmluZGluZ1xuICAgIGluc3QuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8obm9kZSksIHZhbHVlLCBiaW5kaW5nLnRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJvcGVydHkgYmluZGluZ1xuICAgIGxldCBwcm9wID0gYmluZGluZy50YXJnZXQ7XG4gICAgaWYgKG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wXSkge1xuICAgICAgaWYgKCFub2RlW1RZUEVTLlJFQURfT05MWV0gfHwgIW5vZGVbVFlQRVMuUkVBRF9PTkxZXVtwcm9wXSkge1xuICAgICAgICBpZiAobm9kZS5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3AsIHZhbHVlKSkge1xuICAgICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgIHtcbiAgICAgIGluc3QuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIFwiYmluZGluZ1wiIGVmZmVjdCB2YWx1ZSBiYXNlZCBvbiBjb21wb3VuZCAmIG5lZ2F0aW9uXG4gKiBlZmZlY3QgbWV0YWRhdGEsIGFzIHdlbGwgYXMgaGFuZGxpbmcgZm9yIHNwZWNpYWwtY2FzZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhlIHZhbHVlIHdpbGwgYmUgc2V0IHRvXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEByZXR1cm4geyp9IFRyYW5zZm9ybWVkIHZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUJpbmRpbmdWYWx1ZShub2RlLCB2YWx1ZSwgYmluZGluZywgcGFydCkge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZVtiaW5kaW5nLnRhcmdldF07XG4gICAgc3RvcmFnZVtwYXJ0LmNvbXBvdW5kSW5kZXhdID0gdmFsdWU7XG4gICAgdmFsdWUgPSBzdG9yYWdlLmpvaW4oJycpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgIT09ICdhdHRyaWJ1dGUnKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzZXJpYWxpemUgYHVuZGVmaW5lZGAgdG8gYFwidW5kZWZpbmVkXCJgXG4gICAgaWYgKGJpbmRpbmcudGFyZ2V0ID09PSAndGV4dENvbnRlbnQnIHx8XG4gICAgICAgIChub2RlLmxvY2FsTmFtZSA9PSAnaW5wdXQnICYmIGJpbmRpbmcudGFyZ2V0ID09ICd2YWx1ZScpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBiaW5kaW5nJ3MgbWV0YWRhdGEgbWVldHMgYWxsIHRoZSByZXF1aXJlbWVudHMgdG8gYWxsb3dcbiAqIDItd2F5IGJpbmRpbmcsIGFuZCB0aGVyZWZvcmUgYSBgPHByb3BlcnR5Pi1jaGFuZ2VkYCBldmVudCBsaXN0ZW5lciBzaG91bGQgYmVcbiAqIGFkZGVkOlxuICogLSB1c2VkIGN1cmx5IGJyYWNlc1xuICogLSBpcyBhIHByb3BlcnR5IChub3QgYXR0cmlidXRlKSBiaW5kaW5nXG4gKiAtIGlzIG5vdCBhIHRleHRDb250ZW50IGJpbmRpbmdcbiAqIC0gaXMgbm90IGNvbXBvdW5kXG4gKlxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIDItd2F5IGxpc3RlbmVyIHNob3VsZCBiZSBhZGRlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykge1xuICByZXR1cm4gQm9vbGVhbihiaW5kaW5nLnRhcmdldCkgJiZcbiAgICAgICAgIGJpbmRpbmcua2luZCAhPSAnYXR0cmlidXRlJyAmJlxuICAgICAgICAgYmluZGluZy5raW5kICE9ICd0ZXh0JyAmJlxuICAgICAgICAgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgICAgYmluZGluZy5wYXJ0c1swXS5tb2RlID09PSAneyc7XG59XG5cbi8qKlxuICogU2V0dXAgY29tcG91bmQgYmluZGluZyBzdG9yYWdlIHN0cnVjdHVyZXMsIG5vdGlmeSBsaXN0ZW5lcnMsIGFuZCBkYXRhSG9zdFxuICogcmVmZXJlbmNlcyBvbnRvIHRoZSBib3VuZCBub2RlTGlzdC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRoYXQgYmFzIGJlZW4gcHJldmlvdXNseSBib3VuZFxuICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBCaW5kaW5ncyhpbnN0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgZGF0YUhvc3QsIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gIGxldCB7bm9kZUxpc3QsIG5vZGVJbmZvTGlzdH0gPSB0ZW1wbGF0ZUluZm87XG4gIGlmIChub2RlSW5mb0xpc3QubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaW5mbyA9IG5vZGVJbmZvTGlzdFtpXTtcbiAgICAgIGxldCBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgICBsZXQgYmluZGluZ3MgPSBpbmZvLmJpbmRpbmdzO1xuICAgICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZyk7XG4gICAgICAgICAgYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuX19kYXRhSG9zdCA9IGluc3Q7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYF9fZGF0YUNvbXBvdW5kU3RvcmFnZWAgbG9jYWwgc3RvcmFnZSBvbiBhIGJvdW5kIG5vZGUgd2l0aFxuICogaW5pdGlhbCBsaXRlcmFsIGRhdGEgZm9yIGNvbXBvdW5kIGJpbmRpbmdzLCBhbmQgc2V0cyB0aGUgam9pbmVkXG4gKiBsaXRlcmFsIHBhcnRzIHRvIHRoZSBib3VuZCBwcm9wZXJ0eS5cbiAqXG4gKiBXaGVuIGNoYW5nZXMgdG8gY29tcG91bmQgcGFydHMgb2NjdXIsIHRoZXkgYXJlIGZpcnN0IHNldCBpbnRvIHRoZSBjb21wb3VuZFxuICogc3RvcmFnZSBhcnJheSBmb3IgdGhhdCBwcm9wZXJ0eSwgYW5kIHRoZW4gdGhlIGFycmF5IGlzIGpvaW5lZCB0byByZXN1bHQgaW5cbiAqIHRoZSBmaW5hbCB2YWx1ZSBzZXQgdG8gdGhlIHByb3BlcnR5L2F0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgQm91bmQgbm9kZSB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgLy8gQ3JlYXRlIGNvbXBvdW5kIHN0b3JhZ2UgbWFwXG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fFxuICAgICAgKG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlID0ge30pO1xuICAgIGxldCBwYXJ0cyA9IGJpbmRpbmcucGFydHM7XG4gICAgLy8gQ29weSBsaXRlcmFscyBmcm9tIHBhcnRzIGludG8gc3RvcmFnZSBmb3IgdGhpcyBiaW5kaW5nXG4gICAgbGV0IGxpdGVyYWxzID0gbmV3IEFycmF5KHBhcnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaj0wOyBqPHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsaXRlcmFsc1tqXSA9IHBhcnRzW2pdLmxpdGVyYWw7XG4gICAgfVxuICAgIGxldCB0YXJnZXQgPSBiaW5kaW5nLnRhcmdldDtcbiAgICBzdG9yYWdlW3RhcmdldF0gPSBsaXRlcmFscztcbiAgICAvLyBDb25maWd1cmUgcHJvcGVydGllcyB3aXRoIHRoZWlyIGxpdGVyYWwgcGFydHNcbiAgICBpZiAoYmluZGluZy5saXRlcmFsICYmIGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSB7XG4gICAgICBub2RlW3RhcmdldF0gPSBiaW5kaW5nLmxpdGVyYWw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkcyBhIDItd2F5IGJpbmRpbmcgbm90aWZpY2F0aW9uIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlIHNwZWNpZmllZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIENoaWxkIGVsZW1lbnQgdG8gYWRkIGxpc3RlbmVyIHRvXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSB0byBoYW5kbGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5saXN0ZW5lckV2ZW50KSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmxpc3RlbmVyRXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihlLCBpbnN0LCBiaW5kaW5nLnRhcmdldCwgcGFydC5zb3VyY2UsIHBhcnQubmVnYXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyAtLSBmb3IgbWV0aG9kLWJhc2VkIGVmZmVjdHMgKGNvbXBsZXhPYnNlcnZlciAmIGNvbXB1dGVkKSAtLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyBmb3IgZWFjaCBhcmd1bWVudCBpbiB0aGUgbWV0aG9kIHNpZ25hdHVyZSAoYW5kXG4gKiBvcHRpb25hbGx5LCBmb3IgdGhlIG1ldGhvZCBuYW1lIGlmIGBkeW5hbWljYCBpcyB0cnVlKSB0aGF0IGNhbGxzIHRoZVxuICogcHJvdmlkZWQgZWZmZWN0IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudCB8IE9iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIG9mIHByb3BlcnR5IGVmZmVjdCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVmZmVjdEZuIEZ1bmN0aW9uIHRvIHJ1biB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcbiAqIEBwYXJhbSB7Kj19IG1ldGhvZEluZm8gRWZmZWN0LXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGJlIGluY2x1ZGVkIGluXG4gKiAgIG1ldGhvZCBlZmZlY3QgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LiBOb3RlLFxuICogICBkZWZhdWx0cyB0byB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgc3RhdGljIChzaWcuc3RhdGljIGlzIHRydWUpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRWZmZWN0KG1vZGVsLCBzaWcsIHR5cGUsIGVmZmVjdEZuLCBtZXRob2RJbmZvLCBkeW5hbWljRm4pIHtcbiAgZHluYW1pY0ZuID0gc2lnLnN0YXRpYyB8fCAoZHluYW1pY0ZuICYmXG4gICAgKHR5cGVvZiBkeW5hbWljRm4gIT09ICdvYmplY3QnIHx8IGR5bmFtaWNGbltzaWcubWV0aG9kTmFtZV0pKTtcbiAgbGV0IGluZm8gPSB7XG4gICAgbWV0aG9kTmFtZTogc2lnLm1ldGhvZE5hbWUsXG4gICAgYXJnczogc2lnLmFyZ3MsXG4gICAgbWV0aG9kSW5mbyxcbiAgICBkeW5hbWljRm5cbiAgfTtcbiAgZm9yIChsZXQgaT0wLCBhcmc7IChpPHNpZy5hcmdzLmxlbmd0aCkgJiYgKGFyZz1zaWcuYXJnc1tpXSk7IGkrKykge1xuICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChhcmcucm9vdFByb3BlcnR5LCB0eXBlLCB7XG4gICAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mbywgdHJpZ2dlcjogYXJnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGR5bmFtaWNGbikge1xuICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChzaWcubWV0aG9kTmFtZSwgdHlwZSwge1xuICAgICAgZm46IGVmZmVjdEZuLCBpbmZvOiBpbmZvXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCB3aXRoIGFyZ3VtZW50cyBtYXJzaGFsZWQgZnJvbSBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZVxuICogYmFzZWQgb24gdGhlIG1ldGhvZCBzaWduYXR1cmUgY29udGFpbmVkIGluIHRoZSBlZmZlY3QgbWV0YWRhdGEuXG4gKlxuICogTXVsdGktcHJvcGVydHkgb2JzZXJ2ZXJzLCBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICogZnVuY3Rpb25zIGNhbGwgdGhpcyBmdW5jdGlvbiB0byBpbnZva2UgdGhlIG1ldGhvZCwgdGhlbiB1c2UgdGhlIHJldHVyblxuICogdmFsdWUgYWNjb3JkaW5nbHkuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbWV0aG9kIGludm9jYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICBsZXQgY29udGV4dCA9IGluc3QuX21ldGhvZEhvc3QgfHwgaW5zdDtcbiAgbGV0IGZuID0gY29udGV4dFtpbmZvLm1ldGhvZE5hbWVdO1xuICBpZiAoZm4pIHtcbiAgICBsZXQgYXJncyA9IG1hcnNoYWxBcmdzKGluc3QuX19kYXRhLCBpbmZvLmFyZ3MsIHByb3BlcnR5LCBwcm9wcyk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2FybignbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgfVxufVxuXG5jb25zdCBlbXB0eUFycmF5ID0gW107XG5cbi8vIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdXNlZCBmb3IgYmluZGluZ1xuY29uc3QgSURFTlQgID0gJyg/OicgKyAnW2EtekEtWl8kXVtcXFxcdy46JFxcXFwtKl0qJyArICcpJztcbmNvbnN0IE5VTUJFUiA9ICcoPzonICsgJ1stK10/WzAtOV0qXFxcXC4/WzAtOV0rKD86W2VFXVstK10/WzAtOV0rKT8nICsgJyknO1xuY29uc3QgU1FVT1RFX1NUUklORyA9ICcoPzonICsgJ1xcJyg/OlteXFwnXFxcXFxcXFxdfFxcXFxcXFxcLikqXFwnJyArICcpJztcbmNvbnN0IERRVU9URV9TVFJJTkcgPSAnKD86JyArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFwuKSpcIicgKyAnKSc7XG5jb25zdCBTVFJJTkcgPSAnKD86JyArIFNRVU9URV9TVFJJTkcgKyAnfCcgKyBEUVVPVEVfU1RSSU5HICsgJyknO1xuY29uc3QgQVJHVU1FTlQgPSAnKD86KCcgKyBJREVOVCArICd8JyArIE5VTUJFUiArICd8JyArICBTVFJJTkcgKyAnKVxcXFxzKicgKyAnKSc7XG5jb25zdCBBUkdVTUVOVFMgPSAnKD86JyArIEFSR1VNRU5UICsgJyg/OixcXFxccyonICsgQVJHVU1FTlQgKyAnKSonICsgJyknO1xuY29uc3QgQVJHVU1FTlRfTElTVCA9ICcoPzonICsgJ1xcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIEFSR1VNRU5UUyArICc/JyArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFwpXFxcXHMqJyArICcpJztcbmNvbnN0IEJJTkRJTkcgPSAnKCcgKyBJREVOVCArICdcXFxccyonICsgQVJHVU1FTlRfTElTVCArICc/JyArICcpJzsgLy8gR3JvdXAgM1xuY29uc3QgT1BFTl9CUkFDS0VUID0gJyhcXFxcW1xcXFxbfHt7KScgKyAnXFxcXHMqJztcbmNvbnN0IENMT1NFX0JSQUNLRVQgPSAnKD86XV18fX0pJztcbmNvbnN0IE5FR0FURSA9ICcoPzooISlcXFxccyopPyc7IC8vIEdyb3VwIDJcbmNvbnN0IEVYUFJFU1NJT04gPSBPUEVOX0JSQUNLRVQgKyBORUdBVEUgKyBCSU5ESU5HICsgQ0xPU0VfQlJBQ0tFVDtcbmNvbnN0IGJpbmRpbmdSZWdleCA9IG5ldyBSZWdFeHAoRVhQUkVTU0lPTiwgXCJnXCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHN0cmluZyBmcm9tIGJpbmRpbmcgcGFydHMgb2YgYWxsIHRoZSBsaXRlcmFsIHBhcnRzXG4gKlxuICogQHBhcmFtIHshQXJyYXk8QmluZGluZ1BhcnQ+fSBwYXJ0cyBBbGwgcGFydHMgdG8gc3RyaW5naWZ5XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyBtYWRlIGZyb20gdGhlIGxpdGVyYWwgcGFydHNcbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cykge1xuICBsZXQgcyA9ICcnO1xuICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbGl0ZXJhbCA9IHBhcnRzW2ldLmxpdGVyYWw7XG4gICAgcyArPSBsaXRlcmFsIHx8ICcnO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHN0cmluZyBmb3IgYSBtZXRob2Qgc2lnbmF0dXJlLCBhbmQgcmV0dXJucyBhIG1ldGFkYXRhXG4gKiBkZXNjcmliaW5nIHRoZSBtZXRob2QgaW4gdGVybXMgb2YgYG1ldGhvZE5hbWVgLCBgc3RhdGljYCAod2hldGhlciBhbGwgdGhlXG4gKiBhcmd1bWVudHMgYXJlIGxpdGVyYWxzKSwgYW5kIGFuIGFycmF5IG9mIGBhcmdzYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHs/TWV0aG9kU2lnbmF0dXJlfSBUaGUgbWV0aG9kIG1ldGFkYXRhIG9iamVjdCBpZiBhIG1ldGhvZCBleHByZXNzaW9uIHdhc1xuICogICBmb3VuZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU1ldGhvZChleHByZXNzaW9uKSB7XG4gIC8vIHRyaWVzIHRvIG1hdGNoIHZhbGlkIGphdmFzY3JpcHQgcHJvcGVydHkgbmFtZXNcbiAgbGV0IG0gPSBleHByZXNzaW9uLm1hdGNoKC8oW15cXHNdKz8pXFwoKFtcXHNcXFNdKilcXCkvKTtcbiAgaWYgKG0pIHtcbiAgICBsZXQgbWV0aG9kTmFtZSA9IG1bMV07XG4gICAgbGV0IHNpZyA9IHsgbWV0aG9kTmFtZSwgc3RhdGljOiB0cnVlLCBhcmdzOiBlbXB0eUFycmF5IH07XG4gICAgaWYgKG1bMl0udHJpbSgpKSB7XG4gICAgICAvLyByZXBsYWNlIGVzY2FwZWQgY29tbWFzIHdpdGggY29tbWEgZW50aXR5LCBzcGxpdCBvbiB1bi1lc2NhcGVkIGNvbW1hc1xuICAgICAgbGV0IGFyZ3MgPSBtWzJdLnJlcGxhY2UoL1xcXFwsL2csICcmY29tbWE7Jykuc3BsaXQoJywnKTtcbiAgICAgIHJldHVybiBwYXJzZUFyZ3MoYXJncywgc2lnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBhbmQgc2V0cyB0aGUgYGFyZ3NgIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZFxuICogc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdC4gU2V0cyB0aGUgYHN0YXRpY2AgcHJvcGVydHkgdG8gZmFsc2UgaWYgYW55XG4gKiBhcmd1bWVudCBpcyBhIG5vbi1saXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IGFyZ0xpc3QgQXJyYXkgb2YgYXJndW1lbnQgbmFtZXNcbiAqIEBwYXJhbSB7IU1ldGhvZFNpZ25hdHVyZX0gc2lnIE1ldGhvZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcmV0dXJuIHshTWV0aG9kU2lnbmF0dXJlfSBUaGUgdXBkYXRlZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZ3MoYXJnTGlzdCwgc2lnKSB7XG4gIHNpZy5hcmdzID0gYXJnTGlzdC5tYXAoZnVuY3Rpb24ocmF3QXJnKSB7XG4gICAgbGV0IGFyZyA9IHBhcnNlQXJnKHJhd0FyZyk7XG4gICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgc2lnLnN0YXRpYyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9LCB0aGlzKTtcbiAgcmV0dXJuIHNpZztcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gaW5kaXZpZHVhbCBhcmd1bWVudCwgYW5kIHJldHVybnMgYW4gYXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqICAge1xuICogICAgIHZhbHVlOiAncHJvcCcsICAgICAgICAvLyBwcm9wZXJ0eS9wYXRoIG9yIGxpdGVyYWwgdmFsdWVcbiAqICAgICBsaXRlcmFsOiBmYWxzZSwgICAgICAgLy8gd2hldGhlciBhcmd1bWVudCBpcyBhIGxpdGVyYWxcbiAqICAgICBzdHJ1Y3R1cmVkOiBmYWxzZSwgICAgLy8gd2hldGhlciB0aGUgcHJvcGVydHkgaXMgYSBwYXRoXG4gKiAgICAgcm9vdFByb3BlcnR5OiAncHJvcCcsIC8vIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoXG4gKiAgICAgd2lsZGNhcmQ6IGZhbHNlICAgICAgIC8vIHdoZXRoZXIgdGhlIGFyZ3VtZW50IHdhcyBhIHdpbGRjYXJkICcuKicgcGF0aFxuICogICB9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJhd0FyZyBUaGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICogQHJldHVybiB7IU1ldGhvZEFyZ30gQXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZyhyYXdBcmcpIHtcbiAgLy8gY2xlYW4gdXAgd2hpdGVzcGFjZVxuICBsZXQgYXJnID0gcmF3QXJnLnRyaW0oKVxuICAgIC8vIHJlcGxhY2UgY29tbWEgZW50aXR5IHdpdGggY29tbWFcbiAgICAucmVwbGFjZSgvJmNvbW1hOy9nLCAnLCcpXG4gICAgLy8gcmVwYWlyIGV4dHJhIGVzY2FwZSBzZXF1ZW5jZXM7IG5vdGUgb25seSBjb21tYXMgc3RyaWN0bHkgbmVlZFxuICAgIC8vIGVzY2FwaW5nLCBidXQgd2UgYWxsb3cgYW55IG90aGVyIGNoYXIgdG8gYmUgZXNjYXBlZCBzaW5jZSBpdHNcbiAgICAvLyBsaWtlbHkgdXNlcnMgd2lsbCBkbyB0aGlzXG4gICAgLnJlcGxhY2UoL1xcXFwoLikvZywgJ1xcJDEnKVxuICAgIDtcbiAgLy8gYmFzaWMgYXJndW1lbnQgZGVzY3JpcHRvclxuICBsZXQgYSA9IHtcbiAgICBuYW1lOiBhcmcsXG4gICAgdmFsdWU6ICcnLFxuICAgIGxpdGVyYWw6IGZhbHNlXG4gIH07XG4gIC8vIGRldGVjdCBsaXRlcmFsIHZhbHVlIChtdXN0IGJlIFN0cmluZyBvciBOdW1iZXIpXG4gIGxldCBmYyA9IGFyZ1swXTtcbiAgaWYgKGZjID09PSAnLScpIHtcbiAgICBmYyA9IGFyZ1sxXTtcbiAgfVxuICBpZiAoZmMgPj0gJzAnICYmIGZjIDw9ICc5Jykge1xuICAgIGZjID0gJyMnO1xuICB9XG4gIHN3aXRjaChmYykge1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOlxuICAgICAgYS52YWx1ZSA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBhLnZhbHVlID0gTnVtYmVyKGFyZyk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgLy8gaWYgbm90IGxpdGVyYWwsIGxvb2sgZm9yIHN0cnVjdHVyZWQgcGF0aFxuICBpZiAoIWEubGl0ZXJhbCkge1xuICAgIGEucm9vdFByb3BlcnR5ID0gcm9vdCQwKGFyZyk7XG4gICAgLy8gZGV0ZWN0IHN0cnVjdHVyZWQgcGF0aCAoaGFzIGRvdHMpXG4gICAgYS5zdHJ1Y3R1cmVkID0gaXNQYXRoJDAoYXJnKTtcbiAgICBpZiAoYS5zdHJ1Y3R1cmVkKSB7XG4gICAgICBhLndpbGRjYXJkID0gKGFyZy5zbGljZSgtMikgPT0gJy4qJyk7XG4gICAgICBpZiAoYS53aWxkY2FyZCkge1xuICAgICAgICBhLm5hbWUgPSBhcmcuc2xpY2UoMCwgLTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBHYXRoZXIgdGhlIGFyZ3VtZW50IHZhbHVlcyBmb3IgYSBtZXRob2Qgc3BlY2lmaWVkIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICogb2YgYXJndW1lbnQgbWV0YWRhdGEuXG4gKlxuICogVGhlIGBwYXRoYCBhbmQgYHZhbHVlYCBhcmd1bWVudHMgYXJlIHVzZWQgdG8gZmlsbCBpbiB3aWxkY2FyZCBkZXNjcmlwdG9yXG4gKiB3aGVuIHRoZSBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIGFzIGEgcmVzdWx0IG9mIGEgcGF0aCBub3RpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgSW5zdGFuY2UgZGF0YSBzdG9yYWdlIG9iamVjdCB0byByZWFkIHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHshQXJyYXk8IU1ldGhvZEFyZz59IGFyZ3MgQXJyYXkgb2YgYXJndW1lbnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFByb3BlcnR5L3BhdGggbmFtZSB0aGF0IHRyaWdnZXJlZCB0aGUgbWV0aG9kIGVmZmVjdFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBBcnJheSBvZiBhcmd1bWVudCB2YWx1ZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1hcnNoYWxBcmdzKGRhdGEsIGFyZ3MsIHBhdGgsIHByb3BzKSB7XG4gIGxldCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChsZXQgaT0wLCBsPWFyZ3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgIGxldCBhcmcgPSBhcmdzW2ldO1xuICAgIGxldCBuYW1lID0gYXJnLm5hbWU7XG4gICAgbGV0IHY7XG4gICAgaWYgKGFyZy5saXRlcmFsKSB7XG4gICAgICB2ID0gYXJnLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnLnN0cnVjdHVyZWQpIHtcbiAgICAgICAgdiA9IGdldCQwKGRhdGEsIG5hbWUpO1xuICAgICAgICAvLyB3aGVuIGRhdGEgaXMgbm90IHN0b3JlZCBlLmcuIGBzcGxpY2VzYFxuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdiA9IHByb3BzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gZGF0YVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZy53aWxkY2FyZCkge1xuICAgICAgLy8gT25seSBzZW5kIHRoZSBhY3R1YWwgcGF0aCBjaGFuZ2VkIGluZm8gaWYgdGhlIGNoYW5nZSB0aGF0XG4gICAgICAvLyBjYXVzZWQgdGhlIG9ic2VydmVyIHRvIHJ1biBtYXRjaGVkIHRoZSB3aWxkY2FyZFxuICAgICAgbGV0IGJhc2VDaGFuZ2VkID0gKG5hbWUuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMCk7XG4gICAgICBsZXQgbWF0Y2hlcyA9IChwYXRoLmluZGV4T2YobmFtZSkgPT09IDAgJiYgIWJhc2VDaGFuZ2VkKTtcbiAgICAgIHZhbHVlc1tpXSA9IHtcbiAgICAgICAgcGF0aDogbWF0Y2hlcyA/IHBhdGggOiBuYW1lLFxuICAgICAgICB2YWx1ZTogbWF0Y2hlcyA/IHByb3BzW3BhdGhdIDogdixcbiAgICAgICAgYmFzZTogdlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2ldID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gZGF0YSBhcGlcblxuLyoqXG4gKiBTZW5kcyBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9ucyAoYC5zcGxpY2VzYCBhbmQgYC5sZW5ndGhgKVxuICpcbiAqIE5vdGU6IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG5vcm1hbGl6ZWQgcGF0aHNcbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRvIHNlbmQgbm90aWZpY2F0aW9ucyB0b1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRoZSBtdXRhdGlvbnMgb2NjdXJyZWQgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3RpZnlTcGxpY2VzKGluc3QsIGFycmF5LCBwYXRoLCBzcGxpY2VzKSB7XG4gIGxldCBzcGxpY2VzUGF0aCA9IHBhdGggKyAnLnNwbGljZXMnO1xuICBpbnN0Lm5vdGlmeVBhdGgoc3BsaWNlc1BhdGgsIHsgaW5kZXhTcGxpY2VzOiBzcGxpY2VzIH0pO1xuICBpbnN0Lm5vdGlmeVBhdGgocGF0aCArICcubGVuZ3RoJywgYXJyYXkubGVuZ3RoKTtcbiAgLy8gTnVsbCBoZXJlIHRvIGFsbG93IHBvdGVudGlhbGx5IGxhcmdlIHNwbGljZSByZWNvcmRzIHRvIGJlIEdDJ2VkLlxuICBpbnN0Ll9fZGF0YVtzcGxpY2VzUGF0aF0gPSB7aW5kZXhTcGxpY2VzOiBudWxsfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3BsaWNlIHJlY29yZCBhbmQgc2VuZHMgYW4gYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbiBmb3JcbiAqIHRoZSBkZXNjcmliZWQgbXV0YXRpb25cbiAqXG4gKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBJbnN0YW5jZSB0byBzZW5kIG5vdGlmaWNhdGlvbnMgdG9cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXJyYXkgdGhhdCB3YXMgbXV0YXRlZFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRoZSBhcnJheSBtdXRhdGlvbiBvY2N1cnJlZFxuICogQHBhcmFtIHtudW1iZXJ9IGFkZGVkQ291bnQgTnVtYmVyIG9mIGFkZGVkIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fSByZW1vdmVkIEFycmF5IG9mIHJlbW92ZWQgaXRlbXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVNwbGljZShpbnN0LCBhcnJheSwgcGF0aCwgaW5kZXgsIGFkZGVkQ291bnQsIHJlbW92ZWQpIHtcbiAgbm90aWZ5U3BsaWNlcyhpbnN0LCBhcnJheSwgcGF0aCwgW3tcbiAgICBpbmRleDogaW5kZXgsXG4gICAgYWRkZWRDb3VudDogYWRkZWRDb3VudCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIG9iamVjdDogYXJyYXksXG4gICAgdHlwZTogJ3NwbGljZSdcbiAgfV0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gdXBwZXItY2FzZWQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN0cmluZyB0byB1cHBlcmNhc2VcbiAqIEByZXR1cm4ge3N0cmluZ30gVXBwZXJjYXNlZCBzdHJpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwcGVyKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xufVxuXG5leHBvcnQgY29uc3QgUHJvcGVydHlFZmZlY3RzID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtzdXBlckNsYXNzfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY29uc3QgcHJvcGVydHlFZmZlY3RzQmFzZSA9IFRlbXBsYXRlU3RhbXAoUHJvcGVydHlBY2Nlc3NvcnMoc3VwZXJDbGFzcykpO1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqIEBleHRlbmRzIHtwcm9wZXJ0eUVmZmVjdHNCYXNlfVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUVmZmVjdHMgZXh0ZW5kcyBwcm9wZXJ0eUVmZmVjdHNCYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5O1xuICAgICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHM7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZTtcbiAgICAgIC8qKiBAdHlwZSB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG4gICAgICB0aGlzLl9fZGF0YUhvc3Q7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVRlbXA7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUNsaWVudHNJbml0aWFsaXplZDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19jb21wdXRlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlZmxlY3RFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fbm90aWZ5RWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3Byb3BhZ2F0ZUVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19vYnNlcnZlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlYWRPbmx5O1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXI7XG4gICAgICAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovXG4gICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgIH1cblxuICAgIGdldCBQUk9QRVJUWV9FRkZFQ1RfVFlQRVMoKSB7XG4gICAgICByZXR1cm4gVFlQRVM7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICBob3N0U3RhY2sucmVnaXN0ZXJIb3N0KHRoaXMpO1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSBmYWxzZTtcbiAgICAgIC8vIE1heSBiZSBzZXQgb24gaW5zdGFuY2UgcHJpb3IgdG8gdXBncmFkZVxuICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fCBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFIb3N0ID0gdGhpcy5fX2RhdGFIb3N0IHx8IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFcbiAgICAgKiBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiBvZiBpbml0aWFsaXppbmcgcHJvcGVydGllcyBmcm9tXG4gICAgICogdGhlIHByb3RvdHlwZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBpbml0aWFsaXplIG9uIHRoZSBwcm90b3R5cGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgdGhpcy5fX2RhdGEgPSBPYmplY3QuY3JlYXRlKHByb3BzKTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIGF2b2lkIHNldHRpbmdcbiAgICAgKiBgX3NldFByb3BlcnR5YCdzIGBzaG91bGROb3RpZnk6IHRydWVgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgbGV0IHJlYWRPbmx5ID0gdGhpc1tUWVBFUy5SRUFEX09OTFldO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoIXJlYWRPbmx5IHx8ICFyZWFkT25seVtwcm9wXSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHRoaXMuX19kYXRhUGVuZGluZyB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHRoaXMuX19kYXRhT2xkIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BdID0gdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm90b3R5cGUgc2V0dXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGFkZFByb3BlcnR5RWZmZWN0YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICB0aGlzLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCB0eXBlID09IFRZUEVTLlJFQURfT05MWSk7XG4gICAgICAvLyBlZmZlY3RzIGFyZSBhY2N1bXVsYXRlZCBpbnRvIGFycmF5cyBwZXIgcHJvcGVydHkgYmFzZWQgb24gdHlwZVxuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgaWYgKCFlZmZlY3RzKSB7XG4gICAgICAgIGVmZmVjdHMgPSB0aGlzW3R5cGVdW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgfVxuICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcHJvcGVydHkgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoZSBlZmZlY3Qgd2FzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdCB0byByZW1vdmVcbiAgICAgKi9cbiAgICBfcmVtb3ZlUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgbGV0IGlkeCA9IGVmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGVmZmVjdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBwcm9wZXJ0eSBlZmZlY3RcbiAgICAgKiBvZiBhIGNlcnRhaW4gdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgbGV0IGVmZmVjdHMgPSB0aGlzW3R5cGVdO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZWZmZWN0cyAmJiBlZmZlY3RzW3Byb3BlcnR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcInJlYWQgb25seVwiXG4gICAgICogYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUFEX09OTFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJub3RpZnlcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc05vdGlmeUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWZsZWN0IHRvIGF0dHJpYnV0ZVwiXG4gICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzUmVmbGVjdEVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUZMRUNUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwiY29tcHV0ZWRcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc0NvbXB1dGVkRWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLkNPTVBVVEUpO1xuICAgIH1cblxuICAgIC8vIFJ1bnRpbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHBlbmRpbmcgcHJvcGVydHkgb3IgcGF0aC4gIElmIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoIGluXG4gICAgICogcXVlc3Rpb24gaGFkIG5vIGFjY2Vzc29yLCB0aGUgcGF0aCBpcyBzZXQsIG90aGVyd2lzZSBpdCBpcyBlbnF1ZXVlZFxuICAgICAqIHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzb2xhdGVzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGZ1bmN0aW9uYWxpdHkgbmVjZXNzYXJ5XG4gICAgICogZm9yIHRoZSBwdWJsaWMgQVBJIChgc2V0YCwgYHNldFByb3BlcnRpZXNgLCBgbm90aWZ5UGF0aGAsIGFuZCBwcm9wZXJ0eVxuICAgICAqIGNoYW5nZSBsaXN0ZW5lcnMgdmlhIHt7Li4ufX0gYmluZGluZ3MpLCBzdWNoIHRoYXQgaXQgaXMgb25seSBkb25lXG4gICAgICogd2hlbiBwYXRocyBlbnRlciB0aGUgc3lzdGVtLCBhbmQgbm90IGF0IGV2ZXJ5IHByb3BhZ2F0aW9uIHN0ZXAuICBJdFxuICAgICAqIGFsc28gc2V0cyBhIGBfX2RhdGFIYXNQYXRoc2AgZmxhZyBvbiB0aGUgaW5zdGFuY2Ugd2hpY2ggaXMgdXNlZCB0b1xuICAgICAqIGZhc3QtcGF0aCBzbG93ZXIgcGF0aC1tYXRjaGluZyBjb2RlIGluIHRoZSBwcm9wZXJ0eSBlZmZlY3RzIGhvc3QgcGF0aHMuXG4gICAgICpcbiAgICAgKiBgcGF0aGAgY2FuIGJlIGEgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2YgcGF0aCBwYXJ0cyBhcyBhY2NlcHRlZCBieSB0aGVcbiAgICAgKiBwdWJsaWMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8bnVtYmVyfHN0cmluZz59IHBhdGggUGF0aCB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBTZXQgdG8gdHJ1ZSBpZiB0aGlzIGNoYW5nZSBzaG91bGRcbiAgICAgKiAgY2F1c2UgYSBwcm9wZXJ0eSBub3RpZmljYXRpb24gZXZlbnQgZGlzcGF0Y2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1BhdGhOb3RpZmljYXRpb24gSWYgdGhlIHBhdGggYmVpbmcgc2V0IGlzIGEgcGF0aFxuICAgICAqICAgbm90aWZpY2F0aW9uIG9mIGFuIGFscmVhZHkgY2hhbmdlZCB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBhIHJlcXVlc3RcbiAgICAgKiAgIHRvIHNldCBhbmQgbm90aWZ5IHRoZSBjaGFuZ2UuICBJbiB0aGUgbGF0dGVyIGBmYWxzZWAgY2FzZSwgYSBkaXJ0eVxuICAgICAqICAgY2hlY2sgaXMgcGVyZm9ybWVkIGFuZCB0aGVuIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHBhdGggYmVmb3JlXG4gICAgICogICBlbnF1ZXVpbmcgdGhlIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkvcGF0aCB3YXMgZW5xdWV1ZWQgaW5cbiAgICAgKiAgIHRoZSBwZW5kaW5nIGNoYW5nZXMgYmFnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCBzaG91bGROb3RpZnksIGlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgaWYgKGlzUGF0aE5vdGlmaWNhdGlvbiB8fFxuICAgICAgICAgIHJvb3QkMChBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aFswXSA6IHBhdGgpICE9PSBwYXRoKSB7XG4gICAgICAgIC8vIERpcnR5IGNoZWNrIGNoYW5nZXMgYmVpbmcgc2V0IHRvIGEgcGF0aCBhZ2FpbnN0IHRoZSBhY3R1YWwgb2JqZWN0LFxuICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgcGF0aHMgaW50byB0aGUgc3lzdGVtOyBmcm9tIGhlcmVcbiAgICAgICAgLy8gdGhlIG9ubHkgZGlydHkgY2hlY2tzIGFyZSBhZ2FpbnN0IHRoZSBgX19kYXRhVGVtcGAgY2FjaGUgdG8gcHJldmVudFxuICAgICAgICAvLyBkdXBsaWNhdGUgd29yayBpbiB0aGUgc2FtZSB0dXJuIG9ubHkuIE5vdGUsIGlmIHRoaXMgd2FzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgIC8vIG9mIGEgY2hhbmdlIGFscmVhZHkgc2V0IHRvIGEgcGF0aCAoaXNQYXRoTm90aWZpY2F0aW9uOiB0cnVlKSxcbiAgICAgICAgLy8gd2UgYWx3YXlzIGxldCB0aGUgY2hhbmdlIHRocm91Z2ggYW5kIHNraXAgdGhlIGBzZXRgIHNpbmNlIGl0IHdhc1xuICAgICAgICAvLyBhbHJlYWR5IGRpcnR5IGNoZWNrZWQgYXQgdGhlIHBvaW50IG9mIGVudHJ5IGFuZCB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG4gICAgICAgIGlmICghaXNQYXRoTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgbGV0IG9sZCA9IGdldCQwKHRoaXMsIHBhdGgpO1xuICAgICAgICAgIHBhdGggPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHNldCQwKHRoaXMsIHBhdGgsIHZhbHVlKSk7XG4gICAgICAgICAgLy8gVXNlIHByb3BlcnR5LWFjY2Vzc29yJ3Mgc2ltcGxlciBkaXJ0eSBjaGVja1xuICAgICAgICAgIGlmICghcGF0aCB8fCAhc3VwZXIuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHBhdGgsIHZhbHVlLCBvbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSkpIHtcbiAgICAgICAgICBjb21wdXRlTGlua2VkUGF0aHModGhpcywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3BhdGhdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eSgvKipAdHlwZXtzdHJpbmd9Ki8ocGF0aCksIHZhbHVlLCBzaG91bGROb3RpZnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSB2YWx1ZSB0byBhIG5vbi1Qb2x5bWVyIGVsZW1lbnQvbm9kZSdzIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG1ha2VzIGEgYmVzdC1lZmZvcnQgYXQgYmluZGluZyBpbnRlcm9wOlxuICAgICAqIFNvbWUgbmF0aXZlIGVsZW1lbnQgcHJvcGVydGllcyBoYXZlIHNpZGUtZWZmZWN0cyB3aGVuXG4gICAgICogcmUtc2V0dGluZyB0aGUgc2FtZSB2YWx1ZSAoZS5nLiBzZXR0aW5nIGA8aW5wdXQ+LnZhbHVlYCByZXNldHMgdGhlXG4gICAgICogY3Vyc29yIHBvc2l0aW9uKSwgc28gd2UgZG8gYSBkaXJ0eS1jaGVjayBiZWZvcmUgc2V0dGluZyB0aGUgdmFsdWUuXG4gICAgICogSG93ZXZlciwgZm9yIGJldHRlciBpbnRlcm9wIHdpdGggbm9uLVBvbHltZXIgY3VzdG9tIGVsZW1lbnRzIHRoYXRcbiAgICAgKiBhY2NlcHQgb2JqZWN0cywgd2UgZXhwbGljaXRseSByZS1zZXQgb2JqZWN0IGNoYW5nZXMgY29taW5nIGZyb20gdGhlXG4gICAgICogUG9seW1lciB3b3JsZCAod2hpY2ggbWF5IGluY2x1ZGUgZGVlcCBvYmplY3QgY2hhbmdlcyB3aXRob3V0IHRoZVxuICAgICAqIHRvcCByZWZlcmVuY2UgY2hhbmdpbmcpLCBlcnJpbmcgb24gdGhlIHNpZGUgb2YgcHJvdmlkaW5nIG1vcmVcbiAgICAgKiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGFsdGVybmF0ZSBhcHByb2FjaGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHNldCBhIHByb3BlcnR5IG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIC8vIEl0IGlzIGEganVkZ21lbnQgY2FsbCB0aGF0IHJlc2V0dGluZyBwcmltaXRpdmVzIGlzXG4gICAgICAvLyBcImJhZFwiIGFuZCByZXNldHRpbmdzIG9iamVjdHMgaXMgYWxzbyBcImdvb2RcIjsgYWx0ZXJuYXRpdmVseSB3ZSBjb3VsZFxuICAgICAgLy8gaW1wbGVtZW50IGEgd2hpdGVsaXN0IG9mIHRhZyAmIHByb3BlcnR5IHZhbHVlcyB0aGF0IHNob3VsZCBuZXZlclxuICAgICAgLy8gYmUgcmVzZXQgKGUuZy4gPGlucHV0Pi52YWx1ZSAmJiA8c2VsZWN0Pi52YWx1ZSlcbiAgICAgIGlmICh2YWx1ZSAhPT0gbm9kZVtwcm9wXSB8fCB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgYFByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBpbnRyb2R1Y2Ugc3BlY2lhbFxuICAgICAqIGRpcnR5IGNoZWNrIGxvZ2ljIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydHkgJiB2YWx1ZSBiZWluZyBzZXQ6XG4gICAgICpcbiAgICAgKiAxLiBBbnkgdmFsdWUgc2V0IHRvIGEgcGF0aCAoZS5nLiAnb2JqLnByb3AnOiA0MiBvciAnb2JqLnByb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YVRlbXBgXG4gICAgICogMi4gT2JqZWN0IHNldCB0byBzaW1wbGUgcHJvcGVydHkgKGUuZy4gJ3Byb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgIGFuZCBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0XG4gICAgICogICAgYF9fZGF0YVRlbXBgIGJ5IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYF9zaG91bGRQcm9wZXJ0eUNoYW5nZWBcbiAgICAgKiAzLiBQcmltaXRpdmUgdmFsdWUgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IDQyKVxuICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGBfX2RhdGFgXG4gICAgICpcbiAgICAgKiBUaGUgZGlydHktY2hlY2sgaXMgaW1wb3J0YW50IHRvIHByZXZlbnQgY3ljbGVzIGR1ZSB0byB0d28td2F5XG4gICAgICogbm90aWZpY2F0aW9uLCBidXQgcGF0aHMgYW5kIG9iamVjdHMgYXJlIG9ubHkgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGFueVxuICAgICAqIHByZXZpb3VzIHZhbHVlIHNldCBkdXJpbmcgdGhpcyB0dXJuIHZpYSBhIFwidGVtcG9yYXJ5IGNhY2hlXCIgdGhhdCBpc1xuICAgICAqIGNsZWFyZWQgd2hlbiB0aGUgbGFzdCBgX3Byb3BlcnRpZXNDaGFnZWRgIGV4aXRzLiBUaGlzIGlzIHNvOlxuICAgICAqIGEuIGFueSBjYWNoZWQgYXJyYXkgcGF0aHMgKGUuZy4gJ2FycmF5LjMucHJvcCcpIG1heSBiZSBpbnZhbGlkYXRlZFxuICAgICAqICAgIGR1ZSB0byBhcnJheSBtdXRhdGlvbnMgbGlrZSBzaGlmdC91bnNoaWZ0L3NwbGljZTsgdGhpcyBpcyBmaW5lXG4gICAgICogICAgc2luY2UgcGF0aCBjaGFuZ2VzIGFyZSBkaXJ0eS1jaGVja2VkIGF0IHVzZXIgZW50cnkgcG9pbnRzIGxpa2UgYHNldGBcbiAgICAgKiBiLiBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBvbmx5IGxhc3RzIG9uZSB0dXJuIHRvIGFsbG93IHRoZSB1c2VyXG4gICAgICogICAgdG8gbXV0YXRlIHRoZSBvYmplY3QgaW4tcGxhY2UgYW5kIHJlLXNldCBpdCB3aXRoIHRoZSBzYW1lIGlkZW50aXR5XG4gICAgICogICAgYW5kIGhhdmUgYWxsIHN1Yi1wcm9wZXJ0aWVzIHJlLXByb3BhZ2F0ZWQgaW4gYSBzdWJzZXF1ZW50IHR1cm4uXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcCBjYWNoZSBpcyBub3QgbmVjZXNzYXJpbHkgc3VmZmljaWVudCB0byBwcmV2ZW50IGludmFsaWQgYXJyYXlcbiAgICAgKiBwYXRocywgc2luY2UgYSBzcGxpY2UgY2FuIGhhcHBlbiBkdXJpbmcgdGhlIHNhbWUgdHVybiAod2l0aCBwYXRob2xvZ2ljYWxcbiAgICAgKiB1c2VyIGNvZGUpOyB3ZSBjb3VsZCBpbnRyb2R1Y2UgYSBcImZpeHVwXCIgZm9yIHRlbXBvcmFyaWx5IGNhY2hlZCBhcnJheVxuICAgICAqIHBhdGhzIGlmIG5lZWRlZDogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvNDIyN1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGROb3RpZnkgVHJ1ZSBpZiBwcm9wZXJ0eSBzaG91bGQgZmlyZSBub3RpZmljYXRpb25cbiAgICAgKiAgIGV2ZW50IChhcHBsaWVzIG9ubHkgZm9yIGBub3RpZnk6IHRydWVgIHByb3BlcnRpZXMpXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHNob3VsZE5vdGlmeSkge1xuICAgICAgbGV0IGlzUGF0aCA9IHRoaXMuX19kYXRhSGFzUGF0aHMgJiYgaXNQYXRoJDAocHJvcGVydHkpO1xuICAgICAgbGV0IHByZXZQcm9wcyA9IGlzUGF0aCA/IHRoaXMuX19kYXRhVGVtcCA6IHRoaXMuX19kYXRhO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgcHJldlByb3BzW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgIGlmICghKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXRocyBhcmUgc3RvcmVkIGluIHRlbXBvcmFyeSBjYWNoZSAoY2xlYXJlZCBhdCBlbmQgb2YgdHVybiksXG4gICAgICAgIC8vIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nLCBhbGwgb3RoZXJzIHN0b3JlZCBpbiBfX2RhdGFcbiAgICAgICAgaWYgKGlzUGF0aCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgY2hhbmdlcyBnbyBpbnRvIHBlbmRpbmcgcHJvcGVydHkgYmFnLCBwYXNzZWQgdG8gX3Byb3BlcnRpZXNDaGFuZ2VkXG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgLy8gVHJhY2sgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3RpZnkgc2VwYXJhdGVseVxuICAgICAgICBpZiAoaXNQYXRoIHx8ICh0aGlzW1RZUEVTLk5PVElGWV0gJiYgdGhpc1tUWVBFUy5OT1RJRlldW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gdGhpcy5fX2RhdGFUb05vdGlmeSB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5W3Byb3BlcnR5XSA9IHNob3VsZE5vdGlmeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgYWxsIGFjY2Vzc29ycyBzZXQgYHNob3VsZE5vdGlmeWBcbiAgICAgKiB0byB0cnVlLCBmb3IgcGVyLXByb3BlcnR5IG5vdGlmaWNhdGlvbiB0cmFja2luZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCB0cnVlKSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcmAncyBkZWZhdWx0IGFzeW5jIHF1ZXVpbmcgb2ZcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYDogaWYgYF9fZGF0YVJlYWR5YCBpcyBmYWxzZSAoaGFzIG5vdCB5ZXQgYmVlblxuICAgICAqIG1hbnVhbGx5IGZsdXNoZWQpLCB0aGUgZnVuY3Rpb24gbm8tb3BzOyBvdGhlcndpc2UgZmx1c2hlc1xuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIHN5bmNocm9ub3VzbHkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2xpZW50IG9uIGEgbGlzdCBvZiBwZW5kaW5nIGNsaWVudHMsIHdob3NlXG4gICAgICogcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2VzIGNhbiBsYXRlciBiZSBmbHVzaGVkIHZpYSBhIGNhbGwgdG9cbiAgICAgKiBgX2ZsdXNoQ2xpZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpZW50IFByb3BlcnR5RWZmZWN0cyBjbGllbnQgdG8gZW5xdWV1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZW5xdWV1ZUNsaWVudChjbGllbnQpIHtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzIHx8IFtdO1xuICAgICAgaWYgKGNsaWVudCAhPT0gdGhpcykge1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGFueSBjbGllbnRzIHByZXZpb3VzbHkgZW5xdWV1ZWQgdmlhIGBfZW5xdWV1ZUNsaWVudGAsIGNhdXNpbmdcbiAgICAgKiB0aGVpciBgX2ZsdXNoUHJvcGVydGllc2AgbWV0aG9kIHRvIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZmx1c2hDbGllbnRzKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlYWR5Q2xpZW50cygpO1xuICAgICAgICAvLyBPdmVycmlkZSBwb2ludCB3aGVyZSBhY2Nlc3NvcnMgYXJlIHR1cm5lZCBvbjsgaW1wb3J0YW50bHksXG4gICAgICAgIC8vIHRoaXMgaXMgYWZ0ZXIgY2xpZW50cyBoYXZlIGZ1bGx5IHJlYWRpZWQsIHByb3ZpZGluZyBhIGd1YXJhbnRlZVxuICAgICAgICAvLyB0aGF0IGFueSBwcm9wZXJ0eSBlZmZlY3RzIG9jY3VyIG9ubHkgYWZ0ZXIgYWxsIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IFdlIGVuc3VyZSBjbGllbnRzIGVpdGhlciBlbmFibGUgb3IgZmx1c2ggYXMgYXBwcm9wcmlhdGUuIFRoaXNcbiAgICAvLyBoYW5kbGVzIHR3byBjb3JuZXIgY2FzZXM6XG4gICAgLy8gKDEpIGNsaWVudHMgZmx1c2ggcHJvcGVybHkgd2hlbiBjb25uZWN0ZWQvZW5hYmxlZCBiZWZvcmUgdGhlIGhvc3RcbiAgICAvLyBlbmFibGVzOyBlLmcuXG4gICAgLy8gICAoYSkgVGVtcGxhdGl6ZSBzdGFtcHMgd2l0aCBubyBwcm9wZXJ0aWVzIGFuZCBkb2VzIG5vdCBmbHVzaCBhbmRcbiAgICAvLyAgIChiKSB0aGUgaW5zdGFuY2UgaXMgaW5zZXJ0ZWQgaW50byBkb20gYW5kXG4gICAgLy8gICAoYykgdGhlbiB0aGUgaW5zdGFuY2UgZmx1c2hlcy5cbiAgICAvLyAoMikgY2xpZW50cyBlbmFibGUgcHJvcGVybHkgd2hlbiBub3QgY29ubmVjdGVkL2VuYWJsZWQgd2hlbiB0aGUgaG9zdFxuICAgIC8vIGZsdXNoZXM7IGUuZy5cbiAgICAvLyAgIChhKSBhIHRlbXBsYXRlIGlzIHJ1bnRpbWUgc3RhbXBlZCBhbmQgbm90IHlldCBjb25uZWN0ZWQvZW5hYmxlZFxuICAgIC8vICAgKGIpIGEgaG9zdCBzZXRzIGEgcHJvcGVydHksIGNhdXNpbmcgc3RhbXBlZCBkb20gdG8gZmx1c2hcbiAgICAvLyAgIChjKSB0aGUgc3RhbXBlZCBkb20gZW5hYmxlcy5cbiAgICBfX2VuYWJsZU9yRmx1c2hDbGllbnRzKCkge1xuICAgICAgbGV0IGNsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzO1xuICAgICAgaWYgKGNsaWVudHMpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgY2xpZW50ID0gY2xpZW50c1tpXTtcbiAgICAgICAgICBpZiAoIWNsaWVudC5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgICAgICBjbGllbnQuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaWVudC5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICBjbGllbnQuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW55IGluaXRpYWwgc2V0dXAgb24gY2xpZW50IGRvbS4gQ2FsbGVkIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgKiBgX2ZsdXNoUHJvcGVydGllc2AgY2FsbCBvbiBjbGllbnQgZG9tIGFuZCBiZWZvcmUgYW55IGVsZW1lbnRcbiAgICAgKiBvYnNlcnZlcnMgYXJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgdGhpcy5fX2VuYWJsZU9yRmx1c2hDbGllbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGJhZyBvZiBwcm9wZXJ0eSBjaGFuZ2VzIHRvIHRoaXMgaW5zdGFuY2UsIGFuZFxuICAgICAqIHN5bmNocm9ub3VzbHkgcHJvY2Vzc2VzIGFsbCBlZmZlY3RzIG9mIHRoZSBwcm9wZXJ0aWVzIGFzIGEgYmF0Y2guXG4gICAgICpcbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtdXN0IGJlIHNpbXBsZSBwcm9wZXJ0aWVzLCBub3QgcGF0aHMuICBCYXRjaGVkXG4gICAgICogcGF0aCBwcm9wYWdhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBvbmUgb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2hvc2Uga2V5IGlzXG4gICAgICogICBhIHByb3BlcnR5IGFuZCB2YWx1ZSBpcyB0aGUgbmV3IHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXRSZWFkT25seSBXaGVuIHRydWUsIGFueSBwcml2YXRlIHZhbHVlcyBzZXQgaW5cbiAgICAgKiAgIGBwcm9wc2Agd2lsbCBiZSBzZXQuIEJ5IGRlZmF1bHQsIGBzZXRQcm9wZXJ0aWVzYCB3aWxsIG5vdCBzZXRcbiAgICAgKiAgIGByZWFkT25seTogdHJ1ZWAgcm9vdCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXRQcm9wZXJ0aWVzKHByb3BzLCBzZXRSZWFkT25seSkge1xuICAgICAgZm9yIChsZXQgcGF0aCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoc2V0UmVhZE9ubHkgfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldW3BhdGhdKSB7XG4gICAgICAgICAgLy9UT0RPKGtzY2hhYWYpOiBleHBsaWNpdGx5IGRpc2FsbG93IHBhdGhzIGluIHNldFByb3BlcnR5P1xuICAgICAgICAgIC8vIHdpbGRjYXJkIG9ic2VydmVycyBjdXJyZW50bHkgb25seSBwYXNzIHRoZSBmaXJzdCBjaGFuZ2VkIHBhdGhcbiAgICAgICAgICAvLyBpbiB0aGUgYGluZm9gIG9iamVjdCwgYW5kIHlvdSBjb3VsZCBkbyBzb21lIG9kZCB0aGluZ3MgYmF0Y2hpbmdcbiAgICAgICAgICAvLyBwYXRocywgZS5nLiB7J2Zvby5iYXInOiB7Li4ufSwgJ2Zvbyc6IG51bGx9XG4gICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHByb3BzW3BhdGhdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCBzbyB0aGF0IHByb3BlcnR5IGFjY2Vzc29yXG4gICAgICogc2lkZSBlZmZlY3RzIGFyZSBub3QgZW5hYmxlZCB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGZ1bGx5IHJlYWR5LlxuICAgICAqIEFsc28gY2FsbHMgYF9mbHVzaENsaWVudHNgIGNhbGxiYWNrIHRvIGVuc3VyZSBjbGllbnQgZG9tIGlzIGVuYWJsZWRcbiAgICAgKiB0aGF0IHdhcyBub3QgZW5hYmxlZCBhcyBhIHJlc3VsdCBvZiBmbHVzaGluZyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCBgc3VwZXIucmVhZHkoKWAgaXMgbm90IGNhbGxlZCBoZXJlIGFzIGl0XG4gICAgICAvLyBpbW1lZGlhdGVseSB0dXJucyBvbiBhY2Nlc3NvcnMuIEluc3RlYWQsIHdlIHdhaXQgdW50aWwgYHJlYWR5Q2xpZW50c2BcbiAgICAgIC8vIHRvIGVuYWJsZSBhY2Nlc3NvcnMgdG8gcHJvdmlkZSBhIGd1YXJhbnRlZSB0aGF0IGNsaWVudHMgYXJlIHJlYWR5XG4gICAgICAvLyBiZWZvcmUgcHJvY2Vzc2luZyBhbnkgYWNjZXNzb3JzIHNpZGUgZWZmZWN0cy5cbiAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgLy8gSWYgbm8gZGF0YSB3YXMgcGVuZGluZywgYF9mbHVzaFByb3BlcnRpZXNgIHdpbGwgbm90IGBmbHVzaENsaWVudHNgXG4gICAgICAvLyBzbyBlbnN1cmUgdGhpcyBpcyBkb25lLlxuICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIH1cbiAgICAgIC8vIEJlZm9yZSByZWFkeSwgY2xpZW50IG5vdGlmaWNhdGlvbnMgZG8gbm90IHRyaWdnZXIgX2ZsdXNoUHJvcGVydGllcy5cbiAgICAgIC8vIFRoZXJlZm9yZSBhIGZsdXNoIGlzIG5lY2Vzc2FyeSBoZXJlIGlmIGRhdGEgaGFzIGJlZW4gc2V0LlxuICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGBQcm9wZXJ0eUFjY2Vzc29yc2AncyBwcm9wZXJ0aWVzIGNoYW5nZWQgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBSdW5zIGVhY2ggY2xhc3Mgb2YgZWZmZWN0cyBmb3IgdGhlIGJhdGNoIG9mIGNoYW5nZWQgcHJvcGVydGllcyBpblxuICAgICAqIGEgc3BlY2lmaWMgb3JkZXIgKGNvbXB1dGUsIHByb3BhZ2F0ZSwgcmVmbGVjdCwgb2JzZXJ2ZSwgbm90aWZ5KS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHtcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIGxldCBjID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hhbmdlZFByb3BzIHx8IHt9KTtcbiAgICAgIC8vIHdpbmRvdy5kZWJ1ZyAmJiBjb25zb2xlLmdyb3VwKHRoaXMubG9jYWxOYW1lICsgJyMnICsgdGhpcy5pZCArICc6ICcgKyBjKTtcbiAgICAgIC8vIGlmICh3aW5kb3cuZGVidWcpIHsgZGVidWdnZXI7IH1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGxldCBoYXNQYXRocyA9IHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICAvLyBDb21wdXRlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkNvbXB1dGVkRWZmZWN0cyh0aGlzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBDbGVhciBub3RpZnkgcHJvcGVydGllcyBwcmlvciB0byBwb3NzaWJsZSByZWVudHJ5IChwcm9wYWdhdGUsIG9ic2VydmUpLFxuICAgICAgLy8gYnV0IGFmdGVyIGNvbXB1dGluZyBlZmZlY3RzIGhhdmUgYSBjaGFuY2UgdG8gYWRkIHRvIHRoZW1cbiAgICAgIGxldCBub3RpZnlQcm9wcyA9IHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgIC8vIFByb3BhZ2F0ZSBwcm9wZXJ0aWVzIHRvIGNsaWVudHNcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBGbHVzaCBjbGllbnRzXG4gICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIC8vIFJlZmxlY3QgcHJvcGVydGllc1xuICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlJFRkxFQ1RdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBPYnNlcnZlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5PQlNFUlZFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gTm90aWZ5IHByb3BlcnRpZXMgdG8gaG9zdFxuICAgICAgaWYgKG5vdGlmeVByb3BzKSB7XG4gICAgICAgIHJ1bk5vdGlmeUVmZmVjdHModGhpcywgbm90aWZ5UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIHRlbXBvcmFyeSBjYWNoZSBhdCBlbmQgb2YgdHVyblxuICAgICAgaWYgKHRoaXMuX19kYXRhQ291bnRlciA9PSAxKSB7XG4gICAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgfVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXBFbmQodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwcm9wYWdhdGUgYW55IHByb3BlcnR5IGNoYW5nZXMgdG8gc3RhbXBlZCB0ZW1wbGF0ZSBub2Rlc1xuICAgICAqIG1hbmFnZWQgYnkgdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgaWYgKHRoaXNbVFlQRVMuUFJPUEFHQVRFXSkge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuUFJPUEFHQVRFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgfVxuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICB3aGlsZSAodGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcyxcbiAgICAgICAgICBoYXNQYXRocywgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXNlcyBvbmUgZGF0YSBwYXRoIGFzIGFub3RoZXIsIHN1Y2ggdGhhdCBwYXRoIG5vdGlmaWNhdGlvbnMgZnJvbSBvbmVcbiAgICAgKiBhcmUgcm91dGVkIHRvIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSB0byBUYXJnZXQgcGF0aCB0byBsaW5rLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBmcm9tIFNvdXJjZSBwYXRoIHRvIGxpbmsuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGxpbmtQYXRocyh0bywgZnJvbSkge1xuICAgICAgdG8gPSBub3JtYWxpemUodG8pO1xuICAgICAgZnJvbSA9IG5vcm1hbGl6ZShmcm9tKTtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzIHx8IHt9O1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1t0b10gPSBmcm9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkYXRhIHBhdGggYWxpYXMgcHJldmlvdXNseSBlc3RhYmxpc2hlZCB3aXRoIGBfbGlua1BhdGhzYC5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoZSBwYXRoIHRvIHVubGluayBzaG91bGQgYmUgdGhlIHRhcmdldCAoYHRvYCkgdXNlZCB3aGVuXG4gICAgICogbGlua2luZyB0aGUgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBUYXJnZXQgcGF0aCB0byB1bmxpbmsuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVubGlua1BhdGhzKHBhdGgpIHtcbiAgICAgIHBhdGggPSBub3JtYWxpemUocGF0aCk7XG4gICAgICBpZiAodGhpcy5fX2RhdGFMaW5rZWRQYXRocykge1xuICAgICAgICBkZWxldGUgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1twYXRoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgdGhhdCBhbiBhcnJheSBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgdGhpcy5pdGVtcyA9IFsge25hbWU6ICdKaW0nfSwge25hbWU6ICdUb2RkJ30sIHtuYW1lOiAnQmlsbCd9IF07XG4gICAgICogICAgIC4uLlxuICAgICAqICAgICB0aGlzLml0ZW1zLnNwbGljZSgxLCAxLCB7bmFtZTogJ1NhbSd9KTtcbiAgICAgKiAgICAgdGhpcy5pdGVtcy5wdXNoKHtuYW1lOiAnQm9iJ30pO1xuICAgICAqICAgICB0aGlzLm5vdGlmeVNwbGljZXMoJ2l0ZW1zJywgW1xuICAgICAqICAgICAgIHsgaW5kZXg6IDEsIHJlbW92ZWQ6IFt7bmFtZTogJ1RvZGQnfV0sIGFkZGVkQ291bnQ6IDEsIG9iZWN0OiB0aGlzLml0ZW1zLCB0eXBlOiAnc3BsaWNlJyB9LFxuICAgICAqICAgICAgIHsgaW5kZXg6IDMsIHJlbW92ZWQ6IFtdLCBhZGRlZENvdW50OiAxLCBvYmplY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnfVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3BsaWNlcyBBcnJheSBvZiBzcGxpY2UgcmVjb3JkcyBpbmRpY2F0aW5nIG9yZGVyZWRcbiAgICAgKiAgIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCB0byB0aGUgYXJyYXkuIEVhY2ggcmVjb3JkIHNob3VsZCBoYXZlIHRoZVxuICAgICAqICAgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgKiAgICAqIGluZGV4OiBpbmRleCBhdCB3aGljaCB0aGUgY2hhbmdlIG9jY3VycmVkXG4gICAgICogICAgKiByZW1vdmVkOiBhcnJheSBvZiBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgaW5kZXhcbiAgICAgKiAgICAqIGFkZGVkQ291bnQ6IG51bWJlciBvZiBuZXcgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICAgICAqICAgICogb2JqZWN0OiBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkgaW4gcXVlc3Rpb25cbiAgICAgKiAgICAqIHR5cGU6IHRoZSBzdHJpbmcgbGl0ZXJhbCAnc3BsaWNlJ1xuICAgICAqXG4gICAgICogICBOb3RlIHRoYXQgc3BsaWNlIHJlY29yZHMgX211c3RfIGJlIG5vcm1hbGl6ZWQgc3VjaCB0aGF0IHRoZXkgYXJlXG4gICAgICogICByZXBvcnRlZCBpbiBpbmRleCBvcmRlciAocmF3IHJlc3VsdHMgZnJvbSBgT2JqZWN0Lm9ic2VydmVgIGFyZSBub3RcbiAgICAgKiAgIG9yZGVyZWQgYW5kIG11c3QgYmUgbm9ybWFsaXplZC9tZXJnZWQgYmVmb3JlIG5vdGlmeWluZykuXG4gICAgICogQHB1YmxpY1xuICAgICovXG4gICAgbm90aWZ5U3BsaWNlcyhwYXRoLCBzcGxpY2VzKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBub3RpZnlTcGxpY2VzKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHNwbGljZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgcmVhZGluZyBhIHZhbHVlIGZyb20gYSBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW4gZGVyZWZlcmVuY2luZyB1bmRlZmluZWRcbiAgICAgKiBwYXRocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byByZWFkLiAgVGhlIHBhdGggbWF5IGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZS5nLiBgZm9vLmJhci5iYXpgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgdXNlcnMuMTIubmFtZWAgb3IgYFsndXNlcnMnLCAxMiwgJ25hbWUnXWApLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCB0aGUgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgKiAgIGlzIHVuZGVmaW5lZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0KHBhdGgsIHJvb3QpIHtcbiAgICAgIHJldHVybiBnZXQkMChyb290IHx8IHRoaXMsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3Igc2V0dGluZyBhIHZhbHVlIHRvIGEgcGF0aCBhbmQgbm90aWZ5aW5nIGFueVxuICAgICAqIGVsZW1lbnRzIGJvdW5kIHRvIHRoZSBzYW1lIHBhdGguXG4gICAgICpcbiAgICAgKiBOb3RlLCBpZiBhbnkgcGFydCBpbiB0aGUgcGF0aCBleGNlcHQgZm9yIHRoZSBsYXN0IGlzIHVuZGVmaW5lZCxcbiAgICAgKiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW5cbiAgICAgKiBkZXJlZmVyZW5jaW5nIHVuZGVmaW5lZCBwYXRocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byB3cml0ZS4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYCdmb28uYmFyLmJheidgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgJ3VzZXJzLjEyLm5hbWUnYCBvciBgWyd1c2VycycsIDEyLCAnbmFtZSddYCkuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiAgIFdoZW4gc3BlY2lmaWVkLCBubyBub3RpZmljYXRpb24gd2lsbCBvY2N1ci5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBzZXQocGF0aCwgdmFsdWUsIHJvb3QpIHtcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIHNldCQwKHJvb3QsIHBhdGgsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bLyoqIEB0eXBlIHtzdHJpbmd9ICovKHBhdGgpXSkge1xuICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgaXRlbXMgb250byB0aGUgZW5kIG9mIHRoZSBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnB1c2hgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBwdXNoIG9udG8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdXNoKHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucHVzaCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBsZW4sIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZW5kIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcG9wKHBhdGgpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBoYWRMZW5ndGggPSBCb29sZWFuKGFycmF5Lmxlbmd0aCk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucG9wKCk7XG4gICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBhcnJheS5sZW5ndGgsIDAsIFtyZXRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRpbmcgZnJvbSB0aGUgc3RhcnQgaW5kZXggc3BlY2lmaWVkLCByZW1vdmVzIDAgb3IgbW9yZSBpdGVtc1xuICAgICAqIGZyb20gdGhlIGFycmF5IGFuZCBpbnNlcnRzIDAgb3IgbW9yZSBuZXcgaXRlbXMgaW4gdGhlaXIgcGxhY2UuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgSW5kZXggZnJvbSB3aGljaCB0byBzdGFydCByZW1vdmluZy9pbnNlcnRpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGV0ZUNvdW50IE51bWJlciBvZiBpdGVtcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW50byBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgcmVtb3ZlZCBpdGVtcy5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3BsaWNlKHBhdGgsIHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGggOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAvLyBOb3JtYWxpemUgZmFuY3kgbmF0aXZlIHNwbGljZSBoYW5kbGluZyBvZiBjcmF6eSBzdGFydCB2YWx1ZXNcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBhcnJheS5sZW5ndGggLSBNYXRoLmZsb29yKC1zdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBsZXQgcmV0ID0gYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCB8fCByZXQubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBzdGFydCwgaXRlbXMubGVuZ3RoLCByZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2hpZnQocGF0aCkge1xuICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oZ2V0JDAodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgIGxldCByZXQgPSBhcnJheS5zaGlmdCgpO1xuICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgMCwgMCwgW3JldF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGluZm8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB1bnNoaWZ0KHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCBpdGVtcy5sZW5ndGgsIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoYXQgYSBwYXRoIGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICB0aGlzLml0ZW0udXNlci5uYW1lID0gJ0JvYic7XG4gICAgICogICAgIHRoaXMubm90aWZ5UGF0aCgnaXRlbS51c2VyLm5hbWUnKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgVmFsdWUgYXQgdGhlIHBhdGggKG9wdGlvbmFsKS5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBub3RpZnlQYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIGxldCBwcm9wUGF0aDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gR2V0IHZhbHVlIGlmIG5vdCBzdXBwbGllZFxuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIHZhbHVlID0gZ2V0JDAodGhpcywgcGF0aCwgaW5mbyk7XG4gICAgICAgIHByb3BQYXRoID0gaW5mby5wYXRoO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBwYXRoIGlmIG5lZWRlZFxuICAgICAgICBwcm9wUGF0aCA9IG5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BQYXRoID0gLyoqIEB0eXBle3N0cmluZ30gKi8ocGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHByb3BQYXRoLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwcm90ZWN0ZWRTZXR0ZXIgQ3JlYXRlcyBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyXG4gICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgICBpZiAocHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICAgIHRoaXNbJ19zZXQnICsgdXBwZXIocHJvcGVydHkpXSA9IC8qKiBAdGhpcyB7UHJvcGVydHlFZmZlY3RzfSAqL2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUHJvcGVydHlPYnNlcnZlcmAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZHluYW1pY0ZuIFdoZXRoZXIgdGhlIG1ldGhvZCBuYW1lIHNob3VsZCBiZSBpbmNsdWRlZCBhc1xuICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pIHtcbiAgICAgIGxldCBpbmZvID0geyBwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuOiBCb29sZWFuKGR5bmFtaWNGbikgfTtcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5PQlNFUlZFLCB7XG4gICAgICAgIGZuOiBydW5PYnNlcnZlckVmZmVjdCwgaW5mbywgdHJpZ2dlcjoge25hbWU6IHByb3BlcnR5fVxuICAgICAgfSk7XG4gICAgICBpZiAoZHluYW1pY0ZuKSB7XG4gICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KG1ldGhvZE5hbWUsIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBtZXRob2ROYW1lfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlTWV0aG9kT2JzZXJ2ZXJgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgb2JzZXJ2ZXIgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuT0JTRVJWRSwgcnVuTWV0aG9kRWZmZWN0LCBudWxsLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZLCB7XG4gICAgICAgIGZuOiBydW5Ob3RpZnlFZmZlY3QsXG4gICAgICAgIGluZm86IHtcbiAgICAgICAgICBldmVudE5hbWU6IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSArICctY2hhbmdlZCcsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICBsZXQgYXR0ciA9IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KTtcbiAgICAgIGlmIChhdHRyWzBdID09PSAnLScpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSAnICsgcHJvcGVydHkgKyAnIGNhbm5vdCBiZSByZWZsZWN0ZWQgdG8gYXR0cmlidXRlICcgK1xuICAgICAgICAgIGF0dHIgKyAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgc3RhcnRpbmcgYXR0cmlidXRlIG5hbWUuIFVzZSBhIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eSB0aGlzZWFkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFRkxFQ1QsIHtcbiAgICAgICAgICBmbjogcnVuUmVmbGVjdEVmZmVjdCxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBhdHRyTmFtZTogYXR0clxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZUNvbXB1dGVkUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgY29tcHV0ZWQgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuQ09NUFVURSwgcnVuQ29tcHV0ZWRFZmZlY3QsIHByb3BlcnR5LCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8vIC0tIHN0YXRpYyBjbGFzcyBtZXRob2RzIC0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhbiBhY2Nlc3NvciBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHksIGFuZCBhZGRzXG4gICAgICogdG8gYSBsaXN0IG9mIFwicHJvcGVydHkgZWZmZWN0c1wiIHRoYXQgd2lsbCBydW4gd2hlbiB0aGUgYWNjZXNzb3IgZm9yXG4gICAgICogdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpcyBzZXQuICBFZmZlY3RzIGFyZSBncm91cGVkIGJ5IFwidHlwZVwiLCB3aGljaFxuICAgICAqIHJvdWdobHkgY29ycmVzcG9uZHMgdG8gYSBwaGFzZSBpbiBlZmZlY3QgcHJvY2Vzc2luZy4gIFRoZSBlZmZlY3RcbiAgICAgKiBtZXRhZGF0YSBzaG91bGQgYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtOlxuICAgICAqXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBmbjogZWZmZWN0RnVuY3Rpb24sIC8vIFJlZmVyZW5jZSB0byBmdW5jdGlvbiB0byBjYWxsIHRvIHBlcmZvcm0gZWZmZWN0XG4gICAgICogICAgICAgaW5mbzogeyAuLi4gfSAgICAgICAvLyBFZmZlY3QgbWV0YWRhdGEgcGFzc2VkIHRvIGZ1bmN0aW9uXG4gICAgICogICAgICAgdHJpZ2dlcjogeyAgICAgICAgICAvLyBPcHRpb25hbCB0cmlnZ2VyaW5nIG1ldGFkYXRhOyBpZiBub3QgcHJvdmlkZWRcbiAgICAgKiAgICAgICAgIG5hbWU6IHN0cmluZyAgICAgIC8vIHRoZSBwcm9wZXJ0eSBpcyB0cmVhdGVkIGFzIGEgd2lsZGNhcmRcbiAgICAgKiAgICAgICAgIHN0cnVjdHVyZWQ6IGJvb2xlYW5cbiAgICAgKiAgICAgICAgIHdpbGRjYXJkOiBib29sZWFuXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBFZmZlY3RzIGFyZSBjYWxsZWQgZnJvbSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIGJ5XG4gICAgICogdHlwZTpcbiAgICAgKlxuICAgICAqIDEuIENPTVBVVEVcbiAgICAgKiAyLiBQUk9QQUdBVEVcbiAgICAgKiAzLiBSRUZMRUNUXG4gICAgICogNC4gT0JTRVJWRVxuICAgICAqIDUuIE5PVElGWVxuICAgICAqXG4gICAgICogRWZmZWN0IGZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gICAgICpcbiAgICAgKiAgICAgZWZmZWN0RnVuY3Rpb24oaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGFkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlLXByb3BlcnR5IG9ic2VydmVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICogICBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG11bHRpLXByb3BlcnR5IFwibWV0aG9kIG9ic2VydmVyXCIgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gICAgICogZXhwcmVzc2lvbiwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nIGluIHRoZSBmb3JtIG9mIGEgbm9ybWFsIEphdmFzY3JpcHRcbiAgICAgKiBmdW5jdGlvbiBzaWduYXR1cmU6IGAnbWV0aG9kTmFtZShhcmcxLCBbLi4uLCBhcmduXSknYC4gIEVhY2ggYXJndW1lbnRcbiAgICAgKiBzaG91bGQgY29ycmVzcG9uZCB0byBhIHByb3BlcnR5IG9yIHBhdGggaW4gdGhlIGNvbnRleHQgb2YgdGhpc1xuICAgICAqIHByb3RvdHlwZSAob3IgaW5zdGFuY2UpLCBvciBtYXkgYmUgYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byBkaXNwYXRjaCBgPHByb3BlcnR5Pi1jaGFuZ2VkYFxuICAgICAqIGV2ZW50cyB0byBub3RpZnkgb2YgY2hhbmdlcyB0byB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlYWQtb25seSBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVG8gc2V0IHRoZSBwcm9wZXJ0eSwgdXNlIHRoZSBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgQVBJLlxuICAgICAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyIChlLmcuIGBfc2V0TXlQcm9wKClgIGZvclxuICAgICAqIHByb3BlcnR5IGBteVByb3BgKSwgcGFzcyBgdHJ1ZWAgZm9yIGBwcm90ZWN0ZWRTZXR0ZXJgLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgdGhlIHByb3BlcnR5IHdpbGwgaGF2ZSBvdGhlciBwcm9wZXJ0eSBlZmZlY3RzLCB0aGlzIG1ldGhvZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QsIGJlZm9yZSBhZGRpbmcgb3RoZXIgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgc2V0dGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdG8gcmVmbGVjdCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgKiB0byBhIChkYXNoLWNhc2VkKSBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgc2V0IHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICogbWV0aG9kIGRlc2NyaWJlZCBieSB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGVhY2ggdGltZSBvbmUgb3IgbW9yZVxuICAgICAqIGFyZ3VtZW50cyB0byB0aGUgbWV0aG9kIGNoYW5nZXMuICBUaGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgYSBzdHJpbmdcbiAgICAgKiBpbiB0aGUgZm9ybSBvZiBhIG5vcm1hbCBKYXZhc2NyaXB0IGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgKiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAgICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIHRvIGVuc3VyZSBiaW5kaW5nIGVmZmVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgKiBmb3IgdGhlbSwgYW5kIHRoZW4gZW5zdXJlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIGNyZWF0ZWQgZm9yIGFueVxuICAgICAqIGRlcGVuZGVudCBwcm9wZXJ0aWVzIGluIHRoZSB0ZW1wbGF0ZS4gIEJpbmRpbmcgZWZmZWN0cyBmb3IgYm91bmRcbiAgICAgKiB0ZW1wbGF0ZXMgYXJlIHN0b3JlZCBpbiBhIGxpbmtlZCBsaXN0IG9uIHRoZSBpbnN0YW5jZSBzbyB0aGF0XG4gICAgICogdGVtcGxhdGVzIGNhbiBiZSBlZmZpY2llbnRseSBzdGFtcGVkIGFuZCB1bnN0YW1wZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAqICAgYmluZGluZ3NcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gLS0gYmluZGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYmluZFRlbXBsYXRlYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIHRoZSBwcm90b3R5cGUgKGZvciBwcm90b3R5cGljYWwgdGVtcGxhdGVcbiAgICAgKiBiaW5kaW5nLCB0byBhdm9pZCBjcmVhdGluZyBhY2Nlc3NvcnMgZXZlcnkgaW5zdGFuY2UpIG9uY2UgcGVyIHByb3RvdHlwZSxcbiAgICAgKiBhbmQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgcnVudGltZUJpbmRpbmc6IHRydWVgIGJ5IGBfc3RhbXBUZW1wbGF0ZWAgdG9cbiAgICAgKiBjcmVhdGUgYW5kIGxpbmsgYW4gaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgICogcGFydGljdWxhciBzdGFtcGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgY29udGFpbmluZyBiaW5kaW5nXG4gICAgICogICBiaW5kaW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluc3RhbmNlQmluZGluZyBXaGVuIGZhbHNlIChkZWZhdWx0KSwgcGVyZm9ybXNcbiAgICAgKiAgIFwicHJvdG90eXBpY2FsXCIgYmluZGluZyBvZiB0aGUgdGVtcGxhdGUgYW5kIG92ZXJ3cml0ZXMgYW55IHByZXZpb3VzbHlcbiAgICAgKiAgIGJvdW5kIHRlbXBsYXRlIGZvciB0aGUgY2xhc3MuIFdoZW4gdHJ1ZSAoYXMgcGFzc2VkIGZyb21cbiAgICAgKiAgIGBfc3RhbXBUZW1wbGF0ZWApLCB0aGUgdGVtcGxhdGUgaW5mbyBpcyBpbnN0YW5jZWQgYW5kIGxpbmtlZCBpbnRvXG4gICAgICogICB0aGUgbGlzdCBvZiBib3VuZCB0ZW1wbGF0ZXMuXG4gICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gVGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0OyBmb3IgYHJ1bnRpbWVCaW5kaW5nYCxcbiAgICAgKiAgIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSBpbmZvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIGluc3RhbmNlQmluZGluZykge1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IHdhc1ByZUJvdW5kID0gdGhpcy5fX3RlbXBsYXRlSW5mbyA9PSB0ZW1wbGF0ZUluZm87XG4gICAgICAvLyBPcHRpbWl6YXRpb246IHNpbmNlIHRoaXMgaXMgY2FsbGVkIHR3aWNlIGZvciBwcm90by1ib3VuZCB0ZW1wbGF0ZXMsXG4gICAgICAvLyBkb24ndCBhdHRlbXB0IHRvIHJlY3JlYXRlIGFjY2Vzc29ycyBpZiB0aGlzIHRlbXBsYXRlIHdhcyBwcmUtYm91bmRcbiAgICAgIGlmICghd2FzUHJlQm91bmQpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlQmluZGluZykge1xuICAgICAgICAvLyBGb3IgaW5zdGFuY2UtdGltZSBiaW5kaW5nLCBjcmVhdGUgaW5zdGFuY2Ugb2YgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAgLy8gYW5kIGxpbmsgaW50byBsaXN0IG9mIHRlbXBsYXRlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyhPYmplY3QuY3JlYXRlKHRlbXBsYXRlSW5mbykpO1xuICAgICAgICB0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQgPSB3YXNQcmVCb3VuZDtcbiAgICAgICAgaWYgKCF3YXNQcmVCb3VuZCAmJiB0aGlzLl9fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCB8fCB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID0gbGFzdC5uZXh0VGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IGxhc3Q7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX190ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHByb3BlcnR5IGVmZmVjdCB0byB0aGUgZ2l2ZW4gdGVtcGxhdGUgbWV0YWRhdGEsIHdoaWNoIGlzIHJ1blxuICAgICAqIGF0IHRoZSBcInByb3BhZ2F0ZVwiIHN0YWdlIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHdoZW4gdGhlIHRlbXBsYXRlXG4gICAgICogaGFzIGJlZW4gYm91bmQgdG8gdGhlIGVsZW1lbnQgdmlhIGBfYmluZFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgZWZmZWN0YCBvYmplY3Qgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgaW4gYF9hZGRQcm9wZXJ0eUVmZmVjdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIHRvIGFkZCBlZmZlY3QgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBfYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHByb3AsIGVmZmVjdCkge1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICAgICAgaG9zdFByb3BzW3Byb3BdID0gdHJ1ZTtcbiAgICAgIGxldCBlZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyA9IHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMgfHwge307XG4gICAgICBsZXQgcHJvcEVmZmVjdHMgPSBlZmZlY3RzW3Byb3BdID0gZWZmZWN0c1twcm9wXSB8fCBbXTtcbiAgICAgIHByb3BFZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFtcHMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGFuZCBwZXJmb3JtcyBpbnN0YW5jZS10aW1lIHNldHVwIGZvclxuICAgICAqIFBvbHltZXIgdGVtcGxhdGUgZmVhdHVyZXMsIGluY2x1ZGluZyBkYXRhIGJpbmRpbmdzLCBkZWNsYXJhdGl2ZSBldmVudFxuICAgICAqIGxpc3RlbmVycywgYW5kIHRoZSBgdGhpcy4kYCBtYXAgb2YgYGlkYCdzIHRvIG5vZGVzLiAgQSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqIGlzIHJldHVybmVkIGNvbnRhaW5pbmcgdGhlIHN0YW1wZWQgRE9NLCByZWFkeSBmb3IgaW5zZXJ0aW9uIGludG8gdGhlXG4gICAgICogRE9NLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZTsgaG93ZXZlciBub3RlIHRoYXQgZHVlIHRvXG4gICAgICogYHNoYWR5Y3NzYCBwb2x5ZmlsbCBsaW1pdGF0aW9ucywgb25seSBzdHlsZXMgZnJvbSB0ZW1wbGF0ZXMgcHJlcGFyZWRcbiAgICAgKiB1c2luZyBgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlYCB3aWxsIGJlIGNvcnJlY3RseSBwb2x5ZmlsbGVkIChzY29wZWRcbiAgICAgKiB0byB0aGUgc2hhZG93IHJvb3QgYW5kIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzKSwgYW5kIG5vdGUgdGhhdFxuICAgICAqIGBTaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVgIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBlbGVtZW50LiBBcyBzdWNoLFxuICAgICAqIGFueSBzdHlsZXMgcmVxdWlyZWQgYnkgaW4gcnVudGltZS1zdGFtcGVkIHRlbXBsYXRlcyBtdXN0IGJlIGluY2x1ZGVkXG4gICAgICogaW4gdGhlIG1haW4gZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIC8vIEVuc3VyZXMgdGhhdCBjcmVhdGVkIGRvbSBpcyBgX2VucXVldWVDbGllbnRgJ2QgdG8gdGhpcyBlbGVtZW50IHNvXG4gICAgICAvLyB0aGF0IGl0IGNhbiBiZSBmbHVzaGVkIG9uIG5leHQgY2FsbCB0byBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgIGhvc3RTdGFjay5iZWdpbkhvc3RpbmcodGhpcyk7XG4gICAgICBsZXQgZG9tID0gc3VwZXIuX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgaG9zdFN0YWNrLmVuZEhvc3RpbmcodGhpcyk7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyh0aGlzLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIHRydWUpKTtcbiAgICAgIC8vIEFkZCB0ZW1wbGF0ZS1pbnN0YW5jZS1zcGVjaWZpYyBkYXRhIHRvIGluc3RhbmNlZCB0ZW1wbGF0ZUluZm9cbiAgICAgIHRlbXBsYXRlSW5mby5ub2RlTGlzdCA9IGRvbS5ub2RlTGlzdDtcbiAgICAgIC8vIENhcHR1cmUgY2hpbGQgbm9kZXMgdG8gYWxsb3cgdW5zdGFtcGluZyBvZiBub24tcHJvdG90eXBpY2FsIHRlbXBsYXRlc1xuICAgICAgaWYgKCF0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbj1kb20uZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9tLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIDItd2F5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0IGZvciBiaW5kaW5nc1xuICAgICAgc2V0dXBCaW5kaW5ncyh0aGlzLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgLy8gRmx1c2ggcHJvcGVydGllcyBpbnRvIHRlbXBsYXRlIG5vZGVzIGlmIGFscmVhZHkgYm9vdGVkXG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMsIHRoaXMuX19kYXRhLCBudWxsLFxuICAgICAgICAgIGZhbHNlLCB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuZCB1bmJpbmRzIHRoZSBub2RlcyBwcmV2aW91c2x5IGNvbnRhaW5lZCBpbiB0aGUgcHJvdmlkZWRcbiAgICAgKiBEb2N1bWVudEZyYWdtZW50IHJldHVybmVkIGZyb20gYF9zdGFtcFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVN0YW1wZWRUZW1wbGF0ZX0gZG9tIERvY3VtZW50RnJhZ21lbnQgcHJldmlvdXNseSByZXR1cm5lZFxuICAgICAqICAgZnJvbSBgX3N0YW1wVGVtcGxhdGVgIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZXMgdG8gYmUgcmVtb3ZlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlQm91bmREb20oZG9tKSB7XG4gICAgICAvLyBVbmxpbmsgdGVtcGxhdGUgaW5mb1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IGRvbS50ZW1wbGF0ZUluZm87XG4gICAgICBpZiAodGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID1cbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbykge1xuICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID09IHRlbXBsYXRlSW5mbykge1xuICAgICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCA9IHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBzdGFtcGVkIG5vZGVzXG4gICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGk9MDsgaTxub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnNpbmcgYmluZGluZ3MgZnJvbSBgVGV4dE5vZGVgJ3MnIGB0ZXh0Q29udGVudGAuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgbGV0IG5vdGVkID0gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3Mobm9kZS50ZXh0Q29udGVudCwgdGVtcGxhdGVJbmZvKTtcbiAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdGV4dENvbnRlbnQgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICAgIC8vIE5PVEU6IGRlZmF1bHQgdG8gYSBzcGFjZSBoZXJlIHNvIHRoZSB0ZXh0Tm9kZSByZW1haW5zOyBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgLy8gKElFKSBldmFjaXBhdGUgYW4gZW1wdHkgdGV4dE5vZGUgZm9sbG93aW5nIGNsb25lTm9kZS9pbXBvcnROb2RlLlxuICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB8fCAnICc7XG4gICAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAndGV4dCcsICd0ZXh0Q29udGVudCcsIHBhcnRzKTtcbiAgICAgICAgICBub3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogcGFyc2luZyBiaW5kaW5ncyBmcm9tIGF0dHJpYnV0ZXMuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3ModmFsdWUsIHRlbXBsYXRlSW5mbyk7XG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgLy8gQXR0cmlidXRlIG9yIHByb3BlcnR5XG4gICAgICAgIGxldCBvcmlnTmFtZSA9IG5hbWU7XG4gICAgICAgIGxldCBraW5kID0gJ3Byb3BlcnR5JztcbiAgICAgICAgaWYgKG5hbWVbbmFtZS5sZW5ndGgtMV0gPT0gJyQnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIGtpbmQgPSAnYXR0cmlidXRlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIGF0dHJpYnV0ZSBiaW5kaW5ncyB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgIGxldCBsaXRlcmFsID0gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cyk7XG4gICAgICAgIGlmIChsaXRlcmFsICYmIGtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBsaXRlcmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBhdHRyaWJ1dGUgYmVmb3JlIHJlbW92aW5nLCBzaW5jZSBJRSB3b24ndCBhbGxvdyByZW1vdmluZ1xuICAgICAgICAvLyBgdmFsdWVgIGF0dHJpYnV0ZSBpZiBpdCBwcmV2aW91c2x5IGhhZCBhIHZhbHVlIChjYW4ndFxuICAgICAgICAvLyB1bmNvbmRpdGlvbmFsbHkgc2V0ICcnIGJlZm9yZSByZW1vdmluZyBzaW5jZSBhdHRyaWJ1dGVzIHdpdGggYCRgXG4gICAgICAgIC8vIGNhbid0IGJlIHNldCB1c2luZyBzZXRBdHRyaWJ1dGUpXG4gICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiBvcmlnTmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG9yaWdOYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFubm90YXRpb25cbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUob3JpZ05hbWUpO1xuICAgICAgICAvLyBDYXNlIGhhY2tlcnk6IGF0dHJpYnV0ZXMgYXJlIGxvd2VyLWNhc2UsIGJ1dCBiaW5kIHRhcmdldHNcbiAgICAgICAgLy8gKHByb3BlcnRpZXMpIGFyZSBjYXNlIHNlbnNpdGl2ZS4gR2FtYml0IGlzIHRvIG1hcCBkYXNoLWNhc2UgdG9cbiAgICAgICAgLy8gY2FtZWwtY2FzZTogYGZvby1iYXJgIGJlY29tZXMgYGZvb0JhcmAuXG4gICAgICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5ncyBhcmUgZXhjZXB0ZWQuXG4gICAgICAgIGlmIChraW5kID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgbmFtZSA9IGRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIG5hbWUsIHBhcnRzLCBsaXRlcmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogYmluZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IGEgbmVzdGVkIHRlbXBsYXRlIGRlcGVuZHMgb24gdG8gdGhlIHRlbXBsYXRlXG4gICAgICogYXMgYF9ob3N0Xzxwcm9wZXJ0eT5gLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgbm90ZWQgPSBzdXBlci5fcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgLy8gTWVyZ2UgaG9zdCBwcm9wcyBpbnRvIG91dGVyIHRlbXBsYXRlIGFuZCBhZGQgYmluZGluZ3NcbiAgICAgIGxldCBob3N0UHJvcHMgPSBub2RlSW5mby50ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgbGV0IG1vZGUgPSAneyc7XG4gICAgICBmb3IgKGxldCBzb3VyY2UgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFt7IG1vZGUsIHNvdXJjZSwgZGVwZW5kZW5jaWVzOiBbc291cmNlXSB9XTtcbiAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAncHJvcGVydHknLCAnX2hvc3RfJyArIHNvdXJjZSwgcGFydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwYXJzZSB0ZXh0IGluIGEgdGVtcGxhdGUgKGVpdGhlciBhdHRyaWJ1dGUgdmFsdWVzIG9yXG4gICAgICogdGV4dENvbnRlbnQpIGludG8gYmluZGluZyBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEFueSBvdmVycmlkZXMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBiaW5kaW5nIHBhcnRcbiAgICAgKiBtZXRhZGF0YSAgcmVwcmVzZW50aW5nIG9uZSBvciBtb3JlIGJpbmRpbmdzIGZvdW5kIGluIHRoZSBwcm92aWRlZCB0ZXh0XG4gICAgICogYW5kIGFueSBcImxpdGVyYWxcIiB0ZXh0IGluIGJldHdlZW4uICBBbnkgbm9uLWxpdGVyYWwgcGFydHMgd2lsbCBiZSBwYXNzZWRcbiAgICAgKiB0byBgX2V2YWx1YXRlQmluZGluZ2Agd2hlbiBhbnkgZGVwZW5kZW5jaWVzIGNoYW5nZS4gIFRoZSBvbmx5IHJlcXVpcmVkXG4gICAgICogZmllbGRzIG9mIGVhY2ggXCJwYXJ0XCIgaW4gdGhlIHJldHVybmVkIGFycmF5IGFyZSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogLSBgZGVwZW5kZW5jaWVzYCAtIEFycmF5IGNvbnRhaW5pbmcgdHJpZ2dlciBtZXRhZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgYmluZGluZyB0byB1cGRhdGVcbiAgICAgKiAtIGBsaXRlcmFsYCAtIFN0cmluZyBjb250YWluaW5nIHRleHQgaWYgdGhlIHBhcnQgcmVwcmVzZW50cyBhIGxpdGVyYWw7XG4gICAgICogICBpbiB0aGlzIGNhc2Ugbm8gYGRlcGVuZGVuY2llc2AgYXJlIG5lZWRlZFxuICAgICAqXG4gICAgICogQWRkaXRpb25hbCBtZXRhZGF0YSBmb3IgdXNlIGJ5IGBfZXZhbHVhdGVCaW5kaW5nYCBtYXkgYmUgcHJvdmlkZWQgaW5cbiAgICAgKiBlYWNoIHBhcnQgb2JqZWN0IGFzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhhbmRsZXMgdGhlIGZvbGxvd2luZyB0eXBlcyBvZiBiaW5kaW5nc1xuICAgICAqIChvbmUgb3IgbW9yZSBtYXkgYmUgaW50ZXJtaXhlZCB3aXRoIGxpdGVyYWwgc3RyaW5ncyk6XG4gICAgICogLSBQcm9wZXJ0eSBiaW5kaW5nOiBgW1twcm9wXV1gXG4gICAgICogLSBQYXRoIGJpbmRpbmc6IGBbW29iamVjdC5wcm9wXV1gXG4gICAgICogLSBOZWdhdGVkIHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3M6IGBbWyFwcm9wXV1gIG9yIGBbWyFvYmplY3QucHJvcF1dYFxuICAgICAqIC0gVHdvLXdheSBwcm9wZXJ0eSBvciBwYXRoIGJpbmRpbmdzIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBge3twcm9wfX1gLCBge3tvYmplY3QucHJvcH19YCwgYHt7IXByb3B9fWAgb3IgYHt7IW9iamVjdC5wcm9wfX1gXG4gICAgICogLSBJbmxpbmUgY29tcHV0ZWQgbWV0aG9kIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBgW1tjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWAsIGBbWyFjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGFyc2UgZnJvbSBhdHRyaWJ1dGUgb3IgdGV4dENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIEN1cnJlbnQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHtBcnJheTwhQmluZGluZ1BhcnQ+fSBBcnJheSBvZiBiaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZUJpbmRpbmdzKHRleHQsIHRlbXBsYXRlSW5mbykge1xuICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtO1xuICAgICAgLy8gRXhhbXBsZTogXCJsaXRlcmFsMXt7cHJvcH19bGl0ZXJhbDJbWyFjb21wdXRlKGZvbyxiYXIpXV1maW5hbFwiXG4gICAgICAvLyBSZWdleCBtYXRjaGVzOlxuICAgICAgLy8gICAgICAgIEl0ZXJhdGlvbiAxOiAgSXRlcmF0aW9uIDI6XG4gICAgICAvLyBtWzFdOiAne3snICAgICAgICAgICdbWydcbiAgICAgIC8vIG1bMl06ICcnICAgICAgICAgICAgJyEnXG4gICAgICAvLyBtWzNdOiAncHJvcCcgICAgICAgICdjb21wdXRlKGZvbyxiYXIpJ1xuICAgICAgd2hpbGUgKChtID0gYmluZGluZ1JlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFkZCBsaXRlcmFsIHBhcnRcbiAgICAgICAgaWYgKG0uaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtsaXRlcmFsOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgbS5pbmRleCl9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYmluZGluZyBwYXJ0XG4gICAgICAgIGxldCBtb2RlID0gbVsxXVswXTtcbiAgICAgICAgbGV0IG5lZ2F0ZSA9IEJvb2xlYW4obVsyXSk7XG4gICAgICAgIGxldCBzb3VyY2UgPSBtWzNdLnRyaW0oKTtcbiAgICAgICAgbGV0IGN1c3RvbUV2ZW50ID0gZmFsc2UsIG5vdGlmeUV2ZW50ID0gJycsIGNvbG9uID0gLTE7XG4gICAgICAgIGlmIChtb2RlID09ICd7JyAmJiAoY29sb24gPSBzb3VyY2UuaW5kZXhPZignOjonKSkgPiAwKSB7XG4gICAgICAgICAgbm90aWZ5RXZlbnQgPSBzb3VyY2Uuc3Vic3RyaW5nKGNvbG9uICsgMik7XG4gICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBjb2xvbik7XG4gICAgICAgICAgY3VzdG9tRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWduYXR1cmUgPSBwYXJzZU1ldGhvZChzb3VyY2UpO1xuICAgICAgICBsZXQgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAvLyBJbmxpbmUgY29tcHV0ZWQgZnVuY3Rpb25cbiAgICAgICAgICBsZXQge2FyZ3MsIG1ldGhvZE5hbWV9ID0gc2lnbmF0dXJlO1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucztcbiAgICAgICAgICBpZiAoZHluYW1pY0ZucyAmJiBkeW5hbWljRm5zW21ldGhvZE5hbWVdIHx8IHNpZ25hdHVyZS5zdGF0aWMpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgc2lnbmF0dXJlLmR5bmFtaWNGbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFByb3BlcnR5IG9yIHBhdGhcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZSwgbW9kZSwgbmVnYXRlLCBjdXN0b21FdmVudCwgc2lnbmF0dXJlLCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgZXZlbnQ6IG5vdGlmeUV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0SW5kZXggPSBiaW5kaW5nUmVnZXgubGFzdEluZGV4O1xuICAgICAgfVxuICAgICAgLy8gQWRkIGEgZmluYWwgbGl0ZXJhbCBwYXJ0XG4gICAgICBpZiAobGFzdEluZGV4ICYmIGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaXRlcmFsID0gdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4KTtcbiAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGxpdGVyYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gZXZhbHVhdGUgYSBwcmV2aW91c2x5IHBhcnNlZCBiaW5kaW5nIHBhcnQgYmFzZWQgb24gYSBzZXQgb2ZcbiAgICAgKiBvbmUgb3IgbW9yZSBjaGFuZ2VkIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dGhpc30gaW5zdCBFbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgc2NvcGUgZm9yXG4gICAgICogICBiaW5kaW5nIGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7QmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCB0aGF0IHRyaWdnZXJlZCB0aGlzIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSB0aGUgYmluZGluZyBwYXJ0IGV2YWx1YXRlZCB0b1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgX2V2YWx1YXRlQmluZGluZyhpbnN0LCBwYXJ0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBpZiAocGFydC5zaWduYXR1cmUpIHtcbiAgICAgICAgdmFsdWUgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBwYXJ0LnNpZ25hdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdGggIT0gcGFydC5zb3VyY2UpIHtcbiAgICAgICAgdmFsdWUgPSBnZXQkMChpbnN0LCBwYXJ0LnNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzUGF0aHMgJiYgaXNQYXRoJDAocGF0aCkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldCQwKGluc3QsIHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gaW5zdC5fX2RhdGFbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0Lm5lZ2F0ZSkge1xuICAgICAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIG1ha2UgYSB0eXBpbmcgZm9yIGNsb3N1cmUgOlBcbiAgUHJvcGVydHlFZmZlY3RzVHlwZSA9IFByb3BlcnR5RWZmZWN0cztcblxuICByZXR1cm4gUHJvcGVydHlFZmZlY3RzO1xufSk7XG5cbi8qKlxuICogSGVscGVyIGFwaSBmb3IgZW5xdWVpbmcgY2xpZW50IGRvbSBjcmVhdGVkIGJ5IGEgaG9zdCBlbGVtZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQgZWxlbWVudHMgYXJlIGZsdXNoZWQgdmlhIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aGVuXG4gKiBgY29ubmVjdGVkQ2FsbGJhY2tgIGlzIGNhbGxlZC4gRWxlbWVudHMgYXR0YWNoIHRoZWlyIGNsaWVudCBkb20gdG9cbiAqIHRoZW1zZWx2ZXMgYXQgYHJlYWR5YCB0aW1lIHdoaWNoIHJlc3VsdHMgZnJvbSB0aGlzIGZpcnN0IGZsdXNoLlxuICogVGhpcyBwcm92aWRlcyBhbiBvcmRlcmluZyBndWFyYW50ZWUgdGhhdCB0aGUgY2xpZW50IGRvbSBhbiBlbGVtZW50XG4gKiBjcmVhdGVzIGlzIGZsdXNoZWQgYmVmb3JlIHRoZSBlbGVtZW50IGl0c2VsZiAoaS5lLiBjbGllbnQgYHJlYWR5YFxuICogZmlyZXMgYmVmb3JlIGhvc3QgYHJlYWR5YCkuXG4gKlxuICogSG93ZXZlciwgaWYgYF9mbHVzaFByb3BlcnRpZXNgIGlzIGNhbGxlZCAqYmVmb3JlKiBhbiBlbGVtZW50IGlzIGNvbm5lY3RlZCxcbiAqIGFzIGZvciBleGFtcGxlIGBUZW1wbGF0aXplYCBkb2VzLCB0aGlzIG9yZGVyaW5nIGd1YXJhbnRlZSBjYW5ub3QgYmVcbiAqIHNhdGlzZmllZCBiZWNhdXNlIG5vIGVsZW1lbnRzIGFyZSBjb25uZWN0ZWQuIChOb3RlOiBCb3VuZCBlbGVtZW50cyB0aGF0XG4gKiByZWNlaXZlIGRhdGEgZG8gYmVjb21lIGVucXVldWVkIGNsaWVudHMgYW5kIGFyZSBwcm9wZXJseSBvcmRlcmVkIGJ1dFxuICogdW5ib3VuZCBlbGVtZW50cyBhcmUgbm90LilcbiAqXG4gKiBUbyBtYWludGFpbiB0aGUgZGVzaXJlZCBcImNsaWVudCBiZWZvcmUgaG9zdFwiIG9yZGVyaW5nIGd1YXJhbnRlZSBmb3IgdGhpc1xuICogY2FzZSB3ZSByZWx5IG9uIHRoZSBcImhvc3Qgc3RhY2suIENsaWVudCBub2RlcyByZWdpc3RlcnMgdGhlbXNlbHZlcyB3aXRoXG4gKiB0aGUgY3JlYXRpbmcgaG9zdCBlbGVtZW50IHdoZW4gY3JlYXRlZC4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsIGNsaWVudCBkb21cbiAqIGlzIHJlYWRpZWQgaW4gdGhlIHByb3BlciBvcmRlciwgbWFpbnRhaW5pbmcgdGhlIGRlc2lyZWQgZ3VhcmFudGVlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmxldCBob3N0U3RhY2sgPSB7XG5cbiAgc3RhY2s6IFtdLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYWRkIHRvIGhvc3RTdGFja1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgcmVnaXN0ZXJIb3N0KGluc3QpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIGxldCBob3N0ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXTtcbiAgICAgIGhvc3QuX2VucXVldWVDbGllbnQoaW5zdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYmVnaW4gaG9zdGluZ1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgYmVnaW5Ib3N0aW5nKGluc3QpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goaW5zdCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5zdCBJbnN0YW5jZSB0byBlbmQgaG9zdGluZ1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgZW5kSG9zdGluZyhpbnN0KSB7XG4gICAgbGV0IHN0YWNrTGVuID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgaWYgKHN0YWNrTGVuICYmIHRoaXMuc3RhY2tbc3RhY2tMZW4tMV0gPT0gaW5zdCkge1xuICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBzY2hlZHVsZWQgPSBmYWxzZTtcbmxldCBiZWZvcmVSZW5kZXJRdWV1ZSA9IFtdO1xubGV0IGFmdGVyUmVuZGVyUXVldWUgPSBbXTtcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gIHNjaGVkdWxlZCA9IHRydWU7XG4gIC8vIGJlZm9yZSBuZXh0IHJlbmRlclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgZmx1c2hRdWV1ZShiZWZvcmVSZW5kZXJRdWV1ZSk7XG4gICAgLy8gYWZ0ZXIgdGhlIHJlbmRlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBydW5RdWV1ZShhZnRlclJlbmRlclF1ZXVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUXVldWUocXVldWUpIHtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuUXVldWUocXVldWUpIHtcbiAgZm9yIChsZXQgaT0wLCBsPXF1ZXVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbE1ldGhvZChpbmZvKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBpbmZvWzBdO1xuICBjb25zdCBjYWxsYmFjayA9IGluZm9bMV07XG4gIGNvbnN0IGFyZ3MgPSBpbmZvWzJdO1xuICB0cnkge1xuICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gIHdoaWxlIChiZWZvcmVSZW5kZXJRdWV1ZS5sZW5ndGggfHwgYWZ0ZXJSZW5kZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICBmbHVzaFF1ZXVlKGJlZm9yZVJlbmRlclF1ZXVlKTtcbiAgICBmbHVzaFF1ZXVlKGFmdGVyUmVuZGVyUXVldWUpO1xuICB9XG4gIHNjaGVkdWxlZCA9IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlTmV4dFJlbmRlcihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICBpZiAoIXNjaGVkdWxlZCkge1xuICAgIHNjaGVkdWxlKCk7XG4gIH1cbiAgYmVmb3JlUmVuZGVyUXVldWUucHVzaChbY29udGV4dCwgY2FsbGJhY2ssIGFyZ3NdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyTmV4dFJlbmRlcihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICBpZiAoIXNjaGVkdWxlZCkge1xuICAgIHNjaGVkdWxlKCk7XG4gIH1cbiAgYWZ0ZXJSZW5kZXJRdWV1ZS5wdXNoKFtjb250ZXh0LCBjYWxsYmFjaywgYXJnc10pO1xufVxuXG5leHBvcnQgeyBmbHVzaCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVuZGVyLXN0YXR1cy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5sZXQgZGVib3VuY2VyUXVldWUgPSBbXTtcblxuZXhwb3J0IGNvbnN0IGVucXVldWVEZWJvdW5jZXIgPSBmdW5jdGlvbihkZWJvdW5jZXIpIHtcbiAgZGVib3VuY2VyUXVldWUucHVzaChkZWJvdW5jZXIpO1xufTtcblxuZnVuY3Rpb24gZmx1c2hEZWJvdW5jZXJzKCkge1xuICBjb25zdCBkaWRGbHVzaCA9IEJvb2xlYW4oZGVib3VuY2VyUXVldWUubGVuZ3RoKTtcbiAgd2hpbGUgKGRlYm91bmNlclF1ZXVlLmxlbmd0aCkge1xuICAgIHRyeSB7XG4gICAgICBkZWJvdW5jZXJRdWV1ZS5zaGlmdCgpLmZsdXNoKCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlkRmx1c2g7XG59XG5cbmV4cG9ydCBjb25zdCBmbHVzaCA9IGZ1bmN0aW9uKCkge1xuICBsZXQgc2hhZHlET00sIGRlYm91bmNlcnM7XG4gIGRvIHtcbiAgICBzaGFkeURPTSA9IHdpbmRvdy5TaGFkeURPTSAmJiBTaGFkeURPTS5mbHVzaCgpO1xuICAgIGlmICh3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltKSB7XG4gICAgICB3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0uZmx1c2goKTtcbiAgICB9XG4gICAgZGVib3VuY2VycyA9IGZsdXNoRGVib3VuY2VycygpO1xuICB9IHdoaWxlIChzaGFkeURPTSB8fCBkZWJvdW5jZXJzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlFZmZlY3RzIH0gZnJvbSAnLi4vbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanMnO1xuaW1wb3J0IHsgTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcblxuLy8gQmFzZSBjbGFzcyBmb3IgSFRNTFRlbXBsYXRlRWxlbWVudCBleHRlbnNpb24gdGhhdCBoYXMgcHJvcGVydHkgZWZmZWN0c1xuLy8gbWFjaGluZXJ5IGZvciBwcm9wYWdhdGluZyBob3N0IHByb3BlcnRpZXMgdG8gY2hpbGRyZW4uIFRoaXMgaXMgYW4gRVM1XG4vLyBjbGFzcyBvbmx5IGJlY2F1c2UgQmFiZWwgKGluY29ycmVjdGx5KSByZXF1aXJlcyBzdXBlcigpIGluIHRoZSBjbGFzc1xuLy8gY29uc3RydWN0b3IgZXZlbiB0aG91Z2ggbm8gYHRoaXNgIGlzIHVzZWQgYW5kIGl0IHJldHVybnMgYW4gaW5zdGFuY2UuXG5sZXQgbmV3SW5zdGFuY2UgPSBudWxsO1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtIVE1MVGVtcGxhdGVFbGVtZW50fVxuICovXG5mdW5jdGlvbiBIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uKCkgeyByZXR1cm4gbmV3SW5zdGFuY2U7IH1cbkhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShIVE1MVGVtcGxhdGVFbGVtZW50LnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge1xuICAgIHZhbHVlOiBIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH1cbn0pO1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAqIEBleHRlbmRzIHtIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9ufVxuICovXG5jb25zdCBEYXRhVGVtcGxhdGUgPSBQcm9wZXJ0eUVmZmVjdHMoSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbik7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gKiBAZXh0ZW5kcyB7RGF0YVRlbXBsYXRlfVxuICovXG5jb25zdCBNdXRhYmxlRGF0YVRlbXBsYXRlID0gTXV0YWJsZURhdGEoRGF0YVRlbXBsYXRlKTtcblxuLy8gQXBwbGllcyBhIERhdGFUZW1wbGF0ZSBzdWJjbGFzcyB0byBhIDx0ZW1wbGF0ZT4gaW5zdGFuY2VcbmZ1bmN0aW9uIHVwZ3JhZGVUZW1wbGF0ZSh0ZW1wbGF0ZSwgY29uc3RydWN0b3IpIHtcbiAgbmV3SW5zdGFuY2UgPSB0ZW1wbGF0ZTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRlbXBsYXRlLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICBuZXcgY29uc3RydWN0b3IoKTtcbiAgbmV3SW5zdGFuY2UgPSBudWxsO1xufVxuXG4vLyBCYXNlIGNsYXNzIGZvciBUZW1wbGF0ZUluc3RhbmNlJ3Ncbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gKi9cbmNvbnN0IGJhc2UgPSBQcm9wZXJ0eUVmZmVjdHMoY2xhc3Mge30pO1xuXG4vKipcbiAqIEBwb2x5bWVyXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c1xuICogQHVucmVzdHJpY3RlZFxuICovXG5jbGFzcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBleHRlbmRzIGJhc2Uge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29uZmlndXJlUHJvcGVydGllcyhwcm9wcyk7XG4gICAgdGhpcy5yb290ID0gdGhpcy5fc3RhbXBUZW1wbGF0ZSh0aGlzLl9fZGF0YUhvc3QpO1xuICAgIC8vIFNhdmUgbGlzdCBvZiBzdGFtcGVkIGNoaWxkcmVuXG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIGZvciAobGV0IG4gPSB0aGlzLnJvb3QuZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKG4pO1xuICAgICAgbi5fX3RlbXBsYXRpemVJbnN0YW5jZSA9IHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fdGVtcGxhdGl6ZU93bmVyLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXykge1xuICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbih0cnVlKTtcbiAgICB9XG4gICAgLy8gRmx1c2ggcHJvcHMgb25seSB3aGVuIHByb3BzIGFyZSBwYXNzZWQgaWYgaW5zdGFuY2UgcHJvcHMgZXhpc3RcbiAgICAvLyBvciB3aGVuIHRoZXJlIGlzbid0IGluc3RhbmNlIHByb3BzLlxuICAgIGxldCBvcHRpb25zID0gdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zO1xuICAgIGlmICgocHJvcHMgJiYgb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB8fCAhb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB7XG4gICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb25maWd1cmUgdGhlIGdpdmVuIGBwcm9wc2AgYnkgY2FsbGluZyBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuIEFsc29cbiAgICogc2V0cyBhbnkgcHJvcGVydGllcyBzdG9yZWQgaW4gYF9faG9zdFByb3BzYC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIE9iamVjdCBvZiBwcm9wZXJ0eSBuYW1lLXZhbHVlIHBhaXJzIHRvIHNldC5cbiAgICovXG4gIF9jb25maWd1cmVQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBmb3IgKGxldCBpcHJvcCBpbiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgaWYgKGlwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KGlwcm9wLCBwcm9wc1tpcHJvcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGhwcm9wIGluIHRoaXMuX19ob3N0UHJvcHMpIHtcbiAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShocHJvcCwgdGhpcy5fX2RhdGFIb3N0WydfaG9zdF8nICsgaHByb3BdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZvcndhcmRzIGEgaG9zdCBwcm9wZXJ0eSB0byB0aGlzIGluc3RhbmNlLiAgVGhpcyBtZXRob2Qgc2hvdWxkIGJlXG4gICAqIGNhbGxlZCBvbiBpbnN0YW5jZXMgZnJvbSB0aGUgYG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wYCBjYWxsYmFja1xuICAgKiB0byBwcm9wYWdhdGUgY2hhbmdlcyBvZiBob3N0IHByb3BlcnRpZXMgdG8gZWFjaCBpbnN0YW5jZS5cbiAgICpcbiAgICogTm90ZSB0aGlzIG1ldGhvZCBlbnF1ZXVlcyB0aGUgY2hhbmdlLCB3aGljaCBhcmUgZmx1c2hlZCBhcyBhIGJhdGNoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBvciBwYXRoIG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gZm9yd2FyZFxuICAgKi9cbiAgZm9yd2FyZEhvc3RQcm9wKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwcm9wLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICB0aGlzLl9fZGF0YUhvc3QuX2VucXVldWVDbGllbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICh0aGlzLl9tZXRob2RIb3N0ICYmIHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucy5wYXJlbnRNb2RlbCkge1xuICAgICAgLy8gSWYgdGhpcyBpbnN0YW5jZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIHBhcmVudCBtb2RlbCwgZGVjb3JhdGVcbiAgICAgIC8vIGV2ZW50cyB0aGlzIHRlbXBsYXRlIGluc3RhbmNlIGFzIGBtb2RlbGBcbiAgICAgIHRoaXMuX21ldGhvZEhvc3QuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCAoZSkgPT4ge1xuICAgICAgICBlLm1vZGVsID0gdGhpcztcbiAgICAgICAgaGFuZGxlcihlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgZGVsZWdhdGUgdG8gdGhlIHRlbXBsYXRlJ3MgaG9zdCAod2hpY2ggY291bGQgYmUpXG4gICAgICAvLyBhbm90aGVyIHRlbXBsYXRlIGluc3RhbmNlXG4gICAgICBsZXQgdGVtcGxhdGVIb3N0ID0gdGhpcy5fX2RhdGFIb3N0Ll9fZGF0YUhvc3Q7XG4gICAgICBpZiAodGVtcGxhdGVIb3N0KSB7XG4gICAgICAgIHRlbXBsYXRlSG9zdC5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2hvd3Mgb3IgaGlkZXMgdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRvcCBsZXZlbCBjaGlsZCBlbGVtZW50cy4gRm9yXG4gICAqIHRleHQgbm9kZXMsIGB0ZXh0Q29udGVudGAgaXMgcmVtb3ZlZCB3aGlsZSBcImhpZGRlblwiIGFuZCByZXBsYWNlZCB3aGVuXG4gICAqIFwic2hvd24uXCJcbiAgICogQHBhcmFtIHtib29sZWFufSBoaWRlIFNldCB0byB0cnVlIHRvIGhpZGUgdGhlIGNoaWxkcmVuO1xuICAgKiBzZXQgdG8gZmFsc2UgdG8gc2hvdyB0aGVtLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2hvd0hpZGVDaGlsZHJlbihoaWRlKSB7XG4gICAgbGV0IGMgPSB0aGlzLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGk9MDsgaTxjLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbiA9IGNbaV07XG4gICAgICAvLyBJZ25vcmUgbm9uLWNoYW5nZXNcbiAgICAgIGlmIChCb29sZWFuKGhpZGUpICE9IEJvb2xlYW4obi5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18pKSB7XG4gICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICBuLl9fcG9seW1lclRleHRDb250ZW50X18gPSBuLnRleHRDb250ZW50O1xuICAgICAgICAgICAgbi50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuLnRleHRDb250ZW50ID0gbi5fX3BvbHltZXJUZXh0Q29udGVudF9fO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuLnN0eWxlKSB7XG4gICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgIG4uX19wb2x5bWVyRGlzcGxheV9fID0gbi5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuLnN0eWxlLmRpc3BsYXkgPSBuLl9fcG9seW1lckRpc3BsYXlfXztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4uX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fID0gaGlkZTtcbiAgICAgIGlmIChuLl9zaG93SGlkZUNoaWxkcmVuKSB7XG4gICAgICAgIG4uX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgZGVmYXVsdCBwcm9wZXJ0eS1lZmZlY3RzIGltcGxlbWVudGF0aW9uIHRvIGludGVyY2VwdFxuICAgKiB0ZXh0Q29udGVudCBiaW5kaW5ncyB3aGlsZSBjaGlsZHJlbiBhcmUgXCJoaWRkZW5cIiBhbmQgY2FjaGUgaW5cbiAgICogcHJpdmF0ZSBzdG9yYWdlIGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKG5vZGUuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fICYmXG4gICAgICAgIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5URVhUX05PREUgJiYgcHJvcCA9PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICBub2RlLl9fcG9seW1lclRleHRDb250ZW50X18gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHBhcmVudCBtb2RlbCBvZiB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLiAgVGhlIHBhcmVudCBtb2RlbFxuICAgKiBpcyBlaXRoZXIgYW5vdGhlciB0ZW1wbGF0aXplIGluc3RhbmNlIHRoYXQgaGFkIG9wdGlvbiBgcGFyZW50TW9kZWw6IHRydWVgLFxuICAgKiBvciBlbHNlIHRoZSBob3N0IGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBUaGUgcGFyZW50IG1vZGVsIG9mIHRoaXMgaW5zdGFuY2VcbiAgICovXG4gIGdldCBwYXJlbnRNb2RlbCgpIHtcbiAgICBsZXQgbW9kZWwgPSB0aGlzLl9fcGFyZW50TW9kZWw7XG4gICAgaWYgKCFtb2RlbCkge1xuICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICBtb2RlbCA9IHRoaXM7XG4gICAgICBkbyB7XG4gICAgICAgIC8vIEEgdGVtcGxhdGUgaW5zdGFuY2UncyBgX19kYXRhSG9zdGAgaXMgYSA8dGVtcGxhdGU+XG4gICAgICAgIC8vIGBtb2RlbC5fX2RhdGFIb3N0Ll9fZGF0YUhvc3RgIGlzIHRoZSB0ZW1wbGF0ZSdzIGhvc3RcbiAgICAgICAgbW9kZWwgPSBtb2RlbC5fX2RhdGFIb3N0Ll9fZGF0YUhvc3Q7XG4gICAgICB9IHdoaWxlICgob3B0aW9ucyA9IG1vZGVsLl9fdGVtcGxhdGl6ZU9wdGlvbnMpICYmICFvcHRpb25zLnBhcmVudE1vZGVsKTtcbiAgICAgIHRoaXMuX19wYXJlbnRNb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbn1cblxuLyoqIEB0eXBlIHshRGF0YVRlbXBsYXRlfSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fZGF0YUhvc3Q7XG4vKiogQHR5cGUgeyFUZW1wbGF0aXplT3B0aW9uc30gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPcHRpb25zO1xuLyoqIEB0eXBlIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX21ldGhvZEhvc3Q7XG4vKiogQHR5cGUgeyFPYmplY3R9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX190ZW1wbGF0aXplT3duZXI7XG4vKiogQHR5cGUgeyFPYmplY3R9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX19ob3N0UHJvcHM7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAqL1xuY29uc3QgTXV0YWJsZVRlbXBsYXRlSW5zdGFuY2VCYXNlID0gTXV0YWJsZURhdGEoVGVtcGxhdGVJbnN0YW5jZUJhc2UpO1xuXG5mdW5jdGlvbiBmaW5kTWV0aG9kSG9zdCh0ZW1wbGF0ZSkge1xuICAvLyBUZWNobmljYWxseSB0aGlzIHNob3VsZCBiZSB0aGUgb3duZXIgb2YgdGhlIG91dGVybW9zdCB0ZW1wbGF0ZS5cbiAgLy8gSW4gc2hhZG93IGRvbSwgdGhpcyBpcyBhbHdheXMgZ2V0Um9vdE5vZGUoKS5ob3N0LCBidXQgd2UgY2FuXG4gIC8vIGFwcHJveGltYXRlIHRoaXMgdmlhIGNvb3BlcmF0aW9uIHdpdGggb3VyIGRhdGFIb3N0IGFsd2F5cyBzZXR0aW5nXG4gIC8vIGBfbWV0aG9kSG9zdGAgYXMgbG9uZyBhcyB0aGVyZSB3ZXJlIGJpbmRpbmdzIChvciBpZCdzKSBvbiB0aGlzXG4gIC8vIGluc3RhbmNlIGNhdXNpbmcgaXQgdG8gZ2V0IGEgZGF0YUhvc3QuXG4gIGxldCB0ZW1wbGF0ZUhvc3QgPSB0ZW1wbGF0ZS5fX2RhdGFIb3N0O1xuICByZXR1cm4gdGVtcGxhdGVIb3N0ICYmIHRlbXBsYXRlSG9zdC5fbWV0aG9kSG9zdCB8fCB0ZW1wbGF0ZUhvc3Q7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4vKipcbiAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgZGVmaW5lZCBmb3Igc29tZSByZWFzb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGl6ZXJDbGFzcyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gIC8vIEFub255bW91cyBjbGFzcyBjcmVhdGVkIGJ5IHRoZSB0ZW1wbGF0aXplXG4gIGxldCBiYXNlID0gb3B0aW9ucy5tdXRhYmxlRGF0YSA/XG4gICAgTXV0YWJsZVRlbXBsYXRlSW5zdGFuY2VCYXNlIDogVGVtcGxhdGVJbnN0YW5jZUJhc2U7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge2Jhc2V9XG4gICAqL1xuICBsZXQga2xhc3MgPSBjbGFzcyBleHRlbmRzIGJhc2UgeyB9O1xuICBrbGFzcy5wcm90b3R5cGUuX190ZW1wbGF0aXplT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGtsYXNzLnByb3RvdHlwZS5fYmluZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgYWRkTm90aWZ5RWZmZWN0cyhrbGFzcywgdGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucyk7XG4gIHJldHVybiBrbGFzcztcbn1cblxuLyoqXG4gKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBjbGFzcy5wcm90b3R5cGUgaXMgbm90IGRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gKi9cbmZ1bmN0aW9uIGFkZFByb3BhZ2F0ZUVmZmVjdHModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucykge1xuICBsZXQgdXNlckZvcndhcmRIb3N0UHJvcCA9IG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wO1xuICBpZiAodXNlckZvcndhcmRIb3N0UHJvcCkge1xuICAgIC8vIFByb3ZpZGUgZGF0YSBBUEkgYW5kIHByb3BlcnR5IGVmZmVjdHMgb24gbWVtb2l6ZWQgdGVtcGxhdGUgY2xhc3NcbiAgICBsZXQga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3M7XG4gICAgaWYgKCFrbGFzcykge1xuICAgICAgbGV0IGJhc2UgPSBvcHRpb25zLm11dGFibGVEYXRhID8gTXV0YWJsZURhdGFUZW1wbGF0ZSA6IERhdGFUZW1wbGF0ZTtcbiAgICAgIGtsYXNzID0gdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVUZW1wbGF0ZUNsYXNzID1cbiAgICAgICAgY2xhc3MgVGVtcGxhdGl6ZWRUZW1wbGF0ZSBleHRlbmRzIGJhc2Uge307XG4gICAgICAvLyBBZGQgdGVtcGxhdGUgLSA+aW5zdGFuY2VzIGVmZmVjdHNcbiAgICAgIC8vIGFuZCBob3N0IDwtIHRlbXBsYXRlIGVmZmVjdHNcbiAgICAgIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBob3N0UHJvcHMpIHtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdCgnX2hvc3RfJyArIHByb3AsXG4gICAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5QUk9QQUdBVEUsXG4gICAgICAgICAge2ZuOiBjcmVhdGVGb3J3YXJkSG9zdFByb3BFZmZlY3QocHJvcCwgdXNlckZvcndhcmRIb3N0UHJvcCl9KTtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eSgnX2hvc3RfJyArIHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGdyYWRlVGVtcGxhdGUodGVtcGxhdGUsIGtsYXNzKTtcbiAgICAvLyBNaXggYW55IHByZS1ib3VuZCBkYXRhIGludG8gX19kYXRhOyBubyBuZWVkIHRvIGZsdXNoIHRoaXMgdG9cbiAgICAvLyBpbnN0YW5jZXMgc2luY2UgdGhleSBwdWxsIGZyb20gdGhlIHRlbXBsYXRlIGF0IGluc3RhbmNlLXRpbWVcbiAgICBpZiAodGVtcGxhdGUuX19kYXRhUHJvdG8pIHtcbiAgICAgIC8vIE5vdGUsIGdlbmVyYWxseSBgX19kYXRhUHJvdG9gIGNvdWxkIGJlIGNoYWluZWQsIGJ1dCBpdCdzIGd1YXJhbnRlZWRcbiAgICAgIC8vIHRvIG5vdCBiZSBzaW5jZSB0aGlzIGlzIGEgdmFuaWxsYSB0ZW1wbGF0ZSB3ZSBqdXN0IGFkZGVkIGVmZmVjdHMgdG9cbiAgICAgIE9iamVjdC5hc3NpZ24odGVtcGxhdGUuX19kYXRhLCB0ZW1wbGF0ZS5fX2RhdGFQcm90byk7XG4gICAgfVxuICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIGRhdGEgZm9yIHBlcmZvcm1hbmNlXG4gICAgdGVtcGxhdGUuX19kYXRhVGVtcCA9IHt9O1xuICAgIHRlbXBsYXRlLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgIHRlbXBsYXRlLl9fZGF0YU9sZCA9IG51bGw7XG4gICAgdGVtcGxhdGUuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGb3J3YXJkSG9zdFByb3BFZmZlY3QoaG9zdFByb3AsIHVzZXJGb3J3YXJkSG9zdFByb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvcndhcmRIb3N0UHJvcCh0ZW1wbGF0ZSwgcHJvcCwgcHJvcHMpIHtcbiAgICB1c2VyRm9yd2FyZEhvc3RQcm9wLmNhbGwodGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIsXG4gICAgICBwcm9wLnN1YnN0cmluZygnX2hvc3RfJy5sZW5ndGgpLCBwcm9wc1twcm9wXSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZE5vdGlmeUVmZmVjdHMoa2xhc3MsIHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgfHwge307XG4gIGZvciAobGV0IGlwcm9wIGluIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgIGRlbGV0ZSBob3N0UHJvcHNbaXByb3BdO1xuICAgIGxldCB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wID0gb3B0aW9ucy5ub3RpZnlJbnN0YW5jZVByb3A7XG4gICAgaWYgKHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApIHtcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoaXByb3AsXG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuTk9USUZZLFxuICAgICAgICB7Zm46IGNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdChpcHJvcCwgdXNlck5vdGlmeUluc3RhbmNlUHJvcCl9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wICYmIHRlbXBsYXRlLl9fZGF0YUhvc3QpIHtcbiAgICBmb3IgKGxldCBocHJvcCBpbiBob3N0UHJvcHMpIHtcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoaHByb3AsXG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuTk9USUZZLFxuICAgICAgICB7Zm46IGNyZWF0ZU5vdGlmeUhvc3RQcm9wRWZmZWN0KCl9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTm90aWZ5SW5zdGFuY2VQcm9wRWZmZWN0KGluc3RQcm9wLCB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub3RpZnlJbnN0YW5jZVByb3AoaW5zdCwgcHJvcCwgcHJvcHMpIHtcbiAgICB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wLmNhbGwoaW5zdC5fX3RlbXBsYXRpemVPd25lcixcbiAgICAgIGluc3QsIHByb3AsIHByb3BzW3Byb3BdKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub3RpZnlIb3N0UHJvcChpbnN0LCBwcm9wLCBwcm9wcykge1xuICAgIGluc3QuX19kYXRhSG9zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKCdfaG9zdF8nICsgcHJvcCwgcHJvcHNbcHJvcF0sIHRydWUsIHRydWUpO1xuICB9O1xufVxuXG4vKipcbiAqIE1vZHVsZSBmb3IgcHJlcGFyaW5nIGFuZCBzdGFtcGluZyBpbnN0YW5jZXMgb2YgdGVtcGxhdGVzIHRoYXQgdXRpbGl6ZVxuICogUG9seW1lcidzIGRhdGEtYmluZGluZyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXIgZmVhdHVyZXMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gR2V0IGEgdGVtcGxhdGUgZnJvbSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gKiAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICogICAgIC8vIFByZXBhcmUgdGhlIHRlbXBsYXRlXG4gKiAgICAgbGV0IFRlbXBsYXRlQ2xhc3MgPSBQb2x5bWVyLlRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSk7XG4gKiAgICAgLy8gSW5zdGFuY2UgdGhlIHRlbXBsYXRlIHdpdGggYW4gaW5pdGlhbCBkYXRhIG1vZGVsXG4gKiAgICAgbGV0IGluc3RhbmNlID0gbmV3IFRlbXBsYXRlQ2xhc3Moe215UHJvcDogJ2luaXRpYWwnfSk7XG4gKiAgICAgLy8gSW5zZXJ0IHRoZSBpbnN0YW5jZSdzIERPTSBzb21ld2hlcmUsIGUuZy4gZWxlbWVudCdzIHNoYWRvdyBET01cbiAqICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoaW5zdGFuY2Uucm9vdCk7XG4gKiAgICAgLy8gQ2hhbmdpbmcgYSBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2Ugd2lsbCBwcm9wYWdhdGUgdG8gYmluZGluZ3NcbiAqICAgICAvLyBpbiB0aGUgdGVtcGxhdGVcbiAqICAgICBpbnN0YW5jZS5teVByb3AgPSAnbmV3IHZhbHVlJztcbiAqXG4gKiBUaGUgYG9wdGlvbnNgIGRpY3Rpb25hcnkgcGFzc2VkIHRvIGB0ZW1wbGF0aXplYCBhbGxvd3MgZm9yIGN1c3RvbWl6aW5nXG4gKiBmZWF0dXJlcyBvZiB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIGNsYXNzLCBpbmNsdWRpbmcgaG93IG91dGVyLXNjb3BlIGhvc3RcbiAqIHByb3BlcnRpZXMgc2hvdWxkIGJlIGZvcndhcmRlZCBpbnRvIHRlbXBsYXRlIGluc3RhbmNlcywgaG93IGFueSBpbnN0YW5jZVxuICogcHJvcGVydGllcyBhZGRlZCBpbnRvIHRoZSB0ZW1wbGF0ZSdzIHNjb3BlIHNob3VsZCBiZSBub3RpZmllZCBvdXQgdG9cbiAqIHRoZSBob3N0LCBhbmQgd2hldGhlciB0aGUgaW5zdGFuY2Ugc2hvdWxkIGJlIGRlY29yYXRlZCBhcyBhIFwicGFyZW50IG1vZGVsXCJcbiAqIG9mIGFueSBldmVudCBoYW5kbGVycy5cbiAqXG4gKiAgICAgLy8gQ3VzdG9temUgcHJvcGVydHkgZm9yd2FyZGluZyBhbmQgZXZlbnQgbW9kZWwgZGVjb3JhdGlvblxuICogICAgIGxldCBUZW1wbGF0ZUNsYXNzID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAqICAgICAgIHBhcmVudE1vZGVsOiB0cnVlLFxuICogICAgICAgaW5zdGFuY2VQcm9wczogey4uLn0sXG4gKiAgICAgICBmb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKSB7Li4ufSxcbiAqICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcChpbnN0YW5jZSwgcHJvcGVydHksIHZhbHVlKSB7Li4ufSxcbiAqICAgICB9KTtcbiAqXG4gKlxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IE1vZHVsZSBmb3IgcHJlcGFyaW5nIGFuZCBzdGFtcGluZyBpbnN0YW5jZXMgb2YgdGVtcGxhdGVzXG4gKiAgIHV0aWxpemluZyBQb2x5bWVyIHRlbXBsYXRpbmcgZmVhdHVyZXMuXG4gKi9cblxuY29uc3QgVGVtcGxhdGl6ZSA9IHtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhbm9ueW1vdXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBjbGFzcyBib3VuZCB0byB0aGVcbiAgICogYDx0ZW1wbGF0ZT5gIHByb3ZpZGVkLiAgSW5zdGFuY2luZyB0aGUgY2xhc3Mgd2lsbCByZXN1bHQgaW4gdGhlXG4gICAqIHRlbXBsYXRlIGJlaW5nIHN0YW1wZWQgaW50byBkb2N1bWVudCBmcmFnbWVudCBzdG9yZWQgYXMgdGhlIGluc3RhbmNlJ3NcbiAgICogYHJvb3RgIHByb3BlcnR5LCBhZnRlciB3aGljaCBpdCBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIERPTS5cbiAgICpcbiAgICogVGVtcGxhdGVzIG1heSB1dGlsaXplIGFsbCBQb2x5bWVyIGRhdGEtYmluZGluZyBmZWF0dXJlcyBhcyB3ZWxsIGFzXG4gICAqIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycy4gIEV2ZW50IGxpc3RlbmVycyBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICAgKiBmdW5jdGlvbnMgaW4gdGhlIHRlbXBsYXRlIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSBob3N0IG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogVGhlIGNvbnN0cnVjdG9yIHJldHVybmVkIHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50IGRpY3Rpb25hcnkgb2YgaW5pdGlhbFxuICAgKiBwcm9wZXJ0eSB2YWx1ZXMgdG8gcHJvcGFnYXRlIGludG8gdGVtcGxhdGUgYmluZGluZ3MuICBBZGRpdGlvbmFsbHlcbiAgICogaG9zdCBwcm9wZXJ0aWVzIGNhbiBiZSBmb3J3YXJkZWQgaW4sIGFuZCBpbnN0YW5jZSBwcm9wZXJ0aWVzIGNhbiBiZVxuICAgKiBub3RpZmllZCBvdXQgYnkgcHJvdmlkaW5nIG9wdGlvbmFsIGNhbGxiYWNrcyBpbiB0aGUgYG9wdGlvbnNgIGRpY3Rpb25hcnkuXG4gICAqXG4gICAqIFZhbGlkIGNvbmZpZ3VyYXRpb24gaW4gYG9wdGlvbnNgIGFyZSBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiAtIGBmb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKWA6IENhbGxlZCB3aGVuIGEgcHJvcGVydHkgcmVmZXJlbmNlZFxuICAgKiAgIGluIHRoZSB0ZW1wbGF0ZSBjaGFuZ2VkIG9uIHRoZSB0ZW1wbGF0ZSdzIGhvc3QuIEFzIHRoaXMgbGlicmFyeSBkb2VzXG4gICAqICAgbm90IHJldGFpbiByZWZlcmVuY2VzIHRvIHRlbXBsYXRlcyBpbnN0YW5jZWQgYnkgdGhlIHVzZXIsIGl0IGlzIHRoZVxuICAgKiAgIHRlbXBsYXRpemUgb3duZXIncyByZXNwb25zaWJpbGl0eSB0byBmb3J3YXJkIGhvc3QgcHJvcGVydHkgY2hhbmdlcyBpbnRvXG4gICAqICAgdXNlci1zdGFtcGVkIGluc3RhbmNlcy4gIFRoZSBgaW5zdGFuY2UuZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSlgXG4gICAqICAgIG1ldGhvZCBvbiB0aGUgZ2VuZXJhdGVkIGNsYXNzIHNob3VsZCBiZSBjYWxsZWQgdG8gZm9yd2FyZCBob3N0XG4gICAqICAgcHJvcGVydGllcyBpbnRvIHRoZSB0ZW1wbGF0ZSB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHByb3BlcnR5LWNoYW5nZWRcbiAgICogICBub3RpZmljYXRpb25zLiBBbnkgcHJvcGVydGllcyByZWZlcmVuY2VkIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IGFyZSBub3RcbiAgICogICBkZWZpbmVkIGluIGBpbnN0YW5jZVByb3BzYCB3aWxsIGJlIG5vdGlmaWVkIHVwIHRvIHRoZSB0ZW1wbGF0ZSdzIGhvc3RcbiAgICogICBhdXRvbWF0aWNhbGx5LlxuICAgKiAtIGBpbnN0YW5jZVByb3BzYDogRGljdGlvbmFyeSBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IHdpbGwgYmUgYWRkZWRcbiAgICogICB0byB0aGUgaW5zdGFuY2UgYnkgdGhlIHRlbXBsYXRpemUgb3duZXIuICBUaGVzZSBwcm9wZXJ0aWVzIHNoYWRvdyBhbnlcbiAgICogICBob3N0IHByb3BlcnRpZXMsIGFuZCBjaGFuZ2VzIHdpdGhpbiB0aGUgdGVtcGxhdGUgdG8gdGhlc2UgcHJvcGVydGllc1xuICAgKiAgIHdpbGwgcmVzdWx0IGluIGBub3RpZnlJbnN0YW5jZVByb3BgIGJlaW5nIGNhbGxlZC5cbiAgICogLSBgbXV0YWJsZURhdGFgOiBXaGVuIGB0cnVlYCwgdGhlIGdlbmVyYXRlZCBjbGFzcyB3aWxsIHNraXAgc3RyaWN0XG4gICAqICAgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmVcbiAgICogICBcImRpcnR5XCIpLlxuICAgKiAtIGBub3RpZnlJbnN0YW5jZVByb3AoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSlgOiBDYWxsZWQgd2hlblxuICAgKiAgIGFuIGluc3RhbmNlIHByb3BlcnR5IGNoYW5nZXMuICBVc2VycyBtYXkgY2hvb3NlIHRvIGNhbGwgYG5vdGlmeVBhdGhgXG4gICAqICAgb24gZS5nLiB0aGUgb3duZXIgdG8gbm90aWZ5IHRoZSBjaGFuZ2UuXG4gICAqIC0gYHBhcmVudE1vZGVsYDogV2hlbiBgdHJ1ZWAsIGV2ZW50cyBoYW5kbGVkIGJ5IGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVyc1xuICAgKiAgIChgb24tZXZlbnQ9XCJoYW5kbGVyXCJgKSB3aWxsIGJlIGRlY29yYXRlZCB3aXRoIGEgYG1vZGVsYCBwcm9wZXJ0eSBwb2ludGluZ1xuICAgKiAgIHRvIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGF0IHN0YW1wZWQgaXQuICBJdCB3aWxsIGFsc28gYmUgcmV0dXJuZWRcbiAgICogICBmcm9tIGBpbnN0YW5jZS5wYXJlbnRNb2RlbGAgaW4gY2FzZXMgd2hlcmUgdGVtcGxhdGUgaW5zdGFuY2UgbmVzdGluZ1xuICAgKiAgIGNhdXNlcyBhbiBpbm5lciBtb2RlbCB0byBzaGFkb3cgYW4gb3V0ZXIgbW9kZWwuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY2xhc3MgcmV0dXJuZWQgZnJvbSBgdGVtcGxhdGl6ZWAgaXMgZ2VuZXJhdGVkIG9ubHkgb25jZVxuICAgKiBmb3IgYSBnaXZlbiBgPHRlbXBsYXRlPmAgdXNpbmcgYG9wdGlvbnNgIGZyb20gdGhlIGZpcnN0IGNhbGwgZm9yIHRoYXRcbiAgICogdGVtcGxhdGUsIGFuZCB0aGUgY2FjaGVkIGNsYXNzIGlzIHJldHVybmVkIGZvciBhbGwgc3Vic2VxdWVudCBjYWxscyB0b1xuICAgKiBgdGVtcGxhdGl6ZWAgZm9yIHRoYXQgdGVtcGxhdGUuICBBcyBzdWNoLCBgb3B0aW9uc2AgY2FsbGJhY2tzIHNob3VsZCBub3RcbiAgICogY2xvc2Ugb3ZlciBvd25lci1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNpbmNlIG9ubHkgdGhlIGZpcnN0IGBvcHRpb25zYCBpc1xuICAgKiB1c2VkOyByYXRoZXIsIGNhbGxiYWNrcyBhcmUgY2FsbGVkIGJvdW5kIHRvIHRoZSBgb3duZXJgLCBhbmQgc28gY29udGV4dFxuICAgKiBuZWVkZWQgZnJvbSB0aGUgY2FsbGJhY2tzIChzdWNoIGFzIHJlZmVyZW5jZXMgdG8gYGluc3RhbmNlc2Agc3RhbXBlZClcbiAgICogc2hvdWxkIGJlIHN0b3JlZCBvbiB0aGUgYG93bmVyYCBzdWNoIHRoYXQgdGhleSBjYW4gYmUgcmV0cmlldmVkIHZpYSBgdGhpc2AuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLlRlbXBsYXRpemVcbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gdGVtcGxhdGl6ZVxuICAgKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gb3duZXIgT3duZXIgb2YgdGhlIHRlbXBsYXRlIGluc3RhbmNlcztcbiAgICogICBhbnkgb3B0aW9uYWwgY2FsbGJhY2tzIHdpbGwgYmUgYm91bmQgdG8gdGhpcyBvd25lci5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgZGljdGlvbmFyeSAoc2VlIHN1bW1hcnkgZm9yIGRldGFpbHMpXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpUZW1wbGF0ZUluc3RhbmNlQmFzZSl9IEdlbmVyYXRlZCBjbGFzcyBib3VuZCB0byB0aGUgdGVtcGxhdGVcbiAgICogICBwcm92aWRlZFxuICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICovXG4gIHRlbXBsYXRpemUodGVtcGxhdGUsIG93bmVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IVRlbXBsYXRpemVPcHRpb25zfSAqLyhvcHRpb25zIHx8IHt9KTtcbiAgICBpZiAodGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSA8dGVtcGxhdGU+IGNhbiBvbmx5IGJlIHRlbXBsYXRpemVkIG9uY2UnKTtcbiAgICB9XG4gICAgdGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIgPSBvd25lcjtcbiAgICBsZXQgdGVtcGxhdGVJbmZvID0gb3duZXIuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgIC8vIEdldCBtZW1vaXplZCBiYXNlIGNsYXNzIGZvciB0aGUgcHJvdG90eXBpY2FsIHRlbXBsYXRlLCB3aGljaFxuICAgIC8vIGluY2x1ZGVzIHByb3BlcnR5IGVmZmVjdHMgZm9yIGJpbmRpbmcgdGVtcGxhdGUgJiBmb3J3YXJkaW5nXG4gICAgbGV0IGJhc2VDbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplSW5zdGFuY2VDbGFzcztcbiAgICBpZiAoIWJhc2VDbGFzcykge1xuICAgICAgYmFzZUNsYXNzID0gY3JlYXRlVGVtcGxhdGl6ZXJDbGFzcyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKTtcbiAgICAgIHRlbXBsYXRlSW5mby50ZW1wbGF0aXplSW5zdGFuY2VDbGFzcyA9IGJhc2VDbGFzcztcbiAgICB9XG4gICAgLy8gSG9zdCBwcm9wZXJ0eSBmb3J3YXJkaW5nIG11c3QgYmUgaW5zdGFsbGVkIG9udG8gdGVtcGxhdGUgaW5zdGFuY2VcbiAgICBhZGRQcm9wYWdhdGVFZmZlY3RzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgIC8vIFN1YmNsYXNzIGJhc2UgY2xhc3MgYW5kIGFkZCByZWZlcmVuY2UgZm9yIHRoaXMgc3BlY2lmaWMgdGVtcGxhdGVcbiAgICBsZXQga2xhc3MgPSBjbGFzcyBUZW1wbGF0ZUluc3RhbmNlIGV4dGVuZHMgYmFzZUNsYXNzIHt9O1xuICAgIGtsYXNzLnByb3RvdHlwZS5fbWV0aG9kSG9zdCA9IGZpbmRNZXRob2RIb3N0KHRlbXBsYXRlKTtcbiAgICBrbGFzcy5wcm90b3R5cGUuX19kYXRhSG9zdCA9IHRlbXBsYXRlO1xuICAgIGtsYXNzLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPd25lciA9IG93bmVyO1xuICAgIGtsYXNzLnByb3RvdHlwZS5fX2hvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7ZnVuY3Rpb24obmV3OlRlbXBsYXRlSW5zdGFuY2VCYXNlKX0gKi8oa2xhc3MpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2hcbiAgICogc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXNcbiAgICogY29udGFpbmVkIGluLiBBIHRlbXBsYXRlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mXG4gICAqIGBUZW1wbGF0ZUluc3RhbmNlQmFzZWAsIGFuZCBzaG91bGQgYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGFcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgbGV0IG1vZGVsID0gbW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICogICBpZiAobW9kZWwuaW5kZXggPCAxMCkge1xuICAgKiAgICAgbW9kZWwuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtcbiAgICogICB9XG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLlRlbXBsYXRpemVcbiAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUaGUgbW9kZWwgd2lsbCBiZSByZXR1cm5lZCBmb3JcbiAgICogICBlbGVtZW50cyBzdGFtcGVkIGZyb20gdGhpcyB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSBmb3Igd2hpY2ggdG8gcmV0dXJuIGEgdGVtcGxhdGUgbW9kZWwuXG4gICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBUZW1wbGF0ZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlXG4gICAqICAgYmluZGluZyBzY29wZSBmb3IgdGhlIGVsZW1lbnRcbiAgICovXG4gIG1vZGVsRm9yRWxlbWVudCh0ZW1wbGF0ZSwgbm9kZSkge1xuICAgIGxldCBtb2RlbDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgLy8gQW4gZWxlbWVudCB3aXRoIGEgX190ZW1wbGF0aXplSW5zdGFuY2UgbWFya3MgdGhlIHRvcCBib3VuZGFyeVxuICAgICAgLy8gb2YgYSBzY29wZTsgd2FsayB1cCB1bnRpbCB3ZSBmaW5kIG9uZSwgYW5kIHRoZW4gZW5zdXJlIHRoYXRcbiAgICAgIC8vIGl0cyBfX2RhdGFIb3N0IG1hdGNoZXMgYHRoaXNgLCBtZWFuaW5nIHRoaXMgZG9tLXJlcGVhdCBzdGFtcGVkIGl0XG4gICAgICBpZiAoKG1vZGVsID0gbm9kZS5fX3RlbXBsYXRpemVJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gRm91bmQgYW4gZWxlbWVudCBzdGFtcGVkIGJ5IGFub3RoZXIgdGVtcGxhdGU7IGtlZXAgd2Fsa2luZyB1cFxuICAgICAgICAvLyBmcm9tIGl0cyBfX2RhdGFIb3N0XG4gICAgICAgIGlmIChtb2RlbC5fX2RhdGFIb3N0ICE9IHRlbXBsYXRlKSB7XG4gICAgICAgICAgbm9kZSA9IG1vZGVsLl9fZGF0YUhvc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBpbiBhIHRlbXBsYXRlIHNjb3BlLCBrZWVwIGdvaW5nIHVwIHVudGlsXG4gICAgICAgIC8vIGEgX190ZW1wbGF0aXplSW5zdGFuY2UgaXMgZm91bmRcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmV4cG9ydCB7IFRlbXBsYXRpemUgfTtcbmV4cG9ydCB7IFRlbXBsYXRlSW5zdGFuY2VCYXNlIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy90ZW1wbGF0aXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQTExeUtleXNCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi9pcm9uLWNvbnRyb2wtc3RhdGUuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25CdXR0b25TdGF0ZUltcGwgPSB7XG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHVzZXIgaXMgY3VycmVudGx5IGhvbGRpbmcgZG93biB0aGUgYnV0dG9uLlxuICAgICAqL1xuICAgIHByZXNzZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIG9ic2VydmVyOiAnX3ByZXNzZWRDaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIHRvZ2dsZXMgdGhlIGFjdGl2ZSBzdGF0ZSB3aXRoIGVhY2ggdGFwIG9yIHByZXNzXG4gICAgICogb2YgdGhlIHNwYWNlYmFyLlxuICAgICAqL1xuICAgIHRvZ2dsZXM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJ1dHRvbiBpcyBhIHRvZ2dsZSBhbmQgaXMgY3VycmVudGx5IGluIHRoZSBhY3RpdmUgc3RhdGUuXG4gICAgICovXG4gICAgYWN0aXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYnkgYSBcInBvaW50ZXIsXCIgd2hpY2hcbiAgICAgKiBpcyBsb29zZWx5IGRlZmluZWQgYXMgbW91c2Ugb3IgdG91Y2ggaW5wdXQgKGJ1dCBzcGVjaWZpY2FsbHkgZXhjbHVkaW5nXG4gICAgICoga2V5Ym9hcmQgaW5wdXQpLlxuICAgICAqL1xuICAgIHBvaW50ZXJEb3duOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgaW5wdXQgZGV2aWNlIHRoYXQgY2F1c2VkIHRoZSBlbGVtZW50IHRvIHJlY2VpdmUgZm9jdXNcbiAgICAgKiB3YXMgYSBrZXlib2FyZC5cbiAgICAgKi9cbiAgICByZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGFyaWEgYXR0cmlidXRlIHRvIGJlIHNldCBpZiB0aGUgYnV0dG9uIGlzIGEgdG9nZ2xlIGFuZCBpbiB0aGVcbiAgICAgKiBhY3RpdmUgc3RhdGUuXG4gICAgICovXG4gICAgYXJpYUFjdGl2ZUF0dHJpYnV0ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdhcmlhLXByZXNzZWQnLFxuICAgICAgb2JzZXJ2ZXI6ICdfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQnXG4gICAgfVxuICB9LFxuXG4gIGxpc3RlbmVyczoge1xuICAgIGRvd246ICdfZG93bkhhbmRsZXInLFxuICAgIHVwOiAnX3VwSGFuZGxlcicsXG4gICAgdGFwOiAnX3RhcEhhbmRsZXInXG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19mb2N1c0NoYW5nZWQoZm9jdXNlZCknLFxuICAgICdfYWN0aXZlQ2hhbmdlZChhY3RpdmUsIGFyaWFBY3RpdmVBdHRyaWJ1dGUpJ1xuICBdLFxuXG4gIGtleUJpbmRpbmdzOiB7XG4gICAgJ2VudGVyOmtleWRvd24nOiAnX2FzeW5jQ2xpY2snLFxuICAgICdzcGFjZTprZXlkb3duJzogJ19zcGFjZUtleURvd25IYW5kbGVyJyxcbiAgICAnc3BhY2U6a2V5dXAnOiAnX3NwYWNlS2V5VXBIYW5kbGVyJyxcbiAgfSxcblxuICBfbW91c2VFdmVudFJlOiAvXm1vdXNlLyxcblxuICBfdGFwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudG9nZ2xlcykge1xuICAgICAvLyBhIHRhcCBpcyBuZWVkZWQgdG8gdG9nZ2xlIHRoZSBhY3RpdmUgc3RhdGVcbiAgICAgIHRoaXMuX3VzZXJBY3RpdmF0ZSghdGhpcy5hY3RpdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBfZm9jdXNDaGFuZ2VkOiBmdW5jdGlvbihmb2N1c2VkKSB7XG4gICAgdGhpcy5fZGV0ZWN0S2V5Ym9hcmRGb2N1cyhmb2N1c2VkKTtcblxuICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIF9kZXRlY3RLZXlib2FyZEZvY3VzOiBmdW5jdGlvbihmb2N1c2VkKSB7XG4gICAgdGhpcy5fc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCghdGhpcy5wb2ludGVyRG93biAmJiBmb2N1c2VkKTtcbiAgfSxcblxuICAvLyB0byBlbXVsYXRlIG5hdGl2ZSBjaGVja2JveCwgKGRlLSlhY3RpdmF0aW9ucyBmcm9tIGEgdXNlciBpbnRlcmFjdGlvbiBmaXJlXG4gIC8vICdjaGFuZ2UnIGV2ZW50c1xuICBfdXNlckFjdGl2YXRlOiBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUgIT09IGFjdGl2ZSkge1xuICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSxcblxuICBfZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5fc2V0UG9pbnRlckRvd24odHJ1ZSk7XG4gICAgdGhpcy5fc2V0UHJlc3NlZCh0cnVlKTtcbiAgICB0aGlzLl9zZXRSZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKGZhbHNlKTtcbiAgfSxcblxuICBfdXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZXRQb2ludGVyRG93bihmYWxzZSk7XG4gICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGV2ZW50IC5cbiAgICovXG4gIF9zcGFjZUtleURvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBrZXlib2FyZEV2ZW50ID0gZXZlbnQuZGV0YWlsLmtleWJvYXJkRXZlbnQ7XG4gICAgdmFyIHRhcmdldCA9IGRvbShrZXlib2FyZEV2ZW50KS5sb2NhbFRhcmdldDtcblxuICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgdGhpcyBpcyBjb21pbmcgZnJvbSBhIGZvY3VzZWQgbGlnaHQgY2hpbGQsIHNpbmNlIHRoYXRcbiAgICAvLyBlbGVtZW50IHdpbGwgZGVhbCB3aXRoIGl0LlxuICAgIGlmICh0aGlzLmlzTGlnaHREZXNjZW5kYW50KC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KSkpXG4gICAgICByZXR1cm47XG5cbiAgICBrZXlib2FyZEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAga2V5Ym9hcmRFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLl9zZXRQcmVzc2VkKHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldmVudCAuXG4gICAqL1xuICBfc3BhY2VLZXlVcEhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGtleWJvYXJkRXZlbnQgPSBldmVudC5kZXRhaWwua2V5Ym9hcmRFdmVudDtcbiAgICB2YXIgdGFyZ2V0ID0gZG9tKGtleWJvYXJkRXZlbnQpLmxvY2FsVGFyZ2V0O1xuXG4gICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiB0aGlzIGlzIGNvbWluZyBmcm9tIGEgZm9jdXNlZCBsaWdodCBjaGlsZCwgc2luY2UgdGhhdFxuICAgIC8vIGVsZW1lbnQgd2lsbCBkZWFsIHdpdGggaXQuXG4gICAgaWYgKHRoaXMuaXNMaWdodERlc2NlbmRhbnQoLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSlcbiAgICAgIHJldHVybjtcblxuICAgIGlmICh0aGlzLnByZXNzZWQpIHtcbiAgICAgIHRoaXMuX2FzeW5jQ2xpY2soKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gIH0sXG5cbiAgLy8gdHJpZ2dlciBjbGljayBhc3luY2hyb25vdXNseSwgdGhlIGFzeW5jaHJvbnkgaXMgdXNlZnVsIHRvIGFsbG93IG9uZVxuICAvLyBldmVudCBoYW5kbGVyIHRvIHVud2luZCBiZWZvcmUgdHJpZ2dlcmluZyBhbm90aGVyIGV2ZW50XG4gIF9hc3luY0NsaWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGljaygpO1xuICAgIH0sIDEpO1xuICB9LFxuXG4gIC8vIGFueSBvZiB0aGVzZSBjaGFuZ2VzIGFyZSBjb25zaWRlcmVkIGEgY2hhbmdlIHRvIGJ1dHRvbiBzdGF0ZVxuXG4gIF9wcmVzc2VkQ2hhbmdlZDogZnVuY3Rpb24ocHJlc3NlZCkge1xuICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICB9LFxuXG4gIF9hcmlhQWN0aXZlQXR0cmlidXRlQ2hhbmdlZDogZnVuY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgaWYgKG9sZFZhbHVlICYmIG9sZFZhbHVlICE9IHZhbHVlICYmIHRoaXMuaGFzQXR0cmlidXRlKG9sZFZhbHVlKSkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUob2xkVmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBfYWN0aXZlQ2hhbmdlZDogZnVuY3Rpb24oYWN0aXZlLCBhcmlhQWN0aXZlQXR0cmlidXRlKSB7XG4gICAgaWYgKHRoaXMudG9nZ2xlcykge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUodGhpcy5hcmlhQWN0aXZlQXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKHRoaXMuYXJpYUFjdGl2ZUF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICB9LFxuXG4gIF9jb250cm9sU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICAgIH1cbiAgfSxcblxuICAvLyBwcm92aWRlIGhvb2sgZm9yIGZvbGxvdy1vbiBiZWhhdmlvcnMgdG8gcmVhY3QgdG8gYnV0dG9uLXN0YXRlXG5cbiAgX2NoYW5nZWRCdXR0b25TdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2J1dHRvblN0YXRlQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYnV0dG9uU3RhdGVDaGFuZ2VkKCk7IC8vIGFic3RyYWN0XG4gICAgfVxuICB9XG5cbn07XG5cbmV4cG9ydCBjb25zdCBJcm9uQnV0dG9uU3RhdGUgPSBbXG4gIElyb25BMTF5S2V5c0JlaGF2aW9yLFxuICBJcm9uQnV0dG9uU3RhdGVJbXBsXG5dO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEJhc2UgfSBmcm9tICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9pcm9uLW1ldGEvaXJvbi1tZXRhLmpzJztcbmltcG9ydCAnLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0LmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtaW5saW5lO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyLWNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuXG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XG5cbiAgICAgICAgZmlsbDogdmFyKC0taXJvbi1pY29uLWZpbGwtY29sb3IsIGN1cnJlbnRjb2xvcik7XG4gICAgICAgIHN0cm9rZTogdmFyKC0taXJvbi1pY29uLXN0cm9rZS1jb2xvciwgbm9uZSk7XG5cbiAgICAgICAgd2lkdGg6IHZhcigtLWlyb24taWNvbi13aWR0aCwgMjRweCk7XG4gICAgICAgIGhlaWdodDogdmFyKC0taXJvbi1pY29uLWhlaWdodCwgMjRweCk7XG4gICAgICAgIEBhcHBseSAtLWlyb24taWNvbjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuYCxcblxuICBpczogJ2lyb24taWNvbicsXG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGljb24gdG8gdXNlLiBUaGUgbmFtZSBzaG91bGQgYmUgb2YgdGhlIGZvcm06XG4gICAgICogYGljb25zZXRfbmFtZTppY29uX25hbWVgLlxuICAgICAqL1xuICAgIGljb246IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdGhlbWUgdG8gdXNlZCwgaWYgb25lIGlzIHNwZWNpZmllZCBieSB0aGVcbiAgICAgKiBpY29uc2V0LlxuICAgICAqL1xuICAgIHRoZW1lOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdXNpbmcgaXJvbi1pY29uIHdpdGhvdXQgYW4gaWNvbnNldCwgeW91IGNhbiBzZXQgdGhlIHNyYyB0byBiZVxuICAgICAqIHRoZSBVUkwgb2YgYW4gaW5kaXZpZHVhbCBpY29uIGltYWdlIGZpbGUuIE5vdGUgdGhhdCB0aGlzIHdpbGwgdGFrZVxuICAgICAqIHByZWNlZGVuY2Ugb3ZlciBhIGdpdmVuIGljb24gYXR0cmlidXRlLlxuICAgICAqL1xuICAgIHNyYzoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshUG9seW1lci5Jcm9uTWV0YX1cbiAgICAgKi9cbiAgICBfbWV0YToge1xuICAgICAgdmFsdWU6IEJhc2UuY3JlYXRlKCdpcm9uLW1ldGEnLCB7dHlwZTogJ2ljb25zZXQnfSlcbiAgICB9XG5cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX3VwZGF0ZUljb24oX21ldGEsIGlzQXR0YWNoZWQpJyxcbiAgICAnX3VwZGF0ZUljb24odGhlbWUsIGlzQXR0YWNoZWQpJyxcbiAgICAnX3NyY0NoYW5nZWQoc3JjLCBpc0F0dGFjaGVkKScsXG4gICAgJ19pY29uQ2hhbmdlZChpY29uLCBpc0F0dGFjaGVkKSdcbiAgXSxcblxuICBfREVGQVVMVF9JQ09OU0VUOiAnaWNvbnMnLFxuXG4gIF9pY29uQ2hhbmdlZDogZnVuY3Rpb24oaWNvbikge1xuICAgIHZhciBwYXJ0cyA9IChpY29uIHx8ICcnKS5zcGxpdCgnOicpO1xuICAgIHRoaXMuX2ljb25OYW1lID0gcGFydHMucG9wKCk7XG4gICAgdGhpcy5faWNvbnNldE5hbWUgPSBwYXJ0cy5wb3AoKSB8fCB0aGlzLl9ERUZBVUxUX0lDT05TRVQ7XG4gICAgdGhpcy5fdXBkYXRlSWNvbigpO1xuICB9LFxuXG4gIF9zcmNDaGFuZ2VkOiBmdW5jdGlvbihzcmMpIHtcbiAgICB0aGlzLl91cGRhdGVJY29uKCk7XG4gIH0sXG5cbiAgX3VzZXNJY29uc2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pY29uIHx8ICF0aGlzLnNyYztcbiAgfSxcblxuICAvKiogQHN1cHByZXNzIHt2aXNpYmlsaXR5fSAqL1xuICBfdXBkYXRlSWNvbjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3VzZXNJY29uc2V0KCkpIHtcbiAgICAgIGlmICh0aGlzLl9pbWcgJiYgdGhpcy5faW1nLnBhcmVudE5vZGUpIHtcbiAgICAgICAgZG9tKHRoaXMucm9vdCkucmVtb3ZlQ2hpbGQodGhpcy5faW1nKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9pY29uTmFtZSA9PT0gXCJcIikge1xuICAgICAgICBpZiAodGhpcy5faWNvbnNldCkge1xuICAgICAgICAgIHRoaXMuX2ljb25zZXQucmVtb3ZlSWNvbih0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLl9pY29uc2V0TmFtZSAmJiB0aGlzLl9tZXRhKSB7XG4gICAgICAgIHRoaXMuX2ljb25zZXQgPSAvKiogQHR5cGUgez9Qb2x5bWVyLkljb25zZXR9ICovIChcbiAgICAgICAgICB0aGlzLl9tZXRhLmJ5S2V5KHRoaXMuX2ljb25zZXROYW1lKSk7XG4gICAgICAgIGlmICh0aGlzLl9pY29uc2V0KSB7XG4gICAgICAgICAgdGhpcy5faWNvbnNldC5hcHBseUljb24odGhpcywgdGhpcy5faWNvbk5hbWUsIHRoaXMudGhlbWUpO1xuICAgICAgICAgIHRoaXMudW5saXN0ZW4od2luZG93LCAnaXJvbi1pY29uc2V0LWFkZGVkJywgJ191cGRhdGVJY29uJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5saXN0ZW4od2luZG93LCAnaXJvbi1pY29uc2V0LWFkZGVkJywgJ191cGRhdGVJY29uJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuX2ljb25zZXQpIHtcbiAgICAgICAgdGhpcy5faWNvbnNldC5yZW1vdmVJY29uKHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9pbWcpIHtcbiAgICAgICAgdGhpcy5faW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgIHRoaXMuX2ltZy5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5faW1nLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5faW1nLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgdGhpcy5faW1nLnNyYyA9IHRoaXMuc3JjO1xuICAgICAgZG9tKHRoaXMucm9vdCkuYXBwZW5kQ2hpbGQodGhpcy5faW1nKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1pY29uL2lyb24taWNvbi5qc1xuLy8gbW9kdWxlIGlkID0gMzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgUG9seW1lciBhcyBQb2x5bWVyJDAgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3t0eXBlOiAoc3RyaW5nfG51bGwpLCBrZXk6IChzdHJpbmd8bnVsbCksIHZhbHVlOiAqfX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBJcm9uTWV0YShvcHRpb25zKSB7XG4gIHRoaXMudHlwZSA9IChvcHRpb25zICYmIG9wdGlvbnMudHlwZSkgfHwgJ2RlZmF1bHQnO1xuICB0aGlzLmtleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5rZXk7XG4gIGlmICgndmFsdWUnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgfVxufVxuXG5Jcm9uTWV0YS50eXBlcyA9IHt9O1xuXG5Jcm9uTWV0YS5wcm90b3R5cGUgPSB7XG4gIGdldCB2YWx1ZSgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICBpZiAodHlwZSAmJiBrZXkpIHtcbiAgICAgIHJldHVybiBJcm9uTWV0YS50eXBlc1t0eXBlXSAmJiBJcm9uTWV0YS50eXBlc1t0eXBlXVtrZXldO1xuICAgIH1cbiAgfSxcblxuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICBpZiAodHlwZSAmJiBrZXkpIHtcbiAgICAgIHR5cGUgPSBJcm9uTWV0YS50eXBlc1t0eXBlXSA9IElyb25NZXRhLnR5cGVzW3R5cGVdIHx8IHt9O1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHR5cGVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXQgbGlzdCgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoSXJvbk1ldGEudHlwZXNbdGhpcy50eXBlXSkubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gbWV0YURhdGFzW3RoaXMudHlwZV1ba2V5XTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICBieUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn07XG5cbmV4cG9ydCB7IElyb25NZXRhIH07XG5cbnZhciBtZXRhRGF0YXMgPSBJcm9uTWV0YS50eXBlcztcblxuUG9seW1lciQwKHtcblxuICBpczogJ2lyb24tbWV0YScsXG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgbWV0YS1kYXRhLiAgQWxsIG1ldGEtZGF0YSBvZiB0aGUgc2FtZSB0eXBlIGlzIHN0b3JlZFxuICAgICAqIHRvZ2V0aGVyLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdkZWZhdWx0JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGtleSB1c2VkIHRvIHN0b3JlIGB2YWx1ZWAgdW5kZXIgdGhlIGB0eXBlYCBuYW1lc3BhY2UuXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAga2V5OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRhLWRhdGEgdG8gc3RvcmUgb3IgcmV0cmlldmUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgYHZhbHVlYCBpcyBzZXQgdG8gdGhlIGlyb24tbWV0YSBpbnN0YW5jZSBpdHNlbGYuXG4gICAgICovXG4gICAgIHNlbGY6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBvYnNlcnZlcjogJ19zZWxmQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgX19tZXRhOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgY29tcHV0ZWQ6ICdfX2NvbXB1dGVNZXRhKHR5cGUsIGtleSwgdmFsdWUpJ1xuICAgIH1cbiAgfSxcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgIGhpZGRlbjogdHJ1ZVxuICB9LFxuXG4gIF9fY29tcHV0ZU1ldGE6IGZ1bmN0aW9uKHR5cGUsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgbWV0YSA9IG5ldyBJcm9uTWV0YSh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAga2V5OiBrZXlcbiAgICB9KTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICBtZXRhLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gbWV0YS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfSxcblxuICBnZXQgbGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX21ldGEgJiYgdGhpcy5fX21ldGEubGlzdDtcbiAgfSxcblxuICBfc2VsZkNoYW5nZWQ6IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICBpZiAoc2VsZikge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbWV0YSBkYXRhIHZhbHVlIGJ5IGtleS5cbiAgICpcbiAgICogQG1ldGhvZCBieUtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGEtZGF0YSB0byBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGJ5S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gbmV3IElyb25NZXRhKHtcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGtleToga2V5XG4gICAgfSkudmFsdWU7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1tZXRhL2lyb24tbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gMzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkJ1dHRvblN0YXRlIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanMnO1xuaW1wb3J0IHsgUGFwZXJSaXBwbGVCZWhhdmlvciB9IGZyb20gJy4vcGFwZXItcmlwcGxlLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IElyb25Db250cm9sU3RhdGUgfSBmcm9tICcuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWNvbnRyb2wtc3RhdGUuanMnO1xuXG5leHBvcnQgY29uc3QgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGwgPSB7XG4gIG9ic2VydmVyczogW1xuICAgICdfZm9jdXNlZENoYW5nZWQocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCknXG4gIF0sXG5cbiAgX2ZvY3VzZWRDaGFuZ2VkOiBmdW5jdGlvbihyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSB7XG4gICAgaWYgKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICB0aGlzLl9yaXBwbGUuaG9sZERvd24gPSByZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkO1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmlwcGxlID0gUGFwZXJSaXBwbGVCZWhhdmlvci5fY3JlYXRlUmlwcGxlKCk7XG4gICAgcmlwcGxlLmlkID0gJ2luayc7XG4gICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgnY2VudGVyJywgJycpO1xuICAgIHJpcHBsZS5jbGFzc0xpc3QuYWRkKCdjaXJjbGUnKTtcbiAgICByZXR1cm4gcmlwcGxlO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciA9IFtcbiAgSXJvbkJ1dHRvblN0YXRlLFxuICBJcm9uQ29udHJvbFN0YXRlLFxuICBQYXBlclJpcHBsZUJlaGF2aW9yLFxuICBQYXBlcklua3lGb2N1c0JlaGF2aW9ySW1wbFxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSAzM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZnVuY3Rpb24gYWpheCh1cmwsIGRhdGEsIG1ldGhvZCwgaGVhZGVycywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gIHZhciBjb25maWcgPSB7bWV0aG9kOiBtZXRob2QsIGhlYWRlcnM6IGhlYWRlcnN9O1xuICBpZiAodHlwZW9mIGRhdGEgIT0gXCJ1bmRlZmluZWRcIikge1xuICAgIGNvbmZpZy5ib2R5ID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIH1cbiAgZmV0Y2godXJsLCBjb25maWcpXG4gIC50aGVuKHJlc3BvbnNlID0+IHtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzcG9uc2UpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ0ZhaWxlZCB0byBwb3N0IGRhdGEnKSk7XG4gICAgfVxuICB9KVxuICAudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpIC8vIHBhcnNlIHJlc3BvbnNlIGFzIEpTT05cbiAgLnRoZW4oZGF0YSA9PiB7XG4gICAgaWYgKHR5cGVvZiBzdWNjZXNzQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgc3VjY2Vzc0NhbGxiYWNrKGRhdGEpO1xuICAgIH1cbiAgfSlcbiAgLmNhdGNoKGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgY29uc29sZS5sb2coYEVycm9yOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gICAgaWYgKHR5cGVvZiBlcnJvckNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGVycm9yQ2FsbGJhY2soZXJyb3IpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhamF4R2V0KHVybCwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgYWpheCh1cmwsIHVuZGVmaW5lZCwgXCJHRVRcIiwgaGVhZGVycywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFqYXhQb3N0KHVybCwgZGF0YSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgaGVhZGVycy5hcHBlbmQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICBhamF4KHVybCwgZGF0YSwgXCJQT1NUXCIsIGhlYWRlcnMsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhamF4UHV0KHVybCwgZGF0YSwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgaGVhZGVycy5hcHBlbmQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICBhamF4KHVybCwgZGF0YSwgXCJQVVRcIiwgaGVhZGVycywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFqYXhEZWxldGUodXJsLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBhamF4KHVybCwgdW5kZWZpbmVkLCBcIkRFTEVURVwiLCBoZWFkZXJzLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdGFjdGlsZS9jbGllbnQvYWpheC5qcyIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25BMTF5S2V5c0JlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5cbnZhciBVdGlsaXR5ID0ge1xuICBkaXN0YW5jZTogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgeERlbHRhID0gKHgxIC0geDIpO1xuICAgIHZhciB5RGVsdGEgPSAoeTEgLSB5Mik7XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHhEZWx0YSAqIHhEZWx0YSArIHlEZWx0YSAqIHlEZWx0YSk7XG4gIH0sXG5cbiAgbm93OiB3aW5kb3cucGVyZm9ybWFuY2UgJiYgd2luZG93LnBlcmZvcm1hbmNlLm5vdyA/XG4gICAgICB3aW5kb3cucGVyZm9ybWFuY2Uubm93LmJpbmQod2luZG93LnBlcmZvcm1hbmNlKSA6IERhdGUubm93XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBFbGVtZW50TWV0cmljcyhlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMud2lkdGggPSB0aGlzLmJvdW5kaW5nUmVjdC53aWR0aDtcbiAgdGhpcy5oZWlnaHQgPSB0aGlzLmJvdW5kaW5nUmVjdC5oZWlnaHQ7XG5cbiAgdGhpcy5zaXplID0gTWF0aC5tYXgodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xufVxuXG5FbGVtZW50TWV0cmljcy5wcm90b3R5cGUgPSB7XG4gIGdldCBib3VuZGluZ1JlY3QgKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0sXG5cbiAgZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb206IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB2YXIgdG9wTGVmdCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgMCwgMCk7XG4gICAgdmFyIHRvcFJpZ2h0ID0gVXRpbGl0eS5kaXN0YW5jZSh4LCB5LCB0aGlzLndpZHRoLCAwKTtcbiAgICB2YXIgYm90dG9tTGVmdCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgMCwgdGhpcy5oZWlnaHQpO1xuICAgIHZhciBib3R0b21SaWdodCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KHRvcExlZnQsIHRvcFJpZ2h0LCBib3R0b21MZWZ0LCBib3R0b21SaWdodCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJpcHBsZShlbGVtZW50KSB7XG4gIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gIHRoaXMuY29sb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5jb2xvcjtcblxuICB0aGlzLndhdmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGhpcy53YXZlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMud2F2ZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSB0aGlzLmNvbG9yO1xuICB0aGlzLndhdmUuY2xhc3NMaXN0LmFkZCgnd2F2ZScpO1xuICB0aGlzLndhdmVDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnd2F2ZS1jb250YWluZXInKTtcbiAgZG9tKHRoaXMud2F2ZUNvbnRhaW5lcikuYXBwZW5kQ2hpbGQodGhpcy53YXZlKTtcblxuICB0aGlzLnJlc2V0SW50ZXJhY3Rpb25TdGF0ZSgpO1xufVxuXG5SaXBwbGUuTUFYX1JBRElVUyA9IDMwMDtcblxuUmlwcGxlLnByb3RvdHlwZSA9IHtcbiAgZ2V0IHJlY2VudGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LnJlY2VudGVycztcbiAgfSxcblxuICBnZXQgY2VudGVyKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuY2VudGVyO1xuICB9LFxuXG4gIGdldCBtb3VzZURvd25FbGFwc2VkKCkge1xuICAgIHZhciBlbGFwc2VkO1xuXG4gICAgaWYgKCF0aGlzLm1vdXNlRG93blN0YXJ0KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBlbGFwc2VkID0gVXRpbGl0eS5ub3coKSAtIHRoaXMubW91c2VEb3duU3RhcnQ7XG5cbiAgICBpZiAodGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgIGVsYXBzZWQgLT0gdGhpcy5tb3VzZVVwRWxhcHNlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gZWxhcHNlZDtcbiAgfSxcblxuICBnZXQgbW91c2VVcEVsYXBzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgIFV0aWxpdHkubm93ICgpIC0gdGhpcy5tb3VzZVVwU3RhcnQgOiAwO1xuICB9LFxuXG4gIGdldCBtb3VzZURvd25FbGFwc2VkU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZURvd25FbGFwc2VkIC8gMTAwMDtcbiAgfSxcblxuICBnZXQgbW91c2VVcEVsYXBzZWRTZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlVXBFbGFwc2VkIC8gMTAwMDtcbiAgfSxcblxuICBnZXQgbW91c2VJbnRlcmFjdGlvblNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VEb3duRWxhcHNlZFNlY29uZHMgKyB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcztcbiAgfSxcblxuICBnZXQgaW5pdGlhbE9wYWNpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5pbml0aWFsT3BhY2l0eTtcbiAgfSxcblxuICBnZXQgb3BhY2l0eURlY2F5VmVsb2NpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5vcGFjaXR5RGVjYXlWZWxvY2l0eTtcbiAgfSxcblxuICBnZXQgcmFkaXVzKCkge1xuICAgIHZhciB3aWR0aDIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggKiB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGg7XG4gICAgdmFyIGhlaWdodDIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0ICogdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodDtcbiAgICB2YXIgd2F2ZVJhZGl1cyA9IE1hdGgubWluKFxuICAgICAgTWF0aC5zcXJ0KHdpZHRoMiArIGhlaWdodDIpLFxuICAgICAgUmlwcGxlLk1BWF9SQURJVVNcbiAgICApICogMS4xICsgNTtcblxuICAgIHZhciBkdXJhdGlvbiA9IDEuMSAtIDAuMiAqICh3YXZlUmFkaXVzIC8gUmlwcGxlLk1BWF9SQURJVVMpO1xuICAgIHZhciB0aW1lTm93ID0gdGhpcy5tb3VzZUludGVyYWN0aW9uU2Vjb25kcyAvIGR1cmF0aW9uO1xuICAgIHZhciBzaXplID0gd2F2ZVJhZGl1cyAqICgxIC0gTWF0aC5wb3coODAsIC10aW1lTm93KSk7XG5cbiAgICByZXR1cm4gTWF0aC5hYnMoc2l6ZSk7XG4gIH0sXG5cbiAgZ2V0IG9wYWNpdHkoKSB7XG4gICAgaWYgKCF0aGlzLm1vdXNlVXBTdGFydCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW5pdGlhbE9wYWNpdHk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgMCxcbiAgICAgIHRoaXMuaW5pdGlhbE9wYWNpdHkgLSB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcyAqIHRoaXMub3BhY2l0eURlY2F5VmVsb2NpdHlcbiAgICApO1xuICB9LFxuXG4gIGdldCBvdXRlck9wYWNpdHkoKSB7XG4gICAgLy8gTGluZWFyIGluY3JlYXNlIGluIGJhY2tncm91bmQgb3BhY2l0eSwgY2FwcGVkIGF0IHRoZSBvcGFjaXR5XG4gICAgLy8gb2YgdGhlIHdhdmVmcm9udCAod2F2ZU9wYWNpdHkpLlxuICAgIHZhciBvdXRlck9wYWNpdHkgPSB0aGlzLm1vdXNlVXBFbGFwc2VkU2Vjb25kcyAqIDAuMztcbiAgICB2YXIgd2F2ZU9wYWNpdHkgPSB0aGlzLm9wYWNpdHk7XG5cbiAgICByZXR1cm4gTWF0aC5tYXgoXG4gICAgICAwLFxuICAgICAgTWF0aC5taW4ob3V0ZXJPcGFjaXR5LCB3YXZlT3BhY2l0eSlcbiAgICApO1xuICB9LFxuXG4gIGdldCBpc09wYWNpdHlGdWxseURlY2F5ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMub3BhY2l0eSA8IDAuMDEgJiZcbiAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gIH0sXG5cbiAgZ2V0IGlzUmVzdGluZ0F0TWF4UmFkaXVzKCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPj0gdGhpcy5pbml0aWFsT3BhY2l0eSAmJlxuICAgICAgdGhpcy5yYWRpdXMgPj0gTWF0aC5taW4odGhpcy5tYXhSYWRpdXMsIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgfSxcblxuICBnZXQgaXNBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZVVwU3RhcnQgP1xuICAgICAgdGhpcy5pc09wYWNpdHlGdWxseURlY2F5ZWQgOiB0aGlzLmlzUmVzdGluZ0F0TWF4UmFkaXVzO1xuICB9LFxuXG4gIGdldCB0cmFuc2xhdGlvbkZyYWN0aW9uKCkge1xuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgIDEsXG4gICAgICB0aGlzLnJhZGl1cyAvIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICogMiAvIE1hdGguc3FydCgyKVxuICAgICk7XG4gIH0sXG5cbiAgZ2V0IHhOb3coKSB7XG4gICAgaWYgKHRoaXMueEVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMueFN0YXJ0ICsgdGhpcy50cmFuc2xhdGlvbkZyYWN0aW9uICogKHRoaXMueEVuZCAtIHRoaXMueFN0YXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy54U3RhcnQ7XG4gIH0sXG5cbiAgZ2V0IHlOb3coKSB7XG4gICAgaWYgKHRoaXMueUVuZCkge1xuICAgICAgcmV0dXJuIHRoaXMueVN0YXJ0ICsgdGhpcy50cmFuc2xhdGlvbkZyYWN0aW9uICogKHRoaXMueUVuZCAtIHRoaXMueVN0YXJ0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy55U3RhcnQ7XG4gIH0sXG5cbiAgZ2V0IGlzTW91c2VEb3duKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlRG93blN0YXJ0ICYmICF0aGlzLm1vdXNlVXBTdGFydDtcbiAgfSxcblxuICByZXNldEludGVyYWN0aW9uU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubWF4UmFkaXVzID0gMDtcbiAgICB0aGlzLm1vdXNlRG93blN0YXJ0ID0gMDtcbiAgICB0aGlzLm1vdXNlVXBTdGFydCA9IDA7XG5cbiAgICB0aGlzLnhTdGFydCA9IDA7XG4gICAgdGhpcy55U3RhcnQgPSAwO1xuICAgIHRoaXMueEVuZCA9IDA7XG4gICAgdGhpcy55RW5kID0gMDtcbiAgICB0aGlzLnNsaWRlRGlzdGFuY2UgPSAwO1xuXG4gICAgdGhpcy5jb250YWluZXJNZXRyaWNzID0gbmV3IEVsZW1lbnRNZXRyaWNzKHRoaXMuZWxlbWVudCk7XG4gIH0sXG5cbiAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjYWxlO1xuICAgIHZhciB0cmFuc2xhdGVTdHJpbmc7XG4gICAgdmFyIGR4O1xuICAgIHZhciBkeTtcblxuICAgIHRoaXMud2F2ZS5zdHlsZS5vcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgc2NhbGUgPSB0aGlzLnJhZGl1cyAvICh0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAvIDIpO1xuICAgIGR4ID0gdGhpcy54Tm93IC0gKHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDIpO1xuICAgIGR5ID0gdGhpcy55Tm93IC0gKHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgLyAyKTtcblxuXG4gICAgLy8gMmQgdHJhbnNmb3JtIGZvciBzYWZhcmkgYmVjYXVzZSBvZiBib3JkZXItcmFkaXVzIGFuZCBvdmVyZmxvdzpoaWRkZW4gY2xpcHBpbmcgYnVnLlxuICAgIC8vIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD05ODUzOFxuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyBkeCArICdweCwgJyArIGR5ICsgJ3B4KSc7XG4gICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgnICsgZHggKyAncHgsICcgKyBkeSArICdweCwgMCknO1xuICAgIHRoaXMud2F2ZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnc2NhbGUoJyArIHNjYWxlICsgJywnICsgc2NhbGUgKyAnKSc7XG4gICAgdGhpcy53YXZlLnN0eWxlLnRyYW5zZm9ybSA9ICdzY2FsZTNkKCcgKyBzY2FsZSArICcsJyArIHNjYWxlICsgJywxKSc7XG4gIH0sXG5cbiAgLyoqIEBwYXJhbSB7RXZlbnQ9fSBldmVudCAqL1xuICBkb3duQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB4Q2VudGVyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC8gMjtcbiAgICB2YXIgeUNlbnRlciA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgLyAyO1xuXG4gICAgdGhpcy5yZXNldEludGVyYWN0aW9uU3RhdGUoKTtcbiAgICB0aGlzLm1vdXNlRG93blN0YXJ0ID0gVXRpbGl0eS5ub3coKTtcblxuICAgIGlmICh0aGlzLmNlbnRlcikge1xuICAgICAgdGhpcy54U3RhcnQgPSB4Q2VudGVyO1xuICAgICAgdGhpcy55U3RhcnQgPSB5Q2VudGVyO1xuICAgICAgdGhpcy5zbGlkZURpc3RhbmNlID0gVXRpbGl0eS5kaXN0YW5jZShcbiAgICAgICAgdGhpcy54U3RhcnQsIHRoaXMueVN0YXJ0LCB0aGlzLnhFbmQsIHRoaXMueUVuZFxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54U3RhcnQgPSBldmVudCA/XG4gICAgICAgICAgZXZlbnQuZGV0YWlsLnggLSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuYm91bmRpbmdSZWN0LmxlZnQgOlxuICAgICAgICAgIHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDI7XG4gICAgICB0aGlzLnlTdGFydCA9IGV2ZW50ID9cbiAgICAgICAgICBldmVudC5kZXRhaWwueSAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5ib3VuZGluZ1JlY3QudG9wIDpcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWNlbnRlcnMpIHtcbiAgICAgIHRoaXMueEVuZCA9IHhDZW50ZXI7XG4gICAgICB0aGlzLnlFbmQgPSB5Q2VudGVyO1xuICAgICAgdGhpcy5zbGlkZURpc3RhbmNlID0gVXRpbGl0eS5kaXN0YW5jZShcbiAgICAgICAgdGhpcy54U3RhcnQsIHRoaXMueVN0YXJ0LCB0aGlzLnhFbmQsIHRoaXMueUVuZFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB0aGlzLm1heFJhZGl1cyA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5mdXJ0aGVzdENvcm5lckRpc3RhbmNlRnJvbShcbiAgICAgIHRoaXMueFN0YXJ0LFxuICAgICAgdGhpcy55U3RhcnRcbiAgICApO1xuXG4gICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLnRvcCA9XG4gICAgICAodGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAtIHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplKSAvIDIgKyAncHgnO1xuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS5sZWZ0ID1cbiAgICAgICh0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLSB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSkgLyAyICsgJ3B4JztcblxuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS53aWR0aCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgKyAncHgnO1xuICB9LFxuXG4gIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgdXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmlzTW91c2VEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5tb3VzZVVwU3RhcnQgPSBVdGlsaXR5Lm5vdygpO1xuICB9LFxuXG4gIHJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgZG9tKHRoaXMud2F2ZUNvbnRhaW5lci5wYXJlbnROb2RlKS5yZW1vdmVDaGlsZChcbiAgICAgIHRoaXMud2F2ZUNvbnRhaW5lclxuICAgICk7XG4gIH1cbn07XG5cblBvbHltZXIoe1xuICBfdGVtcGxhdGU6IGBcbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IGluaGVyaXQ7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcblxuICAgICAgICAvKiBTZWUgUG9seW1lckVsZW1lbnRzL3BhcGVyLWJlaGF2aW9ycy9pc3N1ZXMvMzQuIE9uIG5vbi1DaHJvbWUgYnJvd3NlcnMsXG4gICAgICAgICAqIGNyZWF0aW5nIGEgbm9kZSAod2l0aCBhIHBvc2l0aW9uOmFic29sdXRlKSBpbiB0aGUgbWlkZGxlIG9mIGFuIGV2ZW50XG4gICAgICAgICAqIGhhbmRsZXIgXCJpbnRlcnJ1cHRzXCIgdGhhdCBldmVudCBoYW5kbGVyICh3aGljaCBoYXBwZW5zIHdoZW4gdGhlXG4gICAgICAgICAqIHJpcHBsZSBpcyBjcmVhdGVkIG9uIGRlbWFuZCkgKi9cbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFthbmltYXRpbmddKSB7XG4gICAgICAgIC8qIFRoaXMgcmVzb2x2ZXMgYSByZW5kZXJpbmcgaXNzdWUgaW4gQ2hyb21lIChhcyBvZiA0MCkgd2hlcmUgdGhlXG4gICAgICAgICAgIHJpcHBsZSBpcyBub3QgcHJvcGVybHkgY2xpcHBlZCBieSBpdHMgcGFyZW50ICh3aGljaCBtYXkgaGF2ZVxuICAgICAgICAgICByb3VuZGVkIGNvcm5lcnMpLiBTZWU6IGh0dHA6Ly9qc2Jpbi5jb20vdGVtZXhhLzRcblxuICAgICAgICAgICBOb3RlOiBXZSBvbmx5IGFwcGx5IHRoaXMgc3R5bGUgY29uZGl0aW9uYWxseS4gT3RoZXJ3aXNlLCB0aGUgYnJvd3NlclxuICAgICAgICAgICB3aWxsIGNyZWF0ZSBhIG5ldyBjb21wb3NpdGluZyBsYXllciBmb3IgZXZlcnkgcmlwcGxlIGVsZW1lbnQgb24gdGhlXG4gICAgICAgICAgIHBhZ2UsIGFuZCB0aGF0IHdvdWxkIGJlIGJhZC4gKi9cbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgwLCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmQsXG4gICAgICAjd2F2ZXMsXG4gICAgICAud2F2ZS1jb250YWluZXIsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgIH1cblxuICAgICAgI2JhY2tncm91bmQsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICB9XG5cbiAgICAgICN3YXZlcyxcbiAgICAgIC53YXZlIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLndhdmUtY29udGFpbmVyLFxuICAgICAgLndhdmUge1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KC5jaXJjbGUpICNiYWNrZ3JvdW5kLFxuICAgICAgOmhvc3QoLmNpcmNsZSkgI3dhdmVzIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCguY2lyY2xlKSAud2F2ZS1jb250YWluZXIge1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGlkPVwiYmFja2dyb3VuZFwiPjwvZGl2PlxuICAgIDxkaXYgaWQ9XCJ3YXZlc1wiPjwvZGl2PlxuYCxcblxuICBpczogJ3BhcGVyLXJpcHBsZScsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgSXJvbkExMXlLZXlzQmVoYXZpb3JcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIGluaXRpYWwgb3BhY2l0eSBzZXQgb24gdGhlIHdhdmUuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIGluaXRpYWxPcGFjaXR5XG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC4yNVxuICAgICAqL1xuICAgIGluaXRpYWxPcGFjaXR5OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB2YWx1ZTogMC4yNVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBIb3cgZmFzdCAob3BhY2l0eSBwZXIgc2Vjb25kKSB0aGUgd2F2ZSBmYWRlcyBvdXQuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIG9wYWNpdHlEZWNheVZlbG9jaXR5XG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMC44XG4gICAgICovXG4gICAgb3BhY2l0eURlY2F5VmVsb2NpdHk6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHZhbHVlOiAwLjhcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgcmlwcGxlcyB3aWxsIGV4aGliaXQgYSBncmF2aXRhdGlvbmFsIHB1bGwgdG93YXJkc1xuICAgICAqIHRoZSBjZW50ZXIgb2YgdGhlaXIgY29udGFpbmVyIGFzIHRoZXkgZmFkZSBhd2F5LlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSByZWNlbnRlcnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICByZWNlbnRlcnM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgcmlwcGxlcyB3aWxsIGNlbnRlciBpbnNpZGUgaXRzIGNvbnRhaW5lclxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSByZWNlbnRlcnNcbiAgICAgKiBAdHlwZSBib29sZWFuXG4gICAgICogQGRlZmF1bHQgZmFsc2VcbiAgICAgKi9cbiAgICBjZW50ZXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBsaXN0IG9mIHRoZSB2aXN1YWwgcmlwcGxlcy5cbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgcmlwcGxlc1xuICAgICAqIEB0eXBlIEFycmF5XG4gICAgICogQGRlZmF1bHQgW11cbiAgICAgKi9cbiAgICByaXBwbGVzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIHdoZW4gdGhlcmUgYXJlIHZpc2libGUgcmlwcGxlcyBhbmltYXRpbmcgd2l0aGluIHRoZVxuICAgICAqIGVsZW1lbnQuXG4gICAgICovXG4gICAgYW5pbWF0aW5nOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHJpcHBsZSB3aWxsIHJlbWFpbiBpbiB0aGUgXCJkb3duXCIgc3RhdGUgdW50aWwgYGhvbGREb3duYFxuICAgICAqIGlzIHNldCB0byBmYWxzZSBhZ2Fpbi5cbiAgICAgKi9cbiAgICBob2xkRG93bjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG9ic2VydmVyOiAnX2hvbGREb3duQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHJpcHBsZSB3aWxsIG5vdCBnZW5lcmF0ZSBhIHJpcHBsZSBlZmZlY3RcbiAgICAgKiB2aWEgcG9pbnRlciBpbnRlcmFjdGlvbi5cbiAgICAgKiBDYWxsaW5nIHJpcHBsZSdzIGltcGVyYXRpdmUgYXBpIGxpa2UgYHNpbXVsYXRlZFJpcHBsZWAgd2lsbFxuICAgICAqIHN0aWxsIGdlbmVyYXRlIHRoZSByaXBwbGUgZWZmZWN0LlxuICAgICAqL1xuICAgIG5vaW5rOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIF9hbmltYXRpbmc6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuXG4gICAgX2JvdW5kQW5pbWF0ZToge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZ2V0IHRhcmdldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMua2V5RXZlbnRUYXJnZXQ7XG4gIH0sXG5cbiAga2V5QmluZGluZ3M6IHtcbiAgICAnZW50ZXI6a2V5ZG93bic6ICdfb25FbnRlcktleWRvd24nLFxuICAgICdzcGFjZTprZXlkb3duJzogJ19vblNwYWNlS2V5ZG93bicsXG4gICAgJ3NwYWNlOmtleXVwJzogJ19vblNwYWNlS2V5dXAnXG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFNldCB1cCBhMTF5S2V5c0JlaGF2aW9yIHRvIGxpc3RlbiB0byBrZXkgZXZlbnRzIG9uIHRoZSB0YXJnZXQsXG4gICAgLy8gc28gdGhhdCBzcGFjZSBhbmQgZW50ZXIgYWN0aXZhdGUgdGhlIHJpcHBsZSBldmVuIGlmIHRoZSB0YXJnZXQgZG9lc24ndFxuICAgIC8vIGhhbmRsZSBrZXkgZXZlbnRzLiBUaGUga2V5IGhhbmRsZXJzIGRlYWwgd2l0aCBgbm9pbmtgIHRoZW1zZWx2ZXMuXG4gICAgaWYgKHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZSA9PSAxMSkgeyAvLyBET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG4gICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gZG9tKHRoaXMpLmdldE93bmVyUm9vdCgpLmhvc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5RXZlbnRUYXJnZXQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHZhciBrZXlFdmVudFRhcmdldCA9IC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAodGhpcy5rZXlFdmVudFRhcmdldCk7XG4gICAgdGhpcy5saXN0ZW4oa2V5RXZlbnRUYXJnZXQsICd1cCcsICd1aVVwQWN0aW9uJyk7XG4gICAgdGhpcy5saXN0ZW4oa2V5RXZlbnRUYXJnZXQsICdkb3duJywgJ3VpRG93bkFjdGlvbicpO1xuICB9LFxuXG4gIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVubGlzdGVuKHRoaXMua2V5RXZlbnRUYXJnZXQsICd1cCcsICd1aVVwQWN0aW9uJyk7XG4gICAgdGhpcy51bmxpc3Rlbih0aGlzLmtleUV2ZW50VGFyZ2V0LCAnZG93bicsICd1aURvd25BY3Rpb24nKTtcbiAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gbnVsbDtcbiAgfSxcblxuICBnZXQgc2hvdWxkS2VlcEFuaW1hdGluZyAoKSB7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMucmlwcGxlcy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgIGlmICghdGhpcy5yaXBwbGVzW2luZGV4XS5pc0FuaW1hdGlvbkNvbXBsZXRlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBzaW11bGF0ZWRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZG93bkFjdGlvbihudWxsKTtcblxuICAgIC8vIFBsZWFzZSBzZWUgcG9seW1lci9wb2x5bWVyIzEzMDVcbiAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy51cEFjdGlvbigpO1xuICAgIH0sIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm92b2tlcyBhIHJpcHBsZSBkb3duIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAqL1xuICB1aURvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm5vaW5rKSB7XG4gICAgICB0aGlzLmRvd25BY3Rpb24oZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHJvdm9rZXMgYSByaXBwbGUgZG93biBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAqICpub3QqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgKi9cbiAgZG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5ob2xkRG93biAmJiB0aGlzLnJpcHBsZXMubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByaXBwbGUgPSB0aGlzLmFkZFJpcHBsZSgpO1xuXG4gICAgcmlwcGxlLmRvd25BY3Rpb24oZXZlbnQpO1xuXG4gICAgaWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGluZyA9IHRydWU7XG4gICAgICB0aGlzLmFuaW1hdGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3Zva2VzIGEgcmlwcGxlIHVwIGVmZmVjdCB2aWEgYSBVSSBldmVudCxcbiAgICogcmVzcGVjdGluZyB0aGUgYG5vaW5rYCBwcm9wZXJ0eS5cbiAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50XG4gICAqL1xuICB1aVVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgdGhpcy51cEFjdGlvbihldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQcm92b2tlcyBhIHJpcHBsZSB1cCBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAqICpub3QqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgKi9cbiAgdXBBY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaG9sZERvd24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJpcHBsZXMuZm9yRWFjaChmdW5jdGlvbihyaXBwbGUpIHtcbiAgICAgIHJpcHBsZS51cEFjdGlvbihldmVudCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xuICAgIHRoaXMuYW5pbWF0ZSgpO1xuICB9LFxuXG4gIG9uQW5pbWF0aW9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2FuaW1hdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuJC5iYWNrZ3JvdW5kLnN0eWxlLmJhY2tncm91bmRDb2xvciA9IG51bGw7XG4gICAgdGhpcy5maXJlKCd0cmFuc2l0aW9uZW5kJyk7XG4gIH0sXG5cbiAgYWRkUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmlwcGxlID0gbmV3IFJpcHBsZSh0aGlzKTtcblxuICAgIGRvbSh0aGlzLiQud2F2ZXMpLmFwcGVuZENoaWxkKHJpcHBsZS53YXZlQ29udGFpbmVyKTtcbiAgICB0aGlzLiQuYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByaXBwbGUuY29sb3I7XG4gICAgdGhpcy5yaXBwbGVzLnB1c2gocmlwcGxlKTtcblxuICAgIHRoaXMuX3NldEFuaW1hdGluZyh0cnVlKTtcblxuICAgIHJldHVybiByaXBwbGU7XG4gIH0sXG5cbiAgcmVtb3ZlUmlwcGxlOiBmdW5jdGlvbihyaXBwbGUpIHtcbiAgICB2YXIgcmlwcGxlSW5kZXggPSB0aGlzLnJpcHBsZXMuaW5kZXhPZihyaXBwbGUpO1xuXG4gICAgaWYgKHJpcHBsZUluZGV4IDwgMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucmlwcGxlcy5zcGxpY2UocmlwcGxlSW5kZXgsIDEpO1xuXG4gICAgcmlwcGxlLnJlbW92ZSgpO1xuXG4gICAgaWYgKCF0aGlzLnJpcHBsZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9zZXRBbmltYXRpbmcoZmFsc2UpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBjb25mbGljdHMgd2l0aCBFbGVtZW50I2FudGltYXRlKCkuXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50L2FuaW1hdGVcbiAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgKi9cbiAgYW5pbWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9hbmltYXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGluZGV4O1xuICAgIHZhciByaXBwbGU7XG5cbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnJpcHBsZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICByaXBwbGUgPSB0aGlzLnJpcHBsZXNbaW5kZXhdO1xuXG4gICAgICByaXBwbGUuZHJhdygpO1xuXG4gICAgICB0aGlzLiQuYmFja2dyb3VuZC5zdHlsZS5vcGFjaXR5ID0gcmlwcGxlLm91dGVyT3BhY2l0eTtcblxuICAgICAgaWYgKHJpcHBsZS5pc09wYWNpdHlGdWxseURlY2F5ZWQgJiYgIXJpcHBsZS5pc1Jlc3RpbmdBdE1heFJhZGl1cykge1xuICAgICAgICB0aGlzLnJlbW92ZVJpcHBsZShyaXBwbGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRLZWVwQW5pbWF0aW5nICYmIHRoaXMucmlwcGxlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub25BbmltYXRpb25Db21wbGV0ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX2JvdW5kQW5pbWF0ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9vbkVudGVyS2V5ZG93bjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51aURvd25BY3Rpb24oKTtcbiAgICB0aGlzLmFzeW5jKHRoaXMudWlVcEFjdGlvbiwgMSk7XG4gIH0sXG5cbiAgX29uU3BhY2VLZXlkb3duOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVpRG93bkFjdGlvbigpO1xuICB9LFxuXG4gIF9vblNwYWNlS2V5dXA6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudWlVcEFjdGlvbigpO1xuICB9LFxuXG4gIC8vIG5vdGU6IGhvbGREb3duIGRvZXMgbm90IHJlc3BlY3Qgbm9pbmsgc2luY2UgaXQgY2FuIGJlIGEgZm9jdXMgYmFzZWRcbiAgLy8gZWZmZWN0LlxuICBfaG9sZERvd25DaGFuZ2VkOiBmdW5jdGlvbihuZXdWYWwsIG9sZFZhbCkge1xuICAgIGlmIChvbGRWYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV3VmFsKSB7XG4gICAgICB0aGlzLmRvd25BY3Rpb24oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy51cEFjdGlvbigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMuXG4gIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHdhaXQgdW50aWxcbiAgdGhlIHJpcHBsZSBhbmltYXRpb24gZmluaXNoZXMgdG8gcGVyZm9ybSBzb21lIGFjdGlvbi5cblxuICBAZXZlbnQgdHJhbnNpdGlvbmVuZFxuICBAcGFyYW0ge3tub2RlOiBPYmplY3R9fSBkZXRhaWwgQ29udGFpbnMgdGhlIGFuaW1hdGVkIG5vZGUuXG4gICovXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXJpcHBsZS9wYXBlci1yaXBwbGUuanNcbi8vIG1vZHVsZSBpZCA9IDM1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vLi4vLi4vLi4vQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvYXBwbHktc2hpbS5qcyc7XG5pbXBvcnQgeyBFbGVtZW50TWl4aW4gfSBmcm9tICcuLi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyc7XG5pbXBvcnQgeyBHZXN0dXJlRXZlbnRMaXN0ZW5lcnMgfSBmcm9tICcuLi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IGltcG9ydEhyZWYgYXMgaW1wb3J0SHJlZiQwIH0gZnJvbSAnLi4vdXRpbHMvaW1wb3J0LWhyZWYuanMnO1xuaW1wb3J0ICcuLi91dGlscy9yZW5kZXItc3RhdHVzLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvdW5yZXNvbHZlZC5qcyc7XG5pbXBvcnQgeyBkb20gYXMgZG9tJDAsIG1hdGNoZXNTZWxlY3RvciB9IGZyb20gJy4vcG9seW1lci5kb20uanMnO1xuaW1wb3J0IHsgc2V0VG91Y2hBY3Rpb24gfSBmcm9tICcuLi91dGlscy9nZXN0dXJlcy5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgeyB0aW1lT3V0LCBtaWNyb1Rhc2sgfSBmcm9tICcuLi91dGlscy9hc3luYy5qcyc7XG5pbXBvcnQgeyBnZXQgYXMgZ2V0JDAgfSBmcm9tICcuLi91dGlscy9wYXRoLmpzJztcblxubGV0IHN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTO1xuXG5leHBvcnQgY29uc3QgTGVnYWN5RWxlbWVudE1peGluID0gZGVkdXBpbmdNaXhpbigoYmFzZSkgPT4ge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge2Jhc2V9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICAgKi9cbiAgY29uc3QgbGVnYWN5RWxlbWVudEJhc2UgPSBHZXN0dXJlRXZlbnRMaXN0ZW5lcnMoRWxlbWVudE1peGluKGJhc2UpKTtcblxuICAvKipcbiAgICogTWFwIG9mIHNpbXBsZSBuYW1lcyB0byB0b3VjaCBhY3Rpb24gbmFtZXNcbiAgICogQGRpY3RcbiAgICovXG4gIGNvbnN0IERJUkVDVElPTl9NQVAgPSB7XG4gICAgJ3gnOiAncGFuLXgnLFxuICAgICd5JzogJ3Bhbi15JyxcbiAgICAnbm9uZSc6ICdub25lJyxcbiAgICAnYWxsJzogJ2F1dG8nXG4gIH07XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBleHRlbmRzIHtsZWdhY3lFbGVtZW50QmFzZX1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfTGVnYWN5RWxlbWVudE1peGlufVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBMZWdhY3lFbGVtZW50IGV4dGVuZHMgbGVnYWN5RWxlbWVudEJhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5yb290ID0gdGhpcztcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuaXNBdHRhY2hlZDtcbiAgICAgIC8qKiBAdHlwZSB7V2Vha01hcDwhRWxlbWVudCwgIU9iamVjdDxzdHJpbmcsICFGdW5jdGlvbj4+fSAqL1xuICAgICAgdGhpcy5fX2JvdW5kTGlzdGVuZXJzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBGdW5jdGlvbj59ICovXG4gICAgICB0aGlzLl9kZWJvdW5jZXJzO1xuICAgICAgdGhpcy5jcmVhdGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgdGhlIGBjb25zdHJ1Y3RvcmAsIGZvciBvdmVycmlkaW5nXG4gICAgICogYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgY3JlYXRlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBgY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAgICogd2hpY2ggYWRkcyBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgYXR0YWNoZWRgIG1ldGhvZC5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICB0aGlzLmlzQXR0YWNoZWQgPSB0cnVlO1xuICAgICAgdGhpcy5hdHRhY2hlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBjb25uZWN0ZWRDYWxsYmFja2AsIGZvciBvdmVycmlkaW5nXG4gICAgICogYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgYXR0YWNoZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYFxuICAgICAqIHdoaWNoIGFkZHMgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGRldGFjaGVkYCBtZXRob2QuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgdGhpcy5pc0F0dGFjaGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmRldGFjaGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGRpc2Nvbm5lY3RlZENhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBkZXRhY2hlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBvdmVycmlkZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYFxuICAgICAqIHdoaWNoIGFkZHMgdGhlIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBhdHRyaWJ1dGVDaGFuZ2VkYCBtZXRob2QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyBgYXR0cmlidXRlQ2hhbmdlZENoYWxsYmFja2AsIGZvciBvdmVycmlkaW5nXG4gICAgICogYnkgdGhlIHVzZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSkge30gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgaW1wbGVtZW50YXRpb24gdG9cbiAgICAgKiBhZGQgc3VwcG9ydCBmb3IgY2xhc3MgaW5pdGlhbGl6YXRpb24gdmlhIHRoZSBgX3JlZ2lzdGVyZWRgIGNhbGxiYWNrLlxuICAgICAqIFRoaXMgaXMgY2FsbGVkIG9ubHkgd2hlbiB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQgaXMgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgIGxldCBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKTtcbiAgICAgIGlmICghcHJvdG8uaGFzT3duUHJvcGVydHkoJ19faGFzUmVnaXN0ZXJGaW5pc2hlZCcpKSB7XG4gICAgICAgIHByb3RvLl9faGFzUmVnaXN0ZXJGaW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlZ2lzdGVyZWQoKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdXRvbWF0aWNhbGx5IHdoZW4gYW4gZWxlbWVudCBpcyBpbml0aWFsaXppbmcuXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gY2xhc3MgcmVnaXN0cmF0aW9uIHRpbWVcbiAgICAgKiB3b3JrLiBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGVuc3VyZSB0aGUgd29yayBpcyBwZXJmb3JtZWRcbiAgICAgKiBvbmx5IG9uY2UgZm9yIHRoZSBjbGFzcy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3JlZ2lzdGVyZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBkZWZhdWx0IGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgaW1wbGVtZW50YXRpb24gdG9cbiAgICAgKiBhZGQgc3VwcG9ydCBmb3IgaW5zdGFsbGluZyBgaG9zdEF0dHJpYnV0ZXNgIGFuZCBgbGlzdGVuZXJzYC5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgdGhpcy5fZW5zdXJlQXR0cmlidXRlcygpO1xuICAgICAgdGhpcy5fYXBwbHlMaXN0ZW5lcnMoKTtcbiAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhbiBlbGVtZW50IGhhcyByZXF1aXJlZCBhdHRyaWJ1dGVzLiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudFxuICAgICAqIGlzIGJlaW5nIHJlYWRpZWQgdmlhIGByZWFkeWAuIFVzZXJzIHNob3VsZCBvdmVycmlkZSB0byBzZXQgdGhlXG4gICAgICogZWxlbWVudCdzIHJlcXVpcmVkIGF0dHJpYnV0ZXMuIFRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgYmUgc3VyZVxuICAgICAqIHRvIGNoZWNrIGFuZCBub3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYXR0cmlidXRlcyBhZGRlZCBieVxuICAgICAqIHRoZSB1c2VyIG9mIHRoZSBlbGVtZW50LiBUeXBpY2FsbHksIHNldHRpbmcgYXR0cmlidXRlcyBzaG91bGQgYmUgbGVmdFxuICAgICAqIHRvIHRoZSBlbGVtZW50IHVzZXIgYW5kIG5vdCBkb25lIGhlcmU7IHJlYXNvbmFibGUgZXhjZXB0aW9ucyBpbmNsdWRlXG4gICAgICogc2V0dGluZyBhcmlhIHJvbGVzIGFuZCBmb2N1c2FiaWxpdHkuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9lbnN1cmVBdHRyaWJ1dGVzKCkge31cblxuICAgIC8qKlxuICAgICAqIEFkZHMgZWxlbWVudCBldmVudCBsaXN0ZW5lcnMuIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50XG4gICAgICogaXMgYmVpbmcgcmVhZGllZCB2aWEgYHJlYWR5YC4gVXNlcnMgc2hvdWxkIG92ZXJyaWRlIHRvXG4gICAgICogYWRkIGFueSByZXF1aXJlZCBlbGVtZW50IGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBJbiBwZXJmb3JtYW5jZSBjcml0aWNhbCBlbGVtZW50cywgdGhlIHdvcmsgZG9uZSBoZXJlIHNob3VsZCBiZSBrZXB0XG4gICAgICogdG8gYSBtaW5pbXVtIHNpbmNlIGl0IGlzIGRvbmUgYmVmb3JlIHRoZSBlbGVtZW50IGlzIHJlbmRlcmVkLiBJblxuICAgICAqIHRoZXNlIGVsZW1lbnRzLCBjb25zaWRlciBhZGRpbmcgbGlzdGVuZXJzIGFzeWNocm9ub3VzbHkgc28gYXMgbm90IHRvXG4gICAgICogYmxvY2sgcmVuZGVyLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfYXBwbHlMaXN0ZW5lcnMoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy4gVG8gY3VzdG9taXplXG4gICAgICogaG93IHByb3BlcnRpZXMgYXJlIHNlcmlhbGl6ZWQgdG8gYXR0cmlidXRlcyBmb3IgYXR0cmlidXRlIGJpbmRpbmdzIGFuZFxuICAgICAqIGByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVgIHByb3BlcnRpZXMgYXMgd2VsbCBhcyB0aGlzIG1ldGhvZCwgb3ZlcnJpZGVcbiAgICAgKiB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHByb3ZpZGVkIGJ5IGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gZGVzZXJpYWxpemVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmcgfCB1bmRlZmluZWR9IFNlcmlhbGl6ZWQgdmFsdWVcbiAgICAgKi9cbiAgICBzZXJpYWxpemUodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemVWYWx1ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy4gIFRvIGN1c3RvbWl6ZVxuICAgICAqIGhvdyBhdHRyaWJ1dGVzIGFyZSBkZXNlcmlhbGl6ZWQgdG8gcHJvcGVydGllcyBmb3IgaW5cbiAgICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCwgb3ZlcnJpZGUgYF9kZXNlcmlhbGl6ZVZhbHVlYCBtZXRob2RcbiAgICAgKiBwcm92aWRlZCBieSBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgU3RyaW5nIHRvIGRlc2VyaWFsaXplXG4gICAgICogQHBhcmFtIHsqfSB0eXBlIFR5cGUgdG8gZGVzZXJpYWxpemUgdGhlIHN0cmluZyB0b1xuICAgICAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIGRlc2VyaWFsaXplZCB2YWx1ZSBpbiB0aGUgYHR5cGVgIGdpdmVuLlxuICAgICAqL1xuICAgIGRlc2VyaWFsaXplKHZhbHVlLCB0eXBlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSB0byByZWZsZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gcmVmZWN0LlxuICAgICAqL1xuICAgIHJlZmxlY3RQcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLl9wcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgdHlwZWQgdmFsdWUgdG8gYW4gSFRNTCBhdHRyaWJ1dGUgb24gYSBub2RlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gc2VyaWFsaXplIHRvLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHNldCBhdHRyaWJ1dGUgdG8uXG4gICAgICovXG4gICAgc2VyaWFsaXplVmFsdWVUb0F0dHJpYnV0ZSh2YWx1ZSwgYXR0cmlidXRlLCBub2RlKSB7XG4gICAgICB0aGlzLl92YWx1ZVRvTm9kZUF0dHJpYnV0ZSgvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpLCB2YWx1ZSwgYXR0cmlidXRlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgb3duIHByb3BlcnRpZXMgKGluY2x1ZGluZyBhY2Nlc3NvciBkZXNjcmlwdG9ycykgZnJvbSBhIHNvdXJjZVxuICAgICAqIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRhcmdldCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhcGkgU291cmNlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHByb3RvdHlwZSBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGFzIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqL1xuICAgIGV4dGVuZChwcm90b3R5cGUsIGFwaSkge1xuICAgICAgaWYgKCEocHJvdG90eXBlICYmIGFwaSkpIHtcbiAgICAgICAgcmV0dXJuIHByb3RvdHlwZSB8fCBhcGk7XG4gICAgICB9XG4gICAgICBsZXQgbiQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcGkpO1xuICAgICAgZm9yIChsZXQgaT0wLCBuOyAoaTxuJC5sZW5ndGgpICYmIChuPW4kW2ldKTsgaSsrKSB7XG4gICAgICAgIGxldCBwZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYXBpLCBuKTtcbiAgICAgICAgaWYgKHBkKSB7XG4gICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvdHlwZSwgbiwgcGQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvdG90eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wcyBmcm9tIGEgc291cmNlIG9iamVjdCB0byBhIHRhcmdldCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBOb3RlLCB0aGlzIG1ldGhvZCB1c2VzIGEgc2ltcGxlIGBmb3IuLi5pbmAgc3RyYXRlZ3kgZm9yIGVudW1lcmF0aW5nXG4gICAgICogcHJvcGVydGllcy4gIFRvIGVuc3VyZSBvbmx5IGBvd25Qcm9wZXJ0aWVzYCBhcmUgY29waWVkIGZyb20gc291cmNlXG4gICAgICogdG8gdGFyZ2V0IGFuZCB0aGF0IGFjY2Vzc29yIGltcGxlbWVudGF0aW9ucyBhcmUgY29waWVkLCB1c2UgYGV4dGVuZGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGFyZ2V0IFRhcmdldCBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgU291cmNlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRhcmdldCBvYmplY3QgdGhhdCB3YXMgcGFzc2VkIGFzIGZpcnN0IGFyZ3VtZW50LlxuICAgICAqL1xuICAgIG1peGluKHRhcmdldCwgc291cmNlKSB7XG4gICAgICBmb3IgKGxldCBpIGluIHNvdXJjZSkge1xuICAgICAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHByb3RvdHlwZSBvZiBhbiBvYmplY3QuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCBvbiB3aGljaCB0byBzZXQgdGhlIHByb3RvdHlwZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG90eXBlIFRoZSBwcm90b3R5cGUgdGhhdCB3aWxsIGJlIHNldCBvbiB0aGUgZ2l2ZW5cbiAgICAgKiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgdGhlIGdpdmVuIGBvYmplY3RgIHdpdGggaXRzIHByb3RvdHlwZSBzZXRcbiAgICAgKiB0byB0aGUgZ2l2ZW4gYHByb3RvdHlwZWAgb2JqZWN0LlxuICAgICAqL1xuICAgIGNoYWluT2JqZWN0KG9iamVjdCwgcHJvdG90eXBlKSB7XG4gICAgICBpZiAob2JqZWN0ICYmIHByb3RvdHlwZSAmJiBvYmplY3QgIT09IHByb3RvdHlwZSkge1xuICAgICAgICBvYmplY3QuX19wcm90b19fID0gcHJvdG90eXBlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9XG5cbiAgICAvKiAqKioqIEJlZ2luIFRlbXBsYXRlICoqKiogKi9cblxuICAgIC8qKlxuICAgICAqIENhbGxzIGBpbXBvcnROb2RlYCBvbiB0aGUgYGNvbnRlbnRgIG9mIHRoZSBgdGVtcGxhdGVgIHNwZWNpZmllZCBhbmRcbiAgICAgKiByZXR1cm5zIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgaW1wb3J0ZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgSFRNTCB0ZW1wbGF0ZSBlbGVtZW50IHRvIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9IERvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGltcG9ydGVkXG4gICAgICogICB0ZW1wbGF0ZSBjb250ZW50LlxuICAgICovXG4gICAgaW5zdGFuY2VUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLmNvbnN0cnVjdG9yLl9jb250ZW50Rm9yVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IGRvbSA9IC8qKiBAdHlwZSB7RG9jdW1lbnRGcmFnbWVudH0gKi9cbiAgICAgICAgKGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSkpO1xuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG5cbiAgICAvKiAqKioqIEJlZ2luIEV2ZW50cyAqKioqICovXG5cblxuXG4gICAgLyoqXG4gICAgICogRGlzcGF0Y2hlcyBhIGN1c3RvbSBldmVudCB3aXRoIGFuIG9wdGlvbmFsIGRldGFpbCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIE5hbWUgb2YgZXZlbnQgdHlwZS5cbiAgICAgKiBAcGFyYW0geyo9fSBkZXRhaWwgRGV0YWlsIHZhbHVlIGNvbnRhaW5pbmcgZXZlbnQtc3BlY2lmaWNcbiAgICAgKiAgIHBheWxvYWQuXG4gICAgICogQHBhcmFtIHt7IGJ1YmJsZXM6IChib29sZWFufHVuZGVmaW5lZCksIGNhbmNlbGFibGU6IChib29sZWFufHVuZGVmaW5lZCksIGNvbXBvc2VkOiAoYm9vbGVhbnx1bmRlZmluZWQpIH09fVxuICAgICAqICBvcHRpb25zIE9iamVjdCBzcGVjaWZ5aW5nIG9wdGlvbnMuICBUaGVzZSBtYXkgaW5jbHVkZTpcbiAgICAgKiAgYGJ1YmJsZXNgIChib29sZWFuLCBkZWZhdWx0cyB0byBgdHJ1ZWApLFxuICAgICAqICBgY2FuY2VsYWJsZWAgKGJvb2xlYW4sIGRlZmF1bHRzIHRvIGZhbHNlKSwgYW5kXG4gICAgICogIGBub2RlYCBvbiB3aGljaCB0byBmaXJlIHRoZSBldmVudCAoSFRNTEVsZW1lbnQsIGRlZmF1bHRzIHRvIGB0aGlzYCkuXG4gICAgICogQHJldHVybiB7RXZlbnR9IFRoZSBuZXcgZXZlbnQgdGhhdCB3YXMgZmlyZWQuXG4gICAgICovXG4gICAgZmlyZSh0eXBlLCBkZXRhaWwsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgZGV0YWlsID0gKGRldGFpbCA9PT0gbnVsbCB8fCBkZXRhaWwgPT09IHVuZGVmaW5lZCkgPyB7fSA6IGRldGFpbDtcbiAgICAgIGxldCBldmVudCA9IG5ldyBFdmVudCh0eXBlLCB7XG4gICAgICAgIGJ1YmJsZXM6IG9wdGlvbnMuYnViYmxlcyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogQm9vbGVhbihvcHRpb25zLmNhbmNlbGFibGUpLFxuICAgICAgICBjb21wb3NlZDogb3B0aW9ucy5jb21wb3NlZCA9PT0gdW5kZWZpbmVkID8gdHJ1ZTogb3B0aW9ucy5jb21wb3NlZFxuICAgICAgfSk7XG4gICAgICBldmVudC5kZXRhaWwgPSBkZXRhaWw7XG4gICAgICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCB0aGlzO1xuICAgICAgbm9kZS5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gYWRkIGFuIGV2ZW50IGxpc3RlbmVyIG9uIGEgZ2l2ZW4gZWxlbWVudCxcbiAgICAgKiBsYXRlIGJvdW5kIHRvIGEgbmFtZWQgbWV0aG9kIG9uIHRoaXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIGFkZCBldmVudCBsaXN0ZW5lciB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnQgdG8gbGlzdGVuIGZvci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIGhhbmRsZXIgbWV0aG9kIG9uIGB0aGlzYCB0byBjYWxsLlxuICAgICAqL1xuICAgIGxpc3Rlbihub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIGxldCBoYmwgPSB0aGlzLl9fYm91bmRMaXN0ZW5lcnMgfHxcbiAgICAgICAgKHRoaXMuX19ib3VuZExpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCkpO1xuICAgICAgbGV0IGJsID0gaGJsLmdldChub2RlKTtcbiAgICAgIGlmICghYmwpIHtcbiAgICAgICAgYmwgPSB7fTtcbiAgICAgICAgaGJsLnNldChub2RlLCBibCk7XG4gICAgICB9XG4gICAgICBsZXQga2V5ID0gZXZlbnROYW1lICsgbWV0aG9kTmFtZTtcbiAgICAgIGlmICghYmxba2V5XSkge1xuICAgICAgICBibFtrZXldID0gdGhpcy5fYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShcbiAgICAgICAgICBub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUsIHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byByZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIgZnJvbSBhIGdpdmVuIGVsZW1lbnQsXG4gICAgICogbGF0ZSBib3VuZCB0byBhIG5hbWVkIG1ldGhvZCBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnQgdG8gc3RvcCBsaXN0ZW5pbmcgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBoYW5kbGVyIG1ldGhvZCBvbiBgdGhpc2AgdG8gbm90IGNhbGxcbiAgICAgYW55bW9yZS5cbiAgICAgKi9cbiAgICB1bmxpc3Rlbihub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIGxldCBibCA9IHRoaXMuX19ib3VuZExpc3RlbmVycyAmJiB0aGlzLl9fYm91bmRMaXN0ZW5lcnMuZ2V0KG5vZGUpO1xuICAgICAgbGV0IGtleSA9IGV2ZW50TmFtZSArIG1ldGhvZE5hbWU7XG4gICAgICBsZXQgaGFuZGxlciA9IGJsICYmIGJsW2tleV07XG4gICAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgICAgYmxba2V5XSA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgc2Nyb2xsaW5nIGJlaGF2aW9yIHRvIGFsbCBkaXJlY3Rpb24sIG9uZSBkaXJlY3Rpb24sIG9yIG5vbmUuXG4gICAgICpcbiAgICAgKiBWYWxpZCBzY3JvbGwgZGlyZWN0aW9uczpcbiAgICAgKiAgIC0gJ2FsbCc6IHNjcm9sbCBpbiBhbnkgZGlyZWN0aW9uXG4gICAgICogICAtICd4Jzogc2Nyb2xsIG9ubHkgaW4gdGhlICd4JyBkaXJlY3Rpb25cbiAgICAgKiAgIC0gJ3knOiBzY3JvbGwgb25seSBpbiB0aGUgJ3knIGRpcmVjdGlvblxuICAgICAqICAgLSAnbm9uZSc6IGRpc2FibGUgc2Nyb2xsaW5nIGZvciB0aGlzIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZGlyZWN0aW9uIERpcmVjdGlvbiB0byBhbGxvdyBzY3JvbGxpbmdcbiAgICAgKiBEZWZhdWx0cyB0byBgYWxsYC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gYXBwbHkgc2Nyb2xsIGRpcmVjdGlvbiBzZXR0aW5nLlxuICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgKi9cbiAgICBzZXRTY3JvbGxEaXJlY3Rpb24oZGlyZWN0aW9uLCBub2RlKSB7XG4gICAgICBzZXRUb3VjaEFjdGlvbiggKG5vZGUgfHwgdGhpcyksIERJUkVDVElPTl9NQVBbZGlyZWN0aW9uXSB8fCAnYXV0bycpO1xuICAgIH1cbiAgICAvKiAqKioqIEVuZCBFdmVudHMgKioqKiAqL1xuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJ1biBgcXVlcnlTZWxlY3RvcmAgb24gdGhpcyBsb2NhbCBET00gc2NvcGUuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGNhbGxzIGBQb2x5bWVyLmRvbSh0aGlzLnJvb3QpLnF1ZXJ5U2VsZWN0b3Ioc2xjdHIpYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzbGN0ciBTZWxlY3RvciB0byBydW4gb24gdGhpcyBsb2NhbCBET00gc2NvcGVcbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBFbGVtZW50IGZvdW5kIGJ5IHRoZSBzZWxlY3Rvciwgb3IgbnVsbCBpZiBub3QgZm91bmQuXG4gICAgICovXG4gICAgJCQoc2xjdHIpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihzbGN0cik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBlbGVtZW50IHdob3NlIGxvY2FsIGRvbSB3aXRoaW4gd2hpY2ggdGhpcyBlbGVtZW50XG4gICAgICogaXMgY29udGFpbmVkLiBUaGlzIGlzIGEgc2hvcnRoYW5kIGZvclxuICAgICAqIGB0aGlzLmdldFJvb3ROb2RlKCkuaG9zdGAuXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICovXG4gICAgZ2V0IGRvbUhvc3QoKSB7XG4gICAgICBsZXQgcm9vdCA9IHRoaXMuZ2V0Um9vdE5vZGUoKTtcbiAgICAgIHJldHVybiAocm9vdCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpID8gLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyAocm9vdCkuaG9zdCA6IHJvb3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9yY2UgdGhpcyBlbGVtZW50IHRvIGRpc3RyaWJ1dGUgaXRzIGNoaWxkcmVuIHRvIGl0cyBsb2NhbCBkb20uXG4gICAgICogVGhpcyBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBhcyBvZiBQb2x5bWVyIDIuMC4yIGFuZCBpcyBwcm92aWRlZCBvbmx5XG4gICAgICogZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgICAqL1xuICAgIGRpc3RyaWJ1dGVDb250ZW50KCkge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeURPTSAmJiB0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgICAgU2hhZHlET00uZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyB0aGF0IGFyZSB0aGUgZWZmZWN0aXZlIGNoaWxkTm9kZXMuIFRoZSBlZmZlY3RpdmVcbiAgICAgKiBjaGlsZE5vZGVzIGxpc3QgaXMgdGhlIHNhbWUgYXMgdGhlIGVsZW1lbnQncyBjaGlsZE5vZGVzIGV4Y2VwdCB0aGF0XG4gICAgICogYW55IGA8Y29udGVudD5gIGVsZW1lbnRzIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBsaXN0IG9mIG5vZGVzIGRpc3RyaWJ1dGVkXG4gICAgICogdG8gdGhlIGA8Y29udGVudD5gLCB0aGUgcmVzdWx0IG9mIGl0cyBgZ2V0RGlzdHJpYnV0ZWROb2Rlc2AgbWV0aG9kLlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkIG5vZGVzLlxuICAgICAqL1xuICAgIGdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyAoZG9tJDAodGhpcykpLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZCB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXQgbWF0Y2hcbiAgICAgKiBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkcmVuIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkIHRvXG4gICAgICogY2hpbGRyZW4gdGhhdCBhcmUgaW5zZXJ0aW9uIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGRpc3RyaWJ1dGVkIGVsZW1lbnRzIHRoYXQgbWF0Y2ggc2VsZWN0b3IuXG4gICAgICovXG4gICAgcXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyAoZG9tJDAodGhpcykpLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3RvcilcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWxlbWVudHMgdGhhdCBhcmUgdGhlIGVmZmVjdGl2ZSBjaGlsZHJlbi4gVGhlIGVmZmVjdGl2ZVxuICAgICAqIGNoaWxkcmVuIGxpc3QgaXMgdGhlIHNhbWUgYXMgdGhlIGVsZW1lbnQncyBjaGlsZHJlbiBleGNlcHQgdGhhdFxuICAgICAqIGFueSBgPGNvbnRlbnQ+YCBlbGVtZW50cyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgbGlzdCBvZiBlbGVtZW50c1xuICAgICAqIGRpc3RyaWJ1dGVkIHRvIHRoZSBgPGNvbnRlbnQ+YC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGdldEVmZmVjdGl2ZUNoaWxkcmVuKCkge1xuICAgICAgbGV0IGxpc3QgPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgIHJldHVybiBsaXN0LmZpbHRlcihmdW5jdGlvbigvKiogQHR5cGUge05vZGV9ICovIG4pIHtcbiAgICAgICAgcmV0dXJuIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIHRleHQgY29udGVudCB0aGF0IGlzIHRoZSBjb25jYXRlbmF0aW9uIG9mIHRoZVxuICAgICAqIHRleHQgY29udGVudCdzIG9mIHRoZSBlbGVtZW50J3MgZWZmZWN0aXZlIGNoaWxkTm9kZXMgKHRoZSBlbGVtZW50c1xuICAgICAqIHJldHVybmVkIGJ5IDxhIGhyZWY9XCIjZ2V0RWZmZWN0aXZlQ2hpbGROb2Rlcz5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzPC9hPi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RpdmVUZXh0Q29udGVudCgpIHtcbiAgICAgIGxldCBjbiA9IHRoaXMuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpO1xuICAgICAgbGV0IHRjID0gW107XG4gICAgICBmb3IgKGxldCBpPTAsIGM7IChjID0gY25baV0pOyBpKyspIHtcbiAgICAgICAgaWYgKGMubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdGMucHVzaChjLnRleHRDb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRjLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGZpcnN0IGVmZmVjdGl2ZSBjaGlsZE5vZGUgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0XG4gICAgICogbWF0Y2ggYHNlbGVjdG9yYC4gVGhlc2UgY2FuIGJlIGRvbSBjaGlsZCBub2RlcyBvciBlbGVtZW50cyBkaXN0cmlidXRlZFxuICAgICAqIHRvIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3Q8Tm9kZT59IEZpcnN0IGVmZmVjdGl2ZSBjaGlsZCBub2RlIHRoYXQgbWF0Y2hlcyBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBxdWVyeUVmZmVjdGl2ZUNoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgICBsZXQgZSQgPSB0aGlzLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICByZXR1cm4gZSQgJiYgZSRbMF07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWZmZWN0aXZlIGNoaWxkTm9kZXMgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0XG4gICAgICogbWF0Y2ggYHNlbGVjdG9yYC4gVGhlc2UgY2FuIGJlIGRvbSBjaGlsZCBub2RlcyBvciBlbGVtZW50cyBkaXN0cmlidXRlZFxuICAgICAqIHRvIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBlZmZlY3RpdmUgY2hpbGQgbm9kZXMgdGhhdCBtYXRjaCBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBxdWVyeUFsbEVmZmVjdGl2ZUNoaWxkcmVuKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIGRpc3RyaWJ1dGVkIHRvIHRoaXMgZWxlbWVudCdzIGA8c2xvdD5gLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBlbGVtZW50IGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgYDxzbG90PmAgaW4gaXRzIGxvY2FsIERPTSxcbiAgICAgKiBhbiBvcHRpb25hbCBzZWxlY3RvciBtYXkgYmUgcGFzc2VkIHRvIGNob29zZSB0aGUgZGVzaXJlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBzbGN0ciBDU1Mgc2VsZWN0b3IgdG8gY2hvb3NlIHRoZSBkZXNpcmVkXG4gICAgICogICBgPHNsb3Q+YC4gIERlZmF1bHRzIHRvIGBjb250ZW50YC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBkaXN0cmlidXRlZCBub2RlcyBmb3IgdGhlIGA8c2xvdD5gLlxuICAgICAqL1xuICAgIGdldENvbnRlbnRDaGlsZE5vZGVzKHNsY3RyKSB7XG4gICAgICBsZXQgY29udGVudCA9IHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKHNsY3RyIHx8ICdzbG90Jyk7XG4gICAgICByZXR1cm4gY29udGVudCA/IC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovKGRvbSQwKGNvbnRlbnQpKS5nZXREaXN0cmlidXRlZE5vZGVzKCkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlbGVtZW50IGNoaWxkcmVuIGRpc3RyaWJ1dGVkIHRvIHRoaXMgZWxlbWVudCdzXG4gICAgICogYDxzbG90PmAuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGVsZW1lbnQgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBgPHNsb3Q+YCBpbiBpdHNcbiAgICAgKiBsb2NhbCBET00sIGFuIG9wdGlvbmFsIHNlbGVjdG9yIG1heSBiZSBwYXNzZWQgdG8gY2hvb3NlIHRoZSBkZXNpcmVkXG4gICAgICogY29udGVudC4gIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBgZ2V0Q29udGVudENoaWxkTm9kZXNgIGluIHRoYXQgb25seVxuICAgICAqIGVsZW1lbnRzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2xjdHIgQ1NTIHNlbGVjdG9yIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAqICAgYDxjb250ZW50PmAuICBEZWZhdWx0cyB0byBgY29udGVudGAuXG4gICAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fSBMaXN0IG9mIGRpc3RyaWJ1dGVkIG5vZGVzIGZvciB0aGVcbiAgICAgKiAgIGA8c2xvdD5gLlxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIGdldENvbnRlbnRDaGlsZHJlbihzbGN0cikge1xuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7QXJyYXk8SFRNTEVsZW1lbnQ+fSAqLyh0aGlzLmdldENvbnRlbnRDaGlsZE5vZGVzKHNsY3RyKS5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoaXMgZWxlbWVudCdzIGxpZ2h0IERPTSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/Tm9kZX0gbm9kZSBUaGUgZWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbm9kZSBpcyBpbiB0aGlzIGVsZW1lbnQncyBsaWdodCBET00gdHJlZS5cbiAgICAgKi9cbiAgICBpc0xpZ2h0RGVzY2VuZGFudChub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcyAhPT0gbm9kZSAmJiB0aGlzLmNvbnRhaW5zKG5vZGUpICYmXG4gICAgICAgICAgdGhpcy5nZXRSb290Tm9kZSgpID09PSBub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBpbiB0aGlzIGVsZW1lbnQncyBsb2NhbCBET00gdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgVGhlIGVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG5vZGUgaXMgaW4gdGhpcyBlbGVtZW50J3MgbG9jYWwgRE9NIHRyZWUuXG4gICAgICovXG4gICAgaXNMb2NhbERlc2NlbmRhbnQobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdCA9PT0gbm9kZS5nZXRSb290Tm9kZSgpO1xuICAgIH1cblxuICAgIC8vIE5PVEU6IHNob3VsZCBub3cgYmUgaGFuZGxlZCBieSBTaGFkeUNzcyBsaWJyYXJ5LlxuICAgIHNjb3BlU3VidHJlZShjb250YWluZXIsIHNob3VsZE9ic2VydmUpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbXB1dGVkIHN0eWxlIHZhbHVlIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFRoZSBjc3MgcHJvcGVydHkgbmFtZS5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFJldHVybnMgdGhlIGNvbXB1dGVkIGNzcyBwcm9wZXJ0eSB2YWx1ZSBmb3IgdGhlIGdpdmVuXG4gICAgICogYHByb3BlcnR5YC5cbiAgICAgKi9cbiAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWUocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBzdHlsZUludGVyZmFjZS5nZXRDb21wdXRlZFN0eWxlVmFsdWUodGhpcywgcHJvcGVydHkpO1xuICAgIH1cblxuICAgIC8vIGRlYm91bmNlXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIGBkZWJvdW5jZWAgdG8gY29sbGFwc2UgbXVsdGlwbGUgcmVxdWVzdHMgZm9yIGEgbmFtZWQgdGFzayBpbnRvXG4gICAgICogb25lIGludm9jYXRpb24gd2hpY2ggaXMgbWFkZSBhZnRlciB0aGUgd2FpdCB0aW1lIGhhcyBlbGFwc2VkIHdpdGhcbiAgICAgKiBubyBuZXcgcmVxdWVzdC4gIElmIG5vIHdhaXQgdGltZSBpcyBnaXZlbiwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gICAgICogYXQgbWljcm90YXNrIHRpbWluZyAoZ3VhcmFudGVlZCBiZWZvcmUgcGFpbnQpLlxuICAgICAqXG4gICAgICogICAgIGRlYm91bmNlZENsaWNrQWN0aW9uKGUpIHtcbiAgICAgKiAgICAgICAvLyB3aWxsIG5vdCBjYWxsIGBwcm9jZXNzQ2xpY2tgIG1vcmUgdGhhbiBvbmNlIHBlciAxMDBtc1xuICAgICAqICAgICAgIHRoaXMuZGVib3VuY2UoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgIHRoaXMucHJvY2Vzc0NsaWNrKCk7XG4gICAgICogICAgICAgfSAxMDApO1xuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBTdHJpbmcgdG8gaW5kZW50aWZ5IHRoZSBkZWJvdW5jZSBqb2IuXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCAod2l0aCBgdGhpc2BcbiAgICAgKiAgIGNvbnRleHQpIHdoZW4gdGhlIHdhaXQgdGltZSBlbGFwc2VzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IE9wdGlvbmFsIHdhaXQgdGltZSBpbiBtaWxsaXNlY29uZHMgKG1zKSBhZnRlciB0aGVcbiAgICAgKiAgIGxhc3Qgc2lnbmFsIHRoYXQgbXVzdCBlbGFwc2UgYmVmb3JlIGludm9raW5nIGBjYWxsYmFja2BcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYSBkZWJvdW5jZXIgb2JqZWN0IG9uIHdoaWNoIGV4aXN0cyB0aGVcbiAgICAgKiBmb2xsb3dpbmcgbWV0aG9kczogYGlzQWN0aXZlKClgIHJldHVybnMgdHJ1ZSBpZiB0aGUgZGVib3VuY2VyIGlzXG4gICAgICogYWN0aXZlOyBgY2FuY2VsKClgIGNhbmNlbHMgdGhlIGRlYm91bmNlciBpZiBpdCBpcyBhY3RpdmU7XG4gICAgICogYGZsdXNoKClgIGltbWVkaWF0ZWx5IGludm9rZXMgdGhlIGRlYm91bmNlZCBjYWxsYmFjayBpZiB0aGUgZGVib3VuY2VyXG4gICAgICogaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGRlYm91bmNlKGpvYk5hbWUsIGNhbGxiYWNrLCB3YWl0KSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgIHJldHVybiB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdID0gRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgICAgdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXVxuICAgICAgICAgICwgd2FpdCA+IDAgPyB0aW1lT3V0LmFmdGVyKHdhaXQpIDogbWljcm9UYXNrXG4gICAgICAgICAgLCBjYWxsYmFjay5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBuYW1lZCBkZWJvdW5jZXIgaXMgYWN0aXZlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGRlYm91bmNlciBpcyBhY3RpdmUgKGhhcyBub3QgeWV0IGZpcmVkKS5cbiAgICAgKi9cbiAgICBpc0RlYm91bmNlckFjdGl2ZShqb2JOYW1lKSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgIGxldCBkZWJvdW5jZXIgPSB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdO1xuICAgICAgcmV0dXJuICEhKGRlYm91bmNlciAmJiBkZWJvdW5jZXIuaXNBY3RpdmUoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1tZWRpYXRlbHkgY2FsbHMgdGhlIGRlYm91bmNlciBgY2FsbGJhY2tgIGFuZCBpbmFjdGl2YXRlcyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgKi9cbiAgICBmbHVzaERlYm91bmNlcihqb2JOYW1lKSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgIGxldCBkZWJvdW5jZXIgPSB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdO1xuICAgICAgaWYgKGRlYm91bmNlcikge1xuICAgICAgICBkZWJvdW5jZXIuZmx1c2goKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIuICBUaGUgYGNhbGxiYWNrYCB3aWxsIG5vdCBiZSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVib3VuY2VyIHN0YXJ0ZWQgd2l0aCBgZGVib3VuY2VgXG4gICAgICovXG4gICAgY2FuY2VsRGVib3VuY2VyKGpvYk5hbWUpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICBpZiAoZGVib3VuY2VyKSB7XG4gICAgICAgIGRlYm91bmNlci5jYW5jZWwoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSdW5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gYXN5bmNyb25vdXNseS5cbiAgICAgKlxuICAgICAqIEJ5IGRlZmF1bHQgKGlmIG5vIHdhaXRUaW1lIGlzIHNwZWNpZmllZCksIGFzeW5jIGNhbGxiYWNrcyBhcmUgcnVuIGF0XG4gICAgICogbWljcm90YXNrIHRpbWluZywgd2hpY2ggd2lsbCBvY2N1ciBiZWZvcmUgcGFpbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuLCBib3VuZCB0byBgdGhpc2AuXG4gICAgICogQHBhcmFtIHtudW1iZXI9fSB3YWl0VGltZSBUaW1lIHRvIHdhaXQgYmVmb3JlIGNhbGxpbmcgdGhlXG4gICAgICogICBgY2FsbGJhY2tgLiAgSWYgdW5zcGVjaWZpZWQgb3IgMCwgdGhlIGNhbGxiYWNrIHdpbGwgYmUgcnVuIGF0IG1pY3JvdGFza1xuICAgICAqICAgdGltaW5nIChiZWZvcmUgcGFpbnQpLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHRoYXQgbWF5IGJlIHVzZWQgdG8gY2FuY2VsIHRoZSBhc3luYyBqb2IuXG4gICAgICovXG4gICAgYXN5bmMoY2FsbGJhY2ssIHdhaXRUaW1lKSB7XG4gICAgICByZXR1cm4gd2FpdFRpbWUgPiAwID8gdGltZU91dC5ydW4oY2FsbGJhY2suYmluZCh0aGlzKSwgd2FpdFRpbWUpIDpcbiAgICAgICAgICB+bWljcm9UYXNrLnJ1bihjYWxsYmFjay5iaW5kKHRoaXMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGFuIGFzeW5jIG9wZXJhdGlvbiBzdGFydGVkIHdpdGggYGFzeW5jYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gb3JpZ2luYWwgYGFzeW5jYCBjYWxsIHRvXG4gICAgICogICBjYW5jZWwuXG4gICAgICovXG4gICAgY2FuY2VsQXN5bmMoaGFuZGxlKSB7XG4gICAgICBoYW5kbGUgPCAwID8gbWljcm9UYXNrLmNhbmNlbCh+aGFuZGxlKSA6XG4gICAgICAgICAgdGltZU91dC5jYW5jZWwoaGFuZGxlKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlclxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBjcmVhdGluZyBhbiBlbGVtZW50IGFuZCBjb25maWd1cmluZyBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0YWcgSFRNTCBlbGVtZW50IHRhZyB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIE9iamVjdCBvZiBwcm9wZXJ0aWVzIHRvIGNvbmZpZ3VyZSBvbiB0aGVcbiAgICAgKiAgICBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtFbGVtZW50fSBOZXdseSBjcmVhdGVkIGFuZCBjb25maWd1cmVkIGVsZW1lbnQuXG4gICAgICovXG4gICAgY3JlYXRlKHRhZywgcHJvcHMpIHtcbiAgICAgIGxldCBlbHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgaWYgKGVsdC5zZXRQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgZWx0LnNldFByb3BlcnRpZXMocHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAobGV0IG4gaW4gcHJvcHMpIHtcbiAgICAgICAgICAgIGVsdFtuXSA9IHByb3BzW25dO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGltcG9ydGluZyBhbiBIVE1MIGRvY3VtZW50IGltcGVyYXRpdmVseS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBuZXcgYDxsaW5rIHJlbD1cImltcG9ydFwiPmAgZWxlbWVudCB3aXRoXG4gICAgICogdGhlIHByb3ZpZGVkIFVSTCBhbmQgYXBwZW5kcyBpdCB0byB0aGUgZG9jdW1lbnQgdG8gc3RhcnQgbG9hZGluZy5cbiAgICAgKiBJbiB0aGUgYG9ubG9hZGAgY2FsbGJhY2ssIHRoZSBgaW1wb3J0YCBwcm9wZXJ0eSBvZiB0aGUgYGxpbmtgXG4gICAgICogZWxlbWVudCB3aWxsIGNvbnRhaW4gdGhlIGltcG9ydGVkIGRvY3VtZW50IGNvbnRlbnRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgVVJMIHRvIGRvY3VtZW50IHRvIGxvYWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25sb2FkIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydCBzdWNjZXNzZnVsbHlcbiAgICAgKiAgIGxvYWRlZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbmVycm9yIENhbGxiYWNrIHRvIG5vdGlmeSB3aGVuIGFuIGltcG9ydFxuICAgICAqICAgdW5zdWNjZXNzZnVsbHkgbG9hZGVkLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3B0QXN5bmMgVHJ1ZSBpZiB0aGUgaW1wb3J0IHNob3VsZCBiZSBsb2FkZWQgYGFzeW5jYC5cbiAgICAgKiAgIERlZmF1bHRzIHRvIGBmYWxzZWAuXG4gICAgICogQHJldHVybiB7SFRNTExpbmtFbGVtZW50fSBUaGUgbGluayBlbGVtZW50IGZvciB0aGUgVVJMIHRvIGJlIGxvYWRlZC5cbiAgICAgKi9cbiAgICBpbXBvcnRIcmVmKGhyZWYsIG9ubG9hZCwgb25lcnJvciwgb3B0QXN5bmMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgbGV0IGxvYWRGbiA9IG9ubG9hZCA/IG9ubG9hZC5iaW5kKHRoaXMpIDogbnVsbDtcbiAgICAgIGxldCBlcnJvckZuID0gb25lcnJvciA/IG9uZXJyb3IuYmluZCh0aGlzKSA6IG51bGw7XG4gICAgICByZXR1cm4gaW1wb3J0SHJlZiQwKGhyZWYsIGxvYWRGbiwgZXJyb3JGbiwgb3B0QXN5bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBvbHlmaWxsIGZvciBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzLCB3aGljaCBpcyBzb21ldGltZXMgc3RpbGxcbiAgICAgKiBwcmVmaXhlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byB0ZXN0LlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byB0ZXN0IHRoZSBzZWxlY3RvciBhZ2FpbnN0LlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGVsZW1lbnQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IuXG4gICAgICovXG4gICAgZWxlbWVudE1hdGNoZXMoc2VsZWN0b3IsIG5vZGUpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzU2VsZWN0b3IoIChub2RlIHx8IHRoaXMpLCBzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBvciBvZmYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBIVE1MIGF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gYm9vbCBCb29sZWFuIHRvIGZvcmNlIHRoZSBhdHRyaWJ1dGUgb24gb3Igb2ZmLlxuICAgICAqICAgIFdoZW4gdW5zcGVjaWZpZWQsIHRoZSBzdGF0ZSBvZiB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmV2ZXJzZWQuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBOb2RlIHRvIHRhcmdldC4gIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgKi9cbiAgICB0b2dnbGVBdHRyaWJ1dGUobmFtZSwgYm9vbCwgbm9kZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGJvb2wgPSAhbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoYm9vbCkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYSBDU1MgY2xhc3Mgb24gb3Igb2ZmLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIGNsYXNzIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBib29sIEJvb2xlYW4gdG8gZm9yY2UgdGhlIGNsYXNzIG9uIG9yIG9mZi5cbiAgICAgKiAgICBXaGVuIHVuc3BlY2lmaWVkLCB0aGUgc3RhdGUgb2YgdGhlIGNsYXNzIHdpbGwgYmUgcmV2ZXJzZWQuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBOb2RlIHRvIHRhcmdldC4gIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgKi9cbiAgICB0b2dnbGVDbGFzcyhuYW1lLCBib29sLCBub2RlKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgYm9vbCA9ICFub2RlLmNsYXNzTGlzdC5jb250YWlucyhuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChib29sKSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZChuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZShuYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcy1wbGF0Zm9ybSBoZWxwZXIgZm9yIHNldHRpbmcgYW4gZWxlbWVudCdzIENTUyBgdHJhbnNmb3JtYCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0cmFuc2Zvcm1UZXh0IFRyYW5zZm9ybSBzZXR0aW5nLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHRvLlxuICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYFxuICAgICAqL1xuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm1UZXh0LCBub2RlKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIG5vZGUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtVGV4dDtcbiAgICAgIG5vZGUuc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtVGV4dDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcm9zcy1wbGF0Zm9ybSBoZWxwZXIgZm9yIHNldHRpbmcgYW4gZWxlbWVudCdzIENTUyBgdHJhbnNsYXRlM2RgXG4gICAgICogcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCBYIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSBZIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geiBaIG9mZnNldC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSB0by5cbiAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICovXG4gICAgdHJhbnNsYXRlM2QoeCwgeSwgeiwgbm9kZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgndHJhbnNsYXRlM2QoJyArIHggKyAnLCcgKyB5ICsgJywnICsgeiArICcpJywgbm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBpdGVtIGZyb20gYW4gYXJyYXksIGlmIGl0IGV4aXN0cy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBhcnJheSBpcyBzcGVjaWZpZWQgYnkgcGF0aCwgYSBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlzXG4gICAgICogZ2VuZXJhdGVkLCBzbyB0aGF0IG9ic2VydmVycywgZGF0YSBiaW5kaW5ncyBhbmQgY29tcHV0ZWRcbiAgICAgKiBwcm9wZXJ0aWVzIHdhdGNoaW5nIHRoYXQgcGF0aCBjYW4gdXBkYXRlLlxuICAgICAqXG4gICAgICogSWYgdGhlIGFycmF5IGlzIHBhc3NlZCBkaXJlY3RseSwgKipubyBjaGFuZ2VcbiAgICAgKiBub3RpZmljYXRpb24gaXMgZ2VuZXJhdGVkKiouXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxudW1iZXJ8c3RyaW5nPn0gYXJyYXlPclBhdGggUGF0aCB0byBhcnJheSBmcm9tIHdoaWNoIHRvIHJlbW92ZSB0aGUgaXRlbVxuICAgICAqICAgKG9yIHRoZSBhcnJheSBpdHNlbGYpLlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBpdGVtIHJlbW92ZWQuXG4gICAgICovXG4gICAgYXJyYXlEZWxldGUoYXJyYXlPclBhdGgsIGl0ZW0pIHtcbiAgICAgIGxldCBpbmRleDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFycmF5T3JQYXRoKSkge1xuICAgICAgICBpbmRleCA9IGFycmF5T3JQYXRoLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIGFycmF5T3JQYXRoLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBhcnIgPSBnZXQkMCh0aGlzLCBhcnJheU9yUGF0aCk7XG4gICAgICAgIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc3BsaWNlKGFycmF5T3JQYXRoLCBpbmRleCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIGxvZ2dpbmdcblxuICAgIC8qKlxuICAgICAqIEZhY2FkZXMgYGNvbnNvbGUubG9nYC9gd2FybmAvYGVycm9yYCBhcyBvdmVycmlkZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXZlbCBPbmUgb2YgJ2xvZycsICd3YXJuJywgJ2Vycm9yJ1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAqL1xuICAgIF9sb2dnZXIobGV2ZWwsIGFyZ3MpIHtcbiAgICAgIC8vIGFjY2VwdCBbJ2ZvbycsICdiYXInXSBhbmQgW1snZm9vJywgJ2JhciddXVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncykgJiYgYXJncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgYXJncyA9IGFyZ3NbMF07XG4gICAgICB9XG4gICAgICBzd2l0Y2gobGV2ZWwpIHtcbiAgICAgICAgY2FzZSAnbG9nJzpcbiAgICAgICAgY2FzZSAnd2Fybic6XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBjb25zb2xlW2xldmVsXSguLi5hcmdzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGYWNhZGVzIGBjb25zb2xlLmxvZ2AgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAqL1xuICAgIF9sb2coLi4uYXJncykge1xuICAgICAgdGhpcy5fbG9nZ2VyKCdsb2cnLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGYWNhZGVzIGBjb25zb2xlLndhcm5gIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgKi9cbiAgICBfd2FybiguLi5hcmdzKSB7XG4gICAgICB0aGlzLl9sb2dnZXIoJ3dhcm4nLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGYWNhZGVzIGBjb25zb2xlLmVycm9yYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICovXG4gICAgX2Vycm9yKC4uLmFyZ3MpIHtcbiAgICAgIHRoaXMuX2xvZ2dlcignZXJyb3InLCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JtYXRzIGEgbWVzc2FnZSB1c2luZyB0aGUgZWxlbWVudCB0eXBlIGFuIGEgbWV0aG9kIG5hbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBNZXRob2QgbmFtZSB0byBhc3NvY2lhdGUgd2l0aCBtZXNzYWdlXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgd2l0aCBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIGZvciBgY29uc29sZWBcbiAgICAgKiAgIGxvZ2dpbmcuXG4gICAgICovXG4gICAgX2xvZ2YobWV0aG9kTmFtZSwgLi4uYXJncykge1xuICAgICAgcmV0dXJuIFsnWyVzOjolc10nLCB0aGlzLmlzLCBtZXRob2ROYW1lLCAuLi5hcmdzXTtcbiAgICB9XG5cbiAgfVxuXG4gIExlZ2FjeUVsZW1lbnQucHJvdG90eXBlLmlzID0gJyc7XG5cbiAgcmV0dXJuIExlZ2FjeUVsZW1lbnQ7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L2xlZ2FjeS1lbGVtZW50LW1peGluLmpzXG4vLyBtb2R1bGUgaWQgPSAzNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7bmF0aXZlU2hhZG93LCBuYXRpdmVDc3NWYXJpYWJsZXN9IGZyb20gJy4vc3R5bGUtc2V0dGluZ3MuanMnO1xuaW1wb3J0IHtwYXJzZSwgc3RyaW5naWZ5LCB0eXBlcywgU3R5bGVOb2RlfSBmcm9tICcuL2Nzcy1wYXJzZS5qcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7TUVESUFfTUFUQ0h9IGZyb20gJy4vY29tbW9uLXJlZ2V4LmpzJztcbmltcG9ydCB7cHJvY2Vzc1Vuc2NvcGVkU3R5bGUsIGlzVW5zY29wZWRTdHlsZX0gZnJvbSAnLi91bnNjb3BlZC1zdHlsZS1oYW5kbGVyLmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3xTdHlsZU5vZGV9IHJ1bGVzXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFN0eWxlTm9kZSk9fSBjYWxsYmFja1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Dc3NUZXh0IChydWxlcywgY2FsbGJhY2spIHtcbiAgaWYgKCFydWxlcykge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBpZiAodHlwZW9mIHJ1bGVzID09PSAnc3RyaW5nJykge1xuICAgIHJ1bGVzID0gcGFyc2UocnVsZXMpO1xuICB9XG4gIGlmIChjYWxsYmFjaykge1xuICAgIGZvckVhY2hSdWxlKHJ1bGVzLCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIHN0cmluZ2lmeShydWxlcywgbmF0aXZlQ3NzVmFyaWFibGVzKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBydWxlc0ZvclN0eWxlKHN0eWxlKSB7XG4gIGlmICghc3R5bGVbJ19fY3NzUnVsZXMnXSAmJiBzdHlsZS50ZXh0Q29udGVudCkge1xuICAgIHN0eWxlWydfX2Nzc1J1bGVzJ10gPSBwYXJzZShzdHlsZS50ZXh0Q29udGVudCk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlWydfX2Nzc1J1bGVzJ10gfHwgbnVsbDtcbn1cblxuLy8gVGVzdHMgaWYgYSBydWxlIGlzIGEga2V5ZnJhbWVzIHNlbGVjdG9yLCB3aGljaCBsb29rcyBhbG1vc3QgZXhhY3RseVxuLy8gbGlrZSBhIG5vcm1hbCBzZWxlY3RvciBidXQgaXMgbm90IChpdCBoYXMgbm90aGluZyB0byBkbyB3aXRoIHNjb3Bpbmdcbi8vIGZvciBleGFtcGxlKS5cbi8qKlxuICogQHBhcmFtIHtTdHlsZU5vZGV9IHJ1bGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0tleWZyYW1lc1NlbGVjdG9yKHJ1bGUpIHtcbiAgcmV0dXJuIEJvb2xlYW4ocnVsZVsncGFyZW50J10pICYmXG4gIHJ1bGVbJ3BhcmVudCddWyd0eXBlJ10gPT09IHR5cGVzLktFWUZSQU1FU19SVUxFO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gc3R5bGVSdWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBrZXlmcmFtZXNSdWxlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IG9ubHlBY3RpdmVSdWxlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZm9yRWFjaFJ1bGUobm9kZSwgc3R5bGVSdWxlQ2FsbGJhY2ssIGtleWZyYW1lc1J1bGVDYWxsYmFjaywgb25seUFjdGl2ZVJ1bGVzKSB7XG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgc2tpcFJ1bGVzID0gZmFsc2U7XG4gIGxldCB0eXBlID0gbm9kZVsndHlwZSddO1xuICBpZiAob25seUFjdGl2ZVJ1bGVzKSB7XG4gICAgaWYgKHR5cGUgPT09IHR5cGVzLk1FRElBX1JVTEUpIHtcbiAgICAgIGxldCBtYXRjaE1lZGlhID0gbm9kZVsnc2VsZWN0b3InXS5tYXRjaChNRURJQV9NQVRDSCk7XG4gICAgICBpZiAobWF0Y2hNZWRpYSkge1xuICAgICAgICAvLyBpZiBydWxlIGlzIGEgbm9uIG1hdGNoaW5nIEBtZWRpYSBydWxlLCBza2lwIHN1YnJ1bGVzXG4gICAgICAgIGlmICghd2luZG93Lm1hdGNoTWVkaWEobWF0Y2hNZWRpYVsxXSkubWF0Y2hlcykge1xuICAgICAgICAgIHNraXBSdWxlcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUgPT09IHR5cGVzLlNUWUxFX1JVTEUpIHtcbiAgICBzdHlsZVJ1bGVDYWxsYmFjayhub2RlKTtcbiAgfSBlbHNlIGlmIChrZXlmcmFtZXNSdWxlQ2FsbGJhY2sgJiZcbiAgICB0eXBlID09PSB0eXBlcy5LRVlGUkFNRVNfUlVMRSkge1xuICAgIGtleWZyYW1lc1J1bGVDYWxsYmFjayhub2RlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSB0eXBlcy5NSVhJTl9SVUxFKSB7XG4gICAgc2tpcFJ1bGVzID0gdHJ1ZTtcbiAgfVxuICBsZXQgciQgPSBub2RlWydydWxlcyddO1xuICBpZiAociQgJiYgIXNraXBSdWxlcykge1xuICAgIGZvciAobGV0IGk9MCwgbD1yJC5sZW5ndGgsIHI7IChpPGwpICYmIChyPXIkW2ldKTsgaSsrKSB7XG4gICAgICBmb3JFYWNoUnVsZShyLCBzdHlsZVJ1bGVDYWxsYmFjaywga2V5ZnJhbWVzUnVsZUNhbGxiYWNrLCBvbmx5QWN0aXZlUnVsZXMpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBhZGQgYSBzdHJpbmcgb2YgY3NzVGV4dCB0byB0aGUgZG9jdW1lbnQuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gbW9uaWtlclxuICogQHBhcmFtIHtOb2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7Tm9kZX0gY29udGV4dE5vZGVcbiAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUNzcyhjc3NUZXh0LCBtb25pa2VyLCB0YXJnZXQsIGNvbnRleHROb2RlKSB7XG4gIGxldCBzdHlsZSA9IGNyZWF0ZVNjb3BlU3R5bGUoY3NzVGV4dCwgbW9uaWtlcik7XG4gIGFwcGx5U3R5bGUoc3R5bGUsIHRhcmdldCwgY29udGV4dE5vZGUpO1xuICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb25pa2VyXG4gKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2NvcGVTdHlsZShjc3NUZXh0LCBtb25pa2VyKSB7XG4gIGxldCBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTFN0eWxlRWxlbWVudH0gKi8oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKSk7XG4gIGlmIChtb25pa2VyKSB7XG4gICAgc3R5bGUuc2V0QXR0cmlidXRlKCdzY29wZScsIG1vbmlrZXIpO1xuICB9XG4gIHN0eWxlLnRleHRDb250ZW50ID0gY3NzVGV4dDtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG4vKipcbiAqIFRyYWNrIHRoZSBwb3NpdGlvbiBvZiB0aGUgbGFzdCBhZGRlZCBzdHlsZSBmb3IgcGxhY2luZyBwbGFjZWhvbGRlcnNcbiAqIEB0eXBlIHtOb2RlfVxuICovXG5sZXQgbGFzdEhlYWRBcHBseU5vZGUgPSBudWxsO1xuXG4vLyBpbnNlcnQgYSBjb21tZW50IG5vZGUgYXMgYSBzdHlsaW5nIHBvc2l0aW9uIHBsYWNlaG9sZGVyLlxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9uaWtlclxuICogQHJldHVybiB7IUNvbW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlUGxhY2VIb2xkZXIobW9uaWtlcikge1xuICBsZXQgcGxhY2VIb2xkZXIgPSBkb2N1bWVudC5jcmVhdGVDb21tZW50KCcgU2hhZHkgRE9NIHN0eWxlcyBmb3IgJyArXG4gICAgbW9uaWtlciArICcgJyk7XG4gIGxldCBhZnRlciA9IGxhc3RIZWFkQXBwbHlOb2RlID9cbiAgICBsYXN0SGVhZEFwcGx5Tm9kZVsnbmV4dFNpYmxpbmcnXSA6IG51bGw7XG4gIGxldCBzY29wZSA9IGRvY3VtZW50LmhlYWQ7XG4gIHNjb3BlLmluc2VydEJlZm9yZShwbGFjZUhvbGRlciwgYWZ0ZXIgfHwgc2NvcGUuZmlyc3RDaGlsZCk7XG4gIGxhc3RIZWFkQXBwbHlOb2RlID0gcGxhY2VIb2xkZXI7XG4gIHJldHVybiBwbGFjZUhvbGRlcjtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gKiBAcGFyYW0gez9Ob2RlfSB0YXJnZXRcbiAqIEBwYXJhbSB7P05vZGV9IGNvbnRleHROb2RlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseVN0eWxlKHN0eWxlLCB0YXJnZXQsIGNvbnRleHROb2RlKSB7XG4gIHRhcmdldCA9IHRhcmdldCB8fCBkb2N1bWVudC5oZWFkO1xuICBsZXQgYWZ0ZXIgPSAoY29udGV4dE5vZGUgJiYgY29udGV4dE5vZGUubmV4dFNpYmxpbmcpIHx8XG4gICAgdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gIHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGFmdGVyKTtcbiAgaWYgKCFsYXN0SGVhZEFwcGx5Tm9kZSkge1xuICAgIGxhc3RIZWFkQXBwbHlOb2RlID0gc3R5bGU7XG4gIH0gZWxzZSB7XG4gICAgLy8gb25seSB1cGRhdGUgbGFzdEhlYWRBcHBseU5vZGUgaWYgdGhlIG5ldyBzdHlsZSBpcyBpbnNlcnRlZCBhZnRlciB0aGUgb2xkIGxhc3RIZWFkQXBwbHlOb2RlXG4gICAgbGV0IHBvc2l0aW9uID0gc3R5bGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24obGFzdEhlYWRBcHBseU5vZGUpO1xuICAgIGlmIChwb3NpdGlvbiA9PT0gTm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcpIHtcbiAgICAgIGxhc3RIZWFkQXBwbHlOb2RlID0gc3R5bGU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJ1aWxkVHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVGFyZ2V0ZWRCdWlsZChidWlsZFR5cGUpIHtcbiAgcmV0dXJuIG5hdGl2ZVNoYWRvdyA/IGJ1aWxkVHlwZSA9PT0gJ3NoYWRvdycgOiBidWlsZFR5cGUgPT09ICdzaGFkeSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3NzQnVpbGRUeXBlKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjc3MtYnVpbGQnKTtcbn1cblxuLyoqXG4gKiBXYWxrIGZyb20gdGV4dFtzdGFydF0gbWF0Y2hpbmcgcGFyZW5zIGFuZFxuICogcmV0dXJucyBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgZW5kIHBhcmVuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmRNYXRjaGluZ1BhcmVuKHRleHQsIHN0YXJ0KSB7XG4gIGxldCBsZXZlbCA9IDA7XG4gIGZvciAobGV0IGk9c3RhcnQsIGw9dGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAodGV4dFtpXSA9PT0gJygnKSB7XG4gICAgICBsZXZlbCsrO1xuICAgIH0gZWxzZSBpZiAodGV4dFtpXSA9PT0gJyknKSB7XG4gICAgICBpZiAoLS1sZXZlbCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBzdHJpbmcsIHN0cmluZywgc3RyaW5nKX0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NWYXJpYWJsZUFuZEZhbGxiYWNrKHN0ciwgY2FsbGJhY2spIHtcbiAgLy8gZmluZCAndmFyKCdcbiAgbGV0IHN0YXJ0ID0gc3RyLmluZGV4T2YoJ3ZhcignKTtcbiAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgIC8vIG5vIHZhcj8sIGV2ZXJ5dGhpbmcgaXMgcHJlZml4XG4gICAgcmV0dXJuIGNhbGxiYWNrKHN0ciwgJycsICcnLCAnJyk7XG4gIH1cbiAgLy8ke3ByZWZpeH12YXIoJHtpbm5lcn0pJHtzdWZmaXh9XG4gIGxldCBlbmQgPSBmaW5kTWF0Y2hpbmdQYXJlbihzdHIsIHN0YXJ0ICsgMyk7XG4gIGxldCBpbm5lciA9IHN0ci5zdWJzdHJpbmcoc3RhcnQgKyA0LCBlbmQpO1xuICBsZXQgcHJlZml4ID0gc3RyLnN1YnN0cmluZygwLCBzdGFydCk7XG4gIC8vIHN1ZmZpeCBtYXkgaGF2ZSBvdGhlciB2YXJpYWJsZXNcbiAgbGV0IHN1ZmZpeCA9IHByb2Nlc3NWYXJpYWJsZUFuZEZhbGxiYWNrKHN0ci5zdWJzdHJpbmcoZW5kICsgMSksIGNhbGxiYWNrKTtcbiAgbGV0IGNvbW1hID0gaW5uZXIuaW5kZXhPZignLCcpO1xuICAvLyB2YWx1ZSBhbmQgZmFsbGJhY2sgYXJncyBzaG91bGQgYmUgdHJpbW1lZCB0byBtYXRjaCBpbiBwcm9wZXJ0eSBsb29rdXBcbiAgaWYgKGNvbW1hID09PSAtMSkge1xuICAgIC8vIHZhcmlhYmxlLCBubyBmYWxsYmFja1xuICAgIHJldHVybiBjYWxsYmFjayhwcmVmaXgsIGlubmVyLnRyaW0oKSwgJycsIHN1ZmZpeCk7XG4gIH1cbiAgLy8gdmFyKCR7dmFsdWV9LCR7ZmFsbGJhY2t9KVxuICBsZXQgdmFsdWUgPSBpbm5lci5zdWJzdHJpbmcoMCwgY29tbWEpLnRyaW0oKTtcbiAgbGV0IGZhbGxiYWNrID0gaW5uZXIuc3Vic3RyaW5nKGNvbW1hICsgMSkudHJpbSgpO1xuICByZXR1cm4gY2FsbGJhY2socHJlZml4LCB2YWx1ZSwgZmFsbGJhY2ssIHN1ZmZpeCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEVsZW1lbnRDbGFzc1JhdyhlbGVtZW50LCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIHNldEF0dHJpYnV0ZSBwcm92aWRlZCBieSBTaGFkeURPTSB3aGVuIHNldEF0dHJpYnV0ZSBpcyBwYXRjaGVkXG4gIGlmIChuYXRpdmVTaGFkb3cpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCB2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgd2luZG93WydTaGFkeURPTSddWyduYXRpdmVNZXRob2RzJ11bJ3NldEF0dHJpYnV0ZSddLmNhbGwoZWxlbWVudCwgJ2NsYXNzJywgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50IHwge2lzOiBzdHJpbmcsIGV4dGVuZHM6IHN0cmluZ319IGVsZW1lbnRcbiAqIEByZXR1cm4ge3tpczogc3RyaW5nLCB0eXBlRXh0ZW5zaW9uOiBzdHJpbmd9fVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SXNFeHRlbmRzKGVsZW1lbnQpIHtcbiAgbGV0IGxvY2FsTmFtZSA9IGVsZW1lbnRbJ2xvY2FsTmFtZSddO1xuICBsZXQgaXMgPSAnJywgdHlwZUV4dGVuc2lvbiA9ICcnO1xuICAvKlxuICBOT1RFOiB0ZWNobmljYWxseSwgdGhpcyBjYW4gYmUgd3JvbmcgZm9yIGNlcnRhaW4gc3ZnIGVsZW1lbnRzXG4gIHdpdGggYC1gIGluIHRoZSBuYW1lIGxpa2UgYDxmb250LWZhY2U+YFxuICAqL1xuICBpZiAobG9jYWxOYW1lKSB7XG4gICAgaWYgKGxvY2FsTmFtZS5pbmRleE9mKCctJykgPiAtMSkge1xuICAgICAgaXMgPSBsb2NhbE5hbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHR5cGVFeHRlbnNpb24gPSBsb2NhbE5hbWU7XG4gICAgICBpcyA9IChlbGVtZW50LmdldEF0dHJpYnV0ZSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaXMnKSkgfHwgJyc7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlzID0gLyoqIEB0eXBlIHs/fSAqLyhlbGVtZW50KS5pcztcbiAgICB0eXBlRXh0ZW5zaW9uID0gLyoqIEB0eXBlIHs/fSAqLyhlbGVtZW50KS5leHRlbmRzO1xuICB9XG4gIHJldHVybiB7aXMsIHR5cGVFeHRlbnNpb259O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnYXRoZXJTdHlsZVRleHQoZWxlbWVudCkge1xuICAvKiogQHR5cGUgeyFBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCBzdHlsZVRleHRQYXJ0cyA9IFtdO1xuICBjb25zdCBzdHlsZXMgPSAvKiogQHR5cGUgeyFOb2RlTGlzdDwhSFRNTFN0eWxlRWxlbWVudD59ICovKGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3R5bGUgPSBzdHlsZXNbaV07XG4gICAgaWYgKGlzVW5zY29wZWRTdHlsZShzdHlsZSkpIHtcbiAgICAgIGlmICghbmF0aXZlU2hhZG93KSB7XG4gICAgICAgIHByb2Nlc3NVbnNjb3BlZFN0eWxlKHN0eWxlKTtcbiAgICAgICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlVGV4dFBhcnRzLnB1c2goc3R5bGUudGV4dENvbnRlbnQpO1xuICAgICAgc3R5bGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZVRleHRQYXJ0cy5qb2luKCcnKS50cmltKCk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3N0eWxlLXV0aWwuanNcbi8vIG1vZHVsZSBpZCA9IDM3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCAhSFRNTFRlbXBsYXRlRWxlbWVudD59XG4gKi9cbmNvbnN0IHRlbXBsYXRlTWFwID0ge307XG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZU1hcDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy90ZW1wbGF0ZS1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHtQcm9taXNlPHZvaWQ+fSAqL1xubGV0IHJlYWR5UHJvbWlzZSA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P2Z1bmN0aW9uKD9mdW5jdGlvbigpKX0gKi9cbmxldCB3aGVuUmVhZHkgPSB3aW5kb3dbJ0hUTUxJbXBvcnRzJ10gJiYgd2luZG93WydIVE1MSW1wb3J0cyddWyd3aGVuUmVhZHknXSB8fCBudWxsO1xuXG4vKiogQHR5cGUge2Z1bmN0aW9uKCl9ICovXG5sZXQgcmVzb2x2ZUZuO1xuXG4vKipcbiAqIEBwYXJhbSB7P2Z1bmN0aW9uKCl9IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRvY3VtZW50V2FpdChjYWxsYmFjaykge1xuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgaWYgKHdoZW5SZWFkeSkge1xuICAgICAgd2hlblJlYWR5KGNhbGxiYWNrKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJlYWR5UHJvbWlzZSkge1xuICAgICAgICByZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge3Jlc29sdmVGbiA9IHJlc29sdmV9KTtcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICByZXNvbHZlRm4oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgICAgcmVzb2x2ZUZuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlYWR5UHJvbWlzZS50aGVuKGZ1bmN0aW9uKCl7IGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7IH0pO1xuICAgIH1cbiAgfSk7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvZG9jdW1lbnQtd2FpdC5qc1xuLy8gbW9kdWxlIGlkID0gMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgZG9jdW1lbnRXYWl0IGZyb20gJy4vZG9jdW1lbnQtd2FpdC5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge0hUTUxTdHlsZUVsZW1lbnQgfCB7Z2V0U3R5bGU6IGZ1bmN0aW9uKCk6SFRNTFN0eWxlRWxlbWVudH19XG4gKi9cbmV4cG9ydCBsZXQgQ3VzdG9tU3R5bGVQcm92aWRlcjtcblxuY29uc3QgU0VFTl9NQVJLRVIgPSAnX19zZWVuQnlTaGFkeUNTUyc7XG5jb25zdCBDQUNIRURfU1RZTEUgPSAnX19zaGFkeUNTU0NhY2hlZFN0eWxlJztcblxuLyoqIEB0eXBlIHs/ZnVuY3Rpb24oIUhUTUxTdHlsZUVsZW1lbnQpfSAqL1xubGV0IHRyYW5zZm9ybUZuID0gbnVsbDtcblxuLyoqIEB0eXBlIHs/ZnVuY3Rpb24oKX0gKi9cbmxldCB2YWxpZGF0ZUZuID0gbnVsbDtcblxuLyoqXG5UaGlzIGludGVyZmFjZSBpcyBwcm92aWRlZCB0byBhZGQgZG9jdW1lbnQtbGV2ZWwgPHN0eWxlPiBlbGVtZW50cyB0byBTaGFkeUNTUyBmb3IgcHJvY2Vzc2luZy5cblRoZXNlIHN0eWxlcyBtdXN0IGJlIHByb2Nlc3NlZCBieSBTaGFkeUNTUyB0byBzaW11bGF0ZSBTaGFkb3dSb290IHVwcGVyLWJvdW5kIGVuY2Fwc3VsYXRpb24gZnJvbSBvdXRzaWRlIHN0eWxlc1xuSW4gYWRkaXRpb24sIHRoZXNlIHN0eWxlcyBtYXkgYWxzbyBuZWVkIHRvIGJlIHByb2Nlc3NlZCBmb3IgQGFwcGx5IHJ1bGVzIGFuZCBDU1MgQ3VzdG9tIFByb3BlcnRpZXNcblxuVG8gYWRkIGRvY3VtZW50LWxldmVsIHN0eWxlcyB0byBTaGFkeUNTUywgb25lIGNhbiBjYWxsIGBTaGFkeUNTUy5hZGREb2N1bWVudFN0eWxlKHN0eWxlRWxlbWVudClgIG9yIGBTaGFkeUNTUy5hZGREb2N1bWVudFN0eWxlKHtnZXRTdHlsZTogKCkgPT4gc3R5bGVFbGVtZW50fSlgXG5cbkluIGFkZGl0aW9uLCBpZiB0aGUgcHJvY2VzcyB1c2VkIHRvIGRpc2NvdmVyIGRvY3VtZW50LWxldmVsIHN0eWxlcyBjYW4gYmUgc3luY2hyb25vdXNseSBmbHVzaGVkLCBvbmUgc2hvdWxkIHNldCBgU2hhZHlDU1MuZG9jdW1lbnRTdHlsZUZsdXNoYC5cblRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2hlbiBjYWxjdWxhdGluZyBzdHlsZXMuXG5cbkFuIGV4YW1wbGUgdXNhZ2Ugb2YgdGhlIGRvY3VtZW50LWxldmVsIHN0eWxpbmcgYXBpIGNhbiBiZSBmb3VuZCBpbiBgZXhhbXBsZXMvZG9jdW1lbnQtc3R5bGUtbGliLmpzYFxuXG5AdW5yZXN0cmljdGVkXG4qL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ3VzdG9tU3R5bGVJbnRlcmZhY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgeyFBcnJheTwhQ3VzdG9tU3R5bGVQcm92aWRlcj59ICovXG4gICAgdGhpc1snY3VzdG9tU3R5bGVzJ10gPSBbXTtcbiAgICB0aGlzWydlbnF1ZXVlZCddID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIFF1ZXVlIGEgdmFsaWRhdGlvbiBmb3IgbmV3IGN1c3RvbSBzdHlsZXMgdG8gYmF0Y2ggc3R5bGUgcmVjYWxjdWxhdGlvbnNcbiAgICovXG4gIGVucXVldWVEb2N1bWVudFZhbGlkYXRpb24oKSB7XG4gICAgaWYgKHRoaXNbJ2VucXVldWVkJ10gfHwgIXZhbGlkYXRlRm4pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpc1snZW5xdWV1ZWQnXSA9IHRydWU7XG4gICAgZG9jdW1lbnRXYWl0KHZhbGlkYXRlRm4pO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICAgKi9cbiAgYWRkQ3VzdG9tU3R5bGUoc3R5bGUpIHtcbiAgICBpZiAoIXN0eWxlW1NFRU5fTUFSS0VSXSkge1xuICAgICAgc3R5bGVbU0VFTl9NQVJLRVJdID0gdHJ1ZTtcbiAgICAgIHRoaXNbJ2N1c3RvbVN0eWxlcyddLnB1c2goc3R5bGUpO1xuICAgICAgdGhpcy5lbnF1ZXVlRG9jdW1lbnRWYWxpZGF0aW9uKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFDdXN0b21TdHlsZVByb3ZpZGVyfSBjdXN0b21TdHlsZVxuICAgKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fVxuICAgKi9cbiAgZ2V0U3R5bGVGb3JDdXN0b21TdHlsZShjdXN0b21TdHlsZSkge1xuICAgIGlmIChjdXN0b21TdHlsZVtDQUNIRURfU1RZTEVdKSB7XG4gICAgICByZXR1cm4gY3VzdG9tU3R5bGVbQ0FDSEVEX1NUWUxFXTtcbiAgICB9XG4gICAgbGV0IHN0eWxlO1xuICAgIGlmIChjdXN0b21TdHlsZVsnZ2V0U3R5bGUnXSkge1xuICAgICAgc3R5bGUgPSBjdXN0b21TdHlsZVsnZ2V0U3R5bGUnXSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZSA9IGN1c3RvbVN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cbiAgLyoqXG4gICAqIEByZXR1cm4geyFBcnJheTwhQ3VzdG9tU3R5bGVQcm92aWRlcj59XG4gICAqL1xuICBwcm9jZXNzU3R5bGVzKCkge1xuICAgIGNvbnN0IGNzID0gdGhpc1snY3VzdG9tU3R5bGVzJ107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY3VzdG9tU3R5bGUgPSBjc1tpXTtcbiAgICAgIGlmIChjdXN0b21TdHlsZVtDQUNIRURfU1RZTEVdKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3R5bGUgPSB0aGlzLmdldFN0eWxlRm9yQ3VzdG9tU3R5bGUoY3VzdG9tU3R5bGUpO1xuICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIC8vIEhUTUxJbXBvcnRzIHBvbHlmaWxsIG1heSBoYXZlIGNsb25lZCB0aGUgc3R5bGUgaW50byB0aGUgbWFpbiBkb2N1bWVudCxcbiAgICAgICAgLy8gd2hpY2ggaXMgcmVmZXJlbmNlZCB3aXRoIF9fYXBwbGllZEVsZW1lbnQuXG4gICAgICAgIGNvbnN0IHN0eWxlVG9UcmFuc2Zvcm0gPSAvKiogQHR5cGUgeyFIVE1MU3R5bGVFbGVtZW50fSAqLyhzdHlsZVsnX19hcHBsaWVkRWxlbWVudCddIHx8IHN0eWxlKTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybUZuKSB7XG4gICAgICAgICAgdHJhbnNmb3JtRm4oc3R5bGVUb1RyYW5zZm9ybSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VzdG9tU3R5bGVbQ0FDSEVEX1NUWUxFXSA9IHN0eWxlVG9UcmFuc2Zvcm07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjcztcbiAgfVxufVxuXG5DdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGVbJ2FkZEN1c3RvbVN0eWxlJ10gPSBDdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGUuYWRkQ3VzdG9tU3R5bGU7XG5DdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGVbJ2dldFN0eWxlRm9yQ3VzdG9tU3R5bGUnXSA9IEN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRTdHlsZUZvckN1c3RvbVN0eWxlO1xuQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlWydwcm9jZXNzU3R5bGVzJ10gPSBDdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGUucHJvY2Vzc1N0eWxlcztcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlLCB7XG4gICd0cmFuc2Zvcm1DYWxsYmFjayc6IHtcbiAgICAvKiogQHJldHVybiB7P2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KX0gKi9cbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtRm47XG4gICAgfSxcbiAgICAvKiogQHBhcmFtIHs/ZnVuY3Rpb24oIUhUTUxTdHlsZUVsZW1lbnQpfSBmbiAqL1xuICAgIHNldChmbikge1xuICAgICAgdHJhbnNmb3JtRm4gPSBmbjtcbiAgICB9XG4gIH0sXG4gICd2YWxpZGF0ZUNhbGxiYWNrJzoge1xuICAgIC8qKiBAcmV0dXJuIHs/ZnVuY3Rpb24oKX0gKi9cbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGVGbjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKCl9IGZuXG4gICAgICogQHRoaXMge0N1c3RvbVN0eWxlSW50ZXJmYWNlfVxuICAgICAqL1xuICAgIHNldChmbikge1xuICAgICAgbGV0IG5lZWRzRW5xdWV1ZSA9IGZhbHNlO1xuICAgICAgaWYgKCF2YWxpZGF0ZUZuKSB7XG4gICAgICAgIG5lZWRzRW5xdWV1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YWxpZGF0ZUZuID0gZm47XG4gICAgICBpZiAobmVlZHNFbnF1ZXVlKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZURvY3VtZW50VmFsaWRhdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG4gIH1cbn0pXG5cbi8qKiBAdHlwZWRlZiB7e1xuICogY3VzdG9tU3R5bGVzOiAhQXJyYXk8IUN1c3RvbVN0eWxlUHJvdmlkZXI+LFxuICogYWRkQ3VzdG9tU3R5bGU6IGZ1bmN0aW9uKCFDdXN0b21TdHlsZVByb3ZpZGVyKSxcbiAqIGdldFN0eWxlRm9yQ3VzdG9tU3R5bGU6IGZ1bmN0aW9uKCFDdXN0b21TdHlsZVByb3ZpZGVyKTogSFRNTFN0eWxlRWxlbWVudCxcbiAqIGZpbmRTdHlsZXM6IGZ1bmN0aW9uKCksXG4gKiB0cmFuc2Zvcm1DYWxsYmFjazogP2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KSxcbiAqIHZhbGlkYXRlQ2FsbGJhY2s6ID9mdW5jdGlvbigpXG4gKiB9fVxuICovXG5leHBvcnQgbGV0IEN1c3RvbVN0eWxlSW50ZXJmYWNlSW50ZXJmYWNlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IHJlc29sdmVDc3MgfSBmcm9tICcuL3Jlc29sdmUtdXJsLmpzJztcblxuY29uc3QgTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IgPSAnbGlua1tyZWw9aW1wb3J0XVt0eXBlfj1jc3NdJztcbmNvbnN0IElOQ0xVREVfQVRUUiA9ICdpbmNsdWRlJztcblxuZnVuY3Rpb24gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKSB7XG4gIGNvbnN0IC8qKiBQb2x5bWVyLkRvbU1vZHVsZSAqLyBQb2x5bWVyRG9tTW9kdWxlID0gY3VzdG9tRWxlbWVudHMuZ2V0KCdkb20tbW9kdWxlJyk7XG4gIGlmICghUG9seW1lckRvbU1vZHVsZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBQb2x5bWVyRG9tTW9kdWxlLmltcG9ydChtb2R1bGVJZCk7XG59XG5cbi8qKiBAdHlwZWRlZiB7e2Fzc2V0cGF0aDogc3RyaW5nfX0gKi9cbmxldCB0ZW1wbGF0ZVdpdGhBc3NldFBhdGg7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuZXhwb3J0IGZ1bmN0aW9uIGNzc0Zyb21Nb2R1bGVzKG1vZHVsZUlkcykge1xuICBsZXQgbW9kdWxlcyA9IG1vZHVsZUlkcy50cmltKCkuc3BsaXQoL1xccysvKTtcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgZm9yIChsZXQgaT0wOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNzc1RleHQgKz0gY3NzRnJvbU1vZHVsZShtb2R1bGVzW2ldKTtcbiAgfVxuICByZXR1cm4gY3NzVGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzc0Zyb21Nb2R1bGUobW9kdWxlSWQpIHtcbiAgbGV0IG0gPSBpbXBvcnRNb2R1bGUobW9kdWxlSWQpO1xuICBpZiAobSAmJiBtLl9jc3NUZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBtb2R1bGUgaW1wb3J0czogPGxpbmsgcmVsPVwiaW1wb3J0XCIgdHlwZT1cImNzc1wiPlxuICAgIGxldCBjc3NUZXh0ID0gX2Nzc0Zyb21Nb2R1bGVJbXBvcnRzKG0pO1xuICAgIC8vIGluY2x1ZGUgY3NzIGZyb20gdGhlIGZpcnN0IHRlbXBsYXRlIGluIHRoZSBtb2R1bGVcbiAgICBsZXQgdCA9IG0ucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAgICBpZiAodCkge1xuICAgICAgY3NzVGV4dCArPSBjc3NGcm9tVGVtcGxhdGUodCwgLyoqIEB0eXBlIHt0ZW1wbGF0ZVdpdGhBc3NldFBhdGh9ICovKG0pLmFzc2V0cGF0aCk7XG4gICAgfVxuICAgIG0uX2Nzc1RleHQgPSBjc3NUZXh0IHx8IG51bGw7XG4gIH1cbiAgaWYgKCFtKSB7XG4gICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBzdHlsZSBkYXRhIGluIG1vZHVsZSBuYW1lZCcsIG1vZHVsZUlkKTtcbiAgfVxuICByZXR1cm4gbSAmJiBtLl9jc3NUZXh0IHx8ICcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBiYXNlVVJJKSB7XG4gIGxldCBjc3NUZXh0ID0gJyc7XG4gIC8vIGlmIGVsZW1lbnQgaXMgYSB0ZW1wbGF0ZSwgZ2V0IGNvbnRlbnQgZnJvbSBpdHMgLmNvbnRlbnRcbiAgbGV0IGUkID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZScpO1xuICBmb3IgKGxldCBpPTA7IGkgPCBlJC5sZW5ndGg7IGkrKykge1xuICAgIGxldCBlID0gZSRbaV07XG4gICAgLy8gc3VwcG9ydCBzdHlsZSBzaGFyaW5nIGJ5IGFsbG93aW5nIHN0eWxlcyB0byBcImluY2x1ZGVcIlxuICAgIC8vIG90aGVyIGRvbS1tb2R1bGVzIHRoYXQgY29udGFpbiBzdHlsaW5nXG4gICAgbGV0IGluY2x1ZGUgPSBlLmdldEF0dHJpYnV0ZShJTkNMVURFX0FUVFIpO1xuICAgIGlmIChpbmNsdWRlKSB7XG4gICAgICBjc3NUZXh0ICs9IGNzc0Zyb21Nb2R1bGVzKGluY2x1ZGUpO1xuICAgIH1cbiAgICBlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZSk7XG4gICAgY3NzVGV4dCArPSBiYXNlVVJJID9cbiAgICAgIHJlc29sdmVDc3MoZS50ZXh0Q29udGVudCwgYmFzZVVSSSkgOiBlLnRleHRDb250ZW50O1xuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlSWQpIHtcbiAgbGV0IG0gPSBpbXBvcnRNb2R1bGUobW9kdWxlSWQpO1xuICByZXR1cm4gbSA/IF9jc3NGcm9tTW9kdWxlSW1wb3J0cyhtKSA6ICcnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2Nzc0Zyb21Nb2R1bGVJbXBvcnRzKG1vZHVsZSkge1xuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBsZXQgcCQgPSBtb2R1bGUucXVlcnlTZWxlY3RvckFsbChNT0RVTEVfU1RZTEVfTElOS19TRUxFQ1RPUik7XG4gIGZvciAobGV0IGk9MDsgaSA8IHAkLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHAgPSBwJFtpXTtcbiAgICBpZiAocC5pbXBvcnQpIHtcbiAgICAgIGxldCBpbXBvcnREb2MgPSBwLmltcG9ydDtcbiAgICAgIC8vIE5PVEU6IHBvbHlmaWxsIGFmZm9yZGFuY2UuXG4gICAgICAvLyB1bmRlciB0aGUgSFRNTEltcG9ydHMgcG9seWZpbGwsIHRoZXJlIHdpbGwgYmUgbm8gJ2JvZHknLFxuICAgICAgLy8gYnV0IHRoZSBpbXBvcnQgcHNldWRvLWRvYyBjYW4gYmUgdXNlZCBkaXJlY3RseS5cbiAgICAgIGxldCBjb250YWluZXIgPSBpbXBvcnREb2MuYm9keSA/IGltcG9ydERvYy5ib2R5IDogaW1wb3J0RG9jO1xuICAgICAgY3NzVGV4dCArPVxuICAgICAgICByZXNvbHZlQ3NzKGNvbnRhaW5lci50ZXh0Q29udGVudCxcbiAgICAgICAgICBpbXBvcnREb2MuYmFzZVVSSSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvc3R5bGUtZ2F0aGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCAqIGFzIGdlc3R1cmVzJDAgZnJvbSAnLi4vdXRpbHMvZ2VzdHVyZXMuanMnO1xuXG4vKipcbiAqIEBjb25zdCB7UG9seW1lci5HZXN0dXJlc31cbiAqL1xuY29uc3QgZ2VzdHVyZXMgPSBnZXN0dXJlcyQwO1xuXG5leHBvcnQgY29uc3QgR2VzdHVyZUV2ZW50TGlzdGVuZXJzID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICAgKi9cbiAgY2xhc3MgR2VzdHVyZUV2ZW50TGlzdGVuZXJzIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIGlmICghZ2VzdHVyZXMuYWRkTGlzdGVuZXIobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSkge1xuICAgICAgICBzdXBlci5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIWdlc3R1cmVzLnJlbW92ZUxpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikpIHtcbiAgICAgICAgc3VwZXIuX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEdlc3R1cmVFdmVudExpc3RlbmVycztcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvZ2VzdHVyZS1ldmVudC1saXN0ZW5lcnMuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcblxuZnVuY3Rpb24gbmV3U3BsaWNlKGluZGV4LCByZW1vdmVkLCBhZGRlZENvdW50KSB7XG4gIHJldHVybiB7XG4gICAgaW5kZXg6IGluZGV4LFxuICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgYWRkZWRDb3VudDogYWRkZWRDb3VudFxuICB9O1xufVxuXG5jb25zdCBFRElUX0xFQVZFID0gMDtcbmNvbnN0IEVESVRfVVBEQVRFID0gMTtcbmNvbnN0IEVESVRfQUREID0gMjtcbmNvbnN0IEVESVRfREVMRVRFID0gMztcblxuLy8gTm90ZTogVGhpcyBmdW5jdGlvbiBpcyAqYmFzZWQqIG9uIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgTGV2ZW5zaHRlaW5cbi8vIFwiZWRpdFwiIGRpc3RhbmNlLiBUaGUgb25lIGNoYW5nZSBpcyB0aGF0IFwidXBkYXRlc1wiIGFyZSB0cmVhdGVkIGFzIHR3b1xuLy8gZWRpdHMgLSBub3Qgb25lLiBXaXRoIEFycmF5IHNwbGljZXMsIGFuIHVwZGF0ZSBpcyByZWFsbHkgYSBkZWxldGVcbi8vIGZvbGxvd2VkIGJ5IGFuIGFkZC4gQnkgcmV0YWluaW5nIHRoaXMsIHdlIG9wdGltaXplIGZvciBcImtlZXBpbmdcIiB0aGVcbi8vIG1heGltdW0gYXJyYXkgaXRlbXMgaW4gdGhlIG9yaWdpbmFsIGFycmF5LiBGb3IgZXhhbXBsZTpcbi8vXG4vLyAgICd4eHh4MTIzJyAtPiAnMTIzeXl5eSdcbi8vXG4vLyBXaXRoIDEtZWRpdCB1cGRhdGVzLCB0aGUgc2hvcnRlc3QgcGF0aCB3b3VsZCBiZSBqdXN0IHRvIHVwZGF0ZSBhbGwgc2V2ZW5cbi8vIGNoYXJhY3RlcnMuIFdpdGggMi1lZGl0IHVwZGF0ZXMsIHdlIGRlbGV0ZSA0LCBsZWF2ZSAzLCBhbmQgYWRkIDQuIFRoaXNcbi8vIGxlYXZlcyB0aGUgc3Vic3RyaW5nICcxMjMnIGludGFjdC5cbmZ1bmN0aW9uIGNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgLy8gXCJEZWxldGlvblwiIGNvbHVtbnNcbiAgbGV0IHJvd0NvdW50ID0gb2xkRW5kIC0gb2xkU3RhcnQgKyAxO1xuICBsZXQgY29sdW1uQ291bnQgPSBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ICsgMTtcbiAgbGV0IGRpc3RhbmNlcyA9IG5ldyBBcnJheShyb3dDb3VudCk7XG5cbiAgLy8gXCJBZGRpdGlvblwiIHJvd3MuIEluaXRpYWxpemUgbnVsbCBjb2x1bW4uXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGRpc3RhbmNlc1tpXSA9IG5ldyBBcnJheShjb2x1bW5Db3VudCk7XG4gICAgZGlzdGFuY2VzW2ldWzBdID0gaTtcbiAgfVxuXG4gIC8vIEluaXRpYWxpemUgbnVsbCByb3dcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2x1bW5Db3VudDsgaisrKVxuICAgIGRpc3RhbmNlc1swXVtqXSA9IGo7XG5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgZm9yIChsZXQgaiA9IDE7IGogPCBjb2x1bW5Db3VudDsgaisrKSB7XG4gICAgICBpZiAoZXF1YWxzKGN1cnJlbnRbY3VycmVudFN0YXJ0ICsgaiAtIDFdLCBvbGRbb2xkU3RhcnQgKyBpIC0gMV0pKVxuICAgICAgICBkaXN0YW5jZXNbaV1bal0gPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBsZXQgbm9ydGggPSBkaXN0YW5jZXNbaSAtIDFdW2pdICsgMTtcbiAgICAgICAgbGV0IHdlc3QgPSBkaXN0YW5jZXNbaV1baiAtIDFdICsgMTtcbiAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gbm9ydGggPCB3ZXN0ID8gbm9ydGggOiB3ZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkaXN0YW5jZXM7XG59XG5cbi8vIFRoaXMgc3RhcnRzIGF0IHRoZSBmaW5hbCB3ZWlnaHQsIGFuZCB3YWxrcyBcImJhY2t3YXJkXCIgYnkgZmluZGluZ1xuLy8gdGhlIG1pbmltdW0gcHJldmlvdXMgd2VpZ2h0IHJlY3Vyc2l2ZWx5IHVudGlsIHRoZSBvcmlnaW4gb2YgdGhlIHdlaWdodFxuLy8gbWF0cml4LlxuZnVuY3Rpb24gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKGRpc3RhbmNlcykge1xuICBsZXQgaSA9IGRpc3RhbmNlcy5sZW5ndGggLSAxO1xuICBsZXQgaiA9IGRpc3RhbmNlc1swXS5sZW5ndGggLSAxO1xuICBsZXQgY3VycmVudCA9IGRpc3RhbmNlc1tpXVtqXTtcbiAgbGV0IGVkaXRzID0gW107XG4gIHdoaWxlIChpID4gMCB8fCBqID4gMCkge1xuICAgIGlmIChpID09IDApIHtcbiAgICAgIGVkaXRzLnB1c2goRURJVF9BREQpO1xuICAgICAgai0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChqID09IDApIHtcbiAgICAgIGVkaXRzLnB1c2goRURJVF9ERUxFVEUpO1xuICAgICAgaS0tO1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGxldCBub3J0aFdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2ogLSAxXTtcbiAgICBsZXQgd2VzdCA9IGRpc3RhbmNlc1tpIC0gMV1bal07XG4gICAgbGV0IG5vcnRoID0gZGlzdGFuY2VzW2ldW2ogLSAxXTtcblxuICAgIGxldCBtaW47XG4gICAgaWYgKHdlc3QgPCBub3J0aClcbiAgICAgIG1pbiA9IHdlc3QgPCBub3J0aFdlc3QgPyB3ZXN0IDogbm9ydGhXZXN0O1xuICAgIGVsc2VcbiAgICAgIG1pbiA9IG5vcnRoIDwgbm9ydGhXZXN0ID8gbm9ydGggOiBub3J0aFdlc3Q7XG5cbiAgICBpZiAobWluID09IG5vcnRoV2VzdCkge1xuICAgICAgaWYgKG5vcnRoV2VzdCA9PSBjdXJyZW50KSB7XG4gICAgICAgIGVkaXRzLnB1c2goRURJVF9MRUFWRSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfVVBEQVRFKTtcbiAgICAgICAgY3VycmVudCA9IG5vcnRoV2VzdDtcbiAgICAgIH1cbiAgICAgIGktLTtcbiAgICAgIGotLTtcbiAgICB9IGVsc2UgaWYgKG1pbiA9PSB3ZXN0KSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgIGktLTtcbiAgICAgIGN1cnJlbnQgPSB3ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgIGotLTtcbiAgICAgIGN1cnJlbnQgPSBub3J0aDtcbiAgICB9XG4gIH1cblxuICBlZGl0cy5yZXZlcnNlKCk7XG4gIHJldHVybiBlZGl0cztcbn1cblxuLyoqXG4gKiBTcGxpY2UgUHJvamVjdGlvbiBmdW5jdGlvbnM6XG4gKlxuICogQSBzcGxpY2UgbWFwIGlzIGEgcmVwcmVzZW50YXRpb24gb2YgaG93IGEgcHJldmlvdXMgYXJyYXkgb2YgaXRlbXNcbiAqIHdhcyB0cmFuc2Zvcm1lZCBpbnRvIGEgbmV3IGFycmF5IG9mIGl0ZW1zLiBDb25jZXB0dWFsbHkgaXQgaXMgYSBsaXN0IG9mXG4gKiB0dXBsZXMgb2ZcbiAqXG4gKiAgIDxpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudD5cbiAqXG4gKiB3aGljaCBhcmUga2VwdCBpbiBhc2NlbmRpbmcgaW5kZXggb3JkZXIgb2YuIFRoZSB0dXBsZSByZXByZXNlbnRzIHRoYXQgYXRcbiAqIHRoZSB8aW5kZXh8LCB8cmVtb3ZlZHwgc2VxdWVuY2Ugb2YgaXRlbXMgd2VyZSByZW1vdmVkLCBhbmQgY291bnRpbmcgZm9yd2FyZFxuICogZnJvbSB8aW5kZXh8LCB8YWRkZWRDb3VudHwgaXRlbXMgd2VyZSBhZGRlZC5cbiAqL1xuXG4vKipcbiAqIExhY2tpbmcgaW5kaXZpZHVhbCBzcGxpY2UgbXV0YXRpb24gaW5mb3JtYXRpb24sIHRoZSBtaW5pbWFsIHNldCBvZlxuICogc3BsaWNlcyBjYW4gYmUgc3ludGhlc2l6ZWQgZ2l2ZW4gdGhlIHByZXZpb3VzIHN0YXRlIGFuZCBmaW5hbCBzdGF0ZSBvZiBhblxuICogYXJyYXkuIFRoZSBiYXNpYyBhcHByb2FjaCBpcyB0byBjYWxjdWxhdGUgdGhlIGVkaXQgZGlzdGFuY2UgbWF0cml4IGFuZFxuICogY2hvb3NlIHRoZSBzaG9ydGVzdCBwYXRoIHRocm91Z2ggaXQuXG4gKlxuICogQ29tcGxleGl0eTogTyhsICogcClcbiAqICAgbDogVGhlIGxlbmd0aCBvZiB0aGUgY3VycmVudCBhcnJheVxuICogICBwOiBUaGUgbGVuZ3RoIG9mIHRoZSBvbGQgYXJyYXlcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBjdXJyZW50IFRoZSBjdXJyZW50IFwiY2hhbmdlZFwiIGFycmF5IGZvciB3aGljaCB0b1xuICogY2FsY3VsYXRlIHNwbGljZXMuXG4gKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFN0YXJ0IFN0YXJ0aW5nIGluZGV4IGluIHRoZSBgY3VycmVudGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRFbmQgRW5kaW5nIGluZGV4IGluIHRoZSBgY3VycmVudGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHtBcnJheX0gb2xkIFRoZSBvcmlnaW5hbCBcInVuY2hhbmdlZFwiIGFycmF5IHRvIGNvbXBhcmUgYGN1cnJlbnRgXG4gKiBhZ2FpbnN0IHRvIGRldGVybWluZSBzcGxpY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9sZFN0YXJ0IFN0YXJ0aW5nIGluZGV4IGluIHRoZSBgb2xkYCBhcnJheSBmb3JcbiAqIHdoaWNoIHNwbGljZXMgYXJlIGNhbGN1bGF0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gb2xkRW5kIEVuZGluZyBpbmRleCBpbiB0aGUgYG9sZGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHJldHVybiB7QXJyYXl9IFJldHVybnMgYW4gYXJyYXkgb2Ygc3BsaWNlIHJlY29yZCBvYmplY3RzLiBFYWNoIG9mIHRoZXNlXG4gKiBjb250YWluczogYGluZGV4YCB0aGUgbG9jYXRpb24gd2hlcmUgdGhlIHNwbGljZSBvY2N1cnJlZDsgYHJlbW92ZWRgXG4gKiB0aGUgYXJyYXkgb2YgcmVtb3ZlZCBpdGVtcyBmcm9tIHRoaXMgbG9jYXRpb247IGBhZGRlZENvdW50YCB0aGUgbnVtYmVyXG4gKiBvZiBpdGVtcyBhZGRlZCBhdCB0aGlzIGxvY2F0aW9uLlxuICovXG5mdW5jdGlvbiBjYWxjU3BsaWNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gIGxldCBwcmVmaXhDb3VudCA9IDA7XG4gIGxldCBzdWZmaXhDb3VudCA9IDA7XG4gIGxldCBzcGxpY2U7XG5cbiAgbGV0IG1pbkxlbmd0aCA9IE1hdGgubWluKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQsIG9sZEVuZCAtIG9sZFN0YXJ0KTtcbiAgaWYgKGN1cnJlbnRTdGFydCA9PSAwICYmIG9sZFN0YXJ0ID09IDApXG4gICAgcHJlZml4Q291bnQgPSBzaGFyZWRQcmVmaXgoY3VycmVudCwgb2xkLCBtaW5MZW5ndGgpO1xuXG4gIGlmIChjdXJyZW50RW5kID09IGN1cnJlbnQubGVuZ3RoICYmIG9sZEVuZCA9PSBvbGQubGVuZ3RoKVxuICAgIHN1ZmZpeENvdW50ID0gc2hhcmVkU3VmZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoIC0gcHJlZml4Q291bnQpO1xuXG4gIGN1cnJlbnRTdGFydCArPSBwcmVmaXhDb3VudDtcbiAgb2xkU3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gIGN1cnJlbnRFbmQgLT0gc3VmZml4Q291bnQ7XG4gIG9sZEVuZCAtPSBzdWZmaXhDb3VudDtcblxuICBpZiAoY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCA9PSAwICYmIG9sZEVuZCAtIG9sZFN0YXJ0ID09IDApXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmIChjdXJyZW50U3RhcnQgPT0gY3VycmVudEVuZCkge1xuICAgIHNwbGljZSA9IG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCAwKTtcbiAgICB3aGlsZSAob2xkU3RhcnQgPCBvbGRFbmQpXG4gICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRTdGFydCsrXSk7XG5cbiAgICByZXR1cm4gWyBzcGxpY2UgXTtcbiAgfSBlbHNlIGlmIChvbGRTdGFydCA9PSBvbGRFbmQpXG4gICAgcmV0dXJuIFsgbmV3U3BsaWNlKGN1cnJlbnRTdGFydCwgW10sIGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQpIF07XG5cbiAgbGV0IG9wcyA9IHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhcbiAgICAgIGNhbGNFZGl0RGlzdGFuY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSk7XG5cbiAgc3BsaWNlID0gdW5kZWZpbmVkO1xuICBsZXQgc3BsaWNlcyA9IFtdO1xuICBsZXQgaW5kZXggPSBjdXJyZW50U3RhcnQ7XG4gIGxldCBvbGRJbmRleCA9IG9sZFN0YXJ0O1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG9wcy5sZW5ndGg7IGkrKykge1xuICAgIHN3aXRjaChvcHNbaV0pIHtcbiAgICAgIGNhc2UgRURJVF9MRUFWRTpcbiAgICAgICAgaWYgKHNwbGljZSkge1xuICAgICAgICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICAgICAgICAgIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFRElUX1VQREFURTpcbiAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgc3BsaWNlLmFkZGVkQ291bnQrKztcbiAgICAgICAgaW5kZXgrKztcblxuICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRURJVF9BREQ6XG4gICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFRElUX0RFTEVURTpcbiAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNwbGljZSkge1xuICAgIHNwbGljZXMucHVzaChzcGxpY2UpO1xuICB9XG4gIHJldHVybiBzcGxpY2VzO1xufVxuXG5mdW5jdGlvbiBzaGFyZWRQcmVmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWFyY2hMZW5ndGg7IGkrKylcbiAgICBpZiAoIWVxdWFscyhjdXJyZW50W2ldLCBvbGRbaV0pKVxuICAgICAgcmV0dXJuIGk7XG4gIHJldHVybiBzZWFyY2hMZW5ndGg7XG59XG5cbmZ1bmN0aW9uIHNoYXJlZFN1ZmZpeChjdXJyZW50LCBvbGQsIHNlYXJjaExlbmd0aCkge1xuICBsZXQgaW5kZXgxID0gY3VycmVudC5sZW5ndGg7XG4gIGxldCBpbmRleDIgPSBvbGQubGVuZ3RoO1xuICBsZXQgY291bnQgPSAwO1xuICB3aGlsZSAoY291bnQgPCBzZWFyY2hMZW5ndGggJiYgZXF1YWxzKGN1cnJlbnRbLS1pbmRleDFdLCBvbGRbLS1pbmRleDJdKSlcbiAgICBjb3VudCsrO1xuXG4gIHJldHVybiBjb3VudDtcbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlU3BsaWNlcyhjdXJyZW50LCBwcmV2aW91cykge1xuICByZXR1cm4gY2FsY1NwbGljZXMoY3VycmVudCwgMCwgY3VycmVudC5sZW5ndGgsIHByZXZpb3VzLCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91cy5sZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBlcXVhbHMoY3VycmVudFZhbHVlLCBwcmV2aW91c1ZhbHVlKSB7XG4gIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHByZXZpb3VzVmFsdWU7XG59XG5cbmV4cG9ydCB7IGNhbGN1bGF0ZVNwbGljZXMgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2FycmF5LXNwbGljZS5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgRWxlbWVudCBhcyBQb2x5bWVyRWxlbWVudCB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50JztcbmltcG9ydCB7aHRtbCwgcmVuZGVyfSBmcm9tICdsaXQtaHRtbCc7XG5pbXBvcnQgeyBhamF4R2V0LCBhamF4UG9zdCwgYWpheFB1dCwgYWpheERlbGV0ZSB9IGZyb20gXCIuL2FqYXguanNcIjtcbmltcG9ydCBcIkBwb2x5bWVyL3BhcGVyLWRpYWxvZy9wYXBlci1kaWFsb2dcIjtcbmltcG9ydCBcIkBwb2x5bWVyL3BhcGVyLWJ1dHRvbi9wYXBlci1idXR0b25cIjtcbmltcG9ydCBcIkBwb2x5bWVyL2lyb24taWNvbi9pcm9uLWljb25cIjtcbmltcG9ydCBcIkBwb2x5bWVyL3BhcGVyLWljb24tYnV0dG9uL3BhcGVyLWljb24tYnV0dG9uXCI7XG5pbXBvcnQgXCJAcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dFwiO1xuaW1wb3J0IFwiQHBvbHltZXIvcGFwZXItY2hlY2tib3gvcGFwZXItY2hlY2tib3hcIjtcbmltcG9ydCBcIkBwb2x5bWVyL2lyb24taWNvbnMvaXJvbi1pY29uc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWN0aWxlRWRpdGFibGUgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgaXMoKSB7XG4gICAgcmV0dXJuIFwidGFjdGlsZS1lZGl0YWJsZVwiO1xuICB9XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBwYXRoOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIH0sXG4gICAgICBjb21wVHlwZToge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB9LFxuICAgICAgaW5saW5lOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogXCJvcGVuXCJ9KTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGFqYXhHZXQodGhpcy5wYXRoK1wiLmpzb25cIiwgKGNvbXBvbmVudCkgPT4ge1xuICAgICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gICAgICB2YXIgdGFjdGlsZU1vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGFjdGlsZS1tb2RlXCIpO1xuICAgICAgdGhpcy5lZGl0TW9kZSA9IHRhY3RpbGVNb2RlLm1vZGU7XG4gICAgICB0aGlzLnJlbmRlcigpO1xuXG4gICAgICB0YWN0aWxlTW9kZS5hZGRFdmVudExpc3RlbmVyKFwic3dpdGNoZWQtdG8tZWRpdFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZWRpdE1vZGUgPSB0cnVlO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgfSk7XG4gICAgICB0YWN0aWxlTW9kZS5hZGRFdmVudExpc3RlbmVyKFwic3dpdGNoZWQtdG8tcHVibGlzaFwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZWRpdE1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHZhciBlZGl0Q29udGVudCA9IGBgO1xuICAgIHZhciBibG9ja0NvbnRlbnQgPSBgYDtcbiAgICB2YXIgb3RoZXJDb250ZW50ID0gYGA7XG5cbiAgICBpZiAodGhpcy5lZGl0TW9kZSkge1xuICAgICAgZWRpdENvbnRlbnQgPSBodG1sYFxuICAgICAgPHBhcGVyLWRpYWxvZyBtb2RhbCBzdHlsZT1cIm1pbi13aWR0aDogNjAwcHg7XCI+XG4gICAgICAgICR7dGhpcy5fY3JlYXRlTWVzc2FnZSgpfVxuICAgICAgICAke3RoaXMuX2NyZWF0ZUlucHV0cygpfVxuICAgICAgICAke3RoaXMuX2NyZWF0ZUJ1dHRvbnMoKX1cbiAgICAgIDwvcGFwZXItZGlhbG9nPlxuICAgICAgJHt0aGlzLl9lZGl0U3R5bGVzKCl9XG4gICAgICBgO1xuICAgIH1cblxuICAgIGlmICghIHRoaXMuaW5saW5lICYmIHRoaXMuZWRpdE1vZGUpIHtcbiAgICAgIGJsb2NrQ29udGVudCA9IGh0bWxgXG4gICAgICA8c3BhbiBjbGFzcz1cImlubGluZS1idXR0b25zXCI+XG4gICAgICAgICR7dGhpcy5jb21wb25lbnQuYXV0aG9yLnRpdGxlfVxuICAgICAgICAke3RoaXMuX2NyZWF0ZUNvbmZpZ3VyZWFibGVCdXR0b25zKCl9XG4gICAgICA8L3NwYW4+XG4gICAgICA8ZGl2IHN0eWxlPVwicG9zaXRpb246IHJlbGF0aXZlO1wiPlxuICAgICAgICA8cGFwZXItcmlwcGxlPjwvcGFwZXItcmlwcGxlPlxuICAgICAgICA8c2xvdD48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cbiAgICAgICR7dGhpcy5fYmxvY2tTdHlsZXMoKX1cbiAgICAgIGA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG90aGVyQ29udGVudCA9IGh0bWxgPHNsb3Q+PC9zbG90PmA7XG4gICAgfVxuXG4gICAgcmVuZGVyKGh0bWxgXG4gICAgJHtlZGl0Q29udGVudH1cbiAgICAke2Jsb2NrQ29udGVudH1cbiAgICAke290aGVyQ29udGVudH1cbiAgICBgLCB0aGlzLnNoYWRvd1Jvb3QpO1xuXG4gICAgdGhpcy5fYXR0YWNoSW5saW5lRXZlbnRIYW5kbGVycygpO1xuICB9XG5cbiAgb3BlbkRpYWxvZyhjYWxsYmFjaykge1xuICAgIHZhciBwYXBlckRpYWxvZyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwicGFwZXItZGlhbG9nXCIpXG4gICAgcGFwZXJEaWFsb2cub3BlbigpO1xuICAgIHRoaXMuX2F0dGFjaENsb3NlZEhhbmRsZXJzKGNhbGxiYWNrKTtcbiAgICB0aGlzLl9hdHRhY2hEaWFsb2dCdXR0b25IYW5kbGVycyhjYWxsYmFjayk7XG4gIH1cblxuICBmb3JtVmFsdWVzKCkge1xuICAgIHZhciB2YWx1ZXMgPSB7fTtcbiAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbChcInBhcGVyLWlucHV0XCIpLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0LnZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHZhbHVlc1tpbnB1dC5uYW1lXSA9IGlucHV0LnZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzW2lucHV0Lm5hbWVdID0gXCJcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbChcInBhcGVyLWNoZWNrYm94XCIpLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGlucHV0LnZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGlucHV0LmFjdGl2ZSk7XG4gICAgICAgIHZhbHVlc1tpbnB1dC5uYW1lXSA9IGlucHV0LmFjdGl2ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc1tpbnB1dC5uYW1lXSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH1cblxuICBfYmxvY2tTdHlsZXMoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICAgIGA7XG4gIH1cblxuICBfZWRpdFN0eWxlcygpIHtcbiAgICByZXR1cm4gaHRtbGBcbiAgICA8c3R5bGU+XG4gICAgICAgIDpob3N0IHtcbiAgICAgICAgICBtYXJnaW46IC0ycHg7XG4gICAgICAgICAgYm9yZGVyOiAycHggc29saWQgcmdiYSgwLDAsMCwwKTtcbiAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgOmhvc3QoOmhvdmVyKSB7XG4gICAgICAgICAgYm9yZGVyOiAycHggc29saWQgI2RkZDtcbiAgICAgICAgfVxuICAgICAgICAuaW5saW5lLWJ1dHRvbnMge1xuICAgICAgICAgIGN1cnNvcjogYXV0bztcbiAgICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjZGRkO1xuICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgICB6LWluZGV4OiAxO1xuICAgICAgICAgIHRyYW5zaXRpb246IHZpc2liaWxpdHkgMHMsIG9wYWNpdHkgMC4ycyBsaW5lYXI7XG4gICAgICAgICAgY29sb3I6ICM1NTU7XG4gICAgICAgICAgcGFkZGluZzogN3B4O1xuICAgICAgICAgIGJveC1zaGFkb3c6IDAgMXB4IDNweCByZ2JhKDAsMCwwLDAuMTIpLCAwIDFweCAycHggcmdiYSgwLDAsMCwwLjI0KTtcbiAgICAgICAgfVxuICAgICAgICAuaW5saW5lLWJ1dHRvbnMgcGFwZXItaWNvbi1idXR0b24ge1xuICAgICAgICAgIGJvcmRlci1yYWRpdXM6IDEwMCU7XG4gICAgICAgIH1cbiAgICAgICAgLnRhY3RpbGUtaW5saW5lLWJ1dHRvbiB7XG4gICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgIHBhZGRpbmctdG9wOiA1cHg7XG4gICAgICAgIH1cbiAgICAgICAgLnRhY3RpbGUtaW5saW5lLWJ1dHRvbjpob3ZlciB7XG4gICAgICAgICAgY29sb3I6ICMxMTE7XG4gICAgICAgIH1cbiAgICAgIDwvc3R5bGU+XG4gICAgYDtcbiAgfVxuXG4gIF9hdHRhY2hDbG9zZWRIYW5kbGVycyhjYWxsYmFjaykge1xuICAgIHZhciBwYXBlckRpYWxvZyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwicGFwZXItZGlhbG9nXCIpXG5cbiAgICB2YXIgZGlhbG9nQ2xvc2VkID0gKGV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQuZGV0YWlsLmNvbmZpcm1lZCkge1xuICAgICAgICBhamF4UG9zdCh0aGlzLnBhdGgsIHRoaXMuZm9ybVZhbHVlcygpKTtcbiAgICAgIH1cbiAgICAgIHBhcGVyRGlhbG9nLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJpcm9uLW92ZXJsYXktY2xvc2VkXCIsIGRpYWxvZ0Nsb3NlZCk7XG4gICAgICBjYWxsYmFjayhldmVudC5kZXRhaWwuY29uZmlybWVkKTtcbiAgICB9XG5cbiAgICBwYXBlckRpYWxvZy5hZGRFdmVudExpc3RlbmVyKFwiaXJvbi1vdmVybGF5LWNsb3NlZFwiLCBkaWFsb2dDbG9zZWQpO1xuICB9XG5cbiAgX2F0dGFjaERpYWxvZ0J1dHRvbkhhbmRsZXJzKGNhbGxiYWNrKSB7XG4gICAgQXJyYXkuZnJvbSh0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvckFsbChcInBhcGVyLWJ1dHRvbi50YWN0aWxlLWRlbGV0ZVwiKSkuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICBhamF4RGVsZXRlKHRoaXMucGF0aCwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBfYXR0YWNoSW5saW5lRXZlbnRIYW5kbGVycygpIHtcbiAgICB2YXIgYWRkQnV0dG9uID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIudGFjdGlsZS1hZGRcIik7XG4gICAgaWYgKGFkZEJ1dHRvbikge1xuICAgICAgYWRkQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCtcIi9cIitlLnRhcmdldC5kYXRhc2V0LnBhdGg7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IEpTT04ucGFyc2UoZS50YXJnZXQuZGF0YXNldC50ZW1wbGF0ZSk7XG4gICAgICAgIGFqYXhQdXQocGF0aCwgdGVtcGxhdGUpO1xuICAgICAgICAvLyBUT0RPIGp1c3QgcmVpbml0aWFsaXplIHRoZSBjb21wb25lbnQgdXNpbmcgdGhlIGhhbmRsZWJhcnMgdGVtcGxhdGUuXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBpbmxpbmVCdXR0b25zID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCIuaW5saW5lLWJ1dHRvbnNcIik7XG5cbiAgICBpZiAoaW5saW5lQnV0dG9ucykge1xuICAgICAgaW5saW5lQnV0dG9ucy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIGlubGluZUJ1dHRvbnMuc3R5bGUub3BhY2l0eSA9IFwiMFwiO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgIGlubGluZUJ1dHRvbnMuc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgICAgICBpbmxpbmVCdXR0b25zLnN0eWxlLm9wYWNpdHkgPSBcIjFcIjtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsICgpID0+IHtcbiAgICAgICAgaW5saW5lQnV0dG9ucy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgICAgaW5saW5lQnV0dG9ucy5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBfY3JlYXRlSW5wdXRzKCkge1xuICAgIHZhciBpbnB1dHMgPSBbIF07XG4gICAgdGhpcy5jb21wb25lbnQuYXV0aG9yLmF0dHJzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpZiAoaW5wdXQudHlwZSA9PT0gXCJTdHJpbmdcIikge1xuICAgICAgICBpbnB1dHMucHVzaChcbiAgICAgICAgICBodG1sYDxwYXBlci1pbnB1dFxuICAgICAgICAgICAgICAgIG5hbWU9JHtpbnB1dC5uYW1lfVxuICAgICAgICAgICAgICAgIGxhYmVsPSR7aW5wdXQudGl0bGV9XG4gICAgICAgICAgICAgICAgdmFsdWU9JHt0aGlzLmNvbXBvbmVudFtpbnB1dC5uYW1lXX0+PC9wYXBlci1pbnB1dD5gKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQudHlwZSA9PT0gXCJCb29sZWFuXCIpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50W2lucHV0Lm5hbWVdKSB7XG4gICAgICAgICAgaW5wdXRzLnB1c2goaHRtbGA8cGFwZXItY2hlY2tib3ggbmFtZT0ke2lucHV0Lm5hbWV9IGNoZWNrZWQ+JHtpbnB1dC50aXRsZX08L3BhcGVyLWNoZWNrYm94PmApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlucHV0cy5wdXNoKGh0bWxgPHBhcGVyLWNoZWNrYm94IG5hbWU9JHtpbnB1dC5uYW1lfT4ke2lucHV0LnRpdGxlfTwvcGFwZXItY2hlY2tib3g+YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaW5wdXRzO1xuICB9XG5cbiAgX2NyZWF0ZU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIGh0bWxgXG4gICAgICA8aDI+JHt0aGlzLmNvbXBvbmVudC5hdXRob3IudGl0bGV9PC9oMj5cbiAgICAgIDxwPiR7dGhpcy5jb21wb25lbnQuYXV0aG9yLmRlc2NyaXB0aW9ufTwvcD5gO1xuICB9XG5cbiAgX2NyZWF0ZUNvbmZpZ3VyZWFibGVCdXR0b25zKCkge1xuICAgIHZhciBidXR0b25zID0gWyBdO1xuICAgIHRoaXMuY29tcG9uZW50LmF1dGhvci5hdHRycy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKGlucHV0LnR5cGUgPT09IFwiQWRkXCIpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IGh0bWxgPGRpdlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidGFjdGlsZS1pbmxpbmUtYnV0dG9uIHRhY3RpbGUtYWRkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXBhdGg9JHtpbnB1dC5wYXRofVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtdGVtcGxhdGU9JHtKU09OLnN0cmluZ2lmeShpbnB1dC50ZW1wbGF0ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1jb21wLXR5cGU9JHtpbnB1dC5jb21wVHlwZX0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJHtpbnB1dC50aXRsZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+YDtcblxuICAgICAgICBidXR0b25zLnB1c2goYnV0dG9uKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYnV0dG9ucztcbiAgfVxuXG4gIF9jcmVhdGVCdXR0b25zKCkge1xuICAgIHZhciBleHRyYUJ1dHRvbnMgPSBbIF07XG5cbiAgICBpZiAoISB0aGlzLmNvbXBvbmVudC5hdXRob3IucHJldmVudERlbGV0ZSAmJiAhIHRoaXMuY29tcG9uZW50LnByZXZlbnREZWxldGUpIHtcbiAgICAgIHZhciBkZWxldGVCdXR0b24gPSBodG1sYFxuICAgICAgICA8cGFwZXItYnV0dG9uIGNsYXNzPVwidGFjdGlsZS1kZWxldGVcIiBkYXRhLXBhdGg9JHt0aGlzLnBhdGh9PkRlbGV0ZTwvcGFwZXItYnV0dG9uPlxuICAgICAgYDtcbiAgICB9XG5cbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxkaXYgY2xhc3M9XCJidXR0b25zXCI+XG4gICAgICAgICR7ZXh0cmFCdXR0b25zfVxuICAgICAgICAke2RlbGV0ZUJ1dHRvbn1cbiAgICAgICAgPHBhcGVyLWJ1dHRvbiBkaWFsb2ctZGlzbWlzcz5EZWNsaW5lPC9wYXBlci1idXR0b24+XG4gICAgICAgIDxwYXBlci1idXR0b24gZGlhbG9nLWNvbmZpcm0gYXV0b2ZvY3VzPkFjY2VwdDwvcGFwZXItYnV0dG9uPlxuICAgICAgPC9kaXY+YDtcbiAgfVxufVxuXG4vLyBSZWdpc3RlciBjdXN0b20gZWxlbWVudCBjbGFzcyB3aXRoIGJyb3dzZXJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZShUYWN0aWxlRWRpdGFibGUuaXMsIFRhY3RpbGVFZGl0YWJsZSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi90YWN0aWxlL2NsaWVudC90YWN0aWxlLWVkaXRhYmxlLmpzIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuLyoqXG4gKiBUeXBlU2NyaXB0IGhhcyBhIHByb2JsZW0gd2l0aCBwcmVjb21waWxpbmcgdGVtcGxhdGVzIGxpdGVyYWxzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vTWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzE3OTU2XG4gKlxuICogVE9ETyhqdXN0aW5mYWduYW5pKTogUnVuIHRlc3RzIGNvbXBpbGVkIHRvIEVTNSB3aXRoIGJvdGggQmFiZWwgYW5kXG4gKiBUeXBlU2NyaXB0IHRvIHZlcmlmeSBjb3JyZWN0bmVzcy5cbiAqL1xuY29uc3QgZW52Q2FjaGVzVGVtcGxhdGVzID0gKCh0KSA9PiB0KCkgPT09IHQoKSkoKCkgPT4gKChzKSA9PiBzKSBgYCk7XG4vLyBUaGUgZmlyc3QgYXJndW1lbnQgdG8gSlMgdGVtcGxhdGUgdGFncyByZXRhaW4gaWRlbnRpdHkgYWNyb3NzIG11bHRpcGxlXG4vLyBjYWxscyB0byBhIHRhZyBmb3IgdGhlIHNhbWUgbGl0ZXJhbCwgc28gd2UgY2FuIGNhY2hlIHdvcmsgZG9uZSBwZXIgbGl0ZXJhbFxuLy8gaW4gYSBNYXAuXG5jb25zdCB0ZW1wbGF0ZXMgPSBuZXcgTWFwKCk7XG5jb25zdCBzdmdUZW1wbGF0ZXMgPSBuZXcgTWFwKCk7XG4vKipcbiAqIEludGVycHJldHMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIGFuIEhUTUwgdGVtcGxhdGUgdGhhdCBjYW4gZWZmaWNpZW50bHlcbiAqIHJlbmRlciB0byBhbmQgdXBkYXRlIGEgY29udGFpbmVyLlxuICovXG5leHBvcnQgY29uc3QgaHRtbCA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+IGxpdFRhZyhzdHJpbmdzLCB2YWx1ZXMsIHRlbXBsYXRlcywgZmFsc2UpO1xuLyoqXG4gKiBJbnRlcnByZXRzIGEgdGVtcGxhdGUgbGl0ZXJhbCBhcyBhbiBTVkcgdGVtcGxhdGUgdGhhdCBjYW4gZWZmaWNpZW50bHlcbiAqIHJlbmRlciB0byBhbmQgdXBkYXRlIGEgY29udGFpbmVyLlxuICovXG5leHBvcnQgY29uc3Qgc3ZnID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4gbGl0VGFnKHN0cmluZ3MsIHZhbHVlcywgc3ZnVGVtcGxhdGVzLCB0cnVlKTtcbmZ1bmN0aW9uIGxpdFRhZyhzdHJpbmdzLCB2YWx1ZXMsIHRlbXBsYXRlcywgaXNTdmcpIHtcbiAgICBjb25zdCBrZXkgPSBlbnZDYWNoZXNUZW1wbGF0ZXMgP1xuICAgICAgICBzdHJpbmdzIDpcbiAgICAgICAgc3RyaW5ncy5qb2luKCd7ey0tdW5pcXVlbmVzcy13b3JrYXJvdW5kLS19fScpO1xuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlcy5nZXQoa2V5KTtcbiAgICBpZiAodGVtcGxhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0ZW1wbGF0ZSA9IG5ldyBUZW1wbGF0ZShzdHJpbmdzLCBpc1N2Zyk7XG4gICAgICAgIHRlbXBsYXRlcy5zZXQoa2V5LCB0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVGVtcGxhdGVSZXN1bHQodGVtcGxhdGUsIHZhbHVlcyk7XG59XG4vKipcbiAqIFRoZSByZXR1cm4gdHlwZSBvZiBgaHRtbGAsIHdoaWNoIGhvbGRzIGEgVGVtcGxhdGUgYW5kIHRoZSB2YWx1ZXMgZnJvbVxuICogaW50ZXJwb2xhdGVkIGV4cHJlc3Npb25zLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVSZXN1bHQge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLnZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG59XG4vKipcbiAqIFJlbmRlcnMgYSB0ZW1wbGF0ZSB0byBhIGNvbnRhaW5lci5cbiAqXG4gKiBUbyB1cGRhdGUgYSBjb250YWluZXIgd2l0aCBuZXcgdmFsdWVzLCByZWV2YWx1YXRlIHRoZSB0ZW1wbGF0ZSBsaXRlcmFsIGFuZFxuICogY2FsbCBgcmVuZGVyYCB3aXRoIHRoZSBuZXcgcmVzdWx0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVuZGVyKHJlc3VsdCwgY29udGFpbmVyLCBwYXJ0Q2FsbGJhY2sgPSBkZWZhdWx0UGFydENhbGxiYWNrKSB7XG4gICAgbGV0IGluc3RhbmNlID0gY29udGFpbmVyLl9fdGVtcGxhdGVJbnN0YW5jZTtcbiAgICAvLyBSZXBlYXQgcmVuZGVyLCBqdXN0IGNhbGwgdXBkYXRlKClcbiAgICBpZiAoaW5zdGFuY2UgIT09IHVuZGVmaW5lZCAmJiBpbnN0YW5jZS50ZW1wbGF0ZSA9PT0gcmVzdWx0LnRlbXBsYXRlICYmXG4gICAgICAgIGluc3RhbmNlLl9wYXJ0Q2FsbGJhY2sgPT09IHBhcnRDYWxsYmFjaykge1xuICAgICAgICBpbnN0YW5jZS51cGRhdGUocmVzdWx0LnZhbHVlcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gRmlyc3QgcmVuZGVyLCBjcmVhdGUgYSBuZXcgVGVtcGxhdGVJbnN0YW5jZSBhbmQgYXBwZW5kIGl0XG4gICAgaW5zdGFuY2UgPSBuZXcgVGVtcGxhdGVJbnN0YW5jZShyZXN1bHQudGVtcGxhdGUsIHBhcnRDYWxsYmFjayk7XG4gICAgY29udGFpbmVyLl9fdGVtcGxhdGVJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGNvbnN0IGZyYWdtZW50ID0gaW5zdGFuY2UuX2Nsb25lKCk7XG4gICAgaW5zdGFuY2UudXBkYXRlKHJlc3VsdC52YWx1ZXMpO1xuICAgIGxldCBjaGlsZDtcbiAgICB3aGlsZSAoKGNoaWxkID0gY29udGFpbmVyLmxhc3RDaGlsZCkpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbn1cbi8qKlxuICogQW4gZXhwcmVzc2lvbiBtYXJrZXIgd2l0aCBlbWJlZGRlZCB1bmlxdWUga2V5IHRvIGF2b2lkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lckxhYnMvbGl0LWh0bWwvaXNzdWVzLzYyXG4gKi9cbmNvbnN0IGF0dHJpYnV0ZU1hcmtlciA9IGB7e2xpdC0ke01hdGgucmFuZG9tKCl9fX1gO1xuLyoqXG4gKiBSZWdleCB0byBzY2FuIHRoZSBzdHJpbmcgcHJlY2VkaW5nIGFuIGV4cHJlc3Npb24gdG8gc2VlIGlmIHdlJ3JlIGluIGEgdGV4dFxuICogY29udGV4dCwgYW5kIG5vdCBhbiBhdHRyaWJ1dGUgY29udGV4dC5cbiAqXG4gKiBUaGlzIHdvcmtzIGJ5IHNlZWluZyBpZiB3ZSBoYXZlIGEgYD5gIG5vdCBmb2xsb3dlZCBieSBhIGA8YC4gSWYgdGhlcmUgaXMgYVxuICogYDxgIGNsb3NlciB0byB0aGUgZW5kIG9mIHRoZSBzdHJpbmdzLCB0aGVuIHdlJ3JlIGluc2lkZSBhIHRhZy5cbiAqL1xuY29uc3QgdGV4dFJlZ2V4ID0gLz5bXjxdKiQvO1xuY29uc3QgaGFzVGFnc1JlZ2V4ID0gL1tePF0qLztcbmNvbnN0IHRleHRNYXJrZXJDb250ZW50ID0gJ18tbGl0LWh0bWwtXyc7XG5jb25zdCB0ZXh0TWFya2VyID0gYDwhLS0ke3RleHRNYXJrZXJDb250ZW50fS0tPmA7XG5jb25zdCBhdHRyT3JUZXh0UmVnZXggPSBuZXcgUmVnRXhwKGAke2F0dHJpYnV0ZU1hcmtlcn18JHt0ZXh0TWFya2VyfWApO1xuLyoqXG4gKiBBIHBsYWNlaG9sZGVyIGZvciBhIGR5bmFtaWMgZXhwcmVzc2lvbiBpbiBhbiBIVE1MIHRlbXBsYXRlLlxuICpcbiAqIFRoZXJlIGFyZSB0d28gYnVpbHQtaW4gcGFydCB0eXBlczogQXR0cmlidXRlUGFydCBhbmQgTm9kZVBhcnQuIE5vZGVQYXJ0c1xuICogYWx3YXlzIHJlcHJlc2VudCBhIHNpbmdsZSBkeW5hbWljIGV4cHJlc3Npb24sIHdoaWxlIEF0dHJpYnV0ZVBhcnRzIG1heVxuICogcmVwcmVzZW50IGFzIG1hbnkgZXhwcmVzc2lvbnMgYXJlIGNvbnRhaW5lZCBpbiB0aGUgYXR0cmlidXRlLlxuICpcbiAqIEEgVGVtcGxhdGUncyBwYXJ0cyBhcmUgbXV0YWJsZSwgc28gcGFydHMgY2FuIGJlIHJlcGxhY2VkIG9yIG1vZGlmaWVkXG4gKiAocG9zc2libHkgdG8gaW1wbGVtZW50IGRpZmZlcmVudCB0ZW1wbGF0ZSBzZW1hbnRpY3MpLiBUaGUgY29udHJhY3QgaXMgdGhhdFxuICogcGFydHMgY2FuIG9ubHkgYmUgcmVwbGFjZWQsIG5vdCByZW1vdmVkLCBhZGRlZCBvciByZW9yZGVyZWQsIGFuZCBwYXJ0cyBtdXN0XG4gKiBhbHdheXMgY29uc3VtZSB0aGUgY29ycmVjdCBudW1iZXIgb2YgdmFsdWVzIGluIHRoZWlyIGB1cGRhdGUoKWAgbWV0aG9kLlxuICpcbiAqIFRPRE8oanVzdGluZmFnbmFuaSk6IFRoYXQgcmVxdWlyZW1lbnQgaXMgYSBsaXR0bGUgZnJhZ2lsZS4gQVxuICogVGVtcGxhdGVJbnN0YW5jZSBjb3VsZCBpbnN0ZWFkIGJlIG1vcmUgY2FyZWZ1bCBhYm91dCB3aGljaCB2YWx1ZXMgaXQgZ2l2ZXNcbiAqIHRvIFBhcnQudXBkYXRlKCkuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKHR5cGUsIGluZGV4LCBuYW1lLCByYXdOYW1lLCBzdHJpbmdzKSB7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5yYXdOYW1lID0gcmF3TmFtZTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgVGVtcGxhdGUge1xuICAgIGNvbnN0cnVjdG9yKHN0cmluZ3MsIHN2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMucGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy5zdmcgPSBzdmc7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9nZXRIdG1sKHN0cmluZ3MsIHN2Zyk7XG4gICAgICAgIC8vIEVkZ2UgbmVlZHMgYWxsIDQgcGFyYW1ldGVycyBwcmVzZW50OyBJRTExIG5lZWRzIDNyZCBwYXJhbWV0ZXIgdG8gYmUgbnVsbFxuICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHRoaXMuZWxlbWVudC5jb250ZW50LCAxMzMgLyogTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCB8XG4gICAgICAgICAgICAgICBOb2RlRmlsdGVyLlNIT1dfVEVYVCAqLywgbnVsbCwgZmFsc2UpO1xuICAgICAgICBsZXQgaW5kZXggPSAtMTtcbiAgICAgICAgbGV0IHBhcnRJbmRleCA9IDA7XG4gICAgICAgIGNvbnN0IG5vZGVzVG9SZW1vdmUgPSBbXTtcbiAgICAgICAgLy8gVGhlIGFjdHVhbCBwcmV2aW91cyBub2RlLCBhY2NvdW50aW5nIGZvciByZW1vdmFsczogaWYgYSBub2RlIGlzIHJlbW92ZWRcbiAgICAgICAgLy8gaXQgd2lsbCBuZXZlciBiZSB0aGUgcHJldmlvdXNOb2RlLlxuICAgICAgICBsZXQgcHJldmlvdXNOb2RlO1xuICAgICAgICAvLyBVc2VkIHRvIHNldCBwcmV2aW91c05vZGUgYXQgdGhlIHRvcCBvZiB0aGUgbG9vcC5cbiAgICAgICAgbGV0IGN1cnJlbnROb2RlO1xuICAgICAgICB3aGlsZSAod2Fsa2VyLm5leHROb2RlKCkpIHtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICBwcmV2aW91c05vZGUgPSBjdXJyZW50Tm9kZTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjdXJyZW50Tm9kZSA9IHdhbGtlci5jdXJyZW50Tm9kZTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAxIC8qIE5vZGUuRUxFTUVOVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IG5vZGUuYXR0cmlidXRlcztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlID0gYXR0cmlidXRlcy5pdGVtKGkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVTdHJpbmdzID0gYXR0cmlidXRlLnZhbHVlLnNwbGl0KGF0dHJPclRleHRSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVTdHJpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgdGVtcGxhdGUgbGl0ZXJhbCBzZWN0aW9uIGxlYWRpbmcgdXAgdG8gdGhlIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBleHByZXNzaW9uIGluIHRoaXMgYXR0cmlidXRlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlU3RyaW5nID0gc3RyaW5nc1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJpbSB0aGUgdHJhaWxpbmcgbGl0ZXJhbCB2YWx1ZSBpZiB0aGlzIGlzIGFuIGludGVycG9sYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd05hbWVTdHJpbmcgPSBhdHRyaWJ1dGVTdHJpbmcuc3Vic3RyaW5nKDAsIGF0dHJpYnV0ZVN0cmluZy5sZW5ndGggLSBhdHRyaWJ1dGVTdHJpbmdzWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3TmFtZSA9IHJhd05hbWVTdHJpbmcubWF0Y2goLygoPzpcXHd8Wy5cXC1fJF0pKyk9W1wiJ10/JC8pWzFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKG5ldyBUZW1wbGF0ZVBhcnQoJ2F0dHJpYnV0ZScsIGluZGV4LCBhdHRyaWJ1dGUubmFtZSwgcmF3TmFtZSwgYXR0cmlidXRlU3RyaW5ncykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4ICs9IGF0dHJpYnV0ZVN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDMgLyogTm9kZS5URVhUX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlVmFsdWUgPSBub2RlLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdHJpbmdzID0gbm9kZVZhbHVlLnNwbGl0KGF0dHJpYnV0ZU1hcmtlcik7XG4gICAgICAgICAgICAgICAgaWYgKHN0cmluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RJbmRleCA9IHN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhIHBhcnQgZm9yIGVhY2ggbWF0Y2ggZm91bmRcbiAgICAgICAgICAgICAgICAgICAgcGFydEluZGV4ICs9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2Uga2VlcCB0aGlzIGN1cnJlbnQgbm9kZSwgYnV0IHJlc2V0IGl0cyBjb250ZW50IHRvIHRoZSBsYXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxpdGVyYWwgcGFydC4gV2UgaW5zZXJ0IG5ldyBsaXRlcmFsIG5vZGVzIGJlZm9yZSB0aGlzIHNvIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyZWUgd2Fsa2VyIGtlZXBzIGl0cyBwb3NpdGlvbiBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBzdHJpbmdzW2xhc3RJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IHRleHQgbm9kZSBmb3IgZWFjaCBsaXRlcmFsIHNlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2Ugbm9kZXMgYXJlIGFsc28gdXNlZCBhcyB0aGUgbWFya2VycyBmb3Igbm9kZSBwYXJ0c1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJbmRleDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHN0cmluZ3NbaV0pLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaChuZXcgVGVtcGxhdGVQYXJ0KCdub2RlJywgaW5kZXgrKykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBTdHJpcCB3aGl0ZXNwYWNlLW9ubHkgbm9kZXMsIG9ubHkgYmV0d2VlbiBlbGVtZW50cywgb3IgYXQgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlZ2lubmluZyBvciBlbmQgb2YgZWxlbWVudHMuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzU2libGluZyA9IG5vZGUucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0U2libGluZyA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGlmICgocHJldmlvdXNTaWJsaW5nID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcubm9kZVR5cGUgPT09IDEgLyogTm9kZS5FTEVNRU5UX05PREUgKi8pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAobmV4dFNpYmxpbmcgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0U2libGluZy5ub2RlVHlwZSA9PT0gMSAvKiBOb2RlLkVMRU1FTlRfTk9ERSAqLykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVWYWx1ZS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHByZXZpb3VzTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIE5vZGUuQ09NTUVOVF9OT0RFICovICYmXG4gICAgICAgICAgICAgICAgbm9kZS5ub2RlVmFsdWUgPT09IHRleHRNYXJrZXJDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBwcmV2aW91cyBub2RlIGFkZCBhIG1hcmtlciBub2RlLlxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBwcmV2aW91c1NpYmxpbmcgaXMgcmVtb3ZlZCwgYmVjYXVzZSBpdCdzIGFub3RoZXIgcGFydFxuICAgICAgICAgICAgICAgIC8vIHBsYWNob2xkZXIsIG9yIGVtcHR5IHRleHQsIGFkZCBhIG1hcmtlciBub2RlLlxuICAgICAgICAgICAgICAgIGlmIChub2RlLnByZXZpb3VzU2libGluZyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICBub2RlLnByZXZpb3VzU2libGluZyAhPT0gcHJldmlvdXNOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobmV3IFRleHQoKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2gobmV3IFRlbXBsYXRlUGFydCgnbm9kZScsIGluZGV4KyspKTtcbiAgICAgICAgICAgICAgICBub2Rlc1RvUmVtb3ZlLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIG5leHQgbm9kZSBhZGQgYSBtYXJrZXIgbm9kZS5cbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBoYXZlIHRvIGNoZWNrIGlmIHRoZSBuZXh0IG5vZGUgaXMgZ29pbmcgdG8gYmUgcmVtb3ZlZCxcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoYXQgbm9kZSB3aWxsIGluZHVjZSBhIG1hcmtlciBpZiBzby5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uZXh0U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ldyBUZXh0KCksIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBwcmV2aW91c05vZGU7XG4gICAgICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRleHQgYmluZGluZyBub2RlcyBhZnRlciB0aGUgd2FsayB0byBub3QgZGlzdHVyYiB0aGUgVHJlZVdhbGtlclxuICAgICAgICBmb3IgKGNvbnN0IG4gb2Ygbm9kZXNUb1JlbW92ZSkge1xuICAgICAgICAgICAgbi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgb2YgSFRNTCB1c2VkIHRvIGNyZWF0ZSBhIDx0ZW1wbGF0ZT4gZWxlbWVudC5cbiAgICAgKi9cbiAgICBfZ2V0SHRtbChzdHJpbmdzLCBzdmcpIHtcbiAgICAgICAgY29uc3QgbCA9IHN0cmluZ3MubGVuZ3RoO1xuICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgIGxldCBpc1RleHRCaW5kaW5nID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbCAtIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgcyA9IHN0cmluZ3NbaV07XG4gICAgICAgICAgICBhLnB1c2gocyk7XG4gICAgICAgICAgICAvLyBXZSdyZSBpbiBhIHRleHQgcG9zaXRpb24gaWYgdGhlIHByZXZpb3VzIHN0cmluZyBtYXRjaGVzIHRoZVxuICAgICAgICAgICAgLy8gdGV4dFJlZ2V4LiBJZiBpdCBkb2Vzbid0IGFuZCB0aGUgcHJldmlvdXMgc3RyaW5nIGhhcyBubyB0YWdzLCB0aGVuXG4gICAgICAgICAgICAvLyB3ZSB1c2UgdGhlIHByZXZpb3VzIHRleHQgcG9zaXRpb24gc3RhdGUuXG4gICAgICAgICAgICBpc1RleHRCaW5kaW5nID0gcy5tYXRjaCh0ZXh0UmVnZXgpICE9PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgKHMubWF0Y2goaGFzVGFnc1JlZ2V4KSAhPT0gbnVsbCAmJiBpc1RleHRCaW5kaW5nKTtcbiAgICAgICAgICAgIGEucHVzaChpc1RleHRCaW5kaW5nID8gdGV4dE1hcmtlciA6IGF0dHJpYnV0ZU1hcmtlcik7XG4gICAgICAgIH1cbiAgICAgICAgYS5wdXNoKHN0cmluZ3NbbCAtIDFdKTtcbiAgICAgICAgY29uc3QgaHRtbCA9IGEuam9pbignJyk7XG4gICAgICAgIHJldHVybiBzdmcgPyBgPHN2Zz4ke2h0bWx9PC9zdmc+YCA6IGh0bWw7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGdldFZhbHVlID0gKHBhcnQsIHZhbHVlKSA9PiB7XG4gICAgLy8gYG51bGxgIGFzIHRoZSB2YWx1ZSBvZiBhIFRleHQgbm9kZSB3aWxsIHJlbmRlciB0aGUgc3RyaW5nICdudWxsJ1xuICAgIC8vIHNvIHdlIGNvbnZlcnQgaXQgdG8gdW5kZWZpbmVkXG4gICAgaWYgKHZhbHVlICE9IG51bGwgJiYgdmFsdWUuX19saXREaXJlY3RpdmUgPT09IHRydWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZShwYXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gdW5kZWZpbmVkIDogdmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IGRpcmVjdGl2ZSA9IChmKSA9PiB7XG4gICAgZi5fX2xpdERpcmVjdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIGY7XG59O1xuZXhwb3J0IGNsYXNzIEF0dHJpYnV0ZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGluc3RhbmNlLCBlbGVtZW50LCBuYW1lLCBzdHJpbmdzKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5zdHJpbmdzID0gc3RyaW5ncztcbiAgICAgICAgdGhpcy5zaXplID0gc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZXMsIHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgY29uc3Qgc3RyaW5ncyA9IHRoaXMuc3RyaW5ncztcbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IHN0cmluZ3NbaV07XG4gICAgICAgICAgICBpZiAoaSA8IHN0cmluZ3MubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSBnZXRWYWx1ZSh0aGlzLCB2YWx1ZXNbc3RhcnRJbmRleCArIGldKTtcbiAgICAgICAgICAgICAgICBpZiAodiAmJlxuICAgICAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh2KSB8fCB0eXBlb2YgdiAhPT0gJ3N0cmluZycgJiYgdltTeW1ib2wuaXRlcmF0b3JdKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHQgb2Ygdikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogd2UgbmVlZCB0byByZWN1cnNpdmVseSBjYWxsIGdldFZhbHVlIGludG8gaXRlcmFibGVzLi4uXG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSh0aGlzLm5hbWUsIHRleHQpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOb2RlUGFydCB7XG4gICAgY29uc3RydWN0b3IoaW5zdGFuY2UsIHN0YXJ0Tm9kZSwgZW5kTm9kZSkge1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIHRoaXMuc3RhcnROb2RlID0gc3RhcnROb2RlO1xuICAgICAgICB0aGlzLmVuZE5vZGUgPSBlbmROb2RlO1xuICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZXRWYWx1ZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IGdldFZhbHVlKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgICAhKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHByaW1pdGl2ZSB2YWx1ZXNcbiAgICAgICAgICAgIC8vIElmIHRoZSB2YWx1ZSBkaWRuJ3QgY2hhbmdlLCBkbyBub3RoaW5nXG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHRoaXMuX3ByZXZpb3VzVmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRUZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFRlbXBsYXRlUmVzdWx0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRUZW1wbGF0ZVJlc3VsdCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgdmFsdWVbU3ltYm9sLml0ZXJhdG9yXSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0SXRlcmFibGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0Tm9kZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUudGhlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQcm9taXNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrLCB3aWxsIHJlbmRlciB0aGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgICAgICAgICB0aGlzLl9zZXRUZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW5zZXJ0KG5vZGUpIHtcbiAgICAgICAgdGhpcy5lbmROb2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKG5vZGUsIHRoaXMuZW5kTm9kZSk7XG4gICAgfVxuICAgIF9zZXROb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5faW5zZXJ0KHZhbHVlKTtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBfc2V0VGV4dCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBub2RlID0gdGhpcy5zdGFydE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChub2RlID09PSB0aGlzLmVuZE5vZGUucHJldmlvdXNTaWJsaW5nICYmXG4gICAgICAgICAgICBub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgLy8gSWYgd2Ugb25seSBoYXZlIGEgc2luZ2xlIHRleHQgbm9kZSBiZXR3ZWVuIHRoZSBtYXJrZXJzLCB3ZSBjYW4ganVzdFxuICAgICAgICAgICAgLy8gc2V0IGl0cyB2YWx1ZSwgcmF0aGVyIHRoYW4gcmVwbGFjaW5nIGl0LlxuICAgICAgICAgICAgLy8gVE9ETyhqdXN0aW5mYWduYW5pKTogQ2FuIHdlIGp1c3QgY2hlY2sgaWYgX3ByZXZpb3VzVmFsdWUgaXNcbiAgICAgICAgICAgIC8vIHByaW1pdGl2ZT9cbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldE5vZGUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUgPT09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIF9zZXRUZW1wbGF0ZVJlc3VsdCh2YWx1ZSkge1xuICAgICAgICBsZXQgaW5zdGFuY2U7XG4gICAgICAgIGlmICh0aGlzLl9wcmV2aW91c1ZhbHVlICYmXG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlLnRlbXBsYXRlID09PSB2YWx1ZS50ZW1wbGF0ZSkge1xuICAgICAgICAgICAgaW5zdGFuY2UgPSB0aGlzLl9wcmV2aW91c1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaW5zdGFuY2UgPVxuICAgICAgICAgICAgICAgIG5ldyBUZW1wbGF0ZUluc3RhbmNlKHZhbHVlLnRlbXBsYXRlLCB0aGlzLmluc3RhbmNlLl9wYXJ0Q2FsbGJhY2spO1xuICAgICAgICAgICAgdGhpcy5fc2V0Tm9kZShpbnN0YW5jZS5fY2xvbmUoKSk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gaW5zdGFuY2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKHZhbHVlLnZhbHVlcyk7XG4gICAgfVxuICAgIF9zZXRJdGVyYWJsZSh2YWx1ZSkge1xuICAgICAgICAvLyBGb3IgYW4gSXRlcmFibGUsIHdlIGNyZWF0ZSBhIG5ldyBJbnN0YW5jZVBhcnQgcGVyIGl0ZW0sIHRoZW4gc2V0IGl0c1xuICAgICAgICAvLyB2YWx1ZSB0byB0aGUgaXRlbS4gVGhpcyBpcyBhIGxpdHRsZSBiaXQgb2Ygb3ZlcmhlYWQgZm9yIGV2ZXJ5IGl0ZW0gaW5cbiAgICAgICAgLy8gYW4gSXRlcmFibGUsIGJ1dCBpdCBsZXRzIHVzIHJlY3Vyc2UgZWFzaWx5IGFuZCBlZmZpY2llbnRseSB1cGRhdGUgQXJyYXlzXG4gICAgICAgIC8vIG9mIFRlbXBsYXRlUmVzdWx0cyB0aGF0IHdpbGwgYmUgY29tbW9ubHkgcmV0dXJuZWQgZnJvbSBleHByZXNzaW9ucyBsaWtlOlxuICAgICAgICAvLyBhcnJheS5tYXAoKGkpID0+IGh0bWxgJHtpfWApLCBieSByZXVzaW5nIGV4aXN0aW5nIFRlbXBsYXRlSW5zdGFuY2VzLlxuICAgICAgICAvLyBJZiBfcHJldmlvdXNWYWx1ZSBpcyBhbiBhcnJheSwgdGhlbiB0aGUgcHJldmlvdXMgcmVuZGVyIHdhcyBvZiBhblxuICAgICAgICAvLyBpdGVyYWJsZSBhbmQgX3ByZXZpb3VzVmFsdWUgd2lsbCBjb250YWluIHRoZSBOb2RlUGFydHMgZnJvbSB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gcmVuZGVyLiBJZiBfcHJldmlvdXNWYWx1ZSBpcyBub3QgYW4gYXJyYXksIGNsZWFyIHRoaXMgcGFydCBhbmQgbWFrZSBhIG5ld1xuICAgICAgICAvLyBhcnJheSBmb3IgTm9kZVBhcnRzLlxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpcy5fcHJldmlvdXNWYWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBMZXRzIHVzIGtlZXAgdHJhY2sgb2YgaG93IG1hbnkgaXRlbXMgd2Ugc3RhbXBlZCBzbyB3ZSBjYW4gY2xlYXIgbGVmdG92ZXJcbiAgICAgICAgLy8gaXRlbXMgZnJvbSBhIHByZXZpb3VzIHJlbmRlclxuICAgICAgICBjb25zdCBpdGVtUGFydHMgPSB0aGlzLl9wcmV2aW91c1ZhbHVlO1xuICAgICAgICBsZXQgcGFydEluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gcmV1c2UgYW4gZXhpc3RpbmcgcGFydFxuICAgICAgICAgICAgbGV0IGl0ZW1QYXJ0ID0gaXRlbVBhcnRzW3BhcnRJbmRleF07XG4gICAgICAgICAgICAvLyBJZiBubyBleGlzdGluZyBwYXJ0LCBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgICAgICBpZiAoaXRlbVBhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIGNyZWF0aW5nIHRoZSBmaXJzdCBpdGVtIHBhcnQsIGl0J3Mgc3RhcnROb2RlIHNob3VsZCBiZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBjb250YWluZXIncyBzdGFydE5vZGVcbiAgICAgICAgICAgICAgICBsZXQgaXRlbVN0YXJ0ID0gdGhpcy5zdGFydE5vZGU7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGNyZWF0aW5nIHRoZSBmaXJzdCBwYXJ0LCBjcmVhdGUgYSBuZXcgc2VwYXJhdG9yIG1hcmtlclxuICAgICAgICAgICAgICAgIC8vIG5vZGUsIGFuZCBmaXggdXAgdGhlIHByZXZpb3VzIHBhcnQncyBlbmROb2RlIHRvIHBvaW50IHRvIGl0XG4gICAgICAgICAgICAgICAgaWYgKHBhcnRJbmRleCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNQYXJ0ID0gaXRlbVBhcnRzW3BhcnRJbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpdGVtU3RhcnQgPSBwcmV2aW91c1BhcnQuZW5kTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5zZXJ0KGl0ZW1TdGFydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW1QYXJ0ID0gbmV3IE5vZGVQYXJ0KHRoaXMuaW5zdGFuY2UsIGl0ZW1TdGFydCwgdGhpcy5lbmROb2RlKTtcbiAgICAgICAgICAgICAgICBpdGVtUGFydHMucHVzaChpdGVtUGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtUGFydC5zZXRWYWx1ZShpdGVtKTtcbiAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0SW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydEluZGV4IDwgaXRlbVBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGFzdFBhcnQgPSBpdGVtUGFydHNbcGFydEluZGV4IC0gMV07XG4gICAgICAgICAgICAvLyBUcnVuY2F0ZSB0aGUgcGFydHMgYXJyYXkgc28gX3ByZXZpb3VzVmFsdWUgcmVmbGVjdHMgdGhlIGN1cnJlbnQgc3RhdGVcbiAgICAgICAgICAgIGl0ZW1QYXJ0cy5sZW5ndGggPSBwYXJ0SW5kZXg7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKGxhc3RQYXJ0LmVuZE5vZGUucHJldmlvdXNTaWJsaW5nKTtcbiAgICAgICAgICAgIGxhc3RQYXJ0LmVuZE5vZGUgPSB0aGlzLmVuZE5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX3NldFByb21pc2UodmFsdWUpIHtcbiAgICAgICAgdmFsdWUudGhlbigodikgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzVmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgY2xlYXIoc3RhcnROb2RlID0gdGhpcy5zdGFydE5vZGUpIHtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIHdoaWxlICgobm9kZSA9IHN0YXJ0Tm9kZS5uZXh0U2libGluZykgIT09IHRoaXMuZW5kTm9kZSkge1xuICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGRlZmF1bHRQYXJ0Q2FsbGJhY2sgPSAoaW5zdGFuY2UsIHRlbXBsYXRlUGFydCwgbm9kZSkgPT4ge1xuICAgIGlmICh0ZW1wbGF0ZVBhcnQudHlwZSA9PT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBdHRyaWJ1dGVQYXJ0KGluc3RhbmNlLCBub2RlLCB0ZW1wbGF0ZVBhcnQubmFtZSwgdGVtcGxhdGVQYXJ0LnN0cmluZ3MpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0ZW1wbGF0ZVBhcnQudHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgIHJldHVybiBuZXcgTm9kZVBhcnQoaW5zdGFuY2UsIG5vZGUsIG5vZGUubmV4dFNpYmxpbmcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFydCB0eXBlICR7dGVtcGxhdGVQYXJ0LnR5cGV9YCk7XG59O1xuLyoqXG4gKiBBbiBpbnN0YW5jZSBvZiBhIGBUZW1wbGF0ZWAgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIERPTSBhbmQgdXBkYXRlZFxuICogd2l0aCBuZXcgdmFsdWVzLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVJbnN0YW5jZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGUsIHBhcnRDYWxsYmFjayA9IGRlZmF1bHRQYXJ0Q2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fcGFydHMgPSBbXTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgICAgICB0aGlzLl9wYXJ0Q2FsbGJhY2sgPSBwYXJ0Q2FsbGJhY2s7XG4gICAgfVxuICAgIHVwZGF0ZSh2YWx1ZXMpIHtcbiAgICAgICAgbGV0IHZhbHVlSW5kZXggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2YgdGhpcy5fcGFydHMpIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LnNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHBhcnQuc2V0VmFsdWUodmFsdWVzW3ZhbHVlSW5kZXhdKTtcbiAgICAgICAgICAgICAgICB2YWx1ZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnNldFZhbHVlKHZhbHVlcywgdmFsdWVJbmRleCk7XG4gICAgICAgICAgICAgICAgdmFsdWVJbmRleCArPSBwYXJ0LnNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Nsb25lKCkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IGRvY3VtZW50LmltcG9ydE5vZGUodGhpcy50ZW1wbGF0ZS5lbGVtZW50LmNvbnRlbnQsIHRydWUpO1xuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZS5wYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBFZGdlIG5lZWRzIGFsbCA0IHBhcmFtZXRlcnMgcHJlc2VudDsgSUUxMSBuZWVkcyAzcmQgcGFyYW1ldGVyIHRvIGJlXG4gICAgICAgICAgICAvLyBudWxsXG4gICAgICAgICAgICBjb25zdCB3YWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGZyYWdtZW50LCAxMzMgLyogTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfQ09NTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19URVhUICovLCBudWxsLCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBwYXJ0cyA9IHRoaXMudGVtcGxhdGUucGFydHM7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IHBhcnRJbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgdGVtcGxhdGVQYXJ0ID0gcGFydHNbMF07XG4gICAgICAgICAgICBsZXQgbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgd2hpbGUgKG5vZGUgIT0gbnVsbCAmJiBwYXJ0SW5kZXggPCBwYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPT09IHRlbXBsYXRlUGFydC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9wYXJ0cy5wdXNoKHRoaXMuX3BhcnRDYWxsYmFjayh0aGlzLCB0ZW1wbGF0ZVBhcnQsIG5vZGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGVQYXJ0ID0gcGFydHNbKytwYXJ0SW5kZXhdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgbm9kZSA9IHdhbGtlci5uZXh0Tm9kZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy50ZW1wbGF0ZS5zdmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHN2Z0VsZW1lbnQgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuICAgICAgICAgICAgZnJhZ21lbnQucmVtb3ZlQ2hpbGQoc3ZnRWxlbWVudCk7XG4gICAgICAgICAgICBjb25zdCBub2RlcyA9IHN2Z0VsZW1lbnQuY2hpbGROb2RlcztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZChub2Rlcy5pdGVtKGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnJhZ21lbnQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGl0LWh0bWwuanMubWFwXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGl0LWh0bWwuanNcbi8vIG1vZHVsZSBpZCA9IDQ1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8Y3VzdG9tLXN0eWxlPlxuICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICBodG1sIHtcblxuICAgICAgLyogTWF0ZXJpYWwgRGVzaWduIGNvbG9yIHBhbGV0dGUgZm9yIEdvb2dsZSBwcm9kdWN0cyAqL1xuXG4gICAgICAtLWdvb2dsZS1yZWQtMTAwOiAjZjRjN2MzO1xuICAgICAgLS1nb29nbGUtcmVkLTMwMDogI2U2N2M3MztcbiAgICAgIC0tZ29vZ2xlLXJlZC01MDA6ICNkYjQ0Mzc7XG4gICAgICAtLWdvb2dsZS1yZWQtNzAwOiAjYzUzOTI5O1xuXG4gICAgICAtLWdvb2dsZS1ibHVlLTEwMDogI2M2ZGFmYztcbiAgICAgIC0tZ29vZ2xlLWJsdWUtMzAwOiAjN2JhYWY3O1xuICAgICAgLS1nb29nbGUtYmx1ZS01MDA6ICM0Mjg1ZjQ7XG4gICAgICAtLWdvb2dsZS1ibHVlLTcwMDogIzMzNjdkNjtcblxuICAgICAgLS1nb29nbGUtZ3JlZW4tMTAwOiAjYjdlMWNkO1xuICAgICAgLS1nb29nbGUtZ3JlZW4tMzAwOiAjNTdiYjhhO1xuICAgICAgLS1nb29nbGUtZ3JlZW4tNTAwOiAjMGY5ZDU4O1xuICAgICAgLS1nb29nbGUtZ3JlZW4tNzAwOiAjMGI4MDQzO1xuXG4gICAgICAtLWdvb2dsZS15ZWxsb3ctMTAwOiAjZmNlOGIyO1xuICAgICAgLS1nb29nbGUteWVsbG93LTMwMDogI2Y3Y2I0ZDtcbiAgICAgIC0tZ29vZ2xlLXllbGxvdy01MDA6ICNmNGI0MDA7XG4gICAgICAtLWdvb2dsZS15ZWxsb3ctNzAwOiAjZjA5MzAwO1xuXG4gICAgICAtLWdvb2dsZS1ncmV5LTEwMDogI2Y1ZjVmNTtcbiAgICAgIC0tZ29vZ2xlLWdyZXktMzAwOiAjZTBlMGUwO1xuICAgICAgLS1nb29nbGUtZ3JleS01MDA6ICM5ZTllOWU7XG4gICAgICAtLWdvb2dsZS1ncmV5LTcwMDogIzYxNjE2MTtcblxuICAgICAgLyogTWF0ZXJpYWwgRGVzaWduIGNvbG9yIHBhbGV0dGUgZnJvbSBvbmxpbmUgc3BlYyBkb2N1bWVudCAqL1xuXG4gICAgICAtLXBhcGVyLXJlZC01MDogI2ZmZWJlZTtcbiAgICAgIC0tcGFwZXItcmVkLTEwMDogI2ZmY2RkMjtcbiAgICAgIC0tcGFwZXItcmVkLTIwMDogI2VmOWE5YTtcbiAgICAgIC0tcGFwZXItcmVkLTMwMDogI2U1NzM3MztcbiAgICAgIC0tcGFwZXItcmVkLTQwMDogI2VmNTM1MDtcbiAgICAgIC0tcGFwZXItcmVkLTUwMDogI2Y0NDMzNjtcbiAgICAgIC0tcGFwZXItcmVkLTYwMDogI2U1MzkzNTtcbiAgICAgIC0tcGFwZXItcmVkLTcwMDogI2QzMmYyZjtcbiAgICAgIC0tcGFwZXItcmVkLTgwMDogI2M2MjgyODtcbiAgICAgIC0tcGFwZXItcmVkLTkwMDogI2I3MWMxYztcbiAgICAgIC0tcGFwZXItcmVkLWExMDA6ICNmZjhhODA7XG4gICAgICAtLXBhcGVyLXJlZC1hMjAwOiAjZmY1MjUyO1xuICAgICAgLS1wYXBlci1yZWQtYTQwMDogI2ZmMTc0NDtcbiAgICAgIC0tcGFwZXItcmVkLWE3MDA6ICNkNTAwMDA7XG5cbiAgICAgIC0tcGFwZXItcGluay01MDogI2ZjZTRlYztcbiAgICAgIC0tcGFwZXItcGluay0xMDA6ICNmOGJiZDA7XG4gICAgICAtLXBhcGVyLXBpbmstMjAwOiAjZjQ4ZmIxO1xuICAgICAgLS1wYXBlci1waW5rLTMwMDogI2YwNjI5MjtcbiAgICAgIC0tcGFwZXItcGluay00MDA6ICNlYzQwN2E7XG4gICAgICAtLXBhcGVyLXBpbmstNTAwOiAjZTkxZTYzO1xuICAgICAgLS1wYXBlci1waW5rLTYwMDogI2Q4MWI2MDtcbiAgICAgIC0tcGFwZXItcGluay03MDA6ICNjMjE4NWI7XG4gICAgICAtLXBhcGVyLXBpbmstODAwOiAjYWQxNDU3O1xuICAgICAgLS1wYXBlci1waW5rLTkwMDogIzg4MGU0ZjtcbiAgICAgIC0tcGFwZXItcGluay1hMTAwOiAjZmY4MGFiO1xuICAgICAgLS1wYXBlci1waW5rLWEyMDA6ICNmZjQwODE7XG4gICAgICAtLXBhcGVyLXBpbmstYTQwMDogI2Y1MDA1NztcbiAgICAgIC0tcGFwZXItcGluay1hNzAwOiAjYzUxMTYyO1xuXG4gICAgICAtLXBhcGVyLXB1cnBsZS01MDogI2YzZTVmNTtcbiAgICAgIC0tcGFwZXItcHVycGxlLTEwMDogI2UxYmVlNztcbiAgICAgIC0tcGFwZXItcHVycGxlLTIwMDogI2NlOTNkODtcbiAgICAgIC0tcGFwZXItcHVycGxlLTMwMDogI2JhNjhjODtcbiAgICAgIC0tcGFwZXItcHVycGxlLTQwMDogI2FiNDdiYztcbiAgICAgIC0tcGFwZXItcHVycGxlLTUwMDogIzljMjdiMDtcbiAgICAgIC0tcGFwZXItcHVycGxlLTYwMDogIzhlMjRhYTtcbiAgICAgIC0tcGFwZXItcHVycGxlLTcwMDogIzdiMWZhMjtcbiAgICAgIC0tcGFwZXItcHVycGxlLTgwMDogIzZhMWI5YTtcbiAgICAgIC0tcGFwZXItcHVycGxlLTkwMDogIzRhMTQ4YztcbiAgICAgIC0tcGFwZXItcHVycGxlLWExMDA6ICNlYTgwZmM7XG4gICAgICAtLXBhcGVyLXB1cnBsZS1hMjAwOiAjZTA0MGZiO1xuICAgICAgLS1wYXBlci1wdXJwbGUtYTQwMDogI2Q1MDBmOTtcbiAgICAgIC0tcGFwZXItcHVycGxlLWE3MDA6ICNhYTAwZmY7XG5cbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNTA6ICNlZGU3ZjY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTEwMDogI2QxYzRlOTtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtMjAwOiAjYjM5ZGRiO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS0zMDA6ICM5NTc1Y2Q7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTQwMDogIzdlNTdjMjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNTAwOiAjNjczYWI3O1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS02MDA6ICM1ZTM1YjE7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTcwMDogIzUxMmRhODtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtODAwOiAjNDUyN2EwO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS05MDA6ICMzMTFiOTI7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWExMDA6ICNiMzg4ZmY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWEyMDA6ICM3YzRkZmY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWE0MDA6ICM2NTFmZmY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWE3MDA6ICM2MjAwZWE7XG5cbiAgICAgIC0tcGFwZXItaW5kaWdvLTUwOiAjZThlYWY2O1xuICAgICAgLS1wYXBlci1pbmRpZ28tMTAwOiAjYzVjYWU5O1xuICAgICAgLS1wYXBlci1pbmRpZ28tMjAwOiAjOWZhOGRhO1xuICAgICAgLS1wYXBlci1pbmRpZ28tMzAwOiAjNzk4NmNiO1xuICAgICAgLS1wYXBlci1pbmRpZ28tNDAwOiAjNWM2YmMwO1xuICAgICAgLS1wYXBlci1pbmRpZ28tNTAwOiAjM2Y1MWI1O1xuICAgICAgLS1wYXBlci1pbmRpZ28tNjAwOiAjMzk0OWFiO1xuICAgICAgLS1wYXBlci1pbmRpZ28tNzAwOiAjMzAzZjlmO1xuICAgICAgLS1wYXBlci1pbmRpZ28tODAwOiAjMjgzNTkzO1xuICAgICAgLS1wYXBlci1pbmRpZ28tOTAwOiAjMWEyMzdlO1xuICAgICAgLS1wYXBlci1pbmRpZ28tYTEwMDogIzhjOWVmZjtcbiAgICAgIC0tcGFwZXItaW5kaWdvLWEyMDA6ICM1MzZkZmU7XG4gICAgICAtLXBhcGVyLWluZGlnby1hNDAwOiAjM2Q1YWZlO1xuICAgICAgLS1wYXBlci1pbmRpZ28tYTcwMDogIzMwNGZmZTtcblxuICAgICAgLS1wYXBlci1ibHVlLTUwOiAjZTNmMmZkO1xuICAgICAgLS1wYXBlci1ibHVlLTEwMDogI2JiZGVmYjtcbiAgICAgIC0tcGFwZXItYmx1ZS0yMDA6ICM5MGNhZjk7XG4gICAgICAtLXBhcGVyLWJsdWUtMzAwOiAjNjRiNWY2O1xuICAgICAgLS1wYXBlci1ibHVlLTQwMDogIzQyYTVmNTtcbiAgICAgIC0tcGFwZXItYmx1ZS01MDA6ICMyMTk2ZjM7XG4gICAgICAtLXBhcGVyLWJsdWUtNjAwOiAjMWU4OGU1O1xuICAgICAgLS1wYXBlci1ibHVlLTcwMDogIzE5NzZkMjtcbiAgICAgIC0tcGFwZXItYmx1ZS04MDA6ICMxNTY1YzA7XG4gICAgICAtLXBhcGVyLWJsdWUtOTAwOiAjMGQ0N2ExO1xuICAgICAgLS1wYXBlci1ibHVlLWExMDA6ICM4MmIxZmY7XG4gICAgICAtLXBhcGVyLWJsdWUtYTIwMDogIzQ0OGFmZjtcbiAgICAgIC0tcGFwZXItYmx1ZS1hNDAwOiAjMjk3OWZmO1xuICAgICAgLS1wYXBlci1ibHVlLWE3MDA6ICMyOTYyZmY7XG5cbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS01MDogI2UxZjVmZTtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS0xMDA6ICNiM2U1ZmM7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtMjAwOiAjODFkNGZhO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTMwMDogIzRmYzNmNztcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS00MDA6ICMyOWI2ZjY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtNTAwOiAjMDNhOWY0O1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTYwMDogIzAzOWJlNTtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS03MDA6ICMwMjg4ZDE7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtODAwOiAjMDI3N2JkO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTkwMDogIzAxNTc5YjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS1hMTAwOiAjODBkOGZmO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLWEyMDA6ICM0MGM0ZmY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtYTQwMDogIzAwYjBmZjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS1hNzAwOiAjMDA5MWVhO1xuXG4gICAgICAtLXBhcGVyLWN5YW4tNTA6ICNlMGY3ZmE7XG4gICAgICAtLXBhcGVyLWN5YW4tMTAwOiAjYjJlYmYyO1xuICAgICAgLS1wYXBlci1jeWFuLTIwMDogIzgwZGVlYTtcbiAgICAgIC0tcGFwZXItY3lhbi0zMDA6ICM0ZGQwZTE7XG4gICAgICAtLXBhcGVyLWN5YW4tNDAwOiAjMjZjNmRhO1xuICAgICAgLS1wYXBlci1jeWFuLTUwMDogIzAwYmNkNDtcbiAgICAgIC0tcGFwZXItY3lhbi02MDA6ICMwMGFjYzE7XG4gICAgICAtLXBhcGVyLWN5YW4tNzAwOiAjMDA5N2E3O1xuICAgICAgLS1wYXBlci1jeWFuLTgwMDogIzAwODM4ZjtcbiAgICAgIC0tcGFwZXItY3lhbi05MDA6ICMwMDYwNjQ7XG4gICAgICAtLXBhcGVyLWN5YW4tYTEwMDogIzg0ZmZmZjtcbiAgICAgIC0tcGFwZXItY3lhbi1hMjAwOiAjMThmZmZmO1xuICAgICAgLS1wYXBlci1jeWFuLWE0MDA6ICMwMGU1ZmY7XG4gICAgICAtLXBhcGVyLWN5YW4tYTcwMDogIzAwYjhkNDtcblxuICAgICAgLS1wYXBlci10ZWFsLTUwOiAjZTBmMmYxO1xuICAgICAgLS1wYXBlci10ZWFsLTEwMDogI2IyZGZkYjtcbiAgICAgIC0tcGFwZXItdGVhbC0yMDA6ICM4MGNiYzQ7XG4gICAgICAtLXBhcGVyLXRlYWwtMzAwOiAjNGRiNmFjO1xuICAgICAgLS1wYXBlci10ZWFsLTQwMDogIzI2YTY5YTtcbiAgICAgIC0tcGFwZXItdGVhbC01MDA6ICMwMDk2ODg7XG4gICAgICAtLXBhcGVyLXRlYWwtNjAwOiAjMDA4OTdiO1xuICAgICAgLS1wYXBlci10ZWFsLTcwMDogIzAwNzk2YjtcbiAgICAgIC0tcGFwZXItdGVhbC04MDA6ICMwMDY5NWM7XG4gICAgICAtLXBhcGVyLXRlYWwtOTAwOiAjMDA0ZDQwO1xuICAgICAgLS1wYXBlci10ZWFsLWExMDA6ICNhN2ZmZWI7XG4gICAgICAtLXBhcGVyLXRlYWwtYTIwMDogIzY0ZmZkYTtcbiAgICAgIC0tcGFwZXItdGVhbC1hNDAwOiAjMWRlOWI2O1xuICAgICAgLS1wYXBlci10ZWFsLWE3MDA6ICMwMGJmYTU7XG5cbiAgICAgIC0tcGFwZXItZ3JlZW4tNTA6ICNlOGY1ZTk7XG4gICAgICAtLXBhcGVyLWdyZWVuLTEwMDogI2M4ZTZjOTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tMjAwOiAjYTVkNmE3O1xuICAgICAgLS1wYXBlci1ncmVlbi0zMDA6ICM4MWM3ODQ7XG4gICAgICAtLXBhcGVyLWdyZWVuLTQwMDogIzY2YmI2YTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tNTAwOiAjNGNhZjUwO1xuICAgICAgLS1wYXBlci1ncmVlbi02MDA6ICM0M2EwNDc7XG4gICAgICAtLXBhcGVyLWdyZWVuLTcwMDogIzM4OGUzYztcbiAgICAgIC0tcGFwZXItZ3JlZW4tODAwOiAjMmU3ZDMyO1xuICAgICAgLS1wYXBlci1ncmVlbi05MDA6ICMxYjVlMjA7XG4gICAgICAtLXBhcGVyLWdyZWVuLWExMDA6ICNiOWY2Y2E7XG4gICAgICAtLXBhcGVyLWdyZWVuLWEyMDA6ICM2OWYwYWU7XG4gICAgICAtLXBhcGVyLWdyZWVuLWE0MDA6ICMwMGU2NzY7XG4gICAgICAtLXBhcGVyLWdyZWVuLWE3MDA6ICMwMGM4NTM7XG5cbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNTA6ICNmMWY4ZTk7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTEwMDogI2RjZWRjODtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tMjAwOiAjYzVlMWE1O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi0zMDA6ICNhZWQ1ODE7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTQwMDogIzljY2M2NTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNTAwOiAjOGJjMzRhO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi02MDA6ICM3Y2IzNDI7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTcwMDogIzY4OWYzODtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tODAwOiAjNTU4YjJmO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi05MDA6ICMzMzY5MWU7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWExMDA6ICNjY2ZmOTA7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWEyMDA6ICNiMmZmNTk7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWE0MDA6ICM3NmZmMDM7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWE3MDA6ICM2NGRkMTc7XG5cbiAgICAgIC0tcGFwZXItbGltZS01MDogI2Y5ZmJlNztcbiAgICAgIC0tcGFwZXItbGltZS0xMDA6ICNmMGY0YzM7XG4gICAgICAtLXBhcGVyLWxpbWUtMjAwOiAjZTZlZTljO1xuICAgICAgLS1wYXBlci1saW1lLTMwMDogI2RjZTc3NTtcbiAgICAgIC0tcGFwZXItbGltZS00MDA6ICNkNGUxNTc7XG4gICAgICAtLXBhcGVyLWxpbWUtNTAwOiAjY2RkYzM5O1xuICAgICAgLS1wYXBlci1saW1lLTYwMDogI2MwY2EzMztcbiAgICAgIC0tcGFwZXItbGltZS03MDA6ICNhZmI0MmI7XG4gICAgICAtLXBhcGVyLWxpbWUtODAwOiAjOWU5ZDI0O1xuICAgICAgLS1wYXBlci1saW1lLTkwMDogIzgyNzcxNztcbiAgICAgIC0tcGFwZXItbGltZS1hMTAwOiAjZjRmZjgxO1xuICAgICAgLS1wYXBlci1saW1lLWEyMDA6ICNlZWZmNDE7XG4gICAgICAtLXBhcGVyLWxpbWUtYTQwMDogI2M2ZmYwMDtcbiAgICAgIC0tcGFwZXItbGltZS1hNzAwOiAjYWVlYTAwO1xuXG4gICAgICAtLXBhcGVyLXllbGxvdy01MDogI2ZmZmRlNztcbiAgICAgIC0tcGFwZXIteWVsbG93LTEwMDogI2ZmZjljNDtcbiAgICAgIC0tcGFwZXIteWVsbG93LTIwMDogI2ZmZjU5ZDtcbiAgICAgIC0tcGFwZXIteWVsbG93LTMwMDogI2ZmZjE3NjtcbiAgICAgIC0tcGFwZXIteWVsbG93LTQwMDogI2ZmZWU1ODtcbiAgICAgIC0tcGFwZXIteWVsbG93LTUwMDogI2ZmZWIzYjtcbiAgICAgIC0tcGFwZXIteWVsbG93LTYwMDogI2ZkZDgzNTtcbiAgICAgIC0tcGFwZXIteWVsbG93LTcwMDogI2ZiYzAyZDtcbiAgICAgIC0tcGFwZXIteWVsbG93LTgwMDogI2Y5YTgyNTtcbiAgICAgIC0tcGFwZXIteWVsbG93LTkwMDogI2Y1N2YxNztcbiAgICAgIC0tcGFwZXIteWVsbG93LWExMDA6ICNmZmZmOGQ7XG4gICAgICAtLXBhcGVyLXllbGxvdy1hMjAwOiAjZmZmZjAwO1xuICAgICAgLS1wYXBlci15ZWxsb3ctYTQwMDogI2ZmZWEwMDtcbiAgICAgIC0tcGFwZXIteWVsbG93LWE3MDA6ICNmZmQ2MDA7XG5cbiAgICAgIC0tcGFwZXItYW1iZXItNTA6ICNmZmY4ZTE7XG4gICAgICAtLXBhcGVyLWFtYmVyLTEwMDogI2ZmZWNiMztcbiAgICAgIC0tcGFwZXItYW1iZXItMjAwOiAjZmZlMDgyO1xuICAgICAgLS1wYXBlci1hbWJlci0zMDA6ICNmZmQ1NGY7XG4gICAgICAtLXBhcGVyLWFtYmVyLTQwMDogI2ZmY2EyODtcbiAgICAgIC0tcGFwZXItYW1iZXItNTAwOiAjZmZjMTA3O1xuICAgICAgLS1wYXBlci1hbWJlci02MDA6ICNmZmIzMDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLTcwMDogI2ZmYTAwMDtcbiAgICAgIC0tcGFwZXItYW1iZXItODAwOiAjZmY4ZjAwO1xuICAgICAgLS1wYXBlci1hbWJlci05MDA6ICNmZjZmMDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLWExMDA6ICNmZmU1N2Y7XG4gICAgICAtLXBhcGVyLWFtYmVyLWEyMDA6ICNmZmQ3NDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLWE0MDA6ICNmZmM0MDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLWE3MDA6ICNmZmFiMDA7XG5cbiAgICAgIC0tcGFwZXItb3JhbmdlLTUwOiAjZmZmM2UwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtMTAwOiAjZmZlMGIyO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtMjAwOiAjZmZjYzgwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtMzAwOiAjZmZiNzRkO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNDAwOiAjZmZhNzI2O1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNTAwOiAjZmY5ODAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNjAwOiAjZmI4YzAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNzAwOiAjZjU3YzAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtODAwOiAjZWY2YzAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtOTAwOiAjZTY1MTAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtYTEwMDogI2ZmZDE4MDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLWEyMDA6ICNmZmFiNDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS1hNDAwOiAjZmY5MTAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtYTcwMDogI2ZmNjUwMDtcblxuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS01MDogI2ZiZTllNztcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtMTAwOiAjZmZjY2JjO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS0yMDA6ICNmZmFiOTE7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTMwMDogI2ZmOGE2NTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtNDAwOiAjZmY3MDQzO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS01MDA6ICNmZjU3MjI7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTYwMDogI2Y0NTExZTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtNzAwOiAjZTY0YTE5O1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS04MDA6ICNkODQzMTU7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTkwMDogI2JmMzYwYztcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTEwMDogI2ZmOWU4MDtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTIwMDogI2ZmNmU0MDtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTQwMDogI2ZmM2QwMDtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTcwMDogI2RkMmMwMDtcblxuICAgICAgLS1wYXBlci1icm93bi01MDogI2VmZWJlOTtcbiAgICAgIC0tcGFwZXItYnJvd24tMTAwOiAjZDdjY2M4O1xuICAgICAgLS1wYXBlci1icm93bi0yMDA6ICNiY2FhYTQ7XG4gICAgICAtLXBhcGVyLWJyb3duLTMwMDogI2ExODg3ZjtcbiAgICAgIC0tcGFwZXItYnJvd24tNDAwOiAjOGQ2ZTYzO1xuICAgICAgLS1wYXBlci1icm93bi01MDA6ICM3OTU1NDg7XG4gICAgICAtLXBhcGVyLWJyb3duLTYwMDogIzZkNGM0MTtcbiAgICAgIC0tcGFwZXItYnJvd24tNzAwOiAjNWQ0MDM3O1xuICAgICAgLS1wYXBlci1icm93bi04MDA6ICM0ZTM0MmU7XG4gICAgICAtLXBhcGVyLWJyb3duLTkwMDogIzNlMjcyMztcblxuICAgICAgLS1wYXBlci1ncmV5LTUwOiAjZmFmYWZhO1xuICAgICAgLS1wYXBlci1ncmV5LTEwMDogI2Y1ZjVmNTtcbiAgICAgIC0tcGFwZXItZ3JleS0yMDA6ICNlZWVlZWU7XG4gICAgICAtLXBhcGVyLWdyZXktMzAwOiAjZTBlMGUwO1xuICAgICAgLS1wYXBlci1ncmV5LTQwMDogI2JkYmRiZDtcbiAgICAgIC0tcGFwZXItZ3JleS01MDA6ICM5ZTllOWU7XG4gICAgICAtLXBhcGVyLWdyZXktNjAwOiAjNzU3NTc1O1xuICAgICAgLS1wYXBlci1ncmV5LTcwMDogIzYxNjE2MTtcbiAgICAgIC0tcGFwZXItZ3JleS04MDA6ICM0MjQyNDI7XG4gICAgICAtLXBhcGVyLWdyZXktOTAwOiAjMjEyMTIxO1xuXG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS01MDogI2VjZWZmMTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTEwMDogI2NmZDhkYztcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTIwMDogI2IwYmVjNTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTMwMDogIzkwYTRhZTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTQwMDogIzc4OTA5YztcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTUwMDogIzYwN2Q4YjtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTYwMDogIzU0NmU3YTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTcwMDogIzQ1NWE2NDtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTgwMDogIzM3NDc0ZjtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTkwMDogIzI2MzIzODtcblxuICAgICAgLyogb3BhY2l0eSBmb3IgZGFyayB0ZXh0IG9uIGEgbGlnaHQgYmFja2dyb3VuZCAqL1xuICAgICAgLS1kYXJrLWRpdmlkZXItb3BhY2l0eTogMC4xMjtcbiAgICAgIC0tZGFyay1kaXNhYmxlZC1vcGFjaXR5OiAwLjM4OyAvKiBvciBoaW50IHRleHQgb3IgaWNvbiAqL1xuICAgICAgLS1kYXJrLXNlY29uZGFyeS1vcGFjaXR5OiAwLjU0O1xuICAgICAgLS1kYXJrLXByaW1hcnktb3BhY2l0eTogMC44NztcblxuICAgICAgLyogb3BhY2l0eSBmb3IgbGlnaHQgdGV4dCBvbiBhIGRhcmsgYmFja2dyb3VuZCAqL1xuICAgICAgLS1saWdodC1kaXZpZGVyLW9wYWNpdHk6IDAuMTI7XG4gICAgICAtLWxpZ2h0LWRpc2FibGVkLW9wYWNpdHk6IDAuMzsgLyogb3IgaGludCB0ZXh0IG9yIGljb24gKi9cbiAgICAgIC0tbGlnaHQtc2Vjb25kYXJ5LW9wYWNpdHk6IDAuNztcbiAgICAgIC0tbGlnaHQtcHJpbWFyeS1vcGFjaXR5OiAxLjA7XG5cbiAgICB9XG5cbiAgPC9zdHlsZT5cbjwvY3VzdG9tLXN0eWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvY29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8Y3VzdG9tLXN0eWxlPlxuICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICBodG1sIHtcblxuICAgICAgLS1zaGFkb3ctdHJhbnNpdGlvbjoge1xuICAgICAgICB0cmFuc2l0aW9uOiBib3gtc2hhZG93IDAuMjhzIGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XG4gICAgICB9O1xuXG4gICAgICAtLXNoYWRvdy1ub25lOiB7XG4gICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgICB9O1xuXG4gICAgICAvKiBmcm9tIGh0dHA6Ly9jb2RlcGVuLmlvL3NoeW5kbWFuL3Blbi9jNTM5NGRkZjJlOGIyYTVjOTE4NTkwNGI1NzQyMWNkYiAqL1xuXG4gICAgICAtLXNoYWRvdy1lbGV2YXRpb24tMmRwOiB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDJweCAwIHJnYmEoMCwgMCwgMCwgMC4xNCksXG4gICAgICAgICAgICAgICAgICAgIDAgMXB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksXG4gICAgICAgICAgICAgICAgICAgIDAgM3B4IDFweCAtMnB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICAgIH07XG5cbiAgICAgIC0tc2hhZG93LWVsZXZhdGlvbi0zZHA6IHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAzcHggNHB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgMCAxcHggOHB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCAzcHggM3B4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgfTtcblxuICAgICAgLS1zaGFkb3ctZWxldmF0aW9uLTRkcDoge1xuICAgICAgICBib3gtc2hhZG93OiAwIDRweCA1cHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLFxuICAgICAgICAgICAgICAgICAgICAwIDFweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCAycHggNHB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgfTtcblxuICAgICAgLS1zaGFkb3ctZWxldmF0aW9uLTZkcDoge1xuICAgICAgICBib3gtc2hhZG93OiAwIDZweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgMCAxcHggMThweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksXG4gICAgICAgICAgICAgICAgICAgIDAgM3B4IDVweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAgIH07XG5cbiAgICAgIC0tc2hhZG93LWVsZXZhdGlvbi04ZHA6IHtcbiAgICAgICAgYm94LXNoYWRvdzogMCA4cHggMTBweCAxcHggcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgMCAzcHggMTRweCAycHggcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCA1cHggNXB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgfTtcblxuICAgICAgLS1zaGFkb3ctZWxldmF0aW9uLTEyZHA6IHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxMnB4IDE2cHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCksXG4gICAgICAgICAgICAgICAgICAgIDAgNHB4IDIycHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xMiksXG4gICAgICAgICAgICAgICAgICAgIDAgNnB4IDdweCAtNHB4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAgIH07XG5cbiAgICAgIC0tc2hhZG93LWVsZXZhdGlvbi0xNmRwOiB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMTZweCAyNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTQpLFxuICAgICAgICAgICAgICAgICAgICAwICA2cHggMzBweCA1cHggcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCAgOHB4IDEwcHggLTVweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICB9O1xuXG4gICAgICAtLXNoYWRvdy1lbGV2YXRpb24tMjRkcDoge1xuICAgICAgICBib3gtc2hhZG93OiAwIDI0cHggMzhweCAzcHggcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgMCA5cHggNDZweCA4cHggcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCAxMXB4IDE1cHggLTdweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICB9O1xuICAgIH1cbiAgPC9zdHlsZT5cbjwvY3VzdG9tLXN0eWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvc2hhZG93LmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSAnLi4vcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IgPSB7XG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWRkZWQgdG8gYW4gYGlyb24tZm9ybWAuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1mb3JtLWVsZW1lbnQtcmVnaXN0ZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGFuIGBpcm9uLWZvcm1gLlxuICAgICAqXG4gICAgICogQGV2ZW50IGlyb24tZm9ybS1lbGVtZW50LXVucmVnaXN0ZXJcbiAgICAgKi9cbiAgICAgXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICB2YWx1ZToge1xuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIG1hcmsgdGhlIGlucHV0IGFzIHJlcXVpcmVkLiBJZiB1c2VkIGluIGEgZm9ybSwgYVxuICAgICAqIGN1c3RvbSBlbGVtZW50IHRoYXQgdXNlcyB0aGlzIGJlaGF2aW9yIHNob3VsZCBhbHNvIHVzZVxuICAgICAqIFBvbHltZXIuSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IgYW5kIGRlZmluZSBhIGN1c3RvbSB2YWxpZGF0aW9uIG1ldGhvZC5cbiAgICAgKiBPdGhlcndpc2UsIGEgYHJlcXVpcmVkYCBlbGVtZW50IHdpbGwgYWx3YXlzIGJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gICAgICogSXQncyBhbHNvIHN0cm9uZ2x5IHJlY29tbWVuZGVkIHRvIHByb3ZpZGUgYSB2aXN1YWwgc3R5bGUgZm9yIHRoZSBlbGVtZW50XG4gICAgICogd2hlbiBpdHMgdmFsdWUgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICByZXF1aXJlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybSB0aGF0IHRoZSBlbGVtZW50IGlzIHJlZ2lzdGVyZWQgdG8uXG4gICAgICovXG4gICAgX3BhcmVudEZvcm06IHtcbiAgICAgIHR5cGU6IE9iamVjdFxuICAgIH1cbiAgfSxcblxuICBhdHRhY2hlZDogRWxlbWVudCA/IG51bGwgOiBmdW5jdGlvbigpIHtcbiAgICAvLyBOb3RlOiB0aGUgaXJvbi1mb3JtIHRoYXQgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8gd2lsbCBzZXQgdGhpc1xuICAgIC8vIGVsZW1lbnQncyBfcGFyZW50Rm9ybSBwcm9wZXJ0eSB3aGVuIGhhbmRsaW5nIHRoaXMgZXZlbnQuXG4gICAgdGhpcy5maXJlKCdpcm9uLWZvcm0tZWxlbWVudC1yZWdpc3RlcicpO1xuICB9LFxuXG4gIGRldGFjaGVkOiBFbGVtZW50ID8gbnVsbCA6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnRGb3JtKSB7XG4gICAgICB0aGlzLl9wYXJlbnRGb3JtLmZpcmUoJ2lyb24tZm9ybS1lbGVtZW50LXVucmVnaXN0ZXInLCB7dGFyZ2V0OiB0aGlzfSk7XG4gICAgfVxuICB9XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbk1ldGEgfSBmcm9tICcuLi9pcm9uLW1ldGEvaXJvbi1tZXRhLmpzJztcbmV4cG9ydCBsZXQgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhID0gbnVsbDtcblxuZXhwb3J0IGNvbnN0IElyb25WYWxpZGF0YWJsZUJlaGF2aW9yID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSB2YWxpZGF0b3IgdG8gdXNlLlxuICAgICAqL1xuICAgIHZhbGlkYXRvcjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGxhc3QgY2FsbCB0byBgdmFsaWRhdGVgIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgaW52YWxpZDoge1xuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG9ic2VydmVyOiAnX2ludmFsaWRDaGFuZ2VkJ1xuICAgIH0sXG4gIH0sXG5cbiAgcmVnaXN0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhID0gbmV3IElyb25NZXRhKHt0eXBlOiAndmFsaWRhdG9yJ30pO1xuICB9LFxuXG4gIF9pbnZhbGlkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyogUmVjb21wdXRlIHRoaXMgZXZlcnkgdGltZSBpdCdzIG5lZWRlZCwgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGlmIHRoZVxuICAgKiB1bmRlcmx5aW5nIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSBoYXMgY2hhbmdlZC4gKi9cbiAgZ2V0IF92YWxpZGF0b3IoKSB7XG4gICAgcmV0dXJuIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSAmJlxuICAgICAgICBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEuYnlLZXkodGhpcy52YWxpZGF0b3IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWxpZGF0b3IgYHZhbGlkYXRvcmAgZXhpc3RzLlxuICAgKi9cbiAgaGFzVmFsaWRhdG9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWRhdG9yICE9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCwgYW5kIHVwZGF0ZXMgYGludmFsaWRgLiBJZiB5b3Ugd2FudFxuICAgKiB5b3VyIGVsZW1lbnQgdG8gaGF2ZSBjdXN0b20gdmFsaWRhdGlvbiBsb2dpYywgZG8gbm90IG92ZXJyaWRlIHRoaXMgbWV0aG9kO1xuICAgKiBvdmVycmlkZSBgX2dldFZhbGlkaXR5KHZhbHVlKWAgaW5zdGVhZC5cblxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgRGVwcmVjYXRlZDogVGhlIHZhbHVlIHRvIGJlIHZhbGlkYXRlZC4gQnkgZGVmYXVsdCxcbiAgICogaXQgaXMgcGFzc2VkIHRvIHRoZSB2YWxpZGF0b3IncyBgdmFsaWRhdGUoKWAgZnVuY3Rpb24sIGlmIGEgdmFsaWRhdG9yIGlzIHNldC5cbiAgICogSWYgdGhpcyBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHRoZSBlbGVtZW50J3MgYHZhbHVlYCBwcm9wZXJ0eVxuICAgKiBpcyB1c2VkLCBpZiBpdCBleGlzdHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC5cbiAgICovXG4gIHZhbGlkYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIElmIHRoaXMgaXMgYW4gZWxlbWVudCB0aGF0IGFsc28gaGFzIGEgdmFsdWUgcHJvcGVydHksIGFuZCB0aGVyZSB3YXNcbiAgICAvLyBubyBleHBsaWNpdCB2YWx1ZSBhcmd1bWVudCBwYXNzZWQsIHVzZSB0aGUgZWxlbWVudCdzIHByb3BlcnR5IGluc3RlYWQuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgdGhpcy5pbnZhbGlkID0gIXRoaXMuX2dldFZhbGlkaXR5KHRoaXMudmFsdWUpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuaW52YWxpZCA9ICF0aGlzLl9nZXRWYWxpZGl0eSh2YWx1ZSk7XG4gICAgcmV0dXJuICF0aGlzLmludmFsaWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLiAgQnkgZGVmYXVsdCwgaXQgaXMgcGFzc2VkXG4gICAqIHRvIHRoZSB2YWxpZGF0b3IncyBgdmFsaWRhdGUoKWAgZnVuY3Rpb24sIGlmIGEgdmFsaWRhdG9yIGlzIHNldC4gWW91XG4gICAqIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3Ugd2FudCB0byBpbXBsZW1lbnQgY3VzdG9tIHZhbGlkaXR5XG4gICAqIGxvZ2ljIGZvciB5b3VyIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdmFsaWRhdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQuXG4gICAqL1xuXG4gIF9nZXRWYWxpZGl0eTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXNWYWxpZGF0b3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvci52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBmbHVzaCB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBQYXBlcklucHV0QWRkb25CZWhhdmlvciA9IHtcbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5ZG9tL2lzc3Vlcy85NlxuICAgIGZsdXNoKCk7XG4gICAgdGhpcy5maXJlKCdhZGRvbi1hdHRhY2hlZCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIGJ5IGA8cGFwZXItaW5wdXQtY29udGFpbmVyPmAgd2hlbiB0aGUgaW5wdXQgdmFsdWUgb3IgdmFsaWRpdHkgY2hhbmdlcy5cbiAgICogQHBhcmFtIHt7XG4gICAqICAgaW5wdXRFbGVtZW50OiAoRWxlbWVudHx1bmRlZmluZWQpLFxuICAgKiAgIHZhbHVlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICAqICAgaW52YWxpZDogYm9vbGVhblxuICAgKiB9fSBzdGF0ZSAtXG4gICAqICAgICBpbnB1dEVsZW1lbnQ6IFRoZSBpbnB1dCBlbGVtZW50LlxuICAgKiAgICAgdmFsdWU6IFRoZSBpbnB1dCB2YWx1ZS5cbiAgICogICAgIGludmFsaWQ6IFRydWUgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGludmFsaWQuXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIH1cblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWlucHV0L3BhcGVyLWlucHV0LWFkZG9uLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA1MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGwsIElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciB9IGZyb20gJy4vcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBQYXBlclJpcHBsZUJlaGF2aW9yIH0gZnJvbSAnLi9wYXBlci1yaXBwbGUtYmVoYXZpb3IuanMnO1xuXG5leHBvcnQgY29uc3QgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCA9IHtcbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyB0aGUgZWxlbWVudCdzIGNoZWNrZWQgc3RhdGUgd2l0aCBpdHMgcmlwcGxlIGVmZmVjdC5cbiAgICovXG4gIF9jaGVja2VkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsLl9jaGVja2VkQ2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICBpZiAodGhpcy5jaGVja2VkKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZS5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yaXBwbGUucmVtb3ZlQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgdGhlIGVsZW1lbnQncyBgYWN0aXZlYCBhbmQgYGNoZWNrZWRgIHN0YXRlLlxuICAgKi9cbiAgX2J1dHRvblN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgUGFwZXJSaXBwbGVCZWhhdmlvci5fYnV0dG9uU3RhdGVDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gdGhpcy5hY3RpdmU7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9yID0gW1xuICBQYXBlcklua3lGb2N1c0JlaGF2aW9yLFxuICBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvcixcbiAgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbFxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDUxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudCc7XG5pbXBvcnQgXCJAcG9seW1lci9wYXBlci10b2dnbGUtYnV0dG9uL3BhcGVyLXRvZ2dsZS1idXR0b25cIjtcbmltcG9ydCB7aHRtbCwgcmVuZGVyfSBmcm9tICdsaXQtaHRtbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhY3RpbGVNb2RlIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IGlzKCkge1xuICAgIHJldHVybiBcInRhY3RpbGUtbW9kZVwiO1xuICB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICByZXR1cm4gXCI8cGFwZXItdG9nZ2xlLWJ1dHRvbj5FZGl0PC9wYXBlci10b2dnbGUtYnV0dG9uPlwiO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLnRvZ2dsZSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwicGFwZXItdG9nZ2xlLWJ1dHRvblwiKTtcblxuICAgIHRoaXMudG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoXCJpcm9uLWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy50b2dnbGUuY2hlY2tlZCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdzd2l0Y2hlZC10by1lZGl0JykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc3dpdGNoZWQtdG8tcHVibGlzaCcpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN3aXRjaFRvRWRpdCgpIHtcbiAgICB0aGlzLnRvZ2dsZS5jaGVja2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHN3aXRjaFRvUHVibGlzaCgpIHtcbiAgICB0aGlzLnRvZ2dsZS5jaGVja2VkID0gZmFsc2U7XG4gIH1cblxuICBnZXQgbW9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy50b2dnbGUuY2hlY2tlZDtcbiAgfVxufVxuXG4vLyBSZWdpc3RlciBjdXN0b20gZWxlbWVudCBjbGFzcyB3aXRoIGJyb3dzZXJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZShUYWN0aWxlTW9kZS5pcywgVGFjdGlsZU1vZGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdGFjdGlsZS9jbGllbnQvdGFjdGlsZS1tb2RlLmpzIiwiaW1wb3J0IFwiQHBvbHltZXIvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZVwiO1xuaW1wb3J0IFwiLi90YWN0aWxlLWVkaXRhYmxlLmpzXCI7XG5pbXBvcnQgXCIuL3RhY3RpbGUtbW9kZS5qc1wiO1xuXG5mdW5jdGlvbiB3YXRjaEZvckNvbXBvbmVudENsaWNrcyhldmVudCkge1xuICAvLyBUaGlzIHN0b3BzIHVzZXIgZnJvbSBpbnRlcmFjdGluZyB3aXRoIHBhZ2UgaW4gYXV0aG9yIG1vZGVcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgdmFyIGNvbXBvbmVudCA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFwidGFjdGlsZS1lZGl0YWJsZVwiKTtcbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudC5vcGVuRGlhbG9nKHdhdGNoRm9yQ29tcG9uZW50Q2xpY2tzKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgd2F0Y2hGb3JDb21wb25lbnRDbGlja3MpO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIHdhdGNoRm9yQ29tcG9uZW50Q2xpY2tzKGV2ZW50KSB7XG4gIC8vIFRoaXMgc3RvcHMgdXNlciBmcm9tIGludGVyYWN0aW5nIHdpdGggcGFnZSBpbiBhdXRob3IgbW9kZVxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICB2YXIgdGFjdGlsZUVkaXRhYmxlID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoXCJ0YWN0aWxlLWVkaXRhYmxlXCIpO1xuICBpZiAodGFjdGlsZUVkaXRhYmxlKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHdhdGNoRm9yQ29tcG9uZW50Q2xpY2tzKTtcblxuICAgIHRhY3RpbGVFZGl0YWJsZS5vcGVuRGlhbG9nKGZ1bmN0aW9uKHJlcXVpcmVzUmVmcmVzaCA9IHRydWUpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB3YXRjaEZvckNvbXBvbmVudENsaWNrcyk7XG5cbiAgICAgIC8vIFRPRE8ganVzdCByZWxvYWQgdGhlIGNvbXBvbmVudCwgbm90IHRoZSBlbnRpcmUgcGFnZS5cbiAgICAgIGlmIChyZXF1aXJlc1JlZnJlc2gpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzZXR1cEVkaXRNb2RlKCkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgd2F0Y2hGb3JDb21wb25lbnRDbGlja3MpO1xuICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJlZGl0XCIpO1xuICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcInRhY3RpbGUtbW9kZVwiLCBcImVkaXRcIik7XG59XG5cbmZ1bmN0aW9uIHNldHVwUHVibGlzaE1vZGUoKSB7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB3YXRjaEZvckNvbXBvbmVudENsaWNrcyk7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImVkaXRcIik7XG4gIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwidGFjdGlsZS1tb2RlXCIsIFwicHVibGlzaFwiKTtcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKGV2ZW50KSA9PiB7XG4gIGlmIChkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZWRpdCcpKSB7XG4gICAgdmFyIHRhY3RpbGVNb2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRhY3RpbGUtbW9kZVwiKTtcblxuICAgIHRhY3RpbGVNb2RlLmFkZEV2ZW50TGlzdGVuZXIoXCJzd2l0Y2hlZC10by1lZGl0XCIsICgpID0+IHtcbiAgICAgIHNldHVwRWRpdE1vZGUoKTtcbiAgICB9KTtcbiAgICB0YWN0aWxlTW9kZS5hZGRFdmVudExpc3RlbmVyKFwic3dpdGNoZWQtdG8tcHVibGlzaFwiLCAoKSA9PiB7XG4gICAgICBzZXR1cFB1Ymxpc2hNb2RlKCk7XG4gICAgfSk7XG5cbiAgICB2YXIgbW9kZSA9IHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5nZXRJdGVtKFwidGFjdGlsZS1tb2RlXCIpO1xuICAgIGlmIChtb2RlID09PSBcImVkaXRcIikge1xuICAgICAgdGFjdGlsZU1vZGUuc3dpdGNoVG9FZGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhY3RpbGVNb2RlLnN3aXRjaFRvUHVibGlzaCgpO1xuICAgIH1cbiAgfVxufSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi90YWN0aWxlL2NsaWVudC9hdXRob3IuanMiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBBcHBseVNoaW0gZnJvbSAnLi4vc3JjL2FwcGx5LXNoaW0uanMnO1xuaW1wb3J0IHRlbXBsYXRlTWFwIGZyb20gJy4uL3NyYy90ZW1wbGF0ZS1tYXAuanMnO1xuaW1wb3J0IHtnZXRJc0V4dGVuZHMsIHRvQ3NzVGV4dH0gZnJvbSAnLi4vc3JjL3N0eWxlLXV0aWwuanMnO1xuaW1wb3J0ICogYXMgQXBwbHlTaGltVXRpbHMgZnJvbSAnLi4vc3JjL2FwcGx5LXNoaW0tdXRpbHMuanMnO1xuaW1wb3J0IGRvY3VtZW50V2FpdCBmcm9tICcuLi9zcmMvZG9jdW1lbnQtd2FpdC5qcyc7XG5pbXBvcnQge2dldENvbXB1dGVkU3R5bGVWYWx1ZSwgdXBkYXRlTmF0aXZlUHJvcGVydGllc30gZnJvbSAnLi4vc3JjL2NvbW1vbi11dGlscy5qcyc7XG5pbXBvcnQge0N1c3RvbVN0eWxlSW50ZXJmYWNlSW50ZXJmYWNlfSBmcm9tICcuLi9zcmMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCB7bmF0aXZlQ3NzVmFyaWFibGVzLCBuYXRpdmVTaGFkb3d9IGZyb20gJy4uL3NyYy9zdHlsZS1zZXR0aW5ncy5qcyc7XG5cbi8qKiBAY29uc3Qge0FwcGx5U2hpbX0gKi9cbmNvbnN0IGFwcGx5U2hpbSA9IG5ldyBBcHBseVNoaW0oKTtcblxuY2xhc3MgQXBwbHlTaGltSW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHs/Q3VzdG9tU3R5bGVJbnRlcmZhY2VJbnRlcmZhY2V9ICovXG4gICAgdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZSA9IG51bGw7XG4gICAgZG9jdW1lbnRXYWl0KCgpID0+IHtcbiAgICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgfSk7XG4gICAgYXBwbHlTaGltWydpbnZhbGlkQ2FsbGJhY2snXSA9IEFwcGx5U2hpbVV0aWxzLmludmFsaWRhdGU7XG4gIH1cbiAgZW5zdXJlKCkge1xuICAgIGlmICh0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2UgPSB3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U7XG4gICAgaWYgKHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2UpIHtcbiAgICAgIHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ3RyYW5zZm9ybUNhbGxiYWNrJ10gPSAoc3R5bGUpID0+IHtcbiAgICAgICAgYXBwbHlTaGltLnRyYW5zZm9ybUN1c3RvbVN0eWxlKHN0eWxlKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWyd2YWxpZGF0ZUNhbGxiYWNrJ10gPSAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ2VucXVldWVkJ10pIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAqL1xuICBwcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lKSB7XG4gICAgdGhpcy5lbnN1cmUoKTtcbiAgICB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV0gPSB0ZW1wbGF0ZTtcbiAgICBsZXQgYXN0ID0gYXBwbHlTaGltLnRyYW5zZm9ybVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSk7XG4gICAgLy8gc2F2ZSBvcmlnaW5hbCBzdHlsZSBhc3QgdG8gdXNlIGZvciByZXZhbGlkYXRpbmcgaW5zdGFuY2VzXG4gICAgdGVtcGxhdGVbJ19zdHlsZUFzdCddID0gYXN0O1xuICB9XG4gIGZsdXNoQ3VzdG9tU3R5bGVzKCkge1xuICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgaWYgKCF0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBzdHlsZXMgPSB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWydwcm9jZXNzU3R5bGVzJ10oKTtcbiAgICBpZiAoIXRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ2VucXVldWVkJ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICBsZXQgY3MgPSBzdHlsZXNbaV07XG4gICAgICBsZXQgc3R5bGUgPSB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWydnZXRTdHlsZUZvckN1c3RvbVN0eWxlJ10oY3MpO1xuICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgIGFwcGx5U2hpbS50cmFuc2Zvcm1DdXN0b21TdHlsZShzdHlsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ2VucXVldWVkJ10gPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICovXG4gIHN0eWxlU3VidHJlZShlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5lbnN1cmUoKTtcbiAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgdXBkYXRlTmF0aXZlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuc2hhZG93Um9vdCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICBsZXQgc2hhZG93Q2hpbGRyZW4gPSBlbGVtZW50LnNoYWRvd1Jvb3QuY2hpbGRyZW4gfHwgZWxlbWVudC5zaGFkb3dSb290LmNoaWxkTm9kZXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNoYWRvd0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc3R5bGVTdWJ0cmVlKC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKHNoYWRvd0NoaWxkcmVuW2ldKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBjaGlsZHJlbiA9IGVsZW1lbnQuY2hpbGRyZW4gfHwgZWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnN0eWxlU3VidHJlZSgvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhjaGlsZHJlbltpXSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgc3R5bGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICB0aGlzLmVuc3VyZSgpO1xuICAgIGxldCB7aXN9ID0gZ2V0SXNFeHRlbmRzKGVsZW1lbnQpO1xuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2lzXTtcbiAgICBpZiAodGVtcGxhdGUgJiYgIUFwcGx5U2hpbVV0aWxzLnRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSkpIHtcbiAgICAgIC8vIG9ubHkgcmV2YWxpZGF0ZSB0ZW1wbGF0ZSBvbmNlXG4gICAgICBpZiAoIUFwcGx5U2hpbVV0aWxzLnRlbXBsYXRlSXNWYWxpZGF0aW5nKHRlbXBsYXRlKSkge1xuICAgICAgICB0aGlzLnByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgaXMpO1xuICAgICAgICBBcHBseVNoaW1VdGlscy5zdGFydFZhbGlkYXRpbmdUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICB9XG4gICAgICAvLyB1cGRhdGUgdGhpcyBlbGVtZW50IGluc3RhbmNlXG4gICAgICBsZXQgcm9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdDtcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIGxldCBzdHlsZSA9IC8qKiBAdHlwZSB7SFRNTFN0eWxlRWxlbWVudH0gKi8ocm9vdC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKTtcbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgLy8gcmV1c2UgdGhlIHRlbXBsYXRlJ3Mgc3R5bGUgYXN0LCBpdCBoYXMgYWxsIHRoZSBvcmlnaW5hbCBjc3MgdGV4dFxuICAgICAgICAgIHN0eWxlWydfX2Nzc1J1bGVzJ10gPSB0ZW1wbGF0ZVsnX3N0eWxlQXN0J107XG4gICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSB0b0Nzc1RleHQodGVtcGxhdGVbJ19zdHlsZUFzdCddKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICovXG4gIHN0eWxlRG9jdW1lbnQocHJvcGVydGllcykge1xuICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgdGhpcy5zdHlsZVN1YnRyZWUoZG9jdW1lbnQuYm9keSwgcHJvcGVydGllcyk7XG4gIH1cbn1cblxuaWYgKCF3aW5kb3cuU2hhZHlDU1MgfHwgIXdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbSkge1xuICBjb25zdCBhcHBseVNoaW1JbnRlcmZhY2UgPSBuZXcgQXBwbHlTaGltSW50ZXJmYWNlKCk7XG4gIGxldCBDdXN0b21TdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUyAmJiB3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U7XG5cbiAgd2luZG93LlNoYWR5Q1NTID0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbGVtZW50RXh0ZW5kc1xuICAgICAqL1xuICAgIHByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUsIGVsZW1lbnRFeHRlbmRzKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLnByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc3R5bGVTdWJ0cmVlKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLnN0eWxlU3VidHJlZShlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBzdHlsZUVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2Uuc3R5bGVFbGVtZW50KGVsZW1lbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdHlsZURvY3VtZW50KHByb3BlcnRpZXMpIHtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLnN0eWxlRG9jdW1lbnQocHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpO1xuICAgIH0sXG4gICAgbmF0aXZlQ3NzOiBuYXRpdmVDc3NWYXJpYWJsZXMsXG4gICAgbmF0aXZlU2hhZG93OiBuYXRpdmVTaGFkb3dcbiAgfTtcblxuICBpZiAoQ3VzdG9tU3R5bGVJbnRlcmZhY2UpIHtcbiAgICB3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2UgPSBDdXN0b21TdHlsZUludGVyZmFjZTtcbiAgfVxufVxuXG53aW5kb3cuU2hhZHlDU1MuQXBwbHlTaGltID0gYXBwbHlTaGltO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2FwcGx5LXNoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG4vKlxuICogVGhlIGFwcGx5IHNoaW0gc2ltdWxhdGVzIHRoZSBiZWhhdmlvciBvZiBgQGFwcGx5YCBwcm9wb3NlZCBhdFxuICogaHR0cHM6Ly90YWJhdGtpbnMuZ2l0aHViLmlvL3NwZWNzL2Nzcy1hcHBseS1ydWxlLy5cbiAqIFRoZSBhcHByb2FjaCBpcyB0byBjb252ZXJ0IGEgcHJvcGVydHkgbGlrZSB0aGlzOlxuICpcbiAqICAgIC0tZm9vOiB7Y29sb3I6IHJlZDsgYmFja2dyb3VuZDogYmx1ZTt9XG4gKlxuICogdG8gdGhpczpcbiAqXG4gKiAgICAtLWZvb18tX2NvbG9yOiByZWQ7XG4gKiAgICAtLWZvb18tX2JhY2tncm91bmQ6IGJsdWU7XG4gKlxuICogVGhlbiB3aGVyZSBgQGFwcGx5IC0tZm9vYCBpcyB1c2VkLCB0aGF0IGlzIGNvbnZlcnRlZCB0bzpcbiAqXG4gKiAgICBjb2xvcjogdmFyKC0tZm9vXy1fY29sb3IpO1xuICogICAgYmFja2dyb3VuZDogdmFyKC0tZm9vXy1fYmFja2dyb3VuZCk7XG4gKlxuICogVGhpcyBhcHByb2FjaCBnZW5lcmFsbHkgd29ya3MgYnV0IHRoZXJlIGFyZSBzb21lIGlzc3VlcyBhbmQgbGltaXRhdGlvbnMuXG4gKiBDb25zaWRlciwgZm9yIGV4YW1wbGUsIHRoYXQgc29tZXdoZXJlICpiZXR3ZWVuKiB3aGVyZSBgLS1mb29gIGlzIHNldCBhbmQgdXNlZCxcbiAqIGFub3RoZXIgZWxlbWVudCBzZXRzIGl0IHRvOlxuICpcbiAqICAgIC0tZm9vOiB7IGJvcmRlcjogMnB4IHNvbGlkIHJlZDsgfVxuICpcbiAqIFdlIG11c3Qgbm93IGVuc3VyZSB0aGF0IHRoZSBjb2xvciBhbmQgYmFja2dyb3VuZCBmcm9tIHRoZSBwcmV2aW91cyBzZXR0aW5nXG4gKiBkbyBub3QgYXBwbHkuIFRoaXMgaXMgYWNjb21wbGlzaGVkIGJ5IGNoYW5naW5nIHRoZSBwcm9wZXJ0eSBzZXQgdG8gdGhpczpcbiAqXG4gKiAgICAtLWZvb18tX2JvcmRlcjogMnB4IHNvbGlkIHJlZDtcbiAqICAgIC0tZm9vXy1fY29sb3I6IGluaXRpYWw7XG4gKiAgICAtLWZvb18tX2JhY2tncm91bmQ6IGluaXRpYWw7XG4gKlxuICogVGhpcyB3b3JrcyBidXQgaW50cm9kdWNlcyBvbmUgbmV3IGlzc3VlLlxuICogQ29uc2lkZXIgdGhpcyBzZXR1cCBhdCB0aGUgcG9pbnQgd2hlcmUgdGhlIGBAYXBwbHlgIGlzIHVzZWQ6XG4gKlxuICogICAgYmFja2dyb3VuZDogb3JhbmdlO1xuICogICAgYEBhcHBseWAgLS1mb287XG4gKlxuICogSW4gdGhpcyBjYXNlIHRoZSBiYWNrZ3JvdW5kIHdpbGwgYmUgdW5zZXQgKGluaXRpYWwpIHJhdGhlciB0aGFuIHRoZSBkZXNpcmVkXG4gKiBgb3JhbmdlYC4gV2UgYWRkcmVzcyB0aGlzIGJ5IGFsdGVyaW5nIHRoZSBwcm9wZXJ0eSBzZXQgdG8gdXNlIGEgZmFsbGJhY2tcbiAqIHZhbHVlIGxpa2UgdGhpczpcbiAqXG4gKiAgICBjb2xvcjogdmFyKC0tZm9vXy1fY29sb3IpO1xuICogICAgYmFja2dyb3VuZDogdmFyKC0tZm9vXy1fYmFja2dyb3VuZCwgb3JhbmdlKTtcbiAqICAgIGJvcmRlcjogdmFyKC0tZm9vXy1fYm9yZGVyKTtcbiAqXG4gKiBOb3RlIHRoYXQgdGhlIGRlZmF1bHQgaXMgcmV0YWluZWQgaW4gdGhlIHByb3BlcnR5IHNldCBhbmQgdGhlIGBiYWNrZ3JvdW5kYCBpc1xuICogdGhlIGRlc2lyZWQgYG9yYW5nZWAuIFRoaXMgbGVhZHMgdXMgdG8gYSBsaW1pdGF0aW9uLlxuICpcbiAqIExpbWl0YXRpb24gMTpcblxuICogT25seSBwcm9wZXJ0aWVzIGluIHRoZSBydWxlIHdoZXJlIHRoZSBgQGFwcGx5YFxuICogaXMgdXNlZCBhcmUgY29uc2lkZXJlZCBhcyBkZWZhdWx0IHZhbHVlcy5cbiAqIElmIGFub3RoZXIgcnVsZSBtYXRjaGVzIHRoZSBlbGVtZW50IGFuZCBzZXRzIGBiYWNrZ3JvdW5kYCB3aXRoXG4gKiBsZXNzIHNwZWNpZmljaXR5IHRoYW4gdGhlIHJ1bGUgaW4gd2hpY2ggYEBhcHBseWAgYXBwZWFycyxcbiAqIHRoZSBgYmFja2dyb3VuZGAgd2lsbCBub3QgYmUgc2V0LlxuICpcbiAqIExpbWl0YXRpb24gMjpcbiAqXG4gKiBXaGVuIHVzaW5nIFBvbHltZXIncyBgdXBkYXRlU3R5bGVzYCBhcGksIG5ldyBwcm9wZXJ0aWVzIG1heSBub3QgYmUgc2V0IGZvclxuICogYEBhcHBseWAgcHJvcGVydGllcy5cblxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge2ZvckVhY2hSdWxlLCBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjaywgcnVsZXNGb3JTdHlsZSwgdG9Dc3NUZXh0LCBnYXRoZXJTdHlsZVRleHR9IGZyb20gJy4vc3R5bGUtdXRpbC5qcyc7XG5pbXBvcnQge01JWElOX01BVENILCBWQVJfQVNTSUdOfSBmcm9tICcuL2NvbW1vbi1yZWdleC5qcyc7XG5pbXBvcnQge2RldGVjdE1peGlufSBmcm9tICcuL2NvbW1vbi11dGlscy5qcyc7XG5pbXBvcnQge1N0eWxlTm9kZX0gZnJvbSAnLi9jc3MtcGFyc2UuanMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmNvbnN0IEFQUExZX05BTUVfQ0xFQU4gPSAvO1xccyovbTtcbmNvbnN0IElOSVRJQUxfSU5IRVJJVCA9IC9eXFxzKihpbml0aWFsKXwoaW5oZXJpdClcXHMqJC87XG5cbi8vIHNlcGFyYXRvciB1c2VkIGJldHdlZW4gbWl4aW4tbmFtZSBhbmQgbWl4aW4tcHJvcGVydHktbmFtZSB3aGVuIHByb2R1Y2luZyBwcm9wZXJ0aWVzXG4vLyBOT1RFOiBwbGFpbiAnLScgbWF5IGNhdXNlIGNvbGxpc2lvbnMgaW4gdXNlciBzdHlsZXNcbmNvbnN0IE1JWElOX1ZBUl9TRVAgPSAnXy1fJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gKi9cbmxldCBQcm9wZXJ0eUVudHJ5OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogQHR5cGVkZWYgeyFPYmplY3Q8c3RyaW5nLCBib29sZWFuPn1cbiAqL1xubGV0IERlcGVuZGFudHNFbnRyeTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKiogQHR5cGVkZWYge3tcbiAqICAgIHByb3BlcnRpZXM6IFByb3BlcnR5RW50cnksXG4gKiAgICBkZXBlbmRhbnRzOiBEZXBlbmRhbnRzRW50cnlcbiAqIH19XG4gKi9cbmxldCBNaXhpbk1hcEVudHJ5OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8vIG1hcCBvZiBtaXhpbiB0byBwcm9wZXJ0eSBuYW1lc1xuLy8gLS1mb286IHtib3JkZXI6IDJweH0gLT4ge3Byb3BlcnRpZXM6IHsoLS1mb28sIFsnYm9yZGVyJ10pfSwgZGVwZW5kYW50czogeydlbGVtZW50LW5hbWUnOiBwcm90b319XG5jbGFzcyBNaXhpbk1hcCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFNaXhpbk1hcEVudHJ5Pn0gKi9cbiAgICB0aGlzLl9tYXAgPSB7fTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHshUHJvcGVydHlFbnRyeX0gcHJvcHNcbiAgICovXG4gIHNldChuYW1lLCBwcm9wcykge1xuICAgIG5hbWUgPSBuYW1lLnRyaW0oKTtcbiAgICB0aGlzLl9tYXBbbmFtZV0gPSB7XG4gICAgICBwcm9wZXJ0aWVzOiBwcm9wcyxcbiAgICAgIGRlcGVuZGFudHM6IHt9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHtNaXhpbk1hcEVudHJ5fVxuICAgKi9cbiAgZ2V0KG5hbWUpIHtcbiAgICBuYW1lID0gbmFtZS50cmltKCk7XG4gICAgcmV0dXJuIHRoaXMuX21hcFtuYW1lXSB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIHdoZW4gYW4gZWxlbWVudCBpcyBtYXJrZWQgaW52YWxpZFxuICogQHR5cGUgez9mdW5jdGlvbihzdHJpbmcpfVxuICovXG5sZXQgaW52YWxpZENhbGxiYWNrID0gbnVsbDtcblxuLyoqIEB1bnJlc3RyaWN0ZWQgKi9cbmNsYXNzIEFwcGx5U2hpbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7P3N0cmluZ30gKi9cbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtIVE1MTWV0YUVsZW1lbnR9ICovXG4gICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuX21hcCA9IG5ldyBNaXhpbk1hcCgpO1xuICB9XG4gIC8qKlxuICAgKiByZXR1cm4gdHJ1ZSBpZiBgY3NzVGV4dGAgY29udGFpbnMgYSBtaXhpbiBkZWZpbml0aW9uIG9yIGNvbnN1bXB0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBkZXRlY3RNaXhpbihjc3NUZXh0KSB7XG4gICAgcmV0dXJuIGRldGVjdE1peGluKGNzc1RleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdhdGhlciBzdHlsZXMgaW50byBvbmUgc3R5bGUgZm9yIGVhc2llciBwcm9jZXNzaW5nXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9XG4gICAqL1xuICBnYXRoZXJTdHlsZXModGVtcGxhdGUpIHtcbiAgICBjb25zdCBzdHlsZVRleHQgPSBnYXRoZXJTdHlsZVRleHQodGVtcGxhdGUuY29udGVudCk7XG4gICAgaWYgKHN0eWxlVGV4dCkge1xuICAgICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUgeyFIVE1MU3R5bGVFbGVtZW50fSAqLyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gc3R5bGVUZXh0O1xuICAgICAgdGVtcGxhdGUuY29udGVudC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRlbXBsYXRlLmNvbnRlbnQuZmlyc3RDaGlsZCk7XG4gICAgICByZXR1cm4gc3R5bGU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICogQHJldHVybiB7U3R5bGVOb2RlfVxuICAgKi9cbiAgdHJhbnNmb3JtVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lKSB7XG4gICAgaWYgKHRlbXBsYXRlLl9nYXRoZXJlZFN0eWxlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRlbXBsYXRlLl9nYXRoZXJlZFN0eWxlID0gdGhpcy5nYXRoZXJTdHlsZXModGVtcGxhdGUpO1xuICAgIH1cbiAgICAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovXG4gICAgY29uc3Qgc3R5bGUgPSB0ZW1wbGF0ZS5fZ2F0aGVyZWRTdHlsZTtcbiAgICByZXR1cm4gc3R5bGUgPyB0aGlzLnRyYW5zZm9ybVN0eWxlKHN0eWxlLCBlbGVtZW50TmFtZSkgOiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICogQHJldHVybiB7U3R5bGVOb2RlfVxuICAgKi9cbiAgdHJhbnNmb3JtU3R5bGUoc3R5bGUsIGVsZW1lbnROYW1lID0gJycpIHtcbiAgICBsZXQgYXN0ID0gcnVsZXNGb3JTdHlsZShzdHlsZSk7XG4gICAgdGhpcy50cmFuc2Zvcm1SdWxlcyhhc3QsIGVsZW1lbnROYW1lKTtcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRvQ3NzVGV4dChhc3QpO1xuICAgIHJldHVybiBhc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gICAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAgICovXG4gIHRyYW5zZm9ybUN1c3RvbVN0eWxlKHN0eWxlKSB7XG4gICAgbGV0IGFzdCA9IHJ1bGVzRm9yU3R5bGUoc3R5bGUpO1xuICAgIGZvckVhY2hSdWxlKGFzdCwgKHJ1bGUpID0+IHtcbiAgICAgIGlmIChydWxlWydzZWxlY3RvciddID09PSAnOnJvb3QnKSB7XG4gICAgICAgIHJ1bGVbJ3NlbGVjdG9yJ10gPSAnaHRtbCc7XG4gICAgICB9XG4gICAgICB0aGlzLnRyYW5zZm9ybVJ1bGUocnVsZSk7XG4gICAgfSlcbiAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRvQ3NzVGV4dChhc3QpO1xuICAgIHJldHVybiBhc3Q7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3R5bGVOb2RlfSBydWxlc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICovXG4gIHRyYW5zZm9ybVJ1bGVzKHJ1bGVzLCBlbGVtZW50TmFtZSkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudE5hbWU7XG4gICAgZm9yRWFjaFJ1bGUocnVsZXMsIChyKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zZm9ybVJ1bGUocik7XG4gICAgfSk7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFTdHlsZU5vZGV9IHJ1bGVcbiAgICovXG4gIHRyYW5zZm9ybVJ1bGUocnVsZSkge1xuICAgIHJ1bGVbJ2Nzc1RleHQnXSA9IHRoaXMudHJhbnNmb3JtQ3NzVGV4dChydWxlWydwYXJzZWRDc3NUZXh0J10pO1xuICAgIC8vIDpyb290IHdhcyBvbmx5IHVzZWQgZm9yIHZhcmlhYmxlIGFzc2lnbm1lbnQgaW4gcHJvcGVydHkgc2hpbSxcbiAgICAvLyBidXQgZ2VuZXJhdGVzIGludmFsaWQgc2VsZWN0b3JzIHdpdGggcmVhbCBwcm9wZXJ0aWVzLlxuICAgIC8vIHJlcGxhY2Ugd2l0aCBgOmhvc3QgPiAqYCwgd2hpY2ggc2VydmVzIHRoZSBzYW1lIGVmZmVjdFxuICAgIGlmIChydWxlWydzZWxlY3RvciddID09PSAnOnJvb3QnKSB7XG4gICAgICBydWxlWydzZWxlY3RvciddID0gJzpob3N0ID4gKic7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICB0cmFuc2Zvcm1Dc3NUZXh0KGNzc1RleHQpIHtcbiAgICAvLyBwcm9kdWNlIHZhcmlhYmxlc1xuICAgIGNzc1RleHQgPSBjc3NUZXh0LnJlcGxhY2UoVkFSX0FTU0lHTiwgKG1hdGNoVGV4dCwgcHJvcGVydHlOYW1lLCB2YWx1ZVByb3BlcnR5LCB2YWx1ZU1peGluKSA9PlxuICAgICAgdGhpcy5fcHJvZHVjZUNzc1Byb3BlcnRpZXMobWF0Y2hUZXh0LCBwcm9wZXJ0eU5hbWUsIHZhbHVlUHJvcGVydHksIHZhbHVlTWl4aW4pKTtcbiAgICAvLyBjb25zdW1lIG1peGluc1xuICAgIHJldHVybiB0aGlzLl9jb25zdW1lQ3NzUHJvcGVydGllcyhjc3NUZXh0KTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9nZXRJbml0aWFsVmFsdWVGb3JQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgIGlmICghdGhpcy5fbWVhc3VyZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX21lYXN1cmVFbGVtZW50ID0gLyoqIEB0eXBlIHtIVE1MTWV0YUVsZW1lbnR9ICovKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ21ldGEnKSk7XG4gICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FwcGx5LXNoaW0tbWVhc3VyZScsICcnKTtcbiAgICAgIHRoaXMuX21lYXN1cmVFbGVtZW50LnN0eWxlLmFsbCA9ICdpbml0aWFsJztcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGhpcy5fbWVhc3VyZUVsZW1lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5fbWVhc3VyZUVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICB9XG4gIC8qKlxuICAgKiByZXBsYWNlIG1peGluIGNvbnN1bXB0aW9uIHdpdGggdmFyaWFibGUgY29uc3VtcHRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX2NvbnN1bWVDc3NQcm9wZXJ0aWVzKHRleHQpIHtcbiAgICAvKiogQHR5cGUge0FycmF5fSAqL1xuICAgIGxldCBtID0gbnVsbDtcbiAgICAvLyBsb29wIG92ZXIgdGV4dCB1bnRpbCBhbGwgbWl4aW5zIHdpdGggZGVmaW50aW9ucyBoYXZlIGJlZW4gYXBwbGllZFxuICAgIHdoaWxlKChtID0gTUlYSU5fTUFUQ0guZXhlYyh0ZXh0KSkpIHtcbiAgICAgIGxldCBtYXRjaFRleHQgPSBtWzBdO1xuICAgICAgbGV0IG1peGluTmFtZSA9IG1bMV07XG4gICAgICBsZXQgaWR4ID0gbS5pbmRleDtcbiAgICAgIC8vIGNvbGxlY3QgcHJvcGVydGllcyBiZWZvcmUgYXBwbHkgdG8gYmUgXCJkZWZhdWx0c1wiIGlmIG1peGluIG1pZ2h0IG92ZXJyaWRlIHRoZW1cbiAgICAgIC8vIG1hdGNoIGluY2x1ZGVzIGEgXCJwcmVmaXhcIiwgc28gZmluZCB0aGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvbnMgb2YgQGFwcGx5XG4gICAgICBsZXQgYXBwbHlQb3MgPSBpZHggKyBtYXRjaFRleHQuaW5kZXhPZignQGFwcGx5Jyk7XG4gICAgICBsZXQgYWZ0ZXJBcHBseVBvcyA9IGlkeCArIG1hdGNoVGV4dC5sZW5ndGg7XG4gICAgICAvLyBmaW5kIHByb3BzIGRlZmluZWQgYmVmb3JlIHRoaXMgQGFwcGx5XG4gICAgICBsZXQgdGV4dEJlZm9yZUFwcGx5ID0gdGV4dC5zbGljZSgwLCBhcHBseVBvcyk7XG4gICAgICBsZXQgdGV4dEFmdGVyQXBwbHkgPSB0ZXh0LnNsaWNlKGFmdGVyQXBwbHlQb3MpO1xuICAgICAgbGV0IGRlZmF1bHRzID0gdGhpcy5fY3NzVGV4dFRvTWFwKHRleHRCZWZvcmVBcHBseSk7XG4gICAgICBsZXQgcmVwbGFjZW1lbnQgPSB0aGlzLl9hdEFwcGx5VG9Dc3NQcm9wZXJ0aWVzKG1peGluTmFtZSwgZGVmYXVsdHMpO1xuICAgICAgLy8gdXNlIHJlZ2V4IG1hdGNoIHBvc2l0aW9uIHRvIHJlcGxhY2UgbWl4aW4sIGtlZXAgbGluZWFyIHByb2Nlc3NpbmcgdGltZVxuICAgICAgdGV4dCA9IGAke3RleHRCZWZvcmVBcHBseX0ke3JlcGxhY2VtZW50fSR7dGV4dEFmdGVyQXBwbHl9YDtcbiAgICAgIC8vIG1vdmUgcmVnZXggc2VhcmNoIHRvIF9hZnRlcl8gcmVwbGFjZW1lbnRcbiAgICAgIE1JWElOX01BVENILmxhc3RJbmRleCA9IGlkeCArIHJlcGxhY2VtZW50Lmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cbiAgLyoqXG4gICAqIHByb2R1Y2UgdmFyaWFibGUgY29uc3VtcHRpb24gYXQgdGhlIHNpdGUgb2YgbWl4aW4gY29uc3VtcHRpb25cbiAgICogYEBhcHBseWAgLS1mb287IC0+IGZvciBhbGwgcHJvcHMgKCR7cHJvcG5hbWV9OiB2YXIoLS1mb29fLV8ke3Byb3BuYW1lfSwgJHtmYWxsYmFja1twcm9wbmFtZV19fSkpXG4gICAqIEV4YW1wbGU6XG4gICAqICBib3JkZXI6IHZhcigtLWZvb18tX2JvcmRlcik7IHBhZGRpbmc6IHZhcigtLWZvb18tX3BhZGRpbmcsIDJweClcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1peGluTmFtZVxuICAgKiBAcGFyYW0ge09iamVjdH0gZmFsbGJhY2tzXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9hdEFwcGx5VG9Dc3NQcm9wZXJ0aWVzKG1peGluTmFtZSwgZmFsbGJhY2tzKSB7XG4gICAgbWl4aW5OYW1lID0gbWl4aW5OYW1lLnJlcGxhY2UoQVBQTFlfTkFNRV9DTEVBTiwgJycpO1xuICAgIGxldCB2YXJzID0gW107XG4gICAgbGV0IG1peGluRW50cnkgPSB0aGlzLl9tYXAuZ2V0KG1peGluTmFtZSk7XG4gICAgLy8gaWYgd2UgZGVwZW5kIG9uIGEgbWl4aW4gYmVmb3JlIGl0IGlzIGNyZWF0ZWRcbiAgICAvLyBtYWtlIGEgc2VudGluZWwgZW50cnkgaW4gdGhlIG1hcCB0byBhZGQgdGhpcyBlbGVtZW50IGFzIGEgZGVwZW5kZW5jeSBmb3Igd2hlbiBpdCBpcyBkZWZpbmVkLlxuICAgIGlmICghbWl4aW5FbnRyeSkge1xuICAgICAgdGhpcy5fbWFwLnNldChtaXhpbk5hbWUsIHt9KTtcbiAgICAgIG1peGluRW50cnkgPSB0aGlzLl9tYXAuZ2V0KG1peGluTmFtZSk7XG4gICAgfVxuICAgIGlmIChtaXhpbkVudHJ5KSB7XG4gICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgbWl4aW5FbnRyeS5kZXBlbmRhbnRzW3RoaXMuX2N1cnJlbnRFbGVtZW50XSA9IHRydWU7XG4gICAgICB9XG4gICAgICBsZXQgcCwgcGFydHMsIGY7XG4gICAgICBmb3IgKHAgaW4gbWl4aW5FbnRyeS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgIGYgPSBmYWxsYmFja3MgJiYgZmFsbGJhY2tzW3BdO1xuICAgICAgICBwYXJ0cyA9IFtwLCAnOiB2YXIoJywgbWl4aW5OYW1lLCBNSVhJTl9WQVJfU0VQLCBwXTtcbiAgICAgICAgaWYgKGYpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKCcsJywgZik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaCgnKScpO1xuICAgICAgICB2YXJzLnB1c2gocGFydHMuam9pbignJykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFycy5qb2luKCc7ICcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX3JlcGxhY2VJbml0aWFsT3JJbmhlcml0KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgIGxldCBtYXRjaCA9IElOSVRJQUxfSU5IRVJJVC5leGVjKHZhbHVlKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGlmIChtYXRjaFsxXSkge1xuICAgICAgICAvLyBpbml0aWFsXG4gICAgICAgIC8vIHJlcGxhY2UgYGluaXRpYWxgIHdpdGggdGhlIGNvbmNyZXRlIGluaXRpYWwgdmFsdWUgZm9yIHRoaXMgcHJvcGVydHlcbiAgICAgICAgdmFsdWUgPSB0aGlzLl9nZXRJbml0aWFsVmFsdWVGb3JQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpbmhlcml0XG4gICAgICAgIC8vIHdpdGggdGhpcyBwdXJwb3NmdWxseSBpbGxlZ2FsIHZhbHVlLCB0aGUgdmFyaWFibGUgd2lsbCBiZSBpbnZhbGlkIGF0XG4gICAgICAgIC8vIGNvbXB1dGUgdGltZSAoaHR0cHM6Ly93d3cudzMub3JnL1RSL2Nzcy12YXJpYWJsZXMvI2ludmFsaWQtYXQtY29tcHV0ZWQtdmFsdWUtdGltZSlcbiAgICAgICAgLy8gYW5kIGZvciBpbmhlcml0aW5nIHZhbHVlcywgd2lsbCBiZWhhdmUgc2ltaWxhcmx5XG4gICAgICAgIC8vIHdlIGNhbm5vdCBzdXBwb3J0IHRoZSBzYW1lIGJlaGF2aW9yIGZvciBub24gaW5oZXJpdGluZyB2YWx1ZXMgbGlrZSAnYm9yZGVyJ1xuICAgICAgICB2YWx1ZSA9ICdhcHBseS1zaGltLWluaGVyaXQnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogXCJwYXJzZVwiIGEgbWl4aW4gZGVmaW5pdGlvbiBpbnRvIGEgbWFwIG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuICAgKiBjc3NUZXh0VG9NYXAoJ2JvcmRlcjogMnB4IHNvbGlkIGJsYWNrJykgLT4gKCdib3JkZXInLCAnMnB4IHNvbGlkIGJsYWNrJylcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICogQHJldHVybiB7IU9iamVjdDxzdHJpbmcsIHN0cmluZz59XG4gICAqL1xuICBfY3NzVGV4dFRvTWFwKHRleHQpIHtcbiAgICBsZXQgcHJvcHMgPSB0ZXh0LnNwbGl0KCc7Jyk7XG4gICAgbGV0IHByb3BlcnR5LCB2YWx1ZTtcbiAgICBsZXQgb3V0ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDAsIHAsIHNwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHAgPSBwcm9wc1tpXTtcbiAgICAgIGlmIChwKSB7XG4gICAgICAgIHNwID0gcC5zcGxpdCgnOicpO1xuICAgICAgICAvLyBpZ25vcmUgbGluZXMgdGhhdCBhcmVuJ3QgZGVmaW5pdGlvbnMgbGlrZSBAbWVkaWFcbiAgICAgICAgaWYgKHNwLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICBwcm9wZXJ0eSA9IHNwWzBdLnRyaW0oKTtcbiAgICAgICAgICAvLyBzb21lIHByb3BlcnRpZXMgbWF5IGhhdmUgJzonIGluIHRoZSB2YWx1ZSwgbGlrZSBkYXRhIHVybHNcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX3JlcGxhY2VJbml0aWFsT3JJbmhlcml0KHByb3BlcnR5LCBzcC5zbGljZSgxKS5qb2luKCc6JykpO1xuICAgICAgICAgIG91dFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TWl4aW5NYXBFbnRyeX0gbWl4aW5FbnRyeVxuICAgKi9cbiAgX2ludmFsaWRhdGVNaXhpbkVudHJ5KG1peGluRW50cnkpIHtcbiAgICBpZiAoIWludmFsaWRDYWxsYmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBlbGVtZW50TmFtZSBpbiBtaXhpbkVudHJ5LmRlcGVuZGFudHMpIHtcbiAgICAgIGlmIChlbGVtZW50TmFtZSAhPT0gdGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgaW52YWxpZENhbGxiYWNrKGVsZW1lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoVGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVQcm9wZXJ0eVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlTWl4aW5cbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX3Byb2R1Y2VDc3NQcm9wZXJ0aWVzKG1hdGNoVGV4dCwgcHJvcGVydHlOYW1lLCB2YWx1ZVByb3BlcnR5LCB2YWx1ZU1peGluKSB7XG4gICAgLy8gaGFuZGxlIGNhc2Ugd2hlcmUgcHJvcGVydHkgdmFsdWUgaXMgYSBtaXhpblxuICAgIGlmICh2YWx1ZVByb3BlcnR5KSB7XG4gICAgICAvLyBmb3JtOiAtLW1peGluMjogdmFyKC0tbWl4aW4xKSwgd2hlcmUgLS1taXhpbjEgaXMgaW4gdGhlIG1hcFxuICAgICAgcHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2sodmFsdWVQcm9wZXJ0eSwgKHByZWZpeCwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICYmIHRoaXMuX21hcC5nZXQodmFsdWUpKSB7XG4gICAgICAgICAgdmFsdWVNaXhpbiA9IGBAYXBwbHkgJHt2YWx1ZX07YFxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCF2YWx1ZU1peGluKSB7XG4gICAgICByZXR1cm4gbWF0Y2hUZXh0O1xuICAgIH1cbiAgICBsZXQgbWl4aW5Bc1Byb3BlcnRpZXMgPSB0aGlzLl9jb25zdW1lQ3NzUHJvcGVydGllcyh2YWx1ZU1peGluKTtcbiAgICBsZXQgcHJlZml4ID0gbWF0Y2hUZXh0LnNsaWNlKDAsIG1hdGNoVGV4dC5pbmRleE9mKCctLScpKTtcbiAgICBsZXQgbWl4aW5WYWx1ZXMgPSB0aGlzLl9jc3NUZXh0VG9NYXAobWl4aW5Bc1Byb3BlcnRpZXMpO1xuICAgIGxldCBjb21iaW5lZFByb3BzID0gbWl4aW5WYWx1ZXM7XG4gICAgbGV0IG1peGluRW50cnkgPSB0aGlzLl9tYXAuZ2V0KHByb3BlcnR5TmFtZSk7XG4gICAgbGV0IG9sZFByb3BzID0gbWl4aW5FbnRyeSAmJiBtaXhpbkVudHJ5LnByb3BlcnRpZXM7XG4gICAgaWYgKG9sZFByb3BzKSB7XG4gICAgICAvLyBOT1RFOiBzaW5jZSB3ZSB1c2UgbWl4aW4sIHRoZSBtYXAgb2YgcHJvcGVydGllcyBpcyB1cGRhdGVkIGhlcmVcbiAgICAgIC8vIGFuZCB0aGlzIGlzIHdoYXQgd2Ugd2FudC5cbiAgICAgIGNvbWJpbmVkUHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUob2xkUHJvcHMpLCBtaXhpblZhbHVlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX21hcC5zZXQocHJvcGVydHlOYW1lLCBjb21iaW5lZFByb3BzKTtcbiAgICB9XG4gICAgbGV0IG91dCA9IFtdO1xuICAgIGxldCBwLCB2O1xuICAgIC8vIHNldCB2YXJpYWJsZXMgZGVmaW5lZCBieSBjdXJyZW50IG1peGluXG4gICAgbGV0IG5lZWRUb0ludmFsaWRhdGUgPSBmYWxzZTtcbiAgICBmb3IgKHAgaW4gY29tYmluZWRQcm9wcykge1xuICAgICAgdiA9IG1peGluVmFsdWVzW3BdO1xuICAgICAgLy8gaWYgcHJvcGVydHkgbm90IGRlZmluZWQgYnkgY3VycmVudCBtaXhpbiwgc2V0IGluaXRpYWxcbiAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdiA9ICdpbml0aWFsJztcbiAgICAgIH1cbiAgICAgIGlmIChvbGRQcm9wcyAmJiAhKHAgaW4gb2xkUHJvcHMpKSB7XG4gICAgICAgIG5lZWRUb0ludmFsaWRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgb3V0LnB1c2goYCR7cHJvcGVydHlOYW1lfSR7TUlYSU5fVkFSX1NFUH0ke3B9OiAke3Z9YCk7XG4gICAgfVxuICAgIGlmIChuZWVkVG9JbnZhbGlkYXRlKSB7XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlTWl4aW5FbnRyeShtaXhpbkVudHJ5KTtcbiAgICB9XG4gICAgaWYgKG1peGluRW50cnkpIHtcbiAgICAgIG1peGluRW50cnkucHJvcGVydGllcyA9IGNvbWJpbmVkUHJvcHM7XG4gICAgfVxuICAgIC8vIGJlY2F1c2UgdGhlIG1peGluTWFwIGlzIGdsb2JhbCwgdGhlIG1peGluIG1pZ2h0IGNvbmZsaWN0IHdpdGhcbiAgICAvLyBhIGRpZmZlcmVudCBzY29wZSdzIHNpbXBsZSB2YXJpYWJsZSBkZWZpbml0aW9uOlxuICAgIC8vIEV4YW1wbGU6XG4gICAgLy8gc29tZSBzdHlsZSBzb21ld2hlcmU6XG4gICAgLy8gLS1taXhpbjE6eyAuLi4gfVxuICAgIC8vIC0tbWl4aW4yOiB2YXIoLS1taXhpbjEpO1xuICAgIC8vIHNvbWUgb3RoZXIgZWxlbWVudDpcbiAgICAvLyAtLW1peGluMTogMTBweCBzb2xpZCByZWQ7XG4gICAgLy8gLS1mb286IHZhcigtLW1peGluMSk7XG4gICAgLy8gSW4gdGhpcyBjYXNlLCB3ZSBsZWF2ZSB0aGUgb3JpZ2luYWwgdmFyaWFibGUgZGVmaW5pdGlvbiBpbiBwbGFjZS5cbiAgICBpZiAodmFsdWVQcm9wZXJ0eSkge1xuICAgICAgcHJlZml4ID0gYCR7bWF0Y2hUZXh0fTske3ByZWZpeH1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7cHJlZml4fSR7b3V0LmpvaW4oJzsgJyl9O2A7XG4gIH1cbn1cblxuLyogZXhwb3J0cyAqL1xuQXBwbHlTaGltLnByb3RvdHlwZVsnZGV0ZWN0TWl4aW4nXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUuZGV0ZWN0TWl4aW47XG5BcHBseVNoaW0ucHJvdG90eXBlWyd0cmFuc2Zvcm1TdHlsZSddID0gQXBwbHlTaGltLnByb3RvdHlwZS50cmFuc2Zvcm1TdHlsZTtcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ3RyYW5zZm9ybUN1c3RvbVN0eWxlJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLnRyYW5zZm9ybUN1c3RvbVN0eWxlO1xuQXBwbHlTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtUnVsZXMnXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUudHJhbnNmb3JtUnVsZXM7XG5BcHBseVNoaW0ucHJvdG90eXBlWyd0cmFuc2Zvcm1SdWxlJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLnRyYW5zZm9ybVJ1bGU7XG5BcHBseVNoaW0ucHJvdG90eXBlWyd0cmFuc2Zvcm1UZW1wbGF0ZSddID0gQXBwbHlTaGltLnByb3RvdHlwZS50cmFuc2Zvcm1UZW1wbGF0ZTtcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ19zZXBhcmF0b3InXSA9IE1JWElOX1ZBUl9TRVA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQXBwbHlTaGltLnByb3RvdHlwZSwgJ2ludmFsaWRDYWxsYmFjaycsIHtcbiAgLyoqIEByZXR1cm4gez9mdW5jdGlvbihzdHJpbmcpfSAqL1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIGludmFsaWRDYWxsYmFjaztcbiAgfSxcbiAgLyoqIEBwYXJhbSB7P2Z1bmN0aW9uKHN0cmluZyl9IGNiICovXG4gIHNldChjYikge1xuICAgIGludmFsaWRDYWxsYmFjayA9IGNiO1xuICB9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQgQXBwbHlTaGltO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7IVNldDxzdHJpbmc+fSAqL1xuY29uc3Qgc3R5bGVUZXh0U2V0ID0gbmV3IFNldCgpO1xuXG5leHBvcnQgY29uc3Qgc2NvcGluZ0F0dHJpYnV0ZSA9ICdzaGFkeS11bnNjb3BlZCc7XG5cbi8qKlxuICogQWRkIGEgc3BlY2lmaWNhbGx5LW1hcmtlZCBzdHlsZSB0byB0aGUgZG9jdW1lbnQgZGlyZWN0bHksIGFuZCBvbmx5IG9uZSBjb3B5IG9mIHRoYXQgc3R5bGUuXG4gKlxuICogQHBhcmFtIHshSFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3NVbnNjb3BlZFN0eWxlKHN0eWxlKSB7XG4gIGNvbnN0IHRleHQgPSBzdHlsZS50ZXh0Q29udGVudDtcbiAgaWYgKCFzdHlsZVRleHRTZXQuaGFzKHRleHQpKSB7XG4gICAgc3R5bGVUZXh0U2V0LmFkZCh0ZXh0KTtcbiAgICBjb25zdCBuZXdTdHlsZSA9IHN0eWxlLmNsb25lTm9kZSh0cnVlKTtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG5ld1N0eWxlKTtcbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3R5bGUgaXMgc3VwcG9zZWQgdG8gYmUgdW5zY29wZWRcbiAqIEBwYXJhbSB7IUhUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIHRoZSBzdHlsZSBoYXMgdGhlIHVuc2NvcGluZyBhdHRyaWJ1dGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVW5zY29wZWRTdHlsZShzdHlsZSkge1xuICByZXR1cm4gc3R5bGUuaGFzQXR0cmlidXRlKHNjb3BpbmdBdHRyaWJ1dGUpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy91bnNjb3BlZC1zdHlsZS1oYW5kbGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA1N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5pbXBvcnQgdGVtcGxhdGVNYXAgZnJvbSAnLi90ZW1wbGF0ZS1tYXAuanMnO1xuaW1wb3J0IHtTdHlsZU5vZGV9IGZyb20gJy4vY3NzLXBhcnNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKlxuICogVXRpbGl0aWVzIGZvciBoYW5kbGluZyBpbnZhbGlkYXRpbmcgYXBwbHktc2hpbSBtaXhpbnMgZm9yIGEgZ2l2ZW4gdGVtcGxhdGUuXG4gKlxuICogVGhlIGludmFsaWRhdGlvbiBzdHJhdGVneSBpbnZvbHZlcyBrZWVwaW5nIHRyYWNrIG9mIHRoZSBcImN1cnJlbnRcIiB2ZXJzaW9uIG9mIGEgdGVtcGxhdGUncyBtaXhpbnMsIGFuZCB1cGRhdGluZyB0aGF0IGNvdW50IHdoZW4gYSBtaXhpbiBpcyBpbnZhbGlkYXRlZC5cbiAqIFRoZSB0ZW1wbGF0ZVxuICovXG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IENVUlJFTlRfVkVSU0lPTiA9ICdfYXBwbHlTaGltQ3VycmVudFZlcnNpb24nO1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBORVhUX1ZFUlNJT04gPSAnX2FwcGx5U2hpbU5leHRWZXJzaW9uJztcblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgVkFMSURBVElOR19WRVJTSU9OID0gJ19hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbic7XG5cbi8qKlxuICogQGNvbnN0IHtQcm9taXNlPHZvaWQ+fVxuICovXG5jb25zdCBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlKGVsZW1lbnROYW1lKXtcbiAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICBpZiAodGVtcGxhdGUpIHtcbiAgICBpbnZhbGlkYXRlVGVtcGxhdGUodGVtcGxhdGUpO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHRvIG1hcmsgYSB0ZW1wbGF0ZSBpbnZhbGlkXG4gKiBhbmQgc2lnbmFsIHRoYXQgdGhlIHN0eWxlIGluc2lkZSBtdXN0IGJlIHJlZ2VuZXJhdGVkLlxuICpcbiAqIFVzZSBgc3RhcnRWYWxpZGF0aW5nVGVtcGxhdGVgIHRvIGJlZ2luIGFuIGFzeW5jaHJvbm91cyB2YWxpZGF0aW9uIGN5Y2xlLlxuICogRHVyaW5nIHRoYXQgY3ljbGUsIGNhbGwgYHRlbXBsYXRlSXNWYWxpZGF0aW5nYCB0byBzZWUgaWYgdGhlIHRlbXBsYXRlIG11c3RcbiAqIGJlIHJldmFsaWRhdGVkXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnZhbGlkYXRlVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgLy8gZGVmYXVsdCB0aGUgY3VycmVudCB2ZXJzaW9uIHRvIDBcbiAgdGVtcGxhdGVbQ1VSUkVOVF9WRVJTSU9OXSA9IHRlbXBsYXRlW0NVUlJFTlRfVkVSU0lPTl0gfHwgMDtcbiAgLy8gZW5zdXJlIHRoZSBcInZhbGlkYXRpbmcgZm9yXCIgZmxhZyBleGlzdHNcbiAgdGVtcGxhdGVbVkFMSURBVElOR19WRVJTSU9OXSA9IHRlbXBsYXRlW1ZBTElEQVRJTkdfVkVSU0lPTl0gfHwgMDtcbiAgLy8gaW5jcmVtZW50IHRoZSBuZXh0IHZlcnNpb25cbiAgdGVtcGxhdGVbTkVYVF9WRVJTSU9OXSA9ICh0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dIHx8IDApICsgMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkKGVsZW1lbnROYW1lKSB7XG4gIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgaWYgKHRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSkge1xuICByZXR1cm4gdGVtcGxhdGVbQ1VSUkVOVF9WRVJTSU9OXSA9PT0gdGVtcGxhdGVbTkVYVF9WRVJTSU9OXTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkYXRpbmcoZWxlbWVudE5hbWUpIHtcbiAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICBpZiAodGVtcGxhdGUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVJc1ZhbGlkYXRpbmcodGVtcGxhdGUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRlbXBsYXRlIGlzIGN1cnJlbnRseSBpbnZhbGlkIGFuZCBgc3RhcnRWYWxpZGF0aW5nYCBoYXMgYmVlbiBjYWxsZWQgc2luY2UgdGhlIGxhc3QgaW52YWxpZGF0aW9uLlxuICogSWYgZmFsc2UsIHRoZSB0ZW1wbGF0ZSBtdXN0IGJlIHZhbGlkYXRlZC5cbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUlzVmFsaWRhdGluZyh0ZW1wbGF0ZSkge1xuICByZXR1cm4gIXRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSkgJiYgdGVtcGxhdGVbVkFMSURBVElOR19WRVJTSU9OXSA9PT0gdGVtcGxhdGVbTkVYVF9WRVJTSU9OXTtcbn1cblxuLyoqXG4gKiB0aGUgdGVtcGxhdGUgaXMgbWFya2VkIGFzIGB2YWxpZGF0aW5nYCBmb3Igb25lIG1pY3JvdGFzayBzbyB0aGF0IGFsbCBpbnN0YW5jZXNcbiAqIGZvdW5kIGluIHRoZSB0cmVlIGNyYXdsIG9mIGBhcHBseVN0eWxlYCB3aWxsIHVwZGF0ZSB0aGVtc2VsdmVzLFxuICogYnV0IHRoZSB0ZW1wbGF0ZSB3aWxsIG9ubHkgYmUgdXBkYXRlZCBvbmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0VmFsaWRhdGluZyhlbGVtZW50TmFtZSkge1xuICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gIHN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlKHRlbXBsYXRlKTtcbn1cblxuLyoqXG4gKiBCZWdpbiBhbiBhc3luY2hyb25vdXMgaW52YWxpZGF0aW9uIGN5Y2xlLlxuICogVGhpcyBzaG91bGQgYmUgY2FsbGVkIGFmdGVyIGV2ZXJ5IHZhbGlkYXRpb24gb2YgYSB0ZW1wbGF0ZVxuICpcbiAqIEFmdGVyIG9uZSBtaWNyb3Rhc2ssIHRoZSB0ZW1wbGF0ZSB3aWxsIGJlIG1hcmtlZCBhcyB2YWxpZCB1bnRpbCB0aGUgbmV4dCBjYWxsIHRvIGBpbnZhbGlkYXRlVGVtcGxhdGVgXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFZhbGlkYXRpbmdUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAvLyByZW1lbWJlciB0aGF0IHRoZSBjdXJyZW50IFwibmV4dCB2ZXJzaW9uXCIgaXMgdGhlIHJlYXNvbiBmb3IgdGhpcyB2YWxpZGF0aW9uIGN5Y2xlXG4gIHRlbXBsYXRlW1ZBTElEQVRJTkdfVkVSU0lPTl0gPSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xuICAvLyBob3dldmVyLCB0aGVyZSBvbmx5IG5lZWRzIHRvIGJlIG9uZSBhc3luYyB0YXNrIHRvIGNsZWFyIHRoZSBjb3VudGVyc1xuICBpZiAoIXRlbXBsYXRlLl92YWxpZGF0aW5nKSB7XG4gICAgdGVtcGxhdGUuX3ZhbGlkYXRpbmcgPSB0cnVlO1xuICAgIHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIC8vIHN5bmMgdGhlIGN1cnJlbnQgdmVyc2lvbiB0byBsZXQgZnV0dXJlIGludmFsaWRhdGlvbnMgY2F1c2UgYSByZWZyZXNoIGN5Y2xlXG4gICAgICB0ZW1wbGF0ZVtDVVJSRU5UX1ZFUlNJT05dID0gdGVtcGxhdGVbTkVYVF9WRVJTSU9OXTtcbiAgICAgIHRlbXBsYXRlLl92YWxpZGF0aW5nID0gZmFsc2U7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZWxlbWVudHNBcmVJbnZhbGlkKCkge1xuICBmb3IgKGxldCBlbGVtZW50TmFtZSBpbiB0ZW1wbGF0ZU1hcCkge1xuICAgIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgICBpZiAoIXRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2FwcGx5LXNoaW0tdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0ICogYXMgY2FzZU1hcCQwIGZyb20gJy4uL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IG1pY3JvVGFzayB9IGZyb20gJy4uL3V0aWxzL2FzeW5jLmpzJztcblxubGV0IGNhc2VNYXAgPSBjYXNlTWFwJDA7XG5cbmxldCBtaWNyb3Rhc2sgPSBtaWNyb1Rhc2s7XG5cbi8vIFNhdmUgbWFwIG9mIG5hdGl2ZSBwcm9wZXJ0aWVzOyB0aGlzIGZvcm1zIGEgYmxhY2tsaXN0IG9yIHByb3BlcnRpZXNcbi8vIHRoYXQgd29uJ3QgaGF2ZSB0aGVpciB2YWx1ZXMgXCJzYXZlZFwiIGJ5IGBzYXZlQWNjZXNzb3JWYWx1ZWAsIHNpbmNlXG4vLyByZWFkaW5nIGZyb20gYW4gSFRNTEVsZW1lbnQgYWNjZXNzb3IgZnJvbSB0aGUgY29udGV4dCBvZiBhIHByb3RvdHlwZSB0aHJvd3NcbmNvbnN0IG5hdGl2ZVByb3BlcnRpZXMgPSB7fTtcbmxldCBwcm90byA9IEhUTUxFbGVtZW50LnByb3RvdHlwZTtcbndoaWxlIChwcm90bykge1xuICBsZXQgcHJvcHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90byk7XG4gIGZvciAobGV0IGk9MDsgaTxwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIG5hdGl2ZVByb3BlcnRpZXNbcHJvcHNbaV1dID0gdHJ1ZTtcbiAgfVxuICBwcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90byk7XG59XG5cbi8qKlxuICogVXNlZCB0byBzYXZlIHRoZSB2YWx1ZSBvZiBhIHByb3BlcnR5IHRoYXQgd2lsbCBiZSBvdmVycmlkZGVuIHdpdGhcbiAqIGFuIGFjY2Vzc29yLiBJZiB0aGUgYG1vZGVsYCBpcyBhIHByb3RvdHlwZSwgdGhlIHZhbHVlcyB3aWxsIGJlIHNhdmVkXG4gKiBpbiBgX19kYXRhUHJvdG9gLCBhbmQgaXQncyB1cCB0byB0aGUgdXNlciAob3IgZG93bnN0cmVhbSBtaXhpbikgdG9cbiAqIGRlY2lkZSBob3cvd2hlbiB0byBzZXQgdGhlc2UgdmFsdWVzIGJhY2sgaW50byB0aGUgYWNjZXNzb3JzLlxuICogSWYgYG1vZGVsYCBpcyBhbHJlYWR5IGFuIGluc3RhbmNlIChpdCBoYXMgYSBgX19kYXRhYCBwcm9wZXJ0eSksIHRoZW5cbiAqIHRoZSB2YWx1ZSB3aWxsIGJlIHNldCBhcyBhIHBlbmRpbmcgcHJvcGVydHksIG1lYW5pbmcgdGhlIHVzZXIgc2hvdWxkXG4gKiBjYWxsIGBfaW52YWxpZGF0ZVByb3BlcnRpZXNgIG9yIGBfZmx1c2hQcm9wZXJ0aWVzYCB0byB0YWtlIGVmZmVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlQWNjZXNzb3JWYWx1ZShtb2RlbCwgcHJvcGVydHkpIHtcbiAgLy8gRG9uJ3QgcmVhZC9zdG9yZSB2YWx1ZSBmb3IgYW55IG5hdGl2ZSBwcm9wZXJ0aWVzIHNpbmNlIHRoZXkgY291bGQgdGhyb3dcbiAgaWYgKCFuYXRpdmVQcm9wZXJ0aWVzW3Byb3BlcnR5XSkge1xuICAgIGxldCB2YWx1ZSA9IG1vZGVsW3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKG1vZGVsLl9fZGF0YSkge1xuICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gaW5zdGFuY2U7IHVwZGF0ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gSXQgaXMgdGhlIHVzZXIncyByZXNwb25zaWJpbGl0eSB0byBjYWxsIF9mbHVzaFByb3BlcnRpZXNcbiAgICAgICAgbW9kZWwuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWRkaW5nIGFjY2Vzc29yIHRvIHByb3RvOyBzYXZlIHByb3RvJ3MgdmFsdWUgZm9yIGluc3RhbmNlLXRpbWUgdXNlXG4gICAgICAgIGlmICghbW9kZWwuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90byA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKCFtb2RlbC5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2RhdGFQcm90bycsIG1vZGVsKSkpIHtcbiAgICAgICAgICBtb2RlbC5fX2RhdGFQcm90byA9IE9iamVjdC5jcmVhdGUobW9kZWwuX19kYXRhUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIG1vZGVsLl9fZGF0YVByb3RvW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgUHJvcGVydHlBY2Nlc3NvcnMgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgUHJvcGVydHlBY2Nlc3NvcnMgZXh0ZW5kcyBzdXBlckNsYXNzIHtcblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgZm9yIGFsbCBhdHRyaWJ1dGVzIGluIHRoZSBzdGFuZGFyZFxuICAgICAqIHN0YXRpYyBgb2JzZXJ2ZWRBdHRyaWJ1dGVzYCBhcnJheS5cbiAgICAgKlxuICAgICAqIEF0dHJpYnV0ZSBuYW1lcyBhcmUgbWFwcGVkIHRvIHByb3BlcnR5IG5hbWVzIHVzaW5nIHRoZSBgZGFzaC1jYXNlYCB0b1xuICAgICAqIGBjYW1lbENhc2VgIGNvbnZlbnRpb25cbiAgICAgKlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVQcm9wZXJ0aWVzRm9yQXR0cmlidXRlcygpIHtcbiAgICAgIGxldCBhJCA9IHRoaXMub2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgYSQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IoY2FzZU1hcC5kYXNoVG9DYW1lbENhc2UoYSRbaV0pKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fc2VyaWFsaXppbmc7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ291bnRlcjtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhRW5hYmxlZDtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhUmVhZHk7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUludmFsaWQ7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YTtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YU9sZDtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQcm90bztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3NvcjtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzO1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIG5hdGl2ZSBDdXN0b20gRWxlbWVudHMgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgdG9cbiAgICAgKiBzZXQgYW4gYXR0cmlidXRlIHZhbHVlIHRvIGEgcHJvcGVydHkgdmlhIGBfYXR0cmlidXRlVG9Qcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZSB0aGF0IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgYXR0cmlidXRlIHZhbHVlXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBOZXcgYXR0cmlidXRlIHZhbHVlXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZVRvUHJvcGVydHkobmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICpcbiAgICAgKiBQcm92aWRlZCBhcyBhbiBvdmVycmlkZSBwb2ludCBmb3IgcGVyZm9ybWluZyBhbnkgc2V0dXAgd29yayBwcmlvclxuICAgICAqIHRvIGluaXRpYWxpemluZyB0aGUgcHJvcGVydHkgYWNjZXNzb3Igc3lzdGVtLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGFDb3VudGVyID0gMDtcbiAgICAgIHRoaXMuX19kYXRhRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGFSZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YSA9IHt9O1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhT2xkID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLl9fZGF0YVByb3RvKSB7XG4gICAgICAgIHRoaXMuX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXModGhpcy5fX2RhdGFQcm90byk7XG4gICAgICAgIHRoaXMuX19kYXRhUHJvdG8gPSBudWxsO1xuICAgICAgfVxuICAgICAgLy8gQ2FwdHVyZSBpbnN0YW5jZSBwcm9wZXJ0aWVzOyB0aGVzZSB3aWxsIGJlIHNldCBpbnRvIGFjY2Vzc29yc1xuICAgICAgLy8gZHVyaW5nIGZpcnN0IGZsdXNoLiBEb24ndCBzZXQgdGhlbSBoZXJlLCBzaW5jZSB3ZSB3YW50XG4gICAgICAvLyB0aGVzZSB0byBvdmVyd3JpdGUgZGVmYXVsdHMvY29uc3RydWN0b3IgYXNzaWdubWVudHNcbiAgICAgIGZvciAobGV0IHAgaW4gdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcikge1xuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHNbcF0gPSB0aGlzW3BdO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzW3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF0IGluc3RhbmNlIHRpbWUgd2l0aCBiYWcgb2YgcHJvcGVydGllcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgKiBieSBhY2Nlc3NvcnMgb24gdGhlIHByb3RvdHlwZSB3aGVuIGFjY2Vzc29ycyB3ZXJlIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBzZXRzIHRoZXNlIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZVxuICAgICAqIHNldHRlciBhdCBpbnN0YW5jZSB0aW1lLiAgVGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYW4gb3ZlcnJpZGVcbiAgICAgKiBwb2ludCBmb3IgY3VzdG9taXppbmcgb3IgcHJvdmlkaW5nIG1vcmUgZWZmaWNpZW50IGluaXRpYWxpemF0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCB3ZXJlIG92ZXJ3cml0dGVuXG4gICAgICogICB3aGVuIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm90b1Byb3BlcnRpZXMocHJvcHMpIHtcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocCwgcHJvcHNbcF0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCBhdCByZWFkeSB0aW1lIHdpdGggYmFnIG9mIGluc3RhbmNlIHByb3BlcnRpZXMgdGhhdCBvdmVyd3JvdGVcbiAgICAgKiBhY2Nlc3NvcnMgd2hlbiB0aGUgZWxlbWVudCB1cGdyYWRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICogc2V0dGVyIGF0IHJlYWR5IHRpbWUuICBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBhbiBvdmVycmlkZVxuICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnR5IHZhbHVlcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGUgZWxlbWVudCBoYXMgdGhlIGdpdmVuIGF0dHJpYnV0ZS4gSWYgaXQgZG9lcyBub3QsXG4gICAgICogYXNzaWducyB0aGUgZ2l2ZW4gdmFsdWUgdG8gdGhlIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBlbnN1cmUgaXMgc2V0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIF9lbnN1cmVBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGUpKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKHRoaXMsIHZhbHVlLCBhdHRyaWJ1dGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplcyBhbiBhdHRyaWJ1dGUgdG8gaXRzIGFzc29jaWF0ZWQgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgYF9kZXNlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgc3RyaW5nIHRvXG4gICAgICogYSB0eXBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgTmFtZSBvZiBhdHRyaWJ1dGUgdG8gZGVzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBvZiB0aGUgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgdHlwZSB0byBkZXNlcmlhbGl6ZSB0by5cbiAgICAgKi9cbiAgICBfYXR0cmlidXRlVG9Qcm9wZXJ0eShhdHRyaWJ1dGUsIHZhbHVlLCB0eXBlKSB7XG4gICAgICAvLyBEb24ndCBkZXNlcmlhbGl6ZSBiYWNrIHRvIHByb3BlcnR5IGlmIGN1cnJlbnRseSByZWZsZWN0aW5nXG4gICAgICBpZiAoIXRoaXMuX19zZXJpYWxpemluZykge1xuICAgICAgICBsZXQgcHJvcGVydHkgPSBjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShhdHRyaWJ1dGUpO1xuICAgICAgICB0aGlzW3Byb3BlcnR5XSA9IHRoaXMuX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgYSBwcm9wZXJ0eSB0byBpdHMgYXNzb2NpYXRlZCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZSB0byByZWZsZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gcmVmZWN0LlxuICAgICAqL1xuICAgIF9wcm9wZXJ0eVRvQXR0cmlidXRlKHByb3BlcnR5LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICB0aGlzLl9fc2VyaWFsaXppbmcgPSB0cnVlO1xuICAgICAgdmFsdWUgPSAoYXJndW1lbnRzLmxlbmd0aCA8IDMpID8gdGhpc1twcm9wZXJ0eV0gOiB2YWx1ZTtcbiAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKHRoaXMsIHZhbHVlLFxuICAgICAgICBhdHRyaWJ1dGUgfHwgY2FzZU1hcC5jYW1lbFRvRGFzaENhc2UocHJvcGVydHkpKTtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB0eXBlZCB2YWx1ZSB0byBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjYWxscyB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHRvIGNvbnZlcnQgdGhlIHR5cGVkXG4gICAgICogdmFsdWUgdG8gYSBzdHJpbmcuICBJZiB0aGUgYF9zZXJpYWxpemVWYWx1ZWAgbWV0aG9kIHJldHVybnMgYHVuZGVmaW5lZGAsXG4gICAgICogdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJlbW92ZWQgKHRoaXMgaXMgdGhlIGRlZmF1bHQgZm9yIGJvb2xlYW5cbiAgICAgKiB0eXBlIGBmYWxzZWApLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gc2V0IGF0dHJpYnV0ZSB0by5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHNlcmlhbGl6ZSB0by5cbiAgICAgKi9cbiAgICBfdmFsdWVUb05vZGVBdHRyaWJ1dGUobm9kZSwgdmFsdWUsIGF0dHJpYnV0ZSkge1xuICAgICAgbGV0IHN0ciA9IHRoaXMuX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICAgIGlmIChzdHIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCBzdHIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBieSBQb2x5bWVyIHdoZW4gc2V0dGluZyBKUyBwcm9wZXJ0eSB2YWx1ZXMgdG9cbiAgICAgKiBIVE1MIGF0dHJpYnV0ZXMuICBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgb24gUG9seW1lciBlbGVtZW50XG4gICAgICogcHJvdG90eXBlcyB0byBwcm92aWRlIHNlcmlhbGl6YXRpb24gZm9yIGN1c3RvbSB0eXBlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgUHJvcGVydHkgdmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gU3RyaW5nIHNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWQgcHJvcGVydHkgdmFsdWUuXG4gICAgICovXG4gICAgX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgcmV0dXJuIHZhbHVlID8gJycgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCA/IHZhbHVlLnRvU3RyaW5nKCkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBzdHJpbmcgdG8gYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFBvbHltZXIgd2hlbiByZWFkaW5nIEhUTUwgYXR0cmlidXRlIHZhbHVlcyB0b1xuICAgICAqIEpTIHByb3BlcnRpZXMuICBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2Qgb24gUG9seW1lciBlbGVtZW50XG4gICAgICogcHJvdG90eXBlcyB0byBwcm92aWRlIGRlc2VyaWFsaXphdGlvbiBmb3IgY3VzdG9tIGB0eXBlYHMuICBOb3RlLFxuICAgICAqIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBgdHlwZWAgZmllbGQgcHJvdmlkZWQgaW4gdGhlXG4gICAgICogYHByb3BlcnRpZXNgIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBhIGdpdmVuIHByb3BlcnR5LCBhbmQgaXNcbiAgICAgKiBieSBjb252ZW50aW9uIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIHR5cGUgdG8gZGVzZXJpYWxpemUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGUgcmV0dXJuIHZhbHVlIG9mIGB1bmRlZmluZWRgIGlzIHVzZWQgYXMgYSBzZW50aW5lbCB2YWx1ZSB0b1xuICAgICAqIGluZGljYXRlIHRoZSBhdHRyaWJ1dGUgc2hvdWxkIGJlIHJlbW92ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0geyo9fSB0eXBlIFR5cGUgdG8gZGVzZXJpYWxpemUgdGhlIHN0cmluZyB0by5cbiAgICAgKiBAcmV0dXJuIHsqfSBUeXBlZCB2YWx1ZSBkZXNlcmlhbGl6ZWQgZnJvbSB0aGUgcHJvdmlkZWQgc3RyaW5nLlxuICAgICAqL1xuICAgIF9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHsqfVxuICAgICAgICovXG4gICAgICBsZXQgb3V0VmFsdWU7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgICAgb3V0VmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgQm9vbGVhbjpcbiAgICAgICAgICBvdXRWYWx1ZSA9ICh2YWx1ZSAhPT0gbnVsbCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG91dFZhbHVlID0gSlNPTi5wYXJzZSgvKiogQHR5cGUgc3RyaW5nICovKHZhbHVlKSk7XG4gICAgICAgICAgfSBjYXRjaCh4KSB7XG4gICAgICAgICAgICAvLyBhbGxvdyBub24tSlNPTiBsaXRlcmFscyBsaWtlIFN0cmluZ3MgYW5kIE51bWJlcnNcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBBcnJheTpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3V0VmFsdWUgPSBKU09OLnBhcnNlKC8qKiBAdHlwZSBzdHJpbmcgKi8odmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgIG91dFZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgUG9seW1lcjo6QXR0cmlidXRlczogY291bGRuJ3QgZGVjb2RlIEFycmF5IGFzIEpTT046ICR7dmFsdWV9YCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgRGF0ZTpcbiAgICAgICAgICBvdXRWYWx1ZSA9IG5ldyBEYXRlKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBvdXRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0VmFsdWU7XG4gICAgfVxuICAgIC8qIGVzbGludC1lbmFibGUgbm8tZmFsbHRocm91Z2ggKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzZXR0ZXIvZ2V0dGVyIHBhaXIgZm9yIHRoZSBuYW1lZCBwcm9wZXJ0eSB3aXRoIGl0cyBvd25cbiAgICAgKiBsb2NhbCBzdG9yYWdlLiAgVGhlIGdldHRlciByZXR1cm5zIHRoZSB2YWx1ZSBpbiB0aGUgbG9jYWwgc3RvcmFnZSxcbiAgICAgKiBhbmQgdGhlIHNldHRlciBjYWxscyBgX3NldFByb3BlcnR5YCwgd2hpY2ggdXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZVxuICAgICAqIGZvciB0aGUgcHJvcGVydHkgYW5kIGVucXVldWVzIGEgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIGEgcHJvdG90eXBlIG9yIGFuIGluc3RhbmNlLiAgQ2FsbGluZ1xuICAgICAqIHRoaXMgbWV0aG9kIG1heSBvdmVyd3JpdGUgYSBwcm9wZXJ0eSB2YWx1ZSB0aGF0IGFscmVhZHkgZXhpc3RzIG9uXG4gICAgICogdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBieSBjcmVhdGluZyB0aGUgYWNjZXNzb3IuICBXaGVuIGNhbGxpbmcgb25cbiAgICAgKiBhIHByb3RvdHlwZSwgYW55IG92ZXJ3cml0dGVuIHZhbHVlcyBhcmUgc2F2ZWQgaW4gYF9fZGF0YVByb3RvYCxcbiAgICAgKiBhbmQgaXQgaXMgdXAgdG8gdGhlIHN1YmNsYXNzZXIgdG8gZGVjaWRlIGhvdy93aGVuIHRvIHNldCB0aG9zZVxuICAgICAqIHByb3BlcnRpZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3Nvci4gIFdoZW4gY2FsbGluZyBvbiBhbiBpbnN0YW5jZSxcbiAgICAgKiB0aGUgb3ZlcndyaXR0ZW4gdmFsdWUgaXMgc2V0IHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAsIGFuZCB0aGVcbiAgICAgKiB1c2VyIHNob3VsZCBjYWxsIGBfaW52YWxpZGF0ZVByb3BlcnRpZXNgIG9yIGBfZmx1c2hQcm9wZXJ0aWVzYFxuICAgICAqIGZvciB0aGUgdmFsdWVzIHRvIHRha2UgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcmVhZE9ubHkgV2hlbiB0cnVlLCBubyBzZXR0ZXIgaXMgY3JlYXRlZDsgdGhlXG4gICAgICogICBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgZnVuY3Rpb24gbXVzdCBiZSB1c2VkIHRvIHNldCB0aGUgcHJvcGVydHlcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcGVydHksIHJlYWRPbmx5KSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoJ19fZGF0YUhhc0FjY2Vzc29yJykpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFIYXNBY2Nlc3NvciA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX19kYXRhSGFzQWNjZXNzb3IpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XSkge1xuICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIHNhdmVBY2Nlc3NvclZhbHVlKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BlcnR5LCB7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgICAgICAgICAvKiogQHRoaXMge1Byb3BlcnR5QWNjZXNzb3JzfSAqL1xuICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgLyoqIEB0aGlzIHtQcm9wZXJ0eUFjY2Vzc29yc30gKi9cbiAgICAgICAgICBzZXQ6IHJlYWRPbmx5ID8gZnVuY3Rpb24oKSB7fSA6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGxpYnJhcnkgY3JlYXRlZCBhbiBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGFjY2Vzc29yIHdhcyBjcmVhdGVkXG4gICAgICovXG4gICAgX2hhc0FjY2Vzc29yKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BlcnR5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBhIHByb3BlcnR5ICh2aWEgYF9zZXRQZW5kaW5nUHJvcGVydHlgKVxuICAgICAqIGFuZCBlbnF1ZXVlcyBhIGBfcHJvZXBydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpKSB7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgbG9jYWwgc3RvcmFnZSBmb3IgYSBwcm9wZXJ0eSwgcmVjb3JkcyB0aGUgcHJldmlvdXMgdmFsdWUsXG4gICAgICogYW5kIGFkZHMgaXQgdG8gdGhlIHNldCBvZiBcInBlbmRpbmcgY2hhbmdlc1wiIHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gdGhlXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suICBUaGlzIG1ldGhvZCBkb2VzIG5vdCBlbnF1ZXVlIHRoZVxuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIGxldCBvbGQgPSB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICBsZXQgY2hhbmdlZCA9IHRoaXMuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKTtcbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIGlmICghdGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0ge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICAvLyBFbnN1cmUgb2xkIGlzIGNhcHR1cmVkIGZyb20gdGhlIGxhc3QgdHVyblxuICAgICAgICBpZiAodGhpcy5fX2RhdGFPbGQgJiYgIShwcm9wZXJ0eSBpbiB0aGlzLl9fZGF0YU9sZCkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZFtwcm9wZXJ0eV0gPSBvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2RhdGFbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjaGFuZ2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGhhcyBhIHBlbmRpbmcgY2hhbmdlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgcHJvcGVydHkgaGFzIGEgcGVuZGluZyBjaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2lzUHJvcGVydHlQZW5kaW5nKHByb3ApIHtcbiAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuX19kYXRhUGVuZGluZyAmJiAocHJvcCBpbiB0aGlzLl9fZGF0YVBlbmRpbmcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNYXJrcyB0aGUgcHJvcGVydGllcyBhcyBpbnZhbGlkLCBhbmQgZW5xdWV1ZXMgYW4gYXN5bmNcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX19kYXRhSW52YWxpZCAmJiB0aGlzLl9fZGF0YVJlYWR5KSB7XG4gICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IHRydWU7XG4gICAgICAgIG1pY3JvdGFzay5ydW4oKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9fZGF0YUludmFsaWQpIHtcbiAgICAgICAgICAgIHRoaXMuX19kYXRhSW52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRvIGVuYWJsZSBwcm9wZXJ0eSBhY2Nlc3NvciBwcm9jZXNzaW5nLiBCZWZvcmUgdGhpcyBtZXRob2QgaXNcbiAgICAgKiBjYWxsZWQgYWNjZXNzb3IgdmFsdWVzIHdpbGwgYmUgc2V0IGJ1dCBzaWRlIGVmZmVjdHMgYXJlXG4gICAgICogcXVldWVkLiBXaGVuIGNhbGxlZCwgYW55IHBlbmRpbmcgc2lkZSBlZmZlY3RzIG9jY3VyIGltbWVkaWF0ZWx5LlxuICAgICAqIEZvciBlbGVtZW50cywgZ2VuZXJhbGx5IGBjb25uZWN0ZWRDYWxsYmFja2AgaXMgYSBub3JtYWwgc3BvdCB0byBkbyBzby5cbiAgICAgKiBJdCBpcyBzYWZlIHRvIGNhbGwgdGhpcyBtZXRob2QgbXVsdGlwbGUgdGltZXMgYXMgaXQgb25seSB0dXJucyBvblxuICAgICAqIHByb3BlcnR5IGFjY2Vzc29ycyBvbmNlLlxuICAgICAqL1xuICAgIF9lbmFibGVQcm9wZXJ0aWVzKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZGF0YUVuYWJsZWQpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcykge1xuICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVJbnN0YW5jZVByb3BlcnRpZXModGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzKTtcbiAgICAgICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVhZHkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxscyB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2sgd2l0aCB0aGUgY3VycmVudCBzZXQgb2ZcbiAgICAgKiBwZW5kaW5nIGNoYW5nZXMgKGFuZCBvbGQgdmFsdWVzIHJlY29yZGVkIHdoZW4gcGVuZGluZyBjaGFuZ2VzIHdlcmVcbiAgICAgKiBzZXQpLCBhbmQgcmVzZXRzIHRoZSBwZW5kaW5nIHNldCBvZiBjaGFuZ2VzLiBHZW5lcmFsbHksIHRoaXMgbWV0aG9kXG4gICAgICogc2hvdWxkIG5vdCBiZSBjYWxsZWQgaW4gdXNlciBjb2RlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2ZsdXNoUHJvcGVydGllcygpIHtcbiAgICAgIGlmICh0aGlzLl9fZGF0YVBlbmRpbmcgJiYgdGhpcy5fX2RhdGFPbGQpIHtcbiAgICAgICAgbGV0IGNoYW5nZWRQcm9wcyA9IHRoaXMuX19kYXRhUGVuZGluZztcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyKys7XG4gICAgICAgIHRoaXMuX3Byb3BlcnRpZXNDaGFuZ2VkKHRoaXMuX19kYXRhLCBjaGFuZ2VkUHJvcHMsIHRoaXMuX19kYXRhT2xkKTtcbiAgICAgICAgdGhpcy5fX2RhdGFDb3VudGVyLS07XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGlmZWN5Y2xlIGNhbGxiYWNrIGNhbGxlZCB0aGUgZmlyc3QgdGltZSBwcm9wZXJ0aWVzIGFyZSBiZWluZyBmbHVzaGVkLlxuICAgICAqIFByaW9yIHRvIGByZWFkeWAsIGFsbCBwcm9wZXJ0eSBzZXRzIHRocm91Z2ggYWNjZXNzb3JzIGFyZSBxdWV1ZWQgYW5kXG4gICAgICogdGhlaXIgZWZmZWN0cyBhcmUgZmx1c2hlZCBhZnRlciB0aGlzIG1ldGhvZCByZXR1cm5zLlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gdG8gaW1wbGVtZW50IGJlaGF2aW9yIHRoYXQgaXNcbiAgICAgKiBkZXBlbmRlbnQgb24gdGhlIGVsZW1lbnQgaGF2aW5nIGl0cyBwcm9wZXJ0aWVzIGluaXRpYWxpemVkLCBlLmcuXG4gICAgICogZnJvbSBkZWZhdWx0cyAoaW5pdGlhbGl6ZWQgZnJvbSBgY29uc3RydWN0b3JgLCBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCksXG4gICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG9yIHZhbHVlcyBwcm9wYWdhdGVkIGZyb20gaG9zdCBlLmcuIHZpYVxuICAgICAqIGJpbmRpbmdzLiAgYHN1cGVyLnJlYWR5KClgIG11c3QgYmUgY2FsbGVkIHRvIGVuc3VyZSB0aGUgZGF0YSBzeXN0ZW1cbiAgICAgKiBiZWNvbWVzIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gdHJ1ZTtcbiAgICAgIC8vIFJ1biBub3JtYWwgZmx1c2hcbiAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIGFueSBwcm9wZXJ0aWVzIHdpdGggYWNjZXNzb3JzIGNyZWF0ZWQgdmlhXG4gICAgICogYF9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yYCBoYXZlIGJlZW4gc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBjdXJyZW50UHJvcHMgQmFnIG9mIGFsbCBjdXJyZW50IGFjY2Vzc29yIHZhbHVlc1xuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIGNoYW5nZWQgc2luY2UgdGhlIGxhc3RcbiAgICAgKiAgIGNhbGwgdG8gYF9wcm9wZXJ0aWVzQ2hhbmdlZGBcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGVhY2ggcHJvcGVydHlcbiAgICAgKiAgIGluIGBjaGFuZ2VkUHJvcHNgXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBjYWxsZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBwcm9wZXJ0eSB2YWx1ZSBzaG91bGQgYmVcbiAgICAgKiBjb25zaWRlcmVkIGFzIGEgY2hhbmdlIGFuZCBjYXVzZSB0aGUgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgKiB0byBiZSBlbnF1ZXVlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgYHRydWVgIGZvciBwcmltaXRpdmUgdHlwZXMgaWYgYVxuICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVjayBmYWlscywgYW5kIHJldHVybnMgYHRydWVgIGZvciBhbGwgT2JqZWN0L0FycmF5cy5cbiAgICAgKiBUaGUgbWV0aG9kIGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBgTmFOYC5cbiAgICAgKlxuICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGUuZy4gcHJvdmlkZSBzdHJpY3RlciBjaGVja2luZyBmb3JcbiAgICAgKiBPYmplY3RzL0FycmF5cyB3aGVuIHVzaW5nIGltbXV0YWJsZSBwYXR0ZXJucy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogICBhbmQgZW5xdWV1ZSBhIGBfcHJvZXBydGllc0NoYW5nZWRgIGNhbGxiYWNrXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLy8gU3RyaWN0IGVxdWFsaXR5IGNoZWNrXG4gICAgICAgIChvbGQgIT09IHZhbHVlICYmXG4gICAgICAgICAvLyBUaGlzIGVuc3VyZXMgKG9sZD09TmFOLCB2YWx1ZT09TmFOKSBhbHdheXMgcmV0dXJucyBmYWxzZVxuICAgICAgICAgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpXG4gICAgICApO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFByb3BlcnR5QWNjZXNzb3JzO1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1hY2Nlc3NvcnMuanNcbi8vIG1vZHVsZSBpZCA9IDU5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuXG4vLyAxLnggYmFja3dhcmRzLWNvbXBhdGlibGUgYXV0by13cmFwcGVyIGZvciB0ZW1wbGF0ZSB0eXBlIGV4dGVuc2lvbnNcbi8vIFRoaXMgaXMgYSBjbGVhciBsYXllcmluZyB2aW9sYXRpb24gYW5kIGdpdmVzIGZhdm9yZWQtbmF0aW9uIHN0YXR1cyB0b1xuLy8gZG9tLWlmIGFuZCBkb20tcmVwZWF0IHRlbXBsYXRlcy4gIFRoaXMgaXMgYSBjb25jZWl0IHdlJ3JlIGNob29zaW5nIHRvIGtlZXBcbi8vIGEuKSB0byBlYXNlIDEueCBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBkdWUgdG8gbG9zcyBvZiBgaXNgLCBhbmRcbi8vIGIuKSB0byBtYWludGFpbiBpZi9yZXBlYXQgY2FwYWJpbGl0eSBpbiBwYXJzZXItY29uc3RyYWluZWQgZWxlbWVudHNcbi8vICAgICAoZS5nLiB0YWJsZSwgc2VsZWN0KSBpbiBsaWV1IG9mIG5hdGl2ZSBDRSB0eXBlIGV4dGVuc2lvbnMgd2l0aG91dFxuLy8gICAgIG1hc3NpdmUgbmV3IGludmVudGlvbiBpbiB0aGlzIHNwYWNlIChlLmcuIGRpcmVjdGl2ZSBzeXN0ZW0pXG5jb25zdCB0ZW1wbGF0ZUV4dGVuc2lvbnMgPSB7XG4gICdkb20taWYnOiB0cnVlLFxuICAnZG9tLXJlcGVhdCc6IHRydWVcbn07XG5mdW5jdGlvbiB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSkge1xuICBsZXQgaXMgPSBub2RlLmdldEF0dHJpYnV0ZSgnaXMnKTtcbiAgaWYgKGlzICYmIHRlbXBsYXRlRXh0ZW5zaW9uc1tpc10pIHtcbiAgICBsZXQgdCA9IG5vZGU7XG4gICAgdC5yZW1vdmVBdHRyaWJ1dGUoJ2lzJyk7XG4gICAgbm9kZSA9IHQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KGlzKTtcbiAgICB0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKG5vZGUsIHQpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQodCk7XG4gICAgd2hpbGUodC5hdHRyaWJ1dGVzLmxlbmd0aCkge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUodC5hdHRyaWJ1dGVzWzBdLm5hbWUsIHQuYXR0cmlidXRlc1swXS52YWx1ZSk7XG4gICAgICB0LnJlbW92ZUF0dHJpYnV0ZSh0LmF0dHJpYnV0ZXNbMF0ubmFtZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBmaW5kVGVtcGxhdGVOb2RlKHJvb3QsIG5vZGVJbmZvKSB7XG4gIC8vIHJlY3Vyc2l2ZWx5IGFzY2VuZCB0cmVlIHVudGlsIHdlIGhpdCByb290XG4gIGxldCBwYXJlbnQgPSBub2RlSW5mby5wYXJlbnRJbmZvICYmIGZpbmRUZW1wbGF0ZU5vZGUocm9vdCwgbm9kZUluZm8ucGFyZW50SW5mbyk7XG4gIC8vIHVud2luZCB0aGUgc3RhY2ssIHJldHVybmluZyB0aGUgaW5kZXhlZCBub2RlIGF0IGVhY2ggbGV2ZWxcbiAgaWYgKHBhcmVudCkge1xuICAgIC8vIG5vdGU6IG1hcmdpbmFsbHkgZmFzdGVyIHRoYW4gaW5kZXhpbmcgdmlhIGNoaWxkTm9kZXNcbiAgICAvLyAoaHR0cDovL2pzcGVyZi5jb20vY2hpbGRub2Rlcy1sb29rdXApXG4gICAgZm9yIChsZXQgbj1wYXJlbnQuZmlyc3RDaGlsZCwgaT0wOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgIGlmIChub2RlSW5mby5wYXJlbnRJbmRleCA9PT0gaSsrKSB7XG4gICAgICAgIHJldHVybiBuO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcm9vdDtcbiAgfVxufVxuXG4vLyBjb25zdHJ1Y3QgYCRgIG1hcCAoZnJvbSBpZCBhbm5vdGF0aW9ucylcbmZ1bmN0aW9uIGFwcGx5SWRUb01hcChpbnN0LCBtYXAsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby5pZCkge1xuICAgIG1hcFtub2RlSW5mby5pZF0gPSBub2RlO1xuICB9XG59XG5cbi8vIGluc3RhbGwgZXZlbnQgbGlzdGVuZXJzIChmcm9tIGV2ZW50IGFubm90YXRpb25zKVxuZnVuY3Rpb24gYXBwbHlFdmVudExpc3RlbmVyKGluc3QsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby5ldmVudHMgJiYgbm9kZUluZm8uZXZlbnRzLmxlbmd0aCkge1xuICAgIGZvciAobGV0IGo9MCwgZSQ9bm9kZUluZm8uZXZlbnRzLCBlOyAoajxlJC5sZW5ndGgpICYmIChlPWUkW2pdKTsgaisrKSB7XG4gICAgICBpbnN0Ll9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGUubmFtZSwgZS52YWx1ZSwgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8vIHB1c2ggY29uZmlndXJhdGlvbiByZWZlcmVuY2VzIGF0IGNvbmZpZ3VyZSB0aW1lXG5mdW5jdGlvbiBhcHBseVRlbXBsYXRlQ29udGVudChpbnN0LCBub2RlLCBub2RlSW5mbykge1xuICBpZiAobm9kZUluZm8udGVtcGxhdGVJbmZvKSB7XG4gICAgbm9kZS5fdGVtcGxhdGVJbmZvID0gbm9kZUluZm8udGVtcGxhdGVJbmZvO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVFdmVudEhhbmRsZXIoY29udGV4dCwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICBjb250ZXh0ID0gY29udGV4dC5fbWV0aG9kSG9zdCB8fCBjb250ZXh0O1xuICBsZXQgaGFuZGxlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoY29udGV4dFttZXRob2ROYW1lXSkge1xuICAgICAgY29udGV4dFttZXRob2ROYW1lXShlLCBlLmRldGFpbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignbGlzdGVuZXIgbWV0aG9kIGAnICsgbWV0aG9kTmFtZSArICdgIG5vdCBkZWZpbmVkJyk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gaGFuZGxlcjtcbn1cblxuZXhwb3J0IGNvbnN0IFRlbXBsYXRlU3RhbXAgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9UZW1wbGF0ZVN0YW1wfVxuICAgKi9cbiAgY2xhc3MgVGVtcGxhdGVTdGFtcCBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgLyoqXG4gICAgICogU2NhbnMgYSB0ZW1wbGF0ZSB0byBwcm9kdWNlIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogVGVtcGxhdGUtc3BlY2lmaWMgbWV0YWRhdGEgYXJlIHN0b3JlZCBpbiB0aGUgb2JqZWN0IHJldHVybmVkLCBhbmQgbm9kZS1cbiAgICAgKiBzcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIG9iamVjdHMgaW4gaXRzIGZsYXR0ZW5lZCBgbm9kZUluZm9MaXN0YFxuICAgICAqIGFycmF5LiAgT25seSBub2RlcyBpbiB0aGUgdGVtcGxhdGUgdGhhdCB3ZXJlIHBhcnNlZCBhcyBub2RlcyBvZlxuICAgICAqIGludGVyZXN0IGNvbnRhaW4gYW4gb2JqZWN0IGluIGBub2RlSW5mb0xpc3RgLiAgRWFjaCBgbm9kZUluZm9gIG9iamVjdFxuICAgICAqIGNvbnRhaW5zIGFuIGBpbmRleGAgKGBjaGlsZE5vZGVzYCBpbmRleCBpbiBwYXJlbnQpIGFuZCBvcHRpb25hbGx5XG4gICAgICogYHBhcmVudGAsIHdoaWNoIHBvaW50cyB0byBub2RlIGluZm8gb2YgaXRzIHBhcmVudCAoaW5jbHVkaW5nIGl0cyBpbmRleCkuXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0IHJldHVybmVkIGZyb20gdGhpcyBtZXRob2QgaGFzIHRoZSBmb2xsb3dpbmdcbiAgICAgKiBzdHJ1Y3R1cmUgKG1hbnkgZmllbGRzIG9wdGlvbmFsKTpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogICB7XG4gICAgICogICAgIC8vIEZsYXR0ZW5lZCBsaXN0IG9mIG5vZGUgbWV0YWRhdGEgKGZvciBub2RlcyB0aGF0IGdlbmVyYXRlZCBtZXRhZGF0YSlcbiAgICAgKiAgICAgbm9kZUluZm9MaXN0OiBbXG4gICAgICogICAgICAge1xuICAgICAqICAgICAgICAgLy8gYGlkYCBhdHRyaWJ1dGUgZm9yIGFueSBub2RlcyB3aXRoIGlkJ3MgZm9yIGdlbmVyYXRpbmcgYCRgIG1hcFxuICAgICAqICAgICAgICAgaWQ6IHtzdHJpbmd9LFxuICAgICAqICAgICAgICAgLy8gYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBtZXRhZGF0YVxuICAgICAqICAgICAgICAgZXZlbnRzOiBbXG4gICAgICogICAgICAgICAgIHtcbiAgICAgKiAgICAgICAgICAgICBuYW1lOiB7c3RyaW5nfSwgICAvLyBldmVudCBuYW1lXG4gICAgICogICAgICAgICAgICAgdmFsdWU6IHtzdHJpbmd9LCAgLy8gaGFuZGxlciBtZXRob2QgbmFtZVxuICAgICAqICAgICAgICAgICB9LCAuLi5cbiAgICAgKiAgICAgICAgIF0sXG4gICAgICogICAgICAgICAvLyBOb3RlcyB3aGVuIHRoZSB0ZW1wbGF0ZSBjb250YWluZWQgYSBgPHNsb3Q+YCBmb3Igc2hhZHkgRE9NXG4gICAgICogICAgICAgICAvLyBvcHRpbWl6YXRpb24gcHVycG9zZXNcbiAgICAgKiAgICAgICAgIGhhc0luc2VydGlvblBvaW50OiB7Ym9vbGVhbn0sXG4gICAgICogICAgICAgICAvLyBGb3IgbmVzdGVkIGA8dGVtcGxhdGU+YGAgbm9kZXMsIG5lc3RlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqICAgICAgICAgdGVtcGxhdGVJbmZvOiB7b2JqZWN0fSwgLy8gbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICogICAgICAgICAvLyBNZXRhZGF0YSB0byBhbGxvdyBlZmZpY2llbnQgcmV0cmlldmFsIG9mIGluc3RhbmNlZCBub2RlXG4gICAgICogICAgICAgICAvLyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgbWV0YWRhdGFcbiAgICAgKiAgICAgICAgIHBhcmVudEluZm86IHtudW1iZXJ9LCAgIC8vIHJlZmVyZW5jZSB0byBwYXJlbnQgbm9kZUluZm8+XG4gICAgICogICAgICAgICBwYXJlbnRJbmRleDoge251bWJlcn0sICAvLyBpbmRleCBpbiBwYXJlbnQncyBgY2hpbGROb2Rlc2AgY29sbGVjdGlvblxuICAgICAqICAgICAgICAgaW5mb0luZGV4OiB7bnVtYmVyfSwgICAgLy8gaW5kZXggb2YgdGhpcyBgbm9kZUluZm9gIGluIGB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0YFxuICAgICAqICAgICAgIH0sXG4gICAgICogICAgICAgLi4uXG4gICAgICogICAgIF0sXG4gICAgICogICAgIC8vIFdoZW4gdHJ1ZSwgdGhlIHRlbXBsYXRlIGhhZCB0aGUgYHN0cmlwLXdoaXRlc3BhY2VgIGF0dHJpYnV0ZVxuICAgICAqICAgICAvLyBvciB3YXMgbmVzdGVkIGluIGEgdGVtcGxhdGUgd2l0aCB0aGF0IHNldHRpbmdcbiAgICAgKiAgICAgc3RyaXBXaGl0ZXNwYWNlOiB7Ym9vbGVhbn0sXG4gICAgICogICAgIC8vIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBuZXN0ZWQgdGVtcGxhdGUgY29udGVudCBpcyBtb3ZlZCBpbnRvXG4gICAgICogICAgIC8vIGEgZG9jdW1lbnQgZnJhZ21lbnQgc3RvcmVkIGhlcmU7IHRoaXMgaXMgYW4gb3B0aW1pemF0aW9uIHRvXG4gICAgICogICAgIC8vIGF2b2lkIHRoZSBjb3N0IG9mIG5lc3RlZCB0ZW1wbGF0ZSBjbG9uaW5nXG4gICAgICogICAgIGNvbnRlbnQ6IHtEb2N1bWVudEZyYWdtZW50fVxuICAgICAqICAgfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qga2lja3Mgb2ZmIGEgcmVjdXJzaXZlIHRyZWV3YWxrIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiAgICBfcGFyc2VUZW1wbGF0ZSA8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgICAqICAgICAgX3BhcnNlVGVtcGxhdGVDb250ZW50ICAgICAgICAgICAgICB8XG4gICAgICogICAgICAgIF9wYXJzZVRlbXBsYXRlTm9kZSAgPC0tLS0tLS0tLS0tLXwtLStcbiAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlIC0tKyAgfFxuICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyAtLS0tLS0tLS0rXG4gICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlc1xuICAgICAqICAgICAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlXG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIFRoZXNlIG1ldGhvZHMgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWRkIGN1c3RvbSBtZXRhZGF0YSBhYm91dCB0ZW1wbGF0ZXNcbiAgICAgKiB0byBlaXRoZXIgYHRlbXBsYXRlSW5mb2Agb3IgYG5vZGVJbmZvYC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCBtYXkgYmUgZGVzdHJ1Y3RpdmUgdG8gdGhlIHRlbXBsYXRlLCBpbiB0aGF0XG4gICAgICogZS5nLiBldmVudCBhbm5vdGF0aW9ucyBtYXkgYmUgcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm89fSBvdXRlclRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmcm9tIHRoZSBvdXRlclxuICAgICAqICAgdGVtcGxhdGUsIGZvciBwYXJzaW5nIG5lc3RlZCB0ZW1wbGF0ZXNcbiAgICAgKiBAcmV0dXJuIHshVGVtcGxhdGVJbmZvfSBQYXJzZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUsIG91dGVyVGVtcGxhdGVJbmZvKSB7XG4gICAgICAvLyBzaW5jZSBhIHRlbXBsYXRlIG1heSBiZSByZS11c2VkLCBtZW1vLWl6ZSBtZXRhZGF0YVxuICAgICAgaWYgKCF0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZS5fdGVtcGxhdGVJbmZvID0ge307XG4gICAgICAgIHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QgPSBbXTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSA9XG4gICAgICAgICAgKG91dGVyVGVtcGxhdGVJbmZvICYmIG91dGVyVGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSkgfHxcbiAgICAgICAgICB0ZW1wbGF0ZS5oYXNBdHRyaWJ1dGUoJ3N0cmlwLXdoaXRlc3BhY2UnKTtcbiAgICAgICAgdGhpcy5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywge3BhcmVudDogbnVsbH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRlbXBsYXRlLl90ZW1wbGF0ZUluZm87XG4gICAgfVxuXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlKHRlbXBsYXRlLmNvbnRlbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBub2RlIGFuZCBhZGRzIHRlbXBsYXRlIGFuZCBub2RlIG1ldGFkYXRhIGJhc2VkIG9uXG4gICAgICogdGhlIGN1cnJlbnQgbm9kZSwgYW5kIGl0cyBgY2hpbGROb2Rlc2AgYW5kIGBhdHRyaWJ1dGVzYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFkZCBjdXN0b20gbm9kZSBvciB0ZW1wbGF0ZSBzcGVjaWZpY1xuICAgICAqIG1ldGFkYXRhIGJhc2VkIG9uIHRoaXMgbm9kZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHshVGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgbm90ZWQ7XG4gICAgICBsZXQgZWxlbWVudCA9IC8qKiBAdHlwZSBFbGVtZW50ICovKG5vZGUpO1xuICAgICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09ICd0ZW1wbGF0ZScgJiYgIWVsZW1lbnQuaGFzQXR0cmlidXRlKCdwcmVzZXJ2ZS1jb250ZW50JykpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICAgICAgLy8gRm9yIFNoYWR5RG9tIG9wdGltaXphdGlvbiwgaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgICAgdGVtcGxhdGVJbmZvLmhhc0luc2VydGlvblBvaW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlQ2hpbGROb2RlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZXMgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgbm90ZWQgPSB0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZXMoZWxlbWVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykgfHwgbm90ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIGNoaWxkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gcm9vdCBub2RlLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgYWxzbyB3cmFwcyB3aGl0ZWxpc3RlZCBsZWdhY3kgdGVtcGxhdGUgZXh0ZW5zaW9uc1xuICAgICAqIChgaXM9XCJkb20taWZcImAgYW5kIGBpcz1cImRvbS1yZXBlYXRcImApIHdpdGggdGhlaXIgZXF1aXZhbGVudCBlbGVtZW50XG4gICAgICogd3JhcHBlcnMsIGNvbGxhcHNlcyB0ZXh0IG5vZGVzLCBhbmQgc3RyaXBzIHdoaXRlc3BhY2UgZnJvbSB0aGUgdGVtcGxhdGVcbiAgICAgKiBpZiB0aGUgYHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlc3BhY2VgIHNldHRpbmcgd2FzIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSByb290IFJvb3Qgbm9kZSB3aG9zZSBgY2hpbGROb2Rlc2Agd2lsbCBiZSBwYXJzZWRcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZUNoaWxkTm9kZXMocm9vdCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgZm9yIChsZXQgbm9kZT1yb290LmZpcnN0Q2hpbGQsIHBhcmVudEluZGV4PTAsIG5leHQ7IG5vZGU7IG5vZGU9bmV4dCkge1xuICAgICAgICAvLyBXcmFwIHRlbXBsYXRlc1xuICAgICAgICBpZiAobm9kZS5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgIG5vZGUgPSB3cmFwVGVtcGxhdGVFeHRlbnNpb24obm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29sbGFwc2UgYWRqYWNlbnQgdGV4dE5vZGVzOiBmaXhlcyBhbiBJRSBpc3N1ZSB0aGF0IGNhbiBjYXVzZVxuICAgICAgICAvLyB0ZXh0IG5vZGVzIHRvIGJlIGluZXhwbGljYWJseSBzcGxpdCA9KFxuICAgICAgICAvLyBub3RlIHRoYXQgcm9vdC5ub3JtYWxpemUoKSBzaG91bGQgd29yayBidXQgZG9lcyBub3Qgc28gd2UgZG8gdGhpc1xuICAgICAgICAvLyBtYW51YWxseS5cbiAgICAgICAgbmV4dCA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIGxldCAvKiogTm9kZSAqLyBuID0gbmV4dDtcbiAgICAgICAgICB3aGlsZSAobiAmJiAobi5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpKSB7XG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ICs9IG4udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBuZXh0ID0gbi5uZXh0U2libGluZztcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgICAgICBuID0gbmV4dDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3B0aW9uYWxseSBzdHJpcCB3aGl0ZXNwYWNlXG4gICAgICAgICAgaWYgKHRlbXBsYXRlSW5mby5zdHJpcFdoaXRlU3BhY2UgJiYgIW5vZGUudGV4dENvbnRlbnQudHJpbSgpKSB7XG4gICAgICAgICAgICByb290LnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBjaGlsZEluZm8gPSB7IHBhcmVudEluZGV4LCBwYXJlbnRJbmZvOiBub2RlSW5mbyB9O1xuICAgICAgICBpZiAodGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBjaGlsZEluZm8pKSB7XG4gICAgICAgICAgY2hpbGRJbmZvLmluZm9JbmRleCA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3QucHVzaCgvKiogQHR5cGUgeyFOb2RlSW5mb30gKi8oY2hpbGRJbmZvKSkgLSAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluY3JlbWVudCBpZiBub3QgcmVtb3ZlZFxuICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgcGFyZW50SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0ZW1wbGF0ZSBjb250ZW50IGZvciB0aGUgZ2l2ZW4gbmVzdGVkIGA8dGVtcGxhdGU+YC5cbiAgICAgKlxuICAgICAqIE5lc3RlZCB0ZW1wbGF0ZSBpbmZvIGlzIHN0b3JlZCBhcyBgdGVtcGxhdGVJbmZvYCBpbiB0aGUgY3VycmVudCBub2RlJ3NcbiAgICAgKiBgbm9kZUluZm9gLiBgdGVtcGxhdGUuY29udGVudGAgaXMgcmVtb3ZlZCBhbmQgc3RvcmVkIGluIGB0ZW1wbGF0ZUluZm9gLlxuICAgICAqIEl0IHdpbGwgdGhlbiBiZSB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIGhvc3QgdG8gc2V0IGl0IGJhY2sgdG8gdGhlXG4gICAgICogdGVtcGxhdGUgYW5kIGZvciB1c2VycyBzdGFtcGluZyBuZXN0ZWQgdGVtcGxhdGVzIHRvIHVzZSB0aGVcbiAgICAgKiBgX2NvbnRlbnRGb3JUZW1wbGF0ZWAgbWV0aG9kIHRvIHJldHJpZXZlIHRoZSBjb250ZW50IGZvciB0aGlzIHRlbXBsYXRlXG4gICAgICogKGFuIG9wdGltaXphdGlvbiB0byBhdm9pZCB0aGUgY29zdCBvZiBjbG9uaW5nIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlIChhIDx0ZW1wbGF0ZT4pXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogICB0aGF0IGluY2x1ZGVzIHRoZSB0ZW1wbGF0ZSBgbm9kZWBcbiAgICAgKiBAcGFyYW0geyFOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZS5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgb3V0ZXJUZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5fcGFyc2VUZW1wbGF0ZShub2RlLCBvdXRlclRlbXBsYXRlSW5mbyk7XG4gICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlSW5mby5jb250ZW50ID1cbiAgICAgICAgbm9kZS5jb250ZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgY29udGVudC5hcHBlbmRDaGlsZChub2RlLmNvbnRlbnQpO1xuICAgICAgbm9kZUluZm8udGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIG5vZGUgYXR0cmlidXRlcyBhbmQgYWRkcyBub2RlIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKiBmb3Igbm9kZXMgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICAvLyBNYWtlIGNvcHkgb2Ygb3JpZ2luYWwgYXR0cmlidXRlIGxpc3QsIHNpbmNlIHRoZSBvcmRlciBtYXkgY2hhbmdlXG4gICAgICAvLyBhcyBhdHRyaWJ1dGVzIGFyZSBhZGRlZCBhbmQgcmVtb3ZlZFxuICAgICAgbGV0IG5vdGVkID0gZmFsc2U7XG4gICAgICBsZXQgYXR0cnMgPSBBcnJheS5mcm9tKG5vZGUuYXR0cmlidXRlcyk7XG4gICAgICBmb3IgKGxldCBpPWF0dHJzLmxlbmd0aC0xLCBhOyAoYT1hdHRyc1tpXSk7IGktLSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGEubmFtZSwgYS52YWx1ZSkgfHwgbm90ZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgc2luZ2xlIHRlbXBsYXRlIG5vZGUgYXR0cmlidXRlIGFuZCBhZGRzIG5vZGUgbWV0YWRhdGEgdG9cbiAgICAgKiBgbm9kZUluZm9gIGZvciBhdHRyaWJ1dGVzIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogVGhpcyBpbXBsZW1lbnRhdGlvbiBhZGRzIG1ldGFkYXRhIGZvciBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIGF0dHJpYnV0ZXNcbiAgICAgKiBhbmQgYGlkYCBhdHRyaWJ1dGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIEF0dHJpYnV0ZSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKSB7XG4gICAgICAvLyBldmVudHMgKG9uLSopXG4gICAgICBpZiAobmFtZS5zbGljZSgwLCAzKSA9PT0gJ29uLScpIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIG5vZGVJbmZvLmV2ZW50cyA9IG5vZGVJbmZvLmV2ZW50cyB8fCBbXTtcbiAgICAgICAgbm9kZUluZm8uZXZlbnRzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IG5hbWUuc2xpY2UoMyksXG4gICAgICAgICAgdmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgLy8gc3RhdGljIGlkXG4gICAgICBlbHNlIGlmIChuYW1lID09PSAnaWQnKSB7XG4gICAgICAgIG5vZGVJbmZvLmlkID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGBjb250ZW50YCBkb2N1bWVudCBmcmFnbWVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEZvciBuZXN0ZWQgdGVtcGxhdGVzLCBQb2x5bWVyIHBlcmZvcm1zIGFuIG9wdGltaXphdGlvbiB0byBjYWNoZSBuZXN0ZWRcbiAgICAgKiB0ZW1wbGF0ZSBjb250ZW50IHRvIGF2b2lkIHRoZSBjb3N0IG9mIGNsb25pbmcgZGVlcGx5IG5lc3RlZCB0ZW1wbGF0ZXMuXG4gICAgICogVGhpcyBtZXRob2QgcmV0cmlldmVzIHRoZSBjYWNoZWQgY29udGVudCBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcmV0cmlldmUgYGNvbnRlbnRgIGZvclxuICAgICAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9IENvbnRlbnQgZnJhZ21lbnRcbiAgICAgKi9cbiAgICBzdGF0aWMgX2NvbnRlbnRGb3JUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudFdpdGhJbmZvfSAqLyAodGVtcGxhdGUpLl90ZW1wbGF0ZUluZm87XG4gICAgICByZXR1cm4gKHRlbXBsYXRlSW5mbyAmJiB0ZW1wbGF0ZUluZm8uY29udGVudCkgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbG9uZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGNvbnRlbnQgYW5kIHJldHVybnMgYSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqIGNvbnRhaW5pbmcgdGhlIGNsb25lZCBkb20uXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcGxhdGUgaXMgcGFyc2VkIChvbmNlIGFuZCBtZW1vaXplZCkgdXNpbmcgdGhpcyBsaWJyYXJ5J3NcbiAgICAgKiB0ZW1wbGF0ZSBwYXJzaW5nIGZlYXR1cmVzLCBhbmQgcHJvdmlkZXMgdGhlIGZvbGxvd2luZyB2YWx1ZS1hZGRlZFxuICAgICAqIGZlYXR1cmVzOlxuICAgICAqICogQWRkcyBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAqICogR2VuZXJhdGVzIGFuIFwiaWQgbWFwXCIgZm9yIGFsbCBub2RlcyB3aXRoIGlkJ3MgdW5kZXIgYCRgIG9uIHJldHVybmVkXG4gICAgICogICBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqICogUGFzc2VzIHRlbXBsYXRlIGluZm8gaW5jbHVkaW5nIGBjb250ZW50YCBiYWNrIHRvIHRlbXBsYXRlcyBhc1xuICAgICAqICAgYF90ZW1wbGF0ZUluZm9gIChhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiB0byBhdm9pZCBkZWVwIHRlbXBsYXRlXG4gICAgICogICBjbG9uaW5nKVxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoZSBtZW1vaXplZCB0ZW1wbGF0ZSBwYXJzaW5nIHByb2Nlc3MgaXMgZGVzdHJ1Y3RpdmUgdG8gdGhlXG4gICAgICogdGVtcGxhdGU6IGF0dHJpYnV0ZXMgZm9yIGJpbmRpbmdzIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMgYXJlXG4gICAgICogcmVtb3ZlZCBhZnRlciBiZWluZyBub3RlZCBpbiBub3RlcywgYW5kIGFueSBuZXN0ZWQgYDx0ZW1wbGF0ZT4uY29udGVudGBcbiAgICAgKiBpcyByZW1vdmVkIGFuZCBzdG9yZWQgaW4gbm90ZXMgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgKi9cbiAgICBfc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgLy8gUG9seWZpbGwgc3VwcG9ydDogYm9vdHN0cmFwIHRoZSB0ZW1wbGF0ZSBpZiBpdCBoYXMgbm90IGFscmVhZHkgYmVlblxuICAgICAgaWYgKHRlbXBsYXRlICYmICF0ZW1wbGF0ZS5jb250ZW50ICYmXG4gICAgICAgICAgd2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQgJiYgSFRNTFRlbXBsYXRlRWxlbWVudC5kZWNvcmF0ZSkge1xuICAgICAgICBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKHRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLmNvbnN0cnVjdG9yLl9wYXJzZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGxldCBub2RlSW5mbyA9IHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3Q7XG4gICAgICBsZXQgY29udGVudCA9IHRlbXBsYXRlSW5mby5jb250ZW50IHx8IHRlbXBsYXRlLmNvbnRlbnQ7XG4gICAgICBsZXQgZG9tID0gLyoqIEB0eXBlIERvY3VtZW50RnJhZ21lbnQgKi8gKGRvY3VtZW50LmltcG9ydE5vZGUoY29udGVudCwgdHJ1ZSkpO1xuICAgICAgLy8gTk9URTogU2hhZHlEb20gb3B0aW1pemF0aW9uIGluZGljYXRpbmcgdGhlcmUgaXMgYW4gaW5zZXJ0aW9uIHBvaW50XG4gICAgICBkb20uX19ub0luc2VydGlvblBvaW50ID0gIXRlbXBsYXRlSW5mby5oYXNJbnNlcnRpb25Qb2ludDtcbiAgICAgIGxldCBub2RlcyA9IGRvbS5ub2RlTGlzdCA9IG5ldyBBcnJheShub2RlSW5mby5sZW5ndGgpO1xuICAgICAgZG9tLiQgPSB7fTtcbiAgICAgIGZvciAobGV0IGk9MCwgbD1ub2RlSW5mby5sZW5ndGgsIGluZm87IChpPGwpICYmIChpbmZvPW5vZGVJbmZvW2ldKTsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV0gPSBmaW5kVGVtcGxhdGVOb2RlKGRvbSwgaW5mbyk7XG4gICAgICAgIGFwcGx5SWRUb01hcCh0aGlzLCBkb20uJCwgbm9kZSwgaW5mbyk7XG4gICAgICAgIGFwcGx5VGVtcGxhdGVDb250ZW50KHRoaXMsIG5vZGUsIGluZm8pO1xuICAgICAgICBhcHBseUV2ZW50TGlzdGVuZXIodGhpcywgbm9kZSwgaW5mbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHshU3RhbXBlZFRlbXBsYXRlfSAqLyhkb20pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgYnkgbWV0aG9kIG5hbWUgZm9yIHRoZSBldmVudCBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGdlbmVyYXRlcyBhIGhhbmRsZXIgZnVuY3Rpb24gdGhhdCBsb29rcyB1cCB0aGUgbWV0aG9kXG4gICAgICogbmFtZSBhdCBoYW5kbGluZyB0aW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYWRkIGxpc3RlbmVyIG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBtZXRob2RcbiAgICAgKiBAcGFyYW0geyo9fSBjb250ZXh0IENvbnRleHQgdGhlIG1ldGhvZCB3aWxsIGJlIGNhbGxlZCBvbiAoZGVmYXVsdHNcbiAgICAgKiAgIHRvIGBub2RlYClcbiAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gR2VuZXJhdGVkIGhhbmRsZXIgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBfYWRkTWV0aG9kRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIG1ldGhvZE5hbWUsIGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG5vZGU7XG4gICAgICBsZXQgaGFuZGxlciA9IGNyZWF0ZU5vZGVFdmVudEhhbmRsZXIoY29udGV4dCwgZXZlbnROYW1lLCBtZXRob2ROYW1lKTtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIHJldHVybiBoYW5kbGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGFkZCBldmVudCBsaXN0ZW5lciB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gYWRkXG4gICAgICovXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBwb2ludCBmb3IgYWRkaW5nIGN1c3RvbSBvciBzaW11bGF0ZWQgZXZlbnQgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byByZW1vdmUgZXZlbnQgbGlzdGVuZXIgZnJvbVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgTGlzdGVuZXIgZnVuY3Rpb24gdG8gcmVtb3ZlXG4gICAgICovXG4gICAgX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFRlbXBsYXRlU3RhbXA7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3RlbXBsYXRlLXN0YW1wLmpzXG4vLyBtb2R1bGUgaWQgPSA2MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8vIHJ1biBhIGNhbGxiYWNrIHdoZW4gSFRNTEltcG9ydHMgYXJlIHJlYWR5IG9yIGltbWVkaWF0ZWx5IGlmXG4vLyB0aGlzIGFwaSBpcyBub3QgYXZhaWxhYmxlLlxuZnVuY3Rpb24gd2hlbkltcG9ydHNSZWFkeShjYikge1xuICBpZiAod2luZG93LkhUTUxJbXBvcnRzKSB7XG4gICAgSFRNTEltcG9ydHMud2hlblJlYWR5KGNiKTtcbiAgfSBlbHNlIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbXBvcnRIcmVmID0gZnVuY3Rpb24oaHJlZiwgb25sb2FkLCBvbmVycm9yLCBvcHRBc3luYykge1xuICBsZXQgbGluayA9IC8qKiBAdHlwZSB7SFRNTExpbmtFbGVtZW50fSAqL1xuICAgIChkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZj1cIicgKyBocmVmICsgJ1wiXVtpbXBvcnQtaHJlZl0nKSk7XG4gIGlmICghbGluaykge1xuICAgIGxpbmsgPSAvKiogQHR5cGUge0hUTUxMaW5rRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKSk7XG4gICAgbGluay5yZWwgPSAnaW1wb3J0JztcbiAgICBsaW5rLmhyZWYgPSBocmVmO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCdpbXBvcnQtaHJlZicsICcnKTtcbiAgfVxuICAvLyBhbHdheXMgZW5zdXJlIGxpbmsgaGFzIGBhc3luY2AgYXR0cmlidXRlIGlmIHVzZXIgc3BlY2lmaWVkIG9uZSxcbiAgLy8gZXZlbiBpZiBpdCB3YXMgcHJldmlvdXNseSBub3QgYXN5bmMuIFRoaXMgaXMgY29uc2lkZXJlZCBsZXNzIGNvbmZ1c2luZy5cbiAgaWYgKG9wdEFzeW5jKSB7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoJ2FzeW5jJywgJycpO1xuICB9XG4gIC8vIE5PVEU6IHRoZSBsaW5rIG1heSBub3cgYmUgaW4gMyBzdGF0ZXM6ICgxKSBwZW5kaW5nIGluc2VydGlvbixcbiAgLy8gKDIpIGluZmxpZ2h0LCAoMykgYWxyZWFkeSBsYW9kZWQuIEluIGVhY2ggY2FzZSwgd2UgbmVlZCB0byBhZGRcbiAgLy8gZXZlbnQgbGlzdGVuZXJzIHRvIHByb2Nlc3MgY2FsbGJhY2tzLlxuICBsZXQgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lcik7XG4gICAgbGluay5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICB9O1xuICBsZXQgbG9hZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgLy8gSW4gY2FzZSBvZiBhIHN1Y2Nlc3NmdWwgbG9hZCwgY2FjaGUgdGhlIGxvYWQgZXZlbnQgb24gdGhlIGxpbmsgc29cbiAgICAvLyB0aGF0IGl0IGNhbiBiZSB1c2VkIHRvIHNob3J0LWNpcmN1aXQgdGhpcyBtZXRob2QgaW4gdGhlIGZ1dHVyZSB3aGVuXG4gICAgLy8gaXQgaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgaHJlZiBwYXJhbS5cbiAgICBsaW5rLl9fZHluYW1pY0ltcG9ydExvYWRlZCA9IHRydWU7XG4gICAgaWYgKG9ubG9hZCkge1xuICAgICAgd2hlbkltcG9ydHNSZWFkeSgoKSA9PiB7XG4gICAgICAgIG9ubG9hZChldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGxldCBlcnJvckxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciwgcmVtb3ZlIHRoZSBsaW5rIGZyb20gdGhlIGRvY3VtZW50IHNvIHRoYXQgaXRcbiAgICAvLyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBhZ2FpbiB0aGUgbmV4dCB0aW1lIGBpbXBvcnRIcmVmYCBpc1xuICAgIC8vIGNhbGxlZC5cbiAgICBpZiAobGluay5wYXJlbnROb2RlKSB7XG4gICAgICBsaW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgfVxuICAgIGlmIChvbmVycm9yKSB7XG4gICAgICB3aGVuSW1wb3J0c1JlYWR5KCgpID0+IHtcbiAgICAgICAgb25lcnJvcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lcik7XG4gIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgaWYgKGxpbmsucGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgLy8gaWYgdGhlIGxpbmsgYWxyZWFkeSBsb2FkZWQsIGRpc3BhdGNoIGEgZmFrZSBsb2FkIGV2ZW50XG4gIC8vIHNvIHRoYXQgbGlzdGVuZXJzIGFyZSBjYWxsZWQgYW5kIGdldCBhIHByb3BlciBldmVudCBhcmd1bWVudC5cbiAgfSBlbHNlIGlmIChsaW5rLl9fZHluYW1pY0ltcG9ydExvYWRlZCkge1xuICAgIGxpbmsuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2xvYWQnKSk7XG4gIH1cbiAgcmV0dXJuIGxpbms7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKCd1bnJlc29sdmVkJyk7XG59XG5cbmlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgcmVzb2x2ZSgpO1xufSBlbHNlIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCByZXNvbHZlKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDYyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNwbGljZXMgfSBmcm9tICcuL2FycmF5LXNwbGljZS5qcyc7XG5pbXBvcnQgeyBtaWNyb1Rhc2sgfSBmcm9tICcuL2FzeW5jLmpzJztcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYG5vZGVgIGlzIGEgc2xvdCBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIE5vZGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGEgc2xvdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTbG90KG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKTtcbn1cblxuLyoqXG4gKiBDbGFzcyB0aGF0IGxpc3RlbnMgZm9yIGNoYW5nZXMgKGFkZGl0aW9ucyBvciByZW1vdmFscykgdG9cbiAqIFwiZmxhdHRlbmVkIG5vZGVzXCIgb24gYSBnaXZlbiBgbm9kZWAuIFRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBjb25zaXN0c1xuICogb2YgYSBub2RlJ3MgY2hpbGRyZW4gYW5kLCBmb3IgYW55IGNoaWxkcmVuIHRoYXQgYXJlIGA8c2xvdD5gIGVsZW1lbnRzLFxuICogdGhlIGV4cGFuZGVkIGZsYXR0ZW5lZCBsaXN0IG9mIGBhc3NpZ25lZE5vZGVzYC5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgb2JzZXJ2ZWQgbm9kZSBoYXMgY2hpbGRyZW4gYDxhPjwvYT48c2xvdD48L3Nsb3Q+PGI+PC9iPmBcbiAqIGFuZCB0aGUgYDxzbG90PmAgaGFzIG9uZSBgPGRpdj5gIGFzc2lnbmVkIHRvIGl0LCB0aGVuIHRoZSBmbGF0dGVuZWRcbiAqIG5vZGVzIGxpc3QgaXMgYDxhPjwvYT48ZGl2PjwvZGl2PjxiPjwvYj5gLiBJZiB0aGUgYDxzbG90PmAgaGFzIG90aGVyXG4gKiBgPHNsb3Q+YCBlbGVtZW50cyBhc3NpZ25lZCB0byBpdCwgdGhlc2UgYXJlIGZsYXR0ZW5lZCBhcyB3ZWxsLlxuICpcbiAqIFRoZSBwcm92aWRlZCBgY2FsbGJhY2tgIGlzIGNhbGxlZCB3aGVuZXZlciBhbnkgY2hhbmdlIHRvIHRoaXMgbGlzdFxuICogb2YgZmxhdHRlbmVkIG5vZGVzIG9jY3Vycywgd2hlcmUgYW4gYWRkaXRpb24gb3IgcmVtb3ZhbCBvZiBhIG5vZGUgaXNcbiAqIGNvbnNpZGVyZWQgYSBjaGFuZ2UuIFRoZSBgY2FsbGJhY2tgIGlzIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0XG4gKiBjb250YWluaW5nIGFuIGFycmF5IG9mIGFueSBgYWRkZWROb2Rlc2AgYW5kIGByZW1vdmVkTm9kZXNgLlxuICpcbiAqIE5vdGU6IHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgYXN5bmNocm9ub3VzIHRvIGFueSBjaGFuZ2VzXG4gKiBhdCBhIG1pY3JvdGFzayBjaGVja3BvaW50LiBUaGlzIGlzIGJlY2F1c2Ugb2JzZXJ2YXRpb24gaXMgcGVyZm9ybWVkIHVzaW5nXG4gKiBgTXV0YXRpb25PYnNlcnZlcmAgYW5kIHRoZSBgPHNsb3Q+YCBlbGVtZW50J3MgYHNsb3RjaGFuZ2VgIGV2ZW50IHdoaWNoXG4gKiBhcmUgYXN5bmNocm9ub3VzLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDbGFzcyB0aGF0IGxpc3RlbnMgZm9yIGNoYW5nZXMgKGFkZGl0aW9ucyBvciByZW1vdmFscykgdG9cbiAqIFwiZmxhdHRlbmVkIG5vZGVzXCIgb24gYSBnaXZlbiBgbm9kZWAuXG4gKi9cbmNsYXNzIEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBmb3IgdGhlIGdpdmVuIGBub2RlYC5cbiAgICogVGhpcyBsaXN0IGNvbnNpc3RzIG9mIGEgbm9kZSdzIGNoaWxkcmVuIGFuZCwgZm9yIGFueSBjaGlsZHJlblxuICAgKiB0aGF0IGFyZSBgPHNsb3Q+YCBlbGVtZW50cywgdGhlIGV4cGFuZGVkIGZsYXR0ZW5lZCBsaXN0IG9mIGBhc3NpZ25lZE5vZGVzYC5cbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBvYnNlcnZlZCBub2RlIGhhcyBjaGlsZHJlbiBgPGE+PC9hPjxzbG90Pjwvc2xvdD48Yj48L2I+YFxuICAgKiBhbmQgdGhlIGA8c2xvdD5gIGhhcyBvbmUgYDxkaXY+YCBhc3NpZ25lZCB0byBpdCwgdGhlbiB0aGUgZmxhdHRlbmVkXG4gICAqIG5vZGVzIGxpc3QgaXMgYDxhPjwvYT48ZGl2PjwvZGl2PjxiPjwvYj5gLiBJZiB0aGUgYDxzbG90PmAgaGFzIG90aGVyXG4gICAqIGA8c2xvdD5gIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0LCB0aGVzZSBhcmUgZmxhdHRlbmVkIGFzIHdlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTFNsb3RFbGVtZW50fSBub2RlIFRoZSBub2RlIGZvciB3aGljaCB0byByZXR1cm4gdGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gYG5vZGVgLlxuICAqL1xuICBzdGF0aWMgZ2V0RmxhdHRlbmVkTm9kZXMobm9kZSkge1xuICAgIGlmIChpc1Nsb3Qobm9kZSkpIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxTbG90RWxlbWVudH0gKi8gKG5vZGUpLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5tYXAobm9kZSA9PiB7XG4gICAgICAgIGlmIChpc1Nsb3Qobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MU2xvdEVsZW1lbnR9ICovIChub2RlKS5hc3NpZ25lZE5vZGVzKHtmbGF0dGVuOiB0cnVlfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgfVxuICAgICAgfSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldCBOb2RlIG9uIHdoaWNoIHRvIGxpc3RlbiBmb3IgY2hhbmdlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlcmUgYXJlIGFkZGl0aW9uc1xuICAgKiBvciByZW1vdmFscyBmcm9tIHRoZSB0YXJnZXQncyBsaXN0IG9mIGZsYXR0ZW5lZCBub2Rlcy5cbiAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIC8qKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzID0gW107XG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKX0gKi9cbiAgICB0aGlzLl9ib3VuZFNjaGVkdWxlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9O1xuICAgIHRoaXMuY29ubmVjdCgpO1xuICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIGFuIG9ic2VydmVyLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuXG4gICAqIGEgYEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIGlzIGNyZWF0ZWQuIEl0IHNob3VsZCBvbmx5IGJlIGNhbGxlZCB0b1xuICAgKiByZS1hY3RpdmF0ZSBhbiBvYnNlcnZlciB0aGF0IGhhcyBiZWVuIGRlYWN0aXZhdGVkIHZpYSB0aGUgYGRpc2Nvbm5lY3RgIG1ldGhvZC5cbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgaWYgKGlzU2xvdCh0aGlzLl90YXJnZXQpKSB7XG4gICAgICB0aGlzLl9saXN0ZW5TbG90cyhbdGhpcy5fdGFyZ2V0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpc3RlblNsb3RzKHRoaXMuX3RhcmdldC5jaGlsZHJlbik7XG4gICAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9XG4gICAgICAgICAgU2hhZHlET00ub2JzZXJ2ZUNoaWxkcmVuKHRoaXMuX3RhcmdldCwgKG11dGF0aW9ucykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9XG4gICAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyLm9ic2VydmUodGhpcy5fdGFyZ2V0LCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGZsYXR0ZW5lZCBub2RlcyBvYnNlcnZlci4gQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIHdoZW4gY2hhbmdlcyB0byBmbGF0dGVuZWQgbm9kZXNcbiAgICogb2NjdXIuIFRoZSBgY29ubmVjdGAgbWV0aG9kIG1heSBiZSBzdWJzZXF1ZW50bHkgY2FsbGVkIHRvIHJlYWN0aXZhdGVcbiAgICogdGhlIG9ic2VydmVyLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAoaXNTbG90KHRoaXMuX3RhcmdldCkpIHtcbiAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHMoW3RoaXMuX3RhcmdldF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91bmxpc3RlblNsb3RzKHRoaXMuX3RhcmdldC5jaGlsZHJlbik7XG4gICAgICBpZiAod2luZG93LlNoYWR5RE9NICYmIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICBTaGFkeURPTS51bm9ic2VydmVDaGlsZHJlbih0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpO1xuICAgICAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gIH1cblxuICBfc2NoZWR1bGUoKSB7XG4gICAgaWYgKCF0aGlzLl9zY2hlZHVsZWQpIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBtaWNyb1Rhc2sucnVuKCgpID0+IHRoaXMuZmx1c2goKSk7XG4gICAgfVxuICB9XG5cbiAgX3Byb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnMobXV0YXRpb25zKTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cblxuICBfcHJvY2Vzc1Nsb3RNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgaWYgKG11dGF0aW9ucykge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBtdXRhdGlvbiA9IG11dGF0aW9uc1tpXTtcbiAgICAgICAgaWYgKG11dGF0aW9uLmFkZGVkTm9kZXMpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5TbG90cyhtdXRhdGlvbi5hZGRlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXV0YXRpb24ucmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgICAgdGhpcy5fdW5saXN0ZW5TbG90cyhtdXRhdGlvbi5yZW1vdmVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoZXMgdGhlIG9ic2VydmVyIGNhdXNpbmcgYW55IHBlbmRpbmcgY2hhbmdlcyB0byBiZSBpbW1lZGlhdGVseVxuICAgKiBkZWxpdmVyZWQgdGhlIG9ic2VydmVyIGNhbGxiYWNrLiBCeSBkZWZhdWx0IHRoZXNlIGNoYW5nZXMgYXJlIGRlbGl2ZXJlZFxuICAgKiBhc3luY2hyb25vdXNseSBhdCB0aGUgbmV4dCBtaWNyb3Rhc2sgY2hlY2twb2ludC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwZW5kaW5nIGNoYW5nZXMgY2F1c2VkIHRoZSBvYnNlcnZlclxuICAgKiBjYWxsYmFjayB0byBydW4uXG4gICAqL1xuICBmbHVzaCgpIHtcbiAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICBTaGFkeURPTS5mbHVzaCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnModGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnModGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgIH1cbiAgICB0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBsZXQgaW5mbyA9IHtcbiAgICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LFxuICAgICAgYWRkZWROb2RlczogW10sXG4gICAgICByZW1vdmVkTm9kZXM6IFtdXG4gICAgfTtcbiAgICBsZXQgbmV3Tm9kZXMgPSB0aGlzLmNvbnN0cnVjdG9yLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMuX3RhcmdldCk7XG4gICAgbGV0IHNwbGljZXMgPSBjYWxjdWxhdGVTcGxpY2VzKG5ld05vZGVzLFxuICAgICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMpO1xuICAgIC8vIHByb2Nlc3MgcmVtb3ZhbHNcbiAgICBmb3IgKGxldCBpPTAsIHM7IChpPHNwbGljZXMubGVuZ3RoKSAmJiAocz1zcGxpY2VzW2ldKTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqPTAsIG47IChqIDwgcy5yZW1vdmVkLmxlbmd0aCkgJiYgKG49cy5yZW1vdmVkW2pdKTsgaisrKSB7XG4gICAgICAgIGluZm8ucmVtb3ZlZE5vZGVzLnB1c2gobik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHByb2Nlc3MgYWRkc1xuICAgIGZvciAobGV0IGk9MCwgczsgKGk8c3BsaWNlcy5sZW5ndGgpICYmIChzPXNwbGljZXNbaV0pOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGo9cy5pbmRleDsgaiA8IHMuaW5kZXggKyBzLmFkZGVkQ291bnQ7IGorKykge1xuICAgICAgICBpbmZvLmFkZGVkTm9kZXMucHVzaChuZXdOb2Rlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBjYWNoZVxuICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzID0gbmV3Tm9kZXM7XG4gICAgbGV0IGRpZEZsdXNoID0gZmFsc2U7XG4gICAgaWYgKGluZm8uYWRkZWROb2Rlcy5sZW5ndGggfHwgaW5mby5yZW1vdmVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBkaWRGbHVzaCA9IHRydWU7XG4gICAgICB0aGlzLmNhbGxiYWNrLmNhbGwodGhpcy5fdGFyZ2V0LCBpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZEZsdXNoO1xuICB9XG5cbiAgX2xpc3RlblNsb3RzKG5vZGVMaXN0KSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuID0gbm9kZUxpc3RbaV07XG4gICAgICBpZiAoaXNTbG90KG4pKSB7XG4gICAgICAgIG4uYWRkRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMuX2JvdW5kU2NoZWR1bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF91bmxpc3RlblNsb3RzKG5vZGVMaXN0KSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuID0gbm9kZUxpc3RbaV07XG4gICAgICBpZiAoaXNTbG90KG4pKSB7XG4gICAgICAgIG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMuX2JvdW5kU2NoZWR1bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCB7IEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgTGVnYWN5RWxlbWVudE1peGluIH0gZnJvbSAnLi9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyc7XG5pbXBvcnQgeyBEb21Nb2R1bGUgfSBmcm9tICcuLi9lbGVtZW50cy9kb20tbW9kdWxlLmpzJztcblxubGV0IG1ldGFQcm9wcyA9IHtcbiAgYXR0YWNoZWQ6IHRydWUsXG4gIGRldGFjaGVkOiB0cnVlLFxuICByZWFkeTogdHJ1ZSxcbiAgY3JlYXRlZDogdHJ1ZSxcbiAgYmVmb3JlUmVnaXN0ZXI6IHRydWUsXG4gIHJlZ2lzdGVyZWQ6IHRydWUsXG4gIGF0dHJpYnV0ZUNoYW5nZWQ6IHRydWUsXG4gIC8vIG1ldGEgb2JqZWN0c1xuICBiZWhhdmlvcnM6IHRydWVcbn07XG5cbi8qKlxuICogQXBwbGllcyBhIFwibGVnYWN5XCIgYmVoYXZpb3Igb3IgYXJyYXkgb2YgYmVoYXZpb3JzIHRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCB3aWxsIGF1dG9tYXRpY2FsbHkgYWxzbyBhcHBseSB0aGUgYFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluYFxuICogdG8gZW5zdXJlIHRoYXQgYW55IGxlZ2FjeSBiZWhhdmlvcnMgY2FuIHJlbHkgb24gbGVnYWN5IFBvbHltZXIgQVBJIG9uXG4gKiB0aGUgdW5kZXJseWluZyBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7IShPYmplY3R8QXJyYXkpfSBiZWhhdmlvcnMgQmVoYXZpb3Igb2JqZWN0IG9yIGFycmF5IG9mIGJlaGF2aW9ycy5cbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fGZ1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IGtsYXNzIEVsZW1lbnQgY2xhc3MuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBSZXR1cm5zIGEgbmV3IEVsZW1lbnQgY2xhc3MgZXh0ZW5kZWQgYnkgdGhlXG4gKiBwYXNzZWQgaW4gYGJlaGF2aW9yc2AgYW5kIGFsc28gYnkgYFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluYC5cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0cywgY2hlY2tUeXBlc31cbiAqL1xuZnVuY3Rpb24gbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcykge1xuICBpZiAoIWJlaGF2aW9ycykge1xuICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhrbGFzcyk7XG4gIH1cbiAgLy8gTk9URTogZW5zdXJlIHRoZSBiYWhldmlvciBpcyBleHRlbmRpbmcgYSBjbGFzcyB3aXRoXG4gIC8vIGxlZ2FjeSBlbGVtZW50IGFwaS4gVGhpcyBpcyBuZWNlc3Nhcnkgc2luY2UgYmVoYXZpb3JzIGV4cGVjdCB0byBiZSBhYmxlXG4gIC8vIHRvIGFjY2VzcyAxLnggbGVnYWN5IGFwaS5cbiAga2xhc3MgPSBMZWdhY3lFbGVtZW50TWl4aW4oa2xhc3MpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYmVoYXZpb3JzKSkge1xuICAgIGJlaGF2aW9ycyA9IFtiZWhhdmlvcnNdO1xuICB9XG4gIGxldCBzdXBlckJlaGF2aW9ycyA9IGtsYXNzLnByb3RvdHlwZS5iZWhhdmlvcnM7XG4gIC8vIGdldCBmbGF0dGVuZWQsIGRlZHVwZWQgbGlzdCBvZiBiZWhhdmlvcnMgKm5vdCogYWxyZWFkeSBvbiBzdXBlciBjbGFzc1xuICBiZWhhdmlvcnMgPSBmbGF0dGVuQmVoYXZpb3JzKGJlaGF2aW9ycywgbnVsbCwgc3VwZXJCZWhhdmlvcnMpO1xuICAvLyBtaXhpbiBuZXcgYmVoYXZpb3JzXG4gIGtsYXNzID0gX21peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpO1xuICBpZiAoc3VwZXJCZWhhdmlvcnMpIHtcbiAgICBiZWhhdmlvcnMgPSBzdXBlckJlaGF2aW9ycy5jb25jYXQoYmVoYXZpb3JzKTtcbiAgfVxuICAvLyBTZXQgYmVoYXZpb3JzIG9uIHByb3RvdHlwZSBmb3IgQkMuLi5cbiAga2xhc3MucHJvdG90eXBlLmJlaGF2aW9ycyA9IGJlaGF2aW9ycztcbiAgcmV0dXJuIGtsYXNzO1xufVxuXG4vLyBOT1RFOlxuLy8gMS54XG4vLyBCZWhhdmlvcnMgd2VyZSBtaXhlZCBpbiAqaW4gcmV2ZXJzZSBvcmRlciogYW5kIGRlLWR1cGVkIG9uIHRoZSBmbHkuXG4vLyBUaGUgcnVsZSB3YXMgdGhhdCBiZWhhdmlvciBwcm9wZXJ0aWVzIHdlcmUgY29waWVkIG9udG8gdGhlIGVsZW1lbnRcbi8vIHByb3RvdHlwZSBpZiBhbmQgb25seSBpZiB0aGUgcHJvcGVydHkgZGlkIG5vdCBhbHJlYWR5IGV4aXN0LlxuLy8gR2l2ZW46IFBvbHltZXJ7IGJlaGF2aW9yczogW0EsIEIsIEMsIEEsIEJdfSwgcHJvcGVydHkgY29weSBvcmRlciB3YXM6XG4vLyAoMSksIEIsICgyKSwgQSwgKDMpIEMuIFRoaXMgbWVhbnMgcHJvdG90eXBlIHByb3BlcnRpZXMgd2luIG92ZXJcbi8vIEIgcHJvcGVydGllcyB3aW4gb3ZlciBBIHdpbiBvdmVyIEMuIFRoaXMgbWlycm9ycyB3aGF0IHdvdWxkIGhhcHBlblxuLy8gd2l0aCBpbmhlcml0YW5jZSBpZiBlbGVtZW50IGV4dGVuZGVkIEIgZXh0ZW5kZWQgQSBleHRlbmRlZCBDLlxuLy9cbi8vIEFnYWluIGdpdmVuLCBQb2x5bWVyeyBiZWhhdmlvcnM6IFtBLCBCLCBDLCBBLCBCXX0sIHRoZSByZXN1bHRpbmdcbi8vIGBiZWhhdmlvcnNgIGFycmF5IHdhcyBbQywgQSwgQl0uXG4vLyBCZWhhdmlvciBsaWZlY3ljbGUgbWV0aG9kcyB3ZXJlIGNhbGxlZCBpbiBiZWhhdmlvciBhcnJheSBvcmRlclxuLy8gZm9sbG93ZWQgYnkgdGhlIGVsZW1lbnQsIGUuZy4gKDEpIEMuY3JlYXRlZCwgKDIpIEEuY3JlYXRlZCxcbi8vICgzKSBCLmNyZWF0ZWQsICg0KSBlbGVtZW50LmNyZWF0ZWQuIFRoZXJlIHdhcyBubyBzdXBwb3J0IGZvclxuLy8gc3VwZXIsIGFuZCBcInN1cGVyLWJlaGF2aW9yXCIgbWV0aG9kcyB3ZXJlIGNhbGxhYmxlIG9ubHkgYnkgbmFtZSkuXG4vL1xuLy8gMi54XG4vLyBCZWhhdmlvcnMgYXJlIG1hZGUgaW50byBwcm9wZXIgbWl4aW5zIHdoaWNoIGxpdmUgaW4gdGhlXG4vLyBlbGVtZW50J3MgcHJvdG90eXBlIGNoYWluLiBCZWhhdmlvcnMgYXJlIHBsYWNlZCBpbiB0aGUgZWxlbWVudCBwcm90b3R5cGVcbi8vIGVsZGVzdCB0byB5b3VuZ2VzdCBhbmQgZGUtZHVwZWQgeW91bmdlc3QgdG8gb2xkZXN0OlxuLy8gU28sIGZpcnN0IFtBLCBCLCBDLCBBLCBCXSBiZWNvbWVzIFtDLCBBLCBCXSB0aGVuLFxuLy8gdGhlIGVsZW1lbnQgcHJvdG90eXBlIGJlY29tZXMgKG9sZGVzdCkgKDEpIFBvbHltZXIuRWxlbWVudCwgKDIpIGNsYXNzKEMpLFxuLy8gKDMpIGNsYXNzKEEpLCAoNCkgY2xhc3MoQiksICg1KSBjbGFzcyhQb2x5bWVyKHsuLi59KSkuXG4vLyBSZXN1bHQ6XG4vLyBUaGlzIG1lYW5zIGVsZW1lbnQgcHJvcGVydGllcyB3aW4gb3ZlciBCIHByb3BlcnRpZXMgd2luIG92ZXIgQSB3aW5cbi8vIG92ZXIgQy4gKHNhbWUgYXMgMS54KVxuLy8gSWYgbGlmZWN5Y2xlIGlzIGNhbGxlZCAoc3VwZXIgdGhlbiBtZSksIG9yZGVyIGlzXG4vLyAoMSkgQy5jcmVhdGVkLCAoMikgQS5jcmVhdGVkLCAoMykgQi5jcmVhdGVkLCAoNCkgZWxlbWVudC5jcmVhdGVkXG4vLyAoYWdhaW4gc2FtZSBhcyAxLngpXG5mdW5jdGlvbiBfbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcykge1xuICBmb3IgKGxldCBpPTA7IGk8YmVoYXZpb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGIgPSBiZWhhdmlvcnNbaV07XG4gICAgaWYgKGIpIHtcbiAgICAgIGtsYXNzID0gQXJyYXkuaXNBcnJheShiKSA/IF9taXhpbkJlaGF2aW9ycyhiLCBrbGFzcykgOlxuICAgICAgICBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oYiwga2xhc3MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2xhc3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gYmVoYXZpb3JzIExpc3Qgb2YgYmVoYXZpb3JzIHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge0FycmF5PX0gbGlzdCBUYXJnZXQgbGlzdCB0byBmbGF0dGVuIGJlaGF2aW9ycyBpbnRvLlxuICogQHBhcmFtIHtBcnJheT19IGV4Y2x1ZGUgTGlzdCBvZiBiZWhhdmlvcnMgdG8gZXhjbHVkZSBmcm9tIHRoZSBsaXN0LlxuICogQHJldHVybiB7IUFycmF5fSBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBiZWhhdmlvcnMuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBsaXN0LCBleGNsdWRlKSB7XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICBmb3IgKGxldCBpPWJlaGF2aW9ycy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYiA9IGJlaGF2aW9yc1tpXTtcbiAgICBpZiAoYikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgZmxhdHRlbkJlaGF2aW9ycyhiLCBsaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZHVwXG4gICAgICAgIGlmIChsaXN0LmluZGV4T2YoYikgPCAwICYmICghZXhjbHVkZSB8fCBleGNsdWRlLmluZGV4T2YoYikgPCAwKSkge1xuICAgICAgICAgIGxpc3QudW5zaGlmdChiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2JlaGF2aW9yIGlzIG51bGwsIGNoZWNrIGZvciBtaXNzaW5nIG9yIDQwNCBpbXBvcnQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHshUG9seW1lckluaXR9IGluZm8gUG9seW1lciBpbmZvIG9iamVjdFxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBCYXNlIGJhc2UgY2xhc3MgdG8gZXh0ZW5kIHdpdGggaW5mbyBvYmplY3RcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IEdlbmVyYXRlZCBjbGFzc1xuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGluZm8sIEJhc2UpIHtcblxuICBjbGFzcyBQb2x5bWVyR2VuZXJhdGVkIGV4dGVuZHMgQmFzZSB7XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4gaW5mby5wcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgcmV0dXJuIGluZm8ub2JzZXJ2ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIGZvciB0aGlzIGNsYXNzXG4gICAgICovXG4gICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgIC8vIGdldCB0ZW1wbGF0ZSBmaXJzdCBmcm9tIGFueSBpbXBlcmF0aXZlIHNldCBpbiBgaW5mby5fdGVtcGxhdGVgXG4gICAgICByZXR1cm4gaW5mby5fdGVtcGxhdGUgfHxcbiAgICAgICAgLy8gbmV4dCBsb29rIGluIGRvbS1tb2R1bGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWxlbWVudCdzIGlzLlxuICAgICAgICBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKSB8fFxuICAgICAgICAvLyBuZXh0IGxvb2sgZm9yIHN1cGVyY2xhc3MgdGVtcGxhdGUgKG5vdGU6IHVzZSBzdXBlcmNsYXNzIHN5bWJvbFxuICAgICAgICAvLyB0byBlbnN1cmUgY29ycmVjdCBgdGhpcy5pc2ApXG4gICAgICAgIEJhc2UudGVtcGxhdGUgfHxcbiAgICAgICAgLy8gZmluYWxseSBmYWxsIGJhY2sgdG8gYF90ZW1wbGF0ZWAgaW4gZWxlbWVudCdzIHByb3RveXBlLlxuICAgICAgICB0aGlzLnByb3RvdHlwZS5fdGVtcGxhdGUgfHxcbiAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICBjcmVhdGVkKCkge1xuICAgICAgc3VwZXIuY3JlYXRlZCgpO1xuICAgICAgaWYgKGluZm8uY3JlYXRlZCkge1xuICAgICAgICBpbmZvLmNyZWF0ZWQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVnaXN0ZXJlZCgpIHtcbiAgICAgIHN1cGVyLl9yZWdpc3RlcmVkKCk7XG4gICAgICAvKiBOT1RFOiBgYmVmb3JlUmVnaXN0ZXJgIGlzIGNhbGxlZCBoZXJlIGZvciBiYywgYnV0IHRoZSBiZWhhdmlvclxuICAgICAgIGlzIGRpZmZlcmVudCB0aGFuIGluIDEueC4gSW4gMS4wLCB0aGUgbWV0aG9kIHdhcyBjYWxsZWQgKmFmdGVyKlxuICAgICAgIG1peGluZyBwcm90b3R5cGVzIHRvZ2V0aGVyIGJ1dCAqYmVmb3JlKiBwcm9jZXNzaW5nIG9mIG1ldGEtb2JqZWN0cy5cbiAgICAgICBIb3dldmVyLCBkeW5hbWljIGVmZmVjdHMgY2FuIHN0aWxsIGJlIHNldCBoZXJlIGFuZCBjYW4gYmUgZG9uZSBlaXRoZXJcbiAgICAgICBpbiBgYmVmb3JlUmVnaXN0ZXJgIG9yIGByZWdpc3RlcmVkYC4gSXQgaXMgbm8gbG9uZ2VyIHBvc3NpYmxlIHRvIHNldFxuICAgICAgIGBpc2AgaW4gYGJlZm9yZVJlZ2lzdGVyYCBhcyB5b3UgY291bGQgaW4gMS54LlxuICAgICAgKi9cbiAgICAgIGlmIChpbmZvLmJlZm9yZVJlZ2lzdGVyKSB7XG4gICAgICAgIGluZm8uYmVmb3JlUmVnaXN0ZXIuY2FsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8ucmVnaXN0ZXJlZCkge1xuICAgICAgICBpbmZvLnJlZ2lzdGVyZWQuY2FsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hcHBseUxpc3RlbmVycygpIHtcbiAgICAgIHN1cGVyLl9hcHBseUxpc3RlbmVycygpO1xuICAgICAgaWYgKGluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgIGZvciAobGV0IGwgaW4gaW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICB0aGlzLl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKHRoaXMsIGwsIGluZm8ubGlzdGVuZXJzW2xdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdGU6IGV4Y2VwdGlvbiB0byBcInN1cGVyIHRoZW4gbWVcIiBydWxlO1xuICAgIC8vIGRvIHdvcmsgYmVmb3JlIGNhbGxpbmcgc3VwZXIgc28gdGhhdCBzdXBlciBhdHRyaWJ1dGVzXG4gICAgLy8gb25seSBhcHBseSBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICAgX2Vuc3VyZUF0dHJpYnV0ZXMoKSB7XG4gICAgICBpZiAoaW5mby5ob3N0QXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKGxldCBhIGluIGluZm8uaG9zdEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICB0aGlzLl9lbnN1cmVBdHRyaWJ1dGUoYSwgaW5mby5ob3N0QXR0cmlidXRlc1thXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN1cGVyLl9lbnN1cmVBdHRyaWJ1dGVzKCk7XG4gICAgfVxuXG4gICAgcmVhZHkoKSB7XG4gICAgICBzdXBlci5yZWFkeSgpO1xuICAgICAgaWYgKGluZm8ucmVhZHkpIHtcbiAgICAgICAgaW5mby5yZWFkeS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF0dGFjaGVkKCkge1xuICAgICAgc3VwZXIuYXR0YWNoZWQoKTtcbiAgICAgIGlmIChpbmZvLmF0dGFjaGVkKSB7XG4gICAgICAgIGluZm8uYXR0YWNoZWQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZXRhY2hlZCgpIHtcbiAgICAgIHN1cGVyLmRldGFjaGVkKCk7XG4gICAgICBpZiAoaW5mby5kZXRhY2hlZCkge1xuICAgICAgICBpbmZvLmRldGFjaGVkLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgaWYgKGluZm8uYXR0cmlidXRlQ2hhbmdlZCkge1xuICAgICAgICBpbmZvLmF0dHJpYnV0ZUNoYW5nZWQuY2FsbCh0aGlzLCBuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgIH1cbiAgIH1cbiAgfVxuXG4gIFBvbHltZXJHZW5lcmF0ZWQuZ2VuZXJhdGVkRnJvbSA9IGluZm87XG5cbiAgZm9yIChsZXQgcCBpbiBpbmZvKSB7XG4gICAgLy8gTk9URTogY2Fubm90IGNvcHkgYG1ldGFQcm9wc2AgbWV0aG9kcyBvbnRvIHByb3RvdHlwZSBhdCBsZWFzdCBiZWNhdXNlXG4gICAgLy8gYHN1cGVyLnJlYWR5YCBtdXN0IGJlIGNhbGxlZCBhbmQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSB1c2VyIGZuLlxuICAgIGlmICghKHAgaW4gbWV0YVByb3BzKSkge1xuICAgICAgbGV0IHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmZvLCBwKTtcbiAgICAgIGlmIChwZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9seW1lckdlbmVyYXRlZC5wcm90b3R5cGUsIHAsIHBkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUG9seW1lckdlbmVyYXRlZDtcbn1cblxuZXhwb3J0IGNvbnN0IENsYXNzID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoIWluZm8pIHtcbiAgICBjb25zb2xlLndhcm4oJ1BvbHltZXIuQ2xhc3MgcmVxdWlyZXMgYGluZm9gIGFyZ3VtZW50Jyk7XG4gIH1cbiAgbGV0IGtsYXNzID0gR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGluZm8sIGluZm8uYmVoYXZpb3JzID9cbiAgICAvLyBub3RlOiBtaXhpbkJlaGF2aW9ycyBlbnN1cmVzIGBMZWdhY3lFbGVtZW50TWl4aW5gLlxuICAgIG1peGluQmVoYXZpb3JzKGluZm8uYmVoYXZpb3JzLCBIVE1MRWxlbWVudCkgOlxuICAgIExlZ2FjeUVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCkpO1xuICAvLyBkZWNvcmF0ZSBrbGFzcyB3aXRoIHJlZ2lzdHJhdGlvbiBpbmZvXG4gIGtsYXNzLmlzID0gaW5mby5pcztcbiAgcmV0dXJuIGtsYXNzO1xufTtcblxuZXhwb3J0IHsgbWl4aW5CZWhhdmlvcnMgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9jbGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgVGVtcGxhdGVJbnN0YW5jZUJhc2UgYXMgVGVtcGxhdGVJbnN0YW5jZUJhc2UkMCwgVGVtcGxhdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3RlbXBsYXRpemUuanMnO1xuXG5sZXQgVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgX3RlbXBsYXRpemVyVGVtcGxhdGU6IEhUTUxUZW1wbGF0ZUVsZW1lbnQsXG4gKiAgIF9wYXJlbnRNb2RlbDogYm9vbGVhbixcbiAqICAgX2luc3RhbmNlUHJvcHM6IE9iamVjdCxcbiAqICAgX2ZvcndhcmRIb3N0UHJvcFYyOiBGdW5jdGlvbixcbiAqICAgX25vdGlmeUluc3RhbmNlUHJvcFYyOiBGdW5jdGlvbixcbiAqICAgY3RvcjogVGVtcGxhdGVJbnN0YW5jZUJhc2VcbiAqIH19XG4gKi9cbmxldCBUZW1wbGF0aXplclVzZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBUaGUgYFBvbHltZXIuVGVtcGxhdGl6ZXJgIGJlaGF2aW9yIGFkZHMgbWV0aG9kcyB0byBnZW5lcmF0ZSBpbnN0YW5jZXMgb2ZcbiAqIHRlbXBsYXRlcyB0aGF0IGFyZSBlYWNoIG1hbmFnZWQgYnkgYW4gYW5vbnltb3VzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2BcbiAqIGluc3RhbmNlIHdoZXJlIGRhdGEtYmluZGluZ3MgaW4gdGhlIHN0YW1wZWQgdGVtcGxhdGUgY29udGVudCBhcmUgYm91bmQgdG9cbiAqIGFjY2Vzc29ycyBvbiBpdHNlbGYuXG4gKlxuICogVGhpcyBiZWhhdmlvciBpcyBwcm92aWRlZCBpbiBQb2x5bWVyIDIueCBhcyBhIGh5YnJpZC1lbGVtZW50IGNvbnZlbmllbmNlXG4gKiBvbmx5LiAgRm9yIG5vbi1oeWJyaWQgdXNhZ2UsIHRoZSBgUG9seW1lci5UZW1wbGF0aXplYCBsaWJyYXJ5XG4gKiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEdldCBhIHRlbXBsYXRlIGZyb20gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICogICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAqICAgICAvLyBQcmVwYXJlIHRoZSB0ZW1wbGF0ZVxuICogICAgIHRoaXMudGVtcGxhdGl6ZSh0ZW1wbGF0ZSk7XG4gKiAgICAgLy8gSW5zdGFuY2UgdGhlIHRlbXBsYXRlIHdpdGggYW4gaW5pdGlhbCBkYXRhIG1vZGVsXG4gKiAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5zdGFtcCh7bXlQcm9wOiAnaW5pdGlhbCd9KTtcbiAqICAgICAvLyBJbnNlcnQgdGhlIGluc3RhbmNlJ3MgRE9NIHNvbWV3aGVyZSwgZS5nLiBsaWdodCBET01cbiAqICAgICBQb2x5bWVyLmRvbSh0aGlzKS5hcHBlbmRDaGlsZChpbnN0YW5jZS5yb290KTtcbiAqICAgICAvLyBDaGFuZ2luZyBhIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZSB3aWxsIHByb3BhZ2F0ZSB0byBiaW5kaW5nc1xuICogICAgIC8vIGluIHRoZSB0ZW1wbGF0ZVxuICogICAgIGluc3RhbmNlLm15UHJvcCA9ICduZXcgdmFsdWUnO1xuICpcbiAqIFVzZXJzIG9mIGBUZW1wbGF0aXplcmAgbWF5IG5lZWQgdG8gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgYWJzdHJhY3RcbiAqIEFQSSdzIHRvIGRldGVybWluZSBob3cgcHJvcGVydGllcyBhbmQgcGF0aHMgZnJvbSB0aGUgaG9zdCBzaG91bGQgYmVcbiAqIGZvcndhcmRlZCBpbnRvIHRvIGluc3RhbmNlczpcbiAqXG4gKiAgICAgX2ZvcndhcmRIb3N0UHJvcFYyOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSlcbiAqXG4gKiBMaWtld2lzZSwgdXNlcnMgbWF5IGltcGxlbWVudCB0aGVzZSBhZGRpdGlvbmFsIGFic3RyYWN0IEFQSSdzIHRvIGRldGVybWluZVxuICogaG93IGluc3RhbmNlLXNwZWNpZmljIHByb3BlcnRpZXMgdGhhdCBjaGFuZ2Ugb24gdGhlIGluc3RhbmNlIHNob3VsZCBiZVxuICogZm9yd2FyZGVkIG91dCB0byB0aGUgaG9zdCwgaWYgbmVjZXNzYXJ5LlxuICpcbiAqICAgICBfbm90aWZ5SW5zdGFuY2VQcm9wVjI6IGZ1bmN0aW9uKGluc3QsIHByb3AsIHZhbHVlKVxuICpcbiAqIEluIG9yZGVyIHRvIGRldGVybWluZSB3aGljaCBwcm9wZXJ0aWVzIGFyZSBpbnN0YW5jZS1zcGVjaWZpYyBhbmQgcmVxdWlyZVxuICogY3VzdG9tIG5vdGlmaWNhdGlvbiB2aWEgYF9ub3RpZnlJbnN0YW5jZVByb3BgLCBkZWZpbmUgYW4gYF9pbnN0YW5jZVByb3BzYFxuICogb2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgZWFjaCBpbnN0YW5jZSBwcm9wLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgX2luc3RhbmNlUHJvcHM6IHtcbiAqICAgICAgIGl0ZW06IHRydWUsXG4gKiAgICAgICBpbmRleDogdHJ1ZVxuICogICAgIH1cbiAqXG4gKiBBbnkgcHJvcGVydGllcyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IGFyZSBub3QgZGVmaW5lZCBpbiBfaW5zdGFuY2VQcm9wXG4gKiB3aWxsIGJlIGZvcndhcmRlZCBvdXQgdG8gdGhlIFRlbXBsYXRpemUgYG93bmVyYCBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIFVzZXJzIG1heSBhbHNvIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIGFic3RyYWN0IGZ1bmN0aW9uIHRvIHNob3cgb3JcbiAqIGhpZGUgYW55IERPTSBnZW5lcmF0ZWQgdXNpbmcgYHN0YW1wYDpcbiAqXG4gKiAgICAgX3Nob3dIaWRlQ2hpbGRyZW46IGZ1bmN0aW9uKHNob3VsZEhpZGUpXG4gKlxuICogTm90ZSB0aGF0IHNvbWUgY2FsbGJhY2tzIGFyZSBzdWZmaXhlZCB3aXRoIGBWMmAgaW4gdGhlIFBvbHltZXIgMi54IGJlaGF2aW9yXG4gKiBhcyB0aGUgaW1wbGVtZW50YXRpb25zIHdpbGwgbmVlZCB0byBkaWZmZXIgZnJvbSB0aGUgY2FsbGJhY2tzIHJlcXVpcmVkXG4gKiBieSB0aGUgMS54IFRlbXBsYXRpemVyIEFQSSBkdWUgdG8gY2hhbmdlcyBpbiB0aGUgYFRlbXBsYXRlSW5zdGFuY2VgIEFQSVxuICogYmV0d2VlbiB2ZXJzaW9ucyAxLnggYW5kIDIueC5cbiAqXG4gKiBAcG9seW1lckJlaGF2aW9yXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICovXG5sZXQgVGVtcGxhdGl6ZXIgPSB7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBhbm9ueW1vdXMgYFRlbXBsYXRlSW5zdGFuY2VgIGNsYXNzIChzdG9yZWQgYXMgYHRoaXMuY3RvcmApXG4gICAqIGZvciB0aGUgcHJvdmlkZWQgdGVtcGxhdGUuICBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG9uY2UgcGVyXG4gICAqIHRlbXBsYXRlIHRvIHByZXBhcmUgYW4gZWxlbWVudCBmb3Igc3RhbXBpbmcgdGhlIHRlbXBsYXRlLCBmb2xsb3dlZFxuICAgKiBieSBgc3RhbXBgIHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBwcmVwYXJlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG11dGFibGVEYXRhIFdoZW4gYHRydWVgLCB0aGUgZ2VuZXJhdGVkIGNsYXNzIHdpbGwgc2tpcFxuICAgKiAgIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0b1xuICAgKiAgIGJlIFwiZGlydHlcIikuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgKi9cbiAgdGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgbXV0YWJsZURhdGEpIHtcbiAgICB0aGlzLl90ZW1wbGF0aXplclRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgdGhpcy5jdG9yID0gVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICBtdXRhYmxlRGF0YTogQm9vbGVhbihtdXRhYmxlRGF0YSksXG4gICAgICBwYXJlbnRNb2RlbDogdGhpcy5fcGFyZW50TW9kZWwsXG4gICAgICBpbnN0YW5jZVByb3BzOiB0aGlzLl9pbnN0YW5jZVByb3BzLFxuICAgICAgZm9yd2FyZEhvc3RQcm9wOiB0aGlzLl9mb3J3YXJkSG9zdFByb3BWMixcbiAgICAgIG5vdGlmeUluc3RhbmNlUHJvcDogdGhpcy5fbm90aWZ5SW5zdGFuY2VQcm9wVjJcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGUgcHJlcGFyZWQgYnkgYHRlbXBsYXRpemVgLiAgVGhlIG9iamVjdFxuICAgKiByZXR1cm5lZCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgYW5vbnltb3VzIGNsYXNzIGdlbmVyYXRlZCBieSBgdGVtcGxhdGl6ZWBcbiAgICogd2hvc2UgYHJvb3RgIHByb3BlcnR5IGlzIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyBuZXdseSBjbG9uZWRcbiAgICogdGVtcGxhdGUgY29udGVudCwgYW5kIHdoaWNoIGhhcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgY29ycmVzcG9uZGluZyB0b1xuICAgKiBwcm9wZXJ0aWVzIHJlZmVyZW5jZWQgaW4gdGVtcGxhdGUgYmluZGluZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gbW9kZWwgT2JqZWN0IGNvbnRhaW5pbmcgaW5pdGlhbCBwcm9wZXJ0eSB2YWx1ZXMgdG9cbiAgICogICBwb3B1bGF0ZSBpbnRvIHRoZSB0ZW1wbGF0ZSBiaW5kaW5ncy5cbiAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IFJldHVybnMgdGhlIGNyZWF0ZWQgaW5zdGFuY2Ugb2ZcbiAgICogdGhlIHRlbXBsYXRlIHByZXBhcmVkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICovXG4gIHN0YW1wKG1vZGVsKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmN0b3IobW9kZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgKGBUZW1wbGF0ZUluc3RhbmNlYCkgYXNzb2NpYXRlZCB3aXRoXG4gICAqIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2ggc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGVcbiAgICogaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXMgY29udGFpbmVkIGluLiAgQSB0ZW1wbGF0ZSBtb2RlbCBzaG91bGQgYmUgdXNlZFxuICAgKiB0byBtYW5pcHVsYXRlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgKiAgIHRoZSBlbGVtZW50LlxuICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgKi9cbiAgbW9kZWxGb3JFbGVtZW50KGVsKSB7XG4gICAgcmV0dXJuIFRlbXBsYXRpemUubW9kZWxGb3JFbGVtZW50KHRoaXMuX3RlbXBsYXRpemVyVGVtcGxhdGUsIGVsKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgVGVtcGxhdGl6ZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS90ZW1wbGF0aXplci1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IFByb3BlcnR5RWZmZWN0cyB9IGZyb20gJy4uL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzJztcbmltcG9ydCB7IE9wdGlvbmFsTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcbmltcG9ydCB7IEdlc3R1cmVFdmVudExpc3RlbmVycyB9IGZyb20gJy4uL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5qcyc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SFRNTEVsZW1lbnR9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICovXG5jb25zdCBkb21CaW5kQmFzZSA9XG4gIEdlc3R1cmVFdmVudExpc3RlbmVycyhcbiAgICBPcHRpb25hbE11dGFibGVEYXRhKFxuICAgICAgUHJvcGVydHlFZmZlY3RzKEhUTUxFbGVtZW50KSkpO1xuXG4vKipcbiAqIEN1c3RvbSBlbGVtZW50IHRvIGFsbG93IHVzaW5nIFBvbHltZXIncyB0ZW1wbGF0ZSBmZWF0dXJlcyAoZGF0YSBiaW5kaW5nLFxuICogZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLCBldGMuKSBpbiB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGRlZmluaW5nXG4gKiBhIG5ldyBjdXN0b20gZWxlbWVudC5cbiAqXG4gKiBgPHRlbXBsYXRlPmAgdGFncyB1dGlsaXppbmcgYmluZGluZ3MgbWF5IGJlIHdyYXBwZWQgd2l0aCB0aGUgYDxkb20tYmluZD5gXG4gKiBlbGVtZW50LCB3aGljaCB3aWxsIGltbWVkaWF0ZWx5IHN0YW1wIHRoZSB3cmFwcGVkIHRlbXBsYXRlIGludG8gdGhlIG1haW5cbiAqIGRvY3VtZW50IGFuZCBiaW5kIGVsZW1lbnRzIHRvIHRoZSBgZG9tLWJpbmRgIGVsZW1lbnQgaXRzZWxmIGFzIHRoZVxuICogYmluZGluZyBzY29wZS5cbiAqXG4gKiBAcG9seW1lclxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhXG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzXG4gKiBAZXh0ZW5kcyB7ZG9tQmluZEJhc2V9XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdG8gYWxsb3cgdXNpbmcgUG9seW1lcidzIHRlbXBsYXRlIGZlYXR1cmVzIChkYXRhXG4gKiAgIGJpbmRpbmcsIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycywgZXRjLikgaW4gdGhlIG1haW4gZG9jdW1lbnQuXG4gKi9cbmNsYXNzIERvbUJpbmQgZXh0ZW5kcyBkb21CaW5kQmFzZSB7XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7IHJldHVybiBbJ211dGFibGUtZGF0YSddOyB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIHRoaXMuJCA9IG51bGw7XG4gICAgdGhpcy5fX2NoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFzc3VtZXMgb25seSBvbmUgb2JzZXJ2ZWQgYXR0cmlidXRlXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm11dGFibGVEYXRhID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9fcmVtb3ZlQ2hpbGRyZW4oKTtcbiAgfVxuXG4gIF9faW5zZXJ0Q2hpbGRyZW4oKSB7XG4gICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnJvb3QsIHRoaXMpO1xuICB9XG5cbiAgX19yZW1vdmVDaGlsZHJlbigpIHtcbiAgICBpZiAodGhpcy5fX2NoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9fY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGl0cyBjb250ZW50LiBUaGlzIGlzIHR5cGljYWxseSBvbmx5XG4gICAqIG5lY2Vzc2FyeSB0byBjYWxsIGlmIEhUTUxJbXBvcnRzIHdpdGggdGhlIGFzeW5jIGF0dHJpYnV0ZSBhcmUgdXNlZC5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgdGVtcGxhdGU7XG4gICAgaWYgKCF0aGlzLl9fY2hpbGRyZW4pIHtcbiAgICAgIHRlbXBsYXRlID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyh0ZW1wbGF0ZSB8fCB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgdGVtcGxhdGUgPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSk7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1iaW5kIHJlcXVpcmVzIGEgPHRlbXBsYXRlPiBjaGlsZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIHRoaXMuJCA9IHRoaXMucm9vdC4kO1xuICAgICAgdGhpcy5fX2NoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGxldCBuPXRoaXMucm9vdC5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdGhpcy5fX2NoaWxkcmVuW3RoaXMuX19jaGlsZHJlbi5sZW5ndGhdID0gbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gICAgdGhpcy5fX2luc2VydENoaWxkcmVuKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH0pKTtcbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZG9tLWJpbmQnLCBEb21CaW5kKTtcblxuZXhwb3J0IHsgRG9tQmluZCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLWJpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi8uLi9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVJbnN0YW5jZUJhc2UgYXMgVGVtcGxhdGVJbnN0YW5jZUJhc2UkMCwgVGVtcGxhdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3RlbXBsYXRpemUuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VyIH0gZnJvbSAnLi4vdXRpbHMvZGVib3VuY2UuanMnO1xuaW1wb3J0IHsgZW5xdWV1ZURlYm91bmNlciwgZmx1c2ggfSBmcm9tICcuLi91dGlscy9mbHVzaC5qcyc7XG5pbXBvcnQgeyBPcHRpb25hbE11dGFibGVEYXRhIH0gZnJvbSAnLi4vbWl4aW5zL211dGFibGUtZGF0YS5qcyc7XG5pbXBvcnQgeyBtYXRjaGVzLCB0cmFuc2xhdGUgfSBmcm9tICcuLi91dGlscy9wYXRoLmpzJztcbmltcG9ydCB7IHRpbWVPdXQsIG1pY3JvVGFzayB9IGZyb20gJy4uL3V0aWxzL2FzeW5jLmpzJztcblxubGV0IFRlbXBsYXRlSW5zdGFuY2VCYXNlID0gVGVtcGxhdGVJbnN0YW5jZUJhc2UkMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfT3B0aW9uYWxNdXRhYmxlRGF0YX1cbiAqIEBleHRlbmRzIHtQb2x5bWVyLkVsZW1lbnR9XG4gKi9cbmNvbnN0IGRvbVJlcGVhdEJhc2UgPSBPcHRpb25hbE11dGFibGVEYXRhKEVsZW1lbnQpO1xuXG4vKipcbiAqIFRoZSBgPGRvbS1yZXBlYXQ+YCBlbGVtZW50IHdpbGwgYXV0b21hdGljYWxseSBzdGFtcCBhbmQgYmluZHMgb25lIGluc3RhbmNlXG4gKiBvZiB0ZW1wbGF0ZSBjb250ZW50IHRvIGVhY2ggb2JqZWN0IGluIGEgdXNlci1wcm92aWRlZCBhcnJheS5cbiAqIGBkb20tcmVwZWF0YCBhY2NlcHRzIGFuIGBpdGVtc2AgcHJvcGVydHksIGFuZCBvbmUgaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlXG4gKiBpcyBzdGFtcGVkIGZvciBlYWNoIGl0ZW0gaW50byB0aGUgRE9NIGF0IHRoZSBsb2NhdGlvbiBvZiB0aGUgYGRvbS1yZXBlYXRgXG4gKiBlbGVtZW50LiAgVGhlIGBpdGVtYCBwcm9wZXJ0eSB3aWxsIGJlIHNldCBvbiBlYWNoIGluc3RhbmNlJ3MgYmluZGluZ1xuICogc2NvcGUsIHRodXMgdGVtcGxhdGVzIHNob3VsZCBiaW5kIHRvIHN1Yi1wcm9wZXJ0aWVzIG9mIGBpdGVtYC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkb20tbW9kdWxlIGlkPVwiZW1wbG95ZWUtbGlzdFwiPlxuICpcbiAqICAgPHRlbXBsYXRlPlxuICpcbiAqICAgICA8ZGl2PiBFbXBsb3llZSBsaXN0OiA8L2Rpdj5cbiAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCI+XG4gKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgICAgIDxkaXY+TGFzdCBuYW1lOiA8c3Bhbj57e2l0ZW0ubGFzdH19PC9zcGFuPjwvZGl2PlxuICogICAgIDwvdGVtcGxhdGU+XG4gKlxuICogICA8L3RlbXBsYXRlPlxuICpcbiAqICAgPHNjcmlwdD5cbiAqICAgICBQb2x5bWVyKHtcbiAqICAgICAgIGlzOiAnZW1wbG95ZWUtbGlzdCcsXG4gKiAgICAgICByZWFkeTogZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIHRoaXMuZW1wbG95ZWVzID0gW1xuICogICAgICAgICAgICAge2ZpcnN0OiAnQm9iJywgbGFzdDogJ1NtaXRoJ30sXG4gKiAgICAgICAgICAgICB7Zmlyc3Q6ICdTYWxseScsIGxhc3Q6ICdKb2huc29uJ30sXG4gKiAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgXTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgPCAvc2NyaXB0PlxuICpcbiAqIDwvZG9tLW1vZHVsZT5cbiAqIGBgYFxuICpcbiAqIE5vdGlmaWNhdGlvbnMgZm9yIGNoYW5nZXMgdG8gaXRlbXMgc3ViLXByb3BlcnRpZXMgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGVtcGxhdGVcbiAqIGluc3RhbmNlcywgd2hpY2ggd2lsbCB1cGRhdGUgdmlhIHRoZSBub3JtYWwgc3RydWN0dXJlZCBkYXRhIG5vdGlmaWNhdGlvbiBzeXN0ZW0uXG4gKlxuICogTXV0YXRpb25zIHRvIHRoZSBgaXRlbXNgIGFycmF5IGl0c2VsZiBzaG91bGQgYmUgbWFkZSB1c2luZyB0aGUgQXJyYXlcbiAqIG11dGF0aW9uIEFQSSdzIG9uIGBQb2x5bWVyLkJhc2VgIChgcHVzaGAsIGBwb3BgLCBgc3BsaWNlYCwgYHNoaWZ0YCxcbiAqIGB1bnNoaWZ0YCksIGFuZCB0ZW1wbGF0ZSBpbnN0YW5jZXMgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgZGF0YSBpbiB0aGVcbiAqIGFycmF5LlxuICpcbiAqIEV2ZW50cyBjYXVnaHQgYnkgZXZlbnQgaGFuZGxlcnMgd2l0aGluIHRoZSBgZG9tLXJlcGVhdGAgdGVtcGxhdGUgd2lsbCBiZVxuICogZGVjb3JhdGVkIHdpdGggYSBgbW9kZWxgIHByb3BlcnR5LCB3aGljaCByZXByZXNlbnRzIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICogZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZiBQb2x5bWVyLkJhc2UsIGFuZCBzaG91bGRcbiAqIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhIG9uIHRoZSBpbnN0YW5jZSwgZm9yIGV4YW1wbGVcbiAqIGBldmVudC5tb2RlbC5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO2AuXG4gKlxuICogQWx0ZXJuYXRpdmVseSwgdGhlIG1vZGVsIGZvciBhIHRlbXBsYXRlIGluc3RhbmNlIGZvciBhbiBlbGVtZW50IHN0YW1wZWQgYnlcbiAqIGEgYGRvbS1yZXBlYXRgIGNhbiBiZSBvYnRhaW5lZCB1c2luZyB0aGUgYG1vZGVsRm9yRWxlbWVudGAgQVBJIG9uIHRoZVxuICogYGRvbS1yZXBlYXRgIHRoYXQgc3RhbXBlZCBpdCwgZm9yIGV4YW1wbGVcbiAqIGB0aGlzLiQuZG9tUmVwZWF0Lm1vZGVsRm9yRWxlbWVudChldmVudC50YXJnZXQpLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7YC5cbiAqIFRoaXMgbWF5IGJlIHVzZWZ1bCBmb3IgbWFuaXB1bGF0aW5nIGluc3RhbmNlIGRhdGEgb2YgZXZlbnQgdGFyZ2V0cyBvYnRhaW5lZFxuICogYnkgZXZlbnQgaGFuZGxlcnMgb24gcGFyZW50cyBvZiB0aGUgYGRvbS1yZXBlYXRgIChldmVudCBkZWxlZ2F0aW9uKS5cbiAqXG4gKiBBIHZpZXctc3BlY2lmaWMgZmlsdGVyL3NvcnQgbWF5IGJlIGFwcGxpZWQgdG8gZWFjaCBgZG9tLXJlcGVhdGAgYnkgc3VwcGx5aW5nIGFcbiAqIGBmaWx0ZXJgIGFuZC9vciBgc29ydGAgcHJvcGVydHkuICBUaGlzIG1heSBiZSBhIHN0cmluZyB0aGF0IG5hbWVzIGEgZnVuY3Rpb24gb25cbiAqIHRoZSBob3N0LCBvciBhIGZ1bmN0aW9uIG1heSBiZSBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkgZGlyZWN0bHkuICBUaGUgZnVuY3Rpb25zXG4gKiBzaG91bGQgaW1wbGVtZW50ZWQgZm9sbG93aW5nIHRoZSBzdGFuZGFyZCBgQXJyYXlgIGZpbHRlci9zb3J0IEFQSS5cbiAqXG4gKiBJbiBvcmRlciB0byByZS1ydW4gdGhlIGZpbHRlciBvciBzb3J0IGZ1bmN0aW9ucyBiYXNlZCBvbiBjaGFuZ2VzIHRvIHN1Yi1maWVsZHNcbiAqIG9mIGBpdGVtc2AsIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHkgbWF5IGJlIHNldCBhcyBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mXG4gKiBgaXRlbWAgc3ViLWZpZWxkcyB0aGF0IHNob3VsZCBjYXVzZSBhIHJlLWZpbHRlci9zb3J0IHdoZW4gbW9kaWZpZWQuICBJZlxuICogdGhlIGZpbHRlciBvciBzb3J0IGZ1bmN0aW9uIGRlcGVuZHMgb24gcHJvcGVydGllcyBub3QgY29udGFpbmVkIGluIGBpdGVtc2AsXG4gKiB0aGUgdXNlciBzaG91bGQgb2JzZXJ2ZSBjaGFuZ2VzIHRvIHRob3NlIHByb3BlcnRpZXMgYW5kIGNhbGwgYHJlbmRlcmAgdG8gdXBkYXRlXG4gKiB0aGUgdmlldyBiYXNlZCBvbiB0aGUgZGVwZW5kZW5jeSBjaGFuZ2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGZvciBhbiBgZG9tLXJlcGVhdGAgd2l0aCBhIGZpbHRlciBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIGBgYGpzXG4gKiBpc0VuZ2luZWVyOiBmdW5jdGlvbihpdGVtKSB7XG4gKiAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSAnZW5naW5lZXInIHx8IGl0ZW0ubWFuYWdlci50eXBlID09ICdlbmdpbmVlcic7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGVuIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHkgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgYXMgZm9sbG93czpcbiAqXG4gKiBgYGBodG1sXG4gKiA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCJcbiAqICAgICAgICAgICBmaWx0ZXI9XCJpc0VuZ2luZWVyXCIgb2JzZXJ2ZT1cInR5cGUgbWFuYWdlci50eXBlXCI+XG4gKiBgYGBcbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQHBvbHltZXJcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAZXh0ZW5kcyB7ZG9tUmVwZWF0QmFzZX1cbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBmb3Igc3RhbXBpbmcgaW5zdGFuY2Ugb2YgYSB0ZW1wbGF0ZSBib3VuZCB0b1xuICogICBpdGVtcyBpbiBhbiBhcnJheS5cbiAqL1xuY2xhc3MgRG9tUmVwZWF0IGV4dGVuZHMgZG9tUmVwZWF0QmFzZSB7XG5cbiAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2RvbS1yZXBlYXQnOyB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIG51bGw7IH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuZXZlciBET00gaXMgYWRkZWQgb3IgcmVtb3ZlZCBieSB0aGlzIHRlbXBsYXRlIChieVxuICAgICAqIGRlZmF1bHQsIHJlbmRlcmluZyBvY2N1cnMgbGF6aWx5KS4gIFRvIGZvcmNlIGltbWVkaWF0ZSByZW5kZXJpbmcsIGNhbGxcbiAgICAgKiBgcmVuZGVyYC5cbiAgICAgKlxuICAgICAqIEBldmVudCBkb20tY2hhbmdlXG4gICAgICovXG4gICAgcmV0dXJuIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGl0ZW1zIGRldGVybWluaW5nIGhvdyBtYW55IGluc3RhbmNlcyBvZiB0aGUgdGVtcGxhdGVcbiAgICAgICAqIHRvIHN0YW1wIGFuZCB0aGF0IHRoYXQgZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZSBzaG91bGQgYmluZCB0by5cbiAgICAgICAqL1xuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXlcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIGFycmF5XG4gICAgICAgKiBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgICAgICovXG4gICAgICBhczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaXRlbSdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSB3aXRoIHRoZSBpbmRleFxuICAgICAgICogb2YgdGhlIGluc3RhbmNlIGluIHRoZSBzb3J0ZWQgYW5kIGZpbHRlcmVkIGxpc3Qgb2YgcmVuZGVyZWQgaXRlbXMuXG4gICAgICAgKiBOb3RlLCBmb3IgdGhlIGluZGV4IGluIHRoZSBgdGhpcy5pdGVtc2AgYXJyYXksIHVzZSB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICAgKiBgaXRlbXNJbmRleEFzYCBwcm9wZXJ0eS5cbiAgICAgICAqL1xuICAgICAgaW5kZXhBczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaW5kZXgnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBhZGQgdG8gdGhlIGJpbmRpbmcgc2NvcGUgd2l0aCB0aGUgaW5kZXhcbiAgICAgICAqIG9mIHRoZSBpbnN0YW5jZSBpbiB0aGUgYHRoaXMuaXRlbXNgIGFycmF5LiBOb3RlLCBmb3IgdGhlIGluZGV4IG9mXG4gICAgICAgKiB0aGlzIGluc3RhbmNlIGluIHRoZSBzb3J0ZWQgYW5kIGZpbHRlcmVkIGxpc3Qgb2YgcmVuZGVyZWQgaXRlbXMsXG4gICAgICAgKiB1c2UgdGhlIHZhbHVlIG9mIHRoZSBgaW5kZXhBc2AgcHJvcGVydHkuXG4gICAgICAgKi9cbiAgICAgIGl0ZW1zSW5kZXhBczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaXRlbXNJbmRleCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBkZXRlcm1pbmUgdGhlIHNvcnQgb3JkZXIgb2YgdGhlIGl0ZW1zLiAgVGhpc1xuICAgICAgICogcHJvcGVydHkgc2hvdWxkIGVpdGhlciBiZSBwcm92aWRlZCBhcyBhIHN0cmluZywgaW5kaWNhdGluZyBhIG1ldGhvZFxuICAgICAgICogbmFtZSBvbiB0aGUgZWxlbWVudCdzIGhvc3QsIG9yIGVsc2UgYmUgYW4gYWN0dWFsIGZ1bmN0aW9uLiAgVGhlXG4gICAgICAgKiBmdW5jdGlvbiBzaG91bGQgbWF0Y2ggdGhlIHNvcnQgZnVuY3Rpb24gcGFzc2VkIHRvIGBBcnJheS5zb3J0YC5cbiAgICAgICAqIFVzaW5nIGEgc29ydCBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1bmRlcmx5aW5nIGBpdGVtc2AgYXJyYXkuXG4gICAgICAgKi9cbiAgICAgIHNvcnQ6IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIG9ic2VydmVyOiAnX19zb3J0Q2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbHRlciBpdGVtcyBvdXQgb2YgdGhlIHZpZXcuICBUaGlzXG4gICAgICAgKiBwcm9wZXJ0eSBzaG91bGQgZWl0aGVyIGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLCBpbmRpY2F0aW5nIGEgbWV0aG9kXG4gICAgICAgKiBuYW1lIG9uIHRoZSBlbGVtZW50J3MgaG9zdCwgb3IgZWxzZSBiZSBhbiBhY3R1YWwgZnVuY3Rpb24uICBUaGVcbiAgICAgICAqIGZ1bmN0aW9uIHNob3VsZCBtYXRjaCB0aGUgc29ydCBmdW5jdGlvbiBwYXNzZWQgdG8gYEFycmF5LmZpbHRlcmAuXG4gICAgICAgKiBVc2luZyBhIGZpbHRlciBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1bmRlcmx5aW5nIGBpdGVtc2AgYXJyYXkuXG4gICAgICAgKi9cbiAgICAgIGZpbHRlcjoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2ZpbHRlckNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdXNpbmcgYSBgZmlsdGVyYCBvciBgc29ydGAgZnVuY3Rpb24sIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHlcbiAgICAgICAqIHNob3VsZCBiZSBzZXQgdG8gYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGUgbmFtZXMgb2YgaXRlbVxuICAgICAgICogc3ViLWZpZWxkcyB0aGF0IHNob3VsZCB0cmlnZ2VyIGEgcmUtc29ydCBvciByZS1maWx0ZXIgd2hlbiBjaGFuZ2VkLlxuICAgICAgICogVGhlc2Ugc2hvdWxkIGdlbmVyYWxseSBiZSBmaWVsZHMgb2YgYGl0ZW1gIHRoYXQgdGhlIHNvcnQgb3IgZmlsdGVyXG4gICAgICAgKiBmdW5jdGlvbiBkZXBlbmRzIG9uLlxuICAgICAgICovXG4gICAgICBvYnNlcnZlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX29ic2VydmVDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHVzaW5nIGEgYGZpbHRlcmAgb3IgYHNvcnRgIGZ1bmN0aW9uLCB0aGUgYGRlbGF5YCBwcm9wZXJ0eVxuICAgICAgICogZGV0ZXJtaW5lcyBhIGRlYm91bmNlIHRpbWUgYWZ0ZXIgYSBjaGFuZ2UgdG8gb2JzZXJ2ZWQgaXRlbVxuICAgICAgICogcHJvcGVydGllcyB0aGF0IG11c3QgcGFzcyBiZWZvcmUgdGhlIGZpbHRlciBvciBzb3J0IGlzIHJlLXJ1bi5cbiAgICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIHJhdGUtbGltaXRpbmcgc2h1ZmZpbmcgb2YgdGhlIHZpZXcgd2hlblxuICAgICAgICogaXRlbSBjaGFuZ2VzIG1heSBiZSBmcmVxdWVudC5cbiAgICAgICAqL1xuICAgICAgZGVsYXk6IE51bWJlcixcblxuICAgICAgLyoqXG4gICAgICAgKiBDb3VudCBvZiBjdXJyZW50bHkgcmVuZGVyZWQgaXRlbXMgYWZ0ZXIgYGZpbHRlcmAgKGlmIGFueSkgaGFzIGJlZW4gYXBwbGllZC5cbiAgICAgICAqIElmIFwiY2h1bmtpbmcgbW9kZVwiIGlzIGVuYWJsZWQsIGByZW5kZXJlZEl0ZW1Db3VudGAgaXMgdXBkYXRlZCBlYWNoIHRpbWUgYVxuICAgICAgICogc2V0IG9mIHRlbXBsYXRlIGluc3RhbmNlcyBpcyByZW5kZXJlZC5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgIHJlbmRlcmVkSXRlbUNvdW50OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWZpbmVzIGFuIGluaXRpYWwgY291bnQgb2YgdGVtcGxhdGUgaW5zdGFuY2VzIHRvIHJlbmRlciBhZnRlciBzZXR0aW5nXG4gICAgICAgKiB0aGUgYGl0ZW1zYCBhcnJheSwgYmVmb3JlIHRoZSBuZXh0IHBhaW50LCBhbmQgcHV0cyB0aGUgYGRvbS1yZXBlYXRgXG4gICAgICAgKiBpbnRvIFwiY2h1bmtpbmcgbW9kZVwiLiAgVGhlIHJlbWFpbmluZyBpdGVtcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJlbmRlcmVkXG4gICAgICAgKiBpbmNyZW1lbnRhbGx5IGF0IGVhY2ggYW5pbWF0aW9uIGZyYW1lIHRoZXJvZiB1bnRpbCBhbGwgaW5zdGFuY2VzIGhhdmVcbiAgICAgICAqIGJlZW4gcmVuZGVyZWQuXG4gICAgICAgKi9cbiAgICAgIGluaXRpYWxDb3VudDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIG9ic2VydmVyOiAnX19pbml0aWFsaXplQ2h1bmtpbmcnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gYGluaXRpYWxDb3VudGAgaXMgdXNlZCwgdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIGEgZnJhbWUgcmF0ZSB0b1xuICAgICAgICogdGFyZ2V0IGJ5IHRocm90dGxpbmcgdGhlIG51bWJlciBvZiBpbnN0YW5jZXMgcmVuZGVyZWQgZWFjaCBmcmFtZSB0b1xuICAgICAgICogbm90IGV4Y2VlZCB0aGUgYnVkZ2V0IGZvciB0aGUgdGFyZ2V0IGZyYW1lIHJhdGUuICBTZXR0aW5nIHRoaXMgdG8gYVxuICAgICAgICogaGlnaGVyIG51bWJlciB3aWxsIGFsbG93IGxvd2VyIGxhdGVuY3kgYW5kIGhpZ2hlciB0aHJvdWdocHV0IGZvclxuICAgICAgICogdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIGJ1dCB3aWxsIHJlc3VsdCBpbiBhIGxvbmdlciB0aW1lIGZvciB0aGVcbiAgICAgICAqIHJlbWFpbmluZyBpdGVtcyB0byBjb21wbGV0ZSByZW5kZXJpbmcuXG4gICAgICAgKi9cbiAgICAgIHRhcmdldEZyYW1lcmF0ZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAyMFxuICAgICAgfSxcblxuICAgICAgX3RhcmdldEZyYW1lVGltZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIGNvbXB1dGVkOiAnX19jb21wdXRlRnJhbWVUaW1lKHRhcmdldEZyYW1lcmF0ZSknXG4gICAgICB9XG5cbiAgICB9O1xuXG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICByZXR1cm4gWyAnX19pdGVtc0NoYW5nZWQoaXRlbXMuKiknIF07XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19pbnN0YW5jZXMgPSBbXTtcbiAgICB0aGlzLl9fbGltaXQgPSBJbmZpbml0eTtcbiAgICB0aGlzLl9fcG9vbCA9IFtdO1xuICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBudWxsO1xuICAgIHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeCA9IHt9O1xuICAgIHRoaXMuX19jaHVua0NvdW50ID0gbnVsbDtcbiAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IG51bGw7XG4gICAgdGhpcy5fX3NvcnRGbiA9IG51bGw7XG4gICAgdGhpcy5fX2ZpbHRlckZuID0gbnVsbDtcbiAgICB0aGlzLl9fb2JzZXJ2ZVBhdGhzID0gbnVsbDtcbiAgICB0aGlzLl9fY3RvciA9IG51bGw7XG4gICAgdGhpcy5fX2lzRGV0YWNoZWQgPSB0cnVlO1xuICAgIHRoaXMudGVtcGxhdGUgPSBudWxsO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLl9faXNEZXRhY2hlZCA9IHRydWU7XG4gICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX19pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX19kZXRhY2hJbnN0YW5jZShpKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIC8vIG9ubHkgcGVyZm9ybSBhdHRhY2htZW50IGlmIHRoZSBlbGVtZW50IHdhcyBwcmV2aW91c2x5IGRldGFjaGVkLlxuICAgIGlmICh0aGlzLl9faXNEZXRhY2hlZCkge1xuICAgICAgdGhpcy5fX2lzRGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9fYXR0YWNoSW5zdGFuY2UoaSwgcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfX2Vuc3VyZVRlbXBsYXRpemVkKCkge1xuICAgIC8vIFRlbXBsYXRpemluZyAoZ2VuZXJhdGluZyB0aGUgaW5zdGFuY2UgY29uc3RydWN0b3IpIG5lZWRzIHRvIHdhaXRcbiAgICAvLyB1bnRpbCByZWFkeSwgc2luY2Ugd29uJ3QgaGF2ZSBpdHMgdGVtcGxhdGUgY29udGVudCBoYW5kZWQgYmFjayB0b1xuICAgIC8vIGl0IHVudGlsIHRoZW5cbiAgICBpZiAoIXRoaXMuX19jdG9yKSB7XG4gICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAvLyAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1yZXBlYXQgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRlbXBsYXRlIGluc3RhbmNlIHByb3BzIHRoYXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gZm9yd2FyZGluZ1xuICAgICAgbGV0IGluc3RhbmNlUHJvcHMgPSB7fTtcbiAgICAgIGluc3RhbmNlUHJvcHNbdGhpcy5hc10gPSB0cnVlO1xuICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLmluZGV4QXNdID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlUHJvcHNbdGhpcy5pdGVtc0luZGV4QXNdID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19jdG9yID0gVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgIG11dGFibGVEYXRhOiB0aGlzLm11dGFibGVEYXRhLFxuICAgICAgICBwYXJlbnRNb2RlbDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VQcm9wczogaW5zdGFuY2VQcm9wcyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBzZXRcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgICAgICovXG4gICAgICAgIGZvcndhcmRIb3N0UHJvcDogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICBsZXQgaSQgPSB0aGlzLl9faW5zdGFuY2VzO1xuICAgICAgICAgIGZvciAobGV0IGk9MCwgaW5zdDsgKGk8aSQubGVuZ3RoKSAmJiAoaW5zdD1pJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgaW5zdC5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5zdCBJbnN0YW5jZSB0byBub3RpZnlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gbm90aWZ5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gbm90aWZ5XG4gICAgICAgICAqL1xuICAgICAgICBub3RpZnlJbnN0YW5jZVByb3A6IGZ1bmN0aW9uKGluc3QsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG1hdGNoZXModGhpcy5hcywgcHJvcCkpIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpbnN0W3RoaXMuaXRlbXNJbmRleEFzXTtcbiAgICAgICAgICAgIGlmIChwcm9wID09IHRoaXMuYXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5pdGVtc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGF0aCA9IHRyYW5zbGF0ZSh0aGlzLmFzLCAnaXRlbXMuJyArIGlkeCwgcHJvcCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVBhdGgocGF0aCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX19nZXRNZXRob2RIb3N0KCkge1xuICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgc2hvdWxkIGJlIHRoZSBvd25lciBvZiB0aGUgb3V0ZXJtb3N0IHRlbXBsYXRlLlxuICAgIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAgIC8vIGFwcHJveGltYXRlIHRoaXMgdmlhIGNvb3BlcmF0aW9uIHdpdGggb3VyIGRhdGFIb3N0IGFsd2F5cyBzZXR0aW5nXG4gICAgLy8gYF9tZXRob2RIb3N0YCBhcyBsb25nIGFzIHRoZXJlIHdlcmUgYmluZGluZ3MgKG9yIGlkJ3MpIG9uIHRoaXNcbiAgICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICAgIHJldHVybiB0aGlzLl9fZGF0YUhvc3QuX21ldGhvZEhvc3QgfHwgdGhpcy5fX2RhdGFIb3N0O1xuICB9XG5cbiAgX19zb3J0Q2hhbmdlZChzb3J0KSB7XG4gICAgbGV0IG1ldGhvZEhvc3QgPSB0aGlzLl9fZ2V0TWV0aG9kSG9zdCgpO1xuICAgIHRoaXMuX19zb3J0Rm4gPSBzb3J0ICYmICh0eXBlb2Ygc29ydCA9PSAnZnVuY3Rpb24nID8gc29ydCA6XG4gICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG1ldGhvZEhvc3Rbc29ydF0uYXBwbHkobWV0aG9kSG9zdCwgYXJndW1lbnRzKTsgfSk7XG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG4gIH1cblxuICBfX2ZpbHRlckNoYW5nZWQoZmlsdGVyKSB7XG4gICAgbGV0IG1ldGhvZEhvc3QgPSB0aGlzLl9fZ2V0TWV0aG9kSG9zdCgpO1xuICAgIHRoaXMuX19maWx0ZXJGbiA9IGZpbHRlciAmJiAodHlwZW9mIGZpbHRlciA9PSAnZnVuY3Rpb24nID8gZmlsdGVyIDpcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kSG9zdFtmaWx0ZXJdLmFwcGx5KG1ldGhvZEhvc3QsIGFyZ3VtZW50cyk7IH0pO1xuICAgIGlmICh0aGlzLml0ZW1zKSB7XG4gICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgfVxuICB9XG5cbiAgX19jb21wdXRlRnJhbWVUaW1lKHJhdGUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKDEwMDAvcmF0ZSk7XG4gIH1cblxuICBfX2luaXRpYWxpemVDaHVua2luZygpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsQ291bnQpIHtcbiAgICAgIHRoaXMuX19saW1pdCA9IHRoaXMuaW5pdGlhbENvdW50O1xuICAgICAgdGhpcy5fX2NodW5rQ291bnQgPSB0aGlzLmluaXRpYWxDb3VudDtcbiAgICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9XG5cbiAgX190cnlSZW5kZXJDaHVuaygpIHtcbiAgICAvLyBEZWJvdW5jZWQgc28gdGhhdCBtdWx0aXBsZSBjYWxscyB0aHJvdWdoIGBfcmVuZGVyYCBiZXR3ZWVuIGFuaW1hdGlvblxuICAgIC8vIGZyYW1lcyBvbmx5IHF1ZXVlIG9uZSBuZXcgckFGIChlLmcuIGFycmF5IG11dGF0aW9uICYgY2h1bmtlZCByZW5kZXIpXG4gICAgaWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5fX2xpbWl0IDwgdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVxdWVzdFJlbmRlckNodW5rKTtcbiAgICB9XG4gIH1cblxuICBfX3JlcXVlc3RSZW5kZXJDaHVuaygpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PnRoaXMuX19yZW5kZXJDaHVuaygpKTtcbiAgfVxuXG4gIF9fcmVuZGVyQ2h1bmsoKSB7XG4gICAgLy8gU2ltcGxlIGF1dG8gY2h1bmtTaXplIHRocm90dGxpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIGZlZWRiYWNrIGxvb3A6XG4gICAgLy8gbWVhc3VyZSBhY3R1YWwgdGltZSBiZXR3ZWVuIGZyYW1lcyBhbmQgc2NhbGUgY2h1bmsgY291bnQgYnkgcmF0aW9cbiAgICAvLyBvZiB0YXJnZXQvYWN0dWFsIGZyYW1lIHRpbWVcbiAgICBsZXQgY3VyckNodW5rVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGxldCByYXRpbyA9IHRoaXMuX3RhcmdldEZyYW1lVGltZSAvIChjdXJyQ2h1bmtUaW1lIC0gdGhpcy5fX2xhc3RDaHVua1RpbWUpO1xuICAgIHRoaXMuX19jaHVua0NvdW50ID0gTWF0aC5yb3VuZCh0aGlzLl9fY2h1bmtDb3VudCAqIHJhdGlvKSB8fCAxO1xuICAgIHRoaXMuX19saW1pdCArPSB0aGlzLl9fY2h1bmtDb3VudDtcbiAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IGN1cnJDaHVua1RpbWU7XG4gICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICB9XG5cbiAgX19vYnNlcnZlQ2hhbmdlZCgpIHtcbiAgICB0aGlzLl9fb2JzZXJ2ZVBhdGhzID0gdGhpcy5vYnNlcnZlICYmXG4gICAgICB0aGlzLm9ic2VydmUucmVwbGFjZSgnLionLCAnLicpLnNwbGl0KCcgJyk7XG4gIH1cblxuICBfX2l0ZW1zQ2hhbmdlZChjaGFuZ2UpIHtcbiAgICBpZiAodGhpcy5pdGVtcyAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLml0ZW1zKSkge1xuICAgICAgY29uc29sZS53YXJuKCdkb20tcmVwZWF0IGV4cGVjdGVkIGFycmF5IGZvciBgaXRlbXNgLCBmb3VuZCcsIHRoaXMuaXRlbXMpO1xuICAgIH1cbiAgICAvLyBJZiBwYXRoIHdhcyB0byBhbiBpdGVtIChlLmcuICdpdGVtcy4zJyBvciAnaXRlbXMuMy5mb28nKSwgZm9yd2FyZCB0aGVcbiAgICAvLyBwYXRoIHRvIHRoYXQgaW5zdGFuY2Ugc3luY2hyb25vdXNseSAocmV0dW5zIGZhbHNlIGZvciBub24taXRlbSBwYXRocylcbiAgICBpZiAoIXRoaXMuX19oYW5kbGVJdGVtUGF0aChjaGFuZ2UucGF0aCwgY2hhbmdlLnZhbHVlKSkge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgYXJyYXkgd2FzIHJlc2V0ICgnaXRlbXMnKSBvciBzcGxpY2VkICgnaXRlbXMuc3BsaWNlcycpLFxuICAgICAgLy8gc28gcXVldWUgYSBmdWxsIHJlZnJlc2hcbiAgICAgIHRoaXMuX19pbml0aWFsaXplQ2h1bmtpbmcoKTtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG4gIH1cblxuICBfX2hhbmRsZU9ic2VydmVkUGF0aHMocGF0aCkge1xuICAgIGlmICh0aGlzLl9fb2JzZXJ2ZVBhdGhzKSB7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcocGF0aC5pbmRleE9mKCcuJykgKyAxKTtcbiAgICAgIGxldCBwYXRocyA9IHRoaXMuX19vYnNlcnZlUGF0aHM7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8cGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdGguaW5kZXhPZihwYXRoc1tpXSkgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlciwgdGhpcy5kZWxheSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOkRvbVJlcGVhdCl9IGZuIEZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IGRlbGF5IERlbGF5IGluIG1zIHRvIGRlYm91bmNlIGJ5LlxuICAgKi9cbiAgX19kZWJvdW5jZVJlbmRlcihmbiwgZGVsYXkgPSAwKSB7XG4gICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyXG4gICAgICAgICwgZGVsYXkgPiAwID8gdGltZU91dC5hZnRlcihkZWxheSkgOiBtaWNyb1Rhc2tcbiAgICAgICAgLCBmbi5iaW5kKHRoaXMpKTtcbiAgICBlbnF1ZXVlRGVib3VuY2VyKHRoaXMuX19yZW5kZXJEZWJvdW5jZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIE5vcm1hbGx5IHJlbmRlcmluZyBpc1xuICAgKiBhc3luY2hyb25vdXMgdG8gYSBwcm92b2tpbmcgY2hhbmdlLiBUaGlzIGlzIGRvbmUgZm9yIGVmZmljaWVuY3kgc29cbiAgICogdGhhdCBtdWx0aXBsZSBjaGFuZ2VzIHRyaWdnZXIgb25seSBhIHNpbmdsZSByZW5kZXIuIFRoZSByZW5kZXIgbWV0aG9kXG4gICAqIHNob3VsZCBiZSBjYWxsZWQgaWYsIGZvciBleGFtcGxlLCB0ZW1wbGF0ZSByZW5kZXJpbmcgaXMgcmVxdWlyZWQgdG9cbiAgICogdmFsaWRhdGUgYXBwbGljYXRpb24gc3RhdGUuXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgLy8gUXVldWUgdGhpcyByZXBlYXRlciwgdGhlbiBmbHVzaCBhbGwgaW4gb3JkZXJcbiAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgZmx1c2goKTtcbiAgfVxuXG4gIF9fcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5fX2Vuc3VyZVRlbXBsYXRpemVkKCkpIHtcbiAgICAgIC8vIE5vIHRlbXBsYXRlIGZvdW5kIHlldFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fYXBwbHlGdWxsUmVmcmVzaCgpO1xuICAgIC8vIFJlc2V0IHRoZSBwb29sXG4gICAgLy8gVE9ETyhrc2NoYWFmKTogUmV1c2UgcG9vbCBhY3Jvc3MgdHVybnMgYW5kIG5lc3RlZCB0ZW1wbGF0ZXNcbiAgICAvLyBOb3cgdGhhdCBvYmplY3RzL2FycmF5cyBhcmUgcmUtZXZhbHVhdGVkIHdoZW4gc2V0LCB3ZSBjYW4gc2FmZWx5XG4gICAgLy8gcmV1c2UgcG9vbGVkIGluc3RhbmNlcyBhY3Jvc3MgdHVybnMsIGhvd2V2ZXIgd2Ugc3RpbGwgbmVlZCB0byBkZWNpZGVcbiAgICAvLyBzZW1hbnRpY3MgcmVnYXJkaW5nIGhvdyBsb25nIHRvIGhvbGQsIGhvdyBtYW55IHRvIGhvbGQsIGV0Yy5cbiAgICB0aGlzLl9fcG9vbC5sZW5ndGggPSAwO1xuICAgIC8vIFNldCByZW5kZXJlZCBpdGVtIGNvdW50XG4gICAgdGhpcy5fc2V0UmVuZGVyZWRJdGVtQ291bnQodGhpcy5fX2luc3RhbmNlcy5sZW5ndGgpO1xuICAgIC8vIE5vdGlmeSB1c2Vyc1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9KSk7XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gcmVuZGVyIG1vcmUgaXRlbXNcbiAgICB0aGlzLl9fdHJ5UmVuZGVyQ2h1bmsoKTtcbiAgfVxuXG4gIF9fYXBwbHlGdWxsUmVmcmVzaCgpIHtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zIHx8IFtdO1xuICAgIGxldCBpc250SWR4VG9JdGVtc0lkeCA9IG5ldyBBcnJheShpdGVtcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaXNudElkeFRvSXRlbXNJZHhbaV0gPSBpO1xuICAgIH1cbiAgICAvLyBBcHBseSB1c2VyIGZpbHRlclxuICAgIGlmICh0aGlzLl9fZmlsdGVyRm4pIHtcbiAgICAgIGlzbnRJZHhUb0l0ZW1zSWR4ID0gaXNudElkeFRvSXRlbXNJZHguZmlsdGVyKChpLCBpZHgsIGFycmF5KSA9PlxuICAgICAgICB0aGlzLl9fZmlsdGVyRm4oaXRlbXNbaV0sIGlkeCwgYXJyYXkpKTtcbiAgICB9XG4gICAgLy8gQXBwbHkgdXNlciBzb3J0XG4gICAgaWYgKHRoaXMuX19zb3J0Rm4pIHtcbiAgICAgIGlzbnRJZHhUb0l0ZW1zSWR4LnNvcnQoKGEsIGIpID0+IHRoaXMuX19zb3J0Rm4oaXRlbXNbYV0sIGl0ZW1zW2JdKSk7XG4gICAgfVxuICAgIC8vIGl0ZW1zLT5pbnN0IG1hcCBrZXB0IGZvciBpdGVtIHBhdGggZm9yd2FyZGluZ1xuICAgIGNvbnN0IGl0ZW1zSWR4VG9JbnN0SWR4ID0gdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4ID0ge307XG4gICAgbGV0IGluc3RJZHggPSAwO1xuICAgIC8vIEdlbmVyYXRlIGluc3RhbmNlcyBhbmQgYXNzaWduIGl0ZW1zXG4gICAgY29uc3QgbGltaXQgPSBNYXRoLm1pbihpc250SWR4VG9JdGVtc0lkeC5sZW5ndGgsIHRoaXMuX19saW1pdCk7XG4gICAgZm9yICg7IGluc3RJZHg8bGltaXQ7IGluc3RJZHgrKykge1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdO1xuICAgICAgbGV0IGl0ZW1JZHggPSBpc250SWR4VG9JdGVtc0lkeFtpbnN0SWR4XTtcbiAgICAgIGxldCBpdGVtID0gaXRlbXNbaXRlbUlkeF07XG4gICAgICBpdGVtc0lkeFRvSW5zdElkeFtpdGVtSWR4XSA9IGluc3RJZHg7XG4gICAgICBpZiAoaW5zdCAmJiBpbnN0SWR4IDwgdGhpcy5fX2xpbWl0KSB7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmFzLCBpdGVtKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaW5kZXhBcywgaW5zdElkeCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLml0ZW1zSW5kZXhBcywgaXRlbUlkeCk7XG4gICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2luc2VydEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgYW55IGV4dHJhIGluc3RhbmNlcyBmcm9tIHByZXZpb3VzIHN0YXRlXG4gICAgZm9yIChsZXQgaT10aGlzLl9faW5zdGFuY2VzLmxlbmd0aC0xOyBpPj1pbnN0SWR4OyBpLS0pIHtcbiAgICAgIHRoaXMuX19kZXRhY2hBbmRSZW1vdmVJbnN0YW5jZShpKTtcbiAgICB9XG4gIH1cblxuICBfX2RldGFjaEluc3RhbmNlKGlkeCkge1xuICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpZHhdO1xuICAgIGZvciAobGV0IGk9MDsgaTxpbnN0LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZWwgPSBpbnN0LmNoaWxkcmVuW2ldO1xuICAgICAgaW5zdC5yb290LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICBfX2F0dGFjaEluc3RhbmNlKGlkeCwgcGFyZW50KSB7XG4gICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2lkeF07XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShpbnN0LnJvb3QsIHRoaXMpO1xuICB9XG5cbiAgX19kZXRhY2hBbmRSZW1vdmVJbnN0YW5jZShpZHgpIHtcbiAgICBsZXQgaW5zdCA9IHRoaXMuX19kZXRhY2hJbnN0YW5jZShpZHgpO1xuICAgIGlmIChpbnN0KSB7XG4gICAgICB0aGlzLl9fcG9vbC5wdXNoKGluc3QpO1xuICAgIH1cbiAgICB0aGlzLl9faW5zdGFuY2VzLnNwbGljZShpZHgsIDEpO1xuICB9XG5cbiAgX19zdGFtcEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpIHtcbiAgICBsZXQgbW9kZWwgPSB7fTtcbiAgICBtb2RlbFt0aGlzLmFzXSA9IGl0ZW07XG4gICAgbW9kZWxbdGhpcy5pbmRleEFzXSA9IGluc3RJZHg7XG4gICAgbW9kZWxbdGhpcy5pdGVtc0luZGV4QXNdID0gaXRlbUlkeDtcbiAgICByZXR1cm4gbmV3IHRoaXMuX19jdG9yKG1vZGVsKTtcbiAgfVxuXG4gIF9faW5zZXJ0SW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCkge1xuICAgIGxldCBpbnN0ID0gdGhpcy5fX3Bvb2wucG9wKCk7XG4gICAgaWYgKGluc3QpIHtcbiAgICAgIC8vIFRPRE8oa3NjaGFhZik6IElmIHRoZSBwb29sIGlzIHNoYXJlZCBhY3Jvc3MgdHVybnMsIGhvc3RQcm9wc1xuICAgICAgLy8gbmVlZCB0byBiZSByZS1zZXQgdG8gcmV1c2VkIGluc3RhbmNlcyBpbiBhZGRpdGlvbiB0byBpdGVtXG4gICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5hcywgaXRlbSk7XG4gICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pbmRleEFzLCBpbnN0SWR4KTtcbiAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLml0ZW1zSW5kZXhBcywgaXRlbUlkeCk7XG4gICAgICBpbnN0Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdCA9IHRoaXMuX19zdGFtcEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlUm93ID0gdGhpcy5fX2luc3RhbmNlc1tpbnN0SWR4ICsgMV07XG4gICAgbGV0IGJlZm9yZU5vZGUgPSBiZWZvcmVSb3cgPyBiZWZvcmVSb3cuY2hpbGRyZW5bMF0gOiB0aGlzO1xuICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zdC5yb290LCBiZWZvcmVOb2RlKTtcbiAgICB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdID0gaW5zdDtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIC8vIEltcGxlbWVudHMgZXh0ZW5zaW9uIHBvaW50IGZyb20gVGVtcGxhdGl6ZSBtaXhpblxuICBfc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pIHtcbiAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fX2luc3RhbmNlc1tpXS5fc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBhcyBhIHNpZGUgZWZmZWN0IG9mIGEgaG9zdCBpdGVtcy48a2V5Pi48cGF0aD4gcGF0aCBjaGFuZ2UsXG4gIC8vIHJlc3BvbnNpYmxlIGZvciBub3RpZnlpbmcgaXRlbS48cGF0aD4gY2hhbmdlcyB0byBpbnN0IGZvciBrZXlcbiAgX19oYW5kbGVJdGVtUGF0aChwYXRoLCB2YWx1ZSkge1xuICAgIGxldCBpdGVtc1BhdGggPSBwYXRoLnNsaWNlKDYpOyAvLyAnaXRlbXMuJy5sZW5ndGggPT0gNlxuICAgIGxldCBkb3QgPSBpdGVtc1BhdGguaW5kZXhPZignLicpO1xuICAgIGxldCBpdGVtc0lkeCA9IGRvdCA8IDAgPyBpdGVtc1BhdGggOiBpdGVtc1BhdGguc3Vic3RyaW5nKDAsIGRvdCk7XG4gICAgLy8gSWYgcGF0aCB3YXMgaW5kZXggaW50byBhcnJheS4uLlxuICAgIGlmIChpdGVtc0lkeCA9PSBwYXJzZUludChpdGVtc0lkeCwgMTApKSB7XG4gICAgICBsZXQgaXRlbVN1YlBhdGggPSBkb3QgPCAwID8gJycgOiBpdGVtc1BhdGguc3Vic3RyaW5nKGRvdCsxKTtcbiAgICAgIC8vIElmIHRoZSBwYXRoIGlzIG9ic2VydmVkLCBpdCB3aWxsIHRyaWdnZXIgYSBmdWxsIHJlZnJlc2hcbiAgICAgIHRoaXMuX19oYW5kbGVPYnNlcnZlZFBhdGhzKGl0ZW1TdWJQYXRoKTtcbiAgICAgIC8vIE5vdGUsIGV2ZW4gaWYgYSBydWxsIHJlZnJlc2ggaXMgdHJpZ2dlcmVkLCBhbHdheXMgZG8gdGhlIHBhdGhcbiAgICAgIC8vIG5vdGlmaWNhdGlvbiBiZWNhdXNlIHVubGVzcyBtdXRhYmxlRGF0YSBpcyB1c2VkIGZvciBkb20tcmVwZWF0XG4gICAgICAvLyBhbmQgYWxsIGVsZW1lbnRzIGluIHRoZSBpbnN0YW5jZSBzdWJ0cmVlLCBhIGZ1bGwgcmVmcmVzaCBtYXlcbiAgICAgIC8vIG5vdCB0cmlnZ2VyIHRoZSBwcm9wZXIgdXBkYXRlLlxuICAgICAgbGV0IGluc3RJZHggPSB0aGlzLl9faXRlbXNJZHhUb0luc3RJZHhbaXRlbXNJZHhdO1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgbGV0IGl0ZW1QYXRoID0gdGhpcy5hcyArIChpdGVtU3ViUGF0aCA/ICcuJyArIGl0ZW1TdWJQYXRoIDogJycpO1xuICAgICAgICAvLyBUaGlzIGlzIGVmZmVjdGl2ZWx5IGBub3RpZnlQYXRoYCwgYnV0IGF2b2lkcyBzb21lIG9mIHRoZSBvdmVyaGVhZFxuICAgICAgICAvLyBvZiB0aGUgcHVibGljIEFQSVxuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgoaXRlbVBhdGgsIHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZW0gYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCBzdGFtcGVkIGJ5XG4gICAqIHRoaXMgYGRvbS1yZXBlYXRgLlxuICAgKlxuICAgKiBOb3RlLCB0byBtb2RpZnkgc3ViLXByb3BlcnRpZXMgb2YgdGhlIGl0ZW0sXG4gICAqIGBtb2RlbEZvckVsZW1lbnQoZWwpLnNldCgnaXRlbS48c3ViLXByb3A+JywgdmFsdWUpYFxuICAgKiBzaG91bGQgYmUgdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBpdGVtLlxuICAgKiBAcmV0dXJuIHsqfSBJdGVtIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudC5cbiAgICovXG4gIGl0ZW1Gb3JFbGVtZW50KGVsKSB7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5tb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVt0aGlzLmFzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnN0IGluZGV4IGZvciBhIGdpdmVuIGVsZW1lbnQgc3RhbXBlZCBieSB0aGlzIGBkb20tcmVwZWF0YC5cbiAgICogSWYgYHNvcnRgIGlzIHByb3ZpZGVkLCB0aGUgaW5kZXggd2lsbCByZWZsZWN0IHRoZSBzb3J0ZWQgb3JkZXIgKHJhdGhlclxuICAgKiB0aGFuIHRoZSBvcmlnaW5hbCBhcnJheSBvcmRlcikuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiB0aGUgaW5kZXguXG4gICAqIEByZXR1cm4geyp9IFJvdyBpbmRleCBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnQgKG5vdGUgdGhpcyBtYXlcbiAgICogICBub3QgY29ycmVzcG9uZCB0byB0aGUgYXJyYXkgaW5kZXggaWYgYSB1c2VyIGBzb3J0YCBpcyBhcHBsaWVkKS5cbiAgICovXG4gIGluZGV4Rm9yRWxlbWVudChlbCkge1xuICAgIGxldCBpbnN0YW5jZSA9IHRoaXMubW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2VbdGhpcy5pbmRleEFzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2hcbiAgICogc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXNcbiAgICogY29udGFpbmVkIGluLiBBIHRlbXBsYXRlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkJhc2VgLCBhbmRcbiAgICogc2hvdWxkIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgIGxldCBtb2RlbCA9IG1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAqICAgaWYgKG1vZGVsLmluZGV4IDwgMTApIHtcbiAgICogICAgIG1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IE1vZGVsIHJlcHJlc2VudGluZyB0aGUgYmluZGluZyBzY29wZSBmb3JcbiAgICogICB0aGUgZWxlbWVudC5cbiAgICovXG4gIG1vZGVsRm9yRWxlbWVudChlbCkge1xuICAgIHJldHVybiBUZW1wbGF0aXplLm1vZGVsRm9yRWxlbWVudCh0aGlzLnRlbXBsYXRlLCBlbCk7XG4gIH1cblxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoRG9tUmVwZWF0LmlzLCBEb21SZXBlYXQpO1xuXG5leHBvcnQgeyBEb21SZXBlYXQgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1yZXBlYXQuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi8uLi9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3RlbXBsYXRpemUuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VyIH0gZnJvbSAnLi4vdXRpbHMvZGVib3VuY2UuanMnO1xuaW1wb3J0IHsgZW5xdWV1ZURlYm91bmNlciwgZmx1c2ggfSBmcm9tICcuLi91dGlscy9mbHVzaC5qcyc7XG5pbXBvcnQgeyBtaWNyb1Rhc2sgfSBmcm9tICcuLi91dGlscy9hc3luYy5qcyc7XG5pbXBvcnQgeyByb290IGFzIHJvb3QkMCB9IGZyb20gJy4uL3V0aWxzL3BhdGguanMnO1xuXG4vKipcbiAqIFRoZSBgPGRvbS1pZj5gIGVsZW1lbnQgd2lsbCBzdGFtcCBhIGxpZ2h0LWRvbSBgPHRlbXBsYXRlPmAgY2hpbGQgd2hlblxuICogdGhlIGBpZmAgcHJvcGVydHkgYmVjb21lcyB0cnV0aHksIGFuZCB0aGUgdGVtcGxhdGUgY2FuIHVzZSBQb2x5bWVyXG4gKiBkYXRhLWJpbmRpbmcgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGZlYXR1cmVzIHdoZW4gdXNlZCBpbiB0aGUgY29udGV4dCBvZlxuICogYSBQb2x5bWVyIGVsZW1lbnQncyB0ZW1wbGF0ZS5cbiAqXG4gKiBXaGVuIGBpZmAgYmVjb21lcyBmYWxzZXksIHRoZSBzdGFtcGVkIGNvbnRlbnQgaXMgaGlkZGVuIGJ1dCBub3RcbiAqIHJlbW92ZWQgZnJvbSBkb20uIFdoZW4gYGlmYCBzdWJzZXF1ZW50bHkgYmVjb21lcyB0cnV0aHkgYWdhaW4sIHRoZSBjb250ZW50XG4gKiBpcyBzaW1wbHkgcmUtc2hvd24uIFRoaXMgYXBwcm9hY2ggaXMgdXNlZCBkdWUgdG8gaXRzIGZhdm9yYWJsZSBwZXJmb3JtYW5jZVxuICogY2hhcmFjdGVyaXN0aWNzOiB0aGUgZXhwZW5zZSBvZiBjcmVhdGluZyB0ZW1wbGF0ZSBjb250ZW50IGlzIHBhaWQgb25seVxuICogb25jZSBhbmQgbGF6aWx5LlxuICpcbiAqIFNldCB0aGUgYHJlc3RhbXBgIHByb3BlcnR5IHRvIHRydWUgdG8gZm9yY2UgdGhlIHN0YW1wZWQgY29udGVudCB0byBiZVxuICogY3JlYXRlZCAvIGRlc3Ryb3llZCB3aGVuIHRoZSBgaWZgIGNvbmRpdGlvbiBjaGFuZ2VzLlxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAcG9seW1lclxuICogQGV4dGVuZHMgUG9seW1lci5FbGVtZW50XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBjb25kaXRpb25hbGx5IHN0YW1wcyBhbmQgaGlkZXMgb3IgcmVtb3Zlc1xuICogICB0ZW1wbGF0ZSBjb250ZW50IGJhc2VkIG9uIGEgYm9vbGVhbiBmbGFnLlxuICovXG5jbGFzcyBEb21JZiBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgLy8gY2FuIGZpbmQgdGhlIHRhZyBuYW1lIGZyb20gY3VzdG9tRWxlbWVudHMuZGVmaW5lIGNhbGxcbiAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdkb20taWYnOyB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIG51bGw7IH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW5ldmVyIERPTSBpcyBhZGRlZCBvciByZW1vdmVkL2hpZGRlbiBieSB0aGlzIHRlbXBsYXRlIChieVxuICAgICAgICogZGVmYXVsdCwgcmVuZGVyaW5nIG9jY3VycyBsYXppbHkpLiAgVG8gZm9yY2UgaW1tZWRpYXRlIHJlbmRlcmluZywgY2FsbFxuICAgICAgICogYHJlbmRlcmAuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGRvbS1jaGFuZ2VcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyB0ZW1wbGF0ZSBzaG91bGQgc3RhbXAuXG4gICAgICAgKi9cbiAgICAgIGlmOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG9ic2VydmVyOiAnX19kZWJvdW5jZVJlbmRlcidcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0cnVlLCBlbGVtZW50cyB3aWxsIGJlIHJlbW92ZWQgZnJvbSBET00gYW5kIGRpc2NhcmRlZCB3aGVuIGBpZmBcbiAgICAgICAqIGJlY29tZXMgZmFsc2UgYW5kIHJlLWNyZWF0ZWQgYW5kIGFkZGVkIGJhY2sgdG8gdGhlIERPTSB3aGVuIGBpZmBcbiAgICAgICAqIGJlY29tZXMgdHJ1ZS4gIEJ5IGRlZmF1bHQsIHN0YW1wZWQgZWxlbWVudHMgd2lsbCBiZSBoaWRkZW4gYnV0IGxlZnRcbiAgICAgICAqIGluIHRoZSBET00gd2hlbiBgaWZgIGJlY29tZXMgZmFsc2UsIHdoaWNoIGlzIGdlbmVyYWxseSByZXN1bHRzXG4gICAgICAgKiBpbiBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgKi9cbiAgICAgIHJlc3RhbXA6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2RlYm91bmNlUmVuZGVyJ1xuICAgICAgfVxuXG4gICAgfTtcblxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gbnVsbDtcbiAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICB0aGlzLl9faW5zdGFuY2UgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RJZiA9IGZhbHNlO1xuICAgIHRoaXMuX19jdG9yID0gbnVsbDtcbiAgfVxuXG4gIF9fZGVib3VuY2VSZW5kZXIoKSB7XG4gICAgLy8gUmVuZGVyIGlzIGFzeW5jIGZvciAyIHJlYXNvbnM6XG4gICAgLy8gMS4gVG8gZWxpbWluYXRlIGRvbSBjcmVhdGlvbiB0cmFzaGluZyBpZiB1c2VyIGNvZGUgdGhyYXNoZXMgYGlmYCBpbiB0aGVcbiAgICAvLyAgICBzYW1lIHR1cm4uIFRoaXMgd2FzIG1vcmUgY29tbW9uIGluIDEueCB3aGVyZSBhIGNvbXBvdW5kIGNvbXB1dGVkXG4gICAgLy8gICAgcHJvcGVydHkgY291bGQgcmVzdWx0IGluIHRoZSByZXN1bHQgY2hhbmdpbmcgbXVsdGlwbGUgdGltZXMsIGJ1dCBpc1xuICAgIC8vICAgIG1pdGlnYXRlZCB0byBhIGxhcmdlIGV4dGVudCBieSBiYXRjaGVkIHByb3BlcnR5IHByb2Nlc3NpbmcgaW4gMi54LlxuICAgIC8vIDIuIFRvIGF2b2lkIGRvdWJsZSBvYmplY3QgcHJvcGFnYXRpb24gd2hlbiBhIGJhZyBpbmNsdWRpbmcgdmFsdWVzIGJvdW5kXG4gICAgLy8gICAgdG8gdGhlIGBpZmAgcHJvcGVydHkgYXMgd2VsbCBhcyBvbmUgb3IgbW9yZSBob3N0UHJvcHMgY291bGQgZW5xdWV1ZVxuICAgIC8vICAgIHRoZSA8ZG9tLWlmPiB0byBmbHVzaCBiZWZvcmUgdGhlIDx0ZW1wbGF0ZT4ncyBob3N0IHByb3BlcnR5XG4gICAgLy8gICAgZm9yd2FyZGluZy4gSW4gdGhhdCBzY2VuYXJpbyBjcmVhdGluZyBhbiBpbnN0YW5jZSB3b3VsZCByZXN1bHQgaW5cbiAgICAvLyAgICB0aGUgaG9zdCBwcm9wcyBiZWluZyBzZXQgb25jZSwgYW5kIHRoZW4gdGhlIGVucXVldWVkIGNoYW5nZXMgb24gdGhlXG4gICAgLy8gICAgdGVtcGxhdGUgd291bGQgc2V0IHByb3BlcnRpZXMgYSBzZWNvbmQgdGltZSwgcG90ZW50aWFsbHkgY2F1c2luZyBhblxuICAgIC8vICAgIG9iamVjdCB0byBiZSBzZXQgdG8gYW4gaW5zdGFuY2UgbW9yZSB0aGFuIG9uY2UuICBDcmVhdGluZyB0aGVcbiAgICAvLyAgICBpbnN0YW5jZSBhc3luYyBmcm9tIGZsdXNoaW5nIGRhdGEgZW5zdXJlcyB0aGlzIGRvZXNuJ3QgaGFwcGVuLiBJZlxuICAgIC8vICAgIHdlIHdhbnRlZCBhIHN5bmMgb3B0aW9uIGluIHRoZSBmdXR1cmUsIHNpbXBseSBoYXZpbmcgPGRvbS1pZj4gZmx1c2hcbiAgICAvLyAgICAob3IgY2xlYXIpIGl0cyB0ZW1wbGF0ZSdzIHBlbmRpbmcgaG9zdCBwcm9wZXJ0aWVzIGJlZm9yZSBjcmVhdGluZ1xuICAgIC8vICAgIHRoZSBpbnN0YW5jZSB3b3VsZCBhbHNvIGF2b2lkIHRoZSBwcm9ibGVtLlxuICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBEZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlclxuICAgICAgICAsIG1pY3JvVGFza1xuICAgICAgICAsICgpID0+IHRoaXMuX19yZW5kZXIoKSk7XG4gICAgZW5xdWV1ZURlYm91bmNlcih0aGlzLl9fcmVuZGVyRGVib3VuY2VyKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudE5vZGUgfHxcbiAgICAgICAgKHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZSA9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiZcbiAgICAgICAgICF0aGlzLnBhcmVudE5vZGUuaG9zdCkpIHtcbiAgICAgIHRoaXMuX190ZWFyZG93bkluc3RhbmNlKCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBpZiAodGhpcy5pZikge1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIE5vcm1hbGx5IHJlbmRlcmluZyBpc1xuICAgKiBhc3luY2hyb25vdXMgdG8gYSBwcm92b2tpbmcgY2hhbmdlLiBUaGlzIGlzIGRvbmUgZm9yIGVmZmljaWVuY3kgc29cbiAgICogdGhhdCBtdWx0aXBsZSBjaGFuZ2VzIHRyaWdnZXIgb25seSBhIHNpbmdsZSByZW5kZXIuIFRoZSByZW5kZXIgbWV0aG9kXG4gICAqIHNob3VsZCBiZSBjYWxsZWQgaWYsIGZvciBleGFtcGxlLCB0ZW1wbGF0ZSByZW5kZXJpbmcgaXMgcmVxdWlyZWQgdG9cbiAgICogdmFsaWRhdGUgYXBwbGljYXRpb24gc3RhdGUuXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgZmx1c2goKTtcbiAgfVxuXG4gIF9fcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICBpZiAoIXRoaXMuX19lbnN1cmVJbnN0YW5jZSgpKSB7XG4gICAgICAgIC8vIE5vIHRlbXBsYXRlIGZvdW5kIHlldFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlc3RhbXApIHtcbiAgICAgIHRoaXMuX190ZWFyZG93bkluc3RhbmNlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZXN0YW1wICYmIHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZiAhPSB0aGlzLl9sYXN0SWYpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICB9KSk7XG4gICAgICB0aGlzLl9sYXN0SWYgPSB0aGlzLmlmO1xuICAgIH1cbiAgfVxuXG4gIF9fZW5zdXJlSW5zdGFuY2UoKSB7XG4gICAgbGV0IHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgLy8gR3VhcmQgYWdhaW5zdCBlbGVtZW50IGJlaW5nIGRldGFjaGVkIHdoaWxlIHJlbmRlciB3YXMgcXVldWVkXG4gICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgIGlmICghdGhpcy5fX2N0b3IpIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgLy8gV2FpdCB1bnRpbCBjaGlsZExpc3QgY2hhbmdlcyBhbmQgdGVtcGxhdGUgc2hvdWxkIGJlIHRoZXJlIGJ5IHRoZW5cbiAgICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb20taWYgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19jdG9yID0gVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgICAgLy8gZG9tLWlmIHRlbXBsYXRpemVyIGluc3RhbmNlcyByZXF1aXJlIGBtdXRhYmxlOiB0cnVlYCwgYXNcbiAgICAgICAgICAvLyBgX19zeW5jSG9zdFByb3BlcnRpZXNgIHJlbGllcyBvbiB0aGF0IGJlaGF2aW9yIHRvIHN5bmMgb2JqZWN0c1xuICAgICAgICAgIG11dGFibGVEYXRhOiB0cnVlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIGZvcndhcmRcbiAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIHByb3BlcnR5XG4gICAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAgICovXG4gICAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW5zdGFuY2UgYnV0IGFyZSBzcXVlbGNoaW5nIGhvc3QgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBmb3J3YXJkaW5nIGR1ZSB0byBpZiBiZWluZyBmYWxzZSwgbm90ZSB0aGUgaW52YWxpZGF0ZWRcbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIHNvIGBfX3N5bmNIb3N0UHJvcGVydGllc2AgY2FuIHN5bmMgdGhlbSB0aGUgbmV4dFxuICAgICAgICAgICAgICAgIC8vIHRpbWUgYGlmYCBiZWNvbWVzIHRydWVcbiAgICAgICAgICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gdGhpcy5fX2ludmFsaWRQcm9wcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHNbcm9vdCQwKHByb3ApXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlID0gbmV3IHRoaXMuX19jdG9yKCk7XG4gICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX19pbnN0YW5jZS5yb290LCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19zeW5jSG9zdFByb3BlcnRpZXMoKTtcbiAgICAgICAgbGV0IGMkID0gdGhpcy5fX2luc3RhbmNlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoYyQgJiYgYyQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IGNhc2Ugd2hlcmUgZG9tLWlmIHdhcyByZS1hdHRhY2hlZCBpbiBuZXcgcG9zaXRpb25cbiAgICAgICAgICBsZXQgbGFzdENoaWxkID0gdGhpcy5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgaWYgKGxhc3RDaGlsZCAhPT0gYyRbYyQubGVuZ3RoLTFdKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTAsIG47IChpPGMkLmxlbmd0aCkgJiYgKG49YyRbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobiwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX19zeW5jSG9zdFByb3BlcnRpZXMoKSB7XG4gICAgbGV0IHByb3BzID0gdGhpcy5fX2ludmFsaWRQcm9wcztcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcCwgdGhpcy5fX2RhdGFIb3N0W3Byb3BdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2luc3RhbmNlLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cblxuICBfX3RlYXJkb3duSW5zdGFuY2UoKSB7XG4gICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgbGV0IGMkID0gdGhpcy5fX2luc3RhbmNlLmNoaWxkcmVuO1xuICAgICAgaWYgKGMkICYmIGMkLmxlbmd0aCkge1xuICAgICAgICAvLyB1c2UgZmlyc3QgY2hpbGQgcGFyZW50LCBmb3IgY2FzZSB3aGVuIGRvbS1pZiBtYXkgaGF2ZSBiZWVuIGRldGFjaGVkXG4gICAgICAgIGxldCBwYXJlbnQgPSBjJFswXS5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBpPTAsIG47IChpPGMkLmxlbmd0aCkgJiYgKG49YyRbaV0pOyBpKyspIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX19pbnN0YW5jZSA9IG51bGw7XG4gICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfc2hvd0hpZGVDaGlsZHJlbigpIHtcbiAgICBsZXQgaGlkZGVuID0gdGhpcy5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gfHwgIXRoaXMuaWY7XG4gICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgdGhpcy5fX2luc3RhbmNlLl9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbik7XG4gICAgfVxuICB9XG5cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKERvbUlmLmlzLCBEb21JZik7XG5cbmV4cG9ydCB7IERvbUlmIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuanNcbi8vIG1vZHVsZSBpZCA9IDY4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi8uLi9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNwbGljZXMgfSBmcm9tICcuLi91dGlscy9hcnJheS1zcGxpY2UuanMnO1xuaW1wb3J0IHsgRWxlbWVudE1peGluIH0gZnJvbSAnLi4vbWl4aW5zL2VsZW1lbnQtbWl4aW4uanMnO1xuXG4vKipcbiAqIEVsZW1lbnQgbWl4aW4gZm9yIHJlY29yZGluZyBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYVxuICogbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGEgYHNlbGVjdGVkYCBhcnJheSBzdWNoIHRoYXQgcGF0aCBjaGFuZ2VzIHRvIHRoZVxuICogbWFzdGVyIGFycmF5IChhdCB0aGUgaG9zdCkgZWxlbWVudCBvciBlbHNld2hlcmUgdmlhIGRhdGEtYmluZGluZykgYXJlXG4gKiBjb3JyZWN0bHkgcHJvcGFnYXRlZCB0byBpdGVtcyBpbiB0aGUgc2VsZWN0ZWQgYXJyYXkgYW5kIHZpY2UtdmVyc2EuXG4gKlxuICogVGhlIGBpdGVtc2AgcHJvcGVydHkgYWNjZXB0cyBhbiBhcnJheSBvZiB1c2VyIGRhdGEsIGFuZCB2aWEgdGhlXG4gKiBgc2VsZWN0KGl0ZW0pYCBhbmQgYGRlc2VsZWN0KGl0ZW0pYCBBUEksIHVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcHJvcGVydHlcbiAqIHdoaWNoIG1heSBiZSBib3VuZCB0byBvdGhlciBwYXJ0cyBvZiB0aGUgYXBwbGljYXRpb24sIGFuZCBhbnkgY2hhbmdlcyB0b1xuICogc3ViLWZpZWxkcyBvZiBgc2VsZWN0ZWRgIGl0ZW0ocykgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCBpdGVtcyBpbiB0aGVcbiAqIGBpdGVtc2AgYXJyYXkuICBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIGBzZWxlY3RlZGAgaXMgYSBwcm9wZXJ0eVxuICogcmVwcmVzZW50aW5nIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW0uICBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgYHNlbGVjdGVkYFxuICogaXMgYW4gYXJyYXkgb2YgbXVsdGlwbHkgc2VsZWN0ZWQgaXRlbXMuXG4gKlxuICogQHBvbHltZXJcbiAqIEBtaXhpbkZ1bmN0aW9uXG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuRWxlbWVudE1peGluXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgRWxlbWVudCBtaXhpbiBmb3IgcmVjb3JkaW5nIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhXG4gKiBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYSBgc2VsZWN0ZWRgIGFycmF5XG4gKi9cbmxldCBBcnJheVNlbGVjdG9yTWl4aW4gPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge3N1cGVyQ2xhc3N9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICovXG4gIGxldCBlbGVtZW50QmFzZSA9IEVsZW1lbnRNaXhpbihzdXBlckNsYXNzKTtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfQXJyYXlTZWxlY3Rvck1peGlufVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBBcnJheVNlbGVjdG9yTWl4aW4gZXh0ZW5kcyBlbGVtZW50QmFzZSB7XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAgIHJldHVybiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaXRlbXMgZnJvbSB3aGljaCBzZWxlY3Rpb24gd2lsbCBiZSBtYWRlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgdHJ1ZWAsIG11bHRpcGxlIGl0ZW1zIG1heSBiZSBzZWxlY3RlZCBhdCBvbmNlIChpbiB0aGlzIGNhc2UsXG4gICAgICAgICAqIGBzZWxlY3RlZGAgaXMgYW4gYXJyYXkgb2YgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zKS4gIFdoZW4gYGZhbHNlYCxcbiAgICAgICAgICogb25seSBvbmUgaXRlbSBtYXkgYmUgc2VsZWN0ZWQgYXQgYSB0aW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGk6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIHRydWUsIHRoaXMgaXMgYW4gYXJyYXkgdGhhdCBjb250YWlucyBhbnkgc2VsZWN0ZWQuXG4gICAgICAgICAqIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgdGhpcyBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIG9yIGBudWxsYFxuICAgICAgICAgKiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAdHlwZSB7PyhPYmplY3R8QXJyYXk8IU9iamVjdD4pfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWQ6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgdGhpcyBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIG9yIGBudWxsYFxuICAgICAgICAgKiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkSXRlbToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgdHJ1ZWAsIGNhbGxpbmcgYHNlbGVjdGAgb24gYW4gaXRlbSB0aGF0IGlzIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICogd2lsbCBkZXNlbGVjdCB0aGUgaXRlbS5cbiAgICAgICAgICovXG4gICAgICAgIHRvZ2dsZToge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgIHJldHVybiBbJ19fdXBkYXRlU2VsZWN0aW9uKG11bHRpLCBpdGVtcy4qKSddO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX19sYXN0SXRlbXMgPSBudWxsO1xuICAgICAgdGhpcy5fX2xhc3RNdWx0aSA9IG51bGw7XG4gICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAgPSBudWxsO1xuICAgIH1cblxuICAgIF9fdXBkYXRlU2VsZWN0aW9uKG11bHRpLCBpdGVtc0luZm8pIHtcbiAgICAgIGxldCBwYXRoID0gaXRlbXNJbmZvLnBhdGg7XG4gICAgICBpZiAocGF0aCA9PSAnaXRlbXMnKSB7XG4gICAgICAgIC8vIENhc2UgMSAtIGl0ZW1zIGFycmF5IGNoYW5nZWQsIHNvIGRpZmYgYWdhaW5zdCBwcmV2aW91cyBhcnJheSBhbmRcbiAgICAgICAgLy8gZGVzZWxlY3QgYW55IHJlbW92ZWQgaXRlbXMgYW5kIGFkanVzdCBzZWxlY3RlZCBpbmRpY2VzXG4gICAgICAgIGxldCBuZXdJdGVtcyA9IGl0ZW1zSW5mby5iYXNlIHx8IFtdO1xuICAgICAgICBsZXQgbGFzdEl0ZW1zID0gdGhpcy5fX2xhc3RJdGVtcztcbiAgICAgICAgbGV0IGxhc3RNdWx0aSA9IHRoaXMuX19sYXN0TXVsdGk7XG4gICAgICAgIGlmIChtdWx0aSAhPT0gbGFzdE11bHRpKSB7XG4gICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0SXRlbXMpIHtcbiAgICAgICAgICBsZXQgc3BsaWNlcyA9IGNhbGN1bGF0ZVNwbGljZXMobmV3SXRlbXMsIGxhc3RJdGVtcyk7XG4gICAgICAgICAgdGhpcy5fX2FwcGx5U3BsaWNlcyhzcGxpY2VzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fbGFzdEl0ZW1zID0gbmV3SXRlbXM7XG4gICAgICAgIHRoaXMuX19sYXN0TXVsdGkgPSBtdWx0aTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNJbmZvLnBhdGggPT0gJ2l0ZW1zLnNwbGljZXMnKSB7XG4gICAgICAgIC8vIENhc2UgMiAtIGdvdCBzcGVjaWZpYyBzcGxpY2UgaW5mb3JtYXRpb24gZGVzY3JpYmluZyB0aGUgYXJyYXkgbXV0YXRpb246XG4gICAgICAgIC8vIGRlc2VsZWN0IGFueSByZW1vdmVkIGl0ZW1zIGFuZCBhZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlc1xuICAgICAgICB0aGlzLl9fYXBwbHlTcGxpY2VzKGl0ZW1zSW5mby52YWx1ZS5pbmRleFNwbGljZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FzZSAzIC0gYW4gYXJyYXkgZWxlbWVudCB3YXMgY2hhbmdlZCwgc28gZGVzZWxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgIC8vIGl0ZW0gZm9yIHRoYXQgaW5kZXggaWYgaXQgd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWRcbiAgICAgICAgbGV0IHBhcnQgPSBwYXRoLnNsaWNlKCdpdGVtcy4nLmxlbmd0aCk7XG4gICAgICAgIGxldCBpZHggPSBwYXJzZUludChwYXJ0LCAxMCk7XG4gICAgICAgIGlmICgocGFydC5pbmRleE9mKCcuJykgPCAwKSAmJiBwYXJ0ID09IGlkeCkge1xuICAgICAgICAgIHRoaXMuX19kZXNlbGVjdENoYW5nZWRJZHgoaWR4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9fYXBwbHlTcGxpY2VzKHNwbGljZXMpIHtcbiAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuX19zZWxlY3RlZE1hcDtcbiAgICAgIC8vIEFkanVzdCBzZWxlY3RlZCBpbmRpY2VzIGFuZCBtYXJrIHJlbW92YWxzXG4gICAgICBmb3IgKGxldCBpPTA7IGk8c3BsaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcyA9IHNwbGljZXNbaV07XG4gICAgICAgIHNlbGVjdGVkLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChpZHggPCBzLmluZGV4KSB7XG4gICAgICAgICAgICAvLyBubyBjaGFuZ2VcbiAgICAgICAgICB9IGVsc2UgaWYgKGlkeCA+PSBzLmluZGV4ICsgcy5yZW1vdmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gYWRqdXN0IGluZGV4XG4gICAgICAgICAgICBzZWxlY3RlZC5zZXQoaXRlbSwgaWR4ICsgcy5hZGRlZENvdW50IC0gcy5yZW1vdmVkLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpbmRleFxuICAgICAgICAgICAgc2VsZWN0ZWQuc2V0KGl0ZW0sIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBqPTA7IGo8cy5hZGRlZENvdW50OyBqKyspIHtcbiAgICAgICAgICBsZXQgaWR4ID0gcy5pbmRleCArIGo7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkLmhhcyh0aGlzLml0ZW1zW2lkeF0pKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5zZXQodGhpcy5pdGVtc1tpZHhdLCBpZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIGxpbmtlZCBwYXRoc1xuICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgaXRlbXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgaXRlbXMgYXJyYXlcbiAgICAgIGxldCBzaWR4ID0gMDtcbiAgICAgIHNlbGVjdGVkLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZSgnc2VsZWN0ZWQnLCBzaWR4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZWN0ZWQuZGVsZXRlKGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpZHgrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX191cGRhdGVMaW5rcygpIHtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB7fTtcbiAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIGxldCBzaWR4ID0gMDtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdpdGVtcy4nICsgaWR4LCAnc2VsZWN0ZWQuJyArIHNpZHgrKyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3NlbGVjdGVkJywgJ2l0ZW1zLicgKyBpZHgpO1xuICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdzZWxlY3RlZEl0ZW0nLCAnaXRlbXMuJyArIGlkeCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc2VsZWN0aW9uIHN0YXRlLlxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAvLyBVbmJpbmQgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0ge307XG4gICAgICAvLyBUaGUgc2VsZWN0ZWQgbWFwIHN0b3JlcyAzIHBpZWNlcyBvZiBpbmZvcm1hdGlvbjpcbiAgICAgIC8vIGtleTogaXRlbXMgYXJyYXkgb2JqZWN0XG4gICAgICAvLyB2YWx1ZTogaXRlbXMgYXJyYXkgaW5kZXhcbiAgICAgIC8vIG9yZGVyOiBzZWxlY3RlZCBhcnJheSBpbmRleFxuICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwID0gbmV3IE1hcCgpO1xuICAgICAgLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb25cbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLm11bHRpID8gW10gOiBudWxsO1xuICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaXRlbSBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2VsZWN0ZWRNYXAuaGFzKGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaXRlbSBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzSW5kZXhTZWxlY3RlZChpZHgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU2VsZWN0ZWQodGhpcy5pdGVtc1tpZHhdKTtcbiAgICB9XG5cbiAgICBfX2Rlc2VsZWN0Q2hhbmdlZElkeChpZHgpIHtcbiAgICAgIGxldCBzaWR4ID0gdGhpcy5fX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgoaWR4KTtcbiAgICAgIGlmIChzaWR4ID49IDApIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKHNpZHggPT0gaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0KGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCkge1xuICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1snaXRlbXMuJyArIGlkeF07XG4gICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNlbGVjdGVkLnNsaWNlKCdzZWxlY3RlZC4nLmxlbmd0aCksIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGl0ZW0gaWYgaXQgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byBkZXNlbGVjdFxuICAgICAqL1xuICAgIGRlc2VsZWN0KGl0ZW0pIHtcbiAgICAgIGxldCBpZHggPSB0aGlzLl9fc2VsZWN0ZWRNYXAuZ2V0KGl0ZW0pO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5kZWxldGUoaXRlbSk7XG4gICAgICAgIGxldCBzaWR4O1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIHNpZHggPSB0aGlzLl9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIHRoaXMuc3BsaWNlKCdzZWxlY3RlZCcsIHNpZHgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGluZGV4IGlmIGl0IGlzIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byBkZXNlbGVjdFxuICAgICAqL1xuICAgIGRlc2VsZWN0SW5kZXgoaWR4KSB7XG4gICAgICB0aGlzLmRlc2VsZWN0KHRoaXMuaXRlbXNbaWR4XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gaXRlbS4gIFdoZW4gYHRvZ2dsZWAgaXMgdHJ1ZSwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBkZXNlbGVjdCB0aGUgaXRlbSBpZiBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gZnJvbSBgaXRlbXNgIGFycmF5IHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNlbGVjdChpdGVtKSB7XG4gICAgICB0aGlzLnNlbGVjdEluZGV4KHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gaW5kZXguICBXaGVuIGB0b2dnbGVgIGlzIHRydWUsIHRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICogZGVzZWxlY3QgdGhlIGl0ZW0gaWYgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNlbGVjdEluZGV4KGlkeCkge1xuICAgICAgbGV0IGl0ZW0gPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZChpdGVtKSkge1xuICAgICAgICBpZiAoIXRoaXMubXVsdGkpIHtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuc2V0KGl0ZW0sIGlkeCk7XG4gICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIHRoaXMucHVzaCgnc2VsZWN0ZWQnLCBpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudG9nZ2xlKSB7XG4gICAgICAgIHRoaXMuZGVzZWxlY3RJbmRleChpZHgpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEFycmF5U2VsZWN0b3JNaXhpbjtcblxufSk7XG5cbmV4cG9ydCB7IEFycmF5U2VsZWN0b3JNaXhpbiB9O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1BvbHltZXIuRWxlbWVudH1cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0FycmF5U2VsZWN0b3JNaXhpbn1cbiAqL1xubGV0IGJhc2VBcnJheVNlbGVjdG9yID0gQXJyYXlTZWxlY3Rvck1peGluKEVsZW1lbnQpO1xuXG4vKipcbiAqIEVsZW1lbnQgaW1wbGVtZW50aW5nIHRoZSBgUG9seW1lci5BcnJheVNlbGVjdG9yYCBtaXhpbiwgd2hpY2ggcmVjb3Jkc1xuICogZHluYW1pYyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBpdGVtIHBhdGhzIGluIGEgbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGFcbiAqIGBzZWxlY3RlZGAgYXJyYXkgc3VjaCB0aGF0IHBhdGggY2hhbmdlcyB0byB0aGUgbWFzdGVyIGFycmF5IChhdCB0aGUgaG9zdClcbiAqIGVsZW1lbnQgb3IgZWxzZXdoZXJlIHZpYSBkYXRhLWJpbmRpbmcpIGFyZSBjb3JyZWN0bHkgcHJvcGFnYXRlZCB0byBpdGVtc1xuICogaW4gdGhlIHNlbGVjdGVkIGFycmF5IGFuZCB2aWNlLXZlcnNhLlxuICpcbiAqIFRoZSBgaXRlbXNgIHByb3BlcnR5IGFjY2VwdHMgYW4gYXJyYXkgb2YgdXNlciBkYXRhLCBhbmQgdmlhIHRoZVxuICogYHNlbGVjdChpdGVtKWAgYW5kIGBkZXNlbGVjdChpdGVtKWAgQVBJLCB1cGRhdGVzIHRoZSBgc2VsZWN0ZWRgIHByb3BlcnR5XG4gKiB3aGljaCBtYXkgYmUgYm91bmQgdG8gb3RoZXIgcGFydHMgb2YgdGhlIGFwcGxpY2F0aW9uLCBhbmQgYW55IGNoYW5nZXMgdG9cbiAqIHN1Yi1maWVsZHMgb2YgYHNlbGVjdGVkYCBpdGVtKHMpIHdpbGwgYmUga2VwdCBpbiBzeW5jIHdpdGggaXRlbXMgaW4gdGhlXG4gKiBgaXRlbXNgIGFycmF5LiAgV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCBgc2VsZWN0ZWRgIGlzIGEgcHJvcGVydHlcbiAqIHJlcHJlc2VudGluZyB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtLiAgV2hlbiBgbXVsdGlgIGlzIHRydWUsIGBzZWxlY3RlZGBcbiAqIGlzIGFuIGFycmF5IG9mIG11bHRpcGx5IHNlbGVjdGVkIGl0ZW1zLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgaHRtbFxuICogPGRvbS1tb2R1bGUgaWQ9XCJlbXBsb3llZS1saXN0XCI+XG4gKlxuICogICA8dGVtcGxhdGU+XG4gKlxuICogICAgIDxkaXY+IEVtcGxveWVlIGxpc3Q6IDwvZGl2PlxuICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpZD1cImVtcGxveWVlTGlzdFwiIGl0ZW1zPVwie3tlbXBsb3llZXN9fVwiPlxuICogICAgICAgICA8ZGl2PkZpcnN0IG5hbWU6IDxzcGFuPnt7aXRlbS5maXJzdH19PC9zcGFuPjwvZGl2PlxuICogICAgICAgICA8ZGl2Pkxhc3QgbmFtZTogPHNwYW4+e3tpdGVtLmxhc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICAgICAgPGJ1dHRvbiBvbi1jbGljaz1cInRvZ2dsZVNlbGVjdGlvblwiPlNlbGVjdDwvYnV0dG9uPlxuICogICAgIDwvdGVtcGxhdGU+XG4gKlxuICogICAgIDxhcnJheS1zZWxlY3RvciBpZD1cInNlbGVjdG9yXCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCIgc2VsZWN0ZWQ9XCJ7e3NlbGVjdGVkfX1cIiBtdWx0aSB0b2dnbGU+PC9hcnJheS1zZWxlY3Rvcj5cbiAqXG4gKiAgICAgPGRpdj4gU2VsZWN0ZWQgZW1wbG95ZWVzOiA8L2Rpdj5cbiAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e3NlbGVjdGVkfX1cIj5cbiAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgPC90ZW1wbGF0ZT5cbiAqXG4gKiAgIDwvdGVtcGxhdGU+XG4gKlxuICogPC9kb20tbW9kdWxlPlxuICogYGBgXG4gKlxuICogYGBganNcbiAqIFBvbHltZXIoe1xuICogICBpczogJ2VtcGxveWVlLWxpc3QnLFxuICogICByZWFkeSgpIHtcbiAqICAgICB0aGlzLmVtcGxveWVlcyA9IFtcbiAqICAgICAgICAge2ZpcnN0OiAnQm9iJywgbGFzdDogJ1NtaXRoJ30sXG4gKiAgICAgICAgIHtmaXJzdDogJ1NhbGx5JywgbGFzdDogJ0pvaG5zb24nfSxcbiAqICAgICAgICAgLi4uXG4gKiAgICAgXTtcbiAqICAgfSxcbiAqICAgdG9nZ2xlU2VsZWN0aW9uKGUpIHtcbiAqICAgICBsZXQgaXRlbSA9IHRoaXMuJC5lbXBsb3llZUxpc3QuaXRlbUZvckVsZW1lbnQoZS50YXJnZXQpO1xuICogICAgIHRoaXMuJC5zZWxlY3Rvci5zZWxlY3QoaXRlbSk7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBvbHltZXJcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAZXh0ZW5kcyB7YmFzZUFycmF5U2VsZWN0b3J9XG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuQXJyYXlTZWxlY3Rvck1peGluXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBsaW5rcyBwYXRocyBiZXR3ZWVuIGFuIGlucHV0IGBpdGVtc2AgYXJyYXkgYW5kXG4gKiAgIGFuIG91dHB1dCBgc2VsZWN0ZWRgIGl0ZW0gb3IgYXJyYXkgYmFzZWQgb24gY2FsbHMgdG8gaXRzIHNlbGVjdGlvbiBBUEkuXG4gKi9cbmNsYXNzIEFycmF5U2VsZWN0b3IgZXh0ZW5kcyBiYXNlQXJyYXlTZWxlY3RvciB7XG4gIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgLy8gY2FuIGZpbmQgdGhlIHRhZyBuYW1lIGZyb20gY3VzdG9tRWxlbWVudHMuZGVmaW5lIGNhbGxcbiAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdhcnJheS1zZWxlY3Rvcic7IH1cbn1cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShBcnJheVNlbGVjdG9yLmlzLCBBcnJheVNlbGVjdG9yKTtcbmV4cG9ydCB7IEFycmF5U2VsZWN0b3IgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uLy4uLy4uLy4uL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMnO1xuaW1wb3J0IHsgY3NzRnJvbU1vZHVsZXMgfSBmcm9tICcuLi91dGlscy9zdHlsZS1nYXRoZXIuanMnO1xuXG5jb25zdCBhdHRyID0gJ2luY2x1ZGUnO1xuXG5jb25zdCBDdXN0b21TdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZTtcblxuLyoqXG4gKiBDdXN0b20gZWxlbWVudCBmb3IgZGVmaW5pbmcgc3R5bGVzIGluIHRoZSBtYWluIGRvY3VtZW50IHRoYXQgY2FuIHRha2VcbiAqIGFkdmFudGFnZSBvZiBbc2hhZHkgRE9NXShodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9zaGFkeWNzcykgc2hpbXNcbiAqIGZvciBzdHlsZSBlbmNhcHN1bGF0aW9uLCBjdXN0b20gcHJvcGVydGllcywgYW5kIGN1c3RvbSBtaXhpbnMuXG4gKlxuICogLSBEb2N1bWVudCBzdHlsZXMgZGVmaW5lZCBpbiBhIGA8Y3VzdG9tLXN0eWxlPmAgYXJlIHNoaW1tZWQgdG8gZW5zdXJlIHRoZXlcbiAqICAgZG8gbm90IGxlYWsgaW50byBsb2NhbCBET00gd2hlbiBydW5uaW5nIG9uIGJyb3dzZXJzIHdpdGhvdXQgbmF0aXZlXG4gKiAgIFNoYWRvdyBET00uXG4gKiAtIEN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBiZSBkZWZpbmVkIGluIGEgYDxjdXN0b20tc3R5bGU+YC4gVXNlIHRoZSBgaHRtbGAgc2VsZWN0b3JcbiAqICAgdG8gZGVmaW5lIGN1c3RvbSBwcm9wZXJ0aWVzIHRoYXQgYXBwbHkgdG8gYWxsIGN1c3RvbSBlbGVtZW50cy5cbiAqIC0gQ3VzdG9tIG1peGlucyBjYW4gYmUgZGVmaW5lZCBpbiBhIGA8Y3VzdG9tLXN0eWxlPmAsIGlmIHlvdSBpbXBvcnQgdGhlIG9wdGlvbmFsXG4gKiAgIFthcHBseSBzaGltXShodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9zaGFkeWNzcyNhYm91dC1hcHBseXNoaW0pXG4gKiAgIChgc2hhZHljc3MvYXBwbHktc2hpbS5odG1sYCkuXG4gKlxuICogVG8gdXNlOlxuICpcbiAqIC0gSW1wb3J0IGBjdXN0b20tc3R5bGUuaHRtbGAuXG4gKiAtIFBsYWNlIGEgYDxjdXN0b20tc3R5bGU+YCBlbGVtZW50IGluIHRoZSBtYWluIGRvY3VtZW50LCB3cmFwcGluZyBhbiBpbmxpbmUgYDxzdHlsZT5gIHRhZyB0aGF0XG4gKiAgIGNvbnRhaW5zIHRoZSBDU1MgcnVsZXMgeW91IHdhbnQgdG8gc2hpbS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIDwhLS0gaW1wb3J0IGFwcGx5IHNoaW0tLW9ubHkgcmVxdWlyZWQgaWYgdXNpbmcgbWl4aW5zIC0tPlxuICogPGxpbmsgcmVsPVwiaW1wb3J0IGhyZWY9XCJib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2FwcGx5LXNoaW0uaHRtbFwiPlxuICogPCEtLSBpbXBvcnQgY3VzdG9tLXN0eWxlIGVsZW1lbnQgLS0+XG4gKiA8bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbFwiPlxuICogLi4uXG4gKiA8Y3VzdG9tLXN0eWxlPlxuICogICA8c3R5bGU+XG4gKiAgICAgaHRtbCB7XG4gKiAgICAgICAtLWN1c3RvbS1jb2xvcjogYmx1ZTtcbiAqICAgICAgIC0tY3VzdG9tLW1peGluOiB7XG4gKiAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICogICAgICAgICBjb2xvcjogcmVkO1xuICogICAgICAgfTtcbiAqICAgICB9XG4gKiAgIDwvc3R5bGU+XG4gKiA8L2N1c3RvbS1zdHlsZT5cbiAqIGBgYFxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGZvciBkZWZpbmluZyBzdHlsZXMgaW4gdGhlIG1haW4gZG9jdW1lbnQgdGhhdCBjYW5cbiAqICAgdGFrZSBhZHZhbnRhZ2Ugb2YgUG9seW1lcidzIHN0eWxlIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0aWVzIHNoaW1zLlxuICovXG5jbGFzcyBDdXN0b21TdHlsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgQ3VzdG9tU3R5bGVJbnRlcmZhY2UuYWRkQ3VzdG9tU3R5bGUodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpZ2h0LURPTSBgPHN0eWxlPmAgY2hpbGQgdGhpcyBlbGVtZW50IHdyYXBzLiAgVXBvbiBmaXJzdFxuICAgKiBjYWxsIGFueSBzdHlsZSBtb2R1bGVzIHJlZmVyZW5jZWQgdmlhIHRoZSBgaW5jbHVkZWAgYXR0cmlidXRlIHdpbGwgYmVcbiAgICogY29uY2F0ZW5hdGVkIHRvIHRoaXMgZWxlbWVudCdzIGA8c3R5bGU+YC5cbiAgICpcbiAgICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH0gVGhpcyBlbGVtZW50J3MgbGlnaHQtRE9NIGA8c3R5bGU+YFxuICAgKi9cbiAgZ2V0U3R5bGUoKSB7XG4gICAgaWYgKHRoaXMuX3N0eWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqLyh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpO1xuICAgIGlmICghc3R5bGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgIGNvbnN0IGluY2x1ZGUgPSBzdHlsZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzRnJvbU1vZHVsZXMoaW5jbHVkZSkgKyBzdHlsZS50ZXh0Q29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG59XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2N1c3RvbS1zdHlsZScsIEN1c3RvbVN0eWxlKTtcbmV4cG9ydCB7IEN1c3RvbVN0eWxlIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEN1c3RvbVN0eWxlSW50ZXJmYWNlIGZyb20gJy4uL3NyYy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzJztcbmltcG9ydCB7Z2V0Q29tcHV0ZWRTdHlsZVZhbHVlLCB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzfSBmcm9tICcuLi9zcmMvY29tbW9uLXV0aWxzLmpzJztcbmltcG9ydCB7bmF0aXZlQ3NzVmFyaWFibGVzLCBuYXRpdmVTaGFkb3d9IGZyb20gJy4uL3NyYy9zdHlsZS1zZXR0aW5ncy5qcyc7XG5cbmNvbnN0IGN1c3RvbVN0eWxlSW50ZXJmYWNlID0gbmV3IEN1c3RvbVN0eWxlSW50ZXJmYWNlKCk7XG5cbmlmICghd2luZG93LlNoYWR5Q1NTKSB7XG4gIHdpbmRvdy5TaGFkeUNTUyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbGVtZW50RXh0ZW5kc1xuICAgICAqL1xuICAgIHByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUsIGVsZW1lbnRFeHRlbmRzKSB7fSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc3R5bGVTdWJ0cmVlKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICAgIGN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb2Nlc3NTdHlsZXMoKTtcbiAgICAgIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIHN0eWxlRWxlbWVudChlbGVtZW50KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb2Nlc3NTdHlsZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc3R5bGVEb2N1bWVudChwcm9wZXJ0aWVzKSB7XG4gICAgICBjdXN0b21TdHlsZUludGVyZmFjZS5wcm9jZXNzU3R5bGVzKCk7XG4gICAgICB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzKGRvY3VtZW50LmJvZHksIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgICB9LFxuICAgIG5hdGl2ZUNzczogbmF0aXZlQ3NzVmFyaWFibGVzLFxuICAgIG5hdGl2ZVNoYWRvdzogbmF0aXZlU2hhZG93XG4gIH1cbn1cblxud2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlID0gY3VzdG9tU3R5bGVJbnRlcmZhY2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcblxubGV0IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcbihcbiAgLyoqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9ICovXG4gIChmdW5jdGlvbigpIHtcbiAgbXV0YWJsZVByb3BlcnR5Q2hhbmdlID0gTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZTtcbn0pKSgpO1xuXG5leHBvcnQgY29uc3QgTXV0YWJsZURhdGFCZWhhdmlvciA9IHtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGBcbiAgICogY2FjaGUgKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0cnVlKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IE9wdGlvbmFsTXV0YWJsZURhdGFCZWhhdmlvciA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogSW5zdGFuY2UtbGV2ZWwgZmxhZyBmb3IgY29uZmlndXJpbmcgdGhlIGRpcnR5LWNoZWNraW5nIHN0cmF0ZWd5XG4gICAgICogZm9yIHRoaXMgZWxlbWVudC4gIFdoZW4gdHJ1ZSwgT2JqZWN0cyBhbmQgQXJyYXlzIHdpbGwgc2tpcCBkaXJ0eVxuICAgICAqIGNoZWNraW5nLCBvdGhlcndpc2Ugc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBtdXRhYmxlRGF0YTogQm9vbGVhblxuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBza2lwIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZ1xuICAgKiBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgKlxuICAgKiBQdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGAgY2FjaGVcbiAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgKiBAdGhpcyB7dGhpc31cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdGhpcy5tdXRhYmxlRGF0YSk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvbXV0YWJsZS1kYXRhLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBOZW9uQW5pbWF0aW9uUnVubmVyQmVoYXZpb3IgfSBmcm9tICcuLi9uZW9uLWFuaW1hdGlvbi9uZW9uLWFuaW1hdGlvbi1ydW5uZXItYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUGFwZXJEaWFsb2dCZWhhdmlvciB9IGZyb20gJy4uL3BhcGVyLWRpYWxvZy1iZWhhdmlvci9wYXBlci1kaWFsb2ctYmVoYXZpb3IuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1kaWFsb2ctYmVoYXZpb3IvcGFwZXItZGlhbG9nLXNoYXJlZC1zdHlsZXMuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcblxuUG9seW1lcih7XG4gIF90ZW1wbGF0ZTogYFxuICAgIDxzdHlsZSBpbmNsdWRlPVwicGFwZXItZGlhbG9nLXNoYXJlZC1zdHlsZXNcIj48L3N0eWxlPlxuICAgIDxzbG90Pjwvc2xvdD5cbmAsXG5cbiAgaXM6ICdwYXBlci1kaWFsb2cnLFxuXG4gIGJlaGF2aW9yczogW1xuICAgIFBhcGVyRGlhbG9nQmVoYXZpb3IsXG4gICAgTmVvbkFuaW1hdGlvblJ1bm5lckJlaGF2aW9yXG4gIF0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgJ25lb24tYW5pbWF0aW9uLWZpbmlzaCc6ICdfb25OZW9uQW5pbWF0aW9uRmluaXNoJ1xuICB9LFxuXG4gIF9yZW5kZXJPcGVuZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5wbGF5QW5pbWF0aW9uKCdlbnRyeScpO1xuICB9LFxuXG4gIF9yZW5kZXJDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XG4gICAgdGhpcy5wbGF5QW5pbWF0aW9uKCdleGl0Jyk7XG4gIH0sXG5cbiAgX29uTmVvbkFuaW1hdGlvbkZpbmlzaDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICB0aGlzLl9maW5pc2hSZW5kZXJPcGVuZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZmluaXNoUmVuZGVyQ2xvc2VkKCk7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWRpYWxvZy9wYXBlci1kaWFsb2cuanNcbi8vIG1vZHVsZSBpZCA9IDczXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IE5lb25BbmltYXRhYmxlQmVoYXZpb3IgfSBmcm9tICcuL25lb24tYW5pbWF0YWJsZS1iZWhhdmlvci5qcyc7XG5cbmV4cG9ydCBjb25zdCBOZW9uQW5pbWF0aW9uUnVubmVyQmVoYXZpb3JJbXBsID0ge1xuXG4gIF9jb25maWd1cmVBbmltYXRpb25zOiBmdW5jdGlvbihjb25maWdzKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBpZiAoY29uZmlncy5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBjb25maWcsIGluZGV4ID0gMDsgY29uZmlnID0gY29uZmlnc1tpbmRleF07IGluZGV4KyspIHtcbiAgICAgICAgdmFyIG5lb25BbmltYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGNvbmZpZy5uYW1lKTtcbiAgICAgICAgLy8gaXMgdGhpcyBlbGVtZW50IGFjdHVhbGx5IGEgbmVvbiBhbmltYXRpb24/XG4gICAgICAgIGlmIChuZW9uQW5pbWF0aW9uLmlzTmVvbkFuaW1hdGlvbikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICAgIC8vIGNvbmZpZ3VyYXRpb24gb3IgcGxheSBjb3VsZCBmYWlsIGlmIHBvbHlmaWxscyBhcmVuJ3QgbG9hZGVkXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG5lb25BbmltYXRpb24uY29uZmlndXJlKGNvbmZpZyk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGFuIEVmZmVjdCByYXRoZXIgdGhhbiBhbiBBbmltYXRpb25cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzdWx0LmNhbmNlbCAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IGRvY3VtZW50LnRpbWVsaW5lLnBsYXkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBudWxsO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZG50IHBsYXknLCAnKCcsIGNvbmZpZy5uYW1lLCAnKS4nLCBlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgbmVvbkFuaW1hdGlvbjogbmVvbkFuaW1hdGlvbixcbiAgICAgICAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgICAgICAgIGFuaW1hdGlvbjogcmVzdWx0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2Fybih0aGlzLmlzICsgJzonLCBjb25maWcubmFtZSwgJ25vdCBmb3VuZCEnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfSxcblxuICBfc2hvdWxkQ29tcGxldGU6IGZ1bmN0aW9uKGFjdGl2ZUVudHJpZXMpIHtcbiAgICB2YXIgZmluaXNoZWQgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aXZlRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFjdGl2ZUVudHJpZXNbaV0uYW5pbWF0aW9uLnBsYXlTdGF0ZSAhPSAnZmluaXNoZWQnKSB7XG4gICAgICAgIGZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluaXNoZWQ7XG4gIH0sXG5cbiAgX2NvbXBsZXRlOiBmdW5jdGlvbihhY3RpdmVFbnRyaWVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmVFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmVFbnRyaWVzW2ldLm5lb25BbmltYXRpb24uY29tcGxldGUoYWN0aXZlRW50cmllc1tpXS5jb25maWcpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGl2ZUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2ZUVudHJpZXNbaV0uYW5pbWF0aW9uLmNhbmNlbCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGxheXMgYW4gYW5pbWF0aW9uIHdpdGggYW4gb3B0aW9uYWwgYHR5cGVgLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHR5cGVcbiAgICogQHBhcmFtIHshT2JqZWN0PX0gY29va2llXG4gICAqL1xuICBwbGF5QW5pbWF0aW9uOiBmdW5jdGlvbih0eXBlLCBjb29raWUpIHtcbiAgICB2YXIgY29uZmlncyA9IHRoaXMuZ2V0QW5pbWF0aW9uQ29uZmlnKHR5cGUpO1xuICAgIGlmICghY29uZmlncykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl9hY3RpdmUgfHwge307XG4gICAgaWYgKHRoaXMuX2FjdGl2ZVt0eXBlXSkge1xuICAgICAgdGhpcy5fY29tcGxldGUodGhpcy5fYWN0aXZlW3R5cGVdKTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9hY3RpdmVbdHlwZV07XG4gICAgfVxuXG4gICAgdmFyIGFjdGl2ZUVudHJpZXMgPSB0aGlzLl9jb25maWd1cmVBbmltYXRpb25zKGNvbmZpZ3MpO1xuXG4gICAgaWYgKGFjdGl2ZUVudHJpZXMubGVuZ3RoID09IDApIHtcbiAgICAgIHRoaXMuZmlyZSgnbmVvbi1hbmltYXRpb24tZmluaXNoJywgY29va2llLCB7YnViYmxlczogZmFsc2V9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9hY3RpdmVbdHlwZV0gPSBhY3RpdmVFbnRyaWVzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmVFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmVFbnRyaWVzW2ldLmFuaW1hdGlvbi5vbmZpbmlzaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fc2hvdWxkQ29tcGxldGUoYWN0aXZlRW50cmllcykpIHtcbiAgICAgICAgICB0aGlzLl9jb21wbGV0ZShhY3RpdmVFbnRyaWVzKTtcbiAgICAgICAgICBkZWxldGUgdGhpcy5fYWN0aXZlW3R5cGVdO1xuICAgICAgICAgIHRoaXMuZmlyZSgnbmVvbi1hbmltYXRpb24tZmluaXNoJywgY29va2llLCB7YnViYmxlczogZmFsc2V9KTtcbiAgICAgICAgfVxuICAgICAgfS5iaW5kKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgY3VycmVudGx5IHJ1bm5pbmcgYW5pbWF0aW9ucy5cbiAgICovXG4gIGNhbmNlbEFuaW1hdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLl9hbmltYXRpb25zKSB7XG4gICAgICB0aGlzLl9hbmltYXRpb25zW2tdLmNhbmNlbCgpO1xuICAgIH1cbiAgICB0aGlzLl9hbmltYXRpb25zID0ge307XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBOZW9uQW5pbWF0aW9uUnVubmVyQmVoYXZpb3IgPSBbXG4gIE5lb25BbmltYXRhYmxlQmVoYXZpb3IsXG4gIE5lb25BbmltYXRpb25SdW5uZXJCZWhhdmlvckltcGxcbl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9uZW9uLWFuaW1hdGlvbi9uZW9uLWFuaW1hdGlvbi1ydW5uZXItYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcblxuZXhwb3J0IGNvbnN0IE5lb25BbmltYXRhYmxlQmVoYXZpb3IgPSB7XG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogQW5pbWF0aW9uIGNvbmZpZ3VyYXRpb24uIFNlZSBSRUFETUUgZm9yIG1vcmUgaW5mby5cbiAgICAgKi9cbiAgICBhbmltYXRpb25Db25maWc6IHtcbiAgICAgIHR5cGU6IE9iamVjdFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBwcm9wZXJ0eSBmb3Igc2V0dGluZyBhbiAnZW50cnknIGFuaW1hdGlvbi4gRG8gbm90IHNldCBgYW5pbWF0aW9uQ29uZmlnLmVudHJ5YFxuICAgICAqIG1hbnVhbGx5IGlmIHVzaW5nIHRoaXMuIFRoZSBhbmltYXRlZCBub2RlIGlzIHNldCB0byBgdGhpc2AgaWYgdXNpbmcgdGhpcyBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBlbnRyeUFuaW1hdGlvbjoge1xuICAgICAgb2JzZXJ2ZXI6ICdfZW50cnlBbmltYXRpb25DaGFuZ2VkJyxcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBwcm9wZXJ0eSBmb3Igc2V0dGluZyBhbiAnZXhpdCcgYW5pbWF0aW9uLiBEbyBub3Qgc2V0IGBhbmltYXRpb25Db25maWcuZXhpdGBcbiAgICAgKiBtYW51YWxseSBpZiB1c2luZyB0aGlzLiBUaGUgYW5pbWF0ZWQgbm9kZSBpcyBzZXQgdG8gYHRoaXNgIGlmIHVzaW5nIHRoaXMgcHJvcGVydHkuXG4gICAgICovXG4gICAgZXhpdEFuaW1hdGlvbjoge1xuICAgICAgb2JzZXJ2ZXI6ICdfZXhpdEFuaW1hdGlvbkNoYW5nZWQnLFxuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfVxuXG4gIH0sXG5cbiAgX2VudHJ5QW5pbWF0aW9uQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hbmltYXRpb25Db25maWcgPSB0aGlzLmFuaW1hdGlvbkNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLmFuaW1hdGlvbkNvbmZpZ1snZW50cnknXSA9IFt7XG4gICAgICBuYW1lOiB0aGlzLmVudHJ5QW5pbWF0aW9uLFxuICAgICAgbm9kZTogdGhpc1xuICAgIH1dO1xuICB9LFxuXG4gIF9leGl0QW5pbWF0aW9uQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hbmltYXRpb25Db25maWcgPSB0aGlzLmFuaW1hdGlvbkNvbmZpZyB8fCB7fTtcbiAgICB0aGlzLmFuaW1hdGlvbkNvbmZpZ1snZXhpdCddID0gW3tcbiAgICAgIG5hbWU6IHRoaXMuZXhpdEFuaW1hdGlvbixcbiAgICAgIG5vZGU6IHRoaXNcbiAgICB9XTtcbiAgfSxcblxuICBfY29weVByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgICAvLyBzaGFsbG93bHkgY29weSBwcm9wZXJ0aWVzIGZyb20gY29uZmlnMiB0byBjb25maWcxXG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gY29uZmlnMikge1xuICAgICAgY29uZmlnMVtwcm9wZXJ0eV0gPSBjb25maWcyW3Byb3BlcnR5XTtcbiAgICB9XG4gIH0sXG5cbiAgX2Nsb25lQ29uZmlnOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICB2YXIgY2xvbmUgPSB7XG4gICAgICBpc0Nsb25lOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLl9jb3B5UHJvcGVydGllcyhjbG9uZSwgY29uZmlnKTtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH0sXG5cbiAgX2dldEFuaW1hdGlvbkNvbmZpZ1JlY3Vyc2l2ZTogZnVuY3Rpb24odHlwZSwgbWFwLCBhbGxDb25maWdzKSB7XG4gICAgaWYgKCF0aGlzLmFuaW1hdGlvbkNvbmZpZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKHRoaXMuYW5pbWF0aW9uQ29uZmlnLnZhbHVlICYmIHR5cGVvZiB0aGlzLmFuaW1hdGlvbkNvbmZpZy52YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5fd2Fybih0aGlzLl9sb2dmKCdwbGF5QW5pbWF0aW9uJywgXCJQbGVhc2UgcHV0ICdhbmltYXRpb25Db25maWcnIGluc2lkZSBvZiB5b3VyIGNvbXBvbmVudHMgJ3Byb3BlcnRpZXMnIG9iamVjdCBpbnN0ZWFkIG9mIG91dHNpZGUgb2YgaXQuXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB0eXBlIGlzIG9wdGlvbmFsXG4gICAgdmFyIHRoaXNDb25maWc7XG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHRoaXNDb25maWcgPSB0aGlzLmFuaW1hdGlvbkNvbmZpZ1t0eXBlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc0NvbmZpZyA9IHRoaXMuYW5pbWF0aW9uQ29uZmlnO1xuICAgIH1cblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzQ29uZmlnKSkge1xuICAgICAgdGhpc0NvbmZpZyA9IFt0aGlzQ29uZmlnXTtcbiAgICB9XG5cbiAgICAvLyBpdGVyYXRlIGFuaW1hdGlvbnMgYW5kIHJlY3Vyc2UgdG8gcHJvY2VzcyBjb25maWd1cmF0aW9ucyBmcm9tIGNoaWxkIG5vZGVzXG4gICAgaWYgKHRoaXNDb25maWcpIHtcbiAgICAgIGZvciAodmFyIGNvbmZpZywgaW5kZXggPSAwOyBjb25maWcgPSB0aGlzQ29uZmlnW2luZGV4XTsgaW5kZXgrKykge1xuICAgICAgICBpZiAoY29uZmlnLmFuaW1hdGFibGUpIHtcbiAgICAgICAgICBjb25maWcuYW5pbWF0YWJsZS5fZ2V0QW5pbWF0aW9uQ29uZmlnUmVjdXJzaXZlKGNvbmZpZy50eXBlIHx8IHR5cGUsIG1hcCwgYWxsQ29uZmlncyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy5pZCkge1xuICAgICAgICAgICAgdmFyIGNhY2hlZENvbmZpZyA9IG1hcFtjb25maWcuaWRdO1xuICAgICAgICAgICAgaWYgKGNhY2hlZENvbmZpZykge1xuICAgICAgICAgICAgICAvLyBtZXJnZSBjb25maWd1cmF0aW9ucyB3aXRoIHRoZSBzYW1lIGlkLCBtYWtpbmcgYSBjbG9uZSBsYXppbHlcbiAgICAgICAgICAgICAgaWYgKCFjYWNoZWRDb25maWcuaXNDbG9uZSkge1xuICAgICAgICAgICAgICAgIG1hcFtjb25maWcuaWRdID0gdGhpcy5fY2xvbmVDb25maWcoY2FjaGVkQ29uZmlnKTtcbiAgICAgICAgICAgICAgICBjYWNoZWRDb25maWcgPSBtYXBbY29uZmlnLmlkXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9jb3B5UHJvcGVydGllcyhjYWNoZWRDb25maWcsIGNvbmZpZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBwdXQgYW55IGNvbmZpZ3Mgd2l0aCBhbiBpZCBpbnRvIGEgbWFwXG4gICAgICAgICAgICAgIG1hcFtjb25maWcuaWRdID0gY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhbGxDb25maWdzLnB1c2goY29uZmlnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFuIGVsZW1lbnQgaW1wbGVtZW50aW5nIGBQb2x5bWVyLk5lb25BbmltYXRpb25SdW5uZXJCZWhhdmlvcmAgY2FsbHMgdGhpcyBtZXRob2QgdG8gY29uZmlndXJlXG4gICAqIGFuIGFuaW1hdGlvbiB3aXRoIGFuIG9wdGlvbmFsIHR5cGUuIEVsZW1lbnRzIGltcGxlbWVudGluZyBgUG9seW1lci5OZW9uQW5pbWF0YWJsZUJlaGF2aW9yYFxuICAgKiBzaG91bGQgZGVmaW5lIHRoZSBwcm9wZXJ0eSBgYW5pbWF0aW9uQ29uZmlnYCwgd2hpY2ggaXMgZWl0aGVyIGEgY29uZmlndXJhdGlvbiBvYmplY3RcbiAgICogb3IgYSBtYXAgb2YgYW5pbWF0aW9uIHR5cGUgdG8gYXJyYXkgb2YgY29uZmlndXJhdGlvbiBvYmplY3RzLlxuICAgKi9cbiAgZ2V0QW5pbWF0aW9uQ29uZmlnOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIG1hcCA9IHt9O1xuICAgIHZhciBhbGxDb25maWdzID0gW107XG4gICAgdGhpcy5fZ2V0QW5pbWF0aW9uQ29uZmlnUmVjdXJzaXZlKHR5cGUsIG1hcCwgYWxsQ29uZmlncyk7XG4gICAgLy8gYXBwZW5kIHRoZSBjb25maWd1cmF0aW9ucyBzYXZlZCBpbiB0aGUgbWFwIHRvIHRoZSBhcnJheVxuICAgIGZvciAodmFyIGtleSBpbiBtYXApIHtcbiAgICAgIGFsbENvbmZpZ3MucHVzaChtYXBba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiBhbGxDb25maWdzO1xuICB9XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9uZW9uLWFuaW1hdGlvbi9uZW9uLWFuaW1hdGFibGUtYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25PdmVybGF5QmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLW92ZXJsYXktYmVoYXZpb3IvaXJvbi1vdmVybGF5LWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBQYXBlckRpYWxvZ0JlaGF2aW9ySW1wbCA9IHtcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgICdyb2xlJzogJ2RpYWxvZycsXG4gICAgJ3RhYmluZGV4JzogJy0xJ1xuICB9LFxuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIElmIGBtb2RhbGAgaXMgdHJ1ZSwgdGhpcyBpbXBsaWVzIGBuby1jYW5jZWwtb24tb3V0c2lkZS1jbGlja2AsIGBuby1jYW5jZWwtb24tZXNjLWtleWAgYW5kIGB3aXRoLWJhY2tkcm9wYC5cbiAgICAgKi9cbiAgICBtb2RhbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBfX3JlYWRpZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9XG5cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX21vZGFsQ2hhbmdlZChtb2RhbCwgX19yZWFkaWVkKSdcbiAgXSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICAndGFwJzogJ19vbkRpYWxvZ0NsaWNrJ1xuICB9LFxuXG4gIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICAvLyBPbmx5IG5vdyB0aGVzZSBwcm9wZXJ0aWVzIGNhbiBiZSByZWFkLlxuICAgIHRoaXMuX19wcmV2Tm9DYW5jZWxPbk91dHNpZGVDbGljayA9IHRoaXMubm9DYW5jZWxPbk91dHNpZGVDbGljaztcbiAgICB0aGlzLl9fcHJldk5vQ2FuY2VsT25Fc2NLZXkgPSB0aGlzLm5vQ2FuY2VsT25Fc2NLZXk7XG4gICAgdGhpcy5fX3ByZXZXaXRoQmFja2Ryb3AgPSB0aGlzLndpdGhCYWNrZHJvcDtcbiAgICB0aGlzLl9fcmVhZGllZCA9IHRydWU7XG4gIH0sXG5cbiAgX21vZGFsQ2hhbmdlZDogZnVuY3Rpb24obW9kYWwsIHJlYWRpZWQpIHtcbiAgICAvLyBtb2RhbCBpbXBsaWVzIG5vQ2FuY2VsT25PdXRzaWRlQ2xpY2ssIG5vQ2FuY2VsT25Fc2NLZXkgYW5kIHdpdGhCYWNrZHJvcC5cbiAgICAvLyBXZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBlbGVtZW50IHRvIGJlIHJlYWR5IGJlZm9yZSB3ZSBjYW4gcmVhZCB0aGVcbiAgICAvLyBwcm9wZXJ0aWVzIHZhbHVlcy5cbiAgICBpZiAoIXJlYWRpZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobW9kYWwpIHtcbiAgICAgIHRoaXMuX19wcmV2Tm9DYW5jZWxPbk91dHNpZGVDbGljayA9IHRoaXMubm9DYW5jZWxPbk91dHNpZGVDbGljaztcbiAgICAgIHRoaXMuX19wcmV2Tm9DYW5jZWxPbkVzY0tleSA9IHRoaXMubm9DYW5jZWxPbkVzY0tleTtcbiAgICAgIHRoaXMuX19wcmV2V2l0aEJhY2tkcm9wID0gdGhpcy53aXRoQmFja2Ryb3A7XG4gICAgICB0aGlzLm5vQ2FuY2VsT25PdXRzaWRlQ2xpY2sgPSB0cnVlO1xuICAgICAgdGhpcy5ub0NhbmNlbE9uRXNjS2V5ID0gdHJ1ZTtcbiAgICAgIHRoaXMud2l0aEJhY2tkcm9wID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlIHZhbHVlIHdhcyBjaGFuZ2VkIHRvIGZhbHNlLCBsZXQgaXQgZmFsc2UuXG4gICAgICB0aGlzLm5vQ2FuY2VsT25PdXRzaWRlQ2xpY2sgPSB0aGlzLm5vQ2FuY2VsT25PdXRzaWRlQ2xpY2sgJiZcbiAgICAgICAgdGhpcy5fX3ByZXZOb0NhbmNlbE9uT3V0c2lkZUNsaWNrO1xuICAgICAgdGhpcy5ub0NhbmNlbE9uRXNjS2V5ID0gdGhpcy5ub0NhbmNlbE9uRXNjS2V5ICYmXG4gICAgICAgIHRoaXMuX19wcmV2Tm9DYW5jZWxPbkVzY0tleTtcbiAgICAgIHRoaXMud2l0aEJhY2tkcm9wID0gdGhpcy53aXRoQmFja2Ryb3AgJiYgdGhpcy5fX3ByZXZXaXRoQmFja2Ryb3A7XG4gICAgfVxuICB9LFxuXG4gIF91cGRhdGVDbG9zaW5nUmVhc29uQ29uZmlybWVkOiBmdW5jdGlvbihjb25maXJtZWQpIHtcbiAgICB0aGlzLmNsb3NpbmdSZWFzb24gPSB0aGlzLmNsb3NpbmdSZWFzb24gfHwge307XG4gICAgdGhpcy5jbG9zaW5nUmVhc29uLmNvbmZpcm1lZCA9IGNvbmZpcm1lZDtcbiAgfSxcblxuICAvKipcbiAgICogV2lsbCBkaXNtaXNzIHRoZSBkaWFsb2cgaWYgdXNlciBjbGlja2VkIG9uIGFuIGVsZW1lbnQgd2l0aCBkaWFsb2ctZGlzbWlzc1xuICAgKiBvciBkaWFsb2ctY29uZmlybSBhdHRyaWJ1dGUuXG4gICAqL1xuICBfb25EaWFsb2dDbGljazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBTZWFyY2ggZm9yIHRoZSBlbGVtZW50IHdpdGggZGlhbG9nLWNvbmZpcm0gb3IgZGlhbG9nLWRpc21pc3MsXG4gICAgLy8gZnJvbSB0aGUgcm9vdCB0YXJnZXQgdW50aWwgdGhpcyAoZXhjbHVkZWQpLlxuICAgIHZhciBwYXRoID0gZG9tKGV2ZW50KS5wYXRoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gcGF0aC5pbmRleE9mKHRoaXMpOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gcGF0aFtpXTtcbiAgICAgIGlmICh0YXJnZXQuaGFzQXR0cmlidXRlICYmICh0YXJnZXQuaGFzQXR0cmlidXRlKCdkaWFsb2ctZGlzbWlzcycpIHx8IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RpYWxvZy1jb25maXJtJykpKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNsb3NpbmdSZWFzb25Db25maXJtZWQodGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlhbG9nLWNvbmZpcm0nKSk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5leHBvcnQgY29uc3QgUGFwZXJEaWFsb2dCZWhhdmlvciA9IFtJcm9uT3ZlcmxheUJlaGF2aW9yLCBQYXBlckRpYWxvZ0JlaGF2aW9ySW1wbF07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1kaWFsb2ctYmVoYXZpb3IvcGFwZXItZGlhbG9nLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uRml0QmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWZpdC1iZWhhdmlvci9pcm9uLWZpdC1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBJcm9uUmVzaXphYmxlQmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBJcm9uT3ZlcmxheU1hbmFnZXIgfSBmcm9tICcuL2lyb24tb3ZlcmxheS1tYW5hZ2VyLmpzJztcbmltcG9ydCB7IElyb25Gb2N1c2FibGVzSGVscGVyIH0gZnJvbSAnLi9pcm9uLWZvY3VzYWJsZXMtaGVscGVyLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uT3ZlcmxheUJlaGF2aW9ySW1wbCA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBvdmVybGF5IGlzIGN1cnJlbnRseSBkaXNwbGF5ZWQuXG4gICAgICovXG4gICAgb3BlbmVkOiB7XG4gICAgICBvYnNlcnZlcjogJ19vcGVuZWRDaGFuZ2VkJyxcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBub3RpZnk6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgb3ZlcmxheSB3YXMgY2FuY2VsZWQgd2hlbiBpdCB3YXMgbGFzdCBjbG9zZWQuXG4gICAgICovXG4gICAgY2FuY2VsZWQ6IHtcbiAgICAgIG9ic2VydmVyOiAnX2NhbmNlbGVkQ2hhbmdlZCcsXG4gICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZGlzcGxheSBhIGJhY2tkcm9wIGJlaGluZCB0aGUgb3ZlcmxheS4gSXQgdHJhcHMgdGhlIGZvY3VzXG4gICAgICogd2l0aGluIHRoZSBsaWdodCBET00gb2YgdGhlIG92ZXJsYXkuXG4gICAgICovXG4gICAgd2l0aEJhY2tkcm9wOiB7XG4gICAgICBvYnNlcnZlcjogJ193aXRoQmFja2Ryb3BDaGFuZ2VkJyxcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZGlzYWJsZSBhdXRvLWZvY3VzaW5nIHRoZSBvdmVybGF5IG9yIGNoaWxkIG5vZGVzIHdpdGhcbiAgICAgKiB0aGUgYGF1dG9mb2N1c2AgYXR0cmlidXRlYCB3aGVuIHRoZSBvdmVybGF5IGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBub0F1dG9Gb2N1czoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIGNhbmNlbGluZyB0aGUgb3ZlcmxheSB3aXRoIHRoZSBFU0Mga2V5LlxuICAgICAqL1xuICAgIG5vQ2FuY2VsT25Fc2NLZXk6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZGlzYWJsZSBjYW5jZWxpbmcgdGhlIG92ZXJsYXkgYnkgY2xpY2tpbmcgb3V0c2lkZSBpdC5cbiAgICAgKi9cbiAgICBub0NhbmNlbE9uT3V0c2lkZUNsaWNrOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnRhaW5zIHRoZSByZWFzb24ocykgdGhpcyBvdmVybGF5IHdhcyBsYXN0IGNsb3NlZCAoc2VlIGBpcm9uLW92ZXJsYXktY2xvc2VkYCkuXG4gICAgICogYElyb25PdmVybGF5QmVoYXZpb3JgIHByb3ZpZGVzIHRoZSBgY2FuY2VsZWRgIHJlYXNvbjsgaW1wbGVtZW50ZXJzIG9mIHRoZVxuICAgICAqIGJlaGF2aW9yIGNhbiBwcm92aWRlIG90aGVyIHJlYXNvbnMgaW4gYWRkaXRpb24gdG8gYGNhbmNlbGVkYC5cbiAgICAgKi9cbiAgICBjbG9zaW5nUmVhc29uOiB7XG4gICAgICAvLyB3YXMgYSBnZXR0ZXIgYmVmb3JlLCBidXQgbmVlZHMgdG8gYmUgYSBwcm9wZXJ0eSBzbyBvdGhlclxuICAgICAgLy8gYmVoYXZpb3JzIGNhbiBvdmVycmlkZSB0aGlzLlxuICAgICAgdHlwZTogT2JqZWN0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGVuYWJsZSByZXN0b3Jpbmcgb2YgZm9jdXMgd2hlbiBvdmVybGF5IGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICByZXN0b3JlRm9jdXNPbkNsb3NlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGtlZXAgb3ZlcmxheSBhbHdheXMgb24gdG9wLlxuICAgICAqL1xuICAgIGFsd2F5c09uVG9wOiB7XG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNob3J0Y3V0IHRvIGFjY2VzcyB0byB0aGUgb3ZlcmxheSBtYW5hZ2VyLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge1BvbHltZXIuSXJvbk92ZXJsYXlNYW5hZ2VyQ2xhc3N9XG4gICAgICovXG4gICAgX21hbmFnZXI6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHZhbHVlOiBJcm9uT3ZlcmxheU1hbmFnZXJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG5vZGUgYmVpbmcgZm9jdXNlZC5cbiAgICAgKiBAdHlwZSB7P05vZGV9XG4gICAgICovXG4gICAgX2ZvY3VzZWRDaGlsZDoge1xuICAgICAgdHlwZTogT2JqZWN0XG4gICAgfVxuXG4gIH0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgJ2lyb24tcmVzaXplJzogJ19vbklyb25SZXNpemUnXG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBiYWNrZHJvcCBlbGVtZW50LlxuICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICovXG4gIGdldCBiYWNrZHJvcEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21hbmFnZXIuYmFja2Ryb3BFbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBub2RlIHRvIGdpdmUgZm9jdXMgdG8uXG4gICAqIEB0eXBlIHtOb2RlfVxuICAgKi9cbiAgZ2V0IF9mb2N1c05vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvY3VzZWRDaGlsZCB8fCBkb20odGhpcykucXVlcnlTZWxlY3RvcignW2F1dG9mb2N1c10nKSB8fCB0aGlzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcnJheSBvZiBub2RlcyB0aGF0IGNhbiByZWNlaXZlIGZvY3VzIChvdmVybGF5IGluY2x1ZGVkKSwgb3JkZXJlZCBieSBgdGFiaW5kZXhgLlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gcmV0cmlldmUgd2hpY2ggaXMgdGhlIGZpcnN0IGFuZCBsYXN0IGZvY3VzYWJsZSBub2RlcyBpbiBvcmRlclxuICAgKiB0byB3cmFwIHRoZSBmb2N1cyBmb3Igb3ZlcmxheXMgYHdpdGgtYmFja2Ryb3BgLlxuICAgKlxuICAgKiBJZiB5b3Uga25vdyB3aGF0IGlzIHlvdXIgY29udGVudCAoc3BlY2lmaWNhbGx5IHRoZSBmaXJzdCBhbmQgbGFzdCBmb2N1c2FibGUgY2hpbGRyZW4pLFxuICAgKiB5b3UgY2FuIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHJldHVybiBvbmx5IGBbZmlyc3RGb2N1c2FibGUsIGxhc3RGb2N1c2FibGVdO2BcbiAgICogQHR5cGUge0FycmF5PE5vZGU+fVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXQgX2ZvY3VzYWJsZU5vZGVzKCkge1xuICAgIHJldHVybiBJcm9uRm9jdXNhYmxlc0hlbHBlci5nZXRUYWJiYWJsZU5vZGVzKHRoaXMpO1xuICB9LFxuXG4gIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICAvLyBVc2VkIHRvIHNraXAgY2FsbHMgdG8gbm90aWZ5UmVzaXplIGFuZCByZWZpdCB3aGlsZSB0aGUgb3ZlcmxheSBpcyBhbmltYXRpbmcuXG4gICAgdGhpcy5fX2lzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgLy8gd2l0aC1iYWNrZHJvcCBuZWVkcyB0YWJpbmRleCB0byBiZSBzZXQgaW4gb3JkZXIgdG8gdHJhcCB0aGUgZm9jdXMuXG4gICAgLy8gSWYgaXQgaXMgbm90IHNldCwgSXJvbk92ZXJsYXlCZWhhdmlvciB3aWxsIHNldCBpdCwgYW5kIHJlbW92ZSBpdCBpZiB3aXRoLWJhY2tkcm9wID0gZmFsc2UuXG4gICAgdGhpcy5fX3Nob3VsZFJlbW92ZVRhYkluZGV4ID0gZmFsc2U7XG4gICAgLy8gVXNlZCBmb3Igd3JhcHBpbmcgdGhlIGZvY3VzIG9uIFRBQiAvIFNoaWZ0K1RBQi5cbiAgICB0aGlzLl9fZmlyc3RGb2N1c2FibGVOb2RlID0gdGhpcy5fX2xhc3RGb2N1c2FibGVOb2RlID0gbnVsbDtcbiAgICAvLyBVc2VkIGJ5IF9fb25OZXh0QW5pbWF0aW9uRnJhbWUgdG8gY2FuY2VsIGFueSBwcmV2aW91cyBjYWxsYmFjay5cbiAgICB0aGlzLl9fcmFmID0gbnVsbDtcbiAgICAvLyBGb2N1c2VkIG5vZGUgYmVmb3JlIG92ZXJsYXkgZ2V0cyBvcGVuZWQuIENhbiBiZSByZXN0b3JlZCBvbiBjbG9zZS5cbiAgICB0aGlzLl9fcmVzdG9yZUZvY3VzTm9kZSA9IG51bGw7XG4gICAgdGhpcy5fZW5zdXJlU2V0dXAoKTtcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gQ2FsbCBfb3BlbmVkQ2hhbmdlZCBoZXJlIHNvIHRoYXQgcG9zaXRpb24gY2FuIGJlIGNvbXB1dGVkIGNvcnJlY3RseS5cbiAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgIHRoaXMuX29wZW5lZENoYW5nZWQodGhpcy5vcGVuZWQpO1xuICAgIH1cbiAgICB0aGlzLl9vYnNlcnZlciA9IGRvbSh0aGlzKS5vYnNlcnZlTm9kZXModGhpcy5fb25Ob2Rlc0NoYW5nZSk7XG4gIH0sXG5cbiAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGRvbSh0aGlzKS51bm9ic2VydmVOb2Rlcyh0aGlzLl9vYnNlcnZlcik7XG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIGlmICh0aGlzLl9fcmFmKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fX3JhZik7XG4gICAgICB0aGlzLl9fcmFmID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fbWFuYWdlci5yZW1vdmVPdmVybGF5KHRoaXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUb2dnbGUgdGhlIG9wZW5lZCBzdGF0ZSBvZiB0aGUgb3ZlcmxheS5cbiAgICovXG4gIHRvZ2dsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2V0Q2FuY2VsZWQoZmFsc2UpO1xuICAgIHRoaXMub3BlbmVkID0gIXRoaXMub3BlbmVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBPcGVuIHRoZSBvdmVybGF5LlxuICAgKi9cbiAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2V0Q2FuY2VsZWQoZmFsc2UpO1xuICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2xvc2UgdGhlIG92ZXJsYXkuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2V0Q2FuY2VsZWQoZmFsc2UpO1xuICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbmNlbHMgdGhlIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudCBUaGUgb3JpZ2luYWwgZXZlbnRcbiAgICovXG4gIGNhbmNlbDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgY2FuY2VsRXZlbnQgPSB0aGlzLmZpcmUoJ2lyb24tb3ZlcmxheS1jYW5jZWxlZCcsIGV2ZW50LCB7Y2FuY2VsYWJsZTogdHJ1ZX0pO1xuICAgIGlmIChjYW5jZWxFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc2V0Q2FuY2VsZWQodHJ1ZSk7XG4gICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogSW52YWxpZGF0ZXMgdGhlIGNhY2hlZCB0YWJiYWJsZSBub2Rlcy4gVG8gYmUgY2FsbGVkIHdoZW4gYW55IG9mIHRoZSBmb2N1c2FibGVcbiAgICogY29udGVudCBjaGFuZ2VzIChlLmcuIGEgYnV0dG9uIGlzIGRpc2FibGVkKS5cbiAgICovXG4gIGludmFsaWRhdGVUYWJiYWJsZXM6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX19maXJzdEZvY3VzYWJsZU5vZGUgPSB0aGlzLl9fbGFzdEZvY3VzYWJsZU5vZGUgPSBudWxsO1xuICB9LFxuXG4gIF9lbnN1cmVTZXR1cDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX292ZXJsYXlTZXR1cCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9vdmVybGF5U2V0dXAgPSB0cnVlO1xuICAgIHRoaXMuc3R5bGUub3V0bGluZSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGBvcGVuZWRgIGNoYW5nZXMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG9wZW5lZFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb3BlbmVkQ2hhbmdlZDogZnVuY3Rpb24ob3BlbmVkKSB7XG4gICAgaWYgKG9wZW5lZCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XG4gICAgfVxuXG4gICAgLy8gRGVmZXIgYW55IGFuaW1hdGlvbi1yZWxhdGVkIGNvZGUgb24gYXR0YWNoZWRcbiAgICAvLyAoX29wZW5lZENoYW5nZWQgZ2V0cyBjYWxsZWQgYWdhaW4gb24gYXR0YWNoZWQpLlxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fX2lzQW5pbWF0aW5nID0gdHJ1ZTtcblxuICAgIC8vIFVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZm9yIG5vbi1ibG9ja2luZyByZW5kZXJpbmcuXG4gICAgdGhpcy5fX29uTmV4dEFuaW1hdGlvbkZyYW1lKHRoaXMuX19vcGVuZWRDaGFuZ2VkKTtcbiAgfSxcblxuICBfY2FuY2VsZWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmNsb3NpbmdSZWFzb24gPSB0aGlzLmNsb3NpbmdSZWFzb24gfHwge307XG4gICAgdGhpcy5jbG9zaW5nUmVhc29uLmNhbmNlbGVkID0gdGhpcy5jYW5jZWxlZDtcbiAgfSxcblxuICBfd2l0aEJhY2tkcm9wQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gSWYgdGFiaW5kZXggaXMgYWxyZWFkeSBzZXQsIG5vIG5lZWQgdG8gb3ZlcnJpZGUgaXQuXG4gICAgaWYgKHRoaXMud2l0aEJhY2tkcm9wICYmICF0aGlzLmhhc0F0dHJpYnV0ZSgndGFiaW5kZXgnKSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgICB0aGlzLl9fc2hvdWxkUmVtb3ZlVGFiSW5kZXggPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fX3Nob3VsZFJlbW92ZVRhYkluZGV4KSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgIHRoaXMuX19zaG91bGRSZW1vdmVUYWJJbmRleCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcGVuZWQgJiYgdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLnRyYWNrQmFja2Ryb3AoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIHRhc2tzIHdoaWNoIG11c3Qgb2NjdXIgYmVmb3JlIG9wZW5pbmc7IGUuZy4gbWFraW5nIHRoZSBlbGVtZW50IHZpc2libGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9wcmVwYXJlUmVuZGVyT3BlbmVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBTdG9yZSBmb2N1c2VkIG5vZGUuXG4gICAgdGhpcy5fX3Jlc3RvcmVGb2N1c05vZGUgPSB0aGlzLl9tYW5hZ2VyLmRlZXBBY3RpdmVFbGVtZW50O1xuXG4gICAgLy8gTmVlZGVkIHRvIGNhbGN1bGF0ZSB0aGUgc2l6ZSBvZiB0aGUgb3ZlcmxheSBzbyB0aGF0IHRyYW5zaXRpb25zIG9uIGl0cyBzaXplXG4gICAgLy8gd2lsbCBoYXZlIHRoZSBjb3JyZWN0IHN0YXJ0aW5nIHBvaW50cy5cbiAgICB0aGlzLl9wcmVwYXJlUG9zaXRpb25pbmcoKTtcbiAgICB0aGlzLnJlZml0KCk7XG4gICAgdGhpcy5fZmluaXNoUG9zaXRpb25pbmcoKTtcblxuICAgIC8vIFNhZmFyaSB3aWxsIGFwcGx5IHRoZSBmb2N1cyB0byB0aGUgYXV0b2ZvY3VzIGVsZW1lbnQgd2hlbiBkaXNwbGF5ZWRcbiAgICAvLyBmb3IgdGhlIGZpcnN0IHRpbWUsIHNvIHdlIG1ha2Ugc3VyZSB0byByZXR1cm4gdGhlIGZvY3VzIHdoZXJlIGl0IHdhcy5cbiAgICBpZiAodGhpcy5ub0F1dG9Gb2N1cyAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLl9mb2N1c05vZGUpIHtcbiAgICAgIHRoaXMuX2ZvY3VzTm9kZS5ibHVyKCk7XG4gICAgICB0aGlzLl9fcmVzdG9yZUZvY3VzTm9kZS5mb2N1cygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGFza3Mgd2hpY2ggY2F1c2UgdGhlIG92ZXJsYXkgdG8gYWN0dWFsbHkgb3BlbjsgdHlwaWNhbGx5IHBsYXkgYW4gYW5pbWF0aW9uLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyT3BlbmVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9maW5pc2hSZW5kZXJPcGVuZWQoKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFza3Mgd2hpY2ggY2F1c2UgdGhlIG92ZXJsYXkgdG8gYWN0dWFsbHkgY2xvc2U7IHR5cGljYWxseSBwbGF5IGFuIGFuaW1hdGlvbi5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlckNsb3NlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZmluaXNoUmVuZGVyQ2xvc2VkKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRhc2tzIHRvIGJlIHBlcmZvcm1lZCBhdCB0aGUgZW5kIG9mIG9wZW4gYWN0aW9uLiBXaWxsIGZpcmUgYGlyb24tb3ZlcmxheS1vcGVuZWRgLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfZmluaXNoUmVuZGVyT3BlbmVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm5vdGlmeVJlc2l6ZSgpO1xuICAgIHRoaXMuX19pc0FuaW1hdGluZyA9IGZhbHNlO1xuXG4gICAgdGhpcy5maXJlKCdpcm9uLW92ZXJsYXktb3BlbmVkJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRhc2tzIHRvIGJlIHBlcmZvcm1lZCBhdCB0aGUgZW5kIG9mIGNsb3NlIGFjdGlvbi4gV2lsbCBmaXJlIGBpcm9uLW92ZXJsYXktY2xvc2VkYC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2ZpbmlzaFJlbmRlckNsb3NlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gSGlkZSB0aGUgb3ZlcmxheS5cbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgLy8gUmVzZXQgei1pbmRleCBvbmx5IGF0IHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICB0aGlzLnN0eWxlLnpJbmRleCA9ICcnO1xuICAgIHRoaXMubm90aWZ5UmVzaXplKCk7XG4gICAgdGhpcy5fX2lzQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5maXJlKCdpcm9uLW92ZXJsYXktY2xvc2VkJywgdGhpcy5jbG9zaW5nUmVhc29uKTtcbiAgfSxcblxuICBfcHJlcGFyZVBvc2l0aW9uaW5nOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb24gPSB0aGlzLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgdGhpcy5zdHlsZS50cmFuc2Zvcm0gPSB0aGlzLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgfSxcblxuICBfZmluaXNoUG9zaXRpb25pbmc6IGZ1bmN0aW9uKCkge1xuICAgIC8vIEZpcnN0LCBtYWtlIGl0IGludmlzaWJsZSAmIHJlYWN0aXZhdGUgYW5pbWF0aW9ucy5cbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgLy8gRm9yY2UgcmVmbG93IGJlZm9yZSByZS1lbmFibGluZyBhbmltYXRpb25zIHNvIHRoYXQgdGhleSBkb24ndCBzdGFydC5cbiAgICAvLyBTZXQgc2Nyb2xsVG9wIHRvIGl0c2VsZiBzbyB0aGF0IENsb3N1cmUgQ29tcGlsZXIgZG9lc24ndCByZW1vdmUgdGhpcy5cbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVG9wO1xuICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbiA9IHRoaXMuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICcnO1xuICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gdGhpcy5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnJztcbiAgICAvLyBOb3cgdGhhdCBhbmltYXRpb25zIGFyZSBlbmFibGVkLCBtYWtlIGl0IHZpc2libGUgYWdhaW5cbiAgICB0aGlzLnN0eWxlLmRpc3BsYXkgPSAnJztcbiAgICAvLyBGb3JjZSByZWZsb3csIHNvIHRoYXQgZm9sbG93aW5nIGFuaW1hdGlvbnMgYXJlIHByb3Blcmx5IHN0YXJ0ZWQuXG4gICAgLy8gU2V0IHNjcm9sbFRvcCB0byBpdHNlbGYgc28gdGhhdCBDbG9zdXJlIENvbXBpbGVyIGRvZXNuJ3QgcmVtb3ZlIHRoaXMuXG4gICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcDtcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyBmb2N1cyBhY2NvcmRpbmcgdG8gdGhlIG9wZW5lZCBzdGF0ZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2FwcGx5Rm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgaWYgKCF0aGlzLm5vQXV0b0ZvY3VzKSB7XG4gICAgICAgIHRoaXMuX2ZvY3VzTm9kZS5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMuX2ZvY3VzTm9kZS5ibHVyKCk7XG4gICAgICB0aGlzLl9mb2N1c2VkQ2hpbGQgPSBudWxsO1xuICAgICAgLy8gUmVzdG9yZSBmb2N1cy5cbiAgICAgIGlmICh0aGlzLnJlc3RvcmVGb2N1c09uQ2xvc2UgJiYgdGhpcy5fX3Jlc3RvcmVGb2N1c05vZGUpIHtcbiAgICAgICAgdGhpcy5fX3Jlc3RvcmVGb2N1c05vZGUuZm9jdXMoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19yZXN0b3JlRm9jdXNOb2RlID0gbnVsbDtcbiAgICAgIC8vIElmIG1hbnkgb3ZlcmxheXMgZ2V0IGNsb3NlZCBhdCB0aGUgc2FtZSB0aW1lLCBvbmUgb2YgdGhlbSB3b3VsZCBzdGlsbFxuICAgICAgLy8gYmUgdGhlIGN1cnJlbnRPdmVybGF5IGV2ZW4gaWYgYWxyZWFkeSBjbG9zZWQsIGFuZCB3b3VsZCBjYWxsIF9hcHBseUZvY3VzXG4gICAgICAvLyBpbmZpbml0ZWx5LCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBub3QgdG8gYmUgdGhlIGN1cnJlbnQgb3ZlcmxheS5cbiAgICAgIHZhciBjdXJyZW50T3ZlcmxheSA9IHRoaXMuX21hbmFnZXIuY3VycmVudE92ZXJsYXkoKTtcbiAgICAgIGlmIChjdXJyZW50T3ZlcmxheSAmJiB0aGlzICE9PSBjdXJyZW50T3ZlcmxheSkge1xuICAgICAgICBjdXJyZW50T3ZlcmxheS5fYXBwbHlGb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FuY2VscyAoY2xvc2VzKSB0aGUgb3ZlcmxheS4gQ2FsbCB3aGVuIGNsaWNrIGhhcHBlbnMgb3V0c2lkZSB0aGUgb3ZlcmxheS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vbkNhcHR1cmVDbGljazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMubm9DYW5jZWxPbk91dHNpZGVDbGljaykge1xuICAgICAgdGhpcy5jYW5jZWwoZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogS2VlcHMgdHJhY2sgb2YgdGhlIGZvY3VzZWQgY2hpbGQuIElmIHdpdGhCYWNrZHJvcCwgdHJhcHMgZm9jdXMgd2l0aGluIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb25DYXB0dXJlRm9jdXM6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmICghdGhpcy53aXRoQmFja2Ryb3ApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHBhdGggPSBkb20oZXZlbnQpLnBhdGg7XG4gICAgaWYgKHBhdGguaW5kZXhPZih0aGlzKSA9PT0gLTEpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy5fYXBwbHlGb2N1cygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mb2N1c2VkQ2hpbGQgPSBwYXRoWzBdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgRVNDIGtleSBldmVudCBhbmQgY2FuY2VscyAoY2xvc2VzKSB0aGUgb3ZlcmxheS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vbkNhcHR1cmVFc2M6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm5vQ2FuY2VsT25Fc2NLZXkpIHtcbiAgICAgIHRoaXMuY2FuY2VsKGV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgVEFCIGtleSBldmVudHMgdG8gdHJhY2sgZm9jdXMgY2hhbmdlcy5cbiAgICogV2lsbCB3cmFwIGZvY3VzIGZvciBvdmVybGF5cyB3aXRoQmFja2Ryb3AuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb25DYXB0dXJlVGFiOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy53aXRoQmFja2Ryb3ApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fX2Vuc3VyZUZpcnN0TGFzdEZvY3VzYWJsZXMoKTtcbiAgICAvLyBUQUIgd3JhcHMgZnJvbSBsYXN0IHRvIGZpcnN0IGZvY3VzYWJsZS5cbiAgICAvLyBTaGlmdCArIFRBQiB3cmFwcyBmcm9tIGZpcnN0IHRvIGxhc3QgZm9jdXNhYmxlLlxuICAgIHZhciBzaGlmdCA9IGV2ZW50LnNoaWZ0S2V5O1xuICAgIHZhciBub2RlVG9DaGVjayA9IHNoaWZ0ID8gdGhpcy5fX2ZpcnN0Rm9jdXNhYmxlTm9kZSA6IHRoaXMuX19sYXN0Rm9jdXNhYmxlTm9kZTtcbiAgICB2YXIgbm9kZVRvU2V0ID0gc2hpZnQgPyB0aGlzLl9fbGFzdEZvY3VzYWJsZU5vZGUgOiB0aGlzLl9fZmlyc3RGb2N1c2FibGVOb2RlO1xuICAgIHZhciBzaG91bGRXcmFwID0gZmFsc2U7XG4gICAgaWYgKG5vZGVUb0NoZWNrID09PSBub2RlVG9TZXQpIHtcbiAgICAgIC8vIElmIG5vZGVUb0NoZWNrIGlzIHRoZSBzYW1lIGFzIG5vZGVUb1NldCwgaXQgbWVhbnMgd2UgaGF2ZSBhbiBvdmVybGF5XG4gICAgICAvLyB3aXRoIDAgb3IgMSBmb2N1c2FibGVzOyBpbiBlaXRoZXIgY2FzZSB3ZSBzdGlsbCBuZWVkIHRvIHRyYXAgdGhlXG4gICAgICAvLyBmb2N1cyB3aXRoaW4gdGhlIG92ZXJsYXkuXG4gICAgICBzaG91bGRXcmFwID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW4gZG9tPXNoYWRvdywgdGhlIG1hbmFnZXIgd2lsbCByZWNlaXZlIGZvY3VzIGNoYW5nZXMgb24gdGhlIG1haW5cbiAgICAgIC8vIHJvb3QgYnV0IG5vdCB0aGUgb25lcyB3aXRoaW4gb3RoZXIgc2hhZG93IHJvb3RzLCBzbyB3ZSBjYW4ndCByZWx5IG9uXG4gICAgICAvLyBfZm9jdXNlZENoaWxkLCBidXQgd2Ugc2hvdWxkIGNoZWNrIHRoZSBkZWVwZXN0IGFjdGl2ZSBlbGVtZW50LlxuICAgICAgdmFyIGZvY3VzZWROb2RlID0gdGhpcy5fbWFuYWdlci5kZWVwQWN0aXZlRWxlbWVudDtcbiAgICAgIC8vIElmIHRoZSBhY3RpdmUgZWxlbWVudCBpcyBub3QgdGhlIG5vZGVUb0NoZWNrIGJ1dCB0aGUgb3ZlcmxheSBpdHNlbGYsXG4gICAgICAvLyBpdCBtZWFucyB0aGUgZm9jdXMgaXMgYWJvdXQgdG8gZ28gb3V0c2lkZSB0aGUgb3ZlcmxheSwgaGVuY2Ugd2VcbiAgICAgIC8vIHNob3VsZCBwcmV2ZW50IHRoYXQgKGUuZy4gdXNlciBvcGVucyB0aGUgb3ZlcmxheSBhbmQgaGl0IFNoaWZ0K1RBQikuXG4gICAgICBzaG91bGRXcmFwID0gKGZvY3VzZWROb2RlID09PSBub2RlVG9DaGVjayB8fCBmb2N1c2VkTm9kZSA9PT0gdGhpcyk7XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFdyYXApIHtcbiAgICAgIC8vIFdoZW4gdGhlIG92ZXJsYXkgY29udGFpbnMgdGhlIGxhc3QgZm9jdXNhYmxlIGVsZW1lbnQgb2YgdGhlIGRvY3VtZW50XG4gICAgICAvLyBhbmQgaXQncyBhbHJlYWR5IGZvY3VzZWQsIHByZXNzaW5nIFRBQiB3b3VsZCBtb3ZlIHRoZSBmb2N1cyBvdXRzaWRlXG4gICAgICAvLyB0aGUgZG9jdW1lbnQgKGUuZy4gdG8gdGhlIGJyb3dzZXIgc2VhcmNoIGJhcikuIFNpbWlsYXJseSwgd2hlbiB0aGVcbiAgICAgIC8vIG92ZXJsYXkgY29udGFpbnMgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IG9mIHRoZSBkb2N1bWVudCBhbmQgaXQnc1xuICAgICAgLy8gYWxyZWFkeSBmb2N1c2VkLCBwcmVzc2luZyBTaGlmdCtUQUIgd291bGQgbW92ZSB0aGUgZm9jdXMgb3V0c2lkZSB0aGVcbiAgICAgIC8vIGRvY3VtZW50IChlLmcuIHRvIHRoZSBicm93c2VyIHNlYXJjaCBiYXIpLlxuICAgICAgLy8gSW4gYm90aCBjYXNlcywgd2Ugd291bGQgbm90IHJlY2VpdmUgYSBmb2N1cyBldmVudCwgYnV0IG9ubHkgYSBibHVyLlxuICAgICAgLy8gSW4gb3JkZXIgdG8gYWNoaWV2ZSBmb2N1cyB3cmFwcGluZywgd2UgcHJldmVudCB0aGlzIFRBQiBldmVudCBhbmRcbiAgICAgIC8vIGZvcmNlIHRoZSBmb2N1cy4gVGhpcyB3aWxsIGFsc28gcHJldmVudCB0aGUgZm9jdXMgdG8gdGVtcG9yYXJpbHkgbW92ZVxuICAgICAgLy8gb3V0c2lkZSB0aGUgb3ZlcmxheSwgd2hpY2ggbWlnaHQgY2F1c2Ugc2Nyb2xsaW5nLlxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX2ZvY3VzZWRDaGlsZCA9IG5vZGVUb1NldDtcbiAgICAgIHRoaXMuX2FwcGx5Rm9jdXMoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZml0cyBpZiB0aGUgb3ZlcmxheSBpcyBvcGVuZWQgYW5kIG5vdCBhbmltYXRpbmcuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vbklyb25SZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZCAmJiAhdGhpcy5fX2lzQW5pbWF0aW5nKSB7XG4gICAgICB0aGlzLl9fb25OZXh0QW5pbWF0aW9uRnJhbWUodGhpcy5yZWZpdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBXaWxsIGNhbGwgbm90aWZ5UmVzaXplIGlmIG92ZXJsYXkgaXMgb3BlbmVkLlxuICAgKiBDYW4gYmUgb3ZlcnJpZGRlbiBpbiBvcmRlciB0byBhdm9pZCBtdWx0aXBsZSBvYnNlcnZlcnMgb24gdGhlIHNhbWUgbm9kZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29uTm9kZXNDaGFuZ2U6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZCAmJiAhdGhpcy5fX2lzQW5pbWF0aW5nKSB7XG4gICAgICAvLyBJdCBtaWdodCBoYXZlIGFkZGVkIGZvY3VzYWJsZSBub2Rlcywgc28gaW52YWxpZGF0ZSBjYWNoZWQgdmFsdWVzLlxuICAgICAgdGhpcy5pbnZhbGlkYXRlVGFiYmFibGVzKCk7XG4gICAgICB0aGlzLm5vdGlmeVJlc2l6ZSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2lsbCBzZXQgZmlyc3QgYW5kIGxhc3QgZm9jdXNhYmxlIG5vZGVzIGlmIGFueSBvZiB0aGVtIGlzIG5vdCBzZXQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfX2Vuc3VyZUZpcnN0TGFzdEZvY3VzYWJsZXM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fX2ZpcnN0Rm9jdXNhYmxlTm9kZSB8fCAhdGhpcy5fX2xhc3RGb2N1c2FibGVOb2RlKSB7XG4gICAgICB2YXIgZm9jdXNhYmxlTm9kZXMgPSB0aGlzLl9mb2N1c2FibGVOb2RlcztcbiAgICAgIHRoaXMuX19maXJzdEZvY3VzYWJsZU5vZGUgPSBmb2N1c2FibGVOb2Rlc1swXTtcbiAgICAgIHRoaXMuX19sYXN0Rm9jdXNhYmxlTm9kZSA9IGZvY3VzYWJsZU5vZGVzW2ZvY3VzYWJsZU5vZGVzLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGFza3MgZXhlY3V0ZWQgd2hlbiBvcGVuZWQgY2hhbmdlczogcHJlcGFyZSBmb3IgdGhlIG9wZW5pbmcsIG1vdmUgdGhlXG4gICAqIGZvY3VzLCB1cGRhdGUgdGhlIG1hbmFnZXIsIHJlbmRlciBvcGVuZWQvY2xvc2VkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX19vcGVuZWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgIC8vIE1ha2Ugb3ZlcmxheSB2aXNpYmxlLCB0aGVuIGFkZCBpdCB0byB0aGUgbWFuYWdlci5cbiAgICAgIHRoaXMuX3ByZXBhcmVSZW5kZXJPcGVuZWQoKTtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWRkT3ZlcmxheSh0aGlzKTtcbiAgICAgIC8vIE1vdmUgdGhlIGZvY3VzIHRvIHRoZSBjaGlsZCBub2RlIHdpdGggW2F1dG9mb2N1c10uXG4gICAgICB0aGlzLl9hcHBseUZvY3VzKCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlck9wZW5lZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgb3ZlcmxheSwgdGhlbiByZXN0b3JlIHRoZSBmb2N1cyBiZWZvcmUgYWN0dWFsbHkgY2xvc2luZy5cbiAgICAgIHRoaXMuX21hbmFnZXIucmVtb3ZlT3ZlcmxheSh0aGlzKTtcbiAgICAgIHRoaXMuX2FwcGx5Rm9jdXMoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyQ2xvc2VkKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIGNhbGxiYWNrIG9uIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSwgb3ZlcnJpZGluZyBhbnkgcHJldmlvdXNcbiAgICogY2FsbGJhY2sgYXdhaXRpbmcgZm9yIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZS4gZS5nLlxuICAgKiBgX19vbk5leHRBbmltYXRpb25GcmFtZShjYWxsYmFjazEpICYmIF9fb25OZXh0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2syKWA7XG4gICAqIGBjYWxsYmFjazFgIHdpbGwgbmV2ZXIgYmUgaW52b2tlZC5cbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGNhbGxiYWNrIEl0cyBgdGhpc2AgcGFyYW1ldGVyIGlzIHRoZSBvdmVybGF5IGl0c2VsZi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fb25OZXh0QW5pbWF0aW9uRnJhbWU6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuX19yYWYpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9fcmFmKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuX19yYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uIG5leHRBbmltYXRpb25GcmFtZSgpIHtcbiAgICAgIHNlbGYuX19yYWYgPSBudWxsO1xuICAgICAgY2FsbGJhY2suY2FsbChzZWxmKTtcbiAgICB9KTtcbiAgfVxuXG59O1xuXG5leHBvcnQgY29uc3QgSXJvbk92ZXJsYXlCZWhhdmlvciA9IFtJcm9uRml0QmVoYXZpb3IsIElyb25SZXNpemFibGVCZWhhdmlvciwgSXJvbk92ZXJsYXlCZWhhdmlvckltcGxdO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lyb24tb3ZlcmxheS1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25GaXRCZWhhdmlvciA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCB0aGF0IHdpbGwgcmVjZWl2ZSBhIGBtYXgtaGVpZ2h0YC9gd2lkdGhgLiBCeSBkZWZhdWx0IGl0IGlzIHRoZSBzYW1lIGFzIGB0aGlzYCxcbiAgICAgKiBidXQgaXQgY2FuIGJlIHNldCB0byBhIGNoaWxkIGVsZW1lbnQuIFRoaXMgaXMgdXNlZnVsLCBmb3IgZXhhbXBsZSwgZm9yIGltcGxlbWVudGluZyBhXG4gICAgICogc2Nyb2xsaW5nIHJlZ2lvbiBpbnNpZGUgdGhlIGVsZW1lbnQuXG4gICAgICogQHR5cGUgeyFFbGVtZW50fVxuICAgICAqL1xuICAgIHNpemluZ1RhcmdldDoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdG8gZml0IGB0aGlzYCBpbnRvLlxuICAgICAqL1xuICAgIGZpdEludG86IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHZhbHVlOiB3aW5kb3dcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogV2lsbCBwb3NpdGlvbiB0aGUgZWxlbWVudCBhcm91bmQgdGhlIHBvc2l0aW9uVGFyZ2V0IHdpdGhvdXQgb3ZlcmxhcHBpbmcgaXQuXG4gICAgICovXG4gICAgbm9PdmVybGFwOiB7XG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcG9zaXRpb24gdGhlIGVsZW1lbnQuIElmIG5vdCBzZXQsIGl0IHdpbGxcbiAgICAgKiBkZWZhdWx0IHRvIHRoZSBwYXJlbnQgbm9kZS5cbiAgICAgKiBAdHlwZSB7IUVsZW1lbnR9XG4gICAgICovXG4gICAgcG9zaXRpb25UYXJnZXQ6IHtcbiAgICAgIHR5cGU6IEVsZW1lbnRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG9yaWVudGF0aW9uIGFnYWluc3Qgd2hpY2ggdG8gYWxpZ24gdGhlIGVsZW1lbnQgaG9yaXpvbnRhbGx5XG4gICAgICogcmVsYXRpdmUgdG8gdGhlIGBwb3NpdGlvblRhcmdldGAuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJsZWZ0XCIsIFwicmlnaHRcIiwgXCJhdXRvXCIuXG4gICAgICovXG4gICAgaG9yaXpvbnRhbEFsaWduOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG9yaWVudGF0aW9uIGFnYWluc3Qgd2hpY2ggdG8gYWxpZ24gdGhlIGVsZW1lbnQgdmVydGljYWxseVxuICAgICAqIHJlbGF0aXZlIHRvIHRoZSBgcG9zaXRpb25UYXJnZXRgLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwidG9wXCIsIFwiYm90dG9tXCIsIFwiYXV0b1wiLlxuICAgICAqL1xuICAgIHZlcnRpY2FsQWxpZ246IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBpdCB3aWxsIHVzZSBgaG9yaXpvbnRhbEFsaWduYCBhbmQgYHZlcnRpY2FsQWxpZ25gIHZhbHVlcyBhcyBwcmVmZXJyZWQgYWxpZ25tZW50XG4gICAgICogYW5kIGlmIHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSwgaXQgd2lsbCBwaWNrIHRoZSB2YWx1ZXMgd2hpY2ggbWluaW1pemUgdGhlIGNyb3BwaW5nLlxuICAgICAqL1xuICAgIGR5bmFtaWNBbGlnbjoge1xuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHBpeGVsIHZhbHVlIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgcG9zaXRpb24gY2FsY3VsYXRlZCBmb3IgdGhlXG4gICAgICogZ2l2ZW4gYGhvcml6b250YWxBbGlnbmAsIGluIHRoZSBkaXJlY3Rpb24gb2YgYWxpZ25tZW50LiBZb3UgY2FuIHRoaW5rXG4gICAgICogb2YgaXQgYXMgaW5jcmVhc2luZyBvciBkZWNyZWFzaW5nIHRoZSBkaXN0YW5jZSB0byB0aGUgc2lkZSBvZiB0aGVcbiAgICAgKiBzY3JlZW4gZ2l2ZW4gYnkgYGhvcml6b250YWxBbGlnbmAuXG4gICAgICpcbiAgICAgKiBJZiBgaG9yaXpvbnRhbEFsaWduYCBpcyBcImxlZnRcIiwgdGhpcyBvZmZzZXQgd2lsbCBpbmNyZWFzZSBvciBkZWNyZWFzZVxuICAgICAqIHRoZSBkaXN0YW5jZSB0byB0aGUgbGVmdCBzaWRlIG9mIHRoZSBzY3JlZW46IGEgbmVnYXRpdmUgb2Zmc2V0IHdpbGxcbiAgICAgKiBtb3ZlIHRoZSBkcm9wZG93biB0byB0aGUgbGVmdDsgYSBwb3NpdGl2ZSBvbmUsIHRvIHRoZSByaWdodC5cbiAgICAgKlxuICAgICAqIENvbnZlcnNlbHkgaWYgYGhvcml6b250YWxBbGlnbmAgaXMgXCJyaWdodFwiLCB0aGlzIG9mZnNldCB3aWxsIGluY3JlYXNlXG4gICAgICogb3IgZGVjcmVhc2UgdGhlIGRpc3RhbmNlIHRvIHRoZSByaWdodCBzaWRlIG9mIHRoZSBzY3JlZW46IGEgbmVnYXRpdmVcbiAgICAgKiBvZmZzZXQgd2lsbCBtb3ZlIHRoZSBkcm9wZG93biB0byB0aGUgcmlnaHQ7IGEgcG9zaXRpdmUgb25lLCB0byB0aGUgbGVmdC5cbiAgICAgKi9cbiAgICBob3Jpem9udGFsT2Zmc2V0OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIG5vdGlmeTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHBpeGVsIHZhbHVlIHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgcG9zaXRpb24gY2FsY3VsYXRlZCBmb3IgdGhlXG4gICAgICogZ2l2ZW4gYHZlcnRpY2FsQWxpZ25gLCBpbiB0aGUgZGlyZWN0aW9uIG9mIGFsaWdubWVudC4gWW91IGNhbiB0aGlua1xuICAgICAqIG9mIGl0IGFzIGluY3JlYXNpbmcgb3IgZGVjcmVhc2luZyB0aGUgZGlzdGFuY2UgdG8gdGhlIHNpZGUgb2YgdGhlXG4gICAgICogc2NyZWVuIGdpdmVuIGJ5IGB2ZXJ0aWNhbEFsaWduYC5cbiAgICAgKlxuICAgICAqIElmIGB2ZXJ0aWNhbEFsaWduYCBpcyBcInRvcFwiLCB0aGlzIG9mZnNldCB3aWxsIGluY3JlYXNlIG9yIGRlY3JlYXNlXG4gICAgICogdGhlIGRpc3RhbmNlIHRvIHRoZSB0b3Agc2lkZSBvZiB0aGUgc2NyZWVuOiBhIG5lZ2F0aXZlIG9mZnNldCB3aWxsXG4gICAgICogbW92ZSB0aGUgZHJvcGRvd24gdXB3YXJkczsgYSBwb3NpdGl2ZSBvbmUsIGRvd253YXJkcy5cbiAgICAgKlxuICAgICAqIENvbnZlcnNlbHkgaWYgYHZlcnRpY2FsQWxpZ25gIGlzIFwiYm90dG9tXCIsIHRoaXMgb2Zmc2V0IHdpbGwgaW5jcmVhc2VcbiAgICAgKiBvciBkZWNyZWFzZSB0aGUgZGlzdGFuY2UgdG8gdGhlIGJvdHRvbSBzaWRlIG9mIHRoZSBzY3JlZW46IGEgbmVnYXRpdmVcbiAgICAgKiBvZmZzZXQgd2lsbCBtb3ZlIHRoZSBkcm9wZG93biBkb3dud2FyZHM7IGEgcG9zaXRpdmUgb25lLCB1cHdhcmRzLlxuICAgICAqL1xuICAgIHZlcnRpY2FsT2Zmc2V0OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB2YWx1ZTogMCxcbiAgICAgIG5vdGlmeTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBhdXRvLWZpdCBvbiBhdHRhY2guXG4gICAgICovXG4gICAgYXV0b0ZpdE9uQXR0YWNoOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKiBAdHlwZSB7P09iamVjdH0gKi9cbiAgICBfZml0SW5mbzoge1xuICAgICAgdHlwZTogT2JqZWN0XG4gICAgfVxuICB9LFxuXG4gIGdldCBfZml0V2lkdGgoKSB7XG4gICAgdmFyIGZpdFdpZHRoO1xuICAgIGlmICh0aGlzLmZpdEludG8gPT09IHdpbmRvdykge1xuICAgICAgZml0V2lkdGggPSB0aGlzLmZpdEludG8uaW5uZXJXaWR0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgZml0V2lkdGggPSB0aGlzLmZpdEludG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGg7XG4gICAgfVxuICAgIHJldHVybiBmaXRXaWR0aDtcbiAgfSxcblxuICBnZXQgX2ZpdEhlaWdodCgpIHtcbiAgICB2YXIgZml0SGVpZ2h0O1xuICAgIGlmICh0aGlzLmZpdEludG8gPT09IHdpbmRvdykge1xuICAgICAgZml0SGVpZ2h0ID0gdGhpcy5maXRJbnRvLmlubmVySGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXRIZWlnaHQgPSB0aGlzLmZpdEludG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgIH1cbiAgICByZXR1cm4gZml0SGVpZ2h0O1xuICB9LFxuXG4gIGdldCBfZml0TGVmdCgpIHtcbiAgICB2YXIgZml0TGVmdDtcbiAgICBpZiAodGhpcy5maXRJbnRvID09PSB3aW5kb3cpIHtcbiAgICAgIGZpdExlZnQgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXRMZWZ0ID0gdGhpcy5maXRJbnRvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgfVxuICAgIHJldHVybiBmaXRMZWZ0O1xuICB9LFxuXG4gIGdldCBfZml0VG9wKCkge1xuICAgIHZhciBmaXRUb3A7XG4gICAgaWYgKHRoaXMuZml0SW50byA9PT0gd2luZG93KSB7XG4gICAgICBmaXRUb3AgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXRUb3AgPSB0aGlzLmZpdEludG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xuICAgIH1cbiAgICByZXR1cm4gZml0VG9wO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHBvc2l0aW9uIHRoZSBlbGVtZW50LFxuICAgKiBpZiBubyBwb3NpdGlvbiB0YXJnZXQgaXMgY29uZmlndXJlZC5cbiAgICovXG4gIGdldCBfZGVmYXVsdFBvc2l0aW9uVGFyZ2V0KCkge1xuICAgIHZhciBwYXJlbnQgPSBkb20odGhpcykucGFyZW50Tm9kZTtcblxuICAgIGlmIChwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5ob3N0O1xuICAgIH1cblxuICAgIHJldHVybiBwYXJlbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBob3Jpem9udGFsIGFsaWduIHZhbHVlLCBhY2NvdW50aW5nIGZvciB0aGUgUlRML0xUUiB0ZXh0IGRpcmVjdGlvbi5cbiAgICovXG4gIGdldCBfbG9jYWxlSG9yaXpvbnRhbEFsaWduKCkge1xuICAgIGlmICh0aGlzLl9pc1JUTCkge1xuICAgICAgLy8gSW4gUlRMLCBcImxlZnRcIiBiZWNvbWVzIFwicmlnaHRcIi5cbiAgICAgIGlmICh0aGlzLmhvcml6b250YWxBbGlnbiA9PT0gJ3JpZ2h0Jykge1xuICAgICAgICByZXR1cm4gJ2xlZnQnO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbEFsaWduID09PSAnbGVmdCcpIHtcbiAgICAgICAgcmV0dXJuICdyaWdodCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmhvcml6b250YWxBbGlnbjtcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gTWVtb2l6ZSB0aGlzIHRvIGF2b2lkIGV4cGVuc2l2ZSBjYWxjdWxhdGlvbnMgJiByZWxheW91dHMuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGRvIGl0IG9ubHkgb25jZVxuICAgIGlmICh0eXBlb2YgdGhpcy5faXNSVEwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB0aGlzLl9pc1JUTCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmRpcmVjdGlvbiA9PSAncnRsJztcbiAgICB9XG4gICAgdGhpcy5wb3NpdGlvblRhcmdldCA9IHRoaXMucG9zaXRpb25UYXJnZXQgfHwgdGhpcy5fZGVmYXVsdFBvc2l0aW9uVGFyZ2V0O1xuICAgIGlmICh0aGlzLmF1dG9GaXRPbkF0dGFjaCkge1xuICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHRoaXMuZml0KCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBOT1RFOiBzaGFkeWRvbSBhcHBsaWVzIGRpc3RyaWJ1dGlvbiBhc3luY2hyb25vdXNseVxuICAgICAgICAvLyBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucyB3ZWJjb21wb25lbnRzL3NoYWR5ZG9tIzEyMFxuICAgICAgICAvLyBGbHVzaCB0byBnZXQgY29ycmVjdCBsYXlvdXQgaW5mby5cbiAgICAgICAgd2luZG93LlNoYWR5RE9NICYmIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgICAgIHRoaXMuZml0KCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fX2RlZmVycmVkRml0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fX2RlZmVycmVkRml0KTtcbiAgICAgIHRoaXMuX19kZWZlcnJlZEZpdCA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQb3NpdGlvbnMgYW5kIGZpdHMgdGhlIGVsZW1lbnQgaW50byB0aGUgYGZpdEludG9gIGVsZW1lbnQuXG4gICAqL1xuICBmaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucG9zaXRpb24oKTtcbiAgICB0aGlzLmNvbnN0cmFpbigpO1xuICAgIHRoaXMuY2VudGVyKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lbW9pemUgaW5mb3JtYXRpb24gbmVlZGVkIHRvIHBvc2l0aW9uIGFuZCBzaXplIHRoZSB0YXJnZXQgZWxlbWVudC5cbiAgICogQHN1cHByZXNzIHtkZXByZWNhdGVkfVxuICAgKi9cbiAgX2Rpc2NvdmVySW5mbzogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2ZpdEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRhcmdldCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpO1xuICAgIHZhciBzaXplciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuc2l6aW5nVGFyZ2V0KTtcblxuICAgIHRoaXMuX2ZpdEluZm8gPSB7XG4gICAgICBpbmxpbmVTdHlsZToge1xuICAgICAgICB0b3A6IHRoaXMuc3R5bGUudG9wIHx8ICcnLFxuICAgICAgICBsZWZ0OiB0aGlzLnN0eWxlLmxlZnQgfHwgJycsXG4gICAgICAgIHBvc2l0aW9uOiB0aGlzLnN0eWxlLnBvc2l0aW9uIHx8ICcnXG4gICAgICB9LFxuICAgICAgc2l6ZXJJbmxpbmVTdHlsZToge1xuICAgICAgICBtYXhXaWR0aDogdGhpcy5zaXppbmdUYXJnZXQuc3R5bGUubWF4V2lkdGggfHwgJycsXG4gICAgICAgIG1heEhlaWdodDogdGhpcy5zaXppbmdUYXJnZXQuc3R5bGUubWF4SGVpZ2h0IHx8ICcnLFxuICAgICAgICBib3hTaXppbmc6IHRoaXMuc2l6aW5nVGFyZ2V0LnN0eWxlLmJveFNpemluZyB8fCAnJ1xuICAgICAgfSxcbiAgICAgIHBvc2l0aW9uZWRCeToge1xuICAgICAgICB2ZXJ0aWNhbGx5OiB0YXJnZXQudG9wICE9PSAnYXV0bycgPyAndG9wJyA6ICh0YXJnZXQuYm90dG9tICE9PSAnYXV0bycgP1xuICAgICAgICAgICdib3R0b20nIDogbnVsbCksXG4gICAgICAgIGhvcml6b250YWxseTogdGFyZ2V0LmxlZnQgIT09ICdhdXRvJyA/ICdsZWZ0JyA6ICh0YXJnZXQucmlnaHQgIT09ICdhdXRvJyA/XG4gICAgICAgICAgJ3JpZ2h0JyA6IG51bGwpXG4gICAgICB9LFxuICAgICAgc2l6ZWRCeToge1xuICAgICAgICBoZWlnaHQ6IHNpemVyLm1heEhlaWdodCAhPT0gJ25vbmUnLFxuICAgICAgICB3aWR0aDogc2l6ZXIubWF4V2lkdGggIT09ICdub25lJyxcbiAgICAgICAgbWluV2lkdGg6IHBhcnNlSW50KHNpemVyLm1pbldpZHRoLCAxMCkgfHwgMCxcbiAgICAgICAgbWluSGVpZ2h0OiBwYXJzZUludChzaXplci5taW5IZWlnaHQsIDEwKSB8fCAwXG4gICAgICB9LFxuICAgICAgbWFyZ2luOiB7XG4gICAgICAgIHRvcDogcGFyc2VJbnQodGFyZ2V0Lm1hcmdpblRvcCwgMTApIHx8IDAsXG4gICAgICAgIHJpZ2h0OiBwYXJzZUludCh0YXJnZXQubWFyZ2luUmlnaHQsIDEwKSB8fCAwLFxuICAgICAgICBib3R0b206IHBhcnNlSW50KHRhcmdldC5tYXJnaW5Cb3R0b20sIDEwKSB8fCAwLFxuICAgICAgICBsZWZ0OiBwYXJzZUludCh0YXJnZXQubWFyZ2luTGVmdCwgMTApIHx8IDBcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXNldHMgdGhlIHRhcmdldCBlbGVtZW50J3MgcG9zaXRpb24gYW5kIHNpemUgY29uc3RyYWludHMsIGFuZCBjbGVhclxuICAgKiB0aGUgbWVtb2l6ZWQgZGF0YS5cbiAgICovXG4gIHJlc2V0Rml0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuX2ZpdEluZm8gfHwge307XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gaW5mby5zaXplcklubGluZVN0eWxlKSB7XG4gICAgICB0aGlzLnNpemluZ1RhcmdldC5zdHlsZVtwcm9wZXJ0eV0gPSBpbmZvLnNpemVySW5saW5lU3R5bGVbcHJvcGVydHldO1xuICAgIH1cbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBpbmZvLmlubGluZVN0eWxlKSB7XG4gICAgICB0aGlzLnN0eWxlW3Byb3BlcnR5XSA9IGluZm8uaW5saW5lU3R5bGVbcHJvcGVydHldO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpdEluZm8gPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFcXVpdmFsZW50IHRvIGNhbGxpbmcgYHJlc2V0Rml0KClgIGFuZCBgZml0KClgLiBVc2VmdWwgdG8gY2FsbCB0aGlzIGFmdGVyXG4gICAqIHRoZSBlbGVtZW50IG9yIHRoZSBgZml0SW50b2AgZWxlbWVudCBoYXMgYmVlbiByZXNpemVkLCBvciBpZiBhbnkgb2YgdGhlXG4gICAqIHBvc2l0aW9uaW5nIHByb3BlcnRpZXMgKGUuZy4gYGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbmApIGlzIHVwZGF0ZWQuXG4gICAqIEl0IHByZXNlcnZlcyB0aGUgc2Nyb2xsIHBvc2l0aW9uIG9mIHRoZSBzaXppbmdUYXJnZXQuXG4gICAqL1xuICByZWZpdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHNjcm9sbExlZnQgPSB0aGlzLnNpemluZ1RhcmdldC5zY3JvbGxMZWZ0O1xuICAgIHZhciBzY3JvbGxUb3AgPSB0aGlzLnNpemluZ1RhcmdldC5zY3JvbGxUb3A7XG4gICAgdGhpcy5yZXNldEZpdCgpO1xuICAgIHRoaXMuZml0KCk7XG4gICAgdGhpcy5zaXppbmdUYXJnZXQuc2Nyb2xsTGVmdCA9IHNjcm9sbExlZnQ7XG4gICAgdGhpcy5zaXppbmdUYXJnZXQuc2Nyb2xsVG9wID0gc2Nyb2xsVG9wO1xuICB9LFxuXG4gIC8qKlxuICAgKiBQb3NpdGlvbnMgdGhlIGVsZW1lbnQgYWNjb3JkaW5nIHRvIGBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ25gLlxuICAgKi9cbiAgcG9zaXRpb246IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5ob3Jpem9udGFsQWxpZ24gJiYgIXRoaXMudmVydGljYWxBbGlnbikge1xuICAgICAgLy8gbmVlZHMgdG8gYmUgY2VudGVyZWQsIGFuZCBpdCBpcyBkb25lIGFmdGVyIGNvbnN0cmFpbi5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGlzY292ZXJJbmZvKCk7XG5cbiAgICB0aGlzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAvLyBOZWVkIGJvcmRlci1ib3ggZm9yIG1hcmdpbi9wYWRkaW5nLlxuICAgIHRoaXMuc2l6aW5nVGFyZ2V0LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgICAvLyBTZXQgdG8gMCwgMCBpbiBvcmRlciB0byBkaXNjb3ZlciBhbnkgb2Zmc2V0IGNhdXNlZCBieSBwYXJlbnQgc3RhY2tpbmcgY29udGV4dHMuXG4gICAgdGhpcy5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgdGhpcy5zdHlsZS50b3AgPSAnMHB4JztcblxuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgcG9zaXRpb25SZWN0ID0gdGhpcy5fX2dldE5vcm1hbGl6ZWRSZWN0KHRoaXMucG9zaXRpb25UYXJnZXQpO1xuICAgIHZhciBmaXRSZWN0ID0gdGhpcy5fX2dldE5vcm1hbGl6ZWRSZWN0KHRoaXMuZml0SW50byk7XG5cbiAgICB2YXIgbWFyZ2luID0gdGhpcy5fZml0SW5mby5tYXJnaW47XG5cbiAgICAvLyBDb25zaWRlciB0aGUgbWFyZ2luIGFzIHBhcnQgb2YgdGhlIHNpemUgZm9yIHBvc2l0aW9uIGNhbGN1bGF0aW9ucy5cbiAgICB2YXIgc2l6ZSA9IHtcbiAgICAgIHdpZHRoOiByZWN0LndpZHRoICsgbWFyZ2luLmxlZnQgKyBtYXJnaW4ucmlnaHQsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0ICsgbWFyZ2luLnRvcCArIG1hcmdpbi5ib3R0b21cbiAgICB9O1xuXG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fX2dldFBvc2l0aW9uKHRoaXMuX2xvY2FsZUhvcml6b250YWxBbGlnbiwgdGhpcy52ZXJ0aWNhbEFsaWduLCBzaXplLCBwb3NpdGlvblJlY3QsXG4gICAgICBmaXRSZWN0KTtcblxuICAgIHZhciBsZWZ0ID0gcG9zaXRpb24ubGVmdCArIG1hcmdpbi5sZWZ0O1xuICAgIHZhciB0b3AgPSBwb3NpdGlvbi50b3AgKyBtYXJnaW4udG9wO1xuXG4gICAgLy8gV2UgZmlyc3QgbGltaXQgcmlnaHQvYm90dG9tIHdpdGhpbiBmaXRJbnRvIHJlc3BlY3RpbmcgdGhlIG1hcmdpbixcbiAgICAvLyB0aGVuIHVzZSB0aG9zZSB2YWx1ZXMgdG8gbGltaXQgdG9wL2xlZnQuXG4gICAgdmFyIHJpZ2h0ID0gTWF0aC5taW4oZml0UmVjdC5yaWdodCAtIG1hcmdpbi5yaWdodCwgbGVmdCArIHJlY3Qud2lkdGgpO1xuICAgIHZhciBib3R0b20gPSBNYXRoLm1pbihmaXRSZWN0LmJvdHRvbSAtIG1hcmdpbi5ib3R0b20sIHRvcCArIHJlY3QuaGVpZ2h0KTtcblxuICAgIC8vIEtlZXAgbGVmdC90b3Agd2l0aGluIGZpdEludG8gcmVzcGVjdGluZyB0aGUgbWFyZ2luLlxuICAgIGxlZnQgPSBNYXRoLm1heChmaXRSZWN0LmxlZnQgKyBtYXJnaW4ubGVmdCxcbiAgICAgIE1hdGgubWluKGxlZnQsIHJpZ2h0IC0gdGhpcy5fZml0SW5mby5zaXplZEJ5Lm1pbldpZHRoKSk7XG4gICAgdG9wID0gTWF0aC5tYXgoZml0UmVjdC50b3AgKyBtYXJnaW4udG9wLFxuICAgICAgTWF0aC5taW4odG9wLCBib3R0b20gLSB0aGlzLl9maXRJbmZvLnNpemVkQnkubWluSGVpZ2h0KSk7XG5cbiAgICAvLyBVc2UgcmlnaHQvYm90dG9tIHRvIHNldCBtYXhXaWR0aC9tYXhIZWlnaHQsIGFuZCByZXNwZWN0IG1pbldpZHRoL21pbkhlaWdodC5cbiAgICB0aGlzLnNpemluZ1RhcmdldC5zdHlsZS5tYXhXaWR0aCA9IE1hdGgubWF4KHJpZ2h0IC0gbGVmdCwgdGhpcy5fZml0SW5mby5zaXplZEJ5Lm1pbldpZHRoKSArICdweCc7XG4gICAgdGhpcy5zaXppbmdUYXJnZXQuc3R5bGUubWF4SGVpZ2h0ID0gTWF0aC5tYXgoYm90dG9tIC0gdG9wLCB0aGlzLl9maXRJbmZvLnNpemVkQnkubWluSGVpZ2h0KSArICdweCc7XG5cbiAgICAvLyBSZW1vdmUgdGhlIG9mZnNldCBjYXVzZWQgYnkgYW55IHN0YWNraW5nIGNvbnRleHQuXG4gICAgdGhpcy5zdHlsZS5sZWZ0ID0gKGxlZnQgLSByZWN0LmxlZnQpICsgJ3B4JztcbiAgICB0aGlzLnN0eWxlLnRvcCA9ICh0b3AgLSByZWN0LnRvcCkgKyAncHgnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdHJhaW5zIHRoZSBzaXplIG9mIHRoZSBlbGVtZW50IHRvIGBmaXRJbnRvYCBieSBzZXR0aW5nIGBtYXgtaGVpZ2h0YFxuICAgKiBhbmQvb3IgYG1heC13aWR0aGAuXG4gICAqL1xuICBjb25zdHJhaW46IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmhvcml6b250YWxBbGlnbiB8fCB0aGlzLnZlcnRpY2FsQWxpZ24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGlzY292ZXJJbmZvKCk7XG5cbiAgICB2YXIgaW5mbyA9IHRoaXMuX2ZpdEluZm87XG4gICAgLy8gcG9zaXRpb24gYXQgKDBweCwgMHB4KSBpZiBub3QgYWxyZWFkeSBwb3NpdGlvbmVkLCBzbyB3ZSBjYW4gbWVhc3VyZSB0aGUgbmF0dXJhbCBzaXplLlxuICAgIGlmICghaW5mby5wb3NpdGlvbmVkQnkudmVydGljYWxseSkge1xuICAgICAgdGhpcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICB0aGlzLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIH1cbiAgICBpZiAoIWluZm8ucG9zaXRpb25lZEJ5Lmhvcml6b250YWxseSkge1xuICAgICAgdGhpcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICB0aGlzLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICB9XG5cbiAgICAvLyBuZWVkIGJvcmRlci1ib3ggZm9yIG1hcmdpbi9wYWRkaW5nXG4gICAgdGhpcy5zaXppbmdUYXJnZXQuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgIC8vIGNvbnN0cmFpbiB0aGUgd2lkdGggYW5kIGhlaWdodCBpZiBub3QgYWxyZWFkeSBzZXRcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKCFpbmZvLnNpemVkQnkuaGVpZ2h0KSB7XG4gICAgICB0aGlzLl9fc2l6ZURpbWVuc2lvbihyZWN0LCBpbmZvLnBvc2l0aW9uZWRCeS52ZXJ0aWNhbGx5LCAndG9wJywgJ2JvdHRvbScsICdIZWlnaHQnKTtcbiAgICB9XG4gICAgaWYgKCFpbmZvLnNpemVkQnkud2lkdGgpIHtcbiAgICAgIHRoaXMuX19zaXplRGltZW5zaW9uKHJlY3QsIGluZm8ucG9zaXRpb25lZEJ5Lmhvcml6b250YWxseSwgJ2xlZnQnLCAncmlnaHQnLCAnV2lkdGgnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIF9zaXplRGltZW5zaW9uOiBmdW5jdGlvbihyZWN0LCBwb3NpdGlvbmVkQnksIHN0YXJ0LCBlbmQsIGV4dGVudCkge1xuICAgIHRoaXMuX19zaXplRGltZW5zaW9uKHJlY3QsIHBvc2l0aW9uZWRCeSwgc3RhcnQsIGVuZCwgZXh0ZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fc2l6ZURpbWVuc2lvbjogZnVuY3Rpb24ocmVjdCwgcG9zaXRpb25lZEJ5LCBzdGFydCwgZW5kLCBleHRlbnQpIHtcbiAgICB2YXIgaW5mbyA9IHRoaXMuX2ZpdEluZm87XG4gICAgdmFyIGZpdFJlY3QgPSB0aGlzLl9fZ2V0Tm9ybWFsaXplZFJlY3QodGhpcy5maXRJbnRvKTtcbiAgICB2YXIgbWF4ID0gZXh0ZW50ID09PSAnV2lkdGgnID8gZml0UmVjdC53aWR0aCA6IGZpdFJlY3QuaGVpZ2h0O1xuICAgIHZhciBmbGlwID0gKHBvc2l0aW9uZWRCeSA9PT0gZW5kKTtcbiAgICB2YXIgb2Zmc2V0ID0gZmxpcCA/IG1heCAtIHJlY3RbZW5kXSA6IHJlY3Rbc3RhcnRdO1xuICAgIHZhciBtYXJnaW4gPSBpbmZvLm1hcmdpbltmbGlwID8gc3RhcnQgOiBlbmRdO1xuICAgIHZhciBvZmZzZXRFeHRlbnQgPSAnb2Zmc2V0JyArIGV4dGVudDtcbiAgICB2YXIgc2l6aW5nT2Zmc2V0ID0gdGhpc1tvZmZzZXRFeHRlbnRdIC0gdGhpcy5zaXppbmdUYXJnZXRbb2Zmc2V0RXh0ZW50XTtcbiAgICB0aGlzLnNpemluZ1RhcmdldC5zdHlsZVsnbWF4JyArIGV4dGVudF0gPSAobWF4IC0gbWFyZ2luIC0gb2Zmc2V0IC0gc2l6aW5nT2Zmc2V0KSArICdweCc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENlbnRlcnMgaG9yaXpvbnRhbGx5IGFuZCB2ZXJ0aWNhbGx5IGlmIG5vdCBhbHJlYWR5IHBvc2l0aW9uZWQuIFRoaXMgYWxzbyBzZXRzXG4gICAqIGBwb3NpdGlvbjpmaXhlZGAuXG4gICAqL1xuICBjZW50ZXI6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmhvcml6b250YWxBbGlnbiB8fCB0aGlzLnZlcnRpY2FsQWxpZ24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZGlzY292ZXJJbmZvKCk7XG5cbiAgICB2YXIgcG9zaXRpb25lZEJ5ID0gdGhpcy5fZml0SW5mby5wb3NpdGlvbmVkQnk7XG4gICAgaWYgKHBvc2l0aW9uZWRCeS52ZXJ0aWNhbGx5ICYmIHBvc2l0aW9uZWRCeS5ob3Jpem9udGFsbHkpIHtcbiAgICAgIC8vIEFscmVhZHkgcG9zaXRpb25lZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gTmVlZCBwb3NpdGlvbjpmaXhlZCB0byBjZW50ZXJcbiAgICB0aGlzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAvLyBUYWtlIGludG8gYWNjb3VudCB0aGUgb2Zmc2V0IGNhdXNlZCBieSBwYXJlbnRzIHRoYXQgY3JlYXRlIHN0YWNraW5nXG4gICAgLy8gY29udGV4dHMgKGUuZy4gd2l0aCB0cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKS4gVHJhbnNsYXRlIHRvIDAsMCBhbmRcbiAgICAvLyBtZWFzdXJlIHRoZSBib3VuZGluZyByZWN0LlxuICAgIGlmICghcG9zaXRpb25lZEJ5LnZlcnRpY2FsbHkpIHtcbiAgICAgIHRoaXMuc3R5bGUudG9wID0gJzBweCc7XG4gICAgfVxuICAgIGlmICghcG9zaXRpb25lZEJ5Lmhvcml6b250YWxseSkge1xuICAgICAgdGhpcy5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgfVxuICAgIC8vIEl0IHdpbGwgdGFrZSBpbiBjb25zaWRlcmF0aW9uIG1hcmdpbnMgYW5kIHRyYW5zZm9ybXNcbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIGZpdFJlY3QgPSB0aGlzLl9fZ2V0Tm9ybWFsaXplZFJlY3QodGhpcy5maXRJbnRvKTtcbiAgICBpZiAoIXBvc2l0aW9uZWRCeS52ZXJ0aWNhbGx5KSB7XG4gICAgICB2YXIgdG9wID0gZml0UmVjdC50b3AgLSByZWN0LnRvcCArIChmaXRSZWN0LmhlaWdodCAtIHJlY3QuaGVpZ2h0KSAvIDI7XG4gICAgICB0aGlzLnN0eWxlLnRvcCA9IHRvcCArICdweCc7XG4gICAgfVxuICAgIGlmICghcG9zaXRpb25lZEJ5Lmhvcml6b250YWxseSkge1xuICAgICAgdmFyIGxlZnQgPSBmaXRSZWN0LmxlZnQgLSByZWN0LmxlZnQgKyAoZml0UmVjdC53aWR0aCAtIHJlY3Qud2lkdGgpIC8gMjtcbiAgICAgIHRoaXMuc3R5bGUubGVmdCA9IGxlZnQgKyAncHgnO1xuICAgIH1cbiAgfSxcblxuICBfX2dldE5vcm1hbGl6ZWRSZWN0OiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0ID09PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgdGFyZ2V0ID09PSB3aW5kb3cpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgd2lkdGg6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgICBib3R0b206IHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgfSxcblxuICBfX2dldENyb3BwZWRBcmVhOiBmdW5jdGlvbihwb3NpdGlvbiwgc2l6ZSwgZml0UmVjdCkge1xuICAgIHZhciB2ZXJ0aWNhbENyb3AgPSBNYXRoLm1pbigwLCBwb3NpdGlvbi50b3ApICsgTWF0aC5taW4oMCwgZml0UmVjdC5ib3R0b20gLSAocG9zaXRpb24udG9wICsgc2l6ZS5oZWlnaHQpKTtcbiAgICB2YXIgaG9yaXpvbnRhbENyb3AgPSBNYXRoLm1pbigwLCBwb3NpdGlvbi5sZWZ0KSArIE1hdGgubWluKDAsIGZpdFJlY3QucmlnaHQgLSAocG9zaXRpb24ubGVmdCArIHNpemUud2lkdGgpKTtcbiAgICByZXR1cm4gTWF0aC5hYnModmVydGljYWxDcm9wKSAqIHNpemUud2lkdGggKyBNYXRoLmFicyhob3Jpem9udGFsQ3JvcCkgKiBzaXplLmhlaWdodDtcbiAgfSxcblxuXG4gIF9fZ2V0UG9zaXRpb246IGZ1bmN0aW9uKGhBbGlnbiwgdkFsaWduLCBzaXplLCBwb3NpdGlvblJlY3QsIGZpdFJlY3QpIHtcbiAgICAvLyBBbGwgdGhlIHBvc3NpYmxlIGNvbmZpZ3VyYXRpb25zLlxuICAgIC8vIE9yZGVyZWQgYXMgdG9wLWxlZnQsIHRvcC1yaWdodCwgYm90dG9tLWxlZnQsIGJvdHRvbS1yaWdodC5cbiAgICB2YXIgcG9zaXRpb25zID0gW3tcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgaG9yaXpvbnRhbEFsaWduOiAnbGVmdCcsXG4gICAgICB0b3A6IHBvc2l0aW9uUmVjdC50b3AgKyB0aGlzLnZlcnRpY2FsT2Zmc2V0LFxuICAgICAgbGVmdDogcG9zaXRpb25SZWN0LmxlZnQgKyB0aGlzLmhvcml6b250YWxPZmZzZXRcbiAgICB9LCB7XG4gICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcbiAgICAgIGhvcml6b250YWxBbGlnbjogJ3JpZ2h0JyxcbiAgICAgIHRvcDogcG9zaXRpb25SZWN0LnRvcCArIHRoaXMudmVydGljYWxPZmZzZXQsXG4gICAgICBsZWZ0OiBwb3NpdGlvblJlY3QucmlnaHQgLSBzaXplLndpZHRoIC0gdGhpcy5ob3Jpem9udGFsT2Zmc2V0XG4gICAgfSwge1xuICAgICAgdmVydGljYWxBbGlnbjogJ2JvdHRvbScsXG4gICAgICBob3Jpem9udGFsQWxpZ246ICdsZWZ0JyxcbiAgICAgIHRvcDogcG9zaXRpb25SZWN0LmJvdHRvbSAtIHNpemUuaGVpZ2h0IC0gdGhpcy52ZXJ0aWNhbE9mZnNldCxcbiAgICAgIGxlZnQ6IHBvc2l0aW9uUmVjdC5sZWZ0ICsgdGhpcy5ob3Jpem9udGFsT2Zmc2V0XG4gICAgfSwge1xuICAgICAgdmVydGljYWxBbGlnbjogJ2JvdHRvbScsXG4gICAgICBob3Jpem9udGFsQWxpZ246ICdyaWdodCcsXG4gICAgICB0b3A6IHBvc2l0aW9uUmVjdC5ib3R0b20gLSBzaXplLmhlaWdodCAtIHRoaXMudmVydGljYWxPZmZzZXQsXG4gICAgICBsZWZ0OiBwb3NpdGlvblJlY3QucmlnaHQgLSBzaXplLndpZHRoIC0gdGhpcy5ob3Jpem9udGFsT2Zmc2V0XG4gICAgfV07XG5cbiAgICBpZiAodGhpcy5ub092ZXJsYXApIHtcbiAgICAgIC8vIER1cGxpY2F0ZS5cbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gcG9zaXRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY29weSA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcG9zaXRpb25zW2ldKSB7XG4gICAgICAgICAgY29weVtrZXldID0gcG9zaXRpb25zW2ldW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgcG9zaXRpb25zLnB1c2goY29weSk7XG4gICAgICB9XG4gICAgICAvLyBIb3Jpem9udGFsIG92ZXJsYXAgb25seS5cbiAgICAgIHBvc2l0aW9uc1swXS50b3AgPSBwb3NpdGlvbnNbMV0udG9wICs9IHBvc2l0aW9uUmVjdC5oZWlnaHQ7XG4gICAgICBwb3NpdGlvbnNbMl0udG9wID0gcG9zaXRpb25zWzNdLnRvcCAtPSBwb3NpdGlvblJlY3QuaGVpZ2h0O1xuICAgICAgLy8gVmVydGljYWwgb3ZlcmxhcCBvbmx5LlxuICAgICAgcG9zaXRpb25zWzRdLmxlZnQgPSBwb3NpdGlvbnNbNl0ubGVmdCArPSBwb3NpdGlvblJlY3Qud2lkdGg7XG4gICAgICBwb3NpdGlvbnNbNV0ubGVmdCA9IHBvc2l0aW9uc1s3XS5sZWZ0IC09IHBvc2l0aW9uUmVjdC53aWR0aDtcbiAgICB9XG5cbiAgICAvLyBDb25zaWRlciBhdXRvIGFzIG51bGwgZm9yIGNvZGluZyBjb252ZW5pZW5jZS5cbiAgICB2QWxpZ24gPSB2QWxpZ24gPT09ICdhdXRvJyA/IG51bGwgOiB2QWxpZ247XG4gICAgaEFsaWduID0gaEFsaWduID09PSAnYXV0bycgPyBudWxsIDogaEFsaWduO1xuXG4gICAgdmFyIHBvc2l0aW9uO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9zaXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcG9zID0gcG9zaXRpb25zW2ldO1xuXG4gICAgICAvLyBJZiBib3RoIHZBbGlnbiBhbmQgaEFsaWduIGFyZSBkZWZpbmVkLCByZXR1cm4gZXhhY3QgbWF0Y2guXG4gICAgICAvLyBGb3IgZHluYW1pY0FsaWduIGFuZCBub092ZXJsYXAgd2UnbGwgaGF2ZSBtb3JlIHRoYW4gb25lIGNhbmRpZGF0ZSwgc29cbiAgICAgIC8vIHdlJ2xsIGhhdmUgdG8gY2hlY2sgdGhlIGNyb3BwZWRBcmVhIHRvIG1ha2UgdGhlIGJlc3QgY2hvaWNlLlxuICAgICAgaWYgKCF0aGlzLmR5bmFtaWNBbGlnbiAmJiAhdGhpcy5ub092ZXJsYXAgJiZcbiAgICAgICAgcG9zLnZlcnRpY2FsQWxpZ24gPT09IHZBbGlnbiAmJiBwb3MuaG9yaXpvbnRhbEFsaWduID09PSBoQWxpZ24pIHtcbiAgICAgICAgcG9zaXRpb24gPSBwb3M7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBBbGlnbiBpcyBvayBpZiBhbGlnbm1lbnQgcHJlZmVyZW5jZXMgYXJlIHJlc3BlY3RlZC4gSWYgbm8gcHJlZmVyZW5jZXMsXG4gICAgICAvLyBpdCBpcyBjb25zaWRlcmVkIG9rLlxuICAgICAgdmFyIGFsaWduT2sgPSAoIXZBbGlnbiB8fCBwb3MudmVydGljYWxBbGlnbiA9PT0gdkFsaWduKSAmJlxuICAgICAgICAoIWhBbGlnbiB8fCBwb3MuaG9yaXpvbnRhbEFsaWduID09PSBoQWxpZ24pO1xuXG4gICAgICAvLyBGaWx0ZXIgb3V0IGVsZW1lbnRzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIGFsaWdubWVudCAoaWYgZGVmaW5lZCkuXG4gICAgICAvLyBXaXRoIGR5bmFtaWNBbGlnbiwgd2UgbmVlZCB0byBjb25zaWRlciBhbGwgdGhlIHBvc2l0aW9ucyB0byBmaW5kIHRoZVxuICAgICAgLy8gb25lIHRoYXQgbWluaW1pemVzIHRoZSBjcm9wcGVkIGFyZWEuXG4gICAgICBpZiAoIXRoaXMuZHluYW1pY0FsaWduICYmICFhbGlnbk9rKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uIHx8IHBvcztcbiAgICAgIHBvcy5jcm9wcGVkQXJlYSA9IHRoaXMuX19nZXRDcm9wcGVkQXJlYShwb3MsIHNpemUsIGZpdFJlY3QpO1xuICAgICAgdmFyIGRpZmYgPSBwb3MuY3JvcHBlZEFyZWEgLSBwb3NpdGlvbi5jcm9wcGVkQXJlYTtcbiAgICAgIC8vIENoZWNrIHdoaWNoIGNyb3BzIGxlc3MuIElmIGl0IGNyb3BzIGVxdWFsbHksIGNoZWNrIGlmIGFsaWduIGlzIG9rLlxuICAgICAgaWYgKGRpZmYgPCAwIHx8IChkaWZmID09PSAwICYmIGFsaWduT2spKSB7XG4gICAgICAgIHBvc2l0aW9uID0gcG9zO1xuICAgICAgfVxuICAgICAgLy8gSWYgbm90IGNyb3BwZWQgYW5kIHJlc3BlY3RzIHRoZSBhbGlnbiByZXF1aXJlbWVudHMsIGtlZXAgaXQuXG4gICAgICAvLyBUaGlzIGFsbG93cyB0byBwcmVmZXIgcG9zaXRpb25zIG92ZXJsYXBwaW5nIGhvcml6b250YWxseSBvdmVyIHRoZVxuICAgICAgLy8gb25lcyBvdmVybGFwcGluZyB2ZXJ0aWNhbGx5LlxuICAgICAgaWYgKHBvc2l0aW9uLmNyb3BwZWRBcmVhID09PSAwICYmIGFsaWduT2spIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZpdC1iZWhhdmlvci9pcm9uLWZpdC1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgU2V0dGluZ3MgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi91dGlscy9zZXR0aW5ncy5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5leHBvcnQgY29uc3QgSXJvblJlc2l6YWJsZUJlaGF2aW9yID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIGNsb3Nlc3QgYW5jZXN0b3IgZWxlbWVudCB0aGF0IGltcGxlbWVudHMgYElyb25SZXNpemFibGVCZWhhdmlvcmAuXG4gICAgICovXG4gICAgX3BhcmVudFJlc2l6YWJsZToge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgb2JzZXJ2ZXI6ICdfcGFyZW50UmVzaXphYmxlQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGlzIGVsZW1lbnQgaXMgY3VycmVudGx5IG5vdGlmeWluZyBpdHMgZGVzY2VuZGFudCBlbGVtZW50cyBvZlxuICAgICAqIHJlc2l6ZS5cbiAgICAgKi9cbiAgICBfbm90aWZ5aW5nRGVzY2VuZGFudDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH1cbiAgfSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICAnaXJvbi1yZXF1ZXN0LXJlc2l6ZS1ub3RpZmljYXRpb25zJzogJ19vbklyb25SZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucydcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBXZSBkb24ndCByZWFsbHkgbmVlZCBwcm9wZXJ0eSBlZmZlY3RzIG9uIHRoZXNlLCBhbmQgYWxzbyB3ZSB3YW50IHRoZW1cbiAgICAvLyB0byBiZSBjcmVhdGVkIGJlZm9yZSB0aGUgYF9wYXJlbnRSZXNpemFibGVgIG9ic2VydmVyIGZpcmVzOlxuICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzID0gW107XG4gICAgdGhpcy5fYm91bmROb3RpZnlSZXNpemUgPSB0aGlzLm5vdGlmeVJlc2l6ZS5iaW5kKHRoaXMpO1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucygpO1xuICB9LFxuXG4gIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50UmVzaXphYmxlKSB7XG4gICAgICB0aGlzLl9wYXJlbnRSZXNpemFibGUuc3RvcFJlc2l6ZU5vdGlmaWNhdGlvbnNGb3IodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE5vdGlmeVJlc2l6ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGFyZW50UmVzaXphYmxlID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ2FuIGJlIGNhbGxlZCB0byBtYW51YWxseSBub3RpZnkgYSByZXNpemFibGUgYW5kIGl0cyBkZXNjZW5kYW50XG4gICAqIHJlc2l6YWJsZXMgb2YgYSByZXNpemUgY2hhbmdlLlxuICAgKi9cbiAgbm90aWZ5UmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLmZvckVhY2goZnVuY3Rpb24ocmVzaXphYmxlKSB7XG4gICAgICBpZiAodGhpcy5yZXNpemVyU2hvdWxkTm90aWZ5KHJlc2l6YWJsZSkpIHtcbiAgICAgICAgdGhpcy5fbm90aWZ5RGVzY2VuZGFudChyZXNpemFibGUpO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgdGhpcy5fZmlyZVJlc2l6ZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIGFzc2lnbiB0aGUgY2xvc2VzdCByZXNpemFibGUgYW5jZXN0b3IgdG8gdGhpcyByZXNpemFibGVcbiAgICogaWYgdGhlIGFuY2VzdG9yIGRldGVjdHMgYSByZXF1ZXN0IGZvciBub3RpZmljYXRpb25zLlxuICAgKi9cbiAgYXNzaWduUGFyZW50UmVzaXphYmxlOiBmdW5jdGlvbihwYXJlbnRSZXNpemFibGUpIHtcbiAgICB0aGlzLl9wYXJlbnRSZXNpemFibGUgPSBwYXJlbnRSZXNpemFibGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gcmVtb3ZlIGEgcmVzaXphYmxlIGRlc2NlbmRhbnQgZnJvbSB0aGUgbGlzdCBvZiBkZXNjZW5kYW50c1xuICAgKiB0aGF0IHNob3VsZCBiZSBub3RpZmllZCBvZiBhIHJlc2l6ZSBjaGFuZ2UuXG4gICAqL1xuICBzdG9wUmVzaXplTm90aWZpY2F0aW9uc0ZvcjogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuaW5kZXhPZih0YXJnZXQpO1xuXG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICB0aGlzLnVubGlzdGVuKHRhcmdldCwgJ2lyb24tcmVzaXplJywgJ19vbkRlc2NlbmRhbnRJcm9uUmVzaXplJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgb3ZlcnJpZGRlbiB0byBmaWx0ZXIgbmVzdGVkIGVsZW1lbnRzIHRoYXQgc2hvdWxkIG9yXG4gICAqIHNob3VsZCBub3QgYmUgbm90aWZpZWQgYnkgdGhlIGN1cnJlbnQgZWxlbWVudC4gUmV0dXJuIHRydWUgaWYgYW4gZWxlbWVudFxuICAgKiBzaG91bGQgYmUgbm90aWZpZWQsIG9yIGZhbHNlIGlmIGl0IHNob3VsZCBub3QgYmUgbm90aWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgQSBjYW5kaWRhdGUgZGVzY2VuZGFudCBlbGVtZW50IHRoYXRcbiAgICogaW1wbGVtZW50cyBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgYGVsZW1lbnRgIHNob3VsZCBiZSBub3RpZmllZCBvZiByZXNpemUuXG4gICAqL1xuICByZXNpemVyU2hvdWxkTm90aWZ5OiBmdW5jdGlvbihlbGVtZW50KSB7IHJldHVybiB0cnVlOyB9LFxuXG4gIF9vbkRlc2NlbmRhbnRJcm9uUmVzaXplOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLl9ub3RpZnlpbmdEZXNjZW5kYW50KSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBOT1RFKGNkYXRhKTogSW4gU2hhZG93RE9NLCBldmVudCByZXRhcmdldGluZyBtYWtlcyBlY2hvaW5nIG9mIHRoZVxuICAgIC8vIG90aGVyd2lzZSBub24tYnViYmxpbmcgZXZlbnQgXCJqdXN0IHdvcmsuXCIgV2UgZG8gaXQgbWFudWFsbHkgaGVyZSBmb3JcbiAgICAvLyB0aGUgY2FzZSB3aGVyZSBQb2x5bWVyIGlzIG5vdCB1c2luZyBzaGFkb3cgcm9vdHMgZm9yIHdoYXRldmVyIHJlYXNvbjpcbiAgICBpZiAoIVNldHRpbmdzLnVzZVNoYWRvdykge1xuICAgICAgdGhpcy5fZmlyZVJlc2l6ZSgpO1xuICAgIH1cbiAgfSxcblxuICBfZmlyZVJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5maXJlKCdpcm9uLXJlc2l6ZScsIG51bGwsIHtcbiAgICAgIG5vZGU6IHRoaXMsXG4gICAgICBidWJibGVzOiBmYWxzZVxuICAgIH0pO1xuICB9LFxuXG4gIF9vbklyb25SZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9uczogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChkb20oZXZlbnQpLnJvb3RUYXJnZXQpO1xuICAgIGlmICh0YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuaW5kZXhPZih0YXJnZXQpID09PSAtMSkge1xuICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMucHVzaCh0YXJnZXQpO1xuICAgICAgdGhpcy5saXN0ZW4odGFyZ2V0LCAnaXJvbi1yZXNpemUnLCAnX29uRGVzY2VuZGFudElyb25SZXNpemUnKTtcbiAgICB9XG5cbiAgICB0YXJnZXQuYXNzaWduUGFyZW50UmVzaXphYmxlKHRoaXMpO1xuICAgIHRoaXMuX25vdGlmeURlc2NlbmRhbnQodGFyZ2V0KTtcblxuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9LFxuXG4gIF9wYXJlbnRSZXNpemFibGVDaGFuZ2VkOiBmdW5jdGlvbihwYXJlbnRSZXNpemFibGUpIHtcbiAgICBpZiAocGFyZW50UmVzaXphYmxlKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmROb3RpZnlSZXNpemUpO1xuICAgIH1cbiAgfSxcblxuICBfbm90aWZ5RGVzY2VuZGFudDogZnVuY3Rpb24oZGVzY2VuZGFudCkge1xuICAgIC8vIE5PVEUoY2RhdGEpOiBJbiBJRTEwLCBhdHRhY2hlZCBpcyBmaXJlZCBvbiBjaGlsZHJlbiBmaXJzdCwgc28gaXQnc1xuICAgIC8vIGltcG9ydGFudCBub3QgdG8gbm90aWZ5IHRoZW0gaWYgdGhlIHBhcmVudCBpcyBub3QgYXR0YWNoZWQgeWV0IChvclxuICAgIC8vIGVsc2UgdGhleSB3aWxsIGdldCByZWR1bmRhbnRseSBub3RpZmllZCB3aGVuIHRoZSBwYXJlbnQgYXR0YWNoZXMpLlxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbm90aWZ5aW5nRGVzY2VuZGFudCA9IHRydWU7XG4gICAgZGVzY2VuZGFudC5ub3RpZnlSZXNpemUoKTtcbiAgICB0aGlzLl9ub3RpZnlpbmdEZXNjZW5kYW50ID0gZmFsc2U7XG4gIH0sXG4gIFxuICBfcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKVxuICAgICAgcmV0dXJuO1xuICAgIFxuICAgIC8vIE5PVEUodmFsZHJpbikgSW4gQ3VzdG9tRWxlbWVudHMgdjEgd2l0aCBuYXRpdmUgSFRNTEltcG9ydHMsIHRoZSBvcmRlclxuICAgIC8vIG9mIGltcG9ydHMgYWZmZWN0cyB0aGUgb3JkZXIgb2YgYGF0dGFjaGVkYCBjYWxsYmFja3MgKHNlZSB3ZWJjb21wb25lbnRzL2N1c3RvbS1lbGVtZW50cyMxNSkuXG4gICAgLy8gVGhpcyBtaWdodCBjYXVzZSBhIGNoaWxkIHRvIG5vdGlmeSBwYXJlbnRzIHRvbyBlYXJseSAoYXMgdGhlIHBhcmVudFxuICAgIC8vIHN0aWxsIGhhcyB0byBiZSB1cGdyYWRlZCksIHJlc3VsdGluZyBpbiBhIHBhcmVudCBub3QgYWJsZSB0byBrZWVwIHRyYWNrXG4gICAgLy8gb2YgdGhlIGBfaW50ZXJlc3RlZFJlc2l6YWJsZXNgLiBUbyBzb2x2ZSB0aGlzLCB3ZSB3YWl0IGZvciB0aGUgZG9jdW1lbnRcbiAgICAvLyB0byBiZSBkb25lIGxvYWRpbmcgYmVmb3JlIGZpcmluZyB0aGUgZXZlbnQuXG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgdmFyIF9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucyA9IHRoaXMuX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zLmJpbmQodGhpcyk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgZnVuY3Rpb24gcmVhZHlzdGF0ZWNoYW5nZWQoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCByZWFkeXN0YXRlY2hhbmdlZCk7XG4gICAgICAgIF9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucygpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmlyZSgnaXJvbi1yZXF1ZXN0LXJlc2l6ZS1ub3RpZmljYXRpb25zJywgbnVsbCwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCF0aGlzLl9wYXJlbnRSZXNpemFibGUpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplKTtcbiAgICAgICAgdGhpcy5ub3RpZnlSZXNpemUoKTtcbiAgICAgIH0gXG4gICAgfVxuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDc5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25BMTF5S2V5c0JlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuanMnO1xuaW1wb3J0ICcuL2lyb24tb3ZlcmxheS1iYWNrZHJvcC5qcyc7XG5pbXBvcnQgKiBhcyBnZXN0dXJlcyBmcm9tICcuLi9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbk92ZXJsYXlNYW5hZ2VyQ2xhc3MgPSBmdW5jdGlvbigpIHtcbiAgLyoqXG4gICAqIFVzZWQgdG8ga2VlcCB0cmFjayBvZiB0aGUgb3BlbmVkIG92ZXJsYXlzLlxuICAgKiBAcHJpdmF0ZSB7QXJyYXk8RWxlbWVudD59XG4gICAqL1xuICB0aGlzLl9vdmVybGF5cyA9IFtdO1xuXG4gIC8qKlxuICAgKiBpZnJhbWVzIGhhdmUgYSBkZWZhdWx0IHotaW5kZXggb2YgMTAwLFxuICAgKiBzbyB0aGlzIGRlZmF1bHQgc2hvdWxkIGJlIGF0IGxlYXN0IHRoYXQuXG4gICAqIEBwcml2YXRlIHtudW1iZXJ9XG4gICAqL1xuICB0aGlzLl9taW5pbXVtWiA9IDEwMTtcblxuICAvKipcbiAgICogTWVtb2l6ZWQgYmFja2Ryb3AgZWxlbWVudC5cbiAgICogQHByaXZhdGUge0VsZW1lbnR8bnVsbH1cbiAgICovXG4gIHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IG51bGw7XG5cbiAgLy8gRW5hYmxlIGRvY3VtZW50LXdpZGUgdGFwIHJlY29nbml6ZXIuXG4gIC8vIE5PVEU6IFVzZSB1c2VDYXB0dXJlPXRydWUgdG8gYXZvaWQgYWNjaWRlbnRhbGx5IHByZXZlbnRpb24gb2YgdGhlIGNsb3NpbmdcbiAgLy8gb2YgYW4gb3ZlcmxheSB2aWEgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkuIFRoZSBvbmx5IHdheSB0byBwcmV2ZW50XG4gIC8vIGNsb3Npbmcgb2YgYW4gb3ZlcmxheSBzaG91bGQgYmUgdGhyb3VnaCBpdHMgQVBJcy5cbiAgLy8gTk9URTogZW5hYmxlIHRhcCBvbiA8aHRtbD4gdG8gd29ya2Fyb3VuZCBQb2x5bWVyL3BvbHltZXIjNDQ1OVxuICBnZXN0dXJlcy5hZGQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCAndGFwJywgbnVsbCk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RhcCcsIHRoaXMuX29uQ2FwdHVyZUNsaWNrLmJpbmQodGhpcyksIHRydWUpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX29uQ2FwdHVyZUZvY3VzLmJpbmQodGhpcyksIHRydWUpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fb25DYXB0dXJlS2V5RG93bi5iaW5kKHRoaXMpLCB0cnVlKTtcbn07XG5cbklyb25PdmVybGF5TWFuYWdlckNsYXNzLnByb3RvdHlwZSA9IHtcblxuICBjb25zdHJ1Y3RvcjogSXJvbk92ZXJsYXlNYW5hZ2VyQ2xhc3MsXG5cbiAgLyoqXG4gICAqIFRoZSBzaGFyZWQgYmFja2Ryb3AgZWxlbWVudC5cbiAgICogQHR5cGUgeyFFbGVtZW50fSBiYWNrZHJvcEVsZW1lbnRcbiAgICovXG4gIGdldCBiYWNrZHJvcEVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9iYWNrZHJvcEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2JhY2tkcm9wRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lyb24tb3ZlcmxheS1iYWNrZHJvcCcpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fYmFja2Ryb3BFbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgZGVlcGVzdCBhY3RpdmUgZWxlbWVudC5cbiAgICogQHR5cGUgeyFFbGVtZW50fSBhY3RpdmVFbGVtZW50IHRoZSBhY3RpdmUgZWxlbWVudFxuICAgKi9cbiAgZ2V0IGRlZXBBY3RpdmVFbGVtZW50KCkge1xuICAgIC8vIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIGJlIG51bGxcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRG9jdW1lbnQvYWN0aXZlRWxlbWVudFxuICAgIC8vIEluIGNhc2Ugb2YgbnVsbCwgZGVmYXVsdCBpdCB0byBkb2N1bWVudC5ib2R5LlxuICAgIHZhciBhY3RpdmUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gICAgd2hpbGUgKGFjdGl2ZS5yb290ICYmIGRvbShhY3RpdmUucm9vdCkuYWN0aXZlRWxlbWVudCkge1xuICAgICAgYWN0aXZlID0gZG9tKGFjdGl2ZS5yb290KS5hY3RpdmVFbGVtZW50O1xuICAgIH1cbiAgICByZXR1cm4gYWN0aXZlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBCcmluZ3MgdGhlIG92ZXJsYXkgYXQgdGhlIHNwZWNpZmllZCBpbmRleCB0byB0aGUgZnJvbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYnJpbmdPdmVybGF5QXRJbmRleFRvRnJvbnQ6IGZ1bmN0aW9uKGkpIHtcbiAgICB2YXIgb3ZlcmxheSA9IHRoaXMuX292ZXJsYXlzW2ldO1xuICAgIGlmICghb3ZlcmxheSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGFzdEkgPSB0aGlzLl9vdmVybGF5cy5sZW5ndGggLSAxO1xuICAgIHZhciBjdXJyZW50T3ZlcmxheSA9IHRoaXMuX292ZXJsYXlzW2xhc3RJXTtcbiAgICAvLyBFbnN1cmUgYWx3YXlzLW9uLXRvcCBvdmVybGF5IHN0YXlzIG9uIHRvcC5cbiAgICBpZiAoY3VycmVudE92ZXJsYXkgJiYgdGhpcy5fc2hvdWxkQmVCZWhpbmRPdmVybGF5KG92ZXJsYXksIGN1cnJlbnRPdmVybGF5KSkge1xuICAgICAgbGFzdEktLTtcbiAgICB9XG4gICAgLy8gSWYgYWxyZWFkeSB0aGUgdG9wIGVsZW1lbnQsIHJldHVybi5cbiAgICBpZiAoaSA+PSBsYXN0SSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBVcGRhdGUgei1pbmRleCB0byBiZSBvbiB0b3AuXG4gICAgdmFyIG1pbmltdW1aID0gTWF0aC5tYXgodGhpcy5jdXJyZW50T3ZlcmxheVooKSwgdGhpcy5fbWluaW11bVopO1xuICAgIGlmICh0aGlzLl9nZXRaKG92ZXJsYXkpIDw9IG1pbmltdW1aKSB7XG4gICAgICB0aGlzLl9hcHBseU92ZXJsYXlaKG92ZXJsYXksIG1pbmltdW1aKTtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBvdGhlciBvdmVybGF5cyBiZWhpbmQgdGhlIG5ldyBvbiB0b3AuXG4gICAgd2hpbGUgKGkgPCBsYXN0SSkge1xuICAgICAgdGhpcy5fb3ZlcmxheXNbaV0gPSB0aGlzLl9vdmVybGF5c1tpICsgMV07XG4gICAgICBpKys7XG4gICAgfVxuICAgIHRoaXMuX292ZXJsYXlzW2xhc3RJXSA9IG92ZXJsYXk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIG92ZXJsYXkgYW5kIHVwZGF0ZXMgaXRzIHotaW5kZXggaWYgaXQncyBvcGVuZWQsIG9yIHJlbW92ZXMgaXQgaWYgaXQncyBjbG9zZWQuXG4gICAqIEFsc28gdXBkYXRlcyB0aGUgYmFja2Ryb3Agei1pbmRleC5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gb3ZlcmxheVxuICAgKi9cbiAgYWRkT3JSZW1vdmVPdmVybGF5OiBmdW5jdGlvbihvdmVybGF5KSB7XG4gICAgaWYgKG92ZXJsYXkub3BlbmVkKSB7XG4gICAgICB0aGlzLmFkZE92ZXJsYXkob3ZlcmxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlT3ZlcmxheShvdmVybGF5KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYWNrcyBvdmVybGF5cyBmb3Igei1pbmRleCBhbmQgZm9jdXMgbWFuYWdlbWVudC5cbiAgICogRW5zdXJlcyB0aGUgbGFzdCBhZGRlZCBvdmVybGF5IHdpdGggYWx3YXlzLW9uLXRvcCByZW1haW5zIG9uIHRvcC5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gb3ZlcmxheVxuICAgKi9cbiAgYWRkT3ZlcmxheTogZnVuY3Rpb24ob3ZlcmxheSkge1xuICAgIHZhciBpID0gdGhpcy5fb3ZlcmxheXMuaW5kZXhPZihvdmVybGF5KTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9icmluZ092ZXJsYXlBdEluZGV4VG9Gcm9udChpKTtcbiAgICAgIHRoaXMudHJhY2tCYWNrZHJvcCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaW5zZXJ0aW9uSW5kZXggPSB0aGlzLl9vdmVybGF5cy5sZW5ndGg7XG4gICAgdmFyIGN1cnJlbnRPdmVybGF5ID0gdGhpcy5fb3ZlcmxheXNbaW5zZXJ0aW9uSW5kZXggLSAxXTtcbiAgICB2YXIgbWluaW11bVogPSBNYXRoLm1heCh0aGlzLl9nZXRaKGN1cnJlbnRPdmVybGF5KSwgdGhpcy5fbWluaW11bVopO1xuICAgIHZhciBuZXdaID0gdGhpcy5fZ2V0WihvdmVybGF5KTtcblxuICAgIC8vIEVuc3VyZSBhbHdheXMtb24tdG9wIG92ZXJsYXkgc3RheXMgb24gdG9wLlxuICAgIGlmIChjdXJyZW50T3ZlcmxheSAmJiB0aGlzLl9zaG91bGRCZUJlaGluZE92ZXJsYXkob3ZlcmxheSwgY3VycmVudE92ZXJsYXkpKSB7XG4gICAgICAvLyBUaGlzIGJ1bXBzIHRoZSB6LWluZGV4IG9mICsyLlxuICAgICAgdGhpcy5fYXBwbHlPdmVybGF5WihjdXJyZW50T3ZlcmxheSwgbWluaW11bVopO1xuICAgICAgaW5zZXJ0aW9uSW5kZXgtLTtcbiAgICAgIC8vIFVwZGF0ZSBtaW5pbXVtWiB0byBtYXRjaCBwcmV2aW91cyBvdmVybGF5J3Mgei1pbmRleC5cbiAgICAgIHZhciBwcmV2aW91c092ZXJsYXkgPSB0aGlzLl9vdmVybGF5c1tpbnNlcnRpb25JbmRleCAtIDFdO1xuICAgICAgbWluaW11bVogPSBNYXRoLm1heCh0aGlzLl9nZXRaKHByZXZpb3VzT3ZlcmxheSksIHRoaXMuX21pbmltdW1aKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgei1pbmRleCBhbmQgaW5zZXJ0IG92ZXJsYXkuXG4gICAgaWYgKG5ld1ogPD0gbWluaW11bVopIHtcbiAgICAgIHRoaXMuX2FwcGx5T3ZlcmxheVoob3ZlcmxheSwgbWluaW11bVopO1xuICAgIH1cbiAgICB0aGlzLl9vdmVybGF5cy5zcGxpY2UoaW5zZXJ0aW9uSW5kZXgsIDAsIG92ZXJsYXkpO1xuXG4gICAgdGhpcy50cmFja0JhY2tkcm9wKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG92ZXJsYXlcbiAgICovXG4gIHJlbW92ZU92ZXJsYXk6IGZ1bmN0aW9uKG92ZXJsYXkpIHtcbiAgICB2YXIgaSA9IHRoaXMuX292ZXJsYXlzLmluZGV4T2Yob3ZlcmxheSk7XG4gICAgaWYgKGkgPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX292ZXJsYXlzLnNwbGljZShpLCAxKTtcblxuICAgIHRoaXMudHJhY2tCYWNrZHJvcCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG92ZXJsYXkuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR8dW5kZWZpbmVkfVxuICAgKi9cbiAgY3VycmVudE92ZXJsYXk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpID0gdGhpcy5fb3ZlcmxheXMubGVuZ3RoIC0gMTtcbiAgICByZXR1cm4gdGhpcy5fb3ZlcmxheXNbaV07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgb3ZlcmxheSB6LWluZGV4LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBjdXJyZW50T3ZlcmxheVo6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRaKHRoaXMuY3VycmVudE92ZXJsYXkoKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhhdCB0aGUgbWluaW11bSB6LWluZGV4IG9mIG5ldyBvdmVybGF5cyBpcyBhdCBsZWFzdCBgbWluaW11bVpgLlxuICAgKiBUaGlzIGRvZXMgbm90IGVmZmVjdCB0aGUgei1pbmRleCBvZiBhbnkgZXhpc3Rpbmcgb3ZlcmxheXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5pbXVtWlxuICAgKi9cbiAgZW5zdXJlTWluaW11bVo6IGZ1bmN0aW9uKG1pbmltdW1aKSB7XG4gICAgdGhpcy5fbWluaW11bVogPSBNYXRoLm1heCh0aGlzLl9taW5pbXVtWiwgbWluaW11bVopO1xuICB9LFxuXG4gIGZvY3VzT3ZlcmxheTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGN1cnJlbnQgPSAvKiogQHR5cGUgez99ICovICh0aGlzLmN1cnJlbnRPdmVybGF5KCkpO1xuICAgIGlmIChjdXJyZW50KSB7XG4gICAgICBjdXJyZW50Ll9hcHBseUZvY3VzKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBiYWNrZHJvcCB6LWluZGV4LlxuICAgKi9cbiAgdHJhY2tCYWNrZHJvcDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIG92ZXJsYXkgPSB0aGlzLl9vdmVybGF5V2l0aEJhY2tkcm9wKCk7XG4gICAgLy8gQXZvaWQgY3JlYXRpbmcgdGhlIGJhY2tkcm9wIGlmIHRoZXJlIGlzIG5vIG92ZXJsYXkgd2l0aCBiYWNrZHJvcC5cbiAgICBpZiAoIW92ZXJsYXkgJiYgIXRoaXMuX2JhY2tkcm9wRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmJhY2tkcm9wRWxlbWVudC5zdHlsZS56SW5kZXggPSB0aGlzLl9nZXRaKG92ZXJsYXkpIC0gMTtcbiAgICB0aGlzLmJhY2tkcm9wRWxlbWVudC5vcGVuZWQgPSAhIW92ZXJsYXk7XG4gICAgLy8gUHJvcGVydHkgb2JzZXJ2ZXJzIGFyZSBub3QgZmlyZWQgdW50aWwgZWxlbWVudCBpcyBhdHRhY2hlZFxuICAgIC8vIGluIFBvbHltZXIgMi54LCBzbyB3ZSBlbnN1cmUgZWxlbWVudCBpcyBhdHRhY2hlZCBpZiBuZWVkZWQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvNDUyNlxuICAgIHRoaXMuYmFja2Ryb3BFbGVtZW50LnByZXBhcmUoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8RWxlbWVudD59XG4gICAqL1xuICBnZXRCYWNrZHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBiYWNrZHJvcHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX292ZXJsYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5fb3ZlcmxheXNbaV0ud2l0aEJhY2tkcm9wKSB7XG4gICAgICAgIGJhY2tkcm9wcy5wdXNoKHRoaXMuX292ZXJsYXlzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGJhY2tkcm9wcztcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgei1pbmRleCBmb3IgdGhlIGJhY2tkcm9wLlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBiYWNrZHJvcFo6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRaKHRoaXMuX292ZXJsYXlXaXRoQmFja2Ryb3AoKSkgLSAxO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBvcGVuZWQgb3ZlcmxheSB0aGF0IGhhcyBhIGJhY2tkcm9wLlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fHVuZGVmaW5lZH1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vdmVybGF5V2l0aEJhY2tkcm9wOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX292ZXJsYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodGhpcy5fb3ZlcmxheXNbaV0ud2l0aEJhY2tkcm9wKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vdmVybGF5c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIG1pbmltdW0gei1pbmRleCBmb3IgdGhlIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7RWxlbWVudD19IG92ZXJsYXlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRaOiBmdW5jdGlvbihvdmVybGF5KSB7XG4gICAgdmFyIHogPSB0aGlzLl9taW5pbXVtWjtcbiAgICBpZiAob3ZlcmxheSkge1xuICAgICAgdmFyIHoxID0gTnVtYmVyKG92ZXJsYXkuc3R5bGUuekluZGV4IHx8IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG92ZXJsYXkpLnpJbmRleCk7XG4gICAgICAvLyBDaGVjayBpZiBpcyBhIG51bWJlclxuICAgICAgLy8gTnVtYmVyLmlzTmFOIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTArXG4gICAgICBpZiAoejEgPT09IHoxKSB7XG4gICAgICAgIHogPSB6MTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHo7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSB6XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2V0WjogZnVuY3Rpb24oZWxlbWVudCwgeikge1xuICAgIGVsZW1lbnQuc3R5bGUuekluZGV4ID0gejtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gb3ZlcmxheVxuICAgKiBAcGFyYW0ge251bWJlcn0gYWJvdmVaXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfYXBwbHlPdmVybGF5WjogZnVuY3Rpb24ob3ZlcmxheSwgYWJvdmVaKSB7XG4gICAgdGhpcy5fc2V0WihvdmVybGF5LCBhYm92ZVogKyAyKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGVlcGVzdCBvdmVybGF5IGluIHRoZSBwYXRoLlxuICAgKiBAcGFyYW0ge0FycmF5PEVsZW1lbnQ+PX0gcGF0aFxuICAgKiBAcmV0dXJuIHtFbGVtZW50fHVuZGVmaW5lZH1cbiAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vdmVybGF5SW5QYXRoOiBmdW5jdGlvbihwYXRoKSB7XG4gICAgcGF0aCA9IHBhdGggfHwgW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocGF0aFtpXS5fbWFuYWdlciA9PT0gdGhpcykge1xuICAgICAgICByZXR1cm4gcGF0aFtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhlIGNsaWNrIGV2ZW50IGlzIGRlbGVnYXRlZCB0byB0aGUgcmlnaHQgb3ZlcmxheS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DYXB0dXJlQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIG92ZXJsYXkgPSAvKiogQHR5cGUgez99ICovICh0aGlzLmN1cnJlbnRPdmVybGF5KCkpO1xuICAgIC8vIENoZWNrIGlmIGNsaWNrZWQgb3V0c2lkZSBvZiB0b3Agb3ZlcmxheS5cbiAgICBpZiAob3ZlcmxheSAmJiB0aGlzLl9vdmVybGF5SW5QYXRoKGRvbShldmVudCkucGF0aCkgIT09IG92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuX29uQ2FwdHVyZUNsaWNrKGV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhlIGZvY3VzIGV2ZW50IGlzIGRlbGVnYXRlZCB0byB0aGUgcmlnaHQgb3ZlcmxheS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DYXB0dXJlRm9jdXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIG92ZXJsYXkgPSAvKiogQHR5cGUgez99ICovICh0aGlzLmN1cnJlbnRPdmVybGF5KCkpO1xuICAgIGlmIChvdmVybGF5KSB7XG4gICAgICBvdmVybGF5Ll9vbkNhcHR1cmVGb2N1cyhldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIFRBQiBhbmQgRVNDIGtleWJvYXJkIGV2ZW50cyBhcmUgZGVsZWdhdGVkIHRvIHRoZSByaWdodCBvdmVybGF5LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNhcHR1cmVLZXlEb3duOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBvdmVybGF5ID0gLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5jdXJyZW50T3ZlcmxheSgpKTtcbiAgICBpZiAob3ZlcmxheSkge1xuICAgICAgaWYgKElyb25BMTF5S2V5c0JlaGF2aW9yLmtleWJvYXJkRXZlbnRNYXRjaGVzS2V5cyhldmVudCwgJ2VzYycpKSB7XG4gICAgICAgIG92ZXJsYXkuX29uQ2FwdHVyZUVzYyhldmVudCk7XG4gICAgICB9IGVsc2UgaWYgKElyb25BMTF5S2V5c0JlaGF2aW9yLmtleWJvYXJkRXZlbnRNYXRjaGVzS2V5cyhldmVudCwgJ3RhYicpKSB7XG4gICAgICAgIG92ZXJsYXkuX29uQ2FwdHVyZVRhYihldmVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIHRoZSBvdmVybGF5MSBzaG91bGQgYmUgYmVoaW5kIG92ZXJsYXkyLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBvdmVybGF5MVxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBvdmVybGF5MlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Nob3VsZEJlQmVoaW5kT3ZlcmxheTogZnVuY3Rpb24ob3ZlcmxheTEsIG92ZXJsYXkyKSB7XG4gICAgcmV0dXJuICFvdmVybGF5MS5hbHdheXNPblRvcCAmJiBvdmVybGF5Mi5hbHdheXNPblRvcDtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IElyb25PdmVybGF5TWFuYWdlciA9IG5ldyBJcm9uT3ZlcmxheU1hbmFnZXJDbGFzcygpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lyb24tb3ZlcmxheS1tYW5hZ2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuUG9seW1lcih7XG4gIF90ZW1wbGF0ZTogYFxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWlyb24tb3ZlcmxheS1iYWNrZHJvcC1iYWNrZ3JvdW5kLWNvbG9yLCAjMDAwKTtcbiAgICAgICAgb3BhY2l0eTogMDtcbiAgICAgICAgdHJhbnNpdGlvbjogb3BhY2l0eSAwLjJzO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgQGFwcGx5IC0taXJvbi1vdmVybGF5LWJhY2tkcm9wO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCgub3BlbmVkKSB7XG4gICAgICAgIG9wYWNpdHk6IHZhcigtLWlyb24tb3ZlcmxheS1iYWNrZHJvcC1vcGFjaXR5LCAwLjYpO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICAgICAgQGFwcGx5IC0taXJvbi1vdmVybGF5LWJhY2tkcm9wLW9wZW5lZDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPHNsb3Q+PC9zbG90PlxuYCxcblxuICBpczogJ2lyb24tb3ZlcmxheS1iYWNrZHJvcCcsXG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBiYWNrZHJvcCBpcyBvcGVuZWQuXG4gICAgICovXG4gICAgb3BlbmVkOiB7XG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgb2JzZXJ2ZXI6ICdfb3BlbmVkQ2hhbmdlZCdcbiAgICB9XG5cbiAgfSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICAndHJhbnNpdGlvbmVuZCc6ICdfb25UcmFuc2l0aW9uZW5kJ1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVzZWQgdG8gY2FuY2VsIHByZXZpb3VzIHJlcXVlc3RBbmltYXRpb25GcmFtZSBjYWxscyB3aGVuIG9wZW5lZCBjaGFuZ2VzLlxuICAgIHRoaXMuX19vcGVuZWRSYWYgPSBudWxsO1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9wZW5lZCAmJiB0aGlzLl9vcGVuZWRDaGFuZ2VkKHRoaXMub3BlbmVkKTtcbiAgfSxcblxuICAvKipcbiAgICogQXBwZW5kcyB0aGUgYmFja2Ryb3AgdG8gZG9jdW1lbnQgYm9keSBpZiBuZWVkZWQuXG4gICAqL1xuICBwcmVwYXJlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcGVuZWQgJiYgIXRoaXMucGFyZW50Tm9kZSkge1xuICAgICAgZG9tKGRvY3VtZW50LmJvZHkpLmFwcGVuZENoaWxkKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogU2hvd3MgdGhlIGJhY2tkcm9wLlxuICAgKi9cbiAgb3BlbjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBIaWRlcyB0aGUgYmFja2Ryb3AuXG4gICAqL1xuICBjbG9zZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgYmFja2Ryb3AgZnJvbSBkb2N1bWVudCBib2R5IGlmIG5lZWRlZC5cbiAgICovXG4gIGNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMub3BlbmVkICYmIHRoaXMucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgZG9tKHRoaXMucGFyZW50Tm9kZSkucmVtb3ZlQ2hpbGQodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIF9vblRyYW5zaXRpb25lbmQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICYmIGV2ZW50LnRhcmdldCA9PT0gdGhpcykge1xuICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBvcGVuZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vcGVuZWRDaGFuZ2VkOiBmdW5jdGlvbihvcGVuZWQpIHtcbiAgICBpZiAob3BlbmVkKSB7XG4gICAgICAvLyBBdXRvLWF0dGFjaC5cbiAgICAgIHRoaXMucHJlcGFyZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBbmltYXRpb24gbWlnaHQgYmUgZGlzYWJsZWQgdmlhIHRoZSBtaXhpbiBvciBvcGFjaXR5IGN1c3RvbSBwcm9wZXJ0eS5cbiAgICAgIC8vIElmIGl0IGlzIGRpc2FibGVkIGluIG90aGVyIHdheXMsIGl0J3MgdXAgdG8gdGhlIHVzZXIgdG8gY2FsbCBjb21wbGV0ZS5cbiAgICAgIHZhciBjcyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpO1xuICAgICAgaWYgKGNzLnRyYW5zaXRpb25EdXJhdGlvbiA9PT0gJzBzJyB8fCBjcy5vcGFjaXR5ID09IDApIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQWx3YXlzIGNhbmNlbCBwcmV2aW91cyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG4gICAgaWYgKHRoaXMuX19vcGVuZWRSYWYpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9fb3BlbmVkUmFmKTtcbiAgICAgIHRoaXMuX19vcGVuZWRSYWYgPSBudWxsO1xuICAgIH1cbiAgICAvLyBGb3JjZSByZWxheW91dCB0byBlbnN1cmUgcHJvcGVyIHRyYW5zaXRpb25zLlxuICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7XG4gICAgdGhpcy5fX29wZW5lZFJhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl9fb3BlbmVkUmFmID0gbnVsbDtcbiAgICAgIHRoaXMudG9nZ2xlQ2xhc3MoJ29wZW5lZCcsIHRoaXMub3BlbmVkKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tb3ZlcmxheS1iZWhhdmlvci9pcm9uLW92ZXJsYXktYmFja2Ryb3AuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbnZhciBwID0gRWxlbWVudC5wcm90b3R5cGU7XG52YXIgbWF0Y2hlcyA9IHAubWF0Y2hlcyB8fCBwLm1hdGNoZXNTZWxlY3RvciB8fCBwLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICBwLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IHAub01hdGNoZXNTZWxlY3RvciB8fCBwLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuZXhwb3J0IGNvbnN0IElyb25Gb2N1c2FibGVzSGVscGVyID0ge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc29ydGVkIGFycmF5IG9mIHRhYmJhYmxlIG5vZGVzLCBpbmNsdWRpbmcgdGhlIHJvb3Qgbm9kZS5cbiAgICogSXQgc2VhcmNoZXMgdGhlIHRhYmJhYmxlIG5vZGVzIGluIHRoZSBsaWdodCBhbmQgc2hhZG93IGRvbSBvZiB0aGUgY2hpZHJlbixcbiAgICogc29ydGluZyB0aGUgcmVzdWx0IGJ5IHRhYmluZGV4LlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqIEByZXR1cm4ge0FycmF5PEhUTUxFbGVtZW50Pn1cbiAgICovXG4gIGdldFRhYmJhYmxlTm9kZXM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgLy8gSWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIGVsZW1lbnQgd2l0aCB0YWJpbmRleCA+IDAsIHdlIG5lZWQgdG8gc29ydFxuICAgIC8vIHRoZSBmaW5hbCBhcnJheSBieSB0YWJpbmRleC5cbiAgICB2YXIgbmVlZHNTb3J0QnlUYWJJbmRleCA9IHRoaXMuX2NvbGxlY3RUYWJiYWJsZU5vZGVzKG5vZGUsIHJlc3VsdCk7XG4gICAgaWYgKG5lZWRzU29ydEJ5VGFiSW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zb3J0QnlUYWJJbmRleChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIGEgZWxlbWVudCBpcyBmb2N1c2FibGUuXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0ZvY3VzYWJsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIC8vIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTYwMDE5NC80MjI4NzAzOlxuICAgIC8vIFRoZXJlIGlzbid0IGEgZGVmaW5pdGUgbGlzdCwgaXQncyB1cCB0byB0aGUgYnJvd3Nlci4gVGhlIG9ubHlcbiAgICAvLyBzdGFuZGFyZCB3ZSBoYXZlIGlzIERPTSBMZXZlbCAyIEhUTUwgaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUhUTUwvaHRtbC5odG1sLFxuICAgIC8vIGFjY29yZGluZyB0byB3aGljaCB0aGUgb25seSBlbGVtZW50cyB0aGF0IGhhdmUgYSBmb2N1cygpIG1ldGhvZCBhcmVcbiAgICAvLyBIVE1MSW5wdXRFbGVtZW50LCAgSFRNTFNlbGVjdEVsZW1lbnQsIEhUTUxUZXh0QXJlYUVsZW1lbnQgYW5kXG4gICAgLy8gSFRNTEFuY2hvckVsZW1lbnQuIFRoaXMgbm90YWJseSBvbWl0cyBIVE1MQnV0dG9uRWxlbWVudCBhbmRcbiAgICAvLyBIVE1MQXJlYUVsZW1lbnQuXG4gICAgLy8gUmVmZXJyaW5nIHRvIHRoZXNlIHRlc3RzIHdpdGggdGFiYmFibGVzIGluIGRpZmZlcmVudCBicm93c2Vyc1xuICAgIC8vIGh0dHA6Ly9hbGx5anMuaW8vZGF0YS10YWJsZXMvZm9jdXNhYmxlLmh0bWxcblxuICAgIC8vIEVsZW1lbnRzIHRoYXQgY2Fubm90IGJlIGZvY3VzZWQgaWYgdGhleSBoYXZlIFtkaXNhYmxlZF0gYXR0cmlidXRlLlxuICAgIGlmIChtYXRjaGVzLmNhbGwoZWxlbWVudCwgJ2lucHV0LCBzZWxlY3QsIHRleHRhcmVhLCBidXR0b24sIG9iamVjdCcpKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsICc6bm90KFtkaXNhYmxlZF0pJyk7XG4gICAgfVxuICAgIC8vIEVsZW1lbnRzIHRoYXQgY2FuIGJlIGZvY3VzZWQgZXZlbiBpZiB0aGV5IGhhdmUgW2Rpc2FibGVkXSBhdHRyaWJ1dGUuXG4gICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbGVtZW50LFxuICAgICAgJ2FbaHJlZl0sIGFyZWFbaHJlZl0sIGlmcmFtZSwgW3RhYmluZGV4XSwgW2NvbnRlbnRFZGl0YWJsZV0nKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBpZiBhIGVsZW1lbnQgaXMgdGFiYmFibGUuIFRvIGJlIHRhYmJhYmxlLCBhIGVsZW1lbnQgbXVzdCBiZVxuICAgKiBmb2N1c2FibGUsIHZpc2libGUsIGFuZCB3aXRoIGEgdGFiaW5kZXggIT09IC0xLlxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNUYWJiYWJsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIHJldHVybiB0aGlzLmlzRm9jdXNhYmxlKGVsZW1lbnQpICYmXG4gICAgICBtYXRjaGVzLmNhbGwoZWxlbWVudCwgJzpub3QoW3RhYmluZGV4PVwiLTFcIl0pJykgJiZcbiAgICAgIHRoaXMuX2lzVmlzaWJsZShlbGVtZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9ybWFsaXplZCBlbGVtZW50IHRhYmluZGV4LiBJZiBub3QgZm9jdXNhYmxlLCByZXR1cm5zIC0xLlxuICAgKiBJdCBjaGVja3MgZm9yIHRoZSBhdHRyaWJ1dGUgXCJ0YWJpbmRleFwiIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgcHJvcGVydHlcbiAgICogYHRhYkluZGV4YCBzaW5jZSBicm93c2VycyBhc3NpZ24gZGlmZmVyZW50IHZhbHVlcyB0byBpdC5cbiAgICogZS5nLiBpbiBGaXJlZm94IGA8ZGl2IGNvbnRlbnRlZGl0YWJsZT5gIGhhcyBgdGFiSW5kZXggPSAtMWBcbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7IW51bWJlcn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ub3JtYWxpemVkVGFiSW5kZXg6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5pc0ZvY3VzYWJsZShlbGVtZW50KSkge1xuICAgICAgdmFyIHRhYkluZGV4ID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykgfHwgMDtcbiAgICAgIHJldHVybiBOdW1iZXIodGFiSW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNlYXJjaGVzIGZvciBub2RlcyB0aGF0IGFyZSB0YWJiYWJsZSBhbmQgYWRkcyB0aGVtIHRvIHRoZSBgcmVzdWx0YCBhcnJheS5cbiAgICogUmV0dXJucyBpZiB0aGUgYHJlc3VsdGAgYXJyYXkgbmVlZHMgdG8gYmUgc29ydGVkIGJ5IHRhYmluZGV4LlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlIFRoZSBzdGFydGluZyBwb2ludCBmb3IgdGhlIHNlYXJjaDsgYWRkZWQgdG8gYHJlc3VsdGBcbiAgICogaWYgdGFiYmFibGUuXG4gICAqIEBwYXJhbSB7IUFycmF5PEhUTUxFbGVtZW50Pn0gcmVzdWx0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29sbGVjdFRhYmJhYmxlTm9kZXM6IGZ1bmN0aW9uKG5vZGUsIHJlc3VsdCkge1xuICAgIC8vIElmIG5vdCBhbiBlbGVtZW50IG9yIG5vdCB2aXNpYmxlLCBubyBuZWVkIHRvIGV4cGxvcmUgY2hpbGRyZW4uXG4gICAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFIHx8ICF0aGlzLl9pc1Zpc2libGUobm9kZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyAobm9kZSk7XG4gICAgdmFyIHRhYkluZGV4ID0gdGhpcy5fbm9ybWFsaXplZFRhYkluZGV4KGVsZW1lbnQpO1xuICAgIHZhciBuZWVkc1NvcnQgPSB0YWJJbmRleCA+IDA7XG4gICAgaWYgKHRhYkluZGV4ID49IDApIHtcbiAgICAgIHJlc3VsdC5wdXNoKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIC8vIEluIFNoYWRvd0RPTSB2MSwgdGFiIG9yZGVyIGlzIGFmZmVjdGVkIGJ5IHRoZSBvcmRlciBvZiBkaXN0cnVidXRpb24uXG4gICAgLy8gRS5nLiBnZXRUYWJiYWJsZU5vZGVzKCNyb290KSBpbiBTaGFkb3dET00gdjEgc2hvdWxkIHJldHVybiBbI0EsICNCXTtcbiAgICAvLyBpbiBTaGFkb3dET00gdjAgdGFiIG9yZGVyIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgZGlzdHJ1YnV0aW9uIG9yZGVyLFxuICAgIC8vIGluIGZhY3QgZ2V0VGFiYmFibGVOb2Rlcygjcm9vdCkgcmV0dXJucyBbI0IsICNBXS5cbiAgICAvLyAgPGRpdiBpZD1cInJvb3RcIj5cbiAgICAvLyAgIDwhLS0gc2hhZG93IC0tPlxuICAgIC8vICAgICA8c2xvdCBuYW1lPVwiYVwiPlxuICAgIC8vICAgICA8c2xvdCBuYW1lPVwiYlwiPlxuICAgIC8vICAgPCEtLSAvc2hhZG93IC0tPlxuICAgIC8vICAgPGlucHV0IGlkPVwiQVwiIHNsb3Q9XCJhXCI+XG4gICAgLy8gICA8aW5wdXQgaWQ9XCJCXCIgc2xvdD1cImJcIiB0YWJpbmRleD1cIjFcIj5cbiAgICAvLyAgPC9kaXY+XG4gICAgLy8gVE9ETyh2YWxkcmluKSBzdXBwb3J0IFNoYWRvd0RPTSB2MSB3aGVuIHVwZ3JhZGluZyB0byBQb2x5bWVyIHYyLjAuXG4gICAgdmFyIGNoaWxkcmVuO1xuICAgIGlmIChlbGVtZW50LmxvY2FsTmFtZSA9PT0gJ2NvbnRlbnQnIHx8IGVsZW1lbnQubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICAgIGNoaWxkcmVuID0gZG9tKGVsZW1lbnQpLmdldERpc3RyaWJ1dGVkTm9kZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXNlIHNoYWRvdyByb290IGlmIHBvc3NpYmxlLCB3aWxsIGNoZWNrIGZvciBkaXN0cmlidXRlZCBub2Rlcy5cbiAgICAgIGNoaWxkcmVuID0gZG9tKGVsZW1lbnQucm9vdCB8fCBlbGVtZW50KS5jaGlsZHJlbjtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgLy8gRW5zdXJlIG1ldGhvZCBpcyBhbHdheXMgaW52b2tlZCB0byBjb2xsZWN0IHRhYmJhYmxlIGNoaWxkcmVuLlxuICAgICAgbmVlZHNTb3J0ID0gdGhpcy5fY29sbGVjdFRhYmJhYmxlTm9kZXMoY2hpbGRyZW5baV0sIHJlc3VsdCkgfHwgbmVlZHNTb3J0O1xuICAgIH1cbiAgICByZXR1cm4gbmVlZHNTb3J0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGZhbHNlIGlmIHRoZSBlbGVtZW50IGhhcyBgdmlzaWJpbGl0eTogaGlkZGVuYCBvciBgZGlzcGxheTogbm9uZWBcbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc1Zpc2libGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAvLyBDaGVjayBpbmxpbmUgc3R5bGUgZmlyc3QgdG8gc2F2ZSBhIHJlLWZsb3cuIElmIGxvb2tzIGdvb2QsIGNoZWNrIGFsc29cbiAgICAvLyBjb21wdXRlZCBzdHlsZS5cbiAgICB2YXIgc3R5bGUgPSBlbGVtZW50LnN0eWxlO1xuICAgIGlmIChzdHlsZS52aXNpYmlsaXR5ICE9PSAnaGlkZGVuJyAmJiBzdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgIHN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgICByZXR1cm4gKHN0eWxlLnZpc2liaWxpdHkgIT09ICdoaWRkZW4nICYmIHN0eWxlLmRpc3BsYXkgIT09ICdub25lJyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogU29ydHMgYW4gYXJyYXkgb2YgdGFiYmFibGUgZWxlbWVudHMgYnkgdGFiaW5kZXguIFJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAqIEBwYXJhbSB7IUFycmF5PEhUTUxFbGVtZW50Pn0gdGFiYmFibGVzXG4gICAqIEByZXR1cm4ge0FycmF5PEhUTUxFbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zb3J0QnlUYWJJbmRleDogZnVuY3Rpb24odGFiYmFibGVzKSB7XG4gICAgLy8gSW1wbGVtZW50IGEgbWVyZ2Ugc29ydCBhcyBBcnJheS5wcm90b3R5cGUuc29ydCBkb2VzIGEgbm9uLXN0YWJsZSBzb3J0XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvc29ydFxuICAgIHZhciBsZW4gPSB0YWJiYWJsZXMubGVuZ3RoO1xuICAgIGlmIChsZW4gPCAyKSB7XG4gICAgICByZXR1cm4gdGFiYmFibGVzO1xuICAgIH1cbiAgICB2YXIgcGl2b3QgPSBNYXRoLmNlaWwobGVuIC8gMik7XG4gICAgdmFyIGxlZnQgPSB0aGlzLl9zb3J0QnlUYWJJbmRleCh0YWJiYWJsZXMuc2xpY2UoMCwgcGl2b3QpKTtcbiAgICB2YXIgcmlnaHQgPSB0aGlzLl9zb3J0QnlUYWJJbmRleCh0YWJiYWJsZXMuc2xpY2UocGl2b3QpKTtcbiAgICByZXR1cm4gdGhpcy5fbWVyZ2VTb3J0QnlUYWJJbmRleChsZWZ0LCByaWdodCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lcmdlIHNvcnQgaXRlcmF0b3IsIG1lcmdlcyB0aGUgdHdvIGFycmF5cyBpbnRvIG9uZSwgc29ydGVkIGJ5IHRhYiBpbmRleC5cbiAgICogQHBhcmFtIHshQXJyYXk8SFRNTEVsZW1lbnQ+fSBsZWZ0XG4gICAqIEBwYXJhbSB7IUFycmF5PEhUTUxFbGVtZW50Pn0gcmlnaHRcbiAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21lcmdlU29ydEJ5VGFiSW5kZXg6IGZ1bmN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlICgobGVmdC5sZW5ndGggPiAwKSAmJiAocmlnaHQubGVuZ3RoID4gMCkpIHtcbiAgICAgIGlmICh0aGlzLl9oYXNMb3dlclRhYk9yZGVyKGxlZnRbMF0sIHJpZ2h0WzBdKSkge1xuICAgICAgICByZXN1bHQucHVzaChyaWdodC5zaGlmdCgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGxlZnQuc2hpZnQoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC5jb25jYXQobGVmdCwgcmlnaHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIGVsZW1lbnQgYGFgIGhhcyBsb3dlciB0YWIgb3JkZXIgY29tcGFyZWQgdG8gZWxlbWVudCBgYmBcbiAgICogKGJvdGggZWxlbWVudHMgYXJlIGFzc3VtZWQgdG8gYmUgZm9jdXNhYmxlIGFuZCB0YWJiYWJsZSkuXG4gICAqIEVsZW1lbnRzIHdpdGggdGFiaW5kZXggPSAwIGhhdmUgbG93ZXIgdGFiIG9yZGVyIGNvbXBhcmVkIHRvIGVsZW1lbnRzXG4gICAqIHdpdGggdGFiaW5kZXggPiAwLlxuICAgKiBJZiBib3RoIGhhdmUgc2FtZSB0YWJpbmRleCwgaXQgcmV0dXJucyBmYWxzZS5cbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGFcbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9oYXNMb3dlclRhYk9yZGVyOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgLy8gTm9ybWFsaXplIHRhYkluZGV4ZXNcbiAgICAvLyBlLmcuIGluIEZpcmVmb3ggYDxkaXYgY29udGVudGVkaXRhYmxlPmAgaGFzIGB0YWJJbmRleCA9IC0xYFxuICAgIHZhciBhdGkgPSBNYXRoLm1heChhLnRhYkluZGV4LCAwKTtcbiAgICB2YXIgYnRpID0gTWF0aC5tYXgoYi50YWJJbmRleCwgMCk7XG4gICAgcmV0dXJuIChhdGkgPT09IDAgfHwgYnRpID09PSAwKSA/IGJ0aSA+IGF0aSA6IGF0aSA+IGJ0aTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tb3ZlcmxheS1iZWhhdmlvci9pcm9uLWZvY3VzYWJsZXMtaGVscGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA4MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL3R5cG9ncmFwaHkuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvc2hhZG93LmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8ZG9tLW1vZHVsZSBpZD1cInBhcGVyLWRpYWxvZy1zaGFyZWQtc3R5bGVzXCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBtYXJnaW46IDI0cHggNDBweDtcblxuICAgICAgICBiYWNrZ3JvdW5kOiB2YXIoLS1wYXBlci1kaWFsb2ctYmFja2dyb3VuZC1jb2xvciwgdmFyKC0tcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yKSk7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1kaWFsb2ctY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtYm9keTE7XG4gICAgICAgIEBhcHBseSAtLXNoYWRvdy1lbGV2YXRpb24tMTZkcDtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZGlhbG9nO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA+IDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIG1hcmdpbi10b3A6IDIwcHg7XG4gICAgICAgIHBhZGRpbmc6IDAgMjRweDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgPiA6OnNsb3R0ZWQoLm5vLXBhZGRpbmcpIHtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgIH1cblxuICAgICAgLyogSW4gMS54LCB0aGlzIHNlbGVjdG9yIHdhcyBcXGA6aG9zdCA+IDo6Y29udGVudCBoMlxcYC4gSW4gMi54IDxzbG90PiBhbGxvd3NcbiAgICAgIHRvIHNlbGVjdCBkaXJlY3QgY2hpbGRyZW4gb25seSwgd2hpY2ggaW5jcmVhc2VzIHRoZSB3ZWlnaHQgb2YgdGhpc1xuICAgICAgc2VsZWN0b3IsIHNvIHdlIGhhdmUgdG8gbW92ZSBpdCBiZWZvcmUgZmlyc3QtY2hpbGQvbGFzdC1jaGlsZCBzZWxlY3RvcnMgKi9cbiAgICAgIDpob3N0ID4gOjpzbG90dGVkKGgyKSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgbWFyZ2luOiAwO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtdGl0bGU7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWRpYWxvZy10aXRsZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgPiA6OnNsb3R0ZWQoKjpmaXJzdC1jaGlsZCkge1xuICAgICAgICBtYXJnaW4tdG9wOiAyNHB4O1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA+IDo6c2xvdHRlZCgqOmxhc3QtY2hpbGQpIHtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMjRweDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgPiA6OnNsb3R0ZWQoLmJ1dHRvbnMpIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBwYWRkaW5nOiA4cHggOHB4IDhweCAyNHB4O1xuICAgICAgICBtYXJnaW46IDA7XG5cbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWRpYWxvZy1idXR0b24tY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtaG9yaXpvbnRhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWVuZC1qdXN0aWZpZWQ7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgPC90ZW1wbGF0ZT5cbjwvZG9tLW1vZHVsZT5gO1xuXG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItZGlhbG9nLWJlaGF2aW9yL3BhcGVyLWRpYWxvZy1zaGFyZWQtc3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgXG48bGluayByZWw9XCJzdHlsZXNoZWV0XCIgdHlwZT1cInRleHQvY3NzXCIgaHJlZj1cImh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vY3NzP2ZhbWlseT1Sb2JvdG8rTW9ubzo0MDAsNzAwfFJvYm90bzo0MDAsMzAwLDMwMGl0YWxpYyw0MDBpdGFsaWMsNTAwLDUwMGl0YWxpYyw3MDAsNzAwaXRhbGljXCIgY3Jvc3NvcmlnaW49XCJhbm9ueW1vdXNcIj5cbmA7XG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvZm9udC1yb2JvdG8vcm9ib3RvLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyc7XG5pbXBvcnQgeyBQYXBlckJ1dHRvbkJlaGF2aW9yLCBQYXBlckJ1dHRvbkJlaGF2aW9ySW1wbCB9IGZyb20gJy4uL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1idXR0b24tYmVoYXZpb3IuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvZWxlbWVudC1zdHlsZXMvcGFwZXItbWF0ZXJpYWwtc3R5bGVzLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci1idXR0b25cIj5cbiAgPHRlbXBsYXRlIHN0cmlwLXdoaXRlc3BhY2U9XCJcIj5cbiAgICA8c3R5bGUgaW5jbHVkZT1cInBhcGVyLW1hdGVyaWFsLXN0eWxlc1wiPlxuICAgICAgLyogTmVlZCB0byBzcGVjaWZ5IHRoZSBzYW1lIHNwZWNpZmljaXR5IGFzIHRoZSBzdHlsZXMgaW1wb3J0ZWQgZnJvbSBwYXBlci1tYXRlcmlhbC4gKi9cbiAgICAgIDpob3N0IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWlubGluZTtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlci1jZW50ZXI7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgbWluLXdpZHRoOiA1LjE0ZW07XG4gICAgICAgIG1hcmdpbjogMCAwLjI5ZW07XG4gICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHJnYmEoMCwgMCwgMCwgMCk7XG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICAgIGZvbnQ6IGluaGVyaXQ7XG4gICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgICAgIG91dGxpbmUtd2lkdGg6IDA7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDNweDtcbiAgICAgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICB6LWluZGV4OiAwO1xuICAgICAgICBwYWRkaW5nOiAwLjdlbSAwLjU3ZW07XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItYnV0dG9uO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZWxldmF0aW9uPVwiMVwiXSkge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tMTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2VsZXZhdGlvbj1cIjJcIl0pIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTI7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtlbGV2YXRpb249XCIzXCJdKSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi0zO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZWxldmF0aW9uPVwiNFwiXSkge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tNDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2VsZXZhdGlvbj1cIjVcIl0pIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW3JhaXNlZF0ua2V5Ym9hcmQtZm9jdXMpIHtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWJ1dHRvbi1yYWlzZWQta2V5Ym9hcmQtZm9jdXM7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KDpub3QoW3JhaXNlZF0pLmtleWJvYXJkLWZvY3VzKSB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1idXR0b24tZmxhdC1rZXlib2FyZC1mb2N1cztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkge1xuICAgICAgICBiYWNrZ3JvdW5kOiAjZWFlYWVhO1xuICAgICAgICBjb2xvcjogI2E4YThhODtcbiAgICAgICAgY3Vyc29yOiBhdXRvO1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1idXR0b24tZGlzYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFthbmltYXRlZF0pIHtcbiAgICAgICAgQGFwcGx5IC0tc2hhZG93LXRyYW5zaXRpb247XG4gICAgICB9XG5cbiAgICAgIHBhcGVyLXJpcHBsZSB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1idXR0b24taW5rLWNvbG9yKTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPHNsb3Q+PC9zbG90PlxuICA8L3RlbXBsYXRlPlxuXG4gIFxuPC9kb20tbW9kdWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5Qb2x5bWVyKHtcbiAgaXM6ICdwYXBlci1idXR0b24nLFxuXG4gIGJlaGF2aW9yczogW1xuICAgIFBhcGVyQnV0dG9uQmVoYXZpb3JcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJ1dHRvbiBzaG91bGQgYmUgc3R5bGVkIHdpdGggYSBzaGFkb3cuXG4gICAgICovXG4gICAgcmFpc2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgb2JzZXJ2ZXI6ICdfY2FsY3VsYXRlRWxldmF0aW9uJ1xuICAgIH1cbiAgfSxcblxuICBfY2FsY3VsYXRlRWxldmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMucmFpc2VkKSB7XG4gICAgICB0aGlzLl9zZXRFbGV2YXRpb24oMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFBhcGVyQnV0dG9uQmVoYXZpb3JJbXBsLl9jYWxjdWxhdGVFbGV2YXRpb24uYXBwbHkodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gIEZpcmVkIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlcy5cbiAgVGhpcyBpcyB1c2VmdWwgaWYgeW91IHdhbnQgdG8gd2FpdCB1bnRpbFxuICB0aGUgcmlwcGxlIGFuaW1hdGlvbiBmaW5pc2hlcyB0byBwZXJmb3JtIHNvbWUgYWN0aW9uLlxuXG4gIEBldmVudCB0cmFuc2l0aW9uZW5kXG4gIEV2ZW50IHBhcmFtOiB7e25vZGU6IE9iamVjdH19IGRldGFpbCBDb250YWlucyB0aGUgYW5pbWF0ZWQgbm9kZS5cbiAgKi9cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYnV0dG9uL3BhcGVyLWJ1dHRvbi5qc1xuLy8gbW9kdWxlIGlkID0gODVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkJ1dHRvblN0YXRlSW1wbCwgSXJvbkJ1dHRvblN0YXRlIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanMnO1xuaW1wb3J0IHsgUGFwZXJSaXBwbGVCZWhhdmlvciB9IGZyb20gJy4vcGFwZXItcmlwcGxlLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IElyb25Db250cm9sU3RhdGUgfSBmcm9tICcuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWNvbnRyb2wtc3RhdGUuanMnO1xuXG5leHBvcnQgY29uc3QgUGFwZXJCdXR0b25CZWhhdmlvckltcGwgPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgei1kZXB0aCBvZiB0aGlzIGVsZW1lbnQsIGZyb20gMC01LiBTZXR0aW5nIHRvIDAgd2lsbCByZW1vdmUgdGhlXG4gICAgICogc2hhZG93LCBhbmQgZWFjaCBpbmNyZWFzaW5nIG51bWJlciBncmVhdGVyIHRoYW4gMCB3aWxsIGJlIFwiZGVlcGVyXCJcbiAgICAgKiB0aGFuIHRoZSBsYXN0LlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSBlbGV2YXRpb25cbiAgICAgKiBAdHlwZSBudW1iZXJcbiAgICAgKiBAZGVmYXVsdCAxXG4gICAgICovXG4gICAgZWxldmF0aW9uOiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICByZWFkT25seTogdHJ1ZVxuICAgIH1cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX2NhbGN1bGF0ZUVsZXZhdGlvbihmb2N1c2VkLCBkaXNhYmxlZCwgYWN0aXZlLCBwcmVzc2VkLCByZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKScsXG4gICAgJ19jb21wdXRlS2V5Ym9hcmRDbGFzcyhyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSdcbiAgXSxcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgIHJvbGU6ICdidXR0b24nLFxuICAgIHRhYmluZGV4OiAnMCcsXG4gICAgYW5pbWF0ZWQ6IHRydWVcbiAgfSxcblxuICBfY2FsY3VsYXRlRWxldmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgZSA9IDE7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIGUgPSAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hY3RpdmUgfHwgdGhpcy5wcmVzc2VkKSB7XG4gICAgICBlID0gNDtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCkge1xuICAgICAgZSA9IDM7XG4gICAgfVxuICAgIHRoaXMuX3NldEVsZXZhdGlvbihlKTtcbiAgfSxcblxuICBfY29tcHV0ZUtleWJvYXJkQ2xhc3M6IGZ1bmN0aW9uKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpIHtcbiAgICB0aGlzLnRvZ2dsZUNsYXNzKCdrZXlib2FyZC1mb2N1cycsIHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbiBhZGRpdGlvbiB0byBgSXJvbkJ1dHRvblN0YXRlYCBiZWhhdmlvciwgd2hlbiBzcGFjZSBrZXkgZ29lcyBkb3duLFxuICAgKiBjcmVhdGUgYSByaXBwbGUgZG93biBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGV2ZW50IC5cbiAgICovXG4gIF9zcGFjZUtleURvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIElyb25CdXR0b25TdGF0ZUltcGwuX3NwYWNlS2V5RG93bkhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgLy8gRW5zdXJlIHRoYXQgdGhlcmUgaXMgYXQgbW9zdCBvbmUgcmlwcGxlIHdoZW4gdGhlIHNwYWNlIGtleSBpcyBoZWxkIGRvd24uXG4gICAgaWYgKHRoaXMuaGFzUmlwcGxlKCkgJiYgdGhpcy5nZXRSaXBwbGUoKS5yaXBwbGVzLmxlbmd0aCA8IDEpIHtcbiAgICAgIHRoaXMuX3JpcHBsZS51aURvd25BY3Rpb24oKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluIGFkZGl0aW9uIHRvIGBJcm9uQnV0dG9uU3RhdGVgIGJlaGF2aW9yLCB3aGVuIHNwYWNlIGtleSBnb2VzIHVwLFxuICAgKiBjcmVhdGUgYSByaXBwbGUgdXAgZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldmVudCAuXG4gICAqL1xuICBfc3BhY2VLZXlVcEhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgSXJvbkJ1dHRvblN0YXRlSW1wbC5fc3BhY2VLZXlVcEhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgaWYgKHRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgIHRoaXMuX3JpcHBsZS51aVVwQWN0aW9uKCk7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgUGFwZXJCdXR0b25CZWhhdmlvciA9IFtcbiAgSXJvbkJ1dHRvblN0YXRlLFxuICBJcm9uQ29udHJvbFN0YXRlLFxuICBQYXBlclJpcHBsZUJlaGF2aW9yLFxuICBQYXBlckJ1dHRvbkJlaGF2aW9ySW1wbFxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1idXR0b24tYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDg2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi4vc2hhZG93LmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8ZG9tLW1vZHVsZSBpZD1cInBhcGVyLW1hdGVyaWFsLXN0eWxlc1wiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3QsIGh0bWwge1xuICAgICAgICAtLXBhcGVyLW1hdGVyaWFsOiB7XG4gICAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB9O1xuICAgICAgICAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi0xOiB7XG4gICAgICAgICAgQGFwcGx5IC0tc2hhZG93LWVsZXZhdGlvbi0yZHA7XG4gICAgICAgIH07XG4gICAgICAgIC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTI6IHtcbiAgICAgICAgICBAYXBwbHkgLS1zaGFkb3ctZWxldmF0aW9uLTRkcDtcbiAgICAgICAgfTtcbiAgICAgICAgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tMzoge1xuICAgICAgICAgIEBhcHBseSAtLXNoYWRvdy1lbGV2YXRpb24tNmRwO1xuICAgICAgICB9O1xuICAgICAgICAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi00OiB7XG4gICAgICAgICAgQGFwcGx5IC0tc2hhZG93LWVsZXZhdGlvbi04ZHA7XG4gICAgICAgIH07XG4gICAgICAgIC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTU6IHtcbiAgICAgICAgICBAYXBwbHkgLS1zaGFkb3ctZWxldmF0aW9uLTE2ZHA7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICA6aG9zdCgucGFwZXItbWF0ZXJpYWwpLCAucGFwZXItbWF0ZXJpYWwge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbDtcbiAgICAgIH1cbiAgICAgIDpob3N0KC5wYXBlci1tYXRlcmlhbFtlbGV2YXRpb249XCIxXCJdKSwgLnBhcGVyLW1hdGVyaWFsW2VsZXZhdGlvbj1cIjFcIl0ge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tMTtcbiAgICAgIH1cbiAgICAgIDpob3N0KC5wYXBlci1tYXRlcmlhbFtlbGV2YXRpb249XCIyXCJdKSwgLnBhcGVyLW1hdGVyaWFsW2VsZXZhdGlvbj1cIjJcIl0ge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tMjtcbiAgICAgIH1cbiAgICAgIDpob3N0KC5wYXBlci1tYXRlcmlhbFtlbGV2YXRpb249XCIzXCJdKSwgLnBhcGVyLW1hdGVyaWFsW2VsZXZhdGlvbj1cIjNcIl0ge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tMztcbiAgICAgIH1cbiAgICAgIDpob3N0KC5wYXBlci1tYXRlcmlhbFtlbGV2YXRpb249XCI0XCJdKSwgLnBhcGVyLW1hdGVyaWFsW2VsZXZhdGlvbj1cIjRcIl0ge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tNDtcbiAgICAgIH1cbiAgICAgIDpob3N0KC5wYXBlci1tYXRlcmlhbFtlbGV2YXRpb249XCI1XCJdKSwgLnBhcGVyLW1hdGVyaWFsW2VsZXZhdGlvbj1cIjVcIl0ge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tNTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICA8L3RlbXBsYXRlPlxuPC9kb20tbW9kdWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvZWxlbWVudC1zdHlsZXMvcGFwZXItbWF0ZXJpYWwtc3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL2lyb24taWNvbi9pcm9uLWljb24uanMnO1xuaW1wb3J0IHsgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciB9IGZyb20gJy4uL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8ZG9tLW1vZHVsZSBpZD1cInBhcGVyLWljb24tYnV0dG9uXCI+XG4gIDx0ZW1wbGF0ZSBzdHJpcC13aGl0ZXNwYWNlPVwiXCI+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgcGFkZGluZzogOHB4O1xuICAgICAgICBvdXRsaW5lOiBub25lO1xuICAgICAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxO1xuXG4gICAgICAgIHdpZHRoOiA0MHB4O1xuICAgICAgICBoZWlnaHQ6IDQwcHg7XG5cbiAgICAgICAgLyogTk9URTogQm90aCB2YWx1ZXMgYXJlIG5lZWRlZCwgc2luY2Ugc29tZSBwaG9uZXMgcmVxdWlyZSB0aGUgdmFsdWUgdG8gYmUgXFxgdHJhbnNwYXJlbnRcXGAuICovXG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcblxuICAgICAgICAvKiBCZWNhdXNlIG9mIHBvbHltZXIvMjU1OCwgdGhpcyBzdHlsZSBoYXMgbG93ZXIgc3BlY2lmaWNpdHkgdGhhbiAqICovXG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3ggIWltcG9ydGFudDtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pY29uLWJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgI2luayB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pY29uLWJ1dHRvbi1pbmstY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBvcGFjaXR5OiAwLjY7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWljb24tYnV0dG9uLWRpc2FibGVkLXRleHQsIHZhcigtLWRpc2FibGVkLXRleHQtY29sb3IpKTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIGN1cnNvcjogYXV0bztcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pY29uLWJ1dHRvbi1kaXNhYmxlZDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICA6aG9zdCg6aG92ZXIpIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaWNvbi1idXR0b24taG92ZXI7XG4gICAgICB9XG5cbiAgICAgIGlyb24taWNvbiB7XG4gICAgICAgIC0taXJvbi1pY29uLXdpZHRoOiAxMDAlO1xuICAgICAgICAtLWlyb24taWNvbi1oZWlnaHQ6IDEwMCU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxpcm9uLWljb24gaWQ9XCJpY29uXCIgc3JjPVwiW1tzcmNdXVwiIGljb249XCJbW2ljb25dXVwiIGFsdFxcJD1cIltbYWx0XV1cIj48L2lyb24taWNvbj5cbiAgPC90ZW1wbGF0ZT5cblxuICBcbjwvZG9tLW1vZHVsZT5gO1xuXG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuUG9seW1lcih7XG4gIGlzOiAncGFwZXItaWNvbi1idXR0b24nLFxuXG4gIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgcm9sZTogJ2J1dHRvbicsXG4gICAgdGFiaW5kZXg6ICcwJ1xuICB9LFxuXG4gIGJlaGF2aW9yczogW1xuICAgIFBhcGVySW5reUZvY3VzQmVoYXZpb3JcbiAgXSxcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIFVSTCBvZiBhbiBpbWFnZSBmb3IgdGhlIGljb24uIElmIHRoZSBzcmMgcHJvcGVydHkgaXMgc3BlY2lmaWVkLFxuICAgICAqIHRoZSBpY29uIHByb3BlcnR5IHNob3VsZCBub3QgYmUuXG4gICAgICovXG4gICAgc3JjOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBpY29uIG5hbWUgb3IgaW5kZXggaW4gdGhlIHNldCBvZiBpY29ucyBhdmFpbGFibGUgaW5cbiAgICAgKiB0aGUgaWNvbidzIGljb24gc2V0LiBJZiB0aGUgaWNvbiBwcm9wZXJ0eSBpcyBzcGVjaWZpZWQsXG4gICAgICogdGhlIHNyYyBwcm9wZXJ0eSBzaG91bGQgbm90IGJlLlxuICAgICAqL1xuICAgIGljb246IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgdGhlIGFsdGVybmF0ZSB0ZXh0IGZvciB0aGUgYnV0dG9uLCBmb3IgYWNjZXNzaWJpbGl0eS5cbiAgICAgKi9cbiAgICBhbHQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIG9ic2VydmVyOiBcIl9hbHRDaGFuZ2VkXCJcbiAgICB9XG4gIH0sXG5cbiAgX2FsdENoYW5nZWQ6IGZ1bmN0aW9uKG5ld1ZhbHVlLCBvbGRWYWx1ZSkge1xuICAgIHZhciBsYWJlbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJyk7XG5cbiAgICAvLyBEb24ndCBzdG9tcCBvdmVyIGEgdXNlci1zZXQgYXJpYS1sYWJlbC5cbiAgICBpZiAoIWxhYmVsIHx8IG9sZFZhbHVlID09IGxhYmVsKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIG5ld1ZhbHVlKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaWNvbi1idXR0b24vcGFwZXItaWNvbi1idXR0b24uanNcbi8vIG1vZHVsZSBpZCA9IDg4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25Gb3JtRWxlbWVudEJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuaW1wb3J0ICcuLi9pcm9uLWlucHV0L2lyb24taW5wdXQuanMnO1xuaW1wb3J0IHsgUGFwZXJJbnB1dEJlaGF2aW9yIH0gZnJvbSAnLi9wYXBlci1pbnB1dC1iZWhhdmlvci5qcyc7XG5pbXBvcnQgJy4vcGFwZXItaW5wdXQtY2hhci1jb3VudGVyLmpzJztcbmltcG9ydCAnLi9wYXBlci1pbnB1dC1jb250YWluZXIuanMnO1xuaW1wb3J0ICcuL3BhcGVyLWlucHV0LWVycm9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQgeyBEb21Nb2R1bGUgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tbW9kdWxlLmpzJztcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci1pbnB1dFwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2ZvY3VzZWRdKSB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgaW5wdXQge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7IC8qIHRvIG1ha2UgYSBzdGFja2luZyBjb250ZXh0ICovXG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQtY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gICAgICAgIHRleHQtYWxpZ246IGluaGVyaXQ7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBib3R0b207XG5cbiAgICAgICAgLyogRmlyZWZveCBzZXRzIGEgbWluLXdpZHRoIG9uIHRoZSBpbnB1dCwgd2hpY2ggY2FuIGNhdXNlIGxheW91dCBpc3N1ZXMgKi9cbiAgICAgICAgbWluLXdpZHRoOiAwO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtc3ViaGVhZDtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWlucHV0O1xuICAgICAgfVxuXG4gICAgICBpbnB1dDo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcbiAgICAgIGlucHV0Ojotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWlucHV0LXdlYmtpdC1zcGlubmVyO1xuICAgICAgfVxuXG4gICAgICBpbnB1dDo6LXdlYmtpdC1jbGVhci1idXR0b24ge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQtd2Via2l0LWNsZWFyO1xuICAgICAgfVxuXG4gICAgICBpbnB1dDo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItY29sb3IsIHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIGlucHV0Oi1tb3otcGxhY2Vob2xkZXIge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWNvbG9yLCB2YXIoLS1zZWNvbmRhcnktdGV4dC1jb2xvcikpO1xuICAgICAgfVxuXG4gICAgICBpbnB1dDo6LW1vei1wbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItY29sb3IsIHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIGlucHV0OjotbXMtY2xlYXIge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItbXMtY2xlYXI7XG4gICAgICB9XG5cbiAgICAgIGlucHV0Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItY29sb3IsIHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIGxhYmVsIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxwYXBlci1pbnB1dC1jb250YWluZXIgaWQ9XCJjb250YWluZXJcIiBuby1sYWJlbC1mbG9hdD1cIltbbm9MYWJlbEZsb2F0XV1cIiBhbHdheXMtZmxvYXQtbGFiZWw9XCJbW19jb21wdXRlQWx3YXlzRmxvYXRMYWJlbChhbHdheXNGbG9hdExhYmVsLHBsYWNlaG9sZGVyKV1dXCIgYXV0by12YWxpZGF0ZVxcJD1cIltbYXV0b1ZhbGlkYXRlXV1cIiBkaXNhYmxlZFxcJD1cIltbZGlzYWJsZWRdXVwiIGludmFsaWQ9XCJbW2ludmFsaWRdXVwiPlxuXG4gICAgICA8c2xvdCBuYW1lPVwicHJlZml4XCIgc2xvdD1cInByZWZpeFwiPjwvc2xvdD5cblxuICAgICAgPGxhYmVsIGhpZGRlblxcJD1cIltbIWxhYmVsXV1cIiBhcmlhLWhpZGRlbj1cInRydWVcIiBmb3I9XCJpbnB1dFwiIHNsb3Q9XCJsYWJlbFwiPltbbGFiZWxdXTwvbGFiZWw+XG5cbiAgICAgIDxzcGFuIGlkPVwidGVtcGxhdGUtcGxhY2Vob2xkZXJcIj48L3NwYW4+XG5cbiAgICAgIDxzbG90IG5hbWU9XCJzdWZmaXhcIiBzbG90PVwic3VmZml4XCI+PC9zbG90PlxuXG4gICAgICA8dGVtcGxhdGUgaXM9XCJkb20taWZcIiBpZj1cIltbZXJyb3JNZXNzYWdlXV1cIj5cbiAgICAgICAgPHBhcGVyLWlucHV0LWVycm9yIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiIHNsb3Q9XCJhZGQtb25cIj5bW2Vycm9yTWVzc2FnZV1dPC9wYXBlci1pbnB1dC1lcnJvcj5cbiAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1pZlwiIGlmPVwiW1tjaGFyQ291bnRlcl1dXCI+XG4gICAgICAgIDxwYXBlci1pbnB1dC1jaGFyLWNvdW50ZXIgc2xvdD1cImFkZC1vblwiPjwvcGFwZXItaW5wdXQtY2hhci1jb3VudGVyPlxuICAgICAgPC90ZW1wbGF0ZT5cblxuICAgIDwvcGFwZXItaW5wdXQtY29udGFpbmVyPlxuICA8L3RlbXBsYXRlPlxuXG4gIDwhLS0gVGhpcyBpcyBhIGZyZXNoIG5ldyBoZWxsIHRvIG1ha2UgdGhpcyBlbGVtZW50IGh5YnJpZC4gQmFzaWNhbGx5LCBpbiAyLjBcbiAgICB3ZSBsb3N0IGlzPSwgc28gdGhlIGV4YW1wbGUgc2FtZSB0ZW1wbGF0ZSBjYW4ndCBiZSB1c2VkIHdpdGggaXJvbi1pbnB1dCAxLjAgYW5kIDIuMC5cbiAgICBFeHBlY3Qgc29tZSBjb25kaXRpb25hbCBjb2RlIChlc3BlY2lhbGx5IGluIHRoZSB0ZXN0cykuXG4gICAtLT5cbiAgPHRlbXBsYXRlIGlkPVwidjBcIj5cbiAgICA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCIgaWQ9XCJpbnB1dFwiIHNsb3Q9XCJpbnB1dFwiIGFyaWEtbGFiZWxsZWRieVxcJD1cIltbX2FyaWFMYWJlbGxlZEJ5XV1cIiBhcmlhLWRlc2NyaWJlZGJ5XFwkPVwiW1tfYXJpYURlc2NyaWJlZEJ5XV1cIiBkaXNhYmxlZFxcJD1cIltbZGlzYWJsZWRdXVwiIHRpdGxlXFwkPVwiW1t0aXRsZV1dXCIgYmluZC12YWx1ZT1cInt7dmFsdWV9fVwiIGludmFsaWQ9XCJ7e2ludmFsaWR9fVwiIHByZXZlbnQtaW52YWxpZC1pbnB1dD1cIltbcHJldmVudEludmFsaWRJbnB1dF1dXCIgYWxsb3dlZC1wYXR0ZXJuPVwiW1thbGxvd2VkUGF0dGVybl1dXCIgdmFsaWRhdG9yPVwiW1t2YWxpZGF0b3JdXVwiIHR5cGVcXCQ9XCJbW3R5cGVdXVwiIHBhdHRlcm5cXCQ9XCJbW3BhdHRlcm5dXVwiIHJlcXVpcmVkXFwkPVwiW1tyZXF1aXJlZF1dXCIgYXV0b2NvbXBsZXRlXFwkPVwiW1thdXRvY29tcGxldGVdXVwiIGF1dG9mb2N1c1xcJD1cIltbYXV0b2ZvY3VzXV1cIiBpbnB1dG1vZGVcXCQ9XCJbW2lucHV0bW9kZV1dXCIgbWlubGVuZ3RoXFwkPVwiW1ttaW5sZW5ndGhdXVwiIG1heGxlbmd0aFxcJD1cIltbbWF4bGVuZ3RoXV1cIiBtaW5cXCQ9XCJbW21pbl1dXCIgbWF4XFwkPVwiW1ttYXhdXVwiIHN0ZXBcXCQ9XCJbW3N0ZXBdXVwiIG5hbWVcXCQ9XCJbW25hbWVdXVwiIHBsYWNlaG9sZGVyXFwkPVwiW1twbGFjZWhvbGRlcl1dXCIgcmVhZG9ubHlcXCQ9XCJbW3JlYWRvbmx5XV1cIiBsaXN0XFwkPVwiW1tsaXN0XV1cIiBzaXplXFwkPVwiW1tzaXplXV1cIiBhdXRvY2FwaXRhbGl6ZVxcJD1cIltbYXV0b2NhcGl0YWxpemVdXVwiIGF1dG9jb3JyZWN0XFwkPVwiW1thdXRvY29ycmVjdF1dXCIgb24tY2hhbmdlPVwiX29uQ2hhbmdlXCIgdGFiaW5kZXhcXCQ9XCJbW3RhYkluZGV4XV1cIiBhdXRvc2F2ZVxcJD1cIltbYXV0b3NhdmVdXVwiIHJlc3VsdHNcXCQ9XCJbW3Jlc3VsdHNdXVwiIGFjY2VwdFxcJD1cIltbYWNjZXB0XV1cIiBtdWx0aXBsZVxcJD1cIltbbXVsdGlwbGVdXVwiPlxuICA8L3RlbXBsYXRlPlxuXG4gIDx0ZW1wbGF0ZSBpZD1cInYxXCI+XG4gICAgPCEtLSBOZWVkIHRvIGJpbmQgbWF4bGVuZ3RoIHNvIHRoYXQgdGhlIHBhcGVyLWlucHV0LWNoYXItY291bnRlciB3b3JrcyBjb3JyZWN0bHkgLS0+XG4gICAgPGlyb24taW5wdXQgYmluZC12YWx1ZT1cInt7dmFsdWV9fVwiIGlkPVwiaW5wdXRcIiBzbG90PVwiaW5wdXRcIiBtYXhsZW5ndGhcXCQ9XCJbW21heGxlbmd0aF1dXCIgYWxsb3dlZC1wYXR0ZXJuPVwiW1thbGxvd2VkUGF0dGVybl1dXCIgaW52YWxpZD1cInt7aW52YWxpZH19XCIgdmFsaWRhdG9yPVwiW1t2YWxpZGF0b3JdXVwiPlxuICAgICAgPGlucHV0IGlkPVwibmF0aXZlSW5wdXRcIiBhcmlhLWxhYmVsbGVkYnlcXCQ9XCJbW19hcmlhTGFiZWxsZWRCeV1dXCIgYXJpYS1kZXNjcmliZWRieVxcJD1cIltbX2FyaWFEZXNjcmliZWRCeV1dXCIgZGlzYWJsZWRcXCQ9XCJbW2Rpc2FibGVkXV1cIiB0aXRsZVxcJD1cIltbdGl0bGVdXVwiIHR5cGVcXCQ9XCJbW3R5cGVdXVwiIHBhdHRlcm5cXCQ9XCJbW3BhdHRlcm5dXVwiIHJlcXVpcmVkXFwkPVwiW1tyZXF1aXJlZF1dXCIgYXV0b2NvbXBsZXRlXFwkPVwiW1thdXRvY29tcGxldGVdXVwiIGF1dG9mb2N1c1xcJD1cIltbYXV0b2ZvY3VzXV1cIiBpbnB1dG1vZGVcXCQ9XCJbW2lucHV0bW9kZV1dXCIgbWlubGVuZ3RoXFwkPVwiW1ttaW5sZW5ndGhdXVwiIG1heGxlbmd0aFxcJD1cIltbbWF4bGVuZ3RoXV1cIiBtaW5cXCQ9XCJbW21pbl1dXCIgbWF4XFwkPVwiW1ttYXhdXVwiIHN0ZXBcXCQ9XCJbW3N0ZXBdXVwiIG5hbWVcXCQ9XCJbW25hbWVdXVwiIHBsYWNlaG9sZGVyXFwkPVwiW1twbGFjZWhvbGRlcl1dXCIgcmVhZG9ubHlcXCQ9XCJbW3JlYWRvbmx5XV1cIiBsaXN0XFwkPVwiW1tsaXN0XV1cIiBzaXplXFwkPVwiW1tzaXplXV1cIiBhdXRvY2FwaXRhbGl6ZVxcJD1cIltbYXV0b2NhcGl0YWxpemVdXVwiIGF1dG9jb3JyZWN0XFwkPVwiW1thdXRvY29ycmVjdF1dXCIgb24tY2hhbmdlPVwiX29uQ2hhbmdlXCIgdGFiaW5kZXhcXCQ9XCJbW3RhYkluZGV4XV1cIiBhdXRvc2F2ZVxcJD1cIltbYXV0b3NhdmVdXVwiIHJlc3VsdHNcXCQ9XCJbW3Jlc3VsdHNdXVwiIGFjY2VwdFxcJD1cIltbYWNjZXB0XV1cIiBtdWx0aXBsZVxcJD1cIltbbXVsdGlwbGVdXVwiPlxuICAgIDwvaXJvbi1pbnB1dD5cbiAgPC90ZW1wbGF0ZT5cblxuPC9kb20tbW9kdWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5Qb2x5bWVyKHtcbiAgaXM6ICdwYXBlci1pbnB1dCcsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgUGFwZXJJbnB1dEJlaGF2aW9yLFxuICAgIElyb25Gb3JtRWxlbWVudEJlaGF2aW9yXG4gIF0sXG5cbiAgYmVmb3JlUmVnaXN0ZXI6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gdGVsbCB3aGljaCBraW5kIG9mIG9mIHRlbXBsYXRlIHRvIHN0YW1wIGJhc2VkIG9uXG4gICAgLy8gd2hhdCBraW5kIG9mIGBpcm9uLWlucHV0YCB3ZSBnb3QsIGJ1dCBiZWNhdXNlIG9mIHBvbHlmaWxscyBhbmRcbiAgICAvLyBjdXN0b20gZWxlbWVudHMgZGlmZmVyZW5jZXMgYmV0d2VlbiB2MCBhbmQgdjEsIHRoZSBzYWZlc3QgYmV0IGlzXG4gICAgLy8gdG8gY2hlY2sgYSBwYXJ0aWN1bGFyIG1ldGhvZCB3ZSBrbm93IHRoZSBpcm9uLWlucHV0IzIueCBjYW4gaGF2ZS5cbiAgICAvLyBJZiBpdCBkb2Vzbid0IGhhdmUgaXQsIHRoZW4gaXQncyBhbiBpcm9uLWlucHV0IzEueC5cbiAgICB2YXIgaXJvbklucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaXJvbi1pbnB1dCcpO1xuICAgIHZhciB2ZXJzaW9uID0gdHlwZW9mIGlyb25JbnB1dC5faW5pdFNsb3R0ZWRJbnB1dCA9PSAnZnVuY3Rpb24nID8gJ3YxJyA6ICd2MCc7XG4gICAgdmFyIHRlbXBsYXRlID0gRG9tTW9kdWxlLmltcG9ydCgncGFwZXItaW5wdXQnLCAndGVtcGxhdGUnKTtcbiAgICB2YXIgaW5wdXRUZW1wbGF0ZSA9IERvbU1vZHVsZS5pbXBvcnQoJ3BhcGVyLWlucHV0JywgJ3RlbXBsYXRlIycgKyB2ZXJzaW9uKTtcbiAgICB2YXIgaW5wdXRQbGFjZWhvbGRlciA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvcignI3RlbXBsYXRlLXBsYWNlaG9sZGVyJyk7XG4gICAgaWYgKGlucHV0UGxhY2Vob2xkZXIpIHtcbiAgICAgIGlucHV0UGxhY2Vob2xkZXIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoaW5wdXRUZW1wbGF0ZS5jb250ZW50LCBpbnB1dFBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgLy8gZWxzZSBpdCdzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQsIHByb2JhYmx5IGluIHN1cGVyY2xhc3NcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgZm9jdXNhYmxlIGVsZW1lbnQuIE92ZXJyaWRkZW4gZnJvbSBQYXBlcklucHV0QmVoYXZpb3JcbiAgICogdG8gY29ycmVjdGx5IGZvY3VzIHRoZSBuYXRpdmUgaW5wdXQuXG4gICAqL1xuICBnZXQgX2ZvY3VzYWJsZUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQgPyB0aGlzLmlucHV0RWxlbWVudC5faW5wdXRFbGVtZW50IDogdGhpcy5pbnB1dEVsZW1lbnQ7XG4gIH0sXG5cbiAgLy8gTm90ZTogVGhpcyBldmVudCBpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgMS4wIHZlcnNpb24gb2YgdGhpcyBlbGVtZW50LlxuICAvLyBJbiAyLjAsIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGBfb25Jcm9uSW5wdXRSZWFkeWAgaXMgZG9uZSBpblxuICAvLyBQYXBlcklucHV0QmVoYXZpb3I6OmF0dGFjaGVkLlxuICBsaXN0ZW5lcnM6IHtcbiAgICAnaXJvbi1pbnB1dC1yZWFkeSc6ICdfb25Jcm9uSW5wdXRSZWFkeSdcbiAgfSxcblxuICBfb25Jcm9uSW5wdXRSZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaW5wdXRFbGVtZW50ICYmXG4gICAgICAgIHRoaXMuX3R5cGVzVGhhdEhhdmVUZXh0LmluZGV4T2YodGhpcy4kLm5hdGl2ZUlucHV0LnR5cGUpICE9PSAtMSkge1xuICAgICAgdGhpcy5hbHdheXNGbG9hdExhYmVsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IHZhbGlkYXRlIHdoZW4gYXR0YWNoZWQgaWYgdGhlIGlucHV0IGFscmVhZHkgaGFzIGEgdmFsdWUuXG4gICAgaWYgKCEhdGhpcy5pbnB1dEVsZW1lbnQuYmluZFZhbHVlKSB7XG4gICAgICB0aGlzLiQuY29udGFpbmVyLl9oYW5kbGVWYWx1ZUFuZEF1dG9WYWxpZGF0ZSh0aGlzLmlucHV0RWxlbWVudCk7XG4gICAgfVxuICB9LFxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkExMXlBbm5vdW5jZXIgfSBmcm9tICcuLi9pcm9uLWExMXktYW5ub3VuY2VyL2lyb24tYTExeS1hbm5vdW5jZXIuanMnO1xuaW1wb3J0IHsgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgICA8c2xvdCBpZD1cImNvbnRlbnRcIj48L3Nsb3Q+XG5gLFxuXG4gIGlzOiAnaXJvbi1pbnB1dCcsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JcbiAgXSxcblxuICAvKipcbiAgICogRmlyZWQgd2hlbmV2ZXIgYHZhbGlkYXRlKClgIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQGV2ZW50IGlyb24taW5wdXQtdmFsaWRhdGVcbiAgICovXG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcHJvcGVydHkgaW5zdGVhZCBvZiBgdmFsdWVgIGZvciB0d28td2F5IGRhdGEgYmluZGluZywgb3IgdG9cbiAgICAgKiBzZXQgYSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgaW5wdXQuICoqRG8gbm90KiogdXNlIHRoZSBkaXN0cmlidXRlZFxuICAgICAqIGlucHV0J3MgYHZhbHVlYCBwcm9wZXJ0eSB0byBzZXQgYSBkZWZhdWx0IHZhbHVlLlxuICAgICAqL1xuICAgIGJpbmRWYWx1ZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVkIHByb3BlcnR5IHRoYXQgZWNob2VzIGBiaW5kVmFsdWVgIChtb3N0bHkgdXNlZCBmb3IgUG9seW1lciAxLjBcbiAgICAgKiBiYWNrY29tcGF0aWJpbGl0eSwgaWYgeW91IHdlcmUgb25lLXdheSBiaW5kaW5nIHRvIHRoZSBQb2x5bWVyIDEuMFxuICAgICAqIGBpbnB1dCBpcz1cImlyb24taW5wdXRcImAgdmFsdWUgYXR0cmlidXRlKS5cbiAgICAgKi9cbiAgICB2YWx1ZToge1xuICAgICAgY29tcHV0ZWQ6ICdfY29tcHV0ZVZhbHVlKGJpbmRWYWx1ZSknXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2V4LWxpa2UgbGlzdCBvZiBjaGFyYWN0ZXJzIGFsbG93ZWQgYXMgaW5wdXQ7IGFsbCBjaGFyYWN0ZXJzIG5vdCBpbiB0aGUgbGlzdFxuICAgICAqIHdpbGwgYmUgcmVqZWN0ZWQuIFRoZSByZWNvbW1lbmRlZCBmb3JtYXQgc2hvdWxkIGJlIGEgbGlzdCBvZiBhbGxvd2VkIGNoYXJhY3RlcnMsXG4gICAgICogZm9yIGV4YW1wbGUsIGBbYS16QS1aMC05ListITs6XWAuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhdHRlcm4gcmVwcmVzZW50cyB0aGUgYWxsb3dlZCBjaGFyYWN0ZXJzIGZvciB0aGUgZmllbGQ7IGFzIHRoZSB1c2VyIGlucHV0cyB0ZXh0LFxuICAgICAqIGVhY2ggaW5kaXZpZHVhbCBjaGFyYWN0ZXIgd2lsbCBiZSBjaGVja2VkIGFnYWluc3QgdGhlIHBhdHRlcm4gKHJhdGhlciB0aGFuIGNoZWNraW5nXG4gICAgICogdGhlIGVudGlyZSB2YWx1ZSBhcyBhIHdob2xlKS4gSWYgYSBjaGFyYWN0ZXIgaXMgbm90IGEgbWF0Y2gsIGl0IHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAgICpcbiAgICAgKiBQYXN0ZWQgaW5wdXQgd2lsbCBoYXZlIGVhY2ggY2hhcmFjdGVyIGNoZWNrZWQgaW5kaXZpZHVhbGx5OyBpZiBhbnkgY2hhcmFjdGVyXG4gICAgICogZG9lc24ndCBtYXRjaCBgYWxsb3dlZFBhdHRlcm5gLCB0aGUgZW50aXJlIHBhc3RlZCBzdHJpbmcgd2lsbCBiZSByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGlmIHlvdSB3ZXJlIHVzaW5nIGBpcm9uLWlucHV0YCBpbiAxLjAsIHlvdSB3ZXJlIGFsc28gcmVxdWlyZWQgdG9cbiAgICAgKiBzZXQgYHByZXZlbnQtaW52YWxpZC1pbnB1dGAuIFRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCBhcyBvZiBQb2x5bWVyIDIuMCxcbiAgICAgKiBhbmQgd2lsbCBiZSBzZXQgYXV0b21hdGljYWxseSBmb3IgeW91IGlmIGFuIGBhbGxvd2VkUGF0dGVybmAgaXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBhbGxvd2VkUGF0dGVybjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGF1dG8tdmFsaWRhdGUgdGhlIGlucHV0IHZhbHVlIGFzIHlvdSB0eXBlLlxuICAgICAqL1xuICAgIGF1dG9WYWxpZGF0ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH1cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX2JpbmRWYWx1ZUNoYW5nZWQoYmluZFZhbHVlLCBfaW5wdXRFbGVtZW50KSdcbiAgXSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICAnaW5wdXQnOiAnX29uSW5wdXQnLFxuICAgICdrZXlwcmVzcyc6ICdfb25LZXlwcmVzcydcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICBJcm9uQTExeUFubm91bmNlci5yZXF1ZXN0QXZhaWxhYmlsaXR5KCk7XG4gICAgdGhpcy5fcHJldmlvdXNWYWxpZElucHV0ID0gJyc7XG4gICAgdGhpcy5fcGF0dGVybkFscmVhZHlDaGVja2VkID0gZmFsc2U7XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhZGRlZCBhdCBhIGxhdGVyIHRpbWUsIHVwZGF0ZSB0aGUgaW50ZXJuYWwgcmVmZXJlbmNlLlxuICAgIHRoaXMuX29ic2VydmVyID0gZG9tKHRoaXMpLm9ic2VydmVOb2RlcyhmdW5jdGlvbihpbmZvKSB7XG4gICAgICB0aGlzLl9pbml0U2xvdHRlZElucHV0KCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XG4gICAgICBkb20odGhpcykudW5vYnNlcnZlTm9kZXModGhpcy5fb2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgPGlucHV0PiBlbGVtZW50LlxuICAgKi9cbiAgZ2V0IGlucHV0RWxlbWVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0RWxlbWVudDtcbiAgfSxcblxuICBfaW5pdFNsb3R0ZWRJbnB1dDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW5wdXRFbGVtZW50ID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZHJlbigpWzBdO1xuXG4gICAgaWYgKHRoaXMuaW5wdXRFbGVtZW50ICYmIHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlKSB7XG4gICAgICB0aGlzLmJpbmRWYWx1ZSA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuZmlyZSgnaXJvbi1pbnB1dC1yZWFkeScpO1xuICB9LFxuXG4gIGdldCBfcGF0dGVyblJlZ0V4cCgpIHtcbiAgICB2YXIgcGF0dGVybjtcbiAgICBpZiAodGhpcy5hbGxvd2VkUGF0dGVybikge1xuICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAodGhpcy5hbGxvd2VkUGF0dGVybik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgcGF0dGVybiA9IC9bMC05LixlLV0vO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfSxcblxuICAvKipcbiAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgKi9cbiAgX2JpbmRWYWx1ZUNoYW5nZWQ6IGZ1bmN0aW9uKGJpbmRWYWx1ZSwgaW5wdXRFbGVtZW50KSB7XG4gICAgLy8gVGhlIG9ic2VydmVyIGNvdWxkIGhhdmUgcnVuIGJlZm9yZSBhdHRhY2hlZCgpIHdoZW4gd2UgaGF2ZSBhY3R1YWxseSBpbml0aWFsaXplZFxuICAgIC8vIHRoaXMgcHJvcGVydHkuXG4gICAgaWYgKCFpbnB1dEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYmluZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlucHV0RWxlbWVudC52YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChiaW5kVmFsdWUgIT09IGlucHV0RWxlbWVudC52YWx1ZSl7XG4gICAgICB0aGlzLmlucHV0RWxlbWVudC52YWx1ZSA9IGJpbmRWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hdXRvVmFsaWRhdGUpIHtcbiAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBtYW51YWxseSBub3RpZnkgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIG5vdGlmeSB1bnRpbCBhZnRlciBzZXR0aW5nIHZhbHVlXG4gICAgdGhpcy5maXJlKCdiaW5kLXZhbHVlLWNoYW5nZWQnLCB7dmFsdWU6IGJpbmRWYWx1ZX0pO1xuICB9LFxuXG4gIF9vbklucHV0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBOZWVkIHRvIHZhbGlkYXRlIGVhY2ggb2YgdGhlIGNoYXJhY3RlcnMgcGFzdGVkIGlmIHRoZXkgaGF2ZW4ndFxuICAgIC8vIGJlZW4gdmFsaWRhdGVkIGluc2lkZSBgX29uS2V5cHJlc3NgIGFscmVhZHkuXG4gICAgaWYgKHRoaXMuYWxsb3dlZFBhdHRlcm4gJiYgIXRoaXMuX3BhdHRlcm5BbHJlYWR5Q2hlY2tlZCkge1xuICAgICAgdmFyIHZhbGlkID0gdGhpcy5fY2hlY2tQYXR0ZXJuVmFsaWRpdHkoKTtcbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgdGhpcy5fYW5ub3VuY2VJbnZhbGlkQ2hhcmFjdGVyKCdJbnZhbGlkIHN0cmluZyBvZiBjaGFyYWN0ZXJzIG5vdCBlbnRlcmVkLicpO1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC52YWx1ZSA9IHRoaXMuX3ByZXZpb3VzVmFsaWRJbnB1dDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5iaW5kVmFsdWUgPSB0aGlzLl9wcmV2aW91c1ZhbGlkSW5wdXQgPSB0aGlzLmlucHV0RWxlbWVudC52YWx1ZTtcbiAgICB0aGlzLl9wYXR0ZXJuQWxyZWFkeUNoZWNrZWQgPSBmYWxzZTtcbiAgfSxcblxuICBfaXNQcmludGFibGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gV2hhdCBhIGNvbnRyb2wvcHJpbnRhYmxlIGNoYXJhY3RlciBpcyB2YXJpZXMgd2lsZGx5IGJhc2VkIG9uIHRoZSBicm93c2VyLlxuICAgIC8vIC0gbW9zdCBjb250cm9sIGNoYXJhY3RlcnMgKGFycm93cywgYmFja3NwYWNlKSBkbyBub3Qgc2VuZCBhIGBrZXlwcmVzc2AgZXZlbnRcbiAgICAvLyAgIGluIENocm9tZSwgYnV0IHRoZSAqZG8qIG9uIEZpcmVmb3hcbiAgICAvLyAtIGluIEZpcmVmb3gsIHdoZW4gdGhleSBkbyBzZW5kIGEgYGtleXByZXNzYCBldmVudCwgY29udHJvbCBjaGFycyBoYXZlXG4gICAgLy8gICBhIGNoYXJDb2RlID0gMCwga2V5Q29kZSA9IHh4IChmb3IgZXguIDQwIGZvciBkb3duIGFycm93KVxuICAgIC8vIC0gcHJpbnRhYmxlIGNoYXJhY3RlcnMgYWx3YXlzIHNlbmQgYSBrZXlwcmVzcyBldmVudC5cbiAgICAvLyAtIGluIEZpcmVmb3gsIHByaW50YWJsZSBjaGFycyBhbHdheXMgaGF2ZSBhIGtleUNvZGUgPSAwLiBJbiBDaHJvbWUsIHRoZSBrZXlDb2RlXG4gICAgLy8gICBhbHdheXMgbWF0Y2hlcyB0aGUgY2hhckNvZGUuXG4gICAgLy8gTm9uZSBvZiB0aGlzIG1ha2VzIGFueSBzZW5zZS5cblxuICAgIC8vIEZvciB0aGVzZSBrZXlzLCBBU0NJSSBjb2RlID09IGJyb3dzZXIga2V5Y29kZS5cbiAgICB2YXIgYW55Tm9uUHJpbnRhYmxlID1cbiAgICAgIChldmVudC5rZXlDb2RlID09IDgpICAgfHwgIC8vIGJhY2tzcGFjZVxuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gOSkgICB8fCAgLy8gdGFiXG4gICAgICAoZXZlbnQua2V5Q29kZSA9PSAxMykgIHx8ICAvLyBlbnRlclxuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMjcpOyAgICAgLy8gZXNjYXBlXG5cbiAgICAvLyBGb3IgdGhlc2Uga2V5cywgbWFrZSBzdXJlIGl0J3MgYSBicm93c2VyIGtleWNvZGUgYW5kIG5vdCBhbiBBU0NJSSBjb2RlLlxuICAgIHZhciBtb3pOb25QcmludGFibGUgPVxuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMTkpICB8fCAgLy8gcGF1c2VcbiAgICAgIChldmVudC5rZXlDb2RlID09IDIwKSAgfHwgIC8vIGNhcHMgbG9ja1xuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gNDUpICB8fCAgLy8gaW5zZXJ0XG4gICAgICAoZXZlbnQua2V5Q29kZSA9PSA0NikgIHx8ICAvLyBkZWxldGVcbiAgICAgIChldmVudC5rZXlDb2RlID09IDE0NCkgfHwgIC8vIG51bSBsb2NrXG4gICAgICAoZXZlbnQua2V5Q29kZSA9PSAxNDUpIHx8ICAvLyBzY3JvbGwgbG9ja1xuICAgICAgKGV2ZW50LmtleUNvZGUgPiAzMiAmJiBldmVudC5rZXlDb2RlIDwgNDEpICAgfHwgLy8gcGFnZSB1cC9kb3duLCBlbmQsIGhvbWUsIGFycm93c1xuICAgICAgKGV2ZW50LmtleUNvZGUgPiAxMTEgJiYgZXZlbnQua2V5Q29kZSA8IDEyNCk7IC8vIGZuIGtleXNcblxuICAgIHJldHVybiAhYW55Tm9uUHJpbnRhYmxlICYmICEoZXZlbnQuY2hhckNvZGUgPT0gMCAmJiBtb3pOb25QcmludGFibGUpO1xuICB9LFxuXG4gIF9vbktleXByZXNzOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5hbGxvd2VkUGF0dGVybiAmJiB0aGlzLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWdleHAgPSB0aGlzLl9wYXR0ZXJuUmVnRXhwO1xuICAgIGlmICghcmVnZXhwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHNwZWNpYWwga2V5cyBhbmQgYmFja3NwYWNlXG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgcGF0dGVybiBlaXRoZXIgaGVyZSBvciBpbiBgX29uSW5wdXRgLCBidXQgbm90IGluIGJvdGguXG4gICAgdGhpcy5fcGF0dGVybkFscmVhZHlDaGVja2VkID0gdHJ1ZTtcblxuICAgIHZhciB0aGlzQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgIGlmICh0aGlzLl9pc1ByaW50YWJsZShldmVudCkgJiYgIXJlZ2V4cC50ZXN0KHRoaXNDaGFyKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX2Fubm91bmNlSW52YWxpZENoYXJhY3RlcignSW52YWxpZCBjaGFyYWN0ZXIgJyArIHRoaXNDaGFyICsgJyBub3QgZW50ZXJlZC4nKTtcbiAgICB9XG4gIH0sXG5cbiAgX2NoZWNrUGF0dGVyblZhbGlkaXR5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVnZXhwID0gdGhpcy5fcGF0dGVyblJlZ0V4cDtcbiAgICBpZiAoIXJlZ2V4cCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dEVsZW1lbnQudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcmVnZXhwLnRlc3QodGhpcy5pbnB1dEVsZW1lbnQudmFsdWVbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLiBUaGUgdmFsaWRhdG9yIHByb3ZpZGVkIGluIGB2YWxpZGF0b3JgIHdpbGwgYmUgdXNlZCBmaXJzdCxcbiAgICogdGhlbiBhbnkgY29uc3RyYWludHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHZhbGlkLlxuICAgKi9cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5pbnB1dEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuaW52YWxpZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVXNlIHRoZSBuZXN0ZWQgaW5wdXQncyBuYXRpdmUgdmFsaWRpdHkuXG4gICAgdmFyIHZhbGlkID0gIHRoaXMuaW5wdXRFbGVtZW50LmNoZWNrVmFsaWRpdHkoKTtcblxuICAgIC8vIE9ubHkgZG8gZXh0cmEgY2hlY2tpbmcgaWYgdGhlIGJyb3dzZXIgdGhvdWdodCB0aGlzIHdhcyB2YWxpZC5cbiAgICBpZiAodmFsaWQpIHtcbiAgICAgIC8vIEVtcHR5LCByZXF1aXJlZCBpbnB1dCBpcyBpbnZhbGlkXG4gICAgICBpZiAodGhpcy5yZXF1aXJlZCAmJiB0aGlzLmJpbmRWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNWYWxpZGF0b3IoKSkge1xuICAgICAgICB2YWxpZCA9IElyb25WYWxpZGF0YWJsZUJlaGF2aW9yLnZhbGlkYXRlLmNhbGwodGhpcywgdGhpcy5iaW5kVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW52YWxpZCA9ICF2YWxpZDtcbiAgICB0aGlzLmZpcmUoJ2lyb24taW5wdXQtdmFsaWRhdGUnKTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gIH0sXG5cbiAgX2Fubm91bmNlSW52YWxpZENoYXJhY3RlcjogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHRoaXMuZmlyZSgnaXJvbi1hbm5vdW5jZScsIHsgdGV4dDogbWVzc2FnZSB9KTtcbiAgfSxcblxuICBfY29tcHV0ZVZhbHVlOiBmdW5jdGlvbihiaW5kVmFsdWUpIHtcbiAgICByZXR1cm4gYmluZFZhbHVlO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24taW5wdXQvaXJvbi1pbnB1dC5qc1xuLy8gbW9kdWxlIGlkID0gOTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgUG9seW1lciBhcyBQb2x5bWVyJDAgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uQTExeUFubm91bmNlciA9IFBvbHltZXIkMCh7XG4gIF90ZW1wbGF0ZTogYFxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIGNsaXA6IHJlY3QoMHB4LDBweCwwcHgsMHB4KTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICAgIDxkaXYgYXJpYS1saXZlXFwkPVwiW1ttb2RlXV1cIj5bW190ZXh0XV08L2Rpdj5cbmAsXG5cbiAgaXM6ICdpcm9uLWExMXktYW5ub3VuY2VyJyxcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgbW9kZSBpcyB1c2VkIHRvIHNldCB0aGUgYGFyaWEtbGl2ZWAgYXR0cmlidXRlXG4gICAgICogZm9yIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSBhbm5vdW5jZWQuIFZhbGlkIHZhbHVlcyBhcmU6IGBvZmZgLFxuICAgICAqIGBwb2xpdGVgIGFuZCBgYXNzZXJ0aXZlYC5cbiAgICAgKi9cbiAgICBtb2RlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ3BvbGl0ZSdcbiAgICB9LFxuXG4gICAgX3RleHQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnJ1xuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIUlyb25BMTF5QW5ub3VuY2VyLmluc3RhbmNlKSB7XG4gICAgICBJcm9uQTExeUFubm91bmNlci5pbnN0YW5jZSA9IHRoaXM7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdpcm9uLWFubm91bmNlJywgdGhpcy5fb25Jcm9uQW5ub3VuY2UuYmluZCh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhdXNlIGEgdGV4dCBzdHJpbmcgdG8gYmUgYW5ub3VuY2VkIGJ5IHNjcmVlbiByZWFkZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0aGF0IHNob3VsZCBiZSBhbm5vdW5jZWQuXG4gICAqL1xuICBhbm5vdW5jZTogZnVuY3Rpb24odGV4dCkge1xuICAgIHRoaXMuX3RleHQgPSAnJztcbiAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgfSwgMTAwKTtcbiAgfSxcblxuICBfb25Jcm9uQW5ub3VuY2U6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudGV4dCkge1xuICAgICAgdGhpcy5hbm5vdW5jZShldmVudC5kZXRhaWwudGV4dCk7XG4gICAgfVxuICB9XG59KTtcblxuSXJvbkExMXlBbm5vdW5jZXIuaW5zdGFuY2UgPSBudWxsO1xuXG5Jcm9uQTExeUFubm91bmNlci5yZXF1ZXN0QXZhaWxhYmlsaXR5ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghSXJvbkExMXlBbm5vdW5jZXIuaW5zdGFuY2UpIHtcbiAgICBJcm9uQTExeUFubm91bmNlci5pbnN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lyb24tYTExeS1hbm5vdW5jZXInKTtcbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoSXJvbkExMXlBbm5vdW5jZXIuaW5zdGFuY2UpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYTExeS1hbm5vdW5jZXIvaXJvbi1hMTF5LWFubm91bmNlci5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkExMXlLZXlzQmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBJcm9uQ29udHJvbFN0YXRlIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmpzJztcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuZXhwb3J0IGNvbnN0IFBhcGVySW5wdXRIZWxwZXIgPSB7fTtcblBhcGVySW5wdXRIZWxwZXIuTmV4dExhYmVsSUQgPSAxO1xuUGFwZXJJbnB1dEhlbHBlci5OZXh0QWRkb25JRCA9IDE7XG5cbmV4cG9ydCBjb25zdCBQYXBlcklucHV0QmVoYXZpb3JJbXBsID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBpbnB1dCBjaGFuZ2VzIGR1ZSB0byB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIGZvciB0aGlzIGlucHV0LiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogYDxsYWJlbD5gJ3MgY29udGVudCBhbmQgYGhpZGRlbmAgcHJvcGVydHksIGUuZy5cbiAgICAgKiBgPGxhYmVsIGhpZGRlbiQ9XCJbWyFsYWJlbF1dXCI+W1tsYWJlbF1dPC9sYWJlbD5gIGluIHlvdXIgYHRlbXBsYXRlYFxuICAgICAqL1xuICAgIGxhYmVsOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGlzIGlucHV0LiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogdGhlIGA8aXJvbi1pbnB1dD5gJ3MgYGJpbmRWYWx1ZWBcbiAgICAgKiBwcm9wZXJ0eSwgb3IgdGhlIHZhbHVlIHByb3BlcnR5IG9mIHlvdXIgaW5wdXQgdGhhdCBpcyBgbm90aWZ5OnRydWVgLlxuICAgICAqL1xuICAgIHZhbHVlOiB7XG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGlucHV0LiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogYm90aCB0aGUgYDxwYXBlci1pbnB1dC1jb250YWluZXI+YCdzIGFuZCB0aGUgaW5wdXQncyBgZGlzYWJsZWRgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGRpc2FibGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgaW52YWxpZC4gSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0b1xuICAgICAqIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlIGVsZW1lbnQsIGJpbmQgdGhpcyB0byBib3RoIHRoZVxuICAgICAqIGA8cGFwZXItaW5wdXQtY29udGFpbmVyPmAncyBhbmQgdGhlIGlucHV0J3MgYGludmFsaWRgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogSWYgYGF1dG9WYWxpZGF0ZWAgaXMgdHJ1ZSwgdGhlIGBpbnZhbGlkYCBhdHRyaWJ1dGUgaXMgbWFuYWdlZCBhdXRvbWF0aWNhbGx5LFxuICAgICAqIHdoaWNoIGNhbiBjbG9iYmVyIGF0dGVtcHRzIHRvIG1hbmFnZSBpdCBtYW51YWxseS5cbiAgICAgKi9cbiAgICBpbnZhbGlkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHRvIHNwZWNpZnkgdGhlIHBhdHRlcm4gYWxsb3dlZCBieSBgcHJldmVudEludmFsaWRJbnB1dGAuIElmXG4gICAgICogeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYGFsbG93ZWRQYXR0ZXJuYFxuICAgICAqIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGFsbG93ZWRQYXR0ZXJuOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIGlucHV0LiBUaGUgc3VwcG9ydGVkIHR5cGVzIGFyZSBgdGV4dGAsIGBudW1iZXJgIGFuZCBgcGFzc3dvcmRgLlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCxcbiAgICAgKiBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGB0eXBlYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGFsaXN0IG9mIHRoZSBpbnB1dCAoaWYgYW55KS4gVGhpcyBzaG91bGQgbWF0Y2ggdGhlIGlkIG9mIGFuIGV4aXN0aW5nIGA8ZGF0YWxpc3Q+YC5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgbGlzdGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgbGlzdDoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgcGF0dGVybiB0byB2YWxpZGF0ZSB0aGUgYGlucHV0YCB3aXRoLiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBwYXR0ZXJuYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBwYXR0ZXJuOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gbWFyayB0aGUgaW5wdXQgYXMgcmVxdWlyZWQuIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG9cbiAgICAgKiBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LCBiaW5kIHRoaXMgdG9cbiAgICAgKiB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYHJlcXVpcmVkYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICByZXF1aXJlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXJyb3IgbWVzc2FnZSB0byBkaXNwbGF5IHdoZW4gdGhlIGlucHV0IGlzIGludmFsaWQuIElmIHlvdSdyZSB1c2luZ1xuICAgICAqIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LFxuICAgICAqIGJpbmQgdGhpcyB0byB0aGUgYDxwYXBlci1pbnB1dC1lcnJvcj5gJ3MgY29udGVudCwgaWYgdXNpbmcuXG4gICAgICovXG4gICAgZXJyb3JNZXNzYWdlOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gc2hvdyBhIGNoYXJhY3RlciBjb3VudGVyLlxuICAgICAqL1xuICAgIGNoYXJDb3VudGVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdGhlIGZsb2F0aW5nIGxhYmVsLiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogdGhlIGA8cGFwZXItaW5wdXQtY29udGFpbmVyPmAncyBgbm9MYWJlbEZsb2F0YCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBub0xhYmVsRmxvYXQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gYWx3YXlzIGZsb2F0IHRoZSBsYWJlbC4gSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0b1xuICAgICAqIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlIGVsZW1lbnQsIGJpbmQgdGhpcyB0b1xuICAgICAqIHRoZSBgPHBhcGVyLWlucHV0LWNvbnRhaW5lcj5gJ3MgYGFsd2F5c0Zsb2F0TGFiZWxgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGFsd2F5c0Zsb2F0TGFiZWw6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gYXV0by12YWxpZGF0ZSB0aGUgaW5wdXQgdmFsdWUuIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG9cbiAgICAgKiBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LCBiaW5kIHRoaXMgdG9cbiAgICAgKiB0aGUgYDxwYXBlci1pbnB1dC1jb250YWluZXI+YCdzIGBhdXRvVmFsaWRhdGVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGF1dG9WYWxpZGF0ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSB2YWxpZGF0b3IgdG8gdXNlLiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGB2YWxpZGF0b3JgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHZhbGlkYXRvcjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8vIEhUTUxJbnB1dEVsZW1lbnQgYXR0cmlidXRlcyBmb3IgYmluZGluZyBpZiBuZWVkZWRcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBhdXRvY29tcGxldGVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGF1dG9jb21wbGV0ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdvZmYnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBhdXRvZm9jdXNgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGF1dG9mb2N1czoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIG9ic2VydmVyOiAnX2F1dG9mb2N1c0NoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBpbnB1dG1vZGVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGlucHV0bW9kZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIGxlbmd0aCBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYG1pbmxlbmd0aGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgbWlubGVuZ3RoOiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgbWF4bGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBtYXhsZW5ndGg6IHtcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSAobnVtZXJpYyBvciBkYXRlLXRpbWUpIGlucHV0IHZhbHVlLlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBtaW5gIHByb3BlcnR5LlxuICAgICAqL1xuICAgIG1pbjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIChudW1lcmljIG9yIGRhdGUtdGltZSkgaW5wdXQgdmFsdWUuXG4gICAgICogQ2FuIGJlIGEgU3RyaW5nIChlLmcuIGBcIjIwMDAtMDEtMDFcImApIG9yIGEgTnVtYmVyIChlLmcuIGAyYCkuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYG1heGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgbWF4OiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGltaXRzIHRoZSBudW1lcmljIG9yIGRhdGUtdGltZSBpbmNyZW1lbnRzLlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBzdGVwYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBzdGVwOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYG5hbWVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHBsYWNlaG9sZGVyIHN0cmluZyBpbiBhZGRpdGlvbiB0byB0aGUgbGFiZWwuIElmIHRoaXMgaXMgc2V0LCB0aGUgbGFiZWwgd2lsbCBhbHdheXMgZmxvYXQuXG4gICAgICovXG4gICAgcGxhY2Vob2xkZXI6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIC8vIG5lZWQgdG8gc2V0IGEgZGVmYXVsdCBzbyBfY29tcHV0ZUFsd2F5c0Zsb2F0TGFiZWwgaXMgcnVuXG4gICAgICB2YWx1ZTogJydcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYHJlYWRvbmx5YCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICByZWFkb25seToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgc2l6ZWAgcHJvcGVydHkuXG4gICAgICovXG4gICAgc2l6ZToge1xuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcblxuICAgIC8vIE5vbnN0YW5kYXJkIGF0dHJpYnV0ZXMgZm9yIGJpbmRpbmcgaWYgbmVlZGVkXG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgYXV0b2NhcGl0YWxpemVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGF1dG9jYXBpdGFsaXplOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ25vbmUnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBhdXRvY29ycmVjdGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgYXV0b2NvcnJlY3Q6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnb2ZmJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgYXV0b3NhdmVgIHByb3BlcnR5LFxuICAgICAqIHVzZWQgd2l0aCB0eXBlPXNlYXJjaC5cbiAgICAgKi9cbiAgICBhdXRvc2F2ZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGByZXN1bHRzYCBwcm9wZXJ0eSxcbiAgICAgKiB1c2VkIHdpdGggdHlwZT1zZWFyY2guXG4gICAgICovXG4gICAgcmVzdWx0czoge1xuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBhY2NlcHRgIHByb3BlcnR5LFxuICAgICAqIHVzZWQgd2l0aCB0eXBlPWZpbGUuXG4gICAgICovXG4gICAgYWNjZXB0OiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGVgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgbXVsdGlwbGVgIHByb3BlcnR5LFxuICAgICAqIHVzZWQgd2l0aCB0eXBlPWZpbGUuXG4gICAgICovXG4gICAgbXVsdGlwbGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuXG4gICAgX2FyaWFEZXNjcmliZWRCeToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICcnXG4gICAgfSxcblxuICAgIF9hcmlhTGFiZWxsZWRCeToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICcnXG4gICAgfVxuXG4gIH0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgJ2FkZG9uLWF0dGFjaGVkJzogJ19vbkFkZG9uQXR0YWNoZWQnLFxuICB9LFxuXG4gIGtleUJpbmRpbmdzOiB7XG4gICAgJ3NoaWZ0K3RhYjprZXlkb3duJzogJ19vblNoaWZ0VGFiRG93bidcbiAgfSxcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgIHRhYmluZGV4OiAwXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqL1xuICBnZXQgaW5wdXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLiQuaW5wdXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGZvY3VzYWJsZSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0IF9mb2N1c2FibGVFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0RWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGVzZSB0eXBlcyBoYXZlIHNvbWUgZGVmYXVsdCBwbGFjZWhvbGRlciB0ZXh0OyBvdmVybGFwcGluZ1xuICAgIC8vIHRoZSBsYWJlbCBvbiB0b3Agb2YgaXQgbG9va3MgdGVycmlibGUuIEF1dG8tZmxvYXQgdGhlIGxhYmVsIGluIHRoaXMgY2FzZS5cbiAgICB0aGlzLl90eXBlc1RoYXRIYXZlVGV4dCA9IFtcImRhdGVcIiwgXCJkYXRldGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwibW9udGhcIixcbiAgICAgICAgXCJ0aW1lXCIsIFwid2Vla1wiLCBcImZpbGVcIl07XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VwZGF0ZUFyaWFMYWJlbGxlZEJ5KCk7XG5cbiAgICAvLyBJbiB0aGUgMi4wIHZlcnNpb24gb2YgdGhlIGVsZW1lbnQsIHRoaXMgaXMgaGFuZGxlZCBpbiBgb25Jcm9uSW5wdXRSZWFkeWAsXG4gICAgLy8gaS5lLiBhZnRlciB0aGUgbmF0aXZlIGlucHV0IGhhcyBmaW5pc2hlZCBkaXN0cmlidXRpbmcuIEluIHRoZSAxLjAgdmVyc2lvbixcbiAgICAvLyB0aGUgaW5wdXQgaXMgaW4gdGhlIHNoYWRvdyB0cmVlLCBzbyBpdCdzIGFscmVhZHkgYXZhaWxhYmxlLlxuICAgIGlmICghRWxlbWVudCAmJiB0aGlzLmlucHV0RWxlbWVudCAmJlxuICAgICAgICB0aGlzLl90eXBlc1RoYXRIYXZlVGV4dC5pbmRleE9mKHRoaXMuaW5wdXRFbGVtZW50LnR5cGUpICE9PSAtMSkge1xuICAgICAgdGhpcy5hbHdheXNGbG9hdExhYmVsID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgX2FwcGVuZFN0cmluZ1dpdGhTcGFjZTogZnVuY3Rpb24oc3RyLCBtb3JlKSB7XG4gICAgaWYgKHN0cikge1xuICAgICAgc3RyID0gc3RyICsgJyAnICsgbW9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gbW9yZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSxcblxuICBfb25BZGRvbkF0dGFjaGVkOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBkb20oZXZlbnQpLnJvb3RUYXJnZXQ7XG4gICAgaWYgKHRhcmdldC5pZCkge1xuICAgICAgdGhpcy5fYXJpYURlc2NyaWJlZEJ5ID0gdGhpcy5fYXBwZW5kU3RyaW5nV2l0aFNwYWNlKHRoaXMuX2FyaWFEZXNjcmliZWRCeSwgdGFyZ2V0LmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlkID0gJ3BhcGVyLWlucHV0LWFkZC1vbi0nICsgUGFwZXJJbnB1dEhlbHBlci5OZXh0QWRkb25JRCsrO1xuICAgICAgdGFyZ2V0LmlkID0gaWQ7XG4gICAgICB0aGlzLl9hcmlhRGVzY3JpYmVkQnkgPSB0aGlzLl9hcHBlbmRTdHJpbmdXaXRoU3BhY2UodGhpcy5fYXJpYURlc2NyaWJlZEJ5LCBpZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGlucHV0IGVsZW1lbnQgYW5kIHNldHMgYW4gZXJyb3Igc3R5bGUgaWYgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0RWxlbWVudC52YWxpZGF0ZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3J3YXJkIGZvY3VzIHRvIGlucHV0RWxlbWVudC4gT3ZlcnJpZGVuIGZyb20gSXJvbkNvbnRyb2xTdGF0ZS5cbiAgICovXG4gIF9mb2N1c0JsdXJIYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIElyb25Db250cm9sU3RhdGUuX2ZvY3VzQmx1ckhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAvLyBGb3J3YXJkIHRoZSBmb2N1cyB0byB0aGUgbmVzdGVkIGlucHV0LlxuICAgIGlmICh0aGlzLmZvY3VzZWQgJiYgIXRoaXMuX3NoaWZ0VGFiUHJlc3NlZCAmJiB0aGlzLl9mb2N1c2FibGVFbGVtZW50KSB7XG4gICAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVyIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBzaGlmdCt0YWIga2V5cHJlc3MgaXMgZGV0ZWN0ZWQgYnkgdGhlIG1lbnUuXG4gICAqXG4gICAqIEBwYXJhbSB7Q3VzdG9tRXZlbnR9IGV2ZW50IEEga2V5IGNvbWJpbmF0aW9uIGV2ZW50LlxuICAgKi9cbiAgX29uU2hpZnRUYWJEb3duOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBvbGRUYWJJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIHRoaXMuX3NoaWZ0VGFiUHJlc3NlZCA9IHRydWU7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIG9sZFRhYkluZGV4KTtcbiAgICAgIHRoaXMuX3NoaWZ0VGFiUHJlc3NlZCA9IGZhbHNlO1xuICAgIH0sIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBgYXV0b1ZhbGlkYXRlYCBpcyB0cnVlLCB0aGVuIHZhbGlkYXRlcyB0aGUgZWxlbWVudC5cbiAgICovXG4gIF9oYW5kbGVBdXRvVmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmF1dG9WYWxpZGF0ZSlcbiAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb24gYWZ0ZXIgdXBkYXRpbmcgdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWUgVGhlIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHNhdmVkLlxuICAgKi9cbiAgdXBkYXRlVmFsdWVBbmRQcmVzZXJ2ZUNhcmV0OiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgIC8vIE5vdCBhbGwgZWxlbWVudHMgbWlnaHQgaGF2ZSBzZWxlY3Rpb24sIGFuZCBldmVuIGlmIHRoZXkgaGF2ZSB0aGVcbiAgICAvLyByaWdodCBwcm9wZXJ0aWVzLCBhY2Nlc3NpbmcgdGhlbSBtaWdodCB0aHJvdyBhbiBleGNlcHRpb24gKGxpa2UgZm9yXG4gICAgLy8gPGlucHV0IHR5cGU9bnVtYmVyPilcbiAgICB0cnkge1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgIC8vIFRoZSBjdXJzb3IgYXV0b21hdGljYWxseSBqdW1wcyB0byB0aGUgZW5kIGFmdGVyIHJlLXNldHRpbmcgdGhlIHZhbHVlLFxuICAgICAgLy8gc28gcmVzdG9yZSBpdCB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgICB0aGlzLmlucHV0RWxlbWVudC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2VsZWN0aW9uRW5kID0gc3RhcnQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSnVzdCBzZXQgdGhlIHZhbHVlIGFuZCBnaXZlIHVwIG9uIHRoZSBjYXJldC5cbiAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgX2NvbXB1dGVBbHdheXNGbG9hdExhYmVsOiBmdW5jdGlvbihhbHdheXNGbG9hdExhYmVsLCBwbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBwbGFjZWhvbGRlciB8fCBhbHdheXNGbG9hdExhYmVsO1xuICB9LFxuXG4gIF91cGRhdGVBcmlhTGFiZWxsZWRCeTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxhYmVsID0gZG9tKHRoaXMucm9vdCkucXVlcnlTZWxlY3RvcignbGFiZWwnKTtcbiAgICBpZiAoIWxhYmVsKSB7XG4gICAgICB0aGlzLl9hcmlhTGFiZWxsZWRCeSA9ICcnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGFiZWxsZWRCeTtcbiAgICBpZiAobGFiZWwuaWQpIHtcbiAgICAgIGxhYmVsbGVkQnkgPSBsYWJlbC5pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWxsZWRCeSA9ICdwYXBlci1pbnB1dC1sYWJlbC0nICsgUGFwZXJJbnB1dEhlbHBlci5OZXh0TGFiZWxJRCsrO1xuICAgICAgbGFiZWwuaWQgPSBsYWJlbGxlZEJ5O1xuICAgIH1cbiAgICB0aGlzLl9hcmlhTGFiZWxsZWRCeSA9IGxhYmVsbGVkQnk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlOmZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gSW4gdGhlIFNoYWRvdyBET00sIHRoZSBgY2hhbmdlYCBldmVudCBpcyBub3QgbGVha2VkIGludG8gdGhlXG4gICAgLy8gYW5jZXN0b3IgdHJlZSwgc28gd2UgbXVzdCBkbyB0aGlzIG1hbnVhbGx5LlxuICAgIC8vIFNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL3NoYWRvdy8jZXZlbnRzLXRoYXQtYXJlLW5vdC1sZWFrZWQtaW50by1hbmNlc3Rvci10cmVlcy5cbiAgICBpZiAodGhpcy5zaGFkb3dSb290KSB7XG4gICAgICB0aGlzLmZpcmUoZXZlbnQudHlwZSwge3NvdXJjZUV2ZW50OiBldmVudH0sIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgYnViYmxlczogZXZlbnQuYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIF9hdXRvZm9jdXNDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBGaXJlZm94IGRvZXNuJ3QgcmVzcGVjdCB0aGUgYXV0b2ZvY3VzIGF0dHJpYnV0ZSBpZiBpdCdzIGFwcGxpZWQgYWZ0ZXJcbiAgICAvLyB0aGUgcGFnZSBpcyBsb2FkZWQgKENocm9tZS9XZWJLaXQgZG8gcmVzcGVjdCBpdCksIHByZXZlbnRpbmcgYW5cbiAgICAvLyBhdXRvZm9jdXMgYXR0cmlidXRlIHNwZWNpZmllZCBpbiBtYXJrdXAgZnJvbSB0YWtpbmcgZWZmZWN0IHdoZW4gdGhlXG4gICAgLy8gZWxlbWVudCBpcyB1cGdyYWRlZC4gQXMgYSB3b3JrYXJvdW5kLCBpZiB0aGUgYXV0b2ZvY3VzIHByb3BlcnR5IGlzIHNldCxcbiAgICAvLyBhbmQgdGhlIGZvY3VzIGhhc24ndCBhbHJlYWR5IGJlZW4gbW92ZWQgZWxzZXdoZXJlLCB3ZSB0YWtlIGZvY3VzLlxuICAgIGlmICh0aGlzLmF1dG9mb2N1cyAmJiB0aGlzLl9mb2N1c2FibGVFbGVtZW50KSB7XG5cbiAgICAgIC8vIEluIElFIDExLCB0aGUgZGVmYXVsdCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSB0aGUgcGFnZSdzXG4gICAgICAvLyBvdXRlcm1vc3QgaHRtbCBlbGVtZW50LCBidXQgdGhlcmUgYXJlIGFsc28gY2FzZXMgKHVuZGVyIHRoZVxuICAgICAgLy8gcG9seWZpbGw/KSBpbiB3aGljaCB0aGUgYWN0aXZlRWxlbWVudCBpcyBub3QgYSByZWFsIEhUTUxFbGVtZW50LCBidXRcbiAgICAgIC8vIGp1c3QgYSBwbGFpbiBvYmplY3QuIFdlIGlkZW50aWZ5IHRoZSBsYXR0ZXIgY2FzZSBhcyBoYXZpbmcgbm8gdmFsaWRcbiAgICAgIC8vIGFjdGl2ZUVsZW1lbnQuXG4gICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB2YXIgaXNBY3RpdmVFbGVtZW50VmFsaWQgPSBhY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG5cbiAgICAgIC8vIEhhcyBzb21lIG90aGVyIGVsZW1lbnQgaGFzIGFscmVhZHkgdGFrZW4gdGhlIGZvY3VzP1xuICAgICAgdmFyIGlzU29tZUVsZW1lbnRBY3RpdmUgPSBpc0FjdGl2ZUVsZW1lbnRWYWxpZCAmJlxuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkgJiZcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IC8qIElFIDExICovXG4gICAgICBpZiAoIWlzU29tZUVsZW1lbnRBY3RpdmUpIHtcbiAgICAgICAgLy8gTm8gc3BlY2lmaWMgZWxlbWVudCBoYXMgdGFrZW4gdGhlIGZvY3VzIHlldCwgc28gd2UgY2FuIHRha2UgaXQuXG4gICAgICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBQYXBlcklucHV0QmVoYXZpb3IgPSBbXG4gIElyb25Db250cm9sU3RhdGUsXG4gIElyb25BMTF5S2V5c0JlaGF2aW9yLFxuICBQYXBlcklucHV0QmVoYXZpb3JJbXBsXG5dO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL3R5cG9ncmFwaHkuanMnO1xuaW1wb3J0IHsgUGFwZXJJbnB1dEFkZG9uQmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLWlucHV0LWFkZG9uLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIGZsb2F0OiByaWdodDtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNhcHRpb247XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNoYXItY291bnRlcjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICA6aG9zdC1jb250ZXh0KFtkaXI9XCJydGxcIl0pIHtcbiAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxzcGFuPltbX2NoYXJDb3VudGVyU3RyXV08L3NwYW4+XG5gLFxuXG4gIGlzOiAncGFwZXItaW5wdXQtY2hhci1jb3VudGVyJyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBQYXBlcklucHV0QWRkb25CZWhhdmlvclxuICBdLFxuXG4gIHByb3BlcnRpZXM6IHtcbiAgICBfY2hhckNvdW50ZXJTdHI6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnMCdcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgb3ZlcnJpZGVzIHRoZSB1cGRhdGUgZnVuY3Rpb24gaW4gUGFwZXJJbnB1dEFkZG9uQmVoYXZpb3IuXG4gICAqIEBwYXJhbSB7e1xuICAgKiAgIGlucHV0RWxlbWVudDogKEVsZW1lbnR8dW5kZWZpbmVkKSxcbiAgICogICB2YWx1ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAgKiAgIGludmFsaWQ6IGJvb2xlYW5cbiAgICogfX0gc3RhdGUgLVxuICAgKiAgICAgaW5wdXRFbGVtZW50OiBUaGUgaW5wdXQgZWxlbWVudC5cbiAgICogICAgIHZhbHVlOiBUaGUgaW5wdXQgdmFsdWUuXG4gICAqICAgICBpbnZhbGlkOiBUcnVlIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBpbnZhbGlkLlxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuaW5wdXRFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUudmFsdWUgPSBzdGF0ZS52YWx1ZSB8fCAnJztcblxuICAgIHZhciBjb3VudGVyID0gc3RhdGUudmFsdWUudG9TdHJpbmcoKS5sZW5ndGgudG9TdHJpbmcoKTtcblxuICAgIGlmIChzdGF0ZS5pbnB1dEVsZW1lbnQuaGFzQXR0cmlidXRlKCdtYXhsZW5ndGgnKSkge1xuICAgICAgY291bnRlciArPSAnLycgKyBzdGF0ZS5pbnB1dEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtYXhsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGFyQ291bnRlclN0ciA9IGNvdW50ZXI7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtY2hhci1jb3VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL3R5cG9ncmFwaHkuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCB7IGRhc2hUb0NhbWVsQ2FzZSB9IGZyb20gJy4uL3BvbHltZXIvbGliL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcGFkZGluZzogOHB4IDA7XG5cbiAgICAgICAgLS1wYXBlci1pbnB1dC1jb250YWluZXItc2hhcmVkLWlucHV0LXN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOyAvKiB0byBtYWtlIGEgc3RhY2tpbmcgY29udGV4dCAqL1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1pbnB1dC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICAgICAgICAgIHRleHQtYWxpZ246IGluaGVyaXQ7XG4gICAgICAgICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcblxuICAgICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtc3ViaGVhZDtcbiAgICAgICAgfTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXI7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtpbmxpbmVdKSB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgb3BhY2l0eTogMC4zMztcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItZGlzYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgW2hpZGRlbl0ge1xuICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIC5mbG9hdGVkLWxhYmVsLXBsYWNlaG9sZGVyIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jYXB0aW9uO1xuICAgICAgfVxuXG4gICAgICAudW5kZXJsaW5lIHtcbiAgICAgICAgaGVpZ2h0OiAycHg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH1cblxuICAgICAgLmZvY3VzZWQtbGluZSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItZm9jdXMtY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcblxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG4gICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZTNkKDAsMSwxKTtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZTNkKDAsMSwxKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItdW5kZXJsaW5lLWZvY3VzO1xuICAgICAgfVxuXG4gICAgICAudW5kZXJsaW5lLmlzLWhpZ2hsaWdodGVkIC5mb2N1c2VkLWxpbmUge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogbm9uZTtcbiAgICAgICAgdHJhbnNmb3JtOiBub25lO1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIDAuMjVzO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4yNXM7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdHJhbnNpdGlvbi1lYXNpbmc7XG4gICAgICB9XG5cbiAgICAgIC51bmRlcmxpbmUuaXMtaW52YWxpZCAuZm9jdXNlZC1saW5lIHtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItaW52YWxpZC1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IG5vbmU7XG4gICAgICAgIHRyYW5zZm9ybTogbm9uZTtcbiAgICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiAtd2Via2l0LXRyYW5zZm9ybSAwLjI1cztcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMjVzO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRyYW5zaXRpb24tZWFzaW5nO1xuICAgICAgfVxuXG4gICAgICAudW5mb2N1c2VkLWxpbmUge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml0O1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWNvbG9yLCB2YXIoLS1zZWNvbmRhcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItdW5kZXJsaW5lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAudW5mb2N1c2VkLWxpbmUge1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1jb2xvciwgdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLXVuZGVybGluZS1kaXNhYmxlZDtcbiAgICAgIH1cblxuICAgICAgLmlucHV0LXdyYXBwZXIge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtaG9yaXpvbnRhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAuaW5wdXQtY29udGVudCB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1mbGV4LWF1dG87XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1yZWxhdGl2ZTtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgfVxuXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQobGFiZWwpLFxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKC5wYXBlci1pbnB1dC1sYWJlbCkge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBmb250OiBpbmhlcml0O1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWNvbG9yLCB2YXIoLS1zZWNvbmRhcnktdGV4dC1jb2xvcikpO1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIDAuMjVzLCB3aWR0aCAwLjI1cztcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMjVzLCB3aWR0aCAwLjI1cztcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcDtcbiAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3A7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tbm93cmFwO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LXN1YmhlYWQ7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1sYWJlbDtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdHJhbnNpdGlvbi1lYXNpbmc7XG4gICAgICB9XG5cbiAgICAgIC5pbnB1dC1jb250ZW50LmxhYmVsLWlzLWZsb2F0aW5nIDo6c2xvdHRlZChsYWJlbCksXG4gICAgICAuaW5wdXQtY29udGVudC5sYWJlbC1pcy1mbG9hdGluZyA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWxhYmVsKSB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC03NSUpIHNjYWxlKDAuNzUpO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTc1JSkgc2NhbGUoMC43NSk7XG5cbiAgICAgICAgLyogU2luY2Ugd2Ugc2NhbGUgdG8gNzUvMTAwIG9mIHRoZSBzaXplLCB3ZSBhY3R1YWxseSBoYXZlIDEwMC83NSBvZiB0aGVcbiAgICAgICAgb3JpZ2luYWwgc3BhY2Ugbm93IGF2YWlsYWJsZSAqL1xuICAgICAgICB3aWR0aDogMTMzJTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItbGFiZWwtZmxvYXRpbmc7XG4gICAgICB9XG5cbiAgICAgIDpob3N0LWNvbnRleHQoW2Rpcj1cInJ0bFwiXSkgLmlucHV0LWNvbnRlbnQubGFiZWwtaXMtZmxvYXRpbmcgOjpzbG90dGVkKGxhYmVsKSxcbiAgICAgIDpob3N0LWNvbnRleHQoW2Rpcj1cInJ0bFwiXSkgLmlucHV0LWNvbnRlbnQubGFiZWwtaXMtZmxvYXRpbmcgOjpzbG90dGVkKC5wYXBlci1pbnB1dC1sYWJlbCkge1xuICAgICAgICAvKiBUT0RPKG5vbXMpOiBGaWd1cmUgb3V0IHdoeSBsZWF2aW5nIHRoZSB3aWR0aCBhdCAxMzMlIGJlZm9yZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIGFjdHVhbGx5IG1ha2VzXG4gICAgICAgICAqIGl0IHdpZGVyIG9uIHRoZSByaWdodCBzaWRlLCBub3QgbGVmdCBzaWRlLCBhcyB5b3Ugd291bGQgZXhwZWN0IGluIFJUTCAqL1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiByaWdodCB0b3A7XG4gICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHJpZ2h0IHRvcDtcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQubGFiZWwtaXMtaGlnaGxpZ2h0ZWQgOjpzbG90dGVkKGxhYmVsKSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmxhYmVsLWlzLWhpZ2hsaWdodGVkIDo6c2xvdHRlZCgucGFwZXItaW5wdXQtbGFiZWwpIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1mb2N1cy1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1sYWJlbC1mb2N1cztcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQobGFiZWwpLFxuICAgICAgLmlucHV0LWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWxhYmVsKSB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItaW52YWxpZC1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQubGFiZWwtaXMtaGlkZGVuIDo6c2xvdHRlZChsYWJlbCksXG4gICAgICAuaW5wdXQtY29udGVudC5sYWJlbC1pcy1oaWRkZW4gOjpzbG90dGVkKC5wYXBlci1pbnB1dC1sYWJlbCkge1xuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC5pbnB1dC1jb250ZW50IDo6c2xvdHRlZChpcm9uLWlucHV0KSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1zaGFyZWQtaW5wdXQtc3R5bGU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5pbnB1dC1jb250ZW50IDo6c2xvdHRlZChpbnB1dCksXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQodGV4dGFyZWEpLFxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKGlyb24tYXV0b2dyb3ctdGV4dGFyZWEpLFxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKC5wYXBlci1pbnB1dC1pbnB1dCkge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItc2hhcmVkLWlucHV0LXN0eWxlO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIC5pbnB1dC1jb250ZW50IDo6c2xvdHRlZChpbnB1dCk6Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24sXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQoaW5wdXQpOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWlucHV0LXdlYmtpdC1zcGlubmVyO1xuICAgICAgfVxuICAgICAgXG4gICAgICAuaW5wdXQtY29udGVudC5mb2N1c2VkIDo6c2xvdHRlZChpbnB1dCksXG4gICAgICAuaW5wdXQtY29udGVudC5mb2N1c2VkIDo6c2xvdHRlZCh0ZXh0YXJlYSksXG4gICAgICAuaW5wdXQtY29udGVudC5mb2N1c2VkIDo6c2xvdHRlZChpcm9uLWF1dG9ncm93LXRleHRhcmVhKSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmZvY3VzZWQgOjpzbG90dGVkKC5wYXBlci1pbnB1dC1pbnB1dCkge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQtZm9jdXM7XG4gICAgICB9XG5cbiAgICAgIC5pbnB1dC1jb250ZW50LmlzLWludmFsaWQgOjpzbG90dGVkKGlucHV0KSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmlzLWludmFsaWQgOjpzbG90dGVkKHRleHRhcmVhKSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmlzLWludmFsaWQgOjpzbG90dGVkKGlyb24tYXV0b2dyb3ctdGV4dGFyZWEpLFxuICAgICAgLmlucHV0LWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWlucHV0KSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1pbnB1dC1pbnZhbGlkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAucHJlZml4IDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1zdWJoZWFkO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZmxleC1ub25lO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1wcmVmaXg7XG4gICAgICB9XG5cbiAgICAgIC5zdWZmaXggOjpzbG90dGVkKCopIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LXN1YmhlYWQ7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1mbGV4LW5vbmU7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtc3VmZml4O1xuICAgICAgfVxuXG4gICAgICAvKiBGaXJlZm94IHNldHMgYSBtaW4td2lkdGggb24gdGhlIGlucHV0LCB3aGljaCBjYW4gY2F1c2UgbGF5b3V0IGlzc3VlcyAqL1xuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKGlucHV0KSB7XG4gICAgICAgIG1pbi13aWR0aDogMDtcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKHRleHRhcmVhKSB7XG4gICAgICAgIHJlc2l6ZTogbm9uZTtcbiAgICAgIH1cblxuICAgICAgLmFkZC1vbi1jb250ZW50IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAuYWRkLW9uLWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQoKikge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWludmFsaWQtY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIC5hZGQtb24tY29udGVudC5pcy1oaWdobGlnaHRlZCA6OnNsb3R0ZWQoKikge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWZvY3VzLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxkaXYgY2xhc3M9XCJmbG9hdGVkLWxhYmVsLXBsYWNlaG9sZGVyXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgaGlkZGVuPVwiW1tub0xhYmVsRmxvYXRdXVwiPiZuYnNwOzwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LXdyYXBwZXJcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwicHJlZml4XCI+PHNsb3QgbmFtZT1cInByZWZpeFwiPjwvc2xvdD48L3NwYW4+XG5cbiAgICAgIDxkaXYgY2xhc3NcXCQ9XCJbW19jb21wdXRlSW5wdXRDb250ZW50Q2xhc3Mobm9MYWJlbEZsb2F0LGFsd2F5c0Zsb2F0TGFiZWwsZm9jdXNlZCxpbnZhbGlkLF9pbnB1dEhhc0NvbnRlbnQpXV1cIiBpZD1cImxhYmVsQW5kSW5wdXRDb250YWluZXJcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsXCI+PC9zbG90PlxuICAgICAgICA8c2xvdCBuYW1lPVwiaW5wdXRcIj48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPHNwYW4gY2xhc3M9XCJzdWZmaXhcIj48c2xvdCBuYW1lPVwic3VmZml4XCI+PC9zbG90Pjwvc3Bhbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3NcXCQ9XCJbW19jb21wdXRlVW5kZXJsaW5lQ2xhc3MoZm9jdXNlZCxpbnZhbGlkKV1dXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwidW5mb2N1c2VkLWxpbmVcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJmb2N1c2VkLWxpbmVcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3NcXCQ9XCJbW19jb21wdXRlQWRkT25Db250ZW50Q2xhc3MoZm9jdXNlZCxpbnZhbGlkKV1dXCI+XG4gICAgICA8c2xvdCBuYW1lPVwiYWRkLW9uXCI+PC9zbG90PlxuICAgIDwvZGl2PlxuYCxcblxuICBpczogJ3BhcGVyLWlucHV0LWNvbnRhaW5lcicsXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdGhlIGZsb2F0aW5nIGxhYmVsLiBUaGUgbGFiZWwgZGlzYXBwZWFycyB3aGVuIHRoZSBpbnB1dCB2YWx1ZSBpc1xuICAgICAqIG5vdCBudWxsLlxuICAgICAqL1xuICAgIG5vTGFiZWxGbG9hdDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBhbHdheXMgZmxvYXQgdGhlIGZsb2F0aW5nIGxhYmVsLlxuICAgICAqL1xuICAgIGFsd2F5c0Zsb2F0TGFiZWw6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGF0dHJpYnV0ZSB0byBsaXN0ZW4gZm9yIHZhbHVlIGNoYW5nZXMgb24uXG4gICAgICovXG4gICAgYXR0ckZvclZhbHVlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2JpbmQtdmFsdWUnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGF1dG8tdmFsaWRhdGUgdGhlIGlucHV0IHZhbHVlIHdoZW4gaXQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBhdXRvVmFsaWRhdGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgaW5wdXQgaXMgaW52YWxpZC4gVGhpcyBwcm9wZXJ0eSBpcyBzZXQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBpbnB1dCB2YWx1ZVxuICAgICAqIGNoYW5nZXMgaWYgYXV0by12YWxpZGF0aW5nLCBvciB3aGVuIHRoZSBgaXJvbi1pbnB1dC12YWxpZGF0ZWAgZXZlbnQgaXMgaGVhcmQgZnJvbSBhIGNoaWxkLlxuICAgICAqL1xuICAgIGludmFsaWQ6IHtcbiAgICAgIG9ic2VydmVyOiAnX2ludmFsaWRDaGFuZ2VkJyxcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgaW5wdXQgaGFzIGZvY3VzLlxuICAgICAqL1xuICAgIGZvY3VzZWQ6IHtcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG5vdGlmeTogdHJ1ZVxuICAgIH0sXG5cbiAgICBfYWRkb25zOiB7XG4gICAgICB0eXBlOiBBcnJheVxuICAgICAgLy8gZG8gbm90IHNldCBhIGRlZmF1bHQgdmFsdWUgaGVyZSBpbnRlbnRpb25hbGx5IC0gaXQgd2lsbCBiZSBpbml0aWFsaXplZCBsYXppbHkgd2hlbiBhXG4gICAgICAvLyBkaXN0cmlidXRlZCBjaGlsZCBpcyBhdHRhY2hlZCwgd2hpY2ggbWF5IG9jY3VyIGJlZm9yZSBjb25maWd1cmF0aW9uIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgIC8vIGluIHBvbHlmaWxsLlxuICAgIH0sXG5cbiAgICBfaW5wdXRIYXNDb250ZW50OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIF9pbnB1dFNlbGVjdG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2lucHV0LGlyb24taW5wdXQsdGV4dGFyZWEsLnBhcGVyLWlucHV0LWlucHV0J1xuICAgIH0sXG5cbiAgICBfYm91bmRPbkZvY3VzOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2JvdW5kT25CbHVyOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uQmx1ci5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfYm91bmRPbklucHV0OiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2JvdW5kVmFsdWVDaGFuZ2VkOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uVmFsdWVDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGxpc3RlbmVyczoge1xuICAgICdhZGRvbi1hdHRhY2hlZCc6ICdfb25BZGRvbkF0dGFjaGVkJyxcbiAgICAnaXJvbi1pbnB1dC12YWxpZGF0ZSc6ICdfb25Jcm9uSW5wdXRWYWxpZGF0ZSdcbiAgfSxcblxuICBnZXQgX3ZhbHVlQ2hhbmdlZEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJGb3JWYWx1ZSArICctY2hhbmdlZCc7XG4gIH0sXG5cbiAgZ2V0IF9wcm9wZXJ0eUZvclZhbHVlKCkge1xuICAgIHJldHVybiBkYXNoVG9DYW1lbENhc2UodGhpcy5hdHRyRm9yVmFsdWUpO1xuICB9LFxuXG4gIGdldCBfaW5wdXRFbGVtZW50KCkge1xuICAgIHJldHVybiBkb20odGhpcykucXVlcnlTZWxlY3Rvcih0aGlzLl9pbnB1dFNlbGVjdG9yKTtcbiAgfSxcblxuICBnZXQgX2lucHV0RWxlbWVudFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dEVsZW1lbnRbdGhpcy5fcHJvcGVydHlGb3JWYWx1ZV0gfHwgdGhpcy5faW5wdXRFbGVtZW50LnZhbHVlO1xuICB9LFxuXG4gIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2FkZG9ucykge1xuICAgICAgdGhpcy5fYWRkb25zID0gW107XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZE9uRm9jdXMsIHRydWUpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kT25CbHVyLCB0cnVlKTtcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYXR0ckZvclZhbHVlKSB7XG4gICAgICB0aGlzLl9pbnB1dEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl92YWx1ZUNoYW5nZWRFdmVudCwgdGhpcy5fYm91bmRWYWx1ZUNoYW5nZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fb25JbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gT25seSB2YWxpZGF0ZSB3aGVuIGF0dGFjaGVkIGlmIHRoZSBpbnB1dCBhbHJlYWR5IGhhcyBhIHZhbHVlLlxuICAgIGlmICh0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSAmJiB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSAhPSAnJykge1xuICAgICAgdGhpcy5faGFuZGxlVmFsdWVBbmRBdXRvVmFsaWRhdGUodGhpcy5faW5wdXRFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlVmFsdWUodGhpcy5faW5wdXRFbGVtZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQWRkb25BdHRhY2hlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2FkZG9ucykge1xuICAgICAgdGhpcy5fYWRkb25zID0gW107XG4gICAgfVxuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgaWYgKHRoaXMuX2FkZG9ucy5pbmRleE9mKHRhcmdldCkgPT09IC0xKSB7XG4gICAgICB0aGlzLl9hZGRvbnMucHVzaCh0YXJnZXQpO1xuICAgICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVWYWx1ZSh0aGlzLl9pbnB1dEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfb25Gb2N1czogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2V0Rm9jdXNlZCh0cnVlKTtcbiAgfSxcblxuICBfb25CbHVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZXRGb2N1c2VkKGZhbHNlKTtcbiAgICB0aGlzLl9oYW5kbGVWYWx1ZUFuZEF1dG9WYWxpZGF0ZSh0aGlzLl9pbnB1dEVsZW1lbnQpO1xuICB9LFxuXG4gIF9vbklucHV0OiBmdW5jdGlvbihldmVudCkge1xuICAgIHRoaXMuX2hhbmRsZVZhbHVlQW5kQXV0b1ZhbGlkYXRlKGV2ZW50LnRhcmdldCk7XG4gIH0sXG5cbiAgX29uVmFsdWVDaGFuZ2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBpbnB1dCA9IGV2ZW50LnRhcmdldDtcblxuICAgIC8vIFByb2JsZW06IGlmIHRoZSBpbnB1dCBpcyByZXF1aXJlZCBidXQgaGFzIG5vIHRleHQgZW50ZXJlZCwgd2Ugc2hvdWxkXG4gICAgLy8gb25seSB2YWxpZGF0ZSBpdCBvbiBibHVyIChzbyB0aGF0IGFuIGVtcHR5IGZvcm0gZG9lc24ndCBjb21lIHVwIHJlZFxuICAgIC8vIGltbWVkaWF0ZWx5OyBob3dldmVyLCBpbiB0aGlzIGhhbmRsZXIsIHdlIGRvbid0IGtub3cgd2hldGhlciB0aGlzIGlzXG4gICAgLy8gdGhlIGJvb3RpbmcgdXAgdmFsdWUgb3IgYSB2YWx1ZSBpbiB0aGUgZnV0dXJlLiBJIGFtIGFzc3VtaW5nIHRoYXQgdGhlXG4gICAgLy8gY2FzZSAgd2UgY2FyZSBhYm91dCBtYW5pZmVzdHMgaXRzZWxmIHdoZW4gdGhlIHZhbHVlIGlzIHVuZGVmaW5lZC5cbiAgICAvLyBJZiB0aGlzIGNhdXNlcyBmdXR1cmUgcHJvYmxlbXMsIHdlIG5lZWQgdG8gZG8gc29tZXRoaW5nIGxpa2UgdHJhY2sgd2hldGhlclxuICAgIC8vIHRoZSBpcm9uLWlucHV0LXJlYWR5IGV2ZW50IGhhcyBmaXJlZCwgYW5kIHRoaXMgaGFuZGxlciBjYW1lIGJlZm9yZSB0aGF0LlxuXG4gICAgaWYgKGlucHV0LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVWYWx1ZUFuZEF1dG9WYWxpZGF0ZShldmVudC50YXJnZXQpO1xuICB9LFxuXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24oaW5wdXRFbGVtZW50KSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5faW5wdXRFbGVtZW50VmFsdWU7XG5cbiAgICAvLyB0eXBlPVwibnVtYmVyXCIgaGFjayBuZWVkZWQgYmVjYXVzZSB0aGlzLnZhbHVlIGlzIGVtcHR5IHVudGlsIGl0J3MgdmFsaWRcbiAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDAgfHwgKGlucHV0RWxlbWVudC50eXBlID09PSAnbnVtYmVyJyAmJiAhaW5wdXRFbGVtZW50LmNoZWNrVmFsaWRpdHkoKSkpIHtcbiAgICAgIHRoaXMuX2lucHV0SGFzQ29udGVudCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lucHV0SGFzQ29udGVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQWRkb25zKHtcbiAgICAgIGlucHV0RWxlbWVudDogaW5wdXRFbGVtZW50LFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgaW52YWxpZDogdGhpcy5pbnZhbGlkXG4gICAgfSk7XG4gIH0sXG5cbiAgX2hhbmRsZVZhbHVlQW5kQXV0b1ZhbGlkYXRlOiBmdW5jdGlvbihpbnB1dEVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5hdXRvVmFsaWRhdGUgJiYgaW5wdXRFbGVtZW50KSB7XG4gICAgICB2YXIgdmFsaWQ7XG5cbiAgICAgIGlmIChpbnB1dEVsZW1lbnQudmFsaWRhdGUpIHtcbiAgICAgICAgdmFsaWQgPSBpbnB1dEVsZW1lbnQudmFsaWRhdGUodGhpcy5faW5wdXRFbGVtZW50VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWQgPSBpbnB1dEVsZW1lbnQuY2hlY2tWYWxpZGl0eSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnZhbGlkID0gIXZhbGlkO1xuICAgIH1cblxuICAgIC8vIENhbGwgdGhpcyBsYXN0IHRvIG5vdGlmeSB0aGUgYWRkLW9ucy5cbiAgICB0aGlzLl9oYW5kbGVWYWx1ZShpbnB1dEVsZW1lbnQpO1xuICB9LFxuXG4gIF9vbklyb25JbnB1dFZhbGlkYXRlOiBmdW5jdGlvbihldmVudCkge1xuICAgIHRoaXMuaW52YWxpZCA9IHRoaXMuX2lucHV0RWxlbWVudC5pbnZhbGlkO1xuICB9LFxuXG4gIF9pbnZhbGlkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2FkZG9ucykge1xuICAgICAgdGhpcy51cGRhdGVBZGRvbnMoe2ludmFsaWQ6IHRoaXMuaW52YWxpZH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIHVwZGF0ZSB0aGUgc3RhdGUgb2YgYWRkLW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIEFkZC1vbiBzdGF0ZS5cbiAgICovXG4gIHVwZGF0ZUFkZG9uczogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBmb3IgKHZhciBhZGRvbiwgaW5kZXggPSAwOyBhZGRvbiA9IHRoaXMuX2FkZG9uc1tpbmRleF07IGluZGV4KyspIHtcbiAgICAgIGFkZG9uLnVwZGF0ZShzdGF0ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9jb21wdXRlSW5wdXRDb250ZW50Q2xhc3M6IGZ1bmN0aW9uKG5vTGFiZWxGbG9hdCwgYWx3YXlzRmxvYXRMYWJlbCwgZm9jdXNlZCwgaW52YWxpZCwgX2lucHV0SGFzQ29udGVudCkge1xuICAgIHZhciBjbHMgPSAnaW5wdXQtY29udGVudCc7XG4gICAgaWYgKCFub0xhYmVsRmxvYXQpIHtcbiAgICAgIHZhciBsYWJlbCA9IHRoaXMucXVlcnlTZWxlY3RvcignbGFiZWwnKTtcblxuICAgICAgaWYgKGFsd2F5c0Zsb2F0TGFiZWwgfHwgX2lucHV0SGFzQ29udGVudCkge1xuICAgICAgICBjbHMgKz0gJyBsYWJlbC1pcy1mbG9hdGluZyc7XG4gICAgICAgIC8vIElmIHRoZSBsYWJlbCBpcyBmbG9hdGluZywgaWdub3JlIGFueSBvZmZzZXRzIHRoYXQgbWF5IGhhdmUgYmVlblxuICAgICAgICAvLyBhcHBsaWVkIGZyb20gYSBwcmVmaXggZWxlbWVudC5cbiAgICAgICAgdGhpcy4kLmxhYmVsQW5kSW5wdXRDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnc3RhdGljJztcblxuICAgICAgICBpZiAoaW52YWxpZCkge1xuICAgICAgICAgIGNscyArPSAnIGlzLWludmFsaWQnO1xuICAgICAgICB9IGVsc2UgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICBjbHMgKz0gXCIgbGFiZWwtaXMtaGlnaGxpZ2h0ZWRcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgbGFiZWwgaXMgbm90IGZsb2F0aW5nLCBpdCBzaG91bGQgb3ZlcmxhcCB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgdGhpcy4kLmxhYmVsQW5kSW5wdXRDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICAgICAgY2xzICs9ICcgaXMtaW52YWxpZCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF9pbnB1dEhhc0NvbnRlbnQpIHtcbiAgICAgICAgY2xzICs9ICcgbGFiZWwtaXMtaGlkZGVuJztcbiAgICAgIH1cbiAgICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICAgIGNscyArPSAnIGlzLWludmFsaWQnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgY2xzICs9ICcgZm9jdXNlZCc7XG4gICAgfVxuICAgIHJldHVybiBjbHM7XG4gIH0sXG5cbiAgX2NvbXB1dGVVbmRlcmxpbmVDbGFzczogZnVuY3Rpb24oZm9jdXNlZCwgaW52YWxpZCkge1xuICAgIHZhciBjbHMgPSAndW5kZXJsaW5lJztcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgY2xzICs9ICcgaXMtaW52YWxpZCc7XG4gICAgfSBlbHNlIGlmIChmb2N1c2VkKSB7XG4gICAgICBjbHMgKz0gJyBpcy1oaWdobGlnaHRlZCdcbiAgICB9XG4gICAgcmV0dXJuIGNscztcbiAgfSxcblxuICBfY29tcHV0ZUFkZE9uQ29udGVudENsYXNzOiBmdW5jdGlvbihmb2N1c2VkLCBpbnZhbGlkKSB7XG4gICAgdmFyIGNscyA9ICdhZGQtb24tY29udGVudCc7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIGNscyArPSAnIGlzLWludmFsaWQnO1xuICAgIH0gZWxzZSBpZiAoZm9jdXNlZCkge1xuICAgICAgY2xzICs9ICcgaXMtaGlnaGxpZ2h0ZWQnXG4gICAgfVxuICAgIHJldHVybiBjbHM7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtY29udGFpbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL3R5cG9ncmFwaHkuanMnO1xuaW1wb3J0IHsgUGFwZXJJbnB1dEFkZG9uQmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLWlucHV0LWFkZG9uLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcblxuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWludmFsaWQtY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jYXB0aW9uO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1lcnJvcjtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OjA7XG4gICAgICAgIHJpZ2h0OjA7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtpbnZhbGlkXSkge1xuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgICAgfTtcbiAgICA8L3N0eWxlPlxuXG4gICAgPHNsb3Q+PC9zbG90PlxuYCxcblxuICBpczogJ3BhcGVyLWlucHV0LWVycm9yJyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBQYXBlcklucHV0QWRkb25CZWhhdmlvclxuICBdLFxuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBlcnJvciBpcyBzaG93aW5nLlxuICAgICAqL1xuICAgIGludmFsaWQ6IHtcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBvdmVycmlkZXMgdGhlIHVwZGF0ZSBmdW5jdGlvbiBpbiBQYXBlcklucHV0QWRkb25CZWhhdmlvci5cbiAgICogQHBhcmFtIHt7XG4gICAqICAgaW5wdXRFbGVtZW50OiAoRWxlbWVudHx1bmRlZmluZWQpLFxuICAgKiAgIHZhbHVlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICAqICAgaW52YWxpZDogYm9vbGVhblxuICAgKiB9fSBzdGF0ZSAtXG4gICAqICAgICBpbnB1dEVsZW1lbnQ6IFRoZSBpbnB1dCBlbGVtZW50LlxuICAgKiAgICAgdmFsdWU6IFRoZSBpbnB1dCB2YWx1ZS5cbiAgICogICAgIGludmFsaWQ6IFRydWUgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGludmFsaWQuXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5fc2V0SW52YWxpZChzdGF0ZS5pbnZhbGlkKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC1lcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyc7XG5pbXBvcnQgeyBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3IgfSBmcm9tICcuLi9wYXBlci1iZWhhdmlvcnMvcGFwZXItY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQgeyBhZnRlck5leHRSZW5kZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzJztcbmltcG9ydCB7IFBhcGVySW5reUZvY3VzQmVoYXZpb3JJbXBsIH0gZnJvbSAnLi4vcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxkb20tbW9kdWxlIGlkPVwicGFwZXItY2hlY2tib3hcIj5cbiAgPHRlbXBsYXRlIHN0cmlwLXdoaXRlc3BhY2U9XCJcIj5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZTogdmFyKC0tcGFwZXItY2hlY2tib3gtc2l6ZSwgMThweCk7XG4gICAgICAgIC8qIC0xcHggaXMgYSBzZW50aW5lbCBmb3IgdGhlIGRlZmF1bHQgYW5kIGlzIHJlcGxhY2VkIGluIFxcYGF0dGFjaGVkXFxgLiAqL1xuICAgICAgICAtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtaW5rLXNpemU6IHZhcigtLXBhcGVyLWNoZWNrYm94LWluay1zaXplLCAtMXB4KTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoOmZvY3VzKSB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIC5oaWRkZW4ge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgfVxuXG4gICAgICAjY2hlY2tib3hDb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZSk7XG4gICAgICAgIGhlaWdodDogdmFyKC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1zaXplKTtcbiAgICAgICAgbWluLXdpZHRoOiB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUpO1xuICAgICAgICBtYXJnaW46IHZhcigtLXBhcGVyLWNoZWNrYm94LW1hcmdpbiwgaW5pdGlhbCk7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB2YXIoLS1wYXBlci1jaGVja2JveC12ZXJ0aWNhbC1hbGlnbiwgbWlkZGxlKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtdW5jaGVja2VkLWJhY2tncm91bmQtY29sb3IsIHRyYW5zcGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgI2luayB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblxuICAgICAgICAvKiBDZW50ZXIgdGhlIHJpcHBsZSBpbiB0aGUgY2hlY2tib3ggYnkgbmVnYXRpdmUgb2Zmc2V0dGluZyBpdCBieVxuICAgICAgICAgKiAoaW5rV2lkdGggLSByaXBwbGVXaWR0aCkgLyAyICovXG4gICAgICAgIHRvcDogY2FsYygwcHggLSAodmFyKC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1pbmstc2l6ZSkgLSB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUpKSAvIDIpO1xuICAgICAgICBsZWZ0OiBjYWxjKDBweCAtICh2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LWluay1zaXplKSAtIHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZSkpIC8gMik7XG4gICAgICAgIHdpZHRoOiB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LWluay1zaXplKTtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LWluay1zaXplKTtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LXVuY2hlY2tlZC1pbmstY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBvcGFjaXR5OiAwLjY7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdC1jb250ZXh0KFtkaXI9XCJydGxcIl0pICNpbmsge1xuICAgICAgICByaWdodDogY2FsYygwcHggLSAodmFyKC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1pbmstc2l6ZSkgLSB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUpKSAvIDIpO1xuICAgICAgICBsZWZ0OiBhdXRvO1xuICAgICAgfVxuXG4gICAgICAjaW5rW2NoZWNrZWRdIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LWNoZWNrZWQtaW5rLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgICNjaGVja2JveCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBib3JkZXI6IHNvbGlkIDJweDtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1wYXBlci1jaGVja2JveC11bmNoZWNrZWQtY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTQwbXMsIGJvcmRlci1jb2xvciAxNDBtcztcbiAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAxNDBtcywgYm9yZGVyLWNvbG9yIDE0MG1zO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVja2JveCBjaGVja2VkIGFuaW1hdGlvbnMgKi9cbiAgICAgICNjaGVja2JveC5jaGVja2VkICNjaGVja21hcmsge1xuICAgICAgICAtd2Via2l0LWFuaW1hdGlvbjogY2hlY2ttYXJrLWV4cGFuZCAxNDBtcyBlYXNlLW91dCBmb3J3YXJkcztcbiAgICAgICAgYW5pbWF0aW9uOiBjaGVja21hcmstZXhwYW5kIDE0MG1zIGVhc2Utb3V0IGZvcndhcmRzO1xuICAgICAgfVxuXG4gICAgICBALXdlYmtpdC1rZXlmcmFtZXMgY2hlY2ttYXJrLWV4cGFuZCB7XG4gICAgICAgIDAlIHtcbiAgICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCwgMCkgcm90YXRlKDQ1ZGVnKTtcbiAgICAgICAgfVxuICAgICAgICAxMDAlIHtcbiAgICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSwgMSkgcm90YXRlKDQ1ZGVnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBAa2V5ZnJhbWVzIGNoZWNrbWFyay1leHBhbmQge1xuICAgICAgICAwJSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLCAwKSByb3RhdGUoNDVkZWcpO1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSwgMSkgcm90YXRlKDQ1ZGVnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAjY2hlY2tib3guY2hlY2tlZCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LWNoZWNrZWQtY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1wYXBlci1jaGVja2JveC1jaGVja2VkLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgICNjaGVja21hcmsge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAzNiU7XG4gICAgICAgIGhlaWdodDogNzAlO1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgICBib3JkZXItdG9wOiBub25lO1xuICAgICAgICBib3JkZXItbGVmdDogbm9uZTtcbiAgICAgICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiBjYWxjKDIvMTUgKiB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUpKTtcbiAgICAgICAgYm9yZGVyLWJvdHRvbS13aWR0aDogY2FsYygyLzE1ICogdmFyKC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1zaXplKSk7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtY2hlY2ttYXJrLWNvbG9yLCB3aGl0ZSk7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogOTclIDg2JTtcbiAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogOTclIDg2JTtcbiAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7IC8qIHByb3RlY3QgYWdhaW5zdCBwYWdlLWxldmVsIGJveC1zaXppbmcgKi9cbiAgICAgIH1cblxuICAgICAgOmhvc3QtY29udGV4dChbZGlyPVwicnRsXCJdKSAjY2hlY2ttYXJrIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMTQlO1xuICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMTQlO1xuICAgICAgfVxuXG4gICAgICAvKiBsYWJlbCAqL1xuICAgICAgI2NoZWNrYm94TGFiZWwge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiB2YXIoLS1wYXBlci1jaGVja2JveC1sYWJlbC1zcGFjaW5nLCA4cHgpO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xuICAgICAgICBsaW5lLWhlaWdodDogbm9ybWFsO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtbGFiZWwtY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1jaGVja2JveC1sYWJlbDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2NoZWNrZWRdKSAjY2hlY2tib3hMYWJlbCB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1jaGVja2JveC1sYWJlbC1jaGVja2VkLWNvbG9yLCB2YXIoLS1wYXBlci1jaGVja2JveC1sYWJlbC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSkpO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1jaGVja2JveC1sYWJlbC1jaGVja2VkO1xuICAgICAgfVxuXG4gICAgICA6aG9zdC1jb250ZXh0KFtkaXI9XCJydGxcIl0pICNjaGVja2JveExhYmVsIHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tcGFwZXItY2hlY2tib3gtbGFiZWwtc3BhY2luZywgOHB4KTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiAwO1xuICAgICAgfVxuXG4gICAgICAjY2hlY2tib3hMYWJlbFtoaWRkZW5dIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIH1cblxuICAgICAgLyogZGlzYWJsZWQgc3RhdGUgKi9cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgI2NoZWNrYm94IHtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LXVuY2hlY2tlZC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF1bY2hlY2tlZF0pICNjaGVja2JveCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LXVuY2hlY2tlZC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgI2NoZWNrYm94TGFiZWwgIHtcbiAgICAgICAgb3BhY2l0eTogMC42NTtcbiAgICAgIH1cblxuICAgICAgLyogaW52YWxpZCBzdGF0ZSAqL1xuICAgICAgI2NoZWNrYm94LmludmFsaWQ6bm90KC5jaGVja2VkKSB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtZXJyb3ItY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxkaXYgaWQ9XCJjaGVja2JveENvbnRhaW5lclwiPlxuICAgICAgPGRpdiBpZD1cImNoZWNrYm94XCIgY2xhc3NcXCQ9XCJbW19jb21wdXRlQ2hlY2tib3hDbGFzcyhjaGVja2VkLCBpbnZhbGlkKV1dXCI+XG4gICAgICAgIDxkaXYgaWQ9XCJjaGVja21hcmtcIiBjbGFzc1xcJD1cIltbX2NvbXB1dGVDaGVja21hcmtDbGFzcyhjaGVja2VkKV1dXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgaWQ9XCJjaGVja2JveExhYmVsXCI+PHNsb3Q+PC9zbG90PjwvZGl2PlxuICA8L3RlbXBsYXRlPlxuXG4gIFxuPC9kb20tbW9kdWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5Qb2x5bWVyKHtcbiAgaXM6ICdwYXBlci1jaGVja2JveCcsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9yXG4gIF0sXG5cbiAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICByb2xlOiAnY2hlY2tib3gnLFxuICAgICdhcmlhLWNoZWNrZWQnOiBmYWxzZSxcbiAgICB0YWJpbmRleDogMFxuICB9LFxuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMgZHVlIHRvIHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1jaGFuZ2VcbiAgICAgKi9cbiAgICBhcmlhQWN0aXZlQXR0cmlidXRlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2FyaWEtY2hlY2tlZCdcbiAgICB9XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFdhaXQgdW50aWwgc3R5bGVzIGhhdmUgcmVzb2x2ZWQgdG8gY2hlY2sgZm9yIHRoZSBkZWZhdWx0IHNlbnRpbmVsLlxuICAgIC8vIFNlZSBwb2x5bWVyIzQwMDkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBhZnRlck5leHRSZW5kZXIodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5rU2l6ZSA9IHRoaXMuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCctLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtaW5rLXNpemUnKS50cmltKCk7XG4gICAgICAvLyBJZiB1bnNldCwgY29tcHV0ZSBhbmQgc2V0IHRoZSBkZWZhdWx0IGAtLXBhcGVyLWNoZWNrYm94LWluay1zaXplYC5cbiAgICAgIGlmIChpbmtTaXplID09PSAnLTFweCcpIHtcbiAgICAgICAgdmFyIGNoZWNrYm94U2l6ZVRleHQgPSB0aGlzLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUnKS50cmltKCk7XG5cbiAgICAgICAgdmFyIHVuaXRzID0gY2hlY2tib3hTaXplVGV4dC5tYXRjaCgvW0EtWmEtel0rJC8pWzBdIHx8ICdweCc7XG4gICAgICAgIHZhciBjaGVja2JveFNpemUgPSBwYXJzZUZsb2F0KGNoZWNrYm94U2l6ZVRleHQsIDEwKTtcbiAgICAgICAgdmFyIGRlZmF1bHRJbmtTaXplID0gKDggLyAzKSAqIGNoZWNrYm94U2l6ZTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgICBkZWZhdWx0SW5rU2l6ZSA9IE1hdGguZmxvb3IoZGVmYXVsdElua1NpemUpO1xuXG4gICAgICAgICAgLy8gVGhlIGNoZWNrYm94IGFuZCByaXBwbGUgbmVlZCB0byBoYXZlIHRoZSBzYW1lIHBhcml0eSBzbyB0aGF0IHRoZWlyXG4gICAgICAgICAgLy8gY2VudGVycyBhbGlnbi5cbiAgICAgICAgICBpZiAoZGVmYXVsdElua1NpemUgJSAyICE9PSBjaGVja2JveFNpemUgJSAyKSB7XG4gICAgICAgICAgICBkZWZhdWx0SW5rU2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGVzKHtcbiAgICAgICAgICAnLS1wYXBlci1jaGVja2JveC1pbmstc2l6ZSc6IGRlZmF1bHRJbmtTaXplICsgdW5pdHMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIF9jb21wdXRlQ2hlY2tib3hDbGFzczogZnVuY3Rpb24oY2hlY2tlZCwgaW52YWxpZCkge1xuICAgIHZhciBjbGFzc05hbWUgPSAnJztcbiAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgY2xhc3NOYW1lICs9ICdjaGVja2VkICc7XG4gICAgfVxuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gJ2ludmFsaWQnO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9LFxuXG4gIF9jb21wdXRlQ2hlY2ttYXJrQ2xhc3M6IGZ1bmN0aW9uKGNoZWNrZWQpIHtcbiAgICByZXR1cm4gY2hlY2tlZCA/ICcnIDogJ2hpZGRlbic7XG4gIH0sXG5cbiAgLy8gY3JlYXRlIHJpcHBsZSBpbnNpZGUgdGhlIGNoZWNrYm94Q29udGFpbmVyXG4gIF9jcmVhdGVSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3JpcHBsZUNvbnRhaW5lciA9IHRoaXMuJC5jaGVja2JveENvbnRhaW5lcjtcbiAgICByZXR1cm4gUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGwuX2NyZWF0ZVJpcHBsZS5jYWxsKHRoaXMpO1xuICB9XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItY2hlY2tib3gvcGFwZXItY2hlY2tib3guanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25WYWxpZGF0YWJsZUJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IElyb25Gb3JtRWxlbWVudEJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1jaGFuZ2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc3RhdGUsIGB0cnVlYCBpcyBjaGVja2VkIGFuZCBgZmFsc2VgIGlzIHVuY2hlY2tlZC5cbiAgICAgKi9cbiAgICBjaGVja2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgb2JzZXJ2ZXI6ICdfY2hlY2tlZENoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBidXR0b24gdG9nZ2xlcyB0aGUgYWN0aXZlIHN0YXRlIHdpdGggZWFjaCB0YXAgb3IgcHJlc3NcbiAgICAgKiBvZiB0aGUgc3BhY2ViYXIuXG4gICAgICovXG4gICAgdG9nZ2xlczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qIE92ZXJyaWRlbiBmcm9tIFBvbHltZXIuSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IgKi9cbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdvbicsXG4gICAgICBvYnNlcnZlcjogJ192YWx1ZUNoYW5nZWQnXG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfcmVxdWlyZWRDaGFuZ2VkKHJlcXVpcmVkKSdcbiAgXSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBVc2VkIGJ5IGBpcm9uLWZvcm1gIHRvIGhhbmRsZSB0aGUgY2FzZSB0aGF0IGFuIGVsZW1lbnQgd2l0aCB0aGlzIGJlaGF2aW9yXG4gICAgLy8gZG9lc24ndCBoYXZlIGEgcm9sZSBvZiAnY2hlY2tib3gnIG9yICdyYWRpbycsIGJ1dCBzaG91bGQgc3RpbGwgb25seSBiZVxuICAgIC8vIGluY2x1ZGVkIHdoZW4gdGhlIGZvcm0gaXMgc2VyaWFsaXplZCBpZiBgdGhpcy5jaGVja2VkID09PSB0cnVlYC5cbiAgICB0aGlzLl9oYXNJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFsc2UgaWYgdGhlIGVsZW1lbnQgaXMgcmVxdWlyZWQgYW5kIG5vdCBjaGVja2VkLCBhbmQgdHJ1ZSBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSB7Kj19IF92YWx1ZSBJZ25vcmVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGByZXF1aXJlZGAgaXMgZmFsc2Ugb3IgaWYgYGNoZWNrZWRgIGlzIHRydWUuXG4gICAqL1xuICBfZ2V0VmFsaWRpdHk6IGZ1bmN0aW9uKF92YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkIHx8ICF0aGlzLnJlcXVpcmVkIHx8IHRoaXMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhcmlhLXJlcXVpcmVkIGxhYmVsIHdoZW4gYHJlcXVpcmVkYCBpcyBjaGFuZ2VkLlxuICAgKi9cbiAgX3JlcXVpcmVkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVxdWlyZWQpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLXJlcXVpcmVkJywgJ3RydWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtcmVxdWlyZWQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpcmUgYGlyb24tY2hhbmdlZGAgd2hlbiB0aGUgY2hlY2tlZCBzdGF0ZSBjaGFuZ2VzLlxuICAgKi9cbiAgX2NoZWNrZWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFjdGl2ZSA9IHRoaXMuY2hlY2tlZDtcbiAgICB0aGlzLmZpcmUoJ2lyb24tY2hhbmdlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0IHZhbHVlIHRvICdvbicgaWYgaXQgaXMgc2V0IHRvIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgX3ZhbHVlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJ29uJztcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciA9IFtcbiAgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IsXG4gIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yLFxuICBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGxcbl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9pcm9uLWljb24vaXJvbi1pY29uLmpzJztcbmltcG9ydCAnLi4vaXJvbi1pY29uc2V0LXN2Zy9pcm9uLWljb25zZXQtc3ZnLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8aXJvbi1pY29uc2V0LXN2ZyBuYW1lPVwiaWNvbnNcIiBzaXplPVwiMjRcIj5cbjxzdmc+PGRlZnM+XG48ZyBpZD1cIjNkLXJvdGF0aW9uXCI+PHBhdGggZD1cIk03LjUyIDIxLjQ4QzQuMjUgMTkuOTQgMS45MSAxNi43NiAxLjU1IDEzSC4wNUMuNTYgMTkuMTYgNS43MSAyNCAxMiAyNGwuNjYtLjAzLTMuODEtMy44MS0xLjMzIDEuMzJ6bS44OS02LjUyYy0uMTkgMC0uMzctLjAzLS41Mi0uMDgtLjE2LS4wNi0uMjktLjEzLS40LS4yNC0uMTEtLjEtLjItLjIyLS4yNi0uMzctLjA2LS4xNC0uMDktLjMtLjA5LS40N2gtMS4zYzAgLjM2LjA3LjY4LjIxLjk1LjE0LjI3LjMzLjUuNTYuNjkuMjQuMTguNTEuMzIuODIuNDEuMy4xLjYyLjE1Ljk2LjE1LjM3IDAgLjcyLS4wNSAxLjAzLS4xNS4zMi0uMS42LS4yNS44My0uNDRzLjQyLS40My41NS0uNzJjLjEzLS4yOS4yLS42MS4yLS45NyAwLS4xOS0uMDItLjM4LS4wNy0uNTYtLjA1LS4xOC0uMTItLjM1LS4yMy0uNTEtLjEtLjE2LS4yNC0uMy0uNC0uNDMtLjE3LS4xMy0uMzctLjIzLS42MS0uMzEuMi0uMDkuMzctLjIuNTItLjMzLjE1LS4xMy4yNy0uMjcuMzctLjQyLjEtLjE1LjE3LS4zLjIyLS40Ni4wNS0uMTYuMDctLjMyLjA3LS40OCAwLS4zNi0uMDYtLjY4LS4xOC0uOTYtLjEyLS4yOC0uMjktLjUxLS41MS0uNjktLjItLjE5LS40Ny0uMzMtLjc3LS40M0M5LjEgOC4wNSA4Ljc2IDggOC4zOSA4Yy0uMzYgMC0uNjkuMDUtMSAuMTYtLjMuMTEtLjU3LjI2LS43OS40NS0uMjEuMTktLjM4LjQxLS41MS42Ny0uMTIuMjYtLjE4LjU0LS4xOC44NWgxLjNjMC0uMTcuMDMtLjMyLjA5LS40NXMuMTQtLjI1LjI1LS4zNGMuMTEtLjA5LjIzLS4xNy4zOC0uMjIuMTUtLjA1LjMtLjA4LjQ4LS4wOC40IDAgLjcuMS44OS4zMS4xOS4yLjI5LjQ5LjI5Ljg2IDAgLjE4LS4wMy4zNC0uMDguNDktLjA1LjE1LS4xNC4yNy0uMjUuMzctLjExLjEtLjI1LjE4LS40MS4yNC0uMTYuMDYtLjM2LjA5LS41OC4wOUg3LjV2MS4wM2guNzdjLjIyIDAgLjQyLjAyLjYuMDdzLjMzLjEzLjQ1LjIzYy4xMi4xMS4yMi4yNC4yOS40LjA3LjE2LjEuMzUuMS41NyAwIC40MS0uMTIuNzItLjM1LjkzLS4yMy4yMy0uNTUuMzMtLjk1LjMzem04LjU1LTUuOTJjLS4zMi0uMzMtLjctLjU5LTEuMTQtLjc3LS40My0uMTgtLjkyLS4yNy0xLjQ2LS4yN0gxMnY4aDIuM2MuNTUgMCAxLjA2LS4wOSAxLjUxLS4yNy40NS0uMTguODQtLjQzIDEuMTYtLjc2LjMyLS4zMy41Ny0uNzMuNzQtMS4xOS4xNy0uNDcuMjYtLjk5LjI2LTEuNTd2LS40YzAtLjU4LS4wOS0xLjEtLjI2LTEuNTctLjE4LS40Ny0uNDMtLjg3LS43NS0xLjJ6bS0uMzkgMy4xNmMwIC40Mi0uMDUuNzktLjE0IDEuMTMtLjEuMzMtLjI0LjYyLS40My44NS0uMTkuMjMtLjQzLjQxLS43MS41My0uMjkuMTItLjYyLjE4LS45OS4xOGgtLjkxVjkuMTJoLjk3Yy43MiAwIDEuMjcuMjMgMS42NC42OS4zOC40Ni41NyAxLjEyLjU3IDEuOTl2LjR6TTEyIDBsLS42Ni4wMyAzLjgxIDMuODEgMS4zMy0xLjMzYzMuMjcgMS41NSA1LjYxIDQuNzIgNS45NiA4LjQ4aDEuNUMyMy40NCA0Ljg0IDE4LjI5IDAgMTIgMHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhY2Nlc3NpYmlsaXR5XCI+PHBhdGggZD1cIk0xMiAyYzEuMSAwIDIgLjkgMiAycy0uOSAyLTIgMi0yLS45LTItMiAuOS0yIDItMnptOSA3aC02djEzaC0ydi02aC0ydjZIOVY5SDNWN2gxOHYyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImFjY2Vzc2libGVcIj48Y2lyY2xlIGN4PVwiMTJcIiBjeT1cIjRcIiByPVwiMlwiPjwvY2lyY2xlPjxwYXRoIGQ9XCJNMTkgMTN2LTJjLTEuNTQuMDItMy4wOS0uNzUtNC4wNy0xLjgzbC0xLjI5LTEuNDNjLS4xNy0uMTktLjM4LS4zNC0uNjEtLjQ1LS4wMSAwLS4wMS0uMDEtLjAyLS4wMUgxM2MtLjM1LS4yLS43NS0uMy0xLjE5LS4yNkMxMC43NiA3LjExIDEwIDguMDQgMTAgOS4wOVYxNWMwIDEuMS45IDIgMiAyaDV2NWgydi01LjVjMC0xLjEtLjktMi0yLTJoLTN2LTMuNDVjMS4yOSAxLjA3IDMuMjUgMS45NCA1IDEuOTV6bS02LjE3IDVjLS40MSAxLjE2LTEuNTIgMi0yLjgzIDItMS42NiAwLTMtMS4zNC0zLTMgMC0xLjMxLjg0LTIuNDEgMi0yLjgzVjEyLjFjLTIuMjguNDYtNCAyLjQ4LTQgNC45IDAgMi43NiAyLjI0IDUgNSA1IDIuNDIgMCA0LjQ0LTEuNzIgNC45LTRoLTIuMDd6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYWNjb3VudC1iYWxhbmNlXCI+PHBhdGggZD1cIk00IDEwdjdoM3YtN0g0em02IDB2N2gzdi03aC0zek0yIDIyaDE5di0zSDJ2M3ptMTQtMTJ2N2gzdi03aC0zem0tNC41LTlMMiA2djJoMTlWNmwtOS41LTV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYWNjb3VudC1iYWxhbmNlLXdhbGxldFwiPjxwYXRoIGQ9XCJNMjEgMTh2MWMwIDEuMS0uOSAyLTIgMkg1Yy0xLjExIDAtMi0uOS0yLTJWNWMwLTEuMS44OS0yIDItMmgxNGMxLjEgMCAyIC45IDIgMnYxaC05Yy0xLjExIDAtMiAuOS0yIDJ2OGMwIDEuMS44OSAyIDIgMmg5em0tOS0yaDEwVjhIMTJ2OHptNC0yLjVjLS44MyAwLTEuNS0uNjctMS41LTEuNXMuNjctMS41IDEuNS0xLjUgMS41LjY3IDEuNSAxLjUtLjY3IDEuNS0xLjUgMS41elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImFjY291bnQtYm94XCI+PHBhdGggZD1cIk0zIDV2MTRjMCAxLjEuODkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMkg1Yy0xLjExIDAtMiAuOS0yIDJ6bTEyIDRjMCAxLjY2LTEuMzQgMy0zIDNzLTMtMS4zNC0zLTMgMS4zNC0zIDMtMyAzIDEuMzQgMyAzem0tOSA4YzAtMiA0LTMuMSA2LTMuMXM2IDEuMSA2IDMuMXYxSDZ2LTF6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYWNjb3VudC1jaXJjbGVcIj48cGF0aCBkPVwiTTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTAgM2MxLjY2IDAgMyAxLjM0IDMgM3MtMS4zNCAzLTMgMy0zLTEuMzQtMy0zIDEuMzQtMyAzLTN6bTAgMTQuMmMtMi41IDAtNC43MS0xLjI4LTYtMy4yMi4wMy0xLjk5IDQtMy4wOCA2LTMuMDggMS45OSAwIDUuOTcgMS4wOSA2IDMuMDgtMS4yOSAxLjk0LTMuNSAzLjIyLTYgMy4yMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhZGRcIj48cGF0aCBkPVwiTTE5IDEzaC02djZoLTJ2LTZINXYtMmg2VjVoMnY2aDZ2MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhZGQtYWxlcnRcIj48cGF0aCBkPVwiTTEwLjAxIDIxLjAxYzAgMS4xLjg5IDEuOTkgMS45OSAxLjk5czEuOTktLjg5IDEuOTktMS45OWgtMy45OHptOC44Ny00LjE5VjExYzAtMy4yNS0yLjI1LTUuOTctNS4yOS02LjY5di0uNzJDMTMuNTkgMi43MSAxMi44OCAyIDEyIDJzLTEuNTkuNzEtMS41OSAxLjU5di43MkM3LjM3IDUuMDMgNS4xMiA3Ljc1IDUuMTIgMTF2NS44MkwzIDE4Ljk0VjIwaDE4di0xLjA2bC0yLjEyLTIuMTJ6TTE2IDEzLjAxaC0zdjNoLTJ2LTNIOFYxMWgzVjhoMnYzaDN2Mi4wMXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhZGQtYm94XCI+PHBhdGggZD1cIk0xOSAzSDVjLTEuMTEgMC0yIC45LTIgMnYxNGMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0tMiAxMGgtNHY0aC0ydi00SDd2LTJoNFY3aDJ2NGg0djJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYWRkLWNpcmNsZVwiPjxwYXRoIGQ9XCJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptNSAxMWgtNHY0aC0ydi00SDd2LTJoNFY3aDJ2NGg0djJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYWRkLWNpcmNsZS1vdXRsaW5lXCI+PHBhdGggZD1cIk0xMyA3aC0ydjRIN3YyaDR2NGgydi00aDR2LTJoLTRWN3ptLTEtNUM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYWRkLXNob3BwaW5nLWNhcnRcIj48cGF0aCBkPVwiTTExIDloMlY2aDNWNGgtM1YxaC0ydjNIOHYyaDN2M3ptLTQgOWMtMS4xIDAtMS45OS45LTEuOTkgMlM1LjkgMjIgNyAyMnMyLS45IDItMi0uOS0yLTItMnptMTAgMGMtMS4xIDAtMS45OS45LTEuOTkgMnMuODkgMiAxLjk5IDIgMi0uOSAyLTItLjktMi0yLTJ6bS05LjgzLTMuMjVsLjAzLS4xMi45LTEuNjNoNy40NWMuNzUgMCAxLjQxLS40MSAxLjc1LTEuMDNsMy44Ni03LjAxTDE5LjQyIDRoLS4wMWwtMS4xIDItMi43NiA1SDguNTNsLS4xMy0uMjdMNi4xNiA2bC0uOTUtMi0uOTQtMkgxdjJoMmwzLjYgNy41OS0xLjM1IDIuNDVjLS4xNi4yOC0uMjUuNjEtLjI1Ljk2IDAgMS4xLjkgMiAyIDJoMTJ2LTJINy40MmMtLjEzIDAtLjI1LS4xMS0uMjUtLjI1elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImFsYXJtXCI+PHBhdGggZD1cIk0yMiA1LjcybC00LjYtMy44Ni0xLjI5IDEuNTMgNC42IDMuODZMMjIgNS43MnpNNy44OCAzLjM5TDYuNiAxLjg2IDIgNS43MWwxLjI5IDEuNTMgNC41OS0zLjg1ek0xMi41IDhIMTF2Nmw0Ljc1IDIuODUuNzUtMS4yMy00LTIuMzdWOHpNMTIgNGMtNC45NyAwLTkgNC4wMy05IDlzNC4wMiA5IDkgOWM0Ljk3IDAgOS00LjAzIDktOXMtNC4wMy05LTktOXptMCAxNmMtMy44NyAwLTctMy4xMy03LTdzMy4xMy03IDctNyA3IDMuMTMgNyA3LTMuMTMgNy03IDd6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYWxhcm0tYWRkXCI+PHBhdGggZD1cIk03Ljg4IDMuMzlMNi42IDEuODYgMiA1LjcxbDEuMjkgMS41MyA0LjU5LTMuODV6TTIyIDUuNzJsLTQuNi0zLjg2LTEuMjkgMS41MyA0LjYgMy44NkwyMiA1Ljcyek0xMiA0Yy00Ljk3IDAtOSA0LjAzLTkgOXM0LjAyIDkgOSA5YzQuOTcgMCA5LTQuMDMgOS05cy00LjAzLTktOS05em0wIDE2Yy0zLjg3IDAtNy0zLjEzLTctN3MzLjEzLTcgNy03IDcgMy4xMyA3IDctMy4xMyA3LTcgN3ptMS0xMWgtMnYzSDh2MmgzdjNoMnYtM2gzdi0yaC0zVjl6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYWxhcm0tb2ZmXCI+PHBhdGggZD1cIk0xMiA2YzMuODcgMCA3IDMuMTMgNyA3IDAgLjg0LS4xNiAxLjY1LS40MyAyLjRsMS41MiAxLjUyYy41OC0xLjE5LjkxLTIuNTEuOTEtMy45MiAwLTQuOTctNC4wMy05LTktOS0xLjQxIDAtMi43My4zMy0zLjkyLjkxTDkuNiA2LjQzQzEwLjM1IDYuMTYgMTEuMTYgNiAxMiA2em0xMC0uMjhsLTQuNi0zLjg2LTEuMjkgMS41MyA0LjYgMy44NkwyMiA1Ljcyek0yLjkyIDIuMjlMMS42NSAzLjU3IDIuOTggNC45bC0xLjExLjkzIDEuNDIgMS40MiAxLjExLS45NC44LjhDMy44MyA4LjY5IDMgMTAuNzUgMyAxM2MwIDQuOTcgNC4wMiA5IDkgOSAyLjI1IDAgNC4zMS0uODMgNS44OS0yLjJsMi4yIDIuMiAxLjI3LTEuMjdMMy44OSAzLjI3bC0uOTctLjk4em0xMy41NSAxNi4xQzE1LjI2IDE5LjM5IDEzLjcgMjAgMTIgMjBjLTMuODcgMC03LTMuMTMtNy03IDAtMS43LjYxLTMuMjYgMS42MS00LjQ3bDkuODYgOS44NnpNOC4wMiAzLjI4TDYuNiAxLjg2bC0uODYuNzEgMS40MiAxLjQyLjg2LS43MXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhbGFybS1vblwiPjxwYXRoIGQ9XCJNMjIgNS43MmwtNC42LTMuODYtMS4yOSAxLjUzIDQuNiAzLjg2TDIyIDUuNzJ6TTcuODggMy4zOUw2LjYgMS44NiAyIDUuNzFsMS4yOSAxLjUzIDQuNTktMy44NXpNMTIgNGMtNC45NyAwLTkgNC4wMy05IDlzNC4wMiA5IDkgOWM0Ljk3IDAgOS00LjAzIDktOXMtNC4wMy05LTktOXptMCAxNmMtMy44NyAwLTctMy4xMy03LTdzMy4xMy03IDctNyA3IDMuMTMgNyA3LTMuMTMgNy03IDd6bS0xLjQ2LTUuNDdMOC40MSAxMi40bC0xLjA2IDEuMDYgMy4xOCAzLjE4IDYtNi0xLjA2LTEuMDYtNC45MyA0Ljk1elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImFsbC1vdXRcIj48cGF0aCBkPVwiTTE2LjIxIDQuMTZsNCA0di00em00IDEybC00IDRoNHptLTEyIDRsLTQtNHY0em0tNC0xMmw0LTRoLTR6bTEyLjk1LS45NWMtMi43My0yLjczLTcuMTctMi43My05LjkgMHMtMi43MyA3LjE3IDAgOS45IDcuMTcgMi43MyA5LjkgMCAyLjczLTcuMTYgMC05Ljl6bS0xLjEgOC44Yy0yLjEzIDIuMTMtNS41NyAyLjEzLTcuNyAwcy0yLjEzLTUuNTcgMC03LjcgNS41Ny0yLjEzIDcuNyAwIDIuMTMgNS41NyAwIDcuN3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhbmRyb2lkXCI+PHBhdGggZD1cIk02IDE4YzAgLjU1LjQ1IDEgMSAxaDF2My41YzAgLjgzLjY3IDEuNSAxLjUgMS41czEuNS0uNjcgMS41LTEuNVYxOWgydjMuNWMwIC44My42NyAxLjUgMS41IDEuNXMxLjUtLjY3IDEuNS0xLjVWMTloMWMuNTUgMCAxLS40NSAxLTFWOEg2djEwek0zLjUgOEMyLjY3IDggMiA4LjY3IDIgOS41djdjMCAuODMuNjcgMS41IDEuNSAxLjVTNSAxNy4zMyA1IDE2LjV2LTdDNSA4LjY3IDQuMzMgOCAzLjUgOHptMTcgMGMtLjgzIDAtMS41LjY3LTEuNSAxLjV2N2MwIC44My42NyAxLjUgMS41IDEuNXMxLjUtLjY3IDEuNS0xLjV2LTdjMC0uODMtLjY3LTEuNS0xLjUtMS41em0tNC45Ny01Ljg0bDEuMy0xLjNjLjItLjIuMi0uNTEgMC0uNzEtLjItLjItLjUxLS4yLS43MSAwbC0xLjQ4IDEuNDhDMTMuODUgMS4yMyAxMi45NSAxIDEyIDFjLS45NiAwLTEuODYuMjMtMi42Ni42M0w3Ljg1LjE1Yy0uMi0uMi0uNTEtLjItLjcxIDAtLjIuMi0uMi41MSAwIC43MWwxLjMxIDEuMzFDNi45NyAzLjI2IDYgNS4wMSA2IDdoMTJjMC0xLjk5LS45Ny0zLjc1LTIuNDctNC44NHpNMTAgNUg5VjRoMXYxem01IDBoLTFWNGgxdjF6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYW5ub3VuY2VtZW50XCI+PHBhdGggZD1cIk0yMCAySDRjLTEuMSAwLTEuOTkuOS0xLjk5IDJMMiAyMmw0LTRoMTRjMS4xIDAgMi0uOSAyLTJWNGMwLTEuMS0uOS0yLTItMnptLTcgOWgtMlY1aDJ2NnptMCA0aC0ydi0yaDJ2MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhcHBzXCI+PHBhdGggZD1cIk00IDhoNFY0SDR2NHptNiAxMmg0di00aC00djR6bS02IDBoNHYtNEg0djR6bTAtNmg0di00SDR2NHptNiAwaDR2LTRoLTR2NHptNi0xMHY0aDRWNGgtNHptLTYgNGg0VjRoLTR2NHptNiA2aDR2LTRoLTR2NHptMCA2aDR2LTRoLTR2NHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhcmNoaXZlXCI+PHBhdGggZD1cIk0yMC41NCA1LjIzbC0xLjM5LTEuNjhDMTguODggMy4yMSAxOC40NyAzIDE4IDNINmMtLjQ3IDAtLjg4LjIxLTEuMTYuNTVMMy40NiA1LjIzQzMuMTcgNS41NyAzIDYuMDIgMyA2LjVWMTljMCAxLjEuOSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY2LjVjMC0uNDgtLjE3LS45My0uNDYtMS4yN3pNMTIgMTcuNUw2LjUgMTJIMTB2LTJoNHYyaDMuNUwxMiAxNy41ek01LjEyIDVsLjgxLTFoMTJsLjk0IDFINS4xMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhcnJvdy1iYWNrXCI+PHBhdGggZD1cIk0yMCAxMUg3LjgzbDUuNTktNS41OUwxMiA0bC04IDggOCA4IDEuNDEtMS40MUw3LjgzIDEzSDIwdi0yelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImFycm93LWRvd253YXJkXCI+PHBhdGggZD1cIk0yMCAxMmwtMS40MS0xLjQxTDEzIDE2LjE3VjRoLTJ2MTIuMTdsLTUuNTgtNS41OUw0IDEybDggOCA4LTh6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYXJyb3ctZHJvcC1kb3duXCI+PHBhdGggZD1cIk03IDEwbDUgNSA1LTV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYXJyb3ctZHJvcC1kb3duLWNpcmNsZVwiPjxwYXRoIGQ9XCJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxMmwtNC00aDhsLTQgNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhcnJvdy1kcm9wLXVwXCI+PHBhdGggZD1cIk03IDE0bDUtNSA1IDV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYXJyb3ctZm9yd2FyZFwiPjxwYXRoIGQ9XCJNMTIgNGwtMS40MSAxLjQxTDE2LjE3IDExSDR2MmgxMi4xN2wtNS41OCA1LjU5TDEyIDIwbDgtOHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhcnJvdy11cHdhcmRcIj48cGF0aCBkPVwiTTQgMTJsMS40MSAxLjQxTDExIDcuODNWMjBoMlY3LjgzbDUuNTggNS41OUwyMCAxMmwtOC04LTggOHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhc3BlY3QtcmF0aW9cIj48cGF0aCBkPVwiTTE5IDEyaC0ydjNoLTN2Mmg1di01ek03IDloM1Y3SDV2NWgyVjl6bTE0LTZIM2MtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxOGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2LjAxSDNWNC45OWgxOHYxNC4wMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhc3Nlc3NtZW50XCI+PHBhdGggZD1cIk0xOSAzSDVjLTEuMSAwLTIgLjktMiAydjE0YzAgMS4xLjkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnpNOSAxN0g3di03aDJ2N3ptNCAwaC0yVjdoMnYxMHptNCAwaC0ydi00aDJ2NHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJhc3NpZ25tZW50XCI+PHBhdGggZD1cIk0xOSAzaC00LjE4QzE0LjQgMS44NCAxMy4zIDEgMTIgMWMtMS4zIDAtMi40Ljg0LTIuODIgMkg1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bS03IDBjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptMiAxNEg3di0yaDd2MnptMy00SDd2LTJoMTB2MnptMC00SDdWN2gxMHYyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImFzc2lnbm1lbnQtaW5kXCI+PHBhdGggZD1cIk0xOSAzaC00LjE4QzE0LjQgMS44NCAxMy4zIDEgMTIgMWMtMS4zIDAtMi40Ljg0LTIuODIgMkg1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bS03IDBjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptMCA0YzEuNjYgMCAzIDEuMzQgMyAzcy0xLjM0IDMtMyAzLTMtMS4zNC0zLTMgMS4zNC0zIDMtM3ptNiAxMkg2di0xLjRjMC0yIDQtMy4xIDYtMy4xczYgMS4xIDYgMy4xVjE5elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImFzc2lnbm1lbnQtbGF0ZVwiPjxwYXRoIGQ9XCJNMTkgM2gtNC4xOEMxNC40IDEuODQgMTMuMyAxIDEyIDFjLTEuMyAwLTIuNC44NC0yLjgyIDJINWMtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0tNiAxNWgtMnYtMmgydjJ6bTAtNGgtMlY4aDJ2NnptLTEtOWMtLjU1IDAtMS0uNDUtMS0xcy40NS0xIDEtMSAxIC40NSAxIDEtLjQ1IDEtMSAxelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImFzc2lnbm1lbnQtcmV0dXJuXCI+PHBhdGggZD1cIk0xOSAzaC00LjE4QzE0LjQgMS44NCAxMy4zIDEgMTIgMWMtMS4zIDAtMi40Ljg0LTIuODIgMkg1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bS03IDBjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptNCAxMmgtNHYzbC01LTUgNS01djNoNHY0elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImFzc2lnbm1lbnQtcmV0dXJuZWRcIj48cGF0aCBkPVwiTTE5IDNoLTQuMThDMTQuNCAxLjg0IDEzLjMgMSAxMiAxYy0xLjMgMC0yLjQuODQtMi44MiAySDVjLTEuMSAwLTIgLjktMiAydjE0YzAgMS4xLjkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnptLTcgMGMuNTUgMCAxIC40NSAxIDFzLS40NSAxLTEgMS0xLS40NS0xLTEgLjQ1LTEgMS0xem0wIDE1bC01LTVoM1Y5aDR2NGgzbC01IDV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYXNzaWdubWVudC10dXJuZWQtaW5cIj48cGF0aCBkPVwiTTE5IDNoLTQuMThDMTQuNCAxLjg0IDEzLjMgMSAxMiAxYy0xLjMgMC0yLjQuODQtMi44MiAySDVjLTEuMSAwLTIgLjktMiAydjE0YzAgMS4xLjkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnptLTcgMGMuNTUgMCAxIC40NSAxIDFzLS40NSAxLTEgMS0xLS40NS0xLTEgLjQ1LTEgMS0xem0tMiAxNGwtNC00IDEuNDEtMS40MUwxMCAxNC4xN2w2LjU5LTYuNTlMMTggOWwtOCA4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImF0dGFjaG1lbnRcIj48cGF0aCBkPVwiTTIgMTIuNUMyIDkuNDYgNC40NiA3IDcuNSA3SDE4YzIuMjEgMCA0IDEuNzkgNCA0cy0xLjc5IDQtNCA0SDkuNUM4LjEyIDE1IDcgMTMuODggNyAxMi41UzguMTIgMTAgOS41IDEwSDE3djJIOS40MWMtLjU1IDAtLjU1IDEgMCAxSDE4YzEuMSAwIDItLjkgMi0ycy0uOS0yLTItMkg3LjVDNS41NyA5IDQgMTAuNTcgNCAxMi41UzUuNTcgMTYgNy41IDE2SDE3djJINy41QzQuNDYgMTggMiAxNS41NCAyIDEyLjV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYXV0b3JlbmV3XCI+PHBhdGggZD1cIk0xMiA2djNsNC00LTQtNHYzYy00LjQyIDAtOCAzLjU4LTggOCAwIDEuNTcuNDYgMy4wMyAxLjI0IDQuMjZMNi43IDE0LjhjLS40NS0uODMtLjctMS43OS0uNy0yLjggMC0zLjMxIDIuNjktNiA2LTZ6bTYuNzYgMS43NEwxNy4zIDkuMmMuNDQuODQuNyAxLjc5LjcgMi44IDAgMy4zMS0yLjY5IDYtNiA2di0zbC00IDQgNCA0di0zYzQuNDIgMCA4LTMuNTggOC04IDAtMS41Ny0uNDYtMy4wMy0xLjI0LTQuMjZ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiYmFja3NwYWNlXCI+PHBhdGggZD1cIk0yMiAzSDdjLS42OSAwLTEuMjMuMzUtMS41OS44OEwwIDEybDUuNDEgOC4xMWMuMzYuNTMuOS44OSAxLjU5Ljg5aDE1YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6bS0zIDEyLjU5TDE3LjU5IDE3IDE0IDEzLjQxIDEwLjQxIDE3IDkgMTUuNTkgMTIuNTkgMTIgOSA4LjQxIDEwLjQxIDcgMTQgMTAuNTkgMTcuNTkgNyAxOSA4LjQxIDE1LjQxIDEyIDE5IDE1LjU5elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImJhY2t1cFwiPjxwYXRoIGQ9XCJNMTkuMzUgMTAuMDRDMTguNjcgNi41OSAxNS42NCA0IDEyIDQgOS4xMSA0IDYuNiA1LjY0IDUuMzUgOC4wNCAyLjM0IDguMzYgMCAxMC45MSAwIDE0YzAgMy4zMSAyLjY5IDYgNiA2aDEzYzIuNzYgMCA1LTIuMjQgNS01IDAtMi42NC0yLjA1LTQuNzgtNC42NS00Ljk2ek0xNCAxM3Y0aC00di00SDdsNS01IDUgNWgtM3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJibG9ja1wiPjxwYXRoIGQ9XCJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnpNNCAxMmMwLTQuNDIgMy41OC04IDgtOCAxLjg1IDAgMy41NS42MyA0LjkgMS42OUw1LjY5IDE2LjlDNC42MyAxNS41NSA0IDEzLjg1IDQgMTJ6bTggOGMtMS44NSAwLTMuNTUtLjYzLTQuOS0xLjY5TDE4LjMxIDcuMUMxOS4zNyA4LjQ1IDIwIDEwLjE1IDIwIDEyYzAgNC40Mi0zLjU4IDgtOCA4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImJvb2tcIj48cGF0aCBkPVwiTTE4IDJINmMtMS4xIDAtMiAuOS0yIDJ2MTZjMCAxLjEuOSAyIDIgMmgxMmMxLjEgMCAyLS45IDItMlY0YzAtMS4xLS45LTItMi0yek02IDRoNXY4bC0yLjUtMS41TDYgMTJWNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJib29rbWFya1wiPjxwYXRoIGQ9XCJNMTcgM0g3Yy0xLjEgMC0xLjk5LjktMS45OSAyTDUgMjFsNy0zIDcgM1Y1YzAtMS4xLS45LTItMi0yelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImJvb2ttYXJrLWJvcmRlclwiPjxwYXRoIGQ9XCJNMTcgM0g3Yy0xLjEgMC0xLjk5LjktMS45OSAyTDUgMjFsNy0zIDcgM1Y1YzAtMS4xLS45LTItMi0yem0wIDE1bC01LTIuMThMNyAxOFY1aDEwdjEzelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImJ1Zy1yZXBvcnRcIj48cGF0aCBkPVwiTTIwIDhoLTIuODFjLS40NS0uNzgtMS4wNy0xLjQ1LTEuODItMS45NkwxNyA0LjQxIDE1LjU5IDNsLTIuMTcgMi4xN0MxMi45NiA1LjA2IDEyLjQ5IDUgMTIgNWMtLjQ5IDAtLjk2LjA2LTEuNDEuMTdMOC40MSAzIDcgNC40MWwxLjYyIDEuNjNDNy44OCA2LjU1IDcuMjYgNy4yMiA2LjgxIDhINHYyaDIuMDljLS4wNS4zMy0uMDkuNjYtLjA5IDF2MUg0djJoMnYxYzAgLjM0LjA0LjY3LjA5IDFINHYyaDIuODFjMS4wNCAxLjc5IDIuOTcgMyA1LjE5IDNzNC4xNS0xLjIxIDUuMTktM0gyMHYtMmgtMi4wOWMuMDUtLjMzLjA5LS42Ni4wOS0xdi0xaDJ2LTJoLTJ2LTFjMC0uMzQtLjA0LS42Ny0uMDktMUgyMFY4em0tNiA4aC00di0yaDR2MnptMC00aC00di0yaDR2MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJidWlsZFwiPjxwYXRoIGQ9XCJNMjIuNyAxOWwtOS4xLTkuMWMuOS0yLjMuNC01LTEuNS02LjktMi0yLTUtMi40LTcuNC0xLjNMOSA2IDYgOSAxLjYgNC43Qy40IDcuMS45IDEwLjEgMi45IDEyLjFjMS45IDEuOSA0LjYgMi40IDYuOSAxLjVsOS4xIDkuMWMuNC40IDEgLjQgMS40IDBsMi4zLTIuM2MuNS0uNC41LTEuMS4xLTEuNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjYWNoZWRcIj48cGF0aCBkPVwiTTE5IDhsLTQgNGgzYzAgMy4zMS0yLjY5IDYtNiA2LTEuMDEgMC0xLjk3LS4yNS0yLjgtLjdsLTEuNDYgMS40NkM4Ljk3IDE5LjU0IDEwLjQzIDIwIDEyIDIwYzQuNDIgMCA4LTMuNTggOC04aDNsLTQtNHpNNiAxMmMwLTMuMzEgMi42OS02IDYtNiAxLjAxIDAgMS45Ny4yNSAyLjguN2wxLjQ2LTEuNDZDMTUuMDMgNC40NiAxMy41NyA0IDEyIDRjLTQuNDIgMC04IDMuNTgtOCA4SDFsNCA0IDQtNEg2elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNhbWVyYS1lbmhhbmNlXCI+PHBhdGggZD1cIk05IDNMNy4xNyA1SDRjLTEuMSAwLTIgLjktMiAydjEyYzAgMS4xLjkgMiAyIDJoMTZjMS4xIDAgMi0uOSAyLTJWN2MwLTEuMS0uOS0yLTItMmgtMy4xN0wxNSAzSDl6bTMgMTVjLTIuNzYgMC01LTIuMjQtNS01czIuMjQtNSA1LTUgNSAyLjI0IDUgNS0yLjI0IDUtNSA1em0wLTFsMS4yNS0yLjc1TDE2IDEzbC0yLjc1LTEuMjVMMTIgOWwtMS4yNSAyLjc1TDggMTNsMi43NSAxLjI1elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNhbmNlbFwiPjxwYXRoIGQ9XCJNMTIgMkM2LjQ3IDIgMiA2LjQ3IDIgMTJzNC40NyAxMCAxMCAxMCAxMC00LjQ3IDEwLTEwUzE3LjUzIDIgMTIgMnptNSAxMy41OUwxNS41OSAxNyAxMiAxMy40MSA4LjQxIDE3IDcgMTUuNTkgMTAuNTkgMTIgNyA4LjQxIDguNDEgNyAxMiAxMC41OSAxNS41OSA3IDE3IDguNDEgMTMuNDEgMTIgMTcgMTUuNTl6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY2FyZC1naWZ0Y2FyZFwiPjxwYXRoIGQ9XCJNMjAgNmgtMi4xOGMuMTEtLjMxLjE4LS42NS4xOC0xIDAtMS42Ni0xLjM0LTMtMy0zLTEuMDUgMC0xLjk2LjU0LTIuNSAxLjM1bC0uNS42Ny0uNS0uNjhDMTAuOTYgMi41NCAxMC4wNSAyIDkgMiA3LjM0IDIgNiAzLjM0IDYgNWMwIC4zNS4wNy42OS4xOCAxSDRjLTEuMTEgMC0xLjk5Ljg5LTEuOTkgMkwyIDE5YzAgMS4xMS44OSAyIDIgMmgxNmMxLjExIDAgMi0uODkgMi0yVjhjMC0xLjExLS44OS0yLTItMnptLTUtMmMuNTUgMCAxIC40NSAxIDFzLS40NSAxLTEgMS0xLS40NS0xLTEgLjQ1LTEgMS0xek05IDRjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptMTEgMTVINHYtMmgxNnYyem0wLTVINFY4aDUuMDhMNyAxMC44MyA4LjYyIDEyIDExIDguNzZsMS0xLjM2IDEgMS4zNkwxNS4zOCAxMiAxNyAxMC44MyAxNC45MiA4SDIwdjZ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY2FyZC1tZW1iZXJzaGlwXCI+PHBhdGggZD1cIk0yMCAySDRjLTEuMTEgMC0yIC44OS0yIDJ2MTFjMCAxLjExLjg5IDIgMiAyaDR2NWw0LTIgNCAydi01aDRjMS4xMSAwIDItLjg5IDItMlY0YzAtMS4xMS0uODktMi0yLTJ6bTAgMTNINHYtMmgxNnYyem0wLTVINFY0aDE2djZ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY2FyZC10cmF2ZWxcIj48cGF0aCBkPVwiTTIwIDZoLTNWNGMwLTEuMTEtLjg5LTItMi0ySDljLTEuMTEgMC0yIC44OS0yIDJ2Mkg0Yy0xLjExIDAtMiAuODktMiAydjExYzAgMS4xMS44OSAyIDIgMmgxNmMxLjExIDAgMi0uODkgMi0yVjhjMC0xLjExLS44OS0yLTItMnpNOSA0aDZ2Mkg5VjR6bTExIDE1SDR2LTJoMTZ2MnptMC01SDRWOGgzdjJoMlY4aDZ2MmgyVjhoM3Y2elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNoYW5nZS1oaXN0b3J5XCI+PHBhdGggZD1cIk0xMiA3Ljc3TDE4LjM5IDE4SDUuNjFMMTIgNy43N00xMiA0TDIgMjBoMjBMMTIgNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjaGVja1wiPjxwYXRoIGQ9XCJNOSAxNi4xN0w0LjgzIDEybC0xLjQyIDEuNDFMOSAxOSAyMSA3bC0xLjQxLTEuNDF6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY2hlY2stYm94XCI+PHBhdGggZD1cIk0xOSAzSDVjLTEuMTEgMC0yIC45LTIgMnYxNGMwIDEuMS44OSAyIDIgMmgxNGMxLjExIDAgMi0uOSAyLTJWNWMwLTEuMS0uODktMi0yLTJ6bS05IDE0bC01LTUgMS40MS0xLjQxTDEwIDE0LjE3bDcuNTktNy41OUwxOSA4bC05IDl6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY2hlY2stYm94LW91dGxpbmUtYmxhbmtcIj48cGF0aCBkPVwiTTE5IDV2MTRINVY1aDE0bTAtMkg1Yy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY2hlY2stY2lyY2xlXCI+PHBhdGggZD1cIk0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0tMiAxNWwtNS01IDEuNDEtMS40MUwxMCAxNC4xN2w3LjU5LTcuNTlMMTkgOGwtOSA5elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNoZXZyb24tbGVmdFwiPjxwYXRoIGQ9XCJNMTUuNDEgNy40MUwxNCA2bC02IDYgNiA2IDEuNDEtMS40MUwxMC44MyAxMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjaGV2cm9uLXJpZ2h0XCI+PHBhdGggZD1cIk0xMCA2TDguNTkgNy40MSAxMy4xNyAxMmwtNC41OCA0LjU5TDEwIDE4bDYtNnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjaHJvbWUtcmVhZGVyLW1vZGVcIj48cGF0aCBkPVwiTTEzIDEyaDd2MS41aC03em0wLTIuNWg3VjExaC03em0wIDVoN1YxNmgtN3pNMjEgNEgzYy0xLjEgMC0yIC45LTIgMnYxM2MwIDEuMS45IDIgMiAyaDE4YzEuMSAwIDItLjkgMi0yVjZjMC0xLjEtLjktMi0yLTJ6bTAgMTVoLTlWNmg5djEzelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNsYXNzXCI+PHBhdGggZD1cIk0xOCAySDZjLTEuMSAwLTIgLjktMiAydjE2YzAgMS4xLjkgMiAyIDJoMTJjMS4xIDAgMi0uOSAyLTJWNGMwLTEuMS0uOS0yLTItMnpNNiA0aDV2OGwtMi41LTEuNUw2IDEyVjR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY2xlYXJcIj48cGF0aCBkPVwiTTE5IDYuNDFMMTcuNTkgNSAxMiAxMC41OSA2LjQxIDUgNSA2LjQxIDEwLjU5IDEyIDUgMTcuNTkgNi40MSAxOSAxMiAxMy40MSAxNy41OSAxOSAxOSAxNy41OSAxMy40MSAxMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjbG9zZVwiPjxwYXRoIGQ9XCJNMTkgNi40MUwxNy41OSA1IDEyIDEwLjU5IDYuNDEgNSA1IDYuNDEgMTAuNTkgMTIgNSAxNy41OSA2LjQxIDE5IDEyIDEzLjQxIDE3LjU5IDE5IDE5IDE3LjU5IDEzLjQxIDEyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNsb3VkXCI+PHBhdGggZD1cIk0xOS4zNSAxMC4wNEMxOC42NyA2LjU5IDE1LjY0IDQgMTIgNCA5LjExIDQgNi42IDUuNjQgNS4zNSA4LjA0IDIuMzQgOC4zNiAwIDEwLjkxIDAgMTRjMCAzLjMxIDIuNjkgNiA2IDZoMTNjMi43NiAwIDUtMi4yNCA1LTUgMC0yLjY0LTIuMDUtNC43OC00LjY1LTQuOTZ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY2xvdWQtY2lyY2xlXCI+PHBhdGggZD1cIk0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem00LjUgMTRIOGMtMS42NiAwLTMtMS4zNC0zLTNzMS4zNC0zIDMtM2wuMTQuMDFDOC41OCA4LjI4IDEwLjEzIDcgMTIgN2MyLjIxIDAgNCAxLjc5IDQgNGguNWMxLjM4IDAgMi41IDEuMTIgMi41IDIuNVMxNy44OCAxNiAxNi41IDE2elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNsb3VkLWRvbmVcIj48cGF0aCBkPVwiTTE5LjM1IDEwLjA0QzE4LjY3IDYuNTkgMTUuNjQgNCAxMiA0IDkuMTEgNCA2LjYgNS42NCA1LjM1IDguMDQgMi4zNCA4LjM2IDAgMTAuOTEgMCAxNGMwIDMuMzEgMi42OSA2IDYgNmgxM2MyLjc2IDAgNS0yLjI0IDUtNSAwLTIuNjQtMi4wNS00Ljc4LTQuNjUtNC45NnpNMTAgMTdsLTMuNS0zLjUgMS40MS0xLjQxTDEwIDE0LjE3IDE1LjE4IDlsMS40MSAxLjQxTDEwIDE3elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNsb3VkLWRvd25sb2FkXCI+PHBhdGggZD1cIk0xOS4zNSAxMC4wNEMxOC42NyA2LjU5IDE1LjY0IDQgMTIgNCA5LjExIDQgNi42IDUuNjQgNS4zNSA4LjA0IDIuMzQgOC4zNiAwIDEwLjkxIDAgMTRjMCAzLjMxIDIuNjkgNiA2IDZoMTNjMi43NiAwIDUtMi4yNCA1LTUgMC0yLjY0LTIuMDUtNC43OC00LjY1LTQuOTZ6TTE3IDEzbC01IDUtNS01aDNWOWg0djRoM3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjbG91ZC1vZmZcIj48cGF0aCBkPVwiTTE5LjM1IDEwLjA0QzE4LjY3IDYuNTkgMTUuNjQgNCAxMiA0Yy0xLjQ4IDAtMi44NS40My00LjAxIDEuMTdsMS40NiAxLjQ2QzEwLjIxIDYuMjMgMTEuMDggNiAxMiA2YzMuMDQgMCA1LjUgMi40NiA1LjUgNS41di41SDE5YzEuNjYgMCAzIDEuMzQgMyAzIDAgMS4xMy0uNjQgMi4xMS0xLjU2IDIuNjJsMS40NSAxLjQ1QzIzLjE2IDE4LjE2IDI0IDE2LjY4IDI0IDE1YzAtMi42NC0yLjA1LTQuNzgtNC42NS00Ljk2ek0zIDUuMjdsMi43NSAyLjc0QzIuNTYgOC4xNSAwIDEwLjc3IDAgMTRjMCAzLjMxIDIuNjkgNiA2IDZoMTEuNzNsMiAyTDIxIDIwLjczIDQuMjcgNCAzIDUuMjd6TTcuNzMgMTBsOCA4SDZjLTIuMjEgMC00LTEuNzktNC00czEuNzktNCA0LTRoMS43M3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjbG91ZC1xdWV1ZVwiPjxwYXRoIGQ9XCJNMTkuMzUgMTAuMDRDMTguNjcgNi41OSAxNS42NCA0IDEyIDQgOS4xMSA0IDYuNiA1LjY0IDUuMzUgOC4wNCAyLjM0IDguMzYgMCAxMC45MSAwIDE0YzAgMy4zMSAyLjY5IDYgNiA2aDEzYzIuNzYgMCA1LTIuMjQgNS01IDAtMi42NC0yLjA1LTQuNzgtNC42NS00Ljk2ek0xOSAxOEg2Yy0yLjIxIDAtNC0xLjc5LTQtNHMxLjc5LTQgNC00aC43MUM3LjM3IDcuNjkgOS40OCA2IDEyIDZjMy4wNCAwIDUuNSAyLjQ2IDUuNSA1LjV2LjVIMTljMS42NiAwIDMgMS4zNCAzIDNzLTEuMzQgMy0zIDN6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY2xvdWQtdXBsb2FkXCI+PHBhdGggZD1cIk0xOS4zNSAxMC4wNEMxOC42NyA2LjU5IDE1LjY0IDQgMTIgNCA5LjExIDQgNi42IDUuNjQgNS4zNSA4LjA0IDIuMzQgOC4zNiAwIDEwLjkxIDAgMTRjMCAzLjMxIDIuNjkgNiA2IDZoMTNjMi43NiAwIDUtMi4yNCA1LTUgMC0yLjY0LTIuMDUtNC43OC00LjY1LTQuOTZ6TTE0IDEzdjRoLTR2LTRIN2w1LTUgNSA1aC0zelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNvZGVcIj48cGF0aCBkPVwiTTkuNCAxNi42TDQuOCAxMmw0LjYtNC42TDggNmwtNiA2IDYgNiAxLjQtMS40em01LjIgMGw0LjYtNC42LTQuNi00LjZMMTYgNmw2IDYtNiA2LTEuNC0xLjR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY29tcGFyZS1hcnJvd3NcIj48cGF0aCBkPVwiTTkuMDEgMTRIMnYyaDcuMDF2M0wxMyAxNWwtMy45OS00djN6bTUuOTgtMXYtM0gyMlY4aC03LjAxVjVMMTEgOWwzLjk5IDR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiY29udGVudC1jb3B5XCI+PHBhdGggZD1cIk0xNiAxSDRjLTEuMSAwLTIgLjktMiAydjE0aDJWM2gxMlYxem0zIDRIOGMtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxMWMxLjEgMCAyLS45IDItMlY3YzAtMS4xLS45LTItMi0yem0wIDE2SDhWN2gxMXYxNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjb250ZW50LWN1dFwiPjxwYXRoIGQ9XCJNOS42NCA3LjY0Yy4yMy0uNS4zNi0xLjA1LjM2LTEuNjQgMC0yLjIxLTEuNzktNC00LTRTMiAzLjc5IDIgNnMxLjc5IDQgNCA0Yy41OSAwIDEuMTQtLjEzIDEuNjQtLjM2TDEwIDEybC0yLjM2IDIuMzZDNy4xNCAxNC4xMyA2LjU5IDE0IDYgMTRjLTIuMjEgMC00IDEuNzktNCA0czEuNzkgNCA0IDQgNC0xLjc5IDQtNGMwLS41OS0uMTMtMS4xNC0uMzYtMS42NEwxMiAxNGw3IDdoM3YtMUw5LjY0IDcuNjR6TTYgOGMtMS4xIDAtMi0uODktMi0ycy45LTIgMi0yIDIgLjg5IDIgMi0uOSAyLTIgMnptMCAxMmMtMS4xIDAtMi0uODktMi0ycy45LTIgMi0yIDIgLjg5IDIgMi0uOSAyLTIgMnptNi03LjVjLS4yOCAwLS41LS4yMi0uNS0uNXMuMjItLjUuNS0uNS41LjIyLjUuNS0uMjIuNS0uNS41ek0xOSAzbC02IDYgMiAyIDctN1YzelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNvbnRlbnQtcGFzdGVcIj48cGF0aCBkPVwiTTE5IDJoLTQuMThDMTQuNC44NCAxMy4zIDAgMTIgMGMtMS4zIDAtMi40Ljg0LTIuODIgMkg1Yy0xLjEgMC0yIC45LTIgMnYxNmMwIDEuMS45IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjRjMC0xLjEtLjktMi0yLTJ6bS03IDBjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptNyAxOEg1VjRoMnYzaDEwVjRoMnYxNnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjb3B5cmlnaHRcIj48cGF0aCBkPVwiTTEwLjA4IDEwLjg2Yy4wNS0uMzMuMTYtLjYyLjMtLjg3cy4zNC0uNDYuNTktLjYyYy4yNC0uMTUuNTQtLjIyLjkxLS4yMy4yMy4wMS40NC4wNS42My4xMy4yLjA5LjM4LjIxLjUyLjM2cy4yNS4zMy4zNC41My4xMy40Mi4xNC42NGgxLjc5Yy0uMDItLjQ3LS4xMS0uOS0uMjgtMS4yOXMtLjQtLjczLS43LTEuMDEtLjY2LS41LTEuMDgtLjY2LS44OC0uMjMtMS4zOS0uMjNjLS42NSAwLTEuMjIuMTEtMS43LjM0cy0uODguNTMtMS4yLjkyLS41Ni44NC0uNzEgMS4zNlM4IDExLjI5IDggMTEuODd2LjI3YzAgLjU4LjA4IDEuMTIuMjMgMS42NHMuMzkuOTcuNzEgMS4zNS43Mi42OSAxLjIuOTEgMS4wNS4zNCAxLjcuMzRjLjQ3IDAgLjkxLS4wOCAxLjMyLS4yM3MuNzctLjM2IDEuMDgtLjYzLjU2LS41OC43NC0uOTQuMjktLjc0LjMtMS4xNWgtMS43OWMtLjAxLjIxLS4wNi40LS4xNS41OHMtLjIxLjMzLS4zNi40Ni0uMzIuMjMtLjUyLjNjLS4xOS4wNy0uMzkuMDktLjYuMS0uMzYtLjAxLS42Ni0uMDgtLjg5LS4yMy0uMjUtLjE2LS40NS0uMzctLjU5LS42MnMtLjI1LS41NS0uMy0uODgtLjA4LS42Ny0uMDgtMXYtLjI3YzAtLjM1LjAzLS42OC4wOC0xLjAxek0xMiAyQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBTMTcuNTIgMiAxMiAyem0wIDE4Yy00LjQxIDAtOC0zLjU5LTgtOHMzLjU5LTggOC04IDggMy41OSA4IDgtMy41OSA4LTggOHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjcmVhdGVcIj48cGF0aCBkPVwiTTMgMTcuMjVWMjFoMy43NUwxNy44MSA5Ljk0bC0zLjc1LTMuNzVMMyAxNy4yNXpNMjAuNzEgNy4wNGMuMzktLjM5LjM5LTEuMDIgMC0xLjQxbC0yLjM0LTIuMzRjLS4zOS0uMzktMS4wMi0uMzktMS40MSAwbC0xLjgzIDEuODMgMy43NSAzLjc1IDEuODMtMS44M3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJjcmVhdGUtbmV3LWZvbGRlclwiPjxwYXRoIGQ9XCJNMjAgNmgtOGwtMi0ySDRjLTEuMTEgMC0xLjk5Ljg5LTEuOTkgMkwyIDE4YzAgMS4xMS44OSAyIDIgMmgxNmMxLjExIDAgMi0uODkgMi0yVjhjMC0xLjExLS44OS0yLTItMnptLTEgOGgtM3YzaC0ydi0zaC0zdi0yaDNWOWgydjNoM3YyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImNyZWRpdC1jYXJkXCI+PHBhdGggZD1cIk0yMCA0SDRjLTEuMTEgMC0xLjk5Ljg5LTEuOTkgMkwyIDE4YzAgMS4xMS44OSAyIDIgMmgxNmMxLjExIDAgMi0uODkgMi0yVjZjMC0xLjExLS44OS0yLTItMnptMCAxNEg0di02aDE2djZ6bTAtMTBINFY2aDE2djJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZGFzaGJvYXJkXCI+PHBhdGggZD1cIk0zIDEzaDhWM0gzdjEwem0wIDhoOHYtNkgzdjZ6bTEwIDBoOFYxMWgtOHYxMHptMC0xOHY2aDhWM2gtOHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJkYXRlLXJhbmdlXCI+PHBhdGggZD1cIk05IDExSDd2Mmgydi0yem00IDBoLTJ2Mmgydi0yem00IDBoLTJ2Mmgydi0yem0yLTdoLTFWMmgtMnYySDhWMkg2djJINWMtMS4xMSAwLTEuOTkuOS0xLjk5IDJMMyAyMGMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0wIDE2SDVWOWgxNHYxMXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJkZWxldGVcIj48cGF0aCBkPVwiTTYgMTljMCAxLjEuOSAyIDIgMmg4YzEuMSAwIDItLjkgMi0yVjdINnYxMnpNMTkgNGgtMy41bC0xLTFoLTVsLTEgMUg1djJoMTRWNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJkZWxldGUtZm9yZXZlclwiPjxwYXRoIGQ9XCJNNiAxOWMwIDEuMS45IDIgMiAyaDhjMS4xIDAgMi0uOSAyLTJWN0g2djEyem0yLjQ2LTcuMTJsMS40MS0xLjQxTDEyIDEyLjU5bDIuMTItMi4xMiAxLjQxIDEuNDFMMTMuNDEgMTRsMi4xMiAyLjEyLTEuNDEgMS40MUwxMiAxNS40MWwtMi4xMiAyLjEyLTEuNDEtMS40MUwxMC41OSAxNGwtMi4xMy0yLjEyek0xNS41IDRsLTEtMWgtNWwtMSAxSDV2MmgxNFY0elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImRlbGV0ZS1zd2VlcFwiPjxwYXRoIGQ9XCJNMTUgMTZoNHYyaC00em0wLThoN3YyaC03em0wIDRoNnYyaC02ek0zIDE4YzAgMS4xLjkgMiAyIDJoNmMxLjEgMCAyLS45IDItMlY4SDN2MTB6TTE0IDVoLTNsLTEtMUg2TDUgNUgydjJoMTJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZGVzY3JpcHRpb25cIj48cGF0aCBkPVwiTTE0IDJINmMtMS4xIDAtMS45OS45LTEuOTkgMkw0IDIwYzAgMS4xLjg5IDIgMS45OSAySDE4YzEuMSAwIDItLjkgMi0yVjhsLTYtNnptMiAxNkg4di0yaDh2MnptMC00SDh2LTJoOHYyem0tMy01VjMuNUwxOC41IDlIMTN6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZG5zXCI+PHBhdGggZD1cIk0yMCAxM0g0Yy0uNTUgMC0xIC40NS0xIDF2NmMwIC41NS40NSAxIDEgMWgxNmMuNTUgMCAxLS40NSAxLTF2LTZjMC0uNTUtLjQ1LTEtMS0xek03IDE5Yy0xLjEgMC0yLS45LTItMnMuOS0yIDItMiAyIC45IDIgMi0uOSAyLTIgMnpNMjAgM0g0Yy0uNTUgMC0xIC40NS0xIDF2NmMwIC41NS40NSAxIDEgMWgxNmMuNTUgMCAxLS40NSAxLTFWNGMwLS41NS0uNDUtMS0xLTF6TTcgOWMtMS4xIDAtMi0uOS0yLTJzLjktMiAyLTIgMiAuOSAyIDItLjkgMi0yIDJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZG9uZVwiPjxwYXRoIGQ9XCJNOSAxNi4yTDQuOCAxMmwtMS40IDEuNEw5IDE5IDIxIDdsLTEuNC0xLjRMOSAxNi4yelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImRvbmUtYWxsXCI+PHBhdGggZD1cIk0xOCA3bC0xLjQxLTEuNDEtNi4zNCA2LjM0IDEuNDEgMS40MUwxOCA3em00LjI0LTEuNDFMMTEuNjYgMTYuMTcgNy40OCAxMmwtMS40MSAxLjQxTDExLjY2IDE5bDEyLTEyLTEuNDItMS40MXpNLjQxIDEzLjQxTDYgMTlsMS40MS0xLjQxTDEuODMgMTIgLjQxIDEzLjQxelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImRvbnV0LWxhcmdlXCI+PHBhdGggZD1cIk0xMSA1LjA4VjJjLTUgLjUtOSA0LjgxLTkgMTBzNCA5LjUgOSAxMHYtMy4wOGMtMy0uNDgtNi0zLjQtNi02LjkyczMtNi40NCA2LTYuOTJ6TTE4Ljk3IDExSDIyYy0uNDctNS00LTguNTMtOS05djMuMDhDMTYgNS41MSAxOC41NCA4IDE4Ljk3IDExek0xMyAxOC45MlYyMmM1LS40NyA4LjUzLTQgOS05aC0zLjAzYy0uNDMgMy0yLjk3IDUuNDktNS45NyA1LjkyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImRvbnV0LXNtYWxsXCI+PHBhdGggZD1cIk0xMSA5LjE2VjJjLTUgLjUtOSA0Ljc5LTkgMTBzNCA5LjUgOSAxMHYtNy4xNmMtMS0uNDEtMi0xLjUyLTItMi44NHMxLTIuNDMgMi0yLjg0ek0xNC44NiAxMUgyMmMtLjQ4LTQuNzUtNC04LjUzLTktOXY3LjE2YzEgLjMgMS41Mi45OCAxLjg2IDEuODR6TTEzIDE0Ljg0VjIyYzUtLjQ3IDguNTItNC4yNSA5LTloLTcuMTRjLS4zNC44Ni0uODYgMS41NC0xLjg2IDEuODR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZHJhZnRzXCI+PHBhdGggZD1cIk0yMS45OSA4YzAtLjcyLS4zNy0xLjM1LS45NC0xLjdMMTIgMSAyLjk1IDYuM0MyLjM4IDYuNjUgMiA3LjI4IDIgOHYxMGMwIDEuMS45IDIgMiAyaDE2YzEuMSAwIDItLjkgMi0ybC0uMDEtMTB6TTEyIDEzTDMuNzQgNy44NCAxMiAzbDguMjYgNC44NEwxMiAxM3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJlamVjdFwiPjxwYXRoIGQ9XCJNNSAxN2gxNHYySDV6bTctMTJMNS4zMyAxNWgxMy4zNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJlcnJvclwiPjxwYXRoIGQ9XCJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMSAxNWgtMnYtMmgydjJ6bTAtNGgtMlY3aDJ2NnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJlcnJvci1vdXRsaW5lXCI+PHBhdGggZD1cIk0xMSAxNWgydjJoLTJ6bTAtOGgydjZoLTJ6bS45OS01QzYuNDcgMiAyIDYuNDggMiAxMnM0LjQ3IDEwIDkuOTkgMTBDMTcuNTIgMjIgMjIgMTcuNTIgMjIgMTJTMTcuNTIgMiAxMS45OSAyek0xMiAyMGMtNC40MiAwLTgtMy41OC04LThzMy41OC04IDgtOCA4IDMuNTggOCA4LTMuNTggOC04IDh6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZXVyby1zeW1ib2xcIj48cGF0aCBkPVwiTTE1IDE4LjVjLTIuNTEgMC00LjY4LTEuNDItNS43Ni0zLjVIMTV2LTJIOC41OGMtLjA1LS4zMy0uMDgtLjY2LS4wOC0xcy4wMy0uNjcuMDgtMUgxNVY5SDkuMjRDMTAuMzIgNi45MiAxMi41IDUuNSAxNSA1LjVjMS42MSAwIDMuMDkuNTkgNC4yMyAxLjU3TDIxIDUuM0MxOS40MSAzLjg3IDE3LjMgMyAxNSAzYy0zLjkyIDAtNy4yNCAyLjUxLTguNDggNkgzdjJoMy4wNmMtLjA0LjMzLS4wNi42Ni0uMDYgMSAwIC4zNC4wMi42Ny4wNiAxSDN2MmgzLjUyYzEuMjQgMy40OSA0LjU2IDYgOC40OCA2IDIuMzEgMCA0LjQxLS44NyA2LTIuM2wtMS43OC0xLjc3Yy0xLjEzLjk4LTIuNiAxLjU3LTQuMjIgMS41N3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJldmVudFwiPjxwYXRoIGQ9XCJNMTcgMTJoLTV2NWg1di01ek0xNiAxdjJIOFYxSDZ2Mkg1Yy0xLjExIDAtMS45OS45LTEuOTkgMkwzIDE5YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjVjMC0xLjEtLjktMi0yLTJoLTFWMWgtMnptMyAxOEg1VjhoMTR2MTF6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZXZlbnQtc2VhdFwiPjxwYXRoIGQ9XCJNNCAxOHYzaDN2LTNoMTB2M2gzdi02SDR6bTE1LThoM3YzaC0zek0yIDEwaDN2M0gyem0xNSAzSDdWNWMwLTEuMS45LTIgMi0yaDZjMS4xIDAgMiAuOSAyIDJ2OHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJleGl0LXRvLWFwcFwiPjxwYXRoIGQ9XCJNMTAuMDkgMTUuNTlMMTEuNSAxN2w1LTUtNS01LTEuNDEgMS40MUwxMi42NyAxMUgzdjJoOS42N2wtMi41OCAyLjU5ek0xOSAzSDVjLTEuMTEgMC0yIC45LTIgMnY0aDJWNWgxNHYxNEg1di00SDN2NGMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImV4cGFuZC1sZXNzXCI+PHBhdGggZD1cIk0xMiA4bC02IDYgMS40MSAxLjQxTDEyIDEwLjgzbDQuNTkgNC41OEwxOCAxNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJleHBhbmQtbW9yZVwiPjxwYXRoIGQ9XCJNMTYuNTkgOC41OUwxMiAxMy4xNyA3LjQxIDguNTkgNiAxMGw2IDYgNi02elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImV4cGxvcmVcIj48cGF0aCBkPVwiTTEyIDEwLjljLS42MSAwLTEuMS40OS0xLjEgMS4xcy40OSAxLjEgMS4xIDEuMWMuNjEgMCAxLjEtLjQ5IDEuMS0xLjFzLS40OS0xLjEtMS4xLTEuMXpNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMi4xOSAxMi4xOUw2IDE4bDMuODEtOC4xOUwxOCA2bC0zLjgxIDguMTl6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZXh0ZW5zaW9uXCI+PHBhdGggZD1cIk0yMC41IDExSDE5VjdjMC0xLjEtLjktMi0yLTJoLTRWMy41QzEzIDIuMTIgMTEuODggMSAxMC41IDFTOCAyLjEyIDggMy41VjVINGMtMS4xIDAtMS45OS45LTEuOTkgMnYzLjhIMy41YzEuNDkgMCAyLjcgMS4yMSAyLjcgMi43cy0xLjIxIDIuNy0yLjcgMi43SDJWMjBjMCAxLjEuOSAyIDIgMmgzLjh2LTEuNWMwLTEuNDkgMS4yMS0yLjcgMi43LTIuNyAxLjQ5IDAgMi43IDEuMjEgMi43IDIuN1YyMkgxN2MxLjEgMCAyLS45IDItMnYtNGgxLjVjMS4zOCAwIDIuNS0xLjEyIDIuNS0yLjVTMjEuODggMTEgMjAuNSAxMXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJmYWNlXCI+PHBhdGggZD1cIk05IDExLjc1Yy0uNjkgMC0xLjI1LjU2LTEuMjUgMS4yNXMuNTYgMS4yNSAxLjI1IDEuMjUgMS4yNS0uNTYgMS4yNS0xLjI1LS41Ni0xLjI1LTEuMjUtMS4yNXptNiAwYy0uNjkgMC0xLjI1LjU2LTEuMjUgMS4yNXMuNTYgMS4yNSAxLjI1IDEuMjUgMS4yNS0uNTYgMS4yNS0xLjI1LS41Ni0xLjI1LTEuMjUtMS4yNXpNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LTggMC0uMjkuMDItLjU4LjA1LS44NiAyLjM2LTEuMDUgNC4yMy0yLjk4IDUuMjEtNS4zN0MxMS4wNyA4LjMzIDE0LjA1IDEwIDE3LjQyIDEwYy43OCAwIDEuNTMtLjA5IDIuMjUtLjI2LjIxLjcxLjMzIDEuNDcuMzMgMi4yNiAwIDQuNDEtMy41OSA4LTggOHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJmYXZvcml0ZVwiPjxwYXRoIGQ9XCJNMTIgMjEuMzVsLTEuNDUtMS4zMkM1LjQgMTUuMzYgMiAxMi4yOCAyIDguNSAyIDUuNDIgNC40MiAzIDcuNSAzYzEuNzQgMCAzLjQxLjgxIDQuNSAyLjA5QzEzLjA5IDMuODEgMTQuNzYgMyAxNi41IDMgMTkuNTggMyAyMiA1LjQyIDIyIDguNWMwIDMuNzgtMy40IDYuODYtOC41NSAxMS41NEwxMiAyMS4zNXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJmYXZvcml0ZS1ib3JkZXJcIj48cGF0aCBkPVwiTTE2LjUgM2MtMS43NCAwLTMuNDEuODEtNC41IDIuMDlDMTAuOTEgMy44MSA5LjI0IDMgNy41IDMgNC40MiAzIDIgNS40MiAyIDguNWMwIDMuNzggMy40IDYuODYgOC41NSAxMS41NEwxMiAyMS4zNWwxLjQ1LTEuMzJDMTguNiAxNS4zNiAyMiAxMi4yOCAyMiA4LjUgMjIgNS40MiAxOS41OCAzIDE2LjUgM3ptLTQuNCAxNS41NWwtLjEuMS0uMS0uMUM3LjE0IDE0LjI0IDQgMTEuMzkgNCA4LjUgNCA2LjUgNS41IDUgNy41IDVjMS41NCAwIDMuMDQuOTkgMy41NyAyLjM2aDEuODdDMTMuNDYgNS45OSAxNC45NiA1IDE2LjUgNWMyIDAgMy41IDEuNSAzLjUgMy41IDAgMi44OS0zLjE0IDUuNzQtNy45IDEwLjA1elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImZlZWRiYWNrXCI+PHBhdGggZD1cIk0yMCAySDRjLTEuMSAwLTEuOTkuOS0xLjk5IDJMMiAyMmw0LTRoMTRjMS4xIDAgMi0uOSAyLTJWNGMwLTEuMS0uOS0yLTItMnptLTcgMTJoLTJ2LTJoMnYyem0wLTRoLTJWNmgydjR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZmlsZS1kb3dubG9hZFwiPjxwYXRoIGQ9XCJNMTkgOWgtNFYzSDl2Nkg1bDcgNyA3LTd6TTUgMTh2MmgxNHYtMkg1elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImZpbGUtdXBsb2FkXCI+PHBhdGggZD1cIk05IDE2aDZ2LTZoNGwtNy03LTcgN2g0em0tNCAyaDE0djJINXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJmaWx0ZXItbGlzdFwiPjxwYXRoIGQ9XCJNMTAgMThoNHYtMmgtNHYyek0zIDZ2MmgxOFY2SDN6bTMgN2gxMnYtMkg2djJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZmluZC1pbi1wYWdlXCI+PHBhdGggZD1cIk0yMCAxOS41OVY4bC02LTZINmMtMS4xIDAtMS45OS45LTEuOTkgMkw0IDIwYzAgMS4xLjg5IDIgMS45OSAySDE4Yy40NSAwIC44NS0uMTUgMS4xOS0uNGwtNC40My00LjQzYy0uOC41Mi0xLjc0LjgzLTIuNzYuODMtMi43NiAwLTUtMi4yNC01LTVzMi4yNC01IDUtNSA1IDIuMjQgNSA1YzAgMS4wMi0uMzEgMS45Ni0uODMgMi43NUwyMCAxOS41OXpNOSAxM2MwIDEuNjYgMS4zNCAzIDMgM3MzLTEuMzQgMy0zLTEuMzQtMy0zLTMtMyAxLjM0LTMgM3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJmaW5kLXJlcGxhY2VcIj48cGF0aCBkPVwiTTExIDZjMS4zOCAwIDIuNjMuNTYgMy41NCAxLjQ2TDEyIDEwaDZWNGwtMi4wNSAyLjA1QzE0LjY4IDQuNzggMTIuOTMgNCAxMSA0Yy0zLjUzIDAtNi40MyAyLjYxLTYuOTIgNkg2LjFjLjQ2LTIuMjggMi40OC00IDQuOS00em01LjY0IDkuMTRjLjY2LS45IDEuMTItMS45NyAxLjI4LTMuMTRIMTUuOWMtLjQ2IDIuMjgtMi40OCA0LTQuOSA0LTEuMzggMC0yLjYzLS41Ni0zLjU0LTEuNDZMMTAgMTJINHY2bDIuMDUtMi4wNUM3LjMyIDE3LjIyIDkuMDcgMTggMTEgMThjMS41NSAwIDIuOTgtLjUxIDQuMTQtMS4zNkwyMCAyMS40OSAyMS40OSAyMGwtNC44NS00Ljg2elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImZpbmdlcnByaW50XCI+PHBhdGggZD1cIk0xNy44MSA0LjQ3Yy0uMDggMC0uMTYtLjAyLS4yMy0uMDZDMTUuNjYgMy40MiAxNCAzIDEyLjAxIDNjLTEuOTggMC0zLjg2LjQ3LTUuNTcgMS40MS0uMjQuMTMtLjU0LjA0LS42OC0uMi0uMTMtLjI0LS4wNC0uNTUuMi0uNjhDNy44MiAyLjUyIDkuODYgMiAxMi4wMSAyYzIuMTMgMCAzLjk5LjQ3IDYuMDMgMS41Mi4yNS4xMy4zNC40My4yMS42Ny0uMDkuMTgtLjI2LjI4LS40NC4yOHpNMy41IDkuNzJjLS4xIDAtLjItLjAzLS4yOS0uMDktLjIzLS4xNi0uMjgtLjQ3LS4xMi0uNy45OS0xLjQgMi4yNS0yLjUgMy43NS0zLjI3QzkuOTggNC4wNCAxNCA0LjAzIDE3LjE1IDUuNjVjMS41Ljc3IDIuNzYgMS44NiAzLjc1IDMuMjUuMTYuMjIuMTEuNTQtLjEyLjctLjIzLjE2LS41NC4xMS0uNy0uMTItLjktMS4yNi0yLjA0LTIuMjUtMy4zOS0yLjk0LTIuODctMS40Ny02LjU0LTEuNDctOS40LjAxLTEuMzYuNy0yLjUgMS43LTMuNCAyLjk2LS4wOC4xNC0uMjMuMjEtLjM5LjIxem02LjI1IDEyLjA3Yy0uMTMgMC0uMjYtLjA1LS4zNS0uMTUtLjg3LS44Ny0xLjM0LTEuNDMtMi4wMS0yLjY0LS42OS0xLjIzLTEuMDUtMi43My0xLjA1LTQuMzQgMC0yLjk3IDIuNTQtNS4zOSA1LjY2LTUuMzlzNS42NiAyLjQyIDUuNjYgNS4zOWMwIC4yOC0uMjIuNS0uNS41cy0uNS0uMjItLjUtLjVjMC0yLjQyLTIuMDktNC4zOS00LjY2LTQuMzktMi41NyAwLTQuNjYgMS45Ny00LjY2IDQuMzkgMCAxLjQ0LjMyIDIuNzcuOTMgMy44NS42NCAxLjE1IDEuMDggMS42NCAxLjg1IDIuNDIuMTkuMi4xOS41MSAwIC43MS0uMTEuMS0uMjQuMTUtLjM3LjE1em03LjE3LTEuODVjLTEuMTkgMC0yLjI0LS4zLTMuMS0uODktMS40OS0xLjAxLTIuMzgtMi42NS0yLjM4LTQuMzkgMC0uMjguMjItLjUuNS0uNXMuNS4yMi41LjVjMCAxLjQxLjcyIDIuNzQgMS45NCAzLjU2LjcxLjQ4IDEuNTQuNzEgMi41NC43MS4yNCAwIC42NC0uMDMgMS4wNC0uMS4yNy0uMDUuNTMuMTMuNTguNDEuMDUuMjctLjEzLjUzLS40MS41OC0uNTcuMTEtMS4wNy4xMi0xLjIxLjEyek0xNC45MSAyMmMtLjA0IDAtLjA5LS4wMS0uMTMtLjAyLTEuNTktLjQ0LTIuNjMtMS4wMy0zLjcyLTIuMS0xLjQtMS4zOS0yLjE3LTMuMjQtMi4xNy01LjIyIDAtMS42MiAxLjM4LTIuOTQgMy4wOC0yLjk0IDEuNyAwIDMuMDggMS4zMiAzLjA4IDIuOTQgMCAxLjA3LjkzIDEuOTQgMi4wOCAxLjk0czIuMDgtLjg3IDIuMDgtMS45NGMwLTMuNzctMy4yNS02LjgzLTcuMjUtNi44My0yLjg0IDAtNS40NCAxLjU4LTYuNjEgNC4wMy0uMzkuODEtLjU5IDEuNzYtLjU5IDIuOCAwIC43OC4wNyAyLjAxLjY3IDMuNjEuMS4yNi0uMDMuNTUtLjI5LjY0LS4yNi4xLS41NS0uMDQtLjY0LS4yOS0uNDktMS4zMS0uNzMtMi42MS0uNzMtMy45NiAwLTEuMi4yMy0yLjI5LjY4LTMuMjQgMS4zMy0yLjc5IDQuMjgtNC42IDcuNTEtNC42IDQuNTUgMCA4LjI1IDMuNTEgOC4yNSA3LjgzIDAgMS42Mi0xLjM4IDIuOTQtMy4wOCAyLjk0cy0zLjA4LTEuMzItMy4wOC0yLjk0YzAtMS4wNy0uOTMtMS45NC0yLjA4LTEuOTRzLTIuMDguODctMi4wOCAxLjk0YzAgMS43MS42NiAzLjMxIDEuODcgNC41MS45NS45NCAxLjg2IDEuNDYgMy4yNyAxLjg1LjI3LjA3LjQyLjM1LjM1LjYxLS4wNS4yMy0uMjYuMzgtLjQ3LjM4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImZpcnN0LXBhZ2VcIj48cGF0aCBkPVwiTTE4LjQxIDE2LjU5TDEzLjgyIDEybDQuNTktNC41OUwxNyA2bC02IDYgNiA2ek02IDZoMnYxMkg2elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImZsYWdcIj48cGF0aCBkPVwiTTE0LjQgNkwxNCA0SDV2MTdoMnYtN2g1LjZsLjQgMmg3VjZ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZmxpZ2h0LWxhbmRcIj48cGF0aCBkPVwiTTIuNSAxOWgxOXYyaC0xOXptNy4xOC01LjczbDQuMzUgMS4xNiA1LjMxIDEuNDJjLjguMjEgMS42Mi0uMjYgMS44NC0xLjA2LjIxLS44LS4yNi0xLjYyLTEuMDYtMS44NGwtNS4zMS0xLjQyLTIuNzYtOS4wMkwxMC4xMiAydjguMjhMNS4xNSA4Ljk1bC0uOTMtMi4zMi0xLjQ1LS4zOXY1LjE3bDEuNi40MyA1LjMxIDEuNDN6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZmxpZ2h0LXRha2VvZmZcIj48cGF0aCBkPVwiTTIuNSAxOWgxOXYyaC0xOXptMTkuNTctOS4zNmMtLjIxLS44LTEuMDQtMS4yOC0xLjg0LTEuMDZMMTQuOTIgMTBsLTYuOS02LjQzLTEuOTMuNTEgNC4xNCA3LjE3LTQuOTcgMS4zMy0xLjk3LTEuNTQtMS40NS4zOSAxLjgyIDMuMTYuNzcgMS4zMyAxLjYtLjQzIDUuMzEtMS40MiA0LjM1LTEuMTZMMjEgMTEuNDljLjgxLS4yMyAxLjI4LTEuMDUgMS4wNy0xLjg1elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImZsaXAtdG8tYmFja1wiPjxwYXRoIGQ9XCJNOSA3SDd2MmgyVjd6bTAgNEg3djJoMnYtMnptMC04Yy0xLjExIDAtMiAuOS0yIDJoMlYzem00IDEyaC0ydjJoMnYtMnptNi0xMnYyaDJjMC0xLjEtLjktMi0yLTJ6bS02IDBoLTJ2MmgyVjN6TTkgMTd2LTJIN2MwIDEuMS44OSAyIDIgMnptMTAtNGgydi0yaC0ydjJ6bTAtNGgyVjdoLTJ2MnptMCA4YzEuMSAwIDItLjkgMi0yaC0ydjJ6TTUgN0gzdjEyYzAgMS4xLjg5IDIgMiAyaDEydi0ySDVWN3ptMTAtMmgyVjNoLTJ2MnptMCAxMmgydi0yaC0ydjJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZmxpcC10by1mcm9udFwiPjxwYXRoIGQ9XCJNMyAxM2gydi0ySDN2MnptMCA0aDJ2LTJIM3Yyem0yIDR2LTJIM2MwIDEuMS44OSAyIDIgMnpNMyA5aDJWN0gzdjJ6bTEyIDEyaDJ2LTJoLTJ2MnptNC0xOEg5Yy0xLjExIDAtMiAuOS0yIDJ2MTBjMCAxLjEuODkgMiAyIDJoMTBjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnptMCAxMkg5VjVoMTB2MTB6bS04IDZoMnYtMmgtMnYyem0tNCAwaDJ2LTJIN3YyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImZvbGRlclwiPjxwYXRoIGQ9XCJNMTAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY4YzAtMS4xLS45LTItMi0yaC04bC0yLTJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZm9sZGVyLW9wZW5cIj48cGF0aCBkPVwiTTIwIDZoLThsLTItMkg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY4YzAtMS4xLS45LTItMi0yem0wIDEySDRWOGgxNnYxMHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJmb2xkZXItc2hhcmVkXCI+PHBhdGggZD1cIk0yMCA2aC04bC0yLTJINGMtMS4xIDAtMS45OS45LTEuOTkgMkwyIDE4YzAgMS4xLjkgMiAyIDJoMTZjMS4xIDAgMi0uOSAyLTJWOGMwLTEuMS0uOS0yLTItMnptLTUgM2MxLjEgMCAyIC45IDIgMnMtLjkgMi0yIDItMi0uOS0yLTIgLjktMiAyLTJ6bTQgOGgtOHYtMWMwLTEuMzMgMi42Ny0yIDQtMnM0IC42NyA0IDJ2MXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJmb250LWRvd25sb2FkXCI+PHBhdGggZD1cIk05LjkzIDEzLjVoNC4xNEwxMiA3Ljk4ek0yMCAySDRjLTEuMSAwLTIgLjktMiAydjE2YzAgMS4xLjkgMiAyIDJoMTZjMS4xIDAgMi0uOSAyLTJWNGMwLTEuMS0uOS0yLTItMnptLTQuMDUgMTYuNWwtMS4xNC0zSDkuMTdsLTEuMTIgM0g1Ljk2bDUuMTEtMTNoMS44Nmw1LjExIDEzaC0yLjA5elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImZvcndhcmRcIj48cGF0aCBkPVwiTTEyIDhWNGw4IDgtOCA4di00SDRWOHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJmdWxsc2NyZWVuXCI+PHBhdGggZD1cIk03IDE0SDV2NWg1di0ySDd2LTN6bS0yLTRoMlY3aDNWNUg1djV6bTEyIDdoLTN2Mmg1di01aC0ydjN6TTE0IDV2MmgzdjNoMlY1aC01elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImZ1bGxzY3JlZW4tZXhpdFwiPjxwYXRoIGQ9XCJNNSAxNmgzdjNoMnYtNUg1djJ6bTMtOEg1djJoNVY1SDh2M3ptNiAxMWgydi0zaDN2LTJoLTV2NXptMi0xMVY1aC0ydjVoNVY4aC0zelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImctdHJhbnNsYXRlXCI+PHBhdGggZD1cIk0yMCA1aC05LjEyTDEwIDJINGMtMS4xIDAtMiAuOS0yIDJ2MTNjMCAxLjEuOSAyIDIgMmg3bDEgM2g4YzEuMSAwIDItLjkgMi0yVjdjMC0xLjEtLjktMi0yLTJ6TTcuMTcgMTQuNTljLTIuMjUgMC00LjA5LTEuODMtNC4wOS00LjA5czEuODMtNC4wOSA0LjA5LTQuMDljMS4wNCAwIDEuOTkuMzcgMi43NCAxLjA3bC4wNy4wNi0xLjIzIDEuMTgtLjA2LS4wNWMtLjI5LS4yNy0uNzgtLjU5LTEuNTItLjU5LTEuMzEgMC0yLjM4IDEuMDktMi4zOCAyLjQyczEuMDcgMi40MiAyLjM4IDIuNDJjMS4zNyAwIDEuOTYtLjg3IDIuMTItMS40Nkg3LjA4VjkuOTFoMy45NWwuMDEuMDdjLjA0LjIxLjA1LjQuMDUuNjEgMCAyLjM1LTEuNjEgNC0zLjkyIDR6bTYuMDMtMS43MWMuMzMuNi43NCAxLjE4IDEuMTkgMS43bC0uNTQuNTMtLjY1LTIuMjN6bS43Ny0uNzZoLS45OWwtLjMxLTEuMDRoMy45OXMtLjM0IDEuMzEtMS41NiAyLjc0Yy0uNTItLjYyLS44OS0xLjIzLTEuMTMtMS43ek0yMSAyMGMwIC41NS0uNDUgMS0xIDFoLTdsMi0yLS44MS0yLjc3LjkyLS45MkwxNy43OSAxOGwuNzMtLjczLTIuNzEtMi42OGMuOS0xLjAzIDEuNi0yLjI1IDEuOTItMy41MUgxOXYtMS4wNGgtMy42NFY5aC0xLjA0djEuMDRoLTEuOTZMMTEuMTggNkgyMGMuNTUgMCAxIC40NSAxIDF2MTN6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZ2F2ZWxcIj48cGF0aCBkPVwiTTEgMjFoMTJ2Mkgxek01LjI0NSA4LjA3bDIuODMtMi44MjcgMTQuMTQgMTQuMTQyLTIuODI4IDIuODI4ek0xMi4zMTcgMWw1LjY1NyA1LjY1Ni0yLjgzIDIuODMtNS42NTQtNS42NnpNMy44MjUgOS40ODVsNS42NTcgNS42NTctMi44MjggMi44MjgtNS42NTctNS42NTd6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZ2VzdHVyZVwiPjxwYXRoIGQ9XCJNNC41OSA2Ljg5Yy43LS43MSAxLjQtMS4zNSAxLjcxLTEuMjIuNS4yIDAgMS4wMy0uMyAxLjUyLS4yNS40Mi0yLjg2IDMuODktMi44NiA2LjMxIDAgMS4yOC40OCAyLjM0IDEuMzQgMi45OC43NS41NiAxLjc0LjczIDIuNjQuNDYgMS4wNy0uMzEgMS45NS0xLjQgMy4wNi0yLjc3IDEuMjEtMS40OSAyLjgzLTMuNDQgNC4wOC0zLjQ0IDEuNjMgMCAxLjY1IDEuMDEgMS43NiAxLjc5LTMuNzguNjQtNS4zOCAzLjY3LTUuMzggNS4zNyAwIDEuNyAxLjQ0IDMuMDkgMy4yMSAzLjA5IDEuNjMgMCA0LjI5LTEuMzMgNC42OS02LjFIMjF2LTIuNWgtMi40N2MtLjE1LTEuNjUtMS4wOS00LjItNC4wMy00LjItMi4yNSAwLTQuMTggMS45MS00Ljk0IDIuODQtLjU4LjczLTIuMDYgMi40OC0yLjI5IDIuNzItLjI1LjMtLjY4Ljg0LTEuMTEuODQtLjQ1IDAtLjcyLS44My0uMzYtMS45Mi4zNS0xLjA5IDEuNC0yLjg2IDEuODUtMy41Mi43OC0xLjE0IDEuMy0xLjkyIDEuMy0zLjI4QzguOTUgMy42OSA3LjMxIDMgNi40NCAzIDUuMTIgMyAzLjk3IDQgMy43MiA0LjI1Yy0uMzYuMzYtLjY2LjY2LS44OC45M2wxLjc1IDEuNzF6bTkuMjkgMTEuNjZjLS4zMSAwLS43NC0uMjYtLjc0LS43MiAwLS42LjczLTIuMiAyLjg3LTIuNzYtLjMgMi42OS0xLjQzIDMuNDgtMi4xMyAzLjQ4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImdldC1hcHBcIj48cGF0aCBkPVwiTTE5IDloLTRWM0g5djZINWw3IDcgNy03ek01IDE4djJoMTR2LTJINXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJnaWZcIj48cGF0aCBkPVwiTTExLjUgOUgxM3Y2aC0xLjV6TTkgOUg2Yy0uNiAwLTEgLjUtMSAxdjRjMCAuNS40IDEgMSAxaDNjLjYgMCAxLS41IDEtMXYtMkg4LjV2MS41aC0ydi0zSDEwVjEwYzAtLjUtLjQtMS0xLTF6bTEwIDEuNVY5aC00LjV2NkgxNnYtMmgydi0xLjVoLTJ2LTF6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiZ3JhZGVcIj48cGF0aCBkPVwiTTEyIDE3LjI3TDE4LjE4IDIxbC0xLjY0LTcuMDNMMjIgOS4yNGwtNy4xOS0uNjFMMTIgMiA5LjE5IDguNjMgMiA5LjI0bDUuNDYgNC43M0w1LjgyIDIxelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImdyb3VwLXdvcmtcIj48cGF0aCBkPVwiTTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6TTggMTcuNWMtMS4zOCAwLTIuNS0xLjEyLTIuNS0yLjVzMS4xMi0yLjUgMi41LTIuNSAyLjUgMS4xMiAyLjUgMi41LTEuMTIgMi41LTIuNSAyLjV6TTkuNSA4YzAtMS4zOCAxLjEyLTIuNSAyLjUtMi41czIuNSAxLjEyIDIuNSAyLjUtMS4xMiAyLjUtMi41IDIuNVM5LjUgOS4zOCA5LjUgOHptNi41IDkuNWMtMS4zOCAwLTIuNS0xLjEyLTIuNS0yLjVzMS4xMi0yLjUgMi41LTIuNSAyLjUgMS4xMiAyLjUgMi41LTEuMTIgMi41LTIuNSAyLjV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiaGVscFwiPjxwYXRoIGQ9XCJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMSAxN2gtMnYtMmgydjJ6bTIuMDctNy43NWwtLjkuOTJDMTMuNDUgMTIuOSAxMyAxMy41IDEzIDE1aC0ydi0uNWMwLTEuMS40NS0yLjEgMS4xNy0yLjgzbDEuMjQtMS4yNmMuMzctLjM2LjU5LS44Ni41OS0xLjQxIDAtMS4xLS45LTItMi0ycy0yIC45LTIgMkg4YzAtMi4yMSAxLjc5LTQgNC00czQgMS43OSA0IDRjMCAuODgtLjM2IDEuNjgtLjkzIDIuMjV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiaGVscC1vdXRsaW5lXCI+PHBhdGggZD1cIk0xMSAxOGgydi0yaC0ydjJ6bTEtMTZDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4em0wLTE0Yy0yLjIxIDAtNCAxLjc5LTQgNGgyYzAtMS4xLjktMiAyLTJzMiAuOSAyIDJjMCAyLTMgMS43NS0zIDVoMmMwLTIuMjUgMy0yLjUgMy01IDAtMi4yMS0xLjc5LTQtNC00elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImhpZ2hsaWdodC1vZmZcIj48cGF0aCBkPVwiTTE0LjU5IDhMMTIgMTAuNTkgOS40MSA4IDggOS40MSAxMC41OSAxMiA4IDE0LjU5IDkuNDEgMTYgMTIgMTMuNDEgMTQuNTkgMTYgMTYgMTQuNTkgMTMuNDEgMTIgMTYgOS40MSAxNC41OSA4ek0xMiAyQzYuNDcgMiAyIDYuNDcgMiAxMnM0LjQ3IDEwIDEwIDEwIDEwLTQuNDcgMTAtMTBTMTcuNTMgMiAxMiAyem0wIDE4Yy00LjQxIDAtOC0zLjU5LTgtOHMzLjU5LTggOC04IDggMy41OSA4IDgtMy41OSA4LTggOHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJoaXN0b3J5XCI+PHBhdGggZD1cIk0xMyAzYy00Ljk3IDAtOSA0LjAzLTkgOUgxbDMuODkgMy44OS4wNy4xNEw5IDEySDZjMC0zLjg3IDMuMTMtNyA3LTdzNyAzLjEzIDcgNy0zLjEzIDctNyA3Yy0xLjkzIDAtMy42OC0uNzktNC45NC0yLjA2bC0xLjQyIDEuNDJDOC4yNyAxOS45OSAxMC41MSAyMSAxMyAyMWM0Ljk3IDAgOS00LjAzIDktOXMtNC4wMy05LTktOXptLTEgNXY1bDQuMjggMi41NC43Mi0xLjIxLTMuNS0yLjA4VjhIMTJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiaG9tZVwiPjxwYXRoIGQ9XCJNMTAgMjB2LTZoNHY2aDV2LThoM0wxMiAzIDIgMTJoM3Y4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImhvdXJnbGFzcy1lbXB0eVwiPjxwYXRoIGQ9XCJNNiAydjZoLjAxTDYgOC4wMSAxMCAxMmwtNCA0IC4wMS4wMUg2VjIyaDEydi01Ljk5aC0uMDFMMTggMTZsLTQtNCA0LTMuOTktLjAxLS4wMUgxOFYySDZ6bTEwIDE0LjVWMjBIOHYtMy41bDQtNCA0IDR6bS00LTVsLTQtNFY0aDh2My41bC00IDR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiaG91cmdsYXNzLWZ1bGxcIj48cGF0aCBkPVwiTTYgMnY2aC4wMUw2IDguMDEgMTAgMTJsLTQgNCAuMDEuMDFINlYyMmgxMnYtNS45OWgtLjAxTDE4IDE2bC00LTQgNC0zLjk5LS4wMS0uMDFIMThWMkg2elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImh0dHBcIj48cGF0aCBkPVwiTTQuNSAxMWgtMlY5SDF2NmgxLjV2LTIuNWgyVjE1SDZWOUg0LjV2MnptMi41LS41aDEuNVYxNUgxMHYtNC41aDEuNVY5SDd2MS41em01LjUgMEgxNFYxNWgxLjV2LTQuNUgxN1Y5aC00LjV2MS41em05LTEuNUgxOHY2aDEuNXYtMmgyYy44IDAgMS41LS43IDEuNS0xLjV2LTFjMC0uOC0uNy0xLjUtMS41LTEuNXptMCAyLjVoLTJ2LTFoMnYxelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImh0dHBzXCI+PHBhdGggZD1cIk0xOCA4aC0xVjZjMC0yLjc2LTIuMjQtNS01LTVTNyAzLjI0IDcgNnYySDZjLTEuMSAwLTIgLjktMiAydjEwYzAgMS4xLjkgMiAyIDJoMTJjMS4xIDAgMi0uOSAyLTJWMTBjMC0xLjEtLjktMi0yLTJ6bS02IDljLTEuMSAwLTItLjktMi0ycy45LTIgMi0yIDIgLjkgMiAyLS45IDItMiAyem0zLjEtOUg4LjlWNmMwLTEuNzEgMS4zOS0zLjEgMy4xLTMuMSAxLjcxIDAgMy4xIDEuMzkgMy4xIDMuMXYyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImltcG9ydGFudC1kZXZpY2VzXCI+PHBhdGggZD1cIk0yMyAxMS4wMUwxOCAxMWMtLjU1IDAtMSAuNDUtMSAxdjljMCAuNTUuNDUgMSAxIDFoNWMuNTUgMCAxLS40NSAxLTF2LTljMC0uNTUtLjQ1LS45OS0xLS45OXpNMjMgMjBoLTV2LTdoNXY3ek0yMCAySDJDLjg5IDIgMCAyLjg5IDAgNHYxMmMwIDEuMS44OSAyIDIgMmg3djJIN3YyaDh2LTJoLTJ2LTJoMnYtMkgyVjRoMTh2NWgyVjRjMC0xLjExLS45LTItMi0yem0tOC4wMyA3TDExIDZsLS45NyAzSDdsMi40NyAxLjc2LS45NCAyLjkxIDIuNDctMS44IDIuNDcgMS44LS45NC0yLjkxTDE1IDloLTMuMDN6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiaW5ib3hcIj48cGF0aCBkPVwiTTE5IDNINC45OWMtMS4xMSAwLTEuOTguODktMS45OCAyTDMgMTljMCAxLjEuODggMiAxLjk5IDJIMTljMS4xIDAgMi0uOSAyLTJWNWMwLTEuMTEtLjktMi0yLTJ6bTAgMTJoLTRjMCAxLjY2LTEuMzUgMy0zIDNzLTMtMS4zNC0zLTNINC45OVY1SDE5djEwelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImluZGV0ZXJtaW5hdGUtY2hlY2stYm94XCI+PHBhdGggZD1cIk0xOSAzSDVjLTEuMSAwLTIgLjktMiAydjE0YzAgMS4xLjkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnptLTIgMTBIN3YtMmgxMHYyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImluZm9cIj48cGF0aCBkPVwiTTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTEgMTVoLTJ2LTZoMnY2em0wLThoLTJWN2gydjJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiaW5mby1vdXRsaW5lXCI+PHBhdGggZD1cIk0xMSAxN2gydi02aC0ydjZ6bTEtMTVDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTAgMThjLTQuNDEgMC04LTMuNTktOC04czMuNTktOCA4LTggOCAzLjU5IDggOC0zLjU5IDgtOCA4ek0xMSA5aDJWN2gtMnYyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImlucHV0XCI+PHBhdGggZD1cIk0yMSAzLjAxSDNjLTEuMSAwLTIgLjktMiAyVjloMlY0Ljk5aDE4djE0LjAzSDNWMTVIMXY0LjAxYzAgMS4xLjkgMS45OCAyIDEuOThoMThjMS4xIDAgMi0uODggMi0xLjk4di0xNGMwLTEuMTEtLjktMi0yLTJ6TTExIDE2bDQtNC00LTR2M0gxdjJoMTB2M3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJpbnZlcnQtY29sb3JzXCI+PHBhdGggZD1cIk0xNy42NiA3LjkzTDEyIDIuMjcgNi4zNCA3LjkzYy0zLjEyIDMuMTItMy4xMiA4LjE5IDAgMTEuMzFDNy45IDIwLjggOS45NSAyMS41OCAxMiAyMS41OGMyLjA1IDAgNC4xLS43OCA1LjY2LTIuMzQgMy4xMi0zLjEyIDMuMTItOC4xOSAwLTExLjMxek0xMiAxOS41OWMtMS42IDAtMy4xMS0uNjItNC4yNC0xLjc2QzYuNjIgMTYuNjkgNiAxNS4xOSA2IDEzLjU5cy42Mi0zLjExIDEuNzYtNC4yNEwxMiA1LjF2MTQuNDl6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibGFiZWxcIj48cGF0aCBkPVwiTTE3LjYzIDUuODRDMTcuMjcgNS4zMyAxNi42NyA1IDE2IDVMNSA1LjAxQzMuOSA1LjAxIDMgNS45IDMgN3YxMGMwIDEuMS45IDEuOTkgMiAxLjk5TDE2IDE5Yy42NyAwIDEuMjctLjMzIDEuNjMtLjg0TDIyIDEybC00LjM3LTYuMTZ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibGFiZWwtb3V0bGluZVwiPjxwYXRoIGQ9XCJNMTcuNjMgNS44NEMxNy4yNyA1LjMzIDE2LjY3IDUgMTYgNUw1IDUuMDFDMy45IDUuMDEgMyA1LjkgMyA3djEwYzAgMS4xLjkgMS45OSAyIDEuOTlMMTYgMTljLjY3IDAgMS4yNy0uMzMgMS42My0uODRMMjIgMTJsLTQuMzctNi4xNnpNMTYgMTdINVY3aDExbDMuNTUgNUwxNiAxN3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJsYW5ndWFnZVwiPjxwYXRoIGQ9XCJNMTEuOTkgMkM2LjQ3IDIgMiA2LjQ4IDIgMTJzNC40NyAxMCA5Ljk5IDEwQzE3LjUyIDIyIDIyIDE3LjUyIDIyIDEyUzE3LjUyIDIgMTEuOTkgMnptNi45MyA2aC0yLjk1Yy0uMzItMS4yNS0uNzgtMi40NS0xLjM4LTMuNTYgMS44NC42MyAzLjM3IDEuOTEgNC4zMyAzLjU2ek0xMiA0LjA0Yy44MyAxLjIgMS40OCAyLjUzIDEuOTEgMy45NmgtMy44MmMuNDMtMS40MyAxLjA4LTIuNzYgMS45MS0zLjk2ek00LjI2IDE0QzQuMSAxMy4zNiA0IDEyLjY5IDQgMTJzLjEtMS4zNi4yNi0yaDMuMzhjLS4wOC42Ni0uMTQgMS4zMi0uMTQgMiAwIC42OC4wNiAxLjM0LjE0IDJINC4yNnptLjgyIDJoMi45NWMuMzIgMS4yNS43OCAyLjQ1IDEuMzggMy41Ni0xLjg0LS42My0zLjM3LTEuOS00LjMzLTMuNTZ6bTIuOTUtOEg1LjA4Yy45Ni0xLjY2IDIuNDktMi45MyA0LjMzLTMuNTZDOC44MSA1LjU1IDguMzUgNi43NSA4LjAzIDh6TTEyIDE5Ljk2Yy0uODMtMS4yLTEuNDgtMi41My0xLjkxLTMuOTZoMy44MmMtLjQzIDEuNDMtMS4wOCAyLjc2LTEuOTEgMy45NnpNMTQuMzQgMTRIOS42NmMtLjA5LS42Ni0uMTYtMS4zMi0uMTYtMiAwLS42OC4wNy0xLjM1LjE2LTJoNC42OGMuMDkuNjUuMTYgMS4zMi4xNiAyIDAgLjY4LS4wNyAxLjM0LS4xNiAyem0uMjUgNS41NmMuNi0xLjExIDEuMDYtMi4zMSAxLjM4LTMuNTZoMi45NWMtLjk2IDEuNjUtMi40OSAyLjkzLTQuMzMgMy41NnpNMTYuMzYgMTRjLjA4LS42Ni4xNC0xLjMyLjE0LTIgMC0uNjgtLjA2LTEuMzQtLjE0LTJoMy4zOGMuMTYuNjQuMjYgMS4zMS4yNiAycy0uMSAxLjM2LS4yNiAyaC0zLjM4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImxhc3QtcGFnZVwiPjxwYXRoIGQ9XCJNNS41OSA3LjQxTDEwLjE4IDEybC00LjU5IDQuNTlMNyAxOGw2LTYtNi02ek0xNiA2aDJ2MTJoLTJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibGF1bmNoXCI+PHBhdGggZD1cIk0xOSAxOUg1VjVoN1YzSDVjLTEuMTEgMC0yIC45LTIgMnYxNGMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMnYtN2gtMnY3ek0xNCAzdjJoMy41OWwtOS44MyA5LjgzIDEuNDEgMS40MUwxOSA2LjQxVjEwaDJWM2gtN3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJsaWdodGJ1bGItb3V0bGluZVwiPjxwYXRoIGQ9XCJNOSAyMWMwIC41NS40NSAxIDEgMWg0Yy41NSAwIDEtLjQ1IDEtMXYtMUg5djF6bTMtMTlDOC4xNCAyIDUgNS4xNCA1IDljMCAyLjM4IDEuMTkgNC40NyAzIDUuNzRWMTdjMCAuNTUuNDUgMSAxIDFoNmMuNTUgMCAxLS40NSAxLTF2LTIuMjZjMS44MS0xLjI3IDMtMy4zNiAzLTUuNzQgMC0zLjg2LTMuMTQtNy03LTd6bTIuODUgMTEuMWwtLjg1LjZWMTZoLTR2LTIuM2wtLjg1LS42QzcuOCAxMi4xNiA3IDEwLjYzIDcgOWMwLTIuNzYgMi4yNC01IDUtNXM1IDIuMjQgNSA1YzAgMS42My0uOCAzLjE2LTIuMTUgNC4xelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImxpbmUtc3R5bGVcIj48cGF0aCBkPVwiTTMgMTZoNXYtMkgzdjJ6bTYuNSAwaDV2LTJoLTV2MnptNi41IDBoNXYtMmgtNXYyek0zIDIwaDJ2LTJIM3Yyem00IDBoMnYtMkg3djJ6bTQgMGgydi0yaC0ydjJ6bTQgMGgydi0yaC0ydjJ6bTQgMGgydi0yaC0ydjJ6TTMgMTJoOHYtMkgzdjJ6bTEwIDBoOHYtMmgtOHYyek0zIDR2NGgxOFY0SDN6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibGluZS13ZWlnaHRcIj48cGF0aCBkPVwiTTMgMTdoMTh2LTJIM3Yyem0wIDNoMTh2LTFIM3Yxem0wLTdoMTh2LTNIM3Yzem0wLTl2NGgxOFY0SDN6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibGlua1wiPjxwYXRoIGQ9XCJNMy45IDEyYzAtMS43MSAxLjM5LTMuMSAzLjEtMy4xaDRWN0g3Yy0yLjc2IDAtNSAyLjI0LTUgNXMyLjI0IDUgNSA1aDR2LTEuOUg3Yy0xLjcxIDAtMy4xLTEuMzktMy4xLTMuMXpNOCAxM2g4di0ySDh2MnptOS02aC00djEuOWg0YzEuNzEgMCAzLjEgMS4zOSAzLjEgMy4xcy0xLjM5IDMuMS0zLjEgMy4xaC00VjE3aDRjMi43NiAwIDUtMi4yNCA1LTVzLTIuMjQtNS01LTV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibGlzdFwiPjxwYXRoIGQ9XCJNMyAxM2gydi0ySDN2MnptMCA0aDJ2LTJIM3Yyem0wLThoMlY3SDN2MnptNCA0aDE0di0ySDd2MnptMCA0aDE0di0ySDd2MnpNNyA3djJoMTRWN0g3elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImxvY2tcIj48cGF0aCBkPVwiTTE4IDhoLTFWNmMwLTIuNzYtMi4yNC01LTUtNVM3IDMuMjQgNyA2djJINmMtMS4xIDAtMiAuOS0yIDJ2MTBjMCAxLjEuOSAyIDIgMmgxMmMxLjEgMCAyLS45IDItMlYxMGMwLTEuMS0uOS0yLTItMnptLTYgOWMtMS4xIDAtMi0uOS0yLTJzLjktMiAyLTIgMiAuOSAyIDItLjkgMi0yIDJ6bTMuMS05SDguOVY2YzAtMS43MSAxLjM5LTMuMSAzLjEtMy4xIDEuNzEgMCAzLjEgMS4zOSAzLjEgMy4xdjJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibG9jay1vcGVuXCI+PHBhdGggZD1cIk0xMiAxN2MxLjEgMCAyLS45IDItMnMtLjktMi0yLTItMiAuOS0yIDIgLjkgMiAyIDJ6bTYtOWgtMVY2YzAtMi43Ni0yLjI0LTUtNS01UzcgMy4yNCA3IDZoMS45YzAtMS43MSAxLjM5LTMuMSAzLjEtMy4xIDEuNzEgMCAzLjEgMS4zOSAzLjEgMy4xdjJINmMtMS4xIDAtMiAuOS0yIDJ2MTBjMCAxLjEuOSAyIDIgMmgxMmMxLjEgMCAyLS45IDItMlYxMGMwLTEuMS0uOS0yLTItMnptMCAxMkg2VjEwaDEydjEwelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImxvY2stb3V0bGluZVwiPjxwYXRoIGQ9XCJNMTIgMTdjMS4xIDAgMi0uOSAyLTJzLS45LTItMi0yLTIgLjktMiAyIC45IDIgMiAyem02LTloLTFWNmMwLTIuNzYtMi4yNC01LTUtNVM3IDMuMjQgNyA2djJINmMtMS4xIDAtMiAuOS0yIDJ2MTBjMCAxLjEuOSAyIDIgMmgxMmMxLjEgMCAyLS45IDItMlYxMGMwLTEuMS0uOS0yLTItMnpNOC45IDZjMC0xLjcxIDEuMzktMy4xIDMuMS0zLjFzMy4xIDEuMzkgMy4xIDMuMXYySDguOVY2ek0xOCAyMEg2VjEwaDEydjEwelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cImxvdy1wcmlvcml0eVwiPjxwYXRoIGQ9XCJNMTQgNWg4djJoLTh6bTAgNS41aDh2MmgtOHptMCA1LjVoOHYyaC04ek0yIDExLjVDMiAxNS4wOCA0LjkyIDE4IDguNSAxOEg5djJsMy0zLTMtM3YyaC0uNUM2LjAyIDE2IDQgMTMuOTggNCAxMS41UzYuMDIgNyA4LjUgN0gxMlY1SDguNUM0LjkyIDUgMiA3LjkyIDIgMTEuNXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJsb3lhbHR5XCI+PHBhdGggZD1cIk0yMS40MSAxMS41OGwtOS05QzEyLjA1IDIuMjIgMTEuNTUgMiAxMSAySDRjLTEuMSAwLTIgLjktMiAydjdjMCAuNTUuMjIgMS4wNS41OSAxLjQybDkgOWMuMzYuMzYuODYuNTggMS40MS41OC41NSAwIDEuMDUtLjIyIDEuNDEtLjU5bDctN2MuMzctLjM2LjU5LS44Ni41OS0xLjQxIDAtLjU1LS4yMy0xLjA2LS41OS0xLjQyek01LjUgN0M0LjY3IDcgNCA2LjMzIDQgNS41UzQuNjcgNCA1LjUgNCA3IDQuNjcgNyA1LjUgNi4zMyA3IDUuNSA3em0xMS43NyA4LjI3TDEzIDE5LjU0bC00LjI3LTQuMjdDOC4yOCAxNC44MSA4IDE0LjE5IDggMTMuNWMwLTEuMzggMS4xMi0yLjUgMi41LTIuNS42OSAwIDEuMzIuMjggMS43Ny43NGwuNzMuNzIuNzMtLjczYy40NS0uNDUgMS4wOC0uNzMgMS43Ny0uNzMgMS4zOCAwIDIuNSAxLjEyIDIuNSAyLjUgMCAuNjktLjI4IDEuMzItLjczIDEuNzd6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibWFpbFwiPjxwYXRoIGQ9XCJNMjAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0wIDRsLTggNS04LTVWNmw4IDUgOC01djJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibWFya3VucmVhZFwiPjxwYXRoIGQ9XCJNMjAgNEg0Yy0xLjEgMC0xLjk5LjktMS45OSAyTDIgMThjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0wIDRsLTggNS04LTVWNmw4IDUgOC01djJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibWFya3VucmVhZC1tYWlsYm94XCI+PHBhdGggZD1cIk0yMCA2SDEwdjZIOFY0aDZWMEg2djZINGMtMS4xIDAtMiAuOS0yIDJ2MTJjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY4YzAtMS4xLS45LTItMi0yelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cIm1lbnVcIj48cGF0aCBkPVwiTTMgMThoMTh2LTJIM3Yyem0wLTVoMTh2LTJIM3Yyem0wLTd2MmgxOFY2SDN6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwibW9yZS1ob3JpelwiPjxwYXRoIGQ9XCJNNiAxMGMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6bTEyIDBjLTEuMSAwLTIgLjktMiAycy45IDIgMiAyIDItLjkgMi0yLS45LTItMi0yem0tNiAwYy0xLjEgMC0yIC45LTIgMnMuOSAyIDIgMiAyLS45IDItMi0uOS0yLTItMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJtb3JlLXZlcnRcIj48cGF0aCBkPVwiTTEyIDhjMS4xIDAgMi0uOSAyLTJzLS45LTItMi0yLTIgLjktMiAyIC45IDIgMiAyem0wIDJjLTEuMSAwLTIgLjktMiAycy45IDIgMiAyIDItLjkgMi0yLS45LTItMi0yem0wIDZjLTEuMSAwLTIgLjktMiAycy45IDIgMiAyIDItLjkgMi0yLS45LTItMi0yelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cIm1vdG9yY3ljbGVcIj48cGF0aCBkPVwiTTE5LjQ0IDkuMDNMMTUuNDEgNUgxMXYyaDMuNTlsMiAySDVjLTIuOCAwLTUgMi4yLTUgNXMyLjIgNSA1IDVjMi40NiAwIDQuNDUtMS42OSA0LjktNGgxLjY1bDIuNzctMi43N2MtLjIxLjU0LS4zMiAxLjE0LS4zMiAxLjc3IDAgMi44IDIuMiA1IDUgNXM1LTIuMiA1LTVjMC0yLjY1LTEuOTctNC43Ny00LjU2LTQuOTd6TTcuODIgMTVDNy40IDE2LjE1IDYuMjggMTcgNSAxN2MtMS42MyAwLTMtMS4zNy0zLTNzMS4zNy0zIDMtM2MxLjI4IDAgMi40Ljg1IDIuODIgMkg1djJoMi44MnpNMTkgMTdjLTEuNjYgMC0zLTEuMzQtMy0zczEuMzQtMyAzLTMgMyAxLjM0IDMgMy0xLjM0IDMtMyAzelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cIm1vdmUtdG8taW5ib3hcIj48cGF0aCBkPVwiTTE5IDNINC45OWMtMS4xMSAwLTEuOTguOS0xLjk4IDJMMyAxOWMwIDEuMS44OCAyIDEuOTkgMkgxOWMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDEyaC00YzAgMS42Ni0xLjM1IDMtMyAzcy0zLTEuMzQtMy0zSDQuOTlWNUgxOXYxMHptLTMtNWgtMlY3aC00djNIOGw0IDQgNC00elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cIm5leHQtd2Vla1wiPjxwYXRoIGQ9XCJNMjAgN2gtNFY1YzAtLjU1LS4yMi0xLjA1LS41OS0xLjQxQzE1LjA1IDMuMjIgMTQuNTUgMyAxNCAzaC00Yy0xLjEgMC0yIC45LTIgMnYySDRjLTEuMSAwLTIgLjktMiAydjExYzAgMS4xLjkgMiAyIDJoMTZjMS4xIDAgMi0uOSAyLTJWOWMwLTEuMS0uOS0yLTItMnpNMTAgNWg0djJoLTRWNXptMSAxMy41bC0xLTEgMy0zLTMtMyAxLTEgNCA0LTQgNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJub3RlLWFkZFwiPjxwYXRoIGQ9XCJNMTQgMkg2Yy0xLjEgMC0xLjk5LjktMS45OSAyTDQgMjBjMCAxLjEuODkgMiAxLjk5IDJIMThjMS4xIDAgMi0uOSAyLTJWOGwtNi02em0yIDE0aC0zdjNoLTJ2LTNIOHYtMmgzdi0zaDJ2M2gzdjJ6bS0zLTdWMy41TDE4LjUgOUgxM3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJvZmZsaW5lLXBpblwiPjxwYXRoIGQ9XCJNMTIgMkM2LjUgMiAyIDYuNSAyIDEyczQuNSAxMCAxMCAxMCAxMC00LjUgMTAtMTBTMTcuNSAyIDEyIDJ6bTUgMTZIN3YtMmgxMHYyem0tNi43LTRMNyAxMC43bDEuNC0xLjQgMS45IDEuOSA1LjMtNS4zTDE3IDcuMyAxMC4zIDE0elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cIm9wYWNpdHlcIj48cGF0aCBkPVwiTTE3LjY2IDhMMTIgMi4zNSA2LjM0IDhDNC43OCA5LjU2IDQgMTEuNjQgNCAxMy42NHMuNzggNC4xMSAyLjM0IDUuNjcgMy42MSAyLjM1IDUuNjYgMi4zNSA0LjEtLjc5IDUuNjYtMi4zNVMyMCAxNS42NCAyMCAxMy42NCAxOS4yMiA5LjU2IDE3LjY2IDh6TTYgMTRjLjAxLTIgLjYyLTMuMjcgMS43Ni00LjRMMTIgNS4yN2w0LjI0IDQuMzhDMTcuMzggMTAuNzcgMTcuOTkgMTIgMTggMTRINnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJvcGVuLWluLWJyb3dzZXJcIj48cGF0aCBkPVwiTTE5IDRINWMtMS4xMSAwLTIgLjktMiAydjEyYzAgMS4xLjg5IDIgMiAyaDR2LTJINVY4aDE0djEwaC00djJoNGMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS44OS0yLTItMnptLTcgNmwtNCA0aDN2Nmgydi02aDNsLTQtNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJvcGVuLWluLW5ld1wiPjxwYXRoIGQ9XCJNMTkgMTlINVY1aDdWM0g1Yy0xLjExIDAtMiAuOS0yIDJ2MTRjMCAxLjEuODkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJ2LTdoLTJ2N3pNMTQgM3YyaDMuNTlsLTkuODMgOS44MyAxLjQxIDEuNDFMMTkgNi40MVYxMGgyVjNoLTd6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwib3Blbi13aXRoXCI+PHBhdGggZD1cIk0xMCA5aDRWNmgzbC01LTUtNSA1aDN2M3ptLTEgMUg2VjdsLTUgNSA1IDV2LTNoM3YtNHptMTQgMmwtNS01djNoLTN2NGgzdjNsNS01em0tOSAzaC00djNIN2w1IDUgNS01aC0zdi0zelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInBhZ2V2aWV3XCI+PHBhdGggZD1cIk0xMS41IDlDMTAuMTIgOSA5IDEwLjEyIDkgMTEuNXMxLjEyIDIuNSAyLjUgMi41IDIuNS0xLjEyIDIuNS0yLjVTMTIuODggOSAxMS41IDl6TTIwIDRINGMtMS4xIDAtMiAuOS0yIDJ2MTJjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yem0tMy4yMSAxNC4yMWwtMi45MS0yLjkxYy0uNjkuNDQtMS41MS43LTIuMzkuN0M5LjAxIDE2IDcgMTMuOTkgNyAxMS41UzkuMDEgNyAxMS41IDcgMTYgOS4wMSAxNiAxMS41YzAgLjg4LS4yNiAxLjY5LS43IDIuMzlsMi45MSAyLjktMS40MiAxLjQyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInBhbi10b29sXCI+PHBhdGggZD1cIk0yMyA1LjVWMjBjMCAyLjItMS44IDQtNCA0aC03LjNjLTEuMDggMC0yLjEtLjQzLTIuODUtMS4xOUwxIDE0LjgzczEuMjYtMS4yMyAxLjMtMS4yNWMuMjItLjE5LjQ5LS4yOS43OS0uMjkuMjIgMCAuNDIuMDYuNi4xNi4wNC4wMSA0LjMxIDIuNDYgNC4zMSAyLjQ2VjRjMC0uODMuNjctMS41IDEuNS0xLjVTMTEgMy4xNyAxMSA0djdoMVYxLjVjMC0uODMuNjctMS41IDEuNS0xLjVTMTUgLjY3IDE1IDEuNVYxMWgxVjIuNWMwLS44My42Ny0xLjUgMS41LTEuNXMxLjUuNjcgMS41IDEuNVYxMWgxVjUuNWMwLS44My42Ny0xLjUgMS41LTEuNXMxLjUuNjcgMS41IDEuNXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJwYXltZW50XCI+PHBhdGggZD1cIk0yMCA0SDRjLTEuMTEgMC0xLjk5Ljg5LTEuOTkgMkwyIDE4YzAgMS4xMS44OSAyIDIgMmgxNmMxLjExIDAgMi0uODkgMi0yVjZjMC0xLjExLS44OS0yLTItMnptMCAxNEg0di02aDE2djZ6bTAtMTBINFY2aDE2djJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicGVybS1jYW1lcmEtbWljXCI+PHBhdGggZD1cIk0yMCA1aC0zLjE3TDE1IDNIOUw3LjE3IDVINGMtMS4xIDAtMiAuOS0yIDJ2MTJjMCAxLjEuOSAyIDIgMmg3di0yLjA5Yy0yLjgzLS40OC01LTIuOTQtNS01LjkxaDJjMCAyLjIxIDEuNzkgNCA0IDRzNC0xLjc5IDQtNGgyYzAgMi45Ny0yLjE3IDUuNDMtNSA1LjkxVjIxaDdjMS4xIDAgMi0uOSAyLTJWN2MwLTEuMS0uOS0yLTItMnptLTYgOGMwIDEuMS0uOSAyLTIgMnMtMi0uOS0yLTJWOWMwLTEuMS45LTIgMi0yczIgLjkgMiAydjR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicGVybS1jb250YWN0LWNhbGVuZGFyXCI+PHBhdGggZD1cIk0xOSAzaC0xVjFoLTJ2Mkg4VjFINnYySDVjLTEuMTEgMC0yIC45LTIgMnYxNGMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0tNyAzYzEuNjYgMCAzIDEuMzQgMyAzcy0xLjM0IDMtMyAzLTMtMS4zNC0zLTMgMS4zNC0zIDMtM3ptNiAxMkg2di0xYzAtMiA0LTMuMSA2LTMuMXM2IDEuMSA2IDMuMXYxelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInBlcm0tZGF0YS1zZXR0aW5nXCI+PHBhdGggZD1cIk0xOC45OSAxMS41Yy4zNCAwIC42Ny4wMyAxIC4wN0wyMCAwIDAgMjBoMTEuNTZjLS4wNC0uMzMtLjA3LS42Ni0uMDctMSAwLTQuMTQgMy4zNi03LjUgNy41LTcuNXptMy43MSA3Ljk5Yy4wMi0uMTYuMDQtLjMyLjA0LS40OSAwLS4xNy0uMDEtLjMzLS4wNC0uNDlsMS4wNi0uODNjLjA5LS4wOC4xMi0uMjEuMDYtLjMybC0xLTEuNzNjLS4wNi0uMTEtLjE5LS4xNS0uMzEtLjExbC0xLjI0LjVjLS4yNi0uMi0uNTQtLjM3LS44NS0uNDlsLS4xOS0xLjMyYy0uMDEtLjEyLS4xMi0uMjEtLjI0LS4yMWgtMmMtLjEyIDAtLjIzLjA5LS4yNS4yMWwtLjE5IDEuMzJjLS4zLjEzLS41OS4yOS0uODUuNDlsLTEuMjQtLjVjLS4xMS0uMDQtLjI0IDAtLjMxLjExbC0xIDEuNzNjLS4wNi4xMS0uMDQuMjQuMDYuMzJsMS4wNi44M2MtLjAyLjE2LS4wMy4zMi0uMDMuNDkgMCAuMTcuMDEuMzMuMDMuNDlsLTEuMDYuODNjLS4wOS4wOC0uMTIuMjEtLjA2LjMybDEgMS43M2MuMDYuMTEuMTkuMTUuMzEuMTFsMS4yNC0uNWMuMjYuMi41NC4zNy44NS40OWwuMTkgMS4zMmMuMDIuMTIuMTIuMjEuMjUuMjFoMmMuMTIgMCAuMjMtLjA5LjI1LS4yMWwuMTktMS4zMmMuMy0uMTMuNTktLjI5Ljg0LS40OWwxLjI1LjVjLjExLjA0LjI0IDAgLjMxLS4xMWwxLTEuNzNjLjA2LS4xMS4wMy0uMjQtLjA2LS4zMmwtMS4wNy0uODN6bS0zLjcxIDEuMDFjLS44MyAwLTEuNS0uNjctMS41LTEuNXMuNjctMS41IDEuNS0xLjUgMS41LjY3IDEuNSAxLjUtLjY3IDEuNS0xLjUgMS41elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInBlcm0tZGV2aWNlLWluZm9ybWF0aW9uXCI+PHBhdGggZD1cIk0xMyA3aC0ydjJoMlY3em0wIDRoLTJ2Nmgydi02em00LTkuOTlMNyAxYy0xLjEgMC0yIC45LTIgMnYxOGMwIDEuMS45IDIgMiAyaDEwYzEuMSAwIDItLjkgMi0yVjNjMC0xLjEtLjktMS45OS0yLTEuOTl6TTE3IDE5SDdWNWgxMHYxNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJwZXJtLWlkZW50aXR5XCI+PHBhdGggZD1cIk0xMiA1LjljMS4xNiAwIDIuMS45NCAyLjEgMi4xcy0uOTQgMi4xLTIuMSAyLjFTOS45IDkuMTYgOS45IDhzLjk0LTIuMSAyLjEtMi4xbTAgOWMyLjk3IDAgNi4xIDEuNDYgNi4xIDIuMXYxLjFINS45VjE3YzAtLjY0IDMuMTMtMi4xIDYuMS0yLjFNMTIgNEM5Ljc5IDQgOCA1Ljc5IDggOHMxLjc5IDQgNCA0IDQtMS43OSA0LTQtMS43OS00LTQtNHptMCA5Yy0yLjY3IDAtOCAxLjM0LTggNHYzaDE2di0zYzAtMi42Ni01LjMzLTQtOC00elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInBlcm0tbWVkaWFcIj48cGF0aCBkPVwiTTIgNkgwdjVoLjAxTDAgMjBjMCAxLjEuOSAyIDIgMmgxOHYtMkgyVjZ6bTIwLTJoLThsLTItMkg2Yy0xLjEgMC0xLjk5LjktMS45OSAyTDQgMTZjMCAxLjEuOSAyIDIgMmgxNmMxLjEgMCAyLS45IDItMlY2YzAtMS4xLS45LTItMi0yek03IDE1bDQuNS02IDMuNSA0LjUxIDIuNS0zLjAxTDIxIDE1SDd6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicGVybS1waG9uZS1tc2dcIj48cGF0aCBkPVwiTTIwIDE1LjVjLTEuMjUgMC0yLjQ1LS4yLTMuNTctLjU3LS4zNS0uMTEtLjc0LS4wMy0xLjAyLjI0bC0yLjIgMi4yYy0yLjgzLTEuNDQtNS4xNS0zLjc1LTYuNTktNi41OGwyLjItMi4yMWMuMjgtLjI3LjM2LS42Ni4yNS0xLjAxQzguNyA2LjQ1IDguNSA1LjI1IDguNSA0YzAtLjU1LS40NS0xLTEtMUg0Yy0uNTUgMC0xIC40NS0xIDEgMCA5LjM5IDcuNjEgMTcgMTcgMTcgLjU1IDAgMS0uNDUgMS0xdi0zLjVjMC0uNTUtLjQ1LTEtMS0xek0xMiAzdjEwbDMtM2g2VjNoLTl6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicGVybS1zY2FuLXdpZmlcIj48cGF0aCBkPVwiTTEyIDNDNi45NSAzIDMuMTUgNC44NSAwIDcuMjNMMTIgMjIgMjQgNy4yNUMyMC44NSA0Ljg3IDE3LjA1IDMgMTIgM3ptMSAxM2gtMnYtNmgydjZ6bS0yLThWNmgydjJoLTJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicGV0c1wiPjxjaXJjbGUgY3g9XCI0LjVcIiBjeT1cIjkuNVwiIHI9XCIyLjVcIj48L2NpcmNsZT48Y2lyY2xlIGN4PVwiOVwiIGN5PVwiNS41XCIgcj1cIjIuNVwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XCIxNVwiIGN5PVwiNS41XCIgcj1cIjIuNVwiPjwvY2lyY2xlPjxjaXJjbGUgY3g9XCIxOS41XCIgY3k9XCI5LjVcIiByPVwiMi41XCI+PC9jaXJjbGU+PHBhdGggZD1cIk0xNy4zNCAxNC44NmMtLjg3LTEuMDItMS42LTEuODktMi40OC0yLjkxLS40Ni0uNTQtMS4wNS0xLjA4LTEuNzUtMS4zMi0uMTEtLjA0LS4yMi0uMDctLjMzLS4wOS0uMjUtLjA0LS41Mi0uMDQtLjc4LS4wNHMtLjUzIDAtLjc5LjA1Yy0uMTEuMDItLjIyLjA1LS4zMy4wOS0uNy4yNC0xLjI4Ljc4LTEuNzUgMS4zMi0uODcgMS4wMi0xLjYgMS44OS0yLjQ4IDIuOTEtMS4zMSAxLjMxLTIuOTIgMi43Ni0yLjYyIDQuNzkuMjkgMS4wMiAxLjAyIDIuMDMgMi4zMyAyLjMyLjczLjE1IDMuMDYtLjQ0IDUuNTQtLjQ0aC4xOGMyLjQ4IDAgNC44MS41OCA1LjU0LjQ0IDEuMzEtLjI5IDIuMDQtMS4zMSAyLjMzLTIuMzIuMzEtMi4wNC0xLjMtMy40OS0yLjYxLTQuOHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJwaWN0dXJlLWluLXBpY3R1cmVcIj48cGF0aCBkPVwiTTE5IDdoLTh2Nmg4Vjd6bTItNEgzYy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDEuOTggMiAxLjk4aDE4YzEuMSAwIDItLjg4IDItMS45OFY1YzAtMS4xLS45LTItMi0yem0wIDE2LjAxSDNWNC45OGgxOHYxNC4wM3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJwaWN0dXJlLWluLXBpY3R1cmUtYWx0XCI+PHBhdGggZD1cIk0xOSAxMWgtOHY2aDh2LTZ6bTQgOFY0Ljk4QzIzIDMuODggMjIuMSAzIDIxIDNIM2MtMS4xIDAtMiAuODgtMiAxLjk4VjE5YzAgMS4xLjkgMiAyIDJoMThjMS4xIDAgMi0uOSAyLTJ6bS0yIC4wMkgzVjQuOTdoMTh2MTQuMDV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicGxheS1mb3Itd29ya1wiPjxwYXRoIGQ9XCJNMTEgNXY1LjU5SDcuNWw0LjUgNC41IDQuNS00LjVIMTNWNWgtMnptLTUgOWMwIDMuMzEgMi42OSA2IDYgNnM2LTIuNjkgNi02aC0yYzAgMi4yMS0xLjc5IDQtNCA0cy00LTEuNzktNC00SDZ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicG9seW1lclwiPjxwYXRoIGQ9XCJNMTkgNGgtNEw3LjExIDE2LjYzIDQuNSAxMiA5IDRINUwuNSAxMiA1IDIwaDRsNy44OS0xMi42M0wxOS41IDEyIDE1IDIwaDRsNC41LTh6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicG93ZXItc2V0dGluZ3MtbmV3XCI+PHBhdGggZD1cIk0xMyAzaC0ydjEwaDJWM3ptNC44MyAyLjE3bC0xLjQyIDEuNDJDMTcuOTkgNy44NiAxOSA5LjgxIDE5IDEyYzAgMy44Ny0zLjEzIDctNyA3cy03LTMuMTMtNy03YzAtMi4xOSAxLjAxLTQuMTQgMi41OC01LjQyTDYuMTcgNS4xN0M0LjIzIDYuODIgMyA5LjI2IDMgMTJjMCA0Ljk3IDQuMDMgOSA5IDlzOS00LjAzIDktOWMwLTIuNzQtMS4yMy01LjE4LTMuMTctNi44M3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJwcmVnbmFudC13b21hblwiPjxwYXRoIGQ9XCJNOSA0YzAtMS4xMS44OS0yIDItMnMyIC44OSAyIDItLjg5IDItMiAyLTItLjg5LTItMnptNyA5Yy0uMDEtMS4zNC0uODMtMi41MS0yLTMgMC0xLjY2LTEuMzQtMy0zLTNzLTMgMS4zNC0zIDN2N2gydjVoM3YtNWgzdi00elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInByaW50XCI+PHBhdGggZD1cIk0xOSA4SDVjLTEuNjYgMC0zIDEuMzQtMyAzdjZoNHY0aDEydi00aDR2LTZjMC0xLjY2LTEuMzQtMy0zLTN6bS0zIDExSDh2LTVoOHY1em0zLTdjLS41NSAwLTEtLjQ1LTEtMXMuNDUtMSAxLTEgMSAuNDUgMSAxLS40NSAxLTEgMXptLTEtOUg2djRoMTJWM3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJxdWVyeS1idWlsZGVyXCI+PHBhdGggZD1cIk0xMS45OSAyQzYuNDcgMiAyIDYuNDggMiAxMnM0LjQ3IDEwIDkuOTkgMTBDMTcuNTIgMjIgMjIgMTcuNTIgMjIgMTJTMTcuNTIgMiAxMS45OSAyek0xMiAyMGMtNC40MiAwLTgtMy41OC04LThzMy41OC04IDgtOCA4IDMuNTggOCA4LTMuNTggOC04IDh6bS41LTEzSDExdjZsNS4yNSAzLjE1Ljc1LTEuMjMtNC41LTIuNjd6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicXVlc3Rpb24tYW5zd2VyXCI+PHBhdGggZD1cIk0yMSA2aC0ydjlINnYyYzAgLjU1LjQ1IDEgMSAxaDExbDQgNFY3YzAtLjU1LS40NS0xLTEtMXptLTQgNlYzYzAtLjU1LS40NS0xLTEtMUgzYy0uNTUgMC0xIC40NS0xIDF2MTRsNC00aDEwYy41NSAwIDEtLjQ1IDEtMXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJyYWRpby1idXR0b24tY2hlY2tlZFwiPjxwYXRoIGQ9XCJNMTIgN2MtMi43NiAwLTUgMi4yNC01IDVzMi4yNCA1IDUgNSA1LTIuMjQgNS01LTIuMjQtNS01LTV6bTAtNUM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MiAwLTgtMy41OC04LThzMy41OC04IDgtOCA4IDMuNTggOCA4LTMuNTggOC04IDh6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicmFkaW8tYnV0dG9uLXVuY2hlY2tlZFwiPjxwYXRoIGQ9XCJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MiAwLTgtMy41OC04LThzMy41OC04IDgtOCA4IDMuNTggOCA4LTMuNTggOC04IDh6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicmVjZWlwdFwiPjxwYXRoIGQ9XCJNMTggMTdINnYtMmgxMnYyem0wLTRINnYtMmgxMnYyem0wLTRINlY3aDEydjJ6TTMgMjJsMS41LTEuNUw2IDIybDEuNS0xLjVMOSAyMmwxLjUtMS41TDEyIDIybDEuNS0xLjVMMTUgMjJsMS41LTEuNUwxOCAyMmwxLjUtMS41TDIxIDIyVjJsLTEuNSAxLjVMMTggMmwtMS41IDEuNUwxNSAybC0xLjUgMS41TDEyIDJsLTEuNSAxLjVMOSAyIDcuNSAzLjUgNiAyIDQuNSAzLjUgMyAydjIwelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInJlY29yZC12b2ljZS1vdmVyXCI+PGNpcmNsZSBjeD1cIjlcIiBjeT1cIjlcIiByPVwiNFwiPjwvY2lyY2xlPjxwYXRoIGQ9XCJNOSAxNWMtMi42NyAwLTggMS4zNC04IDR2MmgxNnYtMmMwLTIuNjYtNS4zMy00LTgtNHptNy43Ni05LjY0bC0xLjY4IDEuNjljLjg0IDEuMTguODQgMi43MSAwIDMuODlsMS42OCAxLjY5YzIuMDItMi4wMiAyLjAyLTUuMDcgMC03LjI3ek0yMC4wNyAybC0xLjYzIDEuNjNjMi43NyAzLjAyIDIuNzcgNy41NiAwIDEwLjc0TDIwLjA3IDE2YzMuOS0zLjg5IDMuOTEtOS45NSAwLTE0elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInJlZGVlbVwiPjxwYXRoIGQ9XCJNMjAgNmgtMi4xOGMuMTEtLjMxLjE4LS42NS4xOC0xIDAtMS42Ni0xLjM0LTMtMy0zLTEuMDUgMC0xLjk2LjU0LTIuNSAxLjM1bC0uNS42Ny0uNS0uNjhDMTAuOTYgMi41NCAxMC4wNSAyIDkgMiA3LjM0IDIgNiAzLjM0IDYgNWMwIC4zNS4wNy42OS4xOCAxSDRjLTEuMTEgMC0xLjk5Ljg5LTEuOTkgMkwyIDE5YzAgMS4xMS44OSAyIDIgMmgxNmMxLjExIDAgMi0uODkgMi0yVjhjMC0xLjExLS44OS0yLTItMnptLTUtMmMuNTUgMCAxIC40NSAxIDFzLS40NSAxLTEgMS0xLS40NS0xLTEgLjQ1LTEgMS0xek05IDRjLjU1IDAgMSAuNDUgMSAxcy0uNDUgMS0xIDEtMS0uNDUtMS0xIC40NS0xIDEtMXptMTEgMTVINHYtMmgxNnYyem0wLTVINFY4aDUuMDhMNyAxMC44MyA4LjYyIDEyIDExIDguNzZsMS0xLjM2IDEgMS4zNkwxNS4zOCAxMiAxNyAxMC44MyAxNC45MiA4SDIwdjZ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicmVkb1wiPjxwYXRoIGQ9XCJNMTguNCAxMC42QzE2LjU1IDguOTkgMTQuMTUgOCAxMS41IDhjLTQuNjUgMC04LjU4IDMuMDMtOS45NiA3LjIyTDMuOSAxNmMxLjA1LTMuMTkgNC4wNS01LjUgNy42LTUuNSAxLjk1IDAgMy43My43MiA1LjEyIDEuODhMMTMgMTZoOVY3bC0zLjYgMy42elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInJlZnJlc2hcIj48cGF0aCBkPVwiTTE3LjY1IDYuMzVDMTYuMiA0LjkgMTQuMjEgNCAxMiA0Yy00LjQyIDAtNy45OSAzLjU4LTcuOTkgOHMzLjU3IDggNy45OSA4YzMuNzMgMCA2Ljg0LTIuNTUgNy43My02aC0yLjA4Yy0uODIgMi4zMy0zLjA0IDQtNS42NSA0LTMuMzEgMC02LTIuNjktNi02czIuNjktNiA2LTZjMS42NiAwIDMuMTQuNjkgNC4yMiAxLjc4TDEzIDExaDdWNGwtMi4zNSAyLjM1elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInJlbW92ZVwiPjxwYXRoIGQ9XCJNMTkgMTNINXYtMmgxNHYyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInJlbW92ZS1jaXJjbGVcIj48cGF0aCBkPVwiTTEyIDJDNi40OCAyIDIgNi40OCAyIDEyczQuNDggMTAgMTAgMTAgMTAtNC40OCAxMC0xMFMxNy41MiAyIDEyIDJ6bTUgMTFIN3YtMmgxMHYyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInJlbW92ZS1jaXJjbGUtb3V0bGluZVwiPjxwYXRoIGQ9XCJNNyAxMXYyaDEwdi0ySDd6bTUtOUM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnptMCAxOGMtNC40MSAwLTgtMy41OS04LThzMy41OS04IDgtOCA4IDMuNTkgOCA4LTMuNTkgOC04IDh6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicmVtb3ZlLXNob3BwaW5nLWNhcnRcIj48cGF0aCBkPVwiTTIyLjczIDIyLjczTDIuNzcgMi43NyAyIDJsLS43My0uNzNMMCAyLjU0bDQuMzkgNC4zOSAyLjIxIDQuNjYtMS4zNSAyLjQ1Yy0uMTYuMjgtLjI1LjYxLS4yNS45NiAwIDEuMS45IDIgMiAyaDcuNDZsMS4zOCAxLjM4Yy0uNS4zNi0uODMuOTUtLjgzIDEuNjIgMCAxLjEuODkgMiAxLjk5IDIgLjY3IDAgMS4yNi0uMzMgMS42Mi0uODRMMjEuNDYgMjRsMS4yNy0xLjI3ek03LjQyIDE1Yy0uMTQgMC0uMjUtLjExLS4yNS0uMjVsLjAzLS4xMi45LTEuNjNoMi4zNmwyIDJINy40MnptOC4xMy0yYy43NSAwIDEuNDEtLjQxIDEuNzUtMS4wM2wzLjU4LTYuNDljLjA4LS4xNC4xMi0uMzEuMTItLjQ4IDAtLjU1LS40NS0xLTEtMUg2LjU0bDkuMDEgOXpNNyAxOGMtMS4xIDAtMS45OS45LTEuOTkgMlM1LjkgMjIgNyAyMnMyLS45IDItMi0uOS0yLTItMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJyZW9yZGVyXCI+PHBhdGggZD1cIk0zIDE1aDE4di0ySDN2MnptMCA0aDE4di0ySDN2MnptMC04aDE4VjlIM3Yyem0wLTZ2MmgxOFY1SDN6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicmVwbHlcIj48cGF0aCBkPVwiTTEwIDlWNWwtNyA3IDcgN3YtNC4xYzUgMCA4LjUgMS42IDExIDUuMS0xLTUtNC0xMC0xMS0xMXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJyZXBseS1hbGxcIj48cGF0aCBkPVwiTTcgOFY1bC03IDcgNyA3di0zbC00LTQgNC00em02IDFWNWwtNyA3IDcgN3YtNC4xYzUgMCA4LjUgMS42IDExIDUuMS0xLTUtNC0xMC0xMS0xMXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJyZXBvcnRcIj48cGF0aCBkPVwiTTE1LjczIDNIOC4yN0wzIDguMjd2Ny40Nkw4LjI3IDIxaDcuNDZMMjEgMTUuNzNWOC4yN0wxNS43MyAzek0xMiAxNy4zYy0uNzIgMC0xLjMtLjU4LTEuMy0xLjMgMC0uNzIuNTgtMS4zIDEuMy0xLjMuNzIgMCAxLjMuNTggMS4zIDEuMyAwIC43Mi0uNTggMS4zLTEuMyAxLjN6bTEtNC4zaC0yVjdoMnY2elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInJlcG9ydC1wcm9ibGVtXCI+PHBhdGggZD1cIk0xIDIxaDIyTDEyIDIgMSAyMXptMTItM2gtMnYtMmgydjJ6bTAtNGgtMnYtNGgydjR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicmVzdG9yZVwiPjxwYXRoIGQ9XCJNMTMgM2MtNC45NyAwLTkgNC4wMy05IDlIMWwzLjg5IDMuODkuMDcuMTRMOSAxMkg2YzAtMy44NyAzLjEzLTcgNy03czcgMy4xMyA3IDctMy4xMyA3LTcgN2MtMS45MyAwLTMuNjgtLjc5LTQuOTQtMi4wNmwtMS40MiAxLjQyQzguMjcgMTkuOTkgMTAuNTEgMjEgMTMgMjFjNC45NyAwIDktNC4wMyA5LTlzLTQuMDMtOS05LTl6bS0xIDV2NWw0LjI4IDIuNTQuNzItMS4yMS0zLjUtMi4wOFY4SDEyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInJlc3RvcmUtcGFnZVwiPjxwYXRoIGQ9XCJNMTQgMkg2Yy0xLjEgMC0xLjk5LjktMS45OSAyTDQgMjBjMCAxLjEuODkgMiAxLjk5IDJIMThjMS4xIDAgMi0uOSAyLTJWOGwtNi02em0tMiAxNmMtMi4wNSAwLTMuODEtMS4yNC00LjU4LTNoMS43MWMuNjMuOSAxLjY4IDEuNSAyLjg3IDEuNSAxLjkzIDAgMy41LTEuNTcgMy41LTMuNVMxMy45MyA5LjUgMTIgOS41Yy0xLjM1IDAtMi41Mi43OC0zLjEgMS45bDEuNiAxLjZoLTRWOWwxLjMgMS4zQzguNjkgOC45MiAxMC4yMyA4IDEyIDhjMi43NiAwIDUgMi4yNCA1IDVzLTIuMjQgNS01IDV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicm9vbVwiPjxwYXRoIGQ9XCJNMTIgMkM4LjEzIDIgNSA1LjEzIDUgOWMwIDUuMjUgNyAxMyA3IDEzczctNy43NSA3LTEzYzAtMy44Ny0zLjEzLTctNy03em0wIDkuNWMtMS4zOCAwLTIuNS0xLjEyLTIuNS0yLjVzMS4xMi0yLjUgMi41LTIuNSAyLjUgMS4xMiAyLjUgMi41LTEuMTIgMi41LTIuNSAyLjV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwicm91bmRlZC1jb3JuZXJcIj48cGF0aCBkPVwiTTE5IDE5aDJ2MmgtMnYtMnptMC0yaDJ2LTJoLTJ2MnpNMyAxM2gydi0ySDN2MnptMCA0aDJ2LTJIM3Yyem0wLThoMlY3SDN2MnptMC00aDJWM0gzdjJ6bTQgMGgyVjNIN3Yyem04IDE2aDJ2LTJoLTJ2MnptLTQgMGgydi0yaC0ydjJ6bTQgMGgydi0yaC0ydjJ6bS04IDBoMnYtMkg3djJ6bS00IDBoMnYtMkgzdjJ6TTIxIDhjMC0yLjc2LTIuMjQtNS01LTVoLTV2Mmg1YzEuNjUgMCAzIDEuMzUgMyAzdjVoMlY4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInJvd2luZ1wiPjxwYXRoIGQ9XCJNOC41IDE0LjVMNCAxOWwxLjUgMS41TDkgMTdoMmwtMi41LTIuNXpNMTUgMWMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6bTYgMjAuMDFMMTggMjRsLTIuOTktMy4wMVYxOS41bC03LjEtNy4wOWMtLjMxLjA1LS42MS4wNy0uOTEuMDd2LTIuMTZjMS42Ni4wMyAzLjYxLS44NyA0LjY3LTIuMDRsMS40LTEuNTVjLjE5LS4yMS40My0uMzguNjktLjUuMjktLjE0LjYyLS4yMy45Ni0uMjNoLjAzQzE1Ljk5IDYuMDEgMTcgNy4wMiAxNyA4LjI2djUuNzVjMCAuODQtLjM1IDEuNjEtLjkyIDIuMTZsLTMuNTgtMy41OHYtMi4yN2MtLjYzLjUyLTEuNDMgMS4wMi0yLjI5IDEuMzlMMTYuNSAxOEgxOGwzIDMuMDF6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic2F2ZVwiPjxwYXRoIGQ9XCJNMTcgM0g1Yy0xLjExIDAtMiAuOS0yIDJ2MTRjMCAxLjEuODkgMiAyIDJoMTRjMS4xIDAgMi0uOSAyLTJWN2wtNC00em0tNSAxNmMtMS42NiAwLTMtMS4zNC0zLTNzMS4zNC0zIDMtMyAzIDEuMzQgMyAzLTEuMzQgMy0zIDN6bTMtMTBINVY1aDEwdjR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic2NoZWR1bGVcIj48cGF0aCBkPVwiTTExLjk5IDJDNi40NyAyIDIgNi40OCAyIDEyczQuNDcgMTAgOS45OSAxMEMxNy41MiAyMiAyMiAxNy41MiAyMiAxMlMxNy41MiAyIDExLjk5IDJ6TTEyIDIwYy00LjQyIDAtOC0zLjU4LTgtOHMzLjU4LTggOC04IDggMy41OCA4IDgtMy41OCA4LTggOHptLjUtMTNIMTF2Nmw1LjI1IDMuMTUuNzUtMS4yMy00LjUtMi42N3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzZWFyY2hcIj48cGF0aCBkPVwiTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic2VsZWN0LWFsbFwiPjxwYXRoIGQ9XCJNMyA1aDJWM2MtMS4xIDAtMiAuOS0yIDJ6bTAgOGgydi0ySDN2MnptNCA4aDJ2LTJIN3Yyek0zIDloMlY3SDN2MnptMTAtNmgtMnYyaDJWM3ptNiAwdjJoMmMwLTEuMS0uOS0yLTItMnpNNSAyMXYtMkgzYzAgMS4xLjkgMiAyIDJ6bS0yLTRoMnYtMkgzdjJ6TTkgM0g3djJoMlYzem0yIDE4aDJ2LTJoLTJ2MnptOC04aDJ2LTJoLTJ2MnptMCA4YzEuMSAwIDItLjkgMi0yaC0ydjJ6bTAtMTJoMlY3aC0ydjJ6bTAgOGgydi0yaC0ydjJ6bS00IDRoMnYtMmgtMnYyem0wLTE2aDJWM2gtMnYyek03IDE3aDEwVjdIN3YxMHptMi04aDZ2Nkg5Vjl6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic2VuZFwiPjxwYXRoIGQ9XCJNMi4wMSAyMUwyMyAxMiAyLjAxIDMgMiAxMGwxNSAyLTE1IDJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic2V0dGluZ3NcIj48cGF0aCBkPVwiTTE5LjQzIDEyLjk4Yy4wNC0uMzIuMDctLjY0LjA3LS45OHMtLjAzLS42Ni0uMDctLjk4bDIuMTEtMS42NWMuMTktLjE1LjI0LS40Mi4xMi0uNjRsLTItMy40NmMtLjEyLS4yMi0uMzktLjMtLjYxLS4yMmwtMi40OSAxYy0uNTItLjQtMS4wOC0uNzMtMS42OS0uOThsLS4zOC0yLjY1QzE0LjQ2IDIuMTggMTQuMjUgMiAxNCAyaC00Yy0uMjUgMC0uNDYuMTgtLjQ5LjQybC0uMzggMi42NWMtLjYxLjI1LTEuMTcuNTktMS42OS45OGwtMi40OS0xYy0uMjMtLjA5LS40OSAwLS42MS4yMmwtMiAzLjQ2Yy0uMTMuMjItLjA3LjQ5LjEyLjY0bDIuMTEgMS42NWMtLjA0LjMyLS4wNy42NS0uMDcuOThzLjAzLjY2LjA3Ljk4bC0yLjExIDEuNjVjLS4xOS4xNS0uMjQuNDItLjEyLjY0bDIgMy40NmMuMTIuMjIuMzkuMy42MS4yMmwyLjQ5LTFjLjUyLjQgMS4wOC43MyAxLjY5Ljk4bC4zOCAyLjY1Yy4wMy4yNC4yNC40Mi40OS40Mmg0Yy4yNSAwIC40Ni0uMTguNDktLjQybC4zOC0yLjY1Yy42MS0uMjUgMS4xNy0uNTkgMS42OS0uOThsMi40OSAxYy4yMy4wOS40OSAwIC42MS0uMjJsMi0zLjQ2Yy4xMi0uMjIuMDctLjQ5LS4xMi0uNjRsLTIuMTEtMS42NXpNMTIgMTUuNWMtMS45MyAwLTMuNS0xLjU3LTMuNS0zLjVzMS41Ny0zLjUgMy41LTMuNSAzLjUgMS41NyAzLjUgMy41LTEuNTcgMy41LTMuNSAzLjV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic2V0dGluZ3MtYXBwbGljYXRpb25zXCI+PHBhdGggZD1cIk0xMiAxMGMtMS4xIDAtMiAuOS0yIDJzLjkgMiAyIDIgMi0uOSAyLTItLjktMi0yLTJ6bTctN0g1Yy0xLjExIDAtMiAuOS0yIDJ2MTRjMCAxLjEuODkgMiAyIDJoMTRjMS4xMSAwIDItLjkgMi0yVjVjMC0xLjEtLjg5LTItMi0yem0tMS43NSA5YzAgLjIzLS4wMi40Ni0uMDUuNjhsMS40OCAxLjE2Yy4xMy4xMS4xNy4zLjA4LjQ1bC0xLjQgMi40MmMtLjA5LjE1LS4yNy4yMS0uNDMuMTVsLTEuNzQtLjdjLS4zNi4yOC0uNzYuNTEtMS4xOC42OWwtLjI2IDEuODVjLS4wMy4xNy0uMTguMy0uMzUuM2gtMi44Yy0uMTcgMC0uMzItLjEzLS4zNS0uMjlsLS4yNi0xLjg1Yy0uNDMtLjE4LS44Mi0uNDEtMS4xOC0uNjlsLTEuNzQuN2MtLjE2LjA2LS4zNCAwLS40My0uMTVsLTEuNC0yLjQyYy0uMDktLjE1LS4wNS0uMzQuMDgtLjQ1bDEuNDgtMS4xNmMtLjAzLS4yMy0uMDUtLjQ2LS4wNS0uNjkgMC0uMjMuMDItLjQ2LjA1LS42OGwtMS40OC0xLjE2Yy0uMTMtLjExLS4xNy0uMy0uMDgtLjQ1bDEuNC0yLjQyYy4wOS0uMTUuMjctLjIxLjQzLS4xNWwxLjc0LjdjLjM2LS4yOC43Ni0uNTEgMS4xOC0uNjlsLjI2LTEuODVjLjAzLS4xNy4xOC0uMy4zNS0uM2gyLjhjLjE3IDAgLjMyLjEzLjM1LjI5bC4yNiAxLjg1Yy40My4xOC44Mi40MSAxLjE4LjY5bDEuNzQtLjdjLjE2LS4wNi4zNCAwIC40My4xNWwxLjQgMi40MmMuMDkuMTUuMDUuMzQtLjA4LjQ1bC0xLjQ4IDEuMTZjLjAzLjIzLjA1LjQ2LjA1LjY5elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInNldHRpbmdzLWJhY2t1cC1yZXN0b3JlXCI+PHBhdGggZD1cIk0xNCAxMmMwLTEuMS0uOS0yLTItMnMtMiAuOS0yIDIgLjkgMiAyIDIgMi0uOSAyLTJ6bS0yLTljLTQuOTcgMC05IDQuMDMtOSA5SDBsNCA0IDQtNEg1YzAtMy44NyAzLjEzLTcgNy03czcgMy4xMyA3IDctMy4xMyA3LTcgN2MtMS41MSAwLTIuOTEtLjQ5LTQuMDYtMS4zbC0xLjQyIDEuNDRDOC4wNCAyMC4zIDkuOTQgMjEgMTIgMjFjNC45NyAwIDktNC4wMyA5LTlzLTQuMDMtOS05LTl6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic2V0dGluZ3MtYmx1ZXRvb3RoXCI+PHBhdGggZD1cIk0xMSAyNGgydi0yaC0ydjJ6bS00IDBoMnYtMkg3djJ6bTggMGgydi0yaC0ydjJ6bTIuNzEtMTguMjlMMTIgMGgtMXY3LjU5TDYuNDEgMyA1IDQuNDEgMTAuNTkgMTAgNSAxNS41OSA2LjQxIDE3IDExIDEyLjQxVjIwaDFsNS43MS01LjcxLTQuMy00LjI5IDQuMy00LjI5ek0xMyAzLjgzbDEuODggMS44OEwxMyA3LjU5VjMuODN6bTEuODggMTAuNDZMMTMgMTYuMTd2LTMuNzZsMS44OCAxLjg4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInNldHRpbmdzLWJyaWdodG5lc3NcIj48cGF0aCBkPVwiTTIxIDNIM2MtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxOGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2LjAxSDNWNC45OWgxOHYxNC4wMnpNOCAxNmgyLjVsMS41IDEuNSAxLjUtMS41SDE2di0yLjVsMS41LTEuNS0xLjUtMS41VjhoLTIuNUwxMiA2LjUgMTAuNSA4SDh2Mi41TDYuNSAxMiA4IDEzLjVWMTZ6bTQtN2MxLjY2IDAgMyAxLjM0IDMgM3MtMS4zNCAzLTMgM1Y5elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInNldHRpbmdzLWNlbGxcIj48cGF0aCBkPVwiTTcgMjRoMnYtMkg3djJ6bTQgMGgydi0yaC0ydjJ6bTQgMGgydi0yaC0ydjJ6TTE2IC4wMUw4IDBDNi45IDAgNiAuOSA2IDJ2MTZjMCAxLjEuOSAyIDIgMmg4YzEuMSAwIDItLjkgMi0yVjJjMC0xLjEtLjktMS45OS0yLTEuOTl6TTE2IDE2SDhWNGg4djEyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInNldHRpbmdzLWV0aGVybmV0XCI+PHBhdGggZD1cIk03Ljc3IDYuNzZMNi4yMyA1LjQ4LjgyIDEybDUuNDEgNi41MiAxLjU0LTEuMjhMMy40MiAxMmw0LjM1LTUuMjR6TTcgMTNoMnYtMkg3djJ6bTEwLTJoLTJ2Mmgydi0yem0tNiAyaDJ2LTJoLTJ2MnptNi43Ny03LjUybC0xLjU0IDEuMjhMMjAuNTggMTJsLTQuMzUgNS4yNCAxLjU0IDEuMjhMMjMuMTggMTJsLTUuNDEtNi41MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzZXR0aW5ncy1pbnB1dC1hbnRlbm5hXCI+PHBhdGggZD1cIk0xMiA1Yy0zLjg3IDAtNyAzLjEzLTcgN2gyYzAtMi43NiAyLjI0LTUgNS01czUgMi4yNCA1IDVoMmMwLTMuODctMy4xMy03LTctN3ptMSA5LjI5Yy44OC0uMzkgMS41LTEuMjYgMS41LTIuMjkgMC0xLjM4LTEuMTItMi41LTIuNS0yLjVTOS41IDEwLjYyIDkuNSAxMmMwIDEuMDIuNjIgMS45IDEuNSAyLjI5djMuM0w3LjU5IDIxIDkgMjIuNDFsMy0zIDMgM0wxNi40MSAyMSAxMyAxNy41OXYtMy4zek0xMiAxQzUuOTMgMSAxIDUuOTMgMSAxMmgyYzAtNC45NyA0LjAzLTkgOS05czkgNC4wMyA5IDloMmMwLTYuMDctNC45My0xMS0xMS0xMXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzZXR0aW5ncy1pbnB1dC1jb21wb25lbnRcIj48cGF0aCBkPVwiTTUgMmMwLS41NS0uNDUtMS0xLTFzLTEgLjQ1LTEgMXY0SDF2Nmg2VjZINVYyem00IDE0YzAgMS4zLjg0IDIuNCAyIDIuODJWMjNoMnYtNC4xOGMxLjE2LS40MSAyLTEuNTEgMi0yLjgydi0ySDl2MnptLTggMGMwIDEuMy44NCAyLjQgMiAyLjgyVjIzaDJ2LTQuMThDNi4xNiAxOC40IDcgMTcuMyA3IDE2di0ySDF2MnpNMjEgNlYyYzAtLjU1LS40NS0xLTEtMXMtMSAuNDUtMSAxdjRoLTJ2Nmg2VjZoLTJ6bS04LTRjMC0uNTUtLjQ1LTEtMS0xcy0xIC40NS0xIDF2NEg5djZoNlY2aC0yVjJ6bTQgMTRjMCAxLjMuODQgMi40IDIgMi44MlYyM2gydi00LjE4YzEuMTYtLjQxIDItMS41MSAyLTIuODJ2LTJoLTZ2MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzZXR0aW5ncy1pbnB1dC1jb21wb3NpdGVcIj48cGF0aCBkPVwiTTUgMmMwLS41NS0uNDUtMS0xLTFzLTEgLjQ1LTEgMXY0SDF2Nmg2VjZINVYyem00IDE0YzAgMS4zLjg0IDIuNCAyIDIuODJWMjNoMnYtNC4xOGMxLjE2LS40MSAyLTEuNTEgMi0yLjgydi0ySDl2MnptLTggMGMwIDEuMy44NCAyLjQgMiAyLjgyVjIzaDJ2LTQuMThDNi4xNiAxOC40IDcgMTcuMyA3IDE2di0ySDF2MnpNMjEgNlYyYzAtLjU1LS40NS0xLTEtMXMtMSAuNDUtMSAxdjRoLTJ2Nmg2VjZoLTJ6bS04LTRjMC0uNTUtLjQ1LTEtMS0xcy0xIC40NS0xIDF2NEg5djZoNlY2aC0yVjJ6bTQgMTRjMCAxLjMuODQgMi40IDIgMi44MlYyM2gydi00LjE4YzEuMTYtLjQxIDItMS41MSAyLTIuODJ2LTJoLTZ2MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzZXR0aW5ncy1pbnB1dC1oZG1pXCI+PHBhdGggZD1cIk0xOCA3VjRjMC0xLjEtLjktMi0yLTJIOGMtMS4xIDAtMiAuOS0yIDJ2M0g1djZsMyA2djNoOHYtM2wzLTZWN2gtMXpNOCA0aDh2M2gtMlY1aC0xdjJoLTJWNWgtMXYySDhWNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzZXR0aW5ncy1pbnB1dC1zdmlkZW9cIj48cGF0aCBkPVwiTTggMTEuNWMwLS44My0uNjctMS41LTEuNS0xLjVTNSAxMC42NyA1IDExLjUgNS42NyAxMyA2LjUgMTMgOCAxMi4zMyA4IDExLjV6bTctNWMwLS44My0uNjctMS41LTEuNS0xLjVoLTNDOS42NyA1IDkgNS42NyA5IDYuNVM5LjY3IDggMTAuNSA4aDNjLjgzIDAgMS41LS42NyAxLjUtMS41ek04LjUgMTVjLS44MyAwLTEuNS42Ny0xLjUgMS41UzcuNjcgMTggOC41IDE4czEuNS0uNjcgMS41LTEuNVM5LjMzIDE1IDguNSAxNXpNMTIgMUM1LjkzIDEgMSA1LjkzIDEgMTJzNC45MyAxMSAxMSAxMSAxMS00LjkzIDExLTExUzE4LjA3IDEgMTIgMXptMCAyMGMtNC45NiAwLTktNC4wNC05LTlzNC4wNC05IDktOSA5IDQuMDQgOSA5LTQuMDQgOS05IDl6bTUuNS0xMWMtLjgzIDAtMS41LjY3LTEuNSAxLjVzLjY3IDEuNSAxLjUgMS41IDEuNS0uNjcgMS41LTEuNS0uNjctMS41LTEuNS0xLjV6bS0yIDVjLS44MyAwLTEuNS42Ny0xLjUgMS41cy42NyAxLjUgMS41IDEuNSAxLjUtLjY3IDEuNS0xLjUtLjY3LTEuNS0xLjUtMS41elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInNldHRpbmdzLW92ZXJzY2FuXCI+PHBhdGggZD1cIk0xMi4wMSA1LjVMMTAgOGg0bC0xLjk5LTIuNXpNMTggMTB2NGwyLjUtMS45OUwxOCAxMHpNNiAxMGwtMi41IDIuMDFMNiAxNHYtNHptOCA2aC00bDIuMDEgMi41TDE0IDE2em03LTEzSDNjLTEuMSAwLTIgLjktMiAydjE0YzAgMS4xLjkgMiAyIDJoMThjMS4xIDAgMi0uOSAyLTJWNWMwLTEuMS0uOS0yLTItMnptMCAxNi4wMUgzVjQuOTloMTh2MTQuMDJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic2V0dGluZ3MtcGhvbmVcIj48cGF0aCBkPVwiTTEzIDloLTJ2MmgyVjl6bTQgMGgtMnYyaDJWOXptMyA2LjVjLTEuMjUgMC0yLjQ1LS4yLTMuNTctLjU3LS4zNS0uMTEtLjc0LS4wMy0xLjAyLjI0bC0yLjIgMi4yYy0yLjgzLTEuNDQtNS4xNS0zLjc1LTYuNTktNi41OGwyLjItMi4yMWMuMjgtLjI3LjM2LS42Ni4yNS0xLjAxQzguNyA2LjQ1IDguNSA1LjI1IDguNSA0YzAtLjU1LS40NS0xLTEtMUg0Yy0uNTUgMC0xIC40NS0xIDEgMCA5LjM5IDcuNjEgMTcgMTcgMTcgLjU1IDAgMS0uNDUgMS0xdi0zLjVjMC0uNTUtLjQ1LTEtMS0xek0xOSA5djJoMlY5aC0yelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInNldHRpbmdzLXBvd2VyXCI+PHBhdGggZD1cIk03IDI0aDJ2LTJIN3Yyem00IDBoMnYtMmgtMnYyem0yLTIyaC0ydjEwaDJWMnptMy41NiAyLjQ0bC0xLjQ1IDEuNDVDMTYuODQgNi45NCAxOCA4LjgzIDE4IDExYzAgMy4zMS0yLjY5IDYtNiA2cy02LTIuNjktNi02YzAtMi4xNyAxLjE2LTQuMDYgMi44OC01LjEyTDcuNDQgNC40NEM1LjM2IDUuODggNCA4LjI4IDQgMTFjMCA0LjQyIDMuNTggOCA4IDhzOC0zLjU4IDgtOGMwLTIuNzItMS4zNi01LjEyLTMuNDQtNi41NnpNMTUgMjRoMnYtMmgtMnYyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInNldHRpbmdzLXJlbW90ZVwiPjxwYXRoIGQ9XCJNMTUgOUg5Yy0uNTUgMC0xIC40NS0xIDF2MTJjMCAuNTUuNDUgMSAxIDFoNmMuNTUgMCAxLS40NSAxLTFWMTBjMC0uNTUtLjQ1LTEtMS0xem0tMyA2Yy0xLjEgMC0yLS45LTItMnMuOS0yIDItMiAyIC45IDIgMi0uOSAyLTIgMnpNNy4wNSA2LjA1bDEuNDEgMS40MUM5LjM3IDYuNTYgMTAuNjIgNiAxMiA2czIuNjMuNTYgMy41NCAxLjQ2bDEuNDEtMS40MUMxNS42OCA0Ljc4IDEzLjkzIDQgMTIgNHMtMy42OC43OC00Ljk1IDIuMDV6TTEyIDBDOC45NiAwIDYuMjEgMS4yMyA0LjIyIDMuMjJsMS40MSAxLjQxQzcuMjYgMy4wMSA5LjUxIDIgMTIgMnM0Ljc0IDEuMDEgNi4zNiAyLjY0bDEuNDEtMS40MUMxNy43OSAxLjIzIDE1LjA0IDAgMTIgMHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzZXR0aW5ncy12b2ljZVwiPjxwYXRoIGQ9XCJNNyAyNGgydi0ySDd2MnptNS0xMWMxLjY2IDAgMi45OS0xLjM0IDIuOTktM0wxNSA0YzAtMS42Ni0xLjM0LTMtMy0zUzkgMi4zNCA5IDR2NmMwIDEuNjYgMS4zNCAzIDMgM3ptLTEgMTFoMnYtMmgtMnYyem00IDBoMnYtMmgtMnYyem00LTE0aC0xLjdjMCAzLTIuNTQgNS4xLTUuMyA1LjFTNi43IDEzIDYuNyAxMEg1YzAgMy40MSAyLjcyIDYuMjMgNiA2LjcyVjIwaDJ2LTMuMjhjMy4yOC0uNDkgNi0zLjMxIDYtNi43MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzaG9wXCI+PHBhdGggZD1cIk0xNiA2VjRjMC0xLjExLS44OS0yLTItMmgtNGMtMS4xMSAwLTIgLjg5LTIgMnYySDJ2MTNjMCAxLjExLjg5IDIgMiAyaDE2YzEuMTEgMCAyLS44OSAyLTJWNmgtNnptLTYtMmg0djJoLTRWNHpNOSAxOFY5bDcuNSA0TDkgMTh6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic2hvcC10d29cIj48cGF0aCBkPVwiTTMgOUgxdjExYzAgMS4xMS44OSAyIDIgMmgxNGMxLjExIDAgMi0uODkgMi0ySDNWOXptMTUtNFYzYzAtMS4xMS0uODktMi0yLTJoLTRjLTEuMTEgMC0yIC44OS0yIDJ2Mkg1djExYzAgMS4xMS44OSAyIDIgMmgxNGMxLjExIDAgMi0uODkgMi0yVjVoLTV6bS02LTJoNHYyaC00VjN6bTAgMTJWOGw1LjUgMy01LjUgNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzaG9wcGluZy1iYXNrZXRcIj48cGF0aCBkPVwiTTE3LjIxIDlsLTQuMzgtNi41NmMtLjE5LS4yOC0uNTEtLjQyLS44My0uNDItLjMyIDAtLjY0LjE0LS44My40M0w2Ljc5IDlIMmMtLjU1IDAtMSAuNDUtMSAxIDAgLjA5LjAxLjE4LjA0LjI3bDIuNTQgOS4yN2MuMjMuODQgMSAxLjQ2IDEuOTIgMS40NmgxM2MuOTIgMCAxLjY5LS42MiAxLjkzLTEuNDZsMi41NC05LjI3TDIzIDEwYzAtLjU1LS40NS0xLTEtMWgtNC43OXpNOSA5bDMtNC40TDE1IDlIOXptMyA4Yy0xLjEgMC0yLS45LTItMnMuOS0yIDItMiAyIC45IDIgMi0uOSAyLTIgMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzaG9wcGluZy1jYXJ0XCI+PHBhdGggZD1cIk03IDE4Yy0xLjEgMC0xLjk5LjktMS45OSAyUzUuOSAyMiA3IDIyczItLjkgMi0yLS45LTItMi0yek0xIDJ2MmgybDMuNiA3LjU5LTEuMzUgMi40NWMtLjE2LjI4LS4yNS42MS0uMjUuOTYgMCAxLjEuOSAyIDIgMmgxMnYtMkg3LjQyYy0uMTQgMC0uMjUtLjExLS4yNS0uMjVsLjAzLS4xMi45LTEuNjNoNy40NWMuNzUgMCAxLjQxLS40MSAxLjc1LTEuMDNsMy41OC02LjQ5Yy4wOC0uMTQuMTItLjMxLjEyLS40OCAwLS41NS0uNDUtMS0xLTFINS4yMWwtLjk0LTJIMXptMTYgMTZjLTEuMSAwLTEuOTkuOS0xLjk5IDJzLjg5IDIgMS45OSAyIDItLjkgMi0yLS45LTItMi0yelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInNvcnRcIj48cGF0aCBkPVwiTTMgMThoNnYtMkgzdjJ6TTMgNnYyaDE4VjZIM3ptMCA3aDEydi0ySDN2MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzcGVha2VyLW5vdGVzXCI+PHBhdGggZD1cIk0yMCAySDRjLTEuMSAwLTEuOTkuOS0xLjk5IDJMMiAyMmw0LTRoMTRjMS4xIDAgMi0uOSAyLTJWNGMwLTEuMS0uOS0yLTItMnpNOCAxNEg2di0yaDJ2MnptMC0zSDZWOWgydjJ6bTAtM0g2VjZoMnYyem03IDZoLTV2LTJoNXYyem0zLTNoLThWOWg4djJ6bTAtM2gtOFY2aDh2MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzcGVha2VyLW5vdGVzLW9mZlwiPjxwYXRoIGQ9XCJNMTAuNTQgMTFsLS41NC0uNTRMNy41NCA4IDYgNi40NiAyLjM4IDIuODQgMS4yNyAxLjczIDAgM2wyLjAxIDIuMDFMMiAyMmw0LTRoOWw1LjczIDUuNzNMMjIgMjIuNDYgMTcuNTQgMThsLTctN3pNOCAxNEg2di0yaDJ2MnptLTItM1Y5bDIgMkg2em0xNC05SDQuMDhMMTAgNy45MlY2aDh2MmgtNy45MmwxIDFIMTh2MmgtNC45Mmw2Ljk5IDYuOTlDMjEuMTQgMTcuOTUgMjIgMTcuMDggMjIgMTZWNGMwLTEuMS0uOS0yLTItMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzcGVsbGNoZWNrXCI+PHBhdGggZD1cIk0xMi40NSAxNmgyLjA5TDkuNDMgM0g3LjU3TDIuNDYgMTZoMi4wOWwxLjEyLTNoNS42NGwxLjE0IDN6bS02LjAyLTVMOC41IDUuNDggMTAuNTcgMTFINi40M3ptMTUuMTYuNTlsLTguMDkgOC4wOUw5LjgzIDE2bC0xLjQxIDEuNDEgNS4wOSA1LjA5TDIzIDEzbC0xLjQxLTEuNDF6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic3RhclwiPjxwYXRoIGQ9XCJNMTIgMTcuMjdMMTguMTggMjFsLTEuNjQtNy4wM0wyMiA5LjI0bC03LjE5LS42MUwxMiAyIDkuMTkgOC42MyAyIDkuMjRsNS40NiA0LjczTDUuODIgMjF6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic3Rhci1ib3JkZXJcIj48cGF0aCBkPVwiTTIyIDkuMjRsLTcuMTktLjYyTDEyIDIgOS4xOSA4LjYzIDIgOS4yNGw1LjQ2IDQuNzNMNS44MiAyMSAxMiAxNy4yNyAxOC4xOCAyMWwtMS42My03LjAzTDIyIDkuMjR6TTEyIDE1LjRsLTMuNzYgMi4yNyAxLTQuMjgtMy4zMi0yLjg4IDQuMzgtLjM4TDEyIDYuMWwxLjcxIDQuMDQgNC4zOC4zOC0zLjMyIDIuODggMSA0LjI4TDEyIDE1LjR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic3Rhci1oYWxmXCI+PHBhdGggZD1cIk0yMiA5LjI0bC03LjE5LS42MkwxMiAyIDkuMTkgOC42MyAyIDkuMjRsNS40NiA0LjczTDUuODIgMjEgMTIgMTcuMjcgMTguMTggMjFsLTEuNjMtNy4wM0wyMiA5LjI0ek0xMiAxNS40VjYuMWwxLjcxIDQuMDQgNC4zOC4zOC0zLjMyIDIuODggMSA0LjI4TDEyIDE1LjR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic3RhcnNcIj48cGF0aCBkPVwiTTExLjk5IDJDNi40NyAyIDIgNi40OCAyIDEyczQuNDcgMTAgOS45OSAxMEMxNy41MiAyMiAyMiAxNy41MiAyMiAxMlMxNy41MiAyIDExLjk5IDJ6bTQuMjQgMTZMMTIgMTUuNDUgNy43NyAxOGwxLjEyLTQuODEtMy43My0zLjIzIDQuOTItLjQyTDEyIDVsMS45MiA0LjUzIDQuOTIuNDItMy43MyAzLjIzTDE2LjIzIDE4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInN0b3JlXCI+PHBhdGggZD1cIk0yMCA0SDR2MmgxNlY0em0xIDEwdi0ybC0xLTVINGwtMSA1djJoMXY2aDEwdi02aDR2Nmgydi02aDF6bS05IDRINnYtNGg2djR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic3ViZGlyZWN0b3J5LWFycm93LWxlZnRcIj48cGF0aCBkPVwiTTExIDlsMS40MiAxLjQyTDguODMgMTRIMThWNGgydjEySDguODNsMy41OSAzLjU4TDExIDIxbC02LTYgNi02elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInN1YmRpcmVjdG9yeS1hcnJvdy1yaWdodFwiPjxwYXRoIGQ9XCJNMTkgMTVsLTYgNi0xLjQyLTEuNDJMMTUuMTcgMTZINFY0aDJ2MTBoOS4xN2wtMy41OS0zLjU4TDEzIDlsNiA2elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInN1YmplY3RcIj48cGF0aCBkPVwiTTE0IDE3SDR2MmgxMHYtMnptNi04SDR2MmgxNlY5ek00IDE1aDE2di0ySDR2MnpNNCA1djJoMTZWNUg0elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInN1cGVydmlzb3ItYWNjb3VudFwiPjxwYXRoIGQ9XCJNMTYuNSAxMmMxLjM4IDAgMi40OS0xLjEyIDIuNDktMi41UzE3Ljg4IDcgMTYuNSA3QzE1LjEyIDcgMTQgOC4xMiAxNCA5LjVzMS4xMiAyLjUgMi41IDIuNXpNOSAxMWMxLjY2IDAgMi45OS0xLjM0IDIuOTktM1MxMC42NiA1IDkgNUM3LjM0IDUgNiA2LjM0IDYgOHMxLjM0IDMgMyAzem03LjUgM2MtMS44MyAwLTUuNS45Mi01LjUgMi43NVYxOWgxMXYtMi4yNWMwLTEuODMtMy42Ny0yLjc1LTUuNS0yLjc1ek05IDEzYy0yLjMzIDAtNyAxLjE3LTcgMy41VjE5aDd2LTIuMjVjMC0uODUuMzMtMi4zNCAyLjM3LTMuNDdDMTAuNSAxMy4xIDkuNjYgMTMgOSAxM3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzd2FwLWhvcml6XCI+PHBhdGggZD1cIk02Ljk5IDExTDMgMTVsMy45OSA0di0zSDE0di0ySDYuOTl2LTN6TTIxIDlsLTMuOTktNHYzSDEwdjJoNy4wMXYzTDIxIDl6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic3dhcC12ZXJ0XCI+PHBhdGggZD1cIk0xNiAxNy4wMVYxMGgtMnY3LjAxaC0zTDE1IDIxbDQtMy45OWgtM3pNOSAzTDUgNi45OWgzVjE0aDJWNi45OWgzTDkgM3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJzd2FwLXZlcnRpY2FsLWNpcmNsZVwiPjxwYXRoIGQ9XCJNMTIgMkM2LjQ4IDIgMiA2LjQ4IDIgMTJzNC40OCAxMCAxMCAxMCAxMC00LjQ4IDEwLTEwUzE3LjUyIDIgMTIgMnpNNi41IDlMMTAgNS41IDEzLjUgOUgxMXY0SDlWOUg2LjV6bTExIDZMMTQgMTguNSAxMC41IDE1SDEzdi00aDJ2NGgyLjV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwic3lzdGVtLXVwZGF0ZS1hbHRcIj48cGF0aCBkPVwiTTEyIDE2LjVsNC00aC0zdi05aC0ydjlIOGw0IDR6bTktMTNoLTZ2MS45OWg2djE0LjAzSDNWNS40OWg2VjMuNUgzYy0xLjEgMC0yIC45LTIgMnYxNGMwIDEuMS45IDIgMiAyaDE4YzEuMSAwIDItLjkgMi0ydi0xNGMwLTEuMS0uOS0yLTItMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ0YWJcIj48cGF0aCBkPVwiTTIxIDNIM2MtMS4xIDAtMiAuOS0yIDJ2MTRjMCAxLjEuOSAyIDIgMmgxOGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDNWNWgxMHY0aDh2MTB6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidGFiLXVuc2VsZWN0ZWRcIj48cGF0aCBkPVwiTTEgOWgyVjdIMXYyem0wIDRoMnYtMkgxdjJ6bTAtOGgyVjNjLTEuMSAwLTIgLjktMiAyem04IDE2aDJ2LTJIOXYyem0tOC00aDJ2LTJIMXYyem0yIDR2LTJIMWMwIDEuMS45IDIgMiAyek0yMSAzaC04djZoMTBWNWMwLTEuMS0uOS0yLTItMnptMCAxNGgydi0yaC0ydjJ6TTkgNWgyVjNIOXYyek01IDIxaDJ2LTJINXYyek01IDVoMlYzSDV2MnptMTYgMTZjMS4xIDAgMi0uOSAyLTJoLTJ2MnptMC04aDJ2LTJoLTJ2MnptLTggOGgydi0yaC0ydjJ6bTQgMGgydi0yaC0ydjJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidGV4dC1mb3JtYXRcIj48cGF0aCBkPVwiTTUgMTd2MmgxNHYtMkg1em00LjUtNC4yaDVsLjkgMi4yaDIuMUwxMi43NSA0aC0xLjVMNi41IDE1aDIuMWwuOS0yLjJ6TTEyIDUuOThMMTMuODcgMTFoLTMuNzRMMTIgNS45OHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ0aGVhdGVyc1wiPjxwYXRoIGQ9XCJNMTggM3YyaC0yVjNIOHYySDZWM0g0djE4aDJ2LTJoMnYyaDh2LTJoMnYyaDJWM2gtMnpNOCAxN0g2di0yaDJ2MnptMC00SDZ2LTJoMnYyem0wLTRINlY3aDJ2MnptMTAgOGgtMnYtMmgydjJ6bTAtNGgtMnYtMmgydjJ6bTAtNGgtMlY3aDJ2MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ0aHVtYi1kb3duXCI+PHBhdGggZD1cIk0xNSAzSDZjLS44MyAwLTEuNTQuNS0xLjg0IDEuMjJsLTMuMDIgNy4wNWMtLjA5LjIzLS4xNC40Ny0uMTQuNzN2MS45MWwuMDEuMDFMMSAxNGMwIDEuMS45IDIgMiAyaDYuMzFsLS45NSA0LjU3LS4wMy4zMmMwIC40MS4xNy43OS40NCAxLjA2TDkuODMgMjNsNi41OS02LjU5Yy4zNi0uMzYuNTgtLjg2LjU4LTEuNDFWNWMwLTEuMS0uOS0yLTItMnptNCAwdjEyaDRWM2gtNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ0aHVtYi11cFwiPjxwYXRoIGQ9XCJNMSAyMWg0VjlIMXYxMnptMjItMTFjMC0xLjEtLjktMi0yLTJoLTYuMzFsLjk1LTQuNTcuMDMtLjMyYzAtLjQxLS4xNy0uNzktLjQ0LTEuMDZMMTQuMTcgMSA3LjU5IDcuNTlDNy4yMiA3Ljk1IDcgOC40NSA3IDl2MTBjMCAxLjEuOSAyIDIgMmg5Yy44MyAwIDEuNTQtLjUgMS44NC0xLjIybDMuMDItNy4wNWMuMDktLjIzLjE0LS40Ny4xNC0uNzN2LTEuOTFsLS4wMS0uMDFMMjMgMTB6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidGh1bWJzLXVwLWRvd25cIj48cGF0aCBkPVwiTTEyIDZjMC0uNTUtLjQ1LTEtMS0xSDUuODJsLjY2LTMuMTguMDItLjIzYzAtLjMxLS4xMy0uNTktLjMzLS44TDUuMzggMCAuNDQgNC45NEMuMTcgNS4yMSAwIDUuNTkgMCA2djYuNWMwIC44My42NyAxLjUgMS41IDEuNWg2Ljc1Yy42MiAwIDEuMTUtLjM4IDEuMzgtLjkxbDIuMjYtNS4yOWMuMDctLjE3LjExLS4zNi4xMS0uNTVWNnptMTAuNSA0aC02Ljc1Yy0uNjIgMC0xLjE1LjM4LTEuMzguOTFsLTIuMjYgNS4yOWMtLjA3LjE3LS4xMS4zNi0uMTEuNTVWMThjMCAuNTUuNDUgMSAxIDFoNS4xOGwtLjY2IDMuMTgtLjAyLjI0YzAgLjMxLjEzLjU5LjMzLjhsLjc5Ljc4IDQuOTQtNC45NGMuMjctLjI3LjQ0LS42NS40NC0xLjA2di02LjVjMC0uODMtLjY3LTEuNS0xLjUtMS41elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInRpbWVsaW5lXCI+PHBhdGggZD1cIk0yMyA4YzAgMS4xLS45IDItMiAyLS4xOCAwLS4zNS0uMDItLjUxLS4wN2wtMy41NiAzLjU1Yy4wNS4xNi4wNy4zNC4wNy41MiAwIDEuMS0uOSAyLTIgMnMtMi0uOS0yLTJjMC0uMTguMDItLjM2LjA3LS41MmwtMi41NS0yLjU1Yy0uMTYuMDUtLjM0LjA3LS41Mi4wN3MtLjM2LS4wMi0uNTItLjA3bC00LjU1IDQuNTZjLjA1LjE2LjA3LjMzLjA3LjUxIDAgMS4xLS45IDItMiAycy0yLS45LTItMiAuOS0yIDItMmMuMTggMCAuMzUuMDIuNTEuMDdsNC41Ni00LjU1QzguMDIgOS4zNiA4IDkuMTggOCA5YzAtMS4xLjktMiAyLTJzMiAuOSAyIDJjMCAuMTgtLjAyLjM2LS4wNy41MmwyLjU1IDIuNTVjLjE2LS4wNS4zNC0uMDcuNTItLjA3cy4zNi4wMi41Mi4wN2wzLjU1LTMuNTZDMTkuMDIgOC4zNSAxOSA4LjE4IDE5IDhjMC0xLjEuOS0yIDItMnMyIC45IDIgMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ0b2NcIj48cGF0aCBkPVwiTTMgOWgxNFY3SDN2MnptMCA0aDE0di0ySDN2MnptMCA0aDE0di0ySDN2MnptMTYgMGgydi0yaC0ydjJ6bTAtMTB2MmgyVjdoLTJ6bTAgNmgydi0yaC0ydjJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidG9kYXlcIj48cGF0aCBkPVwiTTE5IDNoLTFWMWgtMnYySDhWMUg2djJINWMtMS4xMSAwLTEuOTkuOS0xLjk5IDJMMyAxOWMwIDEuMS44OSAyIDIgMmgxNGMxLjEgMCAyLS45IDItMlY1YzAtMS4xLS45LTItMi0yem0wIDE2SDVWOGgxNHYxMXpNNyAxMGg1djVIN3pcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ0b2xsXCI+PHBhdGggZD1cIk0xNSA0Yy00LjQyIDAtOCAzLjU4LTggOHMzLjU4IDggOCA4IDgtMy41OCA4LTgtMy41OC04LTgtOHptMCAxNGMtMy4zMSAwLTYtMi42OS02LTZzMi42OS02IDYtNiA2IDIuNjkgNiA2LTIuNjkgNi02IDZ6TTMgMTJjMC0yLjYxIDEuNjctNC44MyA0LTUuNjVWNC4yNkMzLjU1IDUuMTUgMSA4LjI3IDEgMTJzMi41NSA2Ljg1IDYgNy43NHYtMi4wOWMtMi4zMy0uODItNC0zLjA0LTQtNS42NXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ0b3VjaC1hcHBcIj48cGF0aCBkPVwiTTkgMTEuMjRWNy41QzkgNi4xMiAxMC4xMiA1IDExLjUgNVMxNCA2LjEyIDE0IDcuNXYzLjc0YzEuMjEtLjgxIDItMi4xOCAyLTMuNzRDMTYgNS4wMSAxMy45OSAzIDExLjUgM1M3IDUuMDEgNyA3LjVjMCAxLjU2Ljc5IDIuOTMgMiAzLjc0em05Ljg0IDQuNjNsLTQuNTQtMi4yNmMtLjE3LS4wNy0uMzUtLjExLS41NC0uMTFIMTN2LTZjMC0uODMtLjY3LTEuNS0xLjUtMS41UzEwIDYuNjcgMTAgNy41djEwLjc0bC0zLjQzLS43MmMtLjA4LS4wMS0uMTUtLjAzLS4yNC0uMDMtLjMxIDAtLjU5LjEzLS43OS4zM2wtLjc5LjggNC45NCA0Ljk0Yy4yNy4yNy42NS40NCAxLjA2LjQ0aDYuNzljLjc1IDAgMS4zMy0uNTUgMS40NC0xLjI4bC43NS01LjI3Yy4wMS0uMDcuMDItLjE0LjAyLS4yIDAtLjYyLS4zOC0xLjE2LS45MS0xLjM4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInRyYWNrLWNoYW5nZXNcIj48cGF0aCBkPVwiTTE5LjA3IDQuOTNsLTEuNDEgMS40MUMxOS4xIDcuNzkgMjAgOS43OSAyMCAxMmMwIDQuNDItMy41OCA4LTggOHMtOC0zLjU4LTgtOGMwLTQuMDggMy4wNS03LjQ0IDctNy45M3YyLjAyQzguMTYgNi41NyA2IDkuMDMgNiAxMmMwIDMuMzEgMi42OSA2IDYgNnM2LTIuNjkgNi02YzAtMS42Ni0uNjctMy4xNi0xLjc2LTQuMjRsLTEuNDEgMS40MUMxNS41NSA5LjkgMTYgMTAuOSAxNiAxMmMwIDIuMjEtMS43OSA0LTQgNHMtNC0xLjc5LTQtNGMwLTEuODYgMS4yOC0zLjQxIDMtMy44NnYyLjE0Yy0uNi4zNS0xIC45OC0xIDEuNzIgMCAxLjEuOSAyIDIgMnMyLS45IDItMmMwLS43NC0uNC0xLjM4LTEtMS43MlYyaC0xQzYuNDggMiAyIDYuNDggMiAxMnM0LjQ4IDEwIDEwIDEwIDEwLTQuNDggMTAtMTBjMC0yLjc2LTEuMTItNS4yNi0yLjkzLTcuMDd6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidHJhbnNsYXRlXCI+PHBhdGggZD1cIk0xMi44NyAxNS4wN2wtMi41NC0yLjUxLjAzLS4wM2MxLjc0LTEuOTQgMi45OC00LjE3IDMuNzEtNi41M0gxN1Y0aC03VjJIOHYySDF2MS45OWgxMS4xN0MxMS41IDcuOTIgMTAuNDQgOS43NSA5IDExLjM1IDguMDcgMTAuMzIgNy4zIDkuMTkgNi42OSA4aC0yYy43MyAxLjYzIDEuNzMgMy4xNyAyLjk4IDQuNTZsLTUuMDkgNS4wMkw0IDE5bDUtNSAzLjExIDMuMTEuNzYtMi4wNHpNMTguNSAxMGgtMkwxMiAyMmgybDEuMTItM2g0Ljc1TDIxIDIyaDJsLTQuNS0xMnptLTIuNjIgN2wxLjYyLTQuMzNMMTkuMTIgMTdoLTMuMjR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidHJlbmRpbmctZG93blwiPjxwYXRoIGQ9XCJNMTYgMThsMi4yOS0yLjI5LTQuODgtNC44OC00IDRMMiA3LjQxIDMuNDEgNmw2IDYgNC00IDYuMyA2LjI5TDIyIDEydjZ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidHJlbmRpbmctZmxhdFwiPjxwYXRoIGQ9XCJNMjIgMTJsLTQtNHYzSDN2MmgxNXYzelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInRyZW5kaW5nLXVwXCI+PHBhdGggZD1cIk0xNiA2bDIuMjkgMi4yOS00Ljg4IDQuODgtNC00TDIgMTYuNTkgMy40MSAxOGw2LTYgNCA0IDYuMy02LjI5TDIyIDEyVjZ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidHVybmVkLWluXCI+PHBhdGggZD1cIk0xNyAzSDdjLTEuMSAwLTEuOTkuOS0xLjk5IDJMNSAyMWw3LTMgNyAzVjVjMC0xLjEtLjktMi0yLTJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidHVybmVkLWluLW5vdFwiPjxwYXRoIGQ9XCJNMTcgM0g3Yy0xLjEgMC0xLjk5LjktMS45OSAyTDUgMjFsNy0zIDcgM1Y1YzAtMS4xLS45LTItMi0yem0wIDE1bC01LTIuMThMNyAxOFY1aDEwdjEzelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInVuYXJjaGl2ZVwiPjxwYXRoIGQ9XCJNMjAuNTUgNS4yMmwtMS4zOS0xLjY4QzE4Ljg4IDMuMjEgMTguNDcgMyAxOCAzSDZjLS40NyAwLS44OC4yMS0xLjE1LjU1TDMuNDYgNS4yMkMzLjE3IDUuNTcgMyA2LjAxIDMgNi41VjE5YzAgMS4xLjg5IDIgMiAyaDE0YzEuMSAwIDItLjkgMi0yVjYuNWMwLS40OS0uMTctLjkzLS40NS0xLjI4ek0xMiA5LjVsNS41IDUuNUgxNHYyaC00di0ySDYuNUwxMiA5LjV6TTUuMTIgNWwuODItMWgxMmwuOTMgMUg1LjEyelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInVuZG9cIj48cGF0aCBkPVwiTTEyLjUgOGMtMi42NSAwLTUuMDUuOTktNi45IDIuNkwyIDd2OWg5bC0zLjYyLTMuNjJjMS4zOS0xLjE2IDMuMTYtMS44OCA1LjEyLTEuODggMy41NCAwIDYuNTUgMi4zMSA3LjYgNS41bDIuMzctLjc4QzIxLjA4IDExLjAzIDE3LjE1IDggMTIuNSA4elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInVuZm9sZC1sZXNzXCI+PHBhdGggZD1cIk03LjQxIDE4LjU5TDguODMgMjAgMTIgMTYuODMgMTUuMTcgMjBsMS40MS0xLjQxTDEyIDE0bC00LjU5IDQuNTl6bTkuMTgtMTMuMThMMTUuMTcgNCAxMiA3LjE3IDguODMgNCA3LjQxIDUuNDEgMTIgMTBsNC41OS00LjU5elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInVuZm9sZC1tb3JlXCI+PHBhdGggZD1cIk0xMiA1LjgzTDE1LjE3IDlsMS40MS0xLjQxTDEyIDMgNy40MSA3LjU5IDguODMgOSAxMiA1Ljgzem0wIDEyLjM0TDguODMgMTVsLTEuNDEgMS40MUwxMiAyMWw0LjU5LTQuNTlMMTUuMTcgMTUgMTIgMTguMTd6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidXBkYXRlXCI+PHBhdGggZD1cIk0yMSAxMC4xMmgtNi43OGwyLjc0LTIuODJjLTIuNzMtMi43LTcuMTUtMi44LTkuODgtLjEtMi43MyAyLjcxLTIuNzMgNy4wOCAwIDkuNzkgMi43MyAyLjcxIDcuMTUgMi43MSA5Ljg4IDBDMTguMzIgMTUuNjUgMTkgMTQuMDggMTkgMTIuMWgyYzAgMS45OC0uODggNC41NS0yLjY0IDYuMjktMy41MSAzLjQ4LTkuMjEgMy40OC0xMi43MiAwLTMuNS0zLjQ3LTMuNTMtOS4xMS0uMDItMTIuNTggMy41MS0zLjQ3IDkuMTQtMy40NyAxMi42NSAwTDIxIDN2Ny4xMnpNMTIuNSA4djQuMjVsMy41IDIuMDgtLjcyIDEuMjFMMTEgMTNWOGgxLjV6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidmVyaWZpZWQtdXNlclwiPjxwYXRoIGQ9XCJNMTIgMUwzIDV2NmMwIDUuNTUgMy44NCAxMC43NCA5IDEyIDUuMTYtMS4yNiA5LTYuNDUgOS0xMlY1bC05LTR6bS0yIDE2bC00LTQgMS40MS0xLjQxTDEwIDE0LjE3bDYuNTktNi41OUwxOCA5bC04IDh6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidmlldy1hZ2VuZGFcIj48cGF0aCBkPVwiTTIwIDEzSDNjLS41NSAwLTEgLjQ1LTEgMXY2YzAgLjU1LjQ1IDEgMSAxaDE3Yy41NSAwIDEtLjQ1IDEtMXYtNmMwLS41NS0uNDUtMS0xLTF6bTAtMTBIM2MtLjU1IDAtMSAuNDUtMSAxdjZjMCAuNTUuNDUgMSAxIDFoMTdjLjU1IDAgMS0uNDUgMS0xVjRjMC0uNTUtLjQ1LTEtMS0xelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInZpZXctYXJyYXlcIj48cGF0aCBkPVwiTTQgMThoM1Y1SDR2MTN6TTE4IDV2MTNoM1Y1aC0zek04IDE4aDlWNUg4djEzelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInZpZXctY2Fyb3VzZWxcIj48cGF0aCBkPVwiTTcgMTloMTBWNEg3djE1em0tNS0yaDRWNkgydjExek0xOCA2djExaDRWNmgtNHpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ2aWV3LWNvbHVtblwiPjxwYXRoIGQ9XCJNMTAgMThoNVY1aC01djEzem0tNiAwaDVWNUg0djEzek0xNiA1djEzaDVWNWgtNXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ2aWV3LWRheVwiPjxwYXRoIGQ9XCJNMiAyMWgxOXYtM0gydjN6TTIwIDhIM2MtLjU1IDAtMSAuNDUtMSAxdjZjMCAuNTUuNDUgMSAxIDFoMTdjLjU1IDAgMS0uNDUgMS0xVjljMC0uNTUtLjQ1LTEtMS0xek0yIDN2M2gxOVYzSDJ6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidmlldy1oZWFkbGluZVwiPjxwYXRoIGQ9XCJNNCAxNWgxNnYtMkg0djJ6bTAgNGgxNnYtMkg0djJ6bTAtOGgxNlY5SDR2MnptMC02djJoMTZWNUg0elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInZpZXctbGlzdFwiPjxwYXRoIGQ9XCJNNCAxNGg0di00SDR2NHptMCA1aDR2LTRINHY0ek00IDloNFY1SDR2NHptNSA1aDEydi00SDl2NHptMCA1aDEydi00SDl2NHpNOSA1djRoMTJWNUg5elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInZpZXctbW9kdWxlXCI+PHBhdGggZD1cIk00IDExaDVWNUg0djZ6bTAgN2g1di02SDR2NnptNiAwaDV2LTZoLTV2NnptNiAwaDV2LTZoLTV2NnptLTYtN2g1VjVoLTV2NnptNi02djZoNVY1aC01elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInZpZXctcXVpbHRcIj48cGF0aCBkPVwiTTEwIDE4aDV2LTZoLTV2NnptLTYgMGg1VjVINHYxM3ptMTIgMGg1di02aC01djZ6TTEwIDV2NmgxMVY1SDEwelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInZpZXctc3RyZWFtXCI+PHBhdGggZD1cIk00IDE4aDE3di02SDR2NnpNNCA1djZoMTdWNUg0elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInZpZXctd2Vla1wiPjxwYXRoIGQ9XCJNNiA1SDNjLS41NSAwLTEgLjQ1LTEgMXYxMmMwIC41NS40NSAxIDEgMWgzYy41NSAwIDEtLjQ1IDEtMVY2YzAtLjU1LS40NS0xLTEtMXptMTQgMGgtM2MtLjU1IDAtMSAuNDUtMSAxdjEyYzAgLjU1LjQ1IDEgMSAxaDNjLjU1IDAgMS0uNDUgMS0xVjZjMC0uNTUtLjQ1LTEtMS0xem0tNyAwaC0zYy0uNTUgMC0xIC40NS0xIDF2MTJjMCAuNTUuNDUgMSAxIDFoM2MuNTUgMCAxLS40NSAxLTFWNmMwLS41NS0uNDUtMS0xLTF6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwidmlzaWJpbGl0eVwiPjxwYXRoIGQ9XCJNMTIgNC41QzcgNC41IDIuNzMgNy42MSAxIDEyYzEuNzMgNC4zOSA2IDcuNSAxMSA3LjVzOS4yNy0zLjExIDExLTcuNWMtMS43My00LjM5LTYtNy41LTExLTcuNXpNMTIgMTdjLTIuNzYgMC01LTIuMjQtNS01czIuMjQtNSA1LTUgNSAyLjI0IDUgNS0yLjI0IDUtNSA1em0wLThjLTEuNjYgMC0zIDEuMzQtMyAzczEuMzQgMyAzIDMgMy0xLjM0IDMtMy0xLjM0LTMtMy0zelwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInZpc2liaWxpdHktb2ZmXCI+PHBhdGggZD1cIk0xMiA3YzIuNzYgMCA1IDIuMjQgNSA1IDAgLjY1LS4xMyAxLjI2LS4zNiAxLjgzbDIuOTIgMi45MmMxLjUxLTEuMjYgMi43LTIuODkgMy40My00Ljc1LTEuNzMtNC4zOS02LTcuNS0xMS03LjUtMS40IDAtMi43NC4yNS0zLjk4LjdsMi4xNiAyLjE2QzEwLjc0IDcuMTMgMTEuMzUgNyAxMiA3ek0yIDQuMjdsMi4yOCAyLjI4LjQ2LjQ2QzMuMDggOC4zIDEuNzggMTAuMDIgMSAxMmMxLjczIDQuMzkgNiA3LjUgMTEgNy41IDEuNTUgMCAzLjAzLS4zIDQuMzgtLjg0bC40Mi40MkwxOS43MyAyMiAyMSAyMC43MyAzLjI3IDMgMiA0LjI3ek03LjUzIDkuOGwxLjU1IDEuNTVjLS4wNS4yMS0uMDguNDMtLjA4LjY1IDAgMS42NiAxLjM0IDMgMyAzIC4yMiAwIC40NC0uMDMuNjUtLjA4bDEuNTUgMS41NWMtLjY3LjMzLTEuNDEuNTMtMi4yLjUzLTIuNzYgMC01LTIuMjQtNS01IDAtLjc5LjItMS41My41My0yLjJ6bTQuMzEtLjc4bDMuMTUgMy4xNS4wMi0uMTZjMC0xLjY2LTEuMzQtMy0zLTNsLS4xNy4wMXpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ3YXJuaW5nXCI+PHBhdGggZD1cIk0xIDIxaDIyTDEyIDIgMSAyMXptMTItM2gtMnYtMmgydjJ6bTAtNGgtMnYtNGgydjR6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwid2F0Y2gtbGF0ZXJcIj48cGF0aCBkPVwiTTEyIDJDNi41IDIgMiA2LjUgMiAxMnM0LjUgMTAgMTAgMTAgMTAtNC41IDEwLTEwUzE3LjUgMiAxMiAyem00LjIgMTQuMkwxMSAxM1Y3aDEuNXY1LjJsNC41IDIuNy0uOCAxLjN6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwid2Vla2VuZFwiPjxwYXRoIGQ9XCJNMjEgMTBjLTEuMSAwLTIgLjktMiAydjNINXYtM2MwLTEuMS0uOS0yLTItMnMtMiAuOS0yIDJ2NWMwIDEuMS45IDIgMiAyaDE4YzEuMSAwIDItLjkgMi0ydi01YzAtMS4xLS45LTItMi0yem0tMy01SDZjLTEuMSAwLTIgLjktMiAydjIuMTVjMS4xNi40MSAyIDEuNTEgMiAyLjgyVjE0aDEydi0yLjAzYzAtMS4zLjg0LTIuNCAyLTIuODJWN2MwLTEuMS0uOS0yLTItMnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ3b3JrXCI+PHBhdGggZD1cIk0yMCA2aC00VjRjMC0xLjExLS44OS0yLTItMmgtNGMtMS4xMSAwLTIgLjg5LTIgMnYySDRjLTEuMTEgMC0xLjk5Ljg5LTEuOTkgMkwyIDE5YzAgMS4xMS44OSAyIDIgMmgxNmMxLjExIDAgMi0uODkgMi0yVjhjMC0xLjExLS44OS0yLTItMnptLTYgMGgtNFY0aDR2MnpcIj48L3BhdGg+PC9nPlxuPGcgaWQ9XCJ5b3V0dWJlLXNlYXJjaGVkLWZvclwiPjxwYXRoIGQ9XCJNMTcuMDEgMTRoLS44bC0uMjctLjI3Yy45OC0xLjE0IDEuNTctMi42MSAxLjU3LTQuMjMgMC0zLjU5LTIuOTEtNi41LTYuNS02LjVzLTYuNSAzLTYuNSA2LjVIMmwzLjg0IDQgNC4xNi00SDYuNTFDNi41MSA3IDguNTMgNSAxMS4wMSA1czQuNSAyLjAxIDQuNSA0LjVjMCAyLjQ4LTIuMDIgNC41LTQuNSA0LjUtLjY1IDAtMS4yNi0uMTQtMS44Mi0uMzhMNy43MSAxNS4xYy45Ny41NyAyLjA5LjkgMy4zLjkgMS42MSAwIDMuMDgtLjU5IDQuMjItMS41N2wuMjcuMjd2Ljc5bDUuMDEgNC45OUwyMiAxOWwtNC45OS01elwiPjwvcGF0aD48L2c+XG48ZyBpZD1cInpvb20taW5cIj48cGF0aCBkPVwiTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6bTIuNS00aC0ydjJIOXYtMkg3VjloMlY3aDF2MmgydjF6XCI+PC9wYXRoPjwvZz5cbjxnIGlkPVwiem9vbS1vdXRcIj48cGF0aCBkPVwiTTE1LjUgMTRoLS43OWwtLjI4LS4yN0MxNS40MSAxMi41OSAxNiAxMS4xMSAxNiA5LjUgMTYgNS45MSAxMy4wOSAzIDkuNSAzUzMgNS45MSAzIDkuNSA1LjkxIDE2IDkuNSAxNmMxLjYxIDAgMy4wOS0uNTkgNC4yMy0xLjU3bC4yNy4yOHYuNzlsNSA0Ljk5TDIwLjQ5IDE5bC00Ljk5LTV6bS02IDBDNy4wMSAxNCA1IDExLjk5IDUgOS41UzcuMDEgNSA5LjUgNSAxNCA3LjAxIDE0IDkuNSAxMS45OSAxNCA5LjUgMTR6TTcgOWg1djFIN3pcIj48L3BhdGg+PC9nPlxuPC9kZWZzPjwvc3ZnPlxuPC9pcm9uLWljb25zZXQtc3ZnPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWljb25zL2lyb24taWNvbnMuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25NZXRhIH0gZnJvbSAnLi4vaXJvbi1tZXRhL2lyb24tbWV0YS5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcbi8qKlxuICogVGhlIGBpcm9uLWljb25zZXQtc3ZnYCBlbGVtZW50IGFsbG93cyB1c2VycyB0byBkZWZpbmUgdGhlaXIgb3duIGljb24gc2V0c1xuICogdGhhdCBjb250YWluIHN2ZyBpY29ucy4gVGhlIHN2ZyBpY29uIGVsZW1lbnRzIHNob3VsZCBiZSBjaGlsZHJlbiBvZiB0aGVcbiAqIGBpcm9uLWljb25zZXQtc3ZnYCBlbGVtZW50LiBNdWx0aXBsZSBpY29ucyBzaG91bGQgYmUgZ2l2ZW4gZGlzdGluY3QgaWQncy5cbiAqXG4gKiBVc2luZyBzdmcgZWxlbWVudHMgdG8gY3JlYXRlIGljb25zIGhhcyBhIGZldyBhZHZhbnRhZ2VzIG92ZXIgdHJhZGl0aW9uYWxcbiAqIGJpdG1hcCBncmFwaGljcyBsaWtlIGpwZyBvciBwbmcuIEljb25zIHRoYXQgdXNlIHN2ZyBhcmUgdmVjdG9yIGJhc2VkIHNvXG4gKiB0aGV5IGFyZSByZXNvbHV0aW9uIGluZGVwZW5kZW50IGFuZCBzaG91bGQgbG9vayBnb29kIG9uIGFueSBkZXZpY2UuIFRoZXlcbiAqIGFyZSBzdHlsYWJsZSB2aWEgY3NzLiBJY29ucyBjYW4gYmUgdGhlbWVkLCBjb2xvcml6ZWQsIGFuZCBldmVuIGFuaW1hdGVkLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDxpcm9uLWljb25zZXQtc3ZnIG5hbWU9XCJteS1zdmctaWNvbnNcIiBzaXplPVwiMjRcIj5cbiAqICAgICAgIDxzdmc+XG4gKiAgICAgICAgIDxkZWZzPlxuICogICAgICAgICAgIDxnIGlkPVwic2hhcGVcIj5cbiAqICAgICAgICAgICAgIDxyZWN0IHg9XCIxMlwiIHk9XCIwXCIgd2lkdGg9XCIxMlwiIGhlaWdodD1cIjI0XCIgLz5cbiAqICAgICAgICAgICAgIDxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiMTJcIiAvPlxuICogICAgICAgICAgIDwvZz5cbiAqICAgICAgICAgPC9kZWZzPlxuICogICAgICAgPC9zdmc+XG4gKiAgICAgPC9pcm9uLWljb25zZXQtc3ZnPlxuICpcbiAqIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IHJlZ2lzdGVyIHRoZSBpY29uIHNldCBcIm15LXN2Zy1pY29uc1wiIHRvIHRoZSBpY29uc2V0XG4gKiBkYXRhYmFzZS4gIFRvIHVzZSB0aGVzZSBpY29ucyBmcm9tIHdpdGhpbiBhbm90aGVyIGVsZW1lbnQsIG1ha2UgYVxuICogYGlyb24taWNvbnNldGAgZWxlbWVudCBhbmQgY2FsbCB0aGUgYGJ5SWRgIG1ldGhvZFxuICogdG8gcmV0cmlldmUgYSBnaXZlbiBpY29uc2V0LiBUbyBhcHBseSBhIHBhcnRpY3VsYXIgaWNvbiBpbnNpZGUgYW5cbiAqIGVsZW1lbnQgdXNlIHRoZSBgYXBwbHlJY29uYCBtZXRob2QuIEZvciBleGFtcGxlOlxuICpcbiAqICAgICBpY29uc2V0LmFwcGx5SWNvbihpY29uTm9kZSwgJ2NhcicpO1xuICpcbiAqIEBlbGVtZW50IGlyb24taWNvbnNldC1zdmdcbiAqIEBkZW1vIGRlbW8vaW5kZXguaHRtbFxuICogQGltcGxlbWVudHMge1BvbHltZXIuSWNvbnNldH1cbiAqL1xuUG9seW1lcih7XG4gIGlzOiAnaXJvbi1pY29uc2V0LXN2ZycsXG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhlIGljb25zZXQuXG4gICAgICovXG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgb2JzZXJ2ZXI6ICdfbmFtZUNoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBzaXplIG9mIGFuIGluZGl2aWR1YWwgaWNvbi4gTm90ZSB0aGF0IGljb25zIG11c3QgYmUgc3F1YXJlLlxuICAgICAqL1xuICAgIHNpemU6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHZhbHVlOiAyNFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgbWlycm9yaW5nIG9mIGljb25zIHdoZXJlIHNwZWNpZmllZCB3aGVuIHRoZXkgYXJlXG4gICAgICogc3RhbXBlZC4gSWNvbnMgdGhhdCBzaG91bGQgYmUgbWlycm9yZWQgc2hvdWxkIGJlIGRlY29yYXRlZCB3aXRoIGFcbiAgICAgKiBgbWlycm9yLWluLXJ0bGAgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogTk9URTogRm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMsIGRpcmVjdGlvbiB3aWxsIGJlIHJlc29sdmVkIG9uY2UgcGVyXG4gICAgICogZG9jdW1lbnQgcGVyIGljb25zZXQsIHNvIG1vdmluZyBpY29ucyBpbiBhbmQgb3V0IG9mIFJUTCBzdWJ0cmVlcyB3aWxsXG4gICAgICogbm90IGNhdXNlIHRoZWlyIG1pcnJvcmVkIHN0YXRlIHRvIGNoYW5nZS5cbiAgICAgKi9cbiAgICBydGxNaXJyb3Jpbmc6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbWV0YSA9IG5ldyBJcm9uTWV0YSh7dHlwZTogJ2ljb25zZXQnLCBrZXk6IG51bGwsIHZhbHVlOiBudWxsfSk7XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RydWN0IGFuIGFycmF5IG9mIGFsbCBpY29uIG5hbWVzIGluIHRoaXMgaWNvbnNldC5cbiAgICpcbiAgICogQHJldHVybiB7IUFycmF5fSBBcnJheSBvZiBpY29uIG5hbWVzLlxuICAgKi9cbiAgZ2V0SWNvbk5hbWVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pY29ucyA9IHRoaXMuX2NyZWF0ZUljb25NYXAoKTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5faWNvbnMpLm1hcChmdW5jdGlvbihuKSB7XG4gICAgICByZXR1cm4gdGhpcy5uYW1lICsgJzonICsgbjtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyBhbiBpY29uIHRvIHRoZSBnaXZlbiBlbGVtZW50LlxuICAgKlxuICAgKiBBbiBzdmcgaWNvbiBpcyBwcmVwZW5kZWQgdG8gdGhlIGVsZW1lbnQncyBzaGFkb3dSb290IGlmIGl0IGV4aXN0cyxcbiAgICogb3RoZXJ3aXNlIHRvIHRoZSBlbGVtZW50IGl0c2VsZi5cbiAgICpcbiAgICogSWYgUlRMIG1pcnJvcmluZyBpcyBlbmFibGVkLCBhbmQgdGhlIGljb24gaXMgbWFya2VkIHRvIGJlIG1pcnJvcmVkIGluXG4gICAqIFJUTCwgdGhlIGVsZW1lbnQgd2lsbCBiZSB0ZXN0ZWQgKG9uY2UgYW5kIG9ubHkgb25jZSBldmVyIGZvciBlYWNoXG4gICAqIGljb25zZXQpIHRvIGRldGVybWluZSB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzdWJ0cmVlIHRoZSBlbGVtZW50IGlzIGluLlxuICAgKiBUaGlzIGRpcmVjdGlvbiB3aWxsIGFwcGx5IHRvIGFsbCBmdXR1cmUgaWNvbiBhcHBsaWNhdGlvbnMsIGFsdGhvdWdoIG9ubHlcbiAgICogaWNvbnMgbWFya2VkIHRvIGJlIG1pcnJvcmVkIHdpbGwgYmUgYWZmZWN0ZWQuXG4gICAqXG4gICAqIEBtZXRob2QgYXBwbHlJY29uXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRvIHdoaWNoIHRoZSBpY29uIGlzIGFwcGxpZWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpY29uTmFtZSBOYW1lIG9mIHRoZSBpY29uIHRvIGFwcGx5LlxuICAgKiBAcmV0dXJuIHs/RWxlbWVudH0gVGhlIHN2ZyBlbGVtZW50IHdoaWNoIHJlbmRlcnMgdGhlIGljb24uXG4gICAqL1xuICBhcHBseUljb246IGZ1bmN0aW9uKGVsZW1lbnQsIGljb25OYW1lKSB7XG4gICAgLy8gUmVtb3ZlIG9sZCBzdmcgZWxlbWVudFxuICAgIHRoaXMucmVtb3ZlSWNvbihlbGVtZW50KTtcbiAgICAvLyBpbnN0YWxsIG5ldyBzdmcgZWxlbWVudFxuICAgIHZhciBzdmcgPSB0aGlzLl9jbG9uZUljb24oaWNvbk5hbWUsXG4gICAgICAgIHRoaXMucnRsTWlycm9yaW5nICYmIHRoaXMuX3RhcmdldElzUlRMKGVsZW1lbnQpKTtcbiAgICBpZiAoc3ZnKSB7XG4gICAgICAvLyBpbnNlcnQgc3ZnIGVsZW1lbnQgaW50byBzaGFkb3cgcm9vdCwgaWYgaXQgZXhpc3RzXG4gICAgICB2YXIgcGRlID0gZG9tKGVsZW1lbnQucm9vdCB8fCBlbGVtZW50KTtcbiAgICAgIHBkZS5pbnNlcnRCZWZvcmUoc3ZnLCBwZGUuY2hpbGROb2Rlc1swXSk7XG4gICAgICByZXR1cm4gZWxlbWVudC5fc3ZnSWNvbiA9IHN2ZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBpY29uIGZyb20gdGhlIGdpdmVuIGVsZW1lbnQgYnkgdW5kb2luZyB0aGUgY2hhbmdlcyBlZmZlY3RlZFxuICAgKiBieSBgYXBwbHlJY29uYC5cbiAgICpcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdGhlIGljb24gaXMgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZUljb246IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAvLyBSZW1vdmUgb2xkIHN2ZyBlbGVtZW50XG4gICAgaWYgKGVsZW1lbnQuX3N2Z0ljb24pIHtcbiAgICAgIGRvbShlbGVtZW50LnJvb3QgfHwgZWxlbWVudCkucmVtb3ZlQ2hpbGQoZWxlbWVudC5fc3ZnSWNvbik7XG4gICAgICBlbGVtZW50Ll9zdmdJY29uID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIE1lYXN1cmVzIGFuZCBtZW1vaXplcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBlbGVtZW50LiBOb3RlIHRoYXQgdGhpc1xuICAgKiBtZWFzdXJlbWVudCBpcyBvbmx5IGRvbmUgb25jZSBhbmQgdGhlIHJlc3VsdCBpcyBtZW1vaXplZCBmb3IgZnV0dXJlXG4gICAqIGludm9jYXRpb25zLlxuICAgKi9cbiAgX3RhcmdldElzUlRMOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICBpZiAodGhpcy5fX3RhcmdldElzUlRMID09IG51bGwpIHtcbiAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICB0YXJnZXQgPSB0YXJnZXQuaG9zdDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fX3RhcmdldElzUlRMID0gdGFyZ2V0ICYmXG4gICAgICAgICAgd2luZG93LmdldENvbXB1dGVkU3R5bGUodGFyZ2V0KVsnZGlyZWN0aW9uJ10gPT09ICdydGwnO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9fdGFyZ2V0SXNSVEw7XG4gIH0sXG5cbiAgLyoqXG4gICAqXG4gICAqIFdoZW4gbmFtZSBpcyBjaGFuZ2VkLCByZWdpc3RlciBpY29uc2V0IG1ldGFkYXRhXG4gICAqXG4gICAqL1xuICBfbmFtZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX21ldGEudmFsdWUgPSBudWxsO1xuICAgIHRoaXMuX21ldGEua2V5ID0gdGhpcy5uYW1lO1xuICAgIHRoaXMuX21ldGEudmFsdWUgPSB0aGlzO1xuXG4gICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZmlyZSgnaXJvbi1pY29uc2V0LWFkZGVkJywgdGhpcywge25vZGU6IHdpbmRvd30pO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtYXAgb2YgY2hpbGQgU1ZHIGVsZW1lbnRzIGJ5IGlkLlxuICAgKlxuICAgKiBAcmV0dXJuIHshT2JqZWN0fSBNYXAgb2YgaWQncyB0byBTVkcgZWxlbWVudHMuXG4gICAqL1xuICBfY3JlYXRlSWNvbk1hcDogZnVuY3Rpb24oKSB7XG4gICAgLy8gT2JqZWN0cyBjaGFpbmVkIHRvIE9iamVjdC5wcm90b3R5cGUgKGB7fWApIGhhdmUgbWVtYmVycy4gU3BlY2lmaWNhbGx5LFxuICAgIC8vIG9uIEZGIHRoZXJlIGlzIGEgYHdhdGNoYCBtZXRob2QgdGhhdCBjb25mdXNlcyB0aGUgaWNvbiBtYXAsIHNvIHdlXG4gICAgLy8gbmVlZCB0byB1c2UgYSBudWxsLWJhc2VkIG9iamVjdCBoZXJlLlxuICAgIHZhciBpY29ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZG9tKHRoaXMpLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tpZF0nKVxuICAgICAgLmZvckVhY2goZnVuY3Rpb24oaWNvbikge1xuICAgICAgICBpY29uc1tpY29uLmlkXSA9IGljb247XG4gICAgICB9KTtcbiAgICByZXR1cm4gaWNvbnM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb2R1Y2UgaW5zdGFsbGFibGUgY2xvbmUgb2YgdGhlIFNWRyBlbGVtZW50IG1hdGNoaW5nIGBpZGAgaW4gdGhpc1xuICAgKiBpY29uc2V0LCBvciBgdW5kZWZpbmVkYCBpZiB0aGVyZSBpcyBubyBtYXRjaGluZyBlbGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIGFuIGluc3RhbGxhYmxlIGNsb25lIG9mIHRoZSBTVkcgZWxlbWVudFxuICAgKiBtYXRjaGluZyBgaWRgLlxuICAgKi9cbiAgX2Nsb25lSWNvbjogZnVuY3Rpb24oaWQsIG1pcnJvckFsbG93ZWQpIHtcbiAgICAvLyBjcmVhdGUgdGhlIGljb24gbWFwIG9uLWRlbWFuZCwgc2luY2UgdGhlIGljb25zZXQgaXRzZWxmIGhhcyBubyBkaXNjcmV0ZVxuICAgIC8vIHNpZ25hbCB0byBrbm93IHdoZW4gaXQncyBjaGlsZHJlbiBhcmUgZnVsbHkgcGFyc2VkXG4gICAgdGhpcy5faWNvbnMgPSB0aGlzLl9pY29ucyB8fCB0aGlzLl9jcmVhdGVJY29uTWFwKCk7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXBhcmVTdmdDbG9uZSh0aGlzLl9pY29uc1tpZF0sIHRoaXMuc2l6ZSwgbWlycm9yQWxsb3dlZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gc291cmNlU3ZnXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gbWlycm9yQWxsb3dlZFxuICAgKiBAcmV0dXJuIHtFbGVtZW50fVxuICAgKi9cbiAgX3ByZXBhcmVTdmdDbG9uZTogZnVuY3Rpb24oc291cmNlU3ZnLCBzaXplLCBtaXJyb3JBbGxvd2VkKSB7XG4gICAgaWYgKHNvdXJjZVN2Zykge1xuICAgICAgdmFyIGNvbnRlbnQgPSBzb3VyY2VTdmcuY2xvbmVOb2RlKHRydWUpLFxuICAgICAgICAgIHN2ZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCAnc3ZnJyksXG4gICAgICAgICAgdmlld0JveCA9IGNvbnRlbnQuZ2V0QXR0cmlidXRlKCd2aWV3Qm94JykgfHwgJzAgMCAnICsgc2l6ZSArICcgJyArIHNpemUsXG4gICAgICAgICAgY3NzVGV4dCA9ICdwb2ludGVyLWV2ZW50czogbm9uZTsgZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7JztcblxuICAgICAgaWYgKG1pcnJvckFsbG93ZWQgJiYgY29udGVudC5oYXNBdHRyaWJ1dGUoJ21pcnJvci1pbi1ydGwnKSkge1xuICAgICAgICBjc3NUZXh0ICs9ICctd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgtMSwxKTt0cmFuc2Zvcm06c2NhbGUoLTEsMSk7JztcbiAgICAgIH1cblxuICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHZpZXdCb3gpO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWlkWU1pZCBtZWV0Jyk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKCdmb2N1c2FibGUnLCAnZmFsc2UnKTtcbiAgICAgIC8vIFRPRE8oZGZyZWVkbSk6IGBwb2ludGVyLWV2ZW50czogbm9uZWAgd29ya3MgYXJvdW5kIGh0dHBzOi8vY3JidWcuY29tLzM3MDEzNlxuICAgICAgLy8gVE9ETyhzam1pbGVzKTogaW5saW5lIHN0eWxlIG1heSBub3QgYmUgaWRlYWwsIGJ1dCBhdm9pZHMgcmVxdWlyaW5nIGEgc2hhZG93LXJvb3RcbiAgICAgIHN2Zy5zdHlsZS5jc3NUZXh0ID0gY3NzVGV4dDtcbiAgICAgIHN2Zy5hcHBlbmRDaGlsZChjb250ZW50KS5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICByZXR1cm4gc3ZnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24taWNvbnNldC1zdmcvaXJvbi1pY29uc2V0LXN2Zy5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvY29sb3IuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyc7XG5pbXBvcnQgeyBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3IgfSBmcm9tICcuLi9wYXBlci1iZWhhdmlvcnMvcGFwZXItY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQgeyBhZnRlck5leHRSZW5kZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzJztcbmltcG9ydCB7IHNldFRvdWNoQWN0aW9uIH0gZnJvbSAnLi4vcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanMnO1xuaW1wb3J0IHsgUGFwZXJSaXBwbGVCZWhhdmlvciB9IGZyb20gJy4uL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1yaXBwbGUtYmVoYXZpb3IuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxkb20tbW9kdWxlIGlkPVwicGFwZXItdG9nZ2xlLWJ1dHRvblwiPlxuICA8dGVtcGxhdGUgc3RyaXAtd2hpdGVzcGFjZT1cIlwiPlxuXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1ob3Jpem9udGFsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCg6Zm9jdXMpIHtcbiAgICAgICAgb3V0bGluZTpub25lO1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWJhciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgb3BhY2l0eTogMC40O1xuICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIGxpbmVhciAuMDhzO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1iYXItY29sb3IsICMwMDAwMDApO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJhcjtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTNweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xuICAgICAgICB3aWR0aDogMjBweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICBib3gtc2hhZG93OiAwIDFweCA1cHggMCByZ2JhKDAsIDAsIDAsIDAuNik7XG4gICAgICAgIHRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIGxpbmVhciAuMDhzLCBiYWNrZ3JvdW5kLWNvbG9yIGxpbmVhciAuMDhzO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gbGluZWFyIC4wOHMsIGJhY2tncm91bmQtY29sb3IgbGluZWFyIC4wOHM7XG4gICAgICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJ1dHRvbi1jb2xvciwgdmFyKC0tcGFwZXItZ3JleS01MCkpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1idXR0b24uZHJhZ2dpbmcge1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XG4gICAgICAgIHRyYW5zaXRpb246IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXTpub3QoW2Rpc2FibGVkXSkpIC50b2dnbGUtYmFyIHtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtYmFyLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWJhcjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgLnRvZ2dsZS1iYXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xuICAgICAgICBvcGFjaXR5OiAwLjEyO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbY2hlY2tlZF0pIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgxNnB4LCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTZweCwgMCk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXTpub3QoW2Rpc2FibGVkXSkpIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWJ1dHRvbi1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1idXR0b247XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2JkYmRiZDtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1pbmsge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTE0cHg7XG4gICAgICAgIGxlZnQ6IC0xNHB4O1xuICAgICAgICByaWdodDogYXV0bztcbiAgICAgICAgYm90dG9tOiBhdXRvO1xuICAgICAgICB3aWR0aDogNDhweDtcbiAgICAgICAgaGVpZ2h0OiA0OHB4O1xuICAgICAgICBvcGFjaXR5OiAwLjU7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtaW5rLWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1pbms7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXSkgLnRvZ2dsZS1pbmsge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWluay1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1pbms7XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtY29udGFpbmVyIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAzNnB4O1xuICAgICAgICBoZWlnaHQ6IDE0cHg7XG4gICAgICAgIC8qIFRoZSB0b2dnbGUgYnV0dG9uIGhhcyBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvZiAtM3B4OyBUaGUgZXh0cmEgMXB4XG4gICAgICAgIC8qIGFjY291bnRzIGZvciB0aGUgdG9nZ2xlIGJ1dHRvbiBzaGFkb3cgYm94LiAqL1xuICAgICAgICBtYXJnaW46IDRweCAxcHg7XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtbGFiZWwge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWxhYmVsLXNwYWNpbmcsIDhweCk7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1sYWJlbC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIC8qIGludmFsaWQgc3RhdGUgKi9cbiAgICAgIDpob3N0KFtpbnZhbGlkXSkgLnRvZ2dsZS1iYXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWludmFsaWQtYmFyLWNvbG9yLCB2YXIoLS1lcnJvci1jb2xvcikpO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaW52YWxpZF0pIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1pbnZhbGlkLWJ1dHRvbi1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2ludmFsaWRdKSAudG9nZ2xlLWluayB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWludmFsaWQtaW5rLWNvbG9yLCB2YXIoLS1lcnJvci1jb2xvcikpO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwidG9nZ2xlLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBpZD1cInRvZ2dsZUJhclwiIGNsYXNzPVwidG9nZ2xlLWJhclwiPjwvZGl2PlxuICAgICAgPGRpdiBpZD1cInRvZ2dsZUJ1dHRvblwiIGNsYXNzPVwidG9nZ2xlLWJ1dHRvblwiPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInRvZ2dsZS1sYWJlbFwiPjxzbG90Pjwvc2xvdD48L2Rpdj5cblxuICA8L3RlbXBsYXRlPlxuXG4gIFxuPC9kb20tbW9kdWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5Qb2x5bWVyKHtcbiAgaXM6ICdwYXBlci10b2dnbGUtYnV0dG9uJyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3JcbiAgXSxcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgIHJvbGU6ICdidXR0b24nLFxuICAgICdhcmlhLXByZXNzZWQnOiAnZmFsc2UnLFxuICAgIHRhYmluZGV4OiAwXG4gIH0sXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgY2hhbmdlcyBkdWUgdG8gdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBldmVudCBjaGFuZ2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1jaGFuZ2VcbiAgICAgKi9cbiAgfSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICB0cmFjazogJ19vbnRyYWNrJ1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICBhZnRlck5leHRSZW5kZXIodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUb3VjaEFjdGlvbih0aGlzLCAncGFuLXknKTtcbiAgICB9KTtcbiAgfSxcblxuICBfb250cmFjazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgdHJhY2sgPSBldmVudC5kZXRhaWw7XG4gICAgaWYgKHRyYWNrLnN0YXRlID09PSAnc3RhcnQnKSB7XG4gICAgICB0aGlzLl90cmFja1N0YXJ0KHRyYWNrKTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrLnN0YXRlID09PSAndHJhY2snKSB7XG4gICAgICB0aGlzLl90cmFja01vdmUodHJhY2spO1xuICAgIH0gZWxzZSBpZiAodHJhY2suc3RhdGUgPT09ICdlbmQnKSB7XG4gICAgICB0aGlzLl90cmFja0VuZCh0cmFjayk7XG4gICAgfVxuICB9LFxuXG4gIF90cmFja1N0YXJ0OiBmdW5jdGlvbih0cmFjaykge1xuICAgIHRoaXMuX3dpZHRoID0gdGhpcy4kLnRvZ2dsZUJhci5vZmZzZXRXaWR0aCAvIDI7XG4gICAgLypcbiAgICAgKiBrZWVwIGFuIHRyYWNrLW9ubHkgY2hlY2sgc3RhdGUgdG8ga2VlcCB0aGUgZHJhZ2dpbmcgYmVoYXZpb3Igc21vb3RoXG4gICAgICogd2hpbGUgdG9nZ2xpbmcgYWN0aXZhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLl90cmFja0NoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XG4gICAgdGhpcy4kLnRvZ2dsZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdkcmFnZ2luZycpO1xuICB9LFxuXG4gIF90cmFja01vdmU6IGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgdmFyIGR4ID0gdHJhY2suZHg7XG4gICAgdGhpcy5feCA9IE1hdGgubWluKHRoaXMuX3dpZHRoLFxuICAgICAgICBNYXRoLm1heCgwLCB0aGlzLl90cmFja0NoZWNrZWQgPyB0aGlzLl93aWR0aCArIGR4IDogZHgpKTtcbiAgICB0aGlzLnRyYW5zbGF0ZTNkKHRoaXMuX3ggKyAncHgnLCAwLCAwLCB0aGlzLiQudG9nZ2xlQnV0dG9uKTtcbiAgICB0aGlzLl91c2VyQWN0aXZhdGUodGhpcy5feCA+ICh0aGlzLl93aWR0aCAvIDIpKTtcbiAgfSxcblxuICBfdHJhY2tFbmQ6IGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgdGhpcy4kLnRvZ2dsZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnZ2luZycpO1xuICAgIHRoaXMudHJhbnNmb3JtKCcnLCB0aGlzLiQudG9nZ2xlQnV0dG9uKTtcbiAgfSxcblxuICAvLyBjdXN0b21pemUgdGhlIGVsZW1lbnQncyByaXBwbGVcbiAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmlwcGxlQ29udGFpbmVyID0gdGhpcy4kLnRvZ2dsZUJ1dHRvbjtcbiAgICB2YXIgcmlwcGxlID0gUGFwZXJSaXBwbGVCZWhhdmlvci5fY3JlYXRlUmlwcGxlKCk7XG4gICAgcmlwcGxlLmlkID0gJ2luayc7XG4gICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgncmVjZW50ZXJzJywgJycpO1xuICAgIHJpcHBsZS5jbGFzc0xpc3QuYWRkKCdjaXJjbGUnLCAndG9nZ2xlLWluaycpO1xuICAgIHJldHVybiByaXBwbGU7XG4gIH1cblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci10b2dnbGUtYnV0dG9uL3BhcGVyLXRvZ2dsZS1idXR0b24uanNcbi8vIG1vZHVsZSBpZCA9IDEwMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgV2ViQ29tcG9uZW50cyBmcm9tICdAd2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvd2ViY29tcG9uZW50cy1saXRlLmpzJztcblxudmFyIGdldEJyZWFrcG9pbnQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh3aW5kb3cuZG9jdW1lbnQucXVlcnlTZWxlY3RvcignYm9keScpLCAnOmJlZm9yZScpLmdldFByb3BlcnR5VmFsdWUoJ2NvbnRlbnQnKS5yZXBsYWNlKC9cIi9nLCAnJyk7XG59O1xuXG5mdW5jdGlvbiBicmVha3BvaW50KGJyZWFrcG9pbnQsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGlmIChnZXRCcmVha3BvaW50KCkgPT09IGJyZWFrcG9pbnQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgICQod2luZG93KS5yZXNpemUoZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKGdldEJyZWFrcG9pbnQoKSA9PT0gYnJlYWtwb2ludCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZXRCcmVha3BvaW50KCkgPT09IGJyZWFrcG9pbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVza3RvcChjYWxsYmFjaykge1xuICByZXR1cm4gYnJlYWtwb2ludChcImRlc2t0b3BcIiwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiB0YWJsZXQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGJyZWFrcG9pbnQoXCJ0YWJsZXRcIiwgY2FsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBwaG9uZShjYWxsYmFjaykge1xuICByZXR1cm4gYnJlYWtwb2ludChcInBob25lXCIsIGNhbGxiYWNrKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2dsb2JhbC9jbGllbnQuanMiLCIoZnVuY3Rpb24oKXsvKlxuXG4gQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciBwLHE9XCJ1bmRlZmluZWRcIiE9dHlwZW9mIHdpbmRvdyYmd2luZG93PT09dGhpcz90aGlzOlwidW5kZWZpbmVkXCIhPXR5cGVvZiBnbG9iYWwmJm51bGwhPWdsb2JhbD9nbG9iYWw6dGhpcyxiYT1cImZ1bmN0aW9uXCI9PXR5cGVvZiBPYmplY3QuZGVmaW5lUHJvcGVydGllcz9PYmplY3QuZGVmaW5lUHJvcGVydHk6ZnVuY3Rpb24oYSxiLGMpe2EhPUFycmF5LnByb3RvdHlwZSYmYSE9T2JqZWN0LnByb3RvdHlwZSYmKGFbYl09Yy52YWx1ZSl9O2Z1bmN0aW9uIGNhKCl7Y2E9ZnVuY3Rpb24oKXt9O3EuU3ltYm9sfHwocS5TeW1ib2w9ZGEpfXZhciBkYT1mdW5jdGlvbigpe3ZhciBhPTA7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVyblwianNjb21wX3N5bWJvbF9cIisoYnx8XCJcIikrYSsrfX0oKTtcbmZ1bmN0aW9uIGVhKCl7Y2EoKTt2YXIgYT1xLlN5bWJvbC5pdGVyYXRvcjthfHwoYT1xLlN5bWJvbC5pdGVyYXRvcj1xLlN5bWJvbChcIml0ZXJhdG9yXCIpKTtcImZ1bmN0aW9uXCIhPXR5cGVvZiBBcnJheS5wcm90b3R5cGVbYV0mJmJhKEFycmF5LnByb3RvdHlwZSxhLHtjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITAsdmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZmEodGhpcyl9fSk7ZWE9ZnVuY3Rpb24oKXt9fWZ1bmN0aW9uIGZhKGEpe3ZhciBiPTA7cmV0dXJuIGhhKGZ1bmN0aW9uKCl7cmV0dXJuIGI8YS5sZW5ndGg/e2RvbmU6ITEsdmFsdWU6YVtiKytdfTp7ZG9uZTohMH19KX1mdW5jdGlvbiBoYShhKXtlYSgpO2E9e25leHQ6YX07YVtxLlN5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc307cmV0dXJuIGF9ZnVuY3Rpb24gaWEoYSl7ZWEoKTt2YXIgYj1hW1N5bWJvbC5pdGVyYXRvcl07cmV0dXJuIGI/Yi5jYWxsKGEpOmZhKGEpfVxuZnVuY3Rpb24gamEoYSl7Zm9yKHZhciBiLGM9W107IShiPWEubmV4dCgpKS5kb25lOyljLnB1c2goYi52YWx1ZSk7cmV0dXJuIGN9XG4oZnVuY3Rpb24oKXtpZighZnVuY3Rpb24oKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO2EuaW5pdEV2ZW50KFwiZm9vXCIsITAsITApO2EucHJldmVudERlZmF1bHQoKTtyZXR1cm4gYS5kZWZhdWx0UHJldmVudGVkfSgpKXt2YXIgYT1FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQ7RXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0PWZ1bmN0aW9uKCl7dGhpcy5jYW5jZWxhYmxlJiYoYS5jYWxsKHRoaXMpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLFwiZGVmYXVsdFByZXZlbnRlZFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4hMH0sY29uZmlndXJhYmxlOiEwfSkpfX12YXIgYj0vVHJpZGVudC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtpZighd2luZG93LkN1c3RvbUV2ZW50fHxiJiZcImZ1bmN0aW9uXCIhPT10eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50KXdpbmRvdy5DdXN0b21FdmVudD1mdW5jdGlvbihhLGIpe2I9Ynx8e307dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbmMuaW5pdEN1c3RvbUV2ZW50KGEsISFiLmJ1YmJsZXMsISFiLmNhbmNlbGFibGUsYi5kZXRhaWwpO3JldHVybiBjfSx3aW5kb3cuQ3VzdG9tRXZlbnQucHJvdG90eXBlPXdpbmRvdy5FdmVudC5wcm90b3R5cGU7aWYoIXdpbmRvdy5FdmVudHx8YiYmXCJmdW5jdGlvblwiIT09dHlwZW9mIHdpbmRvdy5FdmVudCl7dmFyIGM9d2luZG93LkV2ZW50O3dpbmRvdy5FdmVudD1mdW5jdGlvbihhLGIpe2I9Ynx8e307dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTtjLmluaXRFdmVudChhLCEhYi5idWJibGVzLCEhYi5jYW5jZWxhYmxlKTtyZXR1cm4gY307aWYoYylmb3IodmFyIGQgaW4gYyl3aW5kb3cuRXZlbnRbZF09Y1tkXTt3aW5kb3cuRXZlbnQucHJvdG90eXBlPWMucHJvdG90eXBlfWlmKCF3aW5kb3cuTW91c2VFdmVudHx8YiYmXCJmdW5jdGlvblwiIT09dHlwZW9mIHdpbmRvdy5Nb3VzZUV2ZW50KXtiPXdpbmRvdy5Nb3VzZUV2ZW50O3dpbmRvdy5Nb3VzZUV2ZW50PWZ1bmN0aW9uKGEsXG5iKXtiPWJ8fHt9O3ZhciBjPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiTW91c2VFdmVudFwiKTtjLmluaXRNb3VzZUV2ZW50KGEsISFiLmJ1YmJsZXMsISFiLmNhbmNlbGFibGUsYi52aWV3fHx3aW5kb3csYi5kZXRhaWwsYi5zY3JlZW5YLGIuc2NyZWVuWSxiLmNsaWVudFgsYi5jbGllbnRZLGIuY3RybEtleSxiLmFsdEtleSxiLnNoaWZ0S2V5LGIubWV0YUtleSxiLmJ1dHRvbixiLnJlbGF0ZWRUYXJnZXQpO3JldHVybiBjfTtpZihiKWZvcihkIGluIGIpd2luZG93Lk1vdXNlRXZlbnRbZF09YltkXTt3aW5kb3cuTW91c2VFdmVudC5wcm90b3R5cGU9Yi5wcm90b3R5cGV9QXJyYXkuZnJvbXx8KEFycmF5LmZyb209ZnVuY3Rpb24oYSl7cmV0dXJuW10uc2xpY2UuY2FsbChhKX0pO09iamVjdC5hc3NpZ258fChPYmplY3QuYXNzaWduPWZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpLGQ9MCxlO2Q8Yy5sZW5ndGg7ZCsrKWlmKGU9Y1tkXSlmb3IodmFyIGY9XG5hLG09ZSxuPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG0pLHc9MDt3PG4ubGVuZ3RoO3crKyllPW5bd10sZltlXT1tW2VdO3JldHVybiBhfSl9KSh3aW5kb3cuV2ViQ29tcG9uZW50cyk7KGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYSgpe31mdW5jdGlvbiBiKGEsYil7c3dpdGNoKGEubm9kZVR5cGUpe2Nhc2UgTm9kZS5ET0NVTUVOVF9OT0RFOnJldHVybiB3LmNhbGwoYSxiKTtjYXNlIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpyZXR1cm4gSS5jYWxsKGEsYik7ZGVmYXVsdDpyZXR1cm4gbi5jYWxsKGEsYil9fXZhciBjPVwidW5kZWZpbmVkXCI9PT10eXBlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCxkPSEoZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLmNsb25lTm9kZSgpaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSxlPSExOy9UcmlkZW50Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpJiZmdW5jdGlvbigpe2Z1bmN0aW9uIGEoYSxiKXtpZihhIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudClmb3IodmFyIGQ7ZD1hLmZpcnN0Q2hpbGQ7KWMuY2FsbCh0aGlzLGQsYik7ZWxzZSBjLmNhbGwodGhpcyxhLGIpO3JldHVybiBhfWU9ITA7dmFyIGI9Tm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlO1xuTm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlPWZ1bmN0aW9uKGEpe2E9Yi5jYWxsKHRoaXMsYSk7dGhpcyBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQmJihhLl9fcHJvdG9fXz1Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSk7cmV0dXJuIGF9O0RvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGw9SFRNTEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGw7RG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvcj1IVE1MRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvcjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSx7bm9kZVR5cGU6e2dldDpmdW5jdGlvbigpe3JldHVybiBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREV9LGNvbmZpZ3VyYWJsZTohMH0sbG9jYWxOYW1lOntnZXQ6ZnVuY3Rpb24oKXt9LGNvbmZpZ3VyYWJsZTohMH0sbm9kZU5hbWU6e2dldDpmdW5jdGlvbigpe3JldHVyblwiI2RvY3VtZW50LWZyYWdtZW50XCJ9LFxuY29uZmlndXJhYmxlOiEwfX0pO3ZhciBjPU5vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZTtOb2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmU9YTt2YXIgZD1Ob2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZDtOb2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZD1mdW5jdGlvbihiKXtiIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudD9hLmNhbGwodGhpcyxiLG51bGwpOmQuY2FsbCh0aGlzLGIpO3JldHVybiBifTt2YXIgZj1Ob2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCxoPU5vZGUucHJvdG90eXBlLnJlcGxhY2VDaGlsZDtOb2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQ9ZnVuY3Rpb24oYixjKXtiIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudD8oYS5jYWxsKHRoaXMsYixjKSxmLmNhbGwodGhpcyxjKSk6aC5jYWxsKHRoaXMsYixjKTtyZXR1cm4gY307RG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQ9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNyZWF0ZUVsZW1lbnQoXCJkZlwiKTtcbmEuX19wcm90b19fPURvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlO3JldHVybiBhfTt2YXIgZz1Eb2N1bWVudC5wcm90b3R5cGUuaW1wb3J0Tm9kZTtEb2N1bWVudC5wcm90b3R5cGUuaW1wb3J0Tm9kZT1mdW5jdGlvbihhLGIpe2I9Zy5jYWxsKHRoaXMsYSxifHwhMSk7YSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQmJihiLl9fcHJvdG9fXz1Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSk7cmV0dXJuIGJ9fSgpO3ZhciBmPU5vZGUucHJvdG90eXBlLmNsb25lTm9kZSxoPURvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LGc9RG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGUsaz1Ob2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCxsPU5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkLG09Tm9kZS5wcm90b3R5cGUucmVwbGFjZUNoaWxkLG49RWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCx3PURvY3VtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLEk9RG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCxcblphPWZ1bmN0aW9uKCl7aWYoIWMpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKSxiPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtiLmNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSk7YS5jb250ZW50LmFwcGVuZENoaWxkKGIpO2E9YS5jbG9uZU5vZGUoITApO3JldHVybiAwPT09YS5jb250ZW50LmNoaWxkTm9kZXMubGVuZ3RofHwwPT09YS5jb250ZW50LmZpcnN0Q2hpbGQuY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aHx8ZH19KCk7aWYoYyl7dmFyIHQ9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwidGVtcGxhdGVcIiksbmE9ITAsYWE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2FhLnRleHRDb250ZW50PVwidGVtcGxhdGV7ZGlzcGxheTpub25lO31cIjt2YXIgVD1kb2N1bWVudC5oZWFkO1QuaW5zZXJ0QmVmb3JlKGFhLFQuZmlyc3RFbGVtZW50Q2hpbGQpO1xuYS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShIVE1MRWxlbWVudC5wcm90b3R5cGUpO3ZhciBVPSFkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLmhhc093blByb3BlcnR5KFwiaW5uZXJIVE1MXCIpO2EuRD1mdW5jdGlvbihiKXtpZighYi5jb250ZW50KXtiLmNvbnRlbnQ9dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7Zm9yKHZhciBjO2M9Yi5maXJzdENoaWxkOylsLmNhbGwoYi5jb250ZW50LGMpO2lmKFUpYi5fX3Byb3RvX189YS5wcm90b3R5cGU7ZWxzZSBpZihiLmNsb25lTm9kZT1mdW5jdGlvbihiKXtyZXR1cm4gYS5hKHRoaXMsYil9LG5hKXRyeXtuYyhiKSxvYyhiKX1jYXRjaChOZyl7bmE9ITF9YS5KKGIuY29udGVudCl9fTt2YXIgbmM9ZnVuY3Rpb24oYil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJpbm5lckhUTUxcIix7Z2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBhPVwiXCIsYj10aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDtiO2I9Yi5uZXh0U2libGluZylhKz1iLm91dGVySFRNTHx8XG5iLmRhdGEucmVwbGFjZShHZSxwYyk7cmV0dXJuIGF9LHNldDpmdW5jdGlvbihiKXt0LmJvZHkuaW5uZXJIVE1MPWI7Zm9yKGEuSih0KTt0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZDspay5jYWxsKHRoaXMuY29udGVudCx0aGlzLmNvbnRlbnQuZmlyc3RDaGlsZCk7Zm9yKDt0LmJvZHkuZmlyc3RDaGlsZDspbC5jYWxsKHRoaXMuY29udGVudCx0LmJvZHkuZmlyc3RDaGlsZCl9LGNvbmZpZ3VyYWJsZTohMH0pfSxvYz1mdW5jdGlvbihhKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcIm91dGVySFRNTFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIjx0ZW1wbGF0ZT5cIit0aGlzLmlubmVySFRNTCtcIjwvdGVtcGxhdGU+XCJ9LHNldDpmdW5jdGlvbihhKXtpZih0aGlzLnBhcmVudE5vZGUpe3QuYm9keS5pbm5lckhUTUw9YTtmb3IoYT10aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO3QuYm9keS5maXJzdENoaWxkOylsLmNhbGwoYSx0LmJvZHkuZmlyc3RDaGlsZCk7bS5jYWxsKHRoaXMucGFyZW50Tm9kZSxcbmEsdGhpcyl9ZWxzZSB0aHJvdyBFcnJvcihcIkZhaWxlZCB0byBzZXQgdGhlICdvdXRlckhUTUwnIHByb3BlcnR5IG9uICdFbGVtZW50JzogVGhpcyBlbGVtZW50IGhhcyBubyBwYXJlbnQgbm9kZS5cIik7fSxjb25maWd1cmFibGU6ITB9KX07bmMoYS5wcm90b3R5cGUpO29jKGEucHJvdG90eXBlKTthLko9ZnVuY3Rpb24oYyl7Yz1iKGMsXCJ0ZW1wbGF0ZVwiKTtmb3IodmFyIGQ9MCxlPWMubGVuZ3RoLGY7ZDxlJiYoZj1jW2RdKTtkKyspYS5EKGYpfTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLGZ1bmN0aW9uKCl7YS5KKGRvY3VtZW50KX0pO0RvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50PWZ1bmN0aW9uKCl7dmFyIGI9aC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7XCJ0ZW1wbGF0ZVwiPT09Yi5sb2NhbE5hbWUmJmEuRChiKTtyZXR1cm4gYn07dmFyIEdlPS9bJlxcdTAwQTA8Pl0vZyxwYz1mdW5jdGlvbihhKXtzd2l0Y2goYSl7Y2FzZSBcIiZcIjpyZXR1cm5cIiZhbXA7XCI7XG5jYXNlIFwiPFwiOnJldHVyblwiJmx0O1wiO2Nhc2UgXCI+XCI6cmV0dXJuXCImZ3Q7XCI7Y2FzZSBcIlxcdTAwYTBcIjpyZXR1cm5cIiZuYnNwO1wifX19aWYoY3x8WmEpe2EuYT1mdW5jdGlvbihhLGIpe3ZhciBjPWYuY2FsbChhLCExKTt0aGlzLkQmJnRoaXMuRChjKTtiJiYobC5jYWxsKGMuY29udGVudCxmLmNhbGwoYS5jb250ZW50LCEwKSksJGEoYy5jb250ZW50LGEuY29udGVudCkpO3JldHVybiBjfTt2YXIgJGE9ZnVuY3Rpb24oYyxkKXtpZihkLnF1ZXJ5U2VsZWN0b3JBbGwmJihkPWIoZCxcInRlbXBsYXRlXCIpLDAhPT1kLmxlbmd0aCkpe2M9YihjLFwidGVtcGxhdGVcIik7Zm9yKHZhciBlPTAsZj1jLmxlbmd0aCxoLGc7ZTxmO2UrKylnPWRbZV0saD1jW2VdLGEmJmEuRCYmYS5EKGcpLG0uY2FsbChoLnBhcmVudE5vZGUsSGUuY2FsbChnLCEwKSxoKX19LEhlPU5vZGUucHJvdG90eXBlLmNsb25lTm9kZT1mdW5jdGlvbihiKXtpZighZSYmZCYmdGhpcyBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpaWYoYil2YXIgYz1cbkllLmNhbGwodGhpcy5vd25lckRvY3VtZW50LHRoaXMsITApO2Vsc2UgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7ZWxzZSB0aGlzLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJlwidGVtcGxhdGVcIj09PXRoaXMubG9jYWxOYW1lP2M9YS5hKHRoaXMsYik6Yz1mLmNhbGwodGhpcyxiKTtiJiYkYShjLHRoaXMpO3JldHVybiBjfSxJZT1Eb2N1bWVudC5wcm90b3R5cGUuaW1wb3J0Tm9kZT1mdW5jdGlvbihiLGMpe2M9Y3x8ITE7aWYoXCJ0ZW1wbGF0ZVwiPT09Yi5sb2NhbE5hbWUpcmV0dXJuIGEuYShiLGMpO3ZhciBkPWcuY2FsbCh0aGlzLGIsYyk7YyYmJGEoZCxiKTtyZXR1cm4gZH19YyYmKHdpbmRvdy5IVE1MVGVtcGxhdGVFbGVtZW50PWEpfSkoKTt2YXIga2E7QXJyYXkuaXNBcnJheT9rYT1BcnJheS5pc0FycmF5OmthPWZ1bmN0aW9uKGEpe3JldHVyblwiW29iamVjdCBBcnJheV1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhKX07dmFyIGxhPWthO3ZhciBtYT0wLG9hLHBhPVwidW5kZWZpbmVkXCIhPT10eXBlb2Ygd2luZG93P3dpbmRvdzp2b2lkIDAscWE9cGF8fHt9LHJhPXFhLk11dGF0aW9uT2JzZXJ2ZXJ8fHFhLldlYktpdE11dGF0aW9uT2JzZXJ2ZXIsc2E9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBVaW50OENsYW1wZWRBcnJheSYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBpbXBvcnRTY3JpcHRzJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIE1lc3NhZ2VDaGFubmVsO2Z1bmN0aW9uIHRhKCl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBvYT9mdW5jdGlvbigpe29hKHVhKX06dmEoKX1mdW5jdGlvbiB3YSgpe3ZhciBhPTAsYj1uZXcgcmEodWEpLGM9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIik7Yi5vYnNlcnZlKGMse2NoYXJhY3RlckRhdGE6ITB9KTtyZXR1cm4gZnVuY3Rpb24oKXtjLmRhdGE9YT0rK2ElMn19XG5mdW5jdGlvbiB4YSgpe3ZhciBhPW5ldyBNZXNzYWdlQ2hhbm5lbDthLnBvcnQxLm9ubWVzc2FnZT11YTtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYS5wb3J0Mi5wb3N0TWVzc2FnZSgwKX19ZnVuY3Rpb24gdmEoKXt2YXIgYT1zZXRUaW1lb3V0O3JldHVybiBmdW5jdGlvbigpe3JldHVybiBhKHVhLDEpfX12YXIgeWE9QXJyYXkoMUUzKTtmdW5jdGlvbiB1YSgpe2Zvcih2YXIgYT0wO2E8bWE7YSs9MikoMCx5YVthXSkoeWFbYSsxXSkseWFbYV09dm9pZCAwLHlhW2ErMV09dm9pZCAwO21hPTB9dmFyIHphLEFhO1xuaWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBzZWxmJiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIHByb2Nlc3MmJlwiW29iamVjdCBwcm9jZXNzXVwiPT09e30udG9TdHJpbmcuY2FsbChwcm9jZXNzKSlBYT1mdW5jdGlvbigpe3JldHVybiBwcm9jZXNzLmpiKHVhKX07ZWxzZXt2YXIgQmE7aWYocmEpQmE9d2EoKTtlbHNle3ZhciBDYTtpZihzYSlDYT14YSgpO2Vsc2V7dmFyIERhO2lmKHZvaWQgMD09PXBhJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcmVxdWlyZSl0cnl7dmFyIEVhPXJlcXVpcmUoXCJ2ZXJ0eFwiKTtvYT1FYS5sYnx8RWEua2I7RGE9dGEoKX1jYXRjaChhKXtEYT12YSgpfWVsc2UgRGE9dmEoKTtDYT1EYX1CYT1DYX1BYT1CYX16YT1BYTtmdW5jdGlvbiBGYShhLGIpe3lhW21hXT1hO3lhW21hKzFdPWI7bWErPTI7Mj09PW1hJiZ6YSgpfTtmdW5jdGlvbiBHYShhLGIpe3ZhciBjPXRoaXMsZD1uZXcgdGhpcy5jb25zdHJ1Y3RvcihIYSk7dm9pZCAwPT09ZFtJYV0mJkphKGQpO3ZhciBlPWMuZztpZihlKXt2YXIgZj1hcmd1bWVudHNbZS0xXTtGYShmdW5jdGlvbigpe3JldHVybiBLYShlLGQsZixjLmYpfSl9ZWxzZSBMYShjLGQsYSxiKTtyZXR1cm4gZH07ZnVuY3Rpb24gTWEoYSl7aWYoYSYmXCJvYmplY3RcIj09PXR5cGVvZiBhJiZhLmNvbnN0cnVjdG9yPT09dGhpcylyZXR1cm4gYTt2YXIgYj1uZXcgdGhpcyhIYSk7TmEoYixhKTtyZXR1cm4gYn07dmFyIElhPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cmluZygxNik7ZnVuY3Rpb24gSGEoKXt9dmFyIFBhPW5ldyBPYTtmdW5jdGlvbiBRYShhKXt0cnl7cmV0dXJuIGEudGhlbn1jYXRjaChiKXtyZXR1cm4gUGEuZXJyb3I9YixQYX19ZnVuY3Rpb24gUmEoYSxiLGMsZCl7dHJ5e2EuY2FsbChiLGMsZCl9Y2F0Y2goZSl7cmV0dXJuIGV9fWZ1bmN0aW9uIFNhKGEsYixjKXtGYShmdW5jdGlvbihhKXt2YXIgZD0hMSxmPVJhKGMsYixmdW5jdGlvbihjKXtkfHwoZD0hMCxiIT09Yz9OYShhLGMpOnIoYSxjKSl9LGZ1bmN0aW9uKGIpe2R8fChkPSEwLHUoYSxiKSl9KTshZCYmZiYmKGQ9ITAsdShhLGYpKX0sYSl9ZnVuY3Rpb24gVGEoYSxiKXsxPT09Yi5nP3IoYSxiLmYpOjI9PT1iLmc/dShhLGIuZik6TGEoYix2b2lkIDAsZnVuY3Rpb24oYil7cmV0dXJuIE5hKGEsYil9LGZ1bmN0aW9uKGIpe3JldHVybiB1KGEsYil9KX1cbmZ1bmN0aW9uIFVhKGEsYixjKXtiLmNvbnN0cnVjdG9yPT09YS5jb25zdHJ1Y3RvciYmYz09PUdhJiZiLmNvbnN0cnVjdG9yLnJlc29sdmU9PT1NYT9UYShhLGIpOmM9PT1QYT8odShhLFBhLmVycm9yKSxQYS5lcnJvcj1udWxsKTp2b2lkIDA9PT1jP3IoYSxiKTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgYz9TYShhLGIsYyk6cihhLGIpfWZ1bmN0aW9uIE5hKGEsYil7aWYoYT09PWIpdShhLG5ldyBUeXBlRXJyb3IoXCJZb3UgY2Fubm90IHJlc29sdmUgYSBwcm9taXNlIHdpdGggaXRzZWxmXCIpKTtlbHNle3ZhciBjPXR5cGVvZiBiO251bGw9PT1ifHxcIm9iamVjdFwiIT09YyYmXCJmdW5jdGlvblwiIT09Yz9yKGEsYik6VWEoYSxiLFFhKGIpKX19ZnVuY3Rpb24gVmEoYSl7YS5wYSYmYS5wYShhLmYpO1dhKGEpfWZ1bmN0aW9uIHIoYSxiKXt2b2lkIDA9PT1hLmcmJihhLmY9YixhLmc9MSwwIT09YS5JLmxlbmd0aCYmRmEoV2EsYSkpfVxuZnVuY3Rpb24gdShhLGIpe3ZvaWQgMD09PWEuZyYmKGEuZz0yLGEuZj1iLEZhKFZhLGEpKX1mdW5jdGlvbiBMYShhLGIsYyxkKXt2YXIgZT1hLkksZj1lLmxlbmd0aDthLnBhPW51bGw7ZVtmXT1iO2VbZisxXT1jO2VbZisyXT1kOzA9PT1mJiZhLmcmJkZhKFdhLGEpfWZ1bmN0aW9uIFdhKGEpe3ZhciBiPWEuSSxjPWEuZztpZigwIT09Yi5sZW5ndGgpe2Zvcih2YXIgZCxlLGY9YS5mLGg9MDtoPGIubGVuZ3RoO2grPTMpZD1iW2hdLGU9YltoK2NdLGQ/S2EoYyxkLGUsZik6ZShmKTthLkkubGVuZ3RoPTB9fWZ1bmN0aW9uIE9hKCl7dGhpcy5lcnJvcj1udWxsfXZhciBYYT1uZXcgT2E7XG5mdW5jdGlvbiBLYShhLGIsYyxkKXt2YXIgZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgYztpZihlKXt0cnl7dmFyIGY9YyhkKX1jYXRjaChsKXtYYS5lcnJvcj1sLGY9WGF9aWYoZj09PVhhKXt2YXIgaD0hMDt2YXIgZz1mLmVycm9yO2YuZXJyb3I9bnVsbH1lbHNlIHZhciBrPSEwO2lmKGI9PT1mKXt1KGIsbmV3IFR5cGVFcnJvcihcIkEgcHJvbWlzZXMgY2FsbGJhY2sgY2Fubm90IHJldHVybiB0aGF0IHNhbWUgcHJvbWlzZS5cIikpO3JldHVybn19ZWxzZSBmPWQsaz0hMDt2b2lkIDA9PT1iLmcmJihlJiZrP05hKGIsZik6aD91KGIsZyk6MT09PWE/cihiLGYpOjI9PT1hJiZ1KGIsZikpfWZ1bmN0aW9uIFlhKGEsYil7dHJ5e2IoZnVuY3Rpb24oYil7TmEoYSxiKX0sZnVuY3Rpb24oYil7dShhLGIpfSl9Y2F0Y2goYyl7dShhLGMpfX12YXIgYWI9MDtmdW5jdGlvbiBKYShhKXthW0lhXT1hYisrO2EuZz12b2lkIDA7YS5mPXZvaWQgMDthLkk9W119O2Z1bmN0aW9uIGJiKGEsYil7dGhpcy5HYT1hO3RoaXMuQT1uZXcgYShIYSk7dGhpcy5BW0lhXXx8SmEodGhpcy5BKTtpZihsYShiKSlpZih0aGlzLlM9dGhpcy5sZW5ndGg9Yi5sZW5ndGgsdGhpcy5mPUFycmF5KHRoaXMubGVuZ3RoKSwwPT09dGhpcy5sZW5ndGgpcih0aGlzLkEsdGhpcy5mKTtlbHNle3RoaXMubGVuZ3RoPXRoaXMubGVuZ3RofHwwO2ZvcihhPTA7dm9pZCAwPT09dGhpcy5nJiZhPGIubGVuZ3RoO2ErKyljYih0aGlzLGJbYV0sYSk7MD09PXRoaXMuUyYmcih0aGlzLkEsdGhpcy5mKX1lbHNlIHUodGhpcy5BLEVycm9yKFwiQXJyYXkgTWV0aG9kcyBtdXN0IGJlIHByb3ZpZGVkIGFuIEFycmF5XCIpKX1cbmZ1bmN0aW9uIGNiKGEsYixjKXt2YXIgZD1hLkdhLGU9ZC5yZXNvbHZlO2U9PT1NYT8oZT1RYShiKSxlPT09R2EmJnZvaWQgMCE9PWIuZz9kYihhLGIuZyxjLGIuZik6XCJmdW5jdGlvblwiIT09dHlwZW9mIGU/KGEuUy0tLGEuZltjXT1iKTpkPT09dj8oZD1uZXcgZChIYSksVWEoZCxiLGUpLGViKGEsZCxjKSk6ZWIoYSxuZXcgZChmdW5jdGlvbihhKXtyZXR1cm4gYShiKX0pLGMpKTplYihhLGUoYiksYyl9ZnVuY3Rpb24gZGIoYSxiLGMsZCl7dmFyIGU9YS5BO3ZvaWQgMD09PWUuZyYmKGEuUy0tLDI9PT1iP3UoZSxkKTphLmZbY109ZCk7MD09PWEuUyYmcihlLGEuZil9ZnVuY3Rpb24gZWIoYSxiLGMpe0xhKGIsdm9pZCAwLGZ1bmN0aW9uKGIpe3JldHVybiBkYihhLDEsYyxiKX0sZnVuY3Rpb24oYil7cmV0dXJuIGRiKGEsMixjLGIpfSl9O2Z1bmN0aW9uIGZiKGEpe3JldHVybihuZXcgYmIodGhpcyxhKSkuQX07ZnVuY3Rpb24gZ2IoYSl7dmFyIGI9dGhpcztyZXR1cm4gbGEoYSk/bmV3IGIoZnVuY3Rpb24oYyxkKXtmb3IodmFyIGU9YS5sZW5ndGgsZj0wO2Y8ZTtmKyspYi5yZXNvbHZlKGFbZl0pLnRoZW4oYyxkKX0pOm5ldyBiKGZ1bmN0aW9uKGEsYil7cmV0dXJuIGIobmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgdG8gcmFjZS5cIikpfSl9O2Z1bmN0aW9uIGhiKGEpe3ZhciBiPW5ldyB0aGlzKEhhKTt1KGIsYSk7cmV0dXJuIGJ9O2Z1bmN0aW9uIHYoYSl7dGhpc1tJYV09YWIrKzt0aGlzLmY9dGhpcy5nPXZvaWQgMDt0aGlzLkk9W107aWYoSGEhPT1hKXtpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcGFzcyBhIHJlc29sdmVyIGZ1bmN0aW9uIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgcHJvbWlzZSBjb25zdHJ1Y3RvclwiKTtpZih0aGlzIGluc3RhbmNlb2YgdilZYSh0aGlzLGEpO2Vsc2UgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZhaWxlZCB0byBjb25zdHJ1Y3QgJ1Byb21pc2UnOiBQbGVhc2UgdXNlIHRoZSAnbmV3JyBvcGVyYXRvciwgdGhpcyBvYmplY3QgY29uc3RydWN0b3IgY2Fubm90IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uLlwiKTt9fXYucHJvdG90eXBlPXtjb25zdHJ1Y3Rvcjp2LHRoZW46R2EsYTpmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy50aGVuKG51bGwsYSl9fTsvKlxuXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xud2luZG93LlByb21pc2V8fCh3aW5kb3cuUHJvbWlzZT12LHYucHJvdG90eXBlW1wiY2F0Y2hcIl09di5wcm90b3R5cGUuYSx2LnByb3RvdHlwZS50aGVuPXYucHJvdG90eXBlLnRoZW4sdi5hbGw9ZmIsdi5yYWNlPWdiLHYucmVzb2x2ZT1NYSx2LnJlamVjdD1oYik7KGZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoYSxiKXtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2Ygd2luZG93LkN1c3RvbUV2ZW50KXJldHVybiBuZXcgQ3VzdG9tRXZlbnQoYSxiKTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO2MuaW5pdEN1c3RvbUV2ZW50KGEsISFiLmJ1YmJsZXMsISFiLmNhbmNlbGFibGUsYi5kZXRhaWwpO3JldHVybiBjfWZ1bmN0aW9uIGMoYSl7aWYobSlyZXR1cm4gYS5vd25lckRvY3VtZW50IT09ZG9jdW1lbnQ/YS5vd25lckRvY3VtZW50Om51bGw7dmFyIGI9YS5fX2ltcG9ydERvYztpZighYiYmYS5wYXJlbnROb2RlKXtiPWEucGFyZW50Tm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgYi5jbG9zZXN0KWI9Yi5jbG9zZXN0KFwibGlua1tyZWw9aW1wb3J0XVwiKTtlbHNlIGZvcig7IWcoYikmJihiPWIucGFyZW50Tm9kZSk7KTthLl9faW1wb3J0RG9jPWJ9cmV0dXJuIGJ9ZnVuY3Rpb24gZChhKXt2YXIgYj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tyZWw9aW1wb3J0XTpub3QoW2ltcG9ydC1kZXBlbmRlbmN5XSlcIiksXG5jPWIubGVuZ3RoO2M/bChiLGZ1bmN0aW9uKGIpe3JldHVybiBoKGIsZnVuY3Rpb24oKXswPT09LS1jJiZhKCl9KX0pOmEoKX1mdW5jdGlvbiBlKGEpe2Z1bmN0aW9uIGIoKXtcImxvYWRpbmdcIiE9PWRvY3VtZW50LnJlYWR5U3RhdGUmJmRvY3VtZW50LmJvZHkmJihkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGIpLGEoKSl9ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixiKTtiKCl9ZnVuY3Rpb24gZihhKXtlKGZ1bmN0aW9uKCl7cmV0dXJuIGQoZnVuY3Rpb24oKXtyZXR1cm4gYSYmYSgpfSl9KX1mdW5jdGlvbiBoKGEsYil7aWYoYS5fX2xvYWRlZCliJiZiKCk7ZWxzZSBpZihcInNjcmlwdFwiPT09YS5sb2NhbE5hbWUmJiFhLnNyY3x8XCJzdHlsZVwiPT09YS5sb2NhbE5hbWUmJiFhLmZpcnN0Q2hpbGQpYS5fX2xvYWRlZD0hMCxiJiZiKCk7ZWxzZXt2YXIgYz1mdW5jdGlvbihkKXthLnJlbW92ZUV2ZW50TGlzdGVuZXIoZC50eXBlLFxuYyk7YS5fX2xvYWRlZD0hMDtiJiZiKCl9O2EuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixjKTthYSYmXCJzdHlsZVwiPT09YS5sb2NhbE5hbWV8fGEuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsYyl9fWZ1bmN0aW9uIGcoYSl7cmV0dXJuIGEubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmXCJsaW5rXCI9PT1hLmxvY2FsTmFtZSYmXCJpbXBvcnRcIj09PWEucmVsfWZ1bmN0aW9uIGsoKXt2YXIgYT10aGlzO3RoaXMuYT17fTt0aGlzLmI9MDt0aGlzLmg9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oYil7cmV0dXJuIGEuUWEoYil9KTt0aGlzLmgub2JzZXJ2ZShkb2N1bWVudC5oZWFkLHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pO3RoaXMuYyhkb2N1bWVudCl9ZnVuY3Rpb24gbChhLGIsYyl7dmFyIGQ9YT9hLmxlbmd0aDowLGU9Yz8tMToxO2ZvcihjPWM/ZC0xOjA7YzxkJiYwPD1jO2MrPWUpYihhW2NdLGMpfXZhciBtPVwiaW1wb3J0XCJpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKSxcbm49bnVsbDshMT09PVwiY3VycmVudFNjcmlwdFwiaW4gZG9jdW1lbnQmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudCxcImN1cnJlbnRTY3JpcHRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIG58fChcImNvbXBsZXRlXCIhPT1kb2N1bWVudC5yZWFkeVN0YXRlP2RvY3VtZW50LnNjcmlwdHNbZG9jdW1lbnQuc2NyaXB0cy5sZW5ndGgtMV06bnVsbCl9LGNvbmZpZ3VyYWJsZTohMH0pO3ZhciB3PS8odXJsXFwoKShbXildKikoXFwpKS9nLEk9LyhAaW1wb3J0W1xcc10rKD8hdXJsXFwoKSkoW147XSopKDspL2csWmE9Lyg8bGlua1tePl0qKShyZWw9Wyd8XCJdP3N0eWxlc2hlZXRbJ3xcIl0/W14+XSo+KS9nLHQ9e0thOmZ1bmN0aW9uKGEsYil7YS5ocmVmJiZhLnNldEF0dHJpYnV0ZShcImhyZWZcIix0LlkoYS5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGIpKTthLnNyYyYmYS5zZXRBdHRyaWJ1dGUoXCJzcmNcIix0LlkoYS5nZXRBdHRyaWJ1dGUoXCJzcmNcIiksYikpO2lmKFwic3R5bGVcIj09PWEubG9jYWxOYW1lKXt2YXIgYz1cbnQudWEoYS50ZXh0Q29udGVudCxiLHcpO2EudGV4dENvbnRlbnQ9dC51YShjLGIsSSl9fSx1YTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIGEucmVwbGFjZShjLGZ1bmN0aW9uKGEsYyxkLGUpe2E9ZC5yZXBsYWNlKC9bXCInXS9nLFwiXCIpO2ImJihhPXQuWShhLGIpKTtyZXR1cm4gYytcIidcIithK1wiJ1wiK2V9KX0sWTpmdW5jdGlvbihhLGIpe2lmKHZvaWQgMD09PXQuY2Epe3QuY2E9ITE7dHJ5e3ZhciBjPW5ldyBVUkwoXCJiXCIsXCJodHRwOi8vYVwiKTtjLnBhdGhuYW1lPVwiYyUyMGRcIjt0LmNhPVwiaHR0cDovL2EvYyUyMGRcIj09PWMuaHJlZn1jYXRjaChwYyl7fX1pZih0LmNhKXJldHVybihuZXcgVVJMKGEsYikpLmhyZWY7Yz10LkRhO2N8fChjPWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcInRlbXBcIiksdC5EYT1jLGMubWE9Yy5jcmVhdGVFbGVtZW50KFwiYmFzZVwiKSxjLmhlYWQuYXBwZW5kQ2hpbGQoYy5tYSksYy5sYT1jLmNyZWF0ZUVsZW1lbnQoXCJhXCIpKTtjLm1hLmhyZWY9XG5iO2MubGEuaHJlZj1hO3JldHVybiBjLmxhLmhyZWZ8fGF9fSxuYT17YXN5bmM6ITAsbG9hZDpmdW5jdGlvbihhLGIsYyl7aWYoYSlpZihhLm1hdGNoKC9eZGF0YTovKSl7YT1hLnNwbGl0KFwiLFwiKTt2YXIgZD1hWzFdO2Q9LTE8YVswXS5pbmRleE9mKFwiO2Jhc2U2NFwiKT9hdG9iKGQpOmRlY29kZVVSSUNvbXBvbmVudChkKTtiKGQpfWVsc2V7dmFyIGU9bmV3IFhNTEh0dHBSZXF1ZXN0O2Uub3BlbihcIkdFVFwiLGEsbmEuYXN5bmMpO2Uub25sb2FkPWZ1bmN0aW9uKCl7dmFyIGE9ZS5yZXNwb25zZVVSTHx8ZS5nZXRSZXNwb25zZUhlYWRlcihcIkxvY2F0aW9uXCIpO2EmJjA9PT1hLmluZGV4T2YoXCIvXCIpJiYoYT0obG9jYXRpb24ub3JpZ2lufHxsb2NhdGlvbi5wcm90b2NvbCtcIi8vXCIrbG9jYXRpb24uaG9zdCkrYSk7dmFyIGQ9ZS5yZXNwb25zZXx8ZS5yZXNwb25zZVRleHQ7MzA0PT09ZS5zdGF0dXN8fDA9PT1lLnN0YXR1c3x8MjAwPD1lLnN0YXR1cyYmMzAwPmUuc3RhdHVzP2IoZCxhKTpjKGQpfTtcbmUuc2VuZCgpfWVsc2UgYyhcImVycm9yOiBocmVmIG11c3QgYmUgc3BlY2lmaWVkXCIpfX0sYWE9L1RyaWRlbnQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCl8fC9FZGdlXFwvXFxkLi9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7ay5wcm90b3R5cGUuYz1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2E9YS5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tyZWw9aW1wb3J0XVwiKTtsKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGIuTChhKX0pfTtrLnByb3RvdHlwZS5MPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1hLmhyZWY7aWYodm9pZCAwIT09dGhpcy5hW2NdKXt2YXIgZD10aGlzLmFbY107ZCYmZC5fX2xvYWRlZCYmKGEuaW1wb3J0PWQsdGhpcy5vKGEpKX1lbHNlIHRoaXMuYisrLHRoaXMuYVtjXT1cInBlbmRpbmdcIixuYS5sb2FkKGMsZnVuY3Rpb24oYSxkKXthPWIuUmEoYSxkfHxjKTtiLmFbY109YTtiLmItLTtiLmMoYSk7Yi5zYSgpfSxmdW5jdGlvbigpe2IuYVtjXT1udWxsO2IuYi0tO2Iuc2EoKX0pfTtcbmsucHJvdG90eXBlLlJhPWZ1bmN0aW9uKGEsYil7aWYoIWEpcmV0dXJuIGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTthYSYmKGE9YS5yZXBsYWNlKFphLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4tMT09PWEuaW5kZXhPZihcInR5cGU9XCIpP2IrXCIgdHlwZT1pbXBvcnQtZGlzYWJsZSBcIitjOmF9KSk7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO2MuaW5uZXJIVE1MPWE7aWYoYy5jb250ZW50KWE9Yy5jb250ZW50O2Vsc2UgZm9yKGE9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2MuZmlyc3RDaGlsZDspYS5hcHBlbmRDaGlsZChjLmZpcnN0Q2hpbGQpO2lmKGM9YS5xdWVyeVNlbGVjdG9yKFwiYmFzZVwiKSliPXQuWShjLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYiksYy5yZW1vdmVBdHRyaWJ1dGUoXCJocmVmXCIpO2M9YS5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rW3JlbD1pbXBvcnRdLCBsaW5rW3JlbD1zdHlsZXNoZWV0XVtocmVmXVt0eXBlPWltcG9ydC1kaXNhYmxlXSxcXG4gICAgc3R5bGU6bm90KFt0eXBlXSksIGxpbmtbcmVsPXN0eWxlc2hlZXRdW2hyZWZdOm5vdChbdHlwZV0pLFxcbiAgICBzY3JpcHQ6bm90KFt0eXBlXSksIHNjcmlwdFt0eXBlPVwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiXSxcXG4gICAgc2NyaXB0W3R5cGU9XCJ0ZXh0L2phdmFzY3JpcHRcIl0nKTtcbnZhciBkPTA7bChjLGZ1bmN0aW9uKGEpe2goYSk7dC5LYShhLGIpO2Euc2V0QXR0cmlidXRlKFwiaW1wb3J0LWRlcGVuZGVuY3lcIixcIlwiKTtcInNjcmlwdFwiPT09YS5sb2NhbE5hbWUmJiFhLnNyYyYmYS50ZXh0Q29udGVudCYmKGEuc2V0QXR0cmlidXRlKFwic3JjXCIsXCJkYXRhOnRleHQvamF2YXNjcmlwdDtjaGFyc2V0PXV0Zi04LFwiK2VuY29kZVVSSUNvbXBvbmVudChhLnRleHRDb250ZW50KyhcIlxcbi8vIyBzb3VyY2VVUkw9XCIrYisoZD9cIi1cIitkOlwiXCIpK1wiLmpzXFxuXCIpKSksYS50ZXh0Q29udGVudD1cIlwiLGQrKyl9KTtyZXR1cm4gYX07ay5wcm90b3R5cGUuc2E9ZnVuY3Rpb24oKXt2YXIgYT10aGlzO2lmKCF0aGlzLmIpe3RoaXMuaC5kaXNjb25uZWN0KCk7dGhpcy5mbGF0dGVuKGRvY3VtZW50KTt2YXIgYj0hMSxjPSExLGQ9ZnVuY3Rpb24oKXtjJiZiJiYoYS5jKGRvY3VtZW50KSxhLmJ8fChhLmgub2JzZXJ2ZShkb2N1bWVudC5oZWFkLHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pLGEuUGEoKSkpfTtcbnRoaXMuV2EoZnVuY3Rpb24oKXtjPSEwO2QoKX0pO3RoaXMuU2EoZnVuY3Rpb24oKXtiPSEwO2QoKX0pfX07ay5wcm90b3R5cGUuZmxhdHRlbj1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2E9YS5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tyZWw9aW1wb3J0XVwiKTtsKGEsZnVuY3Rpb24oYSl7dmFyIGM9Yi5hW2EuaHJlZl07KGEuaW1wb3J0PWMpJiZjLm5vZGVUeXBlPT09Tm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFJiYoYi5hW2EuaHJlZl09YSxhLnJlYWR5U3RhdGU9XCJsb2FkaW5nXCIsYS5pbXBvcnQ9YSxiLmZsYXR0ZW4oYyksYS5hcHBlbmRDaGlsZChjKSl9KX07ay5wcm90b3R5cGUuU2E9ZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihlKXtpZihlPGQpe3ZhciBmPWNbZV0sZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO2YucmVtb3ZlQXR0cmlidXRlKFwiaW1wb3J0LWRlcGVuZGVuY3lcIik7bChmLmF0dHJpYnV0ZXMsZnVuY3Rpb24oYSl7cmV0dXJuIGcuc2V0QXR0cmlidXRlKGEubmFtZSxcbmEudmFsdWUpfSk7bj1nO2YucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoZyxmKTtoKGcsZnVuY3Rpb24oKXtuPW51bGw7YihlKzEpfSl9ZWxzZSBhKCl9dmFyIGM9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInNjcmlwdFtpbXBvcnQtZGVwZW5kZW5jeV1cIiksZD1jLmxlbmd0aDtiKDApfTtrLnByb3RvdHlwZS5XYT1mdW5jdGlvbihhKXt2YXIgYj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVbaW1wb3J0LWRlcGVuZGVuY3ldLFxcbiAgICBsaW5rW3JlbD1zdHlsZXNoZWV0XVtpbXBvcnQtZGVwZW5kZW5jeV1cIiksZD1iLmxlbmd0aDtpZihkKXt2YXIgZT1hYSYmISFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwibGlua1tyZWw9c3R5bGVzaGVldF1baHJlZl1bdHlwZT1pbXBvcnQtZGlzYWJsZV1cIik7bChiLGZ1bmN0aW9uKGIpe2goYixmdW5jdGlvbigpe2IucmVtb3ZlQXR0cmlidXRlKFwiaW1wb3J0LWRlcGVuZGVuY3lcIik7MD09PS0tZCYmYSgpfSk7aWYoZSYmYi5wYXJlbnROb2RlIT09XG5kb2N1bWVudC5oZWFkKXt2YXIgZj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KGIubG9jYWxOYW1lKTtmLl9fYXBwbGllZEVsZW1lbnQ9YjtmLnNldEF0dHJpYnV0ZShcInR5cGVcIixcImltcG9ydC1wbGFjZWhvbGRlclwiKTtiLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGYsYi5uZXh0U2libGluZyk7Zm9yKGY9YyhiKTtmJiZjKGYpOylmPWMoZik7Zi5wYXJlbnROb2RlIT09ZG9jdW1lbnQuaGVhZCYmKGY9bnVsbCk7ZG9jdW1lbnQuaGVhZC5pbnNlcnRCZWZvcmUoYixmKTtiLnJlbW92ZUF0dHJpYnV0ZShcInR5cGVcIil9fSl9ZWxzZSBhKCl9O2sucHJvdG90eXBlLlBhPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcyxiPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3JlbD1pbXBvcnRdXCIpO2woYixmdW5jdGlvbihiKXtyZXR1cm4gYS5vKGIpfSwhMCl9O2sucHJvdG90eXBlLm89ZnVuY3Rpb24oYSl7YS5fX2xvYWRlZHx8KGEuX19sb2FkZWQ9ITAsYS5pbXBvcnQmJihhLmltcG9ydC5yZWFkeVN0YXRlPVxuXCJjb21wbGV0ZVwiKSxhLmRpc3BhdGNoRXZlbnQoYihhLmltcG9ydD9cImxvYWRcIjpcImVycm9yXCIse2J1YmJsZXM6ITEsY2FuY2VsYWJsZTohMSxkZXRhaWw6dm9pZCAwfSkpKX07ay5wcm90b3R5cGUuUWE9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcztsKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGwoYS5hZGRlZE5vZGVzLGZ1bmN0aW9uKGEpe2EmJmEubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGcoYSk/Yi5MKGEpOmIuYyhhKSl9KX0pfTtpZihtKXt2YXIgVD1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tyZWw9aW1wb3J0XVwiKTtsKFQsZnVuY3Rpb24oYSl7YS5pbXBvcnQmJlwibG9hZGluZ1wiPT09YS5pbXBvcnQucmVhZHlTdGF0ZXx8KGEuX19sb2FkZWQ9ITApfSk7VD1mdW5jdGlvbihhKXthPWEudGFyZ2V0O2coYSkmJihhLl9fbG9hZGVkPSEwKX07ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixULCEwKTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixcblQsITApfWVsc2V7dmFyIFU9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSxcImJhc2VVUklcIik7T2JqZWN0LmRlZmluZVByb3BlcnR5KCghVXx8VS5jb25maWd1cmFibGU/Tm9kZTpFbGVtZW50KS5wcm90b3R5cGUsXCJiYXNlVVJJXCIse2dldDpmdW5jdGlvbigpe3ZhciBhPWcodGhpcyk/dGhpczpjKHRoaXMpO3JldHVybiBhP2EuaHJlZjpVJiZVLmdldD9VLmdldC5jYWxsKHRoaXMpOihkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiYmFzZVwiKXx8d2luZG93LmxvY2F0aW9uKS5ocmVmfSxjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMH0pO2UoZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGt9KX1mKGZ1bmN0aW9uKCl7cmV0dXJuIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoYihcIkhUTUxJbXBvcnRzTG9hZGVkXCIse2NhbmNlbGFibGU6ITAsYnViYmxlczohMCxkZXRhaWw6dm9pZCAwfSkpfSk7YS51c2VOYXRpdmU9bTthLndoZW5SZWFkeT1mO2EuaW1wb3J0Rm9yRWxlbWVudD1cbmN9KSh3aW5kb3cuSFRNTEltcG9ydHM9d2luZG93LkhUTUxJbXBvcnRzfHx7fSk7LypcblxuIENvcHlyaWdodCAoYykgMjAxNCBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbndpbmRvdy5XZWJDb21wb25lbnRzPXdpbmRvdy5XZWJDb21wb25lbnRzfHx7ZmxhZ3M6e319O3ZhciBpYj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbc3JjKj1cIndlYmNvbXBvbmVudHMtbGl0ZS5qc1wiXScpLGpiPS93Yy0oLispLyx4PXt9O2lmKCF4Lm5vT3B0cyl7bG9jYXRpb24uc2VhcmNoLnNsaWNlKDEpLnNwbGl0KFwiJlwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe2E9YS5zcGxpdChcIj1cIik7dmFyIGI7YVswXSYmKGI9YVswXS5tYXRjaChqYikpJiYoeFtiWzFdXT1hWzFdfHwhMCl9KTtpZihpYilmb3IodmFyIGtiPTAsbGI7bGI9aWIuYXR0cmlidXRlc1trYl07a2IrKylcInNyY1wiIT09bGIubmFtZSYmKHhbbGIubmFtZV09bGIudmFsdWV8fCEwKTtpZih4LmxvZyYmeC5sb2cuc3BsaXQpe3ZhciBtYj14LmxvZy5zcGxpdChcIixcIik7eC5sb2c9e307bWIuZm9yRWFjaChmdW5jdGlvbihhKXt4LmxvZ1thXT0hMH0pfWVsc2UgeC5sb2c9e319XG53aW5kb3cuV2ViQ29tcG9uZW50cy5mbGFncz14O3ZhciBuYj14LnNoYWR5ZG9tO25iJiYod2luZG93LlNoYWR5RE9NPXdpbmRvdy5TaGFkeURPTXx8e30sd2luZG93LlNoYWR5RE9NLmZvcmNlPW5iKTt2YXIgb2I9eC5yZWdpc3Rlcnx8eC5jZTtvYiYmd2luZG93LmN1c3RvbUVsZW1lbnRzJiYod2luZG93LmN1c3RvbUVsZW1lbnRzLmZvcmNlUG9seWZpbGw9b2IpOy8qXG5cbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG52YXIgeT13aW5kb3cuU2hhZHlET018fHt9O3kuTWE9ISghRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93fHwhTm9kZS5wcm90b3R5cGUuZ2V0Um9vdE5vZGUpO3ZhciBwYj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5vZGUucHJvdG90eXBlLFwiZmlyc3RDaGlsZFwiKTt5Lk09ISEocGImJnBiLmNvbmZpZ3VyYWJsZSYmcGIuZ2V0KTt5LnRhPXkuZm9yY2V8fCF5Lk1hO2Z1bmN0aW9uIHFiKGEpe3JldHVybiBhLl9fc2hhZHkmJnZvaWQgMCE9PWEuX19zaGFkeS5maXJzdENoaWxkfWZ1bmN0aW9uIHooYSl7cmV0dXJuXCJTaGFkeVJvb3RcIj09PWEuQWF9ZnVuY3Rpb24gcmIoYSl7YT1hLmdldFJvb3ROb2RlKCk7aWYoeihhKSlyZXR1cm4gYX12YXIgc2I9RWxlbWVudC5wcm90b3R5cGUsdGI9c2IubWF0Y2hlc3x8c2IubWF0Y2hlc1NlbGVjdG9yfHxzYi5tb3pNYXRjaGVzU2VsZWN0b3J8fHNiLm1zTWF0Y2hlc1NlbGVjdG9yfHxzYi5vTWF0Y2hlc1NlbGVjdG9yfHxzYi53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5mdW5jdGlvbiB1YihhLGIpe2lmKGEmJmIpZm9yKHZhciBjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGIpLGQ9MCxlO2Q8Yy5sZW5ndGgmJihlPWNbZF0pO2QrKyl7dmFyIGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiLGUpO2YmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGUsZil9fWZ1bmN0aW9uIHZiKGEsYil7Zm9yKHZhciBjPVtdLGQ9MTtkPGFyZ3VtZW50cy5sZW5ndGg7KytkKWNbZC0xXT1hcmd1bWVudHNbZF07Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyl1YihhLGNbZF0pO3JldHVybiBhfWZ1bmN0aW9uIHdiKGEsYil7Zm9yKHZhciBjIGluIGIpYVtjXT1iW2NdfXZhciB4Yj1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKSx5Yj0wLHpiPVtdOyhuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbigpe2Zvcig7emIubGVuZ3RoOyl0cnl7emIuc2hpZnQoKSgpfWNhdGNoKGEpe3Rocm93IHhiLnRleHRDb250ZW50PXliKyssYTt9fSkpLm9ic2VydmUoeGIse2NoYXJhY3RlckRhdGE6ITB9KTtcbmZ1bmN0aW9uIEFiKGEpe3piLnB1c2goYSk7eGIudGV4dENvbnRlbnQ9eWIrK312YXIgQmI9ISFkb2N1bWVudC5jb250YWlucztmdW5jdGlvbiBDYihhLGIpe2Zvcig7Yjspe2lmKGI9PWEpcmV0dXJuITA7Yj1iLnBhcmVudE5vZGV9cmV0dXJuITF9O3ZhciBEYj1bXSxFYjtmdW5jdGlvbiBGYihhKXtFYnx8KEViPSEwLEFiKEdiKSk7RGIucHVzaChhKX1mdW5jdGlvbiBHYigpe0ViPSExO2Zvcih2YXIgYT0hIURiLmxlbmd0aDtEYi5sZW5ndGg7KURiLnNoaWZ0KCkoKTtyZXR1cm4gYX1HYi5saXN0PURiO2Z1bmN0aW9uIEhiKCl7dGhpcy5hPSExO3RoaXMuYWRkZWROb2Rlcz1bXTt0aGlzLnJlbW92ZWROb2Rlcz1bXTt0aGlzLlY9bmV3IFNldH1mdW5jdGlvbiBJYihhKXthLmF8fChhLmE9ITAsQWIoZnVuY3Rpb24oKXtKYihhKX0pKX1mdW5jdGlvbiBKYihhKXtpZihhLmEpe2EuYT0hMTt2YXIgYj1hLnRha2VSZWNvcmRzKCk7Yi5sZW5ndGgmJmEuVi5mb3JFYWNoKGZ1bmN0aW9uKGEpe2EoYil9KX19SGIucHJvdG90eXBlLnRha2VSZWNvcmRzPWZ1bmN0aW9uKCl7aWYodGhpcy5hZGRlZE5vZGVzLmxlbmd0aHx8dGhpcy5yZW1vdmVkTm9kZXMubGVuZ3RoKXt2YXIgYT1be2FkZGVkTm9kZXM6dGhpcy5hZGRlZE5vZGVzLHJlbW92ZWROb2Rlczp0aGlzLnJlbW92ZWROb2Rlc31dO3RoaXMuYWRkZWROb2Rlcz1bXTt0aGlzLnJlbW92ZWROb2Rlcz1bXTtyZXR1cm4gYX1yZXR1cm5bXX07XG5mdW5jdGlvbiBLYihhLGIpe2EuX19zaGFkeT1hLl9fc2hhZHl8fHt9O2EuX19zaGFkeS5OfHwoYS5fX3NoYWR5Lk49bmV3IEhiKTthLl9fc2hhZHkuTi5WLmFkZChiKTt2YXIgYz1hLl9fc2hhZHkuTjtyZXR1cm57RWE6YixDOmMsSGE6YSx0YWtlUmVjb3JkczpmdW5jdGlvbigpe3JldHVybiBjLnRha2VSZWNvcmRzKCl9fX1mdW5jdGlvbiBMYihhKXt2YXIgYj1hJiZhLkM7YiYmKGIuVi5kZWxldGUoYS5FYSksYi5WLnNpemV8fChhLkhhLl9fc2hhZHkuTj1udWxsKSl9XG5mdW5jdGlvbiBNYihhLGIpe3ZhciBjPWIuZ2V0Um9vdE5vZGUoKTtyZXR1cm4gYS5tYXAoZnVuY3Rpb24oYSl7dmFyIGI9Yz09PWEudGFyZ2V0LmdldFJvb3ROb2RlKCk7aWYoYiYmYS5hZGRlZE5vZGVzKXtpZihiPUFycmF5LmZyb20oYS5hZGRlZE5vZGVzKS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGM9PT1hLmdldFJvb3ROb2RlKCl9KSxiLmxlbmd0aClyZXR1cm4gYT1PYmplY3QuY3JlYXRlKGEpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiYWRkZWROb2Rlc1wiLHt2YWx1ZTpiLGNvbmZpZ3VyYWJsZTohMH0pLGF9ZWxzZSBpZihiKXJldHVybiBhfSkuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBhfSl9O3ZhciBBPXt9LE5iPUVsZW1lbnQucHJvdG90eXBlLmluc2VydEJlZm9yZSxPYj1FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVDaGlsZCxQYj1FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUsUWI9RWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlLFJiPUVsZW1lbnQucHJvdG90eXBlLmNsb25lTm9kZSxTYj1Eb2N1bWVudC5wcm90b3R5cGUuaW1wb3J0Tm9kZSxUYj1FbGVtZW50LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyLFViPUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIsVmI9V2luZG93LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyLFdiPVdpbmRvdy5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcixYYj1FbGVtZW50LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50LFliPUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IsWmI9RWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCwkYj1Ob2RlLnByb3RvdHlwZS5jb250YWluc3x8XG5IVE1MRWxlbWVudC5wcm90b3R5cGUuY29udGFpbnM7QS5hcHBlbmRDaGlsZD1FbGVtZW50LnByb3RvdHlwZS5hcHBlbmRDaGlsZDtBLmluc2VydEJlZm9yZT1OYjtBLnJlbW92ZUNoaWxkPU9iO0Euc2V0QXR0cmlidXRlPVBiO0EucmVtb3ZlQXR0cmlidXRlPVFiO0EuY2xvbmVOb2RlPVJiO0EuaW1wb3J0Tm9kZT1TYjtBLmFkZEV2ZW50TGlzdGVuZXI9VGI7QS5yZW1vdmVFdmVudExpc3RlbmVyPVViO0EuYWI9VmI7QS5iYj1XYjtBLmRpc3BhdGNoRXZlbnQ9WGI7QS5xdWVyeVNlbGVjdG9yPVliO0EucXVlcnlTZWxlY3RvckFsbD1aYjtBLmNvbnRhaW5zPSRiO3ZhciBhYz0vWyZcXHUwMEEwXCJdL2csYmM9L1smXFx1MDBBMDw+XS9nO2Z1bmN0aW9uIGNjKGEpe3N3aXRjaChhKXtjYXNlIFwiJlwiOnJldHVyblwiJmFtcDtcIjtjYXNlIFwiPFwiOnJldHVyblwiJmx0O1wiO2Nhc2UgXCI+XCI6cmV0dXJuXCImZ3Q7XCI7Y2FzZSAnXCInOnJldHVyblwiJnF1b3Q7XCI7Y2FzZSBcIlxcdTAwYTBcIjpyZXR1cm5cIiZuYnNwO1wifX1mdW5jdGlvbiBkYyhhKXtmb3IodmFyIGI9e30sYz0wO2M8YS5sZW5ndGg7YysrKWJbYVtjXV09ITA7cmV0dXJuIGJ9dmFyIGVjPWRjKFwiYXJlYSBiYXNlIGJyIGNvbCBjb21tYW5kIGVtYmVkIGhyIGltZyBpbnB1dCBrZXlnZW4gbGluayBtZXRhIHBhcmFtIHNvdXJjZSB0cmFjayB3YnJcIi5zcGxpdChcIiBcIikpLGZjPWRjKFwic3R5bGUgc2NyaXB0IHhtcCBpZnJhbWUgbm9lbWJlZCBub2ZyYW1lcyBwbGFpbnRleHQgbm9zY3JpcHRcIi5zcGxpdChcIiBcIikpO1xuZnVuY3Rpb24gZ2MoYSxiKXtcInRlbXBsYXRlXCI9PT1hLmxvY2FsTmFtZSYmKGE9YS5jb250ZW50KTtmb3IodmFyIGM9XCJcIixkPWI/YihhKTphLmNoaWxkTm9kZXMsZT0wLGY9ZC5sZW5ndGgsaDtlPGYmJihoPWRbZV0pO2UrKyl7YTp7dmFyIGc9aDt2YXIgaz1hO3ZhciBsPWI7c3dpdGNoKGcubm9kZVR5cGUpe2Nhc2UgTm9kZS5FTEVNRU5UX05PREU6Zm9yKHZhciBtPWcubG9jYWxOYW1lLG49XCI8XCIrbSx3PWcuYXR0cmlidXRlcyxJPTA7az13W0ldO0krKyluKz1cIiBcIitrLm5hbWUrJz1cIicray52YWx1ZS5yZXBsYWNlKGFjLGNjKSsnXCInO24rPVwiPlwiO2c9ZWNbbV0/bjpuK2djKGcsbCkrXCI8L1wiK20rXCI+XCI7YnJlYWsgYTtjYXNlIE5vZGUuVEVYVF9OT0RFOmc9Zy5kYXRhO2c9ayYmZmNbay5sb2NhbE5hbWVdP2c6Zy5yZXBsYWNlKGJjLGNjKTticmVhayBhO2Nhc2UgTm9kZS5DT01NRU5UX05PREU6Zz1cIlxceDNjIS0tXCIrZy5kYXRhK1wiLS1cXHgzZVwiO2JyZWFrIGE7ZGVmYXVsdDp0aHJvdyB3aW5kb3cuY29uc29sZS5lcnJvcihnKSxcbkVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO319Yys9Z31yZXR1cm4gY307dmFyIEI9e30sQz1kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGRvY3VtZW50LE5vZGVGaWx0ZXIuU0hPV19BTEwsbnVsbCwhMSksRD1kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGRvY3VtZW50LE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5ULG51bGwsITEpO2Z1bmN0aW9uIGhjKGEpe3ZhciBiPVtdO0MuY3VycmVudE5vZGU9YTtmb3IoYT1DLmZpcnN0Q2hpbGQoKTthOyliLnB1c2goYSksYT1DLm5leHRTaWJsaW5nKCk7cmV0dXJuIGJ9Qi5wYXJlbnROb2RlPWZ1bmN0aW9uKGEpe0MuY3VycmVudE5vZGU9YTtyZXR1cm4gQy5wYXJlbnROb2RlKCl9O0IuZmlyc3RDaGlsZD1mdW5jdGlvbihhKXtDLmN1cnJlbnROb2RlPWE7cmV0dXJuIEMuZmlyc3RDaGlsZCgpfTtCLmxhc3RDaGlsZD1mdW5jdGlvbihhKXtDLmN1cnJlbnROb2RlPWE7cmV0dXJuIEMubGFzdENoaWxkKCl9O0IucHJldmlvdXNTaWJsaW5nPWZ1bmN0aW9uKGEpe0MuY3VycmVudE5vZGU9YTtyZXR1cm4gQy5wcmV2aW91c1NpYmxpbmcoKX07XG5CLm5leHRTaWJsaW5nPWZ1bmN0aW9uKGEpe0MuY3VycmVudE5vZGU9YTtyZXR1cm4gQy5uZXh0U2libGluZygpfTtCLmNoaWxkTm9kZXM9aGM7Qi5wYXJlbnRFbGVtZW50PWZ1bmN0aW9uKGEpe0QuY3VycmVudE5vZGU9YTtyZXR1cm4gRC5wYXJlbnROb2RlKCl9O0IuZmlyc3RFbGVtZW50Q2hpbGQ9ZnVuY3Rpb24oYSl7RC5jdXJyZW50Tm9kZT1hO3JldHVybiBELmZpcnN0Q2hpbGQoKX07Qi5sYXN0RWxlbWVudENoaWxkPWZ1bmN0aW9uKGEpe0QuY3VycmVudE5vZGU9YTtyZXR1cm4gRC5sYXN0Q2hpbGQoKX07Qi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nPWZ1bmN0aW9uKGEpe0QuY3VycmVudE5vZGU9YTtyZXR1cm4gRC5wcmV2aW91c1NpYmxpbmcoKX07Qi5uZXh0RWxlbWVudFNpYmxpbmc9ZnVuY3Rpb24oYSl7RC5jdXJyZW50Tm9kZT1hO3JldHVybiBELm5leHRTaWJsaW5nKCl9O1xuQi5jaGlsZHJlbj1mdW5jdGlvbihhKXt2YXIgYj1bXTtELmN1cnJlbnROb2RlPWE7Zm9yKGE9RC5maXJzdENoaWxkKCk7YTspYi5wdXNoKGEpLGE9RC5uZXh0U2libGluZygpO3JldHVybiBifTtCLmlubmVySFRNTD1mdW5jdGlvbihhKXtyZXR1cm4gZ2MoYSxmdW5jdGlvbihhKXtyZXR1cm4gaGMoYSl9KX07Qi50ZXh0Q29udGVudD1mdW5jdGlvbihhKXtzd2l0Y2goYS5ub2RlVHlwZSl7Y2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpjYXNlIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTphPWRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoYSxOb2RlRmlsdGVyLlNIT1dfVEVYVCxudWxsLCExKTtmb3IodmFyIGI9XCJcIixjO2M9YS5uZXh0Tm9kZSgpOyliKz1jLm5vZGVWYWx1ZTtyZXR1cm4gYjtkZWZhdWx0OnJldHVybiBhLm5vZGVWYWx1ZX19O3ZhciBpYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEVsZW1lbnQucHJvdG90eXBlLFwiaW5uZXJIVE1MXCIpfHxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSxcImlubmVySFRNTFwiKSxqYz1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJpbmVydFwiKSxrYz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKERvY3VtZW50LnByb3RvdHlwZSxcImFjdGl2ZUVsZW1lbnRcIiksbGM9e3BhcmVudEVsZW1lbnQ6e2dldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX19zaGFkeSYmdGhpcy5fX3NoYWR5LnBhcmVudE5vZGU7YSYmYS5ub2RlVHlwZSE9PU5vZGUuRUxFTUVOVF9OT0RFJiYoYT1udWxsKTtyZXR1cm4gdm9pZCAwIT09YT9hOkIucGFyZW50RWxlbWVudCh0aGlzKX0sY29uZmlndXJhYmxlOiEwfSxwYXJlbnROb2RlOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5wYXJlbnROb2RlO1xucmV0dXJuIHZvaWQgMCE9PWE/YTpCLnBhcmVudE5vZGUodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH0sbmV4dFNpYmxpbmc6e2dldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX19zaGFkeSYmdGhpcy5fX3NoYWR5Lm5leHRTaWJsaW5nO3JldHVybiB2b2lkIDAhPT1hP2E6Qi5uZXh0U2libGluZyh0aGlzKX0sY29uZmlndXJhYmxlOiEwfSxwcmV2aW91c1NpYmxpbmc6e2dldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX19zaGFkeSYmdGhpcy5fX3NoYWR5LnByZXZpb3VzU2libGluZztyZXR1cm4gdm9pZCAwIT09YT9hOkIucHJldmlvdXNTaWJsaW5nKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LGNsYXNzTmFtZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCJ9LHNldDpmdW5jdGlvbihhKXt0aGlzLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYSl9LGNvbmZpZ3VyYWJsZTohMH0sbmV4dEVsZW1lbnRTaWJsaW5nOntnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9fc2hhZHkmJlxudm9pZCAwIT09dGhpcy5fX3NoYWR5Lm5leHRTaWJsaW5nKXtmb3IodmFyIGE9dGhpcy5uZXh0U2libGluZzthJiZhLm5vZGVUeXBlIT09Tm9kZS5FTEVNRU5UX05PREU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX1yZXR1cm4gQi5uZXh0RWxlbWVudFNpYmxpbmcodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH0scHJldmlvdXNFbGVtZW50U2libGluZzp7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5fX3NoYWR5JiZ2b2lkIDAhPT10aGlzLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nKXtmb3IodmFyIGE9dGhpcy5wcmV2aW91c1NpYmxpbmc7YSYmYS5ub2RlVHlwZSE9PU5vZGUuRUxFTUVOVF9OT0RFOylhPWEucHJldmlvdXNTaWJsaW5nO3JldHVybiBhfXJldHVybiBCLnByZXZpb3VzRWxlbWVudFNpYmxpbmcodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH19LG1jPXtjaGlsZE5vZGVzOntnZXQ6ZnVuY3Rpb24oKXtpZihxYih0aGlzKSl7aWYoIXRoaXMuX19zaGFkeS5jaGlsZE5vZGVzKXt0aGlzLl9fc2hhZHkuY2hpbGROb2Rlcz1cbltdO2Zvcih2YXIgYT10aGlzLmZpcnN0Q2hpbGQ7YTthPWEubmV4dFNpYmxpbmcpdGhpcy5fX3NoYWR5LmNoaWxkTm9kZXMucHVzaChhKX12YXIgYj10aGlzLl9fc2hhZHkuY2hpbGROb2Rlc31lbHNlIGI9Qi5jaGlsZE5vZGVzKHRoaXMpO2IuaXRlbT1mdW5jdGlvbihhKXtyZXR1cm4gYlthXX07cmV0dXJuIGJ9LGNvbmZpZ3VyYWJsZTohMH0sY2hpbGRFbGVtZW50Q291bnQ6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoaWxkcmVuLmxlbmd0aH0sY29uZmlndXJhYmxlOiEwfSxmaXJzdENoaWxkOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5maXJzdENoaWxkO3JldHVybiB2b2lkIDAhPT1hP2E6Qi5maXJzdENoaWxkKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LGxhc3RDaGlsZDp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkubGFzdENoaWxkO3JldHVybiB2b2lkIDAhPT1hP2E6Qi5sYXN0Q2hpbGQodGhpcyl9LFxuY29uZmlndXJhYmxlOiEwfSx0ZXh0Q29udGVudDp7Z2V0OmZ1bmN0aW9uKCl7aWYocWIodGhpcykpe2Zvcih2YXIgYT1bXSxiPTAsYz10aGlzLmNoaWxkTm9kZXMsZDtkPWNbYl07YisrKWQubm9kZVR5cGUhPT1Ob2RlLkNPTU1FTlRfTk9ERSYmYS5wdXNoKGQudGV4dENvbnRlbnQpO3JldHVybiBhLmpvaW4oXCJcIil9cmV0dXJuIEIudGV4dENvbnRlbnQodGhpcyl9LHNldDpmdW5jdGlvbihhKXtzd2l0Y2godGhpcy5ub2RlVHlwZSl7Y2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpjYXNlIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpmb3IoO3RoaXMuZmlyc3RDaGlsZDspdGhpcy5yZW1vdmVDaGlsZCh0aGlzLmZpcnN0Q2hpbGQpOygwPGEubGVuZ3RofHx0aGlzLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUpJiZ0aGlzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEpKTticmVhaztkZWZhdWx0OnRoaXMubm9kZVZhbHVlPWF9fSxjb25maWd1cmFibGU6ITB9LGZpcnN0RWxlbWVudENoaWxkOntnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9fc2hhZHkmJlxudm9pZCAwIT09dGhpcy5fX3NoYWR5LmZpcnN0Q2hpbGQpe2Zvcih2YXIgYT10aGlzLmZpcnN0Q2hpbGQ7YSYmYS5ub2RlVHlwZSE9PU5vZGUuRUxFTUVOVF9OT0RFOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9cmV0dXJuIEIuZmlyc3RFbGVtZW50Q2hpbGQodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH0sbGFzdEVsZW1lbnRDaGlsZDp7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5fX3NoYWR5JiZ2b2lkIDAhPT10aGlzLl9fc2hhZHkubGFzdENoaWxkKXtmb3IodmFyIGE9dGhpcy5sYXN0Q2hpbGQ7YSYmYS5ub2RlVHlwZSE9PU5vZGUuRUxFTUVOVF9OT0RFOylhPWEucHJldmlvdXNTaWJsaW5nO3JldHVybiBhfXJldHVybiBCLmxhc3RFbGVtZW50Q2hpbGQodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH0sY2hpbGRyZW46e2dldDpmdW5jdGlvbigpe3ZhciBhO3FiKHRoaXMpP2E9QXJyYXkucHJvdG90eXBlLmZpbHRlci5jYWxsKHRoaXMuY2hpbGROb2RlcyxmdW5jdGlvbihhKXtyZXR1cm4gYS5ub2RlVHlwZT09PVxuTm9kZS5FTEVNRU5UX05PREV9KTphPUIuY2hpbGRyZW4odGhpcyk7YS5pdGVtPWZ1bmN0aW9uKGIpe3JldHVybiBhW2JdfTtyZXR1cm4gYX0sY29uZmlndXJhYmxlOiEwfSxpbm5lckhUTUw6e2dldDpmdW5jdGlvbigpe3ZhciBhPVwidGVtcGxhdGVcIj09PXRoaXMubG9jYWxOYW1lP3RoaXMuY29udGVudDp0aGlzO3JldHVybiBxYih0aGlzKT9nYyhhKTpCLmlubmVySFRNTChhKX0sc2V0OmZ1bmN0aW9uKGEpe2Zvcih2YXIgYj1cInRlbXBsYXRlXCI9PT10aGlzLmxvY2FsTmFtZT90aGlzLmNvbnRlbnQ6dGhpcztiLmZpcnN0Q2hpbGQ7KWIucmVtb3ZlQ2hpbGQoYi5maXJzdENoaWxkKTt2YXIgYz10aGlzLmxvY2FsTmFtZTtjJiZcInRlbXBsYXRlXCIhPT1jfHwoYz1cImRpdlwiKTtjPWpjLmNyZWF0ZUVsZW1lbnQoYyk7Zm9yKGljJiZpYy5zZXQ/aWMuc2V0LmNhbGwoYyxhKTpjLmlubmVySFRNTD1hO2MuZmlyc3RDaGlsZDspYi5hcHBlbmRDaGlsZChjLmZpcnN0Q2hpbGQpfSxjb25maWd1cmFibGU6ITB9fSxcbnFjPXtzaGFkb3dSb290OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkuVWF8fG51bGx9LGNvbmZpZ3VyYWJsZTohMH19LHJjPXthY3RpdmVFbGVtZW50OntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT1rYyYma2MuZ2V0P2tjLmdldC5jYWxsKGRvY3VtZW50KTp5Lk0/dm9pZCAwOmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7aWYoYSYmYS5ub2RlVHlwZSl7dmFyIGI9ISF6KHRoaXMpO2lmKHRoaXM9PT1kb2N1bWVudHx8YiYmdGhpcy5ob3N0IT09YSYmQS5jb250YWlucy5jYWxsKHRoaXMuaG9zdCxhKSl7Zm9yKGI9cmIoYSk7YiYmYiE9PXRoaXM7KWE9Yi5ob3N0LGI9cmIoYSk7YT10aGlzPT09ZG9jdW1lbnQ/Yj9udWxsOmE6Yj09PXRoaXM/YTpudWxsfWVsc2UgYT1udWxsfWVsc2UgYT1udWxsO3JldHVybiBhfSxzZXQ6ZnVuY3Rpb24oKXt9LGNvbmZpZ3VyYWJsZTohMH19O1xuZnVuY3Rpb24gRShhLGIsYyl7Zm9yKHZhciBkIGluIGIpe3ZhciBlPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYSxkKTtlJiZlLmNvbmZpZ3VyYWJsZXx8IWUmJmM/T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZCxiW2RdKTpjJiZjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZGVmaW5lXCIsZCxcIm9uXCIsYSl9fWZ1bmN0aW9uIEYoYSl7RShhLGxjKTtFKGEsbWMpO0UoYSxyYyl9dmFyIHNjPXkuTT9mdW5jdGlvbigpe306ZnVuY3Rpb24oYSl7YS5fX3NoYWR5JiZhLl9fc2hhZHkuQmF8fChhLl9fc2hhZHk9YS5fX3NoYWR5fHx7fSxhLl9fc2hhZHkuQmE9ITAsRShhLGxjLCEwKSl9LHRjPXkuTT9mdW5jdGlvbigpe306ZnVuY3Rpb24oYSl7YS5fX3NoYWR5JiZhLl9fc2hhZHkuemF8fChhLl9fc2hhZHk9YS5fX3NoYWR5fHx7fSxhLl9fc2hhZHkuemE9ITAsRShhLG1jLCEwKSxFKGEscWMsITApKX07ZnVuY3Rpb24gdWMoYSxiLGMpe3NjKGEpO2M9Y3x8bnVsbDthLl9fc2hhZHk9YS5fX3NoYWR5fHx7fTtiLl9fc2hhZHk9Yi5fX3NoYWR5fHx7fTtjJiYoYy5fX3NoYWR5PWMuX19zaGFkeXx8e30pO2EuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc9Yz9jLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nOmIubGFzdENoaWxkO3ZhciBkPWEuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc7ZCYmZC5fX3NoYWR5JiYoZC5fX3NoYWR5Lm5leHRTaWJsaW5nPWEpOyhkPWEuX19zaGFkeS5uZXh0U2libGluZz1jKSYmZC5fX3NoYWR5JiYoZC5fX3NoYWR5LnByZXZpb3VzU2libGluZz1hKTthLl9fc2hhZHkucGFyZW50Tm9kZT1iO2M/Yz09PWIuX19zaGFkeS5maXJzdENoaWxkJiYoYi5fX3NoYWR5LmZpcnN0Q2hpbGQ9YSk6KGIuX19zaGFkeS5sYXN0Q2hpbGQ9YSxiLl9fc2hhZHkuZmlyc3RDaGlsZHx8KGIuX19zaGFkeS5maXJzdENoaWxkPWEpKTtiLl9fc2hhZHkuY2hpbGROb2Rlcz1udWxsfVxuZnVuY3Rpb24gdmMoYSl7aWYoIWEuX19zaGFkeXx8dm9pZCAwPT09YS5fX3NoYWR5LmZpcnN0Q2hpbGQpe2EuX19zaGFkeT1hLl9fc2hhZHl8fHt9O2EuX19zaGFkeS5maXJzdENoaWxkPUIuZmlyc3RDaGlsZChhKTthLl9fc2hhZHkubGFzdENoaWxkPUIubGFzdENoaWxkKGEpO3RjKGEpO2Zvcih2YXIgYj1hLl9fc2hhZHkuY2hpbGROb2Rlcz1CLmNoaWxkTm9kZXMoYSksYz0wLGQ7YzxiLmxlbmd0aCYmKGQ9YltjXSk7YysrKWQuX19zaGFkeT1kLl9fc2hhZHl8fHt9LGQuX19zaGFkeS5wYXJlbnROb2RlPWEsZC5fX3NoYWR5Lm5leHRTaWJsaW5nPWJbYysxXXx8bnVsbCxkLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nPWJbYy0xXXx8bnVsbCxzYyhkKX19O2Z1bmN0aW9uIHdjKGEsYixjKXtpZihiPT09YSl0aHJvdyBFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdhcHBlbmRDaGlsZCcgb24gJ05vZGUnOiBUaGUgbmV3IGNoaWxkIGVsZW1lbnQgY29udGFpbnMgdGhlIHBhcmVudC5cIik7aWYoYyl7dmFyIGQ9Yy5fX3NoYWR5JiZjLl9fc2hhZHkucGFyZW50Tm9kZTtpZih2b2lkIDAhPT1kJiZkIT09YXx8dm9pZCAwPT09ZCYmQi5wYXJlbnROb2RlKGMpIT09YSl0aHJvdyBFcnJvcihcIkZhaWxlZCB0byBleGVjdXRlICdpbnNlcnRCZWZvcmUnIG9uICdOb2RlJzogVGhlIG5vZGUgYmVmb3JlIHdoaWNoIHRoZSBuZXcgbm9kZSBpcyB0byBiZSBpbnNlcnRlZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIG5vZGUuXCIpO31pZihjPT09YilyZXR1cm4gYjtiLnBhcmVudE5vZGUmJnhjKGIucGFyZW50Tm9kZSxiKTtkPXJiKGEpO3ZhciBlO2lmKGU9ZClhOntpZighYi5fX25vSW5zZXJ0aW9uUG9pbnQpe3ZhciBmO1wic2xvdFwiPT09Yi5sb2NhbE5hbWU/Zj1bYl06XG5iLnF1ZXJ5U2VsZWN0b3JBbGwmJihmPWIucXVlcnlTZWxlY3RvckFsbChcInNsb3RcIikpO2lmKGYmJmYubGVuZ3RoKXtlPWY7YnJlYWsgYX19ZT12b2lkIDB9KGY9ZSkmJmQuSC5wdXNoLmFwcGx5KGQuSCxbXS5jb25jYXQoZiBpbnN0YW5jZW9mIEFycmF5P2Y6amEoaWEoZikpKSk7ZCYmKFwic2xvdFwiPT09YS5sb2NhbE5hbWV8fGYpJiZ5YyhkKTtpZihxYihhKSl7ZD1jO3RjKGEpO2EuX19zaGFkeT1hLl9fc2hhZHl8fHt9O3ZvaWQgMCE9PWEuX19zaGFkeS5maXJzdENoaWxkJiYoYS5fX3NoYWR5LmNoaWxkTm9kZXM9bnVsbCk7aWYoYi5ub2RlVHlwZT09PU5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSl7Zj1iLmNoaWxkTm9kZXM7Zm9yKGU9MDtlPGYubGVuZ3RoO2UrKyl1YyhmW2VdLGEsZCk7Yi5fX3NoYWR5PWIuX19zaGFkeXx8e307ZD12b2lkIDAhPT1iLl9fc2hhZHkuZmlyc3RDaGlsZD9udWxsOnZvaWQgMDtiLl9fc2hhZHkuZmlyc3RDaGlsZD1iLl9fc2hhZHkubGFzdENoaWxkPVxuZDtiLl9fc2hhZHkuY2hpbGROb2Rlcz1kfWVsc2UgdWMoYixhLGQpO2lmKHpjKGEpKXt5YyhhLl9fc2hhZHkucm9vdCk7dmFyIGg9ITB9ZWxzZSBhLl9fc2hhZHkucm9vdCYmKGg9ITApfWh8fChoPXooYSk/YS5ob3N0OmEsYz8oYz1BYyhjKSxBLmluc2VydEJlZm9yZS5jYWxsKGgsYixjKSk6QS5hcHBlbmRDaGlsZC5jYWxsKGgsYikpO0JjKGEsYik7cmV0dXJuIGJ9XG5mdW5jdGlvbiB4YyhhLGIpe2lmKGIucGFyZW50Tm9kZSE9PWEpdGhyb3cgRXJyb3IoXCJUaGUgbm9kZSB0byBiZSByZW1vdmVkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgbm9kZTogXCIrYik7dmFyIGM9cmIoYik7aWYocWIoYSkpe2IuX19zaGFkeT1iLl9fc2hhZHl8fHt9O2EuX19zaGFkeT1hLl9fc2hhZHl8fHt9O2I9PT1hLl9fc2hhZHkuZmlyc3RDaGlsZCYmKGEuX19zaGFkeS5maXJzdENoaWxkPWIuX19zaGFkeS5uZXh0U2libGluZyk7Yj09PWEuX19zaGFkeS5sYXN0Q2hpbGQmJihhLl9fc2hhZHkubGFzdENoaWxkPWIuX19zaGFkeS5wcmV2aW91c1NpYmxpbmcpO3ZhciBkPWIuX19zaGFkeS5wcmV2aW91c1NpYmxpbmcsZT1iLl9fc2hhZHkubmV4dFNpYmxpbmc7ZCYmKGQuX19zaGFkeT1kLl9fc2hhZHl8fHt9LGQuX19zaGFkeS5uZXh0U2libGluZz1lKTtlJiYoZS5fX3NoYWR5PWUuX19zaGFkeXx8e30sZS5fX3NoYWR5LnByZXZpb3VzU2libGluZz1kKTtiLl9fc2hhZHkucGFyZW50Tm9kZT1cbmIuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc9Yi5fX3NoYWR5Lm5leHRTaWJsaW5nPXZvaWQgMDt2b2lkIDAhPT1hLl9fc2hhZHkuY2hpbGROb2RlcyYmKGEuX19zaGFkeS5jaGlsZE5vZGVzPW51bGwpO2lmKHpjKGEpKXt5YyhhLl9fc2hhZHkucm9vdCk7dmFyIGY9ITB9fUNjKGIpO2lmKGMpeyhkPWEmJlwic2xvdFwiPT09YS5sb2NhbE5hbWUpJiYoZj0hMCk7RGMoYyk7ZT1jLmw7Zm9yKHZhciBoIGluIGUpZm9yKHZhciBnPWVbaF0saz0wO2s8Zy5sZW5ndGg7aysrKXt2YXIgbD1nW2tdO2lmKENiKGIsbCkpe2cuc3BsaWNlKGssMSk7dmFyIG09Yy5zLmluZGV4T2YobCk7MDw9bSYmYy5zLnNwbGljZShtLDEpO2stLTtpZihtPWwuX19zaGFkeS5LKWZvcihsPTA7bDxtLmxlbmd0aDtsKyspe3ZhciBuPW1bbF0sdz1CLnBhcmVudE5vZGUobik7dyYmQS5yZW1vdmVDaGlsZC5jYWxsKHcsbil9bT0hMH19KG18fGQpJiZ5YyhjKX1mfHwoZj16KGEpP2EuaG9zdDphLCghYS5fX3NoYWR5LnJvb3QmJlxuXCJzbG90XCIhPT1iLmxvY2FsTmFtZXx8Zj09PUIucGFyZW50Tm9kZShiKSkmJkEucmVtb3ZlQ2hpbGQuY2FsbChmLGIpKTtCYyhhLG51bGwsYik7cmV0dXJuIGJ9ZnVuY3Rpb24gQ2MoYSl7aWYoYS5fX3NoYWR5JiZ2b2lkIDAhPT1hLl9fc2hhZHkua2EpZm9yKHZhciBiPWEuY2hpbGROb2RlcyxjPTAsZD1iLmxlbmd0aCxlO2M8ZCYmKGU9YltjXSk7YysrKUNjKGUpO2EuX19zaGFkeSYmKGEuX19zaGFkeS5rYT12b2lkIDApfWZ1bmN0aW9uIEFjKGEpe3ZhciBiPWE7YSYmXCJzbG90XCI9PT1hLmxvY2FsTmFtZSYmKGI9KGI9YS5fX3NoYWR5JiZhLl9fc2hhZHkuSykmJmIubGVuZ3RoP2JbMF06QWMoYS5uZXh0U2libGluZykpO3JldHVybiBifWZ1bmN0aW9uIHpjKGEpe3JldHVybihhPWEmJmEuX19zaGFkeSYmYS5fX3NoYWR5LnJvb3QpJiZFYyhhKX1cbmZ1bmN0aW9uIEZjKGEsYil7aWYoXCJzbG90XCI9PT1iKWE9YS5wYXJlbnROb2RlLHpjKGEpJiZ5YyhhLl9fc2hhZHkucm9vdCk7ZWxzZSBpZihcInNsb3RcIj09PWEubG9jYWxOYW1lJiZcIm5hbWVcIj09PWImJihiPXJiKGEpKSl7dmFyIGM9YS5DYSxkPUdjKGEpO2lmKGQhPT1jKXtjPWIubFtjXTt2YXIgZT1jLmluZGV4T2YoYSk7MDw9ZSYmYy5zcGxpY2UoZSwxKTtjPWIubFtkXXx8KGIubFtkXT1bXSk7Yy5wdXNoKGEpOzE8Yy5sZW5ndGgmJihiLmxbZF09SGMoYykpfXljKGIpfX1mdW5jdGlvbiBCYyhhLGIsYyl7aWYoYT1hLl9fc2hhZHkmJmEuX19zaGFkeS5OKWImJmEuYWRkZWROb2Rlcy5wdXNoKGIpLGMmJmEucmVtb3ZlZE5vZGVzLnB1c2goYyksSWIoYSl9XG5mdW5jdGlvbiBJYyhhKXtpZihhJiZhLm5vZGVUeXBlKXthLl9fc2hhZHk9YS5fX3NoYWR5fHx7fTt2YXIgYj1hLl9fc2hhZHkua2E7dm9pZCAwPT09YiYmKHooYSk/Yj1hOmI9KGI9YS5wYXJlbnROb2RlKT9JYyhiKTphLEEuY29udGFpbnMuY2FsbChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsYSkmJihhLl9fc2hhZHkua2E9YikpO3JldHVybiBifX1mdW5jdGlvbiBKYyhhLGIsYyl7dmFyIGQ9W107S2MoYS5jaGlsZE5vZGVzLGIsYyxkKTtyZXR1cm4gZH1mdW5jdGlvbiBLYyhhLGIsYyxkKXtmb3IodmFyIGU9MCxmPWEubGVuZ3RoLGg7ZTxmJiYoaD1hW2VdKTtlKyspe3ZhciBnO2lmKGc9aC5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFKXtnPWg7dmFyIGs9YixsPWMsbT1kLG49ayhnKTtuJiZtLnB1c2goZyk7bCYmbChuKT9nPW46KEtjKGcuY2hpbGROb2RlcyxrLGwsbSksZz12b2lkIDApfWlmKGcpYnJlYWt9fXZhciBMYz1udWxsO1xuZnVuY3Rpb24gTWMoYSxiLGMpe0xjfHwoTGM9d2luZG93LlNoYWR5Q1NTJiZ3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0pO0xjJiZcImNsYXNzXCI9PT1iP0xjLnNldEVsZW1lbnRDbGFzcyhhLGMpOihBLnNldEF0dHJpYnV0ZS5jYWxsKGEsYixjKSxGYyhhLGIpKX1mdW5jdGlvbiBOYyhhLGIpe2lmKGEub3duZXJEb2N1bWVudCE9PWRvY3VtZW50KXJldHVybiBBLmltcG9ydE5vZGUuY2FsbChkb2N1bWVudCxhLGIpO3ZhciBjPUEuaW1wb3J0Tm9kZS5jYWxsKGRvY3VtZW50LGEsITEpO2lmKGIpe2E9YS5jaGlsZE5vZGVzO2I9MDtmb3IodmFyIGQ7YjxhLmxlbmd0aDtiKyspZD1OYyhhW2JdLCEwKSxjLmFwcGVuZENoaWxkKGQpfXJldHVybiBjfTt2YXIgT2M9XCJfX2V2ZW50V3JhcHBlcnNcIitEYXRlLm5vdygpLFBjPXtibHVyOiEwLGZvY3VzOiEwLGZvY3VzaW46ITAsZm9jdXNvdXQ6ITAsY2xpY2s6ITAsZGJsY2xpY2s6ITAsbW91c2Vkb3duOiEwLG1vdXNlZW50ZXI6ITAsbW91c2VsZWF2ZTohMCxtb3VzZW1vdmU6ITAsbW91c2VvdXQ6ITAsbW91c2VvdmVyOiEwLG1vdXNldXA6ITAsd2hlZWw6ITAsYmVmb3JlaW5wdXQ6ITAsaW5wdXQ6ITAsa2V5ZG93bjohMCxrZXl1cDohMCxjb21wb3NpdGlvbnN0YXJ0OiEwLGNvbXBvc2l0aW9udXBkYXRlOiEwLGNvbXBvc2l0aW9uZW5kOiEwLHRvdWNoc3RhcnQ6ITAsdG91Y2hlbmQ6ITAsdG91Y2htb3ZlOiEwLHRvdWNoY2FuY2VsOiEwLHBvaW50ZXJvdmVyOiEwLHBvaW50ZXJlbnRlcjohMCxwb2ludGVyZG93bjohMCxwb2ludGVybW92ZTohMCxwb2ludGVydXA6ITAscG9pbnRlcmNhbmNlbDohMCxwb2ludGVyb3V0OiEwLHBvaW50ZXJsZWF2ZTohMCxnb3Rwb2ludGVyY2FwdHVyZTohMCxsb3N0cG9pbnRlcmNhcHR1cmU6ITAsXG5kcmFnc3RhcnQ6ITAsZHJhZzohMCxkcmFnZW50ZXI6ITAsZHJhZ2xlYXZlOiEwLGRyYWdvdmVyOiEwLGRyb3A6ITAsZHJhZ2VuZDohMCxET01BY3RpdmF0ZTohMCxET01Gb2N1c0luOiEwLERPTUZvY3VzT3V0OiEwLGtleXByZXNzOiEwfTtmdW5jdGlvbiBRYyhhLGIpe3ZhciBjPVtdLGQ9YTtmb3IoYT1hPT09d2luZG93P3dpbmRvdzphLmdldFJvb3ROb2RlKCk7ZDspYy5wdXNoKGQpLGQ9ZC5hc3NpZ25lZFNsb3Q/ZC5hc3NpZ25lZFNsb3Q6ZC5ub2RlVHlwZT09PU5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSYmZC5ob3N0JiYoYnx8ZCE9PWEpP2QuaG9zdDpkLnBhcmVudE5vZGU7Y1tjLmxlbmd0aC0xXT09PWRvY3VtZW50JiZjLnB1c2god2luZG93KTtyZXR1cm4gY31cbmZ1bmN0aW9uIFJjKGEsYil7aWYoIXopcmV0dXJuIGE7YT1RYyhhLCEwKTtmb3IodmFyIGM9MCxkLGUsZixoO2M8Yi5sZW5ndGg7YysrKWlmKGQ9YltjXSxmPWQ9PT13aW5kb3c/d2luZG93OmQuZ2V0Um9vdE5vZGUoKSxmIT09ZSYmKGg9YS5pbmRleE9mKGYpLGU9ZiksIXooZil8fC0xPGgpcmV0dXJuIGR9XG52YXIgU2M9e2dldCBjb21wb3NlZCgpeyExIT09dGhpcy5pc1RydXN0ZWQmJnZvaWQgMD09PXRoaXMuWiYmKHRoaXMuWj1QY1t0aGlzLnR5cGVdKTtyZXR1cm4gdGhpcy5afHwhMX0sY29tcG9zZWRQYXRoOmZ1bmN0aW9uKCl7dGhpcy5uYXx8KHRoaXMubmE9UWModGhpcy5fX3RhcmdldCx0aGlzLmNvbXBvc2VkKSk7cmV0dXJuIHRoaXMubmF9LGdldCB0YXJnZXQoKXtyZXR1cm4gUmModGhpcy5jdXJyZW50VGFyZ2V0LHRoaXMuY29tcG9zZWRQYXRoKCkpfSxnZXQgcmVsYXRlZFRhcmdldCgpe2lmKCF0aGlzLmFhKXJldHVybiBudWxsO3RoaXMub2F8fCh0aGlzLm9hPVFjKHRoaXMuYWEsITApKTtyZXR1cm4gUmModGhpcy5jdXJyZW50VGFyZ2V0LHRoaXMub2EpfSxzdG9wUHJvcGFnYXRpb246ZnVuY3Rpb24oKXtFdmVudC5wcm90b3R5cGUuc3RvcFByb3BhZ2F0aW9uLmNhbGwodGhpcyk7dGhpcy4kPSEwfSxzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246ZnVuY3Rpb24oKXtFdmVudC5wcm90b3R5cGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLmNhbGwodGhpcyk7XG50aGlzLiQ9dGhpcy55YT0hMH19O2Z1bmN0aW9uIFRjKGEpe2Z1bmN0aW9uIGIoYixkKXtiPW5ldyBhKGIsZCk7Yi5aPWQmJiEhZC5jb21wb3NlZDtyZXR1cm4gYn13YihiLGEpO2IucHJvdG90eXBlPWEucHJvdG90eXBlO3JldHVybiBifXZhciBVYz17Zm9jdXM6ITAsYmx1cjohMH07ZnVuY3Rpb24gVmMoYSl7cmV0dXJuIGEuX190YXJnZXQhPT1hLnRhcmdldHx8YS5hYSE9PWEucmVsYXRlZFRhcmdldH1mdW5jdGlvbiBXYyhhLGIsYyl7aWYoYz1iLl9faGFuZGxlcnMmJmIuX19oYW5kbGVyc1thLnR5cGVdJiZiLl9faGFuZGxlcnNbYS50eXBlXVtjXSlmb3IodmFyIGQ9MCxlOyhlPWNbZF0pJiYoIVZjKGEpfHxhLnRhcmdldCE9PWEucmVsYXRlZFRhcmdldCkmJihlLmNhbGwoYixhKSwhYS55YSk7ZCsrKTt9XG5mdW5jdGlvbiBYYyhhKXt2YXIgYj1hLmNvbXBvc2VkUGF0aCgpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiY3VycmVudFRhcmdldFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sY29uZmlndXJhYmxlOiEwfSk7Zm9yKHZhciBjPWIubGVuZ3RoLTE7MDw9YztjLS0pe3ZhciBkPWJbY107V2MoYSxkLFwiY2FwdHVyZVwiKTtpZihhLiQpcmV0dXJufU9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwiZXZlbnRQaGFzZVwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gRXZlbnQuQVRfVEFSR0VUfX0pO3ZhciBlO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspe2Q9YltjXTt2YXIgZj1kLl9fc2hhZHkmJmQuX19zaGFkeS5yb290O2lmKDA9PT1jfHxmJiZmPT09ZSlpZihXYyhhLGQsXCJidWJibGVcIiksZCE9PXdpbmRvdyYmKGU9ZC5nZXRSb290Tm9kZSgpKSxhLiQpYnJlYWt9fVxuZnVuY3Rpb24gWWMoYSxiLGMsZCxlLGYpe2Zvcih2YXIgaD0wO2g8YS5sZW5ndGg7aCsrKXt2YXIgZz1hW2hdLGs9Zy50eXBlLGw9Zy5jYXB0dXJlLG09Zy5vbmNlLG49Zy5wYXNzaXZlO2lmKGI9PT1nLm5vZGUmJmM9PT1rJiZkPT09bCYmZT09PW0mJmY9PT1uKXJldHVybiBofXJldHVybi0xfVxuZnVuY3Rpb24gWmMoYSxiLGMpe2lmKGIpe2lmKGMmJlwib2JqZWN0XCI9PT10eXBlb2YgYyl7dmFyIGQ9ISFjLmNhcHR1cmU7dmFyIGU9ISFjLm9uY2U7dmFyIGY9ISFjLnBhc3NpdmV9ZWxzZSBkPSEhYyxmPWU9ITE7dmFyIGg9YyYmYy5iYXx8dGhpcyxnPWJbT2NdO2lmKGcpe2lmKC0xPFljKGcsaCxhLGQsZSxmKSlyZXR1cm59ZWxzZSBiW09jXT1bXTtnPWZ1bmN0aW9uKGQpe2UmJnRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihhLGIsYyk7ZC5fX3RhcmdldHx8JGMoZCk7aWYoaCE9PXRoaXMpe3ZhciBmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZCxcImN1cnJlbnRUYXJnZXRcIik7T2JqZWN0LmRlZmluZVByb3BlcnR5KGQsXCJjdXJyZW50VGFyZ2V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiBofSxjb25maWd1cmFibGU6ITB9KX1pZihkLmNvbXBvc2VkfHwtMTxkLmNvbXBvc2VkUGF0aCgpLmluZGV4T2YoaCkpaWYoVmMoZCkmJmQudGFyZ2V0PT09ZC5yZWxhdGVkVGFyZ2V0KWQuZXZlbnRQaGFzZT09PVxuRXZlbnQuQlVCQkxJTkdfUEhBU0UmJmQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7ZWxzZSBpZihkLmV2ZW50UGhhc2U9PT1FdmVudC5DQVBUVVJJTkdfUEhBU0V8fGQuYnViYmxlc3x8ZC50YXJnZXQ9PT1ofHxoIGluc3RhbmNlb2YgV2luZG93KXt2YXIgZz1cIm9iamVjdFwiPT09dHlwZW9mIGImJmIuaGFuZGxlRXZlbnQ/Yi5oYW5kbGVFdmVudChkKTpiLmNhbGwoaCxkKTtoIT09dGhpcyYmKGY/KE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkLFwiY3VycmVudFRhcmdldFwiLGYpLGY9bnVsbCk6ZGVsZXRlIGQuY3VycmVudFRhcmdldCk7cmV0dXJuIGd9fTtiW09jXS5wdXNoKHtub2RlOnRoaXMsdHlwZTphLGNhcHR1cmU6ZCxvbmNlOmUscGFzc2l2ZTpmLGNiOmd9KTtVY1thXT8odGhpcy5fX2hhbmRsZXJzPXRoaXMuX19oYW5kbGVyc3x8e30sdGhpcy5fX2hhbmRsZXJzW2FdPXRoaXMuX19oYW5kbGVyc1thXXx8e2NhcHR1cmU6W10sYnViYmxlOltdfSx0aGlzLl9faGFuZGxlcnNbYV1bZD9cblwiY2FwdHVyZVwiOlwiYnViYmxlXCJdLnB1c2goZykpOih0aGlzIGluc3RhbmNlb2YgV2luZG93P0EuYWI6QS5hZGRFdmVudExpc3RlbmVyKS5jYWxsKHRoaXMsYSxnLGMpfX1cbmZ1bmN0aW9uIGFkKGEsYixjKXtpZihiKXtpZihjJiZcIm9iamVjdFwiPT09dHlwZW9mIGMpe3ZhciBkPSEhYy5jYXB0dXJlO3ZhciBlPSEhYy5vbmNlO3ZhciBmPSEhYy5wYXNzaXZlfWVsc2UgZD0hIWMsZj1lPSExO3ZhciBoPWMmJmMuYmF8fHRoaXMsZz12b2lkIDA7dmFyIGs9bnVsbDt0cnl7az1iW09jXX1jYXRjaChsKXt9ayYmKGU9WWMoayxoLGEsZCxlLGYpLC0xPGUmJihnPWsuc3BsaWNlKGUsMSlbMF0uY2Isay5sZW5ndGh8fChiW09jXT12b2lkIDApKSk7KHRoaXMgaW5zdGFuY2VvZiBXaW5kb3c/QS5iYjpBLnJlbW92ZUV2ZW50TGlzdGVuZXIpLmNhbGwodGhpcyxhLGd8fGIsYyk7ZyYmVWNbYV0mJnRoaXMuX19oYW5kbGVycyYmdGhpcy5fX2hhbmRsZXJzW2FdJiYoYT10aGlzLl9faGFuZGxlcnNbYV1bZD9cImNhcHR1cmVcIjpcImJ1YmJsZVwiXSxnPWEuaW5kZXhPZihnKSwtMTxnJiZhLnNwbGljZShnLDEpKX19XG5mdW5jdGlvbiBiZCgpe2Zvcih2YXIgYSBpbiBVYyl3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihhLGZ1bmN0aW9uKGEpe2EuX190YXJnZXR8fCgkYyhhKSxYYyhhKSl9LCEwKX1mdW5jdGlvbiAkYyhhKXthLl9fdGFyZ2V0PWEudGFyZ2V0O2EuYWE9YS5yZWxhdGVkVGFyZ2V0O2lmKHkuTSl7dmFyIGI9T2JqZWN0LmdldFByb3RvdHlwZU9mKGEpO2lmKCFiLmhhc093blByb3BlcnR5KFwiX19wYXRjaFByb3RvXCIpKXt2YXIgYz1PYmplY3QuY3JlYXRlKGIpO2MuZmI9Yjt1YihjLFNjKTtiLl9fcGF0Y2hQcm90bz1jfWEuX19wcm90b19fPWIuX19wYXRjaFByb3RvfWVsc2UgdWIoYSxTYyl9dmFyIGNkPVRjKHdpbmRvdy5FdmVudCksZGQ9VGMod2luZG93LkN1c3RvbUV2ZW50KSxlZD1UYyh3aW5kb3cuTW91c2VFdmVudCk7ZnVuY3Rpb24gZmQoYSxiKXtyZXR1cm57aW5kZXg6YSxPOltdLFU6Yn19XG5mdW5jdGlvbiBnZChhLGIsYyxkKXt2YXIgZT0wLGY9MCxoPTAsZz0wLGs9TWF0aC5taW4oYi1lLGQtZik7aWYoMD09ZSYmMD09ZilhOntmb3IoaD0wO2g8aztoKyspaWYoYVtoXSE9PWNbaF0pYnJlYWsgYTtoPWt9aWYoYj09YS5sZW5ndGgmJmQ9PWMubGVuZ3RoKXtnPWEubGVuZ3RoO2Zvcih2YXIgbD1jLmxlbmd0aCxtPTA7bTxrLWgmJmhkKGFbLS1nXSxjWy0tbF0pOyltKys7Zz1tfWUrPWg7Zis9aDtiLT1nO2QtPWc7aWYoMD09Yi1lJiYwPT1kLWYpcmV0dXJuW107aWYoZT09Yil7Zm9yKGI9ZmQoZSwwKTtmPGQ7KWIuTy5wdXNoKGNbZisrXSk7cmV0dXJuW2JdfWlmKGY9PWQpcmV0dXJuW2ZkKGUsYi1lKV07az1lO2g9ZjtkPWQtaCsxO2c9Yi1rKzE7Yj1BcnJheShkKTtmb3IobD0wO2w8ZDtsKyspYltsXT1BcnJheShnKSxiW2xdWzBdPWw7Zm9yKGw9MDtsPGc7bCsrKWJbMF1bbF09bDtmb3IobD0xO2w8ZDtsKyspZm9yKG09MTttPGc7bSsrKWlmKGFbayttLTFdPT09Y1toK2wtMV0pYltsXVttXT1cbmJbbC0xXVttLTFdO2Vsc2V7dmFyIG49YltsLTFdW21dKzEsdz1iW2xdW20tMV0rMTtiW2xdW21dPW48dz9uOnd9az1iLmxlbmd0aC0xO2g9YlswXS5sZW5ndGgtMTtkPWJba11baF07Zm9yKGE9W107MDxrfHwwPGg7KTA9PWs/KGEucHVzaCgyKSxoLS0pOjA9PWg/KGEucHVzaCgzKSxrLS0pOihnPWJbay0xXVtoLTFdLGw9YltrLTFdW2hdLG09YltrXVtoLTFdLG49bDxtP2w8Zz9sOmc6bTxnP206ZyxuPT1nPyhnPT1kP2EucHVzaCgwKTooYS5wdXNoKDEpLGQ9Zyksay0tLGgtLSk6bj09bD8oYS5wdXNoKDMpLGstLSxkPWwpOihhLnB1c2goMiksaC0tLGQ9bSkpO2EucmV2ZXJzZSgpO2I9dm9pZCAwO2s9W107Zm9yKGg9MDtoPGEubGVuZ3RoO2grKylzd2l0Y2goYVtoXSl7Y2FzZSAwOmImJihrLnB1c2goYiksYj12b2lkIDApO2UrKztmKys7YnJlYWs7Y2FzZSAxOmJ8fChiPWZkKGUsMCkpO2IuVSsrO2UrKztiLk8ucHVzaChjW2ZdKTtmKys7YnJlYWs7Y2FzZSAyOmJ8fChiPWZkKGUsMCkpO1xuYi5VKys7ZSsrO2JyZWFrO2Nhc2UgMzpifHwoYj1mZChlLDApKSxiLk8ucHVzaChjW2ZdKSxmKyt9YiYmay5wdXNoKGIpO3JldHVybiBrfWZ1bmN0aW9uIGhkKGEsYil7cmV0dXJuIGE9PT1ifTt2YXIgaWQ9e307ZnVuY3Rpb24gRyhhLGIsYyl7aWYoYSE9PWlkKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbGxlZ2FsIGNvbnN0cnVjdG9yXCIpO2E9ZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2EuX19wcm90b19fPUcucHJvdG90eXBlO2EuQWE9XCJTaGFkeVJvb3RcIjt2YyhiKTt2YyhhKTthLmhvc3Q9YjthLmE9YyYmYy5tb2RlO2IuX19zaGFkeT1iLl9fc2hhZHl8fHt9O2IuX19zaGFkeS5yb290PWE7Yi5fX3NoYWR5LlVhPVwiY2xvc2VkXCIhPT1hLmE/YTpudWxsO2EuVD0hMTthLnM9W107YS5sPXt9O2EuSD1bXTtjPUIuY2hpbGROb2RlcyhiKTtmb3IodmFyIGQ9MCxlPWMubGVuZ3RoO2Q8ZTtkKyspQS5yZW1vdmVDaGlsZC5jYWxsKGIsY1tkXSk7cmV0dXJuIGF9Ry5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSk7ZnVuY3Rpb24geWMoYSl7YS5UfHwoYS5UPSEwLEZiKGZ1bmN0aW9uKCl7cmV0dXJuIGpkKGEpfSkpfVxuZnVuY3Rpb24gamQoYSl7Zm9yKHZhciBiO2E7KXthLlQmJihiPWEpO2E6e3ZhciBjPWE7YT1jLmhvc3QuZ2V0Um9vdE5vZGUoKTtpZih6KGEpKWZvcih2YXIgZD1jLmhvc3QuY2hpbGROb2RlcyxlPTA7ZTxkLmxlbmd0aDtlKyspaWYoYz1kW2VdLFwic2xvdFwiPT1jLmxvY2FsTmFtZSlicmVhayBhO2E9dm9pZCAwfX1iJiZiLl9yZW5kZXJSb290KCl9XG5HLnByb3RvdHlwZS5fcmVuZGVyUm9vdD1mdW5jdGlvbigpe3RoaXMuVD0hMTtEYyh0aGlzKTtmb3IodmFyIGE9MCxiO2E8dGhpcy5zLmxlbmd0aDthKyspe2I9dGhpcy5zW2FdO3ZhciBjPWIuX19zaGFkeS5hc3NpZ25lZE5vZGVzO2IuX19zaGFkeS5hc3NpZ25lZE5vZGVzPVtdO2IuX19zaGFkeS5LPVtdO2lmKGIuX19zaGFkeS5xYT1jKWZvcih2YXIgZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdO2UuX19zaGFkeS5nYT1lLl9fc2hhZHkuYXNzaWduZWRTbG90O2UuX19zaGFkeS5hc3NpZ25lZFNsb3Q9PT1iJiYoZS5fX3NoYWR5LmFzc2lnbmVkU2xvdD1udWxsKX19Zm9yKGI9dGhpcy5ob3N0LmZpcnN0Q2hpbGQ7YjtiPWIubmV4dFNpYmxpbmcpa2QodGhpcyxiKTtmb3IoYT0wO2E8dGhpcy5zLmxlbmd0aDthKyspe2I9dGhpcy5zW2FdO2lmKCFiLl9fc2hhZHkuYXNzaWduZWROb2Rlcy5sZW5ndGgpZm9yKGM9Yi5maXJzdENoaWxkO2M7Yz1jLm5leHRTaWJsaW5nKWtkKHRoaXMsXG5jLGIpO2M9Yi5wYXJlbnROb2RlOyhjPWMuX19zaGFkeSYmYy5fX3NoYWR5LnJvb3QpJiZFYyhjKSYmYy5fcmVuZGVyUm9vdCgpO2xkKHRoaXMsYi5fX3NoYWR5LkssYi5fX3NoYWR5LmFzc2lnbmVkTm9kZXMpO2lmKGM9Yi5fX3NoYWR5LnFhKXtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKWNbZF0uX19zaGFkeS5nYT1udWxsO2IuX19zaGFkeS5xYT1udWxsO2MubGVuZ3RoPmIuX19zaGFkeS5hc3NpZ25lZE5vZGVzLmxlbmd0aCYmKGIuX19zaGFkeS5pYT0hMCl9Yi5fX3NoYWR5LmlhJiYoYi5fX3NoYWR5LmlhPSExLG1kKHRoaXMsYikpfWE9dGhpcy5zO2I9W107Zm9yKGM9MDtjPGEubGVuZ3RoO2MrKylkPWFbY10ucGFyZW50Tm9kZSxkLl9fc2hhZHkmJmQuX19zaGFkeS5yb290fHwhKDA+Yi5pbmRleE9mKGQpKXx8Yi5wdXNoKGQpO2ZvcihhPTA7YTxiLmxlbmd0aDthKyspe2M9YlthXTtkPWM9PT10aGlzP3RoaXMuaG9zdDpjO2U9W107Yz1jLmNoaWxkTm9kZXM7Zm9yKHZhciBmPTA7ZjxcbmMubGVuZ3RoO2YrKyl7dmFyIGg9Y1tmXTtpZihcInNsb3RcIj09aC5sb2NhbE5hbWUpe2g9aC5fX3NoYWR5Lks7Zm9yKHZhciBnPTA7ZzxoLmxlbmd0aDtnKyspZS5wdXNoKGhbZ10pfWVsc2UgZS5wdXNoKGgpfWM9dm9pZCAwO2Y9Qi5jaGlsZE5vZGVzKGQpO2g9Z2QoZSxlLmxlbmd0aCxmLGYubGVuZ3RoKTtmb3IodmFyIGs9Zz0wO2c8aC5sZW5ndGgmJihjPWhbZ10pO2crKyl7Zm9yKHZhciBsPTAsbTtsPGMuTy5sZW5ndGgmJihtPWMuT1tsXSk7bCsrKUIucGFyZW50Tm9kZShtKT09PWQmJkEucmVtb3ZlQ2hpbGQuY2FsbChkLG0pLGYuc3BsaWNlKGMuaW5kZXgraywxKTtrLT1jLlV9Zm9yKGs9MDtrPGgubGVuZ3RoJiYoYz1oW2tdKTtrKyspZm9yKGc9ZltjLmluZGV4XSxsPWMuaW5kZXg7bDxjLmluZGV4K2MuVTtsKyspbT1lW2xdLEEuaW5zZXJ0QmVmb3JlLmNhbGwoZCxtLGcpLGYuc3BsaWNlKGwsMCxtKX19O1xuZnVuY3Rpb24ga2QoYSxiLGMpe2IuX19zaGFkeT1iLl9fc2hhZHl8fHt9O3ZhciBkPWIuX19zaGFkeS5nYTtiLl9fc2hhZHkuZ2E9bnVsbDtjfHwoYz0oYT1hLmxbYi5zbG90fHxcIl9fY2F0Y2hhbGxcIl0pJiZhWzBdKTtjPyhjLl9fc2hhZHkuYXNzaWduZWROb2Rlcy5wdXNoKGIpLGIuX19zaGFkeS5hc3NpZ25lZFNsb3Q9Yyk6Yi5fX3NoYWR5LmFzc2lnbmVkU2xvdD12b2lkIDA7ZCE9PWIuX19zaGFkeS5hc3NpZ25lZFNsb3QmJmIuX19zaGFkeS5hc3NpZ25lZFNsb3QmJihiLl9fc2hhZHkuYXNzaWduZWRTbG90Ll9fc2hhZHkuaWE9ITApfWZ1bmN0aW9uIGxkKGEsYixjKXtmb3IodmFyIGQ9MCxlO2Q8Yy5sZW5ndGgmJihlPWNbZF0pO2QrKylpZihcInNsb3RcIj09ZS5sb2NhbE5hbWUpe3ZhciBmPWUuX19zaGFkeS5hc3NpZ25lZE5vZGVzO2YmJmYubGVuZ3RoJiZsZChhLGIsZil9ZWxzZSBiLnB1c2goY1tkXSl9XG5mdW5jdGlvbiBtZChhLGIpe0EuZGlzcGF0Y2hFdmVudC5jYWxsKGIsbmV3IEV2ZW50KFwic2xvdGNoYW5nZVwiKSk7Yi5fX3NoYWR5LmFzc2lnbmVkU2xvdCYmbWQoYSxiLl9fc2hhZHkuYXNzaWduZWRTbG90KX1mdW5jdGlvbiBEYyhhKXtpZihhLkgubGVuZ3RoKXtmb3IodmFyIGI9YS5ILGMsZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZT1iW2RdO2UuX19zaGFkeT1lLl9fc2hhZHl8fHt9O3ZjKGUpO3ZjKGUucGFyZW50Tm9kZSk7dmFyIGY9R2MoZSk7YS5sW2ZdPyhjPWN8fHt9LGNbZl09ITAsYS5sW2ZdLnB1c2goZSkpOmEubFtmXT1bZV07YS5zLnB1c2goZSl9aWYoYylmb3IodmFyIGggaW4gYylhLmxbaF09SGMoYS5sW2hdKTthLkg9W119fWZ1bmN0aW9uIEdjKGEpe3ZhciBiPWEubmFtZXx8YS5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpfHxcIl9fY2F0Y2hhbGxcIjtyZXR1cm4gYS5DYT1ifVxuZnVuY3Rpb24gSGMoYSl7cmV0dXJuIGEuc29ydChmdW5jdGlvbihhLGMpe2E9bmQoYSk7Zm9yKHZhciBiPW5kKGMpLGU9MDtlPGEubGVuZ3RoO2UrKyl7Yz1hW2VdO3ZhciBmPWJbZV07aWYoYyE9PWYpcmV0dXJuIGE9QXJyYXkuZnJvbShjLnBhcmVudE5vZGUuY2hpbGROb2RlcyksYS5pbmRleE9mKGMpLWEuaW5kZXhPZihmKX19KX1mdW5jdGlvbiBuZChhKXt2YXIgYj1bXTtkbyBiLnVuc2hpZnQoYSk7d2hpbGUoYT1hLnBhcmVudE5vZGUpO3JldHVybiBifWZ1bmN0aW9uIEVjKGEpe0RjKGEpO3JldHVybiEhYS5zLmxlbmd0aH1HLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGEsYixjKXtcIm9iamVjdFwiIT09dHlwZW9mIGMmJihjPXtjYXB0dXJlOiEhY30pO2MuYmE9dGhpczt0aGlzLmhvc3QuYWRkRXZlbnRMaXN0ZW5lcihhLGIsYyl9O1xuRy5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIsYyl7XCJvYmplY3RcIiE9PXR5cGVvZiBjJiYoYz17Y2FwdHVyZTohIWN9KTtjLmJhPXRoaXM7dGhpcy5ob3N0LnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxiLGMpfTtHLnByb3RvdHlwZS5nZXRFbGVtZW50QnlJZD1mdW5jdGlvbihhKXtyZXR1cm4gSmModGhpcyxmdW5jdGlvbihiKXtyZXR1cm4gYi5pZD09YX0sZnVuY3Rpb24oYSl7cmV0dXJuISFhfSlbMF18fG51bGx9O3ZhciBvZD1HLnByb3RvdHlwZTtFKG9kLG1jLCEwKTtFKG9kLHJjLCEwKTtmdW5jdGlvbiBwZChhKXt2YXIgYj1hLmdldFJvb3ROb2RlKCk7eihiKSYmamQoYik7cmV0dXJuIGEuX19zaGFkeSYmYS5fX3NoYWR5LmFzc2lnbmVkU2xvdHx8bnVsbH1cbnZhciBxZD17YWRkRXZlbnRMaXN0ZW5lcjpaYy5iaW5kKHdpbmRvdykscmVtb3ZlRXZlbnRMaXN0ZW5lcjphZC5iaW5kKHdpbmRvdyl9LHJkPXthZGRFdmVudExpc3RlbmVyOlpjLHJlbW92ZUV2ZW50TGlzdGVuZXI6YWQsYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHdjKHRoaXMsYSl9LGluc2VydEJlZm9yZTpmdW5jdGlvbihhLGIpe3JldHVybiB3Yyh0aGlzLGEsYil9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKGEpe3JldHVybiB4Yyh0aGlzLGEpfSxyZXBsYWNlQ2hpbGQ6ZnVuY3Rpb24oYSxiKXt3Yyh0aGlzLGEsYik7eGModGhpcyxiKTtyZXR1cm4gYX0sY2xvbmVOb2RlOmZ1bmN0aW9uKGEpe2lmKFwidGVtcGxhdGVcIj09dGhpcy5sb2NhbE5hbWUpdmFyIGI9QS5jbG9uZU5vZGUuY2FsbCh0aGlzLGEpO2Vsc2UgaWYoYj1BLmNsb25lTm9kZS5jYWxsKHRoaXMsITEpLGEpe2E9dGhpcy5jaGlsZE5vZGVzO2Zvcih2YXIgYz0wLGQ7YzxhLmxlbmd0aDtjKyspZD1hW2NdLmNsb25lTm9kZSghMCksXG5iLmFwcGVuZENoaWxkKGQpfXJldHVybiBifSxnZXRSb290Tm9kZTpmdW5jdGlvbigpe3JldHVybiBJYyh0aGlzKX0sY29udGFpbnM6ZnVuY3Rpb24oYSl7cmV0dXJuIENiKHRoaXMsYSl9LGdldCBpc0Nvbm5lY3RlZCgpe3ZhciBhPXRoaXMub3duZXJEb2N1bWVudDtpZihCYiYmQS5jb250YWlucy5jYWxsKGEsdGhpcyl8fGEuZG9jdW1lbnRFbGVtZW50JiZBLmNvbnRhaW5zLmNhbGwoYS5kb2N1bWVudEVsZW1lbnQsdGhpcykpcmV0dXJuITA7Zm9yKGE9dGhpczthJiYhKGEgaW5zdGFuY2VvZiBEb2N1bWVudCk7KWE9YS5wYXJlbnROb2RlfHwoYSBpbnN0YW5jZW9mIEc/YS5ob3N0OnZvaWQgMCk7cmV0dXJuISEoYSYmYSBpbnN0YW5jZW9mIERvY3VtZW50KX0sZGlzcGF0Y2hFdmVudDpmdW5jdGlvbihhKXtHYigpO3JldHVybiBBLmRpc3BhdGNoRXZlbnQuY2FsbCh0aGlzLGEpfX0sc2Q9e2dldCBhc3NpZ25lZFNsb3QoKXtyZXR1cm4gcGQodGhpcyl9fSx0ZD17cXVlcnlTZWxlY3RvcjpmdW5jdGlvbihhKXtyZXR1cm4gSmModGhpcyxcbmZ1bmN0aW9uKGIpe3JldHVybiB0Yi5jYWxsKGIsYSl9LGZ1bmN0aW9uKGEpe3JldHVybiEhYX0pWzBdfHxudWxsfSxxdWVyeVNlbGVjdG9yQWxsOmZ1bmN0aW9uKGEpe3JldHVybiBKYyh0aGlzLGZ1bmN0aW9uKGIpe3JldHVybiB0Yi5jYWxsKGIsYSl9KX19LHVkPXthc3NpZ25lZE5vZGVzOmZ1bmN0aW9uKGEpe2lmKFwic2xvdFwiPT09dGhpcy5sb2NhbE5hbWUpe3ZhciBiPXRoaXMuZ2V0Um9vdE5vZGUoKTt6KGIpJiZqZChiKTtyZXR1cm4gdGhpcy5fX3NoYWR5PyhhJiZhLmZsYXR0ZW4/dGhpcy5fX3NoYWR5Lks6dGhpcy5fX3NoYWR5LmFzc2lnbmVkTm9kZXMpfHxbXTpbXX19fSx2ZD12Yih7c2V0QXR0cmlidXRlOmZ1bmN0aW9uKGEsYil7TWModGhpcyxhLGIpfSxyZW1vdmVBdHRyaWJ1dGU6ZnVuY3Rpb24oYSl7QS5yZW1vdmVBdHRyaWJ1dGUuY2FsbCh0aGlzLGEpO0ZjKHRoaXMsYSl9LGF0dGFjaFNoYWRvdzpmdW5jdGlvbihhKXtpZighdGhpcyl0aHJvd1wiTXVzdCBwcm92aWRlIGEgaG9zdC5cIjtcbmlmKCFhKXRocm93XCJOb3QgZW5vdWdoIGFyZ3VtZW50cy5cIjtyZXR1cm4gbmV3IEcoaWQsdGhpcyxhKX0sZ2V0IHNsb3QoKXtyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoXCJzbG90XCIpfSxzZXQgc2xvdChhKXtNYyh0aGlzLFwic2xvdFwiLGEpfSxnZXQgYXNzaWduZWRTbG90KCl7cmV0dXJuIHBkKHRoaXMpfX0sdGQsdWQpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHZkLHFjKTt2YXIgd2Q9dmIoe2ltcG9ydE5vZGU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gTmMoYSxiKX0sZ2V0RWxlbWVudEJ5SWQ6ZnVuY3Rpb24oYSl7cmV0dXJuIEpjKHRoaXMsZnVuY3Rpb24oYil7cmV0dXJuIGIuaWQ9PWF9LGZ1bmN0aW9uKGEpe3JldHVybiEhYX0pWzBdfHxudWxsfX0sdGQpO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHdkLHtfYWN0aXZlRWxlbWVudDpyYy5hY3RpdmVFbGVtZW50fSk7XG52YXIgeGQ9SFRNTEVsZW1lbnQucHJvdG90eXBlLmJsdXIseWQ9dmIoe2JsdXI6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5yb290OyhhPWEmJmEuYWN0aXZlRWxlbWVudCk/YS5ibHVyKCk6eGQuY2FsbCh0aGlzKX19KTtmdW5jdGlvbiBIKGEsYil7Zm9yKHZhciBjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGIpLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXSxmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYixlKTtmLnZhbHVlP2FbZV09Zi52YWx1ZTpPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxlLGYpfX07aWYoeS50YSl7dmFyIFNoYWR5RE9NPXtpblVzZTp5LnRhLHBhdGNoOmZ1bmN0aW9uKGEpe3JldHVybiBhfSxpc1NoYWR5Um9vdDp6LGVucXVldWU6RmIsZmx1c2g6R2Isc2V0dGluZ3M6eSxmaWx0ZXJNdXRhdGlvbnM6TWIsb2JzZXJ2ZUNoaWxkcmVuOktiLHVub2JzZXJ2ZUNoaWxkcmVuOkxiLG5hdGl2ZU1ldGhvZHM6QSxuYXRpdmVUcmVlOkJ9O3dpbmRvdy5TaGFkeURPTT1TaGFkeURPTTt3aW5kb3cuRXZlbnQ9Y2Q7d2luZG93LkN1c3RvbUV2ZW50PWRkO3dpbmRvdy5Nb3VzZUV2ZW50PWVkO2JkKCk7dmFyIHpkPXdpbmRvdy5jdXN0b21FbGVtZW50cyYmd2luZG93LmN1c3RvbUVsZW1lbnRzLm5hdGl2ZUhUTUxFbGVtZW50fHxIVE1MRWxlbWVudDtIKHdpbmRvdy5Ob2RlLnByb3RvdHlwZSxyZCk7SCh3aW5kb3cuV2luZG93LnByb3RvdHlwZSxxZCk7SCh3aW5kb3cuVGV4dC5wcm90b3R5cGUsc2QpO0god2luZG93LkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLHRkKTtIKHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZSxcbnZkKTtIKHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUsd2QpO3dpbmRvdy5IVE1MU2xvdEVsZW1lbnQmJkgod2luZG93LkhUTUxTbG90RWxlbWVudC5wcm90b3R5cGUsdWQpO0goemQucHJvdG90eXBlLHlkKTt5Lk0mJihGKHdpbmRvdy5Ob2RlLnByb3RvdHlwZSksRih3aW5kb3cuVGV4dC5wcm90b3R5cGUpLEYod2luZG93LkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlKSxGKHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZSksRih6ZC5wcm90b3R5cGUpLEYod2luZG93LkRvY3VtZW50LnByb3RvdHlwZSksd2luZG93LkhUTUxTbG90RWxlbWVudCYmRih3aW5kb3cuSFRNTFNsb3RFbGVtZW50LnByb3RvdHlwZSkpO3dpbmRvdy5TaGFkb3dSb290PUd9O3ZhciBBZD1uZXcgU2V0KFwiYW5ub3RhdGlvbi14bWwgY29sb3ItcHJvZmlsZSBmb250LWZhY2UgZm9udC1mYWNlLXNyYyBmb250LWZhY2UtdXJpIGZvbnQtZmFjZS1mb3JtYXQgZm9udC1mYWNlLW5hbWUgbWlzc2luZy1nbHlwaFwiLnNwbGl0KFwiIFwiKSk7ZnVuY3Rpb24gQmQoYSl7dmFyIGI9QWQuaGFzKGEpO2E9L15bYS16XVsuMC05X2Etel0qLVtcXC0uMC05X2Etel0qJC8udGVzdChhKTtyZXR1cm4hYiYmYX1mdW5jdGlvbiBKKGEpe3ZhciBiPWEuaXNDb25uZWN0ZWQ7aWYodm9pZCAwIT09YilyZXR1cm4gYjtmb3IoO2EmJiEoYS5fX0NFX2lzSW1wb3J0RG9jdW1lbnR8fGEgaW5zdGFuY2VvZiBEb2N1bWVudCk7KWE9YS5wYXJlbnROb2RlfHwod2luZG93LlNoYWRvd1Jvb3QmJmEgaW5zdGFuY2VvZiBTaGFkb3dSb290P2EuaG9zdDp2b2lkIDApO3JldHVybiEoIWF8fCEoYS5fX0NFX2lzSW1wb3J0RG9jdW1lbnR8fGEgaW5zdGFuY2VvZiBEb2N1bWVudCkpfVxuZnVuY3Rpb24gQ2QoYSxiKXtmb3IoO2ImJmIhPT1hJiYhYi5uZXh0U2libGluZzspYj1iLnBhcmVudE5vZGU7cmV0dXJuIGImJmIhPT1hP2IubmV4dFNpYmxpbmc6bnVsbH1cbmZ1bmN0aW9uIEsoYSxiLGMpe2M9dm9pZCAwPT09Yz9uZXcgU2V0OmM7Zm9yKHZhciBkPWE7ZDspe2lmKGQubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSl7dmFyIGU9ZDtiKGUpO3ZhciBmPWUubG9jYWxOYW1lO2lmKFwibGlua1wiPT09ZiYmXCJpbXBvcnRcIj09PWUuZ2V0QXR0cmlidXRlKFwicmVsXCIpKXtkPWUuaW1wb3J0O2lmKGQgaW5zdGFuY2VvZiBOb2RlJiYhYy5oYXMoZCkpZm9yKGMuYWRkKGQpLGQ9ZC5maXJzdENoaWxkO2Q7ZD1kLm5leHRTaWJsaW5nKUsoZCxiLGMpO2Q9Q2QoYSxlKTtjb250aW51ZX1lbHNlIGlmKFwidGVtcGxhdGVcIj09PWYpe2Q9Q2QoYSxlKTtjb250aW51ZX1pZihlPWUuX19DRV9zaGFkb3dSb290KWZvcihlPWUuZmlyc3RDaGlsZDtlO2U9ZS5uZXh0U2libGluZylLKGUsYixjKX1kPWQuZmlyc3RDaGlsZD9kLmZpcnN0Q2hpbGQ6Q2QoYSxkKX19ZnVuY3Rpb24gTChhLGIsYyl7YVtiXT1jfTtmdW5jdGlvbiBEZCgpe3RoaXMuYT1uZXcgTWFwO3RoaXMubz1uZXcgTWFwO3RoaXMuaD1bXTt0aGlzLmM9ITF9ZnVuY3Rpb24gRWQoYSxiLGMpe2EuYS5zZXQoYixjKTthLm8uc2V0KGMuY29uc3RydWN0b3IsYyl9ZnVuY3Rpb24gRmQoYSxiKXthLmM9ITA7YS5oLnB1c2goYil9ZnVuY3Rpb24gR2QoYSxiKXthLmMmJksoYixmdW5jdGlvbihiKXtyZXR1cm4gYS5iKGIpfSl9RGQucHJvdG90eXBlLmI9ZnVuY3Rpb24oYSl7aWYodGhpcy5jJiYhYS5fX0NFX3BhdGNoZWQpe2EuX19DRV9wYXRjaGVkPSEwO2Zvcih2YXIgYj0wO2I8dGhpcy5oLmxlbmd0aDtiKyspdGhpcy5oW2JdKGEpfX07ZnVuY3Rpb24gTShhLGIpe3ZhciBjPVtdO0soYixmdW5jdGlvbihhKXtyZXR1cm4gYy5wdXNoKGEpfSk7Zm9yKGI9MDtiPGMubGVuZ3RoO2IrKyl7dmFyIGQ9Y1tiXTsxPT09ZC5fX0NFX3N0YXRlP2EuY29ubmVjdGVkQ2FsbGJhY2soZCk6SGQoYSxkKX19XG5mdW5jdGlvbiBOKGEsYil7dmFyIGM9W107SyhiLGZ1bmN0aW9uKGEpe3JldHVybiBjLnB1c2goYSl9KTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdOzE9PT1kLl9fQ0Vfc3RhdGUmJmEuZGlzY29ubmVjdGVkQ2FsbGJhY2soZCl9fVxuZnVuY3Rpb24gTyhhLGIsYyl7Yz12b2lkIDA9PT1jP3t9OmM7dmFyIGQ9Yy4kYXx8bmV3IFNldCxlPWMud2F8fGZ1bmN0aW9uKGIpe3JldHVybiBIZChhLGIpfSxmPVtdO0soYixmdW5jdGlvbihiKXtpZihcImxpbmtcIj09PWIubG9jYWxOYW1lJiZcImltcG9ydFwiPT09Yi5nZXRBdHRyaWJ1dGUoXCJyZWxcIikpe3ZhciBjPWIuaW1wb3J0O2MgaW5zdGFuY2VvZiBOb2RlJiYoYy5fX0NFX2lzSW1wb3J0RG9jdW1lbnQ9ITAsYy5fX0NFX2hhc1JlZ2lzdHJ5PSEwKTtjJiZcImNvbXBsZXRlXCI9PT1jLnJlYWR5U3RhdGU/Yy5fX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQ9ITA6Yi5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGZ1bmN0aW9uKCl7dmFyIGM9Yi5pbXBvcnQ7aWYoIWMuX19DRV9kb2N1bWVudExvYWRIYW5kbGVkKXtjLl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZD0hMDt2YXIgZj1uZXcgU2V0KGQpO2YuZGVsZXRlKGMpO08oYSxjLHskYTpmLHdhOmV9KX19KX1lbHNlIGYucHVzaChiKX0sZCk7aWYoYS5jKWZvcihiPVxuMDtiPGYubGVuZ3RoO2IrKylhLmIoZltiXSk7Zm9yKGI9MDtiPGYubGVuZ3RoO2IrKyllKGZbYl0pfVxuZnVuY3Rpb24gSGQoYSxiKXtpZih2b2lkIDA9PT1iLl9fQ0Vfc3RhdGUpe3ZhciBjPWIub3duZXJEb2N1bWVudDtpZihjLmRlZmF1bHRWaWV3fHxjLl9fQ0VfaXNJbXBvcnREb2N1bWVudCYmYy5fX0NFX2hhc1JlZ2lzdHJ5KWlmKGM9YS5hLmdldChiLmxvY2FsTmFtZSkpe2MuY29uc3RydWN0aW9uU3RhY2sucHVzaChiKTt2YXIgZD1jLmNvbnN0cnVjdG9yO3RyeXt0cnl7aWYobmV3IGQhPT1iKXRocm93IEVycm9yKFwiVGhlIGN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9yIGRpZCBub3QgcHJvZHVjZSB0aGUgZWxlbWVudCBiZWluZyB1cGdyYWRlZC5cIik7fWZpbmFsbHl7Yy5jb25zdHJ1Y3Rpb25TdGFjay5wb3AoKX19Y2F0Y2goaCl7dGhyb3cgYi5fX0NFX3N0YXRlPTIsaDt9Yi5fX0NFX3N0YXRlPTE7Yi5fX0NFX2RlZmluaXRpb249YztpZihjLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaylmb3IoYz1jLm9ic2VydmVkQXR0cmlidXRlcyxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sXG5mPWIuZ2V0QXR0cmlidXRlKGUpO251bGwhPT1mJiZhLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhiLGUsbnVsbCxmLG51bGwpfUooYikmJmEuY29ubmVjdGVkQ2FsbGJhY2soYil9fX1EZC5wcm90b3R5cGUuY29ubmVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oYSl7dmFyIGI9YS5fX0NFX2RlZmluaXRpb247Yi5jb25uZWN0ZWRDYWxsYmFjayYmYi5jb25uZWN0ZWRDYWxsYmFjay5jYWxsKGEpfTtEZC5wcm90b3R5cGUuZGlzY29ubmVjdGVkQ2FsbGJhY2s9ZnVuY3Rpb24oYSl7dmFyIGI9YS5fX0NFX2RlZmluaXRpb247Yi5kaXNjb25uZWN0ZWRDYWxsYmFjayYmYi5kaXNjb25uZWN0ZWRDYWxsYmFjay5jYWxsKGEpfTtcbkRkLnByb3RvdHlwZS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s9ZnVuY3Rpb24oYSxiLGMsZCxlKXt2YXIgZj1hLl9fQ0VfZGVmaW5pdGlvbjtmLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayYmLTE8Zi5vYnNlcnZlZEF0dHJpYnV0ZXMuaW5kZXhPZihiKSYmZi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2suY2FsbChhLGIsYyxkLGUpfTtmdW5jdGlvbiBJZChhKXt2YXIgYj1kb2N1bWVudDt0aGlzLmo9YTt0aGlzLmE9Yjt0aGlzLkM9dm9pZCAwO08odGhpcy5qLHRoaXMuYSk7XCJsb2FkaW5nXCI9PT10aGlzLmEucmVhZHlTdGF0ZSYmKHRoaXMuQz1uZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLmIuYmluZCh0aGlzKSksdGhpcy5DLm9ic2VydmUodGhpcy5hLHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pKX1mdW5jdGlvbiBKZChhKXthLkMmJmEuQy5kaXNjb25uZWN0KCl9SWQucHJvdG90eXBlLmI9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcy5hLnJlYWR5U3RhdGU7XCJpbnRlcmFjdGl2ZVwiIT09YiYmXCJjb21wbGV0ZVwiIT09Ynx8SmQodGhpcyk7Zm9yKGI9MDtiPGEubGVuZ3RoO2IrKylmb3IodmFyIGM9YVtiXS5hZGRlZE5vZGVzLGQ9MDtkPGMubGVuZ3RoO2QrKylPKHRoaXMuaixjW2RdKX07ZnVuY3Rpb24gS2QoKXt2YXIgYT10aGlzO3RoaXMuYj10aGlzLmE9dm9pZCAwO3RoaXMuYz1uZXcgUHJvbWlzZShmdW5jdGlvbihiKXthLmI9YjthLmEmJmIoYS5hKX0pfUtkLnByb3RvdHlwZS5yZXNvbHZlPWZ1bmN0aW9uKGEpe2lmKHRoaXMuYSl0aHJvdyBFcnJvcihcIkFscmVhZHkgcmVzb2x2ZWQuXCIpO3RoaXMuYT1hO3RoaXMuYiYmdGhpcy5iKGEpfTtmdW5jdGlvbiBQKGEpe3RoaXMuZGE9ITE7dGhpcy5qPWE7dGhpcy5oYT1uZXcgTWFwO3RoaXMuZWE9ZnVuY3Rpb24oYSl7cmV0dXJuIGEoKX07dGhpcy5SPSExO3RoaXMuZmE9W107dGhpcy5GYT1uZXcgSWQoYSl9XG5QLnByb3RvdHlwZS5kZWZpbmU9ZnVuY3Rpb24oYSxiKXt2YXIgYz10aGlzO2lmKCEoYiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3JzIG11c3QgYmUgZnVuY3Rpb25zLlwiKTtpZighQmQoYSkpdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIGVsZW1lbnQgbmFtZSAnXCIrYStcIicgaXMgbm90IHZhbGlkLlwiKTtpZih0aGlzLmouYS5nZXQoYSkpdGhyb3cgRXJyb3IoXCJBIGN1c3RvbSBlbGVtZW50IHdpdGggbmFtZSAnXCIrYStcIicgaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkLlwiKTtpZih0aGlzLmRhKXRocm93IEVycm9yKFwiQSBjdXN0b20gZWxlbWVudCBpcyBhbHJlYWR5IGJlaW5nIGRlZmluZWQuXCIpO3RoaXMuZGE9ITA7dHJ5e3ZhciBkPWZ1bmN0aW9uKGEpe3ZhciBiPWVbYV07aWYodm9pZCAwIT09YiYmIShiIGluc3RhbmNlb2YgRnVuY3Rpb24pKXRocm93IEVycm9yKFwiVGhlICdcIithK1wiJyBjYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uXCIpO1xucmV0dXJuIGJ9LGU9Yi5wcm90b3R5cGU7aWYoIShlIGluc3RhbmNlb2YgT2JqZWN0KSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlIGlzIG5vdCBhbiBvYmplY3QuXCIpO3ZhciBmPWQoXCJjb25uZWN0ZWRDYWxsYmFja1wiKTt2YXIgaD1kKFwiZGlzY29ubmVjdGVkQ2FsbGJhY2tcIik7dmFyIGc9ZChcImFkb3B0ZWRDYWxsYmFja1wiKTt2YXIgaz1kKFwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrXCIpO3ZhciBsPWIub2JzZXJ2ZWRBdHRyaWJ1dGVzfHxbXX1jYXRjaChtKXtyZXR1cm59ZmluYWxseXt0aGlzLmRhPSExfWI9e2xvY2FsTmFtZTphLGNvbnN0cnVjdG9yOmIsY29ubmVjdGVkQ2FsbGJhY2s6ZixkaXNjb25uZWN0ZWRDYWxsYmFjazpoLGFkb3B0ZWRDYWxsYmFjazpnLGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjazprLG9ic2VydmVkQXR0cmlidXRlczpsLGNvbnN0cnVjdGlvblN0YWNrOltdfTtFZCh0aGlzLmosYSxiKTt0aGlzLmZhLnB1c2goYik7XG50aGlzLlJ8fCh0aGlzLlI9ITAsdGhpcy5lYShmdW5jdGlvbigpe3JldHVybiBMZChjKX0pKX07ZnVuY3Rpb24gTGQoYSl7aWYoITEhPT1hLlIpe2EuUj0hMTtmb3IodmFyIGI9YS5mYSxjPVtdLGQ9bmV3IE1hcCxlPTA7ZTxiLmxlbmd0aDtlKyspZC5zZXQoYltlXS5sb2NhbE5hbWUsW10pO08oYS5qLGRvY3VtZW50LHt3YTpmdW5jdGlvbihiKXtpZih2b2lkIDA9PT1iLl9fQ0Vfc3RhdGUpe3ZhciBlPWIubG9jYWxOYW1lLGY9ZC5nZXQoZSk7Zj9mLnB1c2goYik6YS5qLmEuZ2V0KGUpJiZjLnB1c2goYil9fX0pO2ZvcihlPTA7ZTxjLmxlbmd0aDtlKyspSGQoYS5qLGNbZV0pO2Zvcig7MDxiLmxlbmd0aDspe3ZhciBmPWIuc2hpZnQoKTtlPWYubG9jYWxOYW1lO2Y9ZC5nZXQoZi5sb2NhbE5hbWUpO2Zvcih2YXIgaD0wO2g8Zi5sZW5ndGg7aCsrKUhkKGEuaixmW2hdKTsoZT1hLmhhLmdldChlKSkmJmUucmVzb2x2ZSh2b2lkIDApfX19XG5QLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oYSl7aWYoYT10aGlzLmouYS5nZXQoYSkpcmV0dXJuIGEuY29uc3RydWN0b3J9O1AucHJvdG90eXBlLndoZW5EZWZpbmVkPWZ1bmN0aW9uKGEpe2lmKCFCZChhKSlyZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IFN5bnRheEVycm9yKFwiJ1wiK2ErXCInIGlzIG5vdCBhIHZhbGlkIGN1c3RvbSBlbGVtZW50IG5hbWUuXCIpKTt2YXIgYj10aGlzLmhhLmdldChhKTtpZihiKXJldHVybiBiLmM7Yj1uZXcgS2Q7dGhpcy5oYS5zZXQoYSxiKTt0aGlzLmouYS5nZXQoYSkmJiF0aGlzLmZhLnNvbWUoZnVuY3Rpb24oYil7cmV0dXJuIGIubG9jYWxOYW1lPT09YX0pJiZiLnJlc29sdmUodm9pZCAwKTtyZXR1cm4gYi5jfTtQLnByb3RvdHlwZS5UYT1mdW5jdGlvbihhKXtKZCh0aGlzLkZhKTt2YXIgYj10aGlzLmVhO3RoaXMuZWE9ZnVuY3Rpb24oYyl7cmV0dXJuIGEoZnVuY3Rpb24oKXtyZXR1cm4gYihjKX0pfX07XG53aW5kb3cuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5PVA7UC5wcm90b3R5cGUuZGVmaW5lPVAucHJvdG90eXBlLmRlZmluZTtQLnByb3RvdHlwZS5nZXQ9UC5wcm90b3R5cGUuZ2V0O1AucHJvdG90eXBlLndoZW5EZWZpbmVkPVAucHJvdG90eXBlLndoZW5EZWZpbmVkO1AucHJvdG90eXBlLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2s9UC5wcm90b3R5cGUuVGE7dmFyIE1kPXdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCxOZD13aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnROUyxPZD13aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGUsUGQ9d2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5wcmVwZW5kLFFkPXdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuYXBwZW5kLFJkPXdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5wcmVwZW5kLFNkPXdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5hcHBlbmQsVGQ9d2luZG93Lk5vZGUucHJvdG90eXBlLmNsb25lTm9kZSxVZD13aW5kb3cuTm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQsVmQ9d2luZG93Lk5vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZSxXZD13aW5kb3cuTm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQsWGQ9d2luZG93Lk5vZGUucHJvdG90eXBlLnJlcGxhY2VDaGlsZCxZZD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5Ob2RlLnByb3RvdHlwZSxcblwidGV4dENvbnRlbnRcIiksWmQ9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdywkZD1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZSxcImlubmVySFRNTFwiKSxhZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlLGJlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUsY2U9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSxkZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuZ2V0QXR0cmlidXRlTlMsZWU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZU5TLGZlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGVOUyxnZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuaW5zZXJ0QWRqYWNlbnRFbGVtZW50LGhlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5wcmVwZW5kLGllPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hcHBlbmQsXG5qZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYmVmb3JlLGtlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hZnRlcixsZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucmVwbGFjZVdpdGgsbWU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZSxuZT13aW5kb3cuSFRNTEVsZW1lbnQsb2U9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLFwiaW5uZXJIVE1MXCIpLHBlPXdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUuaW5zZXJ0QWRqYWNlbnRFbGVtZW50O3ZhciBxZT1uZXcgZnVuY3Rpb24oKXt9O2Z1bmN0aW9uIHJlKCl7dmFyIGE9c2U7d2luZG93LkhUTUxFbGVtZW50PWZ1bmN0aW9uKCl7ZnVuY3Rpb24gYigpe3ZhciBiPXRoaXMuY29uc3RydWN0b3IsZD1hLm8uZ2V0KGIpO2lmKCFkKXRocm93IEVycm9yKFwiVGhlIGN1c3RvbSBlbGVtZW50IGJlaW5nIGNvbnN0cnVjdGVkIHdhcyBub3QgcmVnaXN0ZXJlZCB3aXRoIGBjdXN0b21FbGVtZW50c2AuXCIpO3ZhciBlPWQuY29uc3RydWN0aW9uU3RhY2s7aWYoMD09PWUubGVuZ3RoKXJldHVybiBlPU1kLmNhbGwoZG9jdW1lbnQsZC5sb2NhbE5hbWUpLE9iamVjdC5zZXRQcm90b3R5cGVPZihlLGIucHJvdG90eXBlKSxlLl9fQ0Vfc3RhdGU9MSxlLl9fQ0VfZGVmaW5pdGlvbj1kLGEuYihlKSxlO2Q9ZS5sZW5ndGgtMTt2YXIgZj1lW2RdO2lmKGY9PT1xZSl0aHJvdyBFcnJvcihcIlRoZSBIVE1MRWxlbWVudCBjb25zdHJ1Y3RvciB3YXMgZWl0aGVyIGNhbGxlZCByZWVudHJhbnRseSBmb3IgdGhpcyBjb25zdHJ1Y3RvciBvciBjYWxsZWQgbXVsdGlwbGUgdGltZXMuXCIpO1xuZVtkXT1xZTtPYmplY3Quc2V0UHJvdG90eXBlT2YoZixiLnByb3RvdHlwZSk7YS5iKGYpO3JldHVybiBmfWIucHJvdG90eXBlPW5lLnByb3RvdHlwZTtyZXR1cm4gYn0oKX07ZnVuY3Rpb24gdGUoYSxiLGMpe2Z1bmN0aW9uIGQoYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2Zvcih2YXIgZD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoOysrZSlkW2UtMF09YXJndW1lbnRzW2VdO2U9W107Zm9yKHZhciBmPVtdLGw9MDtsPGQubGVuZ3RoO2wrKyl7dmFyIG09ZFtsXTttIGluc3RhbmNlb2YgRWxlbWVudCYmSihtKSYmZi5wdXNoKG0pO2lmKG0gaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KWZvcihtPW0uZmlyc3RDaGlsZDttO209bS5uZXh0U2libGluZyllLnB1c2gobSk7ZWxzZSBlLnB1c2gobSl9Yi5hcHBseSh0aGlzLGQpO2ZvcihkPTA7ZDxmLmxlbmd0aDtkKyspTihhLGZbZF0pO2lmKEoodGhpcykpZm9yKGQ9MDtkPGUubGVuZ3RoO2QrKylmPWVbZF0sZiBpbnN0YW5jZW9mIEVsZW1lbnQmJk0oYSxmKX19dm9pZCAwIT09Yy5YJiYoYi5wcmVwZW5kPWQoYy5YKSk7dm9pZCAwIT09Yy5hcHBlbmQmJihiLmFwcGVuZD1kKGMuYXBwZW5kKSl9O2Z1bmN0aW9uIHVlKCl7dmFyIGE9c2U7TChEb2N1bWVudC5wcm90b3R5cGUsXCJjcmVhdGVFbGVtZW50XCIsZnVuY3Rpb24oYil7aWYodGhpcy5fX0NFX2hhc1JlZ2lzdHJ5KXt2YXIgYz1hLmEuZ2V0KGIpO2lmKGMpcmV0dXJuIG5ldyBjLmNvbnN0cnVjdG9yfWI9TWQuY2FsbCh0aGlzLGIpO2EuYihiKTtyZXR1cm4gYn0pO0woRG9jdW1lbnQucHJvdG90eXBlLFwiaW1wb3J0Tm9kZVwiLGZ1bmN0aW9uKGIsYyl7Yj1PZC5jYWxsKHRoaXMsYixjKTt0aGlzLl9fQ0VfaGFzUmVnaXN0cnk/TyhhLGIpOkdkKGEsYik7cmV0dXJuIGJ9KTtMKERvY3VtZW50LnByb3RvdHlwZSxcImNyZWF0ZUVsZW1lbnROU1wiLGZ1bmN0aW9uKGIsYyl7aWYodGhpcy5fX0NFX2hhc1JlZ2lzdHJ5JiYobnVsbD09PWJ8fFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPT09Yikpe3ZhciBkPWEuYS5nZXQoYyk7aWYoZClyZXR1cm4gbmV3IGQuY29uc3RydWN0b3J9Yj1OZC5jYWxsKHRoaXMsYixjKTthLmIoYik7cmV0dXJuIGJ9KTtcbnRlKGEsRG9jdW1lbnQucHJvdG90eXBlLHtYOlBkLGFwcGVuZDpRZH0pfTtmdW5jdGlvbiB2ZSgpe3ZhciBhPXNlO2Z1bmN0aW9uIGIoYixkKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcInRleHRDb250ZW50XCIse2VudW1lcmFibGU6ZC5lbnVtZXJhYmxlLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZC5nZXQsc2V0OmZ1bmN0aW9uKGIpe2lmKHRoaXMubm9kZVR5cGU9PT1Ob2RlLlRFWFRfTk9ERSlkLnNldC5jYWxsKHRoaXMsYik7ZWxzZXt2YXIgYz12b2lkIDA7aWYodGhpcy5maXJzdENoaWxkKXt2YXIgZT10aGlzLmNoaWxkTm9kZXMsZz1lLmxlbmd0aDtpZigwPGcmJkoodGhpcykpe2M9QXJyYXkoZyk7Zm9yKHZhciBrPTA7azxnO2srKyljW2tdPWVba119fWQuc2V0LmNhbGwodGhpcyxiKTtpZihjKWZvcihiPTA7YjxjLmxlbmd0aDtiKyspTihhLGNbYl0pfX19KX1MKE5vZGUucHJvdG90eXBlLFwiaW5zZXJ0QmVmb3JlXCIsZnVuY3Rpb24oYixkKXtpZihiIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGIuY2hpbGROb2Rlcyk7XG5iPVZkLmNhbGwodGhpcyxiLGQpO2lmKEoodGhpcykpZm9yKGQ9MDtkPGMubGVuZ3RoO2QrKylNKGEsY1tkXSk7cmV0dXJuIGJ9Yz1KKGIpO2Q9VmQuY2FsbCh0aGlzLGIsZCk7YyYmTihhLGIpO0oodGhpcykmJk0oYSxiKTtyZXR1cm4gZH0pO0woTm9kZS5wcm90b3R5cGUsXCJhcHBlbmRDaGlsZFwiLGZ1bmN0aW9uKGIpe2lmKGIgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYi5jaGlsZE5vZGVzKTtiPVVkLmNhbGwodGhpcyxiKTtpZihKKHRoaXMpKWZvcih2YXIgZT0wO2U8Yy5sZW5ndGg7ZSsrKU0oYSxjW2VdKTtyZXR1cm4gYn1jPUooYik7ZT1VZC5jYWxsKHRoaXMsYik7YyYmTihhLGIpO0oodGhpcykmJk0oYSxiKTtyZXR1cm4gZX0pO0woTm9kZS5wcm90b3R5cGUsXCJjbG9uZU5vZGVcIixmdW5jdGlvbihiKXtiPVRkLmNhbGwodGhpcyxiKTt0aGlzLm93bmVyRG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeT9PKGEsYik6XG5HZChhLGIpO3JldHVybiBifSk7TChOb2RlLnByb3RvdHlwZSxcInJlbW92ZUNoaWxkXCIsZnVuY3Rpb24oYil7dmFyIGM9SihiKSxlPVdkLmNhbGwodGhpcyxiKTtjJiZOKGEsYik7cmV0dXJuIGV9KTtMKE5vZGUucHJvdG90eXBlLFwicmVwbGFjZUNoaWxkXCIsZnVuY3Rpb24oYixkKXtpZihiIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGIuY2hpbGROb2Rlcyk7Yj1YZC5jYWxsKHRoaXMsYixkKTtpZihKKHRoaXMpKWZvcihOKGEsZCksZD0wO2Q8Yy5sZW5ndGg7ZCsrKU0oYSxjW2RdKTtyZXR1cm4gYn1jPUooYik7dmFyIGY9WGQuY2FsbCh0aGlzLGIsZCksaD1KKHRoaXMpO2gmJk4oYSxkKTtjJiZOKGEsYik7aCYmTShhLGIpO3JldHVybiBmfSk7WWQmJllkLmdldD9iKE5vZGUucHJvdG90eXBlLFlkKTpGZChhLGZ1bmN0aW9uKGEpe2IoYSx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7Zm9yKHZhciBhPVxuW10sYj0wO2I8dGhpcy5jaGlsZE5vZGVzLmxlbmd0aDtiKyspYS5wdXNoKHRoaXMuY2hpbGROb2Rlc1tiXS50ZXh0Q29udGVudCk7cmV0dXJuIGEuam9pbihcIlwiKX0sc2V0OmZ1bmN0aW9uKGEpe2Zvcig7dGhpcy5maXJzdENoaWxkOylXZC5jYWxsKHRoaXMsdGhpcy5maXJzdENoaWxkKTtVZC5jYWxsKHRoaXMsZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYSkpfX0pfSl9O2Z1bmN0aW9uIHdlKGEpe3ZhciBiPUVsZW1lbnQucHJvdG90eXBlO2Z1bmN0aW9uIGMoYil7cmV0dXJuIGZ1bmN0aW9uKGMpe2Zvcih2YXIgZD1bXSxlPTA7ZTxhcmd1bWVudHMubGVuZ3RoOysrZSlkW2UtMF09YXJndW1lbnRzW2VdO2U9W107Zm9yKHZhciBnPVtdLGs9MDtrPGQubGVuZ3RoO2srKyl7dmFyIGw9ZFtrXTtsIGluc3RhbmNlb2YgRWxlbWVudCYmSihsKSYmZy5wdXNoKGwpO2lmKGwgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KWZvcihsPWwuZmlyc3RDaGlsZDtsO2w9bC5uZXh0U2libGluZyllLnB1c2gobCk7ZWxzZSBlLnB1c2gobCl9Yi5hcHBseSh0aGlzLGQpO2ZvcihkPTA7ZDxnLmxlbmd0aDtkKyspTihhLGdbZF0pO2lmKEoodGhpcykpZm9yKGQ9MDtkPGUubGVuZ3RoO2QrKylnPWVbZF0sZyBpbnN0YW5jZW9mIEVsZW1lbnQmJk0oYSxnKX19dm9pZCAwIT09amUmJihiLmJlZm9yZT1jKGplKSk7dm9pZCAwIT09amUmJihiLmFmdGVyPWMoa2UpKTt2b2lkIDAhPT1cbmxlJiZMKGIsXCJyZXBsYWNlV2l0aFwiLGZ1bmN0aW9uKGIpe2Zvcih2YXIgYz1bXSxkPTA7ZDxhcmd1bWVudHMubGVuZ3RoOysrZCljW2QtMF09YXJndW1lbnRzW2RdO2Q9W107Zm9yKHZhciBoPVtdLGc9MDtnPGMubGVuZ3RoO2crKyl7dmFyIGs9Y1tnXTtrIGluc3RhbmNlb2YgRWxlbWVudCYmSihrKSYmaC5wdXNoKGspO2lmKGsgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KWZvcihrPWsuZmlyc3RDaGlsZDtrO2s9ay5uZXh0U2libGluZylkLnB1c2goayk7ZWxzZSBkLnB1c2goayl9Zz1KKHRoaXMpO2xlLmFwcGx5KHRoaXMsYyk7Zm9yKGM9MDtjPGgubGVuZ3RoO2MrKylOKGEsaFtjXSk7aWYoZylmb3IoTihhLHRoaXMpLGM9MDtjPGQubGVuZ3RoO2MrKyloPWRbY10saCBpbnN0YW5jZW9mIEVsZW1lbnQmJk0oYSxoKX0pO3ZvaWQgMCE9PW1lJiZMKGIsXCJyZW1vdmVcIixmdW5jdGlvbigpe3ZhciBiPUoodGhpcyk7bWUuY2FsbCh0aGlzKTtiJiZOKGEsdGhpcyl9KX07ZnVuY3Rpb24geGUoKXt2YXIgYT1zZTtmdW5jdGlvbiBiKGIsYyl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJpbm5lckhUTUxcIix7ZW51bWVyYWJsZTpjLmVudW1lcmFibGUsY29uZmlndXJhYmxlOiEwLGdldDpjLmdldCxzZXQ6ZnVuY3Rpb24oYil7dmFyIGQ9dGhpcyxlPXZvaWQgMDtKKHRoaXMpJiYoZT1bXSxLKHRoaXMsZnVuY3Rpb24oYSl7YSE9PWQmJmUucHVzaChhKX0pKTtjLnNldC5jYWxsKHRoaXMsYik7aWYoZSlmb3IodmFyIGY9MDtmPGUubGVuZ3RoO2YrKyl7dmFyIGw9ZVtmXTsxPT09bC5fX0NFX3N0YXRlJiZhLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGwpfXRoaXMub3duZXJEb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5P08oYSx0aGlzKTpHZChhLHRoaXMpO3JldHVybiBifX0pfWZ1bmN0aW9uIGMoYixjKXtMKGIsXCJpbnNlcnRBZGphY2VudEVsZW1lbnRcIixmdW5jdGlvbihiLGQpe3ZhciBlPUooZCk7Yj1jLmNhbGwodGhpcyxiLGQpO2UmJk4oYSxkKTtKKGIpJiZNKGEsZCk7XG5yZXR1cm4gYn0pfVpkJiZMKEVsZW1lbnQucHJvdG90eXBlLFwiYXR0YWNoU2hhZG93XCIsZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMuX19DRV9zaGFkb3dSb290PWE9WmQuY2FsbCh0aGlzLGEpfSk7JGQmJiRkLmdldD9iKEVsZW1lbnQucHJvdG90eXBlLCRkKTpvZSYmb2UuZ2V0P2IoSFRNTEVsZW1lbnQucHJvdG90eXBlLG9lKTpGZChhLGZ1bmN0aW9uKGEpe2IoYSx7ZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFRkLmNhbGwodGhpcywhMCkuaW5uZXJIVE1MfSxzZXQ6ZnVuY3Rpb24oYSl7dmFyIGI9XCJ0ZW1wbGF0ZVwiPT09dGhpcy5sb2NhbE5hbWUsYz1iP3RoaXMuY29udGVudDp0aGlzLGQ9TWQuY2FsbChkb2N1bWVudCx0aGlzLmxvY2FsTmFtZSk7Zm9yKGQuaW5uZXJIVE1MPWE7MDxjLmNoaWxkTm9kZXMubGVuZ3RoOylXZC5jYWxsKGMsYy5jaGlsZE5vZGVzWzBdKTtmb3IoYT1iP2QuY29udGVudDpkOzA8YS5jaGlsZE5vZGVzLmxlbmd0aDspVWQuY2FsbChjLFxuYS5jaGlsZE5vZGVzWzBdKX19KX0pO0woRWxlbWVudC5wcm90b3R5cGUsXCJzZXRBdHRyaWJ1dGVcIixmdW5jdGlvbihiLGMpe2lmKDEhPT10aGlzLl9fQ0Vfc3RhdGUpcmV0dXJuIGJlLmNhbGwodGhpcyxiLGMpO3ZhciBkPWFlLmNhbGwodGhpcyxiKTtiZS5jYWxsKHRoaXMsYixjKTtjPWFlLmNhbGwodGhpcyxiKTthLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLGIsZCxjLG51bGwpfSk7TChFbGVtZW50LnByb3RvdHlwZSxcInNldEF0dHJpYnV0ZU5TXCIsZnVuY3Rpb24oYixjLGYpe2lmKDEhPT10aGlzLl9fQ0Vfc3RhdGUpcmV0dXJuIGVlLmNhbGwodGhpcyxiLGMsZik7dmFyIGQ9ZGUuY2FsbCh0aGlzLGIsYyk7ZWUuY2FsbCh0aGlzLGIsYyxmKTtmPWRlLmNhbGwodGhpcyxiLGMpO2EuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsYyxkLGYsYil9KTtMKEVsZW1lbnQucHJvdG90eXBlLFwicmVtb3ZlQXR0cmlidXRlXCIsZnVuY3Rpb24oYil7aWYoMSE9PXRoaXMuX19DRV9zdGF0ZSlyZXR1cm4gY2UuY2FsbCh0aGlzLFxuYik7dmFyIGM9YWUuY2FsbCh0aGlzLGIpO2NlLmNhbGwodGhpcyxiKTtudWxsIT09YyYmYS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcyxiLGMsbnVsbCxudWxsKX0pO0woRWxlbWVudC5wcm90b3R5cGUsXCJyZW1vdmVBdHRyaWJ1dGVOU1wiLGZ1bmN0aW9uKGIsYyl7aWYoMSE9PXRoaXMuX19DRV9zdGF0ZSlyZXR1cm4gZmUuY2FsbCh0aGlzLGIsYyk7dmFyIGQ9ZGUuY2FsbCh0aGlzLGIsYyk7ZmUuY2FsbCh0aGlzLGIsYyk7dmFyIGU9ZGUuY2FsbCh0aGlzLGIsYyk7ZCE9PWUmJmEuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsYyxkLGUsYil9KTtwZT9jKEhUTUxFbGVtZW50LnByb3RvdHlwZSxwZSk6Z2U/YyhFbGVtZW50LnByb3RvdHlwZSxnZSk6Y29uc29sZS53YXJuKFwiQ3VzdG9tIEVsZW1lbnRzOiBgRWxlbWVudCNpbnNlcnRBZGphY2VudEVsZW1lbnRgIHdhcyBub3QgcGF0Y2hlZC5cIik7dGUoYSxFbGVtZW50LnByb3RvdHlwZSx7WDpoZSxhcHBlbmQ6aWV9KTt3ZShhKX1cbjt2YXIgeWU9d2luZG93LmN1c3RvbUVsZW1lbnRzO2lmKCF5ZXx8eWUuZm9yY2VQb2x5ZmlsbHx8XCJmdW5jdGlvblwiIT10eXBlb2YgeWUuZGVmaW5lfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB5ZS5nZXQpe3ZhciBzZT1uZXcgRGQ7cmUoKTt1ZSgpO3RlKHNlLERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLHtYOlJkLGFwcGVuZDpTZH0pO3ZlKCk7eGUoKTtkb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5PSEwO3ZhciBjdXN0b21FbGVtZW50cz1uZXcgUChzZSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdyxcImN1c3RvbUVsZW1lbnRzXCIse2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLHZhbHVlOmN1c3RvbUVsZW1lbnRzfSl9O2Z1bmN0aW9uIHplKCl7dGhpcy5lbmQ9dGhpcy5zdGFydD0wO3RoaXMucnVsZXM9dGhpcy5wYXJlbnQ9dGhpcy5wcmV2aW91cz1udWxsO3RoaXMuY3NzVGV4dD10aGlzLnBhcnNlZENzc1RleHQ9XCJcIjt0aGlzLmF0UnVsZT0hMTt0aGlzLnR5cGU9MDt0aGlzLnBhcnNlZFNlbGVjdG9yPXRoaXMuc2VsZWN0b3I9dGhpcy5rZXlmcmFtZXNOYW1lPVwiXCJ9XG5mdW5jdGlvbiBBZShhKXthPWEucmVwbGFjZShCZSxcIlwiKS5yZXBsYWNlKENlLFwiXCIpO3ZhciBiPURlLGM9YSxkPW5ldyB6ZTtkLnN0YXJ0PTA7ZC5lbmQ9Yy5sZW5ndGg7Zm9yKHZhciBlPWQsZj0wLGg9Yy5sZW5ndGg7ZjxoO2YrKylpZihcIntcIj09PWNbZl0pe2UucnVsZXN8fChlLnJ1bGVzPVtdKTt2YXIgZz1lLGs9Zy5ydWxlc1tnLnJ1bGVzLmxlbmd0aC0xXXx8bnVsbDtlPW5ldyB6ZTtlLnN0YXJ0PWYrMTtlLnBhcmVudD1nO2UucHJldmlvdXM9aztnLnJ1bGVzLnB1c2goZSl9ZWxzZVwifVwiPT09Y1tmXSYmKGUuZW5kPWYrMSxlPWUucGFyZW50fHxkKTtyZXR1cm4gYihkLGEpfVxuZnVuY3Rpb24gRGUoYSxiKXt2YXIgYz1iLnN1YnN0cmluZyhhLnN0YXJ0LGEuZW5kLTEpO2EucGFyc2VkQ3NzVGV4dD1hLmNzc1RleHQ9Yy50cmltKCk7YS5wYXJlbnQmJihjPWIuc3Vic3RyaW5nKGEucHJldmlvdXM/YS5wcmV2aW91cy5lbmQ6YS5wYXJlbnQuc3RhcnQsYS5zdGFydC0xKSxjPUVlKGMpLGM9Yy5yZXBsYWNlKEZlLFwiIFwiKSxjPWMuc3Vic3RyaW5nKGMubGFzdEluZGV4T2YoXCI7XCIpKzEpLGM9YS5wYXJzZWRTZWxlY3Rvcj1hLnNlbGVjdG9yPWMudHJpbSgpLGEuYXRSdWxlPTA9PT1jLmluZGV4T2YoXCJAXCIpLGEuYXRSdWxlPzA9PT1jLmluZGV4T2YoXCJAbWVkaWFcIik/YS50eXBlPUplOmMubWF0Y2goS2UpJiYoYS50eXBlPUxlLGEua2V5ZnJhbWVzTmFtZT1hLnNlbGVjdG9yLnNwbGl0KEZlKS5wb3AoKSk6YS50eXBlPTA9PT1jLmluZGV4T2YoXCItLVwiKT9NZTpOZSk7aWYoYz1hLnJ1bGVzKWZvcih2YXIgZD0wLGU9Yy5sZW5ndGgsZjtkPGUmJihmPWNbZF0pO2QrKylEZShmLFxuYik7cmV0dXJuIGF9ZnVuY3Rpb24gRWUoYSl7cmV0dXJuIGEucmVwbGFjZSgvXFxcXChbMC05YS1mXXsxLDZ9KVxccy9naSxmdW5jdGlvbihhLGMpe2E9Yztmb3IoYz02LWEubGVuZ3RoO2MtLTspYT1cIjBcIithO3JldHVyblwiXFxcXFwiK2F9KX1cbmZ1bmN0aW9uIE9lKGEsYixjKXtjPXZvaWQgMD09PWM/XCJcIjpjO3ZhciBkPVwiXCI7aWYoYS5jc3NUZXh0fHxhLnJ1bGVzKXt2YXIgZT1hLnJ1bGVzLGY7aWYoZj1lKWY9ZVswXSxmPSEoZiYmZi5zZWxlY3RvciYmMD09PWYuc2VsZWN0b3IuaW5kZXhPZihcIi0tXCIpKTtpZihmKXtmPTA7Zm9yKHZhciBoPWUubGVuZ3RoLGc7ZjxoJiYoZz1lW2ZdKTtmKyspZD1PZShnLGIsZCl9ZWxzZSBiP2I9YS5jc3NUZXh0OihiPWEuY3NzVGV4dCxiPWIucmVwbGFjZShQZSxcIlwiKS5yZXBsYWNlKFFlLFwiXCIpLGI9Yi5yZXBsYWNlKFJlLFwiXCIpLnJlcGxhY2UoU2UsXCJcIikpLChkPWIudHJpbSgpKSYmKGQ9XCIgIFwiK2QrXCJcXG5cIil9ZCYmKGEuc2VsZWN0b3ImJihjKz1hLnNlbGVjdG9yK1wiIHtcXG5cIiksYys9ZCxhLnNlbGVjdG9yJiYoYys9XCJ9XFxuXFxuXCIpKTtyZXR1cm4gY31cbnZhciBOZT0xLExlPTcsSmU9NCxNZT0xRTMsQmU9L1xcL1xcKlteKl0qXFwqKyhbXi8qXVteKl0qXFwqKykqXFwvL2dpbSxDZT0vQGltcG9ydFteO10qOy9naW0sUGU9Lyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj8oPzpbO1xcbl18JCkvZ2ltLFFlPS8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/e1tefV0qP30oPzpbO1xcbl18JCk/L2dpbSxSZT0vQGFwcGx5XFxzKlxcKD9bXik7XSpcXCk/XFxzKig/Ols7XFxuXXwkKT8vZ2ltLFNlPS9bXjs6XSo/OlteO10qP3ZhclxcKFteO10qXFwpKD86WztcXG5dfCQpPy9naW0sS2U9L15AW15cXHNdKmtleWZyYW1lcy8sRmU9L1xccysvZzt2YXIgUT0hKHdpbmRvdy5TaGFkeURPTSYmd2luZG93LlNoYWR5RE9NLmluVXNlKSxUZTtmdW5jdGlvbiBVZShhKXtUZT1hJiZhLnNoaW1jc3Nwcm9wZXJ0aWVzPyExOlF8fCEobmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC82MDF8RWRnZVxcLzE1Lyl8fCF3aW5kb3cuQ1NTfHwhQ1NTLnN1cHBvcnRzfHwhQ1NTLnN1cHBvcnRzKFwiYm94LXNoYWRvd1wiLFwiMCAwIDAgdmFyKC0tZm9vKVwiKSl9d2luZG93LlNoYWR5Q1NTJiZ2b2lkIDAhPT13aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzP1RlPXdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3M6d2luZG93LlNoYWR5Q1NTPyhVZSh3aW5kb3cuU2hhZHlDU1MpLHdpbmRvdy5TaGFkeUNTUz12b2lkIDApOlVlKHdpbmRvdy5XZWJDb21wb25lbnRzJiZ3aW5kb3cuV2ViQ29tcG9uZW50cy5mbGFncyk7dmFyIFI9VGU7dmFyIFZlPS8oPzpefFs7XFxze11cXHMqKSgtLVtcXHctXSo/KVxccyo6XFxzKig/OigoPzonKD86XFxcXCd8LikqPyd8XCIoPzpcXFxcXCJ8LikqP1wifFxcKFteKV0qP1xcKXxbXn07e10pKyl8XFx7KFtefV0qKVxcfSg/Oig/PVs7XFxzfV0pfCQpKS9naSxXZT0vKD86XnxcXFcrKUBhcHBseVxccypcXCg/KFteKTtcXG5dKilcXCk/L2dpLFhlPS8oLS1bXFx3LV0rKVxccyooWzosOyldfCQpL2dpLFllPS8oYW5pbWF0aW9uXFxzKjopfChhbmltYXRpb24tbmFtZVxccyo6KS8sWmU9L0BtZWRpYVxccyguKikvLCRlPS9cXHtbXn1dKlxcfS9nO3ZhciBhZj1uZXcgU2V0O2Z1bmN0aW9uIGJmKGEsYil7aWYoIWEpcmV0dXJuXCJcIjtcInN0cmluZ1wiPT09dHlwZW9mIGEmJihhPUFlKGEpKTtiJiZjZihhLGIpO3JldHVybiBPZShhLFIpfWZ1bmN0aW9uIGRmKGEpeyFhLl9fY3NzUnVsZXMmJmEudGV4dENvbnRlbnQmJihhLl9fY3NzUnVsZXM9QWUoYS50ZXh0Q29udGVudCkpO3JldHVybiBhLl9fY3NzUnVsZXN8fG51bGx9ZnVuY3Rpb24gZWYoYSl7cmV0dXJuISFhLnBhcmVudCYmYS5wYXJlbnQudHlwZT09PUxlfWZ1bmN0aW9uIGNmKGEsYixjLGQpe2lmKGEpe3ZhciBlPSExLGY9YS50eXBlO2lmKGQmJmY9PT1KZSl7dmFyIGg9YS5zZWxlY3Rvci5tYXRjaChaZSk7aCYmKHdpbmRvdy5tYXRjaE1lZGlhKGhbMV0pLm1hdGNoZXN8fChlPSEwKSl9Zj09PU5lP2IoYSk6YyYmZj09PUxlP2MoYSk6Zj09PU1lJiYoZT0hMCk7aWYoKGE9YS5ydWxlcykmJiFlKXtlPTA7Zj1hLmxlbmd0aDtmb3IodmFyIGc7ZTxmJiYoZz1hW2VdKTtlKyspY2YoZyxiLGMsZCl9fX1cbmZ1bmN0aW9uIGZmKGEsYixjLGQpe3ZhciBlPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtiJiZlLnNldEF0dHJpYnV0ZShcInNjb3BlXCIsYik7ZS50ZXh0Q29udGVudD1hO2dmKGUsYyxkKTtyZXR1cm4gZX12YXIgUz1udWxsO2Z1bmN0aW9uIGdmKGEsYixjKXtiPWJ8fGRvY3VtZW50LmhlYWQ7Yi5pbnNlcnRCZWZvcmUoYSxjJiZjLm5leHRTaWJsaW5nfHxiLmZpcnN0Q2hpbGQpO1M/YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihTKT09PU5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HJiYoUz1hKTpTPWF9XG5mdW5jdGlvbiBoZihhLGIpe3ZhciBjPWEuaW5kZXhPZihcInZhcihcIik7aWYoLTE9PT1jKXJldHVybiBiKGEsXCJcIixcIlwiLFwiXCIpO2E6e3ZhciBkPTA7dmFyIGU9YyszO2Zvcih2YXIgZj1hLmxlbmd0aDtlPGY7ZSsrKWlmKFwiKFwiPT09YVtlXSlkKys7ZWxzZSBpZihcIilcIj09PWFbZV0mJjA9PT0tLWQpYnJlYWsgYTtlPS0xfWQ9YS5zdWJzdHJpbmcoYys0LGUpO2M9YS5zdWJzdHJpbmcoMCxjKTthPWhmKGEuc3Vic3RyaW5nKGUrMSksYik7ZT1kLmluZGV4T2YoXCIsXCIpO3JldHVybi0xPT09ZT9iKGMsZC50cmltKCksXCJcIixhKTpiKGMsZC5zdWJzdHJpbmcoMCxlKS50cmltKCksZC5zdWJzdHJpbmcoZSsxKS50cmltKCksYSl9ZnVuY3Rpb24gamYoYSxiKXtRP2Euc2V0QXR0cmlidXRlKFwiY2xhc3NcIixiKTp3aW5kb3cuU2hhZHlET00ubmF0aXZlTWV0aG9kcy5zZXRBdHRyaWJ1dGUuY2FsbChhLFwiY2xhc3NcIixiKX1cbmZ1bmN0aW9uIFYoYSl7dmFyIGI9YS5sb2NhbE5hbWUsYz1cIlwiO2I/LTE8Yi5pbmRleE9mKFwiLVwiKXx8KGM9YixiPWEuZ2V0QXR0cmlidXRlJiZhLmdldEF0dHJpYnV0ZShcImlzXCIpfHxcIlwiKTooYj1hLmlzLGM9YS5leHRlbmRzKTtyZXR1cm57aXM6YixQOmN9fTtmdW5jdGlvbiBrZigpe31mdW5jdGlvbiBsZihhLGIsYyl7dmFyIGQ9VzthLl9fc3R5bGVTY29wZWQ/YS5fX3N0eWxlU2NvcGVkPW51bGw6bWYoZCxhLGJ8fFwiXCIsYyl9ZnVuY3Rpb24gbWYoYSxiLGMsZCl7Yi5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZuZihiLGMsZCk7aWYoYj1cInRlbXBsYXRlXCI9PT1iLmxvY2FsTmFtZT8oYi5jb250ZW50fHxiLmdiKS5jaGlsZE5vZGVzOmIuY2hpbGRyZW58fGIuY2hpbGROb2Rlcylmb3IodmFyIGU9MDtlPGIubGVuZ3RoO2UrKyltZihhLGJbZV0sYyxkKX1cbmZ1bmN0aW9uIG5mKGEsYixjKXtpZihiKWlmKGEuY2xhc3NMaXN0KWM/KGEuY2xhc3NMaXN0LnJlbW92ZShcInN0eWxlLXNjb3BlXCIpLGEuY2xhc3NMaXN0LnJlbW92ZShiKSk6KGEuY2xhc3NMaXN0LmFkZChcInN0eWxlLXNjb3BlXCIpLGEuY2xhc3NMaXN0LmFkZChiKSk7ZWxzZSBpZihhLmdldEF0dHJpYnV0ZSl7dmFyIGQ9YS5nZXRBdHRyaWJ1dGUob2YpO2M/ZCYmKGI9ZC5yZXBsYWNlKFwic3R5bGUtc2NvcGVcIixcIlwiKS5yZXBsYWNlKGIsXCJcIiksamYoYSxiKSk6amYoYSwoZD9kK1wiIFwiOlwiXCIpK1wic3R5bGUtc2NvcGUgXCIrYil9fWZ1bmN0aW9uIHBmKGEsYixjKXt2YXIgZD1XLGU9YS5fX2Nzc0J1aWxkO1F8fFwic2hhZHlcIj09PWU/Yj1iZihiLGMpOihhPVYoYSksYj1xZihkLGIsYS5pcyxhLlAsYykrXCJcXG5cXG5cIik7cmV0dXJuIGIudHJpbSgpfVxuZnVuY3Rpb24gcWYoYSxiLGMsZCxlKXt2YXIgZj1yZihjLGQpO2M9Yz9zZitjOlwiXCI7cmV0dXJuIGJmKGIsZnVuY3Rpb24oYil7Yi5jfHwoYi5zZWxlY3Rvcj1iLm09dGYoYSxiLGEuYixjLGYpLGIuYz0hMCk7ZSYmZShiLGMsZil9KX1mdW5jdGlvbiByZihhLGIpe3JldHVybiBiP1wiW2lzPVwiK2ErXCJdXCI6YX1mdW5jdGlvbiB0ZihhLGIsYyxkLGUpe3ZhciBmPWIuc2VsZWN0b3Iuc3BsaXQodWYpO2lmKCFlZihiKSl7Yj0wO2Zvcih2YXIgaD1mLmxlbmd0aCxnO2I8aCYmKGc9ZltiXSk7YisrKWZbYl09Yy5jYWxsKGEsZyxkLGUpfXJldHVybiBmLmpvaW4odWYpfWZ1bmN0aW9uIHZmKGEpe3JldHVybiBhLnJlcGxhY2Uod2YsZnVuY3Rpb24oYSxjLGQpey0xPGQuaW5kZXhPZihcIitcIik/ZD1kLnJlcGxhY2UoL1xcKy9nLFwiX19fXCIpOi0xPGQuaW5kZXhPZihcIl9fX1wiKSYmKGQ9ZC5yZXBsYWNlKC9fX18vZyxcIitcIikpO3JldHVyblwiOlwiK2MrXCIoXCIrZCtcIilcIn0pfVxua2YucHJvdG90eXBlLmI9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPSExO2E9YS50cmltKCk7dmFyIGU9d2YudGVzdChhKTtlJiYoYT1hLnJlcGxhY2Uod2YsZnVuY3Rpb24oYSxiLGMpe3JldHVyblwiOlwiK2IrXCIoXCIrYy5yZXBsYWNlKC9cXHMvZyxcIlwiKStcIilcIn0pLGE9dmYoYSkpO2E9YS5yZXBsYWNlKHhmLHlmK1wiICQxXCIpO2E9YS5yZXBsYWNlKHpmLGZ1bmN0aW9uKGEsZSxnKXtkfHwoYT1BZihnLGUsYixjKSxkPWR8fGEuc3RvcCxlPWEuSmEsZz1hLnZhbHVlKTtyZXR1cm4gZStnfSk7ZSYmKGE9dmYoYSkpO3JldHVybiBhfTtcbmZ1bmN0aW9uIEFmKGEsYixjLGQpe3ZhciBlPWEuaW5kZXhPZihCZik7MDw9YS5pbmRleE9mKHlmKT9hPUNmKGEsZCk6MCE9PWUmJihhPWM/RGYoYSxjKTphKTtjPSExOzA8PWUmJihiPVwiXCIsYz0hMCk7aWYoYyl7dmFyIGY9ITA7YyYmKGE9YS5yZXBsYWNlKEVmLGZ1bmN0aW9uKGEsYil7cmV0dXJuXCIgPiBcIitifSkpfWE9YS5yZXBsYWNlKEZmLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm4nW2Rpcj1cIicrYysnXCJdICcrYitcIiwgXCIrYisnW2Rpcj1cIicrYysnXCJdJ30pO3JldHVybnt2YWx1ZTphLEphOmIsc3RvcDpmfX1mdW5jdGlvbiBEZihhLGIpe2E9YS5zcGxpdChHZik7YVswXSs9YjtyZXR1cm4gYS5qb2luKEdmKX1cbmZ1bmN0aW9uIENmKGEsYil7dmFyIGM9YS5tYXRjaChIZik7cmV0dXJuKGM9YyYmY1syXS50cmltKCl8fFwiXCIpP2NbMF0ubWF0Y2goSWYpP2EucmVwbGFjZShIZixmdW5jdGlvbihhLGMsZil7cmV0dXJuIGIrZn0pOmMuc3BsaXQoSWYpWzBdPT09Yj9jOkpmOmEucmVwbGFjZSh5ZixiKX1mdW5jdGlvbiBLZihhKXthLnNlbGVjdG9yPT09TGYmJihhLnNlbGVjdG9yPVwiaHRtbFwiKX1rZi5wcm90b3R5cGUuYz1mdW5jdGlvbihhKXtyZXR1cm4gYS5tYXRjaChCZik/dGhpcy5iKGEsTWYpOkRmKGEudHJpbSgpLE1mKX07cS5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhrZi5wcm90b3R5cGUse2E6e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVyblwic3R5bGUtc2NvcGVcIn19fSk7XG52YXIgd2Y9LzoobnRoWy1cXHddKylcXCgoW14pXSspXFwpLyxNZj1cIjpub3QoLnN0eWxlLXNjb3BlKVwiLHVmPVwiLFwiLHpmPS8oXnxbXFxzPit+XSspKCg/OlxcWy4rP1xcXXxbXlxccz4rfj1bXSkrKS9nLElmPS9bWy46IypdLyx5Zj1cIjpob3N0XCIsTGY9XCI6cm9vdFwiLEJmPVwiOjpzbG90dGVkXCIseGY9bmV3IFJlZ0V4cChcIl4oXCIrQmYrXCIpXCIpLEhmPS8oOmhvc3QpKD86XFwoKCg/OlxcKFteKShdKlxcKXxbXikoXSopKz8pXFwpKS8sRWY9Lyg/Ojo6c2xvdHRlZCkoPzpcXCgoKD86XFwoW14pKF0qXFwpfFteKShdKikrPylcXCkpLyxGZj0vKC4qKTpkaXJcXCgoPzoobHRyfHJ0bCkpXFwpLyxzZj1cIi5cIixHZj1cIjpcIixvZj1cImNsYXNzXCIsSmY9XCJzaG91bGRfbm90X21hdGNoXCIsVz1uZXcga2Y7ZnVuY3Rpb24gTmYoYSxiLGMsZCl7dGhpcy53PWF8fG51bGw7dGhpcy5iPWJ8fG51bGw7dGhpcy5qYT1jfHxbXTt0aGlzLkc9bnVsbDt0aGlzLlA9ZHx8XCJcIjt0aGlzLmE9dGhpcy51PXRoaXMuQj1udWxsfWZ1bmN0aW9uIFgoYSl7cmV0dXJuIGE/YS5fX3N0eWxlSW5mbzpudWxsfWZ1bmN0aW9uIE9mKGEsYil7cmV0dXJuIGEuX19zdHlsZUluZm89Yn1OZi5wcm90b3R5cGUuYz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnd9O05mLnByb3RvdHlwZS5fZ2V0U3R5bGVSdWxlcz1OZi5wcm90b3R5cGUuYzt2YXIgUGYsUWY9d2luZG93LkVsZW1lbnQucHJvdG90eXBlO1BmPVFmLm1hdGNoZXN8fFFmLm1hdGNoZXNTZWxlY3Rvcnx8UWYubW96TWF0Y2hlc1NlbGVjdG9yfHxRZi5tc01hdGNoZXNTZWxlY3Rvcnx8UWYub01hdGNoZXNTZWxlY3Rvcnx8UWYud2Via2l0TWF0Y2hlc1NlbGVjdG9yO3ZhciBSZj1uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKFwiVHJpZGVudFwiKTtmdW5jdGlvbiBTZigpe31mdW5jdGlvbiBUZihhKXt2YXIgYj17fSxjPVtdLGQ9MDtjZihhLGZ1bmN0aW9uKGEpe1VmKGEpO2EuaW5kZXg9ZCsrO2E9YS5pLmNzc1RleHQ7Zm9yKHZhciBjO2M9WGUuZXhlYyhhKTspe3ZhciBlPWNbMV07XCI6XCIhPT1jWzJdJiYoYltlXT0hMCl9fSxmdW5jdGlvbihhKXtjLnB1c2goYSl9KTthLmI9YzthPVtdO2Zvcih2YXIgZSBpbiBiKWEucHVzaChlKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIFVmKGEpe2lmKCFhLmkpe3ZhciBiPXt9LGM9e307VmYoYSxjKSYmKGIudj1jLGEucnVsZXM9bnVsbCk7Yi5jc3NUZXh0PWEucGFyc2VkQ3NzVGV4dC5yZXBsYWNlKCRlLFwiXCIpLnJlcGxhY2UoVmUsXCJcIik7YS5pPWJ9fWZ1bmN0aW9uIFZmKGEsYil7dmFyIGM9YS5pO2lmKGMpe2lmKGMudilyZXR1cm4gT2JqZWN0LmFzc2lnbihiLGMudiksITB9ZWxzZXtjPWEucGFyc2VkQ3NzVGV4dDtmb3IodmFyIGQ7YT1WZS5leGVjKGMpOyl7ZD0oYVsyXXx8YVszXSkudHJpbSgpO2lmKFwiaW5oZXJpdFwiIT09ZHx8XCJ1bnNldFwiIT09ZCliW2FbMV0udHJpbSgpXT1kO2Q9ITB9cmV0dXJuIGR9fVxuZnVuY3Rpb24gV2YoYSxiLGMpe2ImJihiPTA8PWIuaW5kZXhPZihcIjtcIik/WGYoYSxiLGMpOmhmKGIsZnVuY3Rpb24oYixlLGYsaCl7aWYoIWUpcmV0dXJuIGIraDsoZT1XZihhLGNbZV0sYykpJiZcImluaXRpYWxcIiE9PWU/XCJhcHBseS1zaGltLWluaGVyaXRcIj09PWUmJihlPVwiaW5oZXJpdFwiKTplPVdmKGEsY1tmXXx8ZixjKXx8ZjtyZXR1cm4gYisoZXx8XCJcIikraH0pKTtyZXR1cm4gYiYmYi50cmltKCl8fFwiXCJ9XG5mdW5jdGlvbiBYZihhLGIsYyl7Yj1iLnNwbGl0KFwiO1wiKTtmb3IodmFyIGQ9MCxlLGY7ZDxiLmxlbmd0aDtkKyspaWYoZT1iW2RdKXtXZS5sYXN0SW5kZXg9MDtpZihmPVdlLmV4ZWMoZSkpZT1XZihhLGNbZlsxXV0sYyk7ZWxzZSBpZihmPWUuaW5kZXhPZihcIjpcIiksLTEhPT1mKXt2YXIgaD1lLnN1YnN0cmluZyhmKTtoPWgudHJpbSgpO2g9V2YoYSxoLGMpfHxoO2U9ZS5zdWJzdHJpbmcoMCxmKStofWJbZF09ZSYmZS5sYXN0SW5kZXhPZihcIjtcIik9PT1lLmxlbmd0aC0xP2Uuc2xpY2UoMCwtMSk6ZXx8XCJcIn1yZXR1cm4gYi5qb2luKFwiO1wiKX1cbmZ1bmN0aW9uIFlmKGEsYil7dmFyIGM9e30sZD1bXTtjZihhLGZ1bmN0aW9uKGEpe2EuaXx8VWYoYSk7dmFyIGU9YS5tfHxhLnBhcnNlZFNlbGVjdG9yO2ImJmEuaS52JiZlJiZQZi5jYWxsKGIsZSkmJihWZihhLGMpLGE9YS5pbmRleCxlPXBhcnNlSW50KGEvMzIsMTApLGRbZV09KGRbZV18fDApfDE8PGElMzIpfSxudWxsLCEwKTtyZXR1cm57djpjLGtleTpkfX1cbmZ1bmN0aW9uIFpmKGEsYixjLGQpe2IuaXx8VWYoYik7aWYoYi5pLnYpe3ZhciBlPVYoYSk7YT1lLmlzO2U9ZS5QO2U9YT9yZihhLGUpOlwiaHRtbFwiO3ZhciBmPWIucGFyc2VkU2VsZWN0b3IsaD1cIjpob3N0ID4gKlwiPT09Znx8XCJodG1sXCI9PT1mLGc9MD09PWYuaW5kZXhPZihcIjpob3N0XCIpJiYhaDtcInNoYWR5XCI9PT1jJiYoaD1mPT09ZStcIiA+ICouXCIrZXx8LTEhPT1mLmluZGV4T2YoXCJodG1sXCIpLGc9IWgmJjA9PT1mLmluZGV4T2YoZSkpO1wic2hhZG93XCI9PT1jJiYoaD1cIjpob3N0ID4gKlwiPT09Znx8XCJodG1sXCI9PT1mLGc9ZyYmIWgpO2lmKGh8fGcpYz1lLGcmJihRJiYhYi5tJiYoYi5tPXRmKFcsYixXLmIsYT9zZithOlwiXCIsZSkpLGM9Yi5tfHxlKSxkKHtYYTpjLE9hOmcsaWI6aH0pfX1cbmZ1bmN0aW9uICRmKGEsYil7dmFyIGM9e30sZD17fSxlPWImJmIuX19jc3NCdWlsZDtjZihiLGZ1bmN0aW9uKGIpe1pmKGEsYixlLGZ1bmN0aW9uKGUpe1BmLmNhbGwoYS5oYnx8YSxlLlhhKSYmKGUuT2E/VmYoYixjKTpWZihiLGQpKX0pfSxudWxsLCEwKTtyZXR1cm57VmE6ZCxOYTpjfX1cbmZ1bmN0aW9uIGFnKGEsYixjLGQpe3ZhciBlPVYoYiksZj1yZihlLmlzLGUuUCksaD1uZXcgUmVnRXhwKFwiKD86XnxbXi4jWzpdKVwiKyhiLmV4dGVuZHM/XCJcXFxcXCIrZi5zbGljZSgwLC0xKStcIlxcXFxdXCI6ZikrXCIoJHxbLjpbXFxcXHM+K35dKVwiKTtlPVgoYikudzt2YXIgZz1iZyhlLGQpO3JldHVybiBwZihiLGUsZnVuY3Rpb24oYil7dmFyIGU9XCJcIjtiLml8fFVmKGIpO2IuaS5jc3NUZXh0JiYoZT1YZihhLGIuaS5jc3NUZXh0LGMpKTtiLmNzc1RleHQ9ZTtpZighUSYmIWVmKGIpJiZiLmNzc1RleHQpe3ZhciBrPWU9Yi5jc3NUZXh0O251bGw9PWIucmEmJihiLnJhPVllLnRlc3QoZSkpO2lmKGIucmEpaWYobnVsbD09Yi5XKXtiLlc9W107Zm9yKHZhciBuIGluIGcpaz1nW25dLGs9ayhlKSxlIT09ayYmKGU9ayxiLlcucHVzaChuKSl9ZWxzZXtmb3Iobj0wO248Yi5XLmxlbmd0aDsrK24paz1nW2IuV1tuXV0sZT1rKGUpO2s9ZX1iLmNzc1RleHQ9aztiLm09Yi5tfHxiLnNlbGVjdG9yO2U9XCIuXCIrZDtcbm49Yi5tLnNwbGl0KFwiLFwiKTtrPTA7Zm9yKHZhciB3PW4ubGVuZ3RoLEk7azx3JiYoST1uW2tdKTtrKyspbltrXT1JLm1hdGNoKGgpP0kucmVwbGFjZShmLGUpOmUrXCIgXCIrSTtiLnNlbGVjdG9yPW4uam9pbihcIixcIil9fSl9ZnVuY3Rpb24gYmcoYSxiKXthPWEuYjt2YXIgYz17fTtpZighUSYmYSlmb3IodmFyIGQ9MCxlPWFbZF07ZDxhLmxlbmd0aDtlPWFbKytkXSl7dmFyIGY9ZSxoPWI7Zi5oPW5ldyBSZWdFeHAoZi5rZXlmcmFtZXNOYW1lLFwiZ1wiKTtmLmE9Zi5rZXlmcmFtZXNOYW1lK1wiLVwiK2g7Zi5tPWYubXx8Zi5zZWxlY3RvcjtmLnNlbGVjdG9yPWYubS5yZXBsYWNlKGYua2V5ZnJhbWVzTmFtZSxmLmEpO2NbZS5rZXlmcmFtZXNOYW1lXT1jZyhlKX1yZXR1cm4gY31mdW5jdGlvbiBjZyhhKXtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuIGIucmVwbGFjZShhLmgsYS5hKX19XG5mdW5jdGlvbiBkZyhhLGIpe3ZhciBjPWVnLGQ9ZGYoYSk7YS50ZXh0Q29udGVudD1iZihkLGZ1bmN0aW9uKGEpe3ZhciBkPWEuY3NzVGV4dD1hLnBhcnNlZENzc1RleHQ7YS5pJiZhLmkuY3NzVGV4dCYmKGQ9ZC5yZXBsYWNlKFBlLFwiXCIpLnJlcGxhY2UoUWUsXCJcIiksYS5jc3NUZXh0PVhmKGMsZCxiKSl9KX1xLk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNmLnByb3RvdHlwZSx7YTp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJ4LXNjb3BlXCJ9fX0pO3ZhciBlZz1uZXcgU2Y7dmFyIGZnPXt9LGdnPXdpbmRvdy5jdXN0b21FbGVtZW50cztpZihnZyYmIVEpe3ZhciBoZz1nZy5kZWZpbmU7Z2cuZGVmaW5lPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD1kb2N1bWVudC5jcmVhdGVDb21tZW50KFwiIFNoYWR5IERPTSBzdHlsZXMgZm9yIFwiK2ErXCIgXCIpLGU9ZG9jdW1lbnQuaGVhZDtlLmluc2VydEJlZm9yZShkLChTP1MubmV4dFNpYmxpbmc6bnVsbCl8fGUuZmlyc3RDaGlsZCk7Uz1kO2ZnW2FdPWQ7cmV0dXJuIGhnLmNhbGwoZ2csYSxiLGMpfX07ZnVuY3Rpb24gaWcoKXt0aGlzLmNhY2hlPXt9fWlnLnByb3RvdHlwZS5zdG9yZT1mdW5jdGlvbihhLGIsYyxkKXt2YXIgZT10aGlzLmNhY2hlW2FdfHxbXTtlLnB1c2goe3Y6YixzdHlsZUVsZW1lbnQ6Yyx1OmR9KTsxMDA8ZS5sZW5ndGgmJmUuc2hpZnQoKTt0aGlzLmNhY2hlW2FdPWV9O2lnLnByb3RvdHlwZS5mZXRjaD1mdW5jdGlvbihhLGIsYyl7aWYoYT10aGlzLmNhY2hlW2FdKWZvcih2YXIgZD1hLmxlbmd0aC0xOzA8PWQ7ZC0tKXt2YXIgZT1hW2RdLGY7YTp7Zm9yKGY9MDtmPGMubGVuZ3RoO2YrKyl7dmFyIGg9Y1tmXTtpZihlLnZbaF0hPT1iW2hdKXtmPSExO2JyZWFrIGF9fWY9ITB9aWYoZilyZXR1cm4gZX19O2Z1bmN0aW9uIGpnKCl7fVxuZnVuY3Rpb24ga2coYSl7Zm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBjPWFbYl07aWYoYy50YXJnZXQhPT1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQmJmMudGFyZ2V0IT09ZG9jdW1lbnQuaGVhZClmb3IodmFyIGQ9MDtkPGMuYWRkZWROb2Rlcy5sZW5ndGg7ZCsrKXt2YXIgZT1jLmFkZGVkTm9kZXNbZF07aWYoZS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFKXt2YXIgZj1lLmdldFJvb3ROb2RlKCk7dmFyIGg9ZTt2YXIgZz1bXTtoLmNsYXNzTGlzdD9nPUFycmF5LmZyb20oaC5jbGFzc0xpc3QpOmggaW5zdGFuY2VvZiB3aW5kb3cuU1ZHRWxlbWVudCYmaC5oYXNBdHRyaWJ1dGUoXCJjbGFzc1wiKSYmKGc9aC5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKS5zcGxpdCgvXFxzKy8pKTtoPWc7Zz1oLmluZGV4T2YoVy5hKTtpZigoaD0tMTxnP2hbZysxXTpcIlwiKSYmZj09PWUub3duZXJEb2N1bWVudClsZihlLGgsITApO2Vsc2UgaWYoZi5ub2RlVHlwZT09PU5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSYmXG4oZj1mLmhvc3QpKWlmKGY9VihmKS5pcyxoPT09Zilmb3IoZT13aW5kb3cuU2hhZHlET00ubmF0aXZlTWV0aG9kcy5xdWVyeVNlbGVjdG9yQWxsLmNhbGwoZSxcIjpub3QoLlwiK1cuYStcIilcIiksZj0wO2Y8ZS5sZW5ndGg7ZisrKW5mKGVbZl0saCk7ZWxzZSBoJiZsZihlLGgsITApLGxmKGUsZil9fX19XG5pZighUSl7dmFyIGxnPW5ldyBNdXRhdGlvbk9ic2VydmVyKGtnKSxtZz1mdW5jdGlvbihhKXtsZy5vYnNlcnZlKGEse2NoaWxkTGlzdDohMCxzdWJ0cmVlOiEwfSl9O2lmKHdpbmRvdy5jdXN0b21FbGVtZW50cyYmIXdpbmRvdy5jdXN0b21FbGVtZW50cy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKW1nKGRvY3VtZW50KTtlbHNle3ZhciBuZz1mdW5jdGlvbigpe21nKGRvY3VtZW50LmJvZHkpfTt3aW5kb3cuSFRNTEltcG9ydHM/d2luZG93LkhUTUxJbXBvcnRzLndoZW5SZWFkeShuZyk6cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7aWYoXCJsb2FkaW5nXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlKXt2YXIgYT1mdW5jdGlvbigpe25nKCk7ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixhKX07ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixhKX1lbHNlIG5nKCl9KX1qZz1mdW5jdGlvbigpe2tnKGxnLnRha2VSZWNvcmRzKCkpfX1cbnZhciBvZz1qZzt2YXIgcGc9e307dmFyIHFnPVByb21pc2UucmVzb2x2ZSgpO2Z1bmN0aW9uIHJnKGEpe2lmKGE9cGdbYV0pYS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb249YS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb258fDAsYS5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb249YS5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb258fDAsYS5fYXBwbHlTaGltTmV4dFZlcnNpb249KGEuX2FwcGx5U2hpbU5leHRWZXJzaW9ufHwwKSsxfWZ1bmN0aW9uIHNnKGEpe3JldHVybiBhLl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbj09PWEuX2FwcGx5U2hpbU5leHRWZXJzaW9ufWZ1bmN0aW9uIHRnKGEpe2EuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uPWEuX2FwcGx5U2hpbU5leHRWZXJzaW9uO2EuYnx8KGEuYj0hMCxxZy50aGVuKGZ1bmN0aW9uKCl7YS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb249YS5fYXBwbHlTaGltTmV4dFZlcnNpb247YS5iPSExfSkpfTt2YXIgdWc9bnVsbCx2Zz13aW5kb3cuSFRNTEltcG9ydHMmJndpbmRvdy5IVE1MSW1wb3J0cy53aGVuUmVhZHl8fG51bGwsd2c7ZnVuY3Rpb24geGcoYSl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7dmc/dmcoYSk6KHVnfHwodWc9bmV3IFByb21pc2UoZnVuY3Rpb24oYSl7d2c9YX0pLFwiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGU/d2coKTpkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGZ1bmN0aW9uKCl7XCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmd2coKX0pKSx1Zy50aGVuKGZ1bmN0aW9uKCl7YSYmYSgpfSkpfSl9O3ZhciB5Zz1uZXcgaWc7ZnVuY3Rpb24gWSgpe3ZhciBhPXRoaXM7dGhpcy5MPXt9O3RoaXMuYz1kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7dmFyIGI9bmV3IHplO2IucnVsZXM9W107dGhpcy5oPU9mKHRoaXMuYyxuZXcgTmYoYikpO3RoaXMubz0hMTt0aGlzLmI9dGhpcy5hPW51bGw7eGcoZnVuY3Rpb24oKXt6ZyhhKX0pfXA9WS5wcm90b3R5cGU7cC54YT1mdW5jdGlvbigpe29nKCl9O3AuTGE9ZnVuY3Rpb24oYSl7cmV0dXJuIGRmKGEpfTtwLlphPWZ1bmN0aW9uKGEpe3JldHVybiBiZihhKX07XG5wLnByZXBhcmVUZW1wbGF0ZT1mdW5jdGlvbihhLGIsYyl7aWYoIWEuaCl7YS5oPSEwO2EubmFtZT1iO2EuZXh0ZW5kcz1jO3BnW2JdPWE7dmFyIGQ9KGQ9YS5jb250ZW50LnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZVwiKSk/ZC5nZXRBdHRyaWJ1dGUoXCJjc3MtYnVpbGRcIil8fFwiXCI6XCJcIjt2YXIgZT1bXTtmb3IodmFyIGY9YS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVwiKSxoPTA7aDxmLmxlbmd0aDtoKyspe3ZhciBnPWZbaF07aWYoZy5oYXNBdHRyaWJ1dGUoXCJzaGFkeS11bnNjb3BlZFwiKSl7aWYoIVEpe3ZhciBrPWcudGV4dENvbnRlbnQ7YWYuaGFzKGspfHwoYWYuYWRkKGspLGs9Zy5jbG9uZU5vZGUoITApLGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoaykpO2cucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnKX19ZWxzZSBlLnB1c2goZy50ZXh0Q29udGVudCksZy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGcpfWU9ZS5qb2luKFwiXCIpLnRyaW0oKTtjPXtpczpiLGV4dGVuZHM6YyxlYjpkfTtcblF8fGxmKGEuY29udGVudCxiKTt6Zyh0aGlzKTtmPVdlLnRlc3QoZSl8fFZlLnRlc3QoZSk7V2UubGFzdEluZGV4PTA7VmUubGFzdEluZGV4PTA7ZT1BZShlKTtmJiZSJiZ0aGlzLmEmJnRoaXMuYS50cmFuc2Zvcm1SdWxlcyhlLGIpO2EuX3N0eWxlQXN0PWU7YS5vPWQ7ZD1bXTtSfHwoZD1UZihhLl9zdHlsZUFzdCkpO2lmKCFkLmxlbmd0aHx8UillPVE/YS5jb250ZW50Om51bGwsYj1mZ1tiXSxmPXBmKGMsYS5fc3R5bGVBc3QpLGI9Zi5sZW5ndGg/ZmYoZixjLmlzLGUsYik6dm9pZCAwLGEuYT1iO2EuYz1kfX07XG5mdW5jdGlvbiBBZyhhKXshYS5iJiZ3aW5kb3cuU2hhZHlDU1MmJndpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZSYmKGEuYj13aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2UsYS5iLnRyYW5zZm9ybUNhbGxiYWNrPWZ1bmN0aW9uKGIpe2EudmEoYil9LGEuYi52YWxpZGF0ZUNhbGxiYWNrPWZ1bmN0aW9uKCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7KGEuYi5lbnF1ZXVlZHx8YS5vKSYmYS5GKCl9KX0pfWZ1bmN0aW9uIHpnKGEpeyFhLmEmJndpbmRvdy5TaGFkeUNTUyYmd2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbSYmKGEuYT13aW5kb3cuU2hhZHlDU1MuQXBwbHlTaGltLGEuYS5pbnZhbGlkQ2FsbGJhY2s9cmcpO0FnKGEpfVxucC5GPWZ1bmN0aW9uKCl7emcodGhpcyk7aWYodGhpcy5iKXt2YXIgYT10aGlzLmIucHJvY2Vzc1N0eWxlcygpO2lmKHRoaXMuYi5lbnF1ZXVlZCl7aWYoUilmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9dGhpcy5iLmdldFN0eWxlRm9yQ3VzdG9tU3R5bGUoYVtiXSk7aWYoYyYmUiYmdGhpcy5hKXt2YXIgZD1kZihjKTt6Zyh0aGlzKTt0aGlzLmEudHJhbnNmb3JtUnVsZXMoZCk7Yy50ZXh0Q29udGVudD1iZihkKX19ZWxzZSBmb3IoQmcodGhpcyx0aGlzLmMsdGhpcy5oKSxiPTA7YjxhLmxlbmd0aDtiKyspKGM9dGhpcy5iLmdldFN0eWxlRm9yQ3VzdG9tU3R5bGUoYVtiXSkpJiZkZyhjLHRoaXMuaC5CKTt0aGlzLmIuZW5xdWV1ZWQ9ITE7dGhpcy5vJiYhUiYmdGhpcy5zdHlsZURvY3VtZW50KCl9fX07XG5wLnN0eWxlRWxlbWVudD1mdW5jdGlvbihhLGIpe3ZhciBjPVYoYSkuaXMsZD1YKGEpO2lmKCFkKXt2YXIgZT1WKGEpO2Q9ZS5pcztlPWUuUDt2YXIgZj1mZ1tkXTtkPXBnW2RdO2lmKGQpe3ZhciBoPWQuX3N0eWxlQXN0O3ZhciBnPWQuY31kPU9mKGEsbmV3IE5mKGgsZixnLGUpKX1hIT09dGhpcy5jJiYodGhpcy5vPSEwKTtiJiYoZC5HPWQuR3x8e30sT2JqZWN0LmFzc2lnbihkLkcsYikpO2lmKFIpe2lmKGQuRyl7Yj1kLkc7Zm9yKHZhciBrIGluIGIpbnVsbD09PWs/YS5zdHlsZS5yZW1vdmVQcm9wZXJ0eShrKTphLnN0eWxlLnNldFByb3BlcnR5KGssYltrXSl9aWYoKChrPXBnW2NdKXx8YT09PXRoaXMuYykmJmsmJmsuYSYmIXNnKGspKXtpZihzZyhrKXx8ay5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb24hPT1rLl9hcHBseVNoaW1OZXh0VmVyc2lvbil6Zyh0aGlzKSx0aGlzLmEmJnRoaXMuYS50cmFuc2Zvcm1SdWxlcyhrLl9zdHlsZUFzdCxjKSxrLmEudGV4dENvbnRlbnQ9cGYoYSxcbmQudyksdGcoayk7USYmKGM9YS5zaGFkb3dSb290KSYmKGMucXVlcnlTZWxlY3RvcihcInN0eWxlXCIpLnRleHRDb250ZW50PXBmKGEsZC53KSk7ZC53PWsuX3N0eWxlQXN0fX1lbHNlIGlmKEJnKHRoaXMsYSxkKSxkLmphJiZkLmphLmxlbmd0aCl7Yz1kO2s9VihhKS5pcztkPShiPXlnLmZldGNoKGssYy5CLGMuamEpKT9iLnN0eWxlRWxlbWVudDpudWxsO2g9Yy51OyhnPWImJmIudSl8fChnPXRoaXMuTFtrXT0odGhpcy5MW2tdfHwwKSsxLGc9aytcIi1cIitnKTtjLnU9ZztnPWMudTtlPWVnO2U9ZD9kLnRleHRDb250ZW50fHxcIlwiOmFnKGUsYSxjLkIsZyk7Zj1YKGEpO3ZhciBsPWYuYTtsJiYhUSYmbCE9PWQmJihsLl91c2VDb3VudC0tLDA+PWwuX3VzZUNvdW50JiZsLnBhcmVudE5vZGUmJmwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsKSk7UT9mLmE/KGYuYS50ZXh0Q29udGVudD1lLGQ9Zi5hKTplJiYoZD1mZihlLGcsYS5zaGFkb3dSb290LGYuYikpOmQ/ZC5wYXJlbnROb2RlfHwoUmYmJlxuLTE8ZS5pbmRleE9mKFwiQG1lZGlhXCIpJiYoZC50ZXh0Q29udGVudD1lKSxnZihkLG51bGwsZi5iKSk6ZSYmKGQ9ZmYoZSxnLG51bGwsZi5iKSk7ZCYmKGQuX3VzZUNvdW50PWQuX3VzZUNvdW50fHwwLGYuYSE9ZCYmZC5fdXNlQ291bnQrKyxmLmE9ZCk7Zz1kO1F8fChkPWMudSxmPWU9YS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIixoJiYoZj1lLnJlcGxhY2UobmV3IFJlZ0V4cChcIlxcXFxzKngtc2NvcGVcXFxccypcIitoK1wiXFxcXHMqXCIsXCJnXCIpLFwiIFwiKSksZis9KGY/XCIgXCI6XCJcIikrXCJ4LXNjb3BlIFwiK2QsZSE9PWYmJmpmKGEsZikpO2J8fHlnLnN0b3JlKGssYy5CLGcsYy51KX19O2Z1bmN0aW9uIENnKGEsYil7cmV0dXJuKGI9Yi5nZXRSb290Tm9kZSgpLmhvc3QpP1goYik/YjpDZyhhLGIpOmEuY31cbmZ1bmN0aW9uIEJnKGEsYixjKXthPUNnKGEsYik7dmFyIGQ9WChhKTthPU9iamVjdC5jcmVhdGUoZC5CfHxudWxsKTt2YXIgZT0kZihiLGMudyk7Yj1ZZihkLncsYikudjtPYmplY3QuYXNzaWduKGEsZS5OYSxiLGUuVmEpO2I9Yy5HO2Zvcih2YXIgZiBpbiBiKWlmKChlPWJbZl0pfHwwPT09ZSlhW2ZdPWU7Zj1lZztiPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGEpO2ZvcihlPTA7ZTxiLmxlbmd0aDtlKyspZD1iW2VdLGFbZF09V2YoZixhW2RdLGEpO2MuQj1hfXAuc3R5bGVEb2N1bWVudD1mdW5jdGlvbihhKXt0aGlzLnN0eWxlU3VidHJlZSh0aGlzLmMsYSl9O1xucC5zdHlsZVN1YnRyZWU9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnNoYWRvd1Jvb3Q7KGN8fGE9PT10aGlzLmMpJiZ0aGlzLnN0eWxlRWxlbWVudChhLGIpO2lmKGI9YyYmKGMuY2hpbGRyZW58fGMuY2hpbGROb2RlcykpZm9yKGE9MDthPGIubGVuZ3RoO2ErKyl0aGlzLnN0eWxlU3VidHJlZShiW2FdKTtlbHNlIGlmKGE9YS5jaGlsZHJlbnx8YS5jaGlsZE5vZGVzKWZvcihiPTA7YjxhLmxlbmd0aDtiKyspdGhpcy5zdHlsZVN1YnRyZWUoYVtiXSl9O3AudmE9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWRmKGEpO2NmKGMsZnVuY3Rpb24oYSl7aWYoUSlLZihhKTtlbHNle3ZhciBjPVc7YS5zZWxlY3Rvcj1hLnBhcnNlZFNlbGVjdG9yO0tmKGEpO2Euc2VsZWN0b3I9YS5tPXRmKGMsYSxjLmMsdm9pZCAwLHZvaWQgMCl9UiYmKHpnKGIpLGIuYSYmYi5hLnRyYW5zZm9ybVJ1bGUoYSkpfSk7Uj9hLnRleHRDb250ZW50PWJmKGMpOnRoaXMuaC53LnJ1bGVzLnB1c2goYyl9O1xucC5nZXRDb21wdXRlZFN0eWxlVmFsdWU9ZnVuY3Rpb24oYSxiKXt2YXIgYztSfHwoYz0oWChhKXx8WChDZyh0aGlzLGEpKSkuQltiXSk7cmV0dXJuKGM9Y3x8d2luZG93LmdldENvbXB1dGVkU3R5bGUoYSkuZ2V0UHJvcGVydHlWYWx1ZShiKSk/Yy50cmltKCk6XCJcIn07cC5ZYT1mdW5jdGlvbihhLGIpe3ZhciBjPWEuZ2V0Um9vdE5vZGUoKTtiPWI/Yi5zcGxpdCgvXFxzLyk6W107Yz1jLmhvc3QmJmMuaG9zdC5sb2NhbE5hbWU7aWYoIWMpe3ZhciBkPWEuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIik7aWYoZCl7ZD1kLnNwbGl0KC9cXHMvKTtmb3IodmFyIGU9MDtlPGQubGVuZ3RoO2UrKylpZihkW2VdPT09Vy5hKXtjPWRbZSsxXTticmVha319fWMmJmIucHVzaChXLmEsYyk7Unx8KGM9WChhKSkmJmMudSYmYi5wdXNoKGVnLmEsYy51KTtqZihhLGIuam9pbihcIiBcIikpfTtwLklhPWZ1bmN0aW9uKGEpe3JldHVybiBYKGEpfTtZLnByb3RvdHlwZS5mbHVzaD1ZLnByb3RvdHlwZS54YTtcblkucHJvdG90eXBlLnByZXBhcmVUZW1wbGF0ZT1ZLnByb3RvdHlwZS5wcmVwYXJlVGVtcGxhdGU7WS5wcm90b3R5cGUuc3R5bGVFbGVtZW50PVkucHJvdG90eXBlLnN0eWxlRWxlbWVudDtZLnByb3RvdHlwZS5zdHlsZURvY3VtZW50PVkucHJvdG90eXBlLnN0eWxlRG9jdW1lbnQ7WS5wcm90b3R5cGUuc3R5bGVTdWJ0cmVlPVkucHJvdG90eXBlLnN0eWxlU3VidHJlZTtZLnByb3RvdHlwZS5nZXRDb21wdXRlZFN0eWxlVmFsdWU9WS5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlO1kucHJvdG90eXBlLnNldEVsZW1lbnRDbGFzcz1ZLnByb3RvdHlwZS5ZYTtZLnByb3RvdHlwZS5fc3R5bGVJbmZvRm9yTm9kZT1ZLnByb3RvdHlwZS5JYTtZLnByb3RvdHlwZS50cmFuc2Zvcm1DdXN0b21TdHlsZUZvckRvY3VtZW50PVkucHJvdG90eXBlLnZhO1kucHJvdG90eXBlLmdldFN0eWxlQXN0PVkucHJvdG90eXBlLkxhO1kucHJvdG90eXBlLnN0eWxlQXN0VG9TdHJpbmc9WS5wcm90b3R5cGUuWmE7XG5ZLnByb3RvdHlwZS5mbHVzaEN1c3RvbVN0eWxlcz1ZLnByb3RvdHlwZS5GO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFkucHJvdG90eXBlLHtuYXRpdmVTaGFkb3c6e2dldDpmdW5jdGlvbigpe3JldHVybiBRfX0sbmF0aXZlQ3NzOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUn19fSk7dmFyIFo9bmV3IFksRGcsRWc7d2luZG93LlNoYWR5Q1NTJiYoRGc9d2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbSxFZz13aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2UpO3dpbmRvdy5TaGFkeUNTUz17U2NvcGluZ1NoaW06WixwcmVwYXJlVGVtcGxhdGU6ZnVuY3Rpb24oYSxiLGMpe1ouRigpO1oucHJlcGFyZVRlbXBsYXRlKGEsYixjKX0sc3R5bGVTdWJ0cmVlOmZ1bmN0aW9uKGEsYil7Wi5GKCk7Wi5zdHlsZVN1YnRyZWUoYSxiKX0sc3R5bGVFbGVtZW50OmZ1bmN0aW9uKGEpe1ouRigpO1ouc3R5bGVFbGVtZW50KGEpfSxzdHlsZURvY3VtZW50OmZ1bmN0aW9uKGEpe1ouRigpO1ouc3R5bGVEb2N1bWVudChhKX0sZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIFouZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGEsYil9LG5hdGl2ZUNzczpSLG5hdGl2ZVNoYWRvdzpRfTtEZyYmKHdpbmRvdy5TaGFkeUNTUy5BcHBseVNoaW09RGcpO1xuRWcmJih3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2U9RWcpO3ZhciBGZz13aW5kb3cuY3VzdG9tRWxlbWVudHMsR2c9d2luZG93LkhUTUxJbXBvcnRzLEhnPXdpbmRvdy5IVE1MVGVtcGxhdGVFbGVtZW50O3dpbmRvdy5XZWJDb21wb25lbnRzPXdpbmRvdy5XZWJDb21wb25lbnRzfHx7fTtpZihGZyYmRmcucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayl7dmFyIElnLEpnPWZ1bmN0aW9uKCl7aWYoSWcpe0hnLkomJkhnLkood2luZG93LmRvY3VtZW50KTt2YXIgYT1JZztJZz1udWxsO2EoKTtyZXR1cm4hMH19LEtnPUdnLndoZW5SZWFkeTtGZy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKGZ1bmN0aW9uKGEpe0lnPWE7S2coSmcpfSk7R2cud2hlblJlYWR5PWZ1bmN0aW9uKGEpe0tnKGZ1bmN0aW9uKCl7SmcoKT9HZy53aGVuUmVhZHkoYSk6YSgpfSl9fVxuR2cud2hlblJlYWR5KGZ1bmN0aW9uKCl7cmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCl7d2luZG93LldlYkNvbXBvbmVudHMucmVhZHk9ITA7ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJXZWJDb21wb25lbnRzUmVhZHlcIix7YnViYmxlczohMH0pKX0pfSk7dmFyIExnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtMZy50ZXh0Q29udGVudD1cImJvZHkge3RyYW5zaXRpb246IG9wYWNpdHkgZWFzZS1pbiAwLjJzOyB9IFxcbmJvZHlbdW5yZXNvbHZlZF0ge29wYWNpdHk6IDA7IGRpc3BsYXk6IGJsb2NrOyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7IH0gXFxuXCI7dmFyIE1nPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJoZWFkXCIpO01nLmluc2VydEJlZm9yZShMZyxNZy5maXJzdENoaWxkKTt9KS5jYWxsKHRoaXMpO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJjb21wb25lbnRzLWxpdGUuanMubWFwXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvd2ViY29tcG9uZW50cy1saXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTA0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=