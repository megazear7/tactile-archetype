/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 51);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_legacy_legacy_element_mixin_js__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_legacy_templatizer_behavior_js__ = __webpack_require__(63);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_elements_dom_bind_js__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_elements_dom_repeat_js__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__lib_elements_dom_if_js__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__lib_elements_array_selector_js__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__lib_elements_custom_style_js__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__lib_legacy_mutable_data_behavior_js__ = __webpack_require__(70);









const Base = Object(__WEBPACK_IMPORTED_MODULE_0__lib_legacy_legacy_element_mixin_js__["a" /* LegacyElementMixin */])(HTMLElement).prototype;
/* unused harmony export Base */



/***/ }),
/* 1 */
/***/ (function(module, exports) {

window.JSCompiler_renameProperty = function(prop, obj) { return prop; }

/** @namespace */
let Polymer;


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomApi */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return matchesSelector; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_flattened_nodes_observer_js__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__ = __webpack_require__(28);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["b"]; });
/* unused harmony reexport addDebouncer */





const p = Element.prototype;
/**
 * @const {function(this:Element, string): boolean}
 */
const normalizedMatchesSelector = p.matches || p.matchesSelector ||
  p.mozMatchesSelector || p.msMatchesSelector ||
  p.oMatchesSelector || p.webkitMatchesSelector;

/**
 * Cross-platform `element.matches` shim.
 *
 * @function matchesSelector
 * @memberof Polymer.dom
 * @param {!Element} node Node to check selector against
 * @param {string} selector Selector to match
 * @return {boolean} True if node matched selector
 */
const matchesSelector = function(node, selector) {
  return normalizedMatchesSelector.call(node, selector);
};

/**
 * Node API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is a `Node`.
 */
class DomApi {

  /**
   * @param {Node} node Node for which to create a Polymer.dom helper object.
   */
  constructor(node) {
    this.node = node;
  }

  /**
   * Returns an instance of `Polymer.FlattenedNodesObserver` that
   * listens for node changes on this element.
   *
   * @param {Function} callback Called when direct or distributed children
   *   of this element changes
   * @return {Polymer.FlattenedNodesObserver} Observer instance
   */
  observeNodes(callback) {
    return new __WEBPACK_IMPORTED_MODULE_2__utils_flattened_nodes_observer_js__["a" /* FlattenedNodesObserver */](this.node, callback);
  }

  /**
   * Disconnects an observer previously created via `observeNodes`
   *
   * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
   *   to disconnect.
   */
  unobserveNodes(observerHandle) {
    observerHandle.disconnect();
  }

  /**
   * Provided as a backwards-compatible API only.  This method does nothing.
   */
  notifyObserver() {}

  /**
   * Returns true if the provided node is contained with this element's
   * light-DOM children or shadow root, including any nested shadow roots
   * of children therein.
   *
   * @param {Node} node Node to test
   * @return {boolean} Returns true if the given `node` is contained within
   *   this element's light or shadow DOM.
   */
  deepContains(node) {
    if (this.node.contains(node)) {
      return true;
    }
    let n = node;
    let doc = node.ownerDocument;
    // walk from node to `this` or `document`
    while (n && n !== doc && n !== this.node) {
      // use logical parentnode, or native ShadowRoot host
      n = n.parentNode || n.host;
    }
    return n === this.node;
  }

  /**
   * Returns the root node of this node.  Equivalent to `getRoodNode()`.
   *
   * @return {Node} Top most element in the dom tree in which the node
   * exists. If the node is connected to a document this is either a
   * shadowRoot or the document; otherwise, it may be the node
   * itself or a node or document fragment containing it.
   */
  getOwnerRoot() {
    return this.node.getRootNode();
  }

  /**
   * For slot elements, returns the nodes assigned to the slot; otherwise
   * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
   *
   * @return {Array<Node>} Array of assigned nodes
   */
  getDistributedNodes() {
    return (this.node.localName === 'slot') ?
      this.node.assignedNodes({flatten: true}) :
      [];
  }

  /**
   * Returns an array of all slots this element was distributed to.
   *
   * @return {Array<HTMLSlotElement>} Description
   */
  getDestinationInsertionPoints() {
    let ip$ = [];
    let n = this.node.assignedSlot;
    while (n) {
      ip$.push(n);
      n = n.assignedSlot;
    }
    return ip$;
  }

  /**
   * Calls `importNode` on the `ownerDocument` for this node.
   *
   * @param {Node} node Node to import
   * @param {boolean} deep True if the node should be cloned deeply during
   *   import
   * @return {Node} Clone of given node imported to this owner document
   */
  importNode(node, deep) {
    let doc = this.node instanceof Document ? this.node :
      this.node.ownerDocument;
    return doc.importNode(node, deep);
  }

  /**
   * @return {Array} Returns a flattened list of all child nodes and nodes assigned
   * to child slots.
   */
  getEffectiveChildNodes() {
    return __WEBPACK_IMPORTED_MODULE_2__utils_flattened_nodes_observer_js__["a" /* FlattenedNodesObserver */].getFlattenedNodes(this.node);
  }

  /**
   * Returns a filtered list of flattened child elements for this element based
   * on the given selector.
   *
   * @param {string} selector Selector to filter nodes against
   * @return {Array<HTMLElement>} List of flattened child elements
   */
  queryDistributedElements(selector) {
    let c$ = this.getEffectiveChildNodes();
    let list = [];
    for (let i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
      if ((c.nodeType === Node.ELEMENT_NODE) &&
          matchesSelector(c, selector)) {
        list.push(c);
      }
    }
    return list;
  }

  /**
   * For shadow roots, returns the currently focused element within this
   * shadow root.
   *
   * @return {Node|undefined} Currently focused element
   */
  get activeElement() {
    let node = this.node;
    return node._activeElement !== undefined ? node._activeElement : node.activeElement;
  }
}

function forwardMethods(proto, methods) {
  for (let i=0; i < methods.length; i++) {
    let method = methods[i];
    proto[method] = /** @this {DomApi} */ function() {
      return this.node[method].apply(this.node, arguments);
    };
  }
}

function forwardReadOnlyProperties(proto, properties) {
  for (let i=0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        return /** @type {DomApi} */ (this).node[name];
      },
      configurable: true
    });
  }
}

function forwardProperties(proto, properties) {
  for (let i=0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        return /** @type {DomApi} */ (this).node[name];
      },
      set: function(value) {
        /** @type {DomApi} */ (this).node[name] = value;
      },
      configurable: true
    });
  }
}

forwardMethods(DomApi.prototype, [
  'cloneNode', 'appendChild', 'insertBefore', 'removeChild',
  'replaceChild', 'setAttribute', 'removeAttribute',
  'querySelector', 'querySelectorAll'
]);

forwardReadOnlyProperties(DomApi.prototype, [
  'parentNode', 'firstChild', 'lastChild',
  'nextSibling', 'previousSibling', 'firstElementChild',
  'lastElementChild', 'nextElementSibling', 'previousElementSibling',
  'childNodes', 'children', 'classList'
]);

forwardProperties(DomApi.prototype, [
  'textContent', 'innerHTML'
]);


/**
 * Event API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is an `Event`.
 */
class EventApi {
  constructor(event) {
    this.event = event;
  }

  /**
   * Returns the first node on the `composedPath` of this event.
   *
   * @return {Node} The node this event was dispatched to
   */
  get rootTarget() {
    return this.event.composedPath()[0];
  }

  /**
   * Returns the local (re-targeted) target for this event.
   *
   * @return {Node} The local (re-targeted) target for this event.
   */
  get localTarget() {
    return this.event.target;
  }

  /**
   * Returns the `composedPath` for this event.
   */
  get path() {
    return this.event.composedPath();
  }
}



const dom = function(obj) {
  obj = obj || document;
  if (!obj.__domApi) {
    let helper;
    if (obj instanceof Event) {
      helper = new EventApi(obj);
    } else {
      helper = new DomApi(obj);
    }
    obj.__domApi = helper;
  }
  return obj.__domApi;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = dom;







/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__class_js__ = __webpack_require__(62);


const Polymer = function(info) {
  // if input is a `class` (aka a function with a prototype), use the prototype
  // remember that the `constructor` will never be called
  let klass;
  if (typeof info === 'function') {
    klass = info;
  } else {
    klass = Object(__WEBPACK_IMPORTED_MODULE_0__class_js__["a" /* Class */])(info);
  }
  customElements.define(klass.is, /** @type {!HTMLElement} */(klass));
  return klass;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = Polymer;



/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


// unique global id for deduping mixins.
let dedupeId = 0;

/**
 * @constructor
 * @extends {Function}
 */
function MixinFunction(){}
/** @type {(WeakMap | undefined)} */
MixinFunction.prototype.__mixinApplications;
/** @type {(Object | undefined)} */
MixinFunction.prototype.__mixinSet;

const dedupingMixin = function(mixin) {
  let mixinApplications = /** @type {!MixinFunction} */(mixin).__mixinApplications;
  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    /** @type {!MixinFunction} */(mixin).__mixinApplications = mixinApplications;
  }
  // maintain a unique id for each mixin
  let mixinDedupeId = dedupeId++;
  function dedupingMixin(base) {
    let baseSet = /** @type {!MixinFunction} */(base).__mixinSet;
    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }
    let map = mixinApplications;
    let extended = map.get(base);
    if (!extended) {
      extended = /** @type {!Function} */(mixin)(base);
      map.set(base, extended);
    }
    // copy inherited mixin set from the extended class, or the base class
    // NOTE: we avoid use of Set here because some browser (IE11)
    // cannot extend a base Set via the constructor.
    let mixinSet = Object.create(/** @type {!MixinFunction} */(extended).__mixinSet || baseSet || null);
    mixinSet[mixinDedupeId] = true;
    /** @type {!MixinFunction} */(extended).__mixinSet = mixinSet;
    return extended;
  }

  return dedupingMixin;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = dedupingMixin;



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Element; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_mixins_element_mixin_js__ = __webpack_require__(24);


/**
 * Base class that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @constructor
 * @implements {Polymer_ElementMixin}
 * @extends HTMLElement
 * @appliesMixin Polymer.ElementMixin
 * @summary Custom element base class that provides the core API for Polymer's
 *   key meta-programming features including template stamping, data-binding,
 *   attribute deserialization, and property change observation
 */
const Element = Object(__WEBPACK_IMPORTED_MODULE_0__lib_mixins_element_mixin_js__["a" /* ElementMixin */])(HTMLElement);



/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
let AsyncInterface; // eslint-disable-line no-unused-vars

// Microtask implemented using Mutation Observer
let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});

function microtaskFlush() {
  const len = microtaskCallbacks.length;
  for (let i = 0; i < len; i++) {
    let cb = microtaskCallbacks[i];
    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(() => { throw e; });
      }
    }
  }
  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}

const timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} delay Time to wait before calling callbacks in ms
   * @return {AsyncInterface} An async timeout interface
   */
  after(delay) {
    return  {
      run(fn) { return setTimeout(fn, delay); },
      cancel: window.clearTimeout.bind(window)
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof Polymer.Async.timeOut
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.setTimeout.bind(window),
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.clearTimeout.bind(window)
};
/* harmony export (immutable) */ __webpack_exports__["b"] = timeOut;


const animationFrame = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof Polymer.Async.animationFrame
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.requestAnimationFrame.bind(window),
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.cancelAnimationFrame.bind(window)
};
/* unused harmony export animationFrame */


const idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {function(IdleDeadline)} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestIdleCallback ?
      window.requestIdleCallback(fn) :
      window.setTimeout(fn, 16);
  },
  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel(handle) {
    window.cancelIdleCallback ?
      window.cancelIdleCallback(handle) :
      window.clearTimeout(handle);
  }
};
/* unused harmony export idlePeriod */


const microTask = {

  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof Polymer.Async.microTask
   * @param {Function} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    microtaskNode.textContent = microtaskNodeContent++;
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },

  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof Polymer.Async.microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle;
    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }
      microtaskCallbacks[idx] = null;
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = microTask;



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["dashToCamelCase"] = dashToCamelCase;
/* harmony export (immutable) */ __webpack_exports__["camelToDashCase"] = camelToDashCase;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


const caseMap = {};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH = /([A-Z])/g;

function dashToCamelCase(dash) {
  return caseMap[dash] || (
    caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL,
      (m) => m[1].toUpperCase()
    )
  );
}

function camelToDashCase(camel) {
  return caseMap[camel] || (
    caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase()
  );
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(43);


const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {
      /*
       * You can use these generic variables in your elements for easy theming.
       * For example, if all your elements use \`--primary-text-color\` as its main
       * color, then switching from a light to a dark theme is just a matter of
       * changing the value of \`--primary-text-color\` in your application.
       */
      --primary-text-color: var(--light-theme-text-color);
      --primary-background-color: var(--light-theme-background-color);
      --secondary-text-color: var(--light-theme-secondary-color);
      --disabled-text-color: var(--light-theme-disabled-color);
      --divider-color: var(--light-theme-divider-color);
      --error-color: var(--paper-deep-orange-a700);

      /*
       * Primary and accent colors. Also see color.html for more colors.
       */
      --primary-color: var(--paper-indigo-500);
      --light-primary-color: var(--paper-indigo-100);
      --dark-primary-color: var(--paper-indigo-700);

      --accent-color: var(--paper-pink-a200);
      --light-accent-color: var(--paper-pink-a100);
      --dark-accent-color: var(--paper-pink-a400);


      /*
       * Material Design Light background theme
       */
      --light-theme-background-color: #ffffff;
      --light-theme-base-color: #000000;
      --light-theme-text-color: var(--paper-grey-900);
      --light-theme-secondary-color: #737373;  /* for secondary text and icons */
      --light-theme-disabled-color: #9b9b9b;  /* disabled/hint text */
      --light-theme-divider-color: #dbdbdb;

      /*
       * Material Design Dark background theme
       */
      --dark-theme-background-color: var(--paper-grey-900);
      --dark-theme-base-color: #ffffff;
      --dark-theme-text-color: #ffffff;
      --dark-theme-secondary-color: #bcbcbc;  /* for secondary text and icons */
      --dark-theme-disabled-color: #646464;  /* disabled/hint text */
      --dark-theme-divider-color: #3c3c3c;

      /*
       * Deprecated values because of their confusing names.
       */
      --text-primary-color: var(--dark-theme-text-color);
      --default-primary-color: var(--primary-color);
    }
  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return settings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return rootPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return sanitizeDOMValue; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__resolve_url_js__ = __webpack_require__(10);



/**
 * Legacy settings.
 * @namespace
 * @memberof Polymer
 */
const settings = undefined || {};
const useShadow = !(window.ShadyDOM);
/* unused harmony export useShadow */

const useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
/* unused harmony export useNativeCSSProperties */

const useNativeCustomElements = !(window.customElements.polyfillWrapFlushCallback);
/* unused harmony export useNativeCustomElements */



/**
 * Globally settable property that is automatically assigned to
 * `Polymer.ElementMixin` instances, useful for binding in templates to
 * make URL's relative to an application's root.  Defaults to the main
 * document URL, but can be overridden by users.  It may be useful to set
 * `Polymer.rootPath` to provide a stable application mount path when
 * using client side routing.
 *
 * @memberof Polymer
 */
let rootPath = undefined ||
  Object(__WEBPACK_IMPORTED_MODULE_1__resolve_url_js__["a" /* pathFromUrl */])(document.baseURI || window.location.href);



const setRootPath = function(path) {
  rootPath = path;
};
/* unused harmony export setRootPath */


/**
 * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:
 *
 *     Polymer = {
 *       sanitizeDOMValue: function(value, name, type, node) { ... }
 *     }
 *
 * Where:
 *
 * `value` is the value to sanitize.
 * `name` is the name of an attribute or property (for example, href).
 * `type` indicates where the value is being inserted: one of property, attribute, or text.
 * `node` is the node where the value is being inserted.
 *
 * @type {(function(*,string,string,Node):*)|undefined}
 * @memberof Polymer
 */
let sanitizeDOMValue = undefined;



const setSanitizeDOMValue = function(newSanitizeDOMValue) {
  sanitizeDOMValue = newSanitizeDOMValue;
};
/* unused harmony export setSanitizeDOMValue */



/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return resolveCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return resolveUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return pathFromUrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  // Lazy feature detection.
  if (workingURL === undefined) {
    workingURL = false;
    try {
      const u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = (u.href === 'http://a/c%20d');
    } catch (e) {
      // silently fail
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    return (new URL(url, baseURI)).href;
  }
  // Fallback to creating an anchor into a disconnected document.
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;

}

/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
    return pre + '\'' +
      resolveUrl(url.replace(/["']/g, ''), baseURI) +
      '\'' + post;
  });
}

/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}






/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = isPath;
/* harmony export (immutable) */ __webpack_exports__["g"] = root;
/* harmony export (immutable) */ __webpack_exports__["b"] = isAncestor;
/* harmony export (immutable) */ __webpack_exports__["c"] = isDescendant;
/* harmony export (immutable) */ __webpack_exports__["i"] = translate;
/* harmony export (immutable) */ __webpack_exports__["e"] = matches;
/* harmony export (immutable) */ __webpack_exports__["f"] = normalize;
/* unused harmony export split */
/* harmony export (immutable) */ __webpack_exports__["a"] = get;
/* harmony export (immutable) */ __webpack_exports__["h"] = set;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


function isPath(path) {
  return path.indexOf('.') >= 0;
}

function root(path) {
  let dotIndex = path.indexOf('.');
  if (dotIndex === -1) {
    return path;
  }
  return path.slice(0, dotIndex);
}

function isAncestor(base, path) {
  //     base.startsWith(path + '.');
  return base.indexOf(path + '.') === 0;
}

function isDescendant(base, path) {
  //     path.startsWith(base + '.');
  return path.indexOf(base + '.') === 0;
}

function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}

function matches(base, path) {
  return (base === path) ||
         isAncestor(base, path) ||
         isDescendant(base, path);
}

function normalize(path) {
  if (Array.isArray(path)) {
    let parts = [];
    for (let i=0; i<path.length; i++) {
      let args = path[i].toString().split('.');
      for (let j=0; j<args.length; j++) {
        parts.push(args[j]);
      }
    }
    return parts.join('.');
  } else {
    return path;
  }
}

function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split('.');
  }
  return path.toString().split('.');
}

function get(root, path, info) {
  let prop = root;
  let parts = split(path);
  // Loop over path parts[0..n-1] and dereference
  for (let i=0; i<parts.length; i++) {
    if (!prop) {
      return;
    }
    let part = parts[i];
    prop = prop[part];
  }
  if (info) {
    info.path = parts.join('.');
  }
  return prop;
}

function set(root, path, value) {
  let prop = root;
  let parts = split(path);
  let last = parts[parts.length-1];
  if (parts.length > 1) {
    // Loop over path parts[0..n-2] and dereference
    for (let i=0; i<parts.length-1; i++) {
      let part = parts[i];
      prop = prop[part];
      if (!prop) {
        return;
      }
    }
    // Set value to object at end of path
    prop[last] = value;
  } else {
    // Simple property set
    prop[path] = value;
  }
  return parts.join('.');
}

const isDeep = isPath;
/* unused harmony export isDeep */



/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["deepTargetFind"] = deepTargetFind;
/* harmony export (immutable) */ __webpack_exports__["_findOriginalTarget"] = _findOriginalTarget;
/* harmony export (immutable) */ __webpack_exports__["_handleNative"] = _handleNative;
/* harmony export (immutable) */ __webpack_exports__["_handleTouchAction"] = _handleTouchAction;
/* harmony export (immutable) */ __webpack_exports__["addListener"] = addListener;
/* harmony export (immutable) */ __webpack_exports__["removeListener"] = removeListener;
/* harmony export (immutable) */ __webpack_exports__["_add"] = _add;
/* harmony export (immutable) */ __webpack_exports__["_remove"] = _remove;
/* harmony export (immutable) */ __webpack_exports__["register"] = register;
/* harmony export (immutable) */ __webpack_exports__["_findRecognizerByEvent"] = _findRecognizerByEvent;
/* harmony export (immutable) */ __webpack_exports__["setTouchAction"] = setTouchAction;
/* harmony export (immutable) */ __webpack_exports__["_fire"] = _fire;
/* harmony export (immutable) */ __webpack_exports__["prevent"] = prevent;
/* harmony export (immutable) */ __webpack_exports__["resetMouseCanceller"] = resetMouseCanceller;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__async_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__debounce_js__ = __webpack_require__(13);




// detect native touch action support
let HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
let GESTURE_KEY = '__polymerGestures';
let HANDLED_OBJ = '__polymerGesturesHandled';
let TOUCH_ACTION = '__polymerGesturesTouchAction';
// radius for tap and track
let TAP_DISTANCE = 25;
let TRACK_DISTANCE = 5;
// number of last N track positions to keep
let TRACK_LENGTH = 2;

// Disabling "mouse" handlers for 2500ms is enough
let MOUSE_TIMEOUT = 2500;
let MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
let MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
let MOUSE_HAS_BUTTONS = (function() {
  try {
    return new MouseEvent('test', {buttons: 1}).buttons === 1;
  } catch (e) {
    return false;
  }
})();

/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
// check for passive event listeners
let SUPPORTS_PASSIVE = false;
(function() {
  try {
    let opts = Object.defineProperty({}, 'passive', {get: function() {SUPPORTS_PASSIVE = true;}});
    window.addEventListener('test', null, opts);
    window.removeEventListener('test', null, opts);
  } catch(e) {}
})();

// Check for touch-only devices
let IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

let GestureRecognizer = function(){}; // eslint-disable-line no-unused-vars
GestureRecognizer.prototype.reset = function(){};
/** @type {function(MouseEvent) | undefined} */
GestureRecognizer.prototype.mousedown;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mousemove;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mouseup;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchstart;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchmove;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchend;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.click;

// touch will make synthetic mouse events
// `preventDefault` on touchend will cancel them,
// but this breaks `<input>` focus and link clicks
// disable mouse handlers for MOUSE_TIMEOUT ms after
// a touchend to ignore synthetic mouse events
let mouseCanceller = function(mouseEvent) {
  // Check for sourceCapabilities, used to distinguish synthetic events
  // if mouseEvent did not come from a device that fires touch events,
  // it was made by a real mouse and should be counted
  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
  let sc = mouseEvent.sourceCapabilities;
  if (sc && !sc.firesTouchEvents) {
    return;
  }
  // skip synthetic mouse events
  mouseEvent[HANDLED_OBJ] = {skip: true};
  // disable "ghost clicks"
  if (mouseEvent.type === 'click') {
    let path = mouseEvent.composedPath && mouseEvent.composedPath();
    if (path) {
      for (let i = 0; i < path.length; i++) {
        if (path[i] === POINTERSTATE.mouse.target) {
          return;
        }
      }
    }
    mouseEvent.preventDefault();
    mouseEvent.stopPropagation();
  }
};

/**
 * @param {boolean=} setup True to add, false to remove.
 */
function setupTeardownMouseCanceller(setup) {
  let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
  for (let i = 0, en; i < events.length; i++) {
    en = events[i];
    if (setup) {
      document.addEventListener(en, mouseCanceller, true);
    } else {
      document.removeEventListener(en, mouseCanceller, true);
    }
  }
}

function ignoreMouse(e) {
  if (!POINTERSTATE.mouse.mouseIgnoreJob) {
    setupTeardownMouseCanceller(true);
  }
  let unset = function() {
    setupTeardownMouseCanceller();
    POINTERSTATE.mouse.target = null;
    POINTERSTATE.mouse.mouseIgnoreJob = null;
  };
  POINTERSTATE.mouse.target = e.composedPath()[0];
  POINTERSTATE.mouse.mouseIgnoreJob = __WEBPACK_IMPORTED_MODULE_2__debounce_js__["a" /* Debouncer */].debounce(
        POINTERSTATE.mouse.mouseIgnoreJob
      , __WEBPACK_IMPORTED_MODULE_1__async_js__["b" /* timeOut */].after(MOUSE_TIMEOUT)
      , unset);
}

/**
 * @param {MouseEvent} ev event to test for left mouse button down
 * @return {boolean} has left mouse button down
 */
function hasLeftMouseButton(ev) {
  let type = ev.type;
  // exit early if the event is not a mouse event
  if (MOUSE_EVENTS.indexOf(type) === -1) {
    return false;
  }
  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
  if (type === 'mousemove') {
    // allow undefined for testing events
    let buttons = ev.buttons === undefined ? 1 : ev.buttons;
    if ((ev instanceof window.MouseEvent) && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    // buttons is a bitmask, check that the left button bit is set (1)
    return Boolean(buttons & 1);
  } else {
    // allow undefined for testing events
    let button = ev.button === undefined ? 0 : ev.button;
    // ev.button is 0 in mousedown/mouseup/click for left button activation
    return button === 0;
  }
}

function isSyntheticClick(ev) {
  if (ev.type === 'click') {
    // ev.detail is 0 for HTMLElement.click in most browsers
    if (ev.detail === 0) {
      return true;
    }
    // in the worst case, check that the x/y position of the click is within
    // the bounding box of the target of the event
    // Thanks IE 10 >:(
    let t = _findOriginalTarget(ev);
    // make sure the target of the event is an element so we can use getBoundingClientRect,
    // if not, just assume it is a synthetic click
    if (!t.nodeType || /** @type {Element} */(t).nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    let bcr = /** @type {Element} */(t).getBoundingClientRect();
    // use page x/y to account for scrolling
    let x = ev.pageX, y = ev.pageY;
    // ev is a synthetic click if the position is outside the bounding box of the target
    return !((x >= bcr.left && x <= bcr.right) && (y >= bcr.top && y <= bcr.bottom));
  }
  return false;
}

let POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};

function firstTouchAction(ev) {
  let ta = 'auto';
  let path = ev.composedPath && ev.composedPath();
  if (path) {
    for (let i = 0, n; i < path.length; i++) {
      n = path[i];
      if (n[TOUCH_ACTION]) {
        ta = n[TOUCH_ACTION];
        break;
      }
    }
  }
  return ta;
}

function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener('mousemove', movefn);
  document.addEventListener('mouseup', upfn);
}

function untrackDocument(stateObj) {
  document.removeEventListener('mousemove', stateObj.movefn);
  document.removeEventListener('mouseup', stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}

// use a document-wide touchend listener to start the ghost-click prevention mechanism
// Use passive event listeners, if supported, to not affect scrolling performance
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? {passive: true} : false);

const gestures = {};
/* harmony export (immutable) */ __webpack_exports__["gestures"] = gestures;

const recognizers = [];
/* harmony export (immutable) */ __webpack_exports__["recognizers"] = recognizers;


function deepTargetFind(x, y) {
  let node = document.elementFromPoint(x, y);
  let next = node;
  // this code path is only taken when native ShadowDOM is used
  // if there is a shadowroot, it may have a node at x/y
  // if there is not a shadowroot, exit the loop
  while (next && next.shadowRoot && !window.ShadyDOM) {
    // if there is a node at x/y in the shadowroot, look deeper
    let oldNext = next;
    next = next.shadowRoot.elementFromPoint(x, y);
    // on Safari, elementFromPoint may return the shadowRoot host
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}

function _findOriginalTarget(ev) {
  // shadowdom
  if (ev.composedPath) {
    return /** @type {EventTarget} */(ev.composedPath()[0]);
  }
  // shadydom
  return ev.target;
}

function _handleNative(ev) {
  let handled;
  let type = ev.type;
  let node = ev.currentTarget;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  let gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.slice(0, 5) === 'touch') {
      ev = /** @type {TouchEvent} */(ev); // eslint-disable-line no-self-assign
      let t = ev.changedTouches[0];
      if (type === 'touchstart') {
        // only handle the first finger
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === 'touchstart' || type === 'touchmove') {
          _handleTouchAction(ev);
        }
      }
    }
  }
  handled = ev[HANDLED_OBJ];
  // used to ignore synthetic mouse events
  if (handled.skip) {
    return;
  }
  // reset recognizer state
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  // enforce gesture recognizer order
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      handled[r.name] = true;
      r[type](ev);
    }
  }
}

function _handleTouchAction(ev) {
  let t = ev.changedTouches[0];
  let type = ev.type;
  if (type === 'touchstart') {
    POINTERSTATE.touch.x = t.clientX;
    POINTERSTATE.touch.y = t.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === 'touchmove') {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    let ta = firstTouchAction(ev);
    let prevent = false;
    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
    if (!ev.cancelable) {
      // scrolling is happening
    } else if (ta === 'none') {
      prevent = true;
    } else if (ta === 'pan-x') {
      prevent = dy > dx;
    } else if (ta === 'pan-y') {
      prevent = dx > dy;
    }
    if (prevent) {
      ev.preventDefault();
    } else {
      prevent('track');
    }
  }
}

function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}

function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}

function _add(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (let i = 0, dep, gd; i < deps.length; i++) {
    dep = deps[i];
    // don't add mouse handlers on iOS because they cause gray selection overlays
    if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = {_count: 0};
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative);
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}

function _remove(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (gobj) {
    for (let i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative);
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}

function register(recog) {
  recognizers.push(recog);
  for (let i = 0; i < recog.emits.length; i++) {
    gestures[recog.emits[i]] = recog;
  }
}

function _findRecognizerByEvent(evName) {
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    for (let j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}

function setTouchAction(node, value) {
  if (HAS_NATIVE_TA) {
    node.style.touchAction = value;
  }
  node[TOUCH_ACTION] = value;
}

function _fire(target, type, detail) {
  let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  target.dispatchEvent(ev);
  // forward `preventDefault` in a clean way
  if (ev.defaultPrevented) {
    let preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}

function prevent(evName) {
  let recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}

function resetMouseCanceller() {
  if (POINTERSTATE.mouse.mouseIgnoreJob) {
    POINTERSTATE.mouse.mouseIgnoreJob.flush();
  }
}

/* eslint-disable valid-jsdoc */

register({
  name: 'downup',
  deps: ['mousedown', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['down', 'up'],

  info: {
    movefn: null,
    upfn: null
  },

  /** @this {GestureRecognizer} */
  reset: function() {
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn(e) {
      if (!hasLeftMouseButton(e)) {
        self._fire('up', t, e);
        untrackDocument(self.info);
      }
    };
    let upfn = function upfn(e) {
      if (hasLeftMouseButton(e)) {
        self._fire('up', t, e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    this._fire('down', t, e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function(e) {
    this._fire('down', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function(e) {
    this._fire('up', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @param {string} type
   * @param {EventTarget} target
   * @param {Event} event
   * @param {Function} preventer
   */
  _fire: function(type, target, event, preventer) {
    _fire(target, type, {
      x: event.clientX,
      y: event.clientY,
      sourceEvent: event,
      preventer: preventer,
      prevent: function(e) {
        return prevent(e);
      }
    });
  }
});

register({
  name: 'track',
  touchAction: 'none',
  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['track'],

  info: {
    x: 0,
    y: 0,
    state: 'start',
    started: false,
    moves: [],
    /** @this {GestureRecognizer} */
    addMove: function(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },

  /** @this {GestureRecognizer} */
  reset: function() {
    this.info.state = 'start';
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {number} x
   * @param {number} y
   * @return {boolean}
   */
  hasMovedEnough: function(x, y) {
    if (this.info.prevent) {
      return false;
    }
    if (this.info.started) {
      return true;
    }
    let dx = Math.abs(this.info.x - x);
    let dy = Math.abs(this.info.y - y);
    return (dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn(e) {
      let x = e.clientX, y = e.clientY;
      if (self.hasMovedEnough(x, y)) {
        // first move is 'start', subsequent moves are 'move', mouseup is 'end'
        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';
        if (self.info.state === 'start') {
          // if and only if tracking, always prevent tap
          prevent('tap');
        }
        self.info.addMove({x: x, y: y});
        if (!hasLeftMouseButton(e)) {
          // always _fire "end"
          self.info.state = 'end';
          untrackDocument(self.info);
        }
        self._fire(t, e);
        self.info.started = true;
      }
    };
    let upfn = function upfn(e) {
      if (self.info.started) {
        movefn(e);
      }

      // remove the temporary listeners
      untrackDocument(self.info);
    };
    // add temporary document listeners as mouse retargets
    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function(e) {
    let ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchmove: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    let x = ct.clientX, y = ct.clientY;
    if (this.hasMovedEnough(x, y)) {
      if (this.info.state === 'start') {
        // if and only if tracking, always prevent tap
        prevent('tap');
      }
      this.info.addMove({x: x, y: y});
      this._fire(t, ct);
      this.info.state = 'track';
      this.info.started = true;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    // only trackend if track was started and not aborted
    if (this.info.started) {
      // reset started state on up
      this.info.state = 'end';
      this.info.addMove({x: ct.clientX, y: ct.clientY});
      this._fire(t, ct, e);
    }
  },

  /**
   * @this {GestureRecognizer}
   * @param {EventTarget} target
   * @param {Touch} touch
   */
  _fire: function(target, touch) {
    let secondlast = this.info.moves[this.info.moves.length - 2];
    let lastmove = this.info.moves[this.info.moves.length - 1];
    let dx = lastmove.x - this.info.x;
    let dy = lastmove.y - this.info.y;
    let ddx, ddy = 0;
    if (secondlast) {
      ddx = lastmove.x - secondlast.x;
      ddy = lastmove.y - secondlast.y;
    }
    _fire(target, 'track', {
      state: this.info.state,
      x: touch.clientX,
      y: touch.clientY,
      dx: dx,
      dy: dy,
      ddx: ddx,
      ddy: ddy,
      sourceEvent: touch,
      hover: function() {
        return deepTargetFind(touch.clientX, touch.clientY);
      }
    });
  }

});

register({
  name: 'tap',
  deps: ['mousedown', 'click', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['click', 'touchend']
  },
  emits: ['tap'],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  /** @this {GestureRecognizer} */
  reset: function() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  /** @this {GestureRecognizer} */
  save: function(e) {
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function(e) {
    if (hasLeftMouseButton(e)) {
      this.save(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  click: function(e) {
    if (hasLeftMouseButton(e)) {
      this.forward(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function(e) {
    this.save(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function(e) {
    this.forward(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {Event | Touch} e
   * @param {Event=} preventer
   */
  forward: function(e, preventer) {
    let dx = Math.abs(e.clientX - this.info.x);
    let dy = Math.abs(e.clientY - this.info.y);
    // find original target from `preventer` for TouchEvents, or `e` for MouseEvents
    let t = _findOriginalTarget((preventer || e));
    // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
    if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {
      // prevent taps from being generated if an event has canceled them
      if (!this.info.prevent) {
        _fire(t, 'tap', {
          x: e.clientX,
          y: e.clientY,
          sourceEvent: e,
          preventer: preventer
        });
      }
    }
  }
});

const findOriginalTarget = _findOriginalTarget;
/* harmony export (immutable) */ __webpack_exports__["findOriginalTarget"] = findOriginalTarget;

const add = addListener;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;

const remove = removeListener;
/* harmony export (immutable) */ __webpack_exports__["remove"] = remove;



/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Debouncer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__async_js__ = __webpack_require__(6);




/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
let AsyncModule; // eslint-disable-line no-unused-vars

/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 * @memberof Polymer
 */
class Debouncer {
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncModule} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   */
  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   */
  cancel() {
    if (this.isActive()) {
      this._asyncModule.cancel(this._timer);
      this._timer = null;
    }
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   */
  flush() {
    if (this.isActive()) {
      this.cancel();
      this._callback();
    }
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
/**
 * Creates a debouncer if no debouncer is passed as a parameter
 * or it cancels an active debouncer otherwise. The following
 * example shows how a debouncer can be called multiple times within a
 * microtask and "debounced" such that the provided callback function is
 * called once. Add this method to a custom element:
 *
 * _debounceWork() {
 *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
 *       Polymer.Async.microTask, () => {
 *     this._doWork();
 *   });
 * }
 *
 * If the `_debounceWork` method is called multiple times within the same
 * microtask, the `_doWork` function will be called only once at the next
 * microtask checkpoint.
 *
 * Note: In testing it is often convenient to avoid asynchrony. To accomplish
 * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
 * `Polymer.flush`. For example, extend the above example by adding
 * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
 * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
 * the debouncer has completed.
 *
 * @param {Debouncer?} debouncer Debouncer object.
 * @param {!AsyncModule} asyncModule Object with Async interface
 * @param {function()} callback Callback to run.
 * @return {!Debouncer} Returns a debouncer object.
 */
  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer) {
      debouncer.cancel();
    } else {
      debouncer = new Debouncer();
    }
    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }
}




/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_mixin_js__ = __webpack_require__(4);


// Common implementation for mixin & behavior
function mutablePropertyChange(inst, property, value, old, mutableData) {
  let isObject;
  if (mutableData) {
    isObject = (typeof value === 'object' && value !== null);
    // Pull `old` for Objects from temp cache, but treat `null` as a primitive
    if (isObject) {
      old = inst.__dataTemp[property];
    }
  }
  // Strict equality check, but return false for NaN===NaN
  let shouldChange = (old !== value && (old === old || value === value));
  // Objects are stored in temporary cache (cleared at end of
  // turn), which is used for dirty-checking
  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }
  return shouldChange;
}

const MutableData = Object(__WEBPACK_IMPORTED_MODULE_0__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_MutableData}
   */
  class MutableData extends superClass {
    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }

  }
  /** @type {boolean} */
  MutableData.prototype.mutableData = false;

  return MutableData;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = MutableData;


const OptionalMutableData = Object(__WEBPACK_IMPORTED_MODULE_0__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @mixinClass
   * @polymer
   * @implements {Polymer_OptionalMutableData}
   */
  class OptionalMutableData extends superClass {

    static get properties() {
      return {
        /**
         * Instance-level flag for configuring the dirty-checking strategy
         * for this element.  When true, Objects and Arrays will skip dirty
         * checking, otherwise strict equality checking will be used.
         */
        mutableData: Boolean
      };
    }

    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * When `this.mutableData` is true on this instance, this method
     * pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  }

  return OptionalMutableData;

});
/* harmony export (immutable) */ __webpack_exports__["b"] = OptionalMutableData;


// Export for use by legacy behavior
MutableData._mutablePropertyChange = mutablePropertyChange;


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);


/**
 * Chrome uses an older version of DOM Level 3 Keyboard Events
 *
 * Most keys are labeled as text, but some are Unicode codepoints.
 * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
 */
var KEY_IDENTIFIER = {
  'U+0008': 'backspace',
  'U+0009': 'tab',
  'U+001B': 'esc',
  'U+0020': 'space',
  'U+007F': 'del'
};

/**
 * Special table for KeyboardEvent.keyCode.
 * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
 * than that.
 *
 * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
 */
var KEY_CODE = {
  8: 'backspace',
  9: 'tab',
  13: 'enter',
  27: 'esc',
  33: 'pageup',
  34: 'pagedown',
  35: 'end',
  36: 'home',
  32: 'space',
  37: 'left',
  38: 'up',
  39: 'right',
  40: 'down',
  46: 'del',
  106: '*'
};

/**
 * MODIFIER_KEYS maps the short name for modifier keys used in a key
 * combo string to the property name that references those same keys
 * in a KeyboardEvent instance.
 */
var MODIFIER_KEYS = {
  'shift': 'shiftKey',
  'ctrl': 'ctrlKey',
  'alt': 'altKey',
  'meta': 'metaKey'
};

/**
 * KeyboardEvent.key is mostly represented by printable character made by
 * the keyboard, with unprintable keys labeled nicely.
 *
 * However, on OS X, Alt+char can make a Unicode character that follows an
 * Apple-specific mapping. In this case, we fall back to .keyCode.
 */
var KEY_CHAR = /[a-z0-9*]/;

/**
 * Matches a keyIdentifier string.
 */
var IDENT_CHAR = /U\+/;

/**
 * Matches arrow keys in Gecko 27.0+
 */
var ARROW_KEY = /^arrow/;

/**
 * Matches space keys everywhere (notably including IE10's exceptional name
 * `spacebar`).
 */
var SPACE_KEY = /^space(bar)?/;

/**
 * Matches ESC key.
 *
 * Value from: http://w3c.github.io/uievents-key/#key-Escape
 */
var ESC_KEY = /^escape$/;

/**
 * Transforms the key.
 * @param {string} key The KeyBoardEvent.key
 * @param {Boolean} [noSpecialChars] Limits the transformation to
 * alpha-numeric characters.
 */
function transformKey(key, noSpecialChars) {
  var validKey = '';
  if (key) {
    var lKey = key.toLowerCase();
    if (lKey === ' ' || SPACE_KEY.test(lKey)) {
      validKey = 'space';
    } else if (ESC_KEY.test(lKey)) {
      validKey = 'esc';
    } else if (lKey.length == 1) {
      if (!noSpecialChars || KEY_CHAR.test(lKey)) {
        validKey = lKey;
      }
    } else if (ARROW_KEY.test(lKey)) {
      validKey = lKey.replace('arrow', '');
    } else if (lKey == 'multiply') {
      // numpad '*' can map to Multiply on IE/Windows
      validKey = '*';
    } else {
      validKey = lKey;
    }
  }
  return validKey;
}

function transformKeyIdentifier(keyIdent) {
  var validKey = '';
  if (keyIdent) {
    if (keyIdent in KEY_IDENTIFIER) {
      validKey = KEY_IDENTIFIER[keyIdent];
    } else if (IDENT_CHAR.test(keyIdent)) {
      keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
      validKey = String.fromCharCode(keyIdent).toLowerCase();
    } else {
      validKey = keyIdent.toLowerCase();
    }
  }
  return validKey;
}

function transformKeyCode(keyCode) {
  var validKey = '';
  if (Number(keyCode)) {
    if (keyCode >= 65 && keyCode <= 90) {
      // ascii a-z
      // lowercase is 32 offset from uppercase
      validKey = String.fromCharCode(32 + keyCode);
    } else if (keyCode >= 112 && keyCode <= 123) {
      // function keys f1-f12
      validKey = 'f' + (keyCode - 112 + 1);
    } else if (keyCode >= 48 && keyCode <= 57) {
      // top 0-9 keys
      validKey = String(keyCode - 48);
    } else if (keyCode >= 96 && keyCode <= 105) {
      // num pad 0-9
      validKey = String(keyCode - 96);
    } else {
      validKey = KEY_CODE[keyCode];
    }
  }
  return validKey;
}

/**
  * Calculates the normalized key for a KeyboardEvent.
  * @param {KeyboardEvent} keyEvent
  * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
  * transformation to alpha-numeric chars. This is useful with key
  * combinations like shift + 2, which on FF for MacOS produces
  * keyEvent.key = @
  * To get 2 returned, set noSpecialChars = true
  * To get @ returned, set noSpecialChars = false
 */
function normalizedKeyForEvent(keyEvent, noSpecialChars) {
  // Fall back from .key, to .detail.key for artifical keyboard events,
  // and then to deprecated .keyIdentifier and .keyCode.
  if (keyEvent.key) {
    return transformKey(keyEvent.key, noSpecialChars);
  }
  if (keyEvent.detail && keyEvent.detail.key) {
    return transformKey(keyEvent.detail.key, noSpecialChars);
  }
  return transformKeyIdentifier(keyEvent.keyIdentifier) ||
    transformKeyCode(keyEvent.keyCode) || '';
}

function keyComboMatchesEvent(keyCombo, event) {
  // For combos with modifiers we support only alpha-numeric keys
  var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
  return keyEvent === keyCombo.key &&
    (!keyCombo.hasModifiers || (
      !!event.shiftKey === !!keyCombo.shiftKey &&
      !!event.ctrlKey === !!keyCombo.ctrlKey &&
      !!event.altKey === !!keyCombo.altKey &&
      !!event.metaKey === !!keyCombo.metaKey)
    );
}

function parseKeyComboString(keyComboString) {
  if (keyComboString.length === 1) {
    return {
      combo: keyComboString,
      key: keyComboString,
      event: 'keydown'
    };
  }
  return keyComboString.split('+').reduce(function(parsedKeyCombo, keyComboPart) {
    var eventParts = keyComboPart.split(':');
    var keyName = eventParts[0];
    var event = eventParts[1];

    if (keyName in MODIFIER_KEYS) {
      parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
      parsedKeyCombo.hasModifiers = true;
    } else {
      parsedKeyCombo.key = keyName;
      parsedKeyCombo.event = event || 'keydown';
    }

    return parsedKeyCombo;
  }, {
    combo: keyComboString.split(':').shift()
  });
}

function parseEventString(eventString) {
  return eventString.trim().split(' ').map(function(keyComboString) {
    return parseKeyComboString(keyComboString);
  });
}

const IronA11yKeysBehavior = {
  properties: {
    /**
     * The EventTarget that will be firing relevant KeyboardEvents. Set it to
     * `null` to disable the listeners.
     * @type {?EventTarget}
     */
    keyEventTarget: {
      type: Object,
      value: function() {
        return this;
      }
    },

    /**
     * If true, this property will cause the implementing element to
     * automatically stop propagation on any handled KeyboardEvents.
     */
    stopKeyboardEventPropagation: {
      type: Boolean,
      value: false
    },

    _boundKeyHandlers: {
      type: Array,
      value: function() {
        return [];
      }
    },

    // We use this due to a limitation in IE10 where instances will have
    // own properties of everything on the "prototype".
    _imperativeKeyBindings: {
      type: Object,
      value: function() {
        return {};
      }
    }
  },

  observers: [
    '_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'
  ],


  /**
   * To be used to express what combination of keys  will trigger the relative
   * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
   * @type {!Object}
   */
  keyBindings: {},

  registered: function() {
    this._prepKeyBindings();
  },

  attached: function() {
    this._listenKeyEventListeners();
  },

  detached: function() {
    this._unlistenKeyEventListeners();
  },

  /**
   * Can be used to imperatively add a key binding to the implementing
   * element. This is the imperative equivalent of declaring a keybinding
   * in the `keyBindings` prototype property.
   *
   * @param {string} eventString
   * @param {string} handlerName
   */
  addOwnKeyBinding: function(eventString, handlerName) {
    this._imperativeKeyBindings[eventString] = handlerName;
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * When called, will remove all imperatively-added key bindings.
   */
  removeOwnKeyBindings: function() {
    this._imperativeKeyBindings = {};
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * Returns true if a keyboard event matches `eventString`.
   *
   * @param {KeyboardEvent} event
   * @param {string} eventString
   * @return {boolean}
   */
  keyboardEventMatchesKeys: function(event, eventString) {
    var keyCombos = parseEventString(eventString);
    for (var i = 0; i < keyCombos.length; ++i) {
      if (keyComboMatchesEvent(keyCombos[i], event)) {
        return true;
      }
    }
    return false;
  },

  _collectKeyBindings: function() {
    var keyBindings = this.behaviors.map(function(behavior) {
      return behavior.keyBindings;
    });

    if (keyBindings.indexOf(this.keyBindings) === -1) {
      keyBindings.push(this.keyBindings);
    }

    return keyBindings;
  },

  _prepKeyBindings: function() {
    this._keyBindings = {};

    this._collectKeyBindings().forEach(function(keyBindings) {
      for (var eventString in keyBindings) {
        this._addKeyBinding(eventString, keyBindings[eventString]);
      }
    }, this);

    for (var eventString in this._imperativeKeyBindings) {
      this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
    }

    // Give precedence to combos with modifiers to be checked first.
    for (var eventName in this._keyBindings) {
      this._keyBindings[eventName].sort(function (kb1, kb2) {
        var b1 = kb1[0].hasModifiers;
        var b2 = kb2[0].hasModifiers;
        return (b1 === b2) ? 0 : b1 ? -1 : 1;
      })
    }
  },

  _addKeyBinding: function(eventString, handlerName) {
    parseEventString(eventString).forEach(function(keyCombo) {
      this._keyBindings[keyCombo.event] =
        this._keyBindings[keyCombo.event] || [];

      this._keyBindings[keyCombo.event].push([
        keyCombo,
        handlerName
      ]);
    }, this);
  },

  _resetKeyEventListeners: function() {
    this._unlistenKeyEventListeners();

    if (this.isAttached) {
      this._listenKeyEventListeners();
    }
  },

  _listenKeyEventListeners: function() {
    if (!this.keyEventTarget) {
      return;
    }
    Object.keys(this._keyBindings).forEach(function(eventName) {
      var keyBindings = this._keyBindings[eventName];
      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

      this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
    }, this);
  },

  _unlistenKeyEventListeners: function() {
    var keyHandlerTuple;
    var keyEventTarget;
    var eventName;
    var boundKeyHandler;

    while (this._boundKeyHandlers.length) {
      // My kingdom for block-scope binding and destructuring assignment..
      keyHandlerTuple = this._boundKeyHandlers.pop();
      keyEventTarget = keyHandlerTuple[0];
      eventName = keyHandlerTuple[1];
      boundKeyHandler = keyHandlerTuple[2];

      keyEventTarget.removeEventListener(eventName, boundKeyHandler);
    }
  },

  _onKeyBindingEvent: function(keyBindings, event) {
    if (this.stopKeyboardEventPropagation) {
      event.stopPropagation();
    }

    // if event has been already prevented, don't do anything
    if (event.defaultPrevented) {
      return;
    }

    for (var i = 0; i < keyBindings.length; i++) {
      var keyCombo = keyBindings[i][0];
      var handlerName = keyBindings[i][1];
      if (keyComboMatchesEvent(keyCombo, event)) {
        this._triggerKeyHandler(keyCombo, handlerName, event);
        // exit the loop if eventDefault was prevented
        if (event.defaultPrevented) {
          return;
        }
      }
    }
  },

  _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {
    var detail = Object.create(keyCombo);
    detail.keyboardEvent = keyboardEvent;
    var event = new CustomEvent(keyCombo.event, {
      detail: detail,
      cancelable: true
    });
    this[handlerName].call(this, event);
    if (event.defaultPrevented) {
      keyboardEvent.preventDefault();
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronA11yKeysBehavior;



/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      --layout: {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
      };

      --layout-inline: {
        display: -ms-inline-flexbox;
        display: -webkit-inline-flex;
        display: inline-flex;
      };

      --layout-horizontal: {
        @apply --layout;

        -ms-flex-direction: row;
        -webkit-flex-direction: row;
        flex-direction: row;
      };

      --layout-horizontal-reverse: {
        @apply --layout;

        -ms-flex-direction: row-reverse;
        -webkit-flex-direction: row-reverse;
        flex-direction: row-reverse;
      };

      --layout-vertical: {
        @apply --layout;

        -ms-flex-direction: column;
        -webkit-flex-direction: column;
        flex-direction: column;
      };

      --layout-vertical-reverse: {
        @apply --layout;

        -ms-flex-direction: column-reverse;
        -webkit-flex-direction: column-reverse;
        flex-direction: column-reverse;
      };

      --layout-wrap: {
        -ms-flex-wrap: wrap;
        -webkit-flex-wrap: wrap;
        flex-wrap: wrap;
      };

      --layout-wrap-reverse: {
        -ms-flex-wrap: wrap-reverse;
        -webkit-flex-wrap: wrap-reverse;
        flex-wrap: wrap-reverse;
      };

      --layout-flex-auto: {
        -ms-flex: 1 1 auto;
        -webkit-flex: 1 1 auto;
        flex: 1 1 auto;
      };

      --layout-flex-none: {
        -ms-flex: none;
        -webkit-flex: none;
        flex: none;
      };

      --layout-flex: {
        -ms-flex: 1 1 0.000000001px;
        -webkit-flex: 1;
        flex: 1;
        -webkit-flex-basis: 0.000000001px;
        flex-basis: 0.000000001px;
      };

      --layout-flex-2: {
        -ms-flex: 2;
        -webkit-flex: 2;
        flex: 2;
      };

      --layout-flex-3: {
        -ms-flex: 3;
        -webkit-flex: 3;
        flex: 3;
      };

      --layout-flex-4: {
        -ms-flex: 4;
        -webkit-flex: 4;
        flex: 4;
      };

      --layout-flex-5: {
        -ms-flex: 5;
        -webkit-flex: 5;
        flex: 5;
      };

      --layout-flex-6: {
        -ms-flex: 6;
        -webkit-flex: 6;
        flex: 6;
      };

      --layout-flex-7: {
        -ms-flex: 7;
        -webkit-flex: 7;
        flex: 7;
      };

      --layout-flex-8: {
        -ms-flex: 8;
        -webkit-flex: 8;
        flex: 8;
      };

      --layout-flex-9: {
        -ms-flex: 9;
        -webkit-flex: 9;
        flex: 9;
      };

      --layout-flex-10: {
        -ms-flex: 10;
        -webkit-flex: 10;
        flex: 10;
      };

      --layout-flex-11: {
        -ms-flex: 11;
        -webkit-flex: 11;
        flex: 11;
      };

      --layout-flex-12: {
        -ms-flex: 12;
        -webkit-flex: 12;
        flex: 12;
      };

      /* alignment in cross axis */

      --layout-start: {
        -ms-flex-align: start;
        -webkit-align-items: flex-start;
        align-items: flex-start;
      };

      --layout-center: {
        -ms-flex-align: center;
        -webkit-align-items: center;
        align-items: center;
      };

      --layout-end: {
        -ms-flex-align: end;
        -webkit-align-items: flex-end;
        align-items: flex-end;
      };

      --layout-baseline: {
        -ms-flex-align: baseline;
        -webkit-align-items: baseline;
        align-items: baseline;
      };

      /* alignment in main axis */

      --layout-start-justified: {
        -ms-flex-pack: start;
        -webkit-justify-content: flex-start;
        justify-content: flex-start;
      };

      --layout-center-justified: {
        -ms-flex-pack: center;
        -webkit-justify-content: center;
        justify-content: center;
      };

      --layout-end-justified: {
        -ms-flex-pack: end;
        -webkit-justify-content: flex-end;
        justify-content: flex-end;
      };

      --layout-around-justified: {
        -ms-flex-pack: distribute;
        -webkit-justify-content: space-around;
        justify-content: space-around;
      };

      --layout-justified: {
        -ms-flex-pack: justify;
        -webkit-justify-content: space-between;
        justify-content: space-between;
      };

      --layout-center-center: {
        @apply --layout-center;
        @apply --layout-center-justified;
      };

      /* self alignment */

      --layout-self-start: {
        -ms-align-self: flex-start;
        -webkit-align-self: flex-start;
        align-self: flex-start;
      };

      --layout-self-center: {
        -ms-align-self: center;
        -webkit-align-self: center;
        align-self: center;
      };

      --layout-self-end: {
        -ms-align-self: flex-end;
        -webkit-align-self: flex-end;
        align-self: flex-end;
      };

      --layout-self-stretch: {
        -ms-align-self: stretch;
        -webkit-align-self: stretch;
        align-self: stretch;
      };

      --layout-self-baseline: {
        -ms-align-self: baseline;
        -webkit-align-self: baseline;
        align-self: baseline;
      };

      /* multi-line alignment in main axis */

      --layout-start-aligned: {
        -ms-flex-line-pack: start;  /* IE10 */
        -ms-align-content: flex-start;
        -webkit-align-content: flex-start;
        align-content: flex-start;
      };

      --layout-end-aligned: {
        -ms-flex-line-pack: end;  /* IE10 */
        -ms-align-content: flex-end;
        -webkit-align-content: flex-end;
        align-content: flex-end;
      };

      --layout-center-aligned: {
        -ms-flex-line-pack: center;  /* IE10 */
        -ms-align-content: center;
        -webkit-align-content: center;
        align-content: center;
      };

      --layout-between-aligned: {
        -ms-flex-line-pack: justify;  /* IE10 */
        -ms-align-content: space-between;
        -webkit-align-content: space-between;
        align-content: space-between;
      };

      --layout-around-aligned: {
        -ms-flex-line-pack: distribute;  /* IE10 */
        -ms-align-content: space-around;
        -webkit-align-content: space-around;
        align-content: space-around;
      };

      /*******************************
                Other Layout
      *******************************/

      --layout-block: {
        display: block;
      };

      --layout-invisible: {
        visibility: hidden !important;
      };

      --layout-relative: {
        position: relative;
      };

      --layout-fit: {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      };

      --layout-scroll: {
        -webkit-overflow-scrolling: touch;
        overflow: auto;
      };

      --layout-fullbleed: {
        margin: 0;
        height: 100vh;
      };

      /* fixed position */

      --layout-fixed-top: {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
      };

      --layout-fixed-right: {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
      };

      --layout-fixed-bottom: {
        position: fixed;
        right: 0;
        bottom: 0;
        left: 0;
      };

      --layout-fixed-left: {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
      };

    }
  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__font_roboto_roboto_js__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__font_roboto_roboto_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__font_roboto_roboto_js__);


const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      /* Shared Styles */
      --paper-font-common-base: {
        font-family: 'Roboto', 'Noto', sans-serif;
        -webkit-font-smoothing: antialiased;
      };

      --paper-font-common-code: {
        font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
        -webkit-font-smoothing: antialiased;
      };

      --paper-font-common-expensive-kerning: {
        text-rendering: optimizeLegibility;
      };

      --paper-font-common-nowrap: {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      };

      /* Material Font Styles */

      --paper-font-display4: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 112px;
        font-weight: 300;
        letter-spacing: -.044em;
        line-height: 120px;
      };

      --paper-font-display3: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 56px;
        font-weight: 400;
        letter-spacing: -.026em;
        line-height: 60px;
      };

      --paper-font-display2: {
        @apply --paper-font-common-base;

        font-size: 45px;
        font-weight: 400;
        letter-spacing: -.018em;
        line-height: 48px;
      };

      --paper-font-display1: {
        @apply --paper-font-common-base;

        font-size: 34px;
        font-weight: 400;
        letter-spacing: -.01em;
        line-height: 40px;
      };

      --paper-font-headline: {
        @apply --paper-font-common-base;

        font-size: 24px;
        font-weight: 400;
        letter-spacing: -.012em;
        line-height: 32px;
      };

      --paper-font-title: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 20px;
        font-weight: 500;
        line-height: 28px;
      };

      --paper-font-subhead: {
        @apply --paper-font-common-base;

        font-size: 16px;
        font-weight: 400;
        line-height: 24px;
      };

      --paper-font-body2: {
        @apply --paper-font-common-base;

        font-size: 14px;
        font-weight: 500;
        line-height: 24px;
      };

      --paper-font-body1: {
        @apply --paper-font-common-base;

        font-size: 14px;
        font-weight: 400;
        line-height: 20px;
      };

      --paper-font-caption: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 12px;
        font-weight: 400;
        letter-spacing: 0.011em;
        line-height: 20px;
      };

      --paper-font-menu: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 13px;
        font-weight: 500;
        line-height: 24px;
      };

      --paper-font-button: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 14px;
        font-weight: 500;
        letter-spacing: 0.018em;
        line-height: 24px;
        text-transform: uppercase;
      };

      --paper-font-code2: {
        @apply --paper-font-common-code;

        font-size: 14px;
        font-weight: 700;
        line-height: 20px;
      };

      --paper-font-code1: {
        @apply --paper-font-common-code;

        font-size: 14px;
        font-weight: 500;
        line-height: 20px;
      };

    }

  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




const IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function() {
        return !this.shadowRoot && !__WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */];
      }
    }
  },

  observers: [
    '_changedControlState(focused, disabled)'
  ],

  ready: function() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (__WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */]) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */(Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).localTarget);
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, {sourceEvent: event}, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronControlState;



/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_ripple_paper_ripple_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_button_state_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





const PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object,
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_button_state_js__["b" /* IronButtonStateImpl */]._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this._rippleContainer || this);
        var target = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */(target))) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function() {
    return /** @type {!PaperRippleElement} */ (
        document.createElement('paper-ripple'));
  },

  _noinkChanged: function(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperRippleBehavior;



/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return nativeShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return nativeCssVariables; });
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



let nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
let nativeCssVariables;

/**
 * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings
 */
function calcCssVariables(settings) {
  if (settings && settings['shimcssproperties']) {
    nativeCssVariables = false;
  } else {
    // chrome 49 has semi-working css vars, check if box-shadow works
    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
    // However, shim css custom properties are only supported with ShadyDOM enabled,
    // so fall back on native if we do not detect ShadyDOM
    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/
    nativeCssVariables = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) &&
      window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));
  }
}

if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {
  nativeCssVariables = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS);
  // reset window variable to let ShadyCSS API take its place
  window.ShadyCSS = undefined;
} else {
  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
}

/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export StyleNode */
/* harmony export (immutable) */ __webpack_exports__["a"] = parse;
/* harmony export (immutable) */ __webpack_exports__["b"] = stringify;
/* unused harmony export removeCustomPropAssignment */
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/*
Extremely simple css parser. Intended to be not more than what we need
and definitely not necessarily correct =).
*/



/** @unrestricted */
class StyleNode {
  constructor() {
    /** @type {number} */
    this['start'] = 0;
    /** @type {number} */
    this['end'] = 0;
    /** @type {StyleNode} */
    this['previous'] = null;
    /** @type {StyleNode} */
    this['parent'] = null;
    /** @type {Array<StyleNode>} */
    this['rules'] = null;
    /** @type {string} */
    this['parsedCssText'] = '';
    /** @type {string} */
    this['cssText'] = '';
    /** @type {boolean} */
    this['atRule'] = false;
    /** @type {number} */
    this['type'] = 0;
    /** @type {string} */
    this['keyframesName'] = '';
    /** @type {string} */
    this['selector'] = '';
    /** @type {string} */
    this['parsedSelector'] = '';
  }
}



// given a string of css, return a simple rule tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function parse(text) {
  text = clean(text);
  return parseCss(lex(text), text);
}

// remove stuff we don't care about that may hinder parsing
/**
 * @param {string} cssText
 * @return {string}
 */
function clean(cssText) {
  return cssText.replace(RX.comments, '').replace(RX.port, '');
}

// super simple {...} lexer that returns a node tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function lex(text) {
  let root = new StyleNode();
  root['start'] = 0;
  root['end'] = text.length
  let n = root;
  for (let i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n['rules']) {
        n['rules'] = [];
      }
      let p = n;
      let previous = p['rules'][p['rules'].length - 1] || null;
      n = new StyleNode();
      n['start'] = i + 1;
      n['parent'] = p;
      n['previous'] = previous;
      p['rules'].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n['end'] = i + 1;
      n = n['parent'] || root;
    }
  }
  return root;
}

// add selectors/cssText to node tree
/**
 * @param {StyleNode} node
 * @param {string} text
 * @return {StyleNode}
 */
function parseCss(node, text) {
  let t = text.substring(node['start'], node['end'] - 1);
  node['parsedCssText'] = node['cssText'] = t.trim();
  if (node['parent']) {
    let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];
    t = text.substring(ss, node['start'] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, ' ');
    // TODO(sorvell): ad hoc; make selector include only after last ;
    // helps with mixin syntax
    t = t.substring(t.lastIndexOf(';') + 1);
    let s = node['parsedSelector'] = node['selector'] = t.trim();
    node['atRule'] = (s.indexOf(AT_START) === 0);
    // note, support a subset of rule types...
    if (node['atRule']) {
      if (s.indexOf(MEDIA_START) === 0) {
        node['type'] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node['type'] = types.KEYFRAMES_RULE;
        node['keyframesName'] =
          node['selector'].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node['type'] = types.MIXIN_RULE;
      } else {
        node['type'] = types.STYLE_RULE;
      }
    }
  }
  let r$ = node['rules'];
  if (r$) {
    for (let i = 0, l = r$.length, r;
      (i < l) && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }
  return node;
}

/**
 * conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
 * expanded form that doesn't require trailing space `\000033`
 * @param {string} s
 * @return {string}
 */
function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
    let code = arguments[1],
      repeat = 6 - code.length;
    while (repeat--) {
      code = '0' + code;
    }
    return '\\' + code;
  });
}

/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */
function stringify(node, preserveProperties, text = '') {
  // calc rule cssText
  let cssText = '';
  if (node['cssText'] || node['rules']) {
    let r$ = node['rules'];
    if (r$ && !_hasMixinRules(r$)) {
      for (let i = 0, l = r$.length, r;
        (i < l) && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node['cssText'] :
        removeCustomProps(node['cssText']);
      cssText = cssText.trim();
      if (cssText) {
        cssText = '  ' + cssText + '\n';
      }
    }
  }
  // emit rule if there is cssText
  if (cssText) {
    if (node['selector']) {
      text += node['selector'] + ' ' + OPEN_BRACE + '\n';
    }
    text += cssText;
    if (node['selector']) {
      text += CLOSE_BRACE + '\n\n';
    }
  }
  return text;
}

/**
 * @param {Array<StyleNode>} rules
 * @return {boolean}
 */
function _hasMixinRules(rules) {
  let r = rules[0];
  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropAssignment(cssText) {
  return cssText
    .replace(RX.customProp, '')
    .replace(RX.mixinProp, '');
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropApply(cssText) {
  return cssText
    .replace(RX.mixinApply, '')
    .replace(RX.varApply, '');
}

/** @enum {number} */
const types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1000
}
/* harmony export (immutable) */ __webpack_exports__["c"] = types;


const OPEN_BRACE = '{';
const CLOSE_BRACE = '}';

// helper regexp's
const RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
}

const VAR_START = '--';
const MEDIA_START = '@media';
const AT_START = '@';


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
/* harmony export (immutable) */ __webpack_exports__["c"] = VAR_ASSIGN;

const MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
/* harmony export (immutable) */ __webpack_exports__["b"] = MIXIN_MATCH;

const VAR_CONSUMED = /(--[\w-]+)\s*([:,;)]|$)/gi;
/* unused harmony export VAR_CONSUMED */

const ANIMATION_MATCH = /(animation\s*:)|(animation-name\s*:)/;
/* unused harmony export ANIMATION_MATCH */

const MEDIA_MATCH = /@media\s(.*)/;
/* harmony export (immutable) */ __webpack_exports__["a"] = MEDIA_MATCH;

const IS_VAR = /^--/;
/* unused harmony export IS_VAR */

const BRACKETED = /\{[^}]*\}/g;
/* unused harmony export BRACKETED */

const HOST_PREFIX = '(?:^|[^.#[:])';
/* unused harmony export HOST_PREFIX */

const HOST_SUFFIX = '($|[.:[\\s>+~])';
/* unused harmony export HOST_SUFFIX */



/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = updateNativeProperties;
/* harmony export (immutable) */ __webpack_exports__["b"] = getComputedStyleValue;
/* harmony export (immutable) */ __webpack_exports__["a"] = detectMixin;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_regex_js__ = __webpack_require__(22);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/





/**
 * @param {Element} element
 * @param {Object=} properties
 */
function updateNativeProperties(element, properties) {
  // remove previous properties
  for (let p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}

/**
 * @param {Element} element
 * @param {string} property
 * @return {string}
 */
function getComputedStyleValue(element, property) {
  /**
   * @const {string}
   */
  const value = window.getComputedStyle(element).getPropertyValue(property);
  if (!value) {
    return '';
  } else {
    return value.trim();
  }
}

/**
 * return true if `cssText` contains a mixin definition or consumption
 * @param {string} cssText
 * @return {boolean}
 */
function detectMixin(cssText) {
  const has = __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["b" /* MIXIN_MATCH */].test(cssText) || __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["c" /* VAR_ASSIGN */].test(cssText);
  // reset state of the regexes
  __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["b" /* MIXIN_MATCH */].lastIndex = 0;
  __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["c" /* VAR_ASSIGN */].lastIndex = 0;
  return has;
}


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export instanceCount */
/* unused harmony export _regLog */
/* unused harmony export register */
/* unused harmony export dumpRegistrations */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__property_effects_js__ = __webpack_require__(26);










const ElementMixin = Object(__WEBPACK_IMPORTED_MODULE_2__utils_mixin_js__["a" /* dedupingMixin */])(base => {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_PropertyEffects}
   */
  const polymerElementBase = Object(__WEBPACK_IMPORTED_MODULE_7__property_effects_js__["a" /* PropertyEffects */])(base);

  let caseMap = __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__;

  /**
   * Returns the `properties` object specifically on `klass`. Use for:
   * (1) super chain mixes togther to make `propertiesForClass` which is
   * then used to make `observedAttributes`.
   * (2) properties effects and observers are created from it at `finalize` time.
   *
   * @param {HTMLElement} klass Element class
   * @return {Object} Object containing own properties for this class
   * @private
   */
  function ownPropertiesForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__ownProperties', klass))) {
      klass.__ownProperties =
        klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
        /** @type PolymerElementConstructor */ (klass).properties : {};
    }
    return klass.__ownProperties;
  }

  /**
   * Returns the `observers` array specifically on `klass`. Use for
   * setting up observers.
   *
   * @param {HTMLElement} klass Element class
   * @return {Array} Array containing own observers for this class
   * @private
   */
  function ownObserversForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__ownObservers', klass))) {
      klass.__ownObservers =
        klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
        /** @type PolymerElementConstructor */ (klass).observers : [];
    }
    return klass.__ownObservers;
  }

  /**
   * Mixes `props` into `flattenedProps` but upgrades shorthand type
   * syntax to { type: Type}.
   *
   * @param {Object} flattenedProps Bag to collect flattened properties into
   * @param {Object} props Bag of properties to add to `flattenedProps`
   * @return {Object} The input `flattenedProps` bag
   * @private
   */
  function flattenProperties(flattenedProps, props) {
    for (let p in props) {
      let o = props[p];
      if (typeof o == 'function') {
        o = { type: o };
      }
      flattenedProps[p] = o;
    }
    return flattenedProps;
  }

  /**
   * Returns a flattened list of properties mixed together from the chain of all
   * constructor's `config.properties`. This list is used to create
   * (1) observedAttributes,
   * (2) class property default values
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   * @suppress {missingProperties} class.prototype is not a property for some reason?
   * @private
   */
  function propertiesForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__classProperties', klass))) {
      klass.__classProperties =
      flattenProperties({}, ownPropertiesForClass(klass));
      let superCtor = Object.getPrototypeOf(klass.prototype).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        klass.__classProperties = Object.assign(
          Object.create(propertiesForClass(/** @type PolymerElementConstructor */(superCtor))),
          klass.__classProperties);
      }
    }
    return klass.__classProperties;
  }

  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `propertiesForClass`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */
  function propertyDefaultsForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
      klass.__classPropertyDefaults = null;
      let props = propertiesForClass(klass);
      for (let p in props) {
        let info = props[p];
        if ('value' in info) {
          klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
          klass.__classPropertyDefaults[p] = info;
        }
      }
    }
    return klass.__classPropertyDefaults;
  }

  /**
   * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
   * @param {PolymerElementConstructor} klass Element class
   * @return {boolean} True if all metaprogramming for this class has been
   *   completed
   * @private
   */
  function hasClassFinalized(klass) {
    return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
  }

  /**
   * Called by `ElementClass.finalize()`. Ensures this `klass` and
   * *all superclasses* are finalized by traversing the prototype chain
   * and calling `klass.finalize()`.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClassAndSuper(klass) {
    let proto = /** @type PolymerElementConstructor */ (klass).prototype;
    let superCtor = Object.getPrototypeOf(proto).constructor;
    if (superCtor.prototype instanceof PolymerElement) {
      superCtor.finalize();
    }
    finalizeClass(klass);
  }

  /**
   * Configures a `klass` based on a staic `klass.config` object and
   * a `template`. This includes creating accessors and effects
   * for properties in `config` and the `template` as well as preparing the
   * `template` for stamping.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClass(klass) {
    klass.__finalized = true;
    let proto = /** @type PolymerElementConstructor */ (klass).prototype;
    if (klass.hasOwnProperty(
      JSCompiler_renameProperty('is', klass)) && klass.is) {
      register(proto);
    }
    let props = ownPropertiesForClass(klass);
    if (props) {
      finalizeProperties(proto, props);
    }
    let observers = ownObserversForClass(klass);
    if (observers) {
      finalizeObservers(proto, observers, props);
    }
    // note: create "working" template that is finalized at instance time
    let template = /** @type PolymerElementConstructor */ (klass).template;
    if (template) {
      if (typeof template === 'string') {
        let t = document.createElement('template');
        t.innerHTML = template;
        template = t;
      } else {
        template = template.cloneNode(true);
      }
      proto._template = template;
    }
  }

  /**
   * Configures a `proto` based on a `properties` object.
   * Leverages `PropertyEffects` to create property accessors and effects
   * supporting, observers, reflecting to attributes, change notification,
   * computed properties, and read only properties.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *    and effects to
   * @param {Object} properties Flattened bag of property descriptors for
   *    this class
   * @private
   */
  function finalizeProperties(proto, properties) {
    for (let p in properties) {
      createPropertyFromConfig(proto, p, properties[p], properties);
    }
  }

  /**
   * Configures a `proto` based on a `observers` array.
   * Leverages `PropertyEffects` to create observers.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {Object} observers Flattened array of observer descriptors for
   *   this class
   * @param {Object} dynamicFns Object containing keys for any properties
   *   that are functions and should trigger the effect when the function
   *   reference is changed
   * @private
   */
  function finalizeObservers(proto, observers, dynamicFns) {
    for (let i=0; i < observers.length; i++) {
      proto._createMethodObserver(observers[i], dynamicFns);
    }
  }

  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should may contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is dersialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * also automatically is set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttriute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   * Also consider adding warnings when an effect cannot be changed.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @private
   */
  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    }
    // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.
    if (info.computed  && !proto._hasReadOnlyEffect(name)) {
      proto._createComputedProperty(name, info.computed, allProps);
    }
    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    }
    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    }
    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    }
    // always add observer
    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
  }

  /**
   * Configures an element `proto` to function with a given `template`.
   * The element name `is` and extends `ext` must be specified for ShadyCSS
   * style scoping.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {!HTMLTemplateElement} template Template to process and bind
   * @param {string} baseURI URL against which to resolve urls in
   *   style element cssText
   * @param {string} is Tag name (or type extension name) for this element
   * @param {string=} ext For type extensions, the tag name that was extended
   * @private
   */
  function finalizeTemplate(proto, template, baseURI, is, ext) {
    // support `include="module-name"`
    let cssText =
      Object(__WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__["a" /* cssFromModuleImports */])(is) +
      Object(__WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__["c" /* cssFromTemplate */])(template, baseURI);
    if (cssText) {
      let style = document.createElement('style');
      style.textContent = cssText;
      template.content.insertBefore(style, template.content.firstChild);
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is, ext);
    }
    proto._bindTemplate(template);
  }

  /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   */
  class PolymerElement extends polymerElementBase {

    /**
     * Standard Custom Elements V1 API.  The default implementation returns
     * a list of dash-cased attributes based on a flattening of all properties
     * declared in `static get properties()` for this element and any
     * superclasses.
     *
     * @return {Array} Observed attribute list
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
        let list = [];
        let properties = propertiesForClass(this);
        for (let prop in properties) {
          list.push(Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["camelToDashCase"])(prop));
        }
        this.__observedAttributes = list;
      }
      return this.__observedAttributes;
    }

    /**
     * Called automatically when the first element instance is created to
     * ensure that class finalization work has been completed.
     * May be called by users to eagerly perform class finalization work
     * prior to the creation of the first element instance.
     *
     * Class finalization work generally includes meta-programming such as
     * creating property accessors and any property effect metadata needed for
     * the features used.
     *
     * @public
     */
    static finalize() {
      if (!hasClassFinalized(this)) {
        finalizeClassAndSuper(this);
      }
    }

    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation
     * will return the first `<template>` in a `dom-module` whose `id`
     * matches this element's `is`.
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * may be either an `HTMLTemplateElement` or a string that will be
     * automatically parsed into a template.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `Polymer.DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {HTMLTemplateElement|string} Template to be stamped
     */
    static get template() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
        this._template = __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */].import(
          /** @type PolymerElementConstructor*/ (this).is, 'template') ||
          // note: implemented so a subclass can retrieve the super
          // template; call the super impl this way so that `this` points
          // to the superclass.
          Object.getPrototypeOf(/** @type PolymerElementConstructor*/ (this).prototype).constructor.template;
      }
      return this._template;
    }

    /**
     * Path matching the url from which the element was imported.
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     * Defaults to the path matching the url containing a `dom-module` element
     * matching this element's static `is` property.
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     */
    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
          const module = __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */].import(/** @type PolymerElementConstructor */ (this).is);
          this._importPath = module ? module.assetpath : '' ||
          Object.getPrototypeOf(/** @type PolymerElementConstructor*/ (this).prototype).constructor.importPath;
      }
      return this._importPath;
    }

    constructor() {
      super();
      /** @type {HTMLTemplateElement} */
      this._template;
      /** @type {string} */
      this._importPath;
      /** @type {string} */
      this.rootPath;
      /** @type {string} */
      this.importPath;
      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */
      this.root;
      /** @type {!Object<string, !Node>} */
      this.$;
    }

    /**
     * Overrides the default `Polymer.PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @override
     * @suppress {invalidCasts}
     */
    _initializeProperties() {
      instanceCount++;
      this.constructor.finalize();
      const importPath = this.constructor.importPath;
      // note: finalize template when we have access to `localName` to
      // avoid dependence on `is` for polyfilling styling.
      if (this._template && !this._template.__polymerFinalized) {
        this._template.__polymerFinalized = true;
        const baseURI =
          importPath ? Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(importPath) : '';
        finalizeTemplate(/** @type {!PolymerElement} */(this.__proto__), this._template, baseURI,
          /**@type {!HTMLElement}*/(this).localName);
      }
      super._initializeProperties();
      // set path defaults
      this.rootPath = __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__["b" /* rootPath */];
      this.importPath = importPath;
      // apply property defaults...
      let p$ = propertyDefaultsForClass(this.constructor);
      if (!p$) {
        return;
      }
      for (let p in p$) {
        let info = p$[p];
        // Don't set default value if there is already an own property, which
        // happens when a `properties` property with default but no effects had
        // a property set (e.g. bound) by its host before upgrade
        if (!this.hasOwnProperty(p)) {
          let value = typeof info.value == 'function' ?
            info.value.call(this) :
            info.value;
          // Set via `_setProperty` if there is an accessor, to enable
          // initializing readOnly property defaults
          if (this._hasAccessor(p)) {
            this._setPendingProperty(p, value, true);
          } else {
            this[p] = value;
          }
        }
      }
    }

    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @suppress {invalidCasts}
     */
    connectedCallback() {
      if (window.ShadyCSS && this._template) {
        window.ShadyCSS.styleElement(/** @type {!HTMLElement} */(this));
      }
      this._enableProperties();
    }

    /**
     * Provides a default implementation of the standard Custom Elements
     * `disconnectedCallback`.
     */
    disconnectedCallback() {}

    /**
     * Stamps the element template.
     *
     * @override
     */
    ready() {
      if (this._template) {
        this.root = this._stampTemplate(this._template);
        this.$ = this.root.$;
      }
      super.ready();
    }

    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @override
     */
    _readyClients() {
      if (this._template) {
        this.root = this._attachDom(/** @type {StampedTemplate} */(this.root));
      }
      // The super._readyClients here sets the clients initialized flag.
      // We must wait to do this until after client dom is created/attached
      // so that this flag can be checked to prevent notifications fired
      // during this process from being handled before clients are ready.
      super._readyClients();
    }


    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */
    _attachDom(dom) {
      if (this.attachShadow) {
        if (dom) {
          if (!this.shadowRoot) {
            this.attachShadow({mode: 'open'});
          }
          this.shadowRoot.appendChild(dom);
          return this.shadowRoot;
        }
        return null;
      } else {
        throw new Error('ShadowDOM not available. ' +
          // TODO(sorvell): move to compile-time conditional when supported
        'Polymer.Element can create dom as children instead of in ' +
        'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
      }
    }

    /**
     * Provides a default implementation of the standard Custom Elements
     * `attributeChangedCallback`.
     *
     * By default, attributes declared in `properties` metadata are
     * deserialized using their `type` information to properties of the
     * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
     * properties.
     *
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @override
     */
    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        let property = caseMap.dashToCamelCase(name);
        let type = propertiesForClass(this.constructor)[property].type;
        if (!this._hasReadOnlyEffect(property)) {
          this._attributeToProperty(name, value, type);
        }
      }
    }

    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @suppress {invalidCasts}
     */
    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(this), properties);
      }
    }

    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */
    resolveUrl(url, base) {
      if (!base && this.importPath) {
        base = Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(this.importPath);
      }
      return Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(url, base);
    }

    /**
     * Overrides `PropertyAccessors` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @override
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
      return super._parseTemplateContent(template, templateInfo, nodeInfo);
    }

  }

  return PolymerElement;
});
/* harmony export (immutable) */ __webpack_exports__["a"] = ElementMixin;


let instanceCount = 0;
const registrations = [];
/* unused harmony export registrations */


function _regLog(prototype) {
  console.log('[' + prototype.is + ']: registered');
}

function register(prototype) {
  registrations.push(prototype);
  undefined && _regLog(prototype);
}

function dumpRegistrations() {
  registrations.forEach(_regLog);
}

const updateStyles = function(props) {
  if (window.ShadyCSS) {
    window.ShadyCSS.styleDocument(props);
  }
};
/* unused harmony export updateStyles */



/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DomModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__ = __webpack_require__(10);



let modules = {};
let lcModules = {};
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}

function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}

/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */
class DomModule extends HTMLElement {

  static get observedAttributes() { return ['id']; }

  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   */
  static import(id, selector) {
    if (id) {
      let m = findModule(id);
      if (m && selector) {
        return m.querySelector(selector);
      }
      return m;
    }
    return null;
  }

  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this.register();
    }
  }

  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */
  get assetpath() {
    // Don't override existing assetpath.
    if (!this.__assetpath) {
      // note: assetpath set via an attribute must be relative to this
      // element's location; accomodate polyfilled HTMLImports
      const owner = window.HTMLImports && HTMLImports.importForElement ?
        HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = Object(__WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__["c" /* resolveUrl */])(
        this.getAttribute('assetpath') || '', owner.baseURI);
      this.__assetpath = Object(__WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__["a" /* pathFromUrl */])(url);
    }
    return this.__assetpath;
  }

  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   */
  register(id) {
    id = id || this.id;
    if (id) {
      this.id = id;
      // store id separate from lowercased id so that
      // in all cases mixedCase id will stored distinctly
      // and lowercase version is a fallback
      modules[id] = this;
      lcModules[id.toLowerCase()] = this;
      styleOutsideTemplateCheck(this);
    }
  }
}

DomModule.prototype['modules'] = modules;

customElements.define('dom-module', DomModule);




/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_path_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__property_accessors_js__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__template_stamp_js__ = __webpack_require__(58);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_settings_js__ = __webpack_require__(9);









/** @const {Object} */
const CaseMap = __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__;

// Monotonically increasing unique ID used for de-duping effects triggered
// from multiple properties in the same turn
let dedupeId = 0;

/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */
const TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};

/**
 * @typedef {{
 * name: (string | undefined),
 * structured: (boolean | undefined),
 * wildcard: (boolean | undefined)
 * }}
 */
let DataTrigger; //eslint-disable-line no-unused-vars

/**
 * @typedef {{
 * info: ?,
 * trigger: (!DataTrigger | undefined),
 * fn: (!Function | undefined)
 * }}
 */
let DataEffect; //eslint-disable-line no-unused-vars

let PropertyEffectsType; //eslint-disable-line no-unused-vars

/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @return {Object} The own-property map of effects for the given type
 * @private
 */
function ensureOwnEffectMap(model, type) {
  let effects = model[type];
  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);
    for (let p in effects) {
      let protoFx = effects[p];
      let instFx = effects[p] = Array(protoFx.length);
      for (let i=0; i<protoFx.length; i++) {
        instFx[i] = protoFx[i];
      }
    }
  }
  return effects;
}

// -- effects ----------------------------------------------

/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {Object} props Bag of current property changes
 * @param {Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    let ran = false;
    let id = dedupeId++;
    for (let prop in props) {
      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
        ran = true;
      }
    }
    return ran;
  }
  return false;
}

/**
 * Runs a list of effects for a given property.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  let ran = false;
  let rootProperty = hasPaths ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(prop) : prop;
  let fxs = effects[rootProperty];
  if (fxs) {
    for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) &&
          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }
        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }
  return ran;
}

/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */
function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    let triggerPath = trigger.name;
    return (triggerPath == path) ||
      (trigger.structured && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["b" /* isAncestor */])(triggerPath, path)) ||
      (trigger.wildcard && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(triggerPath, path));
  } else {
    return true;
  }
}

/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runObserverEffect(inst, property, props, oldProps, info) {
  let fn = inst[info.methodName];
  let changedProp = info.property;
  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.methodName + '` not defined');
  }
}

/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  // Notify
  let fxs = inst[TYPES.NOTIFY];
  let notified;
  let id = dedupeId++;
  // Try normal notify effects; if none, fall back to try path notification
  for (let prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  }
  // Flush host if we actually notified and host was batching
  // And the host has already initialized clients; this prevents
  // an issue with a host observing data changes before clients are ready.
  let host;
  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}

/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */
function notifyPath(inst, path, props) {
  let rootProperty = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(path);
  if (rootProperty !== path) {
    let eventName = Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["camelToDashCase"])(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }
  return false;
}

/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} eventName The name of the event to send ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property changed, the path
 *   that changed (optional).
 * @private
 * @suppress {invalidCasts}
 */
function dispatchNotifyEvent(inst, eventName, value, path) {
  let detail = {
    value: value,
    queueProperty: true
  };
  if (path) {
    detail.path = path;
  }
  /** @type {!HTMLElement} */(inst).dispatchEvent(new CustomEvent(eventName, { detail }));
}

/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  let rootProperty = hasPaths ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(property) : property;
  let path = rootProperty != property ? property : null;
  let value = path ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, path) : inst.__data[property];
  if (path && value === undefined) {
    value = props[property];  // specifically for .splices
  }
  dispatchNotifyEvent(inst, info.eventName, value, path);
}

/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!PropertyEffectsType} inst Host element instance handling the notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @private
 */
function handleNotification(event, inst, fromProp, toPath, negate) {
  let value;
  let detail = /** @type {Object} */(event.detail);
  let fromPath = detail && detail.path;
  if (fromPath) {
    toPath = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.target[fromProp];
  }
  value = negate ? !value : value;
  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))
      && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}

/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runReflectEffect(inst, property, props, oldProps, info) {
  let value = inst.__data[property];
  if (__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */]) {
    value = Object(__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */])(value, info.attrName, 'attribute', /** @type {Node} */(inst));
  }
  inst._propertyToAttribute(property, info.attrName, value);
}

/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {!Object} changedProps Bag of changed properties
 * @param {!Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  let computeEffects = inst[TYPES.COMPUTE];
  if (computeEffects) {
    let inputProps = changedProps;
    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
      Object.assign(oldProps, inst.__dataOld);
      Object.assign(changedProps, inst.__dataPending);
      inputProps = inst.__dataPending;
      inst.__dataPending = null;
    }
  }
}

/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runComputedEffect(inst, property, props, oldProps, info) {
  let result = runMethodEffect(inst, property, props, oldProps, info);
  let computedProp = info.methodInfo;
  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
  }
}

/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!PropertyEffectsType} inst The instance whose props are changing
 * @param {string | !Array<(string|number)>} path Path that has changed
 * @param {*} value Value of changed path
 * @private
 */
function computeLinkedPaths(inst, path, value) {
  let links = inst.__dataLinkedPaths;
  if (links) {
    let link;
    for (let a in links) {
      let b = links[a];
      if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(a, path)) {
        link = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(a, b, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(b, path)) {
        link = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(b, a, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
}

// -- bindings ----------------------------------------------

/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @private
 */
function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  // Create binding metadata and add to nodeInfo
  nodeInfo.bindings = nodeInfo.bindings || [];
  let /** Binding */ binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };
  nodeInfo.bindings.push(binding);
  // Add listener info to binding metadata
  if (shouldAddListener(binding)) {
    let {event, negate} = binding.parts[0];
    binding.listenerEvent = event || (CaseMap.camelToDashCase(target) + '-changed');
    binding.listenerNegate = negate;
  }
  // Add "propagate" property effects to templateInfo
  let index = templateInfo.nodeInfoList.length;
  for (let i=0; i<binding.parts.length; i++) {
    let part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}

/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 */
function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target +
        ' because "-" is not a valid attribute starting character');
    } else {
      let dependencies = part.dependencies;
      let info = { index, binding, part, evaluator: constructor };
      for (let j=0; j<dependencies.length; j++) {
        let trigger = dependencies[j];
        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }
        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info, trigger
        });
      }
    }
  }
}

/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @private
 */
function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  let node = nodeList[info.index];
  let binding = info.binding;
  let part = info.part;
  // Subpath notification: transform path and set to client
  // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
  if (hasPaths && part.source && (path.length > part.source.length) &&
      (binding.kind == 'property') && !binding.isCompound &&
      node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    let value = props[path];
    path = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(part.source, binding.target, path);
    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
    // Propagate value to child
    applyBindingValue(inst, node, binding, part, value);
  }
}

/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!PropertyEffectsType} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @private
 */
function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);
  if (__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */]) {
    value = Object(__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */])(value, binding.target, binding.kind, node);
  }
  if (binding.kind == 'attribute') {
    // Attribute binding
    inst._valueToNodeAttribute(/** @type {Element} */(node), value, binding.target);
  } else {
    // Property binding
    let prop = binding.target;
    if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else  {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}

/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */
function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }
  if (binding.kind !== 'attribute') {
    // Some browsers serialize `undefined` to `"undefined"`
    if (binding.target === 'textContent' ||
        (node.localName == 'input' && binding.target == 'value')) {
      value = value == undefined ? '' : value;
    }
  }
  return value;
}

/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */
function shouldAddListener(binding) {
  return Boolean(binding.target) &&
         binding.kind != 'attribute' &&
         binding.kind != 'text' &&
         !binding.isCompound &&
         binding.parts[0].mode === '{';
}

/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!PropertyEffectsType} inst Instance that bas been previously bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @private
 */
function setupBindings(inst, templateInfo) {
  // Setup compound storage, dataHost, and notify listeners
  let {nodeList, nodeInfoList} = templateInfo;
  if (nodeInfoList.length) {
    for (let i=0; i < nodeInfoList.length; i++) {
      let info = nodeInfoList[i];
      let node = nodeList[i];
      let bindings = info.bindings;
      if (bindings) {
        for (let i=0; i<bindings.length; i++) {
          let binding = bindings[i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }
      node.__dataHost = inst;
    }
  }
}

/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @private
 */
function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    // Create compound storage map
    let storage = node.__dataCompoundStorage ||
      (node.__dataCompoundStorage = {});
    let parts = binding.parts;
    // Copy literals from parts into storage for this binding
    let literals = new Array(parts.length);
    for (let j=0; j<parts.length; j++) {
      literals[j] = parts[j].literal;
    }
    let target = binding.target;
    storage[target] = literals;
    // Configure properties with their literal parts
    if (binding.literal && binding.kind == 'property') {
      node[target] = binding.literal;
    }
  }
}

/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!PropertyEffectsType} inst Host element instance to handle notification event
 * @param {Binding} binding Binding metadata
 * @private
 */
function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    let part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function(e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
}

// -- for method-based effects (complexObserver & computed) --------------

/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @private
 */
function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || (dynamicFn &&
    (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));
  let info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo,
    dynamicFn
  };
  for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn, info: info, trigger: arg
      });
    }
  }
  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn, info: info
    });
  }
}

/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */
function runMethodEffect(inst, property, props, oldProps, info) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  let context = inst._methodHost || inst;
  let fn = context[info.methodName];
  if (fn) {
    let args = marshalArgs(inst.__data, info.args, property, props);
    return fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}

const emptyArray = [];

// Regular expressions used for binding
const IDENT  = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
const NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
const SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
const DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' +  STRING + ')\\s*' + ')';
const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
const ARGUMENT_LIST = '(?:' + '\\(\\s*' +
                              '(?:' + ARGUMENTS + '?' + ')' +
                            '\\)\\s*' + ')';
const BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
const OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
const CLOSE_BRACKET = '(?:]]|}})';
const NEGATE = '(?:(!)\\s*)?'; // Group 2
const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");

/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */
function literalFromParts(parts) {
  let s = '';
  for (let i=0; i<parts.length; i++) {
    let literal = parts[i].literal;
    s += literal || '';
  }
  return s;
}

/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */
function parseMethod(expression) {
  // tries to match valid javascript property names
  let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m) {
    let methodName = m[1];
    let sig = { methodName, static: true, args: emptyArray };
    if (m[2].trim()) {
      // replace escaped commas with comma entity, split on un-escaped commas
      let args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }
  return null;
}

/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */
function parseArgs(argList, sig) {
  sig.args = argList.map(function(rawArg) {
    let arg = parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}

/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */
function parseArg(rawArg) {
  // clean up whitespace
  let arg = rawArg.trim()
    // replace comma entity with comma
    .replace(/&comma;/g, ',')
    // repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '\$1')
    ;
  // basic argument descriptor
  let a = {
    name: arg,
    value: '',
    literal: false
  };
  // detect literal value (must be String or Number)
  let fc = arg[0];
  if (fc === '-') {
    fc = arg[1];
  }
  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }
  switch(fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;
    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  }
  // if not literal, look for structured path
  if (!a.literal) {
    a.rootProperty = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(arg);
    // detect structured path (has dots)
    a.structured = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(arg);
    if (a.structured) {
      a.wildcard = (arg.slice(-2) == '.*');
      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }
  return a;
}

/**
 * Gather the argument values for a method specified in the provided array
 * of argument metadata.
 *
 * The `path` and `value` arguments are used to fill in wildcard descriptor
 * when the method is being called as a result of a path notification.
 *
 * @param {Object} data Instance data storage object to read properties from
 * @param {!Array<!MethodArg>} args Array of argument metadata
 * @param {string} path Property/path name that triggered the method effect
 * @param {Object} props Bag of current property changes
 * @return {Array<*>} Array of argument values
 * @private
 */
function marshalArgs(data, args, path, props) {
  let values = [];
  for (let i=0, l=args.length; i<l; i++) {
    let arg = args[i];
    let name = arg.name;
    let v;
    if (arg.literal) {
      v = arg.value;
    } else {
      if (arg.structured) {
        v = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(data, name);
        // when data is not stored e.g. `splices`
        if (v === undefined) {
          v = props[name];
        }
      } else {
        v = data[name];
      }
    }
    if (arg.wildcard) {
      // Only send the actual path changed info if the change that
      // caused the observer to run matched the wildcard
      let baseChanged = (name.indexOf(path + '.') === 0);
      let matches = (path.indexOf(name) === 0 && !baseChanged);
      values[i] = {
        path: matches ? path : name,
        value: matches ? props[path] : v,
        base: v
      };
    } else {
      values[i] = v;
    }
  }
  return values;
}

// data api

/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @private
 */
function notifySplices(inst, array, path, splices) {
  let splicesPath = path + '.splices';
  inst.notifyPath(splicesPath, { indexSplices: splices });
  inst.notifyPath(path + '.length', array.length);
  // Null here to allow potentially large splice records to be GC'ed.
  inst.__data[splicesPath] = {indexSplices: null};
}

/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @private
 */
function notifySplice(inst, array, path, index, addedCount, removed) {
  notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}

/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}

const PropertyEffects = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   */
  const propertyEffectsBase = Object(__WEBPACK_IMPORTED_MODULE_5__template_stamp_js__["a" /* TemplateStamp */])(Object(__WEBPACK_IMPORTED_MODULE_4__property_accessors_js__["a" /* PropertyAccessors */])(superClass));

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */
  class PropertyEffects extends propertyEffectsBase {

    constructor() {
      super();
      /** @type {boolean} */
      this.__dataClientsReady;
      /** @type {Array} */
      this.__dataPendingClients;
      /** @type {Object} */
      this.__dataToNotify;
      /** @type {Object} */
      this.__dataLinkedPaths;
      /** @type {boolean} */
      this.__dataHasPaths;
      /** @type {Object} */
      this.__dataCompoundStorage;
      /** @type {Polymer_PropertyEffects} */
      this.__dataHost;
      /** @type {!Object} */
      this.__dataTemp;
      /** @type {boolean} */
      this.__dataClientsInitialized;
      /** @type {!Object} */
      this.__data;
      /** @type {!Object} */
      this.__dataPending;
      /** @type {!Object} */
      this.__dataOld;
      /** @type {Object} */
      this.__computeEffects;
      /** @type {Object} */
      this.__reflectEffects;
      /** @type {Object} */
      this.__notifyEffects;
      /** @type {Object} */
      this.__propagateEffects;
      /** @type {Object} */
      this.__observeEffects;
      /** @type {Object} */
      this.__readOnly;
      /** @type {number} */
      this.__dataCounter;
      /** @type {!TemplateInfo} */
      this.__templateInfo;
    }

    get PROPERTY_EFFECT_TYPES() {
      return TYPES;
    }

    _initializeProperties() {
      super._initializeProperties();
      hostStack.registerHost(this);
      this.__dataClientsReady = false;
      this.__dataPendingClients = null;
      this.__dataToNotify = null;
      this.__dataLinkedPaths = null;
      this.__dataHasPaths = false;
      // May be set on instance prior to upgrade
      this.__dataCompoundStorage = this.__dataCompoundStorage || null;
      this.__dataHost = this.__dataHost || null;
      this.__dataTemp = {};
      this.__dataClientsInitialized = false;
    }

    /**
     * Overrides `Polymer.PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     */
    _initializeProtoProperties(props) {
      this.__data = Object.create(props);
      this.__dataPending = Object.create(props);
      this.__dataOld = {};
    }

    /**
     * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     */
    _initializeInstanceProperties(props) {
      let readOnly = this[TYPES.READ_ONLY];
      for (let prop in props) {
        if (!readOnly || !readOnly[prop]) {
          this.__dataPending = this.__dataPending || {};
          this.__dataOld = this.__dataOld || {};
          this.__data[prop] = this.__dataPending[prop] = props[prop];
        }
      }
    }

    // Prototype setup ----------------------------------------

    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @protected
     */
    _addPropertyEffect(property, type, effect) {
      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
      // effects are accumulated into arrays per property based on type
      let effects = ensureOwnEffectMap(this, type)[property];
      if (!effects) {
        effects = this[type][property] = [];
      }
      effects.push(effect);
    }

    /**
     * Removes the given property effect.
     *
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     */
    _removePropertyEffect(property, type, effect) {
      let effects = ensureOwnEffectMap(this, type)[property];
      let idx = effects.indexOf(effect);
      if (idx >= 0) {
        effects.splice(idx, 1);
      }
    }

    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasPropertyEffect(property, type) {
      let effects = this[type];
      return Boolean(effects && effects[property]);
    }

    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasReadOnlyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.READ_ONLY);
    }

    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasNotifyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.NOTIFY);
    }

    /**
     * Returns whether the current prototype/instance has a "reflect to attribute"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasReflectEffect(property) {
      return this._hasPropertyEffect(property, TYPES.REFLECT);
    }

    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasComputedEffect(property) {
      return this._hasPropertyEffect(property, TYPES.COMPUTE);
    }

    // Runtime ----------------------------------------

    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */
    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
      if (isPathNotification ||
          Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(Array.isArray(path) ? path[0] : path) !== path) {
        // Dirty check changes being set to a path against the actual object,
        // since this is the entry point for paths into the system; from here
        // the only dirty checks are against the `__dataTemp` cache to prevent
        // duplicate work in the same turn only. Note, if this was a notification
        // of a change already set to a path (isPathNotification: true),
        // we always let the change through and skip the `set` since it was
        // already dirty checked at the point of entry and the underlying
        // object has already been updated
        if (!isPathNotification) {
          let old = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path);
          path = /** @type {string} */ (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["h" /* set */])(this, path, value));
          // Use property-accessor's simpler dirty check
          if (!path || !super._shouldPropertyChange(path, value, old)) {
            return false;
          }
        }
        this.__dataHasPaths = true;
        if (this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify)) {
          computeLinkedPaths(this, path, value);
          return true;
        }
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
          return this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify);
        } else {
          this[path] = value;
        }
      }
      return false;
    }

    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @param {Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @protected
     */
    _setUnmanagedPropertyToNode(node, prop, value) {
      // It is a judgment call that resetting primitives is
      // "bad" and resettings objects is also "good"; alternatively we could
      // implement a whitelist of tag & property values that should never
      // be reset (e.g. <input>.value && <select>.value)
      if (value !== node[prop] || typeof value == 'object') {
        node[prop] = value;
      }
    }

    /**
     * Overrides the `PropertyAccessors` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChaged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     * @override
     */
    _setPendingProperty(property, value, shouldNotify) {
      let isPath = this.__dataHasPaths && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(property);
      let prevProps = isPath ? this.__dataTemp : this.__data;
      if (this._shouldPropertyChange(property, value, prevProps[property])) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        // Ensure old is captured from the last turn
        if (!(property in this.__dataOld)) {
          this.__dataOld[property] = this.__data[property];
        }
        // Paths are stored in temporary cache (cleared at end of turn),
        // which is used for dirty-checking, all others stored in __data
        if (isPath) {
          this.__dataTemp[property] = value;
        } else {
          this.__data[property] = value;
        }
        // All changes go into pending property bag, passed to _propertiesChanged
        this.__dataPending[property] = value;
        // Track properties that should notify separately
        if (isPath || (this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property])) {
          this.__dataToNotify = this.__dataToNotify || {};
          this.__dataToNotify[property] = shouldNotify;
        }
        return true;
      }
      return false;
    }

    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     */
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value, true)) {
        this._invalidateProperties();
      }
    }

    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     */
    _invalidateProperties() {
      if (this.__dataReady) {
        this._flushProperties();
      }
    }

    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @param {Object} client PropertyEffects client to enqueue
     * @protected
     */
    _enqueueClient(client) {
      this.__dataPendingClients = this.__dataPendingClients || [];
      if (client !== this) {
        this.__dataPendingClients.push(client);
      }
    }

    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @protected
     */
    _flushClients() {
      if (!this.__dataClientsReady) {
        this.__dataClientsReady = true;
        this._readyClients();
        // Override point where accessors are turned on; importantly,
        // this is after clients have fully readied, providing a guarantee
        // that any property effects occur only after all clients are ready.
        this.__dataReady = true;
      } else {
        this.__enableOrFlushClients();
      }
    }

    // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.
    __enableOrFlushClients() {
      let clients = this.__dataPendingClients;
      if (clients) {
        this.__dataPendingClients = null;
        for (let i=0; i < clients.length; i++) {
          let client = clients[i];
          if (!client.__dataEnabled) {
            client._enableProperties();
          } else if (client.__dataPending) {
            client._flushProperties();
          }
        }
      }
    }

    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @protected
     */
    _readyClients() {
      this.__enableOrFlushClients();
    }

    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @public
     */
    setProperties(props, setReadOnly) {
      for (let path in props) {
        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
          //TODO(kschaaf): explicitly disallow paths in setProperty?
          // wildcard observers currently only pass the first changed path
          // in the `info` object, and you could do some odd things batching
          // paths, e.g. {'foo.bar': {...}, 'foo': null}
          this._setPendingPropertyOrPath(path, props[path], true);
        }
      }
      this._invalidateProperties();
    }

    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     */
    ready() {
      // It is important that `super.ready()` is not called here as it
      // immediately turns on accessors. Instead, we wait until `readyClients`
      // to enable accessors to provide a guarantee that clients are ready
      // before processing any accessors side effects.
      this._flushProperties();
      // If no data was pending, `_flushProperties` will not `flushClients`
      // so ensure this is done.
      if (!this.__dataClientsReady) {
        this._flushClients();
      }
      // Before ready, client notifications do not trigger _flushProperties.
      // Therefore a flush is necessary here if data has been set.
      if (this.__dataPending) {
        this._flushProperties();
      }
    }

    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     */
    _propertiesChanged(currentProps, changedProps, oldProps) {
      // ----------------------------
      // let c = Object.getOwnPropertyNames(changedProps || {});
      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
      // if (window.debug) { debugger; }
      // ----------------------------
      let hasPaths = this.__dataHasPaths;
      this.__dataHasPaths = false;
      // Compute properties
      runComputedEffects(this, changedProps, oldProps, hasPaths);
      // Clear notify properties prior to possible reentry (propagate, observe),
      // but after computing effects have a chance to add to them
      let notifyProps = this.__dataToNotify;
      this.__dataToNotify = null;
      // Propagate properties to clients
      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
      // Flush clients
      this._flushClients();
      // Reflect properties
      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
      // Observe properties
      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
      // Notify properties to host
      if (notifyProps) {
        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
      }
      // Clear temporary cache at end of turn
      if (this.__dataCounter == 1) {
        this.__dataTemp = {};
      }
      // ----------------------------
      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
      // ----------------------------
    }

    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @protected
     */
    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
      if (this[TYPES.PROPAGATE]) {
        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
      }
      let templateInfo = this.__templateInfo;
      while (templateInfo) {
        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,
          hasPaths, templateInfo.nodeList);
        templateInfo = templateInfo.nextTemplateInfo;
      }
    }

    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @public
     */
    linkPaths(to, from) {
      to = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(to);
      from = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(from);
      this.__dataLinkedPaths = this.__dataLinkedPaths || {};
      this.__dataLinkedPaths[to] = from;
    }

    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @public
     */
    unlinkPaths(path) {
      path = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(path);
      if (this.__dataLinkedPaths) {
        delete this.__dataLinkedPaths[path];
      }
    }

    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     * @public
    */
    notifySplices(path, splices) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      notifySplices(this, array, info.path, splices);
    }

    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */
    get(path, root) {
      return Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(root || this, path);
    }

    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @public
    */
    set(path, value, root) {
      if (root) {
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["h" /* set */])(root, path, value);
      } else {
        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */(path)]) {
          if (this._setPendingPropertyOrPath(path, value, true)) {
            this._invalidateProperties();
          }
        }
      }
    }

    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */
    push(path, ...items) {
      let info = {path: ''};
      let array = /** @type {Array}*/(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let len = array.length;
      let ret = array.push(...items);
      if (items.length) {
        notifySplice(this, array, info.path, len, items.length, []);
      }
      return ret;
    }

    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    pop(path) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let hadLength = Boolean(array.length);
      let ret = array.pop();
      if (hadLength) {
        notifySplice(this, array, info.path, array.length, 0, [ret]);
      }
      return ret;
    }

    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {Array} Array of removed items.
     * @public
     */
    splice(path, start, deleteCount, ...items) {
      let info = {path : ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      // Normalize fancy native splice handling of crazy start values
      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else {
        start = Math.floor(start);
      }
      if (!start) {
        start = 0;
      }
      let ret = array.splice(start, deleteCount, ...items);
      if (items.length || ret.length) {
        notifySplice(this, array, info.path, start, items.length, ret);
      }
      return ret;
    }

    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    shift(path) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let hadLength = Boolean(array.length);
      let ret = array.shift();
      if (hadLength) {
        notifySplice(this, array, info.path, 0, 0, [ret]);
      }
      return ret;
    }

    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */
    unshift(path, ...items) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let ret = array.unshift(...items);
      if (items.length) {
        notifySplice(this, array, info.path, 0, items.length, []);
      }
      return ret;
    }

    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @public
    */
    notifyPath(path, value) {
      /** @type {string} */
      let propPath;
      if (arguments.length == 1) {
        // Get value if not supplied
        let info = {path: ''};
        value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info);
        propPath = info.path;
      } else if (Array.isArray(path)) {
        // Normalize path if needed
        propPath = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(path);
      } else {
        propPath = /** @type{string} */(path);
      }
      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
        this._invalidateProperties();
      }
    }

    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @protected
     */
    _createReadOnlyProperty(property, protectedSetter) {
      this._addPropertyEffect(property, TYPES.READ_ONLY);
      if (protectedSetter) {
        this['_set' + upper(property)] = /** @this {PropertyEffects} */function(value) {
          this._setProperty(property, value);
        };
      }
    }

    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @param {string} methodName Name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @protected
     */
    _createPropertyObserver(property, methodName, dynamicFn) {
      let info = { property, methodName, dynamicFn: Boolean(dynamicFn) };
      this._addPropertyEffect(property, TYPES.OBSERVE, {
        fn: runObserverEffect, info, trigger: {name: property}
      });
      if (dynamicFn) {
        this._addPropertyEffect(methodName, TYPES.OBSERVE, {
          fn: runObserverEffect, info, trigger: {name: methodName}
        });
      }
    }

    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */
    _createMethodObserver(expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed observer expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
    }

    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @protected
     */
    _createNotifyingProperty(property) {
      this._addPropertyEffect(property, TYPES.NOTIFY, {
        fn: runNotifyEffect,
        info: {
          eventName: CaseMap.camelToDashCase(property) + '-changed',
          property: property
        }
      });
    }

    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @protected
     */
    _createReflectedProperty(property) {
      let attr = CaseMap.camelToDashCase(property);
      if (attr[0] === '-') {
        console.warn('Property ' + property + ' cannot be reflected to attribute ' +
          attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
      } else {
        this._addPropertyEffect(property, TYPES.REFLECT, {
          fn: runReflectEffect,
          info: {
            attrName: attr
          }
        });
      }
    }

    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */
    _createComputedProperty(property, expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed computed expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
    }

    // -- static class methods ------------

    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @protected
     */
    static addPropertyEffect(property, type, effect) {
      this.prototype._addPropertyEffect(property, type, effect);
    }

    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string} methodName Name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @protected
     */
    static createPropertyObserver(property, methodName, dynamicFn) {
      this.prototype._createPropertyObserver(property, methodName, dynamicFn);
    }

    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal Javascript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */
    static createMethodObserver(expression, dynamicFn) {
      this.prototype._createMethodObserver(expression, dynamicFn);
    }

    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @protected
     */
    static createNotifyingProperty(property) {
      this.prototype._createNotifyingProperty(property);
    }

    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @protected
     */
    static createReadOnlyProperty(property, protectedSetter) {
      this.prototype._createReadOnlyProperty(property, protectedSetter);
    }

    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @protected
     */
    static createReflectedProperty(property) {
      this.prototype._createReflectedProperty(property);
    }

    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal Javascript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @protected
     */
    static createComputedProperty(property, expression, dynamicFn) {
      this.prototype._createComputedProperty(property, expression, dynamicFn);
    }

    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {Object} Template metadata object
     * @protected
     */
    static bindTemplate(template) {
      return this.prototype._bindTemplate(template);
    }

    // -- binding ----------------------------------------------

    /**
     * Equivalent to static `bindTemplate` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @param {HTMLTemplateElement} template Template containing binding
     *   bindings
     * @param {boolean=} instanceBinding When false (default), performs
     *   "prototypical" binding of the template and overwrites any previously
     *   bound template for the class. When true (as passed from
     *   `_stampTemplate`), the template info is instanced and linked into
     *   the list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     *   this is an instance of the prototypical template info
     * @protected
     */
    _bindTemplate(template, instanceBinding) {
      let templateInfo = this.constructor._parseTemplate(template);
      let wasPreBound = this.__templateInfo == templateInfo;
      // Optimization: since this is called twice for proto-bound templates,
      // don't attempt to recreate accessors if this template was pre-bound
      if (!wasPreBound) {
        for (let prop in templateInfo.propertyEffects) {
          this._createPropertyAccessor(prop);
        }
      }
      if (instanceBinding) {
        // For instance-time binding, create instance of template metadata
        // and link into list of templates if necessary
        templateInfo = /** @type {!TemplateInfo} */(Object.create(templateInfo));
        templateInfo.wasPreBound = wasPreBound;
        if (!wasPreBound && this.__templateInfo) {
          let last = this.__templateInfoLast || this.__templateInfo;
          this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
          templateInfo.previousTemplateInfo = last;
          return templateInfo;
        }
      }
      return this.__templateInfo = templateInfo;
    }

    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @protected
     */
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
      hostProps[prop] = true;
      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
      let propEffects = effects[prop] = effects[prop] || [];
      propEffects.push(effect);
    }

    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */
    _stampTemplate(template) {
      // Ensures that created dom is `_enqueueClient`'d to this element so
      // that it can be flushed on next call to `_flushProperties`
      hostStack.beginHosting(this);
      let dom = super._stampTemplate(template);
      hostStack.endHosting(this);
      let templateInfo = /** @type {!TemplateInfo} */(this._bindTemplate(template, true));
      // Add template-instance-specific data to instanced templateInfo
      templateInfo.nodeList = dom.nodeList;
      // Capture child nodes to allow unstamping of non-prototypical templates
      if (!templateInfo.wasPreBound) {
        let nodes = templateInfo.childNodes = [];
        for (let n=dom.firstChild; n; n=n.nextSibling) {
          nodes.push(n);
        }
      }
      dom.templateInfo = templateInfo;
      // Setup compound storage, 2-way listeners, and dataHost for bindings
      setupBindings(this, templateInfo);
      // Flush properties into template nodes if already booted
      if (this.__dataReady) {
        runEffects(this, templateInfo.propertyEffects, this.__data, null,
          false, templateInfo.nodeList);
      }
      return dom;
    }

    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @protected
     */
    _removeBoundDom(dom) {
      // Unlink template info
      let templateInfo = dom.templateInfo;
      if (templateInfo.previousTemplateInfo) {
        templateInfo.previousTemplateInfo.nextTemplateInfo =
          templateInfo.nextTemplateInfo;
      }
      if (templateInfo.nextTemplateInfo) {
        templateInfo.nextTemplateInfo.previousTemplateInfo =
          templateInfo.previousTemplateInfo;
      }
      if (this.__templateInfoLast == templateInfo) {
        this.__templateInfoLast = templateInfo.previousTemplateInfo;
      }
      templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
      // Remove stamped nodes
      let nodes = templateInfo.childNodes;
      for (let i=0; i<nodes.length; i++) {
        let node = nodes[i];
        node.parentNode.removeChild(node);
      }
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @override
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = super._parseTemplateNode(node, templateInfo, nodeInfo);
      if (node.nodeType === Node.TEXT_NODE) {
        let parts = this._parseBindings(node.textContent, templateInfo);
        if (parts) {
          // Initialize the textContent with any literal parts
          // NOTE: default to a space here so the textNode remains; some browsers
          // (IE) evacipate an empty textNode following cloneNode/importNode.
          node.textContent = literalFromParts(parts) || ' ';
          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
          noted = true;
        }
      }
      return noted;
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @override
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      let parts = this._parseBindings(value, templateInfo);
      if (parts) {
        // Attribute or property
        let origName = name;
        let kind = 'property';
        if (name[name.length-1] == '$') {
          name = name.slice(0, -1);
          kind = 'attribute';
        }
        // Initialize attribute bindings with any literal parts
        let literal = literalFromParts(parts);
        if (literal && kind == 'attribute') {
          node.setAttribute(name, literal);
        }
        // Clear attribute before removing, since IE won't allow removing
        // `value` attribute if it previously had a value (can't
        // unconditionally set '' before removing since attributes with `$`
        // can't be set using setAttribute)
        if (node.localName === 'input' && origName === 'value') {
          node.setAttribute(origName, '');
        }
        // Remove annotation
        node.removeAttribute(origName);
        // Case hackery: attributes are lower-case, but bind targets
        // (properties) are case sensitive. Gambit is to map dash-case to
        // camel-case: `foo-bar` becomes `fooBar`.
        // Attribute bindings are excepted.
        if (kind === 'property') {
          name = Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["dashToCamelCase"])(name);
        }
        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
        return true;
      } else {
        return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);
      }
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @override
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
      let noted = super._parseTemplateNestedTemplate(node, templateInfo, nodeInfo);
      // Merge host props into outer template and add bindings
      let hostProps = nodeInfo.templateInfo.hostProps;
      let mode = '{';
      for (let source in hostProps) {
        let parts = [{ mode, source, dependencies: [source] }];
        addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
      }
      return noted;
    }

    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     */
    static _parseBindings(text, templateInfo) {
      let parts = [];
      let lastIndex = 0;
      let m;
      // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
      // Regex matches:
      //        Iteration 1:  Iteration 2:
      // m[1]: '{{'          '[['
      // m[2]: ''            '!'
      // m[3]: 'prop'        'compute(foo,bar)'
      while ((m = bindingRegex.exec(text)) !== null) {
        // Add literal part
        if (m.index > lastIndex) {
          parts.push({literal: text.slice(lastIndex, m.index)});
        }
        // Add binding part
        let mode = m[1][0];
        let negate = Boolean(m[2]);
        let source = m[3].trim();
        let customEvent = false, notifyEvent = '', colon = -1;
        if (mode == '{' && (colon = source.indexOf('::')) > 0) {
          notifyEvent = source.substring(colon + 2);
          source = source.substring(0, colon);
          customEvent = true;
        }
        let signature = parseMethod(source);
        let dependencies = [];
        if (signature) {
          // Inline computed function
          let {args, methodName} = signature;
          for (let i=0; i<args.length; i++) {
            let arg = args[i];
            if (!arg.literal) {
              dependencies.push(arg);
            }
          }
          let dynamicFns = templateInfo.dynamicFns;
          if (dynamicFns && dynamicFns[methodName] || signature.static) {
            dependencies.push(methodName);
            signature.dynamicFn = true;
          }
        } else {
          // Property or path
          dependencies.push(source);
        }
        parts.push({
          source, mode, negate, customEvent, signature, dependencies,
          event: notifyEvent
        });
        lastIndex = bindingRegex.lastIndex;
      }
      // Add a final literal part
      if (lastIndex && lastIndex < text.length) {
        let literal = text.substring(lastIndex);
        if (literal) {
          parts.push({
            literal: literal
          });
        }
      }
      if (parts.length) {
        return parts;
      } else {
        return null;
      }
    }

    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {this} inst Element that should be used as scope for
     *   binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     */
    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
      let value;
      if (part.signature) {
        value = runMethodEffect(inst, path, props, oldProps, part.signature);
      } else if (path != part.source) {
        value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, part.source);
      } else {
        if (hasPaths && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(path)) {
          value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, path);
        } else {
          value = inst.__data[path];
        }
      }
      if (part.negate) {
        value = !value;
      }
      return value;
    }

  }

  // make a typing for closure :P
  PropertyEffectsType = PropertyEffects;

  return PropertyEffects;
});
/* harmony export (immutable) */ __webpack_exports__["a"] = PropertyEffects;


/**
 * Helper api for enqueing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */
let hostStack = {

  stack: [],

  /**
   * @param {*} inst Instance to add to hostStack
   * @this {hostStack}
   */
  registerHost(inst) {
    if (this.stack.length) {
      let host = this.stack[this.stack.length-1];
      host._enqueueClient(inst);
    }
  },

  /**
   * @param {*} inst Instance to begin hosting
   * @this {hostStack}
   */
  beginHosting(inst) {
    this.stack.push(inst);
  },

  /**
   * @param {*} inst Instance to end hosting
   * @this {hostStack}
   */
  endHosting(inst) {
    let stackLen = this.stack.length;
    if (stackLen && this.stack[stackLen-1] == inst) {
      this.stack.pop();
    }
  }

};


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export beforeNextRender */
/* harmony export (immutable) */ __webpack_exports__["a"] = afterNextRender;
/* unused harmony export flush */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


let scheduled = false;
let beforeRenderQueue = [];
let afterRenderQueue = [];

function schedule() {
  scheduled = true;
  // before next render
  requestAnimationFrame(function() {
    scheduled = false;
    flushQueue(beforeRenderQueue);
    // after the render
    setTimeout(function() {
      runQueue(afterRenderQueue);
    });
  });
}

function flushQueue(queue) {
  while (queue.length) {
    callMethod(queue.shift());
  }
}

function runQueue(queue) {
  for (let i=0, l=queue.length; i < l; i++) {
    callMethod(queue.shift());
  }
}

function callMethod(info) {
  const context = info[0];
  const callback = info[1];
  const args = info[2];
  try {
    callback.apply(context, args);
  } catch(e) {
    setTimeout(() => {
      throw e;
    });
  }
}

function flush() {
  while (beforeRenderQueue.length || afterRenderQueue.length) {
    flushQueue(beforeRenderQueue);
    flushQueue(afterRenderQueue);
  }
  scheduled = false;
}

function beforeNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  beforeRenderQueue.push([context, callback, args]);
}

function afterNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  afterRenderQueue.push([context, callback, args]);
}




/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


let debouncerQueue = [];

const enqueueDebouncer = function(debouncer) {
  debouncerQueue.push(debouncer);
};
/* harmony export (immutable) */ __webpack_exports__["a"] = enqueueDebouncer;


function flushDebouncers() {
  const didFlush = Boolean(debouncerQueue.length);
  while (debouncerQueue.length) {
    try {
      debouncerQueue.shift().flush();
    } catch(e) {
      setTimeout(() => {
        throw e;
      });
    }
  }
  return didFlush;
}

const flush = function() {
  let shadyDOM, debouncers;
  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();
    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }
    debouncers = flushDebouncers();
  } while (shadyDOM || debouncers);
};
/* harmony export (immutable) */ __webpack_exports__["b"] = flush;



/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Templatize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TemplateInstanceBase; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__ = __webpack_require__(14);




// Base class for HTMLTemplateElement extension that has property effects
// machinery for propagating host properties to children. This is an ES5
// class only because Babel (incorrectly) requires super() in the class
// constructor even though no `this` is used and it returns an instance.
let newInstance = null;
/**
 * @constructor
 * @extends {HTMLTemplateElement}
 */
function HTMLTemplateElementExtension() { return newInstance; }
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 * @extends {HTMLTemplateElementExtension}
 */
const DataTemplate = Object(__WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__["a" /* PropertyEffects */])(HTMLTemplateElementExtension);
/**
 * @constructor
 * @implements {Polymer_MutableData}
 * @extends {DataTemplate}
 */
const MutableDataTemplate = Object(__WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__["a" /* MutableData */])(DataTemplate);

// Applies a DataTemplate subclass to a <template> instance
function upgradeTemplate(template, constructor) {
  newInstance = template;
  Object.setPrototypeOf(template, constructor.prototype);
  new constructor();
  newInstance = null;
}

// Base class for TemplateInstance's
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 */
const base = Object(__WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__["a" /* PropertyEffects */])(class {});

/**
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @unrestricted
 */
class TemplateInstanceBase extends base {
  constructor(props) {
    super();
    this._configureProperties(props);
    this.root = this._stampTemplate(this.__dataHost);
    // Save list of stamped children
    let children = this.children = [];
    for (let n = this.root.firstChild; n; n=n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = this;
    }
    if (this.__templatizeOwner.__hideTemplateChildren__) {
      this._showHideChildren(true);
    }
    // Flush props only when props are passed if instance props exist
    // or when there isn't instance props.
    let options = this.__templatizeOptions;
    if ((props && options.instanceProps) || !options.instanceProps) {
      this._enableProperties();
    }
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   */
  _configureProperties(props) {
    let options = this.__templatizeOptions;
    if (props) {
      for (let iprop in options.instanceProps) {
        if (iprop in props) {
          this._setPendingProperty(iprop, props[iprop]);
        }
      }
    }
    for (let hprop in this.__hostProps) {
      this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
    }
  }
  /**
   * Forwards a host property to this instance.  This method should be
   * called on instances from the `options.forwardHostProp` callback
   * to propagate changes of host properties to each instance.
   *
   * Note this method enqueues the change, which are flushed as a batch.
   *
   * @param {string} prop Property or path name
   * @param {*} value Value of the property to forward
   */
  forwardHostProp(prop, value) {
    if (this._setPendingPropertyOrPath(prop, value, false, true)) {
      this.__dataHost._enqueueClient(this);
    }
  }
  /**
   * @override
   */
  _addEventListenerToNode(node, eventName, handler) {
    if (this._methodHost && this.__templatizeOptions.parentModel) {
      // If this instance should be considered a parent model, decorate
      // events this template instance as `model`
      this._methodHost._addEventListenerToNode(node, eventName, (e) => {
        e.model = this;
        handler(e);
      });
    } else {
      // Otherwise delegate to the template's host (which could be)
      // another template instance
      let templateHost = this.__dataHost.__dataHost;
      if (templateHost) {
        templateHost._addEventListenerToNode(node, eventName, handler);
      }
    }
  }
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hide Set to true to hide the children;
   * set to false to show them.
   * @protected
   */
  _showHideChildren(hide) {
    let c = this.children;
    for (let i=0; i<c.length; i++) {
      let n = c[i];
      // Ignore non-changes
      if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
        if (n.nodeType === Node.TEXT_NODE) {
          if (hide) {
            n.__polymerTextContent__ = n.textContent;
            n.textContent = '';
          } else {
            n.textContent = n.__polymerTextContent__;
          }
        } else if (n.style) {
          if (hide) {
            n.__polymerDisplay__ = n.style.display;
            n.style.display = 'none';
          } else {
            n.style.display = n.__polymerDisplay__;
          }
        }
      }
      n.__hideTemplateChildren__ = hide;
      if (n._showHideChildren) {
        n._showHideChildren(hide);
      }
    }
  }
  /**
   * Overrides default property-effects implementation to intercept
   * textContent bindings while children are "hidden" and cache in
   * private storage for later retrieval.
   *
   * @override
   */
  _setUnmanagedPropertyToNode(node, prop, value) {
    if (node.__hideTemplateChildren__ &&
        node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
      node.__polymerTextContent__ = value;
    } else {
      super._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
  /**
   * Find the parent model of this template instance.  The parent model
   * is either another templatize instance that had option `parentModel: true`,
   * or else the host element.
   *
   * @return {Polymer_PropertyEffects} The parent model of this instance
   */
  get parentModel() {
    let model = this.__parentModel;
    if (!model) {
      let options;
      model = this;
      do {
        // A template instance's `__dataHost` is a <template>
        // `model.__dataHost.__dataHost` is the template's host
        model = model.__dataHost.__dataHost;
      } while ((options = model.__templatizeOptions) && !options.parentModel);
      this.__parentModel = model;
    }
    return model;
  }
}

/** @type {!DataTemplate} */
TemplateInstanceBase.prototype.__dataHost;
/** @type {!TemplatizeOptions} */
TemplateInstanceBase.prototype.__templatizeOptions;
/** @type {!Polymer_PropertyEffects} */
TemplateInstanceBase.prototype._methodHost;
/** @type {!Object} */
TemplateInstanceBase.prototype.__templatizeOwner;
/** @type {!Object} */
TemplateInstanceBase.prototype.__hostProps;

/**
 * @constructor
 * @extends {TemplateInstanceBase}
 * @implements {Polymer_MutableData}
 */
const MutableTemplateInstanceBase = Object(__WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__["a" /* MutableData */])(TemplateInstanceBase);

function findMethodHost(template) {
  // Technically this should be the owner of the outermost template.
  // In shadow dom, this is always getRootNode().host, but we can
  // approximate this via cooperation with our dataHost always setting
  // `_methodHost` as long as there were bindings (or id's) on this
  // instance causing it to get a dataHost.
  let templateHost = template.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}

/* eslint-disable valid-jsdoc */
/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function createTemplatizerClass(template, templateInfo, options) {
  // Anonymous class created by the templatize
  let base = options.mutableData ?
    MutableTemplateInstanceBase : TemplateInstanceBase;
  /**
   * @constructor
   * @extends {base}
   */
  let klass = class extends base { };
  klass.prototype.__templatizeOptions = options;
  klass.prototype._bindTemplate(template);
  addNotifyEffects(klass, template, templateInfo, options);
  return klass;
}

/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function addPropagateEffects(template, templateInfo, options) {
  let userForwardHostProp = options.forwardHostProp;
  if (userForwardHostProp) {
    // Provide data API and property effects on memoized template class
    let klass = templateInfo.templatizeTemplateClass;
    if (!klass) {
      let base = options.mutableData ? MutableDataTemplate : DataTemplate;
      klass = templateInfo.templatizeTemplateClass =
        class TemplatizedTemplate extends base {};
      // Add template - >instances effects
      // and host <- template effects
      let hostProps = templateInfo.hostProps;
      for (let prop in hostProps) {
        klass.prototype._addPropertyEffect('_host_' + prop,
          klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
          {fn: createForwardHostPropEffect(prop, userForwardHostProp)});
        klass.prototype._createNotifyingProperty('_host_' + prop);
      }
    }
    upgradeTemplate(template, klass);
    // Mix any pre-bound data into __data; no need to flush this to
    // instances since they pull from the template at instance-time
    if (template.__dataProto) {
      // Note, generally `__dataProto` could be chained, but it's guaranteed
      // to not be since this is a vanilla template we just added effects to
      Object.assign(template.__data, template.__dataProto);
    }
    // Clear any pending data for performance
    template.__dataTemp = {};
    template.__dataPending = null;
    template.__dataOld = null;
    template._enableProperties();
  }
}
/* eslint-enable valid-jsdoc */

function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template, prop, props) {
    userForwardHostProp.call(template.__templatizeOwner,
      prop.substring('_host_'.length), props[prop]);
  };
}

function addNotifyEffects(klass, template, templateInfo, options) {
  let hostProps = templateInfo.hostProps || {};
  for (let iprop in options.instanceProps) {
    delete hostProps[iprop];
    let userNotifyInstanceProp = options.notifyInstanceProp;
    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(iprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        {fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)});
    }
  }
  if (options.forwardHostProp && template.__dataHost) {
    for (let hprop in hostProps) {
      klass.prototype._addPropertyEffect(hprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        {fn: createNotifyHostPropEffect()});
    }
  }
}

function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(inst.__templatizeOwner,
      inst, prop, props[prop]);
  };
}

function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
  };
}

/**
 * Module for preparing and stamping instances of templates that utilize
 * Polymer's data-binding and declarative event listener features.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     let TemplateClass = Polymer.Templatize.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = new TemplateClass({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
 *     this.shadowRoot.appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * The `options` dictionary passed to `templatize` allows for customizing
 * features of the generated template class, including how outer-scope host
 * properties should be forwarded into template instances, how any instance
 * properties added into the template's scope should be notified out to
 * the host, and whether the instance should be decorated as a "parent model"
 * of any event handlers.
 *
 *     // Customze property forwarding and event model decoration
 *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
 *       parentModel: true,
 *       instanceProps: {...},
 *       forwardHostProp(property, value) {...},
 *       notifyInstanceProp(instance, property, value) {...},
 *     });
 *
 *
 * @namespace
 * @memberof Polymer
 * @summary Module for preparing and stamping instances of templates
 *   utilizing Polymer templating features.
 */

const Templatize = {

  /**
   * Returns an anonymous `Polymer.PropertyEffects` class bound to the
   * `<template>` provided.  Instancing the class will result in the
   * template being stamped into document fragment stored as the instance's
   * `root` property, after which it can be appended to the DOM.
   *
   * Templates may utilize all Polymer data-binding features as well as
   * declarative event listeners.  Event listeners and inline computing
   * functions in the template will be called on the host of the template.
   *
   * The constructor returned takes a single argument dictionary of initial
   * property values to propagate into template bindings.  Additionally
   * host properties can be forwarded in, and instance properties can be
   * notified out by providing optional callbacks in the `options` dictionary.
   *
   * Valid configuration in `options` are as follows:
   *
   * - `forwardHostProp(property, value)`: Called when a property referenced
   *   in the template changed on the template's host. As this library does
   *   not retain references to templates instanced by the user, it is the
   *   templatize owner's responsibility to forward host property changes into
   *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
   *    method on the generated class should be called to forward host
   *   properties into the template to prevent unnecessary property-changed
   *   notifications. Any properties referenced in the template that are not
   *   defined in `instanceProps` will be notified up to the template's host
   *   automatically.
   * - `instanceProps`: Dictionary of property names that will be added
   *   to the instance by the templatize owner.  These properties shadow any
   *   host properties, and changes within the template to these properties
   *   will result in `notifyInstanceProp` being called.
   * - `mutableData`: When `true`, the generated class will skip strict
   *   dirty-checking for objects and arrays (always consider them to be
   *   "dirty").
   * - `notifyInstanceProp(instance, property, value)`: Called when
   *   an instance property changes.  Users may choose to call `notifyPath`
   *   on e.g. the owner to notify the change.
   * - `parentModel`: When `true`, events handled by declarative event listeners
   *   (`on-event="handler"`) will be decorated with a `model` property pointing
   *   to the template instance that stamped it.  It will also be returned
   *   from `instance.parentModel` in cases where template instance nesting
   *   causes an inner model to shadow an outer model.
   *
   * Note that the class returned from `templatize` is generated only once
   * for a given `<template>` using `options` from the first call for that
   * template, and the cached class is returned for all subsequent calls to
   * `templatize` for that template.  As such, `options` callbacks should not
   * close over owner-specific properties since only the first `options` is
   * used; rather, callbacks are called bound to the `owner`, and so context
   * needed from the callbacks (such as references to `instances` stamped)
   * should be stored on the `owner` such that they can be retrieved via `this`.
   *
   * @memberof Polymer.Templatize
   * @param {!HTMLTemplateElement} template Template to templatize
   * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
   *   any optional callbacks will be bound to this owner.
   * @param {Object=} options Options dictionary (see summary for details)
   * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
   *   provided
   * @suppress {invalidCasts}
   */
  templatize(template, owner, options) {
    options = /** @type {!TemplatizeOptions} */(options || {});
    if (template.__templatizeOwner) {
      throw new Error('A <template> can only be templatized once');
    }
    template.__templatizeOwner = owner;
    let templateInfo = owner.constructor._parseTemplate(template);
    // Get memoized base class for the prototypical template, which
    // includes property effects for binding template & forwarding
    let baseClass = templateInfo.templatizeInstanceClass;
    if (!baseClass) {
      baseClass = createTemplatizerClass(template, templateInfo, options);
      templateInfo.templatizeInstanceClass = baseClass;
    }
    // Host property forwarding must be installed onto template instance
    addPropagateEffects(template, templateInfo, options);
    // Subclass base class and add reference for this specific template
    let klass = class TemplateInstance extends baseClass {};
    klass.prototype._methodHost = findMethodHost(template);
    klass.prototype.__dataHost = template;
    klass.prototype.__templatizeOwner = owner;
    klass.prototype.__hostProps = templateInfo.hostProps;
    return /** @type {function(new:TemplateInstanceBase)} */(klass);
  },

  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model is an instance of
   * `TemplateInstanceBase`, and should be used to manipulate data
   * associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @memberof Polymer.Templatize
   * @param {HTMLTemplateElement} template The model will be returned for
   *   elements stamped from this template
   * @param {Node} node Node for which to return a template model.
   * @return {TemplateInstanceBase} Template instance representing the
   *   binding scope for the element
   */
  modelForElement(template, node) {
    let model;
    while (node) {
      // An element with a __templatizeInstance marks the top boundary
      // of a scope; walk up until we find one, and then ensure that
      // its __dataHost matches `this`, meaning this dom-repeat stamped it
      if ((model = node.__templatizeInstance)) {
        // Found an element stamped by another template; keep walking up
        // from its __dataHost
        if (model.__dataHost != template) {
          node = model.__dataHost;
        } else {
          return model;
        }
      } else {
        // Still in a template scope, keep going up until
        // a __templatizeInstance is found
        node = node.parentNode;
      }
    }
    return null;
  }
};





/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_control_state_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





const IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: [
    '_focusChanged(focused)',
    '_activeChanged(active, ariaActiveAttribute)'
  ],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler',
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function() {
    if (this.toggles) {
     // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant(/** @type {Node} */(target)))
      return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant(/** @type {Node} */(target)))
      return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function() {
    this.async(function() {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute,
                        active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["b"] = IronButtonStateImpl;


const IronButtonState = [
  __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */],
  IronButtonStateImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = IronButtonState;



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["ajax"] = ajax;
/* harmony export (immutable) */ __webpack_exports__["ajaxGet"] = ajaxGet;
/* harmony export (immutable) */ __webpack_exports__["ajaxPost"] = ajaxPost;
/* harmony export (immutable) */ __webpack_exports__["ajaxPut"] = ajaxPut;
/* harmony export (immutable) */ __webpack_exports__["ajaxDelete"] = ajaxDelete;
function ajax(url, data, method, headers, successCallback, errorCallback) {
  var config = {
    method: method,
    headers: headers
  };

  if (typeof data != "undefined") {
    config.body = JSON.stringify(data);
  }

  fetch(url, config).then(response => {
    if (response.ok) {
      return Promise.resolve(response);
    } else {
      return Promise.reject(new Error('Failed to post data'));
    }
  }).then(response => response.json()) // parse response as JSON
  .then(data => {
    if (typeof successCallback === "function") {
      successCallback(data);
    }
  }).catch(function (error) {
    console.log(`Error: ${error.message}`);

    if (typeof errorCallback === "function") {
      errorCallback(error);
    }
  });
}
function ajaxGet(url, successCallback, errorCallback) {
  var headers = new Headers();
  ajax(url, undefined, "GET", headers, successCallback, errorCallback);
}
function ajaxPost(url, data, successCallback, errorCallback) {
  var headers = new Headers();
  headers.append("Content-Type", "application/json");
  ajax(url, data, "POST", headers, successCallback, errorCallback);
}
function ajaxPut(url, data, successCallback, errorCallback) {
  var headers = new Headers();
  headers.append("Content-Type", "application/json");
  ajax(url, data, "PUT", headers, successCallback, errorCallback);
}
function ajaxDelete(url, successCallback, errorCallback) {
  var headers = new Headers();
  ajax(url, undefined, "DELETE", headers, successCallback, errorCallback);
}

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);





var Utility = {
  distance: function(x1, y1, x2, y2) {
    var xDelta = (x1 - x2);
    var yDelta = (y1 - y2);

    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
  },

  now: window.performance && window.performance.now ?
      window.performance.now.bind(window.performance) : Date.now
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function ElementMetrics(element) {
  this.element = element;
  this.width = this.boundingRect.width;
  this.height = this.boundingRect.height;

  this.size = Math.max(this.width, this.height);
}

ElementMetrics.prototype = {
  get boundingRect () {
    return this.element.getBoundingClientRect();
  },

  furthestCornerDistanceFrom: function(x, y) {
    var topLeft = Utility.distance(x, y, 0, 0);
    var topRight = Utility.distance(x, y, this.width, 0);
    var bottomLeft = Utility.distance(x, y, 0, this.height);
    var bottomRight = Utility.distance(x, y, this.width, this.height);

    return Math.max(topLeft, topRight, bottomLeft, bottomRight);
  }
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function Ripple(element) {
  this.element = element;
  this.color = window.getComputedStyle(element).color;

  this.wave = document.createElement('div');
  this.waveContainer = document.createElement('div');
  this.wave.style.backgroundColor = this.color;
  this.wave.classList.add('wave');
  this.waveContainer.classList.add('wave-container');
  Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.waveContainer).appendChild(this.wave);

  this.resetInteractionState();
}

Ripple.MAX_RADIUS = 300;

Ripple.prototype = {
  get recenters() {
    return this.element.recenters;
  },

  get center() {
    return this.element.center;
  },

  get mouseDownElapsed() {
    var elapsed;

    if (!this.mouseDownStart) {
      return 0;
    }

    elapsed = Utility.now() - this.mouseDownStart;

    if (this.mouseUpStart) {
      elapsed -= this.mouseUpElapsed;
    }

    return elapsed;
  },

  get mouseUpElapsed() {
    return this.mouseUpStart ?
      Utility.now () - this.mouseUpStart : 0;
  },

  get mouseDownElapsedSeconds() {
    return this.mouseDownElapsed / 1000;
  },

  get mouseUpElapsedSeconds() {
    return this.mouseUpElapsed / 1000;
  },

  get mouseInteractionSeconds() {
    return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
  },

  get initialOpacity() {
    return this.element.initialOpacity;
  },

  get opacityDecayVelocity() {
    return this.element.opacityDecayVelocity;
  },

  get radius() {
    var width2 = this.containerMetrics.width * this.containerMetrics.width;
    var height2 = this.containerMetrics.height * this.containerMetrics.height;
    var waveRadius = Math.min(
      Math.sqrt(width2 + height2),
      Ripple.MAX_RADIUS
    ) * 1.1 + 5;

    var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
    var timeNow = this.mouseInteractionSeconds / duration;
    var size = waveRadius * (1 - Math.pow(80, -timeNow));

    return Math.abs(size);
  },

  get opacity() {
    if (!this.mouseUpStart) {
      return this.initialOpacity;
    }

    return Math.max(
      0,
      this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity
    );
  },

  get outerOpacity() {
    // Linear increase in background opacity, capped at the opacity
    // of the wavefront (waveOpacity).
    var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
    var waveOpacity = this.opacity;

    return Math.max(
      0,
      Math.min(outerOpacity, waveOpacity)
    );
  },

  get isOpacityFullyDecayed() {
    return this.opacity < 0.01 &&
      this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isRestingAtMaxRadius() {
    return this.opacity >= this.initialOpacity &&
      this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isAnimationComplete() {
    return this.mouseUpStart ?
      this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
  },

  get translationFraction() {
    return Math.min(
      1,
      this.radius / this.containerMetrics.size * 2 / Math.sqrt(2)
    );
  },

  get xNow() {
    if (this.xEnd) {
      return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
    }

    return this.xStart;
  },

  get yNow() {
    if (this.yEnd) {
      return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
    }

    return this.yStart;
  },

  get isMouseDown() {
    return this.mouseDownStart && !this.mouseUpStart;
  },

  resetInteractionState: function() {
    this.maxRadius = 0;
    this.mouseDownStart = 0;
    this.mouseUpStart = 0;

    this.xStart = 0;
    this.yStart = 0;
    this.xEnd = 0;
    this.yEnd = 0;
    this.slideDistance = 0;

    this.containerMetrics = new ElementMetrics(this.element);
  },

  draw: function() {
    var scale;
    var translateString;
    var dx;
    var dy;

    this.wave.style.opacity = this.opacity;

    scale = this.radius / (this.containerMetrics.size / 2);
    dx = this.xNow - (this.containerMetrics.width / 2);
    dy = this.yNow - (this.containerMetrics.height / 2);


    // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
    // https://bugs.webkit.org/show_bug.cgi?id=98538
    this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
    this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
    this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
    this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
  },

  /** @param {Event=} event */
  downAction: function(event) {
    var xCenter = this.containerMetrics.width / 2;
    var yCenter = this.containerMetrics.height / 2;

    this.resetInteractionState();
    this.mouseDownStart = Utility.now();

    if (this.center) {
      this.xStart = xCenter;
      this.yStart = yCenter;
      this.slideDistance = Utility.distance(
        this.xStart, this.yStart, this.xEnd, this.yEnd
      );
    } else {
      this.xStart = event ?
          event.detail.x - this.containerMetrics.boundingRect.left :
          this.containerMetrics.width / 2;
      this.yStart = event ?
          event.detail.y - this.containerMetrics.boundingRect.top :
          this.containerMetrics.height / 2;
    }

    if (this.recenters) {
      this.xEnd = xCenter;
      this.yEnd = yCenter;
      this.slideDistance = Utility.distance(
        this.xStart, this.yStart, this.xEnd, this.yEnd
      );
    }

    this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
      this.xStart,
      this.yStart
    );

    this.waveContainer.style.top =
      (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
    this.waveContainer.style.left =
      (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

    this.waveContainer.style.width = this.containerMetrics.size + 'px';
    this.waveContainer.style.height = this.containerMetrics.size + 'px';
  },

  /** @param {Event=} event */
  upAction: function(event) {
    if (!this.isMouseDown) {
      return;
    }

    this.mouseUpStart = Utility.now();
  },

  remove: function() {
    Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.waveContainer.parentNode).removeChild(
      this.waveContainer
    );
  }
};

Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: block;
        position: absolute;
        border-radius: inherit;
        overflow: hidden;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;

        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,
         * creating a node (with a position:absolute) in the middle of an event
         * handler "interrupts" that event handler (which happens when the
         * ripple is created on demand) */
        pointer-events: none;
      }

      :host([animating]) {
        /* This resolves a rendering issue in Chrome (as of 40) where the
           ripple is not properly clipped by its parent (which may have
           rounded corners). See: http://jsbin.com/temexa/4

           Note: We only apply this style conditionally. Otherwise, the browser
           will create a new compositing layer for every ripple element on the
           page, and that would be bad. */
        -webkit-transform: translate(0, 0);
        transform: translate3d(0, 0, 0);
      }

      #background,
      #waves,
      .wave-container,
      .wave {
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      #background,
      .wave {
        opacity: 0;
      }

      #waves,
      .wave {
        overflow: hidden;
      }

      .wave-container,
      .wave {
        border-radius: 50%;
      }

      :host(.circle) #background,
      :host(.circle) #waves {
        border-radius: 50%;
      }

      :host(.circle) .wave-container {
        overflow: hidden;
      }
    </style>

    <div id="background"></div>
    <div id="waves"></div>
`,

  is: 'paper-ripple',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */]
  ],

  properties: {
    /**
     * The initial opacity set on the wave.
     *
     * @attribute initialOpacity
     * @type number
     * @default 0.25
     */
    initialOpacity: {
      type: Number,
      value: 0.25
    },

    /**
     * How fast (opacity per second) the wave fades out.
     *
     * @attribute opacityDecayVelocity
     * @type number
     * @default 0.8
     */
    opacityDecayVelocity: {
      type: Number,
      value: 0.8
    },

    /**
     * If true, ripples will exhibit a gravitational pull towards
     * the center of their container as they fade away.
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    recenters: {
      type: Boolean,
      value: false
    },

    /**
     * If true, ripples will center inside its container
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    center: {
      type: Boolean,
      value: false
    },

    /**
     * A list of the visual ripples.
     *
     * @attribute ripples
     * @type Array
     * @default []
     */
    ripples: {
      type: Array,
      value: function() {
        return [];
      }
    },

    /**
     * True when there are visible ripples animating within the
     * element.
     */
    animating: {
      type: Boolean,
      readOnly: true,
      reflectToAttribute: true,
      value: false
    },

    /**
     * If true, the ripple will remain in the "down" state until `holdDown`
     * is set to false again.
     */
    holdDown: {
      type: Boolean,
      value: false,
      observer: '_holdDownChanged'
    },

    /**
     * If true, the ripple will not generate a ripple effect
     * via pointer interaction.
     * Calling ripple's imperative api like `simulatedRipple` will
     * still generate the ripple effect.
     */
    noink: {
      type: Boolean,
      value: false
    },

    _animating: {
      type: Boolean
    },

    _boundAnimate: {
      type: Function,
      value: function() {
        return this.animate.bind(this);
      }
    }
  },

  get target () {
    return this.keyEventTarget;
  },

  keyBindings: {
    'enter:keydown': '_onEnterKeydown',
    'space:keydown': '_onSpaceKeydown',
    'space:keyup': '_onSpaceKeyup'
  },

  attached: function() {
    // Set up a11yKeysBehavior to listen to key events on the target,
    // so that space and enter activate the ripple even if the target doesn't
    // handle key events. The key handlers deal with `noink` themselves.
    if (this.parentNode.nodeType == 11) { // DOCUMENT_FRAGMENT_NODE
      this.keyEventTarget = Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).getOwnerRoot().host;
    } else {
      this.keyEventTarget = this.parentNode;
    }
    var keyEventTarget = /** @type {!EventTarget} */ (this.keyEventTarget);
    this.listen(keyEventTarget, 'up', 'uiUpAction');
    this.listen(keyEventTarget, 'down', 'uiDownAction');
  },

  detached: function() {
    this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
    this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
    this.keyEventTarget = null;
  },

  get shouldKeepAnimating () {
    for (var index = 0; index < this.ripples.length; ++index) {
      if (!this.ripples[index].isAnimationComplete) {
        return true;
      }
    }

    return false;
  },

  simulatedRipple: function() {
    this.downAction(null);

    // Please see polymer/polymer#1305
    this.async(function() {
      this.upAction();
    }, 1);
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiDownAction: function(event) {
    if (!this.noink) {
      this.downAction(event);
    }
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  downAction: function(event) {
    if (this.holdDown && this.ripples.length > 0) {
      return;
    }

    var ripple = this.addRipple();

    ripple.downAction(event);

    if (!this._animating) {
      this._animating = true;
      this.animate();
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiUpAction: function(event) {
    if (!this.noink) {
      this.upAction(event);
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  upAction: function(event) {
    if (this.holdDown) {
      return;
    }

    this.ripples.forEach(function(ripple) {
      ripple.upAction(event);
    });

    this._animating = true;
    this.animate();
  },

  onAnimationComplete: function() {
    this._animating = false;
    this.$.background.style.backgroundColor = null;
    this.fire('transitionend');
  },

  addRipple: function() {
    var ripple = new Ripple(this);

    Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.$.waves).appendChild(ripple.waveContainer);
    this.$.background.style.backgroundColor = ripple.color;
    this.ripples.push(ripple);

    this._setAnimating(true);

    return ripple;
  },

  removeRipple: function(ripple) {
    var rippleIndex = this.ripples.indexOf(ripple);

    if (rippleIndex < 0) {
      return;
    }

    this.ripples.splice(rippleIndex, 1);

    ripple.remove();

    if (!this.ripples.length) {
      this._setAnimating(false);
    }
  },

  /**
   * This conflicts with Element#antimate().
   * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
   * @suppress {checkTypes}
   */
  animate: function() {
    if (!this._animating) {
      return;
    }
    var index;
    var ripple;

    for (index = 0; index < this.ripples.length; ++index) {
      ripple = this.ripples[index];

      ripple.draw();

      this.$.background.style.opacity = ripple.outerOpacity;

      if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
        this.removeRipple(ripple);
      }
    }

    if (!this.shouldKeepAnimating && this.ripples.length === 0) {
      this.onAnimationComplete();
    } else {
      window.requestAnimationFrame(this._boundAnimate);
    }
  },

  _onEnterKeydown: function() {
    this.uiDownAction();
    this.async(this.uiUpAction, 1);
  },

  _onSpaceKeydown: function() {
    this.uiDownAction();
  },

  _onSpaceKeyup: function() {
    this.uiUpAction();
  },

  // note: holdDown does not respect noink since it can be a focus based
  // effect.
  _holdDownChanged: function(newVal, oldVal) {
    if (oldVal === undefined) {
      return;
    }
    if (newVal) {
      this.downAction();
    } else {
      this.upAction();
    }
  }

  /**
  Fired when the animation finishes.
  This is useful if you want to wait until
  the ripple animation finishes to perform some action.

  @event transitionend
  @param {{node: Object}} detail Contains the animated node.
  */
});


/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_shadycss_entrypoints_apply_shim_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_element_mixin_js__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixins_gesture_event_listeners_js__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_import_href_js__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_render_status_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_unresolved_js__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_unresolved_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__utils_unresolved_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_gestures_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_debounce_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_async_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__utils_path_js__ = __webpack_require__(11);













let styleInterface = window.ShadyCSS;

const LegacyElementMixin = Object(__WEBPACK_IMPORTED_MODULE_3__utils_mixin_js__["a" /* dedupingMixin */])((base) => {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_ElementMixin}
   * @implements {Polymer_GestureEventListeners}
   */
  const legacyElementBase = Object(__WEBPACK_IMPORTED_MODULE_2__mixins_gesture_event_listeners_js__["a" /* GestureEventListeners */])(Object(__WEBPACK_IMPORTED_MODULE_1__mixins_element_mixin_js__["a" /* ElementMixin */])(base));

  /**
   * Map of simple names to touch action names
   * @dict
   */
  const DIRECTION_MAP = {
    'x': 'pan-x',
    'y': 'pan-y',
    'none': 'none',
    'all': 'auto'
  };

  /**
   * @polymer
   * @mixinClass
   * @extends {legacyElementBase}
   * @implements {Polymer_LegacyElementMixin}
   * @unrestricted
   */
  class LegacyElement extends legacyElementBase {

    constructor() {
      super();
      this.root = this;
      /** @type {boolean} */
      this.isAttached;
      /** @type {WeakMap<!Element, !Object<string, !Function>>} */
      this.__boundListeners;
      /** @type {Object<string, Function>} */
      this._debouncers;
      this.created();
    }

    /**
     * Legacy callback called during the `constructor`, for overriding
     * by the user.
     */
    created() {}

    /**
     * Provides an implementation of `connectedCallback`
     * which adds Polymer legacy API's `attached` method.
     * @override
     */
    connectedCallback() {
      super.connectedCallback();
      this.isAttached = true;
      this.attached();
    }

    /**
     * Legacy callback called during `connectedCallback`, for overriding
     * by the user.
     */
    attached() {}

    /**
     * Provides an implementation of `disconnectedCallback`
     * which adds Polymer legacy API's `detached` method.
     * @override
     */
    disconnectedCallback() {
      super.disconnectedCallback();
      this.isAttached = false;
      this.detached();
    }

    /**
     * Legacy callback called during `disconnectedCallback`, for overriding
     * by the user.
     */
    detached() {}

    /**
     * Provides an override implementation of `attributeChangedCallback`
     * which adds the Polymer legacy API's `attributeChanged` method.
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @override
     */
    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        super.attributeChangedCallback(name, old, value);
        this.attributeChanged(name, old, value);
      }
    }

    /**
     * Legacy callback called during `attributeChangedChallback`, for overriding
     * by the user.
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     */
    attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

    /**
     * Overrides the default `Polymer.PropertyEffects` implementation to
     * add support for class initialization via the `_registered` callback.
     * This is called only when the first instance of the element is created.
     *
     * @override
     */
    _initializeProperties() {
      let proto = Object.getPrototypeOf(this);
      if (!proto.hasOwnProperty('__hasRegisterFinished')) {
        proto.__hasRegisterFinished = true;
        this._registered();
      }
      super._initializeProperties();
    }

    /**
     * Called automatically when an element is initializing.
     * Users may override this method to perform class registration time
     * work. The implementation should ensure the work is performed
     * only once for the class.
     * @protected
     */
    _registered() {}

    /**
     * Overrides the default `Polymer.PropertyEffects` implementation to
     * add support for installing `hostAttributes` and `listeners`.
     *
     * @override
     */
    ready() {
      this._ensureAttributes();
      this._applyListeners();
      super.ready();
    }

    /**
     * Ensures an element has required attributes. Called when the element
     * is being readied via `ready`. Users should override to set the
     * element's required attributes. The implementation should be sure
     * to check and not override existing attributes added by
     * the user of the element. Typically, setting attributes should be left
     * to the element user and not done here; reasonable exceptions include
     * setting aria roles and focusability.
     * @protected
     */
    _ensureAttributes() {}

    /**
     * Adds element event listeners. Called when the element
     * is being readied via `ready`. Users should override to
     * add any required element event listeners.
     * In performance critical elements, the work done here should be kept
     * to a minimum since it is done before the element is rendered. In
     * these elements, consider adding listeners asychronously so as not to
     * block render.
     * @protected
     */
    _applyListeners() {}

    /**
     * Converts a typed JavaScript value to a string.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features. To customize
     * how properties are serialized to attributes for attribute bindings and
     * `reflectToAttribute: true` properties as well as this method, override
     * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
     *
     * @param {*} value Value to deserialize
     * @return {string | undefined} Serialized value
     */
    serialize(value) {
      return this._serializeValue(value);
    }

    /**
     * Converts a string to a typed JavaScript value.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.  To customize
     * how attributes are deserialized to properties for in
     * `attributeChangedCallback`, override `_deserializeValue` method
     * provided by `Polymer.PropertyAccessors`.
     *
     * @param {string} value String to deserialize
     * @param {*} type Type to deserialize the string to
     * @return {*} Returns the deserialized value in the `type` given.
     */
    deserialize(value, type) {
      return this._deserializeValue(value, type);
    }

    /**
     * Serializes a property to its associated attribute.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect.
     * @param {*=} value Property value to refect.
     */
    reflectPropertyToAttribute(property, attribute, value) {
      this._propertyToAttribute(property, attribute, value);
    }

    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     *
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @param {Element} node Element to set attribute to.
     */
    serializeValueToAttribute(value, attribute, node) {
      this._valueToNodeAttribute(/** @type {Element} */ (node || this), value, attribute);
    }

    /**
     * Copies own properties (including accessor descriptors) from a source
     * object to a target object.
     *
     * @param {Object} prototype Target object to copy properties to.
     * @param {Object} api Source object to copy properties from.
     * @return {Object} prototype object that was passed as first argument.
     */
    extend(prototype, api) {
      if (!(prototype && api)) {
        return prototype || api;
      }
      let n$ = Object.getOwnPropertyNames(api);
      for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {
        let pd = Object.getOwnPropertyDescriptor(api, n);
        if (pd) {
          Object.defineProperty(prototype, n, pd);
        }
      }
      return prototype;
    }

    /**
     * Copies props from a source object to a target object.
     *
     * Note, this method uses a simple `for...in` strategy for enumerating
     * properties.  To ensure only `ownProperties` are copied from source
     * to target and that accessor implementations are copied, use `extend`.
     *
     * @param {Object} target Target object to copy properties to.
     * @param {Object} source Source object to copy properties from.
     * @return {Object} Target object that was passed as first argument.
     */
    mixin(target, source) {
      for (let i in source) {
        target[i] = source[i];
      }
      return target;
    }

    /**
     * Sets the prototype of an object.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     * @param {Object} object The object on which to set the prototype.
     * @param {Object} prototype The prototype that will be set on the given
     * `object`.
     * @return {Object} Returns the given `object` with its prototype set
     * to the given `prototype` object.
     */
    chainObject(object, prototype) {
      if (object && prototype && object !== prototype) {
        object.__proto__ = prototype;
      }
      return object;
    }

    /* **** Begin Template **** */

    /**
     * Calls `importNode` on the `content` of the `template` specified and
     * returns a document fragment containing the imported content.
     *
     * @param {HTMLTemplateElement} template HTML template element to instance.
     * @return {DocumentFragment} Document fragment containing the imported
     *   template content.
    */
    instanceTemplate(template) {
      let content = this.constructor._contentForTemplate(template);
      let dom = /** @type {DocumentFragment} */
        (document.importNode(content, true));
      return dom;
    }

    /* **** Begin Events **** */



    /**
     * Dispatches a custom event with an optional detail value.
     *
     * @param {string} type Name of event type.
     * @param {*=} detail Detail value containing event-specific
     *   payload.
     * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
     *  options Object specifying options.  These may include:
     *  `bubbles` (boolean, defaults to `true`),
     *  `cancelable` (boolean, defaults to false), and
     *  `node` on which to fire the event (HTMLElement, defaults to `this`).
     * @return {Event} The new event that was fired.
     */
    fire(type, detail, options) {
      options = options || {};
      detail = (detail === null || detail === undefined) ? {} : detail;
      let event = new Event(type, {
        bubbles: options.bubbles === undefined ? true : options.bubbles,
        cancelable: Boolean(options.cancelable),
        composed: options.composed === undefined ? true: options.composed
      });
      event.detail = detail;
      let node = options.node || this;
      node.dispatchEvent(event);
      return event;
    }

    /**
     * Convenience method to add an event listener on a given element,
     * late bound to a named method on this element.
     *
     * @param {Element} node Element to add event listener to.
     * @param {string} eventName Name of event to listen for.
     * @param {string} methodName Name of handler method on `this` to call.
     */
    listen(node, eventName, methodName) {
      node = /** @type {!Element} */ (node || this);
      let hbl = this.__boundListeners ||
        (this.__boundListeners = new WeakMap());
      let bl = hbl.get(node);
      if (!bl) {
        bl = {};
        hbl.set(node, bl);
      }
      let key = eventName + methodName;
      if (!bl[key]) {
        bl[key] = this._addMethodEventListenerToNode(
          node, eventName, methodName, this);
      }
    }

    /**
     * Convenience method to remove an event listener from a given element,
     * late bound to a named method on this element.
     *
     * @param {Element} node Element to remove event listener from.
     * @param {string} eventName Name of event to stop listening to.
     * @param {string} methodName Name of handler method on `this` to not call
     anymore.
     */
    unlisten(node, eventName, methodName) {
      node = /** @type {!Element} */ (node || this);
      let bl = this.__boundListeners && this.__boundListeners.get(node);
      let key = eventName + methodName;
      let handler = bl && bl[key];
      if (handler) {
        this._removeEventListenerFromNode(node, eventName, handler);
        bl[key] = null;
      }
    }

    /**
     * Override scrolling behavior to all direction, one direction, or none.
     *
     * Valid scroll directions:
     *   - 'all': scroll in any direction
     *   - 'x': scroll only in the 'x' direction
     *   - 'y': scroll only in the 'y' direction
     *   - 'none': disable scrolling for this node
     *
     * @param {string=} direction Direction to allow scrolling
     * Defaults to `all`.
     * @param {Element=} node Element to apply scroll direction setting.
     * Defaults to `this`.
     */
    setScrollDirection(direction, node) {
      Object(__WEBPACK_IMPORTED_MODULE_8__utils_gestures_js__["setTouchAction"])( (node || this), DIRECTION_MAP[direction] || 'auto');
    }
    /* **** End Events **** */

    /**
     * Convenience method to run `querySelector` on this local DOM scope.
     *
     * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
     *
     * @param {string} slctr Selector to run on this local DOM scope
     * @return {Element} Element found by the selector, or null if not found.
     */
    $$(slctr) {
      return this.root.querySelector(slctr);
    }

    /**
     * Return the element whose local dom within which this element
     * is contained. This is a shorthand for
     * `this.getRootNode().host`.
     * @this {Element}
     */
    get domHost() {
      let root = this.getRootNode();
      return (root instanceof DocumentFragment) ? /** @type {ShadowRoot} */ (root).host : root;
    }

    /**
     * Force this element to distribute its children to its local dom.
     * This should not be necessary as of Polymer 2.0.2 and is provided only
     * for backwards compatibility.
     */
    distributeContent() {
      if (window.ShadyDOM && this.shadowRoot) {
        ShadyDOM.flush();
      }
    }

    /**
     * Returns a list of nodes that are the effective childNodes. The effective
     * childNodes list is the same as the element's childNodes except that
     * any `<content>` elements are replaced with the list of nodes distributed
     * to the `<content>`, the result of its `getDistributedNodes` method.
     * @this {Element}
     * @return {Array<Node>} List of effctive child nodes.
     */
    getEffectiveChildNodes() {
      return (
        /** @type {Polymer.DomApi} */ (Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["a" /* dom */])(this)).getEffectiveChildNodes()
      );
    }

    /**
     * Returns a list of nodes distributed within this element that match
     * `selector`. These can be dom children or elements distributed to
     * children that are insertion points.
     * @param {string} selector Selector to run.
     * @this {Element}
     * @return {Array<Node>} List of distributed elements that match selector.
     */
    queryDistributedElements(selector) {
      return (
        /** @type {Polymer.DomApi} */ (Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["a" /* dom */])(this)).queryDistributedElements(selector)
      );
    }

    /**
     * Returns a list of elements that are the effective children. The effective
     * children list is the same as the element's children except that
     * any `<content>` elements are replaced with the list of elements
     * distributed to the `<content>`.
     *
     * @return {Array<Node>} List of effctive children.
     */
    getEffectiveChildren() {
      let list = this.getEffectiveChildNodes();
      return list.filter(function(/** @type {Node} */ n) {
        return (n.nodeType === Node.ELEMENT_NODE);
      });
    }

    /**
     * Returns a string of text content that is the concatenation of the
     * text content's of the element's effective childNodes (the elements
     * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
     *
     * @return {string} List of effctive children.
     */
    getEffectiveTextContent() {
      let cn = this.getEffectiveChildNodes();
      let tc = [];
      for (let i=0, c; (c = cn[i]); i++) {
        if (c.nodeType !== Node.COMMENT_NODE) {
          tc.push(c.textContent);
        }
      }
      return tc.join('');
    }

    /**
     * Returns the first effective childNode within this element that
     * match `selector`. These can be dom child nodes or elements distributed
     * to children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {Object<Node>} First effective child node that matches selector.
     */
    queryEffectiveChildren(selector) {
      let e$ = this.queryDistributedElements(selector);
      return e$ && e$[0];
    }

    /**
     * Returns a list of effective childNodes within this element that
     * match `selector`. These can be dom child nodes or elements distributed
     * to children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {Array<Node>} List of effective child nodes that match selector.
     */
    queryAllEffectiveChildren(selector) {
      return this.queryDistributedElements(selector);
    }

    /**
     * Returns a list of nodes distributed to this element's `<slot>`.
     *
     * If this element contains more than one `<slot>` in its local DOM,
     * an optional selector may be passed to choose the desired content.
     *
     * @param {string=} slctr CSS selector to choose the desired
     *   `<slot>`.  Defaults to `content`.
     * @return {Array<Node>} List of distributed nodes for the `<slot>`.
     */
    getContentChildNodes(slctr) {
      let content = this.root.querySelector(slctr || 'slot');
      return content ? /** @type {Polymer.DomApi} */(Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["a" /* dom */])(content)).getDistributedNodes() : [];
    }

    /**
     * Returns a list of element children distributed to this element's
     * `<slot>`.
     *
     * If this element contains more than one `<slot>` in its
     * local DOM, an optional selector may be passed to choose the desired
     * content.  This method differs from `getContentChildNodes` in that only
     * elements are returned.
     *
     * @param {string=} slctr CSS selector to choose the desired
     *   `<content>`.  Defaults to `content`.
     * @return {Array<HTMLElement>} List of distributed nodes for the
     *   `<slot>`.
     * @suppress {invalidCasts}
     */
    getContentChildren(slctr) {
      return /** @type {Array<HTMLElement>} */(this.getContentChildNodes(slctr).filter(function(n) {
        return (n.nodeType === Node.ELEMENT_NODE);
      }));
    }

    /**
     * Checks whether an element is in this element's light DOM tree.
     *
     * @param {?Node} node The element to be checked.
     * @this {Element}
     * @return {boolean} true if node is in this element's light DOM tree.
     */
    isLightDescendant(node) {
      return this !== node && this.contains(node) &&
          this.getRootNode() === node.getRootNode();
    }

    /**
     * Checks whether an element is in this element's local DOM tree.
     *
     * @param {Element=} node The element to be checked.
     * @return {boolean} true if node is in this element's local DOM tree.
     */
    isLocalDescendant(node) {
      return this.root === node.getRootNode();
    }

    // NOTE: should now be handled by ShadyCss library.
    scopeSubtree(container, shouldObserve) { // eslint-disable-line no-unused-vars
    }

    /**
     * Returns the computed style value for the given property.
     * @param {string} property The css property name.
     * @return {string} Returns the computed css property value for the given
     * `property`.
     */
    getComputedStyleValue(property) {
      return styleInterface.getComputedStyleValue(this, property);
    }

    // debounce

    /**
     * Call `debounce` to collapse multiple requests for a named task into
     * one invocation which is made after the wait time has elapsed with
     * no new request.  If no wait time is given, the callback will be called
     * at microtask timing (guaranteed before paint).
     *
     *     debouncedClickAction(e) {
     *       // will not call `processClick` more than once per 100ms
     *       this.debounce('click', function() {
     *        this.processClick();
     *       } 100);
     *     }
     *
     * @param {string} jobName String to indentify the debounce job.
     * @param {function()} callback Function that is called (with `this`
     *   context) when the wait time elapses.
     * @param {number} wait Optional wait time in milliseconds (ms) after the
     *   last signal that must elapse before invoking `callback`
     * @return {Object} Returns a debouncer object on which exists the
     * following methods: `isActive()` returns true if the debouncer is
     * active; `cancel()` cancels the debouncer if it is active;
     * `flush()` immediately invokes the debounced callback if the debouncer
     * is active.
     */
    debounce(jobName, callback, wait) {
      this._debouncers = this._debouncers || {};
      return this._debouncers[jobName] = __WEBPACK_IMPORTED_MODULE_9__utils_debounce_js__["a" /* Debouncer */].debounce(
            this._debouncers[jobName]
          , wait > 0 ? __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["b" /* timeOut */].after(wait) : __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["a" /* microTask */]
          , callback.bind(this));
    }

    /**
     * Returns whether a named debouncer is active.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     * @return {boolean} Whether the debouncer is active (has not yet fired).
     */
    isDebouncerActive(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      return !!(debouncer && debouncer.isActive());
    }

    /**
     * Immediately calls the debouncer `callback` and inactivates it.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     */
    flushDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.flush();
      }
    }

    /**
     * Cancels an active debouncer.  The `callback` will not be called.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     */
    cancelDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.cancel();
      }
    }

    /**
     * Runs a callback function asyncronously.
     *
     * By default (if no waitTime is specified), async callbacks are run at
     * microtask timing, which will occur before paint.
     *
     * @param {Function} callback The callback function to run, bound to `this`.
     * @param {number=} waitTime Time to wait before calling the
     *   `callback`.  If unspecified or 0, the callback will be run at microtask
     *   timing (before paint).
     * @return {number} Handle that may be used to cancel the async job.
     */
    async(callback, waitTime) {
      return waitTime > 0 ? __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["b" /* timeOut */].run(callback.bind(this), waitTime) :
          ~__WEBPACK_IMPORTED_MODULE_10__utils_async_js__["a" /* microTask */].run(callback.bind(this));
    }

    /**
     * Cancels an async operation started with `async`.
     *
     * @param {number} handle Handle returned from original `async` call to
     *   cancel.
     */
    cancelAsync(handle) {
      handle < 0 ? __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["a" /* microTask */].cancel(~handle) :
          __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["b" /* timeOut */].cancel(handle);
    }

    // other

    /**
     * Convenience method for creating an element and configuring it.
     *
     * @param {string} tag HTML element tag to create.
     * @param {Object} props Object of properties to configure on the
     *    instance.
     * @return {Element} Newly created and configured element.
     */
    create(tag, props) {
      let elt = document.createElement(tag);
      if (props) {
        if (elt.setProperties) {
          elt.setProperties(props);
        } else {
          for (let n in props) {
            elt[n] = props[n];
          }
        }
      }
      return elt;
    }

    /**
     * Convenience method for importing an HTML document imperatively.
     *
     * This method creates a new `<link rel="import">` element with
     * the provided URL and appends it to the document to start loading.
     * In the `onload` callback, the `import` property of the `link`
     * element will contain the imported document contents.
     *
     * @param {string} href URL to document to load.
     * @param {Function} onload Callback to notify when an import successfully
     *   loaded.
     * @param {Function} onerror Callback to notify when an import
     *   unsuccessfully loaded.
     * @param {boolean} optAsync True if the import should be loaded `async`.
     *   Defaults to `false`.
     * @return {HTMLLinkElement} The link element for the URL to be loaded.
     */
    importHref(href, onload, onerror, optAsync) { // eslint-disable-line no-unused-vars
      let loadFn = onload ? onload.bind(this) : null;
      let errorFn = onerror ? onerror.bind(this) : null;
      return Object(__WEBPACK_IMPORTED_MODULE_4__utils_import_href_js__["a" /* importHref */])(href, loadFn, errorFn, optAsync);
    }

    /**
     * Polyfill for Element.prototype.matches, which is sometimes still
     * prefixed.
     *
     * @param {string} selector Selector to test.
     * @param {Element=} node Element to test the selector against.
     * @return {boolean} Whether the element matches the selector.
     */
    elementMatches(selector, node) {
      return Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["c" /* matchesSelector */])( (node || this), selector);
    }

    /**
     * Toggles an HTML attribute on or off.
     *
     * @param {string} name HTML attribute name
     * @param {boolean=} bool Boolean to force the attribute on or off.
     *    When unspecified, the state of the attribute will be reversed.
     * @param {Element=} node Node to target.  Defaults to `this`.
     */
    toggleAttribute(name, bool, node) {
      node = /** @type {Element} */ (node || this);
      if (arguments.length == 1) {
        bool = !node.hasAttribute(name);
      }
      if (bool) {
        node.setAttribute(name, '');
      } else {
        node.removeAttribute(name);
      }
    }


    /**
     * Toggles a CSS class on or off.
     *
     * @param {string} name CSS class name
     * @param {boolean=} bool Boolean to force the class on or off.
     *    When unspecified, the state of the class will be reversed.
     * @param {Element=} node Node to target.  Defaults to `this`.
     */
    toggleClass(name, bool, node) {
      node = /** @type {Element} */ (node || this);
      if (arguments.length == 1) {
        bool = !node.classList.contains(name);
      }
      if (bool) {
        node.classList.add(name);
      } else {
        node.classList.remove(name);
      }
    }

    /**
     * Cross-platform helper for setting an element's CSS `transform` property.
     *
     * @param {string} transformText Transform setting.
     * @param {Element=} node Element to apply the transform to.
     * Defaults to `this`
     */
    transform(transformText, node) {
      node = /** @type {Element} */ (node || this);
      node.style.webkitTransform = transformText;
      node.style.transform = transformText;
    }

    /**
     * Cross-platform helper for setting an element's CSS `translate3d`
     * property.
     *
     * @param {number} x X offset.
     * @param {number} y Y offset.
     * @param {number} z Z offset.
     * @param {Element=} node Element to apply the transform to.
     * Defaults to `this`.
     */
    translate3d(x, y, z, node) {
      node = /** @type {Element} */ (node || this);
      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
    }

    /**
     * Removes an item from an array, if it exists.
     *
     * If the array is specified by path, a change notification is
     * generated, so that observers, data bindings and computed
     * properties watching that path can update.
     *
     * If the array is passed directly, **no change
     * notification is generated**.
     *
     * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
     *   (or the array itself).
     * @param {*} item Item to remove.
     * @return {Array} Array containing item removed.
     */
    arrayDelete(arrayOrPath, item) {
      let index;
      if (Array.isArray(arrayOrPath)) {
        index = arrayOrPath.indexOf(item);
        if (index >= 0) {
          return arrayOrPath.splice(index, 1);
        }
      } else {
        let arr = Object(__WEBPACK_IMPORTED_MODULE_11__utils_path_js__["a" /* get */])(this, arrayOrPath);
        index = arr.indexOf(item);
        if (index >= 0) {
          return this.splice(arrayOrPath, index, 1);
        }
      }
      return null;
    }

    // logging

    /**
     * Facades `console.log`/`warn`/`error` as override point.
     *
     * @param {string} level One of 'log', 'warn', 'error'
     * @param {Array} args Array of strings or objects to log
     */
    _logger(level, args) {
      // accept ['foo', 'bar'] and [['foo', 'bar']]
      if (Array.isArray(args) && args.length === 1) {
        args = args[0];
      }
      switch(level) {
        case 'log':
        case 'warn':
        case 'error':
          console[level](...args);
      }
    }

    /**
     * Facades `console.log` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     */
    _log(...args) {
      this._logger('log', args);
    }

    /**
     * Facades `console.warn` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     */
    _warn(...args) {
      this._logger('warn', args);
    }

    /**
     * Facades `console.error` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     */
    _error(...args) {
      this._logger('error', args);
    }

    /**
     * Formats a message using the element type an a method name.
     *
     * @param {string} methodName Method name to associate with message
     * @param {...*} args Array of strings or objects to log
     * @return {Array} Array with formatting information for `console`
     *   logging.
     */
    _logf(methodName, ...args) {
      return ['[%s::%s]', this.is, methodName, ...args];
    }

  }

  LegacyElement.prototype.is = '';

  return LegacyElement;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = LegacyElementMixin;



/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["f"] = toCssText;
/* harmony export (immutable) */ __webpack_exports__["e"] = rulesForStyle;
/* unused harmony export isKeyframesSelector */
/* harmony export (immutable) */ __webpack_exports__["a"] = forEachRule;
/* unused harmony export applyCss */
/* unused harmony export createScopeStyle */
/* unused harmony export applyStylePlaceHolder */
/* unused harmony export applyStyle */
/* unused harmony export isTargetedBuild */
/* unused harmony export getCssBuildType */
/* harmony export (immutable) */ __webpack_exports__["d"] = processVariableAndFallback;
/* unused harmony export setElementClassRaw */
/* harmony export (immutable) */ __webpack_exports__["c"] = getIsExtends;
/* harmony export (immutable) */ __webpack_exports__["b"] = gatherStyleText;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_settings_js__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_parse_js__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_regex_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__unscoped_style_handler_js__ = __webpack_require__(55);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/




 // eslint-disable-line no-unused-vars



/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 * @return {string}
 */
function toCssText (rules, callback) {
  if (!rules) {
    return '';
  }
  if (typeof rules === 'string') {
    rules = Object(__WEBPACK_IMPORTED_MODULE_1__css_parse_js__["a" /* parse */])(rules);
  }
  if (callback) {
    forEachRule(rules, callback);
  }
  return Object(__WEBPACK_IMPORTED_MODULE_1__css_parse_js__["b" /* stringify */])(rules, __WEBPACK_IMPORTED_MODULE_0__style_settings_js__["a" /* nativeCssVariables */]);
}

/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */
function rulesForStyle(style) {
  if (!style['__cssRules'] && style.textContent) {
    style['__cssRules'] = Object(__WEBPACK_IMPORTED_MODULE_1__css_parse_js__["a" /* parse */])(style.textContent);
  }
  return style['__cssRules'] || null;
}

// Tests if a rule is a keyframes selector, which looks almost exactly
// like a normal selector but is not (it has nothing to do with scoping
// for example).
/**
 * @param {StyleNode} rule
 * @return {boolean}
 */
function isKeyframesSelector(rule) {
  return Boolean(rule['parent']) &&
  rule['parent']['type'] === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].KEYFRAMES_RULE;
}

/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */
function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }
  let skipRules = false;
  let type = node['type'];
  if (onlyActiveRules) {
    if (type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].MEDIA_RULE) {
      let matchMedia = node['selector'].match(__WEBPACK_IMPORTED_MODULE_2__common_regex_js__["a" /* MEDIA_MATCH */]);
      if (matchMedia) {
        // if rule is a non matching @media rule, skip subrules
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }
  if (type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback &&
    type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].MIXIN_RULE) {
    skipRules = true;
  }
  let r$ = node['rules'];
  if (r$ && !skipRules) {
    for (let i=0, l=r$.length, r; (i<l) && (r=r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
}

// add a string of cssText to the document.
/**
 * @param {string} cssText
 * @param {string} moniker
 * @param {Node} target
 * @param {Node} contextNode
 * @return {HTMLStyleElement}
 */
function applyCss(cssText, moniker, target, contextNode) {
  let style = createScopeStyle(cssText, moniker);
  applyStyle(style, target, contextNode);
  return style;
}

/**
 * @param {string} cssText
 * @param {string} moniker
 * @return {HTMLStyleElement}
 */
function createScopeStyle(cssText, moniker) {
  let style = /** @type {HTMLStyleElement} */(document.createElement('style'));
  if (moniker) {
    style.setAttribute('scope', moniker);
  }
  style.textContent = cssText;
  return style;
}

/**
 * Track the position of the last added style for placing placeholders
 * @type {Node}
 */
let lastHeadApplyNode = null;

// insert a comment node as a styling position placeholder.
/**
 * @param {string} moniker
 * @return {!Comment}
 */
function applyStylePlaceHolder(moniker) {
  let placeHolder = document.createComment(' Shady DOM styles for ' +
    moniker + ' ');
  let after = lastHeadApplyNode ?
    lastHeadApplyNode['nextSibling'] : null;
  let scope = document.head;
  scope.insertBefore(placeHolder, after || scope.firstChild);
  lastHeadApplyNode = placeHolder;
  return placeHolder;
}

/**
 * @param {HTMLStyleElement} style
 * @param {?Node} target
 * @param {?Node} contextNode
 */
function applyStyle(style, target, contextNode) {
  target = target || document.head;
  let after = (contextNode && contextNode.nextSibling) ||
    target.firstChild;
  target.insertBefore(style, after);
  if (!lastHeadApplyNode) {
    lastHeadApplyNode = style;
  } else {
    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode
    let position = style.compareDocumentPosition(lastHeadApplyNode);
    if (position === Node.DOCUMENT_POSITION_PRECEDING) {
      lastHeadApplyNode = style;
    }
  }
}

/**
 * @param {string} buildType
 * @return {boolean}
 */
function isTargetedBuild(buildType) {
  return __WEBPACK_IMPORTED_MODULE_0__style_settings_js__["b" /* nativeShadow */] ? buildType === 'shadow' : buildType === 'shady';
}

/**
 * @param {Element} element
 * @return {?string}
 */
function getCssBuildType(element) {
  return element.getAttribute('css-build');
}

/**
 * Walk from text[start] matching parens and
 * returns position of the outer end paren
 * @param {string} text
 * @param {number} start
 * @return {number}
 */
function findMatchingParen(text, start) {
  let level = 0;
  for (let i=start, l=text.length; i < l; i++) {
    if (text[i] === '(') {
      level++;
    } else if (text[i] === ')') {
      if (--level === 0) {
        return i;
      }
    }
  }
  return -1;
}

/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */
function processVariableAndFallback(str, callback) {
  // find 'var('
  let start = str.indexOf('var(');
  if (start === -1) {
    // no var?, everything is prefix
    return callback(str, '', '', '');
  }
  //${prefix}var(${inner})${suffix}
  let end = findMatchingParen(str, start + 3);
  let inner = str.substring(start + 4, end);
  let prefix = str.substring(0, start);
  // suffix may have other variables
  let suffix = processVariableAndFallback(str.substring(end + 1), callback);
  let comma = inner.indexOf(',');
  // value and fallback args should be trimmed to match in property lookup
  if (comma === -1) {
    // variable, no fallback
    return callback(prefix, inner.trim(), '', suffix);
  }
  // var(${value},${fallback})
  let value = inner.substring(0, comma).trim();
  let fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}

/**
 * @param {Element} element
 * @param {string} value
 */
function setElementClassRaw(element, value) {
  // use native setAttribute provided by ShadyDOM when setAttribute is patched
  if (__WEBPACK_IMPORTED_MODULE_0__style_settings_js__["b" /* nativeShadow */]) {
    element.setAttribute('class', value);
  } else {
    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);
  }
}

/**
 * @param {Element | {is: string, extends: string}} element
 * @return {{is: string, typeExtension: string}}
 */
function getIsExtends(element) {
  let localName = element['localName'];
  let is = '', typeExtension = '';
  /*
  NOTE: technically, this can be wrong for certain svg elements
  with `-` in the name like `<font-face>`
  */
  if (localName) {
    if (localName.indexOf('-') > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = (element.getAttribute && element.getAttribute('is')) || '';
    }
  } else {
    is = /** @type {?} */(element).is;
    typeExtension = /** @type {?} */(element).extends;
  }
  return {is, typeExtension};
}

/**
 * @param {Element|DocumentFragment} element
 * @return {string}
 */
function gatherStyleText(element) {
  /** @type {!Array<string>} */
  const styleTextParts = [];
  const styles = /** @type {!NodeList<!HTMLStyleElement>} */(element.querySelectorAll('style'));
  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];
    if (Object(__WEBPACK_IMPORTED_MODULE_3__unscoped_style_handler_js__["a" /* isUnscopedStyle */])(style)) {
      if (!__WEBPACK_IMPORTED_MODULE_0__style_settings_js__["b" /* nativeShadow */]) {
        Object(__WEBPACK_IMPORTED_MODULE_3__unscoped_style_handler_js__["b" /* processUnscopedStyle */])(style);
        style.parentNode.removeChild(style);
      }
    } else {
      styleTextParts.push(style.textContent);
      style.parentNode.removeChild(style);
    }
  }
  return styleTextParts.join('').trim();
}

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * @const {!Object<string, !HTMLTemplateElement>}
 */
const templateMap = {};
/* harmony default export */ __webpack_exports__["a"] = (templateMap);


/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = documentWait;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/** @type {Promise<void>} */
let readyPromise = null;

/** @type {?function(?function())} */
let whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;

/** @type {function()} */
let resolveFn;

/**
 * @param {?function()} callback
 */
function documentWait(callback) {
  requestAnimationFrame(function() {
    if (whenReady) {
      whenReady(callback)
    } else {
      if (!readyPromise) {
        readyPromise = new Promise((resolve) => {resolveFn = resolve});
        if (document.readyState === 'complete') {
          resolveFn();
        } else {
          document.addEventListener('readystatechange', () => {
            if (document.readyState === 'complete') {
              resolveFn();
            }
          });
        }
      }
      readyPromise.then(function(){ callback && callback(); });
    }
  });
}


/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CustomStyleProvider */
/* unused harmony export CustomStyleInterfaceInterface */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__document_wait_js__ = __webpack_require__(36);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/





/**
 * @typedef {HTMLStyleElement | {getStyle: function():HTMLStyleElement}}
 */
let CustomStyleProvider;

const SEEN_MARKER = '__seenByShadyCSS';
const CACHED_STYLE = '__shadyCSSCachedStyle';

/** @type {?function(!HTMLStyleElement)} */
let transformFn = null;

/** @type {?function()} */
let validateFn = null;

/**
This interface is provided to add document-level <style> elements to ShadyCSS for processing.
These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties

To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`

In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
This function will be called when calculating styles.

An example usage of the document-level styling api can be found in `examples/document-style-lib.js`

@unrestricted
*/
class CustomStyleInterface {
  constructor() {
    /** @type {!Array<!CustomStyleProvider>} */
    this['customStyles'] = [];
    this['enqueued'] = false;
  }
  /**
   * Queue a validation for new custom styles to batch style recalculations
   */
  enqueueDocumentValidation() {
    if (this['enqueued'] || !validateFn) {
      return;
    }
    this['enqueued'] = true;
    Object(__WEBPACK_IMPORTED_MODULE_0__document_wait_js__["a" /* default */])(validateFn);
  }
  /**
   * @param {!HTMLStyleElement} style
   */
  addCustomStyle(style) {
    if (!style[SEEN_MARKER]) {
      style[SEEN_MARKER] = true;
      this['customStyles'].push(style);
      this.enqueueDocumentValidation();
    }
  }
  /**
   * @param {!CustomStyleProvider} customStyle
   * @return {HTMLStyleElement}
   */
  getStyleForCustomStyle(customStyle) {
    if (customStyle[CACHED_STYLE]) {
      return customStyle[CACHED_STYLE];
    }
    let style;
    if (customStyle['getStyle']) {
      style = customStyle['getStyle']();
    } else {
      style = customStyle;
    }
    return style;
  }
  /**
   * @return {!Array<!CustomStyleProvider>}
   */
  processStyles() {
    const cs = this['customStyles'];
    for (let i = 0; i < cs.length; i++) {
      const customStyle = cs[i];
      if (customStyle[CACHED_STYLE]) {
        continue;
      }
      const style = this.getStyleForCustomStyle(customStyle);
      if (style) {
        // HTMLImports polyfill may have cloned the style into the main document,
        // which is referenced with __appliedElement.
        const styleToTransform = /** @type {!HTMLStyleElement} */(style['__appliedElement'] || style);
        if (transformFn) {
          transformFn(styleToTransform);
        }
        customStyle[CACHED_STYLE] = styleToTransform;
      }
    }
    return cs;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CustomStyleInterface;


CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype['processStyles'] = CustomStyleInterface.prototype.processStyles;

Object.defineProperties(CustomStyleInterface.prototype, {
  'transformCallback': {
    /** @return {?function(!HTMLStyleElement)} */
    get() {
      return transformFn;
    },
    /** @param {?function(!HTMLStyleElement)} fn */
    set(fn) {
      transformFn = fn;
    }
  },
  'validateCallback': {
    /** @return {?function()} */
    get() {
      return validateFn;
    },
    /**
     * @param {?function()} fn
     * @this {CustomStyleInterface}
     */
    set(fn) {
      let needsEnqueue = false;
      if (!validateFn) {
        needsEnqueue = true;
      }
      validateFn = fn;
      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    },
  }
})

/** @typedef {{
 * customStyles: !Array<!CustomStyleProvider>,
 * addCustomStyle: function(!CustomStyleProvider),
 * getStyleForCustomStyle: function(!CustomStyleProvider): HTMLStyleElement,
 * findStyles: function(),
 * transformCallback: ?function(!HTMLStyleElement),
 * validateCallback: ?function()
 * }}
 */
let CustomStyleInterfaceInterface;


/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = cssFromModules;
/* unused harmony export cssFromModule */
/* harmony export (immutable) */ __webpack_exports__["c"] = cssFromTemplate;
/* harmony export (immutable) */ __webpack_exports__["a"] = cssFromModuleImports;
/* unused harmony export _cssFromModuleImports */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__resolve_url_js__ = __webpack_require__(10);


const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
const INCLUDE_ATTR = 'include';

function importModule(moduleId) {
  const /** Polymer.DomModule */ PolymerDomModule = customElements.get('dom-module');
  if (!PolymerDomModule) {
    return null;
  }
  return PolymerDomModule.import(moduleId);
}

/** @typedef {{assetpath: string}} */
let templateWithAssetPath; // eslint-disable-line no-unused-vars

function cssFromModules(moduleIds) {
  let modules = moduleIds.trim().split(/\s+/);
  let cssText = '';
  for (let i=0; i < modules.length; i++) {
    cssText += cssFromModule(modules[i]);
  }
  return cssText;
}

function cssFromModule(moduleId) {
  let m = importModule(moduleId);
  if (m && m._cssText === undefined) {
    // module imports: <link rel="import" type="css">
    let cssText = _cssFromModuleImports(m);
    // include css from the first template in the module
    let t = m.querySelector('template');
    if (t) {
      cssText += cssFromTemplate(t, /** @type {templateWithAssetPath} */(m).assetpath);
    }
    m._cssText = cssText || null;
  }
  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
  }
  return m && m._cssText || '';
}

function cssFromTemplate(template, baseURI) {
  let cssText = '';
  // if element is a template, get content from its .content
  let e$ = template.content.querySelectorAll('style');
  for (let i=0; i < e$.length; i++) {
    let e = e$[i];
    // support style sharing by allowing styles to "include"
    // other dom-modules that contain styling
    let include = e.getAttribute(INCLUDE_ATTR);
    if (include) {
      cssText += cssFromModules(include);
    }
    e.parentNode.removeChild(e);
    cssText += baseURI ?
      Object(__WEBPACK_IMPORTED_MODULE_0__resolve_url_js__["b" /* resolveCss */])(e.textContent, baseURI) : e.textContent;
  }
  return cssText;
}

function cssFromModuleImports(moduleId) {
  let m = importModule(moduleId);
  return m ? _cssFromModuleImports(m) : '';
}

function _cssFromModuleImports(module) {
  let cssText = '';
  let p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (let i=0; i < p$.length; i++) {
    let p = p$[i];
    if (p.import) {
      let importDoc = p.import;
      // NOTE: polyfill affordance.
      // under the HTMLImports polyfill, there will be no 'body',
      // but the import pseudo-doc can be used directly.
      let container = importDoc.body ? importDoc.body : importDoc;
      cssText +=
        Object(__WEBPACK_IMPORTED_MODULE_0__resolve_url_js__["b" /* resolveCss */])(container.textContent,
          importDoc.baseURI);
    }
  }
  return cssText;
}


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_gestures_js__ = __webpack_require__(12);




/**
 * @const {Polymer.Gestures}
 */
const gestures = __WEBPACK_IMPORTED_MODULE_2__utils_gestures_js__;

const GestureEventListeners = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_GestureEventListeners}
   */
  class GestureEventListeners extends superClass {

    _addEventListenerToNode(node, eventName, handler) {
      if (!gestures.addListener(node, eventName, handler)) {
        super._addEventListenerToNode(node, eventName, handler);
      }
    }

    _removeEventListenerFromNode(node, eventName, handler) {
      if (!gestures.removeListener(node, eventName, handler)) {
        super._removeEventListenerFromNode(node, eventName, handler);
      }
    }

  }

  return GestureEventListeners;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = GestureEventListeners;



/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return calculateSplices; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3;

// Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.
function calcEditDistances(current, currentStart, currentEnd,
                            old, oldStart, oldEnd) {
  // "Deletion" columns
  let rowCount = oldEnd - oldStart + 1;
  let columnCount = currentEnd - currentStart + 1;
  let distances = new Array(rowCount);

  // "Addition" rows. Initialize null column.
  for (let i = 0; i < rowCount; i++) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  }

  // Initialize null row
  for (let j = 0; j < columnCount; j++)
    distances[0][j] = j;

  for (let i = 1; i < rowCount; i++) {
    for (let j = 1; j < columnCount; j++) {
      if (equals(current[currentStart + j - 1], old[oldStart + i - 1]))
        distances[i][j] = distances[i - 1][j - 1];
      else {
        let north = distances[i - 1][j] + 1;
        let west = distances[i][j - 1] + 1;
        distances[i][j] = north < west ? north : west;
      }
    }
  }

  return distances;
}

// This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.
function spliceOperationsFromEditDistances(distances) {
  let i = distances.length - 1;
  let j = distances[0].length - 1;
  let current = distances[i][j];
  let edits = [];
  while (i > 0 || j > 0) {
    if (i == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j == 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }
    let northWest = distances[i - 1][j - 1];
    let west = distances[i - 1][j];
    let north = distances[i][j - 1];

    let min;
    if (west < north)
      min = west < northWest ? west : northWest;
    else
      min = north < northWest ? north : northWest;

    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }

  edits.reverse();
  return edits;
}

/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */

/**
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 *
 * @param {Array} current The current "changed" array for which to
 * calculate splices.
 * @param {number} currentStart Starting index in the `current` array for
 * which splices are calculated.
 * @param {number} currentEnd Ending index in the `current` array for
 * which splices are calculated.
 * @param {Array} old The original "unchanged" array to compare `current`
 * against to determine splices.
 * @param {number} oldStart Starting index in the `old` array for
 * which splices are calculated.
 * @param {number} oldEnd Ending index in the `old` array for
 * which splices are calculated.
 * @return {Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */
function calcSplices(current, currentStart, currentEnd,
                      old, oldStart, oldEnd) {
  let prefixCount = 0;
  let suffixCount = 0;
  let splice;

  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0)
    prefixCount = sharedPrefix(current, old, minLength);

  if (currentEnd == current.length && oldEnd == old.length)
    suffixCount = sharedSuffix(current, old, minLength - prefixCount);

  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;

  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
    return [];

  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd)
      splice.removed.push(old[oldStart++]);

    return [ splice ];
  } else if (oldStart == oldEnd)
    return [ newSplice(currentStart, [], currentEnd - currentStart) ];

  let ops = spliceOperationsFromEditDistances(
      calcEditDistances(current, currentStart, currentEnd,
                             old, oldStart, oldEnd));

  splice = undefined;
  let splices = [];
  let index = currentStart;
  let oldIndex = oldStart;
  for (let i = 0; i < ops.length; i++) {
    switch(ops[i]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = undefined;
        }

        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }

  if (splice) {
    splices.push(splice);
  }
  return splices;
}

function sharedPrefix(current, old, searchLength) {
  for (let i = 0; i < searchLength; i++)
    if (!equals(current[i], old[i]))
      return i;
  return searchLength;
}

function sharedSuffix(current, old, searchLength) {
  let index1 = current.length;
  let index2 = old.length;
  let count = 0;
  while (count < searchLength && equals(current[--index1], old[--index2]))
    count++;

  return count;
}

function calculateSplices(current, previous) {
  return calcSplices(current, 0, current.length, previous, 0,
                          previous.length);
}

function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}




/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_lit_html__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ajax_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_paper_dialog_paper_dialog__ = __webpack_require__(71);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_paper_button_paper_button__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_paper_input_paper_input__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polymer_paper_checkbox_paper_checkbox__ = __webpack_require__(94);







class TactileEditable extends __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__["a" /* Element */] {
  static get is() {
    return "tactile-editable";
  }

  static get properties() {
    return {
      path: {
        type: String
      },
      compType: {
        type: String
      },
      inline: {
        type: Boolean,
        default: true
      }
    };
  }

  constructor() {
    super();
    this.attachShadow({
      mode: "open"
    });
  }

  connectedCallback() {
    this.render();
  }

  render() {
    var inputs = ``;
    var message = ``;
    var buttons = ``;
    var content = ``;

    if (this.component) {
      inputs = this._createInputs(this.component);
      message = this._createMessage(this.component);
      buttons = this._createButtons(this.component);
    }

    if (this.inline) {
      content = __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`<slot></slot>`;
    } else {
      content = __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
      <div style="position: relative;">
        <paper-ripple></paper-ripple>
        <slot></slot>
      </div>`;
    }

    Object(__WEBPACK_IMPORTED_MODULE_1_lit_html__["b" /* render */])(__WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
    <paper-dialog modal style="min-width: 600px;">
      ${message}
      ${inputs}
      ${buttons}
    </paper-dialog>
    ${content}
    `, this.shadowRoot);
  }

  openDialog(callback) {
    Object(__WEBPACK_IMPORTED_MODULE_2__ajax_js__["ajaxGet"])(this.path + ".json", component => {
      this.component = component;
      this.render();
      var paperDialog = this.shadowRoot.querySelector("paper-dialog");
      paperDialog.open();

      this._attachButtonHandlers();

      this._attachClosedHandlers(callback);
    });
  }

  formValues() {
    var values = {};
    this.shadowRoot.querySelectorAll("paper-input").forEach(input => {
      if (typeof input.value !== "undefined") {
        values[input.name] = input.value;
      } else {
        values[input.name] = "";
      }
    });
    this.shadowRoot.querySelectorAll("paper-checkbox").forEach(input => {
      if (typeof input.value !== "undefined") {
        console.log(input.active);
        values[input.name] = input.active;
      } else {
        values[input.name] = false;
      }
    });
    return values;
  }

  _attachClosedHandlers(callback) {
    var paperDialog = this.shadowRoot.querySelector("paper-dialog");

    var dialogClosed = event => {
      if (event.detail.confirmed) {
        Object(__WEBPACK_IMPORTED_MODULE_2__ajax_js__["ajaxPost"])(this.path, this.formValues());
      }

      paperDialog.removeEventListener("iron-overlay-closed", dialogClosed);
      callback(event.detail.confirmed);
    };

    paperDialog.addEventListener("iron-overlay-closed", dialogClosed);
  }

  _attachButtonHandlers() {
    var paperDialog = this.shadowRoot.querySelector("paper-dialog");
    Array.from(paperDialog.querySelectorAll("paper-button.tactile-add")).forEach(button => {
      button.addEventListener("click", e => {
        var path = this.path + "/" + e.target.dataset.path;
        var template = JSON.parse(e.target.dataset.template);
        Object(__WEBPACK_IMPORTED_MODULE_2__ajax_js__["ajaxPut"])(path, template, callback);
      });
    });
    Array.from(paperDialog.querySelectorAll("paper-button.tactile-delete")).forEach(button => {
      button.addEventListener("click", e => {
        Object(__WEBPACK_IMPORTED_MODULE_2__ajax_js__["ajaxDelete"])(this.path, callback);
      });
    });
  }

  _createInputs(component) {
    var inputs = [];
    component.author.attrs.forEach(input => {
      if (input.type === "String") {
        inputs.push(__WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`<paper-input
                name=${input.name}
                label=${input.title}
                value=${component[input.name]}></paper-input>`);
      } else if (input.type === "Boolean") {
        if (component[input.name]) {
          inputs.push(__WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`<paper-checkbox name=${input.name} checked>${input.title}</paper-checkbox>`);
        } else {
          inputs.push(__WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`<paper-checkbox name=${input.name}>${input.title}</paper-checkbox>`);
        }
      }
    });
    return inputs;
  }

  _createMessage(component) {
    return __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
      <h2>${component.author.title}</h2>
      <p>${component.author.description}</p>`;
  }

  _createButtons(component) {
    var extraButtons = [];
    component.author.attrs.forEach(input => {
      if (input.type === "Add") {
        var button = __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`<paper-button
                            class="tactile-add"
                            data-path=${input.path}
                            data-template=${JSON.stringify(input.template)}
                            data-comp-type=${input.compType}>
                            ${input.title}
                          </paper-button>`;
        extraButtons.push(button);
      }
    });

    if (!component.author.preventDelete && !component.preventDelete) {
      var deleteButton = __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
        <paper-button class="tactile-delete" data-path=${this.path}>Delete</paper-button>
      `;
    }

    return __WEBPACK_IMPORTED_MODULE_1_lit_html__["a" /* html */]`
      <div class="buttons">
        ${extraButtons}
        ${deleteButton}
        <paper-button dialog-dismiss>Decline</paper-button>
        <paper-button dialog-confirm autofocus>Accept</paper-button>
      </div>`;
  }

}
/* harmony export (immutable) */ __webpack_exports__["default"] = TactileEditable;
 // Register custom element class with browser

customElements.define(TactileEditable.is, TactileEditable);

/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = render;
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * TypeScript has a problem with precompiling templates literals
 * https://github.com/Microsoft/TypeScript/issues/17956
 *
 * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and
 * TypeScript to verify correctness.
 */
const envCachesTemplates = ((t) => t() === t())(() => ((s) => s) ``);
// The first argument to JS template tags retain identity across multiple
// calls to a tag for the same literal, so we can cache work done per literal
// in a Map.
const templates = new Map();
const svgTemplates = new Map();
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */
const html = (strings, ...values) => litTag(strings, values, templates, false);
/* harmony export (immutable) */ __webpack_exports__["a"] = html;

/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 */
const svg = (strings, ...values) => litTag(strings, values, svgTemplates, true);
/* unused harmony export svg */

function litTag(strings, values, templates, isSvg) {
    const key = envCachesTemplates ?
        strings :
        strings.join('{{--uniqueness-workaround--}}');
    let template = templates.get(key);
    if (template === undefined) {
        template = new Template(strings, isSvg);
        templates.set(key, template);
    }
    return new TemplateResult(template, values);
}
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */
class TemplateResult {
    constructor(template, values) {
        this.template = template;
        this.values = values;
    }
}
/* unused harmony export TemplateResult */

/**
 * Renders a template to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 */
function render(result, container, partCallback = defaultPartCallback) {
    let instance = container.__templateInstance;
    // Repeat render, just call update()
    if (instance !== undefined && instance.template === result.template &&
        instance._partCallback === partCallback) {
        instance.update(result.values);
        return;
    }
    // First render, create a new TemplateInstance and append it
    instance = new TemplateInstance(result.template, partCallback);
    container.__templateInstance = instance;
    const fragment = instance._clone();
    instance.update(result.values);
    let child;
    while ((child = container.lastChild)) {
        container.removeChild(child);
    }
    container.appendChild(fragment);
}
/**
 * An expression marker with embedded unique key to avoid
 * https://github.com/PolymerLabs/lit-html/issues/62
 */
const attributeMarker = `{{lit-${Math.random()}}}`;
/**
 * Regex to scan the string preceding an expression to see if we're in a text
 * context, and not an attribute context.
 *
 * This works by seeing if we have a `>` not followed by a `<`. If there is a
 * `<` closer to the end of the strings, then we're inside a tag.
 */
const textRegex = />[^<]*$/;
const hasTagsRegex = /[^<]*/;
const textMarkerContent = '_-lit-html-_';
const textMarker = `<!--${textMarkerContent}-->`;
const attrOrTextRegex = new RegExp(`${attributeMarker}|${textMarker}`);
/**
 * A placeholder for a dynamic expression in an HTML template.
 *
 * There are two built-in part types: AttributePart and NodePart. NodeParts
 * always represent a single dynamic expression, while AttributeParts may
 * represent as many expressions are contained in the attribute.
 *
 * A Template's parts are mutable, so parts can be replaced or modified
 * (possibly to implement different template semantics). The contract is that
 * parts can only be replaced, not removed, added or reordered, and parts must
 * always consume the correct number of values in their `update()` method.
 *
 * TODO(justinfagnani): That requirement is a little fragile. A
 * TemplateInstance could instead be more careful about which values it gives
 * to Part.update().
 */
class TemplatePart {
    constructor(type, index, name, rawName, strings) {
        this.type = type;
        this.index = index;
        this.name = name;
        this.rawName = rawName;
        this.strings = strings;
    }
}
/* unused harmony export TemplatePart */

class Template {
    constructor(strings, svg = false) {
        this.parts = [];
        this.svg = svg;
        this.element = document.createElement('template');
        this.element.innerHTML = this._getHtml(strings, svg);
        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
        const walker = document.createTreeWalker(this.element.content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
               NodeFilter.SHOW_TEXT */, null, false);
        let index = -1;
        let partIndex = 0;
        const nodesToRemove = [];
        // The actual previous node, accounting for removals: if a node is removed
        // it will never be the previousNode.
        let previousNode;
        // Used to set previousNode at the top of the loop.
        let currentNode;
        while (walker.nextNode()) {
            index++;
            previousNode = currentNode;
            const node = currentNode = walker.currentNode;
            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                if (!node.hasAttributes()) {
                    continue;
                }
                const attributes = node.attributes;
                for (let i = 0; i < attributes.length; i++) {
                    const attribute = attributes.item(i);
                    const attributeStrings = attribute.value.split(attrOrTextRegex);
                    if (attributeStrings.length > 1) {
                        // Get the template literal section leading up to the first
                        // expression in this attribute attribute
                        const attributeString = strings[partIndex];
                        // Trim the trailing literal value if this is an interpolation
                        const rawNameString = attributeString.substring(0, attributeString.length - attributeStrings[0].length);
                        // Find the attribute name
                        const rawName = rawNameString.match(/((?:\w|[.\-_$])+)=["']?$/)[1];
                        this.parts.push(new TemplatePart('attribute', index, attribute.name, rawName, attributeStrings));
                        node.removeAttribute(attribute.name);
                        partIndex += attributeStrings.length - 1;
                        i--;
                    }
                }
            }
            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                const nodeValue = node.nodeValue;
                const strings = nodeValue.split(attributeMarker);
                if (strings.length > 1) {
                    const parent = node.parentNode;
                    const lastIndex = strings.length - 1;
                    // We have a part for each match found
                    partIndex += lastIndex;
                    // We keep this current node, but reset its content to the last
                    // literal part. We insert new literal nodes before this so that the
                    // tree walker keeps its position correctly.
                    node.textContent = strings[lastIndex];
                    // Generate a new text node for each literal section
                    // These nodes are also used as the markers for node parts
                    for (let i = 0; i < lastIndex; i++) {
                        parent.insertBefore(document.createTextNode(strings[i]), node);
                        this.parts.push(new TemplatePart('node', index++));
                    }
                }
                else {
                    // Strip whitespace-only nodes, only between elements, or at the
                    // beginning or end of elements.
                    const previousSibling = node.previousSibling;
                    const nextSibling = node.nextSibling;
                    if ((previousSibling === null ||
                        previousSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&
                        (nextSibling === null ||
                            nextSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&
                        nodeValue.trim() === '') {
                        nodesToRemove.push(node);
                        currentNode = previousNode;
                        index--;
                    }
                }
            }
            else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&
                node.nodeValue === textMarkerContent) {
                const parent = node.parentNode;
                // If we don't have a previous node add a marker node.
                // If the previousSibling is removed, because it's another part
                // placholder, or empty text, add a marker node.
                if (node.previousSibling === null ||
                    node.previousSibling !== previousNode) {
                    parent.insertBefore(new Text(), node);
                }
                else {
                    index--;
                }
                this.parts.push(new TemplatePart('node', index++));
                nodesToRemove.push(node);
                // If we don't have a next node add a marker node.
                // We don't have to check if the next node is going to be removed,
                // because that node will induce a marker if so.
                if (node.nextSibling === null) {
                    parent.insertBefore(new Text(), node);
                }
                else {
                    index--;
                }
                currentNode = previousNode;
                partIndex++;
            }
        }
        // Remove text binding nodes after the walk to not disturb the TreeWalker
        for (const n of nodesToRemove) {
            n.parentNode.removeChild(n);
        }
    }
    /**
     * Returns a string of HTML used to create a <template> element.
     */
    _getHtml(strings, svg) {
        const l = strings.length;
        const a = [];
        let isTextBinding = false;
        for (let i = 0; i < l - 1; i++) {
            const s = strings[i];
            a.push(s);
            // We're in a text position if the previous string matches the
            // textRegex. If it doesn't and the previous string has no tags, then
            // we use the previous text position state.
            isTextBinding = s.match(textRegex) !== null ||
                (s.match(hasTagsRegex) !== null && isTextBinding);
            a.push(isTextBinding ? textMarker : attributeMarker);
        }
        a.push(strings[l - 1]);
        const html = a.join('');
        return svg ? `<svg>${html}</svg>` : html;
    }
}
/* unused harmony export Template */

const getValue = (part, value) => {
    // `null` as the value of a Text node will render the string 'null'
    // so we convert it to undefined
    if (value != null && value.__litDirective === true) {
        value = value(part);
    }
    return value === null ? undefined : value;
};
/* unused harmony export getValue */

const directive = (f) => {
    f.__litDirective = true;
    return f;
};
/* unused harmony export directive */

class AttributePart {
    constructor(instance, element, name, strings) {
        this.instance = instance;
        this.element = element;
        this.name = name;
        this.strings = strings;
        this.size = strings.length - 1;
    }
    setValue(values, startIndex) {
        const strings = this.strings;
        let text = '';
        for (let i = 0; i < strings.length; i++) {
            text += strings[i];
            if (i < strings.length - 1) {
                const v = getValue(this, values[startIndex + i]);
                if (v &&
                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {
                    for (const t of v) {
                        // TODO: we need to recursively call getValue into iterables...
                        text += t;
                    }
                }
                else {
                    text += v;
                }
            }
        }
        this.element.setAttribute(this.name, text);
    }
}
/* unused harmony export AttributePart */

class NodePart {
    constructor(instance, startNode, endNode) {
        this.instance = instance;
        this.startNode = startNode;
        this.endNode = endNode;
        this._previousValue = undefined;
    }
    setValue(value) {
        value = getValue(this, value);
        if (value === null ||
            !(typeof value === 'object' || typeof value === 'function')) {
            // Handle primitive values
            // If the value didn't change, do nothing
            if (value === this._previousValue) {
                return;
            }
            this._setText(value);
        }
        else if (value instanceof TemplateResult) {
            this._setTemplateResult(value);
        }
        else if (Array.isArray(value) || value[Symbol.iterator]) {
            this._setIterable(value);
        }
        else if (value instanceof Node) {
            this._setNode(value);
        }
        else if (value.then !== undefined) {
            this._setPromise(value);
        }
        else {
            // Fallback, will render the string representation
            this._setText(value);
        }
    }
    _insert(node) {
        this.endNode.parentNode.insertBefore(node, this.endNode);
    }
    _setNode(value) {
        this.clear();
        this._insert(value);
        this._previousValue = value;
    }
    _setText(value) {
        const node = this.startNode.nextSibling;
        if (node === this.endNode.previousSibling &&
            node.nodeType === Node.TEXT_NODE) {
            // If we only have a single text node between the markers, we can just
            // set its value, rather than replacing it.
            // TODO(justinfagnani): Can we just check if _previousValue is
            // primitive?
            node.textContent = value;
        }
        else {
            this._setNode(document.createTextNode(value === undefined ? '' : value));
        }
        this._previousValue = value;
    }
    _setTemplateResult(value) {
        let instance;
        if (this._previousValue &&
            this._previousValue.template === value.template) {
            instance = this._previousValue;
        }
        else {
            instance =
                new TemplateInstance(value.template, this.instance._partCallback);
            this._setNode(instance._clone());
            this._previousValue = instance;
        }
        instance.update(value.values);
    }
    _setIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If _previousValue is an array, then the previous render was of an
        // iterable and _previousValue will contain the NodeParts from the previous
        // render. If _previousValue is not an array, clear this part and make a new
        // array for NodeParts.
        if (!Array.isArray(this._previousValue)) {
            this.clear();
            this._previousValue = [];
        }
        // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render
        const itemParts = this._previousValue;
        let partIndex = 0;
        for (const item of value) {
            // Try to reuse an existing part
            let itemPart = itemParts[partIndex];
            // If no existing part, create a new one
            if (itemPart === undefined) {
                // If we're creating the first item part, it's startNode should be the
                // container's startNode
                let itemStart = this.startNode;
                // If we're not creating the first part, create a new separator marker
                // node, and fix up the previous part's endNode to point to it
                if (partIndex > 0) {
                    const previousPart = itemParts[partIndex - 1];
                    itemStart = previousPart.endNode = document.createTextNode('');
                    this._insert(itemStart);
                }
                itemPart = new NodePart(this.instance, itemStart, this.endNode);
                itemParts.push(itemPart);
            }
            itemPart.setValue(item);
            partIndex++;
        }
        if (partIndex === 0) {
            this.clear();
            this._previousValue = undefined;
        }
        else if (partIndex < itemParts.length) {
            const lastPart = itemParts[partIndex - 1];
            // Truncate the parts array so _previousValue reflects the current state
            itemParts.length = partIndex;
            this.clear(lastPart.endNode.previousSibling);
            lastPart.endNode = this.endNode;
        }
    }
    _setPromise(value) {
        value.then((v) => {
            if (this._previousValue === value) {
                this.setValue(v);
            }
        });
        this._previousValue = value;
    }
    clear(startNode = this.startNode) {
        let node;
        while ((node = startNode.nextSibling) !== this.endNode) {
            node.parentNode.removeChild(node);
        }
    }
}
/* unused harmony export NodePart */

const defaultPartCallback = (instance, templatePart, node) => {
    if (templatePart.type === 'attribute') {
        return new AttributePart(instance, node, templatePart.name, templatePart.strings);
    }
    else if (templatePart.type === 'node') {
        return new NodePart(instance, node, node.nextSibling);
    }
    throw new Error(`Unknown part type ${templatePart.type}`);
};
/* unused harmony export defaultPartCallback */

/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */
class TemplateInstance {
    constructor(template, partCallback = defaultPartCallback) {
        this._parts = [];
        this.template = template;
        this._partCallback = partCallback;
    }
    update(values) {
        let valueIndex = 0;
        for (const part of this._parts) {
            if (part.size === undefined) {
                part.setValue(values[valueIndex]);
                valueIndex++;
            }
            else {
                part.setValue(values, valueIndex);
                valueIndex += part.size;
            }
        }
    }
    _clone() {
        const fragment = document.importNode(this.template.element.content, true);
        if (this.template.parts.length > 0) {
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
            // null
            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT */, null, false);
            const parts = this.template.parts;
            let index = 0;
            let partIndex = 0;
            let templatePart = parts[0];
            let node = walker.nextNode();
            while (node != null && partIndex < parts.length) {
                if (index === templatePart.index) {
                    this._parts.push(this._partCallback(this, templatePart, node));
                    templatePart = parts[++partIndex];
                }
                else {
                    index++;
                    node = walker.nextNode();
                }
            }
        }
        if (this.template.svg) {
            const svgElement = fragment.firstChild;
            fragment.removeChild(svgElement);
            const nodes = svgElement.childNodes;
            for (let i = 0; i < nodes.length; i++) {
                fragment.appendChild(nodes.item(i));
            }
        }
        return fragment;
    }
}
/* unused harmony export TemplateInstance */

//# sourceMappingURL=lit-html.js.map

/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      /* Material Design color palette for Google products */

      --google-red-100: #f4c7c3;
      --google-red-300: #e67c73;
      --google-red-500: #db4437;
      --google-red-700: #c53929;

      --google-blue-100: #c6dafc;
      --google-blue-300: #7baaf7;
      --google-blue-500: #4285f4;
      --google-blue-700: #3367d6;

      --google-green-100: #b7e1cd;
      --google-green-300: #57bb8a;
      --google-green-500: #0f9d58;
      --google-green-700: #0b8043;

      --google-yellow-100: #fce8b2;
      --google-yellow-300: #f7cb4d;
      --google-yellow-500: #f4b400;
      --google-yellow-700: #f09300;

      --google-grey-100: #f5f5f5;
      --google-grey-300: #e0e0e0;
      --google-grey-500: #9e9e9e;
      --google-grey-700: #616161;

      /* Material Design color palette from online spec document */

      --paper-red-50: #ffebee;
      --paper-red-100: #ffcdd2;
      --paper-red-200: #ef9a9a;
      --paper-red-300: #e57373;
      --paper-red-400: #ef5350;
      --paper-red-500: #f44336;
      --paper-red-600: #e53935;
      --paper-red-700: #d32f2f;
      --paper-red-800: #c62828;
      --paper-red-900: #b71c1c;
      --paper-red-a100: #ff8a80;
      --paper-red-a200: #ff5252;
      --paper-red-a400: #ff1744;
      --paper-red-a700: #d50000;

      --paper-pink-50: #fce4ec;
      --paper-pink-100: #f8bbd0;
      --paper-pink-200: #f48fb1;
      --paper-pink-300: #f06292;
      --paper-pink-400: #ec407a;
      --paper-pink-500: #e91e63;
      --paper-pink-600: #d81b60;
      --paper-pink-700: #c2185b;
      --paper-pink-800: #ad1457;
      --paper-pink-900: #880e4f;
      --paper-pink-a100: #ff80ab;
      --paper-pink-a200: #ff4081;
      --paper-pink-a400: #f50057;
      --paper-pink-a700: #c51162;

      --paper-purple-50: #f3e5f5;
      --paper-purple-100: #e1bee7;
      --paper-purple-200: #ce93d8;
      --paper-purple-300: #ba68c8;
      --paper-purple-400: #ab47bc;
      --paper-purple-500: #9c27b0;
      --paper-purple-600: #8e24aa;
      --paper-purple-700: #7b1fa2;
      --paper-purple-800: #6a1b9a;
      --paper-purple-900: #4a148c;
      --paper-purple-a100: #ea80fc;
      --paper-purple-a200: #e040fb;
      --paper-purple-a400: #d500f9;
      --paper-purple-a700: #aa00ff;

      --paper-deep-purple-50: #ede7f6;
      --paper-deep-purple-100: #d1c4e9;
      --paper-deep-purple-200: #b39ddb;
      --paper-deep-purple-300: #9575cd;
      --paper-deep-purple-400: #7e57c2;
      --paper-deep-purple-500: #673ab7;
      --paper-deep-purple-600: #5e35b1;
      --paper-deep-purple-700: #512da8;
      --paper-deep-purple-800: #4527a0;
      --paper-deep-purple-900: #311b92;
      --paper-deep-purple-a100: #b388ff;
      --paper-deep-purple-a200: #7c4dff;
      --paper-deep-purple-a400: #651fff;
      --paper-deep-purple-a700: #6200ea;

      --paper-indigo-50: #e8eaf6;
      --paper-indigo-100: #c5cae9;
      --paper-indigo-200: #9fa8da;
      --paper-indigo-300: #7986cb;
      --paper-indigo-400: #5c6bc0;
      --paper-indigo-500: #3f51b5;
      --paper-indigo-600: #3949ab;
      --paper-indigo-700: #303f9f;
      --paper-indigo-800: #283593;
      --paper-indigo-900: #1a237e;
      --paper-indigo-a100: #8c9eff;
      --paper-indigo-a200: #536dfe;
      --paper-indigo-a400: #3d5afe;
      --paper-indigo-a700: #304ffe;

      --paper-blue-50: #e3f2fd;
      --paper-blue-100: #bbdefb;
      --paper-blue-200: #90caf9;
      --paper-blue-300: #64b5f6;
      --paper-blue-400: #42a5f5;
      --paper-blue-500: #2196f3;
      --paper-blue-600: #1e88e5;
      --paper-blue-700: #1976d2;
      --paper-blue-800: #1565c0;
      --paper-blue-900: #0d47a1;
      --paper-blue-a100: #82b1ff;
      --paper-blue-a200: #448aff;
      --paper-blue-a400: #2979ff;
      --paper-blue-a700: #2962ff;

      --paper-light-blue-50: #e1f5fe;
      --paper-light-blue-100: #b3e5fc;
      --paper-light-blue-200: #81d4fa;
      --paper-light-blue-300: #4fc3f7;
      --paper-light-blue-400: #29b6f6;
      --paper-light-blue-500: #03a9f4;
      --paper-light-blue-600: #039be5;
      --paper-light-blue-700: #0288d1;
      --paper-light-blue-800: #0277bd;
      --paper-light-blue-900: #01579b;
      --paper-light-blue-a100: #80d8ff;
      --paper-light-blue-a200: #40c4ff;
      --paper-light-blue-a400: #00b0ff;
      --paper-light-blue-a700: #0091ea;

      --paper-cyan-50: #e0f7fa;
      --paper-cyan-100: #b2ebf2;
      --paper-cyan-200: #80deea;
      --paper-cyan-300: #4dd0e1;
      --paper-cyan-400: #26c6da;
      --paper-cyan-500: #00bcd4;
      --paper-cyan-600: #00acc1;
      --paper-cyan-700: #0097a7;
      --paper-cyan-800: #00838f;
      --paper-cyan-900: #006064;
      --paper-cyan-a100: #84ffff;
      --paper-cyan-a200: #18ffff;
      --paper-cyan-a400: #00e5ff;
      --paper-cyan-a700: #00b8d4;

      --paper-teal-50: #e0f2f1;
      --paper-teal-100: #b2dfdb;
      --paper-teal-200: #80cbc4;
      --paper-teal-300: #4db6ac;
      --paper-teal-400: #26a69a;
      --paper-teal-500: #009688;
      --paper-teal-600: #00897b;
      --paper-teal-700: #00796b;
      --paper-teal-800: #00695c;
      --paper-teal-900: #004d40;
      --paper-teal-a100: #a7ffeb;
      --paper-teal-a200: #64ffda;
      --paper-teal-a400: #1de9b6;
      --paper-teal-a700: #00bfa5;

      --paper-green-50: #e8f5e9;
      --paper-green-100: #c8e6c9;
      --paper-green-200: #a5d6a7;
      --paper-green-300: #81c784;
      --paper-green-400: #66bb6a;
      --paper-green-500: #4caf50;
      --paper-green-600: #43a047;
      --paper-green-700: #388e3c;
      --paper-green-800: #2e7d32;
      --paper-green-900: #1b5e20;
      --paper-green-a100: #b9f6ca;
      --paper-green-a200: #69f0ae;
      --paper-green-a400: #00e676;
      --paper-green-a700: #00c853;

      --paper-light-green-50: #f1f8e9;
      --paper-light-green-100: #dcedc8;
      --paper-light-green-200: #c5e1a5;
      --paper-light-green-300: #aed581;
      --paper-light-green-400: #9ccc65;
      --paper-light-green-500: #8bc34a;
      --paper-light-green-600: #7cb342;
      --paper-light-green-700: #689f38;
      --paper-light-green-800: #558b2f;
      --paper-light-green-900: #33691e;
      --paper-light-green-a100: #ccff90;
      --paper-light-green-a200: #b2ff59;
      --paper-light-green-a400: #76ff03;
      --paper-light-green-a700: #64dd17;

      --paper-lime-50: #f9fbe7;
      --paper-lime-100: #f0f4c3;
      --paper-lime-200: #e6ee9c;
      --paper-lime-300: #dce775;
      --paper-lime-400: #d4e157;
      --paper-lime-500: #cddc39;
      --paper-lime-600: #c0ca33;
      --paper-lime-700: #afb42b;
      --paper-lime-800: #9e9d24;
      --paper-lime-900: #827717;
      --paper-lime-a100: #f4ff81;
      --paper-lime-a200: #eeff41;
      --paper-lime-a400: #c6ff00;
      --paper-lime-a700: #aeea00;

      --paper-yellow-50: #fffde7;
      --paper-yellow-100: #fff9c4;
      --paper-yellow-200: #fff59d;
      --paper-yellow-300: #fff176;
      --paper-yellow-400: #ffee58;
      --paper-yellow-500: #ffeb3b;
      --paper-yellow-600: #fdd835;
      --paper-yellow-700: #fbc02d;
      --paper-yellow-800: #f9a825;
      --paper-yellow-900: #f57f17;
      --paper-yellow-a100: #ffff8d;
      --paper-yellow-a200: #ffff00;
      --paper-yellow-a400: #ffea00;
      --paper-yellow-a700: #ffd600;

      --paper-amber-50: #fff8e1;
      --paper-amber-100: #ffecb3;
      --paper-amber-200: #ffe082;
      --paper-amber-300: #ffd54f;
      --paper-amber-400: #ffca28;
      --paper-amber-500: #ffc107;
      --paper-amber-600: #ffb300;
      --paper-amber-700: #ffa000;
      --paper-amber-800: #ff8f00;
      --paper-amber-900: #ff6f00;
      --paper-amber-a100: #ffe57f;
      --paper-amber-a200: #ffd740;
      --paper-amber-a400: #ffc400;
      --paper-amber-a700: #ffab00;

      --paper-orange-50: #fff3e0;
      --paper-orange-100: #ffe0b2;
      --paper-orange-200: #ffcc80;
      --paper-orange-300: #ffb74d;
      --paper-orange-400: #ffa726;
      --paper-orange-500: #ff9800;
      --paper-orange-600: #fb8c00;
      --paper-orange-700: #f57c00;
      --paper-orange-800: #ef6c00;
      --paper-orange-900: #e65100;
      --paper-orange-a100: #ffd180;
      --paper-orange-a200: #ffab40;
      --paper-orange-a400: #ff9100;
      --paper-orange-a700: #ff6500;

      --paper-deep-orange-50: #fbe9e7;
      --paper-deep-orange-100: #ffccbc;
      --paper-deep-orange-200: #ffab91;
      --paper-deep-orange-300: #ff8a65;
      --paper-deep-orange-400: #ff7043;
      --paper-deep-orange-500: #ff5722;
      --paper-deep-orange-600: #f4511e;
      --paper-deep-orange-700: #e64a19;
      --paper-deep-orange-800: #d84315;
      --paper-deep-orange-900: #bf360c;
      --paper-deep-orange-a100: #ff9e80;
      --paper-deep-orange-a200: #ff6e40;
      --paper-deep-orange-a400: #ff3d00;
      --paper-deep-orange-a700: #dd2c00;

      --paper-brown-50: #efebe9;
      --paper-brown-100: #d7ccc8;
      --paper-brown-200: #bcaaa4;
      --paper-brown-300: #a1887f;
      --paper-brown-400: #8d6e63;
      --paper-brown-500: #795548;
      --paper-brown-600: #6d4c41;
      --paper-brown-700: #5d4037;
      --paper-brown-800: #4e342e;
      --paper-brown-900: #3e2723;

      --paper-grey-50: #fafafa;
      --paper-grey-100: #f5f5f5;
      --paper-grey-200: #eeeeee;
      --paper-grey-300: #e0e0e0;
      --paper-grey-400: #bdbdbd;
      --paper-grey-500: #9e9e9e;
      --paper-grey-600: #757575;
      --paper-grey-700: #616161;
      --paper-grey-800: #424242;
      --paper-grey-900: #212121;

      --paper-blue-grey-50: #eceff1;
      --paper-blue-grey-100: #cfd8dc;
      --paper-blue-grey-200: #b0bec5;
      --paper-blue-grey-300: #90a4ae;
      --paper-blue-grey-400: #78909c;
      --paper-blue-grey-500: #607d8b;
      --paper-blue-grey-600: #546e7a;
      --paper-blue-grey-700: #455a64;
      --paper-blue-grey-800: #37474f;
      --paper-blue-grey-900: #263238;

      /* opacity for dark text on a light background */
      --dark-divider-opacity: 0.12;
      --dark-disabled-opacity: 0.38; /* or hint text or icon */
      --dark-secondary-opacity: 0.54;
      --dark-primary-opacity: 0.87;

      /* opacity for light text on a dark background */
      --light-divider-opacity: 0.12;
      --light-disabled-opacity: 0.3; /* or hint text or icon */
      --light-secondary-opacity: 0.7;
      --light-primary-opacity: 1.0;

    }

  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      --shadow-transition: {
        transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
      };

      --shadow-none: {
        box-shadow: none;
      };

      /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */

      --shadow-elevation-2dp: {
        box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                    0 1px 5px 0 rgba(0, 0, 0, 0.12),
                    0 3px 1px -2px rgba(0, 0, 0, 0.2);
      };

      --shadow-elevation-3dp: {
        box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14),
                    0 1px 8px 0 rgba(0, 0, 0, 0.12),
                    0 3px 3px -2px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-4dp: {
        box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                    0 1px 10px 0 rgba(0, 0, 0, 0.12),
                    0 2px 4px -1px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-6dp: {
        box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                    0 1px 18px 0 rgba(0, 0, 0, 0.12),
                    0 3px 5px -1px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-8dp: {
        box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
                    0 3px 14px 2px rgba(0, 0, 0, 0.12),
                    0 5px 5px -3px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-12dp: {
        box-shadow: 0 12px 16px 1px rgba(0, 0, 0, 0.14),
                    0 4px 22px 3px rgba(0, 0, 0, 0.12),
                    0 6px 7px -4px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-16dp: {
        box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14),
                    0  6px 30px 5px rgba(0, 0, 0, 0.12),
                    0  8px 10px -5px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-24dp: {
        box-shadow: 0 24px 38px 3px rgba(0, 0, 0, 0.14),
                    0 9px 46px 8px rgba(0, 0, 0, 0.12),
                    0 11px 15px -7px rgba(0, 0, 0, 0.4);
      };
    }
  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__ = __webpack_require__(5);



const IronFormElementBehavior = {

  properties: {
    /**
     * Fired when the element is added to an `iron-form`.
     *
     * @event iron-form-element-register
     */

    /**
     * Fired when the element is removed from an `iron-form`.
     *
     * @event iron-form-element-unregister
     */
     
    /**
     * The name of this element.
     */
    name: {
      type: String
    },

    /**
     * The value for this element.
     */
    value: {
      notify: true,
      type: String
    },

    /**
     * Set to true to mark the input as required. If used in a form, a
     * custom element that uses this behavior should also use
     * Polymer.IronValidatableBehavior and define a custom validation method.
     * Otherwise, a `required` element will always be considered valid.
     * It's also strongly recommended to provide a visual style for the element
     * when its value is invalid.
     */
    required: {
      type: Boolean,
      value: false
    },

    /**
     * The form that the element is registered to.
     */
    _parentForm: {
      type: Object
    }
  },

  attached: __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */] ? null : function() {
    // Note: the iron-form that this element belongs to will set this
    // element's _parentForm property when handling this event.
    this.fire('iron-form-element-register');
  },

  detached: __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */] ? null : function() {
    if (this._parentForm) {
      this._parentForm.fire('iron-form-element-unregister', {target: this});
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronFormElementBehavior;



/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export IronValidatableBehaviorMeta */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_meta_iron_meta_js__ = __webpack_require__(89);


let IronValidatableBehaviorMeta = null;

const IronValidatableBehavior = {

  properties: {
    /**
     * Name of the validator to use.
     */
    validator: {
      type: String
    },

    /**
     * True if the last call to `validate` is invalid.
     */
    invalid: {
      notify: true,
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_invalidChanged'
    },
  },

  registered: function() {
    IronValidatableBehaviorMeta = new __WEBPACK_IMPORTED_MODULE_1__iron_meta_iron_meta_js__["a" /* IronMeta */]({type: 'validator'});
  },

  _invalidChanged: function() {
    if (this.invalid) {
      this.setAttribute('aria-invalid', 'true');
    } else {
      this.removeAttribute('aria-invalid');
    }
  },

  /* Recompute this every time it's needed, because we don't know if the
   * underlying IronValidatableBehaviorMeta has changed. */
  get _validator() {
    return IronValidatableBehaviorMeta &&
        IronValidatableBehaviorMeta.byKey(this.validator);
  },

  /**
   * @return {boolean} True if the validator `validator` exists.
   */
  hasValidator: function() {
    return this._validator != null;
  },

  /**
   * Returns true if the `value` is valid, and updates `invalid`. If you want
   * your element to have custom validation logic, do not override this method;
   * override `_getValidity(value)` instead.

   * @param {Object} value Deprecated: The value to be validated. By default,
   * it is passed to the validator's `validate()` function, if a validator is set.
   * If this argument is not specified, then the element's `value` property
   * is used, if it exists.
   * @return {boolean} True if `value` is valid.
   */
  validate: function(value) {
    // If this is an element that also has a value property, and there was
    // no explicit value argument passed, use the element's property instead.
    if (value === undefined && this.value !== undefined)
      this.invalid = !this._getValidity(this.value);
    else
      this.invalid = !this._getValidity(value);
    return !this.invalid;
  },

  /**
   * Returns true if `value` is valid.  By default, it is passed
   * to the validator's `validate()` function, if a validator is set. You
   * should override this method if you want to implement custom validity
   * logic for your element.
   *
   * @param {Object} value The value to be validated.
   * @return {boolean} True if `value` is valid.
   */

  _getValidity: function(value) {
    if (this.hasValidator()) {
      return this._validator.validate(value);
    }
    return true;
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronValidatableBehavior;



/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);



const PaperInputAddonBehavior = {
  attached: function() {
    // Workaround for https://github.com/webcomponents/shadydom/issues/96
    Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["b" /* flush */])();
    this.fire('addon-attached');
  },

  /**
   * The function called by `<paper-input-container>` when the input value or validity changes.
   * @param {{
   *   inputElement: (Element|undefined),
   *   value: (string|undefined),
   *   invalid: boolean
   * }} state -
   *     inputElement: The input element.
   *     value: The input value.
   *     invalid: True if the input value is invalid.
   */
  update: function(state) {
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperInputAddonBehavior;



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_checked_element_behavior_iron_checked_element_behavior_js__ = __webpack_require__(95);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_inky_focus_behavior_js__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_ripple_behavior_js__ = __webpack_require__(19);





const PaperCheckedElementBehaviorImpl = {
  /**
   * Synchronizes the element's checked state with its ripple effect.
   */
  _checkedChanged: function() {
    __WEBPACK_IMPORTED_MODULE_1__iron_checked_element_behavior_iron_checked_element_behavior_js__["b" /* IronCheckedElementBehaviorImpl */]._checkedChanged.call(this);
    if (this.hasRipple()) {
      if (this.checked) {
        this._ripple.setAttribute('checked', '');
      } else {
        this._ripple.removeAttribute('checked');
      }
    }
  },

  /**
   * Synchronizes the element's `active` and `checked` state.
   */
  _buttonStateChanged: function() {
    __WEBPACK_IMPORTED_MODULE_3__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */]._buttonStateChanged.call(this);
    if (this.disabled) {
      return;
    }
    if (this.isAttached) {
      this.checked = this.active;
    }
  }
};
/* unused harmony export PaperCheckedElementBehaviorImpl */


const PaperCheckedElementBehavior = [
  __WEBPACK_IMPORTED_MODULE_2__paper_inky_focus_behavior_js__["a" /* PaperInkyFocusBehavior */],
  __WEBPACK_IMPORTED_MODULE_1__iron_checked_element_behavior_iron_checked_element_behavior_js__["a" /* IronCheckedElementBehavior */],
  PaperCheckedElementBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperCheckedElementBehavior;



/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__ = __webpack_require__(18);





const PaperInkyFocusBehaviorImpl = {
  observers: [
    '_focusedChanged(receivedFocusFromKeyboard)'
  ],

  _focusedChanged: function(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function() {
    var ripple = __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */]._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};
/* harmony export (immutable) */ __webpack_exports__["b"] = PaperInkyFocusBehaviorImpl;


const PaperInkyFocusBehavior = [
  __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["a" /* IronButtonState */],
  __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__["a" /* IronControlState */],
  __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */],
  PaperInkyFocusBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperInkyFocusBehavior;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_paper_toggle_button_paper_toggle_button__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lit_html__ = __webpack_require__(42);



class TactileMode extends __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__["a" /* Element */] {
  static get is() {
    return "tactile-mode";
  }

  static get template() {
    return "<paper-toggle-button>Edit</paper-toggle-button>";
  }

  connectedCallback() {
    super.connectedCallback();
    var toggle = this.shadowRoot.querySelector("paper-toggle-button");
  }

  setToEdit() {
    var toggle = this.shadowRoot.querySelector("paper-toggle-button");
    toggle.checked = true;
  }

  setToPublish() {
    var toggle = this.shadowRoot.querySelector("paper-toggle-button");
    toggle.checked = true;
  }

  switchedToEdit(callback) {
    var toggle = this.shadowRoot.querySelector("paper-toggle-button");
    toggle.addEventListener("iron-change", () => {
      if (toggle.checked) {
        callback();
      }
    });
  }

  switchedToPublish(callback) {
    var toggle = this.shadowRoot.querySelector("paper-toggle-button");
    toggle.addEventListener("iron-change", () => {
      if (!toggle.checked) {
        callback();
      }
    });
  }

}
/* harmony export (immutable) */ __webpack_exports__["default"] = TactileMode;
 // Register custom element class with browser

customElements.define(TactileMode.is, TactileMode);

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31);
__webpack_require__(52);
__webpack_require__(41);
__webpack_require__(50);
module.exports = __webpack_require__(97);


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_paper_ripple_paper_ripple__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tactile_editable_js__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__tactile_mode_js__ = __webpack_require__(50);




function watchForComponentClicks(event) {
  // This stops user from interacting with page in author mode
  event.stopPropagation();
  event.preventDefault();
  var component = event.target.closest("tactile-editable");

  if (component) {
    component.openDialog(watchForComponentClicks);
    document.removeEventListener("click", watchForComponentClicks);
  }
}

;

function watchForComponentClicks(event) {
  // This stops user from interacting with page in author mode
  event.stopPropagation();
  event.preventDefault();
  var tactileEditable = event.target.closest("tactile-editable");

  if (tactileEditable) {
    document.removeEventListener("click", watchForComponentClicks);
    tactileEditable.openDialog(function (requiresRefresh = true) {
      document.addEventListener("click", watchForComponentClicks); // TODO just reload the component, not the entire page.

      if (requiresRefresh) {
        window.location.reload();
      }
    });
  }
}

;

function setupEditMode() {
  document.addEventListener("click", watchForComponentClicks);
  document.body.classList.add("edit");
  window.sessionStorage.setItem("tactile-mode", "edit");
}

function setupPublishMode() {
  document.removeEventListener("click", watchForComponentClicks);
  document.body.classList.remove("edit");
  window.sessionStorage.setItem("tactile-mode", "publish");
}

document.addEventListener("DOMContentLoaded", event => {
  if (document.body.classList.contains('edit')) {
    var tactileModeToggle = document.querySelector("tactile-mode");
    tactileModeToggle.switchedToEdit(setupEditMode);
    tactileModeToggle.switchedToPublish(setupPublishMode);
    var mode = window.sessionStorage.getItem("tactile-mode");

    if (mode === "edit") {
      tactileModeToggle.setToEdit();
    } else {
      setupPublishMode();
    }
  }
});

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_apply_shim_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_template_map_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_style_util_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_document_wait_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_common_utils_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_custom_style_interface_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_style_settings_js__ = __webpack_require__(20);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/









 // eslint-disable-line no-unused-vars


/** @const {ApplyShim} */
const applyShim = new __WEBPACK_IMPORTED_MODULE_0__src_apply_shim_js__["a" /* default */]();

class ApplyShimInterface {
  constructor() {
    /** @type {?CustomStyleInterfaceInterface} */
    this.customStyleInterface = null;
    Object(__WEBPACK_IMPORTED_MODULE_4__src_document_wait_js__["a" /* default */])(() => {
      this.ensure();
    });
    applyShim['invalidCallback'] = __WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["a" /* invalidate */];
  }
  ensure() {
    if (this.customStyleInterface) {
      return;
    }
    this.customStyleInterface = window.ShadyCSS.CustomStyleInterface;
    if (this.customStyleInterface) {
      this.customStyleInterface['transformCallback'] = (style) => {
        applyShim.transformCustomStyle(style);
      };
      this.customStyleInterface['validateCallback'] = () => {
        requestAnimationFrame(() => {
          if (this.customStyleInterface['enqueued']) {
            this.flushCustomStyles();
          }
        });
      }
    }
  }
  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   */
  prepareTemplate(template, elementName) {
    this.ensure();
    __WEBPACK_IMPORTED_MODULE_1__src_template_map_js__["a" /* default */][elementName] = template;
    let ast = applyShim.transformTemplate(template, elementName);
    // save original style ast to use for revalidating instances
    template['_styleAst'] = ast;
  }
  flushCustomStyles() {
    this.ensure();
    if (!this.customStyleInterface) {
      return;
    }
    let styles = this.customStyleInterface['processStyles']();
    if (!this.customStyleInterface['enqueued']) {
      return;
    }
    for (let i = 0; i < styles.length; i++ ) {
      let cs = styles[i];
      let style = this.customStyleInterface['getStyleForCustomStyle'](cs);
      if (style) {
        applyShim.transformCustomStyle(style);
      }
    }
    this.customStyleInterface['enqueued'] = false;
  }
  /**
   * @param {HTMLElement} element
   * @param {Object=} properties
   */
  styleSubtree(element, properties) {
    this.ensure();
    if (properties) {
      Object(__WEBPACK_IMPORTED_MODULE_5__src_common_utils_js__["c" /* updateNativeProperties */])(element, properties);
    }
    if (element.shadowRoot) {
      this.styleElement(element);
      let shadowChildren = element.shadowRoot.children || element.shadowRoot.childNodes;
      for (let i = 0; i < shadowChildren.length; i++) {
        this.styleSubtree(/** @type {HTMLElement} */(shadowChildren[i]));
      }
    } else {
      let children = element.children || element.childNodes;
      for (let i = 0; i < children.length; i++) {
        this.styleSubtree(/** @type {HTMLElement} */(children[i]));
      }
    }
  }
  /**
   * @param {HTMLElement} element
   */
  styleElement(element) {
    this.ensure();
    let {is} = Object(__WEBPACK_IMPORTED_MODULE_2__src_style_util_js__["c" /* getIsExtends */])(element);
    let template = __WEBPACK_IMPORTED_MODULE_1__src_template_map_js__["a" /* default */][is];
    if (template && !__WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["c" /* templateIsValid */](template)) {
      // only revalidate template once
      if (!__WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["d" /* templateIsValidating */](template)) {
        this.prepareTemplate(template, is);
        __WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["b" /* startValidatingTemplate */](template);
      }
      // update this element instance
      let root = element.shadowRoot;
      if (root) {
        let style = /** @type {HTMLStyleElement} */(root.querySelector('style'));
        if (style) {
          // reuse the template's style ast, it has all the original css text
          style['__cssRules'] = template['_styleAst'];
          style.textContent = Object(__WEBPACK_IMPORTED_MODULE_2__src_style_util_js__["f" /* toCssText */])(template['_styleAst'])
        }
      }
    }
  }
  /**
   * @param {Object=} properties
   */
  styleDocument(properties) {
    this.ensure();
    this.styleSubtree(document.body, properties);
  }
}

if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
  const applyShimInterface = new ApplyShimInterface();
  let CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;

  window.ShadyCSS = {
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate(template, elementName, elementExtends) { // eslint-disable-line no-unused-vars
      applyShimInterface.flushCustomStyles();
      applyShimInterface.prepareTemplate(template, elementName)
    },

    /**
     * @param {!HTMLElement} element
     * @param {Object=} properties
     */
    styleSubtree(element, properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleSubtree(element, properties);
    },

    /**
     * @param {!HTMLElement} element
     */
    styleElement(element) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleElement(element);
    },

    /**
     * @param {Object=} properties
     */
    styleDocument(properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleDocument(properties);
    },

    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue(element, property) {
      return Object(__WEBPACK_IMPORTED_MODULE_5__src_common_utils_js__["b" /* getComputedStyleValue */])(element, property);
    },
    nativeCss: __WEBPACK_IMPORTED_MODULE_7__src_style_settings_js__["a" /* nativeCssVariables */],
    nativeShadow: __WEBPACK_IMPORTED_MODULE_7__src_style_settings_js__["b" /* nativeShadow */]
  };

  if (CustomStyleInterface) {
    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
  }
}

window.ShadyCSS.ApplyShim = applyShim;

/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_util_js__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_regex_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_utils_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__css_parse_js__ = __webpack_require__(21);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/*
 * The apply shim simulates the behavior of `@apply` proposed at
 * https://tabatkins.github.io/specs/css-apply-rule/.
 * The approach is to convert a property like this:
 *
 *    --foo: {color: red; background: blue;}
 *
 * to this:
 *
 *    --foo_-_color: red;
 *    --foo_-_background: blue;
 *
 * Then where `@apply --foo` is used, that is converted to:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background);
 *
 * This approach generally works but there are some issues and limitations.
 * Consider, for example, that somewhere *between* where `--foo` is set and used,
 * another element sets it to:
 *
 *    --foo: { border: 2px solid red; }
 *
 * We must now ensure that the color and background from the previous setting
 * do not apply. This is accomplished by changing the property set to this:
 *
 *    --foo_-_border: 2px solid red;
 *    --foo_-_color: initial;
 *    --foo_-_background: initial;
 *
 * This works but introduces one new issue.
 * Consider this setup at the point where the `@apply` is used:
 *
 *    background: orange;
 *    `@apply` --foo;
 *
 * In this case the background will be unset (initial) rather than the desired
 * `orange`. We address this by altering the property set to use a fallback
 * value like this:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background, orange);
 *    border: var(--foo_-_border);
 *
 * Note that the default is retained in the property set and the `background` is
 * the desired `orange`. This leads us to a limitation.
 *
 * Limitation 1:

 * Only properties in the rule where the `@apply`
 * is used are considered as default values.
 * If another rule matches the element and sets `background` with
 * less specificity than the rule in which `@apply` appears,
 * the `background` will not be set.
 *
 * Limitation 2:
 *
 * When using Polymer's `updateStyles` api, new properties may not be set for
 * `@apply` properties.

*/






 // eslint-disable-line no-unused-vars

const APPLY_NAME_CLEAN = /;\s*/m;
const INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;

// separator used between mixin-name and mixin-property-name when producing properties
// NOTE: plain '-' may cause collisions in user styles
const MIXIN_VAR_SEP = '_-_';

/**
 * @typedef {!Object<string, string>}
 */
let PropertyEntry; // eslint-disable-line no-unused-vars

/**
 * @typedef {!Object<string, boolean>}
 */
let DependantsEntry; // eslint-disable-line no-unused-vars

/** @typedef {{
 *    properties: PropertyEntry,
 *    dependants: DependantsEntry
 * }}
 */
let MixinMapEntry; // eslint-disable-line no-unused-vars

// map of mixin to property names
// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}
class MixinMap {
  constructor() {
    /** @type {!Object<string, !MixinMapEntry>} */
    this._map = {};
  }
  /**
   * @param {string} name
   * @param {!PropertyEntry} props
   */
  set(name, props) {
    name = name.trim();
    this._map[name] = {
      properties: props,
      dependants: {}
    }
  }
  /**
   * @param {string} name
   * @return {MixinMapEntry}
   */
  get(name) {
    name = name.trim();
    return this._map[name] || null;
  }
}

/**
 * Callback for when an element is marked invalid
 * @type {?function(string)}
 */
let invalidCallback = null;

/** @unrestricted */
class ApplyShim {
  constructor() {
    /** @type {?string} */
    this._currentElement = null;
    /** @type {HTMLMetaElement} */
    this._measureElement = null;
    this._map = new MixinMap();
  }
  /**
   * return true if `cssText` contains a mixin definition or consumption
   * @param {string} cssText
   * @return {boolean}
   */
  detectMixin(cssText) {
    return Object(__WEBPACK_IMPORTED_MODULE_2__common_utils_js__["a" /* detectMixin */])(cssText);
  }

  /**
   * Gather styles into one style for easier processing
   * @param {!HTMLTemplateElement} template
   * @return {HTMLStyleElement}
   */
  gatherStyles(template) {
    const styleText = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["b" /* gatherStyleText */])(template.content);
    if (styleText) {
      const style = /** @type {!HTMLStyleElement} */(document.createElement('style'));
      style.textContent = styleText;
      template.content.insertBefore(style, template.content.firstChild);
      return style;
    }
    return null;
  }
  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @return {StyleNode}
   */
  transformTemplate(template, elementName) {
    if (template._gatheredStyle === undefined) {
      template._gatheredStyle = this.gatherStyles(template);
    }
    /** @type {HTMLStyleElement} */
    const style = template._gatheredStyle;
    return style ? this.transformStyle(style, elementName) : null;
  }
  /**
   * @param {!HTMLStyleElement} style
   * @param {string} elementName
   * @return {StyleNode}
   */
  transformStyle(style, elementName = '') {
    let ast = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["e" /* rulesForStyle */])(style);
    this.transformRules(ast, elementName);
    style.textContent = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["f" /* toCssText */])(ast);
    return ast;
  }
  /**
   * @param {!HTMLStyleElement} style
   * @return {StyleNode}
   */
  transformCustomStyle(style) {
    let ast = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["e" /* rulesForStyle */])(style);
    Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["a" /* forEachRule */])(ast, (rule) => {
      if (rule['selector'] === ':root') {
        rule['selector'] = 'html';
      }
      this.transformRule(rule);
    })
    style.textContent = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["f" /* toCssText */])(ast);
    return ast;
  }
  /**
   * @param {StyleNode} rules
   * @param {string} elementName
   */
  transformRules(rules, elementName) {
    this._currentElement = elementName;
    Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["a" /* forEachRule */])(rules, (r) => {
      this.transformRule(r);
    });
    this._currentElement = null;
  }
  /**
   * @param {!StyleNode} rule
   */
  transformRule(rule) {
    rule['cssText'] = this.transformCssText(rule['parsedCssText']);
    // :root was only used for variable assignment in property shim,
    // but generates invalid selectors with real properties.
    // replace with `:host > *`, which serves the same effect
    if (rule['selector'] === ':root') {
      rule['selector'] = ':host > *';
    }
  }
  /**
   * @param {string} cssText
   * @return {string}
   */
  transformCssText(cssText) {
    // produce variables
    cssText = cssText.replace(__WEBPACK_IMPORTED_MODULE_1__common_regex_js__["c" /* VAR_ASSIGN */], (matchText, propertyName, valueProperty, valueMixin) =>
      this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin));
    // consume mixins
    return this._consumeCssProperties(cssText);
  }
  /**
   * @param {string} property
   * @return {string}
   */
  _getInitialValueForProperty(property) {
    if (!this._measureElement) {
      this._measureElement = /** @type {HTMLMetaElement} */(document.createElement('meta'));
      this._measureElement.setAttribute('apply-shim-measure', '');
      this._measureElement.style.all = 'initial';
      document.head.appendChild(this._measureElement);
    }
    return window.getComputedStyle(this._measureElement).getPropertyValue(property);
  }
  /**
   * replace mixin consumption with variable consumption
   * @param {string} text
   * @return {string}
   */
  _consumeCssProperties(text) {
    /** @type {Array} */
    let m = null;
    // loop over text until all mixins with defintions have been applied
    while((m = __WEBPACK_IMPORTED_MODULE_1__common_regex_js__["b" /* MIXIN_MATCH */].exec(text))) {
      let matchText = m[0];
      let mixinName = m[1];
      let idx = m.index;
      // collect properties before apply to be "defaults" if mixin might override them
      // match includes a "prefix", so find the start and end positions of @apply
      let applyPos = idx + matchText.indexOf('@apply');
      let afterApplyPos = idx + matchText.length;
      // find props defined before this @apply
      let textBeforeApply = text.slice(0, applyPos);
      let textAfterApply = text.slice(afterApplyPos);
      let defaults = this._cssTextToMap(textBeforeApply);
      let replacement = this._atApplyToCssProperties(mixinName, defaults);
      // use regex match position to replace mixin, keep linear processing time
      text = `${textBeforeApply}${replacement}${textAfterApply}`;
      // move regex search to _after_ replacement
      __WEBPACK_IMPORTED_MODULE_1__common_regex_js__["b" /* MIXIN_MATCH */].lastIndex = idx + replacement.length;
    }
    return text;
  }
  /**
   * produce variable consumption at the site of mixin consumption
   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))
   * Example:
   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)
   *
   * @param {string} mixinName
   * @param {Object} fallbacks
   * @return {string}
   */
  _atApplyToCssProperties(mixinName, fallbacks) {
    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
    let vars = [];
    let mixinEntry = this._map.get(mixinName);
    // if we depend on a mixin before it is created
    // make a sentinel entry in the map to add this element as a dependency for when it is defined.
    if (!mixinEntry) {
      this._map.set(mixinName, {});
      mixinEntry = this._map.get(mixinName);
    }
    if (mixinEntry) {
      if (this._currentElement) {
        mixinEntry.dependants[this._currentElement] = true;
      }
      let p, parts, f;
      for (p in mixinEntry.properties) {
        f = fallbacks && fallbacks[p];
        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
        if (f) {
          parts.push(',', f);
        }
        parts.push(')');
        vars.push(parts.join(''));
      }
    }
    return vars.join('; ');
  }

  /**
   * @param {string} property
   * @param {string} value
   * @return {string}
   */
  _replaceInitialOrInherit(property, value) {
    let match = INITIAL_INHERIT.exec(value);
    if (match) {
      if (match[1]) {
        // initial
        // replace `initial` with the concrete initial value for this property
        value = this._getInitialValueForProperty(property);
      } else {
        // inherit
        // with this purposfully illegal value, the variable will be invalid at
        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)
        // and for inheriting values, will behave similarly
        // we cannot support the same behavior for non inheriting values like 'border'
        value = 'apply-shim-inherit';
      }
    }
    return value;
  }

  /**
   * "parse" a mixin definition into a map of properties and values
   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')
   * @param {string} text
   * @return {!Object<string, string>}
   */
  _cssTextToMap(text) {
    let props = text.split(';');
    let property, value;
    let out = {};
    for (let i = 0, p, sp; i < props.length; i++) {
      p = props[i];
      if (p) {
        sp = p.split(':');
        // ignore lines that aren't definitions like @media
        if (sp.length > 1) {
          property = sp[0].trim();
          // some properties may have ':' in the value, like data urls
          value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));
          out[property] = value;
        }
      }
    }
    return out;
  }

  /**
   * @param {MixinMapEntry} mixinEntry
   */
  _invalidateMixinEntry(mixinEntry) {
    if (!invalidCallback) {
      return;
    }
    for (let elementName in mixinEntry.dependants) {
      if (elementName !== this._currentElement) {
        invalidCallback(elementName);
      }
    }
  }

  /**
   * @param {string} matchText
   * @param {string} propertyName
   * @param {?string} valueProperty
   * @param {?string} valueMixin
   * @return {string}
   */
  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
    // handle case where property value is a mixin
    if (valueProperty) {
      // form: --mixin2: var(--mixin1), where --mixin1 is in the map
      Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["d" /* processVariableAndFallback */])(valueProperty, (prefix, value) => {
        if (value && this._map.get(value)) {
          valueMixin = `@apply ${value};`
        }
      });
    }
    if (!valueMixin) {
      return matchText;
    }
    let mixinAsProperties = this._consumeCssProperties(valueMixin);
    let prefix = matchText.slice(0, matchText.indexOf('--'));
    let mixinValues = this._cssTextToMap(mixinAsProperties);
    let combinedProps = mixinValues;
    let mixinEntry = this._map.get(propertyName);
    let oldProps = mixinEntry && mixinEntry.properties;
    if (oldProps) {
      // NOTE: since we use mixin, the map of properties is updated here
      // and this is what we want.
      combinedProps = Object.assign(Object.create(oldProps), mixinValues);
    } else {
      this._map.set(propertyName, combinedProps);
    }
    let out = [];
    let p, v;
    // set variables defined by current mixin
    let needToInvalidate = false;
    for (p in combinedProps) {
      v = mixinValues[p];
      // if property not defined by current mixin, set initial
      if (v === undefined) {
        v = 'initial';
      }
      if (oldProps && !(p in oldProps)) {
        needToInvalidate = true;
      }
      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);
    }
    if (needToInvalidate) {
      this._invalidateMixinEntry(mixinEntry);
    }
    if (mixinEntry) {
      mixinEntry.properties = combinedProps;
    }
    // because the mixinMap is global, the mixin might conflict with
    // a different scope's simple variable definition:
    // Example:
    // some style somewhere:
    // --mixin1:{ ... }
    // --mixin2: var(--mixin1);
    // some other element:
    // --mixin1: 10px solid red;
    // --foo: var(--mixin1);
    // In this case, we leave the original variable definition in place.
    if (valueProperty) {
      prefix = `${matchText};${prefix}`;
    }
    return `${prefix}${out.join('; ')};`;
  }
}

/* exports */
ApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;
ApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;
ApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;
ApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;
Object.defineProperty(ApplyShim.prototype, 'invalidCallback', {
  /** @return {?function(string)} */
  get() {
    return invalidCallback;
  },
  /** @param {?function(string)} cb */
  set(cb) {
    invalidCallback = cb;
  }
});

/* harmony default export */ __webpack_exports__["a"] = (ApplyShim);

/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = processUnscopedStyle;
/* harmony export (immutable) */ __webpack_exports__["a"] = isUnscopedStyle;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/** @type {!Set<string>} */
const styleTextSet = new Set();

const scopingAttribute = 'shady-unscoped';
/* unused harmony export scopingAttribute */


/**
 * Add a specifically-marked style to the document directly, and only one copy of that style.
 *
 * @param {!HTMLStyleElement} style
 * @return {undefined}
 */
function processUnscopedStyle(style) {
  const text = style.textContent;
  if (!styleTextSet.has(text)) {
    styleTextSet.add(text);
    const newStyle = style.cloneNode(true);
    document.head.appendChild(newStyle);
  }
}

/**
 * Check if a style is supposed to be unscoped
 * @param {!HTMLStyleElement} style
 * @return {boolean} true if the style has the unscoping attribute
 */
function isUnscopedStyle(style) {
  return style.hasAttribute(scopingAttribute);
}

/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = invalidate;
/* unused harmony export invalidateTemplate */
/* unused harmony export isValid */
/* harmony export (immutable) */ __webpack_exports__["c"] = templateIsValid;
/* unused harmony export isValidating */
/* harmony export (immutable) */ __webpack_exports__["d"] = templateIsValidating;
/* unused harmony export startValidating */
/* harmony export (immutable) */ __webpack_exports__["b"] = startValidatingTemplate;
/* unused harmony export elementsAreInvalid */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__template_map_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_parse_js__ = __webpack_require__(21);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



 // eslint-disable-line no-unused-vars

/*
 * Utilities for handling invalidating apply-shim mixins for a given template.
 *
 * The invalidation strategy involves keeping track of the "current" version of a template's mixins, and updating that count when a mixin is invalidated.
 * The template
 */

/** @const {string} */
const CURRENT_VERSION = '_applyShimCurrentVersion';

/** @const {string} */
const NEXT_VERSION = '_applyShimNextVersion';

/** @const {string} */
const VALIDATING_VERSION = '_applyShimValidatingVersion';

/**
 * @const {Promise<void>}
 */
const promise = Promise.resolve();

/**
 * @param {string} elementName
 */
function invalidate(elementName){
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  if (template) {
    invalidateTemplate(template);
  }
}

/**
 * This function can be called multiple times to mark a template invalid
 * and signal that the style inside must be regenerated.
 *
 * Use `startValidatingTemplate` to begin an asynchronous validation cycle.
 * During that cycle, call `templateIsValidating` to see if the template must
 * be revalidated
 * @param {HTMLTemplateElement} template
 */
function invalidateTemplate(template) {
  // default the current version to 0
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
  // ensure the "validating for" flag exists
  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
  // increment the next version
  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValid(elementName) {
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  if (template) {
    return templateIsValid(template);
  }
  return true;
}

/**
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValidating(elementName) {
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  if (template) {
    return templateIsValidating(template);
  }
  return false;
}

/**
 * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.
 * If false, the template must be validated.
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}

/**
 * the template is marked as `validating` for one microtask so that all instances
 * found in the tree crawl of `applyStyle` will update themselves,
 * but the template will only be updated once.
 * @param {string} elementName
*/
function startValidating(elementName) {
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  startValidatingTemplate(template);
}

/**
 * Begin an asynchronous invalidation cycle.
 * This should be called after every validation of a template
 *
 * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`
 * @param {HTMLTemplateElement} template
 */
function startValidatingTemplate(template) {
  // remember that the current "next version" is the reason for this validation cycle
  template[VALIDATING_VERSION] = template[NEXT_VERSION];
  // however, there only needs to be one async task to clear the counters
  if (!template._validating) {
    template._validating = true;
    promise.then(function() {
      // sync the current version to let future invalidations cause a refresh cycle
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

/**
 * @return {boolean}
 */
function elementsAreInvalid() {
  for (let elementName in __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */]) {
    let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
    if (!templateIsValid(template)) {
      return true;
    }
  }
  return false;
}

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_async_js__ = __webpack_require__(6);





let caseMap = __WEBPACK_IMPORTED_MODULE_2__utils_case_map_js__;

let microtask = __WEBPACK_IMPORTED_MODULE_3__utils_async_js__["a" /* microTask */];

// Save map of native properties; this forms a blacklist or properties
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws
const nativeProperties = {};
let proto = HTMLElement.prototype;
while (proto) {
  let props = Object.getOwnPropertyNames(proto);
  for (let i=0; i<props.length; i++) {
    nativeProperties[props[i]] = true;
  }
  proto = Object.getPrototypeOf(proto);
}

/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @private
 */
function saveAccessorValue(model, property) {
  // Don't read/store value for any native properties since they could throw
  if (!nativeProperties[property]) {
    let value = model[property];
    if (value !== undefined) {
      if (model.__data) {
        // Adding accessor to instance; update the property
        // It is the user's responsibility to call _flushProperties
        model._setPendingProperty(property, value);
      } else {
        // Adding accessor to proto; save proto's value for instance-time use
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }
        model.__dataProto[property] = value;
      }
    }
  }
}

const PropertyAccessors = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends HTMLElement
   * @unrestricted
   */
  class PropertyAccessors extends superClass {

    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     */
    static createPropertiesForAttributes() {
      let a$ = this.observedAttributes;
      for (let i=0; i < a$.length; i++) {
        this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[i]));
      }
    }

    constructor() {
      super();
      /** @type {boolean} */
      this.__serializing;
      /** @type {number} */
      this.__dataCounter;
      /** @type {boolean} */
      this.__dataEnabled;
      /** @type {boolean} */
      this.__dataReady;
      /** @type {boolean} */
      this.__dataInvalid;
      /** @type {!Object} */
      this.__data;
      /** @type {Object} */
      this.__dataPending;
      /** @type {Object} */
      this.__dataOld;
      /** @type {Object} */
      this.__dataProto;
      /** @type {Object} */
      this.__dataHasAccessor;
      /** @type {Object} */
      this.__dataInstanceProps;
      this._initializeProperties();
    }

    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     */
    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        this._attributeToProperty(name, value);
      }
    }

    /**
     * Initializes the local storage for property accessors.
     *
     * Provided as an override point for performing any setup work prior
     * to initializing the property accessor system.
     *
     * @protected
     */
    _initializeProperties() {
      this.__serializing = false;
      this.__dataCounter = 0;
      this.__dataEnabled = false;
      this.__dataReady = false;
      this.__dataInvalid = false;
      this.__data = {};
      this.__dataPending = null;
      this.__dataOld = null;
      if (this.__dataProto) {
        this._initializeProtoProperties(this.__dataProto);
        this.__dataProto = null;
      }
      // Capture instance properties; these will be set into accessors
      // during first flush. Don't set them here, since we want
      // these to overwrite defaults/constructor assignments
      for (let p in this.__dataHasAccessor) {
        if (this.hasOwnProperty(p)) {
          this.__dataInstanceProps = this.__dataInstanceProps || {};
          this.__dataInstanceProps[p] = this[p];
          delete this[p];
        }
      }
    }

    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @protected
     */
    _initializeProtoProperties(props) {
      for (let p in props) {
        this._setProperty(p, props[p]);
      }
    }

    /**
     * Called at ready time with bag of instance properties that overwrote
     * accessors when the element upgraded.
     *
     * The default implementation sets these properties back into the
     * setter at ready time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @protected
     */
    _initializeInstanceProperties(props) {
      Object.assign(this, props);
    }

    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     */
    _ensureAttribute(attribute, value) {
      if (!this.hasAttribute(attribute)) {
        this._valueToNodeAttribute(this, value, attribute);
      }
    }

    /**
     * Deserializes an attribute to its associated property.
     *
     * This method calls the `_deserializeValue` method to convert the string to
     * a typed value.
     *
     * @param {string} attribute Name of attribute to deserialize.
     * @param {?string} value of the attribute.
     * @param {*=} type type to deserialize to.
     */
    _attributeToProperty(attribute, value, type) {
      // Don't deserialize back to property if currently reflecting
      if (!this.__serializing) {
        let property = caseMap.dashToCamelCase(attribute);
        this[property] = this._deserializeValue(value, type);
      }
    }

    /**
     * Serializes a property to its associated attribute.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect.
     * @param {*=} value Property value to refect.
     */
    _propertyToAttribute(property, attribute, value) {
      this.__serializing = true;
      value = (arguments.length < 3) ? this[property] : value;
      this._valueToNodeAttribute(this, value,
        attribute || caseMap.camelToDashCase(property));
      this.__serializing = false;
    }

    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * This method calls the `_serializeValue` method to convert the typed
     * value to a string.  If the `_serializeValue` method returns `undefined`,
     * the attribute will be removed (this is the default for boolean
     * type `false`).
     *
     * @param {Element} node Element to set attribute to.
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     */
    _valueToNodeAttribute(node, value, attribute) {
      let str = this._serializeValue(value);
      if (str === undefined) {
        node.removeAttribute(attribute);
      } else {
        node.setAttribute(attribute, str);
      }
    }

    /**
     * Converts a typed JavaScript value to a string.
     *
     * This method is called by Polymer when setting JS property values to
     * HTML attributes.  Users may override this method on Polymer element
     * prototypes to provide serialization for custom types.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property value.
     */
    _serializeValue(value) {
      /* eslint-disable no-fallthrough */
      switch (typeof value) {
        case 'boolean':
          return value ? '' : undefined;

        case 'object':
          if (value instanceof Date) {
            return value.toString();
          } else if (value) {
            try {
              return JSON.stringify(value);
            } catch(x) {
              return '';
            }
          }

        default:
          return value != null ? value.toString() : undefined;
      }
    }

    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     * Note: The return value of `undefined` is used as a sentinel value to
     * indicate the attribute should be removed.
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     */
    _deserializeValue(value, type) {
      /**
       * @type {*}
       */
      let outValue;
      switch (type) {
        case Number:
          outValue = Number(value);
          break;

        case Boolean:
          outValue = (value !== null);
          break;

        case Object:
          try {
            outValue = JSON.parse(/** @type string */(value));
          } catch(x) {
            // allow non-JSON literals like Strings and Numbers
          }
          break;

        case Array:
          try {
            outValue = JSON.parse(/** @type string */(value));
          } catch(x) {
            outValue = null;
            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
          }
          break;

        case Date:
          outValue = new Date(value);
          break;

        case String:
        default:
          outValue = value;
          break;
      }

      return outValue;
    }
    /* eslint-enable no-fallthrough */

    /**
     * Creates a setter/getter pair for the named property with its own
     * local storage.  The getter returns the value in the local storage,
     * and the setter calls `_setProperty`, which updates the local storage
     * for the property and enqueues a `_propertiesChanged` callback.
     *
     * This method may be called on a prototype or an instance.  Calling
     * this method may overwrite a property value that already exists on
     * the prototype/instance by creating the accessor.  When calling on
     * a prototype, any overwritten values are saved in `__dataProto`,
     * and it is up to the subclasser to decide how/when to set those
     * properties back into the accessor.  When calling on an instance,
     * the overwritten value is set via `_setPendingProperty`, and the
     * user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     *
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created; the
     *   protected `_setProperty` function must be used to set the property
     * @protected
     */
    _createPropertyAccessor(property, readOnly) {
      if (!this.hasOwnProperty('__dataHasAccessor')) {
        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
      }
      if (!this.__dataHasAccessor[property]) {
        this.__dataHasAccessor[property] = true;
        saveAccessorValue(this, property);
        Object.defineProperty(this, property, {
          /* eslint-disable valid-jsdoc */
          /** @this {PropertyAccessors} */
          get: function() {
            return this.__data[property];
          },
          /** @this {PropertyAccessors} */
          set: readOnly ? function() {} : function(value) {
            this._setProperty(property, value);
          }
          /* eslint-enable */
        });
      }
    }

    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     */
    _hasAccessor(property) {
      return this.__dataHasAccessor && this.__dataHasAccessor[property];
    }

    /**
     * Updates the local storage for a property (via `_setPendingProperty`)
     * and enqueues a `_proeprtiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @protected
     */
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value)) {
        this._invalidateProperties();
      }
    }

    /**
     * Updates the local storage for a property, records the previous value,
     * and adds it to the set of "pending changes" that will be passed to the
     * `_propertiesChanged` callback.  This method does not enqueue the
     * `_propertiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {boolean} Returns true if the property changed
     * @protected
     */
    _setPendingProperty(property, value) {
      let old = this.__data[property];
      let changed = this._shouldPropertyChange(property, value, old);
      if (changed) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        // Ensure old is captured from the last turn
        if (this.__dataOld && !(property in this.__dataOld)) {
          this.__dataOld[property] = old;
        }
        this.__data[property] = value;
        this.__dataPending[property] = value;
      }
      return changed;
    }

    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     */
    _isPropertyPending(prop) {
      return Boolean(this.__dataPending && (prop in this.__dataPending));
    }

    /**
     * Marks the properties as invalid, and enqueues an async
     * `_propertiesChanged` callback.
     *
     * @protected
     */
    _invalidateProperties() {
      if (!this.__dataInvalid && this.__dataReady) {
        this.__dataInvalid = true;
        microtask.run(() => {
          if (this.__dataInvalid) {
            this.__dataInvalid = false;
            this._flushProperties();
          }
        });
      }
    }

    /**
     * Call to enable property accessor processing. Before this method is
     * called accessor values will be set but side effects are
     * queued. When called, any pending side effects occur immediately.
     * For elements, generally `connectedCallback` is a normal spot to do so.
     * It is safe to call this method multiple times as it only turns on
     * property accessors once.
     */
    _enableProperties() {
      if (!this.__dataEnabled) {
        this.__dataEnabled = true;
        if (this.__dataInstanceProps) {
          this._initializeInstanceProperties(this.__dataInstanceProps);
          this.__dataInstanceProps = null;
        }
        this.ready();
      }
    }

    /**
     * Calls the `_propertiesChanged` callback with the current set of
     * pending changes (and old values recorded when pending changes were
     * set), and resets the pending set of changes. Generally, this method
     * should not be called in user code.
     *
     *
     * @protected
     */
    _flushProperties() {
      if (this.__dataPending && this.__dataOld) {
        let changedProps = this.__dataPending;
        this.__dataPending = null;
        this.__dataCounter++;
        this._propertiesChanged(this.__data, changedProps, this.__dataOld);
        this.__dataCounter--;
      }
    }

    /**
     * Lifecycle callback called the first time properties are being flushed.
     * Prior to `ready`, all property sets through accessors are queued and
     * their effects are flushed after this method returns.
     *
     * Users may override this function to implement behavior that is
     * dependent on the element having its properties initialized, e.g.
     * from defaults (initialized from `constructor`, `_initializeProperties`),
     * `attributeChangedCallback`, or values propagated from host e.g. via
     * bindings.  `super.ready()` must be called to ensure the data system
     * becomes enabled.
     *
     * @public
     */
    ready() {
      this.__dataReady = true;
      // Run normal flush
      this._flushProperties();
    }

    /**
     * Callback called when any properties with accessors created via
     * `_createPropertyAccessor` have been set.
     *
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {!Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {!Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @protected
     */
    _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars
    }

    /**
     * Method called to determine whether a property value should be
     * considered as a change and cause the `_propertiesChanged` callback
     * to be enqueued.
     *
     * The default implementation returns `true` for primitive types if a
     * strict equality check fails, and returns `true` for all Object/Arrays.
     * The method always returns false for `NaN`.
     *
     * Override this method to e.g. provide stricter checking for
     * Objects/Arrays when using immutable patterns.
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     *   and enqueue a `_proeprtiesChanged` callback
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return (
        // Strict equality check
        (old !== value &&
         // This ensures (old==NaN, value==NaN) always returns false
         (old === old || value === value))
      );
    }

  }

  return PropertyAccessors;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = PropertyAccessors;



/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(4);



// 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)
const templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};
function wrapTemplateExtension(node) {
  let is = node.getAttribute('is');
  if (is && templateExtensions[is]) {
    let t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);
    while(t.attributes.length) {
      node.setAttribute(t.attributes[0].name, t.attributes[0].value);
      t.removeAttribute(t.attributes[0].name);
    }
  }
  return node;
}

function findTemplateNode(root, nodeInfo) {
  // recursively ascend tree until we hit root
  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
  // unwind the stack, returning the indexed node at each level
  if (parent) {
    // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
}

// construct `$` map (from id annotations)
function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
}

// install event listeners (from event annotations)
function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
}

// push configuration references at configure time
function applyTemplateContent(inst, node, nodeInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
  }
}

function createNodeEventHandler(context, eventName, methodName) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  context = context._methodHost || context;
  let handler = function(e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };
  return handler;
}

const TemplateStamp = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */
  class TemplateStamp extends superClass {

    /**
     * Scans a template to produce template metadata.
     *
     * Template-specific metadata are stored in the object returned, and node-
     * specific metadata are stored in objects in its flattened `nodeInfoList`
     * array.  Only nodes in the template that were parsed as nodes of
     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
     * contains an `index` (`childNodes` index in parent) and optionally
     * `parent`, which points to node info of its parent (including its index).
     *
     * The template metadata object returned from this method has the following
     * structure (many fields optional):
     *
     * ```js
     *   {
     *     // Flattened list of node metadata (for nodes that generated metadata)
     *     nodeInfoList: [
     *       {
     *         // `id` attribute for any nodes with id's for generating `$` map
     *         id: {string},
     *         // `on-event="handler"` metadata
     *         events: [
     *           {
     *             name: {string},   // event name
     *             value: {string},  // handler method name
     *           }, ...
     *         ],
     *         // Notes when the template contained a `<slot>` for shady DOM
     *         // optimization purposes
     *         hasInsertionPoint: {boolean},
     *         // For nested `<template>`` nodes, nested template metadata
     *         templateInfo: {object}, // nested template metadata
     *         // Metadata to allow efficient retrieval of instanced node
     *         // corresponding to this metadata
     *         parentInfo: {number},   // reference to parent nodeInfo>
     *         parentIndex: {number},  // index in parent's `childNodes` collection
     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
     *       },
     *       ...
     *     ],
     *     // When true, the template had the `strip-whitespace` attribute
     *     // or was nested in a template with that setting
     *     stripWhitespace: {boolean},
     *     // For nested templates, nested template content is moved into
     *     // a document fragment stored here; this is an optimization to
     *     // avoid the cost of nested template cloning
     *     content: {DocumentFragment}
     *   }
     * ```
     *
     * This method kicks off a recursive treewalk as follows:
     *
     * ```
     *    _parseTemplate <---------------------+
     *      _parseTemplateContent              |
     *        _parseTemplateNode  <------------|--+
     *          _parseTemplateNestedTemplate --+  |
     *          _parseTemplateChildNodes ---------+
     *          _parseTemplateNodeAttributes
     *            _parseTemplateNodeAttribute
     *
     * ```
     *
     * These methods may be overridden to add custom metadata about templates
     * to either `templateInfo` or `nodeInfo`.
     *
     * Note that this method may be destructive to the template, in that
     * e.g. event annotations may be removed after being noted in the
     * template metadata.
     *
     * @param {!HTMLTemplateElement} template Template to parse
     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
     *   template, for parsing nested templates
     * @return {!TemplateInfo} Parsed template metadata
     */
    static _parseTemplate(template, outerTemplateInfo) {
      // since a template may be re-used, memo-ize metadata
      if (!template._templateInfo) {
        let templateInfo = template._templateInfo = {};
        templateInfo.nodeInfoList = [];
        templateInfo.stripWhiteSpace =
          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||
          template.hasAttribute('strip-whitespace');
        this._parseTemplateContent(template, templateInfo, {parent: null});
      }
      return template._templateInfo;
    }

    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
    }

    /**
     * Parses template node and adds template and node metadata based on
     * the current node, and its `childNodes` and `attributes`.
     *
     * This method may be overridden to add custom node or template specific
     * metadata based on this node.
     *
     * @param {Node} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted;
      let element = /** @type Element */(node);
      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
      } else if (element.localName === 'slot') {
        // For ShadyDom optimization, indicating there is an insertion point
        templateInfo.hasInsertionPoint = true;
      }
      if (element.firstChild) {
        noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
      }
      if (element.hasAttributes && element.hasAttributes()) {
        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
      }
      return noted;
    }

    /**
     * Parses template child nodes for the given root node.
     *
     * This method also wraps whitelisted legacy template extensions
     * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
     * wrappers, collapses text nodes, and strips whitespace from the template
     * if the `templateInfo.stripWhitespace` setting was provided.
     *
     * @param {Node} root Root node whose `childNodes` will be parsed
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     */
    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
      for (let node=root.firstChild, parentIndex=0, next; node; node=next) {
        // Wrap templates
        if (node.localName == 'template') {
          node = wrapTemplateExtension(node);
        }
        // collapse adjacent textNodes: fixes an IE issue that can cause
        // text nodes to be inexplicably split =(
        // note that root.normalize() should work but does not so we do this
        // manually.
        next = node.nextSibling;
        if (node.nodeType === Node.TEXT_NODE) {
          let /** Node */ n = next;
          while (n && (n.nodeType === Node.TEXT_NODE)) {
            node.textContent += n.textContent;
            next = n.nextSibling;
            root.removeChild(n);
            n = next;
          }
          // optionally strip whitespace
          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
            root.removeChild(node);
            continue;
          }
        }
        let childInfo = { parentIndex, parentInfo: nodeInfo };
        if (this._parseTemplateNode(node, templateInfo, childInfo)) {
          childInfo.infoIndex = templateInfo.nodeInfoList.push(/** @type {!NodeInfo} */(childInfo)) - 1;
        }
        // Increment if not removed
        if (node.parentNode) {
          parentIndex++;
        }
      }
    }

    /**
     * Parses template content for the given nested `<template>`.
     *
     * Nested template info is stored as `templateInfo` in the current node's
     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
     * It will then be the responsibility of the host to set it back to the
     * template and for users stamping nested templates to use the
     * `_contentForTemplate` method to retrieve the content for this template
     * (an optimization to avoid the cost of cloning nested template content).
     *
     * @param {HTMLTemplateElement} node Node to parse (a <template>)
     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
     *   that includes the template `node`
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
      let templateInfo = this._parseTemplate(node, outerTemplateInfo);
      let content = templateInfo.content =
        node.content.ownerDocument.createDocumentFragment();
      content.appendChild(node.content);
      nodeInfo.templateInfo = templateInfo;
      return true;
    }

    /**
     * Parses template node attributes and adds node metadata to `nodeInfo`
     * for nodes of interest.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
      // Make copy of original attribute list, since the order may change
      // as attributes are added and removed
      let noted = false;
      let attrs = Array.from(node.attributes);
      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {
        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
      }
      return noted;
    }

    /**
     * Parses a single template node attribute and adds node metadata to
     * `nodeInfo` for attributes of interest.
     *
     * This implementation adds metadata for `on-event="handler"` attributes
     * and `id` attributes.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      // events (on-*)
      if (name.slice(0, 3) === 'on-') {
        node.removeAttribute(name);
        nodeInfo.events = nodeInfo.events || [];
        nodeInfo.events.push({
          name: name.slice(3),
          value
        });
        return true;
      }
      // static id
      else if (name === 'id') {
        nodeInfo.id = value;
        return true;
      }
      return false;
    }

    /**
     * Returns the `content` document fragment for a given template.
     *
     * For nested templates, Polymer performs an optimization to cache nested
     * template content to avoid the cost of cloning deeply nested templates.
     * This method retrieves the cached content for a given template.
     *
     * @param {HTMLTemplateElement} template Template to retrieve `content` for
     * @return {DocumentFragment} Content fragment
     */
    static _contentForTemplate(template) {
      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;
      return (templateInfo && templateInfo.content) || template.content;
    }

    /**
     * Clones the provided template content and returns a document fragment
     * containing the cloned dom.
     *
     * The template is parsed (once and memoized) using this library's
     * template parsing features, and provides the following value-added
     * features:
     * * Adds declarative event listeners for `on-event="handler"` attributes
     * * Generates an "id map" for all nodes with id's under `$` on returned
     *   document fragment
     * * Passes template info including `content` back to templates as
     *   `_templateInfo` (a performance optimization to avoid deep template
     *   cloning)
     *
     * Note that the memoized template parsing process is destructive to the
     * template: attributes for bindings and declarative event listeners are
     * removed after being noted in notes, and any nested `<template>.content`
     * is removed and stored in notes as well.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     */
    _stampTemplate(template) {
      // Polyfill support: bootstrap the template if it has not already been
      if (template && !template.content &&
          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
        HTMLTemplateElement.decorate(template);
      }
      let templateInfo = this.constructor._parseTemplate(template);
      let nodeInfo = templateInfo.nodeInfoList;
      let content = templateInfo.content || template.content;
      let dom = /** @type DocumentFragment */ (document.importNode(content, true));
      // NOTE: ShadyDom optimization indicating there is an insertion point
      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
      let nodes = dom.nodeList = new Array(nodeInfo.length);
      dom.$ = {};
      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {
        let node = nodes[i] = findTemplateNode(dom, info);
        applyIdToMap(this, dom.$, node, info);
        applyTemplateContent(this, node, info);
        applyEventListener(this, node, info);
      }
      return /** @type {!StampedTemplate} */(dom);
    }

    /**
     * Adds an event listener by method name for the event provided.
     *
     * This method generates a handler function that looks up the method
     * name at handling time.
     *
     * @param {Node} node Node to add listener on
     * @param {string} eventName Name of event
     * @param {string} methodName Name of method
     * @param {*=} context Context the method will be called on (defaults
     *   to `node`)
     * @return {Function} Generated handler function
     */
    _addMethodEventListenerToNode(node, eventName, methodName, context) {
      context = context || node;
      let handler = createNodeEventHandler(context, eventName, methodName);
      this._addEventListenerToNode(node, eventName, handler);
      return handler;
    }

    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {Node} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {Function} handler Listener function to add
     */
    _addEventListenerToNode(node, eventName, handler) {
      node.addEventListener(eventName, handler);
    }

    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {Node} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {Function} handler Listener function to remove
     */
    _removeEventListenerFromNode(node, eventName, handler) {
      node.removeEventListener(eventName, handler);
    }

  }

  return TemplateStamp;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = TemplateStamp;



/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


// run a callback when HTMLImports are ready or immediately if
// this api is not available.
function whenImportsReady(cb) {
  if (window.HTMLImports) {
    HTMLImports.whenReady(cb);
  } else {
    cb();
  }
}

const importHref = function(href, onload, onerror, optAsync) {
  let link = /** @type {HTMLLinkElement} */
    (document.head.querySelector('link[href="' + href + '"][import-href]'));
  if (!link) {
    link = /** @type {HTMLLinkElement} */ (document.createElement('link'));
    link.rel = 'import';
    link.href = href;
    link.setAttribute('import-href', '');
  }
  // always ensure link has `async` attribute if user specified one,
  // even if it was previously not async. This is considered less confusing.
  if (optAsync) {
    link.setAttribute('async', '');
  }
  // NOTE: the link may now be in 3 states: (1) pending insertion,
  // (2) inflight, (3) already laoded. In each case, we need to add
  // event listeners to process callbacks.
  let cleanup = function() {
    link.removeEventListener('load', loadListener);
    link.removeEventListener('error', errorListener);
  };
  let loadListener = function(event) {
    cleanup();
    // In case of a successful load, cache the load event on the link so
    // that it can be used to short-circuit this method in the future when
    // it is called with the same href param.
    link.__dynamicImportLoaded = true;
    if (onload) {
      whenImportsReady(() => {
        onload(event);
      });
    }
  };
  let errorListener = function(event) {
    cleanup();
    // In case of an error, remove the link from the document so that it
    // will be automatically created again the next time `importHref` is
    // called.
    if (link.parentNode) {
      link.parentNode.removeChild(link);
    }
    if (onerror) {
      whenImportsReady(() => {
        onerror(event);
      });
    }
  };
  link.addEventListener('load', loadListener);
  link.addEventListener('error', errorListener);
  if (link.parentNode == null) {
    document.head.appendChild(link);
  // if the link already loaded, dispatch a fake load event
  // so that listeners are called and get a proper event argument.
  } else if (link.__dynamicImportLoaded) {
    link.dispatchEvent(new Event('load'));
  }
  return link;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = importHref;



/***/ }),
/* 60 */
/***/ (function(module, exports) {

function resolve() {
  document.body.removeAttribute('unresolved');
}

if (document.readyState === 'interactive' || document.readyState === 'complete') {
  resolve();
} else {
  window.addEventListener('DOMContentLoaded', resolve);
}


/***/ }),
/* 61 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FlattenedNodesObserver; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array_splice_js__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__async_js__ = __webpack_require__(6);




/**
 * Returns true if `node` is a slot element
 * @param {HTMLElement} node Node to test.
 * @return {boolean} Returns true if the given `node` is a slot
 * @private
 */
function isSlot(node) {
  return (node.localName === 'slot');
}

/**
 * Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`. The list of flattened nodes consists
 * of a node's children and, for any children that are `<slot>` elements,
 * the expanded flattened list of `assignedNodes`.
 * For example, if the observed node has children `<a></a><slot></slot><b></b>`
 * and the `<slot>` has one `<div>` assigned to it, then the flattened
 * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
 * `<slot>` elements assigned to it, these are flattened as well.
 *
 * The provided `callback` is called whenever any change to this list
 * of flattened nodes occurs, where an addition or removal of a node is
 * considered a change. The `callback` is called with one argument, an object
 * containing an array of any `addedNodes` and `removedNodes`.
 *
 * Note: the callback is called asynchronous to any changes
 * at a microtask checkpoint. This is because observation is performed using
 * `MutationObserver` and the `<slot>` element's `slotchange` event which
 * are asynchronous.
 *
 * @memberof Polymer
 * @summary Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`.
 */
class FlattenedNodesObserver {

  /**
   * Returns the list of flattened nodes for the given `node`.
   * This list consists of a node's children and, for any children
   * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
   * @return {Array} The list of flattened nodes for the given `node`.
  */
  static getFlattenedNodes(node) {
    if (isSlot(node)) {
      return /** @type {HTMLSlotElement} */ (node).assignedNodes({flatten: true});
    } else {
      return Array.from(node.childNodes).map(node => {
        if (isSlot(node)) {
          return /** @type {HTMLSlotElement} */ (node).assignedNodes({flatten: true});
        } else {
          return [node];
        }
      }).reduce((a, b) => a.concat(b), []);
    }
  }

  /**
   * @param {Node} target Node on which to listen for changes.
   * @param {Function} callback Function called when there are additions
   * or removals from the target's list of flattened nodes.
  */
  constructor(target, callback) {
    /** @type {MutationObserver} */
    this._shadyChildrenObserver = null;
    /** @type {MutationObserver} */
    this._nativeChildrenObserver = null;
    this._connected = false;
    this._target = target;
    this.callback = callback;
    this._effectiveNodes = [];
    this._observer = null;
    this._scheduled = false;
    /** @type {function()} */
    this._boundSchedule = () => {
      this._schedule();
    };
    this.connect();
    this._schedule();
  }

  /**
   * Activates an observer. This method is automatically called when
   * a `FlattenedNodesObserver` is created. It should only be called to
   * re-activate an observer that has been deactivated via the `disconnect` method.
   */
  connect() {
    if (isSlot(this._target)) {
      this._listenSlots([this._target]);
    } else {
      this._listenSlots(this._target.children);
      if (window.ShadyDOM) {
        this._shadyChildrenObserver =
          ShadyDOM.observeChildren(this._target, (mutations) => {
            this._processMutations(mutations);
          });
      } else {
        this._nativeChildrenObserver =
          new MutationObserver((mutations) => {
            this._processMutations(mutations);
          });
        this._nativeChildrenObserver.observe(this._target, {childList: true});
      }
    }
    this._connected = true;
  }

  /**
   * Deactivates the flattened nodes observer. After calling this method
   * the observer callback will not be called when changes to flattened nodes
   * occur. The `connect` method may be subsequently called to reactivate
   * the observer.
   */
  disconnect() {
    if (isSlot(this._target)) {
      this._unlistenSlots([this._target]);
    } else {
      this._unlistenSlots(this._target.children);
      if (window.ShadyDOM && this._shadyChildrenObserver) {
        ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
        this._shadyChildrenObserver = null;
      } else if (this._nativeChildrenObserver) {
        this._nativeChildrenObserver.disconnect();
        this._nativeChildrenObserver = null;
      }
    }
    this._connected = false;
  }

  _schedule() {
    if (!this._scheduled) {
      this._scheduled = true;
      __WEBPACK_IMPORTED_MODULE_2__async_js__["a" /* microTask */].run(() => this.flush());
    }
  }

  _processMutations(mutations) {
    this._processSlotMutations(mutations);
    this.flush();
  }

  _processSlotMutations(mutations) {
    if (mutations) {
      for (let i=0; i < mutations.length; i++) {
        let mutation = mutations[i];
        if (mutation.addedNodes) {
          this._listenSlots(mutation.addedNodes);
        }
        if (mutation.removedNodes) {
          this._unlistenSlots(mutation.removedNodes);
        }
      }
    }
  }

  /**
   * Flushes the observer causing any pending changes to be immediately
   * delivered the observer callback. By default these changes are delivered
   * asynchronously at the next microtask checkpoint.
   *
   * @return {boolean} Returns true if any pending changes caused the observer
   * callback to run.
   */
  flush() {
    if (!this._connected) {
      return false;
    }
    if (window.ShadyDOM) {
      ShadyDOM.flush();
    }
    if (this._nativeChildrenObserver) {
      this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
    } else if (this._shadyChildrenObserver) {
      this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
    }
    this._scheduled = false;
    let info = {
      target: this._target,
      addedNodes: [],
      removedNodes: []
    };
    let newNodes = this.constructor.getFlattenedNodes(this._target);
    let splices = Object(__WEBPACK_IMPORTED_MODULE_1__array_splice_js__["a" /* calculateSplices */])(newNodes,
      this._effectiveNodes);
    // process removals
    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {
        info.removedNodes.push(n);
      }
    }
    // process adds
    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (let j=s.index; j < s.index + s.addedCount; j++) {
        info.addedNodes.push(newNodes[j]);
      }
    }
    // update cache
    this._effectiveNodes = newNodes;
    let didFlush = false;
    if (info.addedNodes.length || info.removedNodes.length) {
      didFlush = true;
      this.callback.call(this._target, info);
    }
    return didFlush;
  }

  _listenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      let n = nodeList[i];
      if (isSlot(n)) {
        n.addEventListener('slotchange', this._boundSchedule);
      }
    }
  }

  _unlistenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      let n = nodeList[i];
      if (isSlot(n)) {
        n.removeEventListener('slotchange', this._boundSchedule);
      }
    }
  }

}




/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export mixinBehaviors */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__legacy_element_mixin_js__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__elements_dom_module_js__ = __webpack_require__(25);



let metaProps = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  // meta objects
  behaviors: true
};

/**
 * Applies a "legacy" behavior or array of behaviors to the provided class.
 *
 * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
 * to ensure that any legacy behaviors can rely on legacy Polymer API on
 * the underlying element.
 *
 * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
 * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
 * @return {function(new:HTMLElement)} Returns a new Element class extended by the
 * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
 * @memberof Polymer
 * @suppress {invalidCasts, checkTypes}
 */
function mixinBehaviors(behaviors, klass) {
  if (!behaviors) {
    return /** @type {HTMLElement} */(klass);
  }
  // NOTE: ensure the bahevior is extending a class with
  // legacy element api. This is necessary since behaviors expect to be able
  // to access 1.x legacy api.
  klass = Object(__WEBPACK_IMPORTED_MODULE_0__legacy_element_mixin_js__["a" /* LegacyElementMixin */])(klass);
  if (!Array.isArray(behaviors)) {
    behaviors = [behaviors];
  }
  let superBehaviors = klass.prototype.behaviors;
  // get flattened, deduped list of behaviors *not* already on super class
  behaviors = flattenBehaviors(behaviors, null, superBehaviors);
  // mixin new behaviors
  klass = _mixinBehaviors(behaviors, klass);
  if (superBehaviors) {
    behaviors = superBehaviors.concat(behaviors);
  }
  // Set behaviors on prototype for BC...
  klass.prototype.behaviors = behaviors;
  return klass;
}

// NOTE:
// 1.x
// Behaviors were mixed in *in reverse order* and de-duped on the fly.
// The rule was that behavior properties were copied onto the element
// prototype if and only if the property did not already exist.
// Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
// (1), B, (2), A, (3) C. This means prototype properties win over
// B properties win over A win over C. This mirrors what would happen
// with inheritance if element extended B extended A extended C.
//
// Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
// `behaviors` array was [C, A, B].
// Behavior lifecycle methods were called in behavior array order
// followed by the element, e.g. (1) C.created, (2) A.created,
// (3) B.created, (4) element.created. There was no support for
// super, and "super-behavior" methods were callable only by name).
//
// 2.x
// Behaviors are made into proper mixins which live in the
// element's prototype chain. Behaviors are placed in the element prototype
// eldest to youngest and de-duped youngest to oldest:
// So, first [A, B, C, A, B] becomes [C, A, B] then,
// the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
// (3) class(A), (4) class(B), (5) class(Polymer({...})).
// Result:
// This means element properties win over B properties win over A win
// over C. (same as 1.x)
// If lifecycle is called (super then me), order is
// (1) C.created, (2) A.created, (3) B.created, (4) element.created
// (again same as 1.x)
function _mixinBehaviors(behaviors, klass) {
  for (let i=0; i<behaviors.length; i++) {
    let b = behaviors[i];
    if (b) {
      klass = Array.isArray(b) ? _mixinBehaviors(b, klass) :
        GenerateClassFromInfo(b, klass);
    }
  }
  return klass;
}

/**
 * @param {Array} behaviors List of behaviors to flatten.
 * @param {Array=} list Target list to flatten behaviors into.
 * @param {Array=} exclude List of behaviors to exclude from the list.
 * @return {!Array} Returns the list of flattened behaviors.
 */
function flattenBehaviors(behaviors, list, exclude) {
  list = list || [];
  for (let i=behaviors.length-1; i >= 0; i--) {
    let b = behaviors[i];
    if (b) {
      if (Array.isArray(b)) {
        flattenBehaviors(b, list);
      } else {
        // dedup
        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
          list.unshift(b);
        }
      }
    } else {
      console.warn('behavior is null, check for missing or 404 import');
    }
  }
  return list;
}

/**
 * @param {!PolymerInit} info Polymer info object
 * @param {function(new:HTMLElement)} Base base class to extend with info object
 * @return {function(new:HTMLElement)} Generated class
 * @suppress {checkTypes}
 * @private
 */
function GenerateClassFromInfo(info, Base) {

  class PolymerGenerated extends Base {

    static get properties() {
      return info.properties;
    }

    static get observers() {
      return info.observers;
    }

    /**
     * @return {HTMLTemplateElement} template for this class
     */
    static get template() {
      // get template first from any imperative set in `info._template`
      return info._template ||
        // next look in dom-module associated with this element's is.
        __WEBPACK_IMPORTED_MODULE_1__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_1__elements_dom_module_js__["a" /* DomModule */].import(this.is, 'template') ||
        // next look for superclass template (note: use superclass symbol
        // to ensure correct `this.is`)
        Base.template ||
        // finally fall back to `_template` in element's protoype.
        this.prototype._template ||
        null;
    }

    created() {
      super.created();
      if (info.created) {
        info.created.call(this);
      }
    }

    _registered() {
      super._registered();
      /* NOTE: `beforeRegister` is called here for bc, but the behavior
       is different than in 1.x. In 1.0, the method was called *after*
       mixing prototypes together but *before* processing of meta-objects.
       However, dynamic effects can still be set here and can be done either
       in `beforeRegister` or `registered`. It is no longer possible to set
       `is` in `beforeRegister` as you could in 1.x.
      */
      if (info.beforeRegister) {
        info.beforeRegister.call(Object.getPrototypeOf(this));
      }
      if (info.registered) {
        info.registered.call(Object.getPrototypeOf(this));
      }
    }

    _applyListeners() {
      super._applyListeners();
      if (info.listeners) {
        for (let l in info.listeners) {
          this._addMethodEventListenerToNode(this, l, info.listeners[l]);
        }
      }
    }

    // note: exception to "super then me" rule;
    // do work before calling super so that super attributes
    // only apply if not already set.
    _ensureAttributes() {
      if (info.hostAttributes) {
        for (let a in info.hostAttributes) {
          this._ensureAttribute(a, info.hostAttributes[a]);
        }
      }
      super._ensureAttributes();
    }

    ready() {
      super.ready();
      if (info.ready) {
        info.ready.call(this);
      }
    }

    attached() {
      super.attached();
      if (info.attached) {
        info.attached.call(this);
      }
    }

    detached() {
      super.detached();
      if (info.detached) {
        info.detached.call(this);
      }
    }

    attributeChanged(name, old, value) {
      super.attributeChanged(name, old, value);
      if (info.attributeChanged) {
        info.attributeChanged.call(this, name, old, value);
      }
   }
  }

  PolymerGenerated.generatedFrom = info;

  for (let p in info) {
    // NOTE: cannot copy `metaProps` methods onto prototype at least because
    // `super.ready` must be called and is not included in the user fn.
    if (!(p in metaProps)) {
      let pd = Object.getOwnPropertyDescriptor(info, p);
      if (pd) {
        Object.defineProperty(PolymerGenerated.prototype, p, pd);
      }
    }
  }

  return PolymerGenerated;
}

const Class = function(info) {
  if (!info) {
    console.warn('Polymer.Class requires `info` argument');
  }
  let klass = GenerateClassFromInfo(info, info.behaviors ?
    // note: mixinBehaviors ensures `LegacyElementMixin`.
    mixinBehaviors(info.behaviors, HTMLElement) :
    Object(__WEBPACK_IMPORTED_MODULE_0__legacy_element_mixin_js__["a" /* LegacyElementMixin */])(HTMLElement));
  // decorate klass with registration info
  klass.is = info.is;
  return klass;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = Class;





/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Templatizer */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__ = __webpack_require__(29);


let TemplateInstanceBase = __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__["a" /* TemplateInstanceBase */]; // eslint-disable-line

/**
 * @typedef {{
 *   _templatizerTemplate: HTMLTemplateElement,
 *   _parentModel: boolean,
 *   _instanceProps: Object,
 *   _forwardHostPropV2: Function,
 *   _notifyInstancePropV2: Function,
 *   ctor: TemplateInstanceBase
 * }}
 */
let TemplatizerUser; // eslint-disable-line

/**
 * The `Polymer.Templatizer` behavior adds methods to generate instances of
 * templates that are each managed by an anonymous `Polymer.PropertyEffects`
 * instance where data-bindings in the stamped template content are bound to
 * accessors on itself.
 *
 * This behavior is provided in Polymer 2.x as a hybrid-element convenience
 * only.  For non-hybrid usage, the `Polymer.Templatize` library
 * should be used instead.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     this.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = this.stamp({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. light DOM
 *     Polymer.dom(this).appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * Users of `Templatizer` may need to implement the following abstract
 * API's to determine how properties and paths from the host should be
 * forwarded into to instances:
 *
 *     _forwardHostPropV2: function(prop, value)
 *
 * Likewise, users may implement these additional abstract API's to determine
 * how instance-specific properties that change on the instance should be
 * forwarded out to the host, if necessary.
 *
 *     _notifyInstancePropV2: function(inst, prop, value)
 *
 * In order to determine which properties are instance-specific and require
 * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
 * object containing keys for each instance prop, for example:
 *
 *     _instanceProps: {
 *       item: true,
 *       index: true
 *     }
 *
 * Any properties used in the template that are not defined in _instanceProp
 * will be forwarded out to the Templatize `owner` automatically.
 *
 * Users may also implement the following abstract function to show or
 * hide any DOM generated using `stamp`:
 *
 *     _showHideChildren: function(shouldHide)
 *
 * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
 * as the implementations will need to differ from the callbacks required
 * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
 * between versions 1.x and 2.x.
 *
 * @polymerBehavior
 * @memberof Polymer
 */
let Templatizer = {

  /**
   * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
   * for the provided template.  This method should be called once per
   * template to prepare an element for stamping the template, followed
   * by `stamp` to create new instances of the template.
   *
   * @param {HTMLTemplateElement} template Template to prepare
   * @param {boolean=} mutableData When `true`, the generated class will skip
   *   strict dirty-checking for objects and arrays (always consider them to
   *   be "dirty"). Defaults to false.
   * @this {TemplatizerUser}
   */
  templatize(template, mutableData) {
    this._templatizerTemplate = template;
    this.ctor = __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__["b" /* Templatize */].templatize(template, this, {
      mutableData: Boolean(mutableData),
      parentModel: this._parentModel,
      instanceProps: this._instanceProps,
      forwardHostProp: this._forwardHostPropV2,
      notifyInstanceProp: this._notifyInstancePropV2
    });
  },

  /**
   * Creates an instance of the template prepared by `templatize`.  The object
   * returned is an instance of the anonymous class generated by `templatize`
   * whose `root` property is a document fragment containing newly cloned
   * template content, and which has property accessors corresponding to
   * properties referenced in template bindings.
   *
   * @param {Object=} model Object containing initial property values to
   *   populate into the template bindings.
   * @return {TemplateInstanceBase} Returns the created instance of
   * the template prepared by `templatize`.
   * @this {TemplatizerUser}
   */
  stamp(model) {
    return new this.ctor(model);
  },

  /**
   * Returns the template "model" (`TemplateInstance`) associated with
   * a given element, which serves as the binding scope for the template
   * instance the element is contained in.  A template model should be used
   * to manipulate data associated with this template instance.
   *
   * @param {HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   * @this {TemplatizerUser}
   */
  modelForElement(el) {
    return __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__["b" /* Templatize */].modelForElement(this._templatizerTemplate, el);
  }
};




/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomBind */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mixins_gesture_event_listeners_js__ = __webpack_require__(39);





/**
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @implements {Polymer_OptionalMutableData}
 * @implements {Polymer_GestureEventListeners}
 */
const domBindBase =
  Object(__WEBPACK_IMPORTED_MODULE_3__mixins_gesture_event_listeners_js__["a" /* GestureEventListeners */])(
    Object(__WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__["b" /* OptionalMutableData */])(
      Object(__WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__["a" /* PropertyEffects */])(HTMLElement)));

/**
 * Custom element to allow using Polymer's template features (data binding,
 * declarative event listeners, etc.) in the main document without defining
 * a new custom element.
 *
 * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
 * element, which will immediately stamp the wrapped template into the main
 * document and bind elements to the `dom-bind` element itself as the
 * binding scope.
 *
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @appliesMixin Polymer.OptionalMutableData
 * @appliesMixin Polymer.GestureEventListeners
 * @extends {domBindBase}
 * @memberof Polymer
 * @summary Custom element to allow using Polymer's template features (data
 *   binding, declarative event listeners, etc.) in the main document.
 */
class DomBind extends domBindBase {

  static get observedAttributes() { return ['mutable-data']; }

  constructor() {
    super();
    this.root = null;
    this.$ = null;
    this.__children = null;
  }

  // assumes only one observed attribute
  attributeChangedCallback() {
    this.mutableData = true;
  }

  connectedCallback() {
    this.render();
  }

  disconnectedCallback() {
    this.__removeChildren();
  }

  __insertChildren() {
    this.parentNode.insertBefore(this.root, this);
  }

  __removeChildren() {
    if (this.__children) {
      for (let i=0; i<this.__children.length; i++) {
        this.root.appendChild(this.__children[i]);
      }
    }
  }

  /**
   * Forces the element to render its content. This is typically only
   * necessary to call if HTMLImports with the async attribute are used.
   */
  render() {
    let template;
    if (!this.__children) {
      template = /** @type {HTMLTemplateElement} */(template || this.querySelector('template'));
      if (!template) {
        // Wait until childList changes and template should be there by then
        let observer = new MutationObserver(() => {
          template = /** @type {HTMLTemplateElement} */(this.querySelector('template'));
          if (template) {
            observer.disconnect();
            this.render();
          } else {
            throw new Error('dom-bind requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return;
      }
      this.root = this._stampTemplate(template);
      this.$ = this.root.$;
      this.__children = [];
      for (let n=this.root.firstChild; n; n=n.nextSibling) {
        this.__children[this.__children.length] = n;
      }
      this._enableProperties();
    }
    this.__insertChildren();
    this.dispatchEvent(new CustomEvent('dom-change', {
      bubbles: true,
      composed: true
    }));
  }

}

customElements.define('dom-bind', DomBind);




/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomRepeat */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mixins_mutable_data_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_path_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_async_js__ = __webpack_require__(6);








let TemplateInstanceBase = __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["a" /* TemplateInstanceBase */]; // eslint-disable-line

/**
 * @constructor
 * @implements {Polymer_OptionalMutableData}
 * @extends {Polymer.Element}
 */
const domRepeatBase = Object(__WEBPACK_IMPORTED_MODULE_4__mixins_mutable_data_js__["b" /* OptionalMutableData */])(__WEBPACK_IMPORTED_MODULE_0__polymer_element_js__["a" /* Element */]);

/**
 * The `<dom-repeat>` element will automatically stamp and binds one instance
 * of template content to each object in a user-provided array.
 * `dom-repeat` accepts an `items` property, and one instance of the template
 * is stamped for each item into the DOM at the location of the `dom-repeat`
 * element.  The `item` property will be set on each instance's binding
 * scope, thus templates should bind to sub-properties of `item`.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 *   <script>
 *     Polymer({
 *       is: 'employee-list',
 *       ready: function() {
 *         this.employees = [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *         ];
 *       }
 *     });
 *   < /script>
 *
 * </dom-module>
 * ```
 *
 * Notifications for changes to items sub-properties will be forwarded to template
 * instances, which will update via the normal structured data notification system.
 *
 * Mutations to the `items` array itself should be made using the Array
 * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
 * `unshift`), and template instances will be kept in sync with the data in the
 * array.
 *
 * Events caught by event handlers within the `dom-repeat` template will be
 * decorated with a `model` property, which represents the binding scope for
 * each template instance.  The model is an instance of Polymer.Base, and should
 * be used to manipulate data on the instance, for example
 * `event.model.set('item.checked', true);`.
 *
 * Alternatively, the model for a template instance for an element stamped by
 * a `dom-repeat` can be obtained using the `modelForElement` API on the
 * `dom-repeat` that stamped it, for example
 * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
 * This may be useful for manipulating instance data of event targets obtained
 * by event handlers on parents of the `dom-repeat` (event delegation).
 *
 * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
 * `filter` and/or `sort` property.  This may be a string that names a function on
 * the host, or a function may be assigned to the property directly.  The functions
 * should implemented following the standard `Array` filter/sort API.
 *
 * In order to re-run the filter or sort functions based on changes to sub-fields
 * of `items`, the `observe` property may be set as a space-separated list of
 * `item` sub-fields that should cause a re-filter/sort when modified.  If
 * the filter or sort function depends on properties not contained in `items`,
 * the user should observe changes to those properties and call `render` to update
 * the view based on the dependency change.
 *
 * For example, for an `dom-repeat` with a filter of the following:
 *
 * ```js
 * isEngineer: function(item) {
 *     return item.type == 'engineer' || item.manager.type == 'engineer';
 * }
 * ```
 *
 * Then the `observe` property should be configured as follows:
 *
 * ```html
 * <template is="dom-repeat" items="{{employees}}"
 *           filter="isEngineer" observe="type manager.type">
 * ```
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @extends {domRepeatBase}
 * @appliesMixin Polymer.OptionalMutableData
 * @summary Custom element for stamping instance of a template bound to
 *   items in an array.
 */
class DomRepeat extends domRepeatBase {

  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'dom-repeat'; }

  static get template() { return null; }

  static get properties() {

    /**
     * Fired whenever DOM is added or removed by this template (by
     * default, rendering occurs lazily).  To force immediate rendering, call
     * `render`.
     *
     * @event dom-change
     */
    return {

      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },

      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: 'item'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the sorted and filtered list of rendered items.
       * Note, for the index in the `this.items` array, use the value of the
       * `itemsIndexAs` property.
       */
      indexAs: {
        type: String,
        value: 'index'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the `this.items` array. Note, for the index of
       * this instance in the sorted and filtered list of rendered items,
       * use the value of the `indexAs` property.
       */
      itemsIndexAs: {
        type: String,
        value: 'itemsIndex'
      },

      /**
       * A function that should determine the sort order of the items.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.sort`.
       * Using a sort function has no effect on the underlying `items` array.
       */
      sort: {
        type: Function,
        observer: '__sortChanged'
      },

      /**
       * A function that can be used to filter items out of the view.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.filter`.
       * Using a filter function has no effect on the underlying `items` array.
       */
      filter: {
        type: Function,
        observer: '__filterChanged'
      },

      /**
       * When using a `filter` or `sort` function, the `observe` property
       * should be set to a space-separated list of the names of item
       * sub-fields that should trigger a re-sort or re-filter when changed.
       * These should generally be fields of `item` that the sort or filter
       * function depends on.
       */
      observe: {
        type: String,
        observer: '__observeChanged'
      },

      /**
       * When using a `filter` or `sort` function, the `delay` property
       * determines a debounce time after a change to observed item
       * properties that must pass before the filter or sort is re-run.
       * This is useful in rate-limiting shuffing of the view when
       * item changes may be frequent.
       */
      delay: Number,

      /**
       * Count of currently rendered items after `filter` (if any) has been applied.
       * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
       * set of template instances is rendered.
       *
       */
      renderedItemCount: {
        type: Number,
        notify: true,
        readOnly: true
      },

      /**
       * Defines an initial count of template instances to render after setting
       * the `items` array, before the next paint, and puts the `dom-repeat`
       * into "chunking mode".  The remaining items will be created and rendered
       * incrementally at each animation frame therof until all instances have
       * been rendered.
       */
      initialCount: {
        type: Number,
        observer: '__initializeChunking'
      },

      /**
       * When `initialCount` is used, this property defines a frame rate to
       * target by throttling the number of instances rendered each frame to
       * not exceed the budget for the target frame rate.  Setting this to a
       * higher number will allow lower latency and higher throughput for
       * things like event handlers, but will result in a longer time for the
       * remaining items to complete rendering.
       */
      targetFramerate: {
        type: Number,
        value: 20
      },

      _targetFrameTime: {
        type: Number,
        computed: '__computeFrameTime(targetFramerate)'
      }

    };

  }

  static get observers() {
    return [ '__itemsChanged(items.*)' ];
  }

  constructor() {
    super();
    this.__instances = [];
    this.__limit = Infinity;
    this.__pool = [];
    this.__renderDebouncer = null;
    this.__itemsIdxToInstIdx = {};
    this.__chunkCount = null;
    this.__lastChunkTime = null;
    this.__sortFn = null;
    this.__filterFn = null;
    this.__observePaths = null;
    this.__ctor = null;
    this.__isDetached = true;
    this.template = null;
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isDetached = true;
    for (let i=0; i<this.__instances.length; i++) {
      this.__detachInstance(i);
    }
  }

  connectedCallback() {
    super.connectedCallback();
    // only perform attachment if the element was previously detached.
    if (this.__isDetached) {
      this.__isDetached = false;
      let parent = this.parentNode;
      for (let i=0; i<this.__instances.length; i++) {
        this.__attachInstance(i, parent);
      }
    }
  }

  __ensureTemplatized() {
    // Templatizing (generating the instance constructor) needs to wait
    // until ready, since won't have its template content handed back to
    // it until then
    if (!this.__ctor) {
      let template = this.template = this.querySelector('template');
      if (!template) {
        // // Wait until childList changes and template should be there by then
        let observer = new MutationObserver(() => {
          if (this.querySelector('template')) {
            observer.disconnect();
            this.__render();
          } else {
            throw new Error('dom-repeat requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return false;
      }
      // Template instance props that should be excluded from forwarding
      let instanceProps = {};
      instanceProps[this.as] = true;
      instanceProps[this.indexAs] = true;
      instanceProps[this.itemsIndexAs] = true;
      this.__ctor = __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["b" /* Templatize */].templatize(template, this, {
        mutableData: this.mutableData,
        parentModel: true,
        instanceProps: instanceProps,
        /**
         * @this {this}
         * @param {string} prop Property to set
         * @param {*} value Value to set property to
         */
        forwardHostProp: function(prop, value) {
          let i$ = this.__instances;
          for (let i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {
            inst.forwardHostProp(prop, value);
          }
        },
        /**
         * @this {this}
         * @param {Object} inst Instance to notify
         * @param {string} prop Property to notify
         * @param {*} value Value to notify
         */
        notifyInstanceProp: function(inst, prop, value) {
          if (Object(__WEBPACK_IMPORTED_MODULE_5__utils_path_js__["e" /* matches */])(this.as, prop)) {
            let idx = inst[this.itemsIndexAs];
            if (prop == this.as) {
              this.items[idx] = value;
            }
            let path = Object(__WEBPACK_IMPORTED_MODULE_5__utils_path_js__["i" /* translate */])(this.as, 'items.' + idx, prop);
            this.notifyPath(path, value);
          }
        }
      });
    }
    return true;
  }

  __getMethodHost() {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    return this.__dataHost._methodHost || this.__dataHost;
  }

  __sortChanged(sort) {
    let methodHost = this.__getMethodHost();
    this.__sortFn = sort && (typeof sort == 'function' ? sort :
      function() { return methodHost[sort].apply(methodHost, arguments); });
    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }

  __filterChanged(filter) {
    let methodHost = this.__getMethodHost();
    this.__filterFn = filter && (typeof filter == 'function' ? filter :
      function() { return methodHost[filter].apply(methodHost, arguments); });
    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }

  __computeFrameTime(rate) {
    return Math.ceil(1000/rate);
  }

  __initializeChunking() {
    if (this.initialCount) {
      this.__limit = this.initialCount;
      this.__chunkCount = this.initialCount;
      this.__lastChunkTime = performance.now();
    }
  }

  __tryRenderChunk() {
    // Debounced so that multiple calls through `_render` between animation
    // frames only queue one new rAF (e.g. array mutation & chunked render)
    if (this.items && this.__limit < this.items.length) {
      this.__debounceRender(this.__requestRenderChunk);
    }
  }

  __requestRenderChunk() {
    requestAnimationFrame(()=>this.__renderChunk());
  }

  __renderChunk() {
    // Simple auto chunkSize throttling algorithm based on feedback loop:
    // measure actual time between frames and scale chunk count by ratio
    // of target/actual frame time
    let currChunkTime = performance.now();
    let ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
    this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
    this.__limit += this.__chunkCount;
    this.__lastChunkTime = currChunkTime;
    this.__debounceRender(this.__render);
  }

  __observeChanged() {
    this.__observePaths = this.observe &&
      this.observe.replace('.*', '.').split(' ');
  }

  __itemsChanged(change) {
    if (this.items && !Array.isArray(this.items)) {
      console.warn('dom-repeat expected array for `items`, found', this.items);
    }
    // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
    // path to that instance synchronously (retuns false for non-item paths)
    if (!this.__handleItemPath(change.path, change.value)) {
      // Otherwise, the array was reset ('items') or spliced ('items.splices'),
      // so queue a full refresh
      this.__initializeChunking();
      this.__debounceRender(this.__render);
    }
  }

  __handleObservedPaths(path) {
    if (this.__observePaths) {
      path = path.substring(path.indexOf('.') + 1);
      let paths = this.__observePaths;
      for (let i=0; i<paths.length; i++) {
        if (path.indexOf(paths[i]) === 0) {
          this.__debounceRender(this.__render, this.delay);
          return true;
        }
      }
    }
  }

  /**
   * @param {function(this:DomRepeat)} fn Function to debounce.
   * @param {number=} delay Delay in ms to debounce by.
   */
  __debounceRender(fn, delay = 0) {
    this.__renderDebouncer = __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__["a" /* Debouncer */].debounce(
          this.__renderDebouncer
        , delay > 0 ? __WEBPACK_IMPORTED_MODULE_6__utils_async_js__["b" /* timeOut */].after(delay) : __WEBPACK_IMPORTED_MODULE_6__utils_async_js__["a" /* microTask */]
        , fn.bind(this));
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["a" /* enqueueDebouncer */])(this.__renderDebouncer);
  }

  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   */
  render() {
    // Queue this repeater, then flush all in order
    this.__debounceRender(this.__render);
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["b" /* flush */])();
  }

  __render() {
    if (!this.__ensureTemplatized()) {
      // No template found yet
      return;
    }
    this.__applyFullRefresh();
    // Reset the pool
    // TODO(kschaaf): Reuse pool across turns and nested templates
    // Now that objects/arrays are re-evaluated when set, we can safely
    // reuse pooled instances across turns, however we still need to decide
    // semantics regarding how long to hold, how many to hold, etc.
    this.__pool.length = 0;
    // Set rendered item count
    this._setRenderedItemCount(this.__instances.length);
    // Notify users
    this.dispatchEvent(new CustomEvent('dom-change', {
      bubbles: true,
      composed: true
    }));
    // Check to see if we need to render more items
    this.__tryRenderChunk();
  }

  __applyFullRefresh() {
    let items = this.items || [];
    let isntIdxToItemsIdx = new Array(items.length);
    for (let i=0; i<items.length; i++) {
      isntIdxToItemsIdx[i] = i;
    }
    // Apply user filter
    if (this.__filterFn) {
      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) =>
        this.__filterFn(items[i], idx, array));
    }
    // Apply user sort
    if (this.__sortFn) {
      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));
    }
    // items->inst map kept for item path forwarding
    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
    let instIdx = 0;
    // Generate instances and assign items
    const limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
    for (; instIdx<limit; instIdx++) {
      let inst = this.__instances[instIdx];
      let itemIdx = isntIdxToItemsIdx[instIdx];
      let item = items[itemIdx];
      itemsIdxToInstIdx[itemIdx] = instIdx;
      if (inst && instIdx < this.__limit) {
        inst._setPendingProperty(this.as, item);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        this.__insertInstance(item, instIdx, itemIdx);
      }
    }
    // Remove any extra instances from previous state
    for (let i=this.__instances.length-1; i>=instIdx; i--) {
      this.__detachAndRemoveInstance(i);
    }
  }

  __detachInstance(idx) {
    let inst = this.__instances[idx];
    for (let i=0; i<inst.children.length; i++) {
      let el = inst.children[i];
      inst.root.appendChild(el);
    }
    return inst;
  }

  __attachInstance(idx, parent) {
    let inst = this.__instances[idx];
    parent.insertBefore(inst.root, this);
  }

  __detachAndRemoveInstance(idx) {
    let inst = this.__detachInstance(idx);
    if (inst) {
      this.__pool.push(inst);
    }
    this.__instances.splice(idx, 1);
  }

  __stampInstance(item, instIdx, itemIdx) {
    let model = {};
    model[this.as] = item;
    model[this.indexAs] = instIdx;
    model[this.itemsIndexAs] = itemIdx;
    return new this.__ctor(model);
  }

  __insertInstance(item, instIdx, itemIdx) {
    let inst = this.__pool.pop();
    if (inst) {
      // TODO(kschaaf): If the pool is shared across turns, hostProps
      // need to be re-set to reused instances in addition to item
      inst._setPendingProperty(this.as, item);
      inst._setPendingProperty(this.indexAs, instIdx);
      inst._setPendingProperty(this.itemsIndexAs, itemIdx);
      inst._flushProperties();
    } else {
      inst = this.__stampInstance(item, instIdx, itemIdx);
    }
    let beforeRow = this.__instances[instIdx + 1];
    let beforeNode = beforeRow ? beforeRow.children[0] : this;
    this.parentNode.insertBefore(inst.root, beforeNode);
    this.__instances[instIdx] = inst;
    return inst;
  }

  // Implements extension point from Templatize mixin
  _showHideChildren(hidden) {
    for (let i=0; i<this.__instances.length; i++) {
      this.__instances[i]._showHideChildren(hidden);
    }
  }

  // Called as a side effect of a host items.<key>.<path> path change,
  // responsible for notifying item.<path> changes to inst for key
  __handleItemPath(path, value) {
    let itemsPath = path.slice(6); // 'items.'.length == 6
    let dot = itemsPath.indexOf('.');
    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
    // If path was index into array...
    if (itemsIdx == parseInt(itemsIdx, 10)) {
      let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot+1);
      // If the path is observed, it will trigger a full refresh
      this.__handleObservedPaths(itemSubPath);
      // Note, even if a rull refresh is triggered, always do the path
      // notification because unless mutableData is used for dom-repeat
      // and all elements in the instance subtree, a full refresh may
      // not trigger the proper update.
      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
      let inst = this.__instances[instIdx];
      if (inst) {
        let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
        // This is effectively `notifyPath`, but avoids some of the overhead
        // of the public API
        inst._setPendingPropertyOrPath(itemPath, value, false, true);
        inst._flushProperties();
      }
      return true;
    }
  }

  /**
   * Returns the item associated with a given element stamped by
   * this `dom-repeat`.
   *
   * Note, to modify sub-properties of the item,
   * `modelForElement(el).set('item.<sub-prop>', value)`
   * should be used.
   *
   * @param {HTMLElement} el Element for which to return the item.
   * @return {*} Item associated with the element.
   */
  itemForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.as];
  }

  /**
   * Returns the inst index for a given element stamped by this `dom-repeat`.
   * If `sort` is provided, the index will reflect the sorted order (rather
   * than the original array order).
   *
   * @param {HTMLElement} el Element for which to return the index.
   * @return {*} Row index associated with the element (note this may
   *   not correspond to the array index if a user `sort` is applied).
   */
  indexForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.indexAs];
  }

  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model is an instance of `Polymer.Base`, and
   * should be used to manipulate data associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @param {HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   */
  modelForElement(el) {
    return __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["b" /* Templatize */].modelForElement(this.template, el);
  }

}

customElements.define(DomRepeat.is, DomRepeat);




/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomIf */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_async_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_path_js__ = __webpack_require__(11);







/**
 * The `<dom-if>` element will stamp a light-dom `<template>` child when
 * the `if` property becomes truthy, and the template can use Polymer
 * data-binding and declarative event features when used in the context of
 * a Polymer element's template.
 *
 * When `if` becomes falsey, the stamped content is hidden but not
 * removed from dom. When `if` subsequently becomes truthy again, the content
 * is simply re-shown. This approach is used due to its favorable performance
 * characteristics: the expense of creating template content is paid only
 * once and lazily.
 *
 * Set the `restamp` property to true to force the stamped content to be
 * created / destroyed when the `if` condition changes.
 *
 * @customElement
 * @polymer
 * @extends Polymer.Element
 * @memberof Polymer
 * @summary Custom element that conditionally stamps and hides or removes
 *   template content based on a boolean flag.
 */
class DomIf extends __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__["a" /* Element */] {

  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'dom-if'; }

  static get template() { return null; }

  static get properties() {

    return {

      /**
       * Fired whenever DOM is added or removed/hidden by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */

      /**
       * A boolean indicating whether this template should stamp.
       */
      if: {
        type: Boolean,
        observer: '__debounceRender'
      },

      /**
       * When true, elements will be removed from DOM and discarded when `if`
       * becomes false and re-created and added back to the DOM when `if`
       * becomes true.  By default, stamped elements will be hidden but left
       * in the DOM when `if` becomes false, which is generally results
       * in better performance.
       */
      restamp: {
        type: Boolean,
        observer: '__debounceRender'
      }

    };

  }

  constructor() {
    super();
    this.__renderDebouncer = null;
    this.__invalidProps = null;
    this.__instance = null;
    this._lastIf = false;
    this.__ctor = null;
  }

  __debounceRender() {
    // Render is async for 2 reasons:
    // 1. To eliminate dom creation trashing if user code thrashes `if` in the
    //    same turn. This was more common in 1.x where a compound computed
    //    property could result in the result changing multiple times, but is
    //    mitigated to a large extent by batched property processing in 2.x.
    // 2. To avoid double object propagation when a bag including values bound
    //    to the `if` property as well as one or more hostProps could enqueue
    //    the <dom-if> to flush before the <template>'s host property
    //    forwarding. In that scenario creating an instance would result in
    //    the host props being set once, and then the enqueued changes on the
    //    template would set properties a second time, potentially causing an
    //    object to be set to an instance more than once.  Creating the
    //    instance async from flushing data ensures this doesn't happen. If
    //    we wanted a sync option in the future, simply having <dom-if> flush
    //    (or clear) its template's pending host properties before creating
    //    the instance would also avoid the problem.
    this.__renderDebouncer = __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__["a" /* Debouncer */].debounce(
          this.__renderDebouncer
        , __WEBPACK_IMPORTED_MODULE_4__utils_async_js__["a" /* microTask */]
        , () => this.__render());
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["a" /* enqueueDebouncer */])(this.__renderDebouncer);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    if (!this.parentNode ||
        (this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&
         !this.parentNode.host)) {
      this.__teardownInstance();
    }
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.if) {
      this.__debounceRender();
    }
  }

  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   */
  render() {
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["b" /* flush */])();
  }

  __render() {
    if (this.if) {
      if (!this.__ensureInstance()) {
        // No template found yet
        return;
      }
      this._showHideChildren();
    } else if (this.restamp) {
      this.__teardownInstance();
    }
    if (!this.restamp && this.__instance) {
      this._showHideChildren();
    }
    if (this.if != this._lastIf) {
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
      this._lastIf = this.if;
    }
  }

  __ensureInstance() {
    let parentNode = this.parentNode;
    // Guard against element being detached while render was queued
    if (parentNode) {
      if (!this.__ctor) {
        let template = this.querySelector('template');
        if (!template) {
          // Wait until childList changes and template should be there by then
          let observer = new MutationObserver(() => {
            if (this.querySelector('template')) {
              observer.disconnect();
              this.__render();
            } else {
              throw new Error('dom-if requires a <template> child');
            }
          });
          observer.observe(this, {childList: true});
          return false;
        }
        this.__ctor = __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["b" /* Templatize */].templatize(template, this, {
          // dom-if templatizer instances require `mutable: true`, as
          // `__syncHostProperties` relies on that behavior to sync objects
          mutableData: true,
          /**
           * @param {string} prop Property to forward
           * @param {*} value Value of property
           * @this {this}
           */
          forwardHostProp: function(prop, value) {
            if (this.__instance) {
              if (this.if) {
                this.__instance.forwardHostProp(prop, value);
              } else {
                // If we have an instance but are squelching host property
                // forwarding due to if being false, note the invalidated
                // properties so `__syncHostProperties` can sync them the next
                // time `if` becomes true
                this.__invalidProps = this.__invalidProps || Object.create(null);
                this.__invalidProps[Object(__WEBPACK_IMPORTED_MODULE_5__utils_path_js__["g" /* root */])(prop)] = true;
              }
            }
          }
        });
      }
      if (!this.__instance) {
        this.__instance = new this.__ctor();
        parentNode.insertBefore(this.__instance.root, this);
      } else {
        this.__syncHostProperties();
        let c$ = this.__instance.children;
        if (c$ && c$.length) {
          // Detect case where dom-if was re-attached in new position
          let lastChild = this.previousSibling;
          if (lastChild !== c$[c$.length-1]) {
            for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
              parentNode.insertBefore(n, this);
            }
          }
        }
      }
    }
    return true;
  }

  __syncHostProperties() {
    let props = this.__invalidProps;
    if (props) {
      for (let prop in props) {
        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
      }
      this.__invalidProps = null;
      this.__instance._flushProperties();
    }
  }

  __teardownInstance() {
    if (this.__instance) {
      let c$ = this.__instance.children;
      if (c$ && c$.length) {
        // use first child parent, for case when dom-if may have been detached
        let parent = c$[0].parentNode;
        for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
          parent.removeChild(n);
        }
      }
      this.__instance = null;
      this.__invalidProps = null;
    }
  }

  _showHideChildren() {
    let hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance) {
      this.__instance._showHideChildren(hidden);
    }
  }

}

customElements.define(DomIf.is, DomIf);




/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ArraySelectorMixin */
/* unused harmony export ArraySelector */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_array_splice_js__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mixins_element_mixin_js__ = __webpack_require__(24);





/**
 * Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array such that path changes to the
 * master array (at the host) element or elsewhere via data-binding) are
 * correctly propagated to items in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * @polymer
 * @mixinFunction
 * @appliesMixin Polymer.ElementMixin
 * @memberof Polymer
 * @summary Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array
 */
let ArraySelectorMixin = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_ElementMixin}
   */
  let elementBase = Object(__WEBPACK_IMPORTED_MODULE_3__mixins_element_mixin_js__["a" /* ElementMixin */])(superClass);

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_ArraySelectorMixin}
   * @unrestricted
   */
  class ArraySelectorMixin extends elementBase {

    static get properties() {

      return {

        /**
         * An array containing items from which selection will be made.
         */
        items: {
          type: Array,
        },

        /**
         * When `true`, multiple items may be selected at once (in this case,
         * `selected` is an array of currently selected items).  When `false`,
         * only one item may be selected at a time.
         */
        multi: {
          type: Boolean,
          value: false,
        },

        /**
         * When `multi` is true, this is an array that contains any selected.
         * When `multi` is false, this is the currently selected item, or `null`
         * if no item is selected.
         * @type {?(Object|Array<!Object>)}
         */
        selected: {
          type: Object,
          notify: true
        },

        /**
         * When `multi` is false, this is the currently selected item, or `null`
         * if no item is selected.
         * @type {?Object}
         */
        selectedItem: {
          type: Object,
          notify: true
        },

        /**
         * When `true`, calling `select` on an item that is already selected
         * will deselect the item.
         */
        toggle: {
          type: Boolean,
          value: false
        }

      };
    }

    static get observers() {
      return ['__updateSelection(multi, items.*)'];
    }

    constructor() {
      super();
      this.__lastItems = null;
      this.__lastMulti = null;
      this.__selectedMap = null;
    }

    __updateSelection(multi, itemsInfo) {
      let path = itemsInfo.path;
      if (path == 'items') {
        // Case 1 - items array changed, so diff against previous array and
        // deselect any removed items and adjust selected indices
        let newItems = itemsInfo.base || [];
        let lastItems = this.__lastItems;
        let lastMulti = this.__lastMulti;
        if (multi !== lastMulti) {
          this.clearSelection();
        }
        if (lastItems) {
          let splices = Object(__WEBPACK_IMPORTED_MODULE_2__utils_array_splice_js__["a" /* calculateSplices */])(newItems, lastItems);
          this.__applySplices(splices);
        }
        this.__lastItems = newItems;
        this.__lastMulti = multi;
      } else if (itemsInfo.path == 'items.splices') {
        // Case 2 - got specific splice information describing the array mutation:
        // deselect any removed items and adjust selected indices
        this.__applySplices(itemsInfo.value.indexSplices);
      } else {
        // Case 3 - an array element was changed, so deselect the previous
        // item for that index if it was previously selected
        let part = path.slice('items.'.length);
        let idx = parseInt(part, 10);
        if ((part.indexOf('.') < 0) && part == idx) {
          this.__deselectChangedIdx(idx);
        }
      }
    }

    __applySplices(splices) {
      let selected = this.__selectedMap;
      // Adjust selected indices and mark removals
      for (let i=0; i<splices.length; i++) {
        let s = splices[i];
        selected.forEach((idx, item) => {
          if (idx < s.index) {
            // no change
          } else if (idx >= s.index + s.removed.length) {
            // adjust index
            selected.set(item, idx + s.addedCount - s.removed.length);
          } else {
            // remove index
            selected.set(item, -1);
          }
        });
        for (let j=0; j<s.addedCount; j++) {
          let idx = s.index + j;
          if (selected.has(this.items[idx])) {
            selected.set(this.items[idx], idx);
          }
        }
      }
      // Update linked paths
      this.__updateLinks();
      // Remove selected items that were removed from the items array
      let sidx = 0;
      selected.forEach((idx, item) => {
        if (idx < 0) {
          if (this.multi) {
            this.splice('selected', sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
          selected.delete(item);
        } else {
          sidx++;
        }
      });
    }

    __updateLinks() {
      this.__dataLinkedPaths = {};
      if (this.multi) {
        let sidx = 0;
        this.__selectedMap.forEach(idx => {
          if (idx >= 0) {
            this.linkPaths('items.' + idx, 'selected.' + sidx++);
          }
        });
      } else {
        this.__selectedMap.forEach(idx => {
          this.linkPaths('selected', 'items.' + idx);
          this.linkPaths('selectedItem', 'items.' + idx);
        });
      }
    }

    /**
     * Clears the selection state.
     *
     */
    clearSelection() {
      // Unbind previous selection
      this.__dataLinkedPaths = {};
      // The selected map stores 3 pieces of information:
      // key: items array object
      // value: items array index
      // order: selected array index
      this.__selectedMap = new Map();
      // Initialize selection
      this.selected = this.multi ? [] : null;
      this.selectedItem = null;
    }

    /**
     * Returns whether the item is currently selected.
     *
     * @param {*} item Item from `items` array to test
     * @return {boolean} Whether the item is selected
     */
    isSelected(item) {
      return this.__selectedMap.has(item);
    }

    /**
     * Returns whether the item is currently selected.
     *
     * @param {number} idx Index from `items` array to test
     * @return {boolean} Whether the item is selected
     */
    isIndexSelected(idx) {
      return this.isSelected(this.items[idx]);
    }

    __deselectChangedIdx(idx) {
      let sidx = this.__selectedIndexForItemIndex(idx);
      if (sidx >= 0) {
        let i = 0;
        this.__selectedMap.forEach((idx, item) => {
          if (sidx == i++) {
            this.deselect(item);
          }
        });
      }
    }

    __selectedIndexForItemIndex(idx) {
      let selected = this.__dataLinkedPaths['items.' + idx];
      if (selected) {
        return parseInt(selected.slice('selected.'.length), 10);
      }
    }

    /**
     * Deselects the given item if it is already selected.
     *
     * @param {*} item Item from `items` array to deselect
     */
    deselect(item) {
      let idx = this.__selectedMap.get(item);
      if (idx >= 0) {
        this.__selectedMap.delete(item);
        let sidx;
        if (this.multi) {
          sidx = this.__selectedIndexForItemIndex(idx);
        }
        this.__updateLinks();
        if (this.multi) {
          this.splice('selected', sidx, 1);
        } else {
          this.selected = this.selectedItem = null;
        }
      }
    }

    /**
     * Deselects the given index if it is already selected.
     *
     * @param {number} idx Index from `items` array to deselect
     */
    deselectIndex(idx) {
      this.deselect(this.items[idx]);
    }

    /**
     * Selects the given item.  When `toggle` is true, this will automatically
     * deselect the item if already selected.
     *
     * @param {*} item Item from `items` array to select
     */
    select(item) {
      this.selectIndex(this.items.indexOf(item));
    }

    /**
     * Selects the given index.  When `toggle` is true, this will automatically
     * deselect the item if already selected.
     *
     * @param {number} idx Index from `items` array to select
     */
    selectIndex(idx) {
      let item = this.items[idx];
      if (!this.isSelected(item)) {
        if (!this.multi) {
          this.__selectedMap.clear();
        }
        this.__selectedMap.set(item, idx);
        this.__updateLinks();
        if (this.multi) {
          this.push('selected', item);
        } else {
          this.selected = this.selectedItem = item;
        }
      } else if (this.toggle) {
        this.deselectIndex(idx);
      }
    }

  }

  return ArraySelectorMixin;

});



/**
 * @constructor
 * @extends {Polymer.Element}
 * @implements {Polymer_ArraySelectorMixin}
 */
let baseArraySelector = ArraySelectorMixin(__WEBPACK_IMPORTED_MODULE_0__polymer_element_js__["a" /* Element */]);

/**
 * Element implementing the `Polymer.ArraySelector` mixin, which records
 * dynamic associations between item paths in a master `items` array and a
 * `selected` array such that path changes to the master array (at the host)
 * element or elsewhere via data-binding) are correctly propagated to items
 * in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *         <button on-click="toggleSelection">Select</button>
 *     </template>
 *
 *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
 *
 *     <div> Selected employees: </div>
 *     <template is="dom-repeat" items="{{selected}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 * </dom-module>
 * ```
 *
 * ```js
 * Polymer({
 *   is: 'employee-list',
 *   ready() {
 *     this.employees = [
 *         {first: 'Bob', last: 'Smith'},
 *         {first: 'Sally', last: 'Johnson'},
 *         ...
 *     ];
 *   },
 *   toggleSelection(e) {
 *     let item = this.$.employeeList.itemForElement(e.target);
 *     this.$.selector.select(item);
 *   }
 * });
 * ```
 *
 * @polymer
 * @customElement
 * @extends {baseArraySelector}
 * @appliesMixin Polymer.ArraySelectorMixin
 * @memberof Polymer
 * @summary Custom element that links paths between an input `items` array and
 *   an output `selected` item or array based on calls to its selection API.
 */
class ArraySelector extends baseArraySelector {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'array-selector'; }
}
customElements.define(ArraySelector.is, ArraySelector);



/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CustomStyle */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_shadycss_entrypoints_custom_style_interface_js__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_style_gather_js__ = __webpack_require__(38);



const attr = 'include';

const CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

/**
 * Custom element for defining styles in the main document that can take
 * advantage of [shady DOM](https://github.com/webcomponents/shadycss) shims
 * for style encapsulation, custom properties, and custom mixins.
 *
 * - Document styles defined in a `<custom-style>` are shimmed to ensure they
 *   do not leak into local DOM when running on browsers without native
 *   Shadow DOM.
 * - Custom properties can be defined in a `<custom-style>`. Use the `html` selector
 *   to define custom properties that apply to all custom elements.
 * - Custom mixins can be defined in a `<custom-style>`, if you import the optional
 *   [apply shim](https://github.com/webcomponents/shadycss#about-applyshim)
 *   (`shadycss/apply-shim.html`).
 *
 * To use:
 *
 * - Import `custom-style.html`.
 * - Place a `<custom-style>` element in the main document, wrapping an inline `<style>` tag that
 *   contains the CSS rules you want to shim.
 *
 * For example:
 *
 * ```
 * <!-- import apply shim--only required if using mixins -->
 * <link rel="import href="bower_components/shadycss/apply-shim.html">
 * <!-- import custom-style element -->
 * <link rel="import" href="bower_components/polymer/lib/elements/custom-style.html">
 * ...
 * <custom-style>
 *   <style>
 *     html {
 *       --custom-color: blue;
 *       --custom-mixin: {
 *         font-weight: bold;
 *         color: red;
 *       };
 *     }
 *   </style>
 * </custom-style>
 * ```
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element for defining styles in the main document that can
 *   take advantage of Polymer's style scoping and custom properties shims.
 */
class CustomStyle extends HTMLElement {
  constructor() {
    super();
    this._style = null;
    CustomStyleInterface.addCustomStyle(this);
  }
  /**
   * Returns the light-DOM `<style>` child this element wraps.  Upon first
   * call any style modules referenced via the `include` attribute will be
   * concatenated to this element's `<style>`.
   *
   * @return {HTMLStyleElement} This element's light-DOM `<style>`
   */
  getStyle() {
    if (this._style) {
      return this._style;
    }
    const style = /** @type {HTMLStyleElement} */(this.querySelector('style'));
    if (!style) {
      return null;
    }
    this._style = style;
    const include = style.getAttribute(attr);
    if (include) {
      style.removeAttribute(attr);
      style.textContent = Object(__WEBPACK_IMPORTED_MODULE_1__utils_style_gather_js__["b" /* cssFromModules */])(include) + style.textContent;
    }
    return this._style;
  }
}

window.customElements.define('custom-style', CustomStyle);



/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_custom_style_interface_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_style_settings_js__ = __webpack_require__(20);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/







const customStyleInterface = new __WEBPACK_IMPORTED_MODULE_0__src_custom_style_interface_js__["a" /* default */]();

if (!window.ShadyCSS) {
  window.ShadyCSS = {
    /**
     * @param {HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate(template, elementName, elementExtends) {}, // eslint-disable-line no-unused-vars

    /**
     * @param {Element} element
     * @param {Object=} properties
     */
    styleSubtree(element, properties) {
      customStyleInterface.processStyles();
      Object(__WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__["c" /* updateNativeProperties */])(element, properties);
    },

    /**
     * @param {Element} element
     */
    styleElement(element) { // eslint-disable-line no-unused-vars
      customStyleInterface.processStyles();
    },

    /**
     * @param {Object=} properties
     */
    styleDocument(properties) {
      customStyleInterface.processStyles();
      Object(__WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__["c" /* updateNativeProperties */])(document.body, properties);
    },

    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue(element, property) {
      return Object(__WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__["b" /* getComputedStyleValue */])(element, property);
    },
    nativeCss: __WEBPACK_IMPORTED_MODULE_2__src_style_settings_js__["a" /* nativeCssVariables */],
    nativeShadow: __WEBPACK_IMPORTED_MODULE_2__src_style_settings_js__["b" /* nativeShadow */]
  }
}

window.ShadyCSS.CustomStyleInterface = customStyleInterface;

/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixins_mutable_data_js__ = __webpack_require__(14);


let mutablePropertyChange;
(
  /** @suppress {missingProperties} */
  (function() {
  mutablePropertyChange = __WEBPACK_IMPORTED_MODULE_0__mixins_mutable_data_js__["a" /* MutableData */]._mutablePropertyChange;
}))();

const MutableDataBehavior = {

  /**
   * Overrides `Polymer.PropertyEffects` to provide option for skipping
   * strict equality checking for Objects and Arrays.
   *
   * This method pulls the value to dirty check against from the `__dataTemp`
   * cache (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @protected
   */
  _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, true);
  }
};
/* unused harmony export MutableDataBehavior */


const OptionalMutableDataBehavior = {

  properties: {
    /**
     * Instance-level flag for configuring the dirty-checking strategy
     * for this element.  When true, Objects and Arrays will skip dirty
     * checking, otherwise strict equality checking will be used.
     */
    mutableData: Boolean
  },

  /**
   * Overrides `Polymer.PropertyEffects` to skip strict equality checking
   * for Objects and Arrays.
   *
   * Pulls the value to dirty check against from the `__dataTemp` cache
   * (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @this {this}
   * @protected
   */
  _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, this.mutableData);
  }
};
/* unused harmony export OptionalMutableDataBehavior */



/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__neon_animation_neon_animation_runner_behavior_js__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_dialog_behavior_paper_dialog_behavior_js__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_dialog_behavior_paper_dialog_shared_styles_js__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);






Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style include="paper-dialog-shared-styles"></style>
    <slot></slot>
`,

  is: 'paper-dialog',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_dialog_behavior_paper_dialog_behavior_js__["a" /* PaperDialogBehavior */],
    __WEBPACK_IMPORTED_MODULE_1__neon_animation_neon_animation_runner_behavior_js__["a" /* NeonAnimationRunnerBehavior */]
  ],

  listeners: {
    'neon-animation-finish': '_onNeonAnimationFinish'
  },

  _renderOpened: function() {
    this.cancelAnimation();
    this.playAnimation('entry');
  },

  _renderClosed: function() {
    this.cancelAnimation();
    this.playAnimation('exit');
  },

  _onNeonAnimationFinish: function() {
    if (this.opened) {
      this._finishRenderOpened();
    } else {
      this._finishRenderClosed();
    }
  }
});


/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__neon_animatable_behavior_js__ = __webpack_require__(73);



const NeonAnimationRunnerBehaviorImpl = {

  _configureAnimations: function(configs) {
    var results = [];
    if (configs.length > 0) {
      for (var config, index = 0; config = configs[index]; index++) {
        var neonAnimation = document.createElement(config.name);
        // is this element actually a neon animation?
        if (neonAnimation.isNeonAnimation) {
          var result = null;
          // configuration or play could fail if polyfills aren't loaded
          try {
            result = neonAnimation.configure(config);
            // Check if we have an Effect rather than an Animation
            if (typeof result.cancel != 'function') {
              result = document.timeline.play(result);
            }
          } catch (e) {
            result = null;
            console.warn('Couldnt play', '(', config.name, ').', e);
          }
          if (result) {
            results.push({
              neonAnimation: neonAnimation,
              config: config,
              animation: result,
            });
          }
        } else {
          console.warn(this.is + ':', config.name, 'not found!');
        }
      }
    }
    return results;
  },

  _shouldComplete: function(activeEntries) {
    var finished = true;
    for (var i = 0; i < activeEntries.length; i++) {
      if (activeEntries[i].animation.playState != 'finished') {
        finished = false;
        break;
      }
    }
    return finished;
  },

  _complete: function(activeEntries) {
    for (var i = 0; i < activeEntries.length; i++) {
      activeEntries[i].neonAnimation.complete(activeEntries[i].config);
    }
    for (var i = 0; i < activeEntries.length; i++) {
      activeEntries[i].animation.cancel();
    }
  },

  /**
   * Plays an animation with an optional `type`.
   * @param {string=} type
   * @param {!Object=} cookie
   */
  playAnimation: function(type, cookie) {
    var configs = this.getAnimationConfig(type);
    if (!configs) {
      return;
    }
    this._active = this._active || {};
    if (this._active[type]) {
      this._complete(this._active[type]);
      delete this._active[type];
    }

    var activeEntries = this._configureAnimations(configs);

    if (activeEntries.length == 0) {
      this.fire('neon-animation-finish', cookie, {bubbles: false});
      return;
    }

    this._active[type] = activeEntries;

    for (var i = 0; i < activeEntries.length; i++) {
      activeEntries[i].animation.onfinish = function() {
        if (this._shouldComplete(activeEntries)) {
          this._complete(activeEntries);
          delete this._active[type];
          this.fire('neon-animation-finish', cookie, {bubbles: false});
        }
      }.bind(this);
    }
  },

  /**
   * Cancels the currently running animations.
   */
  cancelAnimation: function() {
    for (var k in this._animations) {
      this._animations[k].cancel();
    }
    this._animations = {};
  }
};
/* unused harmony export NeonAnimationRunnerBehaviorImpl */


const NeonAnimationRunnerBehavior = [
  __WEBPACK_IMPORTED_MODULE_1__neon_animatable_behavior_js__["a" /* NeonAnimatableBehavior */],
  NeonAnimationRunnerBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = NeonAnimationRunnerBehavior;



/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);


const NeonAnimatableBehavior = {

  properties: {

    /**
     * Animation configuration. See README for more info.
     */
    animationConfig: {
      type: Object
    },

    /**
     * Convenience property for setting an 'entry' animation. Do not set `animationConfig.entry`
     * manually if using this. The animated node is set to `this` if using this property.
     */
    entryAnimation: {
      observer: '_entryAnimationChanged',
      type: String
    },

    /**
     * Convenience property for setting an 'exit' animation. Do not set `animationConfig.exit`
     * manually if using this. The animated node is set to `this` if using this property.
     */
    exitAnimation: {
      observer: '_exitAnimationChanged',
      type: String
    }

  },

  _entryAnimationChanged: function() {
    this.animationConfig = this.animationConfig || {};
    this.animationConfig['entry'] = [{
      name: this.entryAnimation,
      node: this
    }];
  },

  _exitAnimationChanged: function() {
    this.animationConfig = this.animationConfig || {};
    this.animationConfig['exit'] = [{
      name: this.exitAnimation,
      node: this
    }];
  },

  _copyProperties: function(config1, config2) {
    // shallowly copy properties from config2 to config1
    for (var property in config2) {
      config1[property] = config2[property];
    }
  },

  _cloneConfig: function(config) {
    var clone = {
      isClone: true
    };
    this._copyProperties(clone, config);
    return clone;
  },

  _getAnimationConfigRecursive: function(type, map, allConfigs) {
    if (!this.animationConfig) {
      return;
    }

    if(this.animationConfig.value && typeof this.animationConfig.value === 'function') {
      this._warn(this._logf('playAnimation', "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
      return;
    }

    // type is optional
    var thisConfig;
    if (type) {
      thisConfig = this.animationConfig[type];
    } else {
      thisConfig = this.animationConfig;
    }

    if (!Array.isArray(thisConfig)) {
      thisConfig = [thisConfig];
    }

    // iterate animations and recurse to process configurations from child nodes
    if (thisConfig) {
      for (var config, index = 0; config = thisConfig[index]; index++) {
        if (config.animatable) {
          config.animatable._getAnimationConfigRecursive(config.type || type, map, allConfigs);
        } else {
          if (config.id) {
            var cachedConfig = map[config.id];
            if (cachedConfig) {
              // merge configurations with the same id, making a clone lazily
              if (!cachedConfig.isClone) {
                map[config.id] = this._cloneConfig(cachedConfig);
                cachedConfig = map[config.id];
              }
              this._copyProperties(cachedConfig, config);
            } else {
              // put any configs with an id into a map
              map[config.id] = config;
            }
          } else {
            allConfigs.push(config);
          }
        }
      }
    }
  },

  /**
   * An element implementing `Polymer.NeonAnimationRunnerBehavior` calls this method to configure
   * an animation with an optional type. Elements implementing `Polymer.NeonAnimatableBehavior`
   * should define the property `animationConfig`, which is either a configuration object
   * or a map of animation type to array of configuration objects.
   */
  getAnimationConfig: function(type) {
    var map = {};
    var allConfigs = [];
    this._getAnimationConfigRecursive(type, map, allConfigs);
    // append the configurations saved in the map to the array
    for (var key in map) {
      allConfigs.push(map[key]);
    }
    return allConfigs;
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = NeonAnimatableBehavior;



/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_overlay_behavior_iron_overlay_behavior_js__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




const PaperDialogBehaviorImpl = {

  hostAttributes: {
    'role': 'dialog',
    'tabindex': '-1'
  },

  properties: {

    /**
     * If `modal` is true, this implies `no-cancel-on-outside-click`, `no-cancel-on-esc-key` and `with-backdrop`.
     */
    modal: {
      type: Boolean,
      value: false
    },

    __readied: {
      type: Boolean,
      value: false
    }

  },

  observers: [
    '_modalChanged(modal, __readied)'
  ],

  listeners: {
    'tap': '_onDialogClick'
  },

  ready: function() {
    // Only now these properties can be read.
    this.__prevNoCancelOnOutsideClick = this.noCancelOnOutsideClick;
    this.__prevNoCancelOnEscKey = this.noCancelOnEscKey;
    this.__prevWithBackdrop = this.withBackdrop;
    this.__readied = true;
  },

  _modalChanged: function(modal, readied) {
    // modal implies noCancelOnOutsideClick, noCancelOnEscKey and withBackdrop.
    // We need to wait for the element to be ready before we can read the
    // properties values.
    if (!readied) {
      return;
    }

    if (modal) {
      this.__prevNoCancelOnOutsideClick = this.noCancelOnOutsideClick;
      this.__prevNoCancelOnEscKey = this.noCancelOnEscKey;
      this.__prevWithBackdrop = this.withBackdrop;
      this.noCancelOnOutsideClick = true;
      this.noCancelOnEscKey = true;
      this.withBackdrop = true;
    } else {
      // If the value was changed to false, let it false.
      this.noCancelOnOutsideClick = this.noCancelOnOutsideClick &&
        this.__prevNoCancelOnOutsideClick;
      this.noCancelOnEscKey = this.noCancelOnEscKey &&
        this.__prevNoCancelOnEscKey;
      this.withBackdrop = this.withBackdrop && this.__prevWithBackdrop;
    }
  },

  _updateClosingReasonConfirmed: function(confirmed) {
    this.closingReason = this.closingReason || {};
    this.closingReason.confirmed = confirmed;
  },

  /**
   * Will dismiss the dialog if user clicked on an element with dialog-dismiss
   * or dialog-confirm attribute.
   */
  _onDialogClick: function(event) {
    // Search for the element with dialog-confirm or dialog-dismiss,
    // from the root target until this (excluded).
    var path = Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).path;
    for (var i = 0, l = path.indexOf(this); i < l; i++) {
      var target = path[i];
      if (target.hasAttribute && (target.hasAttribute('dialog-dismiss') || target.hasAttribute('dialog-confirm'))) {
        this._updateClosingReasonConfirmed(target.hasAttribute('dialog-confirm'));
        this.close();
        event.stopPropagation();
        break;
      }
    }
  }

};
/* unused harmony export PaperDialogBehaviorImpl */


const PaperDialogBehavior = [__WEBPACK_IMPORTED_MODULE_1__iron_overlay_behavior_iron_overlay_behavior_js__["a" /* IronOverlayBehavior */], PaperDialogBehaviorImpl];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperDialogBehavior;



/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_fit_behavior_iron_fit_behavior_js__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_resizable_behavior_iron_resizable_behavior_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__iron_overlay_manager_js__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__iron_focusables_helper_js__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);







const IronOverlayBehaviorImpl = {

  properties: {

    /**
     * True if the overlay is currently displayed.
     */
    opened: {
      observer: '_openedChanged',
      type: Boolean,
      value: false,
      notify: true
    },

    /**
     * True if the overlay was canceled when it was last closed.
     */
    canceled: {
      observer: '_canceledChanged',
      readOnly: true,
      type: Boolean,
      value: false
    },

    /**
     * Set to true to display a backdrop behind the overlay. It traps the focus
     * within the light DOM of the overlay.
     */
    withBackdrop: {
      observer: '_withBackdropChanged',
      type: Boolean
    },

    /**
     * Set to true to disable auto-focusing the overlay or child nodes with
     * the `autofocus` attribute` when the overlay is opened.
     */
    noAutoFocus: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to disable canceling the overlay with the ESC key.
     */
    noCancelOnEscKey: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to disable canceling the overlay by clicking outside it.
     */
    noCancelOnOutsideClick: {
      type: Boolean,
      value: false
    },

    /**
     * Contains the reason(s) this overlay was last closed (see `iron-overlay-closed`).
     * `IronOverlayBehavior` provides the `canceled` reason; implementers of the
     * behavior can provide other reasons in addition to `canceled`.
     */
    closingReason: {
      // was a getter before, but needs to be a property so other
      // behaviors can override this.
      type: Object
    },

    /**
     * Set to true to enable restoring of focus when overlay is closed.
     */
    restoreFocusOnClose: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to keep overlay always on top.
     */
    alwaysOnTop: {
      type: Boolean
    },

    /**
     * Shortcut to access to the overlay manager.
     * @private
     * @type {Polymer.IronOverlayManagerClass}
     */
    _manager: {
      type: Object,
      value: __WEBPACK_IMPORTED_MODULE_3__iron_overlay_manager_js__["a" /* IronOverlayManager */]
    },

    /**
     * The node being focused.
     * @type {?Node}
     */
    _focusedChild: {
      type: Object
    }

  },

  listeners: {
    'iron-resize': '_onIronResize'
  },

  /**
   * The backdrop element.
   * @type {Element}
   */
  get backdropElement() {
    return this._manager.backdropElement;
  },

  /**
   * Returns the node to give focus to.
   * @type {Node}
   */
  get _focusNode() {
    return this._focusedChild || Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).querySelector('[autofocus]') || this;
  },

  /**
   * Array of nodes that can receive focus (overlay included), ordered by `tabindex`.
   * This is used to retrieve which is the first and last focusable nodes in order
   * to wrap the focus for overlays `with-backdrop`.
   *
   * If you know what is your content (specifically the first and last focusable children),
   * you can override this method to return only `[firstFocusable, lastFocusable];`
   * @type {Array<Node>}
   * @protected
   */
  get _focusableNodes() {
    return __WEBPACK_IMPORTED_MODULE_4__iron_focusables_helper_js__["a" /* IronFocusablesHelper */].getTabbableNodes(this);
  },

  ready: function() {
    // Used to skip calls to notifyResize and refit while the overlay is animating.
    this.__isAnimating = false;
    // with-backdrop needs tabindex to be set in order to trap the focus.
    // If it is not set, IronOverlayBehavior will set it, and remove it if with-backdrop = false.
    this.__shouldRemoveTabIndex = false;
    // Used for wrapping the focus on TAB / Shift+TAB.
    this.__firstFocusableNode = this.__lastFocusableNode = null;
    // Used by __onNextAnimationFrame to cancel any previous callback.
    this.__raf = null;
    // Focused node before overlay gets opened. Can be restored on close.
    this.__restoreFocusNode = null;
    this._ensureSetup();
  },

  attached: function() {
    // Call _openedChanged here so that position can be computed correctly.
    if (this.opened) {
      this._openedChanged(this.opened);
    }
    this._observer = Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).observeNodes(this._onNodesChange);
  },

  detached: function() {
    Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).unobserveNodes(this._observer);
    this._observer = null;
    if (this.__raf) {
      window.cancelAnimationFrame(this.__raf);
      this.__raf = null;
    }
    this._manager.removeOverlay(this);
  },

  /**
   * Toggle the opened state of the overlay.
   */
  toggle: function() {
    this._setCanceled(false);
    this.opened = !this.opened;
  },

  /**
   * Open the overlay.
   */
  open: function() {
    this._setCanceled(false);
    this.opened = true;
  },

  /**
   * Close the overlay.
   */
  close: function() {
    this._setCanceled(false);
    this.opened = false;
  },

  /**
   * Cancels the overlay.
   * @param {Event=} event The original event
   */
  cancel: function(event) {
    var cancelEvent = this.fire('iron-overlay-canceled', event, {cancelable: true});
    if (cancelEvent.defaultPrevented) {
      return;
    }

    this._setCanceled(true);
    this.opened = false;
  },

  /**
   * Invalidates the cached tabbable nodes. To be called when any of the focusable
   * content changes (e.g. a button is disabled).
   */
  invalidateTabbables: function() {
    this.__firstFocusableNode = this.__lastFocusableNode = null;
  },

  _ensureSetup: function() {
    if (this._overlaySetup) {
      return;
    }
    this._overlaySetup = true;
    this.style.outline = 'none';
    this.style.display = 'none';
  },

  /**
   * Called when `opened` changes.
   * @param {boolean=} opened
   * @protected
   */
  _openedChanged: function(opened) {
    if (opened) {
      this.removeAttribute('aria-hidden');
    } else {
      this.setAttribute('aria-hidden', 'true');
    }

    // Defer any animation-related code on attached
    // (_openedChanged gets called again on attached).
    if (!this.isAttached) {
      return;
    }

    this.__isAnimating = true;

    // Use requestAnimationFrame for non-blocking rendering.
    this.__onNextAnimationFrame(this.__openedChanged);
  },

  _canceledChanged: function() {
    this.closingReason = this.closingReason || {};
    this.closingReason.canceled = this.canceled;
  },

  _withBackdropChanged: function() {
    // If tabindex is already set, no need to override it.
    if (this.withBackdrop && !this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '-1');
      this.__shouldRemoveTabIndex = true;
    } else if (this.__shouldRemoveTabIndex) {
      this.removeAttribute('tabindex');
      this.__shouldRemoveTabIndex = false;
    }
    if (this.opened && this.isAttached) {
      this._manager.trackBackdrop();
    }
  },

  /**
   * tasks which must occur before opening; e.g. making the element visible.
   * @protected
   */
  _prepareRenderOpened: function() {
    // Store focused node.
    this.__restoreFocusNode = this._manager.deepActiveElement;

    // Needed to calculate the size of the overlay so that transitions on its size
    // will have the correct starting points.
    this._preparePositioning();
    this.refit();
    this._finishPositioning();

    // Safari will apply the focus to the autofocus element when displayed
    // for the first time, so we make sure to return the focus where it was.
    if (this.noAutoFocus && document.activeElement === this._focusNode) {
      this._focusNode.blur();
      this.__restoreFocusNode.focus();
    }
  },

  /**
   * Tasks which cause the overlay to actually open; typically play an animation.
   * @protected
   */
  _renderOpened: function() {
    this._finishRenderOpened();
  },

  /**
   * Tasks which cause the overlay to actually close; typically play an animation.
   * @protected
   */
  _renderClosed: function() {
    this._finishRenderClosed();
  },

  /**
   * Tasks to be performed at the end of open action. Will fire `iron-overlay-opened`.
   * @protected
   */
  _finishRenderOpened: function() {
    this.notifyResize();
    this.__isAnimating = false;

    this.fire('iron-overlay-opened');
  },

  /**
   * Tasks to be performed at the end of close action. Will fire `iron-overlay-closed`.
   * @protected
   */
  _finishRenderClosed: function() {
    // Hide the overlay.
    this.style.display = 'none';
    // Reset z-index only at the end of the animation.
    this.style.zIndex = '';
    this.notifyResize();
    this.__isAnimating = false;
    this.fire('iron-overlay-closed', this.closingReason);
  },

  _preparePositioning: function() {
    this.style.transition = this.style.webkitTransition = 'none';
    this.style.transform = this.style.webkitTransform = 'none';
    this.style.display = '';
  },

  _finishPositioning: function() {
    // First, make it invisible & reactivate animations.
    this.style.display = 'none';
    // Force reflow before re-enabling animations so that they don't start.
    // Set scrollTop to itself so that Closure Compiler doesn't remove this.
    this.scrollTop = this.scrollTop;
    this.style.transition = this.style.webkitTransition = '';
    this.style.transform = this.style.webkitTransform = '';
    // Now that animations are enabled, make it visible again
    this.style.display = '';
    // Force reflow, so that following animations are properly started.
    // Set scrollTop to itself so that Closure Compiler doesn't remove this.
    this.scrollTop = this.scrollTop;
  },

  /**
   * Applies focus according to the opened state.
   * @protected
   */
  _applyFocus: function() {
    if (this.opened) {
      if (!this.noAutoFocus) {
        this._focusNode.focus();
      }
    }
    else {
      this._focusNode.blur();
      this._focusedChild = null;
      // Restore focus.
      if (this.restoreFocusOnClose && this.__restoreFocusNode) {
        this.__restoreFocusNode.focus();
      }
      this.__restoreFocusNode = null;
      // If many overlays get closed at the same time, one of them would still
      // be the currentOverlay even if already closed, and would call _applyFocus
      // infinitely, so we check for this not to be the current overlay.
      var currentOverlay = this._manager.currentOverlay();
      if (currentOverlay && this !== currentOverlay) {
        currentOverlay._applyFocus();
      }
    }
  },

  /**
   * Cancels (closes) the overlay. Call when click happens outside the overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureClick: function(event) {
    if (!this.noCancelOnOutsideClick) {
      this.cancel(event);
    }
  },

  /**
   * Keeps track of the focused child. If withBackdrop, traps focus within overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureFocus: function (event) {
    if (!this.withBackdrop) {
      return;
    }
    var path = Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).path;
    if (path.indexOf(this) === -1) {
      event.stopPropagation();
      this._applyFocus();
    } else {
      this._focusedChild = path[0];
    }
  },

  /**
   * Handles the ESC key event and cancels (closes) the overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureEsc: function(event) {
    if (!this.noCancelOnEscKey) {
      this.cancel(event);
    }
  },

  /**
   * Handles TAB key events to track focus changes.
   * Will wrap focus for overlays withBackdrop.
   * @param {!Event} event
   * @protected
   */
  _onCaptureTab: function(event) {
    if (!this.withBackdrop) {
      return;
    }
    this.__ensureFirstLastFocusables();
    // TAB wraps from last to first focusable.
    // Shift + TAB wraps from first to last focusable.
    var shift = event.shiftKey;
    var nodeToCheck = shift ? this.__firstFocusableNode : this.__lastFocusableNode;
    var nodeToSet = shift ? this.__lastFocusableNode : this.__firstFocusableNode;
    var shouldWrap = false;
    if (nodeToCheck === nodeToSet) {
      // If nodeToCheck is the same as nodeToSet, it means we have an overlay
      // with 0 or 1 focusables; in either case we still need to trap the
      // focus within the overlay.
      shouldWrap = true;
    } else {
      // In dom=shadow, the manager will receive focus changes on the main
      // root but not the ones within other shadow roots, so we can't rely on
      // _focusedChild, but we should check the deepest active element.
      var focusedNode = this._manager.deepActiveElement;
      // If the active element is not the nodeToCheck but the overlay itself,
      // it means the focus is about to go outside the overlay, hence we
      // should prevent that (e.g. user opens the overlay and hit Shift+TAB).
      shouldWrap = (focusedNode === nodeToCheck || focusedNode === this);
    }

    if (shouldWrap) {
      // When the overlay contains the last focusable element of the document
      // and it's already focused, pressing TAB would move the focus outside
      // the document (e.g. to the browser search bar). Similarly, when the
      // overlay contains the first focusable element of the document and it's
      // already focused, pressing Shift+TAB would move the focus outside the
      // document (e.g. to the browser search bar).
      // In both cases, we would not receive a focus event, but only a blur.
      // In order to achieve focus wrapping, we prevent this TAB event and
      // force the focus. This will also prevent the focus to temporarily move
      // outside the overlay, which might cause scrolling.
      event.preventDefault();
      this._focusedChild = nodeToSet;
      this._applyFocus();
    }
  },

  /**
   * Refits if the overlay is opened and not animating.
   * @protected
   */
  _onIronResize: function() {
    if (this.opened && !this.__isAnimating) {
      this.__onNextAnimationFrame(this.refit);
    }
  },

  /**
   * Will call notifyResize if overlay is opened.
   * Can be overridden in order to avoid multiple observers on the same node.
   * @protected
   */
  _onNodesChange: function() {
    if (this.opened && !this.__isAnimating) {
      // It might have added focusable nodes, so invalidate cached values.
      this.invalidateTabbables();
      this.notifyResize();
    }
  },

  /**
   * Will set first and last focusable nodes if any of them is not set.
   * @private
   */
  __ensureFirstLastFocusables: function() {
    if (!this.__firstFocusableNode || !this.__lastFocusableNode) {
      var focusableNodes = this._focusableNodes;
      this.__firstFocusableNode = focusableNodes[0];
      this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];
    }
  },

  /**
   * Tasks executed when opened changes: prepare for the opening, move the
   * focus, update the manager, render opened/closed.
   * @private
   */
  __openedChanged: function() {
    if (this.opened) {
      // Make overlay visible, then add it to the manager.
      this._prepareRenderOpened();
      this._manager.addOverlay(this);
      // Move the focus to the child node with [autofocus].
      this._applyFocus();

      this._renderOpened();
    } else {
      // Remove overlay, then restore the focus before actually closing.
      this._manager.removeOverlay(this);
      this._applyFocus();

      this._renderClosed();
    }
  },

  /**
   * Executes a callback on the next animation frame, overriding any previous
   * callback awaiting for the next animation frame. e.g.
   * `__onNextAnimationFrame(callback1) && __onNextAnimationFrame(callback2)`;
   * `callback1` will never be invoked.
   * @param {!Function} callback Its `this` parameter is the overlay itself.
   * @private
   */
  __onNextAnimationFrame: function(callback) {
    if (this.__raf) {
      window.cancelAnimationFrame(this.__raf);
    }
    var self = this;
    this.__raf = window.requestAnimationFrame(function nextAnimationFrame() {
      self.__raf = null;
      callback.call(self);
    });
  }

};
/* unused harmony export IronOverlayBehaviorImpl */


const IronOverlayBehavior = [__WEBPACK_IMPORTED_MODULE_1__iron_fit_behavior_iron_fit_behavior_js__["a" /* IronFitBehavior */], __WEBPACK_IMPORTED_MODULE_2__iron_resizable_behavior_iron_resizable_behavior_js__["a" /* IronResizableBehavior */], IronOverlayBehaviorImpl];
/* harmony export (immutable) */ __webpack_exports__["a"] = IronOverlayBehavior;



/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);



const IronFitBehavior = {

  properties: {

    /**
     * The element that will receive a `max-height`/`width`. By default it is the same as `this`,
     * but it can be set to a child element. This is useful, for example, for implementing a
     * scrolling region inside the element.
     * @type {!Element}
     */
    sizingTarget: {
      type: Object,
      value: function() {
        return this;
      }
    },

    /**
     * The element to fit `this` into.
     */
    fitInto: {
      type: Object,
      value: window
    },

    /**
     * Will position the element around the positionTarget without overlapping it.
     */
    noOverlap: {
      type: Boolean
    },

    /**
     * The element that should be used to position the element. If not set, it will
     * default to the parent node.
     * @type {!Element}
     */
    positionTarget: {
      type: Element
    },

    /**
     * The orientation against which to align the element horizontally
     * relative to the `positionTarget`. Possible values are "left", "right", "auto".
     */
    horizontalAlign: {
      type: String
    },

    /**
     * The orientation against which to align the element vertically
     * relative to the `positionTarget`. Possible values are "top", "bottom", "auto".
     */
    verticalAlign: {
      type: String
    },

    /**
     * If true, it will use `horizontalAlign` and `verticalAlign` values as preferred alignment
     * and if there's not enough space, it will pick the values which minimize the cropping.
     */
    dynamicAlign: {
      type: Boolean
    },

    /**
     * A pixel value that will be added to the position calculated for the
     * given `horizontalAlign`, in the direction of alignment. You can think
     * of it as increasing or decreasing the distance to the side of the
     * screen given by `horizontalAlign`.
     *
     * If `horizontalAlign` is "left", this offset will increase or decrease
     * the distance to the left side of the screen: a negative offset will
     * move the dropdown to the left; a positive one, to the right.
     *
     * Conversely if `horizontalAlign` is "right", this offset will increase
     * or decrease the distance to the right side of the screen: a negative
     * offset will move the dropdown to the right; a positive one, to the left.
     */
    horizontalOffset: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * A pixel value that will be added to the position calculated for the
     * given `verticalAlign`, in the direction of alignment. You can think
     * of it as increasing or decreasing the distance to the side of the
     * screen given by `verticalAlign`.
     *
     * If `verticalAlign` is "top", this offset will increase or decrease
     * the distance to the top side of the screen: a negative offset will
     * move the dropdown upwards; a positive one, downwards.
     *
     * Conversely if `verticalAlign` is "bottom", this offset will increase
     * or decrease the distance to the bottom side of the screen: a negative
     * offset will move the dropdown downwards; a positive one, upwards.
     */
    verticalOffset: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * Set to true to auto-fit on attach.
     */
    autoFitOnAttach: {
      type: Boolean,
      value: false
    },

    /** @type {?Object} */
    _fitInfo: {
      type: Object
    }
  },

  get _fitWidth() {
    var fitWidth;
    if (this.fitInto === window) {
      fitWidth = this.fitInto.innerWidth;
    } else {
      fitWidth = this.fitInto.getBoundingClientRect().width;
    }
    return fitWidth;
  },

  get _fitHeight() {
    var fitHeight;
    if (this.fitInto === window) {
      fitHeight = this.fitInto.innerHeight;
    } else {
      fitHeight = this.fitInto.getBoundingClientRect().height;
    }
    return fitHeight;
  },

  get _fitLeft() {
    var fitLeft;
    if (this.fitInto === window) {
      fitLeft = 0;
    } else {
      fitLeft = this.fitInto.getBoundingClientRect().left;
    }
    return fitLeft;
  },

  get _fitTop() {
    var fitTop;
    if (this.fitInto === window) {
      fitTop = 0;
    } else {
      fitTop = this.fitInto.getBoundingClientRect().top;
    }
    return fitTop;
  },

  /**
   * The element that should be used to position the element,
   * if no position target is configured.
   */
  get _defaultPositionTarget() {
    var parent = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).parentNode;

    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      parent = parent.host;
    }

    return parent;
  },

  /**
   * The horizontal align value, accounting for the RTL/LTR text direction.
   */
  get _localeHorizontalAlign() {
    if (this._isRTL) {
      // In RTL, "left" becomes "right".
      if (this.horizontalAlign === 'right') {
        return 'left';
      }
      if (this.horizontalAlign === 'left') {
        return 'right';
      }
    }
    return this.horizontalAlign;
  },

  attached: function() {
    // Memoize this to avoid expensive calculations & relayouts.
    // Make sure we do it only once
    if (typeof this._isRTL === 'undefined') {
      this._isRTL = window.getComputedStyle(this).direction == 'rtl';
    }
    this.positionTarget = this.positionTarget || this._defaultPositionTarget;
    if (this.autoFitOnAttach) {
      if (window.getComputedStyle(this).display === 'none') {
        setTimeout(function() {
          this.fit();
        }.bind(this));
      } else {
        // NOTE: shadydom applies distribution asynchronously
        // for performance reasons webcomponents/shadydom#120
        // Flush to get correct layout info.
        window.ShadyDOM && ShadyDOM.flush();
        this.fit();
      }
    }
  },

  detached: function() {
    if (this.__deferredFit) {
      clearTimeout(this.__deferredFit);
      this.__deferredFit = null;
    }
  },

  /**
   * Positions and fits the element into the `fitInto` element.
   */
  fit: function() {
    this.position();
    this.constrain();
    this.center();
  },

  /**
   * Memoize information needed to position and size the target element.
   * @suppress {deprecated}
   */
  _discoverInfo: function() {
    if (this._fitInfo) {
      return;
    }
    var target = window.getComputedStyle(this);
    var sizer = window.getComputedStyle(this.sizingTarget);

    this._fitInfo = {
      inlineStyle: {
        top: this.style.top || '',
        left: this.style.left || '',
        position: this.style.position || ''
      },
      sizerInlineStyle: {
        maxWidth: this.sizingTarget.style.maxWidth || '',
        maxHeight: this.sizingTarget.style.maxHeight || '',
        boxSizing: this.sizingTarget.style.boxSizing || ''
      },
      positionedBy: {
        vertically: target.top !== 'auto' ? 'top' : (target.bottom !== 'auto' ?
          'bottom' : null),
        horizontally: target.left !== 'auto' ? 'left' : (target.right !== 'auto' ?
          'right' : null)
      },
      sizedBy: {
        height: sizer.maxHeight !== 'none',
        width: sizer.maxWidth !== 'none',
        minWidth: parseInt(sizer.minWidth, 10) || 0,
        minHeight: parseInt(sizer.minHeight, 10) || 0
      },
      margin: {
        top: parseInt(target.marginTop, 10) || 0,
        right: parseInt(target.marginRight, 10) || 0,
        bottom: parseInt(target.marginBottom, 10) || 0,
        left: parseInt(target.marginLeft, 10) || 0
      }
    };
  },

  /**
   * Resets the target element's position and size constraints, and clear
   * the memoized data.
   */
  resetFit: function() {
    var info = this._fitInfo || {};
    for (var property in info.sizerInlineStyle) {
      this.sizingTarget.style[property] = info.sizerInlineStyle[property];
    }
    for (var property in info.inlineStyle) {
      this.style[property] = info.inlineStyle[property];
    }

    this._fitInfo = null;
  },

  /**
   * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after
   * the element or the `fitInto` element has been resized, or if any of the
   * positioning properties (e.g. `horizontalAlign, verticalAlign`) is updated.
   * It preserves the scroll position of the sizingTarget.
   */
  refit: function() {
    var scrollLeft = this.sizingTarget.scrollLeft;
    var scrollTop = this.sizingTarget.scrollTop;
    this.resetFit();
    this.fit();
    this.sizingTarget.scrollLeft = scrollLeft;
    this.sizingTarget.scrollTop = scrollTop;
  },

  /**
   * Positions the element according to `horizontalAlign, verticalAlign`.
   */
  position: function() {
    if (!this.horizontalAlign && !this.verticalAlign) {
      // needs to be centered, and it is done after constrain.
      return;
    }
    this._discoverInfo();

    this.style.position = 'fixed';
    // Need border-box for margin/padding.
    this.sizingTarget.style.boxSizing = 'border-box';
    // Set to 0, 0 in order to discover any offset caused by parent stacking contexts.
    this.style.left = '0px';
    this.style.top = '0px';

    var rect = this.getBoundingClientRect();
    var positionRect = this.__getNormalizedRect(this.positionTarget);
    var fitRect = this.__getNormalizedRect(this.fitInto);

    var margin = this._fitInfo.margin;

    // Consider the margin as part of the size for position calculations.
    var size = {
      width: rect.width + margin.left + margin.right,
      height: rect.height + margin.top + margin.bottom
    };

    var position = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, size, positionRect,
      fitRect);

    var left = position.left + margin.left;
    var top = position.top + margin.top;

    // We first limit right/bottom within fitInto respecting the margin,
    // then use those values to limit top/left.
    var right = Math.min(fitRect.right - margin.right, left + rect.width);
    var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);

    // Keep left/top within fitInto respecting the margin.
    left = Math.max(fitRect.left + margin.left,
      Math.min(left, right - this._fitInfo.sizedBy.minWidth));
    top = Math.max(fitRect.top + margin.top,
      Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));

    // Use right/bottom to set maxWidth/maxHeight, and respect minWidth/minHeight.
    this.sizingTarget.style.maxWidth = Math.max(right - left, this._fitInfo.sizedBy.minWidth) + 'px';
    this.sizingTarget.style.maxHeight = Math.max(bottom - top, this._fitInfo.sizedBy.minHeight) + 'px';

    // Remove the offset caused by any stacking context.
    this.style.left = (left - rect.left) + 'px';
    this.style.top = (top - rect.top) + 'px';
  },

  /**
   * Constrains the size of the element to `fitInto` by setting `max-height`
   * and/or `max-width`.
   */
  constrain: function() {
    if (this.horizontalAlign || this.verticalAlign) {
      return;
    }
    this._discoverInfo();

    var info = this._fitInfo;
    // position at (0px, 0px) if not already positioned, so we can measure the natural size.
    if (!info.positionedBy.vertically) {
      this.style.position = 'fixed';
      this.style.top = '0px';
    }
    if (!info.positionedBy.horizontally) {
      this.style.position = 'fixed';
      this.style.left = '0px';
    }

    // need border-box for margin/padding
    this.sizingTarget.style.boxSizing = 'border-box';
    // constrain the width and height if not already set
    var rect = this.getBoundingClientRect();
    if (!info.sizedBy.height) {
      this.__sizeDimension(rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');
    }
    if (!info.sizedBy.width) {
      this.__sizeDimension(rect, info.positionedBy.horizontally, 'left', 'right', 'Width');
    }
  },

  /**
   * @protected
   * @deprecated
   */
  _sizeDimension: function(rect, positionedBy, start, end, extent) {
    this.__sizeDimension(rect, positionedBy, start, end, extent);
  },

  /**
   * @private
   */
  __sizeDimension: function(rect, positionedBy, start, end, extent) {
    var info = this._fitInfo;
    var fitRect = this.__getNormalizedRect(this.fitInto);
    var max = extent === 'Width' ? fitRect.width : fitRect.height;
    var flip = (positionedBy === end);
    var offset = flip ? max - rect[end] : rect[start];
    var margin = info.margin[flip ? start : end];
    var offsetExtent = 'offset' + extent;
    var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
    this.sizingTarget.style['max' + extent] = (max - margin - offset - sizingOffset) + 'px';
  },

  /**
   * Centers horizontally and vertically if not already positioned. This also sets
   * `position:fixed`.
   */
  center: function() {
    if (this.horizontalAlign || this.verticalAlign) {
      return;
    }
    this._discoverInfo();

    var positionedBy = this._fitInfo.positionedBy;
    if (positionedBy.vertically && positionedBy.horizontally) {
      // Already positioned.
      return;
    }
    // Need position:fixed to center
    this.style.position = 'fixed';
    // Take into account the offset caused by parents that create stacking
    // contexts (e.g. with transform: translate3d). Translate to 0,0 and
    // measure the bounding rect.
    if (!positionedBy.vertically) {
      this.style.top = '0px';
    }
    if (!positionedBy.horizontally) {
      this.style.left = '0px';
    }
    // It will take in consideration margins and transforms
    var rect = this.getBoundingClientRect();
    var fitRect = this.__getNormalizedRect(this.fitInto);
    if (!positionedBy.vertically) {
      var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;
      this.style.top = top + 'px';
    }
    if (!positionedBy.horizontally) {
      var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;
      this.style.left = left + 'px';
    }
  },

  __getNormalizedRect: function(target) {
    if (target === document.documentElement || target === window) {
      return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight,
        right: window.innerWidth,
        bottom: window.innerHeight
      };
    }
    return target.getBoundingClientRect();
  },

  __getCroppedArea: function(position, size, fitRect) {
    var verticalCrop = Math.min(0, position.top) + Math.min(0, fitRect.bottom - (position.top + size.height));
    var horizontalCrop = Math.min(0, position.left) + Math.min(0, fitRect.right - (position.left + size.width));
    return Math.abs(verticalCrop) * size.width + Math.abs(horizontalCrop) * size.height;
  },


  __getPosition: function(hAlign, vAlign, size, positionRect, fitRect) {
    // All the possible configurations.
    // Ordered as top-left, top-right, bottom-left, bottom-right.
    var positions = [{
      verticalAlign: 'top',
      horizontalAlign: 'left',
      top: positionRect.top + this.verticalOffset,
      left: positionRect.left + this.horizontalOffset
    }, {
      verticalAlign: 'top',
      horizontalAlign: 'right',
      top: positionRect.top + this.verticalOffset,
      left: positionRect.right - size.width - this.horizontalOffset
    }, {
      verticalAlign: 'bottom',
      horizontalAlign: 'left',
      top: positionRect.bottom - size.height - this.verticalOffset,
      left: positionRect.left + this.horizontalOffset
    }, {
      verticalAlign: 'bottom',
      horizontalAlign: 'right',
      top: positionRect.bottom - size.height - this.verticalOffset,
      left: positionRect.right - size.width - this.horizontalOffset
    }];

    if (this.noOverlap) {
      // Duplicate.
      for (var i = 0, l = positions.length; i < l; i++) {
        var copy = {};
        for (var key in positions[i]) {
          copy[key] = positions[i][key];
        }
        positions.push(copy);
      }
      // Horizontal overlap only.
      positions[0].top = positions[1].top += positionRect.height;
      positions[2].top = positions[3].top -= positionRect.height;
      // Vertical overlap only.
      positions[4].left = positions[6].left += positionRect.width;
      positions[5].left = positions[7].left -= positionRect.width;
    }

    // Consider auto as null for coding convenience.
    vAlign = vAlign === 'auto' ? null : vAlign;
    hAlign = hAlign === 'auto' ? null : hAlign;

    var position;
    for (var i = 0; i < positions.length; i++) {
      var pos = positions[i];

      // If both vAlign and hAlign are defined, return exact match.
      // For dynamicAlign and noOverlap we'll have more than one candidate, so
      // we'll have to check the croppedArea to make the best choice.
      if (!this.dynamicAlign && !this.noOverlap &&
        pos.verticalAlign === vAlign && pos.horizontalAlign === hAlign) {
        position = pos;
        break;
      }

      // Align is ok if alignment preferences are respected. If no preferences,
      // it is considered ok.
      var alignOk = (!vAlign || pos.verticalAlign === vAlign) &&
        (!hAlign || pos.horizontalAlign === hAlign);

      // Filter out elements that don't match the alignment (if defined).
      // With dynamicAlign, we need to consider all the positions to find the
      // one that minimizes the cropped area.
      if (!this.dynamicAlign && !alignOk) {
        continue;
      }

      position = position || pos;
      pos.croppedArea = this.__getCroppedArea(pos, size, fitRect);
      var diff = pos.croppedArea - position.croppedArea;
      // Check which crops less. If it crops equally, check if align is ok.
      if (diff < 0 || (diff === 0 && alignOk)) {
        position = pos;
      }
      // If not cropped and respects the align requirements, keep it.
      // This allows to prefer positions overlapping horizontally over the
      // ones overlapping vertically.
      if (position.croppedArea === 0 && alignOk) {
        break;
      }
    }

    return position;
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronFitBehavior;



/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_utils_settings_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




const IronResizableBehavior = {
  properties: {
    /**
     * The closest ancestor element that implements `IronResizableBehavior`.
     */
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged'
    },

    /**
     * True if this element is currently notifying its descendant elements of
     * resize.
     */
    _notifyingDescendant: {
      type: Boolean,
      value: false
    }
  },

  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },

  created: function() {
    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
  },

  attached: function() {
    this._requestResizeNotifications();
  },

  detached: function() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      window.removeEventListener('resize', this._boundNotifyResize);
    }

    this._parentResizable = null;
  },

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize: function() {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function(resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);

    this._fireResize();
  },

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   */
  assignParentResizable: function(parentResizable) {
    this._parentResizable = parentResizable;
  },

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   */
  stopResizeNotificationsFor: function(target) {
    var index = this._interestedResizables.indexOf(target);

    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
    }
  },

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify: function(element) { return true; },

  _onDescendantIronResize: function(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }

    // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
    // otherwise non-bubbling event "just work." We do it manually here for
    // the case where Polymer is not using shadow roots for whatever reason:
    if (!__WEBPACK_IMPORTED_MODULE_1__polymer_lib_utils_settings_js__["a" /* Settings */].useShadow) {
      this._fireResize();
    }
  },

  _fireResize: function() {
    this.fire('iron-resize', null, {
      node: this,
      bubbles: false
    });
  },

  _onIronRequestResizeNotifications: function(event) {
    var target = /** @type {!EventTarget} */ (Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).rootTarget);
    if (target === this) {
      return;
    }

    if (this._interestedResizables.indexOf(target) === -1) {
      this._interestedResizables.push(target);
      this.listen(target, 'iron-resize', '_onDescendantIronResize');
    }

    target.assignParentResizable(this);
    this._notifyDescendant(target);

    event.stopPropagation();
  },

  _parentResizableChanged: function(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },

  _notifyDescendant: function(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  },
  
  _requestResizeNotifications: function() {
    if (!this.isAttached)
      return;
    
    // NOTE(valdrin) In CustomElements v1 with native HTMLImports, the order
    // of imports affects the order of `attached` callbacks (see webcomponents/custom-elements#15).
    // This might cause a child to notify parents too early (as the parent
    // still has to be upgraded), resulting in a parent not able to keep track
    // of the `_interestedResizables`. To solve this, we wait for the document
    // to be done loading before firing the event.
    if (document.readyState === 'loading') {
      var _requestResizeNotifications = this._requestResizeNotifications.bind(this);
      document.addEventListener('readystatechange', function readystatechanged() {
        document.removeEventListener('readystatechange', readystatechanged);
        _requestResizeNotifications();
      });
    } else {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      } 
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronResizableBehavior;



/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_overlay_backdrop_js__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_utils_gestures_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);






const IronOverlayManagerClass = function() {
  /**
   * Used to keep track of the opened overlays.
   * @private {Array<Element>}
   */
  this._overlays = [];

  /**
   * iframes have a default z-index of 100,
   * so this default should be at least that.
   * @private {number}
   */
  this._minimumZ = 101;

  /**
   * Memoized backdrop element.
   * @private {Element|null}
   */
  this._backdropElement = null;

  // Enable document-wide tap recognizer.
  // NOTE: Use useCapture=true to avoid accidentally prevention of the closing
  // of an overlay via event.stopPropagation(). The only way to prevent
  // closing of an overlay should be through its APIs.
  // NOTE: enable tap on <html> to workaround Polymer/polymer#4459
  __WEBPACK_IMPORTED_MODULE_3__polymer_lib_utils_gestures_js__["add"](document.documentElement, 'tap', null);
  document.addEventListener('tap', this._onCaptureClick.bind(this), true);
  document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
  document.addEventListener('keydown', this._onCaptureKeyDown.bind(this), true);
};
/* unused harmony export IronOverlayManagerClass */


IronOverlayManagerClass.prototype = {

  constructor: IronOverlayManagerClass,

  /**
   * The shared backdrop element.
   * @type {!Element} backdropElement
   */
  get backdropElement() {
    if (!this._backdropElement) {
      this._backdropElement = document.createElement('iron-overlay-backdrop');
    }
    return this._backdropElement;
  },

  /**
   * The deepest active element.
   * @type {!Element} activeElement the active element
   */
  get deepActiveElement() {
    // document.activeElement can be null
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
    // In case of null, default it to document.body.
    var active = document.activeElement || document.body;
    while (active.root && Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(active.root).activeElement) {
      active = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(active.root).activeElement;
    }
    return active;
  },

  /**
   * Brings the overlay at the specified index to the front.
   * @param {number} i
   * @private
   */
  _bringOverlayAtIndexToFront: function(i) {
    var overlay = this._overlays[i];
    if (!overlay) {
      return;
    }
    var lastI = this._overlays.length - 1;
    var currentOverlay = this._overlays[lastI];
    // Ensure always-on-top overlay stays on top.
    if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      lastI--;
    }
    // If already the top element, return.
    if (i >= lastI) {
      return;
    }
    // Update z-index to be on top.
    var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
    if (this._getZ(overlay) <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }

    // Shift other overlays behind the new on top.
    while (i < lastI) {
      this._overlays[i] = this._overlays[i + 1];
      i++;
    }
    this._overlays[lastI] = overlay;
  },

  /**
   * Adds the overlay and updates its z-index if it's opened, or removes it if it's closed.
   * Also updates the backdrop z-index.
   * @param {!Element} overlay
   */
  addOrRemoveOverlay: function(overlay) {
    if (overlay.opened) {
      this.addOverlay(overlay);
    } else {
      this.removeOverlay(overlay);
    }
  },

  /**
   * Tracks overlays for z-index and focus management.
   * Ensures the last added overlay with always-on-top remains on top.
   * @param {!Element} overlay
   */
  addOverlay: function(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i >= 0) {
      this._bringOverlayAtIndexToFront(i);
      this.trackBackdrop();
      return;
    }
    var insertionIndex = this._overlays.length;
    var currentOverlay = this._overlays[insertionIndex - 1];
    var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);
    var newZ = this._getZ(overlay);

    // Ensure always-on-top overlay stays on top.
    if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      // This bumps the z-index of +2.
      this._applyOverlayZ(currentOverlay, minimumZ);
      insertionIndex--;
      // Update minimumZ to match previous overlay's z-index.
      var previousOverlay = this._overlays[insertionIndex - 1];
      minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
    }

    // Update z-index and insert overlay.
    if (newZ <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }
    this._overlays.splice(insertionIndex, 0, overlay);

    this.trackBackdrop();
  },

  /**
   * @param {!Element} overlay
   */
  removeOverlay: function(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i === -1) {
      return;
    }
    this._overlays.splice(i, 1);

    this.trackBackdrop();
  },

  /**
   * Returns the current overlay.
   * @return {Element|undefined}
   */
  currentOverlay: function() {
    var i = this._overlays.length - 1;
    return this._overlays[i];
  },

  /**
   * Returns the current overlay z-index.
   * @return {number}
   */
  currentOverlayZ: function() {
    return this._getZ(this.currentOverlay());
  },

  /**
   * Ensures that the minimum z-index of new overlays is at least `minimumZ`.
   * This does not effect the z-index of any existing overlays.
   * @param {number} minimumZ
   */
  ensureMinimumZ: function(minimumZ) {
    this._minimumZ = Math.max(this._minimumZ, minimumZ);
  },

  focusOverlay: function() {
    var current = /** @type {?} */ (this.currentOverlay());
    if (current) {
      current._applyFocus();
    }
  },

  /**
   * Updates the backdrop z-index.
   */
  trackBackdrop: function() {
    var overlay = this._overlayWithBackdrop();
    // Avoid creating the backdrop if there is no overlay with backdrop.
    if (!overlay && !this._backdropElement) {
      return;
    }
    this.backdropElement.style.zIndex = this._getZ(overlay) - 1;
    this.backdropElement.opened = !!overlay;
    // Property observers are not fired until element is attached
    // in Polymer 2.x, so we ensure element is attached if needed.
    // https://github.com/Polymer/polymer/issues/4526
    this.backdropElement.prepare();
  },

  /**
   * @return {Array<Element>}
   */
  getBackdrops: function() {
    var backdrops = [];
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        backdrops.push(this._overlays[i]);
      }
    }
    return backdrops;
  },

  /**
   * Returns the z-index for the backdrop.
   * @return {number}
   */
  backdropZ: function() {
    return this._getZ(this._overlayWithBackdrop()) - 1;
  },

  /**
   * Returns the first opened overlay that has a backdrop.
   * @return {Element|undefined}
   * @private
   */
  _overlayWithBackdrop: function() {
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        return this._overlays[i];
      }
    }
  },

  /**
   * Calculates the minimum z-index for the overlay.
   * @param {Element=} overlay
   * @private
   */
  _getZ: function(overlay) {
    var z = this._minimumZ;
    if (overlay) {
      var z1 = Number(overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);
      // Check if is a number
      // Number.isNaN not supported in IE 10+
      if (z1 === z1) {
        z = z1;
      }
    }
    return z;
  },

  /**
   * @param {!Element} element
   * @param {number|string} z
   * @private
   */
  _setZ: function(element, z) {
    element.style.zIndex = z;
  },

  /**
   * @param {!Element} overlay
   * @param {number} aboveZ
   * @private
   */
  _applyOverlayZ: function(overlay, aboveZ) {
    this._setZ(overlay, aboveZ + 2);
  },

  /**
   * Returns the deepest overlay in the path.
   * @param {Array<Element>=} path
   * @return {Element|undefined}
   * @suppress {missingProperties}
   * @private
   */
  _overlayInPath: function(path) {
    path = path || [];
    for (var i = 0; i < path.length; i++) {
      if (path[i]._manager === this) {
        return path[i];
      }
    }
  },

  /**
   * Ensures the click event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureClick: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    // Check if clicked outside of top overlay.
    if (overlay && this._overlayInPath(Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).path) !== overlay) {
      overlay._onCaptureClick(event);
    }
  },

  /**
   * Ensures the focus event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureFocus: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    if (overlay) {
      overlay._onCaptureFocus(event);
    }
  },

  /**
   * Ensures TAB and ESC keyboard events are delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureKeyDown: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    if (overlay) {
      if (__WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */].keyboardEventMatchesKeys(event, 'esc')) {
        overlay._onCaptureEsc(event);
      } else if (__WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */].keyboardEventMatchesKeys(event, 'tab')) {
        overlay._onCaptureTab(event);
      }
    }
  },

  /**
   * Returns if the overlay1 should be behind overlay2.
   * @param {!Element} overlay1
   * @param {!Element} overlay2
   * @return {boolean}
   * @suppress {missingProperties}
   * @private
   */
  _shouldBeBehindOverlay: function(overlay1, overlay2) {
    return !overlay1.alwaysOnTop && overlay2.alwaysOnTop;
  }
};

const IronOverlayManager = new IronOverlayManagerClass();
/* harmony export (immutable) */ __webpack_exports__["a"] = IronOverlayManager;



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--iron-overlay-backdrop-background-color, #000);
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
        @apply --iron-overlay-backdrop;
      }

      :host(.opened) {
        opacity: var(--iron-overlay-backdrop-opacity, 0.6);
        pointer-events: auto;
        @apply --iron-overlay-backdrop-opened;
      }
    </style>

    <slot></slot>
`,

  is: 'iron-overlay-backdrop',

  properties: {

    /**
     * Returns true if the backdrop is opened.
     */
    opened: {
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_openedChanged'
    }

  },

  listeners: {
    'transitionend': '_onTransitionend'
  },

  created: function() {
    // Used to cancel previous requestAnimationFrame calls when opened changes.
    this.__openedRaf = null;
  },

  attached: function() {
    this.opened && this._openedChanged(this.opened);
  },

  /**
   * Appends the backdrop to document body if needed.
   */
  prepare: function() {
    if (this.opened && !this.parentNode) {
      Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(document.body).appendChild(this);
    }
  },

  /**
   * Shows the backdrop.
   */
  open: function() {
    this.opened = true;
  },

  /**
   * Hides the backdrop.
   */
  close: function() {
    this.opened = false;
  },

  /**
   * Removes the backdrop from document body if needed.
   */
  complete: function() {
    if (!this.opened && this.parentNode === document.body) {
      Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.parentNode).removeChild(this);
    }
  },

  _onTransitionend: function(event) {
    if (event && event.target === this) {
      this.complete();
    }
  },

  /**
   * @param {boolean} opened
   * @private
   */
  _openedChanged: function(opened) {
    if (opened) {
      // Auto-attach.
      this.prepare();
    } else {
      // Animation might be disabled via the mixin or opacity custom property.
      // If it is disabled in other ways, it's up to the user to call complete.
      var cs = window.getComputedStyle(this);
      if (cs.transitionDuration === '0s' || cs.opacity == 0) {
        this.complete();
      }
    }

    if (!this.isAttached) {
      return;
    }

    // Always cancel previous requestAnimationFrame.
    if (this.__openedRaf) {
      window.cancelAnimationFrame(this.__openedRaf);
      this.__openedRaf = null;
    }
    // Force relayout to ensure proper transitions.
    this.scrollTop = this.scrollTop;
    this.__openedRaf = window.requestAnimationFrame(function() {
      this.__openedRaf = null;
      this.toggleClass('opened', this.opened);
    }.bind(this));
  }
});


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);



var p = Element.prototype;
var matches = p.matches || p.matchesSelector || p.mozMatchesSelector ||
  p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

const IronFocusablesHelper = {

  /**
   * Returns a sorted array of tabbable nodes, including the root node.
   * It searches the tabbable nodes in the light and shadow dom of the chidren,
   * sorting the result by tabindex.
   * @param {!Node} node
   * @return {Array<HTMLElement>}
   */
  getTabbableNodes: function(node) {
    var result = [];
    // If there is at least one element with tabindex > 0, we need to sort
    // the final array by tabindex.
    var needsSortByTabIndex = this._collectTabbableNodes(node, result);
    if (needsSortByTabIndex) {
      return this._sortByTabIndex(result);
    }
    return result;
  },

  /**
   * Returns if a element is focusable.
   * @param {!HTMLElement} element
   * @return {boolean}
   */
  isFocusable: function(element) {
    // From http://stackoverflow.com/a/1600194/4228703:
    // There isn't a definite list, it's up to the browser. The only
    // standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,
    // according to which the only elements that have a focus() method are
    // HTMLInputElement,  HTMLSelectElement, HTMLTextAreaElement and
    // HTMLAnchorElement. This notably omits HTMLButtonElement and
    // HTMLAreaElement.
    // Referring to these tests with tabbables in different browsers
    // http://allyjs.io/data-tables/focusable.html

    // Elements that cannot be focused if they have [disabled] attribute.
    if (matches.call(element, 'input, select, textarea, button, object')) {
      return matches.call(element, ':not([disabled])');
    }
    // Elements that can be focused even if they have [disabled] attribute.
    return matches.call(element,
      'a[href], area[href], iframe, [tabindex], [contentEditable]');
  },

  /**
   * Returns if a element is tabbable. To be tabbable, a element must be
   * focusable, visible, and with a tabindex !== -1.
   * @param {!HTMLElement} element
   * @return {boolean}
   */
  isTabbable: function(element) {
    return this.isFocusable(element) &&
      matches.call(element, ':not([tabindex="-1"])') &&
      this._isVisible(element);
  },

  /**
   * Returns the normalized element tabindex. If not focusable, returns -1.
   * It checks for the attribute "tabindex" instead of the element property
   * `tabIndex` since browsers assign different values to it.
   * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
   * @param {!HTMLElement} element
   * @return {!number}
   * @private
   */
  _normalizedTabIndex: function(element) {
    if (this.isFocusable(element)) {
      var tabIndex = element.getAttribute('tabindex') || 0;
      return Number(tabIndex);
    }
    return -1;
  },

  /**
   * Searches for nodes that are tabbable and adds them to the `result` array.
   * Returns if the `result` array needs to be sorted by tabindex.
   * @param {!Node} node The starting point for the search; added to `result`
   * if tabbable.
   * @param {!Array<HTMLElement>} result
   * @return {boolean}
   * @private
   */
  _collectTabbableNodes: function(node, result) {
    // If not an element or not visible, no need to explore children.
    if (node.nodeType !== Node.ELEMENT_NODE || !this._isVisible(node)) {
      return false;
    }
    var element = /** @type {HTMLElement} */ (node);
    var tabIndex = this._normalizedTabIndex(element);
    var needsSort = tabIndex > 0;
    if (tabIndex >= 0) {
      result.push(element);
    }

    // In ShadowDOM v1, tab order is affected by the order of distrubution.
    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];
    // in ShadowDOM v0 tab order is not affected by the distrubution order,
    // in fact getTabbableNodes(#root) returns [#B, #A].
    //  <div id="root">
    //   <!-- shadow -->
    //     <slot name="a">
    //     <slot name="b">
    //   <!-- /shadow -->
    //   <input id="A" slot="a">
    //   <input id="B" slot="b" tabindex="1">
    //  </div>
    // TODO(valdrin) support ShadowDOM v1 when upgrading to Polymer v2.0.
    var children;
    if (element.localName === 'content' || element.localName === 'slot') {
      children = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(element).getDistributedNodes();
    } else {
      // Use shadow root if possible, will check for distributed nodes.
      children = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(element.root || element).children;
    }
    for (var i = 0; i < children.length; i++) {
      // Ensure method is always invoked to collect tabbable children.
      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;
    }
    return needsSort;
  },

  /**
   * Returns false if the element has `visibility: hidden` or `display: none`
   * @param {!HTMLElement} element
   * @return {boolean}
   * @private
   */
  _isVisible: function(element) {
    // Check inline style first to save a re-flow. If looks good, check also
    // computed style.
    var style = element.style;
    if (style.visibility !== 'hidden' && style.display !== 'none') {
      style = window.getComputedStyle(element);
      return (style.visibility !== 'hidden' && style.display !== 'none');
    }
    return false;
  },

  /**
   * Sorts an array of tabbable elements by tabindex. Returns a new array.
   * @param {!Array<HTMLElement>} tabbables
   * @return {Array<HTMLElement>}
   * @private
   */
  _sortByTabIndex: function(tabbables) {
    // Implement a merge sort as Array.prototype.sort does a non-stable sort
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
    var len = tabbables.length;
    if (len < 2) {
      return tabbables;
    }
    var pivot = Math.ceil(len / 2);
    var left = this._sortByTabIndex(tabbables.slice(0, pivot));
    var right = this._sortByTabIndex(tabbables.slice(pivot));
    return this._mergeSortByTabIndex(left, right);
  },

  /**
   * Merge sort iterator, merges the two arrays into one, sorted by tab index.
   * @param {!Array<HTMLElement>} left
   * @param {!Array<HTMLElement>} right
   * @return {Array<HTMLElement>}
   * @private
   */
  _mergeSortByTabIndex: function(left, right) {
    var result = [];
    while ((left.length > 0) && (right.length > 0)) {
      if (this._hasLowerTabOrder(left[0], right[0])) {
        result.push(right.shift());
      } else {
        result.push(left.shift());
      }
    }

    return result.concat(left, right);
  },

  /**
   * Returns if element `a` has lower tab order compared to element `b`
   * (both elements are assumed to be focusable and tabbable).
   * Elements with tabindex = 0 have lower tab order compared to elements
   * with tabindex > 0.
   * If both have same tabindex, it returns false.
   * @param {!HTMLElement} a
   * @param {!HTMLElement} b
   * @return {boolean}
   * @private
   */
  _hasLowerTabOrder: function(a, b) {
    // Normalize tabIndexes
    // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
    var ati = Math.max(a.tabIndex, 0);
    var bti = Math.max(b.tabIndex, 0);
    return (ati === 0 || bti === 0) ? bti > ati : ati > bti;
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronFocusablesHelper;



/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__paper_styles_shadow_js__ = __webpack_require__(44);





const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-dialog-shared-styles">
  <template>
    <style>
      :host {
        display: block;
        margin: 24px 40px;

        background: var(--paper-dialog-background-color, var(--primary-background-color));
        color: var(--paper-dialog-color, var(--primary-text-color));

        @apply --paper-font-body1;
        @apply --shadow-elevation-16dp;
        @apply --paper-dialog;
      }

      :host > ::slotted(*) {
        margin-top: 20px;
        padding: 0 24px;
      }

      :host > ::slotted(.no-padding) {
        padding: 0;
      }

      /* In 1.x, this selector was \`:host > ::content h2\`. In 2.x <slot> allows
      to select direct children only, which increases the weight of this
      selector, so we have to move it before first-child/last-child selectors */
      :host > ::slotted(h2) {
        position: relative;
        margin: 0;

        @apply --paper-font-title;
        @apply --paper-dialog-title;
      }

      :host > ::slotted(*:first-child) {
        margin-top: 24px;
      }

      :host > ::slotted(*:last-child) {
        margin-bottom: 24px;
      }

      :host > ::slotted(.buttons) {
        position: relative;
        padding: 8px 8px 8px 24px;
        margin: 0;

        color: var(--paper-dialog-button-color, var(--primary-color));

        @apply --layout-horizontal;
        @apply --layout-end-justified;
      }
    </style>
  </template>
</dom-module>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 82 */
/***/ (function(module, exports) {

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,300,300italic,400italic,500,500italic,700,700italic" crossorigin="anonymous">
`;
document.head.appendChild($_documentContainer);


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_button_behavior_js__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_element_styles_paper_material_styles_js__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);





const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-button">
  <template strip-whitespace="">
    <style include="paper-material-styles">
      /* Need to specify the same specificity as the styles imported from paper-material. */
      :host {
        @apply --layout-inline;
        @apply --layout-center-center;
        position: relative;
        box-sizing: border-box;
        min-width: 5.14em;
        margin: 0 0.29em;
        background: transparent;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-tap-highlight-color: transparent;
        font: inherit;
        text-transform: uppercase;
        outline-width: 0;
        border-radius: 3px;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        cursor: pointer;
        z-index: 0;
        padding: 0.7em 0.57em;

        @apply --paper-font-common-base;
        @apply --paper-button;
      }

      :host([elevation="1"]) {
        @apply --paper-material-elevation-1;
      }

      :host([elevation="2"]) {
        @apply --paper-material-elevation-2;
      }

      :host([elevation="3"]) {
        @apply --paper-material-elevation-3;
      }

      :host([elevation="4"]) {
        @apply --paper-material-elevation-4;
      }

      :host([elevation="5"]) {
        @apply --paper-material-elevation-5;
      }

      :host([hidden]) {
        display: none !important;
      }

      :host([raised].keyboard-focus) {
        font-weight: bold;
        @apply --paper-button-raised-keyboard-focus;
      }

      :host(:not([raised]).keyboard-focus) {
        font-weight: bold;
        @apply --paper-button-flat-keyboard-focus;
      }

      :host([disabled]) {
        background: #eaeaea;
        color: #a8a8a8;
        cursor: auto;
        pointer-events: none;

        @apply --paper-button-disabled;
      }

      :host([animated]) {
        @apply --shadow-transition;
      }

      paper-ripple {
        color: var(--paper-button-ink-color);
      }
    </style>

    <slot></slot>
  </template>

  
</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-button',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_button_behavior_js__["a" /* PaperButtonBehavior */]
  ],

  properties: {
    /**
     * If true, the button should be styled with a shadow.
     */
    raised: {
      type: Boolean,
      reflectToAttribute: true,
      value: false,
      observer: '_calculateElevation'
    }
  },

  _calculateElevation: function() {
    if (!this.raised) {
      this._setElevation(0);
    } else {
      __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_button_behavior_js__["b" /* PaperButtonBehaviorImpl */]._calculateElevation.apply(this);
    }
  }

  /**
  Fired when the animation finishes.
  This is useful if you want to wait until
  the ripple animation finishes to perform some action.

  @event transitionend
  Event param: {{node: Object}} detail Contains the animated node.
  */
});


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__ = __webpack_require__(18);





const PaperButtonBehaviorImpl = {
  properties: {
    /**
     * The z-depth of this element, from 0-5. Setting to 0 will remove the
     * shadow, and each increasing number greater than 0 will be "deeper"
     * than the last.
     *
     * @attribute elevation
     * @type number
     * @default 1
     */
    elevation: {
      type: Number,
      reflectToAttribute: true,
      readOnly: true
    }
  },

  observers: [
    '_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)',
    '_computeKeyboardClass(receivedFocusFromKeyboard)'
  ],

  hostAttributes: {
    role: 'button',
    tabindex: '0',
    animated: true
  },

  _calculateElevation: function() {
    var e = 1;
    if (this.disabled) {
      e = 0;
    } else if (this.active || this.pressed) {
      e = 4;
    } else if (this.receivedFocusFromKeyboard) {
      e = 3;
    }
    this._setElevation(e);
  },

  _computeKeyboardClass: function(receivedFocusFromKeyboard) {
    this.toggleClass('keyboard-focus', receivedFocusFromKeyboard);
  },

  /**
   * In addition to `IronButtonState` behavior, when space key goes down,
   * create a ripple down effect.
   *
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["b" /* IronButtonStateImpl */]._spaceKeyDownHandler.call(this, event);
    // Ensure that there is at most one ripple when the space key is held down.
    if (this.hasRipple() && this.getRipple().ripples.length < 1) {
      this._ripple.uiDownAction();
    }
  },

  /**
   * In addition to `IronButtonState` behavior, when space key goes up,
   * create a ripple up effect.
   *
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["b" /* IronButtonStateImpl */]._spaceKeyUpHandler.call(this, event);
    if (this.hasRipple()) {
      this._ripple.uiUpAction();
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["b"] = PaperButtonBehaviorImpl;


const PaperButtonBehavior = [
  __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["a" /* IronButtonState */],
  __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__["a" /* IronControlState */],
  __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */],
  PaperButtonBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperButtonBehavior;



/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shadow_js__ = __webpack_require__(44);


const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-material-styles">
  <template>
    <style>
      :host, html {
        --paper-material: {
          display: block;
          position: relative;
        };
        --paper-material-elevation-1: {
          @apply --shadow-elevation-2dp;
        };
        --paper-material-elevation-2: {
          @apply --shadow-elevation-4dp;
        };
        --paper-material-elevation-3: {
          @apply --shadow-elevation-6dp;
        };
        --paper-material-elevation-4: {
          @apply --shadow-elevation-8dp;
        };
        --paper-material-elevation-5: {
          @apply --shadow-elevation-16dp;
        };
      }
      :host(.paper-material), .paper-material {
        @apply --paper-material;
      }
      :host(.paper-material[elevation="1"]), .paper-material[elevation="1"] {
        @apply --paper-material-elevation-1;
      }
      :host(.paper-material[elevation="2"]), .paper-material[elevation="2"] {
        @apply --paper-material-elevation-2;
      }
      :host(.paper-material[elevation="3"]), .paper-material[elevation="3"] {
        @apply --paper-material-elevation-3;
      }
      :host(.paper-material[elevation="4"]), .paper-material[elevation="4"] {
        @apply --paper-material-elevation-4;
      }
      :host(.paper-material[elevation="5"]), .paper-material[elevation="5"] {
        @apply --paper-material-elevation-5;
      }
    </style>
  </template>
</dom-module>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_form_element_behavior_iron_form_element_behavior_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_input_iron_input_js__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_input_behavior_js__ = __webpack_require__(90);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__paper_input_char_counter_js__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__paper_input_container_js__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__paper_input_error_js__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__polymer_lib_elements_dom_module_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__polymer_polymer_element_js__ = __webpack_require__(5);










const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-input">
  <template>
    <style>
      :host {
        display: block;
      }

      :host([focused]) {
        outline: none;
      }

      :host([hidden]) {
        display: none !important;
      }

      input {
        position: relative; /* to make a stacking context */
        outline: none;
        box-shadow: none;
        padding: 0;
        width: 100%;
        max-width: 100%;
        background: transparent;
        border: none;
        color: var(--paper-input-container-input-color, var(--primary-text-color));
        -webkit-appearance: none;
        text-align: inherit;
        vertical-align: bottom;

        /* Firefox sets a min-width on the input, which can cause layout issues */
        min-width: 0;

        @apply --paper-font-subhead;
        @apply --paper-input-container-input;
      }

      input::-webkit-outer-spin-button,
      input::-webkit-inner-spin-button {
        @apply --paper-input-container-input-webkit-spinner;
      }

      input::-webkit-clear-button {
        @apply --paper-input-container-input-webkit-clear;
      }

      input::-webkit-input-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      input:-moz-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      input::-moz-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      input::-ms-clear {
        @apply --paper-input-container-ms-clear;
      }

      input:-ms-input-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      label {
        pointer-events: none;
      }
    </style>

    <paper-input-container id="container" no-label-float="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate\$="[[autoValidate]]" disabled\$="[[disabled]]" invalid="[[invalid]]">

      <slot name="prefix" slot="prefix"></slot>

      <label hidden\$="[[!label]]" aria-hidden="true" for="input" slot="label">[[label]]</label>

      <span id="template-placeholder"></span>

      <slot name="suffix" slot="suffix"></slot>

      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error aria-live="assertive" slot="add-on">[[errorMessage]]</paper-input-error>
      </template>

      <template is="dom-if" if="[[charCounter]]">
        <paper-input-char-counter slot="add-on"></paper-input-char-counter>
      </template>

    </paper-input-container>
  </template>

  <!-- This is a fresh new hell to make this element hybrid. Basically, in 2.0
    we lost is=, so the example same template can't be used with iron-input 1.0 and 2.0.
    Expect some conditional code (especially in the tests).
   -->
  <template id="v0">
    <input is="iron-input" id="input" slot="input" aria-labelledby\$="[[_ariaLabelledBy]]" aria-describedby\$="[[_ariaDescribedBy]]" disabled\$="[[disabled]]" title\$="[[title]]" bind-value="{{value}}" invalid="{{invalid}}" prevent-invalid-input="[[preventInvalidInput]]" allowed-pattern="[[allowedPattern]]" validator="[[validator]]" type\$="[[type]]" pattern\$="[[pattern]]" required\$="[[required]]" autocomplete\$="[[autocomplete]]" autofocus\$="[[autofocus]]" inputmode\$="[[inputmode]]" minlength\$="[[minlength]]" maxlength\$="[[maxlength]]" min\$="[[min]]" max\$="[[max]]" step\$="[[step]]" name\$="[[name]]" placeholder\$="[[placeholder]]" readonly\$="[[readonly]]" list\$="[[list]]" size\$="[[size]]" autocapitalize\$="[[autocapitalize]]" autocorrect\$="[[autocorrect]]" on-change="_onChange" tabindex\$="[[tabIndex]]" autosave\$="[[autosave]]" results\$="[[results]]" accept\$="[[accept]]" multiple\$="[[multiple]]">
  </template>

  <template id="v1">
    <!-- Need to bind maxlength so that the paper-input-char-counter works correctly -->
    <iron-input bind-value="{{value}}" id="input" slot="input" maxlength\$="[[maxlength]]" allowed-pattern="[[allowedPattern]]" invalid="{{invalid}}" validator="[[validator]]">
      <input id="nativeInput" aria-labelledby\$="[[_ariaLabelledBy]]" aria-describedby\$="[[_ariaDescribedBy]]" disabled\$="[[disabled]]" title\$="[[title]]" type\$="[[type]]" pattern\$="[[pattern]]" required\$="[[required]]" autocomplete\$="[[autocomplete]]" autofocus\$="[[autofocus]]" inputmode\$="[[inputmode]]" minlength\$="[[minlength]]" maxlength\$="[[maxlength]]" min\$="[[min]]" max\$="[[max]]" step\$="[[step]]" name\$="[[name]]" placeholder\$="[[placeholder]]" readonly\$="[[readonly]]" list\$="[[list]]" size\$="[[size]]" autocapitalize\$="[[autocapitalize]]" autocorrect\$="[[autocorrect]]" on-change="_onChange" tabindex\$="[[tabIndex]]" autosave\$="[[autosave]]" results\$="[[results]]" accept\$="[[accept]]" multiple\$="[[multiple]]">
    </iron-input>
  </template>

</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_7__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-input',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_3__paper_input_behavior_js__["a" /* PaperInputBehavior */],
    __WEBPACK_IMPORTED_MODULE_1__iron_form_element_behavior_iron_form_element_behavior_js__["a" /* IronFormElementBehavior */]
  ],

  beforeRegister: function() {
    // We need to tell which kind of of template to stamp based on
    // what kind of `iron-input` we got, but because of polyfills and
    // custom elements differences between v0 and v1, the safest bet is
    // to check a particular method we know the iron-input#2.x can have.
    // If it doesn't have it, then it's an iron-input#1.x.
    var ironInput = document.createElement('iron-input');
    var version = typeof ironInput._initSlottedInput == 'function' ? 'v1' : 'v0';
    var template = __WEBPACK_IMPORTED_MODULE_8__polymer_lib_elements_dom_module_js__["a" /* DomModule */].import('paper-input', 'template');
    var inputTemplate = __WEBPACK_IMPORTED_MODULE_8__polymer_lib_elements_dom_module_js__["a" /* DomModule */].import('paper-input', 'template#' + version);
    var inputPlaceholder = template.content.querySelector('#template-placeholder');
    if (inputPlaceholder) {
      inputPlaceholder.parentNode.replaceChild(inputTemplate.content, inputPlaceholder);
    }
    // else it's already been processed, probably in superclass
  },

  /**
   * Returns a reference to the focusable element. Overridden from PaperInputBehavior
   * to correctly focus the native input.
   */
  get _focusableElement() {
    return __WEBPACK_IMPORTED_MODULE_9__polymer_polymer_element_js__["a" /* Element */] ? this.inputElement._inputElement : this.inputElement;
  },

  // Note: This event is only available in the 1.0 version of this element.
  // In 2.0, the functionality of `_onIronInputReady` is done in
  // PaperInputBehavior::attached.
  listeners: {
    'iron-input-ready': '_onIronInputReady'
  },

  _onIronInputReady: function() {
    if (this.inputElement &&
        this._typesThatHaveText.indexOf(this.$.nativeInput.type) !== -1) {
      this.alwaysFloatLabel = true;
    }

    // Only validate when attached if the input already has a value.
    if (!!this.inputElement.bindValue) {
      this.$.container._handleValueAndAutoValidate(this.inputElement);
    }
  },
});


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_announcer_iron_a11y_announcer_js__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_validatable_behavior_iron_validatable_behavior_js__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
      }
    </style>
    <slot id="content"></slot>
`,

  is: 'iron-input',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__iron_validatable_behavior_iron_validatable_behavior_js__["a" /* IronValidatableBehavior */]
  ],

  /**
   * Fired whenever `validate()` is called.
   *
   * @event iron-input-validate
   */

  properties: {

    /**
     * Use this property instead of `value` for two-way data binding, or to
     * set a default value for the input. **Do not** use the distributed
     * input's `value` property to set a default value.
     */
    bindValue: {
      type: String
    },

    /**
     * Computed property that echoes `bindValue` (mostly used for Polymer 1.0
     * backcompatibility, if you were one-way binding to the Polymer 1.0
     * `input is="iron-input"` value attribute).
     */
    value: {
      computed: '_computeValue(bindValue)'
    },

    /**
     * Regex-like list of characters allowed as input; all characters not in the list
     * will be rejected. The recommended format should be a list of allowed characters,
     * for example, `[a-zA-Z0-9.+-!;:]`.
     *
     * This pattern represents the allowed characters for the field; as the user inputs text,
     * each individual character will be checked against the pattern (rather than checking
     * the entire value as a whole). If a character is not a match, it will be rejected.
     *
     * Pasted input will have each character checked individually; if any character
     * doesn't match `allowedPattern`, the entire pasted string will be rejected.
     *
     * Note: if you were using `iron-input` in 1.0, you were also required to
     * set `prevent-invalid-input`. This is no longer needed as of Polymer 2.0,
     * and will be set automatically for you if an `allowedPattern` is provided.
     *
     */
    allowedPattern: {
      type: String
    },

    /**
     * Set to true to auto-validate the input value as you type.
     */
    autoValidate: {
      type: Boolean,
      value: false
    }
  },

  observers: [
    '_bindValueChanged(bindValue, _inputElement)'
  ],

  listeners: {
    'input': '_onInput',
    'keypress': '_onKeypress'
  },

  created: function() {
    __WEBPACK_IMPORTED_MODULE_1__iron_a11y_announcer_iron_a11y_announcer_js__["a" /* IronA11yAnnouncer */].requestAvailability();
    this._previousValidInput = '';
    this._patternAlreadyChecked = false;
  },

  attached: function() {
    // If the input is added at a later time, update the internal reference.
    this._observer = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).observeNodes(function(info) {
      this._initSlottedInput();
    }.bind(this));
  },

  detached: function() {
    if (this._observer) {
      Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).unobserveNodes(this._observer);
      this._observer = null;
    }
  },

  /**
   * Returns the distributed <input> element.
   */
  get inputElement () {
    return this._inputElement;
  },

  _initSlottedInput: function() {
    this._inputElement = this.getEffectiveChildren()[0];

    if (this.inputElement && this.inputElement.value) {
      this.bindValue = this.inputElement.value;
    }

    this.fire('iron-input-ready');
  },

  get _patternRegExp() {
    var pattern;
    if (this.allowedPattern) {
      pattern = new RegExp(this.allowedPattern);
    } else {
      switch (this.type) {
        case 'number':
          pattern = /[0-9.,e-]/;
          break;
      }
    }
    return pattern;
  },

  /**
   * @suppress {checkTypes}
   */
  _bindValueChanged: function(bindValue, inputElement) {
    // The observer could have run before attached() when we have actually initialized
    // this property.
    if (!inputElement) {
      return;
    }

    if (bindValue === undefined) {
      inputElement.value = null;
    } else if (bindValue !== inputElement.value){
      this.inputElement.value = bindValue;
    }

    if (this.autoValidate) {
      this.validate();
    }

    // manually notify because we don't want to notify until after setting value
    this.fire('bind-value-changed', {value: bindValue});
  },

  _onInput: function() {
    // Need to validate each of the characters pasted if they haven't
    // been validated inside `_onKeypress` already.
    if (this.allowedPattern && !this._patternAlreadyChecked) {
      var valid = this._checkPatternValidity();
      if (!valid) {
        this._announceInvalidCharacter('Invalid string of characters not entered.');
        this.inputElement.value = this._previousValidInput;
      }
    }
    this.bindValue = this._previousValidInput = this.inputElement.value;
    this._patternAlreadyChecked = false;
  },

  _isPrintable: function(event) {
    // What a control/printable character is varies wildly based on the browser.
    // - most control characters (arrows, backspace) do not send a `keypress` event
    //   in Chrome, but the *do* on Firefox
    // - in Firefox, when they do send a `keypress` event, control chars have
    //   a charCode = 0, keyCode = xx (for ex. 40 for down arrow)
    // - printable characters always send a keypress event.
    // - in Firefox, printable chars always have a keyCode = 0. In Chrome, the keyCode
    //   always matches the charCode.
    // None of this makes any sense.

    // For these keys, ASCII code == browser keycode.
    var anyNonPrintable =
      (event.keyCode == 8)   ||  // backspace
      (event.keyCode == 9)   ||  // tab
      (event.keyCode == 13)  ||  // enter
      (event.keyCode == 27);     // escape

    // For these keys, make sure it's a browser keycode and not an ASCII code.
    var mozNonPrintable =
      (event.keyCode == 19)  ||  // pause
      (event.keyCode == 20)  ||  // caps lock
      (event.keyCode == 45)  ||  // insert
      (event.keyCode == 46)  ||  // delete
      (event.keyCode == 144) ||  // num lock
      (event.keyCode == 145) ||  // scroll lock
      (event.keyCode > 32 && event.keyCode < 41)   || // page up/down, end, home, arrows
      (event.keyCode > 111 && event.keyCode < 124); // fn keys

    return !anyNonPrintable && !(event.charCode == 0 && mozNonPrintable);
  },

  _onKeypress: function(event) {
    if (!this.allowedPattern && this.type !== 'number') {
      return;
    }
    var regexp = this._patternRegExp;
    if (!regexp) {
      return;
    }

    // Handle special keys and backspace
    if (event.metaKey || event.ctrlKey || event.altKey) {
      return;
    }

    // Check the pattern either here or in `_onInput`, but not in both.
    this._patternAlreadyChecked = true;

    var thisChar = String.fromCharCode(event.charCode);
    if (this._isPrintable(event) && !regexp.test(thisChar)) {
      event.preventDefault();
      this._announceInvalidCharacter('Invalid character ' + thisChar + ' not entered.');
    }
  },

  _checkPatternValidity: function() {
    var regexp = this._patternRegExp;
    if (!regexp) {
      return true;
    }
    for (var i = 0; i < this.inputElement.value.length; i++) {
      if (!regexp.test(this.inputElement.value[i])) {
        return false;
      }
    }
    return true;
  },

  /**
   * Returns true if `value` is valid. The validator provided in `validator` will be used first,
   * then any constraints.
   * @return {boolean} True if the value is valid.
   */
  validate: function() {
    if (!this.inputElement) {
      this.invalid = false;
      return true;
    }

    // Use the nested input's native validity.
    var valid =  this.inputElement.checkValidity();

    // Only do extra checking if the browser thought this was valid.
    if (valid) {
      // Empty, required input is invalid
      if (this.required && this.bindValue === '') {
        valid = false;
      } else if (this.hasValidator()) {
        valid = __WEBPACK_IMPORTED_MODULE_2__iron_validatable_behavior_iron_validatable_behavior_js__["a" /* IronValidatableBehavior */].validate.call(this, this.bindValue);
      }
    }

    this.invalid = !valid;
    this.fire('iron-input-validate');
    return valid;
  },

  _announceInvalidCharacter: function(message) {
    this.fire('iron-announce', { text: message });
  },

  _computeValue: function(bindValue) {
    return bindValue;
  }
});


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);



const IronA11yAnnouncer = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
        position: fixed;
        clip: rect(0px,0px,0px,0px);
      }
    </style>
    <div aria-live\$="[[mode]]">[[_text]]</div>
`,

  is: 'iron-a11y-announcer',

  properties: {

    /**
     * The value of mode is used to set the `aria-live` attribute
     * for the element that will be announced. Valid values are: `off`,
     * `polite` and `assertive`.
     */
    mode: {
      type: String,
      value: 'polite'
    },

    _text: {
      type: String,
      value: ''
    }
  },

  created: function() {
    if (!IronA11yAnnouncer.instance) {
      IronA11yAnnouncer.instance = this;
    }

    document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
  },

  /**
   * Cause a text string to be announced by screen readers.
   *
   * @param {string} text The text that should be announced.
   */
  announce: function(text) {
    this._text = '';
    this.async(function() {
      this._text = text;
    }, 100);
  },

  _onIronAnnounce: function(event) {
    if (event.detail && event.detail.text) {
      this.announce(event.detail.text);
    }
  }
});
/* harmony export (immutable) */ __webpack_exports__["a"] = IronA11yAnnouncer;


IronA11yAnnouncer.instance = null;

IronA11yAnnouncer.requestAvailability = function() {
  if (!IronA11yAnnouncer.instance) {
    IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
  }

  document.body.appendChild(IronA11yAnnouncer.instance);
};


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IronMeta; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);



/**
 * @constructor
 * @param {{type: (string|null), key: (string|null), value: *}} options
 */
function IronMeta(options) {
  this.type = (options && options.type) || 'default';
  this.key = options && options.key;
  if ('value' in options) {
    this.value = options.value;
  }
}

IronMeta.types = {};

IronMeta.prototype = {
  get value() {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      return IronMeta.types[type] && IronMeta.types[type][key];
    }
  },

  set value(value) {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      type = IronMeta.types[type] = IronMeta.types[type] || {};
      if (value == null) {
        delete type[key];
      } else {
        type[key] = value;
      }
    }
  },

  get list() {
    var type = this.type;

    if (type) {
      return Object.keys(IronMeta.types[this.type]).map(function(key) {
        return metaDatas[this.type][key];
      }, this);
    }
  },

  byKey: function(key) {
    this.key = key;
    return this.value;
  }
};



var metaDatas = IronMeta.types;

Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({

  is: 'iron-meta',

  properties: {

    /**
     * The type of meta-data.  All meta-data of the same type is stored
     * together.
     * @type {string}
     */
    type: {
      type: String,
      value: 'default',
    },

    /**
     * The key used to store `value` under the `type` namespace.
     * @type {?string}
     */
    key: {
      type: String,
    },

    /**
     * The meta-data to store or retrieve.
     * @type {*}
     */
    value: {
      type: String,
      notify: true,
    },

    /**
     * If true, `value` is set to the iron-meta instance itself.
     */
     self: {
      type: Boolean,
      observer: '_selfChanged'
    },

    __meta: {
      type: Boolean,
      computed: '__computeMeta(type, key, value)'
    }
  },

  hostAttributes: {
    hidden: true
  },

  __computeMeta: function(type, key, value) {
    var meta = new IronMeta({
      type: type,
      key: key
    });

    if (value !== undefined && value !== meta.value) {
      meta.value = value;
    } else if (this.value !== meta.value) {
      this.value = meta.value;
    }

    return meta;
  },

  get list() {
    return this.__meta && this.__meta.list;
  },

  _selfChanged: function(self) {
    if (self) {
      this.value = this;
    }
  },

  /**
   * Retrieves meta data value by key.
   *
   * @method byKey
   * @param {string} key The key of the meta-data to be returned.
   * @return {*}
   */
  byKey: function(key) {
    return new IronMeta({
      type: this.type,
      key: key
    }).value;
  }
});


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_control_state_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_polymer_element_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





const PaperInputHelper = {};
/* unused harmony export PaperInputHelper */

PaperInputHelper.NextLabelID = 1;
PaperInputHelper.NextAddonID = 1;

const PaperInputBehaviorImpl = {

  properties: {
    /**
     * Fired when the input changes due to user interaction.
     *
     * @event change
     */

    /**
     * The label for this input. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * `<label>`'s content and `hidden` property, e.g.
     * `<label hidden$="[[!label]]">[[label]]</label>` in your `template`
     */
    label: {
      type: String
    },

    /**
     * The value for this input. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<iron-input>`'s `bindValue`
     * property, or the value property of your input that is `notify:true`.
     */
    value: {
      notify: true,
      type: String
    },

    /**
     * Set to true to disable this input. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * both the `<paper-input-container>`'s and the input's `disabled` property.
     */
    disabled: {
      type: Boolean,
      value: false
    },

    /**
     * Returns true if the value is invalid. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to both the
     * `<paper-input-container>`'s and the input's `invalid` property.
     *
     * If `autoValidate` is true, the `invalid` attribute is managed automatically,
     * which can clobber attempts to manage it manually.
     */
    invalid: {
      type: Boolean,
      value: false,
      notify: true
    },

    /**
     * Set this to specify the pattern allowed by `preventInvalidInput`. If
     * you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `allowedPattern`
     * property.
     */
    allowedPattern: {
      type: String
    },

    /**
     * The type of the input. The supported types are `text`, `number` and `password`.
     * If you're using PaperInputBehavior to implement your own paper-input-like element,
     * bind this to the `<input is="iron-input">`'s `type` property.
     */
    type: {
      type: String
    },

    /**
     * The datalist of the input (if any). This should match the id of an existing `<datalist>`.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `list` property.
     */
    list: {
      type: String
    },

    /**
     * A pattern to validate the `input` with. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<input is="iron-input">`'s `pattern` property.
     */
    pattern: {
      type: String
    },

    /**
     * Set to true to mark the input as required. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<input is="iron-input">`'s `required` property.
     */
    required: {
      type: Boolean,
      value: false
    },

    /**
     * The error message to display when the input is invalid. If you're using
     * PaperInputBehavior to implement your own paper-input-like element,
     * bind this to the `<paper-input-error>`'s content, if using.
     */
    errorMessage: {
      type: String
    },

    /**
     * Set to true to show a character counter.
     */
    charCounter: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to disable the floating label. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<paper-input-container>`'s `noLabelFloat` property.
     */
    noLabelFloat: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to always float the label. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<paper-input-container>`'s `alwaysFloatLabel` property.
     */
    alwaysFloatLabel: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to auto-validate the input value. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<paper-input-container>`'s `autoValidate` property.
     */
    autoValidate: {
      type: Boolean,
      value: false
    },

    /**
     * Name of the validator to use. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<input is="iron-input">`'s `validator` property.
     */
    validator: {
      type: String
    },

    // HTMLInputElement attributes for binding if needed

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autocomplete` property.
     */
    autocomplete: {
      type: String,
      value: 'off'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autofocus` property.
     */
    autofocus: {
      type: Boolean,
      observer: '_autofocusChanged'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `inputmode` property.
     */
    inputmode: {
      type: String
    },

    /**
     * The minimum length of the input value.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `minlength` property.
     */
    minlength: {
      type: Number
    },

    /**
     * The maximum length of the input value.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `maxlength` property.
     */
    maxlength: {
      type: Number
    },

    /**
     * The minimum (numeric or date-time) input value.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `min` property.
     */
    min: {
      type: String
    },

    /**
     * The maximum (numeric or date-time) input value.
     * Can be a String (e.g. `"2000-01-01"`) or a Number (e.g. `2`).
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `max` property.
     */
    max: {
      type: String
    },

    /**
     * Limits the numeric or date-time increments.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `step` property.
     */
    step: {
      type: String
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `name` property.
     */
    name: {
      type: String
    },

    /**
     * A placeholder string in addition to the label. If this is set, the label will always float.
     */
    placeholder: {
      type: String,
      // need to set a default so _computeAlwaysFloatLabel is run
      value: ''
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `readonly` property.
     */
    readonly: {
      type: Boolean,
      value: false
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `size` property.
     */
    size: {
      type: Number
    },

    // Nonstandard attributes for binding if needed

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autocapitalize` property.
     */
    autocapitalize: {
      type: String,
      value: 'none'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autocorrect` property.
     */
    autocorrect: {
      type: String,
      value: 'off'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autosave` property,
     * used with type=search.
     */
    autosave: {
      type: String
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `results` property,
     * used with type=search.
     */
    results: {
      type: Number
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `accept` property,
     * used with type=file.
     */
    accept: {
      type: String
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the`<input is="iron-input">`'s `multiple` property,
     * used with type=file.
     */
    multiple: {
      type: Boolean
    },

    _ariaDescribedBy: {
      type: String,
      value: ''
    },

    _ariaLabelledBy: {
      type: String,
      value: ''
    }

  },

  listeners: {
    'addon-attached': '_onAddonAttached',
  },

  keyBindings: {
    'shift+tab:keydown': '_onShiftTabDown'
  },

  hostAttributes: {
    tabindex: 0
  },

  /**
   * Returns a reference to the input element.
   */
  get inputElement() {
    return this.$.input;
  },

  /**
   * Returns a reference to the focusable element.
   */
  get _focusableElement() {
    return this.inputElement;
  },

  created: function() {
    // These types have some default placeholder text; overlapping
    // the label on top of it looks terrible. Auto-float the label in this case.
    this._typesThatHaveText = ["date", "datetime", "datetime-local", "month",
        "time", "week", "file"];
  },

  attached: function() {
    this._updateAriaLabelledBy();

    // In the 2.0 version of the element, this is handled in `onIronInputReady`,
    // i.e. after the native input has finished distributing. In the 1.0 version,
    // the input is in the shadow tree, so it's already available.
    if (!__WEBPACK_IMPORTED_MODULE_3__polymer_polymer_element_js__["a" /* Element */] && this.inputElement &&
        this._typesThatHaveText.indexOf(this.inputElement.type) !== -1) {
      this.alwaysFloatLabel = true;
    }
  },

  _appendStringWithSpace: function(str, more) {
    if (str) {
      str = str + ' ' + more;
    } else {
      str = more;
    }
    return str;
  },

  _onAddonAttached: function(event) {
    var target = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).rootTarget;
    if (target.id) {
      this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
    } else {
      var id = 'paper-input-add-on-' + PaperInputHelper.NextAddonID++;
      target.id = id;
      this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
    }
  },

  /**
   * Validates the input element and sets an error style if needed.
   *
   * @return {boolean}
   */
  validate: function() {
    return this.inputElement.validate();
  },

  /**
   * Forward focus to inputElement. Overriden from IronControlState.
   */
  _focusBlurHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_control_state_js__["a" /* IronControlState */]._focusBlurHandler.call(this, event);

    // Forward the focus to the nested input.
    if (this.focused && !this._shiftTabPressed && this._focusableElement) {
      this._focusableElement.focus();
    }
  },

  /**
   * Handler that is called when a shift+tab keypress is detected by the menu.
   *
   * @param {CustomEvent} event A key combination event.
   */
  _onShiftTabDown: function(event) {
    var oldTabIndex = this.getAttribute('tabindex');
    this._shiftTabPressed = true;
    this.setAttribute('tabindex', '-1');
    this.async(function() {
      this.setAttribute('tabindex', oldTabIndex);
      this._shiftTabPressed = false;
    }, 1);
  },

  /**
   * If `autoValidate` is true, then validates the element.
   */
  _handleAutoValidate: function() {
    if (this.autoValidate)
      this.validate();
  },

  /**
   * Restores the cursor to its original position after updating the value.
   * @param {string} newValue The value that should be saved.
   */
  updateValueAndPreserveCaret: function(newValue) {
    // Not all elements might have selection, and even if they have the
    // right properties, accessing them might throw an exception (like for
    // <input type=number>)
    try {
      var start = this.inputElement.selectionStart;
      this.value = newValue;

      // The cursor automatically jumps to the end after re-setting the value,
      // so restore it to its original position.
      this.inputElement.selectionStart = start;
      this.inputElement.selectionEnd = start;
    } catch (e) {
      // Just set the value and give up on the caret.
      this.value = newValue;
    }
  },

  _computeAlwaysFloatLabel: function(alwaysFloatLabel, placeholder) {
    return placeholder || alwaysFloatLabel;
  },

  _updateAriaLabelledBy: function() {
    var label = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.root).querySelector('label');
    if (!label) {
      this._ariaLabelledBy = '';
      return;
    }
    var labelledBy;
    if (label.id) {
      labelledBy = label.id;
    } else {
      labelledBy = 'paper-input-label-' + PaperInputHelper.NextLabelID++;
      label.id = labelledBy;
    }
    this._ariaLabelledBy = labelledBy;
  },

  _onChange:function(event) {
    // In the Shadow DOM, the `change` event is not leaked into the
    // ancestor tree, so we must do this manually.
    // See https://w3c.github.io/webcomponents/spec/shadow/#events-that-are-not-leaked-into-ancestor-trees.
    if (this.shadowRoot) {
      this.fire(event.type, {sourceEvent: event}, {
        node: this,
        bubbles: event.bubbles,
        cancelable: event.cancelable
      });
    }
  },

  _autofocusChanged: function() {
    // Firefox doesn't respect the autofocus attribute if it's applied after
    // the page is loaded (Chrome/WebKit do respect it), preventing an
    // autofocus attribute specified in markup from taking effect when the
    // element is upgraded. As a workaround, if the autofocus property is set,
    // and the focus hasn't already been moved elsewhere, we take focus.
    if (this.autofocus && this._focusableElement) {

      // In IE 11, the default document.activeElement can be the page's
      // outermost html element, but there are also cases (under the
      // polyfill?) in which the activeElement is not a real HTMLElement, but
      // just a plain object. We identify the latter case as having no valid
      // activeElement.
      var activeElement = document.activeElement;
      var isActiveElementValid = activeElement instanceof HTMLElement;

      // Has some other element has already taken the focus?
      var isSomeElementActive = isActiveElementValid &&
          activeElement !== document.body &&
          activeElement !== document.documentElement; /* IE 11 */
      if (!isSomeElementActive) {
        // No specific element has taken the focus yet, so we can take it.
        this._focusableElement.focus();
      }
    }
  }
};
/* unused harmony export PaperInputBehaviorImpl */


const PaperInputBehavior = [
  __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_control_state_js__["a" /* IronControlState */],
  __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */],
  PaperInputBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperInputBehavior;



/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_input_addon_behavior_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);




Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
        float: right;

        @apply --paper-font-caption;
        @apply --paper-input-char-counter;
      }

      :host([hidden]) {
        display: none !important;
      }

      :host-context([dir="rtl"]) {
        float: left;
      }
    </style>

    <span>[[_charCounterStr]]</span>
`,

  is: 'paper-input-char-counter',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_input_addon_behavior_js__["a" /* PaperInputAddonBehavior */]
  ],

  properties: {
    _charCounterStr: {
      type: String,
      value: '0'
    }
  },

  /**
   * This overrides the update function in PaperInputAddonBehavior.
   * @param {{
   *   inputElement: (Element|undefined),
   *   value: (string|undefined),
   *   invalid: boolean
   * }} state -
   *     inputElement: The input element.
   *     value: The input value.
   *     invalid: True if the input value is invalid.
   */
  update: function(state) {
    if (!state.inputElement) {
      return;
    }

    state.value = state.value || '';

    var counter = state.value.toString().length.toString();

    if (state.inputElement.hasAttribute('maxlength')) {
      counter += '/' + state.inputElement.getAttribute('maxlength');
    }

    this._charCounterStr = counter;
  }
});


/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_lib_utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);







Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: block;
        padding: 8px 0;

        --paper-input-container-shared-input-style: {
          position: relative; /* to make a stacking context */
          outline: none;
          box-shadow: none;
          padding: 0;
          width: 100%;
          max-width: 100%;
          background: transparent;
          border: none;
          color: var(--paper-input-container-input-color, var(--primary-text-color));
          -webkit-appearance: none;
          text-align: inherit;
          vertical-align: bottom;

          @apply --paper-font-subhead;
        };

        @apply --paper-input-container;
      }

      :host([inline]) {
        display: inline-block;
      }

      :host([disabled]) {
        pointer-events: none;
        opacity: 0.33;

        @apply --paper-input-container-disabled;
      }

      :host([hidden]) {
        display: none !important;
      }

      [hidden] {
        display: none !important;
      }

      .floated-label-placeholder {
        @apply --paper-font-caption;
      }

      .underline {
        height: 2px;
        position: relative;
      }

      .focused-line {
        @apply --layout-fit;
        border-bottom: 2px solid var(--paper-input-container-focus-color, var(--primary-color));

        -webkit-transform-origin: center center;
        transform-origin: center center;
        -webkit-transform: scale3d(0,1,1);
        transform: scale3d(0,1,1);

        @apply --paper-input-container-underline-focus;
      }

      .underline.is-highlighted .focused-line {
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply --paper-transition-easing;
      }

      .underline.is-invalid .focused-line {
        border-color: var(--paper-input-container-invalid-color, var(--error-color));
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply --paper-transition-easing;
      }

      .unfocused-line {
        @apply --layout-fit;
        border-bottom: 1px solid var(--paper-input-container-color, var(--secondary-text-color));
        @apply --paper-input-container-underline;
      }

      :host([disabled]) .unfocused-line {
        border-bottom: 1px dashed;
        border-color: var(--paper-input-container-color, var(--secondary-text-color));
        @apply --paper-input-container-underline-disabled;
      }

      .input-wrapper {
        @apply --layout-horizontal;
        @apply --layout-center;
        position: relative;
      }

      .input-content {
        @apply --layout-flex-auto;
        @apply --layout-relative;
        max-width: 100%;
      }

      .input-content ::slotted(label),
      .input-content ::slotted(.paper-input-label) {
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
        width: 100%;
        font: inherit;
        color: var(--paper-input-container-color, var(--secondary-text-color));
        -webkit-transition: -webkit-transform 0.25s, width 0.25s;
        transition: transform 0.25s, width 0.25s;
        -webkit-transform-origin: left top;
        transform-origin: left top;

        @apply --paper-font-common-nowrap;
        @apply --paper-font-subhead;
        @apply --paper-input-container-label;
        @apply --paper-transition-easing;
      }

      .input-content.label-is-floating ::slotted(label),
      .input-content.label-is-floating ::slotted(.paper-input-label) {
        -webkit-transform: translateY(-75%) scale(0.75);
        transform: translateY(-75%) scale(0.75);

        /* Since we scale to 75/100 of the size, we actually have 100/75 of the
        original space now available */
        width: 133%;

        @apply --paper-input-container-label-floating;
      }

      :host-context([dir="rtl"]) .input-content.label-is-floating ::slotted(label),
      :host-context([dir="rtl"]) .input-content.label-is-floating ::slotted(.paper-input-label) {
        /* TODO(noms): Figure out why leaving the width at 133% before the animation
         * actually makes
         * it wider on the right side, not left side, as you would expect in RTL */
        width: 100%;
        -webkit-transform-origin: right top;
        transform-origin: right top;
      }

      .input-content.label-is-highlighted ::slotted(label),
      .input-content.label-is-highlighted ::slotted(.paper-input-label) {
        color: var(--paper-input-container-focus-color, var(--primary-color));

        @apply --paper-input-container-label-focus;
      }

      .input-content.is-invalid ::slotted(label),
      .input-content.is-invalid ::slotted(.paper-input-label) {
        color: var(--paper-input-container-invalid-color, var(--error-color));
      }

      .input-content.label-is-hidden ::slotted(label),
      .input-content.label-is-hidden ::slotted(.paper-input-label) {
        visibility: hidden;
      }

      .input-content ::slotted(iron-input) {
        @apply --paper-input-container-shared-input-style;
      }
      
      .input-content ::slotted(input),
      .input-content ::slotted(textarea),
      .input-content ::slotted(iron-autogrow-textarea),
      .input-content ::slotted(.paper-input-input) {
        @apply --paper-input-container-shared-input-style;
        @apply --paper-input-container-input;
      }

      .input-content ::slotted(input)::-webkit-outer-spin-button,
      .input-content ::slotted(input)::-webkit-inner-spin-button {
        @apply --paper-input-container-input-webkit-spinner;
      }
      
      .input-content.focused ::slotted(input),
      .input-content.focused ::slotted(textarea),
      .input-content.focused ::slotted(iron-autogrow-textarea),
      .input-content.focused ::slotted(.paper-input-input) {
        @apply --paper-input-container-input-focus;
      }

      .input-content.is-invalid ::slotted(input),
      .input-content.is-invalid ::slotted(textarea),
      .input-content.is-invalid ::slotted(iron-autogrow-textarea),
      .input-content.is-invalid ::slotted(.paper-input-input) {
        @apply --paper-input-container-input-invalid;
      }
      
      .prefix ::slotted(*) {
        display: inline-block;
        @apply --paper-font-subhead;
        @apply --layout-flex-none;
        @apply --paper-input-prefix;
      }

      .suffix ::slotted(*) {
        display: inline-block;
        @apply --paper-font-subhead;
        @apply --layout-flex-none;

        @apply --paper-input-suffix;
      }

      /* Firefox sets a min-width on the input, which can cause layout issues */
      .input-content ::slotted(input) {
        min-width: 0;
      }

      .input-content ::slotted(textarea) {
        resize: none;
      }

      .add-on-content {
        position: relative;
      }

      .add-on-content.is-invalid ::slotted(*) {
        color: var(--paper-input-container-invalid-color, var(--error-color));
      }

      .add-on-content.is-highlighted ::slotted(*) {
        color: var(--paper-input-container-focus-color, var(--primary-color));
      }
    </style>

    <div class="floated-label-placeholder" aria-hidden="true" hidden="[[noLabelFloat]]">&nbsp;</div>

    <div class="input-wrapper">
      <span class="prefix"><slot name="prefix"></slot></span>

      <div class\$="[[_computeInputContentClass(noLabelFloat,alwaysFloatLabel,focused,invalid,_inputHasContent)]]" id="labelAndInputContainer">
        <slot name="label"></slot>
        <slot name="input"></slot>
      </div>

      <span class="suffix"><slot name="suffix"></slot></span>
    </div>

    <div class\$="[[_computeUnderlineClass(focused,invalid)]]">
      <div class="unfocused-line"></div>
      <div class="focused-line"></div>
    </div>

    <div class\$="[[_computeAddOnContentClass(focused,invalid)]]">
      <slot name="add-on"></slot>
    </div>
`,

  is: 'paper-input-container',

  properties: {
    /**
     * Set to true to disable the floating label. The label disappears when the input value is
     * not null.
     */
    noLabelFloat: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to always float the floating label.
     */
    alwaysFloatLabel: {
      type: Boolean,
      value: false
    },

    /**
     * The attribute to listen for value changes on.
     */
    attrForValue: {
      type: String,
      value: 'bind-value'
    },

    /**
     * Set to true to auto-validate the input value when it changes.
     */
    autoValidate: {
      type: Boolean,
      value: false
    },

    /**
     * True if the input is invalid. This property is set automatically when the input value
     * changes if auto-validating, or when the `iron-input-validate` event is heard from a child.
     */
    invalid: {
      observer: '_invalidChanged',
      type: Boolean,
      value: false
    },

    /**
     * True if the input has focus.
     */
    focused: {
      readOnly: true,
      type: Boolean,
      value: false,
      notify: true
    },

    _addons: {
      type: Array
      // do not set a default value here intentionally - it will be initialized lazily when a
      // distributed child is attached, which may occur before configuration for this element
      // in polyfill.
    },

    _inputHasContent: {
      type: Boolean,
      value: false
    },

    _inputSelector: {
      type: String,
      value: 'input,iron-input,textarea,.paper-input-input'
    },

    _boundOnFocus: {
      type: Function,
      value: function() {
        return this._onFocus.bind(this);
      }
    },

    _boundOnBlur: {
      type: Function,
      value: function() {
        return this._onBlur.bind(this);
      }
    },

    _boundOnInput: {
      type: Function,
      value: function() {
        return this._onInput.bind(this);
      }
    },

    _boundValueChanged: {
      type: Function,
      value: function() {
        return this._onValueChanged.bind(this);
      }
    }
  },

  listeners: {
    'addon-attached': '_onAddonAttached',
    'iron-input-validate': '_onIronInputValidate'
  },

  get _valueChangedEvent() {
    return this.attrForValue + '-changed';
  },

  get _propertyForValue() {
    return Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_utils_case_map_js__["dashToCamelCase"])(this.attrForValue);
  },

  get _inputElement() {
    return Object(__WEBPACK_IMPORTED_MODULE_6__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).querySelector(this._inputSelector);
  },

  get _inputElementValue() {
    return this._inputElement[this._propertyForValue] || this._inputElement.value;
  },

  ready: function() {
    if (!this._addons) {
      this._addons = [];
    }
    this.addEventListener('focus', this._boundOnFocus, true);
    this.addEventListener('blur', this._boundOnBlur, true);
  },

  attached: function() {
    if (this.attrForValue) {
      this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged);
    } else {
      this.addEventListener('input', this._onInput);
    }

    // Only validate when attached if the input already has a value.
    if (this._inputElementValue && this._inputElementValue != '') {
      this._handleValueAndAutoValidate(this._inputElement);
    } else {
      this._handleValue(this._inputElement);
    }
  },

  _onAddonAttached: function(event) {
    if (!this._addons) {
      this._addons = [];
    }
    var target = event.target;
    if (this._addons.indexOf(target) === -1) {
      this._addons.push(target);
      if (this.isAttached) {
        this._handleValue(this._inputElement);
      }
    }
  },

  _onFocus: function() {
    this._setFocused(true);
  },

  _onBlur: function() {
    this._setFocused(false);
    this._handleValueAndAutoValidate(this._inputElement);
  },

  _onInput: function(event) {
    this._handleValueAndAutoValidate(event.target);
  },

  _onValueChanged: function(event) {
    var input = event.target;

    // Problem: if the input is required but has no text entered, we should
    // only validate it on blur (so that an empty form doesn't come up red
    // immediately; however, in this handler, we don't know whether this is
    // the booting up value or a value in the future. I am assuming that the
    // case  we care about manifests itself when the value is undefined.
    // If this causes future problems, we need to do something like track whether
    // the iron-input-ready event has fired, and this handler came before that.

    if (input.value === undefined) {
      return;
    }

    this._handleValueAndAutoValidate(event.target);
  },

  _handleValue: function(inputElement) {
    var value = this._inputElementValue;

    // type="number" hack needed because this.value is empty until it's valid
    if (value || value === 0 || (inputElement.type === 'number' && !inputElement.checkValidity())) {
      this._inputHasContent = true;
    } else {
      this._inputHasContent = false;
    }

    this.updateAddons({
      inputElement: inputElement,
      value: value,
      invalid: this.invalid
    });
  },

  _handleValueAndAutoValidate: function(inputElement) {
    if (this.autoValidate && inputElement) {
      var valid;

      if (inputElement.validate) {
        valid = inputElement.validate(this._inputElementValue);
      } else {
        valid = inputElement.checkValidity();
      }
      this.invalid = !valid;
    }

    // Call this last to notify the add-ons.
    this._handleValue(inputElement);
  },

  _onIronInputValidate: function(event) {
    this.invalid = this._inputElement.invalid;
  },

  _invalidChanged: function() {
    if (this._addons) {
      this.updateAddons({invalid: this.invalid});
    }
  },

  /**
   * Call this to update the state of add-ons.
   * @param {Object} state Add-on state.
   */
  updateAddons: function(state) {
    for (var addon, index = 0; addon = this._addons[index]; index++) {
      addon.update(state);
    }
  },

  _computeInputContentClass: function(noLabelFloat, alwaysFloatLabel, focused, invalid, _inputHasContent) {
    var cls = 'input-content';
    if (!noLabelFloat) {
      var label = this.querySelector('label');

      if (alwaysFloatLabel || _inputHasContent) {
        cls += ' label-is-floating';
        // If the label is floating, ignore any offsets that may have been
        // applied from a prefix element.
        this.$.labelAndInputContainer.style.position = 'static';

        if (invalid) {
          cls += ' is-invalid';
        } else if (focused) {
          cls += " label-is-highlighted";
        }
      } else {
        // When the label is not floating, it should overlap the input element.
        if (label) {
          this.$.labelAndInputContainer.style.position = 'relative';
        }
        if (invalid) {
          cls += ' is-invalid';
        }
      }
    } else {
      if (_inputHasContent) {
        cls += ' label-is-hidden';
      }
      if (invalid) {
        cls += ' is-invalid';
      }
    }
    if (focused) {
      cls += ' focused';
    }
    return cls;
  },

  _computeUnderlineClass: function(focused, invalid) {
    var cls = 'underline';
    if (invalid) {
      cls += ' is-invalid';
    } else if (focused) {
      cls += ' is-highlighted'
    }
    return cls;
  },

  _computeAddOnContentClass: function(focused, invalid) {
    var cls = 'add-on-content';
    if (invalid) {
      cls += ' is-invalid';
    } else if (focused) {
      cls += ' is-highlighted'
    }
    return cls;
  }
});


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_input_addon_behavior_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);





Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
        visibility: hidden;

        color: var(--paper-input-container-invalid-color, var(--error-color));

        @apply --paper-font-caption;
        @apply --paper-input-error;
        position: absolute;
        left:0;
        right:0;
      }

      :host([invalid]) {
        visibility: visible;
      };
    </style>

    <slot></slot>
`,

  is: 'paper-input-error',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_3__paper_input_addon_behavior_js__["a" /* PaperInputAddonBehavior */]
  ],

  properties: {
    /**
     * True if the error is showing.
     */
    invalid: {
      readOnly: true,
      reflectToAttribute: true,
      type: Boolean
    }
  },

  /**
   * This overrides the update function in PaperInputAddonBehavior.
   * @param {{
   *   inputElement: (Element|undefined),
   *   value: (string|undefined),
   *   invalid: boolean
   * }} state -
   *     inputElement: The input element.
   *     value: The input value.
   *     invalid: True if the input value is invalid.
   */
  update: function(state) {
    this._setInvalid(state.invalid);
  }
});


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_checked_element_behavior_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_utils_render_status_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__paper_behaviors_paper_inky_focus_behavior_js__ = __webpack_require__(49);






const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-checkbox">
  <template strip-whitespace="">
    <style>
      :host {
        display: inline-block;
        white-space: nowrap;
        cursor: pointer;
        --calculated-paper-checkbox-size: var(--paper-checkbox-size, 18px);
        /* -1px is a sentinel for the default and is replaced in \`attached\`. */
        --calculated-paper-checkbox-ink-size: var(--paper-checkbox-ink-size, -1px);
        @apply --paper-font-common-base;
        line-height: 0;
        -webkit-tap-highlight-color: transparent;
      }

      :host([hidden]) {
        display: none !important;
      }

      :host(:focus) {
        outline: none;
      }

      .hidden {
        display: none;
      }

      #checkboxContainer {
        display: inline-block;
        position: relative;
        width: var(--calculated-paper-checkbox-size);
        height: var(--calculated-paper-checkbox-size);
        min-width: var(--calculated-paper-checkbox-size);
        margin: var(--paper-checkbox-margin, initial);
        vertical-align: var(--paper-checkbox-vertical-align, middle);
        background-color: var(--paper-checkbox-unchecked-background-color, transparent);
      }

      #ink {
        position: absolute;

        /* Center the ripple in the checkbox by negative offsetting it by
         * (inkWidth - rippleWidth) / 2 */
        top: calc(0px - (var(--calculated-paper-checkbox-ink-size) - var(--calculated-paper-checkbox-size)) / 2);
        left: calc(0px - (var(--calculated-paper-checkbox-ink-size) - var(--calculated-paper-checkbox-size)) / 2);
        width: var(--calculated-paper-checkbox-ink-size);
        height: var(--calculated-paper-checkbox-ink-size);
        color: var(--paper-checkbox-unchecked-ink-color, var(--primary-text-color));
        opacity: 0.6;
        pointer-events: none;
      }

      :host-context([dir="rtl"]) #ink {
        right: calc(0px - (var(--calculated-paper-checkbox-ink-size) - var(--calculated-paper-checkbox-size)) / 2);
        left: auto;
      }

      #ink[checked] {
        color: var(--paper-checkbox-checked-ink-color, var(--primary-color));
      }

      #checkbox {
        position: relative;
        box-sizing: border-box;
        height: 100%;
        border: solid 2px;
        border-color: var(--paper-checkbox-unchecked-color, var(--primary-text-color));
        border-radius: 2px;
        pointer-events: none;
        -webkit-transition: background-color 140ms, border-color 140ms;
        transition: background-color 140ms, border-color 140ms;
      }

      /* checkbox checked animations */
      #checkbox.checked #checkmark {
        -webkit-animation: checkmark-expand 140ms ease-out forwards;
        animation: checkmark-expand 140ms ease-out forwards;
      }

      @-webkit-keyframes checkmark-expand {
        0% {
          -webkit-transform: scale(0, 0) rotate(45deg);
        }
        100% {
          -webkit-transform: scale(1, 1) rotate(45deg);
        }
      }

      @keyframes checkmark-expand {
        0% {
          transform: scale(0, 0) rotate(45deg);
        }
        100% {
          transform: scale(1, 1) rotate(45deg);
        }
      }

      #checkbox.checked {
        background-color: var(--paper-checkbox-checked-color, var(--primary-color));
        border-color: var(--paper-checkbox-checked-color, var(--primary-color));
      }

      #checkmark {
        position: absolute;
        width: 36%;
        height: 70%;
        border-style: solid;
        border-top: none;
        border-left: none;
        border-right-width: calc(2/15 * var(--calculated-paper-checkbox-size));
        border-bottom-width: calc(2/15 * var(--calculated-paper-checkbox-size));
        border-color: var(--paper-checkbox-checkmark-color, white);
        -webkit-transform-origin: 97% 86%;
        transform-origin: 97% 86%;
        box-sizing: content-box; /* protect against page-level box-sizing */
      }

      :host-context([dir="rtl"]) #checkmark {
        -webkit-transform-origin: 50% 14%;
        transform-origin: 50% 14%;
      }

      /* label */
      #checkboxLabel {
        position: relative;
        display: inline-block;
        vertical-align: middle;
        padding-left: var(--paper-checkbox-label-spacing, 8px);
        white-space: normal;
        line-height: normal;
        color: var(--paper-checkbox-label-color, var(--primary-text-color));
        @apply --paper-checkbox-label;
      }

      :host([checked]) #checkboxLabel {
        color: var(--paper-checkbox-label-checked-color, var(--paper-checkbox-label-color, var(--primary-text-color)));
        @apply --paper-checkbox-label-checked;
      }

      :host-context([dir="rtl"]) #checkboxLabel {
        padding-right: var(--paper-checkbox-label-spacing, 8px);
        padding-left: 0;
      }

      #checkboxLabel[hidden] {
        display: none;
      }

      /* disabled state */

      :host([disabled]) #checkbox {
        opacity: 0.5;
        border-color: var(--paper-checkbox-unchecked-color, var(--primary-text-color));
      }

      :host([disabled][checked]) #checkbox {
        background-color: var(--paper-checkbox-unchecked-color, var(--primary-text-color));
        opacity: 0.5;
      }

      :host([disabled]) #checkboxLabel  {
        opacity: 0.65;
      }

      /* invalid state */
      #checkbox.invalid:not(.checked) {
        border-color: var(--paper-checkbox-error-color, var(--error-color));
      }
    </style>

    <div id="checkboxContainer">
      <div id="checkbox" class\$="[[_computeCheckboxClass(checked, invalid)]]">
        <div id="checkmark" class\$="[[_computeCheckmarkClass(checked)]]"></div>
      </div>
    </div>

    <div id="checkboxLabel"><slot></slot></div>
  </template>

  
</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-checkbox',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_checked_element_behavior_js__["a" /* PaperCheckedElementBehavior */]
  ],

  hostAttributes: {
    role: 'checkbox',
    'aria-checked': false,
    tabindex: 0
  },

  properties: {
    /**
     * Fired when the checked state changes due to user interaction.
     *
     * @event change
     */

    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-checked'
    }
  },

  attached: function() {
    // Wait until styles have resolved to check for the default sentinel.
    // See polymer#4009 for more details.
    Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_utils_render_status_js__["a" /* afterNextRender */])(this, function() {
      var inkSize = this.getComputedStyleValue('--calculated-paper-checkbox-ink-size').trim();
      // If unset, compute and set the default `--paper-checkbox-ink-size`.
      if (inkSize === '-1px') {
        var checkboxSizeText = this.getComputedStyleValue('--calculated-paper-checkbox-size').trim();

        var units = checkboxSizeText.match(/[A-Za-z]+$/)[0] || 'px';
        var checkboxSize = parseFloat(checkboxSizeText, 10);
        var defaultInkSize = (8 / 3) * checkboxSize;

        if (units === 'px') {
          defaultInkSize = Math.floor(defaultInkSize);

          // The checkbox and ripple need to have the same parity so that their
          // centers align.
          if (defaultInkSize % 2 !== checkboxSize % 2) {
            defaultInkSize++;
          }
        }

        this.updateStyles({
          '--paper-checkbox-ink-size': defaultInkSize + units,
        });
      }
    });
  },

  _computeCheckboxClass: function(checked, invalid) {
    var className = '';
    if (checked) {
      className += 'checked ';
    }
    if (invalid) {
      className += 'invalid';
    }
    return className;
  },

  _computeCheckmarkClass: function(checked) {
    return checked ? '' : 'hidden';
  },

  // create ripple inside the checkboxContainer
  _createRipple: function() {
    this._rippleContainer = this.$.checkboxContainer;
    return __WEBPACK_IMPORTED_MODULE_5__paper_behaviors_paper_inky_focus_behavior_js__["b" /* PaperInkyFocusBehaviorImpl */]._createRipple.call(this);
  }

});


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_validatable_behavior_iron_validatable_behavior_js__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_form_element_behavior_iron_form_element_behavior_js__ = __webpack_require__(45);




const IronCheckedElementBehaviorImpl = {

  properties: {
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */

    /**
     * Gets or sets the state, `true` is checked and `false` is unchecked.
     */
    checked: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      notify: true,
      observer: '_checkedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: true,
      reflectToAttribute: true
    },

    /* Overriden from Polymer.IronFormElementBehavior */
    value: {
      type: String,
      value: 'on',
      observer: '_valueChanged'
    }
  },

  observers: [
    '_requiredChanged(required)'
  ],

  created: function() {
    // Used by `iron-form` to handle the case that an element with this behavior
    // doesn't have a role of 'checkbox' or 'radio', but should still only be
    // included when the form is serialized if `this.checked === true`.
    this._hasIronCheckedElementBehavior = true;
  },

  /**
   * Returns false if the element is required and not checked, and true otherwise.
   * @param {*=} _value Ignored.
   * @return {boolean} true if `required` is false or if `checked` is true.
   */
  _getValidity: function(_value) {
    return this.disabled || !this.required || this.checked;
  },

  /**
   * Update the aria-required label when `required` is changed.
   */
  _requiredChanged: function() {
    if (this.required) {
      this.setAttribute('aria-required', 'true');
    } else {
      this.removeAttribute('aria-required');
    }
  },

  /**
   * Fire `iron-changed` when the checked state changes.
   */
  _checkedChanged: function() {
    this.active = this.checked;
    this.fire('iron-change');
  },

  /**
   * Reset value to 'on' if it is set to `undefined`.
   */
  _valueChanged: function() {
    if (this.value === undefined || this.value === null) {
      this.value = 'on';
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["b"] = IronCheckedElementBehaviorImpl;


const IronCheckedElementBehavior = [
  __WEBPACK_IMPORTED_MODULE_2__iron_form_element_behavior_iron_form_element_behavior_js__["a" /* IronFormElementBehavior */],
  __WEBPACK_IMPORTED_MODULE_1__iron_validatable_behavior_iron_validatable_behavior_js__["a" /* IronValidatableBehavior */],
  IronCheckedElementBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = IronCheckedElementBehavior;



/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_color_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__paper_behaviors_paper_checked_element_behavior_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polymer_lib_utils_render_status_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_lib_utils_gestures_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__paper_behaviors_paper_ripple_behavior_js__ = __webpack_require__(19);









const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-toggle-button">
  <template strip-whitespace="">

    <style>
      :host {
        display: inline-block;
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --paper-font-common-base;
      }

      :host([disabled]) {
        pointer-events: none;
      }

      :host(:focus) {
        outline:none;
      }

      .toggle-bar {
        position: absolute;
        height: 100%;
        width: 100%;
        border-radius: 8px;
        pointer-events: none;
        opacity: 0.4;
        transition: background-color linear .08s;
        background-color: var(--paper-toggle-button-unchecked-bar-color, #000000);

        @apply --paper-toggle-button-unchecked-bar;
      }

      .toggle-button {
        position: absolute;
        top: -3px;
        left: 0;
        height: 20px;
        width: 20px;
        border-radius: 50%;
        box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.6);
        transition: -webkit-transform linear .08s, background-color linear .08s;
        transition: transform linear .08s, background-color linear .08s;
        will-change: transform;
        background-color: var(--paper-toggle-button-unchecked-button-color, var(--paper-grey-50));

        @apply --paper-toggle-button-unchecked-button;
      }

      .toggle-button.dragging {
        -webkit-transition: none;
        transition: none;
      }

      :host([checked]:not([disabled])) .toggle-bar {
        opacity: 0.5;
        background-color: var(--paper-toggle-button-checked-bar-color, var(--primary-color));

        @apply --paper-toggle-button-checked-bar;
      }

      :host([disabled]) .toggle-bar {
        background-color: #000;
        opacity: 0.12;
      }

      :host([checked]) .toggle-button {
        -webkit-transform: translate(16px, 0);
        transform: translate(16px, 0);
      }

      :host([checked]:not([disabled])) .toggle-button {
        background-color: var(--paper-toggle-button-checked-button-color, var(--primary-color));

        @apply --paper-toggle-button-checked-button;
      }

      :host([disabled]) .toggle-button {
        background-color: #bdbdbd;
        opacity: 1;
      }

      .toggle-ink {
        position: absolute;
        top: -14px;
        left: -14px;
        right: auto;
        bottom: auto;
        width: 48px;
        height: 48px;
        opacity: 0.5;
        pointer-events: none;
        color: var(--paper-toggle-button-unchecked-ink-color, var(--primary-text-color));

        @apply --paper-toggle-button-unchecked-ink;
      }

      :host([checked]) .toggle-ink {
        color: var(--paper-toggle-button-checked-ink-color, var(--primary-color));

        @apply --paper-toggle-button-checked-ink;
      }

      .toggle-container {
        display: inline-block;
        position: relative;
        width: 36px;
        height: 14px;
        /* The toggle button has an absolute position of -3px; The extra 1px
        /* accounts for the toggle button shadow box. */
        margin: 4px 1px;
      }

      .toggle-label {
        position: relative;
        display: inline-block;
        vertical-align: middle;
        padding-left: var(--paper-toggle-button-label-spacing, 8px);
        pointer-events: none;
        color: var(--paper-toggle-button-label-color, var(--primary-text-color));
      }

      /* invalid state */
      :host([invalid]) .toggle-bar {
        background-color: var(--paper-toggle-button-invalid-bar-color, var(--error-color));
      }

      :host([invalid]) .toggle-button {
        background-color: var(--paper-toggle-button-invalid-button-color, var(--error-color));
      }

      :host([invalid]) .toggle-ink {
        color: var(--paper-toggle-button-invalid-ink-color, var(--error-color));
      }
    </style>

    <div class="toggle-container">
      <div id="toggleBar" class="toggle-bar"></div>
      <div id="toggleButton" class="toggle-button"></div>
    </div>

    <div class="toggle-label"><slot></slot></div>

  </template>

  
</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-toggle-button',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_4__paper_behaviors_paper_checked_element_behavior_js__["a" /* PaperCheckedElementBehavior */]
  ],

  hostAttributes: {
    role: 'button',
    'aria-pressed': 'false',
    tabindex: 0
  },

  properties: {
    /**
     * Fired when the checked state changes due to user interaction.
     *
     * @event change
     */
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */
  },

  listeners: {
    track: '_ontrack'
  },

  attached: function() {
    Object(__WEBPACK_IMPORTED_MODULE_6__polymer_lib_utils_render_status_js__["a" /* afterNextRender */])(this, function() {
      Object(__WEBPACK_IMPORTED_MODULE_7__polymer_lib_utils_gestures_js__["setTouchAction"])(this, 'pan-y');
    });
  },

  _ontrack: function(event) {
    var track = event.detail;
    if (track.state === 'start') {
      this._trackStart(track);
    } else if (track.state === 'track') {
      this._trackMove(track);
    } else if (track.state === 'end') {
      this._trackEnd(track);
    }
  },

  _trackStart: function(track) {
    this._width = this.$.toggleBar.offsetWidth / 2;
    /*
     * keep an track-only check state to keep the dragging behavior smooth
     * while toggling activations
     */
    this._trackChecked = this.checked;
    this.$.toggleButton.classList.add('dragging');
  },

  _trackMove: function(track) {
    var dx = track.dx;
    this._x = Math.min(this._width,
        Math.max(0, this._trackChecked ? this._width + dx : dx));
    this.translate3d(this._x + 'px', 0, 0, this.$.toggleButton);
    this._userActivate(this._x > (this._width / 2));
  },

  _trackEnd: function(track) {
    this.$.toggleButton.classList.remove('dragging');
    this.transform('', this.$.toggleButton);
  },

  // customize the element's ripple
  _createRipple: function() {
    this._rippleContainer = this.$.toggleButton;
    var ripple = __WEBPACK_IMPORTED_MODULE_8__paper_behaviors_paper_ripple_behavior_js__["a" /* PaperRippleBehavior */]._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('recenters', '');
    ripple.classList.add('circle', 'toggle-ink');
    return ripple;
  }

});


/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js__ = __webpack_require__(98);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js__);


var getBreakpoint = function () {
  return window.getComputedStyle(window.document.querySelector('body'), ':before').getPropertyValue('content').replace(/"/g, '');
};

function breakpoint(breakpoint, callback) {
  if (typeof callback === "function") {
    if (getBreakpoint() === breakpoint) {
      callback();
    }

    $(window).resize(function () {
      if (getBreakpoint() === breakpoint) {
        callback();
      }
    });
  } else {
    return getBreakpoint() === breakpoint;
  }
}

function desktop(callback) {
  return breakpoint("desktop", callback);
}

function tablet(callback) {
  return breakpoint("tablet", callback);
}

function phone(callback) {
  return breakpoint("phone", callback);
}

/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function(){/*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
'use strict';var p,q="undefined"!=typeof window&&window===this?this:"undefined"!=typeof global&&null!=global?global:this,ba="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};function ca(){ca=function(){};q.Symbol||(q.Symbol=da)}var da=function(){var a=0;return function(b){return"jscomp_symbol_"+(b||"")+a++}}();
function ea(){ca();var a=q.Symbol.iterator;a||(a=q.Symbol.iterator=q.Symbol("iterator"));"function"!=typeof Array.prototype[a]&&ba(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return fa(this)}});ea=function(){}}function fa(a){var b=0;return ha(function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}})}function ha(a){ea();a={next:a};a[q.Symbol.iterator]=function(){return this};return a}function ia(a){ea();var b=a[Symbol.iterator];return b?b.call(a):fa(a)}
function ja(a){for(var b,c=[];!(b=a.next()).done;)c.push(b.value);return c}
(function(){if(!function(){var a=document.createEvent("Event");a.initEvent("foo",!0,!0);a.preventDefault();return a.defaultPrevented}()){var a=Event.prototype.preventDefault;Event.prototype.preventDefault=function(){this.cancelable&&(a.call(this),Object.defineProperty(this,"defaultPrevented",{get:function(){return!0},configurable:!0}))}}var b=/Trident/.test(navigator.userAgent);if(!window.CustomEvent||b&&"function"!==typeof window.CustomEvent)window.CustomEvent=function(a,b){b=b||{};var c=document.createEvent("CustomEvent");
c.initCustomEvent(a,!!b.bubbles,!!b.cancelable,b.detail);return c},window.CustomEvent.prototype=window.Event.prototype;if(!window.Event||b&&"function"!==typeof window.Event){var c=window.Event;window.Event=function(a,b){b=b||{};var c=document.createEvent("Event");c.initEvent(a,!!b.bubbles,!!b.cancelable);return c};if(c)for(var d in c)window.Event[d]=c[d];window.Event.prototype=c.prototype}if(!window.MouseEvent||b&&"function"!==typeof window.MouseEvent){b=window.MouseEvent;window.MouseEvent=function(a,
b){b=b||{};var c=document.createEvent("MouseEvent");c.initMouseEvent(a,!!b.bubbles,!!b.cancelable,b.view||window,b.detail,b.screenX,b.screenY,b.clientX,b.clientY,b.ctrlKey,b.altKey,b.shiftKey,b.metaKey,b.button,b.relatedTarget);return c};if(b)for(d in b)window.MouseEvent[d]=b[d];window.MouseEvent.prototype=b.prototype}Array.from||(Array.from=function(a){return[].slice.call(a)});Object.assign||(Object.assign=function(a,b){for(var c=[].slice.call(arguments,1),d=0,e;d<c.length;d++)if(e=c[d])for(var f=
a,m=e,n=Object.getOwnPropertyNames(m),w=0;w<n.length;w++)e=n[w],f[e]=m[e];return a})})(window.WebComponents);(function(){function a(){}function b(a,b){switch(a.nodeType){case Node.DOCUMENT_NODE:return w.call(a,b);case Node.DOCUMENT_FRAGMENT_NODE:return I.call(a,b);default:return n.call(a,b)}}var c="undefined"===typeof HTMLTemplateElement,d=!(document.createDocumentFragment().cloneNode()instanceof DocumentFragment),e=!1;/Trident/.test(navigator.userAgent)&&function(){function a(a,b){if(a instanceof DocumentFragment)for(var d;d=a.firstChild;)c.call(this,d,b);else c.call(this,a,b);return a}e=!0;var b=Node.prototype.cloneNode;
Node.prototype.cloneNode=function(a){a=b.call(this,a);this instanceof DocumentFragment&&(a.__proto__=DocumentFragment.prototype);return a};DocumentFragment.prototype.querySelectorAll=HTMLElement.prototype.querySelectorAll;DocumentFragment.prototype.querySelector=HTMLElement.prototype.querySelector;Object.defineProperties(DocumentFragment.prototype,{nodeType:{get:function(){return Node.DOCUMENT_FRAGMENT_NODE},configurable:!0},localName:{get:function(){},configurable:!0},nodeName:{get:function(){return"#document-fragment"},
configurable:!0}});var c=Node.prototype.insertBefore;Node.prototype.insertBefore=a;var d=Node.prototype.appendChild;Node.prototype.appendChild=function(b){b instanceof DocumentFragment?a.call(this,b,null):d.call(this,b);return b};var f=Node.prototype.removeChild,h=Node.prototype.replaceChild;Node.prototype.replaceChild=function(b,c){b instanceof DocumentFragment?(a.call(this,b,c),f.call(this,c)):h.call(this,b,c);return c};Document.prototype.createDocumentFragment=function(){var a=this.createElement("df");
a.__proto__=DocumentFragment.prototype;return a};var g=Document.prototype.importNode;Document.prototype.importNode=function(a,b){b=g.call(this,a,b||!1);a instanceof DocumentFragment&&(b.__proto__=DocumentFragment.prototype);return b}}();var f=Node.prototype.cloneNode,h=Document.prototype.createElement,g=Document.prototype.importNode,k=Node.prototype.removeChild,l=Node.prototype.appendChild,m=Node.prototype.replaceChild,n=Element.prototype.querySelectorAll,w=Document.prototype.querySelectorAll,I=DocumentFragment.prototype.querySelectorAll,
Za=function(){if(!c){var a=document.createElement("template"),b=document.createElement("template");b.content.appendChild(document.createElement("div"));a.content.appendChild(b);a=a.cloneNode(!0);return 0===a.content.childNodes.length||0===a.content.firstChild.content.childNodes.length||d}}();if(c){var t=document.implementation.createHTMLDocument("template"),na=!0,aa=document.createElement("style");aa.textContent="template{display:none;}";var T=document.head;T.insertBefore(aa,T.firstElementChild);
a.prototype=Object.create(HTMLElement.prototype);var U=!document.createElement("div").hasOwnProperty("innerHTML");a.D=function(b){if(!b.content){b.content=t.createDocumentFragment();for(var c;c=b.firstChild;)l.call(b.content,c);if(U)b.__proto__=a.prototype;else if(b.cloneNode=function(b){return a.a(this,b)},na)try{nc(b),oc(b)}catch(Ng){na=!1}a.J(b.content)}};var nc=function(b){Object.defineProperty(b,"innerHTML",{get:function(){for(var a="",b=this.content.firstChild;b;b=b.nextSibling)a+=b.outerHTML||
b.data.replace(Ge,pc);return a},set:function(b){t.body.innerHTML=b;for(a.J(t);this.content.firstChild;)k.call(this.content,this.content.firstChild);for(;t.body.firstChild;)l.call(this.content,t.body.firstChild)},configurable:!0})},oc=function(a){Object.defineProperty(a,"outerHTML",{get:function(){return"<template>"+this.innerHTML+"</template>"},set:function(a){if(this.parentNode){t.body.innerHTML=a;for(a=this.ownerDocument.createDocumentFragment();t.body.firstChild;)l.call(a,t.body.firstChild);m.call(this.parentNode,
a,this)}else throw Error("Failed to set the 'outerHTML' property on 'Element': This element has no parent node.");},configurable:!0})};nc(a.prototype);oc(a.prototype);a.J=function(c){c=b(c,"template");for(var d=0,e=c.length,f;d<e&&(f=c[d]);d++)a.D(f)};document.addEventListener("DOMContentLoaded",function(){a.J(document)});Document.prototype.createElement=function(){var b=h.apply(this,arguments);"template"===b.localName&&a.D(b);return b};var Ge=/[&\u00A0<>]/g,pc=function(a){switch(a){case "&":return"&amp;";
case "<":return"&lt;";case ">":return"&gt;";case "\u00a0":return"&nbsp;"}}}if(c||Za){a.a=function(a,b){var c=f.call(a,!1);this.D&&this.D(c);b&&(l.call(c.content,f.call(a.content,!0)),$a(c.content,a.content));return c};var $a=function(c,d){if(d.querySelectorAll&&(d=b(d,"template"),0!==d.length)){c=b(c,"template");for(var e=0,f=c.length,h,g;e<f;e++)g=d[e],h=c[e],a&&a.D&&a.D(g),m.call(h.parentNode,He.call(g,!0),h)}},He=Node.prototype.cloneNode=function(b){if(!e&&d&&this instanceof DocumentFragment)if(b)var c=
Ie.call(this.ownerDocument,this,!0);else return this.ownerDocument.createDocumentFragment();else this.nodeType===Node.ELEMENT_NODE&&"template"===this.localName?c=a.a(this,b):c=f.call(this,b);b&&$a(c,this);return c},Ie=Document.prototype.importNode=function(b,c){c=c||!1;if("template"===b.localName)return a.a(b,c);var d=g.call(this,b,c);c&&$a(d,b);return d}}c&&(window.HTMLTemplateElement=a)})();var ka;Array.isArray?ka=Array.isArray:ka=function(a){return"[object Array]"===Object.prototype.toString.call(a)};var la=ka;var ma=0,oa,pa="undefined"!==typeof window?window:void 0,qa=pa||{},ra=qa.MutationObserver||qa.WebKitMutationObserver,sa="undefined"!==typeof Uint8ClampedArray&&"undefined"!==typeof importScripts&&"undefined"!==typeof MessageChannel;function ta(){return"undefined"!==typeof oa?function(){oa(ua)}:va()}function wa(){var a=0,b=new ra(ua),c=document.createTextNode("");b.observe(c,{characterData:!0});return function(){c.data=a=++a%2}}
function xa(){var a=new MessageChannel;a.port1.onmessage=ua;return function(){return a.port2.postMessage(0)}}function va(){var a=setTimeout;return function(){return a(ua,1)}}var ya=Array(1E3);function ua(){for(var a=0;a<ma;a+=2)(0,ya[a])(ya[a+1]),ya[a]=void 0,ya[a+1]=void 0;ma=0}var za,Aa;
if("undefined"===typeof self&&"undefined"!==typeof process&&"[object process]"==={}.toString.call(process))Aa=function(){return process.jb(ua)};else{var Ba;if(ra)Ba=wa();else{var Ca;if(sa)Ca=xa();else{var Da;if(void 0===pa&&"function"==="function")try{var Ea=__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"vertx\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));oa=Ea.lb||Ea.kb;Da=ta()}catch(a){Da=va()}else Da=va();Ca=Da}Ba=Ca}Aa=Ba}za=Aa;function Fa(a,b){ya[ma]=a;ya[ma+1]=b;ma+=2;2===ma&&za()};function Ga(a,b){var c=this,d=new this.constructor(Ha);void 0===d[Ia]&&Ja(d);var e=c.g;if(e){var f=arguments[e-1];Fa(function(){return Ka(e,d,f,c.f)})}else La(c,d,a,b);return d};function Ma(a){if(a&&"object"===typeof a&&a.constructor===this)return a;var b=new this(Ha);Na(b,a);return b};var Ia=Math.random().toString(36).substring(16);function Ha(){}var Pa=new Oa;function Qa(a){try{return a.then}catch(b){return Pa.error=b,Pa}}function Ra(a,b,c,d){try{a.call(b,c,d)}catch(e){return e}}function Sa(a,b,c){Fa(function(a){var d=!1,f=Ra(c,b,function(c){d||(d=!0,b!==c?Na(a,c):r(a,c))},function(b){d||(d=!0,u(a,b))});!d&&f&&(d=!0,u(a,f))},a)}function Ta(a,b){1===b.g?r(a,b.f):2===b.g?u(a,b.f):La(b,void 0,function(b){return Na(a,b)},function(b){return u(a,b)})}
function Ua(a,b,c){b.constructor===a.constructor&&c===Ga&&b.constructor.resolve===Ma?Ta(a,b):c===Pa?(u(a,Pa.error),Pa.error=null):void 0===c?r(a,b):"function"===typeof c?Sa(a,b,c):r(a,b)}function Na(a,b){if(a===b)u(a,new TypeError("You cannot resolve a promise with itself"));else{var c=typeof b;null===b||"object"!==c&&"function"!==c?r(a,b):Ua(a,b,Qa(b))}}function Va(a){a.pa&&a.pa(a.f);Wa(a)}function r(a,b){void 0===a.g&&(a.f=b,a.g=1,0!==a.I.length&&Fa(Wa,a))}
function u(a,b){void 0===a.g&&(a.g=2,a.f=b,Fa(Va,a))}function La(a,b,c,d){var e=a.I,f=e.length;a.pa=null;e[f]=b;e[f+1]=c;e[f+2]=d;0===f&&a.g&&Fa(Wa,a)}function Wa(a){var b=a.I,c=a.g;if(0!==b.length){for(var d,e,f=a.f,h=0;h<b.length;h+=3)d=b[h],e=b[h+c],d?Ka(c,d,e,f):e(f);a.I.length=0}}function Oa(){this.error=null}var Xa=new Oa;
function Ka(a,b,c,d){var e="function"===typeof c;if(e){try{var f=c(d)}catch(l){Xa.error=l,f=Xa}if(f===Xa){var h=!0;var g=f.error;f.error=null}else var k=!0;if(b===f){u(b,new TypeError("A promises callback cannot return that same promise."));return}}else f=d,k=!0;void 0===b.g&&(e&&k?Na(b,f):h?u(b,g):1===a?r(b,f):2===a&&u(b,f))}function Ya(a,b){try{b(function(b){Na(a,b)},function(b){u(a,b)})}catch(c){u(a,c)}}var ab=0;function Ja(a){a[Ia]=ab++;a.g=void 0;a.f=void 0;a.I=[]};function bb(a,b){this.Ga=a;this.A=new a(Ha);this.A[Ia]||Ja(this.A);if(la(b))if(this.S=this.length=b.length,this.f=Array(this.length),0===this.length)r(this.A,this.f);else{this.length=this.length||0;for(a=0;void 0===this.g&&a<b.length;a++)cb(this,b[a],a);0===this.S&&r(this.A,this.f)}else u(this.A,Error("Array Methods must be provided an Array"))}
function cb(a,b,c){var d=a.Ga,e=d.resolve;e===Ma?(e=Qa(b),e===Ga&&void 0!==b.g?db(a,b.g,c,b.f):"function"!==typeof e?(a.S--,a.f[c]=b):d===v?(d=new d(Ha),Ua(d,b,e),eb(a,d,c)):eb(a,new d(function(a){return a(b)}),c)):eb(a,e(b),c)}function db(a,b,c,d){var e=a.A;void 0===e.g&&(a.S--,2===b?u(e,d):a.f[c]=d);0===a.S&&r(e,a.f)}function eb(a,b,c){La(b,void 0,function(b){return db(a,1,c,b)},function(b){return db(a,2,c,b)})};function fb(a){return(new bb(this,a)).A};function gb(a){var b=this;return la(a)?new b(function(c,d){for(var e=a.length,f=0;f<e;f++)b.resolve(a[f]).then(c,d)}):new b(function(a,b){return b(new TypeError("You must pass an array to race."))})};function hb(a){var b=new this(Ha);u(b,a);return b};function v(a){this[Ia]=ab++;this.f=this.g=void 0;this.I=[];if(Ha!==a){if("function"!==typeof a)throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(this instanceof v)Ya(this,a);else throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");}}v.prototype={constructor:v,then:Ga,a:function(a){return this.then(null,a)}};/*

Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.Promise||(window.Promise=v,v.prototype["catch"]=v.prototype.a,v.prototype.then=v.prototype.then,v.all=fb,v.race=gb,v.resolve=Ma,v.reject=hb);(function(a){function b(a,b){if("function"===typeof window.CustomEvent)return new CustomEvent(a,b);var c=document.createEvent("CustomEvent");c.initCustomEvent(a,!!b.bubbles,!!b.cancelable,b.detail);return c}function c(a){if(m)return a.ownerDocument!==document?a.ownerDocument:null;var b=a.__importDoc;if(!b&&a.parentNode){b=a.parentNode;if("function"===typeof b.closest)b=b.closest("link[rel=import]");else for(;!g(b)&&(b=b.parentNode););a.__importDoc=b}return b}function d(a){var b=document.querySelectorAll("link[rel=import]:not([import-dependency])"),
c=b.length;c?l(b,function(b){return h(b,function(){0===--c&&a()})}):a()}function e(a){function b(){"loading"!==document.readyState&&document.body&&(document.removeEventListener("readystatechange",b),a())}document.addEventListener("readystatechange",b);b()}function f(a){e(function(){return d(function(){return a&&a()})})}function h(a,b){if(a.__loaded)b&&b();else if("script"===a.localName&&!a.src||"style"===a.localName&&!a.firstChild)a.__loaded=!0,b&&b();else{var c=function(d){a.removeEventListener(d.type,
c);a.__loaded=!0;b&&b()};a.addEventListener("load",c);aa&&"style"===a.localName||a.addEventListener("error",c)}}function g(a){return a.nodeType===Node.ELEMENT_NODE&&"link"===a.localName&&"import"===a.rel}function k(){var a=this;this.a={};this.b=0;this.h=new MutationObserver(function(b){return a.Qa(b)});this.h.observe(document.head,{childList:!0,subtree:!0});this.c(document)}function l(a,b,c){var d=a?a.length:0,e=c?-1:1;for(c=c?d-1:0;c<d&&0<=c;c+=e)b(a[c],c)}var m="import"in document.createElement("link"),
n=null;!1==="currentScript"in document&&Object.defineProperty(document,"currentScript",{get:function(){return n||("complete"!==document.readyState?document.scripts[document.scripts.length-1]:null)},configurable:!0});var w=/(url\()([^)]*)(\))/g,I=/(@import[\s]+(?!url\())([^;]*)(;)/g,Za=/(<link[^>]*)(rel=['|"]?stylesheet['|"]?[^>]*>)/g,t={Ka:function(a,b){a.href&&a.setAttribute("href",t.Y(a.getAttribute("href"),b));a.src&&a.setAttribute("src",t.Y(a.getAttribute("src"),b));if("style"===a.localName){var c=
t.ua(a.textContent,b,w);a.textContent=t.ua(c,b,I)}},ua:function(a,b,c){return a.replace(c,function(a,c,d,e){a=d.replace(/["']/g,"");b&&(a=t.Y(a,b));return c+"'"+a+"'"+e})},Y:function(a,b){if(void 0===t.ca){t.ca=!1;try{var c=new URL("b","http://a");c.pathname="c%20d";t.ca="http://a/c%20d"===c.href}catch(pc){}}if(t.ca)return(new URL(a,b)).href;c=t.Da;c||(c=document.implementation.createHTMLDocument("temp"),t.Da=c,c.ma=c.createElement("base"),c.head.appendChild(c.ma),c.la=c.createElement("a"));c.ma.href=
b;c.la.href=a;return c.la.href||a}},na={async:!0,load:function(a,b,c){if(a)if(a.match(/^data:/)){a=a.split(",");var d=a[1];d=-1<a[0].indexOf(";base64")?atob(d):decodeURIComponent(d);b(d)}else{var e=new XMLHttpRequest;e.open("GET",a,na.async);e.onload=function(){var a=e.responseURL||e.getResponseHeader("Location");a&&0===a.indexOf("/")&&(a=(location.origin||location.protocol+"//"+location.host)+a);var d=e.response||e.responseText;304===e.status||0===e.status||200<=e.status&&300>e.status?b(d,a):c(d)};
e.send()}else c("error: href must be specified")}},aa=/Trident/.test(navigator.userAgent)||/Edge\/\d./i.test(navigator.userAgent);k.prototype.c=function(a){var b=this;a=a.querySelectorAll("link[rel=import]");l(a,function(a){return b.L(a)})};k.prototype.L=function(a){var b=this,c=a.href;if(void 0!==this.a[c]){var d=this.a[c];d&&d.__loaded&&(a.import=d,this.o(a))}else this.b++,this.a[c]="pending",na.load(c,function(a,d){a=b.Ra(a,d||c);b.a[c]=a;b.b--;b.c(a);b.sa()},function(){b.a[c]=null;b.b--;b.sa()})};
k.prototype.Ra=function(a,b){if(!a)return document.createDocumentFragment();aa&&(a=a.replace(Za,function(a,b,c){return-1===a.indexOf("type=")?b+" type=import-disable "+c:a}));var c=document.createElement("template");c.innerHTML=a;if(c.content)a=c.content;else for(a=document.createDocumentFragment();c.firstChild;)a.appendChild(c.firstChild);if(c=a.querySelector("base"))b=t.Y(c.getAttribute("href"),b),c.removeAttribute("href");c=a.querySelectorAll('link[rel=import], link[rel=stylesheet][href][type=import-disable],\n    style:not([type]), link[rel=stylesheet][href]:not([type]),\n    script:not([type]), script[type="application/javascript"],\n    script[type="text/javascript"]');
var d=0;l(c,function(a){h(a);t.Ka(a,b);a.setAttribute("import-dependency","");"script"===a.localName&&!a.src&&a.textContent&&(a.setAttribute("src","data:text/javascript;charset=utf-8,"+encodeURIComponent(a.textContent+("\n//# sourceURL="+b+(d?"-"+d:"")+".js\n"))),a.textContent="",d++)});return a};k.prototype.sa=function(){var a=this;if(!this.b){this.h.disconnect();this.flatten(document);var b=!1,c=!1,d=function(){c&&b&&(a.c(document),a.b||(a.h.observe(document.head,{childList:!0,subtree:!0}),a.Pa()))};
this.Wa(function(){c=!0;d()});this.Sa(function(){b=!0;d()})}};k.prototype.flatten=function(a){var b=this;a=a.querySelectorAll("link[rel=import]");l(a,function(a){var c=b.a[a.href];(a.import=c)&&c.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&(b.a[a.href]=a,a.readyState="loading",a.import=a,b.flatten(c),a.appendChild(c))})};k.prototype.Sa=function(a){function b(e){if(e<d){var f=c[e],g=document.createElement("script");f.removeAttribute("import-dependency");l(f.attributes,function(a){return g.setAttribute(a.name,
a.value)});n=g;f.parentNode.replaceChild(g,f);h(g,function(){n=null;b(e+1)})}else a()}var c=document.querySelectorAll("script[import-dependency]"),d=c.length;b(0)};k.prototype.Wa=function(a){var b=document.querySelectorAll("style[import-dependency],\n    link[rel=stylesheet][import-dependency]"),d=b.length;if(d){var e=aa&&!!document.querySelector("link[rel=stylesheet][href][type=import-disable]");l(b,function(b){h(b,function(){b.removeAttribute("import-dependency");0===--d&&a()});if(e&&b.parentNode!==
document.head){var f=document.createElement(b.localName);f.__appliedElement=b;f.setAttribute("type","import-placeholder");b.parentNode.insertBefore(f,b.nextSibling);for(f=c(b);f&&c(f);)f=c(f);f.parentNode!==document.head&&(f=null);document.head.insertBefore(b,f);b.removeAttribute("type")}})}else a()};k.prototype.Pa=function(){var a=this,b=document.querySelectorAll("link[rel=import]");l(b,function(b){return a.o(b)},!0)};k.prototype.o=function(a){a.__loaded||(a.__loaded=!0,a.import&&(a.import.readyState=
"complete"),a.dispatchEvent(b(a.import?"load":"error",{bubbles:!1,cancelable:!1,detail:void 0})))};k.prototype.Qa=function(a){var b=this;l(a,function(a){return l(a.addedNodes,function(a){a&&a.nodeType===Node.ELEMENT_NODE&&(g(a)?b.L(a):b.c(a))})})};if(m){var T=document.querySelectorAll("link[rel=import]");l(T,function(a){a.import&&"loading"===a.import.readyState||(a.__loaded=!0)});T=function(a){a=a.target;g(a)&&(a.__loaded=!0)};document.addEventListener("load",T,!0);document.addEventListener("error",
T,!0)}else{var U=Object.getOwnPropertyDescriptor(Node.prototype,"baseURI");Object.defineProperty((!U||U.configurable?Node:Element).prototype,"baseURI",{get:function(){var a=g(this)?this:c(this);return a?a.href:U&&U.get?U.get.call(this):(document.querySelector("base")||window.location).href},configurable:!0,enumerable:!0});e(function(){return new k})}f(function(){return document.dispatchEvent(b("HTMLImportsLoaded",{cancelable:!0,bubbles:!0,detail:void 0}))});a.useNative=m;a.whenReady=f;a.importForElement=
c})(window.HTMLImports=window.HTMLImports||{});/*

 Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.WebComponents=window.WebComponents||{flags:{}};var ib=document.querySelector('script[src*="webcomponents-lite.js"]'),jb=/wc-(.+)/,x={};if(!x.noOpts){location.search.slice(1).split("&").forEach(function(a){a=a.split("=");var b;a[0]&&(b=a[0].match(jb))&&(x[b[1]]=a[1]||!0)});if(ib)for(var kb=0,lb;lb=ib.attributes[kb];kb++)"src"!==lb.name&&(x[lb.name]=lb.value||!0);if(x.log&&x.log.split){var mb=x.log.split(",");x.log={};mb.forEach(function(a){x.log[a]=!0})}else x.log={}}
window.WebComponents.flags=x;var nb=x.shadydom;nb&&(window.ShadyDOM=window.ShadyDOM||{},window.ShadyDOM.force=nb);var ob=x.register||x.ce;ob&&window.customElements&&(window.customElements.forcePolyfill=ob);/*

Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
var y=window.ShadyDOM||{};y.Ma=!(!Element.prototype.attachShadow||!Node.prototype.getRootNode);var pb=Object.getOwnPropertyDescriptor(Node.prototype,"firstChild");y.M=!!(pb&&pb.configurable&&pb.get);y.ta=y.force||!y.Ma;function qb(a){return a.__shady&&void 0!==a.__shady.firstChild}function z(a){return"ShadyRoot"===a.Aa}function rb(a){a=a.getRootNode();if(z(a))return a}var sb=Element.prototype,tb=sb.matches||sb.matchesSelector||sb.mozMatchesSelector||sb.msMatchesSelector||sb.oMatchesSelector||sb.webkitMatchesSelector;
function ub(a,b){if(a&&b)for(var c=Object.getOwnPropertyNames(b),d=0,e;d<c.length&&(e=c[d]);d++){var f=Object.getOwnPropertyDescriptor(b,e);f&&Object.defineProperty(a,e,f)}}function vb(a,b){for(var c=[],d=1;d<arguments.length;++d)c[d-1]=arguments[d];for(d=0;d<c.length;d++)ub(a,c[d]);return a}function wb(a,b){for(var c in b)a[c]=b[c]}var xb=document.createTextNode(""),yb=0,zb=[];(new MutationObserver(function(){for(;zb.length;)try{zb.shift()()}catch(a){throw xb.textContent=yb++,a;}})).observe(xb,{characterData:!0});
function Ab(a){zb.push(a);xb.textContent=yb++}var Bb=!!document.contains;function Cb(a,b){for(;b;){if(b==a)return!0;b=b.parentNode}return!1};var Db=[],Eb;function Fb(a){Eb||(Eb=!0,Ab(Gb));Db.push(a)}function Gb(){Eb=!1;for(var a=!!Db.length;Db.length;)Db.shift()();return a}Gb.list=Db;function Hb(){this.a=!1;this.addedNodes=[];this.removedNodes=[];this.V=new Set}function Ib(a){a.a||(a.a=!0,Ab(function(){Jb(a)}))}function Jb(a){if(a.a){a.a=!1;var b=a.takeRecords();b.length&&a.V.forEach(function(a){a(b)})}}Hb.prototype.takeRecords=function(){if(this.addedNodes.length||this.removedNodes.length){var a=[{addedNodes:this.addedNodes,removedNodes:this.removedNodes}];this.addedNodes=[];this.removedNodes=[];return a}return[]};
function Kb(a,b){a.__shady=a.__shady||{};a.__shady.N||(a.__shady.N=new Hb);a.__shady.N.V.add(b);var c=a.__shady.N;return{Ea:b,C:c,Ha:a,takeRecords:function(){return c.takeRecords()}}}function Lb(a){var b=a&&a.C;b&&(b.V.delete(a.Ea),b.V.size||(a.Ha.__shady.N=null))}
function Mb(a,b){var c=b.getRootNode();return a.map(function(a){var b=c===a.target.getRootNode();if(b&&a.addedNodes){if(b=Array.from(a.addedNodes).filter(function(a){return c===a.getRootNode()}),b.length)return a=Object.create(a),Object.defineProperty(a,"addedNodes",{value:b,configurable:!0}),a}else if(b)return a}).filter(function(a){return a})};var A={},Nb=Element.prototype.insertBefore,Ob=Element.prototype.removeChild,Pb=Element.prototype.setAttribute,Qb=Element.prototype.removeAttribute,Rb=Element.prototype.cloneNode,Sb=Document.prototype.importNode,Tb=Element.prototype.addEventListener,Ub=Element.prototype.removeEventListener,Vb=Window.prototype.addEventListener,Wb=Window.prototype.removeEventListener,Xb=Element.prototype.dispatchEvent,Yb=Element.prototype.querySelector,Zb=Element.prototype.querySelectorAll,$b=Node.prototype.contains||
HTMLElement.prototype.contains;A.appendChild=Element.prototype.appendChild;A.insertBefore=Nb;A.removeChild=Ob;A.setAttribute=Pb;A.removeAttribute=Qb;A.cloneNode=Rb;A.importNode=Sb;A.addEventListener=Tb;A.removeEventListener=Ub;A.ab=Vb;A.bb=Wb;A.dispatchEvent=Xb;A.querySelector=Yb;A.querySelectorAll=Zb;A.contains=$b;var ac=/[&\u00A0"]/g,bc=/[&\u00A0<>]/g;function cc(a){switch(a){case "&":return"&amp;";case "<":return"&lt;";case ">":return"&gt;";case '"':return"&quot;";case "\u00a0":return"&nbsp;"}}function dc(a){for(var b={},c=0;c<a.length;c++)b[a[c]]=!0;return b}var ec=dc("area base br col command embed hr img input keygen link meta param source track wbr".split(" ")),fc=dc("style script xmp iframe noembed noframes plaintext noscript".split(" "));
function gc(a,b){"template"===a.localName&&(a=a.content);for(var c="",d=b?b(a):a.childNodes,e=0,f=d.length,h;e<f&&(h=d[e]);e++){a:{var g=h;var k=a;var l=b;switch(g.nodeType){case Node.ELEMENT_NODE:for(var m=g.localName,n="<"+m,w=g.attributes,I=0;k=w[I];I++)n+=" "+k.name+'="'+k.value.replace(ac,cc)+'"';n+=">";g=ec[m]?n:n+gc(g,l)+"</"+m+">";break a;case Node.TEXT_NODE:g=g.data;g=k&&fc[k.localName]?g:g.replace(bc,cc);break a;case Node.COMMENT_NODE:g="\x3c!--"+g.data+"--\x3e";break a;default:throw window.console.error(g),
Error("not implemented");}}c+=g}return c};var B={},C=document.createTreeWalker(document,NodeFilter.SHOW_ALL,null,!1),D=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT,null,!1);function hc(a){var b=[];C.currentNode=a;for(a=C.firstChild();a;)b.push(a),a=C.nextSibling();return b}B.parentNode=function(a){C.currentNode=a;return C.parentNode()};B.firstChild=function(a){C.currentNode=a;return C.firstChild()};B.lastChild=function(a){C.currentNode=a;return C.lastChild()};B.previousSibling=function(a){C.currentNode=a;return C.previousSibling()};
B.nextSibling=function(a){C.currentNode=a;return C.nextSibling()};B.childNodes=hc;B.parentElement=function(a){D.currentNode=a;return D.parentNode()};B.firstElementChild=function(a){D.currentNode=a;return D.firstChild()};B.lastElementChild=function(a){D.currentNode=a;return D.lastChild()};B.previousElementSibling=function(a){D.currentNode=a;return D.previousSibling()};B.nextElementSibling=function(a){D.currentNode=a;return D.nextSibling()};
B.children=function(a){var b=[];D.currentNode=a;for(a=D.firstChild();a;)b.push(a),a=D.nextSibling();return b};B.innerHTML=function(a){return gc(a,function(a){return hc(a)})};B.textContent=function(a){switch(a.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:a=document.createTreeWalker(a,NodeFilter.SHOW_TEXT,null,!1);for(var b="",c;c=a.nextNode();)b+=c.nodeValue;return b;default:return a.nodeValue}};var ic=Object.getOwnPropertyDescriptor(Element.prototype,"innerHTML")||Object.getOwnPropertyDescriptor(HTMLElement.prototype,"innerHTML"),jc=document.implementation.createHTMLDocument("inert"),kc=Object.getOwnPropertyDescriptor(Document.prototype,"activeElement"),lc={parentElement:{get:function(){var a=this.__shady&&this.__shady.parentNode;a&&a.nodeType!==Node.ELEMENT_NODE&&(a=null);return void 0!==a?a:B.parentElement(this)},configurable:!0},parentNode:{get:function(){var a=this.__shady&&this.__shady.parentNode;
return void 0!==a?a:B.parentNode(this)},configurable:!0},nextSibling:{get:function(){var a=this.__shady&&this.__shady.nextSibling;return void 0!==a?a:B.nextSibling(this)},configurable:!0},previousSibling:{get:function(){var a=this.__shady&&this.__shady.previousSibling;return void 0!==a?a:B.previousSibling(this)},configurable:!0},className:{get:function(){return this.getAttribute("class")||""},set:function(a){this.setAttribute("class",a)},configurable:!0},nextElementSibling:{get:function(){if(this.__shady&&
void 0!==this.__shady.nextSibling){for(var a=this.nextSibling;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.nextSibling;return a}return B.nextElementSibling(this)},configurable:!0},previousElementSibling:{get:function(){if(this.__shady&&void 0!==this.__shady.previousSibling){for(var a=this.previousSibling;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.previousSibling;return a}return B.previousElementSibling(this)},configurable:!0}},mc={childNodes:{get:function(){if(qb(this)){if(!this.__shady.childNodes){this.__shady.childNodes=
[];for(var a=this.firstChild;a;a=a.nextSibling)this.__shady.childNodes.push(a)}var b=this.__shady.childNodes}else b=B.childNodes(this);b.item=function(a){return b[a]};return b},configurable:!0},childElementCount:{get:function(){return this.children.length},configurable:!0},firstChild:{get:function(){var a=this.__shady&&this.__shady.firstChild;return void 0!==a?a:B.firstChild(this)},configurable:!0},lastChild:{get:function(){var a=this.__shady&&this.__shady.lastChild;return void 0!==a?a:B.lastChild(this)},
configurable:!0},textContent:{get:function(){if(qb(this)){for(var a=[],b=0,c=this.childNodes,d;d=c[b];b++)d.nodeType!==Node.COMMENT_NODE&&a.push(d.textContent);return a.join("")}return B.textContent(this)},set:function(a){switch(this.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:for(;this.firstChild;)this.removeChild(this.firstChild);(0<a.length||this.nodeType===Node.ELEMENT_NODE)&&this.appendChild(document.createTextNode(a));break;default:this.nodeValue=a}},configurable:!0},firstElementChild:{get:function(){if(this.__shady&&
void 0!==this.__shady.firstChild){for(var a=this.firstChild;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.nextSibling;return a}return B.firstElementChild(this)},configurable:!0},lastElementChild:{get:function(){if(this.__shady&&void 0!==this.__shady.lastChild){for(var a=this.lastChild;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.previousSibling;return a}return B.lastElementChild(this)},configurable:!0},children:{get:function(){var a;qb(this)?a=Array.prototype.filter.call(this.childNodes,function(a){return a.nodeType===
Node.ELEMENT_NODE}):a=B.children(this);a.item=function(b){return a[b]};return a},configurable:!0},innerHTML:{get:function(){var a="template"===this.localName?this.content:this;return qb(this)?gc(a):B.innerHTML(a)},set:function(a){for(var b="template"===this.localName?this.content:this;b.firstChild;)b.removeChild(b.firstChild);var c=this.localName;c&&"template"!==c||(c="div");c=jc.createElement(c);for(ic&&ic.set?ic.set.call(c,a):c.innerHTML=a;c.firstChild;)b.appendChild(c.firstChild)},configurable:!0}},
qc={shadowRoot:{get:function(){return this.__shady&&this.__shady.Ua||null},configurable:!0}},rc={activeElement:{get:function(){var a=kc&&kc.get?kc.get.call(document):y.M?void 0:document.activeElement;if(a&&a.nodeType){var b=!!z(this);if(this===document||b&&this.host!==a&&A.contains.call(this.host,a)){for(b=rb(a);b&&b!==this;)a=b.host,b=rb(a);a=this===document?b?null:a:b===this?a:null}else a=null}else a=null;return a},set:function(){},configurable:!0}};
function E(a,b,c){for(var d in b){var e=Object.getOwnPropertyDescriptor(a,d);e&&e.configurable||!e&&c?Object.defineProperty(a,d,b[d]):c&&console.warn("Could not define",d,"on",a)}}function F(a){E(a,lc);E(a,mc);E(a,rc)}var sc=y.M?function(){}:function(a){a.__shady&&a.__shady.Ba||(a.__shady=a.__shady||{},a.__shady.Ba=!0,E(a,lc,!0))},tc=y.M?function(){}:function(a){a.__shady&&a.__shady.za||(a.__shady=a.__shady||{},a.__shady.za=!0,E(a,mc,!0),E(a,qc,!0))};function uc(a,b,c){sc(a);c=c||null;a.__shady=a.__shady||{};b.__shady=b.__shady||{};c&&(c.__shady=c.__shady||{});a.__shady.previousSibling=c?c.__shady.previousSibling:b.lastChild;var d=a.__shady.previousSibling;d&&d.__shady&&(d.__shady.nextSibling=a);(d=a.__shady.nextSibling=c)&&d.__shady&&(d.__shady.previousSibling=a);a.__shady.parentNode=b;c?c===b.__shady.firstChild&&(b.__shady.firstChild=a):(b.__shady.lastChild=a,b.__shady.firstChild||(b.__shady.firstChild=a));b.__shady.childNodes=null}
function vc(a){if(!a.__shady||void 0===a.__shady.firstChild){a.__shady=a.__shady||{};a.__shady.firstChild=B.firstChild(a);a.__shady.lastChild=B.lastChild(a);tc(a);for(var b=a.__shady.childNodes=B.childNodes(a),c=0,d;c<b.length&&(d=b[c]);c++)d.__shady=d.__shady||{},d.__shady.parentNode=a,d.__shady.nextSibling=b[c+1]||null,d.__shady.previousSibling=b[c-1]||null,sc(d)}};function wc(a,b,c){if(b===a)throw Error("Failed to execute 'appendChild' on 'Node': The new child element contains the parent.");if(c){var d=c.__shady&&c.__shady.parentNode;if(void 0!==d&&d!==a||void 0===d&&B.parentNode(c)!==a)throw Error("Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.");}if(c===b)return b;b.parentNode&&xc(b.parentNode,b);d=rb(a);var e;if(e=d)a:{if(!b.__noInsertionPoint){var f;"slot"===b.localName?f=[b]:
b.querySelectorAll&&(f=b.querySelectorAll("slot"));if(f&&f.length){e=f;break a}}e=void 0}(f=e)&&d.H.push.apply(d.H,[].concat(f instanceof Array?f:ja(ia(f))));d&&("slot"===a.localName||f)&&yc(d);if(qb(a)){d=c;tc(a);a.__shady=a.__shady||{};void 0!==a.__shady.firstChild&&(a.__shady.childNodes=null);if(b.nodeType===Node.DOCUMENT_FRAGMENT_NODE){f=b.childNodes;for(e=0;e<f.length;e++)uc(f[e],a,d);b.__shady=b.__shady||{};d=void 0!==b.__shady.firstChild?null:void 0;b.__shady.firstChild=b.__shady.lastChild=
d;b.__shady.childNodes=d}else uc(b,a,d);if(zc(a)){yc(a.__shady.root);var h=!0}else a.__shady.root&&(h=!0)}h||(h=z(a)?a.host:a,c?(c=Ac(c),A.insertBefore.call(h,b,c)):A.appendChild.call(h,b));Bc(a,b);return b}
function xc(a,b){if(b.parentNode!==a)throw Error("The node to be removed is not a child of this node: "+b);var c=rb(b);if(qb(a)){b.__shady=b.__shady||{};a.__shady=a.__shady||{};b===a.__shady.firstChild&&(a.__shady.firstChild=b.__shady.nextSibling);b===a.__shady.lastChild&&(a.__shady.lastChild=b.__shady.previousSibling);var d=b.__shady.previousSibling,e=b.__shady.nextSibling;d&&(d.__shady=d.__shady||{},d.__shady.nextSibling=e);e&&(e.__shady=e.__shady||{},e.__shady.previousSibling=d);b.__shady.parentNode=
b.__shady.previousSibling=b.__shady.nextSibling=void 0;void 0!==a.__shady.childNodes&&(a.__shady.childNodes=null);if(zc(a)){yc(a.__shady.root);var f=!0}}Cc(b);if(c){(d=a&&"slot"===a.localName)&&(f=!0);Dc(c);e=c.l;for(var h in e)for(var g=e[h],k=0;k<g.length;k++){var l=g[k];if(Cb(b,l)){g.splice(k,1);var m=c.s.indexOf(l);0<=m&&c.s.splice(m,1);k--;if(m=l.__shady.K)for(l=0;l<m.length;l++){var n=m[l],w=B.parentNode(n);w&&A.removeChild.call(w,n)}m=!0}}(m||d)&&yc(c)}f||(f=z(a)?a.host:a,(!a.__shady.root&&
"slot"!==b.localName||f===B.parentNode(b))&&A.removeChild.call(f,b));Bc(a,null,b);return b}function Cc(a){if(a.__shady&&void 0!==a.__shady.ka)for(var b=a.childNodes,c=0,d=b.length,e;c<d&&(e=b[c]);c++)Cc(e);a.__shady&&(a.__shady.ka=void 0)}function Ac(a){var b=a;a&&"slot"===a.localName&&(b=(b=a.__shady&&a.__shady.K)&&b.length?b[0]:Ac(a.nextSibling));return b}function zc(a){return(a=a&&a.__shady&&a.__shady.root)&&Ec(a)}
function Fc(a,b){if("slot"===b)a=a.parentNode,zc(a)&&yc(a.__shady.root);else if("slot"===a.localName&&"name"===b&&(b=rb(a))){var c=a.Ca,d=Gc(a);if(d!==c){c=b.l[c];var e=c.indexOf(a);0<=e&&c.splice(e,1);c=b.l[d]||(b.l[d]=[]);c.push(a);1<c.length&&(b.l[d]=Hc(c))}yc(b)}}function Bc(a,b,c){if(a=a.__shady&&a.__shady.N)b&&a.addedNodes.push(b),c&&a.removedNodes.push(c),Ib(a)}
function Ic(a){if(a&&a.nodeType){a.__shady=a.__shady||{};var b=a.__shady.ka;void 0===b&&(z(a)?b=a:b=(b=a.parentNode)?Ic(b):a,A.contains.call(document.documentElement,a)&&(a.__shady.ka=b));return b}}function Jc(a,b,c){var d=[];Kc(a.childNodes,b,c,d);return d}function Kc(a,b,c,d){for(var e=0,f=a.length,h;e<f&&(h=a[e]);e++){var g;if(g=h.nodeType===Node.ELEMENT_NODE){g=h;var k=b,l=c,m=d,n=k(g);n&&m.push(g);l&&l(n)?g=n:(Kc(g.childNodes,k,l,m),g=void 0)}if(g)break}}var Lc=null;
function Mc(a,b,c){Lc||(Lc=window.ShadyCSS&&window.ShadyCSS.ScopingShim);Lc&&"class"===b?Lc.setElementClass(a,c):(A.setAttribute.call(a,b,c),Fc(a,b))}function Nc(a,b){if(a.ownerDocument!==document)return A.importNode.call(document,a,b);var c=A.importNode.call(document,a,!1);if(b){a=a.childNodes;b=0;for(var d;b<a.length;b++)d=Nc(a[b],!0),c.appendChild(d)}return c};var Oc="__eventWrappers"+Date.now(),Pc={blur:!0,focus:!0,focusin:!0,focusout:!0,click:!0,dblclick:!0,mousedown:!0,mouseenter:!0,mouseleave:!0,mousemove:!0,mouseout:!0,mouseover:!0,mouseup:!0,wheel:!0,beforeinput:!0,input:!0,keydown:!0,keyup:!0,compositionstart:!0,compositionupdate:!0,compositionend:!0,touchstart:!0,touchend:!0,touchmove:!0,touchcancel:!0,pointerover:!0,pointerenter:!0,pointerdown:!0,pointermove:!0,pointerup:!0,pointercancel:!0,pointerout:!0,pointerleave:!0,gotpointercapture:!0,lostpointercapture:!0,
dragstart:!0,drag:!0,dragenter:!0,dragleave:!0,dragover:!0,drop:!0,dragend:!0,DOMActivate:!0,DOMFocusIn:!0,DOMFocusOut:!0,keypress:!0};function Qc(a,b){var c=[],d=a;for(a=a===window?window:a.getRootNode();d;)c.push(d),d=d.assignedSlot?d.assignedSlot:d.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&d.host&&(b||d!==a)?d.host:d.parentNode;c[c.length-1]===document&&c.push(window);return c}
function Rc(a,b){if(!z)return a;a=Qc(a,!0);for(var c=0,d,e,f,h;c<b.length;c++)if(d=b[c],f=d===window?window:d.getRootNode(),f!==e&&(h=a.indexOf(f),e=f),!z(f)||-1<h)return d}
var Sc={get composed(){!1!==this.isTrusted&&void 0===this.Z&&(this.Z=Pc[this.type]);return this.Z||!1},composedPath:function(){this.na||(this.na=Qc(this.__target,this.composed));return this.na},get target(){return Rc(this.currentTarget,this.composedPath())},get relatedTarget(){if(!this.aa)return null;this.oa||(this.oa=Qc(this.aa,!0));return Rc(this.currentTarget,this.oa)},stopPropagation:function(){Event.prototype.stopPropagation.call(this);this.$=!0},stopImmediatePropagation:function(){Event.prototype.stopImmediatePropagation.call(this);
this.$=this.ya=!0}};function Tc(a){function b(b,d){b=new a(b,d);b.Z=d&&!!d.composed;return b}wb(b,a);b.prototype=a.prototype;return b}var Uc={focus:!0,blur:!0};function Vc(a){return a.__target!==a.target||a.aa!==a.relatedTarget}function Wc(a,b,c){if(c=b.__handlers&&b.__handlers[a.type]&&b.__handlers[a.type][c])for(var d=0,e;(e=c[d])&&(!Vc(a)||a.target!==a.relatedTarget)&&(e.call(b,a),!a.ya);d++);}
function Xc(a){var b=a.composedPath();Object.defineProperty(a,"currentTarget",{get:function(){return d},configurable:!0});for(var c=b.length-1;0<=c;c--){var d=b[c];Wc(a,d,"capture");if(a.$)return}Object.defineProperty(a,"eventPhase",{get:function(){return Event.AT_TARGET}});var e;for(c=0;c<b.length;c++){d=b[c];var f=d.__shady&&d.__shady.root;if(0===c||f&&f===e)if(Wc(a,d,"bubble"),d!==window&&(e=d.getRootNode()),a.$)break}}
function Yc(a,b,c,d,e,f){for(var h=0;h<a.length;h++){var g=a[h],k=g.type,l=g.capture,m=g.once,n=g.passive;if(b===g.node&&c===k&&d===l&&e===m&&f===n)return h}return-1}
function Zc(a,b,c){if(b){if(c&&"object"===typeof c){var d=!!c.capture;var e=!!c.once;var f=!!c.passive}else d=!!c,f=e=!1;var h=c&&c.ba||this,g=b[Oc];if(g){if(-1<Yc(g,h,a,d,e,f))return}else b[Oc]=[];g=function(d){e&&this.removeEventListener(a,b,c);d.__target||$c(d);if(h!==this){var f=Object.getOwnPropertyDescriptor(d,"currentTarget");Object.defineProperty(d,"currentTarget",{get:function(){return h},configurable:!0})}if(d.composed||-1<d.composedPath().indexOf(h))if(Vc(d)&&d.target===d.relatedTarget)d.eventPhase===
Event.BUBBLING_PHASE&&d.stopImmediatePropagation();else if(d.eventPhase===Event.CAPTURING_PHASE||d.bubbles||d.target===h||h instanceof Window){var g="object"===typeof b&&b.handleEvent?b.handleEvent(d):b.call(h,d);h!==this&&(f?(Object.defineProperty(d,"currentTarget",f),f=null):delete d.currentTarget);return g}};b[Oc].push({node:this,type:a,capture:d,once:e,passive:f,cb:g});Uc[a]?(this.__handlers=this.__handlers||{},this.__handlers[a]=this.__handlers[a]||{capture:[],bubble:[]},this.__handlers[a][d?
"capture":"bubble"].push(g)):(this instanceof Window?A.ab:A.addEventListener).call(this,a,g,c)}}
function ad(a,b,c){if(b){if(c&&"object"===typeof c){var d=!!c.capture;var e=!!c.once;var f=!!c.passive}else d=!!c,f=e=!1;var h=c&&c.ba||this,g=void 0;var k=null;try{k=b[Oc]}catch(l){}k&&(e=Yc(k,h,a,d,e,f),-1<e&&(g=k.splice(e,1)[0].cb,k.length||(b[Oc]=void 0)));(this instanceof Window?A.bb:A.removeEventListener).call(this,a,g||b,c);g&&Uc[a]&&this.__handlers&&this.__handlers[a]&&(a=this.__handlers[a][d?"capture":"bubble"],g=a.indexOf(g),-1<g&&a.splice(g,1))}}
function bd(){for(var a in Uc)window.addEventListener(a,function(a){a.__target||($c(a),Xc(a))},!0)}function $c(a){a.__target=a.target;a.aa=a.relatedTarget;if(y.M){var b=Object.getPrototypeOf(a);if(!b.hasOwnProperty("__patchProto")){var c=Object.create(b);c.fb=b;ub(c,Sc);b.__patchProto=c}a.__proto__=b.__patchProto}else ub(a,Sc)}var cd=Tc(window.Event),dd=Tc(window.CustomEvent),ed=Tc(window.MouseEvent);function fd(a,b){return{index:a,O:[],U:b}}
function gd(a,b,c,d){var e=0,f=0,h=0,g=0,k=Math.min(b-e,d-f);if(0==e&&0==f)a:{for(h=0;h<k;h++)if(a[h]!==c[h])break a;h=k}if(b==a.length&&d==c.length){g=a.length;for(var l=c.length,m=0;m<k-h&&hd(a[--g],c[--l]);)m++;g=m}e+=h;f+=h;b-=g;d-=g;if(0==b-e&&0==d-f)return[];if(e==b){for(b=fd(e,0);f<d;)b.O.push(c[f++]);return[b]}if(f==d)return[fd(e,b-e)];k=e;h=f;d=d-h+1;g=b-k+1;b=Array(d);for(l=0;l<d;l++)b[l]=Array(g),b[l][0]=l;for(l=0;l<g;l++)b[0][l]=l;for(l=1;l<d;l++)for(m=1;m<g;m++)if(a[k+m-1]===c[h+l-1])b[l][m]=
b[l-1][m-1];else{var n=b[l-1][m]+1,w=b[l][m-1]+1;b[l][m]=n<w?n:w}k=b.length-1;h=b[0].length-1;d=b[k][h];for(a=[];0<k||0<h;)0==k?(a.push(2),h--):0==h?(a.push(3),k--):(g=b[k-1][h-1],l=b[k-1][h],m=b[k][h-1],n=l<m?l<g?l:g:m<g?m:g,n==g?(g==d?a.push(0):(a.push(1),d=g),k--,h--):n==l?(a.push(3),k--,d=l):(a.push(2),h--,d=m));a.reverse();b=void 0;k=[];for(h=0;h<a.length;h++)switch(a[h]){case 0:b&&(k.push(b),b=void 0);e++;f++;break;case 1:b||(b=fd(e,0));b.U++;e++;b.O.push(c[f]);f++;break;case 2:b||(b=fd(e,0));
b.U++;e++;break;case 3:b||(b=fd(e,0)),b.O.push(c[f]),f++}b&&k.push(b);return k}function hd(a,b){return a===b};var id={};function G(a,b,c){if(a!==id)throw new TypeError("Illegal constructor");a=document.createDocumentFragment();a.__proto__=G.prototype;a.Aa="ShadyRoot";vc(b);vc(a);a.host=b;a.a=c&&c.mode;b.__shady=b.__shady||{};b.__shady.root=a;b.__shady.Ua="closed"!==a.a?a:null;a.T=!1;a.s=[];a.l={};a.H=[];c=B.childNodes(b);for(var d=0,e=c.length;d<e;d++)A.removeChild.call(b,c[d]);return a}G.prototype=Object.create(DocumentFragment.prototype);function yc(a){a.T||(a.T=!0,Fb(function(){return jd(a)}))}
function jd(a){for(var b;a;){a.T&&(b=a);a:{var c=a;a=c.host.getRootNode();if(z(a))for(var d=c.host.childNodes,e=0;e<d.length;e++)if(c=d[e],"slot"==c.localName)break a;a=void 0}}b&&b._renderRoot()}
G.prototype._renderRoot=function(){this.T=!1;Dc(this);for(var a=0,b;a<this.s.length;a++){b=this.s[a];var c=b.__shady.assignedNodes;b.__shady.assignedNodes=[];b.__shady.K=[];if(b.__shady.qa=c)for(var d=0;d<c.length;d++){var e=c[d];e.__shady.ga=e.__shady.assignedSlot;e.__shady.assignedSlot===b&&(e.__shady.assignedSlot=null)}}for(b=this.host.firstChild;b;b=b.nextSibling)kd(this,b);for(a=0;a<this.s.length;a++){b=this.s[a];if(!b.__shady.assignedNodes.length)for(c=b.firstChild;c;c=c.nextSibling)kd(this,
c,b);c=b.parentNode;(c=c.__shady&&c.__shady.root)&&Ec(c)&&c._renderRoot();ld(this,b.__shady.K,b.__shady.assignedNodes);if(c=b.__shady.qa){for(d=0;d<c.length;d++)c[d].__shady.ga=null;b.__shady.qa=null;c.length>b.__shady.assignedNodes.length&&(b.__shady.ia=!0)}b.__shady.ia&&(b.__shady.ia=!1,md(this,b))}a=this.s;b=[];for(c=0;c<a.length;c++)d=a[c].parentNode,d.__shady&&d.__shady.root||!(0>b.indexOf(d))||b.push(d);for(a=0;a<b.length;a++){c=b[a];d=c===this?this.host:c;e=[];c=c.childNodes;for(var f=0;f<
c.length;f++){var h=c[f];if("slot"==h.localName){h=h.__shady.K;for(var g=0;g<h.length;g++)e.push(h[g])}else e.push(h)}c=void 0;f=B.childNodes(d);h=gd(e,e.length,f,f.length);for(var k=g=0;g<h.length&&(c=h[g]);g++){for(var l=0,m;l<c.O.length&&(m=c.O[l]);l++)B.parentNode(m)===d&&A.removeChild.call(d,m),f.splice(c.index+k,1);k-=c.U}for(k=0;k<h.length&&(c=h[k]);k++)for(g=f[c.index],l=c.index;l<c.index+c.U;l++)m=e[l],A.insertBefore.call(d,m,g),f.splice(l,0,m)}};
function kd(a,b,c){b.__shady=b.__shady||{};var d=b.__shady.ga;b.__shady.ga=null;c||(c=(a=a.l[b.slot||"__catchall"])&&a[0]);c?(c.__shady.assignedNodes.push(b),b.__shady.assignedSlot=c):b.__shady.assignedSlot=void 0;d!==b.__shady.assignedSlot&&b.__shady.assignedSlot&&(b.__shady.assignedSlot.__shady.ia=!0)}function ld(a,b,c){for(var d=0,e;d<c.length&&(e=c[d]);d++)if("slot"==e.localName){var f=e.__shady.assignedNodes;f&&f.length&&ld(a,b,f)}else b.push(c[d])}
function md(a,b){A.dispatchEvent.call(b,new Event("slotchange"));b.__shady.assignedSlot&&md(a,b.__shady.assignedSlot)}function Dc(a){if(a.H.length){for(var b=a.H,c,d=0;d<b.length;d++){var e=b[d];e.__shady=e.__shady||{};vc(e);vc(e.parentNode);var f=Gc(e);a.l[f]?(c=c||{},c[f]=!0,a.l[f].push(e)):a.l[f]=[e];a.s.push(e)}if(c)for(var h in c)a.l[h]=Hc(a.l[h]);a.H=[]}}function Gc(a){var b=a.name||a.getAttribute("name")||"__catchall";return a.Ca=b}
function Hc(a){return a.sort(function(a,c){a=nd(a);for(var b=nd(c),e=0;e<a.length;e++){c=a[e];var f=b[e];if(c!==f)return a=Array.from(c.parentNode.childNodes),a.indexOf(c)-a.indexOf(f)}})}function nd(a){var b=[];do b.unshift(a);while(a=a.parentNode);return b}function Ec(a){Dc(a);return!!a.s.length}G.prototype.addEventListener=function(a,b,c){"object"!==typeof c&&(c={capture:!!c});c.ba=this;this.host.addEventListener(a,b,c)};
G.prototype.removeEventListener=function(a,b,c){"object"!==typeof c&&(c={capture:!!c});c.ba=this;this.host.removeEventListener(a,b,c)};G.prototype.getElementById=function(a){return Jc(this,function(b){return b.id==a},function(a){return!!a})[0]||null};var od=G.prototype;E(od,mc,!0);E(od,rc,!0);function pd(a){var b=a.getRootNode();z(b)&&jd(b);return a.__shady&&a.__shady.assignedSlot||null}
var qd={addEventListener:Zc.bind(window),removeEventListener:ad.bind(window)},rd={addEventListener:Zc,removeEventListener:ad,appendChild:function(a){return wc(this,a)},insertBefore:function(a,b){return wc(this,a,b)},removeChild:function(a){return xc(this,a)},replaceChild:function(a,b){wc(this,a,b);xc(this,b);return a},cloneNode:function(a){if("template"==this.localName)var b=A.cloneNode.call(this,a);else if(b=A.cloneNode.call(this,!1),a){a=this.childNodes;for(var c=0,d;c<a.length;c++)d=a[c].cloneNode(!0),
b.appendChild(d)}return b},getRootNode:function(){return Ic(this)},contains:function(a){return Cb(this,a)},get isConnected(){var a=this.ownerDocument;if(Bb&&A.contains.call(a,this)||a.documentElement&&A.contains.call(a.documentElement,this))return!0;for(a=this;a&&!(a instanceof Document);)a=a.parentNode||(a instanceof G?a.host:void 0);return!!(a&&a instanceof Document)},dispatchEvent:function(a){Gb();return A.dispatchEvent.call(this,a)}},sd={get assignedSlot(){return pd(this)}},td={querySelector:function(a){return Jc(this,
function(b){return tb.call(b,a)},function(a){return!!a})[0]||null},querySelectorAll:function(a){return Jc(this,function(b){return tb.call(b,a)})}},ud={assignedNodes:function(a){if("slot"===this.localName){var b=this.getRootNode();z(b)&&jd(b);return this.__shady?(a&&a.flatten?this.__shady.K:this.__shady.assignedNodes)||[]:[]}}},vd=vb({setAttribute:function(a,b){Mc(this,a,b)},removeAttribute:function(a){A.removeAttribute.call(this,a);Fc(this,a)},attachShadow:function(a){if(!this)throw"Must provide a host.";
if(!a)throw"Not enough arguments.";return new G(id,this,a)},get slot(){return this.getAttribute("slot")},set slot(a){Mc(this,"slot",a)},get assignedSlot(){return pd(this)}},td,ud);Object.defineProperties(vd,qc);var wd=vb({importNode:function(a,b){return Nc(a,b)},getElementById:function(a){return Jc(this,function(b){return b.id==a},function(a){return!!a})[0]||null}},td);Object.defineProperties(wd,{_activeElement:rc.activeElement});
var xd=HTMLElement.prototype.blur,yd=vb({blur:function(){var a=this.__shady&&this.__shady.root;(a=a&&a.activeElement)?a.blur():xd.call(this)}});function H(a,b){for(var c=Object.getOwnPropertyNames(b),d=0;d<c.length;d++){var e=c[d],f=Object.getOwnPropertyDescriptor(b,e);f.value?a[e]=f.value:Object.defineProperty(a,e,f)}};if(y.ta){var ShadyDOM={inUse:y.ta,patch:function(a){return a},isShadyRoot:z,enqueue:Fb,flush:Gb,settings:y,filterMutations:Mb,observeChildren:Kb,unobserveChildren:Lb,nativeMethods:A,nativeTree:B};window.ShadyDOM=ShadyDOM;window.Event=cd;window.CustomEvent=dd;window.MouseEvent=ed;bd();var zd=window.customElements&&window.customElements.nativeHTMLElement||HTMLElement;H(window.Node.prototype,rd);H(window.Window.prototype,qd);H(window.Text.prototype,sd);H(window.DocumentFragment.prototype,td);H(window.Element.prototype,
vd);H(window.Document.prototype,wd);window.HTMLSlotElement&&H(window.HTMLSlotElement.prototype,ud);H(zd.prototype,yd);y.M&&(F(window.Node.prototype),F(window.Text.prototype),F(window.DocumentFragment.prototype),F(window.Element.prototype),F(zd.prototype),F(window.Document.prototype),window.HTMLSlotElement&&F(window.HTMLSlotElement.prototype));window.ShadowRoot=G};var Ad=new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));function Bd(a){var b=Ad.has(a);a=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(a);return!b&&a}function J(a){var b=a.isConnected;if(void 0!==b)return b;for(;a&&!(a.__CE_isImportDocument||a instanceof Document);)a=a.parentNode||(window.ShadowRoot&&a instanceof ShadowRoot?a.host:void 0);return!(!a||!(a.__CE_isImportDocument||a instanceof Document))}
function Cd(a,b){for(;b&&b!==a&&!b.nextSibling;)b=b.parentNode;return b&&b!==a?b.nextSibling:null}
function K(a,b,c){c=void 0===c?new Set:c;for(var d=a;d;){if(d.nodeType===Node.ELEMENT_NODE){var e=d;b(e);var f=e.localName;if("link"===f&&"import"===e.getAttribute("rel")){d=e.import;if(d instanceof Node&&!c.has(d))for(c.add(d),d=d.firstChild;d;d=d.nextSibling)K(d,b,c);d=Cd(a,e);continue}else if("template"===f){d=Cd(a,e);continue}if(e=e.__CE_shadowRoot)for(e=e.firstChild;e;e=e.nextSibling)K(e,b,c)}d=d.firstChild?d.firstChild:Cd(a,d)}}function L(a,b,c){a[b]=c};function Dd(){this.a=new Map;this.o=new Map;this.h=[];this.c=!1}function Ed(a,b,c){a.a.set(b,c);a.o.set(c.constructor,c)}function Fd(a,b){a.c=!0;a.h.push(b)}function Gd(a,b){a.c&&K(b,function(b){return a.b(b)})}Dd.prototype.b=function(a){if(this.c&&!a.__CE_patched){a.__CE_patched=!0;for(var b=0;b<this.h.length;b++)this.h[b](a)}};function M(a,b){var c=[];K(b,function(a){return c.push(a)});for(b=0;b<c.length;b++){var d=c[b];1===d.__CE_state?a.connectedCallback(d):Hd(a,d)}}
function N(a,b){var c=[];K(b,function(a){return c.push(a)});for(b=0;b<c.length;b++){var d=c[b];1===d.__CE_state&&a.disconnectedCallback(d)}}
function O(a,b,c){c=void 0===c?{}:c;var d=c.$a||new Set,e=c.wa||function(b){return Hd(a,b)},f=[];K(b,function(b){if("link"===b.localName&&"import"===b.getAttribute("rel")){var c=b.import;c instanceof Node&&(c.__CE_isImportDocument=!0,c.__CE_hasRegistry=!0);c&&"complete"===c.readyState?c.__CE_documentLoadHandled=!0:b.addEventListener("load",function(){var c=b.import;if(!c.__CE_documentLoadHandled){c.__CE_documentLoadHandled=!0;var f=new Set(d);f.delete(c);O(a,c,{$a:f,wa:e})}})}else f.push(b)},d);if(a.c)for(b=
0;b<f.length;b++)a.b(f[b]);for(b=0;b<f.length;b++)e(f[b])}
function Hd(a,b){if(void 0===b.__CE_state){var c=b.ownerDocument;if(c.defaultView||c.__CE_isImportDocument&&c.__CE_hasRegistry)if(c=a.a.get(b.localName)){c.constructionStack.push(b);var d=c.constructor;try{try{if(new d!==b)throw Error("The custom element constructor did not produce the element being upgraded.");}finally{c.constructionStack.pop()}}catch(h){throw b.__CE_state=2,h;}b.__CE_state=1;b.__CE_definition=c;if(c.attributeChangedCallback)for(c=c.observedAttributes,d=0;d<c.length;d++){var e=c[d],
f=b.getAttribute(e);null!==f&&a.attributeChangedCallback(b,e,null,f,null)}J(b)&&a.connectedCallback(b)}}}Dd.prototype.connectedCallback=function(a){var b=a.__CE_definition;b.connectedCallback&&b.connectedCallback.call(a)};Dd.prototype.disconnectedCallback=function(a){var b=a.__CE_definition;b.disconnectedCallback&&b.disconnectedCallback.call(a)};
Dd.prototype.attributeChangedCallback=function(a,b,c,d,e){var f=a.__CE_definition;f.attributeChangedCallback&&-1<f.observedAttributes.indexOf(b)&&f.attributeChangedCallback.call(a,b,c,d,e)};function Id(a){var b=document;this.j=a;this.a=b;this.C=void 0;O(this.j,this.a);"loading"===this.a.readyState&&(this.C=new MutationObserver(this.b.bind(this)),this.C.observe(this.a,{childList:!0,subtree:!0}))}function Jd(a){a.C&&a.C.disconnect()}Id.prototype.b=function(a){var b=this.a.readyState;"interactive"!==b&&"complete"!==b||Jd(this);for(b=0;b<a.length;b++)for(var c=a[b].addedNodes,d=0;d<c.length;d++)O(this.j,c[d])};function Kd(){var a=this;this.b=this.a=void 0;this.c=new Promise(function(b){a.b=b;a.a&&b(a.a)})}Kd.prototype.resolve=function(a){if(this.a)throw Error("Already resolved.");this.a=a;this.b&&this.b(a)};function P(a){this.da=!1;this.j=a;this.ha=new Map;this.ea=function(a){return a()};this.R=!1;this.fa=[];this.Fa=new Id(a)}
P.prototype.define=function(a,b){var c=this;if(!(b instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!Bd(a))throw new SyntaxError("The element name '"+a+"' is not valid.");if(this.j.a.get(a))throw Error("A custom element with name '"+a+"' has already been defined.");if(this.da)throw Error("A custom element is already being defined.");this.da=!0;try{var d=function(a){var b=e[a];if(void 0!==b&&!(b instanceof Function))throw Error("The '"+a+"' callback must be a function.");
return b},e=b.prototype;if(!(e instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");var f=d("connectedCallback");var h=d("disconnectedCallback");var g=d("adoptedCallback");var k=d("attributeChangedCallback");var l=b.observedAttributes||[]}catch(m){return}finally{this.da=!1}b={localName:a,constructor:b,connectedCallback:f,disconnectedCallback:h,adoptedCallback:g,attributeChangedCallback:k,observedAttributes:l,constructionStack:[]};Ed(this.j,a,b);this.fa.push(b);
this.R||(this.R=!0,this.ea(function(){return Ld(c)}))};function Ld(a){if(!1!==a.R){a.R=!1;for(var b=a.fa,c=[],d=new Map,e=0;e<b.length;e++)d.set(b[e].localName,[]);O(a.j,document,{wa:function(b){if(void 0===b.__CE_state){var e=b.localName,f=d.get(e);f?f.push(b):a.j.a.get(e)&&c.push(b)}}});for(e=0;e<c.length;e++)Hd(a.j,c[e]);for(;0<b.length;){var f=b.shift();e=f.localName;f=d.get(f.localName);for(var h=0;h<f.length;h++)Hd(a.j,f[h]);(e=a.ha.get(e))&&e.resolve(void 0)}}}
P.prototype.get=function(a){if(a=this.j.a.get(a))return a.constructor};P.prototype.whenDefined=function(a){if(!Bd(a))return Promise.reject(new SyntaxError("'"+a+"' is not a valid custom element name."));var b=this.ha.get(a);if(b)return b.c;b=new Kd;this.ha.set(a,b);this.j.a.get(a)&&!this.fa.some(function(b){return b.localName===a})&&b.resolve(void 0);return b.c};P.prototype.Ta=function(a){Jd(this.Fa);var b=this.ea;this.ea=function(c){return a(function(){return b(c)})}};
window.CustomElementRegistry=P;P.prototype.define=P.prototype.define;P.prototype.get=P.prototype.get;P.prototype.whenDefined=P.prototype.whenDefined;P.prototype.polyfillWrapFlushCallback=P.prototype.Ta;var Md=window.Document.prototype.createElement,Nd=window.Document.prototype.createElementNS,Od=window.Document.prototype.importNode,Pd=window.Document.prototype.prepend,Qd=window.Document.prototype.append,Rd=window.DocumentFragment.prototype.prepend,Sd=window.DocumentFragment.prototype.append,Td=window.Node.prototype.cloneNode,Ud=window.Node.prototype.appendChild,Vd=window.Node.prototype.insertBefore,Wd=window.Node.prototype.removeChild,Xd=window.Node.prototype.replaceChild,Yd=Object.getOwnPropertyDescriptor(window.Node.prototype,
"textContent"),Zd=window.Element.prototype.attachShadow,$d=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),ae=window.Element.prototype.getAttribute,be=window.Element.prototype.setAttribute,ce=window.Element.prototype.removeAttribute,de=window.Element.prototype.getAttributeNS,ee=window.Element.prototype.setAttributeNS,fe=window.Element.prototype.removeAttributeNS,ge=window.Element.prototype.insertAdjacentElement,he=window.Element.prototype.prepend,ie=window.Element.prototype.append,
je=window.Element.prototype.before,ke=window.Element.prototype.after,le=window.Element.prototype.replaceWith,me=window.Element.prototype.remove,ne=window.HTMLElement,oe=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),pe=window.HTMLElement.prototype.insertAdjacentElement;var qe=new function(){};function re(){var a=se;window.HTMLElement=function(){function b(){var b=this.constructor,d=a.o.get(b);if(!d)throw Error("The custom element being constructed was not registered with `customElements`.");var e=d.constructionStack;if(0===e.length)return e=Md.call(document,d.localName),Object.setPrototypeOf(e,b.prototype),e.__CE_state=1,e.__CE_definition=d,a.b(e),e;d=e.length-1;var f=e[d];if(f===qe)throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
e[d]=qe;Object.setPrototypeOf(f,b.prototype);a.b(f);return f}b.prototype=ne.prototype;return b}()};function te(a,b,c){function d(b){return function(c){for(var d=[],e=0;e<arguments.length;++e)d[e-0]=arguments[e];e=[];for(var f=[],l=0;l<d.length;l++){var m=d[l];m instanceof Element&&J(m)&&f.push(m);if(m instanceof DocumentFragment)for(m=m.firstChild;m;m=m.nextSibling)e.push(m);else e.push(m)}b.apply(this,d);for(d=0;d<f.length;d++)N(a,f[d]);if(J(this))for(d=0;d<e.length;d++)f=e[d],f instanceof Element&&M(a,f)}}void 0!==c.X&&(b.prepend=d(c.X));void 0!==c.append&&(b.append=d(c.append))};function ue(){var a=se;L(Document.prototype,"createElement",function(b){if(this.__CE_hasRegistry){var c=a.a.get(b);if(c)return new c.constructor}b=Md.call(this,b);a.b(b);return b});L(Document.prototype,"importNode",function(b,c){b=Od.call(this,b,c);this.__CE_hasRegistry?O(a,b):Gd(a,b);return b});L(Document.prototype,"createElementNS",function(b,c){if(this.__CE_hasRegistry&&(null===b||"http://www.w3.org/1999/xhtml"===b)){var d=a.a.get(c);if(d)return new d.constructor}b=Nd.call(this,b,c);a.b(b);return b});
te(a,Document.prototype,{X:Pd,append:Qd})};function ve(){var a=se;function b(b,d){Object.defineProperty(b,"textContent",{enumerable:d.enumerable,configurable:!0,get:d.get,set:function(b){if(this.nodeType===Node.TEXT_NODE)d.set.call(this,b);else{var c=void 0;if(this.firstChild){var e=this.childNodes,g=e.length;if(0<g&&J(this)){c=Array(g);for(var k=0;k<g;k++)c[k]=e[k]}}d.set.call(this,b);if(c)for(b=0;b<c.length;b++)N(a,c[b])}}})}L(Node.prototype,"insertBefore",function(b,d){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);
b=Vd.call(this,b,d);if(J(this))for(d=0;d<c.length;d++)M(a,c[d]);return b}c=J(b);d=Vd.call(this,b,d);c&&N(a,b);J(this)&&M(a,b);return d});L(Node.prototype,"appendChild",function(b){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);b=Ud.call(this,b);if(J(this))for(var e=0;e<c.length;e++)M(a,c[e]);return b}c=J(b);e=Ud.call(this,b);c&&N(a,b);J(this)&&M(a,b);return e});L(Node.prototype,"cloneNode",function(b){b=Td.call(this,b);this.ownerDocument.__CE_hasRegistry?O(a,b):
Gd(a,b);return b});L(Node.prototype,"removeChild",function(b){var c=J(b),e=Wd.call(this,b);c&&N(a,b);return e});L(Node.prototype,"replaceChild",function(b,d){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);b=Xd.call(this,b,d);if(J(this))for(N(a,d),d=0;d<c.length;d++)M(a,c[d]);return b}c=J(b);var f=Xd.call(this,b,d),h=J(this);h&&N(a,d);c&&N(a,b);h&&M(a,b);return f});Yd&&Yd.get?b(Node.prototype,Yd):Fd(a,function(a){b(a,{enumerable:!0,configurable:!0,get:function(){for(var a=
[],b=0;b<this.childNodes.length;b++)a.push(this.childNodes[b].textContent);return a.join("")},set:function(a){for(;this.firstChild;)Wd.call(this,this.firstChild);Ud.call(this,document.createTextNode(a))}})})};function we(a){var b=Element.prototype;function c(b){return function(c){for(var d=[],e=0;e<arguments.length;++e)d[e-0]=arguments[e];e=[];for(var g=[],k=0;k<d.length;k++){var l=d[k];l instanceof Element&&J(l)&&g.push(l);if(l instanceof DocumentFragment)for(l=l.firstChild;l;l=l.nextSibling)e.push(l);else e.push(l)}b.apply(this,d);for(d=0;d<g.length;d++)N(a,g[d]);if(J(this))for(d=0;d<e.length;d++)g=e[d],g instanceof Element&&M(a,g)}}void 0!==je&&(b.before=c(je));void 0!==je&&(b.after=c(ke));void 0!==
le&&L(b,"replaceWith",function(b){for(var c=[],d=0;d<arguments.length;++d)c[d-0]=arguments[d];d=[];for(var h=[],g=0;g<c.length;g++){var k=c[g];k instanceof Element&&J(k)&&h.push(k);if(k instanceof DocumentFragment)for(k=k.firstChild;k;k=k.nextSibling)d.push(k);else d.push(k)}g=J(this);le.apply(this,c);for(c=0;c<h.length;c++)N(a,h[c]);if(g)for(N(a,this),c=0;c<d.length;c++)h=d[c],h instanceof Element&&M(a,h)});void 0!==me&&L(b,"remove",function(){var b=J(this);me.call(this);b&&N(a,this)})};function xe(){var a=se;function b(b,c){Object.defineProperty(b,"innerHTML",{enumerable:c.enumerable,configurable:!0,get:c.get,set:function(b){var d=this,e=void 0;J(this)&&(e=[],K(this,function(a){a!==d&&e.push(a)}));c.set.call(this,b);if(e)for(var f=0;f<e.length;f++){var l=e[f];1===l.__CE_state&&a.disconnectedCallback(l)}this.ownerDocument.__CE_hasRegistry?O(a,this):Gd(a,this);return b}})}function c(b,c){L(b,"insertAdjacentElement",function(b,d){var e=J(d);b=c.call(this,b,d);e&&N(a,d);J(b)&&M(a,d);
return b})}Zd&&L(Element.prototype,"attachShadow",function(a){return this.__CE_shadowRoot=a=Zd.call(this,a)});$d&&$d.get?b(Element.prototype,$d):oe&&oe.get?b(HTMLElement.prototype,oe):Fd(a,function(a){b(a,{enumerable:!0,configurable:!0,get:function(){return Td.call(this,!0).innerHTML},set:function(a){var b="template"===this.localName,c=b?this.content:this,d=Md.call(document,this.localName);for(d.innerHTML=a;0<c.childNodes.length;)Wd.call(c,c.childNodes[0]);for(a=b?d.content:d;0<a.childNodes.length;)Ud.call(c,
a.childNodes[0])}})});L(Element.prototype,"setAttribute",function(b,c){if(1!==this.__CE_state)return be.call(this,b,c);var d=ae.call(this,b);be.call(this,b,c);c=ae.call(this,b);a.attributeChangedCallback(this,b,d,c,null)});L(Element.prototype,"setAttributeNS",function(b,c,f){if(1!==this.__CE_state)return ee.call(this,b,c,f);var d=de.call(this,b,c);ee.call(this,b,c,f);f=de.call(this,b,c);a.attributeChangedCallback(this,c,d,f,b)});L(Element.prototype,"removeAttribute",function(b){if(1!==this.__CE_state)return ce.call(this,
b);var c=ae.call(this,b);ce.call(this,b);null!==c&&a.attributeChangedCallback(this,b,c,null,null)});L(Element.prototype,"removeAttributeNS",function(b,c){if(1!==this.__CE_state)return fe.call(this,b,c);var d=de.call(this,b,c);fe.call(this,b,c);var e=de.call(this,b,c);d!==e&&a.attributeChangedCallback(this,c,d,e,b)});pe?c(HTMLElement.prototype,pe):ge?c(Element.prototype,ge):console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");te(a,Element.prototype,{X:he,append:ie});we(a)}
;var ye=window.customElements;if(!ye||ye.forcePolyfill||"function"!=typeof ye.define||"function"!=typeof ye.get){var se=new Dd;re();ue();te(se,DocumentFragment.prototype,{X:Rd,append:Sd});ve();xe();document.__CE_hasRegistry=!0;var customElements=new P(se);Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:customElements})};function ze(){this.end=this.start=0;this.rules=this.parent=this.previous=null;this.cssText=this.parsedCssText="";this.atRule=!1;this.type=0;this.parsedSelector=this.selector=this.keyframesName=""}
function Ae(a){a=a.replace(Be,"").replace(Ce,"");var b=De,c=a,d=new ze;d.start=0;d.end=c.length;for(var e=d,f=0,h=c.length;f<h;f++)if("{"===c[f]){e.rules||(e.rules=[]);var g=e,k=g.rules[g.rules.length-1]||null;e=new ze;e.start=f+1;e.parent=g;e.previous=k;g.rules.push(e)}else"}"===c[f]&&(e.end=f+1,e=e.parent||d);return b(d,a)}
function De(a,b){var c=b.substring(a.start,a.end-1);a.parsedCssText=a.cssText=c.trim();a.parent&&(c=b.substring(a.previous?a.previous.end:a.parent.start,a.start-1),c=Ee(c),c=c.replace(Fe," "),c=c.substring(c.lastIndexOf(";")+1),c=a.parsedSelector=a.selector=c.trim(),a.atRule=0===c.indexOf("@"),a.atRule?0===c.indexOf("@media")?a.type=Je:c.match(Ke)&&(a.type=Le,a.keyframesName=a.selector.split(Fe).pop()):a.type=0===c.indexOf("--")?Me:Ne);if(c=a.rules)for(var d=0,e=c.length,f;d<e&&(f=c[d]);d++)De(f,
b);return a}function Ee(a){return a.replace(/\\([0-9a-f]{1,6})\s/gi,function(a,c){a=c;for(c=6-a.length;c--;)a="0"+a;return"\\"+a})}
function Oe(a,b,c){c=void 0===c?"":c;var d="";if(a.cssText||a.rules){var e=a.rules,f;if(f=e)f=e[0],f=!(f&&f.selector&&0===f.selector.indexOf("--"));if(f){f=0;for(var h=e.length,g;f<h&&(g=e[f]);f++)d=Oe(g,b,d)}else b?b=a.cssText:(b=a.cssText,b=b.replace(Pe,"").replace(Qe,""),b=b.replace(Re,"").replace(Se,"")),(d=b.trim())&&(d="  "+d+"\n")}d&&(a.selector&&(c+=a.selector+" {\n"),c+=d,a.selector&&(c+="}\n\n"));return c}
var Ne=1,Le=7,Je=4,Me=1E3,Be=/\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,Ce=/@import[^;]*;/gim,Pe=/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,Qe=/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,Re=/@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,Se=/[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,Ke=/^@[^\s]*keyframes/,Fe=/\s+/g;var Q=!(window.ShadyDOM&&window.ShadyDOM.inUse),Te;function Ue(a){Te=a&&a.shimcssproperties?!1:Q||!(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/)||!window.CSS||!CSS.supports||!CSS.supports("box-shadow","0 0 0 var(--foo)"))}window.ShadyCSS&&void 0!==window.ShadyCSS.nativeCss?Te=window.ShadyCSS.nativeCss:window.ShadyCSS?(Ue(window.ShadyCSS),window.ShadyCSS=void 0):Ue(window.WebComponents&&window.WebComponents.flags);var R=Te;var Ve=/(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,We=/(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,Xe=/(--[\w-]+)\s*([:,;)]|$)/gi,Ye=/(animation\s*:)|(animation-name\s*:)/,Ze=/@media\s(.*)/,$e=/\{[^}]*\}/g;var af=new Set;function bf(a,b){if(!a)return"";"string"===typeof a&&(a=Ae(a));b&&cf(a,b);return Oe(a,R)}function df(a){!a.__cssRules&&a.textContent&&(a.__cssRules=Ae(a.textContent));return a.__cssRules||null}function ef(a){return!!a.parent&&a.parent.type===Le}function cf(a,b,c,d){if(a){var e=!1,f=a.type;if(d&&f===Je){var h=a.selector.match(Ze);h&&(window.matchMedia(h[1]).matches||(e=!0))}f===Ne?b(a):c&&f===Le?c(a):f===Me&&(e=!0);if((a=a.rules)&&!e){e=0;f=a.length;for(var g;e<f&&(g=a[e]);e++)cf(g,b,c,d)}}}
function ff(a,b,c,d){var e=document.createElement("style");b&&e.setAttribute("scope",b);e.textContent=a;gf(e,c,d);return e}var S=null;function gf(a,b,c){b=b||document.head;b.insertBefore(a,c&&c.nextSibling||b.firstChild);S?a.compareDocumentPosition(S)===Node.DOCUMENT_POSITION_PRECEDING&&(S=a):S=a}
function hf(a,b){var c=a.indexOf("var(");if(-1===c)return b(a,"","","");a:{var d=0;var e=c+3;for(var f=a.length;e<f;e++)if("("===a[e])d++;else if(")"===a[e]&&0===--d)break a;e=-1}d=a.substring(c+4,e);c=a.substring(0,c);a=hf(a.substring(e+1),b);e=d.indexOf(",");return-1===e?b(c,d.trim(),"",a):b(c,d.substring(0,e).trim(),d.substring(e+1).trim(),a)}function jf(a,b){Q?a.setAttribute("class",b):window.ShadyDOM.nativeMethods.setAttribute.call(a,"class",b)}
function V(a){var b=a.localName,c="";b?-1<b.indexOf("-")||(c=b,b=a.getAttribute&&a.getAttribute("is")||""):(b=a.is,c=a.extends);return{is:b,P:c}};function kf(){}function lf(a,b,c){var d=W;a.__styleScoped?a.__styleScoped=null:mf(d,a,b||"",c)}function mf(a,b,c,d){b.nodeType===Node.ELEMENT_NODE&&nf(b,c,d);if(b="template"===b.localName?(b.content||b.gb).childNodes:b.children||b.childNodes)for(var e=0;e<b.length;e++)mf(a,b[e],c,d)}
function nf(a,b,c){if(b)if(a.classList)c?(a.classList.remove("style-scope"),a.classList.remove(b)):(a.classList.add("style-scope"),a.classList.add(b));else if(a.getAttribute){var d=a.getAttribute(of);c?d&&(b=d.replace("style-scope","").replace(b,""),jf(a,b)):jf(a,(d?d+" ":"")+"style-scope "+b)}}function pf(a,b,c){var d=W,e=a.__cssBuild;Q||"shady"===e?b=bf(b,c):(a=V(a),b=qf(d,b,a.is,a.P,c)+"\n\n");return b.trim()}
function qf(a,b,c,d,e){var f=rf(c,d);c=c?sf+c:"";return bf(b,function(b){b.c||(b.selector=b.m=tf(a,b,a.b,c,f),b.c=!0);e&&e(b,c,f)})}function rf(a,b){return b?"[is="+a+"]":a}function tf(a,b,c,d,e){var f=b.selector.split(uf);if(!ef(b)){b=0;for(var h=f.length,g;b<h&&(g=f[b]);b++)f[b]=c.call(a,g,d,e)}return f.join(uf)}function vf(a){return a.replace(wf,function(a,c,d){-1<d.indexOf("+")?d=d.replace(/\+/g,"___"):-1<d.indexOf("___")&&(d=d.replace(/___/g,"+"));return":"+c+"("+d+")"})}
kf.prototype.b=function(a,b,c){var d=!1;a=a.trim();var e=wf.test(a);e&&(a=a.replace(wf,function(a,b,c){return":"+b+"("+c.replace(/\s/g,"")+")"}),a=vf(a));a=a.replace(xf,yf+" $1");a=a.replace(zf,function(a,e,g){d||(a=Af(g,e,b,c),d=d||a.stop,e=a.Ja,g=a.value);return e+g});e&&(a=vf(a));return a};
function Af(a,b,c,d){var e=a.indexOf(Bf);0<=a.indexOf(yf)?a=Cf(a,d):0!==e&&(a=c?Df(a,c):a);c=!1;0<=e&&(b="",c=!0);if(c){var f=!0;c&&(a=a.replace(Ef,function(a,b){return" > "+b}))}a=a.replace(Ff,function(a,b,c){return'[dir="'+c+'"] '+b+", "+b+'[dir="'+c+'"]'});return{value:a,Ja:b,stop:f}}function Df(a,b){a=a.split(Gf);a[0]+=b;return a.join(Gf)}
function Cf(a,b){var c=a.match(Hf);return(c=c&&c[2].trim()||"")?c[0].match(If)?a.replace(Hf,function(a,c,f){return b+f}):c.split(If)[0]===b?c:Jf:a.replace(yf,b)}function Kf(a){a.selector===Lf&&(a.selector="html")}kf.prototype.c=function(a){return a.match(Bf)?this.b(a,Mf):Df(a.trim(),Mf)};q.Object.defineProperties(kf.prototype,{a:{configurable:!0,enumerable:!0,get:function(){return"style-scope"}}});
var wf=/:(nth[-\w]+)\(([^)]+)\)/,Mf=":not(.style-scope)",uf=",",zf=/(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=[])+)/g,If=/[[.:#*]/,yf=":host",Lf=":root",Bf="::slotted",xf=new RegExp("^("+Bf+")"),Hf=/(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,Ef=/(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,Ff=/(.*):dir\((?:(ltr|rtl))\)/,sf=".",Gf=":",of="class",Jf="should_not_match",W=new kf;function Nf(a,b,c,d){this.w=a||null;this.b=b||null;this.ja=c||[];this.G=null;this.P=d||"";this.a=this.u=this.B=null}function X(a){return a?a.__styleInfo:null}function Of(a,b){return a.__styleInfo=b}Nf.prototype.c=function(){return this.w};Nf.prototype._getStyleRules=Nf.prototype.c;var Pf,Qf=window.Element.prototype;Pf=Qf.matches||Qf.matchesSelector||Qf.mozMatchesSelector||Qf.msMatchesSelector||Qf.oMatchesSelector||Qf.webkitMatchesSelector;var Rf=navigator.userAgent.match("Trident");function Sf(){}function Tf(a){var b={},c=[],d=0;cf(a,function(a){Uf(a);a.index=d++;a=a.i.cssText;for(var c;c=Xe.exec(a);){var e=c[1];":"!==c[2]&&(b[e]=!0)}},function(a){c.push(a)});a.b=c;a=[];for(var e in b)a.push(e);return a}
function Uf(a){if(!a.i){var b={},c={};Vf(a,c)&&(b.v=c,a.rules=null);b.cssText=a.parsedCssText.replace($e,"").replace(Ve,"");a.i=b}}function Vf(a,b){var c=a.i;if(c){if(c.v)return Object.assign(b,c.v),!0}else{c=a.parsedCssText;for(var d;a=Ve.exec(c);){d=(a[2]||a[3]).trim();if("inherit"!==d||"unset"!==d)b[a[1].trim()]=d;d=!0}return d}}
function Wf(a,b,c){b&&(b=0<=b.indexOf(";")?Xf(a,b,c):hf(b,function(b,e,f,h){if(!e)return b+h;(e=Wf(a,c[e],c))&&"initial"!==e?"apply-shim-inherit"===e&&(e="inherit"):e=Wf(a,c[f]||f,c)||f;return b+(e||"")+h}));return b&&b.trim()||""}
function Xf(a,b,c){b=b.split(";");for(var d=0,e,f;d<b.length;d++)if(e=b[d]){We.lastIndex=0;if(f=We.exec(e))e=Wf(a,c[f[1]],c);else if(f=e.indexOf(":"),-1!==f){var h=e.substring(f);h=h.trim();h=Wf(a,h,c)||h;e=e.substring(0,f)+h}b[d]=e&&e.lastIndexOf(";")===e.length-1?e.slice(0,-1):e||""}return b.join(";")}
function Yf(a,b){var c={},d=[];cf(a,function(a){a.i||Uf(a);var e=a.m||a.parsedSelector;b&&a.i.v&&e&&Pf.call(b,e)&&(Vf(a,c),a=a.index,e=parseInt(a/32,10),d[e]=(d[e]||0)|1<<a%32)},null,!0);return{v:c,key:d}}
function Zf(a,b,c,d){b.i||Uf(b);if(b.i.v){var e=V(a);a=e.is;e=e.P;e=a?rf(a,e):"html";var f=b.parsedSelector,h=":host > *"===f||"html"===f,g=0===f.indexOf(":host")&&!h;"shady"===c&&(h=f===e+" > *."+e||-1!==f.indexOf("html"),g=!h&&0===f.indexOf(e));"shadow"===c&&(h=":host > *"===f||"html"===f,g=g&&!h);if(h||g)c=e,g&&(Q&&!b.m&&(b.m=tf(W,b,W.b,a?sf+a:"",e)),c=b.m||e),d({Xa:c,Oa:g,ib:h})}}
function $f(a,b){var c={},d={},e=b&&b.__cssBuild;cf(b,function(b){Zf(a,b,e,function(e){Pf.call(a.hb||a,e.Xa)&&(e.Oa?Vf(b,c):Vf(b,d))})},null,!0);return{Va:d,Na:c}}
function ag(a,b,c,d){var e=V(b),f=rf(e.is,e.P),h=new RegExp("(?:^|[^.#[:])"+(b.extends?"\\"+f.slice(0,-1)+"\\]":f)+"($|[.:[\\s>+~])");e=X(b).w;var g=bg(e,d);return pf(b,e,function(b){var e="";b.i||Uf(b);b.i.cssText&&(e=Xf(a,b.i.cssText,c));b.cssText=e;if(!Q&&!ef(b)&&b.cssText){var k=e=b.cssText;null==b.ra&&(b.ra=Ye.test(e));if(b.ra)if(null==b.W){b.W=[];for(var n in g)k=g[n],k=k(e),e!==k&&(e=k,b.W.push(n))}else{for(n=0;n<b.W.length;++n)k=g[b.W[n]],e=k(e);k=e}b.cssText=k;b.m=b.m||b.selector;e="."+d;
n=b.m.split(",");k=0;for(var w=n.length,I;k<w&&(I=n[k]);k++)n[k]=I.match(h)?I.replace(f,e):e+" "+I;b.selector=n.join(",")}})}function bg(a,b){a=a.b;var c={};if(!Q&&a)for(var d=0,e=a[d];d<a.length;e=a[++d]){var f=e,h=b;f.h=new RegExp(f.keyframesName,"g");f.a=f.keyframesName+"-"+h;f.m=f.m||f.selector;f.selector=f.m.replace(f.keyframesName,f.a);c[e.keyframesName]=cg(e)}return c}function cg(a){return function(b){return b.replace(a.h,a.a)}}
function dg(a,b){var c=eg,d=df(a);a.textContent=bf(d,function(a){var d=a.cssText=a.parsedCssText;a.i&&a.i.cssText&&(d=d.replace(Pe,"").replace(Qe,""),a.cssText=Xf(c,d,b))})}q.Object.defineProperties(Sf.prototype,{a:{configurable:!0,enumerable:!0,get:function(){return"x-scope"}}});var eg=new Sf;var fg={},gg=window.customElements;if(gg&&!Q){var hg=gg.define;gg.define=function(a,b,c){var d=document.createComment(" Shady DOM styles for "+a+" "),e=document.head;e.insertBefore(d,(S?S.nextSibling:null)||e.firstChild);S=d;fg[a]=d;return hg.call(gg,a,b,c)}};function ig(){this.cache={}}ig.prototype.store=function(a,b,c,d){var e=this.cache[a]||[];e.push({v:b,styleElement:c,u:d});100<e.length&&e.shift();this.cache[a]=e};ig.prototype.fetch=function(a,b,c){if(a=this.cache[a])for(var d=a.length-1;0<=d;d--){var e=a[d],f;a:{for(f=0;f<c.length;f++){var h=c[f];if(e.v[h]!==b[h]){f=!1;break a}}f=!0}if(f)return e}};function jg(){}
function kg(a){for(var b=0;b<a.length;b++){var c=a[b];if(c.target!==document.documentElement&&c.target!==document.head)for(var d=0;d<c.addedNodes.length;d++){var e=c.addedNodes[d];if(e.nodeType===Node.ELEMENT_NODE){var f=e.getRootNode();var h=e;var g=[];h.classList?g=Array.from(h.classList):h instanceof window.SVGElement&&h.hasAttribute("class")&&(g=h.getAttribute("class").split(/\s+/));h=g;g=h.indexOf(W.a);if((h=-1<g?h[g+1]:"")&&f===e.ownerDocument)lf(e,h,!0);else if(f.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&
(f=f.host))if(f=V(f).is,h===f)for(e=window.ShadyDOM.nativeMethods.querySelectorAll.call(e,":not(."+W.a+")"),f=0;f<e.length;f++)nf(e[f],h);else h&&lf(e,h,!0),lf(e,f)}}}}
if(!Q){var lg=new MutationObserver(kg),mg=function(a){lg.observe(a,{childList:!0,subtree:!0})};if(window.customElements&&!window.customElements.polyfillWrapFlushCallback)mg(document);else{var ng=function(){mg(document.body)};window.HTMLImports?window.HTMLImports.whenReady(ng):requestAnimationFrame(function(){if("loading"===document.readyState){var a=function(){ng();document.removeEventListener("readystatechange",a)};document.addEventListener("readystatechange",a)}else ng()})}jg=function(){kg(lg.takeRecords())}}
var og=jg;var pg={};var qg=Promise.resolve();function rg(a){if(a=pg[a])a._applyShimCurrentVersion=a._applyShimCurrentVersion||0,a._applyShimValidatingVersion=a._applyShimValidatingVersion||0,a._applyShimNextVersion=(a._applyShimNextVersion||0)+1}function sg(a){return a._applyShimCurrentVersion===a._applyShimNextVersion}function tg(a){a._applyShimValidatingVersion=a._applyShimNextVersion;a.b||(a.b=!0,qg.then(function(){a._applyShimCurrentVersion=a._applyShimNextVersion;a.b=!1}))};var ug=null,vg=window.HTMLImports&&window.HTMLImports.whenReady||null,wg;function xg(a){requestAnimationFrame(function(){vg?vg(a):(ug||(ug=new Promise(function(a){wg=a}),"complete"===document.readyState?wg():document.addEventListener("readystatechange",function(){"complete"===document.readyState&&wg()})),ug.then(function(){a&&a()}))})};var yg=new ig;function Y(){var a=this;this.L={};this.c=document.documentElement;var b=new ze;b.rules=[];this.h=Of(this.c,new Nf(b));this.o=!1;this.b=this.a=null;xg(function(){zg(a)})}p=Y.prototype;p.xa=function(){og()};p.La=function(a){return df(a)};p.Za=function(a){return bf(a)};
p.prepareTemplate=function(a,b,c){if(!a.h){a.h=!0;a.name=b;a.extends=c;pg[b]=a;var d=(d=a.content.querySelector("style"))?d.getAttribute("css-build")||"":"";var e=[];for(var f=a.content.querySelectorAll("style"),h=0;h<f.length;h++){var g=f[h];if(g.hasAttribute("shady-unscoped")){if(!Q){var k=g.textContent;af.has(k)||(af.add(k),k=g.cloneNode(!0),document.head.appendChild(k));g.parentNode.removeChild(g)}}else e.push(g.textContent),g.parentNode.removeChild(g)}e=e.join("").trim();c={is:b,extends:c,eb:d};
Q||lf(a.content,b);zg(this);f=We.test(e)||Ve.test(e);We.lastIndex=0;Ve.lastIndex=0;e=Ae(e);f&&R&&this.a&&this.a.transformRules(e,b);a._styleAst=e;a.o=d;d=[];R||(d=Tf(a._styleAst));if(!d.length||R)e=Q?a.content:null,b=fg[b],f=pf(c,a._styleAst),b=f.length?ff(f,c.is,e,b):void 0,a.a=b;a.c=d}};
function Ag(a){!a.b&&window.ShadyCSS&&window.ShadyCSS.CustomStyleInterface&&(a.b=window.ShadyCSS.CustomStyleInterface,a.b.transformCallback=function(b){a.va(b)},a.b.validateCallback=function(){requestAnimationFrame(function(){(a.b.enqueued||a.o)&&a.F()})})}function zg(a){!a.a&&window.ShadyCSS&&window.ShadyCSS.ApplyShim&&(a.a=window.ShadyCSS.ApplyShim,a.a.invalidCallback=rg);Ag(a)}
p.F=function(){zg(this);if(this.b){var a=this.b.processStyles();if(this.b.enqueued){if(R)for(var b=0;b<a.length;b++){var c=this.b.getStyleForCustomStyle(a[b]);if(c&&R&&this.a){var d=df(c);zg(this);this.a.transformRules(d);c.textContent=bf(d)}}else for(Bg(this,this.c,this.h),b=0;b<a.length;b++)(c=this.b.getStyleForCustomStyle(a[b]))&&dg(c,this.h.B);this.b.enqueued=!1;this.o&&!R&&this.styleDocument()}}};
p.styleElement=function(a,b){var c=V(a).is,d=X(a);if(!d){var e=V(a);d=e.is;e=e.P;var f=fg[d];d=pg[d];if(d){var h=d._styleAst;var g=d.c}d=Of(a,new Nf(h,f,g,e))}a!==this.c&&(this.o=!0);b&&(d.G=d.G||{},Object.assign(d.G,b));if(R){if(d.G){b=d.G;for(var k in b)null===k?a.style.removeProperty(k):a.style.setProperty(k,b[k])}if(((k=pg[c])||a===this.c)&&k&&k.a&&!sg(k)){if(sg(k)||k._applyShimValidatingVersion!==k._applyShimNextVersion)zg(this),this.a&&this.a.transformRules(k._styleAst,c),k.a.textContent=pf(a,
d.w),tg(k);Q&&(c=a.shadowRoot)&&(c.querySelector("style").textContent=pf(a,d.w));d.w=k._styleAst}}else if(Bg(this,a,d),d.ja&&d.ja.length){c=d;k=V(a).is;d=(b=yg.fetch(k,c.B,c.ja))?b.styleElement:null;h=c.u;(g=b&&b.u)||(g=this.L[k]=(this.L[k]||0)+1,g=k+"-"+g);c.u=g;g=c.u;e=eg;e=d?d.textContent||"":ag(e,a,c.B,g);f=X(a);var l=f.a;l&&!Q&&l!==d&&(l._useCount--,0>=l._useCount&&l.parentNode&&l.parentNode.removeChild(l));Q?f.a?(f.a.textContent=e,d=f.a):e&&(d=ff(e,g,a.shadowRoot,f.b)):d?d.parentNode||(Rf&&
-1<e.indexOf("@media")&&(d.textContent=e),gf(d,null,f.b)):e&&(d=ff(e,g,null,f.b));d&&(d._useCount=d._useCount||0,f.a!=d&&d._useCount++,f.a=d);g=d;Q||(d=c.u,f=e=a.getAttribute("class")||"",h&&(f=e.replace(new RegExp("\\s*x-scope\\s*"+h+"\\s*","g")," ")),f+=(f?" ":"")+"x-scope "+d,e!==f&&jf(a,f));b||yg.store(k,c.B,g,c.u)}};function Cg(a,b){return(b=b.getRootNode().host)?X(b)?b:Cg(a,b):a.c}
function Bg(a,b,c){a=Cg(a,b);var d=X(a);a=Object.create(d.B||null);var e=$f(b,c.w);b=Yf(d.w,b).v;Object.assign(a,e.Na,b,e.Va);b=c.G;for(var f in b)if((e=b[f])||0===e)a[f]=e;f=eg;b=Object.getOwnPropertyNames(a);for(e=0;e<b.length;e++)d=b[e],a[d]=Wf(f,a[d],a);c.B=a}p.styleDocument=function(a){this.styleSubtree(this.c,a)};
p.styleSubtree=function(a,b){var c=a.shadowRoot;(c||a===this.c)&&this.styleElement(a,b);if(b=c&&(c.children||c.childNodes))for(a=0;a<b.length;a++)this.styleSubtree(b[a]);else if(a=a.children||a.childNodes)for(b=0;b<a.length;b++)this.styleSubtree(a[b])};p.va=function(a){var b=this,c=df(a);cf(c,function(a){if(Q)Kf(a);else{var c=W;a.selector=a.parsedSelector;Kf(a);a.selector=a.m=tf(c,a,c.c,void 0,void 0)}R&&(zg(b),b.a&&b.a.transformRule(a))});R?a.textContent=bf(c):this.h.w.rules.push(c)};
p.getComputedStyleValue=function(a,b){var c;R||(c=(X(a)||X(Cg(this,a))).B[b]);return(c=c||window.getComputedStyle(a).getPropertyValue(b))?c.trim():""};p.Ya=function(a,b){var c=a.getRootNode();b=b?b.split(/\s/):[];c=c.host&&c.host.localName;if(!c){var d=a.getAttribute("class");if(d){d=d.split(/\s/);for(var e=0;e<d.length;e++)if(d[e]===W.a){c=d[e+1];break}}}c&&b.push(W.a,c);R||(c=X(a))&&c.u&&b.push(eg.a,c.u);jf(a,b.join(" "))};p.Ia=function(a){return X(a)};Y.prototype.flush=Y.prototype.xa;
Y.prototype.prepareTemplate=Y.prototype.prepareTemplate;Y.prototype.styleElement=Y.prototype.styleElement;Y.prototype.styleDocument=Y.prototype.styleDocument;Y.prototype.styleSubtree=Y.prototype.styleSubtree;Y.prototype.getComputedStyleValue=Y.prototype.getComputedStyleValue;Y.prototype.setElementClass=Y.prototype.Ya;Y.prototype._styleInfoForNode=Y.prototype.Ia;Y.prototype.transformCustomStyleForDocument=Y.prototype.va;Y.prototype.getStyleAst=Y.prototype.La;Y.prototype.styleAstToString=Y.prototype.Za;
Y.prototype.flushCustomStyles=Y.prototype.F;Object.defineProperties(Y.prototype,{nativeShadow:{get:function(){return Q}},nativeCss:{get:function(){return R}}});var Z=new Y,Dg,Eg;window.ShadyCSS&&(Dg=window.ShadyCSS.ApplyShim,Eg=window.ShadyCSS.CustomStyleInterface);window.ShadyCSS={ScopingShim:Z,prepareTemplate:function(a,b,c){Z.F();Z.prepareTemplate(a,b,c)},styleSubtree:function(a,b){Z.F();Z.styleSubtree(a,b)},styleElement:function(a){Z.F();Z.styleElement(a)},styleDocument:function(a){Z.F();Z.styleDocument(a)},getComputedStyleValue:function(a,b){return Z.getComputedStyleValue(a,b)},nativeCss:R,nativeShadow:Q};Dg&&(window.ShadyCSS.ApplyShim=Dg);
Eg&&(window.ShadyCSS.CustomStyleInterface=Eg);var Fg=window.customElements,Gg=window.HTMLImports,Hg=window.HTMLTemplateElement;window.WebComponents=window.WebComponents||{};if(Fg&&Fg.polyfillWrapFlushCallback){var Ig,Jg=function(){if(Ig){Hg.J&&Hg.J(window.document);var a=Ig;Ig=null;a();return!0}},Kg=Gg.whenReady;Fg.polyfillWrapFlushCallback(function(a){Ig=a;Kg(Jg)});Gg.whenReady=function(a){Kg(function(){Jg()?Gg.whenReady(a):a()})}}
Gg.whenReady(function(){requestAnimationFrame(function(){window.WebComponents.ready=!0;document.dispatchEvent(new CustomEvent("WebComponentsReady",{bubbles:!0}))})});var Lg=document.createElement("style");Lg.textContent="body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";var Mg=document.querySelector("head");Mg.insertBefore(Lg,Mg.firstChild);}).call(this);

//# sourceMappingURL=webcomponents-lite.js.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(99), __webpack_require__(100)))

/***/ }),
/* 99 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 100 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMWQyNmE1ZTA2OGE3ZDI1NGQyZGIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2dlc3R1cmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL211dGFibGUtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL3R5cG9ncmFwaHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3N0eWxlLXNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY3NzLXBhcnNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXJlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLW1vZHVsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsdXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy90ZW1wbGF0aXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi90YWN0aWxlL2NsaWVudC9hamF4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvbGVnYWN5LWVsZW1lbnQtbWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS11dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvdGVtcGxhdGUtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvZG9jdW1lbnQtd2FpdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3N0eWxlLWdhdGhlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuanMiLCJ3ZWJwYWNrOi8vLy4vdGFjdGlsZS9jbGllbnQvdGFjdGlsZS1lZGl0YWJsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbGl0LWh0bWwvbGl0LWh0bWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9jb2xvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL3NoYWRvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtYWRkb24tYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL3RhY3RpbGUvY2xpZW50L3RhY3RpbGUtbW9kZS5qcyIsIndlYnBhY2s6Ly8vLi90YWN0aWxlL2NsaWVudC9hdXRob3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2FwcGx5LXNoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvdW5zY29wZWQtc3R5bGUtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2FwcGx5LXNoaW0tdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1hY2Nlc3NvcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy90ZW1wbGF0ZS1zdGFtcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWRpYWxvZy9wYXBlci1kaWFsb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL25lb24tYW5pbWF0aW9uL25lb24tYW5pbWF0aW9uLXJ1bm5lci1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvbmVvbi1hbmltYXRpb24vbmVvbi1hbmltYXRhYmxlLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1kaWFsb2ctYmVoYXZpb3IvcGFwZXItZGlhbG9nLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW92ZXJsYXktYmVoYXZpb3IvaXJvbi1vdmVybGF5LWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZpdC1iZWhhdmlvci9pcm9uLWZpdC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tb3ZlcmxheS1iZWhhdmlvci9pcm9uLW92ZXJsYXktbWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lyb24tb3ZlcmxheS1iYWNrZHJvcC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lyb24tZm9jdXNhYmxlcy1oZWxwZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWRpYWxvZy1iZWhhdmlvci9wYXBlci1kaWFsb2ctc2hhcmVkLXN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvZm9udC1yb2JvdG8vcm9ib3RvLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1idXR0b24vcGFwZXItYnV0dG9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItYnV0dG9uLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvZWxlbWVudC1zdHlsZXMvcGFwZXItbWF0ZXJpYWwtc3R5bGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1pbnB1dC9pcm9uLWlucHV0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWExMXktYW5ub3VuY2VyL2lyb24tYTExeS1hbm5vdW5jZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tbWV0YS9pcm9uLW1ldGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWlucHV0L3BhcGVyLWlucHV0LWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC1jaGFyLWNvdW50ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWlucHV0L3BhcGVyLWlucHV0LWNvbnRhaW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtZXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWNoZWNrYm94L3BhcGVyLWNoZWNrYm94LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItdG9nZ2xlLWJ1dHRvbi9wYXBlci10b2dnbGUtYnV0dG9uLmpzIiwid2VicGFjazovLy8uL2dsb2JhbC9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy93ZWJjb21wb25lbnRzLWxpdGUuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIl0sIm5hbWVzIjpbImFqYXgiLCJ1cmwiLCJkYXRhIiwibWV0aG9kIiwiaGVhZGVycyIsInN1Y2Nlc3NDYWxsYmFjayIsImVycm9yQ2FsbGJhY2siLCJjb25maWciLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsImZldGNoIiwidGhlbiIsInJlc3BvbnNlIiwib2siLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIkVycm9yIiwianNvbiIsImNhdGNoIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwibWVzc2FnZSIsImFqYXhHZXQiLCJIZWFkZXJzIiwidW5kZWZpbmVkIiwiYWpheFBvc3QiLCJhcHBlbmQiLCJhamF4UHV0IiwiYWpheERlbGV0ZSIsIlRhY3RpbGVFZGl0YWJsZSIsImlzIiwicHJvcGVydGllcyIsInBhdGgiLCJ0eXBlIiwiU3RyaW5nIiwiY29tcFR5cGUiLCJpbmxpbmUiLCJCb29sZWFuIiwiZGVmYXVsdCIsImNvbnN0cnVjdG9yIiwiYXR0YWNoU2hhZG93IiwibW9kZSIsImNvbm5lY3RlZENhbGxiYWNrIiwicmVuZGVyIiwiaW5wdXRzIiwiYnV0dG9ucyIsImNvbnRlbnQiLCJjb21wb25lbnQiLCJfY3JlYXRlSW5wdXRzIiwiX2NyZWF0ZU1lc3NhZ2UiLCJfY3JlYXRlQnV0dG9ucyIsInNoYWRvd1Jvb3QiLCJvcGVuRGlhbG9nIiwiY2FsbGJhY2siLCJwYXBlckRpYWxvZyIsInF1ZXJ5U2VsZWN0b3IiLCJvcGVuIiwiX2F0dGFjaEJ1dHRvbkhhbmRsZXJzIiwiX2F0dGFjaENsb3NlZEhhbmRsZXJzIiwiZm9ybVZhbHVlcyIsInZhbHVlcyIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JFYWNoIiwiaW5wdXQiLCJ2YWx1ZSIsIm5hbWUiLCJhY3RpdmUiLCJkaWFsb2dDbG9zZWQiLCJldmVudCIsImRldGFpbCIsImNvbmZpcm1lZCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwiQXJyYXkiLCJmcm9tIiwiYnV0dG9uIiwiZSIsInRhcmdldCIsImRhdGFzZXQiLCJ0ZW1wbGF0ZSIsInBhcnNlIiwiYXV0aG9yIiwiYXR0cnMiLCJwdXNoIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImV4dHJhQnV0dG9ucyIsInByZXZlbnREZWxldGUiLCJkZWxldGVCdXR0b24iLCJjdXN0b21FbGVtZW50cyIsImRlZmluZSIsIlRhY3RpbGVNb2RlIiwidG9nZ2xlIiwic2V0VG9FZGl0IiwiY2hlY2tlZCIsInNldFRvUHVibGlzaCIsInN3aXRjaGVkVG9FZGl0Iiwic3dpdGNoZWRUb1B1Ymxpc2giLCJ3YXRjaEZvckNvbXBvbmVudENsaWNrcyIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiY2xvc2VzdCIsImRvY3VtZW50IiwidGFjdGlsZUVkaXRhYmxlIiwicmVxdWlyZXNSZWZyZXNoIiwid2luZG93IiwibG9jYXRpb24iLCJyZWxvYWQiLCJzZXR1cEVkaXRNb2RlIiwiY2xhc3NMaXN0IiwiYWRkIiwic2Vzc2lvblN0b3JhZ2UiLCJzZXRJdGVtIiwic2V0dXBQdWJsaXNoTW9kZSIsInJlbW92ZSIsImNvbnRhaW5zIiwidGFjdGlsZU1vZGVUb2dnbGUiLCJnZXRJdGVtIiwiZ2V0QnJlYWtwb2ludCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicmVwbGFjZSIsImJyZWFrcG9pbnQiLCIkIiwicmVzaXplIiwiZGVza3RvcCIsInRhYmxldCIsInBob25lIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEy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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQ0FBbUMsd0JBQXdCO0FBQzNELFlBQVk7QUFDWjtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7OztBQzliQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7OztBQzlWQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUNuS0E7QUFDa0I7QUFDSjs7QUFFZDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCw4QkFBOEIsS0FBSztBQUNuQztBQUNBLCtCQUErQixtQkFBbUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7O0FDeEdBO0FBQ0E7QUFDOEI7QUFDaEI7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsS0FBSztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYyxvQkFBb0I7QUFDbEM7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7OztBQzFHQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyx1Q0FBdUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDOzs7Ozs7Ozs7O0FDekNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFUTs7QUFFUjtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsT0FBTztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0EsZ0NBQWdDLElBQUk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUEscUJBQXFCO0FBQ3JCLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLEdBQUc7QUFDdEIsc0JBQXNCLEtBQUssV0FBVyxTQUFTLFFBQVE7QUFDdkQscUJBQXFCLEtBQUssV0FBVyxTQUFTLElBQUksR0FBRyxJQUFJLEtBQUs7QUFDOUQsK0JBQStCLGFBQWE7QUFDNUMsZ0JBQWdCLFFBQVEsV0FBVyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FDdlFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBa0MsR0FBRywwRUFBMEUsT0FBTyxJQUFJLEtBQUssUUFBUSxHQUFHO0FBQUE7QUFBQTtBQUMxSSwrQ0FBc0Q7QUFBQTtBQUFBO0FBQ3RELHdDQUErQztBQUFBO0FBQUE7QUFDL0M7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBO0FBQ0EscUJBQTRCLEdBQUcsSUFBSTtBQUFBO0FBQUE7QUFDbkM7QUFBQTtBQUFBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7OztBQ2xCQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFa0M7O0FBRWxDO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMURBO0FBQ2lDO0FBQ1Q7QUFDeEI7QUFDMEI7QUFDc0I7QUFDWDtBQUNqQjtBQUNNOztBQUUxQjs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QyxjQUFjLHlCQUF5QjtBQUN2QyxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwQkFBMEI7QUFDdkMsY0FBYyx5QkFBeUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QyxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBCQUEwQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLE9BQU87QUFDcEI7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDJCQUEyQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixvQkFBb0I7QUFDckM7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxpQkFBaUIsMkNBQTJDO0FBQzVEO0FBQ0EsaUJBQWlCLHVCQUF1QjtBQUN4QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGdCQUFnQjtBQUNwRCxvQkFBb0IsYUFBYTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixrQkFBa0I7QUFDbEIsZUFBZSxnQkFBZ0I7QUFDL0IsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msa0JBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsYUFBYTtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLENBQUM7QUFBQTtBQUFBOztBQUVEO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7OztBQ250QkE7QUFDa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLGVBQWU7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRVE7Ozs7Ozs7Ozs7Ozs7Ozs7QUN2SFI7QUFDd0I7QUFDaUc7QUFDekg7QUFDZ0U7QUFDcEM7QUFDSjtBQUNHOztBQUUzQixZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZix3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQixXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFdBQVcsU0FBUztBQUNwQixXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsc0JBQXNCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsWUFBWTtBQUN2QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPLDRDQUE0QyxTQUFTO0FBQ3ZFLFdBQVcsRUFBRTtBQUNiLFdBQVcsMEJBQTBCO0FBQ3JDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhLG9EQUFvRCxTQUFTO0FBQ3ZGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcscUJBQXFCO0FBQ2hDLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsRUFBRTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSUFBMkUsS0FBSztBQUNoRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLGlDQUFpQztBQUM1QyxXQUFXLEVBQUU7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLFNBQVM7QUFDcEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsU0FBUyxjQUFjO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxhQUFhO0FBQ3hCLFdBQVcsU0FBUztBQUNwQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGtCQUFrQjtBQUNsQixtQkFBbUIsdUJBQXVCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxQkFBcUI7QUFDaEMsV0FBVyxLQUFLO0FBQ2hCLFdBQVcsU0FBUztBQUNwQixXQUFXLGFBQWE7QUFDeEIsV0FBVyxFQUFFO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxFQUFFO0FBQ2IsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsYUFBYTtBQUN4QixZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLGFBQWE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLHVCQUF1QjtBQUM5QjtBQUNBLGlCQUFpQix5QkFBeUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEtBQUs7QUFDaEIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsU0FBUztBQUNwQixXQUFXLEdBQUc7QUFDZDtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBDQUEwQztBQUM5RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLEVBQUU7QUFDYixZQUFZLEVBQUU7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxnQ0FBZ0M7QUFDaEMsK0JBQStCO0FBQy9CLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGlCQUFpQjtBQUM1QixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxXQUFXO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxtQkFBbUI7QUFDOUIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyx3QkFBd0I7QUFDeEQ7QUFDQTtBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFCQUFxQjtBQUNoQyxXQUFXLE1BQU07QUFDakIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsV0FBVyxNQUFNO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZixrQkFBa0I7QUFDbEIsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDLGVBQWUsRUFBRTtBQUNqQixlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLE9BQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsbURBQW1ELE9BQU87QUFDMUQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsT0FBTztBQUN0QixlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLElBQUk7QUFDM0U7QUFDQSx1REFBdUQsSUFBSTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQixlQUFlLFNBQVM7QUFDeEI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvQkFBb0I7QUFDekM7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsWUFBWSxJQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QyxlQUFlLCtCQUErQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixZQUFZLEdBQUcsYUFBYSxHQUFHLGFBQWE7QUFDdkU7QUFDQSxvQ0FBb0MsWUFBWTtBQUNoRCw0QkFBNEIsWUFBWTtBQUN4QztBQUNBLGNBQWMsc0JBQXNCLGFBQWEscURBQXFEO0FBQ3RHLGNBQWM7QUFDZDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlDQUFpQztBQUNoRDtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUNBQWlDO0FBQ2hEO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1Asd0VBQXdFLE9BQU87QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDLGVBQWUsS0FBSztBQUNwQixnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEIsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0JBQStCO0FBQzlDLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiw2QkFBNkIsTUFBTTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QyxlQUFlLEtBQUs7QUFDcEIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdCQUFnQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwrQ0FBK0M7QUFDL0MsT0FBTztBQUNQO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQix1QkFBdUIsMENBQTBDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWMsMEJBQTBCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGNBQWM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsR0FBRztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsYUFBYTtBQUM1QixlQUFlLFNBQVM7QUFDeEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQixlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxzQkFBc0IsdUNBQXVDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksTUFBTSxNQUFNLGFBQWEsTUFBTSxPQUFPLFFBQVEsY0FBYztBQUN4RTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU07QUFDbkM7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHdDQUF3QztBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDLHVCQUF1QixlQUFlO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsS0FBSztBQUNwQjtBQUNBLGVBQWUsWUFBWTtBQUMzQixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLEVBQUU7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQztBQUFBO0FBQUE7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsYUFBYSxFQUFFO0FBQ2YsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxhQUFhLEVBQUU7QUFDZixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGFBQWEsRUFBRTtBQUNmLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7OztBQzVrRkE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixPQUFPO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVE7Ozs7Ozs7Ozs7QUNsRVI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7O0FDL0JBO0FBQzBCO0FBQ0o7O0FBRXRCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLGtIQUFxQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLEVBQUU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsV0FBVyxtQkFBbUI7QUFDOUI7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQztBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFdBQVcsUUFBUTtBQUNuQjs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsa0JBQWtCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBMkQ7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsa0VBQWtFO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUNBQWlDO0FBQzFDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGtCQUFrQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJO0FBQzdCLDJDQUEyQyxJQUFJO0FBQy9DLHdEQUF3RCxJQUFJO0FBQzVELFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLHlCQUF5QjtBQUN0QztBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLG1DQUFtQztBQUNqRDtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EseUJBQXlCLG1CQUFtQixpQkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtQ0FBbUM7QUFDekQsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQztBQUNBLGFBQWEsS0FBSztBQUNsQixjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVRO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3ZmUjtBQUMrQjtBQUMvQjtBQUNjOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxLQUFLO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxLQUFLO0FBQy9DOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7OztBQ3pOTyxTQUFTQSxJQUFULENBQWNDLEdBQWQsRUFBbUJDLElBQW5CLEVBQXlCQyxNQUF6QixFQUFpQ0MsT0FBakMsRUFBMENDLGVBQTFDLEVBQTJEQyxhQUEzRCxFQUEwRTtBQUMvRSxNQUFJQyxTQUFTO0FBQUNKLFlBQVFBLE1BQVQ7QUFBaUJDLGFBQVNBO0FBQTFCLEdBQWI7O0FBQ0EsTUFBSSxPQUFPRixJQUFQLElBQWUsV0FBbkIsRUFBZ0M7QUFDOUJLLFdBQU9DLElBQVAsR0FBY0MsS0FBS0MsU0FBTCxDQUFlUixJQUFmLENBQWQ7QUFDRDs7QUFDRFMsUUFBTVYsR0FBTixFQUFXTSxNQUFYLEVBQ0NLLElBREQsQ0FDTUMsWUFBWTtBQUNoQixRQUFJQSxTQUFTQyxFQUFiLEVBQWlCO0FBQ2YsYUFBT0MsUUFBUUMsT0FBUixDQUFnQkgsUUFBaEIsQ0FBUDtBQUNELEtBRkQsTUFHSztBQUNILGFBQU9FLFFBQVFFLE1BQVIsQ0FBZSxJQUFJQyxLQUFKLENBQVUscUJBQVYsQ0FBZixDQUFQO0FBQ0Q7QUFDRixHQVJELEVBU0NOLElBVEQsQ0FTTUMsWUFBWUEsU0FBU00sSUFBVCxFQVRsQixFQVNtQztBQVRuQyxHQVVDUCxJQVZELENBVU1WLFFBQVE7QUFDWixRQUFJLE9BQU9HLGVBQVAsS0FBMkIsVUFBL0IsRUFBMkM7QUFDekNBLHNCQUFnQkgsSUFBaEI7QUFDRDtBQUNGLEdBZEQsRUFlQ2tCLEtBZkQsQ0FlTyxVQUFTQyxLQUFULEVBQWdCO0FBQ3JCQyxZQUFRQyxHQUFSLENBQWEsVUFBU0YsTUFBTUcsT0FBUSxFQUFwQzs7QUFDQSxRQUFJLE9BQU9sQixhQUFQLEtBQXlCLFVBQTdCLEVBQXlDO0FBQ3ZDQSxvQkFBY2UsS0FBZDtBQUNEO0FBQ0YsR0FwQkQ7QUFxQkQ7QUFFTSxTQUFTSSxPQUFULENBQWlCeEIsR0FBakIsRUFBc0JJLGVBQXRCLEVBQXVDQyxhQUF2QyxFQUFzRDtBQUMzRCxNQUFJRixVQUFVLElBQUlzQixPQUFKLEVBQWQ7QUFDQTFCLE9BQUtDLEdBQUwsRUFBVTBCLFNBQVYsRUFBcUIsS0FBckIsRUFBNEJ2QixPQUE1QixFQUFxQ0MsZUFBckMsRUFBc0RDLGFBQXREO0FBQ0Q7QUFFTSxTQUFTc0IsUUFBVCxDQUFrQjNCLEdBQWxCLEVBQXVCQyxJQUF2QixFQUE2QkcsZUFBN0IsRUFBOENDLGFBQTlDLEVBQTZEO0FBQ2xFLE1BQUlGLFVBQVUsSUFBSXNCLE9BQUosRUFBZDtBQUNBdEIsVUFBUXlCLE1BQVIsQ0FBZSxjQUFmLEVBQStCLGtCQUEvQjtBQUNBN0IsT0FBS0MsR0FBTCxFQUFVQyxJQUFWLEVBQWdCLE1BQWhCLEVBQXdCRSxPQUF4QixFQUFpQ0MsZUFBakMsRUFBa0RDLGFBQWxEO0FBQ0Q7QUFFTSxTQUFTd0IsT0FBVCxDQUFpQjdCLEdBQWpCLEVBQXNCQyxJQUF0QixFQUE0QkcsZUFBNUIsRUFBNkNDLGFBQTdDLEVBQTREO0FBQ2pFLE1BQUlGLFVBQVUsSUFBSXNCLE9BQUosRUFBZDtBQUNBdEIsVUFBUXlCLE1BQVIsQ0FBZSxjQUFmLEVBQStCLGtCQUEvQjtBQUNBN0IsT0FBS0MsR0FBTCxFQUFVQyxJQUFWLEVBQWdCLEtBQWhCLEVBQXVCRSxPQUF2QixFQUFnQ0MsZUFBaEMsRUFBaURDLGFBQWpEO0FBQ0Q7QUFFTSxTQUFTeUIsVUFBVCxDQUFvQjlCLEdBQXBCLEVBQXlCSSxlQUF6QixFQUEwQ0MsYUFBMUMsRUFBeUQ7QUFDOUQsTUFBSUYsVUFBVSxJQUFJc0IsT0FBSixFQUFkO0FBQ0ExQixPQUFLQyxHQUFMLEVBQVUwQixTQUFWLEVBQXFCLFFBQXJCLEVBQStCdkIsT0FBL0IsRUFBd0NDLGVBQXhDLEVBQXlEQyxhQUF6RDtBQUNELEM7Ozs7Ozs7Ozs7O0FDaEREO0FBQytCO0FBQ2pCO0FBQ0k7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsWUFBWTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsTUFBTSxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDLHNDQUFzQyxnQkFBZ0IsR0FBRyxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsa0JBQWtCO0FBQzNEO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0JBQWtCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQSxvQzs7Ozs7Ozs7QUN2ZkE7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOzs7Ozs7Ozs7QUN2VUE7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7O0FDckVBO0FBQ2tCOztBQUVsQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxL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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRVE7Ozs7Ozs7Ozs7QUNsUTZEOztBQUVyRSw4R0FBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtCQUFrQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFUTs7Ozs7Ozs7Ozs7Ozs7QUN2SVI7QUFDMEI7QUFDSTtBQUNFOztBQUVoQztBQUNBO0FBQ0EsYUFBYTtBQUNiLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DLHlCQUF5Qjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9CQUFvQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxHQUFHO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7O0FBRVE7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsSFU7QUFDbUQ7QUFDakQ7QUFDYztBQUNKO0FBQ0Q7QUFDQTs7QUFFN0IsOEdBQWtEOztBQUVsRDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQsb0NBQW9DLFlBQVk7QUFDaEQsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDRCQUE0QjtBQUM1QyxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsV0FBVztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQSxtQkFBbUIscUJBQXFCOztBQUV4Qyx5QkFBeUIsYUFBYTs7QUFFdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMkJBQTJCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsU0FBUztBQUNULGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQixPQUFPO0FBQzFCLG1CQUFtQixFQUFFO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QiwrQkFBK0I7QUFDNUQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQjtBQUNsQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBc0QsRUFBRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0RBQXdELEVBQUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEseUJBQXlCO0FBQ3RDLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLGVBQWU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFlBQVk7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwyQkFBMkI7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixjQUFjLEVBQUU7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRVE7Ozs7Ozs7Ozs7Ozs7OztBQzVxQlU7QUFDRztBQUNEO0FBQ2M7QUFDZDtBQUNLOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBLG1CQUFtQixpQkFBaUI7O0FBRXBDLHlCQUF5QixhQUFhOztBQUV0Qzs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsa0NBQWtDLGdCQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixPQUFPO0FBQzVCLHFCQUFxQixFQUFFO0FBQ3ZCLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsNEJBQTRCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRVE7Ozs7Ozs7Ozs7Ozs7O0FDaFFVO0FBQ007QUFDRztBQUNKOztBQUV2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QscUJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLENBQUM7O0FBRU87O0FBRVI7QUFDQTtBQUNBLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsb0NBQW9DLFlBQVk7QUFDaEQsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVcsY0FBYyxVQUFVO0FBQ2pGO0FBQ0E7QUFDQSwwQ0FBMEMsVUFBVTtBQUNwRCxvQ0FBb0MsWUFBWTtBQUNoRCxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDRCQUE0QjtBQUN4QyxZQUFZLGdDQUFnQztBQUM1QztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBLG1CQUFtQix5QkFBeUI7QUFDNUM7QUFDQTtBQUNROzs7Ozs7Ozs7OztBQ3ZaUjtBQUN5Qjs7QUFFekI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGlCQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDUTs7Ozs7Ozs7OztBQ3RGUjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNzRDtBQUNiOztBQUV6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQyxlQUFlLE9BQU87QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsNkRBQTZEOztBQUU3RDtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEQ7Ozs7Ozs7O0FDaEVzQjs7QUFFdEI7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLEVBQUU7QUFDZixhQUFhLEVBQUU7QUFDZixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLEVBQUU7QUFDZixhQUFhLEVBQUU7QUFDZixjQUFjLFFBQVE7QUFDdEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7QUNqRUE7QUFDc0M7QUFDUjtBQUM5QjtBQUNrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7QUN4Q0Q7QUFDaUM7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBOztBQUVBOztBQUVBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsZUFBZTtBQUNyRTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7O0FDN0dBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsNEJBQTRCO0FBQzdEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7O0FDbElBO0FBQzhCO0FBQ2hCOztBQUVkOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7Ozs7QUMvRkE7QUFDMEI7QUFDTTtBQUNIO0FBQ0U7QUFDakI7O0FBRWQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0Y7QUFDbEYsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxpRUFBaUUsaUJBQWlCO0FBQ2xGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFBQTtBQUFBOztBQUVBO0FBQUE7QUFBQTs7Ozs7Ozs7OztBQzdpQkE7QUFDYzs7QUFFZDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTCxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOzs7Ozs7Ozs7OztBQ3BqQkE7QUFDbUI7QUFDTDs7QUFFZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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ekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixjQUFjO0FBQy9CO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7O0FDcElEO0FBQytDO0FBQ2pCO0FBQ0g7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDdEpEO0FBQytCO0FBQ0o7QUFDVDtBQUNKO0FBQ2Q7QUFBQTtBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7OztBQzFoQkE7QUFDQTtBQUNrQztBQUNoQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQ2xFRDtBQUNBO0FBQ0E7QUFDQTtBQUNrQjtBQUNRO0FBQ1o7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhGQUE4Rjs7QUFFOUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3hqQkQ7QUFDQTtBQUNBO0FBQ2tDO0FBQ2hCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7OztBQzVERDtBQUNBO0FBQ3NDO0FBQ3BCO0FBQ1E7QUFDVztBQUNyQztBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7QUNsUkQ7QUFDa0M7QUFDQTs7QUFFbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7Ozs7Ozs7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNzQztBQUNwQjtBQUNRO0FBQ0Q7QUFDSztBQUM5QjtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7Ozs7Ozs7Ozs7O0FDaFBEOztBQUVBLElBQUlLLGdCQUFnQixZQUFZO0FBQzlCLFNBQU9iLE9BQU9jLGdCQUFQLENBQXdCZCxPQUFPSCxRQUFQLENBQWdCL0MsYUFBaEIsQ0FBOEIsTUFBOUIsQ0FBeEIsRUFBK0QsU0FBL0QsRUFBMEVpRSxnQkFBMUUsQ0FBMkYsU0FBM0YsRUFBc0dDLE9BQXRHLENBQThHLElBQTlHLEVBQW9ILEVBQXBILENBQVA7QUFDRCxDQUZEOztBQUlBLFNBQVNDLFVBQVQsQ0FBb0JBLFVBQXBCLEVBQWdDckUsUUFBaEMsRUFBMEM7QUFDeEMsTUFBSSxPQUFPQSxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ2xDLFFBQUlpRSxvQkFBb0JJLFVBQXhCLEVBQW9DO0FBQ2xDckU7QUFDRDs7QUFDRHNFLE1BQUVsQixNQUFGLEVBQVVtQixNQUFWLENBQWlCLFlBQVk7QUFDM0IsVUFBSU4sb0JBQW9CSSxVQUF4QixFQUFvQztBQUNsQ3JFO0FBQ0Q7QUFDRixLQUpEO0FBS0QsR0FURCxNQVNPO0FBQ0wsV0FBT2lFLG9CQUFvQkksVUFBM0I7QUFDRDtBQUNGOztBQUVELFNBQVNHLE9BQVQsQ0FBaUJ4RSxRQUFqQixFQUEyQjtBQUN6QixTQUFPcUUsV0FBVyxTQUFYLEVBQXNCckUsUUFBdEIsQ0FBUDtBQUNEOztBQUVELFNBQVN5RSxNQUFULENBQWdCekUsUUFBaEIsRUFBMEI7QUFDeEIsU0FBT3FFLFdBQVcsUUFBWCxFQUFxQnJFLFFBQXJCLENBQVA7QUFDRDs7QUFFRCxTQUFTMEUsS0FBVCxDQUFlMUUsUUFBZixFQUF5QjtBQUN2QixTQUFPcUUsV0FBVyxPQUFYLEVBQW9CckUsUUFBcEIsQ0FBUDtBQUNELEM7Ozs7OztBQy9CRCxtRUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ01BQWdNLHlEQUF5RCxjQUFjLGdCQUFnQix3QkFBd0Isa0JBQWtCLFFBQVEsbUJBQW1CLG9DQUFvQztBQUM3WSxjQUFjLEtBQUssd0JBQXdCLDhDQUE4Qyw2REFBNkQsNkNBQTZDLGlCQUFpQixFQUFFLGdCQUFnQixlQUFlLFFBQVEscUJBQXFCLG1CQUFtQixxQkFBcUIsRUFBRSxTQUFTLEVBQUUsZUFBZSxLQUFLLEdBQUcsUUFBUSxnQ0FBZ0MsYUFBYSxTQUFTLGVBQWUsS0FBSyx5QkFBeUI7QUFDemMsZUFBZSxlQUFlLG1CQUFtQixpQkFBaUI7QUFDbEUsWUFBWSxlQUFlLG9DQUFvQyx5QkFBeUIsbUJBQW1CLDBCQUEwQixJQUFJLHFDQUFxQywwQ0FBMEMsOEVBQThFLGVBQWUsU0FBUyxpQkFBaUIsSUFBSSwwQ0FBMEMsbUdBQW1HLFFBQVE7QUFDeGUseURBQXlELFNBQVMscURBQXFELHVEQUF1RCxtQkFBbUIsMkJBQTJCLFFBQVEsb0NBQW9DLDBDQUEwQyxVQUFVLHlDQUF5QyxtQ0FBbUMsaUVBQWlFLG9CQUFvQjtBQUM3ZCxHQUFHLFFBQVEseUNBQXlDLGdMQUFnTCxVQUFVLDBDQUEwQyx3Q0FBd0Msb0NBQW9DLHVCQUF1QixFQUFFLDRDQUE0QywyQ0FBMkMsV0FBVztBQUMvZCwwQ0FBMEMsV0FBVyxxQkFBcUIsU0FBUyxFQUFFLHdCQUF3QixZQUFZLGNBQWMsZ0JBQWdCLG1CQUFtQiwyQ0FBMkMsb0RBQW9ELDRCQUE0QixrSUFBa0ksZ0RBQWdELGdCQUFnQiwyQ0FBMkMsZUFBZSxrQkFBa0Isc0JBQXNCLFNBQVMsS0FBSztBQUN2bEIscUNBQXFDLGlCQUFpQiwyRUFBMkUsVUFBVSxtRkFBbUYsNkVBQTZFLG9EQUFvRCxVQUFVLGVBQWUsbUNBQW1DLGlCQUFpQixZQUFZLGdCQUFnQixpQkFBaUIsV0FBVyxlQUFlLDJCQUEyQjtBQUM5Z0IsaUJBQWlCLEVBQUUsa0NBQWtDLDhCQUE4QixpQ0FBaUMsdUNBQXVDLGlFQUFpRSxVQUFVLCtEQUErRCwwQ0FBMEMsaUZBQWlGLFVBQVUscURBQXFEO0FBQy9kLHVDQUF1QyxVQUFVLG9DQUFvQyw0Q0FBNEMsdUJBQXVCLHdFQUF3RSxVQUFVLEdBQUc7QUFDN08sY0FBYyxPQUFPLDhFQUE4RSxxREFBcUQseUJBQXlCLGtCQUFrQiwrRkFBK0YsR0FBRyxNQUFNLHNHQUFzRyx5QkFBeUIsY0FBYyxFQUFFLG9CQUFvQjtBQUM5YyxpREFBaUQsaUVBQWlFLGdCQUFnQixlQUFlLHFDQUFxQyxVQUFVLGVBQWUscUJBQXFCLDZCQUE2QixnQ0FBZ0MsbUJBQW1CLFFBQVEsWUFBWSxVQUFVLE1BQU0saUJBQWlCLG1CQUFtQixxQ0FBcUMsZUFBZSx1Q0FBdUMsRUFBRTtBQUN6ZCxzQkFBc0IsU0FBUyxpQkFBaUIsbUJBQW1CLFdBQVcsd0JBQXdCLDhDQUE4QyxLQUFLLGtCQUFrQix3Q0FBd0MsaUJBQWlCLEVBQUUsZ0JBQWdCLHFDQUFxQyxlQUFlLGdEQUFnRCxpQkFBaUIsb0JBQW9CLG1CQUFtQixrREFBa0Qsa0JBQWtCLDZCQUE2QjtBQUNuZixRQUFRLDJHQUEyRyxpQkFBaUIsR0FBRyxnQkFBZ0IsZ0JBQWdCLGdCQUFnQixrQkFBa0IseUJBQXlCLGNBQWMsWUFBWSx3REFBd0QsY0FBYyxFQUFFLDRDQUE0Qyw4QkFBOEIsaUNBQWlDLFVBQVUscUNBQXFDLFVBQVUscUJBQXFCO0FBQzdmLG9CQUFvQixFQUFFLG9CQUFvQixFQUFFLDJCQUEyQixJQUFJLFVBQVUsa0JBQWtCLG1CQUFtQixrQkFBa0Isb0VBQW9FLFVBQVUscUJBQXFCLHlEQUF5RCxrQkFBa0IsMkJBQTJCLElBQUksdUVBQXVFLHlDQUF5QztBQUN6YyxvQ0FBb0Msd0RBQXdELG1HQUFtRyxjQUFjLFNBQVMsZ0RBQWdELFFBQVEsNENBQTRDLHVCQUF1QixXQUFXLFVBQVUsa0NBQWtDLElBQUksT0FBTyw4Q0FBOEMsNERBQTRELFVBQVUsa0VBQWtFLHNLQUFzSyxjQUFjLHlDQUF5QyxPQUFPLE1BQU0sY0FBYyxtREFBbUQsYUFBYSxpQkFBaUIsRUFBRSxrQkFBa0I7QUFDdDZCLGNBQWMseUJBQXlCLHFCQUFxQixrQkFBa0IsK0JBQStCLGNBQWMsaUJBQWlCLGtCQUFrQixnQkFBZ0Isa0JBQWtCLGNBQWMsWUFBWSxLQUFLLG9EQUFvRCxLQUFLO0FBQ3hSLG1GQUFtRixzQ0FBc0MsdUJBQXVCLEtBQUssT0FBTyxjQUFjLEtBQUssT0FBTyxjQUFjLEtBQUssT0FBTyw0Q0FBZ0QsOEpBQXdCLGdCQUFnQixRQUFRLFNBQVMsUUFBUSxhQUFhLE1BQU0sTUFBTSxNQUFNLE1BQU0saUJBQWlCLFNBQVMsV0FBVyxNQUFNLGNBQWMsaUJBQWlCLHNDQUFzQyxzQkFBc0IsVUFBVSxNQUFNLHFCQUFxQixjQUFjLHFCQUFxQixFQUFFLGlCQUFpQixVQUFVLGVBQWUseURBQXlELG1CQUFtQixRQUFRLFVBQVUsZ0RBQWdELGVBQWUsY0FBYyxlQUFlLElBQUksY0FBYyxTQUFTLHNCQUFzQixxQkFBcUIsSUFBSSxjQUFjLFNBQVMsVUFBVSxtQkFBbUIsZUFBZSw4QkFBOEIsK0JBQStCLGFBQWEsaUJBQWlCLEVBQUUscUJBQXFCLElBQUksaUJBQWlCLDBEQUEwRCxlQUFlLGFBQWEsY0FBYztBQUNscEMsbUJBQW1CLHdLQUF3SyxpQkFBaUIsd0VBQXdFLEtBQUssZUFBZSw2REFBNkQsZUFBZSxnQkFBZ0IsTUFBTSxnQkFBZ0I7QUFDMVosZ0JBQWdCLHFDQUFxQyxxQkFBcUIscUJBQXFCLFVBQVUsT0FBTyxTQUFTLFNBQVMscUJBQXFCLGVBQWUsZ0JBQWdCLGlCQUFpQixzQkFBc0IsV0FBVyx3Q0FBd0MsY0FBYyxjQUFjLGdCQUFnQjtBQUM1VCxxQkFBcUIsNEJBQTRCLE1BQU0sSUFBSSxXQUFXLFNBQVMsZ0JBQWdCLFdBQVcsU0FBUyxjQUFjLGFBQWEsY0FBYyxVQUFVLDJFQUEyRSxRQUFRLGNBQWMsaUVBQWlFLGlCQUFpQixJQUFJLGNBQWMsUUFBUSxhQUFhLE9BQU8sRUFBRSxTQUFTLFFBQVEsU0FBUyxlQUFlLFdBQVcsV0FBVyxXQUFXLFFBQVEsaUJBQWlCLFVBQVUsaUJBQWlCLHVCQUF1QixtR0FBbUcsS0FBSywyQkFBMkIsUUFBUSw0QkFBNEIsb0JBQW9CLDZCQUE2QjtBQUN0dkIsbUJBQW1CLHVCQUF1QiwySkFBMkosWUFBWSxtQkFBbUIscUJBQXFCLFVBQVUsNENBQTRDLGtCQUFrQixtQkFBbUIsd0JBQXdCLG1CQUFtQixhQUFhLG1CQUFtQixHQUFHLGVBQWUsMEJBQTBCLGVBQWUsV0FBVyxpQ0FBaUMsdUJBQXVCLElBQUksOEJBQThCLHNCQUFzQiwyREFBMkQsR0FBRyxlQUFlLG1CQUFtQixPQUFPLFVBQVUsY0FBYyxjQUFjLHFCQUFxQixVQUFVLFdBQVcsbUlBQW1JLGdDQUFnQyxvSkFBb0osYUFBYSxvQ0FBb0MsMkJBQTJCOztBQUUvb0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvSkFBb0osYUFBYSxnQkFBZ0Isc0VBQXNFLDBDQUEwQyx5REFBeUQsU0FBUyxjQUFjLDREQUE0RCxvQkFBb0IscUJBQXFCLGVBQWUsaUVBQWlFLFVBQVUsd0JBQXdCLEVBQUUsZ0JBQWdCLFNBQVMsY0FBYztBQUNqbkIsV0FBVyxrQkFBa0Isc0JBQXNCLGFBQWEsRUFBRSxNQUFNLGNBQWMsYUFBYSx5R0FBeUcsZ0RBQWdELElBQUksY0FBYyxhQUFhLG9CQUFvQixjQUFjLEVBQUUsRUFBRSxnQkFBZ0IscUJBQXFCLGtHQUFrRyxLQUFLLGtCQUFrQjtBQUMvZCxHQUFHLGNBQWMsUUFBUSw2QkFBNkIsMERBQTBELGNBQWMsOEVBQThFLGFBQWEsV0FBVyxVQUFVLFNBQVMsd0NBQXdDLGVBQWUsRUFBRSw4QkFBOEIsd0JBQXdCLEVBQUUsaUJBQWlCLGtCQUFrQiw0QkFBNEIsY0FBYyxVQUFVLGVBQWU7QUFDOWMsT0FBTyxpRkFBaUYsZUFBZSw4RkFBOEYsaUJBQWlCLEVBQUUsMERBQTBELEtBQUssNERBQTRELGlCQUFpQiw2REFBNkQsMERBQTBELDBCQUEwQjtBQUNyZix3QkFBd0IsMkJBQTJCLG9CQUFvQixxQ0FBcUMsd0JBQXdCLGdCQUFnQixxQkFBcUIsRUFBRSxpQkFBaUIsa0JBQWtCLFFBQVEsSUFBSSw4QkFBOEIsbUJBQW1CLCtCQUErQixZQUFZLGtDQUFrQyxPQUFPLGlKQUFpSjtBQUNoZixFQUFFLFlBQVkscUJBQXFCLEtBQUssOEJBQThCLDJCQUEyQixlQUFlLFdBQVcsb0JBQW9CLHVDQUF1QyxLQUFLLEtBQUsseUJBQXlCLHlCQUF5QixvQkFBb0IscURBQXFELHFGQUFxRixpQ0FBaUM7QUFDamIsU0FBUyx5Q0FBeUMsZ0ZBQWdGLDBCQUEwQixXQUFXLHlDQUF5QyxnQkFBZ0IsY0FBYyxHQUFHLDBCQUEwQixvQkFBb0IsdUJBQXVCLGdCQUFnQixzQ0FBc0MsMERBQTBELGVBQWUsU0FBUyxNQUFNLE9BQU8sT0FBTyxZQUFZLFlBQVksTUFBTSxPQUFPO0FBQ3ZmLDZCQUE2QiwrQ0FBK0Msb0NBQW9DLDREQUE0RCxHQUFHLHlDQUF5QyxjQUFjLHlCQUF5Qiw2Q0FBNkMsYUFBYSw2QkFBNkIsdUZBQXVGO0FBQzdhLFFBQVEsZ0JBQWdCLEtBQUssVUFBVSx1Q0FBdUMsMkZBQTJGLHFIQUFxSCxFQUFFLFVBQVUsMEJBQTBCLFdBQVcsWUFBWSxvQkFBb0IsdUJBQXVCLDJCQUEyQixzREFBc0Qsd0JBQXdCO0FBQy9lLG1CQUFtQixLQUFLLElBQUksRUFBRSxtQkFBbUIsS0FBSyxJQUFJLElBQUksZ0NBQWdDLFdBQVcseUNBQXlDLGdCQUFnQixrQkFBa0Isd0lBQXdJLEdBQUcsMkJBQTJCLGNBQWMsUUFBUSw4Q0FBOEMsdUNBQXVDLDJCQUEyQjtBQUNoZSxTQUFTLEVBQUUsSUFBSSwrQkFBK0IsZUFBZSxPQUFPLE9BQU8sRUFBRSxTQUFTLHdFQUF3RSxNQUFNLDJCQUEyQixxSEFBcUgsTUFBTSxzRkFBc0YsZ0JBQWdCLGVBQWUsdUNBQXVDLGFBQWEsRUFBRTtBQUNyZSxlQUFlLDBDQUEwQyxxQkFBcUIsNENBQTRDLDJDQUEyQyxXQUFXLFFBQVEsUUFBUSx1Q0FBdUMsZ0NBQWdDLDJCQUEyQixFQUFFLFVBQVUsMEJBQTBCLDJEQUEyRCxnQkFBZ0IsY0FBYyxNQUFNLDBCQUEwQjtBQUNqYyx1REFBdUQsdUNBQXVDLEtBQUssMkJBQTJCLFdBQVcsZ0JBQWdCLGtDQUFrQyx3REFBd0QsRUFBRSxHQUFHLE1BQU0sb0RBQW9ELGdCQUFnQiwyREFBMkQsRUFBRSxjQUFjLFdBQVcsdUJBQXVCLHVDQUF1QztBQUN0ZCxNQUFNLEtBQUssZ0VBQWdFLDZFQUE2RSxlQUFlLDJCQUEyQixpR0FBaUcsK0JBQStCLEVBQUUsYUFBYSxhQUFhLEVBQUUsYUFBYSxxREFBcUQsdUNBQXVDLEdBQUcsRUFBRSxjQUFjLGNBQWM7QUFDMWUsRUFBRSwyQ0FBMkMsRUFBRTs7QUFFL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVSx3RkFBd0YsY0FBYyx3REFBd0QsZUFBZSxNQUFNLDZDQUE2QyxFQUFFLHNCQUFzQixxQkFBcUIsZ0RBQWdELHVCQUF1Qix3QkFBd0IsU0FBUyx1QkFBdUIsWUFBWSxFQUFFO0FBQ2hkLDZCQUE2QixrQkFBa0Isd0NBQXdDLDJCQUEyQix3QkFBd0Isb0VBQW9FOztBQUU5TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxRUFBcUUsb0VBQW9FLG9DQUFvQyxvQkFBb0IsZUFBZSxnREFBZ0QsY0FBYyx5QkFBeUIsZUFBZSxrQkFBa0IsaUJBQWlCO0FBQ25YLGlCQUFpQixzREFBc0QscUJBQXFCLEtBQUssMkNBQTJDLGlDQUFpQyxpQkFBaUIsaUJBQWlCLG1CQUFtQix3QkFBd0IsUUFBUSxXQUFXLGVBQWUsU0FBUyxpQkFBaUIseUJBQXlCLDhDQUE4QyxpQ0FBaUMsS0FBSyxVQUFVLEtBQUssYUFBYSxTQUFTLDhCQUE4QixlQUFlLGlCQUFpQjtBQUN0Z0IsZUFBZSxXQUFXLG9CQUFvQiwyQkFBMkIsaUJBQWlCLEtBQUssRUFBRSxFQUFFLGlCQUFpQixlQUFlLFVBQVUsYUFBYSxlQUFlLG1CQUFtQixXQUFXLGNBQWMsTUFBTSxzQkFBc0IsVUFBVSxjQUFjLFNBQVMsV0FBVyxjQUFjLFVBQVUsbUJBQW1CLHFCQUFxQixlQUFlLGVBQWUsMkJBQTJCLE1BQU0sR0FBRyxlQUFlLFFBQVEsT0FBTyxzQkFBc0Isa0NBQWtDLEtBQUssR0FBRyxvQ0FBb0MscURBQXFELFFBQVEsMERBQTBELEVBQUUsbUJBQW1CLHFCQUFxQixTQUFTO0FBQzNzQixpQkFBaUIsd0JBQXdCLGtDQUFrQyxxQkFBcUIsa0JBQWtCLE9BQU8scUNBQXFDLHlCQUF5QixlQUFlLGFBQWE7QUFDbk4saUJBQWlCLHNCQUFzQix5QkFBeUIsaUNBQWlDLG9CQUFvQixpREFBaUQsMkJBQTJCLDJFQUEyRSx3QkFBd0IsSUFBSSxtQkFBbUIscUJBQXFCLFNBQVMsR0FBRyxRQUFRO0FBQ3BXLCtCQUErQiw0Q0FBNEMsa0JBQWtCLGlCQUFpQixrQkFBa0IscUJBQXFCLGVBQWUsZ0JBQWdCLHNCQUFzQix5QkFBeUIsUUFBUSxRQUFRLG1CQUFtQixtQkFBbUIsc0JBQXNCLGNBQWMsdUNBQXVDLGVBQWUsVUFBVSxxQkFBcUIsRUFBRSxvQkFBb0IsRUFBRSxvQkFBb0IsRUFBRSxzQkFBc0IsRUFBRSwyQkFBMkIsR0FBRyxlQUFlLFlBQVksS0FBSyxXQUFXLGVBQWUsU0FBUztBQUN6akIsaUJBQWlCLHdDQUF3QyxvREFBb0QsY0FBYyxLQUFLLEdBQUcsUUFBUSxRQUFRLFFBQVEsbUJBQW1CLHdFQUF3RSxPQUFPLGtEQUFrRCxPQUFPLCtCQUErQixRQUFRLDZCQUE2Qix3Q0FBd0MsUUFBUSxtREFBbUQsUUFBUTtBQUNyZSwyQkFBMkIsS0FBSyxVQUFVLFFBQVEseUlBQXlJLGVBQWUsU0FBUyxnQkFBZ0IscUJBQXFCLEVBQUUsNkJBQTZCLFNBQVMseUJBQXlCLGdCQUFnQix1QkFBdUIseUJBQXlCLGdCQUFnQix1QkFBdUIsd0JBQXdCLGdCQUFnQixzQkFBc0IsOEJBQThCLGdCQUFnQjtBQUM1Z0IsMEJBQTBCLGdCQUFnQix3QkFBd0IsZ0JBQWdCLDRCQUE0QixnQkFBZ0IsdUJBQXVCLGdDQUFnQyxnQkFBZ0IsdUJBQXVCLCtCQUErQixnQkFBZ0Isc0JBQXNCLHFDQUFxQyxnQkFBZ0IsNEJBQTRCLGlDQUFpQyxnQkFBZ0I7QUFDbmEsdUJBQXVCLFNBQVMsZ0JBQWdCLHFCQUFxQixFQUFFLDZCQUE2QixVQUFVLHdCQUF3Qix3QkFBd0IsYUFBYSxHQUFHLDBCQUEwQixtQkFBbUIsb0hBQW9ILGVBQWUsZUFBZSxnQkFBZ0IsU0FBUyw2QkFBNkIsNFFBQTRRLGVBQWUsZUFBZSw0Q0FBNEMsNENBQTRDLDBDQUEwQyxpQkFBaUIsYUFBYSxlQUFlO0FBQzUzQix1Q0FBdUMsaUJBQWlCLGNBQWMsZUFBZSw2Q0FBNkMsd0NBQXdDLGlCQUFpQixrQkFBa0IsZUFBZSxpREFBaUQsNENBQTRDLGlCQUFpQixZQUFZLGVBQWUsc0NBQXNDLGlCQUFpQiw2QkFBNkIsaUJBQWlCLHFCQUFxQixlQUFlO0FBQzllLG1DQUFtQywyQkFBMkIsa0NBQWtDLGlCQUFpQixTQUFTLGtDQUFrQyxpQkFBaUIseUJBQXlCLGVBQWUsd0RBQXdELCtCQUErQixrQ0FBa0MscUJBQXFCLFNBQVMsc0NBQXNDLGtCQUFrQixLQUFLLFlBQVksZUFBZSxhQUFhLDZCQUE2QjtBQUM5ZSxHQUFHLDBCQUEwQixFQUFFLGdEQUFnRCw4QkFBOEIsMEJBQTBCLG1CQUFtQixhQUFhLFNBQVMsaUJBQWlCLG9CQUFvQixlQUFlLDRCQUE0QixpQkFBaUIsYUFBYSxlQUFlLDRDQUE0Qyx1Q0FBdUMsaUJBQWlCLFlBQVksZUFBZSwyQ0FBMkMsc0NBQXNDO0FBQzdmLGdCQUFnQixjQUFjLGVBQWUsYUFBYSxxQ0FBcUMsT0FBTywwREFBMEQsa0JBQWtCLDJCQUEyQixpQkFBaUIsc0JBQXNCLDZEQUE2RCxnQkFBZ0IsbUNBQW1DLDhGQUE4RixNQUFNLDBCQUEwQixpQkFBaUIsb0JBQW9CLGVBQWU7QUFDdGhCLGtDQUFrQywwQkFBMEIsa0NBQWtDLGlCQUFpQixTQUFTLGlDQUFpQyxpQkFBaUIsbUJBQW1CLGVBQWUsa0RBQWtELHlCQUF5QixrQ0FBa0MscUJBQXFCLFNBQVMsZ0NBQWdDLGlCQUFpQixXQUFXLGVBQWUsTUFBTSxtRUFBbUU7QUFDM2Usa0JBQWtCLHFCQUFxQixtQkFBbUIsYUFBYSxTQUFTLGlCQUFpQixZQUFZLGVBQWUsb0RBQW9ELHFDQUFxQyxpQkFBaUIsd0RBQXdELGFBQWEsNkJBQTZCLHFCQUFxQiw2QkFBNkIsc0JBQXNCLDhDQUE4QyxhQUFhLDZCQUE2QixrQkFBa0I7QUFDMWYsSUFBSSxZQUFZLGVBQWUsMkNBQTJDLGtCQUFrQixLQUFLLGVBQWUsZUFBZSx5RUFBeUUsa0JBQWtCLGdCQUFnQixvRUFBb0UsWUFBWSxZQUFZLGtCQUFrQiwyQ0FBMkMsWUFBWSxZQUFZLFNBQVMsaUJBQWlCO0FBQ3JiLGtCQUFrQixnQkFBZ0IsMkNBQTJDLHVHQUF1RyxjQUFjLFFBQVEsUUFBUSxRQUFRLHVCQUF1QixhQUFhLGlEQUFpRCw2QkFBNkIsb0JBQW9CLGFBQWEsaURBQWlELHlDQUF5QyxtQkFBbUIsTUFBTSxVQUFVLHdCQUF3Qix3QkFBd0IsMkJBQTJCLEVBQUUsa0VBQWtFLGdDQUFnQyx3Q0FBd0Msc0VBQXNFLHVCQUF1Qiw0SEFBNEg7QUFDMTVCLGVBQWUsOENBQThDLHdCQUF3QixxQ0FBcUMsbUNBQW1DLE1BQU0scURBQXFELHFCQUFxQiwyQkFBMkIsMEdBQTBHLG1CQUFtQiw4R0FBOEcsTUFBTSxzQ0FBc0Msb01BQW9NLGtCQUFrQixpQ0FBaUMsUUFBUSxNQUFNLFVBQVUsMEJBQTBCLE1BQU07QUFDOTBCLG1EQUFtRCxnQkFBZ0IsSUFBSSxTQUFTLFNBQVMscUVBQXFFLG9DQUFvQyxVQUFVLElBQUksTUFBTSx3QkFBd0IsMkRBQTJELDZDQUE2QyxlQUFlLFFBQVEsV0FBVyxpQkFBaUIsd0JBQXdCLDRDQUE0QztBQUM3YyxFQUFFLHVCQUF1QixlQUFlLFVBQVUsbUJBQW1CLFNBQVMsNEJBQTRCLG9GQUFvRixRQUFRO0FBQ3RNLGlCQUFpQiwwRkFBMEYsWUFBWSxVQUFVLHdCQUF3Qix3QkFBd0IsdUVBQXVFLHlFQUF5RSx3REFBd0QsMkJBQTJCLDBCQUEwQiwyQkFBMkIsOEJBQThCO0FBQ3ZlLHVEQUF1RCwyREFBMkQsVUFBVSxtQkFBbUIsVUFBVSxNQUFNLE1BQU0sb0NBQW9DLE1BQU0sTUFBTSxrQ0FBa0MsV0FBVyxLQUFLLFdBQVcsWUFBWSxjQUFjLHFCQUFxQixzQkFBc0IsSUFBSSx5QkFBeUIsV0FBVyxLQUFLLDZCQUE2QiwyQkFBMkIsTUFBTSxjQUFjO0FBQ2hkLHFFQUFxRSxhQUFhLFNBQVMsZUFBZSw0RUFBNEUsY0FBYyxVQUFVLGlDQUFpQyxlQUFlLFFBQVEseUZBQXlGLFNBQVMsZUFBZTtBQUN2WCxpQkFBaUIsdURBQXVELHFEQUFxRCxtQkFBbUIsVUFBVSxTQUFTLG1CQUFtQixvQkFBb0Isc0JBQXNCLFVBQVUsMkJBQTJCLE9BQU8sbUJBQW1CO0FBQy9SLGVBQWUsa0JBQWtCLHdCQUF3QixtQkFBbUIsZ0hBQWdILFVBQVUsbUJBQW1CLFNBQVMsdUJBQXVCLFNBQVMscUJBQXFCLHlCQUF5QixjQUFjLEtBQUssTUFBTSxxQ0FBcUMsSUFBSSx1QkFBdUIsYUFBYSw4Q0FBOEMsWUFBWTtBQUNoZCxtQkFBbUIsc0RBQXNELDZFQUE2RSxpQkFBaUIscUVBQXFFLHVDQUF1QyxNQUFNLGVBQWUsSUFBSSxVQUFVLFdBQVcsbUNBQW1DLFVBQVUsd0NBQXdDO0FBQ3RaLHVJQUF1SSxpQkFBaUIsYUFBYSx3Q0FBd0MsRUFBRSw0SEFBNEgseUNBQXlDO0FBQ3BYLGlCQUFpQixlQUFlLFdBQVcsb0JBQW9CLFdBQVc7QUFDMUUsUUFBUSxlQUFlLDZEQUE2RCxrQkFBa0IseUJBQXlCLG1EQUFtRCxlQUFlLGNBQWMsa0RBQWtELHFCQUFxQix3QkFBd0Isa0NBQWtDLHNDQUFzQyw0QkFBNEIsMkNBQTJDLFVBQVUscUNBQXFDO0FBQzVlLG9CQUFvQixlQUFlLGdCQUFnQixhQUFhLG9CQUFvQixTQUFTLFFBQVEsd0JBQXdCLFNBQVMsUUFBUSxrQkFBa0IsZUFBZSxxREFBcUQsbUJBQW1CLCtFQUErRSxvRUFBb0U7QUFDMVksZUFBZSx1QkFBdUIseUNBQXlDLGVBQWUsU0FBUyxpQkFBaUIsRUFBRSxxQkFBcUIsS0FBSyxLQUFLLFdBQVcsa0JBQWtCLGNBQWMsc0NBQXNDLGVBQWUsd0JBQXdCLEVBQUUsTUFBTSxRQUFRLFdBQVcsS0FBSyxPQUFPLGdDQUFnQztBQUN4Vix5QkFBeUIsWUFBWSxXQUFXLEtBQUsscURBQXFELG1EQUFtRDtBQUM3SixtQkFBbUIsTUFBTSwyQkFBMkIsa0JBQWtCLGVBQWUsa0JBQWtCLGtCQUFrQiw0QkFBNEIsTUFBTSw2QkFBNkIsY0FBYyxjQUFjLG1DQUFtQyxrQkFBa0IsYUFBYSx5REFBeUQseUNBQXlDLGVBQWUsU0FBUyxpQkFBaUIsRUFBRTtBQUNuYSxtREFBbUQsNEZBQTRGLHNFQUFzRSx5RkFBeUYsV0FBVyxZQUFZLGlEQUFpRCxFQUFFLDBDQUEwQyx5Q0FBeUMscUJBQXFCO0FBQ2hlO0FBQ0EsbUJBQW1CLE1BQU0sMkJBQTJCLGtCQUFrQixlQUFlLGtCQUFrQixrQkFBa0IsNkJBQTZCLFdBQVcsSUFBSSxRQUFRLFVBQVUsOEVBQThFLHdFQUF3RTtBQUM3VSxjQUFjLHNEQUFzRCwwQkFBMEIsS0FBSyxlQUFlLG9CQUFvQixxQkFBcUIsUUFBUSwrQkFBK0Isc0NBQXNDLHVCQUF1QixPQUFPLFNBQVMsaUJBQWlCLDJCQUEyQixjQUFjLDJFQUEyRSxpQkFBaUIsT0FBTztBQUM1YSxxQkFBcUIsd0NBQXdDLGlCQUFpQixRQUFRLElBQUksMkJBQTJCLElBQUksNkJBQTZCLFdBQVcsdUJBQXVCLHlCQUF5QixLQUFLLElBQUksS0FBSyxLQUFLLEtBQUssS0FBSywyQkFBMkIsU0FBUyxjQUFjLElBQUksa0JBQWtCLFVBQVUsMEJBQTBCLElBQUksSUFBSSxRQUFRLFFBQVEsV0FBVyxRQUFRLElBQUksNEJBQTRCLFFBQVEsSUFBSSxjQUFjLFFBQVEsSUFBSSxZQUFZLElBQUk7QUFDM2QsWUFBWSxLQUFLLGdDQUFnQyxnQkFBZ0IsYUFBYSxnQkFBZ0IsVUFBVSxTQUFTLFNBQVMsb01BQW9NLFlBQVksU0FBUyxLQUFLLFFBQVEsV0FBVyxpQkFBaUIsK0JBQStCLElBQUksSUFBSSxNQUFNLHNCQUFzQixNQUFNLElBQUksZUFBZSxJQUFJLE1BQU07QUFDbGUsTUFBTSxJQUFJLE1BQU0seUNBQXlDLGFBQWEsU0FBUyxpQkFBaUIsY0FBYyxVQUFVLGtCQUFrQixxREFBcUQsb0NBQW9DLHdCQUF3QixpQkFBaUIsTUFBTSxNQUFNLFNBQVMsY0FBYyx3QkFBd0IsaUJBQWlCLG1DQUFtQyxPQUFPLE9BQU8sT0FBTyxPQUFPLGtCQUFrQix1QkFBdUIsSUFBSSwrQkFBK0IsU0FBUyxzREFBc0QsZUFBZSwyQkFBMkIsYUFBYTtBQUN6bEIsZUFBZSxVQUFVLEVBQUUsRUFBRSxXQUFXLEdBQUcsUUFBUSx1QkFBdUIsd0NBQXdDLFdBQVcsMENBQTBDLFVBQVU7QUFDakwsbUNBQW1DLFVBQVUsU0FBUyxjQUFjLGdCQUFnQixLQUFLLFlBQVksOEJBQThCLDJCQUEyQixlQUFlLDhCQUE4QixXQUFXLEtBQUssV0FBVyxvQ0FBb0MsMkRBQTJELDJCQUEyQixFQUFFLDJCQUEyQixRQUFRLGdCQUFnQixLQUFLLFlBQVksc0RBQXNELEVBQUU7QUFDOWQsS0FBSyxlQUFlLHNEQUFzRCw2Q0FBNkMsbUJBQW1CLFFBQVEsV0FBVyx5QkFBeUIsa0JBQWtCLDJEQUEyRCwyQ0FBMkMsU0FBUyxLQUFLLFFBQVEsV0FBVyw4RUFBOEUsUUFBUSxXQUFXLEtBQUssT0FBTyx1QkFBdUIsS0FBSyxlQUFlLFlBQVk7QUFDbmYsU0FBUyxLQUFLLFdBQVcsd0JBQXdCLGNBQWMsWUFBWSxXQUFXLGlCQUFpQixlQUFlLFNBQVMsa0JBQWtCLDRCQUE0QixjQUFjLHFCQUFxQixLQUFLLGNBQWMseUJBQXlCLHVFQUF1RSxPQUFPLFFBQVEscUJBQXFCLCtCQUErQixjQUFjO0FBQ3BaLG1CQUFtQix3QkFBd0IsbUJBQW1CLGtCQUFrQiwyQ0FBMkMsMkZBQTJGLDJGQUEyRixtQkFBbUIsY0FBYyxxQkFBcUIsNEJBQTRCLDhCQUE4Qix1QkFBdUI7QUFDeGIsaUJBQWlCLGdEQUFnRCxxREFBcUQsZUFBZSxlQUFlLG9CQUFvQixXQUFXLEtBQUssV0FBVyx3QkFBd0IsTUFBTSxpQkFBaUIsWUFBWSxlQUFlLG9DQUFvQyxZQUFZLHNDQUFzQyxRQUFRLGVBQWUsbURBQW1EO0FBQzdhLGVBQWUsNEJBQTRCLFFBQVEsb0JBQW9CLFdBQVcsS0FBSyxPQUFPLFdBQVcsaUZBQWlGLEVBQUUsZUFBZSxTQUFTLGdCQUFnQixzQkFBc0IsU0FBUyxlQUFlLE1BQU0sbUJBQW1CLDZDQUE2Qyx5QkFBeUIsWUFBWSxFQUFFLFVBQVU7QUFDelksZ0RBQWdELHlCQUF5QixZQUFZLEVBQUUsVUFBVSxzQ0FBc0MsdUNBQXVDLDJCQUEyQixlQUFlLGFBQWEsVUFBVSxZQUFZLG1CQUFtQixZQUFZLFlBQVksZUFBZSxzQkFBc0IsWUFBWTtBQUN2VixRQUFRLHFFQUFxRSxLQUFLLG1FQUFtRSxrQkFBa0IsNEJBQTRCLG9CQUFvQix5QkFBeUIsa0JBQWtCLDRCQUE0QixhQUFhLFdBQVcsU0FBUyx1QkFBdUIsNkRBQTZELHVDQUF1QyxrQkFBa0IsY0FBYyxXQUFXO0FBQ3JlLGlCQUFpQixTQUFTLHdCQUF3QixnQkFBZ0Isc0JBQXNCLGtCQUFrQixtQkFBbUIseUJBQXlCLG9HQUFvRyxXQUFXLDRCQUE0QixnREFBZ0QsbUNBQW1DLDJCQUEyQixLQUFLLHFDQUFxQyxLQUFLLG1CQUFtQixpQkFBaUIsS0FBSywwQkFBMEI7QUFDamdCLFlBQVksb0JBQW9CLGFBQWEsVUFBVSxXQUFXLDhCQUE4QiwyQkFBMkIsb0JBQW9CLEdBQUcsS0FBSywwQkFBMEIsNEJBQTRCLHlCQUF5QixZQUFZLHNGQUFzRixRQUFRLDJCQUEyQixhQUFhLDZCQUE2QiwrQkFBK0IsV0FBVywwQkFBMEI7QUFDemQsbUNBQW1DLHdCQUF3QixZQUFZLGlDQUFpQyxhQUFhLGtCQUFrQixvQkFBb0IsaUJBQWlCLFFBQVEsK0JBQStCLFdBQVcseUJBQXlCLGVBQWUsNEJBQTRCLDJCQUEyQixlQUFlLGFBQWEsVUFBVSxZQUFZLEtBQUssNEJBQTRCLGdDQUFnQztBQUNoYix5Q0FBeUMsZ0JBQWdCLHNDQUFzQywrQ0FBK0MsRUFBRSxnQkFBZ0IsNENBQTRDLFdBQVcsS0FBSyxrREFBa0Qsb0RBQW9ELFNBQVMsY0FBYyw2QkFBNkIsU0FBUyx1SUFBdUkseUJBQXlCLGdCQUFnQixzQkFBc0IscUJBQXFCLEtBQUssbUZBQW1GLDRCQUE0Qiw4QkFBOEIsNEJBQTRCLHdDQUF3QztBQUNoekIsSUFBSSxnQ0FBZ0MsK0RBQStELG1CQUFtQixtT0FBbU8scUJBQXFCLDhJQUE4SSxlQUFlLGdCQUFnQiw2Q0FBNkMsWUFBWSxjQUFjLG9CQUFvQix1QkFBdUIsS0FBSyxxREFBcUQsNEVBQTRFO0FBQ254QixpQkFBaUIsS0FBSyx5QkFBeUIsZ0JBQWdCO0FBQy9ELGtCQUFrQix1QkFBdUIsWUFBWSxFQUFFLEVBQUUsbUNBQW1DLFFBQVEsS0FBSyxrQkFBa0IsaURBQWlELFdBQVcsNERBQTRELEVBQUUseUJBQXlCLFVBQVUsU0FBUyx3QkFBd0IsVUFBVSxTQUFTLDBDQUEwQyxFQUFFLHlCQUF5QixxQ0FBcUMsa0JBQWtCLFFBQVEsY0FBYyxlQUFlLGVBQWUsVUFBVSxVQUFVLG1CQUFtQixhQUFhLHlCQUF5QixpQkFBaUIsT0FBTyxZQUFZLGlCQUFpQixxQkFBcUIsY0FBYyxFQUFFLDJCQUEyQiw0QkFBNEIsa0JBQWtCLFlBQVksZ0JBQWdCLG1CQUFtQixnQkFBZ0IsU0FBUyxnQkFBZ0IsaUJBQWlCLEVBQUUsUUFBUSxXQUFXLEtBQUssV0FBVztBQUMxM0IsZ0JBQWdCLFNBQVMsZ0JBQWdCLGlCQUFpQixFQUFFLFFBQVEsV0FBVyxLQUFLLFdBQVc7QUFDL0Ysa0JBQWtCLGVBQWUsR0FBRyx3Q0FBd0MsZUFBZSxNQUFNLGdCQUFnQiwyREFBMkQsZUFBZSxzRUFBc0UsZ0dBQWdHLGVBQWUsZ0NBQWdDLDhCQUE4QixpQkFBaUIsWUFBWSxPQUFPLFVBQVUsR0FBRyxFQUFFLGVBQWUsSUFBSTtBQUNwZixFQUFFLFdBQVcsY0FBYyxRQUFRLFdBQVc7QUFDOUMsaUJBQWlCLDBCQUEwQixzQkFBc0IseUZBQXlGLDRCQUE0QixvQkFBb0IsSUFBSSxJQUFJLHdHQUF3RyxRQUFRLDJCQUEyQixTQUFTLHdCQUF3QixlQUFlLG9CQUFvQiw2REFBNkQsV0FBVyxLQUFLO0FBQzllLG9CQUFvQixzREFBc0QsK0JBQStCLDJDQUEyQyx3QkFBd0Isa0RBQWtELDhDQUE4Qyx3QkFBd0I7QUFDcFMsMERBQTBELHdCQUF3Qiw0R0FBNEcsZUFBZSxlQUFlLFNBQVMsU0FBUyxjQUFjLGlCQUFpQixzR0FBc0csd0JBQXdCLEdBQUcsZUFBZSxzQkFBc0IsMkJBQTJCLHdCQUF3Qiw0Q0FBNEMsUUFBUSxXQUFXLGtDQUFrQyxXQUFXLG9CQUFvQixjQUFjLFdBQVcscUJBQXFCLCtCQUErQixNQUFNLFlBQVksRUFBRSxpQ0FBaUMsMkNBQTJDLFNBQVMsbUJBQW1CLGNBQWMsV0FBVyxTQUFTLGdCQUFnQixvQkFBb0IsWUFBWSxVQUFVLFdBQVc7QUFDdDVCLGlDQUFpQyxXQUFXLGtHQUFrRywwRUFBMEUsK0ZBQStGLHFFQUFxRSxXQUFXLElBQUksa0JBQWtCLFdBQVc7QUFDeGEsU0FBUyxlQUFlLDhHQUE4Ryw2QkFBNkIsZ0NBQWdDLDJCQUEyQixvQ0FBb0MsK0JBQStCLFNBQVMsT0FBTyxRQUFRLFdBQVcsR0FBRyw2SkFBNkosZUFBZTtBQUNuZixzQ0FBc0MsYUFBYSxJQUFJLGVBQWUsYUFBYSxPQUFPLGtDQUFrQyxXQUFXLDZCQUE2QixnQkFBZ0IsZUFBZSwwQkFBMEIsNkJBQTZCLHNDQUFzQyxFQUFFLFFBQVEsV0FBVyxpQkFBaUIsS0FBSyxXQUFXLEVBQUUsZ0JBQWdCLGNBQWMscUJBQXFCLFlBQVksV0FBVyxpQkFBaUI7QUFDbmIsNEJBQTRCLDJDQUEyQyxvQ0FBb0MsZ0dBQWdHLHFCQUFxQixnQkFBZ0IsU0FBUyxpQkFBaUIsMkNBQTJDLHVCQUF1QixxQkFBcUIsWUFBWSwyQkFBMkIsWUFBWSxjQUFjLG9CQUFvQixvQkFBb0IsWUFBWTtBQUN0ZCwrQkFBK0Isc0NBQXNDLGdDQUFnQyxnREFBZ0QscURBQXFEO0FBQzFNO0FBQ0EseVNBQXlTLHdCQUF3QixjQUFjLFNBQVMsOEJBQThCLGFBQWEsb0NBQW9DLG9HQUFvRywwQkFBMEIsd0lBQXdJLGFBQWEsV0FBVztBQUNyc0IsUUFBUSxxQ0FBcUMsT0FBTyxTQUFTLHlCQUF5QixTQUFTLElBQUksbUJBQW1CLGNBQWMsbUJBQW1CLGlCQUFpQixtQkFBbUIsd0JBQXdCLEtBQUssaUJBQWlCLFdBQVcsS0FBSyxXQUFXLHNDQUFzQyxvREFBb0QsRUFBRSwwQkFBMEIsZUFBZSxnQkFBZ0IsUUFBUSxXQUFXLGNBQWMsbUJBQW1CLFdBQVcseUNBQXlDLGlDQUFpQywyQ0FBMkMsY0FBYyxTQUFTLGlEQUFpRCwwQkFBMEIsaUJBQWlCLDhCQUE4QixrQkFBa0IsT0FBTyxTQUFTLEVBQUUsZ0RBQWdELG9CQUFvQixxQ0FBcUMsU0FBUyxFQUFFLHFEQUFxRCwwRUFBMEUsaUJBQWlCLDhCQUE4QixvQkFBb0IsT0FBTyxTQUFTO0FBQ3hrQyx5QkFBeUIsZUFBZSxHQUFHLGNBQWMsU0FBUyxnQkFBZ0IsdUNBQXVDLGtFQUFrRSxxREFBcUQsS0FBSyxhQUFhLG9CQUFvQixpQ0FBaUMsaUJBQWlCLFdBQVcsWUFBWSxJQUFJLGVBQWUsbUJBQW1CLGFBQWEsV0FBVyxnQkFBZ0IsRUFBRSw4Q0FBOEMsa0NBQWtDO0FBQy9mLG9CQUFvQixtQkFBbUIsV0FBVyxjQUFjLFNBQVMsT0FBTyxvQkFBb0IsVUFBVSxnQkFBZ0IsU0FBUyxFQUFFLDJDQUEyQyxrQ0FBa0MsZ0RBQWdELGtCQUFrQix1QkFBdUIsV0FBVyxjQUFjLFNBQVMsT0FBTyxrQkFBa0IsVUFBVSxnQkFBZ0IsU0FBUyxFQUFFLHlDQUF5QyxrQkFBa0I7QUFDMWMsUUFBUSxTQUFTLEVBQUUsMkNBQTJDLDZCQUE2QixVQUFVLFNBQVMsRUFBRSw4Q0FBOEMsa0NBQWtDLGdEQUFnRCxvQkFBb0IsMEJBQTBCLFdBQVcsY0FBYyxTQUFTLE9BQU8sa0NBQWtDLFVBQVUsVUFBVSxVQUFVLFNBQVMsRUFBRSxpREFBaUQsS0FBSyw2Q0FBNkM7QUFDcmYsT0FBTyx5QkFBeUIsMkNBQTJDLGtCQUFrQixpQkFBaUIsS0FBSyxnQkFBZ0IsK0JBQStCLDBDQUEwQyxFQUFFLEdBQUcsZUFBZSx3QkFBd0IsY0FBYyxtQkFBbUIsaUJBQWlCLG1CQUFtQix3QkFBd0IsS0FBSyxpQkFBaUIsV0FBVyxLQUFLLFdBQVcsc0NBQXNDLG9EQUFvRCxFQUFFLDBCQUEwQixlQUFlLGdCQUFnQixRQUFRLFdBQVcsY0FBYyxtQkFBbUIsV0FBVyx5Q0FBeUMsOEJBQThCLDZCQUE2QjtBQUM5ckIsa0NBQWtDLGlCQUFpQixtQkFBbUIsd0JBQXdCLEtBQUssaUJBQWlCLFdBQVcsS0FBSyxXQUFXLHNDQUFzQyxvREFBb0QsRUFBRSwwQkFBMEIsZUFBZSxVQUFVLGlCQUFpQixRQUFRLFdBQVcsY0FBYyx1QkFBdUIsV0FBVyx3Q0FBd0MsRUFBRSxxQ0FBcUMsY0FBYyxjQUFjLGFBQWEsR0FBRyxjQUFjLFNBQVMsZ0JBQWdCLHFDQUFxQyxrRUFBa0Usb0JBQW9CLGtDQUFrQyxpQkFBaUIsR0FBRyxtQkFBbUIsaUJBQWlCLFdBQVcsS0FBSyxXQUFXLDRDQUE0Qyx5REFBeUQsVUFBVSxFQUFFLGdCQUFnQiwwQ0FBMEMsV0FBVyxtQkFBbUIsVUFBVTtBQUN2OUIsU0FBUyxFQUFFLG1EQUFtRCw4Q0FBOEMsRUFBRSwyRkFBMkYsS0FBSyw2Q0FBNkMsa0NBQWtDLGlCQUFpQiwyRkFBMkYsa0JBQWtCLHNCQUFzQiw0QkFBNEIsb0JBQW9CLHNCQUFzQjtBQUN2ZixrQkFBa0IsRUFBRSxFQUFFLGlEQUFpRCxnREFBZ0Qsc0JBQXNCLGtCQUFrQixrQkFBa0IsNENBQTRDLEVBQUUscURBQXFELGtEQUFrRCx3QkFBd0Isb0JBQW9CLG9CQUFvQix5Q0FBeUMsRUFBRSxrREFBa0Q7QUFDbmUsR0FBRyxzQkFBc0IsZ0JBQWdCLHlEQUF5RCxFQUFFLHNEQUFzRCxnREFBZ0Qsd0JBQXdCLGtCQUFrQix3QkFBd0IsZ0RBQWdELEVBQUUsNElBQTRJLHdCQUF3QixlQUFlLEVBQUU7QUFDbmYsQ0FBQyw2QkFBNkIsbUZBQW1GLGNBQWMsS0FBSyxLQUFLLGtDQUFrQyxlQUFlLEVBQUUsS0FBSyxLQUFLLDZCQUE2Qiw2QkFBNkIsK0NBQStDLG1EQUFtRCxHQUFHLGNBQWMsc0JBQXNCLDBDQUEwQyxtQ0FBbUMsZUFBZSxZQUFZO0FBQ2pmLGVBQWUsa0NBQWtDLHNCQUFzQixVQUFVLGVBQWUsMkJBQTJCLElBQUksU0FBUyxVQUFVLHNCQUFzQiwwQ0FBMEMsU0FBUyxZQUFZLFdBQVcsYUFBYSxnQkFBZ0IsTUFBTSxvQ0FBb0M7QUFDelQsaUJBQWlCLG1DQUFtQyxtQ0FBbUMsdUlBQXVJLDBOQUEwTixzQ0FBc0MsY0FBYztBQUM1ZSxHQUFHLFNBQVMsZUFBZSw4QkFBOEIsSUFBSSxxQkFBcUIsSUFBSSxpQkFBaUIsSUFBSSxTQUFTLGFBQWE7QUFDakksbUJBQW1CLGtCQUFrQixTQUFTLHVCQUF1QixnQkFBZ0IsK0RBQStELE1BQU0sSUFBSSxxQkFBcUIsY0FBYyxnQkFBZ0IsbUlBQW1JLGtDQUFrQyw0QkFBNEIsUUFBUTtBQUMxWiwrRUFBK0UsR0FBRyxnQkFBZ0IsS0FBSyxXQUFXLFNBQVMsUUFBUSxzQkFBc0IsS0FBSyxXQUFXLFNBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxnQ0FBZ0MsYUFBYSxtQkFBbUIsUUFBUSxXQUFXLFNBQVMsNkNBQTZDLG1EQUFtRCxlQUFlLHNLQUFzSyxtTUFBbU0sU0FBUyxlQUFlLEdBQUcsMEVBQTBFLE9BQU8sSUFBSSxLQUFLLFFBQVEsR0FBRyx3Q0FBd0Msa0NBQWtDLDJFQUEyRSxHQUFHLElBQUksR0FBRyxlQUFlLGlCQUFpQixlQUFlLCtCQUErQixXQUFXLGVBQWUsZUFBZSwrREFBK0QsMEJBQTBCLGVBQWUscUNBQXFDLHFCQUFxQixNQUFNLGtCQUFrQixjQUFjLDJCQUEyQiw2Q0FBNkMsMENBQTBDLG9CQUFvQixJQUFJLFdBQVcsVUFBVSxjQUFjO0FBQ2pnRCxxQkFBcUIsc0NBQXNDLDZCQUE2QixnQkFBZ0IsVUFBVSxTQUFTLFdBQVcsbUJBQW1CLG1CQUFtQixpREFBaUQ7QUFDN04saUJBQWlCLHdCQUF3QiwrQkFBK0IsR0FBRyxRQUFRLFVBQVUsbUJBQW1CLElBQUksc0JBQXNCLG9DQUFvQyxLQUFLLHFCQUFxQixtQkFBbUIseUJBQXlCLGlCQUFpQix1RkFBdUYsaUJBQWlCO0FBQzdXLGNBQWMsdUJBQXVCLDJGQUEyRixPQUFPLFdBQVcsZUFBZSxtQkFBbUIsUUFBUSxxREFBcUQscUJBQXFCLDBDQUEwQyxnR0FBZ0csV0FBVztBQUMzWixtQkFBbUIsb0lBQW9JLHdCQUF3Qix5QkFBeUIsZ0dBQWdHLG1CQUFtQix1QkFBdUIsOERBQThEO0FBQ2haLHVCQUF1QixjQUFjLFlBQVksd0JBQXdCLDZDQUE2QyxZQUFZLEVBQUUsaUJBQWlCLHdCQUF3Qix1QkFBdUIsMkJBQTJCLFdBQVcsSUFBSSxxQkFBcUIsY0FBYyx5QkFBeUIsa0JBQWtCLGVBQWUsb0NBQW9DLDBGQUEwRixzQkFBc0I7QUFDL2QsK0JBQStCLFNBQVMsV0FBVyxpQkFBaUIsbUNBQW1DLHdDQUF3QyxXQUFXLHlCQUF5QiwrQkFBK0IsZ0RBQWdELFdBQVcsRUFBRSxhQUFhO0FBQzVSLHFCQUFxQixvQkFBb0Isa0RBQWtELEtBQUssa0JBQWtCLE1BQU0sU0FBUyxpQ0FBaUMsY0FBYyxHQUFHLCtCQUErQixnREFBZ0QsRUFBRSxPQUFPLHFCQUFxQixpQkFBaUIsY0FBYyxRQUFRO0FBQ3ZVLGlCQUFpQixrQkFBa0IseUVBQXlFLFdBQVcsMENBQTBDLGVBQWUscUNBQXFDLDJCQUEyQixpREFBaUQsd0NBQXdDLEdBQUcsNkNBQTZDLHNCQUFzQjtBQUMvWSxrWEFBa1gscUJBQXFCLGVBQWUsZUFBZSxjQUFjLFlBQVksYUFBYSwwQkFBMEIsY0FBYyw0QkFBNEIsaUJBQWlCLHVCQUF1QiwwQkFBMEIsZUFBZSwyQ0FBMkMsbUNBQW1DLDhIQUE4SCw0Q0FBNEMsZUFBZSxlQUFlLFFBQVEsVUFBVSxpQkFBaUIsTUFBTSxZQUFZLGNBQWMsVUFBVSxhQUFhLEVBQUUsV0FBVyx1QkFBdUIsYUFBYSxVQUFVLEVBQUUsTUFBTSxLQUFLLHlCQUF5QjtBQUNsakMsZUFBZSxTQUFTLFFBQVEsTUFBTSw4QkFBOEIsd0RBQXdELE9BQU8saUJBQWlCLFVBQVUsTUFBTSxzQ0FBc0MsS0FBSyxrQkFBa0IsVUFBVSxhQUFhLEVBQUUsc0JBQXNCLCtDQUErQyxLQUFLO0FBQ3BVLG1CQUFtQixxQkFBcUIsb0NBQW9DLGlCQUFpQiw2RkFBNkYsbUJBQW1CLEdBQUc7QUFDaE4sbUJBQW1CLFlBQVksR0FBRyxnQkFBZ0IsV0FBVyxlQUFlLGVBQWUsa0NBQWtDLGlDQUFpQyxxQkFBcUIsV0FBVyxlQUFlLHFCQUFxQix3QkFBd0Isb0NBQW9DLGdCQUFnQjtBQUM5UyxpQkFBaUIsUUFBUSxNQUFNLGlCQUFpQixXQUFXLDRCQUE0QiwwRkFBMEYsVUFBVSxPQUFPO0FBQ2xNLHFCQUFxQixXQUFXLFVBQVUsV0FBVyxPQUFPLE1BQU0sbUJBQW1CLGtGQUFrRixnRkFBZ0Ysc0RBQXNELG9FQUFvRSxlQUFlO0FBQ2hZLGlCQUFpQixRQUFRLEtBQUssbUJBQW1CLGlCQUFpQixxQkFBcUIsOENBQThDLEVBQUUsVUFBVSxPQUFPO0FBQ3hKLHFCQUFxQixpSEFBaUgsU0FBUyxjQUFjLDBCQUEwQixTQUFTLFdBQVcscUNBQXFDLFlBQVksMEJBQTBCLGtCQUFrQiw4QkFBOEIsc0JBQXNCLE9BQU8sc0RBQXNELEtBQUssUUFBUSxhQUFhLHVCQUF1QixJQUFJLFlBQVksb0JBQW9CO0FBQzllLGlCQUFpQixJQUFJLHFCQUFxQixjQUFjLDJDQUEyQyx3QkFBd0IsRUFBRSxpQkFBaUIsTUFBTSxTQUFTLDRCQUE0QixXQUFXLFVBQVUsWUFBWSxvQ0FBb0MsMEJBQTBCLG9CQUFvQiw0Q0FBNEMseUJBQXlCLFNBQVMsZUFBZSxtQkFBbUI7QUFDNVosaUJBQWlCLGlCQUFpQiwrQkFBK0IsZ0NBQWdDLDBFQUEwRSxFQUFFLHdDQUF3QyxHQUFHLDZDQUE2QyxrQkFBa0IsRUFBRSxjQUFjLFNBQVMsMEJBQTBCLFdBQVcsaUJBQWlCLDBCQUEwQiw2RUFBNkUsdURBQXVELElBQUksUUFBUSwyQkFBMkIsY0FBYyxjQUFjLHFDQUFxQyx3QkFBd0IsUUFBUSx1QkFBdUIsRUFBRSx3QkFBd0IsaUJBQWlCLG1DQUFtQyx3Q0FBd0MsS0FBSyxLQUFLLGFBQWEsR0FBRyxRQUFRLFdBQVcsS0FBSyxXQUFXLGtCQUFrQixLQUFLLFNBQVMsS0FBSyxnQkFBZ0I7QUFDMzRCLGVBQWUsWUFBWSxXQUFXLEtBQUssV0FBVyw2RUFBNkUsc0JBQXNCLEtBQUssc0JBQXNCLG1DQUFtQyxzQkFBc0IsUUFBUSxTQUFTLHdJQUF3SSxJQUFJLGlCQUFpQixzREFBc0Q7QUFDamQsZ0hBQWdILFdBQVcsZUFBZTtBQUMxSSxPQUFPLCtDQUErQyxjQUFjLHdCQUF3QixHQUFHLHdGQUF3RixLQUFLLGtCQUFrQixtQkFBbUIscUZBQXFGLG9DQUFvQyxpQkFBaUIsS0FBSyxvREFBb0QsZ0RBQWdELFVBQVUsRUFBRSxjQUFjO0FBQzllLFVBQVUsVUFBVSx5QkFBeUIsZUFBZSwwTEFBMEwsZUFBZSw0REFBNEQsZUFBZSxzREFBc0QsZ0NBQWdDLG1EQUFtRCxPQUFPLElBQUkseUVBQXlFLGVBQWUsaUNBQWlDLDBDQUEwQyxLQUFLLGdHQUFnRyx1Q0FBdUMsc0JBQXNCLE9BQU8sR0FBRyxHQUFHLGNBQWMsYUFBYSxXQUFXLFVBQVUsZ0NBQWdDLGFBQWEsV0FBVyw0QkFBNEIsVUFBVSxtQkFBbUIsY0FBYyxNQUFNLEVBQUUsY0FBYyxnQkFBZ0IsTUFBTSxpQkFBaUIsY0FBYyxpQkFBaUI7QUFDamtDLGtDQUFrQyxTQUFTLE9BQU8sU0FBUyxZQUFZLFFBQVEsOEVBQThFLFNBQVMsa0RBQWtELFdBQVcsS0FBSyxXQUFXLHFDQUFxQyxPQUFPLG9CQUFvQixzRUFBc0UsNkJBQTZCLHVEQUF1RCxvQkFBb0IsR0FBRztBQUNwZSxtQkFBbUIsU0FBUyx5QkFBeUIsZUFBZSxlQUFlLFFBQVEseUNBQXlDLGNBQWMsTUFBTSxLQUFLLHVCQUF1QixzR0FBc0c7QUFDMVIsZUFBZSx5SUFBeUksUUFBUSxpQ0FBaUMsaUNBQWlDLDJCQUEyQixFQUFFLEVBQUUsZUFBZSx5R0FBeUc7QUFDelgsZUFBZSxTQUFTLFdBQVcsNkJBQTZCLG9CQUFvQixpQkFBaUIsV0FBVyxLQUFLLDBDQUEwQyxpQkFBaUIsWUFBWSxTQUFTLHlCQUF5QixxQkFBcUIsb0NBQW9DLFdBQVcsNERBQTRELG1CQUFtQjtBQUNqWCw2QkFBNkIscUJBQXFCLE9BQU8sV0FBVyxPQUFPLE1BQU0sWUFBWSxRQUFRLE1BQU0sa0JBQWtCLFVBQVUsd0JBQXdCLHdCQUF3QixlQUFlLHVCQUF1QixNQUFNLFFBQVEsTUFBTSw4RUFBOEUsNENBQTRDO0FBQzNXLFdBQVcsc0VBQXNFLGlCQUFpQix3Q0FBd0MsSUFBSSxVQUFVLCtDQUErQyxNQUFNLHFEQUFxRCxNQUFNLE1BQU0sS0FBSyxvQ0FBb0MsT0FBTyxVQUFVLHdGQUF3RjtBQUNoYSxrRkFBa0YsNERBQTRELElBQUksc0pBQXNKLDJCQUEyQixpQkFBaUI7QUFDcFYsbUJBQW1CLFVBQVUsV0FBVywyQkFBMkIsZ0JBQWdCLGNBQWMsNkJBQTZCLE1BQU0seUNBQXlDLEtBQUssZ0NBQWdDLFFBQVEsV0FBVyw2QkFBNkIsTUFBTSw0QkFBNEI7QUFDcFMsNkJBQTZCLG1CQUFtQix3Q0FBd0MsMkNBQTJDLFdBQVcsNEJBQTRCLDJDQUEyQyxXQUFXLDZCQUE2QixpQkFBaUIsbUJBQW1CLGlCQUFpQixXQUFXLEtBQUssUUFBUSw0QkFBNEIsTUFBTSx5Q0FBeUMscUNBQXFDLEVBQUU7QUFDNWIsc0NBQXNDLE1BQU0sa0NBQWtDLHlFQUF5RSxtQkFBbUIsc0JBQXNCLHFCQUFxQiwyQkFBMkIsT0FBTyw4QkFBOEIsTUFBTSxnQkFBZ0IsWUFBWSxXQUFXLG1CQUFtQixTQUFTLFFBQVEsaUJBQWlCLG1DQUFtQyxtQkFBbUIsaUJBQWlCLGFBQWE7QUFDM2Msd0RBQXdELGtEQUFrRCxvREFBb0Qsa0RBQWtELG9FQUFvRSwyQ0FBMkMsNkNBQTZDLDJEQUEyRCx1Q0FBdUM7QUFDOWMsNENBQTRDLHFDQUFxQyxjQUFjLGVBQWUsVUFBVSxZQUFZLGVBQWUsV0FBVyxFQUFFLGtCQUFrQix3RkFBd0YsaUJBQWlCLDhDQUE4QyxNQUFNLHlCQUF5Qiw0QkFBNEIsTUFBTSxvQkFBb0IsMEJBQTBCLE1BQU0sa0JBQWtCLDJCQUEyQixNQUFNLG1CQUFtQixxQ0FBcUMsb0NBQW9DLDZCQUE2QjtBQUMxbUIsOENBQThDLGlGQUFpRiw4Q0FBOEMscUNBQXFDLHFCQUFxQixPQUFPLDRCQUE0QixTQUFTLFFBQVEsSUFBSSxVQUFVLGlCQUFpQix5Q0FBeUMsS0FBSyxPQUFPLEVBQUUseUJBQXlCLGNBQWMseUJBQXlCO0FBQ2piLHdCQUF3QixpQ0FBaUMsOEJBQThCLDZEQUE2RCxXQUFXLEdBQUcsRUFBRSxFQUFFLHVDQUF1QyxzQkFBc0IsaUNBQWlDLEVBQUUscUJBQXFCLFdBQVcsZ0JBQWdCLGtCQUFrQixvQkFBb0IsRUFBRSxLQUFLLHNDQUFzQyxtQ0FBbUM7O0FBRTVhOzs7Ozs7OztBQ2xNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDOztBQUU1Qzs7Ozs7OztBQ3BCQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVIiwiZmlsZSI6IjFkMjZhNWUwNjhhN2QyNTRkMmRiLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNTEpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIHdlYnBhY2svYm9vdHN0cmFwIDFkMjZhNWUwNjhhN2QyNTRkMmRiIiwiaW1wb3J0IHsgTGVnYWN5RWxlbWVudE1peGluIH0gZnJvbSAnLi9saWIvbGVnYWN5L2xlZ2FjeS1lbGVtZW50LW1peGluLmpzJztcbmltcG9ydCAnLi9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0ICcuL2xpYi9sZWdhY3kvdGVtcGxhdGl6ZXItYmVoYXZpb3IuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9kb20tYmluZC5qcyc7XG5pbXBvcnQgJy4vbGliL2VsZW1lbnRzL2RvbS1yZXBlYXQuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9kb20taWYuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9hcnJheS1zZWxlY3Rvci5qcyc7XG5pbXBvcnQgJy4vbGliL2VsZW1lbnRzL2N1c3RvbS1zdHlsZS5qcyc7XG5pbXBvcnQgJy4vbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuanMnO1xuZXhwb3J0IGNvbnN0IEJhc2UgPSBMZWdhY3lFbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpLnByb3RvdHlwZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci5qc1xuLy8gbW9kdWxlIGlkID0gMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJ3aW5kb3cuSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSA9IGZ1bmN0aW9uKHByb3AsIG9iaikgeyByZXR1cm4gcHJvcDsgfVxuXG4vKiogQG5hbWVzcGFjZSAqL1xubGV0IFBvbHltZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9ib290LmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL3NldHRpbmdzLmpzJztcbmltcG9ydCB7IEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIgfSBmcm9tICcuLi91dGlscy9mbGF0dGVuZWQtbm9kZXMtb2JzZXJ2ZXIuanMnO1xuaW1wb3J0IHsgZmx1c2ggYXMgZmx1c2gkMCwgZW5xdWV1ZURlYm91bmNlciB9IGZyb20gJy4uL3V0aWxzL2ZsdXNoLmpzJztcblxuY29uc3QgcCA9IEVsZW1lbnQucHJvdG90eXBlO1xuLyoqXG4gKiBAY29uc3Qge2Z1bmN0aW9uKHRoaXM6RWxlbWVudCwgc3RyaW5nKTogYm9vbGVhbn1cbiAqL1xuY29uc3Qgbm9ybWFsaXplZE1hdGNoZXNTZWxlY3RvciA9IHAubWF0Y2hlcyB8fCBwLm1hdGNoZXNTZWxlY3RvciB8fFxuICBwLm1vek1hdGNoZXNTZWxlY3RvciB8fCBwLm1zTWF0Y2hlc1NlbGVjdG9yIHx8XG4gIHAub01hdGNoZXNTZWxlY3RvciB8fCBwLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBgZWxlbWVudC5tYXRjaGVzYCBzaGltLlxuICpcbiAqIEBmdW5jdGlvbiBtYXRjaGVzU2VsZWN0b3JcbiAqIEBtZW1iZXJvZiBQb2x5bWVyLmRvbVxuICogQHBhcmFtIHshRWxlbWVudH0gbm9kZSBOb2RlIHRvIGNoZWNrIHNlbGVjdG9yIGFnYWluc3RcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBtYXRjaFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBub2RlIG1hdGNoZWQgc2VsZWN0b3JcbiAqL1xuY29uc3QgbWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24obm9kZSwgc2VsZWN0b3IpIHtcbiAgcmV0dXJuIG5vcm1hbGl6ZWRNYXRjaGVzU2VsZWN0b3IuY2FsbChub2RlLCBzZWxlY3Rvcik7XG59O1xuXG4vKipcbiAqIE5vZGUgQVBJIHdyYXBwZXIgY2xhc3MgcmV0dXJuZWQgZnJvbSBgUG9seW1lci5kb20uKHRhcmdldClgIHdoZW5cbiAqIGB0YXJnZXRgIGlzIGEgYE5vZGVgLlxuICovXG5jbGFzcyBEb21BcGkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSBmb3Igd2hpY2ggdG8gY3JlYXRlIGEgUG9seW1lci5kb20gaGVscGVyIG9iamVjdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gaW5zdGFuY2Ugb2YgYFBvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlcmAgdGhhdFxuICAgKiBsaXN0ZW5zIGZvciBub2RlIGNoYW5nZXMgb24gdGhpcyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgd2hlbiBkaXJlY3Qgb3IgZGlzdHJpYnV0ZWQgY2hpbGRyZW5cbiAgICogICBvZiB0aGlzIGVsZW1lbnQgY2hhbmdlc1xuICAgKiBAcmV0dXJuIHtQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJ9IE9ic2VydmVyIGluc3RhbmNlXG4gICAqL1xuICBvYnNlcnZlTm9kZXMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gbmV3IEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIodGhpcy5ub2RlLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdHMgYW4gb2JzZXJ2ZXIgcHJldmlvdXNseSBjcmVhdGVkIHZpYSBgb2JzZXJ2ZU5vZGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXIuRmxhdHRlbmVkTm9kZXNPYnNlcnZlcn0gb2JzZXJ2ZXJIYW5kbGUgT2JzZXJ2ZXIgaW5zdGFuY2VcbiAgICogICB0byBkaXNjb25uZWN0LlxuICAgKi9cbiAgdW5vYnNlcnZlTm9kZXMob2JzZXJ2ZXJIYW5kbGUpIHtcbiAgICBvYnNlcnZlckhhbmRsZS5kaXNjb25uZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZWQgYXMgYSBiYWNrd2FyZHMtY29tcGF0aWJsZSBBUEkgb25seS4gIFRoaXMgbWV0aG9kIGRvZXMgbm90aGluZy5cbiAgICovXG4gIG5vdGlmeU9ic2VydmVyKCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBwcm92aWRlZCBub2RlIGlzIGNvbnRhaW5lZCB3aXRoIHRoaXMgZWxlbWVudCdzXG4gICAqIGxpZ2h0LURPTSBjaGlsZHJlbiBvciBzaGFkb3cgcm9vdCwgaW5jbHVkaW5nIGFueSBuZXN0ZWQgc2hhZG93IHJvb3RzXG4gICAqIG9mIGNoaWxkcmVuIHRoZXJlaW4uXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHRlc3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgY29udGFpbmVkIHdpdGhpblxuICAgKiAgIHRoaXMgZWxlbWVudCdzIGxpZ2h0IG9yIHNoYWRvdyBET00uXG4gICAqL1xuICBkZWVwQ29udGFpbnMobm9kZSkge1xuICAgIGlmICh0aGlzLm5vZGUuY29udGFpbnMobm9kZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgbiA9IG5vZGU7XG4gICAgbGV0IGRvYyA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICAvLyB3YWxrIGZyb20gbm9kZSB0byBgdGhpc2Agb3IgYGRvY3VtZW50YFxuICAgIHdoaWxlIChuICYmIG4gIT09IGRvYyAmJiBuICE9PSB0aGlzLm5vZGUpIHtcbiAgICAgIC8vIHVzZSBsb2dpY2FsIHBhcmVudG5vZGUsIG9yIG5hdGl2ZSBTaGFkb3dSb290IGhvc3RcbiAgICAgIG4gPSBuLnBhcmVudE5vZGUgfHwgbi5ob3N0O1xuICAgIH1cbiAgICByZXR1cm4gbiA9PT0gdGhpcy5ub2RlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvb3Qgbm9kZSBvZiB0aGlzIG5vZGUuICBFcXVpdmFsZW50IHRvIGBnZXRSb29kTm9kZSgpYC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVG9wIG1vc3QgZWxlbWVudCBpbiB0aGUgZG9tIHRyZWUgaW4gd2hpY2ggdGhlIG5vZGVcbiAgICogZXhpc3RzLiBJZiB0aGUgbm9kZSBpcyBjb25uZWN0ZWQgdG8gYSBkb2N1bWVudCB0aGlzIGlzIGVpdGhlciBhXG4gICAqIHNoYWRvd1Jvb3Qgb3IgdGhlIGRvY3VtZW50OyBvdGhlcndpc2UsIGl0IG1heSBiZSB0aGUgbm9kZVxuICAgKiBpdHNlbGYgb3IgYSBub2RlIG9yIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgaXQuXG4gICAqL1xuICBnZXRPd25lclJvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZS5nZXRSb290Tm9kZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvciBzbG90IGVsZW1lbnRzLCByZXR1cm5zIHRoZSBub2RlcyBhc3NpZ25lZCB0byB0aGUgc2xvdDsgb3RoZXJ3aXNlXG4gICAqIGFuIGVtcHR5IGFycmF5LiBJdCBpcyBlcXVpdmFsZW50IHRvIGA8c2xvdD4uYWRkaWduZWROb2Rlcyh7ZmxhdHRlbjp0cnVlfSlgLlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gQXJyYXkgb2YgYXNzaWduZWQgbm9kZXNcbiAgICovXG4gIGdldERpc3RyaWJ1dGVkTm9kZXMoKSB7XG4gICAgcmV0dXJuICh0aGlzLm5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpID9cbiAgICAgIHRoaXMubm9kZS5hc3NpZ25lZE5vZGVzKHtmbGF0dGVuOiB0cnVlfSkgOlxuICAgICAgW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgc2xvdHMgdGhpcyBlbGVtZW50IHdhcyBkaXN0cmlidXRlZCB0by5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8SFRNTFNsb3RFbGVtZW50Pn0gRGVzY3JpcHRpb25cbiAgICovXG4gIGdldERlc3RpbmF0aW9uSW5zZXJ0aW9uUG9pbnRzKCkge1xuICAgIGxldCBpcCQgPSBbXTtcbiAgICBsZXQgbiA9IHRoaXMubm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgd2hpbGUgKG4pIHtcbiAgICAgIGlwJC5wdXNoKG4pO1xuICAgICAgbiA9IG4uYXNzaWduZWRTbG90O1xuICAgIH1cbiAgICByZXR1cm4gaXAkO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxzIGBpbXBvcnROb2RlYCBvbiB0aGUgYG93bmVyRG9jdW1lbnRgIGZvciB0aGlzIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIGltcG9ydFxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRlZXAgVHJ1ZSBpZiB0aGUgbm9kZSBzaG91bGQgYmUgY2xvbmVkIGRlZXBseSBkdXJpbmdcbiAgICogICBpbXBvcnRcbiAgICogQHJldHVybiB7Tm9kZX0gQ2xvbmUgb2YgZ2l2ZW4gbm9kZSBpbXBvcnRlZCB0byB0aGlzIG93bmVyIGRvY3VtZW50XG4gICAqL1xuICBpbXBvcnROb2RlKG5vZGUsIGRlZXApIHtcbiAgICBsZXQgZG9jID0gdGhpcy5ub2RlIGluc3RhbmNlb2YgRG9jdW1lbnQgPyB0aGlzLm5vZGUgOlxuICAgICAgdGhpcy5ub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgcmV0dXJuIGRvYy5pbXBvcnROb2RlKG5vZGUsIGRlZXApO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGEgZmxhdHRlbmVkIGxpc3Qgb2YgYWxsIGNoaWxkIG5vZGVzIGFuZCBub2RlcyBhc3NpZ25lZFxuICAgKiB0byBjaGlsZCBzbG90cy5cbiAgICovXG4gIGdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKSB7XG4gICAgcmV0dXJuIEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIuZ2V0RmxhdHRlbmVkTm9kZXModGhpcy5ub2RlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmlsdGVyZWQgbGlzdCBvZiBmbGF0dGVuZWQgY2hpbGQgZWxlbWVudHMgZm9yIHRoaXMgZWxlbWVudCBiYXNlZFxuICAgKiBvbiB0aGUgZ2l2ZW4gc2VsZWN0b3IuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBmaWx0ZXIgbm9kZXMgYWdhaW5zdFxuICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59IExpc3Qgb2YgZmxhdHRlbmVkIGNoaWxkIGVsZW1lbnRzXG4gICAqL1xuICBxdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICBsZXQgYyQgPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICBsZXQgbGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGk9MCwgbD1jJC5sZW5ndGgsIGM7IChpPGwpICYmIChjPWMkW2ldKTsgaSsrKSB7XG4gICAgICBpZiAoKGMubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSAmJlxuICAgICAgICAgIG1hdGNoZXNTZWxlY3RvcihjLCBzZWxlY3RvcikpIHtcbiAgICAgICAgbGlzdC5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3Igc2hhZG93IHJvb3RzLCByZXR1cm5zIHRoZSBjdXJyZW50bHkgZm9jdXNlZCBlbGVtZW50IHdpdGhpbiB0aGlzXG4gICAqIHNoYWRvdyByb290LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfHVuZGVmaW5lZH0gQ3VycmVudGx5IGZvY3VzZWQgZWxlbWVudFxuICAgKi9cbiAgZ2V0IGFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgbGV0IG5vZGUgPSB0aGlzLm5vZGU7XG4gICAgcmV0dXJuIG5vZGUuX2FjdGl2ZUVsZW1lbnQgIT09IHVuZGVmaW5lZCA/IG5vZGUuX2FjdGl2ZUVsZW1lbnQgOiBub2RlLmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yd2FyZE1ldGhvZHMocHJvdG8sIG1ldGhvZHMpIHtcbiAgZm9yIChsZXQgaT0wOyBpIDwgbWV0aG9kcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBtZXRob2QgPSBtZXRob2RzW2ldO1xuICAgIHByb3RvW21ldGhvZF0gPSAvKiogQHRoaXMge0RvbUFwaX0gKi8gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlW21ldGhvZF0uYXBwbHkodGhpcy5ub2RlLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yd2FyZFJlYWRPbmx5UHJvcGVydGllcyhwcm90bywgcHJvcGVydGllcykge1xuICBmb3IgKGxldCBpPTA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG5hbWUgPSBwcm9wZXJ0aWVzW2ldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7RG9tQXBpfSAqLyAodGhpcykubm9kZVtuYW1lXTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3J3YXJkUHJvcGVydGllcyhwcm90bywgcHJvcGVydGllcykge1xuICBmb3IgKGxldCBpPTA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IG5hbWUgPSBwcm9wZXJ0aWVzW2ldO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7RG9tQXBpfSAqLyAodGhpcykubm9kZVtuYW1lXTtcbiAgICAgIH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8qKiBAdHlwZSB7RG9tQXBpfSAqLyAodGhpcykubm9kZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZvcndhcmRNZXRob2RzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgJ2Nsb25lTm9kZScsICdhcHBlbmRDaGlsZCcsICdpbnNlcnRCZWZvcmUnLCAncmVtb3ZlQ2hpbGQnLFxuICAncmVwbGFjZUNoaWxkJywgJ3NldEF0dHJpYnV0ZScsICdyZW1vdmVBdHRyaWJ1dGUnLFxuICAncXVlcnlTZWxlY3RvcicsICdxdWVyeVNlbGVjdG9yQWxsJ1xuXSk7XG5cbmZvcndhcmRSZWFkT25seVByb3BlcnRpZXMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAncGFyZW50Tm9kZScsICdmaXJzdENoaWxkJywgJ2xhc3RDaGlsZCcsXG4gICduZXh0U2libGluZycsICdwcmV2aW91c1NpYmxpbmcnLCAnZmlyc3RFbGVtZW50Q2hpbGQnLFxuICAnbGFzdEVsZW1lbnRDaGlsZCcsICduZXh0RWxlbWVudFNpYmxpbmcnLCAncHJldmlvdXNFbGVtZW50U2libGluZycsXG4gICdjaGlsZE5vZGVzJywgJ2NoaWxkcmVuJywgJ2NsYXNzTGlzdCdcbl0pO1xuXG5mb3J3YXJkUHJvcGVydGllcyhEb21BcGkucHJvdG90eXBlLCBbXG4gICd0ZXh0Q29udGVudCcsICdpbm5lckhUTUwnXG5dKTtcblxuXG4vKipcbiAqIEV2ZW50IEFQSSB3cmFwcGVyIGNsYXNzIHJldHVybmVkIGZyb20gYFBvbHltZXIuZG9tLih0YXJnZXQpYCB3aGVuXG4gKiBgdGFyZ2V0YCBpcyBhbiBgRXZlbnRgLlxuICovXG5jbGFzcyBFdmVudEFwaSB7XG4gIGNvbnN0cnVjdG9yKGV2ZW50KSB7XG4gICAgdGhpcy5ldmVudCA9IGV2ZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IG5vZGUgb24gdGhlIGBjb21wb3NlZFBhdGhgIG9mIHRoaXMgZXZlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRoZSBub2RlIHRoaXMgZXZlbnQgd2FzIGRpc3BhdGNoZWQgdG9cbiAgICovXG4gIGdldCByb290VGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50LmNvbXBvc2VkUGF0aCgpWzBdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxvY2FsIChyZS10YXJnZXRlZCkgdGFyZ2V0IGZvciB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbG9jYWwgKHJlLXRhcmdldGVkKSB0YXJnZXQgZm9yIHRoaXMgZXZlbnQuXG4gICAqL1xuICBnZXQgbG9jYWxUYXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnQudGFyZ2V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBjb21wb3NlZFBhdGhgIGZvciB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZ2V0IHBhdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gIH1cbn1cblxuZXhwb3J0IHsgRG9tQXBpIH07XG5cbmV4cG9ydCBjb25zdCBkb20gPSBmdW5jdGlvbihvYmopIHtcbiAgb2JqID0gb2JqIHx8IGRvY3VtZW50O1xuICBpZiAoIW9iai5fX2RvbUFwaSkge1xuICAgIGxldCBoZWxwZXI7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIEV2ZW50KSB7XG4gICAgICBoZWxwZXIgPSBuZXcgRXZlbnRBcGkob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGVscGVyID0gbmV3IERvbUFwaShvYmopO1xuICAgIH1cbiAgICBvYmouX19kb21BcGkgPSBoZWxwZXI7XG4gIH1cbiAgcmV0dXJuIG9iai5fX2RvbUFwaTtcbn07XG5cbmV4cG9ydCB7IG1hdGNoZXNTZWxlY3RvciB9O1xuZXhwb3J0IHsgZmx1c2gkMCBhcyBmbHVzaCB9O1xuZXhwb3J0IHsgZW5xdWV1ZURlYm91bmNlciBhcyBhZGREZWJvdW5jZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qc1xuLy8gbW9kdWxlIGlkID0gMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBDbGFzcyB9IGZyb20gJy4vY2xhc3MuanMnO1xuXG5leHBvcnQgY29uc3QgUG9seW1lciA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgLy8gaWYgaW5wdXQgaXMgYSBgY2xhc3NgIChha2EgYSBmdW5jdGlvbiB3aXRoIGEgcHJvdG90eXBlKSwgdXNlIHRoZSBwcm90b3R5cGVcbiAgLy8gcmVtZW1iZXIgdGhhdCB0aGUgYGNvbnN0cnVjdG9yYCB3aWxsIG5ldmVyIGJlIGNhbGxlZFxuICBsZXQga2xhc3M7XG4gIGlmICh0eXBlb2YgaW5mbyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGtsYXNzID0gaW5mbztcbiAgfSBlbHNlIHtcbiAgICBrbGFzcyA9IENsYXNzKGluZm8pO1xuICB9XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShrbGFzcy5pcywgLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovKGtsYXNzKSk7XG4gIHJldHVybiBrbGFzcztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qc1xuLy8gbW9kdWxlIGlkID0gM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8vIHVuaXF1ZSBnbG9iYWwgaWQgZm9yIGRlZHVwaW5nIG1peGlucy5cbmxldCBkZWR1cGVJZCA9IDA7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIE1peGluRnVuY3Rpb24oKXt9XG4vKiogQHR5cGUgeyhXZWFrTWFwIHwgdW5kZWZpbmVkKX0gKi9cbk1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4vKiogQHR5cGUgeyhPYmplY3QgfCB1bmRlZmluZWQpfSAqL1xuTWl4aW5GdW5jdGlvbi5wcm90b3R5cGUuX19taXhpblNldDtcblxuZXhwb3J0IGNvbnN0IGRlZHVwaW5nTWl4aW4gPSBmdW5jdGlvbihtaXhpbikge1xuICBsZXQgbWl4aW5BcHBsaWNhdGlvbnMgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucztcbiAgaWYgKCFtaXhpbkFwcGxpY2F0aW9ucykge1xuICAgIG1peGluQXBwbGljYXRpb25zID0gbmV3IFdlYWtNYXAoKTtcbiAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhtaXhpbikuX19taXhpbkFwcGxpY2F0aW9ucyA9IG1peGluQXBwbGljYXRpb25zO1xuICB9XG4gIC8vIG1haW50YWluIGEgdW5pcXVlIGlkIGZvciBlYWNoIG1peGluXG4gIGxldCBtaXhpbkRlZHVwZUlkID0gZGVkdXBlSWQrKztcbiAgZnVuY3Rpb24gZGVkdXBpbmdNaXhpbihiYXNlKSB7XG4gICAgbGV0IGJhc2VTZXQgPSAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhiYXNlKS5fX21peGluU2V0O1xuICAgIGlmIChiYXNlU2V0ICYmIGJhc2VTZXRbbWl4aW5EZWR1cGVJZF0pIHtcbiAgICAgIHJldHVybiBiYXNlO1xuICAgIH1cbiAgICBsZXQgbWFwID0gbWl4aW5BcHBsaWNhdGlvbnM7XG4gICAgbGV0IGV4dGVuZGVkID0gbWFwLmdldChiYXNlKTtcbiAgICBpZiAoIWV4dGVuZGVkKSB7XG4gICAgICBleHRlbmRlZCA9IC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyhtaXhpbikoYmFzZSk7XG4gICAgICBtYXAuc2V0KGJhc2UsIGV4dGVuZGVkKTtcbiAgICB9XG4gICAgLy8gY29weSBpbmhlcml0ZWQgbWl4aW4gc2V0IGZyb20gdGhlIGV4dGVuZGVkIGNsYXNzLCBvciB0aGUgYmFzZSBjbGFzc1xuICAgIC8vIE5PVEU6IHdlIGF2b2lkIHVzZSBvZiBTZXQgaGVyZSBiZWNhdXNlIHNvbWUgYnJvd3NlciAoSUUxMSlcbiAgICAvLyBjYW5ub3QgZXh0ZW5kIGEgYmFzZSBTZXQgdmlhIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBsZXQgbWl4aW5TZXQgPSBPYmplY3QuY3JlYXRlKC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0IHx8IGJhc2VTZXQgfHwgbnVsbCk7XG4gICAgbWl4aW5TZXRbbWl4aW5EZWR1cGVJZF0gPSB0cnVlO1xuICAgIC8qKiBAdHlwZSB7IU1peGluRnVuY3Rpb259ICovKGV4dGVuZGVkKS5fX21peGluU2V0ID0gbWl4aW5TZXQ7XG4gICAgcmV0dXJuIGV4dGVuZGVkO1xuICB9XG5cbiAgcmV0dXJuIGRlZHVwaW5nTWl4aW47XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvbWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgRWxlbWVudE1peGluIH0gZnJvbSAnLi9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uanMnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXIncyBtZXRhLXByb2dyYW1taW5nXG4gKiBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZywgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbixcbiAqIGFuZCBwcm9wZXJ0eSBjaGFuZ2Ugb2JzZXJ2YXRpb24uXG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBwb2x5bWVyXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkVsZW1lbnRNaXhpblxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgYmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzXG4gKiAgIGtleSBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzIGluY2x1ZGluZyB0ZW1wbGF0ZSBzdGFtcGluZywgZGF0YS1iaW5kaW5nLFxuICogICBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLCBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uXG4gKi9cbmNvbnN0IEVsZW1lbnQgPSBFbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpO1xuZXhwb3J0IHsgRWxlbWVudCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vKiogQHR5cGVkZWYge3tydW46IGZ1bmN0aW9uKGZ1bmN0aW9uKCksIG51bWJlcj0pOm51bWJlciwgY2FuY2VsOiBmdW5jdGlvbihudW1iZXIpfX0gKi9cbmxldCBBc3luY0ludGVyZmFjZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vLyBNaWNyb3Rhc2sgaW1wbGVtZW50ZWQgdXNpbmcgTXV0YXRpb24gT2JzZXJ2ZXJcbmxldCBtaWNyb3Rhc2tDdXJySGFuZGxlID0gMDtcbmxldCBtaWNyb3Rhc2tMYXN0SGFuZGxlID0gMDtcbmxldCBtaWNyb3Rhc2tDYWxsYmFja3MgPSBbXTtcbmxldCBtaWNyb3Rhc2tOb2RlQ29udGVudCA9IDA7XG5sZXQgbWljcm90YXNrTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbm5ldyB3aW5kb3cuTXV0YXRpb25PYnNlcnZlcihtaWNyb3Rhc2tGbHVzaCkub2JzZXJ2ZShtaWNyb3Rhc2tOb2RlLCB7Y2hhcmFjdGVyRGF0YTogdHJ1ZX0pO1xuXG5mdW5jdGlvbiBtaWNyb3Rhc2tGbHVzaCgpIHtcbiAgY29uc3QgbGVuID0gbWljcm90YXNrQ2FsbGJhY2tzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGxldCBjYiA9IG1pY3JvdGFza0NhbGxiYWNrc1tpXTtcbiAgICBpZiAoY2IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4geyB0aHJvdyBlOyB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbWljcm90YXNrQ2FsbGJhY2tzLnNwbGljZSgwLCBsZW4pO1xuICBtaWNyb3Rhc2tMYXN0SGFuZGxlICs9IGxlbjtcbn1cblxuZXhwb3J0IGNvbnN0IHRpbWVPdXQgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgc3ViLW1vZHVsZSB3aXRoIHRoZSBhc3luYyBpbnRlcmZhY2UgcHJvdmlkaW5nIHRoZSBwcm92aWRlZFxuICAgKiBkZWxheS5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsYXkgVGltZSB0byB3YWl0IGJlZm9yZSBjYWxsaW5nIGNhbGxiYWNrcyBpbiBtc1xuICAgKiBAcmV0dXJuIHtBc3luY0ludGVyZmFjZX0gQW4gYXN5bmMgdGltZW91dCBpbnRlcmZhY2VcbiAgICovXG4gIGFmdGVyKGRlbGF5KSB7XG4gICAgcmV0dXJuICB7XG4gICAgICBydW4oZm4pIHsgcmV0dXJuIHNldFRpbWVvdXQoZm4sIGRlbGF5KTsgfSxcbiAgICAgIGNhbmNlbDogd2luZG93LmNsZWFyVGltZW91dC5iaW5kKHdpbmRvdylcbiAgICB9O1xuICB9LFxuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgaW4gdGhlIG5leHQgdGFzay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bjogd2luZG93LnNldFRpbWVvdXQuYmluZCh3aW5kb3cpLFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYHRpbWVPdXRgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqL1xuICBjYW5jZWw6IHdpbmRvdy5jbGVhclRpbWVvdXQuYmluZCh3aW5kb3cpXG59O1xuXG5leHBvcnQgY29uc3QgYW5pbWF0aW9uRnJhbWUgPSB7XG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBgcmVxdWVzdEFuaW1hdGlvbkZyYW1lYCB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmFuaW1hdGlvbkZyYW1lXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuOiB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGBhbmltYXRpb25GcmFtZWAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICovXG4gIGNhbmNlbDogd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxufTtcblxuZXhwb3J0IGNvbnN0IGlkbGVQZXJpb2QgPSB7XG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBgcmVxdWVzdElkbGVDYWxsYmFja2AgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5pZGxlUGVyaW9kXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oSWRsZURlYWRsaW5lKX0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oZm4pIHtcbiAgICByZXR1cm4gd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2sgP1xuICAgICAgd2luZG93LnJlcXVlc3RJZGxlQ2FsbGJhY2soZm4pIDpcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGZuLCAxNik7XG4gIH0sXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgaWRsZVBlcmlvZGAgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLmlkbGVQZXJpb2RcbiAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBgcnVuYCBvZiBjYWxsYmFjayB0byBjYW5jZWxcbiAgICovXG4gIGNhbmNlbChoYW5kbGUpIHtcbiAgICB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrID9cbiAgICAgIHdpbmRvdy5jYW5jZWxJZGxlQ2FsbGJhY2soaGFuZGxlKSA6XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KGhhbmRsZSk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBtaWNyb1Rhc2sgPSB7XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGF0IG1pY3JvdGFzayB0aW1pbmcuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bihjYWxsYmFjaykge1xuICAgIG1pY3JvdGFza05vZGUudGV4dENvbnRlbnQgPSBtaWNyb3Rhc2tOb2RlQ29udGVudCsrO1xuICAgIG1pY3JvdGFza0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gbWljcm90YXNrQ3VyckhhbmRsZSsrO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgbWljcm9UYXNrYCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMubWljcm9UYXNrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgY29uc3QgaWR4ID0gaGFuZGxlIC0gbWljcm90YXNrTGFzdEhhbmRsZTtcbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGlmICghbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGFzeW5jIGhhbmRsZTogJyArIGhhbmRsZSk7XG4gICAgICB9XG4gICAgICBtaWNyb3Rhc2tDYWxsYmFja3NbaWR4XSA9IG51bGw7XG4gICAgfVxuICB9XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmNvbnN0IGNhc2VNYXAgPSB7fTtcbmNvbnN0IERBU0hfVE9fQ0FNRUwgPSAvLVthLXpdL2c7XG5jb25zdCBDQU1FTF9UT19EQVNIID0gLyhbQS1aXSkvZztcblxuZXhwb3J0IGZ1bmN0aW9uIGRhc2hUb0NhbWVsQ2FzZShkYXNoKSB7XG4gIHJldHVybiBjYXNlTWFwW2Rhc2hdIHx8IChcbiAgICBjYXNlTWFwW2Rhc2hdID0gZGFzaC5pbmRleE9mKCctJykgPCAwID8gZGFzaCA6IGRhc2gucmVwbGFjZShEQVNIX1RPX0NBTUVMLFxuICAgICAgKG0pID0+IG1bMV0udG9VcHBlckNhc2UoKVxuICAgIClcbiAgKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbWVsVG9EYXNoQ2FzZShjYW1lbCkge1xuICByZXR1cm4gY2FzZU1hcFtjYW1lbF0gfHwgKFxuICAgIGNhc2VNYXBbY2FtZWxdID0gY2FtZWwucmVwbGFjZShDQU1FTF9UT19EQVNILCAnLSQxJykudG9Mb3dlckNhc2UoKVxuICApO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuanNcbi8vIG1vZHVsZSBpZCA9IDdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuL2NvbG9yLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8Y3VzdG9tLXN0eWxlPlxuICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICBodG1sIHtcbiAgICAgIC8qXG4gICAgICAgKiBZb3UgY2FuIHVzZSB0aGVzZSBnZW5lcmljIHZhcmlhYmxlcyBpbiB5b3VyIGVsZW1lbnRzIGZvciBlYXN5IHRoZW1pbmcuXG4gICAgICAgKiBGb3IgZXhhbXBsZSwgaWYgYWxsIHlvdXIgZWxlbWVudHMgdXNlIFxcYC0tcHJpbWFyeS10ZXh0LWNvbG9yXFxgIGFzIGl0cyBtYWluXG4gICAgICAgKiBjb2xvciwgdGhlbiBzd2l0Y2hpbmcgZnJvbSBhIGxpZ2h0IHRvIGEgZGFyayB0aGVtZSBpcyBqdXN0IGEgbWF0dGVyIG9mXG4gICAgICAgKiBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgXFxgLS1wcmltYXJ5LXRleHQtY29sb3JcXGAgaW4geW91ciBhcHBsaWNhdGlvbi5cbiAgICAgICAqL1xuICAgICAgLS1wcmltYXJ5LXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXRleHQtY29sb3IpO1xuICAgICAgLS1wcmltYXJ5LWJhY2tncm91bmQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLWJhY2tncm91bmQtY29sb3IpO1xuICAgICAgLS1zZWNvbmRhcnktdGV4dC1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtc2Vjb25kYXJ5LWNvbG9yKTtcbiAgICAgIC0tZGlzYWJsZWQtdGV4dC1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtZGlzYWJsZWQtY29sb3IpO1xuICAgICAgLS1kaXZpZGVyLWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1kaXZpZGVyLWNvbG9yKTtcbiAgICAgIC0tZXJyb3ItY29sb3I6IHZhcigtLXBhcGVyLWRlZXAtb3JhbmdlLWE3MDApO1xuXG4gICAgICAvKlxuICAgICAgICogUHJpbWFyeSBhbmQgYWNjZW50IGNvbG9ycy4gQWxzbyBzZWUgY29sb3IuaHRtbCBmb3IgbW9yZSBjb2xvcnMuXG4gICAgICAgKi9cbiAgICAgIC0tcHJpbWFyeS1jb2xvcjogdmFyKC0tcGFwZXItaW5kaWdvLTUwMCk7XG4gICAgICAtLWxpZ2h0LXByaW1hcnktY29sb3I6IHZhcigtLXBhcGVyLWluZGlnby0xMDApO1xuICAgICAgLS1kYXJrLXByaW1hcnktY29sb3I6IHZhcigtLXBhcGVyLWluZGlnby03MDApO1xuXG4gICAgICAtLWFjY2VudC1jb2xvcjogdmFyKC0tcGFwZXItcGluay1hMjAwKTtcbiAgICAgIC0tbGlnaHQtYWNjZW50LWNvbG9yOiB2YXIoLS1wYXBlci1waW5rLWExMDApO1xuICAgICAgLS1kYXJrLWFjY2VudC1jb2xvcjogdmFyKC0tcGFwZXItcGluay1hNDAwKTtcblxuXG4gICAgICAvKlxuICAgICAgICogTWF0ZXJpYWwgRGVzaWduIExpZ2h0IGJhY2tncm91bmQgdGhlbWVcbiAgICAgICAqL1xuICAgICAgLS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yOiAjZmZmZmZmO1xuICAgICAgLS1saWdodC10aGVtZS1iYXNlLWNvbG9yOiAjMDAwMDAwO1xuICAgICAgLS1saWdodC10aGVtZS10ZXh0LWNvbG9yOiB2YXIoLS1wYXBlci1ncmV5LTkwMCk7XG4gICAgICAtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvcjogIzczNzM3MzsgIC8qIGZvciBzZWNvbmRhcnkgdGV4dCBhbmQgaWNvbnMgKi9cbiAgICAgIC0tbGlnaHQtdGhlbWUtZGlzYWJsZWQtY29sb3I6ICM5YjliOWI7ICAvKiBkaXNhYmxlZC9oaW50IHRleHQgKi9cbiAgICAgIC0tbGlnaHQtdGhlbWUtZGl2aWRlci1jb2xvcjogI2RiZGJkYjtcblxuICAgICAgLypcbiAgICAgICAqIE1hdGVyaWFsIERlc2lnbiBEYXJrIGJhY2tncm91bmQgdGhlbWVcbiAgICAgICAqL1xuICAgICAgLS1kYXJrLXRoZW1lLWJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLWdyZXktOTAwKTtcbiAgICAgIC0tZGFyay10aGVtZS1iYXNlLWNvbG9yOiAjZmZmZmZmO1xuICAgICAgLS1kYXJrLXRoZW1lLXRleHQtY29sb3I6ICNmZmZmZmY7XG4gICAgICAtLWRhcmstdGhlbWUtc2Vjb25kYXJ5LWNvbG9yOiAjYmNiY2JjOyAgLyogZm9yIHNlY29uZGFyeSB0ZXh0IGFuZCBpY29ucyAqL1xuICAgICAgLS1kYXJrLXRoZW1lLWRpc2FibGVkLWNvbG9yOiAjNjQ2NDY0OyAgLyogZGlzYWJsZWQvaGludCB0ZXh0ICovXG4gICAgICAtLWRhcmstdGhlbWUtZGl2aWRlci1jb2xvcjogIzNjM2MzYztcblxuICAgICAgLypcbiAgICAgICAqIERlcHJlY2F0ZWQgdmFsdWVzIGJlY2F1c2Ugb2YgdGhlaXIgY29uZnVzaW5nIG5hbWVzLlxuICAgICAgICovXG4gICAgICAtLXRleHQtcHJpbWFyeS1jb2xvcjogdmFyKC0tZGFyay10aGVtZS10ZXh0LWNvbG9yKTtcbiAgICAgIC0tZGVmYXVsdC1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wcmltYXJ5LWNvbG9yKTtcbiAgICB9XG4gIDwvc3R5bGU+XG48L2N1c3RvbS1zdHlsZT5gO1xuXG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuanNcbi8vIG1vZHVsZSBpZCA9IDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuaW1wb3J0IHsgcGF0aEZyb21VcmwgfSBmcm9tICcuL3Jlc29sdmUtdXJsLmpzJztcblxuLyoqXG4gKiBMZWdhY3kgc2V0dGluZ3MuXG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICovXG5jb25zdCBzZXR0aW5ncyA9IHVuZGVmaW5lZCB8fCB7fTtcbmV4cG9ydCBjb25zdCB1c2VTaGFkb3cgPSAhKHdpbmRvdy5TaGFkeURPTSk7XG5leHBvcnQgY29uc3QgdXNlTmF0aXZlQ1NTUHJvcGVydGllcyA9IEJvb2xlYW4oIXdpbmRvdy5TaGFkeUNTUyB8fCB3aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzKTtcbmV4cG9ydCBjb25zdCB1c2VOYXRpdmVDdXN0b21FbGVtZW50cyA9ICEod2luZG93LmN1c3RvbUVsZW1lbnRzLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2spO1xuZXhwb3J0IHsgc2V0dGluZ3MgYXMgU2V0dGluZ3MgfTtcblxuLyoqXG4gKiBHbG9iYWxseSBzZXR0YWJsZSBwcm9wZXJ0eSB0aGF0IGlzIGF1dG9tYXRpY2FsbHkgYXNzaWduZWQgdG9cbiAqIGBQb2x5bWVyLkVsZW1lbnRNaXhpbmAgaW5zdGFuY2VzLCB1c2VmdWwgZm9yIGJpbmRpbmcgaW4gdGVtcGxhdGVzIHRvXG4gKiBtYWtlIFVSTCdzIHJlbGF0aXZlIHRvIGFuIGFwcGxpY2F0aW9uJ3Mgcm9vdC4gIERlZmF1bHRzIHRvIHRoZSBtYWluXG4gKiBkb2N1bWVudCBVUkwsIGJ1dCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB1c2Vycy4gIEl0IG1heSBiZSB1c2VmdWwgdG8gc2V0XG4gKiBgUG9seW1lci5yb290UGF0aGAgdG8gcHJvdmlkZSBhIHN0YWJsZSBhcHBsaWNhdGlvbiBtb3VudCBwYXRoIHdoZW5cbiAqIHVzaW5nIGNsaWVudCBzaWRlIHJvdXRpbmcuXG4gKlxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xubGV0IHJvb3RQYXRoID0gdW5kZWZpbmVkIHx8XG4gIHBhdGhGcm9tVXJsKGRvY3VtZW50LmJhc2VVUkkgfHwgd2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG5leHBvcnQgeyByb290UGF0aCB9O1xuXG5leHBvcnQgY29uc3Qgc2V0Um9vdFBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJvb3RQYXRoID0gcGF0aDtcbn07XG5cbi8qKlxuICogQSBnbG9iYWwgY2FsbGJhY2sgdXNlZCB0byBzYW5pdGl6ZSBhbnkgdmFsdWUgYmVmb3JlIGluc2VydGluZyBpdCBpbnRvIHRoZSBET00uIFRoZSBjYWxsYmFjayBzaWduYXR1cmUgaXM6XG4gKlxuICogICAgIFBvbHltZXIgPSB7XG4gKiAgICAgICBzYW5pdGl6ZURPTVZhbHVlOiBmdW5jdGlvbih2YWx1ZSwgbmFtZSwgdHlwZSwgbm9kZSkgeyAuLi4gfVxuICogICAgIH1cbiAqXG4gKiBXaGVyZTpcbiAqXG4gKiBgdmFsdWVgIGlzIHRoZSB2YWx1ZSB0byBzYW5pdGl6ZS5cbiAqIGBuYW1lYCBpcyB0aGUgbmFtZSBvZiBhbiBhdHRyaWJ1dGUgb3IgcHJvcGVydHkgKGZvciBleGFtcGxlLCBocmVmKS5cbiAqIGB0eXBlYCBpbmRpY2F0ZXMgd2hlcmUgdGhlIHZhbHVlIGlzIGJlaW5nIGluc2VydGVkOiBvbmUgb2YgcHJvcGVydHksIGF0dHJpYnV0ZSwgb3IgdGV4dC5cbiAqIGBub2RlYCBpcyB0aGUgbm9kZSB3aGVyZSB0aGUgdmFsdWUgaXMgYmVpbmcgaW5zZXJ0ZWQuXG4gKlxuICogQHR5cGUgeyhmdW5jdGlvbigqLHN0cmluZyxzdHJpbmcsTm9kZSk6Kil8dW5kZWZpbmVkfVxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xubGV0IHNhbml0aXplRE9NVmFsdWUgPSB1bmRlZmluZWQ7XG5cbmV4cG9ydCB7IHNhbml0aXplRE9NVmFsdWUgfTtcblxuZXhwb3J0IGNvbnN0IHNldFNhbml0aXplRE9NVmFsdWUgPSBmdW5jdGlvbihuZXdTYW5pdGl6ZURPTVZhbHVlKSB7XG4gIHNhbml0aXplRE9NVmFsdWUgPSBuZXdTYW5pdGl6ZURPTVZhbHVlO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmpzXG4vLyBtb2R1bGUgaWQgPSA5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcblxubGV0IENTU19VUkxfUlggPSAvKHVybFxcKCkoW14pXSopKFxcKSkvZztcbmxldCBBQlNfVVJMID0gLyheXFwvKXwoXiMpfCheW1xcdy1cXGRdKjopLztcbmxldCB3b3JraW5nVVJMO1xubGV0IHJlc29sdmVEb2M7XG4vKipcbiAqIFJlc29sdmVzIHRoZSBnaXZlbiBVUkwgYWdhaW5zdCB0aGUgcHJvdmlkZWQgYGJhc2VVcmknLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSW5wdXQgVVJMIHRvIHJlc29sdmVcbiAqIEBwYXJhbSB7P3N0cmluZz19IGJhc2VVUkkgQmFzZSBVUkkgdG8gcmVzb2x2ZSB0aGUgVVJMIGFnYWluc3RcbiAqIEByZXR1cm4ge3N0cmluZ30gcmVzb2x2ZWQgVVJMXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVVcmwodXJsLCBiYXNlVVJJKSB7XG4gIGlmICh1cmwgJiYgQUJTX1VSTC50ZXN0KHVybCkpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIC8vIExhenkgZmVhdHVyZSBkZXRlY3Rpb24uXG4gIGlmICh3b3JraW5nVVJMID09PSB1bmRlZmluZWQpIHtcbiAgICB3b3JraW5nVVJMID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHUgPSBuZXcgVVJMKCdiJywgJ2h0dHA6Ly9hJyk7XG4gICAgICB1LnBhdGhuYW1lID0gJ2MlMjBkJztcbiAgICAgIHdvcmtpbmdVUkwgPSAodS5ocmVmID09PSAnaHR0cDovL2EvYyUyMGQnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBzaWxlbnRseSBmYWlsXG4gICAgfVxuICB9XG4gIGlmICghYmFzZVVSSSkge1xuICAgIGJhc2VVUkkgPSBkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB9XG4gIGlmICh3b3JraW5nVVJMKSB7XG4gICAgcmV0dXJuIChuZXcgVVJMKHVybCwgYmFzZVVSSSkpLmhyZWY7XG4gIH1cbiAgLy8gRmFsbGJhY2sgdG8gY3JlYXRpbmcgYW4gYW5jaG9yIGludG8gYSBkaXNjb25uZWN0ZWQgZG9jdW1lbnQuXG4gIGlmICghcmVzb2x2ZURvYykge1xuICAgIHJlc29sdmVEb2MgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ3RlbXAnKTtcbiAgICByZXNvbHZlRG9jLmJhc2UgPSByZXNvbHZlRG9jLmNyZWF0ZUVsZW1lbnQoJ2Jhc2UnKTtcbiAgICByZXNvbHZlRG9jLmhlYWQuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5iYXNlKTtcbiAgICByZXNvbHZlRG9jLmFuY2hvciA9IHJlc29sdmVEb2MuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHJlc29sdmVEb2MuYm9keS5hcHBlbmRDaGlsZChyZXNvbHZlRG9jLmFuY2hvcik7XG4gIH1cbiAgcmVzb2x2ZURvYy5iYXNlLmhyZWYgPSBiYXNlVVJJO1xuICByZXNvbHZlRG9jLmFuY2hvci5ocmVmID0gdXJsO1xuICByZXR1cm4gcmVzb2x2ZURvYy5hbmNob3IuaHJlZiB8fCB1cmw7XG5cbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhbnkgcmVsYXRpdmUgVVJMJ3MgaW4gdGhlIGdpdmVuIENTUyB0ZXh0IGFnYWluc3QgdGhlIHByb3ZpZGVkXG4gKiBgb3duZXJEb2N1bWVudGAncyBgYmFzZVVSSWAuXG4gKlxuICogQG1lbWJlcm9mIFBvbHltZXIuUmVzb2x2ZVVybFxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHQgQ1NTIHRleHQgdG8gcHJvY2Vzc1xuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgQmFzZSBVUkkgdG8gcmVzb2x2ZSB0aGUgVVJMIGFnYWluc3RcbiAqIEByZXR1cm4ge3N0cmluZ30gUHJvY2Vzc2VkIENTUyB0ZXh0IHdpdGggcmVzb2x2ZWQgVVJMJ3NcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNzcyhjc3NUZXh0LCBiYXNlVVJJKSB7XG4gIHJldHVybiBjc3NUZXh0LnJlcGxhY2UoQ1NTX1VSTF9SWCwgZnVuY3Rpb24obSwgcHJlLCB1cmwsIHBvc3QpIHtcbiAgICByZXR1cm4gcHJlICsgJ1xcJycgK1xuICAgICAgcmVzb2x2ZVVybCh1cmwucmVwbGFjZSgvW1wiJ10vZywgJycpLCBiYXNlVVJJKSArXG4gICAgICAnXFwnJyArIHBvc3Q7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBwYXRoIGZyb20gYSBnaXZlbiBgdXJsYC4gVGhlIHBhdGggaW5jbHVkZXMgdGhlIHRyYWlsaW5nXG4gKiBgL2AgZnJvbSB0aGUgdXJsLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgSW5wdXQgVVJMIHRvIHRyYW5zZm9ybVxuICogQHJldHVybiB7c3RyaW5nfSByZXNvbHZlZCBwYXRoXG4gKi9cbmZ1bmN0aW9uIHBhdGhGcm9tVXJsKHVybCkge1xuICByZXR1cm4gdXJsLnN1YnN0cmluZygwLCB1cmwubGFzdEluZGV4T2YoJy8nKSArIDEpO1xufVxuXG5leHBvcnQgeyByZXNvbHZlQ3NzIH07XG5leHBvcnQgeyByZXNvbHZlVXJsIH07XG5leHBvcnQgeyBwYXRoRnJvbVVybCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuanNcbi8vIG1vZHVsZSBpZCA9IDEwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGlzUGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLmluZGV4T2YoJy4nKSA+PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcm9vdChwYXRoKSB7XG4gIGxldCBkb3RJbmRleCA9IHBhdGguaW5kZXhPZignLicpO1xuICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbiAgcmV0dXJuIHBhdGguc2xpY2UoMCwgZG90SW5kZXgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB7XG4gIC8vICAgICBiYXNlLnN0YXJ0c1dpdGgocGF0aCArICcuJyk7XG4gIHJldHVybiBiYXNlLmluZGV4T2YocGF0aCArICcuJykgPT09IDA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0Rlc2NlbmRhbnQoYmFzZSwgcGF0aCkge1xuICAvLyAgICAgcGF0aC5zdGFydHNXaXRoKGJhc2UgKyAnLicpO1xuICByZXR1cm4gcGF0aC5pbmRleE9mKGJhc2UgKyAnLicpID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdHJhbnNsYXRlKGJhc2UsIG5ld0Jhc2UsIHBhdGgpIHtcbiAgcmV0dXJuIG5ld0Jhc2UgKyBwYXRoLnNsaWNlKGJhc2UubGVuZ3RoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1hdGNoZXMoYmFzZSwgcGF0aCkge1xuICByZXR1cm4gKGJhc2UgPT09IHBhdGgpIHx8XG4gICAgICAgICBpc0FuY2VzdG9yKGJhc2UsIHBhdGgpIHx8XG4gICAgICAgICBpc0Rlc2NlbmRhbnQoYmFzZSwgcGF0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUocGF0aCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IGk9MDsgaTxwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgYXJncyA9IHBhdGhbaV0udG9TdHJpbmcoKS5zcGxpdCgnLicpO1xuICAgICAgZm9yIChsZXQgaj0wOyBqPGFyZ3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhcmdzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcGF0aDtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3BsaXQocGF0aCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShwYXRoKSkge1xuICAgIHJldHVybiBub3JtYWxpemUocGF0aCkuc3BsaXQoJy4nKTtcbiAgfVxuICByZXR1cm4gcGF0aC50b1N0cmluZygpLnNwbGl0KCcuJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQocm9vdCwgcGF0aCwgaW5mbykge1xuICBsZXQgcHJvcCA9IHJvb3Q7XG4gIGxldCBwYXJ0cyA9IHNwbGl0KHBhdGgpO1xuICAvLyBMb29wIG92ZXIgcGF0aCBwYXJ0c1swLi5uLTFdIGFuZCBkZXJlZmVyZW5jZVxuICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIXByb3ApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICBwcm9wID0gcHJvcFtwYXJ0XTtcbiAgfVxuICBpZiAoaW5mbykge1xuICAgIGluZm8ucGF0aCA9IHBhcnRzLmpvaW4oJy4nKTtcbiAgfVxuICByZXR1cm4gcHJvcDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldChyb290LCBwYXRoLCB2YWx1ZSkge1xuICBsZXQgcHJvcCA9IHJvb3Q7XG4gIGxldCBwYXJ0cyA9IHNwbGl0KHBhdGgpO1xuICBsZXQgbGFzdCA9IHBhcnRzW3BhcnRzLmxlbmd0aC0xXTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICAvLyBMb29wIG92ZXIgcGF0aCBwYXJ0c1swLi5uLTJdIGFuZCBkZXJlZmVyZW5jZVxuICAgIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGgtMTsgaSsrKSB7XG4gICAgICBsZXQgcGFydCA9IHBhcnRzW2ldO1xuICAgICAgcHJvcCA9IHByb3BbcGFydF07XG4gICAgICBpZiAoIXByb3ApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXQgdmFsdWUgdG8gb2JqZWN0IGF0IGVuZCBvZiBwYXRoXG4gICAgcHJvcFtsYXN0XSA9IHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFNpbXBsZSBwcm9wZXJ0eSBzZXRcbiAgICBwcm9wW3BhdGhdID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzRGVlcCA9IGlzUGF0aDtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3BhdGguanNcbi8vIG1vZHVsZSBpZCA9IDExXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IHRpbWVPdXQgfSBmcm9tICcuL2FzeW5jLmpzJztcbmltcG9ydCB7IERlYm91bmNlciB9IGZyb20gJy4vZGVib3VuY2UuanMnO1xuXG4vLyBkZXRlY3QgbmF0aXZlIHRvdWNoIGFjdGlvbiBzdXBwb3J0XG5sZXQgSEFTX05BVElWRV9UQSA9IHR5cGVvZiBkb2N1bWVudC5oZWFkLnN0eWxlLnRvdWNoQWN0aW9uID09PSAnc3RyaW5nJztcbmxldCBHRVNUVVJFX0tFWSA9ICdfX3BvbHltZXJHZXN0dXJlcyc7XG5sZXQgSEFORExFRF9PQkogPSAnX19wb2x5bWVyR2VzdHVyZXNIYW5kbGVkJztcbmxldCBUT1VDSF9BQ1RJT04gPSAnX19wb2x5bWVyR2VzdHVyZXNUb3VjaEFjdGlvbic7XG4vLyByYWRpdXMgZm9yIHRhcCBhbmQgdHJhY2tcbmxldCBUQVBfRElTVEFOQ0UgPSAyNTtcbmxldCBUUkFDS19ESVNUQU5DRSA9IDU7XG4vLyBudW1iZXIgb2YgbGFzdCBOIHRyYWNrIHBvc2l0aW9ucyB0byBrZWVwXG5sZXQgVFJBQ0tfTEVOR1RIID0gMjtcblxuLy8gRGlzYWJsaW5nIFwibW91c2VcIiBoYW5kbGVycyBmb3IgMjUwMG1zIGlzIGVub3VnaFxubGV0IE1PVVNFX1RJTUVPVVQgPSAyNTAwO1xubGV0IE1PVVNFX0VWRU5UUyA9IFsnbW91c2Vkb3duJywgJ21vdXNlbW92ZScsICdtb3VzZXVwJywgJ2NsaWNrJ107XG4vLyBhbiBhcnJheSBvZiBiaXRtYXNrIHZhbHVlcyBmb3IgbWFwcGluZyBNb3VzZUV2ZW50LndoaWNoIHRvIE1vdXNlRXZlbnQuYnV0dG9uc1xubGV0IE1PVVNFX1dISUNIX1RPX0JVVFRPTlMgPSBbMCwgMSwgNCwgMl07XG5sZXQgTU9VU0VfSEFTX0JVVFRPTlMgPSAoZnVuY3Rpb24oKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBNb3VzZUV2ZW50KCd0ZXN0Jywge2J1dHRvbnM6IDF9KS5idXR0b25zID09PSAxO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59KSgpO1xuXG4vKiBlc2xpbnQgbm8tZW1wdHk6IFtcImVycm9yXCIsIHsgXCJhbGxvd0VtcHR5Q2F0Y2hcIjogdHJ1ZSB9XSAqL1xuLy8gY2hlY2sgZm9yIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzXG5sZXQgU1VQUE9SVFNfUEFTU0lWRSA9IGZhbHNlO1xuKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIGxldCBvcHRzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAncGFzc2l2ZScsIHtnZXQ6IGZ1bmN0aW9uKCkge1NVUFBPUlRTX1BBU1NJVkUgPSB0cnVlO319KTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2goZSkge31cbn0pKCk7XG5cbi8vIENoZWNrIGZvciB0b3VjaC1vbmx5IGRldmljZXNcbmxldCBJU19UT1VDSF9PTkxZID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvaVAoPzpbb2FdZHxob25lKXxBbmRyb2lkLyk7XG5cbmxldCBHZXN0dXJlUmVjb2duaXplciA9IGZ1bmN0aW9uKCl7fTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKXt9O1xuLyoqIEB0eXBlIHtmdW5jdGlvbihNb3VzZUV2ZW50KSB8IHVuZGVmaW5lZH0gKi9cbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZWRvd247XG4vKiogQHR5cGUgeyhmdW5jdGlvbihNb3VzZUV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2Vtb3ZlO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNldXA7XG4vKiogQHR5cGUgeyhmdW5jdGlvbihUb3VjaEV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2hzdGFydDtcbi8qKiBAdHlwZSB7KGZ1bmN0aW9uKFRvdWNoRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS50b3VjaG1vdmU7XG4vKiogQHR5cGUgeyhmdW5jdGlvbihUb3VjaEV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2hlbmQ7XG4vKiogQHR5cGUgeyhmdW5jdGlvbihNb3VzZUV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUuY2xpY2s7XG5cbi8vIHRvdWNoIHdpbGwgbWFrZSBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4vLyBgcHJldmVudERlZmF1bHRgIG9uIHRvdWNoZW5kIHdpbGwgY2FuY2VsIHRoZW0sXG4vLyBidXQgdGhpcyBicmVha3MgYDxpbnB1dD5gIGZvY3VzIGFuZCBsaW5rIGNsaWNrc1xuLy8gZGlzYWJsZSBtb3VzZSBoYW5kbGVycyBmb3IgTU9VU0VfVElNRU9VVCBtcyBhZnRlclxuLy8gYSB0b3VjaGVuZCB0byBpZ25vcmUgc3ludGhldGljIG1vdXNlIGV2ZW50c1xubGV0IG1vdXNlQ2FuY2VsbGVyID0gZnVuY3Rpb24obW91c2VFdmVudCkge1xuICAvLyBDaGVjayBmb3Igc291cmNlQ2FwYWJpbGl0aWVzLCB1c2VkIHRvIGRpc3Rpbmd1aXNoIHN5bnRoZXRpYyBldmVudHNcbiAgLy8gaWYgbW91c2VFdmVudCBkaWQgbm90IGNvbWUgZnJvbSBhIGRldmljZSB0aGF0IGZpcmVzIHRvdWNoIGV2ZW50cyxcbiAgLy8gaXQgd2FzIG1hZGUgYnkgYSByZWFsIG1vdXNlIGFuZCBzaG91bGQgYmUgY291bnRlZFxuICAvLyBodHRwOi8vd2ljZy5naXRodWIuaW8vSW5wdXREZXZpY2VDYXBhYmlsaXRpZXMvI2RvbS1pbnB1dGRldmljZWNhcGFiaWxpdGllcy1maXJlc3RvdWNoZXZlbnRzXG4gIGxldCBzYyA9IG1vdXNlRXZlbnQuc291cmNlQ2FwYWJpbGl0aWVzO1xuICBpZiAoc2MgJiYgIXNjLmZpcmVzVG91Y2hFdmVudHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc2tpcCBzeW50aGV0aWMgbW91c2UgZXZlbnRzXG4gIG1vdXNlRXZlbnRbSEFORExFRF9PQkpdID0ge3NraXA6IHRydWV9O1xuICAvLyBkaXNhYmxlIFwiZ2hvc3QgY2xpY2tzXCJcbiAgaWYgKG1vdXNlRXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xuICAgIGxldCBwYXRoID0gbW91c2VFdmVudC5jb21wb3NlZFBhdGggJiYgbW91c2VFdmVudC5jb21wb3NlZFBhdGgoKTtcbiAgICBpZiAocGF0aCkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwYXRoW2ldID09PSBQT0lOVEVSU1RBVEUubW91c2UudGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIG1vdXNlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBtb3VzZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IHNldHVwIFRydWUgdG8gYWRkLCBmYWxzZSB0byByZW1vdmUuXG4gKi9cbmZ1bmN0aW9uIHNldHVwVGVhcmRvd25Nb3VzZUNhbmNlbGxlcihzZXR1cCkge1xuICBsZXQgZXZlbnRzID0gSVNfVE9VQ0hfT05MWSA/IFsnY2xpY2snXSA6IE1PVVNFX0VWRU5UUztcbiAgZm9yIChsZXQgaSA9IDAsIGVuOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZW4gPSBldmVudHNbaV07XG4gICAgaWYgKHNldHVwKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKGVuLCBtb3VzZUNhbmNlbGxlciwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZW4sIG1vdXNlQ2FuY2VsbGVyLCB0cnVlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaWdub3JlTW91c2UoZSkge1xuICBpZiAoIVBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYikge1xuICAgIHNldHVwVGVhcmRvd25Nb3VzZUNhbmNlbGxlcih0cnVlKTtcbiAgfVxuICBsZXQgdW5zZXQgPSBmdW5jdGlvbigpIHtcbiAgICBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIoKTtcbiAgICBQT0lOVEVSU1RBVEUubW91c2UudGFyZ2V0ID0gbnVsbDtcbiAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IgPSBudWxsO1xuICB9O1xuICBQT0lOVEVSU1RBVEUubW91c2UudGFyZ2V0ID0gZS5jb21wb3NlZFBhdGgoKVswXTtcbiAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iID0gRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICBQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2JcbiAgICAgICwgdGltZU91dC5hZnRlcihNT1VTRV9USU1FT1VUKVxuICAgICAgLCB1bnNldCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldiBldmVudCB0byB0ZXN0IGZvciBsZWZ0IG1vdXNlIGJ1dHRvbiBkb3duXG4gKiBAcmV0dXJuIHtib29sZWFufSBoYXMgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICovXG5mdW5jdGlvbiBoYXNMZWZ0TW91c2VCdXR0b24oZXYpIHtcbiAgbGV0IHR5cGUgPSBldi50eXBlO1xuICAvLyBleGl0IGVhcmx5IGlmIHRoZSBldmVudCBpcyBub3QgYSBtb3VzZSBldmVudFxuICBpZiAoTU9VU0VfRVZFTlRTLmluZGV4T2YodHlwZSkgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vIGV2LmJ1dHRvbiBpcyBub3QgcmVsaWFibGUgZm9yIG1vdXNlbW92ZSAoMCBpcyBvdmVybG9hZGVkIGFzIGJvdGggbGVmdCBidXR0b24gYW5kIG5vIGJ1dHRvbnMpXG4gIC8vIGluc3RlYWQgd2UgdXNlIGV2LmJ1dHRvbnMgKGJpdG1hc2sgb2YgYnV0dG9ucykgb3IgZmFsbCBiYWNrIHRvIGV2LndoaWNoIChkZXByZWNhdGVkLCAwIGZvciBubyBidXR0b25zLCAxIGZvciBsZWZ0IGJ1dHRvbilcbiAgaWYgKHR5cGUgPT09ICdtb3VzZW1vdmUnKSB7XG4gICAgLy8gYWxsb3cgdW5kZWZpbmVkIGZvciB0ZXN0aW5nIGV2ZW50c1xuICAgIGxldCBidXR0b25zID0gZXYuYnV0dG9ucyA9PT0gdW5kZWZpbmVkID8gMSA6IGV2LmJ1dHRvbnM7XG4gICAgaWYgKChldiBpbnN0YW5jZW9mIHdpbmRvdy5Nb3VzZUV2ZW50KSAmJiAhTU9VU0VfSEFTX0JVVFRPTlMpIHtcbiAgICAgIGJ1dHRvbnMgPSBNT1VTRV9XSElDSF9UT19CVVRUT05TW2V2LndoaWNoXSB8fCAwO1xuICAgIH1cbiAgICAvLyBidXR0b25zIGlzIGEgYml0bWFzaywgY2hlY2sgdGhhdCB0aGUgbGVmdCBidXR0b24gYml0IGlzIHNldCAoMSlcbiAgICByZXR1cm4gQm9vbGVhbihidXR0b25zICYgMSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gYWxsb3cgdW5kZWZpbmVkIGZvciB0ZXN0aW5nIGV2ZW50c1xuICAgIGxldCBidXR0b24gPSBldi5idXR0b24gPT09IHVuZGVmaW5lZCA/IDAgOiBldi5idXR0b247XG4gICAgLy8gZXYuYnV0dG9uIGlzIDAgaW4gbW91c2Vkb3duL21vdXNldXAvY2xpY2sgZm9yIGxlZnQgYnV0dG9uIGFjdGl2YXRpb25cbiAgICByZXR1cm4gYnV0dG9uID09PSAwO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU3ludGhldGljQ2xpY2soZXYpIHtcbiAgaWYgKGV2LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAvLyBldi5kZXRhaWwgaXMgMCBmb3IgSFRNTEVsZW1lbnQuY2xpY2sgaW4gbW9zdCBicm93c2Vyc1xuICAgIGlmIChldi5kZXRhaWwgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBpbiB0aGUgd29yc3QgY2FzZSwgY2hlY2sgdGhhdCB0aGUgeC95IHBvc2l0aW9uIG9mIHRoZSBjbGljayBpcyB3aXRoaW5cbiAgICAvLyB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50XG4gICAgLy8gVGhhbmtzIElFIDEwID46KFxuICAgIGxldCB0ID0gX2ZpbmRPcmlnaW5hbFRhcmdldChldik7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSB0YXJnZXQgb2YgdGhlIGV2ZW50IGlzIGFuIGVsZW1lbnQgc28gd2UgY2FuIHVzZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QsXG4gICAgLy8gaWYgbm90LCBqdXN0IGFzc3VtZSBpdCBpcyBhIHN5bnRoZXRpYyBjbGlja1xuICAgIGlmICghdC5ub2RlVHlwZSB8fCAvKiogQHR5cGUge0VsZW1lbnR9ICovKHQpLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBiY3IgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovKHQpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIC8vIHVzZSBwYWdlIHgveSB0byBhY2NvdW50IGZvciBzY3JvbGxpbmdcbiAgICBsZXQgeCA9IGV2LnBhZ2VYLCB5ID0gZXYucGFnZVk7XG4gICAgLy8gZXYgaXMgYSBzeW50aGV0aWMgY2xpY2sgaWYgdGhlIHBvc2l0aW9uIGlzIG91dHNpZGUgdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGFyZ2V0XG4gICAgcmV0dXJuICEoKHggPj0gYmNyLmxlZnQgJiYgeCA8PSBiY3IucmlnaHQpICYmICh5ID49IGJjci50b3AgJiYgeSA8PSBiY3IuYm90dG9tKSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5sZXQgUE9JTlRFUlNUQVRFID0ge1xuICBtb3VzZToge1xuICAgIHRhcmdldDogbnVsbCxcbiAgICBtb3VzZUlnbm9yZUpvYjogbnVsbFxuICB9LFxuICB0b3VjaDoge1xuICAgIHg6IDAsXG4gICAgeTogMCxcbiAgICBpZDogLTEsXG4gICAgc2Nyb2xsRGVjaWRlZDogZmFsc2VcbiAgfVxufTtcblxuZnVuY3Rpb24gZmlyc3RUb3VjaEFjdGlvbihldikge1xuICBsZXQgdGEgPSAnYXV0byc7XG4gIGxldCBwYXRoID0gZXYuY29tcG9zZWRQYXRoICYmIGV2LmNvbXBvc2VkUGF0aCgpO1xuICBpZiAocGF0aCkge1xuICAgIGZvciAobGV0IGkgPSAwLCBuOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbiA9IHBhdGhbaV07XG4gICAgICBpZiAobltUT1VDSF9BQ1RJT05dKSB7XG4gICAgICAgIHRhID0gbltUT1VDSF9BQ1RJT05dO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhO1xufVxuXG5mdW5jdGlvbiB0cmFja0RvY3VtZW50KHN0YXRlT2JqLCBtb3ZlZm4sIHVwZm4pIHtcbiAgc3RhdGVPYmoubW92ZWZuID0gbW92ZWZuO1xuICBzdGF0ZU9iai51cGZuID0gdXBmbjtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW92ZWZuKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHVwZm4pO1xufVxuXG5mdW5jdGlvbiB1bnRyYWNrRG9jdW1lbnQoc3RhdGVPYmopIHtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgc3RhdGVPYmoubW92ZWZuKTtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHN0YXRlT2JqLnVwZm4pO1xuICBzdGF0ZU9iai5tb3ZlZm4gPSBudWxsO1xuICBzdGF0ZU9iai51cGZuID0gbnVsbDtcbn1cblxuLy8gdXNlIGEgZG9jdW1lbnQtd2lkZSB0b3VjaGVuZCBsaXN0ZW5lciB0byBzdGFydCB0aGUgZ2hvc3QtY2xpY2sgcHJldmVudGlvbiBtZWNoYW5pc21cbi8vIFVzZSBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgaWYgc3VwcG9ydGVkLCB0byBub3QgYWZmZWN0IHNjcm9sbGluZyBwZXJmb3JtYW5jZVxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBpZ25vcmVNb3VzZSwgU1VQUE9SVFNfUEFTU0lWRSA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlKTtcblxuZXhwb3J0IGNvbnN0IGdlc3R1cmVzID0ge307XG5leHBvcnQgY29uc3QgcmVjb2duaXplcnMgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIGRlZXBUYXJnZXRGaW5kKHgsIHkpIHtcbiAgbGV0IG5vZGUgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICBsZXQgbmV4dCA9IG5vZGU7XG4gIC8vIHRoaXMgY29kZSBwYXRoIGlzIG9ubHkgdGFrZW4gd2hlbiBuYXRpdmUgU2hhZG93RE9NIGlzIHVzZWRcbiAgLy8gaWYgdGhlcmUgaXMgYSBzaGFkb3dyb290LCBpdCBtYXkgaGF2ZSBhIG5vZGUgYXQgeC95XG4gIC8vIGlmIHRoZXJlIGlzIG5vdCBhIHNoYWRvd3Jvb3QsIGV4aXQgdGhlIGxvb3BcbiAgd2hpbGUgKG5leHQgJiYgbmV4dC5zaGFkb3dSb290ICYmICF3aW5kb3cuU2hhZHlET00pIHtcbiAgICAvLyBpZiB0aGVyZSBpcyBhIG5vZGUgYXQgeC95IGluIHRoZSBzaGFkb3dyb290LCBsb29rIGRlZXBlclxuICAgIGxldCBvbGROZXh0ID0gbmV4dDtcbiAgICBuZXh0ID0gbmV4dC5zaGFkb3dSb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgLy8gb24gU2FmYXJpLCBlbGVtZW50RnJvbVBvaW50IG1heSByZXR1cm4gdGhlIHNoYWRvd1Jvb3QgaG9zdFxuICAgIGlmIChvbGROZXh0ID09PSBuZXh0KSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKG5leHQpIHtcbiAgICAgIG5vZGUgPSBuZXh0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maW5kT3JpZ2luYWxUYXJnZXQoZXYpIHtcbiAgLy8gc2hhZG93ZG9tXG4gIGlmIChldi5jb21wb3NlZFBhdGgpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtFdmVudFRhcmdldH0gKi8oZXYuY29tcG9zZWRQYXRoKClbMF0pO1xuICB9XG4gIC8vIHNoYWR5ZG9tXG4gIHJldHVybiBldi50YXJnZXQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfaGFuZGxlTmF0aXZlKGV2KSB7XG4gIGxldCBoYW5kbGVkO1xuICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gIGxldCBub2RlID0gZXYuY3VycmVudFRhcmdldDtcbiAgbGV0IGdvYmogPSBub2RlW0dFU1RVUkVfS0VZXTtcbiAgaWYgKCFnb2JqKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBncyA9IGdvYmpbdHlwZV07XG4gIGlmICghZ3MpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCFldltIQU5ETEVEX09CSl0pIHtcbiAgICBldltIQU5ETEVEX09CSl0gPSB7fTtcbiAgICBpZiAodHlwZS5zbGljZSgwLCA1KSA9PT0gJ3RvdWNoJykge1xuICAgICAgZXYgPSAvKiogQHR5cGUge1RvdWNoRXZlbnR9ICovKGV2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWFzc2lnblxuICAgICAgbGV0IHQgPSBldi5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgLy8gb25seSBoYW5kbGUgdGhlIGZpcnN0IGZpbmdlclxuICAgICAgICBpZiAoZXYudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICBQT0lOVEVSU1RBVEUudG91Y2guaWQgPSB0LmlkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChQT0lOVEVSU1RBVEUudG91Y2guaWQgIT09IHQuaWRlbnRpZmllcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIUhBU19OQVRJVkVfVEEpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCB0eXBlID09PSAndG91Y2htb3ZlJykge1xuICAgICAgICAgIF9oYW5kbGVUb3VjaEFjdGlvbihldik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlZCA9IGV2W0hBTkRMRURfT0JKXTtcbiAgLy8gdXNlZCB0byBpZ25vcmUgc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICBpZiAoaGFuZGxlZC5za2lwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHJlc2V0IHJlY29nbml6ZXIgc3RhdGVcbiAgZm9yIChsZXQgaSA9IDAsIHI7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgIHIgPSByZWNvZ25pemVyc1tpXTtcbiAgICBpZiAoZ3Nbci5uYW1lXSAmJiAhaGFuZGxlZFtyLm5hbWVdKSB7XG4gICAgICBpZiAoci5mbG93ICYmIHIuZmxvdy5zdGFydC5pbmRleE9mKGV2LnR5cGUpID4gLTEgJiYgci5yZXNldCkge1xuICAgICAgICByLnJlc2V0KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGVuZm9yY2UgZ2VzdHVyZSByZWNvZ25pemVyIG9yZGVyXG4gIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgaWYgKGdzW3IubmFtZV0gJiYgIWhhbmRsZWRbci5uYW1lXSkge1xuICAgICAgaGFuZGxlZFtyLm5hbWVdID0gdHJ1ZTtcbiAgICAgIHJbdHlwZV0oZXYpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX2hhbmRsZVRvdWNoQWN0aW9uKGV2KSB7XG4gIGxldCB0ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF07XG4gIGxldCB0eXBlID0gZXYudHlwZTtcbiAgaWYgKHR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgIFBPSU5URVJTVEFURS50b3VjaC54ID0gdC5jbGllbnRYO1xuICAgIFBPSU5URVJTVEFURS50b3VjaC55ID0gdC5jbGllbnRZO1xuICAgIFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICBpZiAoUE9JTlRFUlNUQVRFLnRvdWNoLnNjcm9sbERlY2lkZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUE9JTlRFUlNUQVRFLnRvdWNoLnNjcm9sbERlY2lkZWQgPSB0cnVlO1xuICAgIGxldCB0YSA9IGZpcnN0VG91Y2hBY3Rpb24oZXYpO1xuICAgIGxldCBwcmV2ZW50ID0gZmFsc2U7XG4gICAgbGV0IGR4ID0gTWF0aC5hYnMoUE9JTlRFUlNUQVRFLnRvdWNoLnggLSB0LmNsaWVudFgpO1xuICAgIGxldCBkeSA9IE1hdGguYWJzKFBPSU5URVJTVEFURS50b3VjaC55IC0gdC5jbGllbnRZKTtcbiAgICBpZiAoIWV2LmNhbmNlbGFibGUpIHtcbiAgICAgIC8vIHNjcm9sbGluZyBpcyBoYXBwZW5pbmdcbiAgICB9IGVsc2UgaWYgKHRhID09PSAnbm9uZScpIHtcbiAgICAgIHByZXZlbnQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAodGEgPT09ICdwYW4teCcpIHtcbiAgICAgIHByZXZlbnQgPSBkeSA+IGR4O1xuICAgIH0gZWxzZSBpZiAodGEgPT09ICdwYW4teScpIHtcbiAgICAgIHByZXZlbnQgPSBkeCA+IGR5O1xuICAgIH1cbiAgICBpZiAocHJldmVudCkge1xuICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmVudCgndHJhY2snKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZExpc3RlbmVyKG5vZGUsIGV2VHlwZSwgaGFuZGxlcikge1xuICBpZiAoZ2VzdHVyZXNbZXZUeXBlXSkge1xuICAgIF9hZGQobm9kZSwgZXZUeXBlLCBoYW5kbGVyKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKGdlc3R1cmVzW2V2VHlwZV0pIHtcbiAgICBfcmVtb3ZlKG5vZGUsIGV2VHlwZSwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2FkZChub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgbGV0IHJlY29nbml6ZXIgPSBnZXN0dXJlc1tldlR5cGVdO1xuICBsZXQgZGVwcyA9IHJlY29nbml6ZXIuZGVwcztcbiAgbGV0IG5hbWUgPSByZWNvZ25pemVyLm5hbWU7XG4gIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gIGlmICghZ29iaikge1xuICAgIG5vZGVbR0VTVFVSRV9LRVldID0gZ29iaiA9IHt9O1xuICB9XG4gIGZvciAobGV0IGkgPSAwLCBkZXAsIGdkOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgIGRlcCA9IGRlcHNbaV07XG4gICAgLy8gZG9uJ3QgYWRkIG1vdXNlIGhhbmRsZXJzIG9uIGlPUyBiZWNhdXNlIHRoZXkgY2F1c2UgZ3JheSBzZWxlY3Rpb24gb3ZlcmxheXNcbiAgICBpZiAoSVNfVE9VQ0hfT05MWSAmJiBNT1VTRV9FVkVOVFMuaW5kZXhPZihkZXApID4gLTEgJiYgZGVwICE9PSAnY2xpY2snKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgZ2QgPSBnb2JqW2RlcF07XG4gICAgaWYgKCFnZCkge1xuICAgICAgZ29ialtkZXBdID0gZ2QgPSB7X2NvdW50OiAwfTtcbiAgICB9XG4gICAgaWYgKGdkLl9jb3VudCA9PT0gMCkge1xuICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGRlcCwgX2hhbmRsZU5hdGl2ZSk7XG4gICAgfVxuICAgIGdkW25hbWVdID0gKGdkW25hbWVdIHx8IDApICsgMTtcbiAgICBnZC5fY291bnQgPSAoZ2QuX2NvdW50IHx8IDApICsgMTtcbiAgfVxuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZUeXBlLCBoYW5kbGVyKTtcbiAgaWYgKHJlY29nbml6ZXIudG91Y2hBY3Rpb24pIHtcbiAgICBzZXRUb3VjaEFjdGlvbihub2RlLCByZWNvZ25pemVyLnRvdWNoQWN0aW9uKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX3JlbW92ZShub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgbGV0IHJlY29nbml6ZXIgPSBnZXN0dXJlc1tldlR5cGVdO1xuICBsZXQgZGVwcyA9IHJlY29nbml6ZXIuZGVwcztcbiAgbGV0IG5hbWUgPSByZWNvZ25pemVyLm5hbWU7XG4gIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gIGlmIChnb2JqKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGRlcCwgZ2Q7IGkgPCBkZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXAgPSBkZXBzW2ldO1xuICAgICAgZ2QgPSBnb2JqW2RlcF07XG4gICAgICBpZiAoZ2QgJiYgZ2RbbmFtZV0pIHtcbiAgICAgICAgZ2RbbmFtZV0gPSAoZ2RbbmFtZV0gfHwgMSkgLSAxO1xuICAgICAgICBnZC5fY291bnQgPSAoZ2QuX2NvdW50IHx8IDEpIC0gMTtcbiAgICAgICAgaWYgKGdkLl9jb3VudCA9PT0gMCkge1xuICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihkZXAsIF9oYW5kbGVOYXRpdmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldlR5cGUsIGhhbmRsZXIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0ZXIocmVjb2cpIHtcbiAgcmVjb2duaXplcnMucHVzaChyZWNvZyk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgcmVjb2cuZW1pdHMubGVuZ3RoOyBpKyspIHtcbiAgICBnZXN0dXJlc1tyZWNvZy5lbWl0c1tpXV0gPSByZWNvZztcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX2ZpbmRSZWNvZ25pemVyQnlFdmVudChldk5hbWUpIHtcbiAgZm9yIChsZXQgaSA9IDAsIHI7IGkgPCByZWNvZ25pemVycy5sZW5ndGg7IGkrKykge1xuICAgIHIgPSByZWNvZ25pemVyc1tpXTtcbiAgICBmb3IgKGxldCBqID0gMCwgbjsgaiA8IHIuZW1pdHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIG4gPSByLmVtaXRzW2pdO1xuICAgICAgaWYgKG4gPT09IGV2TmFtZSkge1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRUb3VjaEFjdGlvbihub2RlLCB2YWx1ZSkge1xuICBpZiAoSEFTX05BVElWRV9UQSkge1xuICAgIG5vZGUuc3R5bGUudG91Y2hBY3Rpb24gPSB2YWx1ZTtcbiAgfVxuICBub2RlW1RPVUNIX0FDVElPTl0gPSB2YWx1ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maXJlKHRhcmdldCwgdHlwZSwgZGV0YWlsKSB7XG4gIGxldCBldiA9IG5ldyBFdmVudCh0eXBlLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUsIGNvbXBvc2VkOiB0cnVlIH0pO1xuICBldi5kZXRhaWwgPSBkZXRhaWw7XG4gIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2KTtcbiAgLy8gZm9yd2FyZCBgcHJldmVudERlZmF1bHRgIGluIGEgY2xlYW4gd2F5XG4gIGlmIChldi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgbGV0IHByZXZlbnRlciA9IGRldGFpbC5wcmV2ZW50ZXIgfHwgZGV0YWlsLnNvdXJjZUV2ZW50O1xuICAgIGlmIChwcmV2ZW50ZXIgJiYgcHJldmVudGVyLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICBwcmV2ZW50ZXIucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZXZlbnQoZXZOYW1lKSB7XG4gIGxldCByZWNvZ25pemVyID0gX2ZpbmRSZWNvZ25pemVyQnlFdmVudChldk5hbWUpO1xuICBpZiAocmVjb2duaXplci5pbmZvKSB7XG4gICAgcmVjb2duaXplci5pbmZvLnByZXZlbnQgPSB0cnVlO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldE1vdXNlQ2FuY2VsbGVyKCkge1xuICBpZiAoUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iKSB7XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iLmZsdXNoKCk7XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cblxucmVnaXN0ZXIoe1xuICBuYW1lOiAnZG93bnVwJyxcbiAgZGVwczogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCcsICd0b3VjaGVuZCddLFxuICBmbG93OiB7XG4gICAgc3RhcnQ6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSxcbiAgICBlbmQ6IFsnbW91c2V1cCcsICd0b3VjaGVuZCddXG4gIH0sXG4gIGVtaXRzOiBbJ2Rvd24nLCAndXAnXSxcblxuICBpbmZvOiB7XG4gICAgbW92ZWZuOiBudWxsLFxuICAgIHVwZm46IG51bGxcbiAgfSxcblxuICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgdW50cmFja0RvY3VtZW50KHRoaXMuaW5mbyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAqL1xuICBtb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBtb3ZlZm4gPSBmdW5jdGlvbiBtb3ZlZm4oZSkge1xuICAgICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgc2VsZi5fZmlyZSgndXAnLCB0LCBlKTtcbiAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgdXBmbiA9IGZ1bmN0aW9uIHVwZm4oZSkge1xuICAgICAgaWYgKGhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICBzZWxmLl9maXJlKCd1cCcsIHQsIGUpO1xuICAgICAgfVxuICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgfTtcbiAgICB0cmFja0RvY3VtZW50KHRoaXMuaW5mbywgbW92ZWZuLCB1cGZuKTtcbiAgICB0aGlzLl9maXJlKCdkb3duJywgdCwgZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuX2ZpcmUoJ2Rvd24nLCBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpLCBlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaGVuZDogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuX2ZpcmUoJ3VwJywgX2ZpbmRPcmlnaW5hbFRhcmdldChlKSwgZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJldmVudGVyXG4gICAqL1xuICBfZmlyZTogZnVuY3Rpb24odHlwZSwgdGFyZ2V0LCBldmVudCwgcHJldmVudGVyKSB7XG4gICAgX2ZpcmUodGFyZ2V0LCB0eXBlLCB7XG4gICAgICB4OiBldmVudC5jbGllbnRYLFxuICAgICAgeTogZXZlbnQuY2xpZW50WSxcbiAgICAgIHNvdXJjZUV2ZW50OiBldmVudCxcbiAgICAgIHByZXZlbnRlcjogcHJldmVudGVyLFxuICAgICAgcHJldmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gcHJldmVudChlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufSk7XG5cbnJlZ2lzdGVyKHtcbiAgbmFtZTogJ3RyYWNrJyxcbiAgdG91Y2hBY3Rpb246ICdub25lJyxcbiAgZGVwczogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnXSxcbiAgZmxvdzoge1xuICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgZW5kOiBbJ21vdXNldXAnLCAndG91Y2hlbmQnXVxuICB9LFxuICBlbWl0czogWyd0cmFjayddLFxuXG4gIGluZm86IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgc3RhdGU6ICdzdGFydCcsXG4gICAgc3RhcnRlZDogZmFsc2UsXG4gICAgbW92ZXM6IFtdLFxuICAgIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gICAgYWRkTW92ZTogZnVuY3Rpb24obW92ZSkge1xuICAgICAgaWYgKHRoaXMubW92ZXMubGVuZ3RoID4gVFJBQ0tfTEVOR1RIKSB7XG4gICAgICAgIHRoaXMubW92ZXMuc2hpZnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW92ZXMucHVzaChtb3ZlKTtcbiAgICB9LFxuICAgIG1vdmVmbjogbnVsbCxcbiAgICB1cGZuOiBudWxsLFxuICAgIHByZXZlbnQ6IGZhbHNlXG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5mby5zdGF0ZSA9ICdzdGFydCc7XG4gICAgdGhpcy5pbmZvLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmluZm8ubW92ZXMgPSBbXTtcbiAgICB0aGlzLmluZm8ueCA9IDA7XG4gICAgdGhpcy5pbmZvLnkgPSAwO1xuICAgIHRoaXMuaW5mby5wcmV2ZW50ID0gZmFsc2U7XG4gICAgdW50cmFja0RvY3VtZW50KHRoaXMuaW5mbyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc01vdmVkRW5vdWdoOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgaWYgKHRoaXMuaW5mby5wcmV2ZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLmluZm8uc3RhcnRlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGxldCBkeCA9IE1hdGguYWJzKHRoaXMuaW5mby54IC0geCk7XG4gICAgbGV0IGR5ID0gTWF0aC5hYnModGhpcy5pbmZvLnkgLSB5KTtcbiAgICByZXR1cm4gKGR4ID49IFRSQUNLX0RJU1RBTkNFIHx8IGR5ID49IFRSQUNLX0RJU1RBTkNFKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAqL1xuICBtb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCBtb3ZlZm4gPSBmdW5jdGlvbiBtb3ZlZm4oZSkge1xuICAgICAgbGV0IHggPSBlLmNsaWVudFgsIHkgPSBlLmNsaWVudFk7XG4gICAgICBpZiAoc2VsZi5oYXNNb3ZlZEVub3VnaCh4LCB5KSkge1xuICAgICAgICAvLyBmaXJzdCBtb3ZlIGlzICdzdGFydCcsIHN1YnNlcXVlbnQgbW92ZXMgYXJlICdtb3ZlJywgbW91c2V1cCBpcyAnZW5kJ1xuICAgICAgICBzZWxmLmluZm8uc3RhdGUgPSBzZWxmLmluZm8uc3RhcnRlZCA/IChlLnR5cGUgPT09ICdtb3VzZXVwJyA/ICdlbmQnIDogJ3RyYWNrJykgOiAnc3RhcnQnO1xuICAgICAgICBpZiAoc2VsZi5pbmZvLnN0YXRlID09PSAnc3RhcnQnKSB7XG4gICAgICAgICAgLy8gaWYgYW5kIG9ubHkgaWYgdHJhY2tpbmcsIGFsd2F5cyBwcmV2ZW50IHRhcFxuICAgICAgICAgIHByZXZlbnQoJ3RhcCcpO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuaW5mby5hZGRNb3ZlKHt4OiB4LCB5OiB5fSk7XG4gICAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgICAgLy8gYWx3YXlzIF9maXJlIFwiZW5kXCJcbiAgICAgICAgICBzZWxmLmluZm8uc3RhdGUgPSAnZW5kJztcbiAgICAgICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLl9maXJlKHQsIGUpO1xuICAgICAgICBzZWxmLmluZm8uc3RhcnRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfTtcbiAgICBsZXQgdXBmbiA9IGZ1bmN0aW9uIHVwZm4oZSkge1xuICAgICAgaWYgKHNlbGYuaW5mby5zdGFydGVkKSB7XG4gICAgICAgIG1vdmVmbihlKTtcbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIHRoZSB0ZW1wb3JhcnkgbGlzdGVuZXJzXG4gICAgICB1bnRyYWNrRG9jdW1lbnQoc2VsZi5pbmZvKTtcbiAgICB9O1xuICAgIC8vIGFkZCB0ZW1wb3JhcnkgZG9jdW1lbnQgbGlzdGVuZXJzIGFzIG1vdXNlIHJldGFyZ2V0c1xuICAgIHRyYWNrRG9jdW1lbnQodGhpcy5pbmZvLCBtb3ZlZm4sIHVwZm4pO1xuICAgIHRoaXMuaW5mby54ID0gZS5jbGllbnRYO1xuICAgIHRoaXMuaW5mby55ID0gZS5jbGllbnRZO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIHRoaXMuaW5mby54ID0gY3QuY2xpZW50WDtcbiAgICB0aGlzLmluZm8ueSA9IGN0LmNsaWVudFk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2htb3ZlOiBmdW5jdGlvbihlKSB7XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgbGV0IHggPSBjdC5jbGllbnRYLCB5ID0gY3QuY2xpZW50WTtcbiAgICBpZiAodGhpcy5oYXNNb3ZlZEVub3VnaCh4LCB5KSkge1xuICAgICAgaWYgKHRoaXMuaW5mby5zdGF0ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAvLyBpZiBhbmQgb25seSBpZiB0cmFja2luZywgYWx3YXlzIHByZXZlbnQgdGFwXG4gICAgICAgIHByZXZlbnQoJ3RhcCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbmZvLmFkZE1vdmUoe3g6IHgsIHk6IHl9KTtcbiAgICAgIHRoaXMuX2ZpcmUodCwgY3QpO1xuICAgICAgdGhpcy5pbmZvLnN0YXRlID0gJ3RyYWNrJztcbiAgICAgIHRoaXMuaW5mby5zdGFydGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoZSk7XG4gICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAvLyBvbmx5IHRyYWNrZW5kIGlmIHRyYWNrIHdhcyBzdGFydGVkIGFuZCBub3QgYWJvcnRlZFxuICAgIGlmICh0aGlzLmluZm8uc3RhcnRlZCkge1xuICAgICAgLy8gcmVzZXQgc3RhcnRlZCBzdGF0ZSBvbiB1cFxuICAgICAgdGhpcy5pbmZvLnN0YXRlID0gJ2VuZCc7XG4gICAgICB0aGlzLmluZm8uYWRkTW92ZSh7eDogY3QuY2xpZW50WCwgeTogY3QuY2xpZW50WX0pO1xuICAgICAgdGhpcy5fZmlyZSh0LCBjdCwgZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7RXZlbnRUYXJnZXR9IHRhcmdldFxuICAgKiBAcGFyYW0ge1RvdWNofSB0b3VjaFxuICAgKi9cbiAgX2ZpcmU6IGZ1bmN0aW9uKHRhcmdldCwgdG91Y2gpIHtcbiAgICBsZXQgc2Vjb25kbGFzdCA9IHRoaXMuaW5mby5tb3Zlc1t0aGlzLmluZm8ubW92ZXMubGVuZ3RoIC0gMl07XG4gICAgbGV0IGxhc3Rtb3ZlID0gdGhpcy5pbmZvLm1vdmVzW3RoaXMuaW5mby5tb3Zlcy5sZW5ndGggLSAxXTtcbiAgICBsZXQgZHggPSBsYXN0bW92ZS54IC0gdGhpcy5pbmZvLng7XG4gICAgbGV0IGR5ID0gbGFzdG1vdmUueSAtIHRoaXMuaW5mby55O1xuICAgIGxldCBkZHgsIGRkeSA9IDA7XG4gICAgaWYgKHNlY29uZGxhc3QpIHtcbiAgICAgIGRkeCA9IGxhc3Rtb3ZlLnggLSBzZWNvbmRsYXN0Lng7XG4gICAgICBkZHkgPSBsYXN0bW92ZS55IC0gc2Vjb25kbGFzdC55O1xuICAgIH1cbiAgICBfZmlyZSh0YXJnZXQsICd0cmFjaycsIHtcbiAgICAgIHN0YXRlOiB0aGlzLmluZm8uc3RhdGUsXG4gICAgICB4OiB0b3VjaC5jbGllbnRYLFxuICAgICAgeTogdG91Y2guY2xpZW50WSxcbiAgICAgIGR4OiBkeCxcbiAgICAgIGR5OiBkeSxcbiAgICAgIGRkeDogZGR4LFxuICAgICAgZGR5OiBkZHksXG4gICAgICBzb3VyY2VFdmVudDogdG91Y2gsXG4gICAgICBob3ZlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBkZWVwVGFyZ2V0RmluZCh0b3VjaC5jbGllbnRYLCB0b3VjaC5jbGllbnRZKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG59KTtcblxucmVnaXN0ZXIoe1xuICBuYW1lOiAndGFwJyxcbiAgZGVwczogWydtb3VzZWRvd24nLCAnY2xpY2snLCAndG91Y2hzdGFydCcsICd0b3VjaGVuZCddLFxuICBmbG93OiB7XG4gICAgc3RhcnQ6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnXSxcbiAgICBlbmQ6IFsnY2xpY2snLCAndG91Y2hlbmQnXVxuICB9LFxuICBlbWl0czogWyd0YXAnXSxcbiAgaW5mbzoge1xuICAgIHg6IE5hTixcbiAgICB5OiBOYU4sXG4gICAgcHJldmVudDogZmFsc2VcbiAgfSxcbiAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuaW5mby54ID0gTmFOO1xuICAgIHRoaXMuaW5mby55ID0gTmFOO1xuICAgIHRoaXMuaW5mby5wcmV2ZW50ID0gZmFsc2U7XG4gIH0sXG4gIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gIHNhdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLmluZm8ueCA9IGUuY2xpZW50WDtcbiAgICB0aGlzLmluZm8ueSA9IGUuY2xpZW50WTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAqL1xuICBtb3VzZWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICBpZiAoaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICB0aGlzLnNhdmUoZSk7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGVcbiAgICovXG4gIGNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgdGhpcy5mb3J3YXJkKGUpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5zYXZlKGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5mb3J3YXJkKGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge0V2ZW50IHwgVG91Y2h9IGVcbiAgICogQHBhcmFtIHtFdmVudD19IHByZXZlbnRlclxuICAgKi9cbiAgZm9yd2FyZDogZnVuY3Rpb24oZSwgcHJldmVudGVyKSB7XG4gICAgbGV0IGR4ID0gTWF0aC5hYnMoZS5jbGllbnRYIC0gdGhpcy5pbmZvLngpO1xuICAgIGxldCBkeSA9IE1hdGguYWJzKGUuY2xpZW50WSAtIHRoaXMuaW5mby55KTtcbiAgICAvLyBmaW5kIG9yaWdpbmFsIHRhcmdldCBmcm9tIGBwcmV2ZW50ZXJgIGZvciBUb3VjaEV2ZW50cywgb3IgYGVgIGZvciBNb3VzZUV2ZW50c1xuICAgIGxldCB0ID0gX2ZpbmRPcmlnaW5hbFRhcmdldCgocHJldmVudGVyIHx8IGUpKTtcbiAgICAvLyBkeCxkeSBjYW4gYmUgTmFOIGlmIGBjbGlja2AgaGFzIGJlZW4gc2ltdWxhdGVkIGFuZCB0aGVyZSB3YXMgbm8gYGRvd25gIGZvciBgc3RhcnRgXG4gICAgaWYgKGlzTmFOKGR4KSB8fCBpc05hTihkeSkgfHwgKGR4IDw9IFRBUF9ESVNUQU5DRSAmJiBkeSA8PSBUQVBfRElTVEFOQ0UpIHx8IGlzU3ludGhldGljQ2xpY2soZSkpIHtcbiAgICAgIC8vIHByZXZlbnQgdGFwcyBmcm9tIGJlaW5nIGdlbmVyYXRlZCBpZiBhbiBldmVudCBoYXMgY2FuY2VsZWQgdGhlbVxuICAgICAgaWYgKCF0aGlzLmluZm8ucHJldmVudCkge1xuICAgICAgICBfZmlyZSh0LCAndGFwJywge1xuICAgICAgICAgIHg6IGUuY2xpZW50WCxcbiAgICAgICAgICB5OiBlLmNsaWVudFksXG4gICAgICAgICAgc291cmNlRXZlbnQ6IGUsXG4gICAgICAgICAgcHJldmVudGVyOiBwcmV2ZW50ZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxuZXhwb3J0IGNvbnN0IGZpbmRPcmlnaW5hbFRhcmdldCA9IF9maW5kT3JpZ2luYWxUYXJnZXQ7XG5leHBvcnQgY29uc3QgYWRkID0gYWRkTGlzdGVuZXI7XG5leHBvcnQgY29uc3QgcmVtb3ZlID0gcmVtb3ZlTGlzdGVuZXI7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5qc1xuLy8gbW9kdWxlIGlkID0gMTJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuaW1wb3J0ICcuL21peGluLmpzJztcbmltcG9ydCAnLi9hc3luYy5qcyc7XG5cbi8qKiBAdHlwZWRlZiB7e3J1bjogZnVuY3Rpb24oZnVuY3Rpb24oKSwgbnVtYmVyPSk6bnVtYmVyLCBjYW5jZWw6IGZ1bmN0aW9uKG51bWJlcil9fSAqL1xubGV0IEFzeW5jTW9kdWxlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogQHN1bW1hcnkgQ29sbGFwc2UgbXVsdGlwbGUgY2FsbGJhY2tzIGludG8gb25lIGludm9jYXRpb24gYWZ0ZXIgYSB0aW1lci5cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmNsYXNzIERlYm91bmNlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2FzeW5jTW9kdWxlID0gbnVsbDtcbiAgICB0aGlzLl9jYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5fdGltZXIgPSBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzY2hlZHVsZXI7IHRoYXQgaXMsIGEgbW9kdWxlIHdpdGggdGhlIEFzeW5jIGludGVyZmFjZSxcbiAgICogYSBjYWxsYmFjayBhbmQgb3B0aW9uYWwgYXJndW1lbnRzIHRvIGJlIHBhc3NlZCB0byB0aGUgcnVuIGZ1bmN0aW9uXG4gICAqIGZyb20gdGhlIGFzeW5jIG1vZHVsZS5cbiAgICpcbiAgICogQHBhcmFtIHshQXN5bmNNb2R1bGV9IGFzeW5jTW9kdWxlIE9iamVjdCB3aXRoIEFzeW5jIGludGVyZmFjZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbigpfSBjYWxsYmFjayBDYWxsYmFjayB0byBydW4uXG4gICAqL1xuICBzZXRDb25maWcoYXN5bmNNb2R1bGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fYXN5bmNNb2R1bGUgPSBhc3luY01vZHVsZTtcbiAgICB0aGlzLl9jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX3RpbWVyID0gdGhpcy5fYXN5bmNNb2R1bGUucnVuKCgpID0+IHtcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2NhbGxiYWNrKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENhbmNlbHMgYW4gYWN0aXZlIGRlYm91bmNlciBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byBpdHNlbGYuXG4gICAqL1xuICBjYW5jZWwoKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fYXN5bmNNb2R1bGUuY2FuY2VsKHRoaXMuX3RpbWVyKTtcbiAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZsdXNoZXMgYW4gYWN0aXZlIGRlYm91bmNlciBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0byBpdHNlbGYuXG4gICAqL1xuICBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5pc0FjdGl2ZSgpKSB7XG4gICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgdGhpcy5fY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZGVib3VuY2VyIGlzIGFjdGl2ZS5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhY3RpdmUuXG4gICAqL1xuICBpc0FjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZXIgIT0gbnVsbDtcbiAgfVxuLyoqXG4gKiBDcmVhdGVzIGEgZGVib3VuY2VyIGlmIG5vIGRlYm91bmNlciBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXJcbiAqIG9yIGl0IGNhbmNlbHMgYW4gYWN0aXZlIGRlYm91bmNlciBvdGhlcndpc2UuIFRoZSBmb2xsb3dpbmdcbiAqIGV4YW1wbGUgc2hvd3MgaG93IGEgZGVib3VuY2VyIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aGluIGFcbiAqIG1pY3JvdGFzayBhbmQgXCJkZWJvdW5jZWRcIiBzdWNoIHRoYXQgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZ1bmN0aW9uIGlzXG4gKiBjYWxsZWQgb25jZS4gQWRkIHRoaXMgbWV0aG9kIHRvIGEgY3VzdG9tIGVsZW1lbnQ6XG4gKlxuICogX2RlYm91bmNlV29yaygpIHtcbiAqICAgdGhpcy5fZGVib3VuY2VKb2IgPSBQb2x5bWVyLkRlYm91bmNlci5kZWJvdW5jZSh0aGlzLl9kZWJvdW5jZUpvYixcbiAqICAgICAgIFBvbHltZXIuQXN5bmMubWljcm9UYXNrLCAoKSA9PiB7XG4gKiAgICAgdGhpcy5fZG9Xb3JrKCk7XG4gKiAgIH0pO1xuICogfVxuICpcbiAqIElmIHRoZSBgX2RlYm91bmNlV29ya2AgbWV0aG9kIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aXRoaW4gdGhlIHNhbWVcbiAqIG1pY3JvdGFzaywgdGhlIGBfZG9Xb3JrYCBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBvbmx5IG9uY2UgYXQgdGhlIG5leHRcbiAqIG1pY3JvdGFzayBjaGVja3BvaW50LlxuICpcbiAqIE5vdGU6IEluIHRlc3RpbmcgaXQgaXMgb2Z0ZW4gY29udmVuaWVudCB0byBhdm9pZCBhc3luY2hyb255LiBUbyBhY2NvbXBsaXNoXG4gKiB0aGlzIHdpdGggYSBkZWJvdW5jZXIsIHlvdSBjYW4gdXNlIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXJgIGFuZFxuICogYFBvbHltZXIuZmx1c2hgLiBGb3IgZXhhbXBsZSwgZXh0ZW5kIHRoZSBhYm92ZSBleGFtcGxlIGJ5IGFkZGluZ1xuICogYFBvbHltZXIuZW5xdWV1ZURlYm91bmNlcih0aGlzLl9kZWJvdW5jZUpvYilgIGF0IHRoZSBlbmQgb2YgdGhlXG4gKiBgX2RlYm91bmNlV29ya2AgbWV0aG9kLiBUaGVuIGluIGEgdGVzdCwgY2FsbCBgUG9seW1lci5mbHVzaGAgdG8gZW5zdXJlXG4gKiB0aGUgZGVib3VuY2VyIGhhcyBjb21wbGV0ZWQuXG4gKlxuICogQHBhcmFtIHtEZWJvdW5jZXI/fSBkZWJvdW5jZXIgRGVib3VuY2VyIG9iamVjdC5cbiAqIEBwYXJhbSB7IUFzeW5jTW9kdWxlfSBhc3luY01vZHVsZSBPYmplY3Qgd2l0aCBBc3luYyBpbnRlcmZhY2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuLlxuICogQHJldHVybiB7IURlYm91bmNlcn0gUmV0dXJucyBhIGRlYm91bmNlciBvYmplY3QuXG4gKi9cbiAgc3RhdGljIGRlYm91bmNlKGRlYm91bmNlciwgYXN5bmNNb2R1bGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGRlYm91bmNlciBpbnN0YW5jZW9mIERlYm91bmNlcikge1xuICAgICAgZGVib3VuY2VyLmNhbmNlbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJvdW5jZXIgPSBuZXcgRGVib3VuY2VyKCk7XG4gICAgfVxuICAgIGRlYm91bmNlci5zZXRDb25maWcoYXN5bmNNb2R1bGUsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZGVib3VuY2VyO1xuICB9XG59XG5cbmV4cG9ydCB7IERlYm91bmNlciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZGVib3VuY2UuanNcbi8vIG1vZHVsZSBpZCA9IDEzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5cbi8vIENvbW1vbiBpbXBsZW1lbnRhdGlvbiBmb3IgbWl4aW4gJiBiZWhhdmlvclxuZnVuY3Rpb24gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKGluc3QsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCBtdXRhYmxlRGF0YSkge1xuICBsZXQgaXNPYmplY3Q7XG4gIGlmIChtdXRhYmxlRGF0YSkge1xuICAgIGlzT2JqZWN0ID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpO1xuICAgIC8vIFB1bGwgYG9sZGAgZm9yIE9iamVjdHMgZnJvbSB0ZW1wIGNhY2hlLCBidXQgdHJlYXQgYG51bGxgIGFzIGEgcHJpbWl0aXZlXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBvbGQgPSBpbnN0Ll9fZGF0YVRlbXBbcHJvcGVydHldO1xuICAgIH1cbiAgfVxuICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2ssIGJ1dCByZXR1cm4gZmFsc2UgZm9yIE5hTj09PU5hTlxuICBsZXQgc2hvdWxkQ2hhbmdlID0gKG9sZCAhPT0gdmFsdWUgJiYgKG9sZCA9PT0gb2xkIHx8IHZhbHVlID09PSB2YWx1ZSkpO1xuICAvLyBPYmplY3RzIGFyZSBzdG9yZWQgaW4gdGVtcG9yYXJ5IGNhY2hlIChjbGVhcmVkIGF0IGVuZCBvZlxuICAvLyB0dXJuKSwgd2hpY2ggaXMgdXNlZCBmb3IgZGlydHktY2hlY2tpbmdcbiAgaWYgKGlzT2JqZWN0ICYmIHNob3VsZENoYW5nZSkge1xuICAgIGluc3QuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gc2hvdWxkQ2hhbmdlO1xufVxuXG5leHBvcnQgY29uc3QgTXV0YWJsZURhdGEgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAgICovXG4gIGNsYXNzIE11dGFibGVEYXRhIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGBcbiAgICAgKiBjYWNoZSAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgICAqIGNhY2hlIGlzIGNsZWFyZWQgYXQgdGhlIGVuZCBvZiBhIHR1cm4sIHRoaXMgaW1wbGVtZW50YXRpb24gYWxsb3dzXG4gICAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgICAqIGN5Y2xlcyBkdWUgdG8gMi13YXkgbm90aWZpY2F0aW9uKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBOZXcgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdHJ1ZSk7XG4gICAgfVxuXG4gIH1cbiAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICBNdXRhYmxlRGF0YS5wcm90b3R5cGUubXV0YWJsZURhdGEgPSBmYWxzZTtcblxuICByZXR1cm4gTXV0YWJsZURhdGE7XG5cbn0pO1xuXG5leHBvcnQgY29uc3QgT3B0aW9uYWxNdXRhYmxlRGF0YSA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBwb2x5bWVyXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX09wdGlvbmFsTXV0YWJsZURhdGF9XG4gICAqL1xuICBjbGFzcyBPcHRpb25hbE11dGFibGVEYXRhIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zdGFuY2UtbGV2ZWwgZmxhZyBmb3IgY29uZmlndXJpbmcgdGhlIGRpcnR5LWNoZWNraW5nIHN0cmF0ZWd5XG4gICAgICAgICAqIGZvciB0aGlzIGVsZW1lbnQuICBXaGVuIHRydWUsIE9iamVjdHMgYW5kIEFycmF5cyB3aWxsIHNraXAgZGlydHlcbiAgICAgICAgICogY2hlY2tpbmcsIG90aGVyd2lzZSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgd2lsbCBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgbXV0YWJsZURhdGE6IEJvb2xlYW5cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAgICpcbiAgICAgKiBXaGVuIGB0aGlzLm11dGFibGVEYXRhYCBpcyB0cnVlIG9uIHRoaXMgaW5zdGFuY2UsIHRoaXMgbWV0aG9kXG4gICAgICogcHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgIGNhY2hlXG4gICAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRoaXMubXV0YWJsZURhdGEpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBPcHRpb25hbE11dGFibGVEYXRhO1xuXG59KTtcblxuLy8gRXhwb3J0IGZvciB1c2UgYnkgbGVnYWN5IGJlaGF2aW9yXG5NdXRhYmxlRGF0YS5fbXV0YWJsZVByb3BlcnR5Q2hhbmdlID0gbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL211dGFibGUtZGF0YS5qc1xuLy8gbW9kdWxlIGlkID0gMTRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuXG4vKipcbiAqIENocm9tZSB1c2VzIGFuIG9sZGVyIHZlcnNpb24gb2YgRE9NIExldmVsIDMgS2V5Ym9hcmQgRXZlbnRzXG4gKlxuICogTW9zdCBrZXlzIGFyZSBsYWJlbGVkIGFzIHRleHQsIGJ1dCBzb21lIGFyZSBVbmljb2RlIGNvZGVwb2ludHMuXG4gKiBWYWx1ZXMgdGFrZW4gZnJvbTogaHR0cDovL3d3dy53My5vcmcvVFIvMjAwNy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwNzEyMjEva2V5c2V0Lmh0bWwjS2V5U2V0LVNldFxuICovXG52YXIgS0VZX0lERU5USUZJRVIgPSB7XG4gICdVKzAwMDgnOiAnYmFja3NwYWNlJyxcbiAgJ1UrMDAwOSc6ICd0YWInLFxuICAnVSswMDFCJzogJ2VzYycsXG4gICdVKzAwMjAnOiAnc3BhY2UnLFxuICAnVSswMDdGJzogJ2RlbCdcbn07XG5cbi8qKlxuICogU3BlY2lhbCB0YWJsZSBmb3IgS2V5Ym9hcmRFdmVudC5rZXlDb2RlLlxuICogS2V5Ym9hcmRFdmVudC5rZXlJZGVudGlmaWVyIGlzIGJldHRlciwgYW5kIEtleUJvYXJkRXZlbnQua2V5IGlzIGV2ZW4gYmV0dGVyXG4gKiB0aGFuIHRoYXQuXG4gKlxuICogVmFsdWVzIGZyb206IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50LmtleUNvZGUjVmFsdWVfb2Zfa2V5Q29kZVxuICovXG52YXIgS0VZX0NPREUgPSB7XG4gIDg6ICdiYWNrc3BhY2UnLFxuICA5OiAndGFiJyxcbiAgMTM6ICdlbnRlcicsXG4gIDI3OiAnZXNjJyxcbiAgMzM6ICdwYWdldXAnLFxuICAzNDogJ3BhZ2Vkb3duJyxcbiAgMzU6ICdlbmQnLFxuICAzNjogJ2hvbWUnLFxuICAzMjogJ3NwYWNlJyxcbiAgMzc6ICdsZWZ0JyxcbiAgMzg6ICd1cCcsXG4gIDM5OiAncmlnaHQnLFxuICA0MDogJ2Rvd24nLFxuICA0NjogJ2RlbCcsXG4gIDEwNjogJyonXG59O1xuXG4vKipcbiAqIE1PRElGSUVSX0tFWVMgbWFwcyB0aGUgc2hvcnQgbmFtZSBmb3IgbW9kaWZpZXIga2V5cyB1c2VkIGluIGEga2V5XG4gKiBjb21ibyBzdHJpbmcgdG8gdGhlIHByb3BlcnR5IG5hbWUgdGhhdCByZWZlcmVuY2VzIHRob3NlIHNhbWUga2V5c1xuICogaW4gYSBLZXlib2FyZEV2ZW50IGluc3RhbmNlLlxuICovXG52YXIgTU9ESUZJRVJfS0VZUyA9IHtcbiAgJ3NoaWZ0JzogJ3NoaWZ0S2V5JyxcbiAgJ2N0cmwnOiAnY3RybEtleScsXG4gICdhbHQnOiAnYWx0S2V5JyxcbiAgJ21ldGEnOiAnbWV0YUtleSdcbn07XG5cbi8qKlxuICogS2V5Ym9hcmRFdmVudC5rZXkgaXMgbW9zdGx5IHJlcHJlc2VudGVkIGJ5IHByaW50YWJsZSBjaGFyYWN0ZXIgbWFkZSBieVxuICogdGhlIGtleWJvYXJkLCB3aXRoIHVucHJpbnRhYmxlIGtleXMgbGFiZWxlZCBuaWNlbHkuXG4gKlxuICogSG93ZXZlciwgb24gT1MgWCwgQWx0K2NoYXIgY2FuIG1ha2UgYSBVbmljb2RlIGNoYXJhY3RlciB0aGF0IGZvbGxvd3MgYW5cbiAqIEFwcGxlLXNwZWNpZmljIG1hcHBpbmcuIEluIHRoaXMgY2FzZSwgd2UgZmFsbCBiYWNrIHRvIC5rZXlDb2RlLlxuICovXG52YXIgS0VZX0NIQVIgPSAvW2EtejAtOSpdLztcblxuLyoqXG4gKiBNYXRjaGVzIGEga2V5SWRlbnRpZmllciBzdHJpbmcuXG4gKi9cbnZhciBJREVOVF9DSEFSID0gL1VcXCsvO1xuXG4vKipcbiAqIE1hdGNoZXMgYXJyb3cga2V5cyBpbiBHZWNrbyAyNy4wK1xuICovXG52YXIgQVJST1dfS0VZID0gL15hcnJvdy87XG5cbi8qKlxuICogTWF0Y2hlcyBzcGFjZSBrZXlzIGV2ZXJ5d2hlcmUgKG5vdGFibHkgaW5jbHVkaW5nIElFMTAncyBleGNlcHRpb25hbCBuYW1lXG4gKiBgc3BhY2ViYXJgKS5cbiAqL1xudmFyIFNQQUNFX0tFWSA9IC9ec3BhY2UoYmFyKT8vO1xuXG4vKipcbiAqIE1hdGNoZXMgRVNDIGtleS5cbiAqXG4gKiBWYWx1ZSBmcm9tOiBodHRwOi8vdzNjLmdpdGh1Yi5pby91aWV2ZW50cy1rZXkvI2tleS1Fc2NhcGVcbiAqL1xudmFyIEVTQ19LRVkgPSAvXmVzY2FwZSQvO1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGtleS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIEtleUJvYXJkRXZlbnQua2V5XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtub1NwZWNpYWxDaGFyc10gTGltaXRzIHRoZSB0cmFuc2Zvcm1hdGlvbiB0b1xuICogYWxwaGEtbnVtZXJpYyBjaGFyYWN0ZXJzLlxuICovXG5mdW5jdGlvbiB0cmFuc2Zvcm1LZXkoa2V5LCBub1NwZWNpYWxDaGFycykge1xuICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgaWYgKGtleSkge1xuICAgIHZhciBsS2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGxLZXkgPT09ICcgJyB8fCBTUEFDRV9LRVkudGVzdChsS2V5KSkge1xuICAgICAgdmFsaWRLZXkgPSAnc3BhY2UnO1xuICAgIH0gZWxzZSBpZiAoRVNDX0tFWS50ZXN0KGxLZXkpKSB7XG4gICAgICB2YWxpZEtleSA9ICdlc2MnO1xuICAgIH0gZWxzZSBpZiAobEtleS5sZW5ndGggPT0gMSkge1xuICAgICAgaWYgKCFub1NwZWNpYWxDaGFycyB8fCBLRVlfQ0hBUi50ZXN0KGxLZXkpKSB7XG4gICAgICAgIHZhbGlkS2V5ID0gbEtleTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFSUk9XX0tFWS50ZXN0KGxLZXkpKSB7XG4gICAgICB2YWxpZEtleSA9IGxLZXkucmVwbGFjZSgnYXJyb3cnLCAnJyk7XG4gICAgfSBlbHNlIGlmIChsS2V5ID09ICdtdWx0aXBseScpIHtcbiAgICAgIC8vIG51bXBhZCAnKicgY2FuIG1hcCB0byBNdWx0aXBseSBvbiBJRS9XaW5kb3dzXG4gICAgICB2YWxpZEtleSA9ICcqJztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRLZXkgPSBsS2V5O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsaWRLZXk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUtleUlkZW50aWZpZXIoa2V5SWRlbnQpIHtcbiAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gIGlmIChrZXlJZGVudCkge1xuICAgIGlmIChrZXlJZGVudCBpbiBLRVlfSURFTlRJRklFUikge1xuICAgICAgdmFsaWRLZXkgPSBLRVlfSURFTlRJRklFUltrZXlJZGVudF07XG4gICAgfSBlbHNlIGlmIChJREVOVF9DSEFSLnRlc3Qoa2V5SWRlbnQpKSB7XG4gICAgICBrZXlJZGVudCA9IHBhcnNlSW50KGtleUlkZW50LnJlcGxhY2UoJ1UrJywgJzB4JyksIDE2KTtcbiAgICAgIHZhbGlkS2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZShrZXlJZGVudCkudG9Mb3dlckNhc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRLZXkgPSBrZXlJZGVudC50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsaWRLZXk7XG59XG5cbmZ1bmN0aW9uIHRyYW5zZm9ybUtleUNvZGUoa2V5Q29kZSkge1xuICB2YXIgdmFsaWRLZXkgPSAnJztcbiAgaWYgKE51bWJlcihrZXlDb2RlKSkge1xuICAgIGlmIChrZXlDb2RlID49IDY1ICYmIGtleUNvZGUgPD0gOTApIHtcbiAgICAgIC8vIGFzY2lpIGEtelxuICAgICAgLy8gbG93ZXJjYXNlIGlzIDMyIG9mZnNldCBmcm9tIHVwcGVyY2FzZVxuICAgICAgdmFsaWRLZXkgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDMyICsga2V5Q29kZSk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDExMiAmJiBrZXlDb2RlIDw9IDEyMykge1xuICAgICAgLy8gZnVuY3Rpb24ga2V5cyBmMS1mMTJcbiAgICAgIHZhbGlkS2V5ID0gJ2YnICsgKGtleUNvZGUgLSAxMTIgKyAxKTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gNDggJiYga2V5Q29kZSA8PSA1Nykge1xuICAgICAgLy8gdG9wIDAtOSBrZXlzXG4gICAgICB2YWxpZEtleSA9IFN0cmluZyhrZXlDb2RlIC0gNDgpO1xuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSA5NiAmJiBrZXlDb2RlIDw9IDEwNSkge1xuICAgICAgLy8gbnVtIHBhZCAwLTlcbiAgICAgIHZhbGlkS2V5ID0gU3RyaW5nKGtleUNvZGUgLSA5Nik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkS2V5ID0gS0VZX0NPREVba2V5Q29kZV07XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWxpZEtleTtcbn1cblxuLyoqXG4gICogQ2FsY3VsYXRlcyB0aGUgbm9ybWFsaXplZCBrZXkgZm9yIGEgS2V5Ym9hcmRFdmVudC5cbiAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR9IGtleUV2ZW50XG4gICogQHBhcmFtIHtCb29sZWFufSBbbm9TcGVjaWFsQ2hhcnNdIFNldCB0byB0cnVlIHRvIGxpbWl0IGtleUV2ZW50LmtleVxuICAqIHRyYW5zZm9ybWF0aW9uIHRvIGFscGhhLW51bWVyaWMgY2hhcnMuIFRoaXMgaXMgdXNlZnVsIHdpdGgga2V5XG4gICogY29tYmluYXRpb25zIGxpa2Ugc2hpZnQgKyAyLCB3aGljaCBvbiBGRiBmb3IgTWFjT1MgcHJvZHVjZXNcbiAgKiBrZXlFdmVudC5rZXkgPSBAXG4gICogVG8gZ2V0IDIgcmV0dXJuZWQsIHNldCBub1NwZWNpYWxDaGFycyA9IHRydWVcbiAgKiBUbyBnZXQgQCByZXR1cm5lZCwgc2V0IG5vU3BlY2lhbENoYXJzID0gZmFsc2VcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplZEtleUZvckV2ZW50KGtleUV2ZW50LCBub1NwZWNpYWxDaGFycykge1xuICAvLyBGYWxsIGJhY2sgZnJvbSAua2V5LCB0byAuZGV0YWlsLmtleSBmb3IgYXJ0aWZpY2FsIGtleWJvYXJkIGV2ZW50cyxcbiAgLy8gYW5kIHRoZW4gdG8gZGVwcmVjYXRlZCAua2V5SWRlbnRpZmllciBhbmQgLmtleUNvZGUuXG4gIGlmIChrZXlFdmVudC5rZXkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtS2V5KGtleUV2ZW50LmtleSwgbm9TcGVjaWFsQ2hhcnMpO1xuICB9XG4gIGlmIChrZXlFdmVudC5kZXRhaWwgJiYga2V5RXZlbnQuZGV0YWlsLmtleSkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1LZXkoa2V5RXZlbnQuZGV0YWlsLmtleSwgbm9TcGVjaWFsQ2hhcnMpO1xuICB9XG4gIHJldHVybiB0cmFuc2Zvcm1LZXlJZGVudGlmaWVyKGtleUV2ZW50LmtleUlkZW50aWZpZXIpIHx8XG4gICAgdHJhbnNmb3JtS2V5Q29kZShrZXlFdmVudC5rZXlDb2RlKSB8fCAnJztcbn1cblxuZnVuY3Rpb24ga2V5Q29tYm9NYXRjaGVzRXZlbnQoa2V5Q29tYm8sIGV2ZW50KSB7XG4gIC8vIEZvciBjb21ib3Mgd2l0aCBtb2RpZmllcnMgd2Ugc3VwcG9ydCBvbmx5IGFscGhhLW51bWVyaWMga2V5c1xuICB2YXIga2V5RXZlbnQgPSBub3JtYWxpemVkS2V5Rm9yRXZlbnQoZXZlbnQsIGtleUNvbWJvLmhhc01vZGlmaWVycyk7XG4gIHJldHVybiBrZXlFdmVudCA9PT0ga2V5Q29tYm8ua2V5ICYmXG4gICAgKCFrZXlDb21iby5oYXNNb2RpZmllcnMgfHwgKFxuICAgICAgISFldmVudC5zaGlmdEtleSA9PT0gISFrZXlDb21iby5zaGlmdEtleSAmJlxuICAgICAgISFldmVudC5jdHJsS2V5ID09PSAhIWtleUNvbWJvLmN0cmxLZXkgJiZcbiAgICAgICEhZXZlbnQuYWx0S2V5ID09PSAhIWtleUNvbWJvLmFsdEtleSAmJlxuICAgICAgISFldmVudC5tZXRhS2V5ID09PSAhIWtleUNvbWJvLm1ldGFLZXkpXG4gICAgKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VLZXlDb21ib1N0cmluZyhrZXlDb21ib1N0cmluZykge1xuICBpZiAoa2V5Q29tYm9TdHJpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbWJvOiBrZXlDb21ib1N0cmluZyxcbiAgICAgIGtleToga2V5Q29tYm9TdHJpbmcsXG4gICAgICBldmVudDogJ2tleWRvd24nXG4gICAgfTtcbiAgfVxuICByZXR1cm4ga2V5Q29tYm9TdHJpbmcuc3BsaXQoJysnKS5yZWR1Y2UoZnVuY3Rpb24ocGFyc2VkS2V5Q29tYm8sIGtleUNvbWJvUGFydCkge1xuICAgIHZhciBldmVudFBhcnRzID0ga2V5Q29tYm9QYXJ0LnNwbGl0KCc6Jyk7XG4gICAgdmFyIGtleU5hbWUgPSBldmVudFBhcnRzWzBdO1xuICAgIHZhciBldmVudCA9IGV2ZW50UGFydHNbMV07XG5cbiAgICBpZiAoa2V5TmFtZSBpbiBNT0RJRklFUl9LRVlTKSB7XG4gICAgICBwYXJzZWRLZXlDb21ib1tNT0RJRklFUl9LRVlTW2tleU5hbWVdXSA9IHRydWU7XG4gICAgICBwYXJzZWRLZXlDb21iby5oYXNNb2RpZmllcnMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWRLZXlDb21iby5rZXkgPSBrZXlOYW1lO1xuICAgICAgcGFyc2VkS2V5Q29tYm8uZXZlbnQgPSBldmVudCB8fCAna2V5ZG93bic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZEtleUNvbWJvO1xuICB9LCB7XG4gICAgY29tYm86IGtleUNvbWJvU3RyaW5nLnNwbGl0KCc6Jykuc2hpZnQoKVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VFdmVudFN0cmluZyhldmVudFN0cmluZykge1xuICByZXR1cm4gZXZlbnRTdHJpbmcudHJpbSgpLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uKGtleUNvbWJvU3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpO1xuICB9KTtcbn1cblxuZXhwb3J0IGNvbnN0IElyb25BMTF5S2V5c0JlaGF2aW9yID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIEV2ZW50VGFyZ2V0IHRoYXQgd2lsbCBiZSBmaXJpbmcgcmVsZXZhbnQgS2V5Ym9hcmRFdmVudHMuIFNldCBpdCB0b1xuICAgICAqIGBudWxsYCB0byBkaXNhYmxlIHRoZSBsaXN0ZW5lcnMuXG4gICAgICogQHR5cGUgez9FdmVudFRhcmdldH1cbiAgICAgKi9cbiAgICBrZXlFdmVudFRhcmdldDoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhpcyBwcm9wZXJ0eSB3aWxsIGNhdXNlIHRoZSBpbXBsZW1lbnRpbmcgZWxlbWVudCB0b1xuICAgICAqIGF1dG9tYXRpY2FsbHkgc3RvcCBwcm9wYWdhdGlvbiBvbiBhbnkgaGFuZGxlZCBLZXlib2FyZEV2ZW50cy5cbiAgICAgKi9cbiAgICBzdG9wS2V5Ym9hcmRFdmVudFByb3BhZ2F0aW9uOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIF9ib3VuZEtleUhhbmRsZXJzOiB7XG4gICAgICB0eXBlOiBBcnJheSxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBXZSB1c2UgdGhpcyBkdWUgdG8gYSBsaW1pdGF0aW9uIGluIElFMTAgd2hlcmUgaW5zdGFuY2VzIHdpbGwgaGF2ZVxuICAgIC8vIG93biBwcm9wZXJ0aWVzIG9mIGV2ZXJ5dGhpbmcgb24gdGhlIFwicHJvdG90eXBlXCIuXG4gICAgX2ltcGVyYXRpdmVLZXlCaW5kaW5nczoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfcmVzZXRLZXlFdmVudExpc3RlbmVycyhrZXlFdmVudFRhcmdldCwgX2JvdW5kS2V5SGFuZGxlcnMpJ1xuICBdLFxuXG5cbiAgLyoqXG4gICAqIFRvIGJlIHVzZWQgdG8gZXhwcmVzcyB3aGF0IGNvbWJpbmF0aW9uIG9mIGtleXMgIHdpbGwgdHJpZ2dlciB0aGUgcmVsYXRpdmVcbiAgICogY2FsbGJhY2suIGUuZy4gYGtleUJpbmRpbmdzOiB7ICdlc2MnOiAnX29uRXNjUHJlc3NlZCd9YFxuICAgKiBAdHlwZSB7IU9iamVjdH1cbiAgICovXG4gIGtleUJpbmRpbmdzOiB7fSxcblxuICByZWdpc3RlcmVkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9wcmVwS2V5QmluZGluZ3MoKTtcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYW4gYmUgdXNlZCB0byBpbXBlcmF0aXZlbHkgYWRkIGEga2V5IGJpbmRpbmcgdG8gdGhlIGltcGxlbWVudGluZ1xuICAgKiBlbGVtZW50LiBUaGlzIGlzIHRoZSBpbXBlcmF0aXZlIGVxdWl2YWxlbnQgb2YgZGVjbGFyaW5nIGEga2V5YmluZGluZ1xuICAgKiBpbiB0aGUgYGtleUJpbmRpbmdzYCBwcm90b3R5cGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFN0cmluZ1xuICAgKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlck5hbWVcbiAgICovXG4gIGFkZE93bktleUJpbmRpbmc6IGZ1bmN0aW9uKGV2ZW50U3RyaW5nLCBoYW5kbGVyTmFtZSkge1xuICAgIHRoaXMuX2ltcGVyYXRpdmVLZXlCaW5kaW5nc1tldmVudFN0cmluZ10gPSBoYW5kbGVyTmFtZTtcbiAgICB0aGlzLl9wcmVwS2V5QmluZGluZ3MoKTtcbiAgICB0aGlzLl9yZXNldEtleUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdoZW4gY2FsbGVkLCB3aWxsIHJlbW92ZSBhbGwgaW1wZXJhdGl2ZWx5LWFkZGVkIGtleSBiaW5kaW5ncy5cbiAgICovXG4gIHJlbW92ZU93bktleUJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3MgPSB7fTtcbiAgICB0aGlzLl9wcmVwS2V5QmluZGluZ3MoKTtcbiAgICB0aGlzLl9yZXNldEtleUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGtleWJvYXJkIGV2ZW50IG1hdGNoZXMgYGV2ZW50U3RyaW5nYC5cbiAgICpcbiAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBldmVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRTdHJpbmdcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGtleWJvYXJkRXZlbnRNYXRjaGVzS2V5czogZnVuY3Rpb24oZXZlbnQsIGV2ZW50U3RyaW5nKSB7XG4gICAgdmFyIGtleUNvbWJvcyA9IHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5Q29tYm9zLmxlbmd0aDsgKytpKSB7XG4gICAgICBpZiAoa2V5Q29tYm9NYXRjaGVzRXZlbnQoa2V5Q29tYm9zW2ldLCBldmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBfY29sbGVjdEtleUJpbmRpbmdzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIga2V5QmluZGluZ3MgPSB0aGlzLmJlaGF2aW9ycy5tYXAoZnVuY3Rpb24oYmVoYXZpb3IpIHtcbiAgICAgIHJldHVybiBiZWhhdmlvci5rZXlCaW5kaW5ncztcbiAgICB9KTtcblxuICAgIGlmIChrZXlCaW5kaW5ncy5pbmRleE9mKHRoaXMua2V5QmluZGluZ3MpID09PSAtMSkge1xuICAgICAga2V5QmluZGluZ3MucHVzaCh0aGlzLmtleUJpbmRpbmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4ga2V5QmluZGluZ3M7XG4gIH0sXG5cbiAgX3ByZXBLZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fa2V5QmluZGluZ3MgPSB7fTtcblxuICAgIHRoaXMuX2NvbGxlY3RLZXlCaW5kaW5ncygpLmZvckVhY2goZnVuY3Rpb24oa2V5QmluZGluZ3MpIHtcbiAgICAgIGZvciAodmFyIGV2ZW50U3RyaW5nIGluIGtleUJpbmRpbmdzKSB7XG4gICAgICAgIHRoaXMuX2FkZEtleUJpbmRpbmcoZXZlbnRTdHJpbmcsIGtleUJpbmRpbmdzW2V2ZW50U3RyaW5nXSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICBmb3IgKHZhciBldmVudFN0cmluZyBpbiB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3MpIHtcbiAgICAgIHRoaXMuX2FkZEtleUJpbmRpbmcoZXZlbnRTdHJpbmcsIHRoaXMuX2ltcGVyYXRpdmVLZXlCaW5kaW5nc1tldmVudFN0cmluZ10pO1xuICAgIH1cblxuICAgIC8vIEdpdmUgcHJlY2VkZW5jZSB0byBjb21ib3Mgd2l0aCBtb2RpZmllcnMgdG8gYmUgY2hlY2tlZCBmaXJzdC5cbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gdGhpcy5fa2V5QmluZGluZ3MpIHtcbiAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2V2ZW50TmFtZV0uc29ydChmdW5jdGlvbiAoa2IxLCBrYjIpIHtcbiAgICAgICAgdmFyIGIxID0ga2IxWzBdLmhhc01vZGlmaWVycztcbiAgICAgICAgdmFyIGIyID0ga2IyWzBdLmhhc01vZGlmaWVycztcbiAgICAgICAgcmV0dXJuIChiMSA9PT0gYjIpID8gMCA6IGIxID8gLTEgOiAxO1xuICAgICAgfSlcbiAgICB9XG4gIH0sXG5cbiAgX2FkZEtleUJpbmRpbmc6IGZ1bmN0aW9uKGV2ZW50U3RyaW5nLCBoYW5kbGVyTmFtZSkge1xuICAgIHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpLmZvckVhY2goZnVuY3Rpb24oa2V5Q29tYm8pIHtcbiAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XSA9XG4gICAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XSB8fCBbXTtcblxuICAgICAgdGhpcy5fa2V5QmluZGluZ3Nba2V5Q29tYm8uZXZlbnRdLnB1c2goW1xuICAgICAgICBrZXlDb21ibyxcbiAgICAgICAgaGFuZGxlck5hbWVcbiAgICAgIF0pO1xuICAgIH0sIHRoaXMpO1xuICB9LFxuXG4gIF9yZXNldEtleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl91bmxpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLl9saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuICAgIH1cbiAgfSxcblxuICBfbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5rZXlFdmVudFRhcmdldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9rZXlCaW5kaW5ncykuZm9yRWFjaChmdW5jdGlvbihldmVudE5hbWUpIHtcbiAgICAgIHZhciBrZXlCaW5kaW5ncyA9IHRoaXMuX2tleUJpbmRpbmdzW2V2ZW50TmFtZV07XG4gICAgICB2YXIgYm91bmRLZXlIYW5kbGVyID0gdGhpcy5fb25LZXlCaW5kaW5nRXZlbnQuYmluZCh0aGlzLCBrZXlCaW5kaW5ncyk7XG5cbiAgICAgIHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMucHVzaChbdGhpcy5rZXlFdmVudFRhcmdldCwgZXZlbnROYW1lLCBib3VuZEtleUhhbmRsZXJdKTtcblxuICAgICAgdGhpcy5rZXlFdmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBfdW5saXN0ZW5LZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleUhhbmRsZXJUdXBsZTtcbiAgICB2YXIga2V5RXZlbnRUYXJnZXQ7XG4gICAgdmFyIGV2ZW50TmFtZTtcbiAgICB2YXIgYm91bmRLZXlIYW5kbGVyO1xuXG4gICAgd2hpbGUgKHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMubGVuZ3RoKSB7XG4gICAgICAvLyBNeSBraW5nZG9tIGZvciBibG9jay1zY29wZSBiaW5kaW5nIGFuZCBkZXN0cnVjdHVyaW5nIGFzc2lnbm1lbnQuLlxuICAgICAga2V5SGFuZGxlclR1cGxlID0gdGhpcy5fYm91bmRLZXlIYW5kbGVycy5wb3AoKTtcbiAgICAgIGtleUV2ZW50VGFyZ2V0ID0ga2V5SGFuZGxlclR1cGxlWzBdO1xuICAgICAgZXZlbnROYW1lID0ga2V5SGFuZGxlclR1cGxlWzFdO1xuICAgICAgYm91bmRLZXlIYW5kbGVyID0ga2V5SGFuZGxlclR1cGxlWzJdO1xuXG4gICAgICBrZXlFdmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uS2V5QmluZGluZ0V2ZW50OiBmdW5jdGlvbihrZXlCaW5kaW5ncywgZXZlbnQpIHtcbiAgICBpZiAodGhpcy5zdG9wS2V5Ym9hcmRFdmVudFByb3BhZ2F0aW9uKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9XG5cbiAgICAvLyBpZiBldmVudCBoYXMgYmVlbiBhbHJlYWR5IHByZXZlbnRlZCwgZG9uJ3QgZG8gYW55dGhpbmdcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5QmluZGluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXlDb21ibyA9IGtleUJpbmRpbmdzW2ldWzBdO1xuICAgICAgdmFyIGhhbmRsZXJOYW1lID0ga2V5QmluZGluZ3NbaV1bMV07XG4gICAgICBpZiAoa2V5Q29tYm9NYXRjaGVzRXZlbnQoa2V5Q29tYm8sIGV2ZW50KSkge1xuICAgICAgICB0aGlzLl90cmlnZ2VyS2V5SGFuZGxlcihrZXlDb21ibywgaGFuZGxlck5hbWUsIGV2ZW50KTtcbiAgICAgICAgLy8gZXhpdCB0aGUgbG9vcCBpZiBldmVudERlZmF1bHQgd2FzIHByZXZlbnRlZFxuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfdHJpZ2dlcktleUhhbmRsZXI6IGZ1bmN0aW9uKGtleUNvbWJvLCBoYW5kbGVyTmFtZSwga2V5Ym9hcmRFdmVudCkge1xuICAgIHZhciBkZXRhaWwgPSBPYmplY3QuY3JlYXRlKGtleUNvbWJvKTtcbiAgICBkZXRhaWwua2V5Ym9hcmRFdmVudCA9IGtleWJvYXJkRXZlbnQ7XG4gICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KGtleUNvbWJvLmV2ZW50LCB7XG4gICAgICBkZXRhaWw6IGRldGFpbCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzW2hhbmRsZXJOYW1lXS5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAga2V5Ym9hcmRFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGN1c3RvbS1zdHlsZT5cbiAgPHN0eWxlIGlzPVwiY3VzdG9tLXN0eWxlXCI+XG4gICAgaHRtbCB7XG5cbiAgICAgIC0tbGF5b3V0OiB7XG4gICAgICAgIGRpc3BsYXk6IC1tcy1mbGV4Ym94O1xuICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWZsZXg7XG4gICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1pbmxpbmU6IHtcbiAgICAgICAgZGlzcGxheTogLW1zLWlubGluZS1mbGV4Ym94O1xuICAgICAgICBkaXNwbGF5OiAtd2Via2l0LWlubGluZS1mbGV4O1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtZmxleDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWhvcml6b250YWw6IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0O1xuXG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiByb3c7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1ob3Jpem9udGFsLXJldmVyc2U6IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0O1xuXG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XG4gICAgICAgIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93LXJldmVyc2U7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC12ZXJ0aWNhbDoge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQ7XG5cbiAgICAgICAgLW1zLWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXZlcnRpY2FsLXJldmVyc2U6IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0O1xuXG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uLXJldmVyc2U7XG4gICAgICAgIC13ZWJraXQtZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uLXJldmVyc2U7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC13cmFwOiB7XG4gICAgICAgIC1tcy1mbGV4LXdyYXA6IHdyYXA7XG4gICAgICAgIC13ZWJraXQtZmxleC13cmFwOiB3cmFwO1xuICAgICAgICBmbGV4LXdyYXA6IHdyYXA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC13cmFwLXJldmVyc2U6IHtcbiAgICAgICAgLW1zLWZsZXgtd3JhcDogd3JhcC1yZXZlcnNlO1xuICAgICAgICAtd2Via2l0LWZsZXgtd3JhcDogd3JhcC1yZXZlcnNlO1xuICAgICAgICBmbGV4LXdyYXA6IHdyYXAtcmV2ZXJzZTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtYXV0bzoge1xuICAgICAgICAtbXMtZmxleDogMSAxIGF1dG87XG4gICAgICAgIC13ZWJraXQtZmxleDogMSAxIGF1dG87XG4gICAgICAgIGZsZXg6IDEgMSBhdXRvO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC1ub25lOiB7XG4gICAgICAgIC1tcy1mbGV4OiBub25lO1xuICAgICAgICAtd2Via2l0LWZsZXg6IG5vbmU7XG4gICAgICAgIGZsZXg6IG5vbmU7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4OiB7XG4gICAgICAgIC1tcy1mbGV4OiAxIDEgMC4wMDAwMDAwMDFweDtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAxO1xuICAgICAgICBmbGV4OiAxO1xuICAgICAgICAtd2Via2l0LWZsZXgtYmFzaXM6IDAuMDAwMDAwMDAxcHg7XG4gICAgICAgIGZsZXgtYmFzaXM6IDAuMDAwMDAwMDAxcHg7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTI6IHtcbiAgICAgICAgLW1zLWZsZXg6IDI7XG4gICAgICAgIC13ZWJraXQtZmxleDogMjtcbiAgICAgICAgZmxleDogMjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtMzoge1xuICAgICAgICAtbXMtZmxleDogMztcbiAgICAgICAgLXdlYmtpdC1mbGV4OiAzO1xuICAgICAgICBmbGV4OiAzO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC00OiB7XG4gICAgICAgIC1tcy1mbGV4OiA0O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDQ7XG4gICAgICAgIGZsZXg6IDQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTU6IHtcbiAgICAgICAgLW1zLWZsZXg6IDU7XG4gICAgICAgIC13ZWJraXQtZmxleDogNTtcbiAgICAgICAgZmxleDogNTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtNjoge1xuICAgICAgICAtbXMtZmxleDogNjtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA2O1xuICAgICAgICBmbGV4OiA2O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC03OiB7XG4gICAgICAgIC1tcy1mbGV4OiA3O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDc7XG4gICAgICAgIGZsZXg6IDc7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTg6IHtcbiAgICAgICAgLW1zLWZsZXg6IDg7XG4gICAgICAgIC13ZWJraXQtZmxleDogODtcbiAgICAgICAgZmxleDogODtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtOToge1xuICAgICAgICAtbXMtZmxleDogOTtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA5O1xuICAgICAgICBmbGV4OiA5O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC0xMDoge1xuICAgICAgICAtbXMtZmxleDogMTA7XG4gICAgICAgIC13ZWJraXQtZmxleDogMTA7XG4gICAgICAgIGZsZXg6IDEwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC0xMToge1xuICAgICAgICAtbXMtZmxleDogMTE7XG4gICAgICAgIC13ZWJraXQtZmxleDogMTE7XG4gICAgICAgIGZsZXg6IDExO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC0xMjoge1xuICAgICAgICAtbXMtZmxleDogMTI7XG4gICAgICAgIC13ZWJraXQtZmxleDogMTI7XG4gICAgICAgIGZsZXg6IDEyO1xuICAgICAgfTtcblxuICAgICAgLyogYWxpZ25tZW50IGluIGNyb3NzIGF4aXMgKi9cblxuICAgICAgLS1sYXlvdXQtc3RhcnQ6IHtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IHN0YXJ0O1xuICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xuICAgICAgICBhbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWNlbnRlcjoge1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogY2VudGVyO1xuICAgICAgICAtd2Via2l0LWFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBjZW50ZXI7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1lbmQ6IHtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGVuZDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LWVuZDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWJhc2VsaW5lOiB7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBiYXNlbGluZTtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1pdGVtczogYmFzZWxpbmU7XG4gICAgICAgIGFsaWduLWl0ZW1zOiBiYXNlbGluZTtcbiAgICAgIH07XG5cbiAgICAgIC8qIGFsaWdubWVudCBpbiBtYWluIGF4aXMgKi9cblxuICAgICAgLS1sYXlvdXQtc3RhcnQtanVzdGlmaWVkOiB7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IHN0YXJ0O1xuICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtY2VudGVyLWp1c3RpZmllZDoge1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBjZW50ZXI7XG4gICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZW5kLWp1c3RpZmllZDoge1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBlbmQ7XG4gICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWFyb3VuZC1qdXN0aWZpZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogZGlzdHJpYnV0ZTtcbiAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgICAganVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1qdXN0aWZpZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtcGFjazoganVzdGlmeTtcbiAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWNlbnRlci1jZW50ZXI6IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlcjtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlci1qdXN0aWZpZWQ7XG4gICAgICB9O1xuXG4gICAgICAvKiBzZWxmIGFsaWdubWVudCAqL1xuXG4gICAgICAtLWxheW91dC1zZWxmLXN0YXJ0OiB7XG4gICAgICAgIC1tcy1hbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuICAgICAgICAtd2Via2l0LWFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1zZWxmLWNlbnRlcjoge1xuICAgICAgICAtbXMtYWxpZ24tc2VsZjogY2VudGVyO1xuICAgICAgICAtd2Via2l0LWFsaWduLXNlbGY6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24tc2VsZjogY2VudGVyO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtc2VsZi1lbmQ6IHtcbiAgICAgICAgLW1zLWFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICAgICAgICAtd2Via2l0LWFsaWduLXNlbGY6IGZsZXgtZW5kO1xuICAgICAgICBhbGlnbi1zZWxmOiBmbGV4LWVuZDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXNlbGYtc3RyZXRjaDoge1xuICAgICAgICAtbXMtYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgICBhbGlnbi1zZWxmOiBzdHJldGNoO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtc2VsZi1iYXNlbGluZToge1xuICAgICAgICAtbXMtYWxpZ24tc2VsZjogYmFzZWxpbmU7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tc2VsZjogYmFzZWxpbmU7XG4gICAgICAgIGFsaWduLXNlbGY6IGJhc2VsaW5lO1xuICAgICAgfTtcblxuICAgICAgLyogbXVsdGktbGluZSBhbGlnbm1lbnQgaW4gbWFpbiBheGlzICovXG5cbiAgICAgIC0tbGF5b3V0LXN0YXJ0LWFsaWduZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtbGluZS1wYWNrOiBzdGFydDsgIC8qIElFMTAgKi9cbiAgICAgICAgLW1zLWFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcbiAgICAgICAgYWxpZ24tY29udGVudDogZmxleC1zdGFydDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWVuZC1hbGlnbmVkOiB7XG4gICAgICAgIC1tcy1mbGV4LWxpbmUtcGFjazogZW5kOyAgLyogSUUxMCAqL1xuICAgICAgICAtbXMtYWxpZ24tY29udGVudDogZmxleC1lbmQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tY29udGVudDogZmxleC1lbmQ7XG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtY2VudGVyLWFsaWduZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtbGluZS1wYWNrOiBjZW50ZXI7ICAvKiBJRTEwICovXG4gICAgICAgIC1tcy1hbGlnbi1jb250ZW50OiBjZW50ZXI7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgICAgICBhbGlnbi1jb250ZW50OiBjZW50ZXI7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1iZXR3ZWVuLWFsaWduZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtbGluZS1wYWNrOiBqdXN0aWZ5OyAgLyogSUUxMCAqL1xuICAgICAgICAtbXMtYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBhbGlnbi1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtYXJvdW5kLWFsaWduZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtbGluZS1wYWNrOiBkaXN0cmlidXRlOyAgLyogSUUxMCAqL1xuICAgICAgICAtbXMtYWxpZ24tY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgICAtd2Via2l0LWFsaWduLWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgfTtcblxuICAgICAgLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAgICAgICAgICAgICAgICBPdGhlciBMYXlvdXRcbiAgICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbiAgICAgIC0tbGF5b3V0LWJsb2NrOiB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtaW52aXNpYmxlOiB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbiAhaW1wb3J0YW50O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtcmVsYXRpdmU6IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZml0OiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtc2Nyb2xsOiB7XG4gICAgICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcbiAgICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mdWxsYmxlZWQ6IHtcbiAgICAgICAgbWFyZ2luOiAwO1xuICAgICAgICBoZWlnaHQ6IDEwMHZoO1xuICAgICAgfTtcblxuICAgICAgLyogZml4ZWQgcG9zaXRpb24gKi9cblxuICAgICAgLS1sYXlvdXQtZml4ZWQtdG9wOiB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZpeGVkLXJpZ2h0OiB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgYm90dG9tOiAwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZml4ZWQtYm90dG9tOiB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZpeGVkLWxlZnQ6IHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgIH07XG5cbiAgICB9XG4gIDwvc3R5bGU+XG48L2N1c3RvbS1zdHlsZT5gO1xuXG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0LmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL2ZvbnQtcm9ib3RvL3JvYm90by5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGN1c3RvbS1zdHlsZT5cbiAgPHN0eWxlIGlzPVwiY3VzdG9tLXN0eWxlXCI+XG4gICAgaHRtbCB7XG5cbiAgICAgIC8qIFNoYXJlZCBTdHlsZXMgKi9cbiAgICAgIC0tcGFwZXItZm9udC1jb21tb24tYmFzZToge1xuICAgICAgICBmb250LWZhbWlseTogJ1JvYm90bycsICdOb3RvJywgc2Fucy1zZXJpZjtcbiAgICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtY29tbW9uLWNvZGU6IHtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdSb2JvdG8gTW9ubycsICdDb25zb2xhcycsICdNZW5sbycsIG1vbm9zcGFjZTtcbiAgICAgICAgLXdlYmtpdC1mb250LXNtb290aGluZzogYW50aWFsaWFzZWQ7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtY29tbW9uLWV4cGVuc2l2ZS1rZXJuaW5nOiB7XG4gICAgICAgIHRleHQtcmVuZGVyaW5nOiBvcHRpbWl6ZUxlZ2liaWxpdHk7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtY29tbW9uLW5vd3JhcDoge1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0ZXh0LW92ZXJmbG93OiBlbGxpcHNpcztcbiAgICAgIH07XG5cbiAgICAgIC8qIE1hdGVyaWFsIEZvbnQgU3R5bGVzICovXG5cbiAgICAgIC0tcGFwZXItZm9udC1kaXNwbGF5NDoge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1ub3dyYXA7XG5cbiAgICAgICAgZm9udC1zaXplOiAxMTJweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDMwMDtcbiAgICAgICAgbGV0dGVyLXNwYWNpbmc6IC0uMDQ0ZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAxMjBweDtcbiAgICAgIH07XG5cbiAgICAgIC0tcGFwZXItZm9udC1kaXNwbGF5Mzoge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1ub3dyYXA7XG5cbiAgICAgICAgZm9udC1zaXplOiA1NnB4O1xuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICBsZXR0ZXItc3BhY2luZzogLS4wMjZlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDYwcHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtZGlzcGxheTI6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcblxuICAgICAgICBmb250LXNpemU6IDQ1cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgICAgIGxldHRlci1zcGFjaW5nOiAtLjAxOGVtO1xuICAgICAgICBsaW5lLWhlaWdodDogNDhweDtcbiAgICAgIH07XG5cbiAgICAgIC0tcGFwZXItZm9udC1kaXNwbGF5MToge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMzRweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICAgICAgbGV0dGVyLXNwYWNpbmc6IC0uMDFlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDQwcHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtaGVhZGxpbmU6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcblxuICAgICAgICBmb250LXNpemU6IDI0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgICAgIGxldHRlci1zcGFjaW5nOiAtLjAxMmVtO1xuICAgICAgICBsaW5lLWhlaWdodDogMzJweDtcbiAgICAgIH07XG5cbiAgICAgIC0tcGFwZXItZm9udC10aXRsZToge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1ub3dyYXA7XG5cbiAgICAgICAgZm9udC1zaXplOiAyMHB4O1xuICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICBsaW5lLWhlaWdodDogMjhweDtcbiAgICAgIH07XG5cbiAgICAgIC0tcGFwZXItZm9udC1zdWJoZWFkOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG5cbiAgICAgICAgZm9udC1zaXplOiAxNnB4O1xuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICBsaW5lLWhlaWdodDogMjRweDtcbiAgICAgIH07XG5cbiAgICAgIC0tcGFwZXItZm9udC1ib2R5Mjoge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDI0cHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtYm9keTE6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcblxuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWNhcHRpb246IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tbm93cmFwO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMTJweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICAgICAgbGV0dGVyLXNwYWNpbmc6IDAuMDExZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LW1lbnU6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tbm93cmFwO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMTNweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDI0cHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtYnV0dG9uOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLW5vd3JhcDtcblxuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgICAgIGxldHRlci1zcGFjaW5nOiAwLjAxOGVtO1xuICAgICAgICBsaW5lLWhlaWdodDogMjRweDtcbiAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICAgIH07XG5cbiAgICAgIC0tcGFwZXItZm9udC1jb2RlMjoge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1jb2RlO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMTRweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDcwMDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDIwcHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtY29kZTE6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tY29kZTtcblxuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgICAgfTtcblxuICAgIH1cblxuICA8L3N0eWxlPlxuPC9jdXN0b20tc3R5bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy90eXBvZ3JhcGh5LmpzXG4vLyBtb2R1bGUgaWQgPSAxN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSAnLi4vcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25Db250cm9sU3RhdGUgPSB7XG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGVsZW1lbnQgY3VycmVudGx5IGhhcyBmb2N1cy5cbiAgICAgKi9cbiAgICBmb2N1c2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHVzZXIgY2Fubm90IGludGVyYWN0IHdpdGggdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIGRpc2FibGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgb2JzZXJ2ZXI6ICdfZGlzYWJsZWRDaGFuZ2VkJyxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgIH0sXG5cbiAgICBfb2xkVGFiSW5kZXg6IHtcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH0sXG5cbiAgICBfYm91bmRGb2N1c0JsdXJIYW5kbGVyOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZvY3VzQmx1ckhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX19oYW5kbGVFdmVudFJldGFyZ2V0aW5nOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuc2hhZG93Um9vdCAmJiAhRWxlbWVudDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19jaGFuZ2VkQ29udHJvbFN0YXRlKGZvY3VzZWQsIGRpc2FibGVkKSdcbiAgXSxcblxuICByZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kRm9jdXNCbHVySGFuZGxlciwgdHJ1ZSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmRGb2N1c0JsdXJIYW5kbGVyLCB0cnVlKTtcbiAgfSxcblxuICBfZm9jdXNCbHVySGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBJbiBQb2x5bWVyIDIuMCwgdGhlIGxpYnJhcnkgdGFrZXMgY2FyZSBvZiByZXRhcmdldGluZyBldmVudHMuXG4gICAgaWYgKEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldEZvY3VzZWQoZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTk9URShjZGF0YSk6ICBpZiB3ZSBhcmUgaW4gU2hhZG93RE9NIGxhbmQsIGBldmVudC50YXJnZXRgIHdpbGxcbiAgICAvLyBldmVudHVhbGx5IGJlY29tZSBgdGhpc2AgZHVlIHRvIHJldGFyZ2V0aW5nOyBpZiB3ZSBhcmUgbm90IGluXG4gICAgLy8gU2hhZG93RE9NIGxhbmQsIGBldmVudC50YXJnZXRgIHdpbGwgZXZlbnR1YWxseSBiZWNvbWUgYHRoaXNgIGR1ZVxuICAgIC8vIHRvIHRoZSBzZWNvbmQgY29uZGl0aW9uYWwgd2hpY2ggZmlyZXMgYSBzeW50aGV0aWMgZXZlbnQgKHRoYXQgaXMgYWxzb1xuICAgIC8vIGhhbmRsZWQpLiBJbiBlaXRoZXIgY2FzZSwgd2UgY2FuIGRpc3JlZ2FyZCBgZXZlbnQucGF0aGAuXG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcykge1xuICAgICAgdGhpcy5fc2V0Rm9jdXNlZChldmVudC50eXBlID09PSAnZm9jdXMnKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX19oYW5kbGVFdmVudFJldGFyZ2V0aW5nKSB7XG4gICAgICB2YXIgdGFyZ2V0ID0gLyoqIEB0eXBlIHtOb2RlfSAqLyhkb20oZXZlbnQpLmxvY2FsVGFyZ2V0KTtcbiAgICAgIGlmICghdGhpcy5pc0xpZ2h0RGVzY2VuZGFudCh0YXJnZXQpKSB7XG4gICAgICAgIHRoaXMuZmlyZShldmVudC50eXBlLCB7c291cmNlRXZlbnQ6IGV2ZW50fSwge1xuICAgICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgICAgYnViYmxlczogZXZlbnQuYnViYmxlcyxcbiAgICAgICAgICBjYW5jZWxhYmxlOiBldmVudC5jYW5jZWxhYmxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfZGlzYWJsZWRDaGFuZ2VkOiBmdW5jdGlvbihkaXNhYmxlZCwgb2xkKSB7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGlzYWJsZWQnLCBkaXNhYmxlZCA/ICd0cnVlJyA6ICdmYWxzZScpO1xuICAgIHRoaXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IGRpc2FibGVkID8gJ25vbmUnIDogJyc7XG4gICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICB0aGlzLl9vbGRUYWJJbmRleCA9IHRoaXMudGFiSW5kZXg7XG4gICAgICB0aGlzLl9zZXRGb2N1c2VkKGZhbHNlKTtcbiAgICAgIHRoaXMudGFiSW5kZXggPSAtMTtcbiAgICAgIHRoaXMuYmx1cigpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb2xkVGFiSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy50YWJJbmRleCA9IHRoaXMuX29sZFRhYkluZGV4O1xuICAgIH1cbiAgfSxcblxuICBfY2hhbmdlZENvbnRyb2xTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgLy8gX2NvbnRyb2xTdGF0ZUNoYW5nZWQgaXMgYWJzdHJhY3QsIGZvbGxvdy1vbiBiZWhhdmlvcnMgbWF5IGltcGxlbWVudCBpdFxuICAgIGlmICh0aGlzLl9jb250cm9sU3RhdGVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9jb250cm9sU3RhdGVDaGFuZ2VkKCk7XG4gICAgfVxuICB9XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWJlaGF2aW9ycy9pcm9uLWNvbnRyb2wtc3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi4vcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5qcyc7XG5pbXBvcnQgeyBJcm9uQnV0dG9uU3RhdGVJbXBsIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IFBhcGVyUmlwcGxlQmVoYXZpb3IgPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgZWxlbWVudCB3aWxsIG5vdCBwcm9kdWNlIGEgcmlwcGxlIGVmZmVjdCB3aGVuIGludGVyYWN0ZWRcbiAgICAgKiB3aXRoIHZpYSB0aGUgcG9pbnRlci5cbiAgICAgKi9cbiAgICBub2luazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIG9ic2VydmVyOiAnX25vaW5rQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge0VsZW1lbnR8dW5kZWZpbmVkfVxuICAgICAqL1xuICAgIF9yaXBwbGVDb250YWluZXI6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgYSBgPHBhcGVyLXJpcHBsZT5gIGVsZW1lbnQgaXMgYXZhaWxhYmxlIHdoZW4gdGhlIGVsZW1lbnQgaXNcbiAgICogZm9jdXNlZC5cbiAgICovXG4gIF9idXR0b25TdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmZvY3VzZWQpIHtcbiAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbiBhZGRpdGlvbiB0byB0aGUgZnVuY3Rpb25hbGl0eSBwcm92aWRlZCBpbiBgSXJvbkJ1dHRvblN0YXRlYCwgZW5zdXJlc1xuICAgKiBhIHJpcHBsZSBlZmZlY3QgaXMgY3JlYXRlZCB3aGVuIHRoZSBlbGVtZW50IGlzIGluIGEgYHByZXNzZWRgIHN0YXRlLlxuICAgKi9cbiAgX2Rvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIElyb25CdXR0b25TdGF0ZUltcGwuX2Rvd25IYW5kbGVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGlmICh0aGlzLnByZXNzZWQpIHtcbiAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKGV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgdGhpcyBlbGVtZW50IGNvbnRhaW5zIGEgcmlwcGxlIGVmZmVjdC4gRm9yIHN0YXJ0dXAgZWZmaWNpZW5jeVxuICAgKiB0aGUgcmlwcGxlIGVmZmVjdCBpcyBkeW5hbWljYWxseSBvbiBkZW1hbmQgd2hlbiBuZWVkZWQuXG4gICAqIEBwYXJhbSB7IUV2ZW50PX0gb3B0VHJpZ2dlcmluZ0V2ZW50IChvcHRpb25hbCkgZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlXG4gICAqIHJpcHBsZS5cbiAgICovXG4gIGVuc3VyZVJpcHBsZTogZnVuY3Rpb24ob3B0VHJpZ2dlcmluZ0V2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICB0aGlzLl9yaXBwbGUgPSB0aGlzLl9jcmVhdGVSaXBwbGUoKTtcbiAgICAgIHRoaXMuX3JpcHBsZS5ub2luayA9IHRoaXMubm9pbms7XG4gICAgICB2YXIgcmlwcGxlQ29udGFpbmVyID0gdGhpcy5fcmlwcGxlQ29udGFpbmVyIHx8IHRoaXMucm9vdDtcbiAgICAgIGlmIChyaXBwbGVDb250YWluZXIpIHtcbiAgICAgICAgZG9tKHJpcHBsZUNvbnRhaW5lcikuYXBwZW5kQ2hpbGQodGhpcy5fcmlwcGxlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRUcmlnZ2VyaW5nRXZlbnQpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV2ZW50IGhhcHBlbmVkIGluc2lkZSBvZiB0aGUgcmlwcGxlIGNvbnRhaW5lclxuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gaG9zdCBpbnN0ZWFkIG9mIHRoZSByb290IGJlY2F1c2UgZGlzdHJpYnV0ZWQgdGV4dFxuICAgICAgICAvLyBub2RlcyBhcmUgbm90IHZhbGlkIGV2ZW50IHRhcmdldHNcbiAgICAgICAgdmFyIGRvbUNvbnRhaW5lciA9IGRvbSh0aGlzLl9yaXBwbGVDb250YWluZXIgfHwgdGhpcyk7XG4gICAgICAgIHZhciB0YXJnZXQgPSBkb20ob3B0VHJpZ2dlcmluZ0V2ZW50KS5yb290VGFyZ2V0O1xuICAgICAgICBpZiAoZG9tQ29udGFpbmVyLmRlZXBDb250YWlucyggLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSkge1xuICAgICAgICAgIHRoaXMuX3JpcHBsZS51aURvd25BY3Rpb24ob3B0VHJpZ2dlcmluZ0V2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYDxwYXBlci1yaXBwbGU+YCBlbGVtZW50IHVzZWQgYnkgdGhpcyBlbGVtZW50IHRvIGNyZWF0ZVxuICAgKiByaXBwbGUgZWZmZWN0cy4gVGhlIGVsZW1lbnQncyByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQsIHdoZW5cbiAgICogbmVjZXNzYXJ5LCBhbmQgY2FsbGluZyB0aGlzIG1ldGhvZCB3aWxsIGZvcmNlIHRoZVxuICAgKiByaXBwbGUgdG8gYmUgY3JlYXRlZC5cbiAgICovXG4gIGdldFJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5lbnN1cmVSaXBwbGUoKTtcbiAgICByZXR1cm4gdGhpcy5fcmlwcGxlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBlbGVtZW50IGN1cnJlbnRseSBjb250YWlucyBhIHJpcHBsZSBlZmZlY3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBCb29sZWFuKHRoaXMuX3JpcHBsZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgZWxlbWVudCdzIHJpcHBsZSBlZmZlY3QgdmlhIGNyZWF0aW5nIGEgYDxwYXBlci1yaXBwbGU+YC5cbiAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gY3VzdG9taXplIHRoZSByaXBwbGUgZWxlbWVudC5cbiAgICogQHJldHVybiB7IVBhcGVyUmlwcGxlRWxlbWVudH0gUmV0dXJucyBhIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudC5cbiAgICovXG4gIF9jcmVhdGVSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFQYXBlclJpcHBsZUVsZW1lbnR9ICovIChcbiAgICAgICAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncGFwZXItcmlwcGxlJykpO1xuICB9LFxuXG4gIF9ub2lua0NoYW5nZWQ6IGZ1bmN0aW9uKG5vaW5rKSB7XG4gICAgaWYgKHRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgIHRoaXMuX3JpcHBsZS5ub2luayA9IG5vaW5rO1xuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1yaXBwbGUtYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGxldCBuYXRpdmVTaGFkb3cgPSAhKHdpbmRvd1snU2hhZHlET00nXSAmJiB3aW5kb3dbJ1NoYWR5RE9NJ11bJ2luVXNlJ10pO1xuZXhwb3J0IGxldCBuYXRpdmVDc3NWYXJpYWJsZXM7XG5cbi8qKlxuICogQHBhcmFtIHsoU2hhZHlDU1NPcHRpb25zIHwgU2hhZHlDU1NJbnRlcmZhY2UpPX0gc2V0dGluZ3NcbiAqL1xuZnVuY3Rpb24gY2FsY0Nzc1ZhcmlhYmxlcyhzZXR0aW5ncykge1xuICBpZiAoc2V0dGluZ3MgJiYgc2V0dGluZ3NbJ3NoaW1jc3Nwcm9wZXJ0aWVzJ10pIHtcbiAgICBuYXRpdmVDc3NWYXJpYWJsZXMgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBjaHJvbWUgNDkgaGFzIHNlbWktd29ya2luZyBjc3MgdmFycywgY2hlY2sgaWYgYm94LXNoYWRvdyB3b3Jrc1xuICAgIC8vIHNhZmFyaSA5LjEgaGFzIGEgcmVjYWxjIGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NTc4MlxuICAgIC8vIEhvd2V2ZXIsIHNoaW0gY3NzIGN1c3RvbSBwcm9wZXJ0aWVzIGFyZSBvbmx5IHN1cHBvcnRlZCB3aXRoIFNoYWR5RE9NIGVuYWJsZWQsXG4gICAgLy8gc28gZmFsbCBiYWNrIG9uIG5hdGl2ZSBpZiB3ZSBkbyBub3QgZGV0ZWN0IFNoYWR5RE9NXG4gICAgLy8gRWRnZSAxNTogY3VzdG9tIHByb3BlcnRpZXMgdXNlZCBpbiA6OmJlZm9yZSBhbmQgOjphZnRlciB3aWxsIGFsc28gYmUgdXNlZCBpbiB0aGUgcGFyZW50IGVsZW1lbnRcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy8xMjQxNDI1Ny9cbiAgICBuYXRpdmVDc3NWYXJpYWJsZXMgPSBuYXRpdmVTaGFkb3cgfHwgQm9vbGVhbighbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC82MDF8RWRnZVxcLzE1LykgJiZcbiAgICAgIHdpbmRvdy5DU1MgJiYgQ1NTLnN1cHBvcnRzICYmIENTUy5zdXBwb3J0cygnYm94LXNoYWRvdycsICcwIDAgMCB2YXIoLS1mb28pJykpO1xuICB9XG59XG5cbmlmICh3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcyAhPT0gdW5kZWZpbmVkKSB7XG4gIG5hdGl2ZUNzc1ZhcmlhYmxlcyA9IHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3M7XG59IGVsc2UgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICBjYWxjQ3NzVmFyaWFibGVzKHdpbmRvdy5TaGFkeUNTUyk7XG4gIC8vIHJlc2V0IHdpbmRvdyB2YXJpYWJsZSB0byBsZXQgU2hhZHlDU1MgQVBJIHRha2UgaXRzIHBsYWNlXG4gIHdpbmRvdy5TaGFkeUNTUyA9IHVuZGVmaW5lZDtcbn0gZWxzZSB7XG4gIGNhbGNDc3NWYXJpYWJsZXMod2luZG93WydXZWJDb21wb25lbnRzJ10gJiYgd2luZG93WydXZWJDb21wb25lbnRzJ11bJ2ZsYWdzJ10pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS1zZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gMjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuLypcbkV4dHJlbWVseSBzaW1wbGUgY3NzIHBhcnNlci4gSW50ZW5kZWQgdG8gYmUgbm90IG1vcmUgdGhhbiB3aGF0IHdlIG5lZWRcbmFuZCBkZWZpbml0ZWx5IG5vdCBuZWNlc3NhcmlseSBjb3JyZWN0ID0pLlxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHVucmVzdHJpY3RlZCAqL1xuY2xhc3MgU3R5bGVOb2RlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpc1snc3RhcnQnXSA9IDA7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpc1snZW5kJ10gPSAwO1xuICAgIC8qKiBAdHlwZSB7U3R5bGVOb2RlfSAqL1xuICAgIHRoaXNbJ3ByZXZpb3VzJ10gPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7U3R5bGVOb2RlfSAqL1xuICAgIHRoaXNbJ3BhcmVudCddID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0FycmF5PFN0eWxlTm9kZT59ICovXG4gICAgdGhpc1sncnVsZXMnXSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1sncGFyc2VkQ3NzVGV4dCddID0gJyc7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1snY3NzVGV4dCddID0gJyc7XG4gICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgIHRoaXNbJ2F0UnVsZSddID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpc1sndHlwZSddID0gMDtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzWydrZXlmcmFtZXNOYW1lJ10gPSAnJztcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzWydzZWxlY3RvciddID0gJyc7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1sncGFyc2VkU2VsZWN0b3InXSA9ICcnO1xuICB9XG59XG5cbmV4cG9ydCB7U3R5bGVOb2RlfVxuXG4vLyBnaXZlbiBhIHN0cmluZyBvZiBjc3MsIHJldHVybiBhIHNpbXBsZSBydWxlIHRyZWVcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgdGV4dCA9IGNsZWFuKHRleHQpO1xuICByZXR1cm4gcGFyc2VDc3MobGV4KHRleHQpLCB0ZXh0KTtcbn1cblxuLy8gcmVtb3ZlIHN0dWZmIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhhdCBtYXkgaGluZGVyIHBhcnNpbmdcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2xlYW4oY3NzVGV4dCkge1xuICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKFJYLmNvbW1lbnRzLCAnJykucmVwbGFjZShSWC5wb3J0LCAnJyk7XG59XG5cbi8vIHN1cGVyIHNpbXBsZSB7Li4ufSBsZXhlciB0aGF0IHJldHVybnMgYSBub2RlIHRyZWVcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAqL1xuZnVuY3Rpb24gbGV4KHRleHQpIHtcbiAgbGV0IHJvb3QgPSBuZXcgU3R5bGVOb2RlKCk7XG4gIHJvb3RbJ3N0YXJ0J10gPSAwO1xuICByb290WydlbmQnXSA9IHRleHQubGVuZ3RoXG4gIGxldCBuID0gcm9vdDtcbiAgZm9yIChsZXQgaSA9IDAsIGwgPSB0ZXh0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh0ZXh0W2ldID09PSBPUEVOX0JSQUNFKSB7XG4gICAgICBpZiAoIW5bJ3J1bGVzJ10pIHtcbiAgICAgICAgblsncnVsZXMnXSA9IFtdO1xuICAgICAgfVxuICAgICAgbGV0IHAgPSBuO1xuICAgICAgbGV0IHByZXZpb3VzID0gcFsncnVsZXMnXVtwWydydWxlcyddLmxlbmd0aCAtIDFdIHx8IG51bGw7XG4gICAgICBuID0gbmV3IFN0eWxlTm9kZSgpO1xuICAgICAgblsnc3RhcnQnXSA9IGkgKyAxO1xuICAgICAgblsncGFyZW50J10gPSBwO1xuICAgICAgblsncHJldmlvdXMnXSA9IHByZXZpb3VzO1xuICAgICAgcFsncnVsZXMnXS5wdXNoKG4pO1xuICAgIH0gZWxzZSBpZiAodGV4dFtpXSA9PT0gQ0xPU0VfQlJBQ0UpIHtcbiAgICAgIG5bJ2VuZCddID0gaSArIDE7XG4gICAgICBuID0gblsncGFyZW50J10gfHwgcm9vdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJvb3Q7XG59XG5cbi8vIGFkZCBzZWxlY3RvcnMvY3NzVGV4dCB0byBub2RlIHRyZWVcbi8qKlxuICogQHBhcmFtIHtTdHlsZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ3NzKG5vZGUsIHRleHQpIHtcbiAgbGV0IHQgPSB0ZXh0LnN1YnN0cmluZyhub2RlWydzdGFydCddLCBub2RlWydlbmQnXSAtIDEpO1xuICBub2RlWydwYXJzZWRDc3NUZXh0J10gPSBub2RlWydjc3NUZXh0J10gPSB0LnRyaW0oKTtcbiAgaWYgKG5vZGVbJ3BhcmVudCddKSB7XG4gICAgbGV0IHNzID0gbm9kZVsncHJldmlvdXMnXSA/IG5vZGVbJ3ByZXZpb3VzJ11bJ2VuZCddIDogbm9kZVsncGFyZW50J11bJ3N0YXJ0J107XG4gICAgdCA9IHRleHQuc3Vic3RyaW5nKHNzLCBub2RlWydzdGFydCddIC0gMSk7XG4gICAgdCA9IF9leHBhbmRVbmljb2RlRXNjYXBlcyh0KTtcbiAgICB0ID0gdC5yZXBsYWNlKFJYLm11bHRpcGxlU3BhY2VzLCAnICcpO1xuICAgIC8vIFRPRE8oc29ydmVsbCk6IGFkIGhvYzsgbWFrZSBzZWxlY3RvciBpbmNsdWRlIG9ubHkgYWZ0ZXIgbGFzdCA7XG4gICAgLy8gaGVscHMgd2l0aCBtaXhpbiBzeW50YXhcbiAgICB0ID0gdC5zdWJzdHJpbmcodC5sYXN0SW5kZXhPZignOycpICsgMSk7XG4gICAgbGV0IHMgPSBub2RlWydwYXJzZWRTZWxlY3RvciddID0gbm9kZVsnc2VsZWN0b3InXSA9IHQudHJpbSgpO1xuICAgIG5vZGVbJ2F0UnVsZSddID0gKHMuaW5kZXhPZihBVF9TVEFSVCkgPT09IDApO1xuICAgIC8vIG5vdGUsIHN1cHBvcnQgYSBzdWJzZXQgb2YgcnVsZSB0eXBlcy4uLlxuICAgIGlmIChub2RlWydhdFJ1bGUnXSkge1xuICAgICAgaWYgKHMuaW5kZXhPZihNRURJQV9TVEFSVCkgPT09IDApIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuTUVESUFfUlVMRTtcbiAgICAgIH0gZWxzZSBpZiAocy5tYXRjaChSWC5rZXlmcmFtZXNSdWxlKSkge1xuICAgICAgICBub2RlWyd0eXBlJ10gPSB0eXBlcy5LRVlGUkFNRVNfUlVMRTtcbiAgICAgICAgbm9kZVsna2V5ZnJhbWVzTmFtZSddID1cbiAgICAgICAgICBub2RlWydzZWxlY3RvciddLnNwbGl0KFJYLm11bHRpcGxlU3BhY2VzKS5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHMuaW5kZXhPZihWQVJfU1RBUlQpID09PSAwKSB7XG4gICAgICAgIG5vZGVbJ3R5cGUnXSA9IHR5cGVzLk1JWElOX1JVTEU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlWyd0eXBlJ10gPSB0eXBlcy5TVFlMRV9SVUxFO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBsZXQgciQgPSBub2RlWydydWxlcyddO1xuICBpZiAociQpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHIkLmxlbmd0aCwgcjtcbiAgICAgIChpIDwgbCkgJiYgKHIgPSByJFtpXSk7IGkrKykge1xuICAgICAgcGFyc2VDc3MociwgdGV4dCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIGNvbnZlcnNpb24gb2Ygc29ydCB1bmljb2RlIGVzY2FwZXMgd2l0aCBzcGFjZXMgbGlrZSBgXFwzMyBgIChhbmQgbG9uZ2VyKSBpbnRvXG4gKiBleHBhbmRlZCBmb3JtIHRoYXQgZG9lc24ndCByZXF1aXJlIHRyYWlsaW5nIHNwYWNlIGBcXDAwMDAzM2BcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIF9leHBhbmRVbmljb2RlRXNjYXBlcyhzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoL1xcXFwoWzAtOWEtZl17MSw2fSlcXHMvZ2ksIGZ1bmN0aW9uKCkge1xuICAgIGxldCBjb2RlID0gYXJndW1lbnRzWzFdLFxuICAgICAgcmVwZWF0ID0gNiAtIGNvZGUubGVuZ3RoO1xuICAgIHdoaWxlIChyZXBlYXQtLSkge1xuICAgICAgY29kZSA9ICcwJyArIGNvZGU7XG4gICAgfVxuICAgIHJldHVybiAnXFxcXCcgKyBjb2RlO1xuICB9KTtcbn1cblxuLyoqXG4gKiBzdHJpbmdpZnkgcGFyc2VkIGNzcy5cbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBwcmVzZXJ2ZVByb3BlcnRpZXNcbiAqIEBwYXJhbSB7c3RyaW5nPX0gdGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KG5vZGUsIHByZXNlcnZlUHJvcGVydGllcywgdGV4dCA9ICcnKSB7XG4gIC8vIGNhbGMgcnVsZSBjc3NUZXh0XG4gIGxldCBjc3NUZXh0ID0gJyc7XG4gIGlmIChub2RlWydjc3NUZXh0J10gfHwgbm9kZVsncnVsZXMnXSkge1xuICAgIGxldCByJCA9IG5vZGVbJ3J1bGVzJ107XG4gICAgaWYgKHIkICYmICFfaGFzTWl4aW5SdWxlcyhyJCkpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gciQubGVuZ3RoLCByO1xuICAgICAgICAoaSA8IGwpICYmIChyID0gciRbaV0pOyBpKyspIHtcbiAgICAgICAgY3NzVGV4dCA9IHN0cmluZ2lmeShyLCBwcmVzZXJ2ZVByb3BlcnRpZXMsIGNzc1RleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjc3NUZXh0ID0gcHJlc2VydmVQcm9wZXJ0aWVzID8gbm9kZVsnY3NzVGV4dCddIDpcbiAgICAgICAgcmVtb3ZlQ3VzdG9tUHJvcHMobm9kZVsnY3NzVGV4dCddKTtcbiAgICAgIGNzc1RleHQgPSBjc3NUZXh0LnRyaW0oKTtcbiAgICAgIGlmIChjc3NUZXh0KSB7XG4gICAgICAgIGNzc1RleHQgPSAnICAnICsgY3NzVGV4dCArICdcXG4nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBlbWl0IHJ1bGUgaWYgdGhlcmUgaXMgY3NzVGV4dFxuICBpZiAoY3NzVGV4dCkge1xuICAgIGlmIChub2RlWydzZWxlY3RvciddKSB7XG4gICAgICB0ZXh0ICs9IG5vZGVbJ3NlbGVjdG9yJ10gKyAnICcgKyBPUEVOX0JSQUNFICsgJ1xcbic7XG4gICAgfVxuICAgIHRleHQgKz0gY3NzVGV4dDtcbiAgICBpZiAobm9kZVsnc2VsZWN0b3InXSkge1xuICAgICAgdGV4dCArPSBDTE9TRV9CUkFDRSArICdcXG5cXG4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFN0eWxlTm9kZT59IHJ1bGVzXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBfaGFzTWl4aW5SdWxlcyhydWxlcykge1xuICBsZXQgciA9IHJ1bGVzWzBdO1xuICByZXR1cm4gQm9vbGVhbihyKSAmJiBCb29sZWFuKHJbJ3NlbGVjdG9yJ10pICYmIHJbJ3NlbGVjdG9yJ10uaW5kZXhPZihWQVJfU1RBUlQpID09PSAwO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUN1c3RvbVByb3BzKGNzc1RleHQpIHtcbiAgY3NzVGV4dCA9IHJlbW92ZUN1c3RvbVByb3BBc3NpZ25tZW50KGNzc1RleHQpO1xuICByZXR1cm4gcmVtb3ZlQ3VzdG9tUHJvcEFwcGx5KGNzc1RleHQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW1vdmVDdXN0b21Qcm9wQXNzaWdubWVudChjc3NUZXh0KSB7XG4gIHJldHVybiBjc3NUZXh0XG4gICAgLnJlcGxhY2UoUlguY3VzdG9tUHJvcCwgJycpXG4gICAgLnJlcGxhY2UoUlgubWl4aW5Qcm9wLCAnJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tUHJvcEFwcGx5KGNzc1RleHQpIHtcbiAgcmV0dXJuIGNzc1RleHRcbiAgICAucmVwbGFjZShSWC5taXhpbkFwcGx5LCAnJylcbiAgICAucmVwbGFjZShSWC52YXJBcHBseSwgJycpO1xufVxuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmV4cG9ydCBjb25zdCB0eXBlcyA9IHtcbiAgU1RZTEVfUlVMRTogMSxcbiAgS0VZRlJBTUVTX1JVTEU6IDcsXG4gIE1FRElBX1JVTEU6IDQsXG4gIE1JWElOX1JVTEU6IDEwMDBcbn1cblxuY29uc3QgT1BFTl9CUkFDRSA9ICd7JztcbmNvbnN0IENMT1NFX0JSQUNFID0gJ30nO1xuXG4vLyBoZWxwZXIgcmVnZXhwJ3NcbmNvbnN0IFJYID0ge1xuICBjb21tZW50czogL1xcL1xcKlteKl0qXFwqKyhbXi8qXVteKl0qXFwqKykqXFwvL2dpbSxcbiAgcG9ydDogL0BpbXBvcnRbXjtdKjsvZ2ltLFxuICBjdXN0b21Qcm9wOiAvKD86XlteO1xcLVxcc31dKyk/LS1bXjt7fV0qPzpbXnt9O10qPyg/Ols7XFxuXXwkKS9naW0sXG4gIG1peGluUHJvcDogLyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj97W159XSo/fSg/Ols7XFxuXXwkKT8vZ2ltLFxuICBtaXhpbkFwcGx5OiAvQGFwcGx5XFxzKlxcKD9bXik7XSpcXCk/XFxzKig/Ols7XFxuXXwkKT8vZ2ltLFxuICB2YXJBcHBseTogL1teOzpdKj86W147XSo/dmFyXFwoW147XSpcXCkoPzpbO1xcbl18JCk/L2dpbSxcbiAga2V5ZnJhbWVzUnVsZTogL15AW15cXHNdKmtleWZyYW1lcy8sXG4gIG11bHRpcGxlU3BhY2VzOiAvXFxzKy9nXG59XG5cbmNvbnN0IFZBUl9TVEFSVCA9ICctLSc7XG5jb25zdCBNRURJQV9TVEFSVCA9ICdAbWVkaWEnO1xuY29uc3QgQVRfU1RBUlQgPSAnQCc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY3NzLXBhcnNlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5leHBvcnQgY29uc3QgVkFSX0FTU0lHTiA9IC8oPzpefFs7XFxze11cXHMqKSgtLVtcXHctXSo/KVxccyo6XFxzKig/OigoPzonKD86XFxcXCd8LikqPyd8XCIoPzpcXFxcXCJ8LikqP1wifFxcKFteKV0qP1xcKXxbXn07e10pKyl8XFx7KFtefV0qKVxcfSg/Oig/PVs7XFxzfV0pfCQpKS9naTtcbmV4cG9ydCBjb25zdCBNSVhJTl9NQVRDSCA9IC8oPzpefFxcVyspQGFwcGx5XFxzKlxcKD8oW14pO1xcbl0qKVxcKT8vZ2k7XG5leHBvcnQgY29uc3QgVkFSX0NPTlNVTUVEID0gLygtLVtcXHctXSspXFxzKihbOiw7KV18JCkvZ2k7XG5leHBvcnQgY29uc3QgQU5JTUFUSU9OX01BVENIID0gLyhhbmltYXRpb25cXHMqOil8KGFuaW1hdGlvbi1uYW1lXFxzKjopLztcbmV4cG9ydCBjb25zdCBNRURJQV9NQVRDSCA9IC9AbWVkaWFcXHMoLiopLztcbmV4cG9ydCBjb25zdCBJU19WQVIgPSAvXi0tLztcbmV4cG9ydCBjb25zdCBCUkFDS0VURUQgPSAvXFx7W159XSpcXH0vZztcbmV4cG9ydCBjb25zdCBIT1NUX1BSRUZJWCA9ICcoPzpefFteLiNbOl0pJztcbmV4cG9ydCBjb25zdCBIT1NUX1NVRkZJWCA9ICcoJHxbLjpbXFxcXHM+K35dKSc7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXJlZ2V4LmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7IE1JWElOX01BVENILCBWQVJfQVNTSUdOIH0gZnJvbSAnLi9jb21tb24tcmVnZXguanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgLy8gcmVtb3ZlIHByZXZpb3VzIHByb3BlcnRpZXNcbiAgZm9yIChsZXQgcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgLy8gTk9URTogZm9yIGJjIHdpdGggc2hpbSwgZG9uJ3QgYXBwbHkgbnVsbCB2YWx1ZXMuXG4gICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkocCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkocCwgcHJvcGVydGllc1twXSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGVWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAvKipcbiAgICogQGNvbnN0IHtzdHJpbmd9XG4gICAqL1xuICBjb25zdCB2YWx1ZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUocHJvcGVydHkpO1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG4gIH1cbn1cblxuLyoqXG4gKiByZXR1cm4gdHJ1ZSBpZiBgY3NzVGV4dGAgY29udGFpbnMgYSBtaXhpbiBkZWZpbml0aW9uIG9yIGNvbnN1bXB0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRldGVjdE1peGluKGNzc1RleHQpIHtcbiAgY29uc3QgaGFzID0gTUlYSU5fTUFUQ0gudGVzdChjc3NUZXh0KSB8fCBWQVJfQVNTSUdOLnRlc3QoY3NzVGV4dCk7XG4gIC8vIHJlc2V0IHN0YXRlIG9mIHRoZSByZWdleGVzXG4gIE1JWElOX01BVENILmxhc3RJbmRleCA9IDA7XG4gIFZBUl9BU1NJR04ubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIGhhcztcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jb21tb24tdXRpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyByb290UGF0aCBhcyByb290UGF0aCQwIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCAqIGFzIGNhc2VNYXAkMCBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBjYW1lbFRvRGFzaENhc2UgfSBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBjc3NGcm9tTW9kdWxlSW1wb3J0cywgY3NzRnJvbVRlbXBsYXRlIH0gZnJvbSAnLi4vdXRpbHMvc3R5bGUtZ2F0aGVyLmpzJztcbmltcG9ydCB7IHJlc29sdmVVcmwgYXMgcmVzb2x2ZVVybCQwIH0gZnJvbSAnLi4vdXRpbHMvcmVzb2x2ZS11cmwuanMnO1xuaW1wb3J0IHsgRG9tTW9kdWxlIH0gZnJvbSAnLi4vZWxlbWVudHMvZG9tLW1vZHVsZS5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUVmZmVjdHMgfSBmcm9tICcuL3Byb3BlcnR5LWVmZmVjdHMuanMnO1xuXG5leHBvcnQgY29uc3QgRWxlbWVudE1peGluID0gZGVkdXBpbmdNaXhpbihiYXNlID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtiYXNlfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqL1xuICBjb25zdCBwb2x5bWVyRWxlbWVudEJhc2UgPSBQcm9wZXJ0eUVmZmVjdHMoYmFzZSk7XG5cbiAgbGV0IGNhc2VNYXAgPSBjYXNlTWFwJDA7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGBwcm9wZXJ0aWVzYCBvYmplY3Qgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3I6XG4gICAqICgxKSBzdXBlciBjaGFpbiBtaXhlcyB0b2d0aGVyIHRvIG1ha2UgYHByb3BlcnRpZXNGb3JDbGFzc2Agd2hpY2ggaXNcbiAgICogdGhlbiB1c2VkIHRvIG1ha2UgYG9ic2VydmVkQXR0cmlidXRlc2AuXG4gICAqICgyKSBwcm9wZXJ0aWVzIGVmZmVjdHMgYW5kIG9ic2VydmVycyBhcmUgY3JlYXRlZCBmcm9tIGl0IGF0IGBmaW5hbGl6ZWAgdGltZS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IE9iamVjdCBjb250YWluaW5nIG93biBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25Qcm9wZXJ0aWVzJywga2xhc3MpKSkge1xuICAgICAga2xhc3MuX19vd25Qcm9wZXJ0aWVzID1cbiAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgncHJvcGVydGllcycsIGtsYXNzKSkgP1xuICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3BlcnRpZXMgOiB7fTtcbiAgICB9XG4gICAgcmV0dXJuIGtsYXNzLl9fb3duUHJvcGVydGllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgb2JzZXJ2ZXJzYCBhcnJheSBzcGVjaWZpY2FsbHkgb24gYGtsYXNzYC4gVXNlIGZvclxuICAgKiBzZXR0aW5nIHVwIG9ic2VydmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgY29udGFpbmluZyBvd24gb2JzZXJ2ZXJzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcykge1xuICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX293bk9ic2VydmVycycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fb3duT2JzZXJ2ZXJzID1cbiAgICAgICAga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnb2JzZXJ2ZXJzJywga2xhc3MpKSA/XG4gICAgICAgIC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykub2JzZXJ2ZXJzIDogW107XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX293bk9ic2VydmVycztcbiAgfVxuXG4gIC8qKlxuICAgKiBNaXhlcyBgcHJvcHNgIGludG8gYGZsYXR0ZW5lZFByb3BzYCBidXQgdXBncmFkZXMgc2hvcnRoYW5kIHR5cGVcbiAgICogc3ludGF4IHRvIHsgdHlwZTogVHlwZX0uXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmbGF0dGVuZWRQcm9wcyBCYWcgdG8gY29sbGVjdCBmbGF0dGVuZWQgcHJvcGVydGllcyBpbnRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydGllcyB0byBhZGQgdG8gYGZsYXR0ZW5lZFByb3BzYFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBpbnB1dCBgZmxhdHRlbmVkUHJvcHNgIGJhZ1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmxhdHRlblByb3BlcnRpZXMoZmxhdHRlbmVkUHJvcHMsIHByb3BzKSB7XG4gICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgbGV0IG8gPSBwcm9wc1twXTtcbiAgICAgIGlmICh0eXBlb2YgbyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG8gPSB7IHR5cGU6IG8gfTtcbiAgICAgIH1cbiAgICAgIGZsYXR0ZW5lZFByb3BzW3BdID0gbztcbiAgICB9XG4gICAgcmV0dXJuIGZsYXR0ZW5lZFByb3BzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBmbGF0dGVuZWQgbGlzdCBvZiBwcm9wZXJ0aWVzIG1peGVkIHRvZ2V0aGVyIGZyb20gdGhlIGNoYWluIG9mIGFsbFxuICAgKiBjb25zdHJ1Y3RvcidzIGBjb25maWcucHJvcGVydGllc2AuIFRoaXMgbGlzdCBpcyB1c2VkIHRvIGNyZWF0ZVxuICAgKiAoMSkgb2JzZXJ2ZWRBdHRyaWJ1dGVzLFxuICAgKiAoMikgY2xhc3MgcHJvcGVydHkgZGVmYXVsdCB2YWx1ZXNcbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEByZXR1cm4ge1BvbHltZXJFbGVtZW50UHJvcGVydGllc30gRmxhdHRlbmVkIHByb3BlcnRpZXMgZm9yIHRoaXMgY2xhc3NcbiAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBhIHByb3BlcnR5IGZvciBzb21lIHJlYXNvbj9cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIHByb3BlcnRpZXNGb3JDbGFzcyhrbGFzcykge1xuICAgIGlmICgha2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX2NsYXNzUHJvcGVydGllcycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzID1cbiAgICAgIGZsYXR0ZW5Qcm9wZXJ0aWVzKHt9LCBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpKTtcbiAgICAgIGxldCBzdXBlckN0b3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Yoa2xhc3MucHJvdG90eXBlKS5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChzdXBlckN0b3IucHJvdG90eXBlIGluc3RhbmNlb2YgUG9seW1lckVsZW1lbnQpIHtcbiAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgIE9iamVjdC5jcmVhdGUocHJvcGVydGllc0ZvckNsYXNzKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovKHN1cGVyQ3RvcikpKSxcbiAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydGllcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAqIFRoaXMgbGlzdCBpcyBjcmVhdGVkIGFzIGFuIG9wdGltaXphdGlvbiBzaW5jZSBpdCBpcyBhIHN1YnNldCBvZlxuICAgKiB0aGUgbGlzdCByZXR1cm5lZCBmcm9tIGBwcm9wZXJ0aWVzRm9yQ2xhc3NgLlxuICAgKiBUaGlzIGxpc3QgaXMgdXNlZCBpbiBgX2luaXRpYWxpemVQcm9wZXJ0aWVzYCB0byBzZXQgcHJvcGVydHkgZGVmYXVsdHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqICAgdGhhdCBoYXZlIGRlZmF1bHQgdmFsdWVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMnLCBrbGFzcykpKSB7XG4gICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyA9IG51bGw7XG4gICAgICBsZXQgcHJvcHMgPSBwcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICBsZXQgaW5mbyA9IHByb3BzW3BdO1xuICAgICAgICBpZiAoJ3ZhbHVlJyBpbiBpbmZvKSB7XG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgPSBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cyB8fCB7fTtcbiAgICAgICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0c1twXSA9IGluZm87XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBhIGBrbGFzc2AgaGFzIGZpbmFsaXplZC4gQ2FsbGVkIGluIGBFbGVtZW50Q2xhc3MuZmluYWxpemUoKWBcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWxsIG1ldGFwcm9ncmFtbWluZyBmb3IgdGhpcyBjbGFzcyBoYXMgYmVlblxuICAgKiAgIGNvbXBsZXRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzQ2xhc3NGaW5hbGl6ZWQoa2xhc3MpIHtcbiAgICByZXR1cm4ga2xhc3MuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19maW5hbGl6ZWQnLCBrbGFzcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBieSBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgLiBFbnN1cmVzIHRoaXMgYGtsYXNzYCBhbmRcbiAgICogKmFsbCBzdXBlcmNsYXNzZXMqIGFyZSBmaW5hbGl6ZWQgYnkgdHJhdmVyc2luZyB0aGUgcHJvdG90eXBlIGNoYWluXG4gICAqIGFuZCBjYWxsaW5nIGBrbGFzcy5maW5hbGl6ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIoa2xhc3MpIHtcbiAgICBsZXQgcHJvdG8gPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3RvdHlwZTtcbiAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICBzdXBlckN0b3IuZmluYWxpemUoKTtcbiAgICB9XG4gICAgZmluYWxpemVDbGFzcyhrbGFzcyk7XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyBhIGBrbGFzc2AgYmFzZWQgb24gYSBzdGFpYyBga2xhc3MuY29uZmlnYCBvYmplY3QgYW5kXG4gICAqIGEgYHRlbXBsYXRlYC4gVGhpcyBpbmNsdWRlcyBjcmVhdGluZyBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICogZm9yIHByb3BlcnRpZXMgaW4gYGNvbmZpZ2AgYW5kIHRoZSBgdGVtcGxhdGVgIGFzIHdlbGwgYXMgcHJlcGFyaW5nIHRoZVxuICAgKiBgdGVtcGxhdGVgIGZvciBzdGFtcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yfSBrbGFzcyBFbGVtZW50IGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZUNsYXNzKGtsYXNzKSB7XG4gICAga2xhc3MuX19maW5hbGl6ZWQgPSB0cnVlO1xuICAgIGxldCBwcm90byA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykucHJvdG90eXBlO1xuICAgIGlmIChrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ2lzJywga2xhc3MpKSAmJiBrbGFzcy5pcykge1xuICAgICAgcmVnaXN0ZXIocHJvdG8pO1xuICAgIH1cbiAgICBsZXQgcHJvcHMgPSBvd25Qcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wcyk7XG4gICAgfVxuICAgIGxldCBvYnNlcnZlcnMgPSBvd25PYnNlcnZlcnNGb3JDbGFzcyhrbGFzcyk7XG4gICAgaWYgKG9ic2VydmVycykge1xuICAgICAgZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgcHJvcHMpO1xuICAgIH1cbiAgICAvLyBub3RlOiBjcmVhdGUgXCJ3b3JraW5nXCIgdGVtcGxhdGUgdGhhdCBpcyBmaW5hbGl6ZWQgYXQgaW5zdGFuY2UgdGltZVxuICAgIGxldCB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yICovIChrbGFzcykudGVtcGxhdGU7XG4gICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICBpZiAodHlwZW9mIHRlbXBsYXRlID09PSAnc3RyaW5nJykge1xuICAgICAgICBsZXQgdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyk7XG4gICAgICAgIHQuaW5uZXJIVE1MID0gdGVtcGxhdGU7XG4gICAgICAgIHRlbXBsYXRlID0gdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAgfVxuICAgICAgcHJvdG8uX3RlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYHByb3BlcnRpZXNgIG9iamVjdC5cbiAgICogTGV2ZXJhZ2VzIGBQcm9wZXJ0eUVmZmVjdHNgIHRvIGNyZWF0ZSBwcm9wZXJ0eSBhY2Nlc3NvcnMgYW5kIGVmZmVjdHNcbiAgICogc3VwcG9ydGluZywgb2JzZXJ2ZXJzLCByZWZsZWN0aW5nIHRvIGF0dHJpYnV0ZXMsIGNoYW5nZSBub3RpZmljYXRpb24sXG4gICAqIGNvbXB1dGVkIHByb3BlcnRpZXMsIGFuZCByZWFkIG9ubHkgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgICBhbmQgZWZmZWN0cyB0b1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBGbGF0dGVuZWQgYmFnIG9mIHByb3BlcnR5IGRlc2NyaXB0b3JzIGZvclxuICAgKiAgICB0aGlzIGNsYXNzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGxldCBwIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGNyZWF0ZVByb3BlcnR5RnJvbUNvbmZpZyhwcm90bywgcCwgcHJvcGVydGllc1twXSwgcHJvcGVydGllcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBgcHJvdG9gIGJhc2VkIG9uIGEgYG9ic2VydmVyc2AgYXJyYXkuXG4gICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgb2JzZXJ2ZXJzLlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IG9ic2VydmVycyBGbGF0dGVuZWQgYXJyYXkgb2Ygb2JzZXJ2ZXIgZGVzY3JpcHRvcnMgZm9yXG4gICAqICAgdGhpcyBjbGFzc1xuICAgKiBAcGFyYW0ge09iamVjdH0gZHluYW1pY0ZucyBPYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBhbnkgcHJvcGVydGllc1xuICAgKiAgIHRoYXQgYXJlIGZ1bmN0aW9ucyBhbmQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdCB3aGVuIHRoZSBmdW5jdGlvblxuICAgKiAgIHJlZmVyZW5jZSBpcyBjaGFuZ2VkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBmaW5hbGl6ZU9ic2VydmVycyhwcm90bywgb2JzZXJ2ZXJzLCBkeW5hbWljRm5zKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgb2JzZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwcm90by5fY3JlYXRlTWV0aG9kT2JzZXJ2ZXIob2JzZXJ2ZXJzW2ldLCBkeW5hbWljRm5zKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBlZmZlY3RzIGZvciBhIHByb3BlcnR5LlxuICAgKlxuICAgKiBOb3RlLCBvbmNlIGEgcHJvcGVydHkgaGFzIGJlZW4gc2V0IHRvXG4gICAqIGByZWFkT25seWAsIGBjb21wdXRlZGAsIGByZWZsZWN0VG9BdHRyaWJ1dGVgLCBvciBgbm90aWZ5YFxuICAgKiB0aGVzZSB2YWx1ZXMgbWF5IG5vdCBiZSBjaGFuZ2VkLiBGb3IgZXhhbXBsZSwgYSBzdWJjbGFzcyBjYW5ub3RcbiAgICogYWx0ZXIgdGhlc2Ugc2V0dGluZ3MuIEhvd2V2ZXIsIGFkZGl0aW9uYWwgYG9ic2VydmVyc2AgbWF5IGJlIGFkZGVkXG4gICAqIGJ5IHN1YmNsYXNzZXMuXG4gICAqXG4gICAqIFRoZSBpbmZvIG9iamVjdCBzaG91bGQgbWF5IGNvbnRhaW4gcHJvcGVydHkgbWV0YWRhdGEgYXMgZm9sbG93czpcbiAgICpcbiAgICogKiBgdHlwZWA6IHtmdW5jdGlvbn0gdHlwZSB0byB3aGljaCBhbiBhdHRyaWJ1dGUgbWF0Y2hpbmcgdGhlIHByb3BlcnR5XG4gICAqIGlzIGRlc2VyaWFsaXplZC4gTm90ZSB0aGUgcHJvcGVydHkgaXMgY2FtZWwtY2FzZWQgZnJvbSBhIGRhc2gtY2FzZWRcbiAgICogYXR0cmlidXRlLiBGb3IgZXhhbXBsZSwgJ2Zvby1iYXInIGF0dHJpYnV0ZSBpcyBkZXJzaWFsaXplZCB0byBhXG4gICAqIHByb3BlcnR5IG5hbWVkICdmb29CYXInLlxuICAgKlxuICAgKiAqIGByZWFkT25seWA6IHtib29sZWFufSBjcmVhdGVzIGEgcmVhZE9ubHkgcHJvcGVydHkgYW5kXG4gICAqIG1ha2VzIGEgcHJpdmF0ZSBzZXR0ZXIgZm9yIHRoZSBwcml2YXRlIG9mIHRoZSBmb3JtICdfc2V0Rm9vJyBmb3IgYVxuICAgKiBwcm9wZXJ0eSAnZm9vJyxcbiAgICpcbiAgICogKiBgY29tcHV0ZWRgOiB7c3RyaW5nfSBjcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkuIEEgY29tcHV0ZWQgcHJvcGVydHlcbiAgICogYWxzbyBhdXRvbWF0aWNhbGx5IGlzIHNldCB0byBgcmVhZE9ubHk6IHRydWVgLiBUaGUgdmFsdWUgaXMgY2FsY3VsYXRlZFxuICAgKiBieSBydW5uaW5nIGEgbWV0aG9kIGFuZCBhcmd1bWVudHMgcGFyc2VkIGZyb20gdGhlIGdpdmVuIHN0cmluZy4gRm9yXG4gICAqIGV4YW1wbGUgJ2NvbXB1dGUoZm9vKScgd2lsbCBjb21wdXRlIGEgZ2l2ZW4gcHJvcGVydHkgd2hlbiB0aGVcbiAgICogJ2ZvbycgcHJvcGVydHkgY2hhbmdlcyBieSBleGVjdXRpbmcgdGhlICdjb21wdXRlJyBtZXRob2QuIFRoaXMgbWV0aG9kXG4gICAqIG11c3QgcmV0dXJuIHRoZSBjb21wdXRlZCB2YWx1ZS5cbiAgICpcbiAgICogKiBgcmVmbGVjdFRvQXR0cml1dGVgOiB7Ym9vbGVhbn0gSWYgdHJ1ZSwgdGhlIHByb3BlcnR5IHZhbHVlIGlzIHJlZmxlY3RlZFxuICAgKiB0byBhbiBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS4gTm90ZSwgdGhlIGF0dHJpYnV0ZSBpcyBkYXNoLWNhc2VkXG4gICAqIHNvIGEgcHJvcGVydHkgbmFtZWQgJ2Zvb0JhcicgaXMgcmVmbGVjdGVkIGFzICdmb28tYmFyJy5cbiAgICpcbiAgICogKiBgbm90aWZ5YDoge2Jvb2xlYW59IHNlbmRzIGEgbm9uLWJ1YmJsaW5nIG5vdGlmaWNhdGlvbiBldmVudCB3aGVuXG4gICAqIHRoZSBwcm9wZXJ0eSBjaGFuZ2VzLiBGb3IgZXhhbXBsZSwgYSBwcm9wZXJ0eSBuYW1lZCAnZm9vJyBzZW5kcyBhblxuICAgKiBldmVudCBuYW1lZCAnZm9vLWNoYW5nZWQnIHdpdGggYGV2ZW50LmRldGFpbGAgc2V0IHRvIHRoZSB2YWx1ZSBvZlxuICAgKiB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqICogb2JzZXJ2ZXI6IHtzdHJpbmd9IG5hbWUgb2YgYSBtZXRob2QgdGhhdCBydW5zIHdoZW4gdGhlIHByb3BlcnR5XG4gICAqIGNoYW5nZXMuIFRoZSBhcmd1bWVudHMgb2YgdGhlIG1ldGhvZCBhcmUgKHZhbHVlLCBwcmV2aW91c1ZhbHVlKS5cbiAgICpcbiAgICogTm90ZTogVXNlcnMgbWF5IHdhbnQgY29udHJvbCBvdmVyIG1vZGlmeWluZyBwcm9wZXJ0eVxuICAgKiBlZmZlY3RzIHZpYSBzdWJjbGFzc2luZy4gRm9yIGV4YW1wbGUsIGEgdXNlciBtaWdodCB3YW50IHRvIG1ha2UgYVxuICAgKiByZWZsZWN0VG9BdHRyaWJ1dGUgcHJvcGVydHkgbm90IGRvIHNvIGluIGEgc3ViY2xhc3MuIFdlJ3ZlIGNob3NlbiB0b1xuICAgKiBkaXNhYmxlIHRoaXMgYmVjYXVzZSBpdCBsZWFkcyB0byBhZGRpdGlvbmFsIGNvbXBsaWNhdGlvbi5cbiAgICogRm9yIGV4YW1wbGUsIGEgcmVhZE9ubHkgZWZmZWN0IGdlbmVyYXRlcyBhIHNwZWNpYWwgc2V0dGVyLiBJZiBhIHN1YmNsYXNzXG4gICAqIGRpc2FibGVzIHRoZSBlZmZlY3QsIHRoZSBzZXR0ZXIgd291bGQgZmFpbCB1bmV4cGVjdGVkbHkuXG4gICAqIEJhc2VkIG9uIGZlZWRiYWNrLCB3ZSBtYXkgd2FudCB0byB0cnkgdG8gbWFrZSBlZmZlY3RzIG1vcmUgbWFsbGVhYmxlXG4gICAqIGFuZC9vciBwcm92aWRlIGFuIGFkdmFuY2VkIGFwaSBmb3IgbWFuaXB1bGF0aW5nIHRoZW0uXG4gICAqIEFsc28gY29uc2lkZXIgYWRkaW5nIHdhcm5pbmdzIHdoZW4gYW4gZWZmZWN0IGNhbm5vdCBiZSBjaGFuZ2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbmZvIEluZm8gb2JqZWN0IGZyb20gd2hpY2ggdG8gY3JlYXRlIHByb3BlcnR5IGVmZmVjdHMuXG4gICAqIFN1cHBvcnRlZCBrZXlzOlxuICAgKiBAcGFyYW0ge09iamVjdH0gYWxsUHJvcHMgRmxhdHRlbmVkIG1hcCBvZiBhbGwgcHJvcGVydGllcyBkZWZpbmVkIGluIHRoaXNcbiAgICogICBlbGVtZW50IChpbmNsdWRpbmcgaW5oZXJpdGVkIHByb3BlcnRpZXMpXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIG5hbWUsIGluZm8sIGFsbFByb3BzKSB7XG4gICAgLy8gY29tcHV0ZWQgZm9yY2VzIHJlYWRPbmx5Li4uXG4gICAgaWYgKGluZm8uY29tcHV0ZWQpIHtcbiAgICAgIGluZm8ucmVhZE9ubHkgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBOb3RlLCBzaW5jZSBhbGwgY29tcHV0ZWQgcHJvcGVydGllcyBhcmUgcmVhZE9ubHksIHRoaXMgcHJldmVudHNcbiAgICAvLyBhZGRpbmcgYWRkaXRpb25hbCBjb21wdXRlZCBwcm9wZXJ0eSBlZmZlY3RzICh3aGljaCBsZWFkcyB0byBhIGNvbmZ1c2luZ1xuICAgIC8vIHNldHVwIHdoZXJlIG11bHRpcGxlIHRyaWdnZXJzIGZvciBzZXR0aW5nIGEgcHJvcGVydHkpXG4gICAgLy8gV2hpbGUgd2UgZG8gaGF2ZSBgaGFzQ29tcHV0ZWRFZmZlY3RgIHRoaXMgaXMgc2V0IG9uIHRoZSBwcm9wZXJ0eSdzXG4gICAgLy8gZGVwZW5kZW5jaWVzIHJhdGhlciB0aGFuIGl0c2VsZi5cbiAgICBpZiAoaW5mby5jb21wdXRlZCAgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZUNvbXB1dGVkUHJvcGVydHkobmFtZSwgaW5mby5jb21wdXRlZCwgYWxsUHJvcHMpO1xuICAgIH1cbiAgICBpZiAoaW5mby5yZWFkT25seSAmJiAhcHJvdG8uX2hhc1JlYWRPbmx5RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShuYW1lLCAhaW5mby5jb21wdXRlZCk7XG4gICAgfVxuICAgIGlmIChpbmZvLnJlZmxlY3RUb0F0dHJpYnV0ZSAmJiAhcHJvdG8uX2hhc1JlZmxlY3RFZmZlY3QobmFtZSkpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gICAgaWYgKGluZm8ubm90aWZ5ICYmICFwcm90by5faGFzTm90aWZ5RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIC8vIGFsd2F5cyBhZGQgb2JzZXJ2ZXJcbiAgICBpZiAoaW5mby5vYnNlcnZlcikge1xuICAgICAgcHJvdG8uX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIobmFtZSwgaW5mby5vYnNlcnZlciwgYWxsUHJvcHNbaW5mby5vYnNlcnZlcl0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGFuIGVsZW1lbnQgYHByb3RvYCB0byBmdW5jdGlvbiB3aXRoIGEgZ2l2ZW4gYHRlbXBsYXRlYC5cbiAgICogVGhlIGVsZW1lbnQgbmFtZSBgaXNgIGFuZCBleHRlbmRzIGBleHRgIG11c3QgYmUgc3BlY2lmaWVkIGZvciBTaGFkeUNTU1xuICAgKiBzdHlsZSBzY29waW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50fSBwcm90byBFbGVtZW50IGNsYXNzIHByb3RvdHlwZSB0byBhZGQgYWNjZXNzb3JzXG4gICAqICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcHJvY2VzcyBhbmQgYmluZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSSBVUkwgYWdhaW5zdCB3aGljaCB0byByZXNvbHZlIHVybHMgaW5cbiAgICogICBzdHlsZSBlbGVtZW50IGNzc1RleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlzIFRhZyBuYW1lIChvciB0eXBlIGV4dGVuc2lvbiBuYW1lKSBmb3IgdGhpcyBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gZXh0IEZvciB0eXBlIGV4dGVuc2lvbnMsIHRoZSB0YWcgbmFtZSB0aGF0IHdhcyBleHRlbmRlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVUZW1wbGF0ZShwcm90bywgdGVtcGxhdGUsIGJhc2VVUkksIGlzLCBleHQpIHtcbiAgICAvLyBzdXBwb3J0IGBpbmNsdWRlPVwibW9kdWxlLW5hbWVcImBcbiAgICBsZXQgY3NzVGV4dCA9XG4gICAgICBjc3NGcm9tTW9kdWxlSW1wb3J0cyhpcykgK1xuICAgICAgY3NzRnJvbVRlbXBsYXRlKHRlbXBsYXRlLCBiYXNlVVJJKTtcbiAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgbGV0IHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzVGV4dDtcbiAgICAgIHRlbXBsYXRlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICB3aW5kb3cuU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBpcywgZXh0KTtcbiAgICB9XG4gICAgcHJvdG8uX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQHVucmVzdHJpY3RlZFxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAqL1xuICBjbGFzcyBQb2x5bWVyRWxlbWVudCBleHRlbmRzIHBvbHltZXJFbGVtZW50QmFzZSB7XG5cbiAgICAvKipcbiAgICAgKiBTdGFuZGFyZCBDdXN0b20gRWxlbWVudHMgVjEgQVBJLiAgVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJuc1xuICAgICAqIGEgbGlzdCBvZiBkYXNoLWNhc2VkIGF0dHJpYnV0ZXMgYmFzZWQgb24gYSBmbGF0dGVuaW5nIG9mIGFsbCBwcm9wZXJ0aWVzXG4gICAgICogZGVjbGFyZWQgaW4gYHN0YXRpYyBnZXQgcHJvcGVydGllcygpYCBmb3IgdGhpcyBlbGVtZW50IGFuZCBhbnlcbiAgICAgKiBzdXBlcmNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gT2JzZXJ2ZWQgYXR0cmlidXRlIGxpc3RcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfX29ic2VydmVkQXR0cmlidXRlcycsIHRoaXMpKSkge1xuICAgICAgICBsZXQgbGlzdCA9IFtdO1xuICAgICAgICBsZXQgcHJvcGVydGllcyA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgbGlzdC5wdXNoKGNhbWVsVG9EYXNoQ2FzZShwcm9wKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcyA9IGxpc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX29ic2VydmVkQXR0cmlidXRlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlIGlzIGNyZWF0ZWQgdG9cbiAgICAgKiBlbnN1cmUgdGhhdCBjbGFzcyBmaW5hbGl6YXRpb24gd29yayBoYXMgYmVlbiBjb21wbGV0ZWQuXG4gICAgICogTWF5IGJlIGNhbGxlZCBieSB1c2VycyB0byBlYWdlcmx5IHBlcmZvcm0gY2xhc3MgZmluYWxpemF0aW9uIHdvcmtcbiAgICAgKiBwcmlvciB0byB0aGUgY3JlYXRpb24gb2YgdGhlIGZpcnN0IGVsZW1lbnQgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBDbGFzcyBmaW5hbGl6YXRpb24gd29yayBnZW5lcmFsbHkgaW5jbHVkZXMgbWV0YS1wcm9ncmFtbWluZyBzdWNoIGFzXG4gICAgICogY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBhbnkgcHJvcGVydHkgZWZmZWN0IG1ldGFkYXRhIG5lZWRlZCBmb3JcbiAgICAgKiB0aGUgZmVhdHVyZXMgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzdGF0aWMgZmluYWxpemUoKSB7XG4gICAgICBpZiAoIWhhc0NsYXNzRmluYWxpemVkKHRoaXMpKSB7XG4gICAgICAgIGZpbmFsaXplQ2xhc3NBbmRTdXBlcih0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSB0aGF0IHdpbGwgYmUgc3RhbXBlZCBpbnRvIHRoaXMgZWxlbWVudCdzIHNoYWRvdyByb290LlxuICAgICAqXG4gICAgICogSWYgYSBgc3RhdGljIGdldCBpcygpYCBnZXR0ZXIgaXMgZGVmaW5lZCwgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb25cbiAgICAgKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgYDx0ZW1wbGF0ZT5gIGluIGEgYGRvbS1tb2R1bGVgIHdob3NlIGBpZGBcbiAgICAgKiBtYXRjaGVzIHRoaXMgZWxlbWVudCdzIGBpc2AuXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgdG8gcmV0dXJuIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgICAqIChpbiB3aGljaCBjYXNlIHRoZSBgaXNgIGdldHRlciBpcyB1bm5lY2Vzc2FyeSkuIFRoZSB0ZW1wbGF0ZSByZXR1cm5lZFxuICAgICAqIG1heSBiZSBlaXRoZXIgYW4gYEhUTUxUZW1wbGF0ZUVsZW1lbnRgIG9yIGEgc3RyaW5nIHRoYXQgd2lsbCBiZVxuICAgICAqIGF1dG9tYXRpY2FsbHkgcGFyc2VkIGludG8gYSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB3aGVuIHN1YmNsYXNzaW5nLCBpZiB0aGUgc3VwZXIgY2xhc3Mgb3ZlcnJvZGUgdGhlIGRlZmF1bHRcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBhbmQgdGhlIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gcHJvdmlkZSBhbiBhbHRlcm5hdGVcbiAgICAgKiB0ZW1wbGF0ZSB2aWEgYSBgZG9tLW1vZHVsZWAsIGl0IHNob3VsZCBvdmVycmlkZSB0aGlzIGdldHRlciBhbmRcbiAgICAgKiByZXR1cm4gYFBvbHltZXIuRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKWAuXG4gICAgICpcbiAgICAgKiBJZiBhIHN1YmNsYXNzIHdvdWxkIGxpa2UgdG8gbW9kaWZ5IHRoZSBzdXBlciBjbGFzcyB0ZW1wbGF0ZSwgaXQgc2hvdWxkXG4gICAgICogY2xvbmUgaXQgcmF0aGVyIHRoYW4gbW9kaWZ5IGl0IGluIHBsYWNlLiAgSWYgdGhlIGdldHRlciBkb2VzIGV4cGVuc2l2ZVxuICAgICAqIHdvcmsgc3VjaCBhcyBjbG9uaW5nL21vZGlmeWluZyBhIHRlbXBsYXRlLCBpdCBzaG91bGQgbWVtb2l6ZSB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZTpcbiAgICAgKlxuICAgICAqICAgbGV0IG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICogICBjbGFzcyBNeVN1YkNsYXNzIGV4dGVuZHMgTXlTdXBlckNsYXNzIHtcbiAgICAgKiAgICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgKiAgICAgICBpZiAoIW1lbW9pemVkVGVtcGxhdGUpIHtcbiAgICAgKiAgICAgICAgIG1lbW9pemVkVGVtcGxhdGUgPSBzdXBlci50ZW1wbGF0ZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICogICAgICAgICBsZXQgc3ViQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAqICAgICAgICAgc3ViQ29udGVudC50ZXh0Q29udGVudCA9ICdUaGlzIGNhbWUgZnJvbSBNeVN1YkNsYXNzJztcbiAgICAgKiAgICAgICAgIG1lbW9pemVkVGVtcGxhdGUuY29udGVudC5hcHBlbmRDaGlsZChzdWJDb250ZW50KTtcbiAgICAgKiAgICAgICB9XG4gICAgICogICAgICAgcmV0dXJuIG1lbW9pemVkVGVtcGxhdGU7XG4gICAgICogICAgIH1cbiAgICAgKiAgIH1cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0hUTUxUZW1wbGF0ZUVsZW1lbnR8c3RyaW5nfSBUZW1wbGF0ZSB0byBiZSBzdGFtcGVkXG4gICAgICovXG4gICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdfdGVtcGxhdGUnLCB0aGlzKSkpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUgPSBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydChcbiAgICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciovICh0aGlzKS5pcywgJ3RlbXBsYXRlJykgfHxcbiAgICAgICAgICAvLyBub3RlOiBpbXBsZW1lbnRlZCBzbyBhIHN1YmNsYXNzIGNhbiByZXRyaWV2ZSB0aGUgc3VwZXJcbiAgICAgICAgICAvLyB0ZW1wbGF0ZTsgY2FsbCB0aGUgc3VwZXIgaW1wbCB0aGlzIHdheSBzbyB0aGF0IGB0aGlzYCBwb2ludHNcbiAgICAgICAgICAvLyB0byB0aGUgc3VwZXJjbGFzcy5cbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci50ZW1wbGF0ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXRoIG1hdGNoaW5nIHRoZSB1cmwgZnJvbSB3aGljaCB0aGUgZWxlbWVudCB3YXMgaW1wb3J0ZWQuXG4gICAgICogVGhpcyBwYXRoIGlzIHVzZWQgdG8gcmVzb2x2ZSB1cmwncyBpbiB0ZW1wbGF0ZSBzdHlsZSBjc3NUZXh0LlxuICAgICAqIFRoZSBgaW1wb3J0UGF0aGAgcHJvcGVydHkgaXMgYWxzbyBzZXQgb24gZWxlbWVudCBpbnN0YW5jZXMgYW5kIGNhbiBiZVxuICAgICAqIHVzZWQgdG8gY3JlYXRlIGJpbmRpbmdzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgcGF0aC5cbiAgICAgKiBEZWZhdWx0cyB0byB0aGUgcGF0aCBtYXRjaGluZyB0aGUgdXJsIGNvbnRhaW5pbmcgYSBgZG9tLW1vZHVsZWAgZWxlbWVudFxuICAgICAqIG1hdGNoaW5nIHRoaXMgZWxlbWVudCdzIHN0YXRpYyBgaXNgIHByb3BlcnR5LlxuICAgICAqIE5vdGUsIHRoaXMgcGF0aCBzaG91bGQgY29udGFpbiBhIHRyYWlsaW5nIGAvYC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGltcG9ydCBwYXRoIGZvciB0aGlzIGVsZW1lbnQgY2xhc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IGltcG9ydFBhdGgoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX2ltcG9ydFBhdGgnLCB0aGlzKSkpIHtcbiAgICAgICAgICBjb25zdCBtb2R1bGUgPSBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydCgvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAodGhpcykuaXMpO1xuICAgICAgICAgIHRoaXMuX2ltcG9ydFBhdGggPSBtb2R1bGUgPyBtb2R1bGUuYXNzZXRwYXRoIDogJycgfHxcbiAgICAgICAgICBPYmplY3QuZ2V0UHJvdG90eXBlT2YoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykucHJvdG90eXBlKS5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2ltcG9ydFBhdGg7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqL1xuICAgICAgdGhpcy5fdGVtcGxhdGU7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMuX2ltcG9ydFBhdGg7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMucm9vdFBhdGg7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIHRoaXMuaW1wb3J0UGF0aDtcbiAgICAgIC8qKiBAdHlwZSB7U3RhbXBlZFRlbXBsYXRlIHwgSFRNTEVsZW1lbnQgfCBTaGFkb3dSb290fSAqL1xuICAgICAgdGhpcy5yb290O1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIU5vZGU+fSAqL1xuICAgICAgdGhpcy4kO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgdG8gZW5zdXJlIGNsYXNzXG4gICAgICogbWV0YXByb2dyYW1taW5nIHJlbGF0ZWQgdG8gcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzIGhhc1xuICAgICAqIGNvbXBsZXRlZCAoY2FsbHMgYGZpbmFsaXplYCkuXG4gICAgICpcbiAgICAgKiBJdCBhbHNvIGluaXRpYWxpemVzIGFueSBwcm9wZXJ0eSBkZWZhdWx0cyBwcm92aWRlZCB2aWEgYHZhbHVlYCBpblxuICAgICAqIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvcGVydGllcygpIHtcbiAgICAgIGluc3RhbmNlQ291bnQrKztcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuZmluYWxpemUoKTtcbiAgICAgIGNvbnN0IGltcG9ydFBhdGggPSB0aGlzLmNvbnN0cnVjdG9yLmltcG9ydFBhdGg7XG4gICAgICAvLyBub3RlOiBmaW5hbGl6ZSB0ZW1wbGF0ZSB3aGVuIHdlIGhhdmUgYWNjZXNzIHRvIGBsb2NhbE5hbWVgIHRvXG4gICAgICAvLyBhdm9pZCBkZXBlbmRlbmNlIG9uIGBpc2AgZm9yIHBvbHlmaWxsaW5nIHN0eWxpbmcuXG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGUgJiYgIXRoaXMuX3RlbXBsYXRlLl9fcG9seW1lckZpbmFsaXplZCkge1xuICAgICAgICB0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCBiYXNlVVJJID1cbiAgICAgICAgICBpbXBvcnRQYXRoID8gcmVzb2x2ZVVybCQwKGltcG9ydFBhdGgpIDogJyc7XG4gICAgICAgIGZpbmFsaXplVGVtcGxhdGUoLyoqIEB0eXBlIHshUG9seW1lckVsZW1lbnR9ICovKHRoaXMuX19wcm90b19fKSwgdGhpcy5fdGVtcGxhdGUsIGJhc2VVUkksXG4gICAgICAgICAgLyoqQHR5cGUgeyFIVE1MRWxlbWVudH0qLyh0aGlzKS5sb2NhbE5hbWUpO1xuICAgICAgfVxuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICAvLyBzZXQgcGF0aCBkZWZhdWx0c1xuICAgICAgdGhpcy5yb290UGF0aCA9IHJvb3RQYXRoJDA7XG4gICAgICB0aGlzLmltcG9ydFBhdGggPSBpbXBvcnRQYXRoO1xuICAgICAgLy8gYXBwbHkgcHJvcGVydHkgZGVmYXVsdHMuLi5cbiAgICAgIGxldCBwJCA9IHByb3BlcnR5RGVmYXVsdHNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICAgIGlmICghcCQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgcCBpbiBwJCkge1xuICAgICAgICBsZXQgaW5mbyA9IHAkW3BdO1xuICAgICAgICAvLyBEb24ndCBzZXQgZGVmYXVsdCB2YWx1ZSBpZiB0aGVyZSBpcyBhbHJlYWR5IGFuIG93biBwcm9wZXJ0eSwgd2hpY2hcbiAgICAgICAgLy8gaGFwcGVucyB3aGVuIGEgYHByb3BlcnRpZXNgIHByb3BlcnR5IHdpdGggZGVmYXVsdCBidXQgbm8gZWZmZWN0cyBoYWRcbiAgICAgICAgLy8gYSBwcm9wZXJ0eSBzZXQgKGUuZy4gYm91bmQpIGJ5IGl0cyBob3N0IGJlZm9yZSB1cGdyYWRlXG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgICAgIGxldCB2YWx1ZSA9IHR5cGVvZiBpbmZvLnZhbHVlID09ICdmdW5jdGlvbicgP1xuICAgICAgICAgICAgaW5mby52YWx1ZS5jYWxsKHRoaXMpIDpcbiAgICAgICAgICAgIGluZm8udmFsdWU7XG4gICAgICAgICAgLy8gU2V0IHZpYSBgX3NldFByb3BlcnR5YCBpZiB0aGVyZSBpcyBhbiBhY2Nlc3NvciwgdG8gZW5hYmxlXG4gICAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHJlYWRPbmx5IHByb3BlcnR5IGRlZmF1bHRzXG4gICAgICAgICAgaWYgKHRoaXMuX2hhc0FjY2Vzc29yKHApKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocCwgdmFsdWUsIHRydWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW3BdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgKiBgY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gZW5hYmxlcyB0aGUgcHJvcGVydHkgZWZmZWN0cyBzeXN0ZW0gYW5kXG4gICAgICogZmx1c2hlcyBhbnkgcGVuZGluZyBwcm9wZXJ0aWVzLCBhbmQgdXBkYXRlcyBzaGltbWVkIENTUyBwcm9wZXJ0aWVzXG4gICAgICogd2hlbiB1c2luZyB0aGUgU2hhZHlDU1Mgc2NvcGluZy9jdXN0b20gcHJvcGVydGllcyBwb2x5ZmlsbC5cbiAgICAgKlxuICAgICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgICAqL1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVFbGVtZW50KC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBzdGFuZGFyZCBDdXN0b20gRWxlbWVudHNcbiAgICAgKiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge31cblxuICAgIC8qKlxuICAgICAqIFN0YW1wcyB0aGUgZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIHJlYWR5KCkge1xuICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGhpcy5fdGVtcGxhdGUpO1xuICAgICAgICB0aGlzLiQgPSB0aGlzLnJvb3QuJDtcbiAgICAgIH1cbiAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50cyBgUHJvcGVydHlFZmZlY3RzYCdzIGBfcmVhZHlDbGllbnRzYCBjYWxsLiBBdHRhY2hlc1xuICAgICAqIGVsZW1lbnQgZG9tIGJ5IGNhbGxpbmcgYF9hdHRhY2hEb21gIHdpdGggdGhlIGRvbSBzdGFtcGVkIGZyb20gdGhlXG4gICAgICogZWxlbWVudCdzIHRlbXBsYXRlIHZpYSBgX3N0YW1wVGVtcGxhdGVgLiBOb3RlIHRoYXQgdGhpcyBhbGxvd3NcbiAgICAgKiBjbGllbnQgZG9tIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50IHByaW9yIHRvIGFueSBvYnNlcnZlcnNcbiAgICAgKiBydW5uaW5nLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3JlYWR5Q2xpZW50cygpIHtcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9hdHRhY2hEb20oLyoqIEB0eXBlIHtTdGFtcGVkVGVtcGxhdGV9ICovKHRoaXMucm9vdCkpO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHN1cGVyLl9yZWFkeUNsaWVudHMgaGVyZSBzZXRzIHRoZSBjbGllbnRzIGluaXRpYWxpemVkIGZsYWcuXG4gICAgICAvLyBXZSBtdXN0IHdhaXQgdG8gZG8gdGhpcyB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGNyZWF0ZWQvYXR0YWNoZWRcbiAgICAgIC8vIHNvIHRoYXQgdGhpcyBmbGFnIGNhbiBiZSBjaGVja2VkIHRvIHByZXZlbnQgbm90aWZpY2F0aW9ucyBmaXJlZFxuICAgICAgLy8gZHVyaW5nIHRoaXMgcHJvY2VzcyBmcm9tIGJlaW5nIGhhbmRsZWQgYmVmb3JlIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgc3VwZXIuX3JlYWR5Q2xpZW50cygpO1xuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgYW4gZWxlbWVudCdzIHN0YW1wZWQgZG9tIHRvIGl0c2VsZi4gQnkgZGVmYXVsdCxcbiAgICAgKiB0aGlzIG1ldGhvZCBjcmVhdGVzIGEgYHNoYWRvd1Jvb3RgIGFuZCBhZGRzIHRoZSBkb20gdG8gaXQuXG4gICAgICogSG93ZXZlciwgdGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWxsb3cgYW4gZWxlbWVudFxuICAgICAqIHRvIHB1dCBpdHMgZG9tIGluIGFub3RoZXIgbG9jYXRpb24uXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdSZXR1cm59XG4gICAgICogQHBhcmFtIHtTdGFtcGVkVGVtcGxhdGV9IGRvbSB0byBhdHRhY2ggdG8gdGhlIGVsZW1lbnQuXG4gICAgICogQHJldHVybiB7U2hhZG93Um9vdH0gbm9kZSB0byB3aGljaCB0aGUgZG9tIGhhcyBiZWVuIGF0dGFjaGVkLlxuICAgICAqL1xuICAgIF9hdHRhY2hEb20oZG9tKSB7XG4gICAgICBpZiAodGhpcy5hdHRhY2hTaGFkb3cpIHtcbiAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgIGlmICghdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7bW9kZTogJ29wZW4nfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChkb20pO1xuICAgICAgICAgIHJldHVybiB0aGlzLnNoYWRvd1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NoYWRvd0RPTSBub3QgYXZhaWxhYmxlLiAnICtcbiAgICAgICAgICAvLyBUT0RPKHNvcnZlbGwpOiBtb3ZlIHRvIGNvbXBpbGUtdGltZSBjb25kaXRpb25hbCB3aGVuIHN1cHBvcnRlZFxuICAgICAgICAnUG9seW1lci5FbGVtZW50IGNhbiBjcmVhdGUgZG9tIGFzIGNoaWxkcmVuIGluc3RlYWQgb2YgaW4gJyArXG4gICAgICAgICdTaGFkb3dET00gYnkgc2V0dGluZyBgdGhpcy5yb290ID0gdGhpcztcXGAgYmVmb3JlIFxcYHJlYWR5XFxgLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0LCBhdHRyaWJ1dGVzIGRlY2xhcmVkIGluIGBwcm9wZXJ0aWVzYCBtZXRhZGF0YSBhcmVcbiAgICAgKiBkZXNlcmlhbGl6ZWQgdXNpbmcgdGhlaXIgYHR5cGVgIGluZm9ybWF0aW9uIHRvIHByb3BlcnRpZXMgb2YgdGhlXG4gICAgICogc2FtZSBuYW1lLiAgXCJEYXNoLWNhc2VkXCIgYXR0cmlidXRlcyBhcmUgZGVzZXJpYWx6ZWQgdG8gXCJjYW1lbENhc2VcIlxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKG5hbWUpO1xuICAgICAgICBsZXQgdHlwZSA9IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzLmNvbnN0cnVjdG9yKVtwcm9wZXJ0eV0udHlwZTtcbiAgICAgICAgaWYgKCF0aGlzLl9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkpIHtcbiAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVUb1Byb3BlcnR5KG5hbWUsIHZhbHVlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0eSBzaGltLCBjYXVzZXMgYWxsXG4gICAgICogc2hpbW1lZCBzdHlsZXMgaW4gdGhpcyBlbGVtZW50IChhbmQgaXRzIHN1YnRyZWUpIHRvIGJlIHVwZGF0ZWRcbiAgICAgKiBiYXNlZCBvbiBjdXJyZW50IGN1c3RvbSBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBUaGUgb3B0aW9uYWwgcGFyYW1ldGVyIG92ZXJyaWRlcyBpbmxpbmUgY3VzdG9tIHByb3BlcnR5IHN0eWxlcyB3aXRoIGFuXG4gICAgICogb2JqZWN0IG9mIHByb3BlcnRpZXMgd2hlcmUgdGhlIGtleXMgYXJlIENTUyBwcm9wZXJ0aWVzLCBhbmQgdGhlIHZhbHVlc1xuICAgICAqIGFyZSBzdHJpbmdzLlxuICAgICAqXG4gICAgICogRXhhbXBsZTogYHRoaXMudXBkYXRlU3R5bGVzKHsnLS1jb2xvcic6ICdibHVlJ30pYFxuICAgICAqXG4gICAgICogVGhlc2UgcHJvcGVydGllcyBhcmUgcmV0YWluZWQgdW5sZXNzIGEgdmFsdWUgb2YgYG51bGxgIGlzIHNldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBCYWcgb2YgY3VzdG9tIHByb3BlcnR5IGtleS92YWx1ZXMgdG9cbiAgICAgKiAgIGFwcGx5IHRvIHRoaXMgZWxlbWVudC5cbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICB1cGRhdGVTdHlsZXMocHJvcGVydGllcykge1xuICAgICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgICB3aW5kb3cuU2hhZHlDU1Muc3R5bGVTdWJ0cmVlKC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyh0aGlzKSwgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV3cml0ZXMgYSBnaXZlbiBVUkwgcmVsYXRpdmUgdG8gYSBiYXNlIFVSTC4gVGhlIGJhc2UgVVJMIGRlZmF1bHRzIHRvXG4gICAgICogdGhlIG9yaWdpbmFsIGxvY2F0aW9uIG9mIHRoZSBkb2N1bWVudCBjb250YWluaW5nIHRoZSBgZG9tLW1vZHVsZWAgZm9yXG4gICAgICogdGhpcyBlbGVtZW50LiBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiB0aGUgc2FtZSBVUkwgYmVmb3JlIGFuZCBhZnRlclxuICAgICAqIGJ1bmRsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCBVUkwgdG8gcmVzb2x2ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGJhc2UgT3B0aW9uYWwgYmFzZSBVUkwgdG8gcmVzb2x2ZSBhZ2FpbnN0LCBkZWZhdWx0c1xuICAgICAqIHRvIHRoZSBlbGVtZW50J3MgYGltcG9ydFBhdGhgXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXdyaXR0ZW4gVVJMIHJlbGF0aXZlIHRvIGJhc2VcbiAgICAgKi9cbiAgICByZXNvbHZlVXJsKHVybCwgYmFzZSkge1xuICAgICAgaWYgKCFiYXNlICYmIHRoaXMuaW1wb3J0UGF0aCkge1xuICAgICAgICBiYXNlID0gcmVzb2x2ZVVybCQwKHRoaXMuaW1wb3J0UGF0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzb2x2ZVVybCQwKHVybCwgYmFzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yc2AgdG8gYWRkIG1hcCBvZiBkeW5hbWljIGZ1bmN0aW9ucyBvblxuICAgICAqIHRlbXBsYXRlIGluZm8sIGZvciBjb25zdW1wdGlvbiBieSBgUHJvcGVydHlFZmZlY3RzYCB0ZW1wbGF0ZSBiaW5kaW5nXG4gICAgICogY29kZS4gVGhpcyBtYXAgZGV0ZXJtaW5lcyB3aGljaCBtZXRob2QgdGVtcGxhdGVzIHNob3VsZCBoYXZlIGFjY2Vzc29yc1xuICAgICAqIGNyZWF0ZWQgZm9yIHRoZW0uXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyA9IHRlbXBsYXRlSW5mby5keW5hbWljRm5zIHx8IHByb3BlcnRpZXNGb3JDbGFzcyh0aGlzKTtcbiAgICAgIHJldHVybiBzdXBlci5fcGFyc2VUZW1wbGF0ZUNvbnRlbnQodGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIFBvbHltZXJFbGVtZW50O1xufSk7XG5cbmV4cG9ydCBsZXQgaW5zdGFuY2VDb3VudCA9IDA7XG5leHBvcnQgY29uc3QgcmVnaXN0cmF0aW9ucyA9IFtdO1xuXG5leHBvcnQgZnVuY3Rpb24gX3JlZ0xvZyhwcm90b3R5cGUpIHtcbiAgY29uc29sZS5sb2coJ1snICsgcHJvdG90eXBlLmlzICsgJ106IHJlZ2lzdGVyZWQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHByb3RvdHlwZSkge1xuICByZWdpc3RyYXRpb25zLnB1c2gocHJvdG90eXBlKTtcbiAgdW5kZWZpbmVkICYmIF9yZWdMb2cocHJvdG90eXBlKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGR1bXBSZWdpc3RyYXRpb25zKCkge1xuICByZWdpc3RyYXRpb25zLmZvckVhY2goX3JlZ0xvZyk7XG59XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVTdHlsZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRG9jdW1lbnQocHJvcHMpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDI0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyByZXNvbHZlVXJsLCBwYXRoRnJvbVVybCB9IGZyb20gJy4uL3V0aWxzL3Jlc29sdmUtdXJsLmpzJztcblxubGV0IG1vZHVsZXMgPSB7fTtcbmxldCBsY01vZHVsZXMgPSB7fTtcbmZ1bmN0aW9uIGZpbmRNb2R1bGUoaWQpIHtcbiAgcmV0dXJuIG1vZHVsZXNbaWRdIHx8IGxjTW9kdWxlc1tpZC50b0xvd2VyQ2FzZSgpXTtcbn1cblxuZnVuY3Rpb24gc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayhpbnN0KSB7XG4gIGlmIChpbnN0LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpIHtcbiAgICBjb25zb2xlLndhcm4oJ2RvbS1tb2R1bGUgJXMgaGFzIHN0eWxlIG91dHNpZGUgdGVtcGxhdGUnLCBpbnN0LmlkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBgZG9tLW1vZHVsZWAgZWxlbWVudCByZWdpc3RlcnMgdGhlIGRvbSBpdCBjb250YWlucyB0byB0aGUgbmFtZSBnaXZlblxuICogYnkgdGhlIG1vZHVsZSdzIGlkIGF0dHJpYnV0ZS4gSXQgcHJvdmlkZXMgYSB1bmlmaWVkIGRhdGFiYXNlIG9mIGRvbVxuICogYWNjZXNzaWJsZSB2aWEgaXRzIHN0YXRpYyBgaW1wb3J0YCBBUEkuXG4gKlxuICogQSBrZXkgdXNlIGNhc2Ugb2YgYGRvbS1tb2R1bGVgIGlzIGZvciBwcm92aWRpbmcgY3VzdG9tIGVsZW1lbnQgYDx0ZW1wbGF0ZT5gc1xuICogdmlhIEhUTUwgaW1wb3J0cyB0aGF0IGFyZSBwYXJzZWQgYnkgdGhlIG5hdGl2ZSBIVE1MIHBhcnNlciwgdGhhdCBjYW4gYmVcbiAqIHJlbG9jYXRlZCBkdXJpbmcgYSBidW5kbGluZyBwYXNzIGFuZCBzdGlsbCBsb29rZWQgdXAgYnkgYGlkYC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA8ZG9tLW1vZHVsZSBpZD1cImZvb1wiPlxuICogICAgICAgPGltZyBzcmM9XCJzdHVmZi5wbmdcIj5cbiAqICAgICA8L2RvbS1tb2R1bGU+XG4gKlxuICogVGhlbiBpbiBjb2RlIGluIHNvbWUgb3RoZXIgbG9jYXRpb24gdGhhdCBjYW5ub3QgYWNjZXNzIHRoZSBkb20tbW9kdWxlIGFib3ZlXG4gKlxuICogICAgIGxldCBpbWcgPSBjdXN0b21FbGVtZW50cy5nZXQoJ2RvbS1tb2R1bGUnKS5pbXBvcnQoJ2ZvbycsICdpbWcnKTtcbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQGV4dGVuZHMgSFRNTEVsZW1lbnRcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IHByb3ZpZGVzIGEgcmVnaXN0cnkgb2YgcmVsb2NhdGFibGUgRE9NIGNvbnRlbnRcbiAqICAgYnkgYGlkYCB0aGF0IGlzIGFnbm9zdGljIHRvIGJ1bmRsaW5nLlxuICogQHVucmVzdHJpY3RlZFxuICovXG5jbGFzcyBEb21Nb2R1bGUgZXh0ZW5kcyBIVE1MRWxlbWVudCB7XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7IHJldHVybiBbJ2lkJ107IH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBlbGVtZW50IHNwZWNpZmllZCBieSB0aGUgY3NzIGBzZWxlY3RvcmAgaW4gdGhlIG1vZHVsZVxuICAgKiByZWdpc3RlcmVkIGJ5IGBpZGAuIEZvciBleGFtcGxlLCB0aGlzLmltcG9ydCgnZm9vJywgJ2ltZycpO1xuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIGlkIG9mIHRoZSBkb20tbW9kdWxlIGluIHdoaWNoIHRvIHNlYXJjaC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBzZWxlY3RvciBUaGUgY3NzIHNlbGVjdG9yIGJ5IHdoaWNoIHRvIGZpbmQgdGhlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR9IFJldHVybnMgdGhlIGVsZW1lbnQgd2hpY2ggbWF0Y2hlcyBgc2VsZWN0b3JgIGluIHRoZVxuICAgKiBtb2R1bGUgcmVnaXN0ZXJlZCBhdCB0aGUgc3BlY2lmaWVkIGBpZGAuXG4gICAqL1xuICBzdGF0aWMgaW1wb3J0KGlkLCBzZWxlY3Rvcikge1xuICAgIGlmIChpZCkge1xuICAgICAgbGV0IG0gPSBmaW5kTW9kdWxlKGlkKTtcbiAgICAgIGlmIChtICYmIHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBtLnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5yZWdpc3RlcigpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYWJzb2x1dGUgVVJMIG9mIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGlzIGBkb20tbW9kdWxlYC5cbiAgICpcbiAgICogVGhpcyB2YWx1ZSB3aWxsIGRpZmZlciBmcm9tIHRoaXMgZWxlbWVudCdzIGBvd25lckRvY3VtZW50YCBpbiB0aGVcbiAgICogZm9sbG93aW5nIHdheXM6XG4gICAqIC0gVGFrZXMgaW50byBhY2NvdW50IGFueSBgYXNzZXRwYXRoYCBhdHRyaWJ1dGUgYWRkZWQgZHVyaW5nIGJ1bmRsaW5nXG4gICAqICAgdG8gaW5kaWNhdGUgdGhlIG9yaWdpbmFsIGxvY2F0aW9uIHJlbGF0aXZlIHRvIHRoZSBidW5kbGVkIGxvY2F0aW9uXG4gICAqIC0gVXNlcyB0aGUgSFRNTEltcG9ydHMgcG9seWZpbGwncyBgaW1wb3J0Rm9yRWxlbWVudGAgQVBJIHRvIGVuc3VyZVxuICAgKiAgIHRoZSBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBpbXBvcnQgZG9jdW1lbnQncyBsb2NhdGlvbiBzaW5jZVxuICAgKiAgIGBvd25lckRvY3VtZW50YCBpcyBub3QgY3VycmVudGx5IHBvbHlmaWxsZWRcbiAgICovXG4gIGdldCBhc3NldHBhdGgoKSB7XG4gICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgYXNzZXRwYXRoLlxuICAgIGlmICghdGhpcy5fX2Fzc2V0cGF0aCkge1xuICAgICAgLy8gbm90ZTogYXNzZXRwYXRoIHNldCB2aWEgYW4gYXR0cmlidXRlIG11c3QgYmUgcmVsYXRpdmUgdG8gdGhpc1xuICAgICAgLy8gZWxlbWVudCdzIGxvY2F0aW9uOyBhY2NvbW9kYXRlIHBvbHlmaWxsZWQgSFRNTEltcG9ydHNcbiAgICAgIGNvbnN0IG93bmVyID0gd2luZG93LkhUTUxJbXBvcnRzICYmIEhUTUxJbXBvcnRzLmltcG9ydEZvckVsZW1lbnQgP1xuICAgICAgICBIVE1MSW1wb3J0cy5pbXBvcnRGb3JFbGVtZW50KHRoaXMpIHx8IGRvY3VtZW50IDogdGhpcy5vd25lckRvY3VtZW50O1xuICAgICAgY29uc3QgdXJsID0gcmVzb2x2ZVVybChcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ2Fzc2V0cGF0aCcpIHx8ICcnLCBvd25lci5iYXNlVVJJKTtcbiAgICAgIHRoaXMuX19hc3NldHBhdGggPSBwYXRoRnJvbVVybCh1cmwpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fX2Fzc2V0cGF0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlcnMgdGhlIGRvbS1tb2R1bGUgYXQgYSBnaXZlbiBpZC4gVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgY2FsbGVkXG4gICAqIHdoZW4gYSBkb20tbW9kdWxlIGlzIGltcGVyYXRpdmVseSBjcmVhdGVkLiBGb3JcbiAgICogZXhhbXBsZSwgYGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RvbS1tb2R1bGUnKS5yZWdpc3RlcignZm9vJylgLlxuICAgKiBAcGFyYW0ge3N0cmluZz19IGlkIFRoZSBpZCBhdCB3aGljaCB0byByZWdpc3RlciB0aGUgZG9tLW1vZHVsZS5cbiAgICovXG4gIHJlZ2lzdGVyKGlkKSB7XG4gICAgaWQgPSBpZCB8fCB0aGlzLmlkO1xuICAgIGlmIChpZCkge1xuICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgLy8gc3RvcmUgaWQgc2VwYXJhdGUgZnJvbSBsb3dlcmNhc2VkIGlkIHNvIHRoYXRcbiAgICAgIC8vIGluIGFsbCBjYXNlcyBtaXhlZENhc2UgaWQgd2lsbCBzdG9yZWQgZGlzdGluY3RseVxuICAgICAgLy8gYW5kIGxvd2VyY2FzZSB2ZXJzaW9uIGlzIGEgZmFsbGJhY2tcbiAgICAgIG1vZHVsZXNbaWRdID0gdGhpcztcbiAgICAgIGxjTW9kdWxlc1tpZC50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XG4gICAgICBzdHlsZU91dHNpZGVUZW1wbGF0ZUNoZWNrKHRoaXMpO1xuICAgIH1cbiAgfVxufVxuXG5Eb21Nb2R1bGUucHJvdG90eXBlWydtb2R1bGVzJ10gPSBtb2R1bGVzO1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2RvbS1tb2R1bGUnLCBEb21Nb2R1bGUpO1xuXG5leHBvcnQgeyBEb21Nb2R1bGUgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1tb2R1bGUuanNcbi8vIG1vZHVsZSBpZCA9IDI1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vdXRpbHMvYm9vdC5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0IHsgcm9vdCBhcyByb290JDAsIGlzQW5jZXN0b3IsIGlzRGVzY2VuZGFudCwgZ2V0IGFzIGdldCQwLCB0cmFuc2xhdGUsIGlzUGF0aCBhcyBpc1BhdGgkMCwgc2V0IGFzIHNldCQwLCBub3JtYWxpemUgfSBmcm9tICcuLi91dGlscy9wYXRoLmpzJztcbmltcG9ydCAqIGFzIGNhc2VNYXAgZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgY2FtZWxUb0Rhc2hDYXNlIGFzIGNhbWVsVG9EYXNoQ2FzZSQwLCBkYXNoVG9DYW1lbENhc2UgfSBmcm9tICcuLi91dGlscy9jYXNlLW1hcC5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUFjY2Vzc29ycyB9IGZyb20gJy4vcHJvcGVydHktYWNjZXNzb3JzLmpzJztcbmltcG9ydCB7IFRlbXBsYXRlU3RhbXAgfSBmcm9tICcuL3RlbXBsYXRlLXN0YW1wLmpzJztcbmltcG9ydCB7IHNhbml0aXplRE9NVmFsdWUgfSBmcm9tICcuLi91dGlscy9zZXR0aW5ncy5qcyc7XG5cbi8qKiBAY29uc3Qge09iamVjdH0gKi9cbmNvbnN0IENhc2VNYXAgPSBjYXNlTWFwO1xuXG4vLyBNb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgdW5pcXVlIElEIHVzZWQgZm9yIGRlLWR1cGluZyBlZmZlY3RzIHRyaWdnZXJlZFxuLy8gZnJvbSBtdWx0aXBsZSBwcm9wZXJ0aWVzIGluIHRoZSBzYW1lIHR1cm5cbmxldCBkZWR1cGVJZCA9IDA7XG5cbi8qKlxuICogUHJvcGVydHkgZWZmZWN0IHR5cGVzOyBlZmZlY3RzIGFyZSBzdG9yZWQgb24gdGhlIHByb3RvdHlwZSB1c2luZyB0aGVzZSBrZXlzXG4gKiBAZW51bSB7c3RyaW5nfVxuICovXG5jb25zdCBUWVBFUyA9IHtcbiAgQ09NUFVURTogJ19fY29tcHV0ZUVmZmVjdHMnLFxuICBSRUZMRUNUOiAnX19yZWZsZWN0RWZmZWN0cycsXG4gIE5PVElGWTogJ19fbm90aWZ5RWZmZWN0cycsXG4gIFBST1BBR0FURTogJ19fcHJvcGFnYXRlRWZmZWN0cycsXG4gIE9CU0VSVkU6ICdfX29ic2VydmVFZmZlY3RzJyxcbiAgUkVBRF9PTkxZOiAnX19yZWFkT25seSdcbn07XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIG5hbWU6IChzdHJpbmcgfCB1bmRlZmluZWQpLFxuICogc3RydWN0dXJlZDogKGJvb2xlYW4gfCB1bmRlZmluZWQpLFxuICogd2lsZGNhcmQ6IChib29sZWFuIHwgdW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IERhdGFUcmlnZ2VyOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogaW5mbzogPyxcbiAqIHRyaWdnZXI6ICghRGF0YVRyaWdnZXIgfCB1bmRlZmluZWQpLFxuICogZm46ICghRnVuY3Rpb24gfCB1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgRGF0YUVmZmVjdDsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmxldCBQcm9wZXJ0eUVmZmVjdHNUeXBlOyAvL2VzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqXG4gKiBFbnN1cmVzIHRoYXQgdGhlIG1vZGVsIGhhcyBhbiBvd24tcHJvcGVydHkgbWFwIG9mIGVmZmVjdHMgZm9yIHRoZSBnaXZlbiB0eXBlLlxuICogVGhlIG1vZGVsIG1heSBiZSBhIHByb3RvdHlwZSBvciBhbiBpbnN0YW5jZS5cbiAqXG4gKiBQcm9wZXJ0eSBlZmZlY3RzIGFyZSBzdG9yZWQgYXMgYXJyYXlzIG9mIGVmZmVjdHMgYnkgcHJvcGVydHkgaW4gYSBtYXAsXG4gKiBieSBuYW1lZCB0eXBlIG9uIHRoZSBtb2RlbC4gZS5nLlxuICpcbiAqICAgX19jb21wdXRlRWZmZWN0czoge1xuICogICAgIGZvbzogWyAuLi4gXSxcbiAqICAgICBiYXI6IFsgLi4uIF1cbiAqICAgfVxuICpcbiAqIElmIHRoZSBtb2RlbCBkb2VzIG5vdCB5ZXQgaGF2ZSBhbiBlZmZlY3QgbWFwIGZvciB0aGUgdHlwZSwgb25lIGlzIGNyZWF0ZWRcbiAqIGFuZCByZXR1cm5lZC4gIElmIGl0IGRvZXMsIGJ1dCBpdCBpcyBub3QgYW4gb3duIHByb3BlcnR5IChpLmUuIHRoZVxuICogcHJvdG90eXBlIGhhZCBlZmZlY3RzKSwgdGhlIHRoZSBtYXAgaXMgZGVlcGx5IGNsb25lZCBhbmQgdGhlIGNvcHkgaXNcbiAqIHNldCBvbiB0aGUgbW9kZWwgYW5kIHJldHVybmVkLCByZWFkeSBmb3IgbmV3IGVmZmVjdHMgdG8gYmUgYWRkZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgUHJvcGVydHkgZWZmZWN0IHR5cGVcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIG93bi1wcm9wZXJ0eSBtYXAgb2YgZWZmZWN0cyBmb3IgdGhlIGdpdmVuIHR5cGVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuc3VyZU93bkVmZmVjdE1hcChtb2RlbCwgdHlwZSkge1xuICBsZXQgZWZmZWN0cyA9IG1vZGVsW3R5cGVdO1xuICBpZiAoIWVmZmVjdHMpIHtcbiAgICBlZmZlY3RzID0gbW9kZWxbdHlwZV0gPSB7fTtcbiAgfSBlbHNlIGlmICghbW9kZWwuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcbiAgICBlZmZlY3RzID0gbW9kZWxbdHlwZV0gPSBPYmplY3QuY3JlYXRlKG1vZGVsW3R5cGVdKTtcbiAgICBmb3IgKGxldCBwIGluIGVmZmVjdHMpIHtcbiAgICAgIGxldCBwcm90b0Z4ID0gZWZmZWN0c1twXTtcbiAgICAgIGxldCBpbnN0RnggPSBlZmZlY3RzW3BdID0gQXJyYXkocHJvdG9GeC5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaT0wOyBpPHByb3RvRngubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaW5zdEZ4W2ldID0gcHJvdG9GeFtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVmZmVjdHM7XG59XG5cbi8vIC0tIGVmZmVjdHMgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIFJ1bnMgYWxsIGVmZmVjdHMgb2YgYSBnaXZlbiB0eXBlIGZvciB0aGUgZ2l2ZW4gc2V0IG9mIHByb3BlcnR5IGNoYW5nZXNcbiAqIG9uIGFuIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3RzIE9iamVjdCBtYXAgb2YgcHJvcGVydHktdG8tQXJyYXkgb2YgZWZmZWN0c1xuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHBhcmFtIHsqPX0gZXh0cmFBcmdzIEFkZGl0aW9uYWwgbWV0YWRhdGEgdG8gcGFzcyB0byBlZmZlY3QgZnVuY3Rpb25cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gZWZmZWN0IHJhbiBmb3IgdGhpcyBwcm9wZXJ0eVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuRWZmZWN0cyhpbnN0LCBlZmZlY3RzLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpIHtcbiAgaWYgKGVmZmVjdHMpIHtcbiAgICBsZXQgcmFuID0gZmFsc2U7XG4gICAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICBpZiAocnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGVmZmVjdHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzLCBleHRyYUFyZ3MpKSB7XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByYW47XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJ1bnMgYSBsaXN0IG9mIGVmZmVjdHMgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICogQHBhcmFtIHtPYmplY3R9IGVmZmVjdHMgT2JqZWN0IG1hcCBvZiBwcm9wZXJ0eS10by1BcnJheSBvZiBlZmZlY3RzXG4gKiBAcGFyYW0ge251bWJlcn0gZGVkdXBlSWQgQ291bnRlciB1c2VkIGZvciBkZS1kdXBpbmcgZWZmZWN0c1xuICogQHBhcmFtIHtzdHJpbmd9IHByb3AgTmFtZSBvZiBjaGFuZ2VkIHByb3BlcnR5XG4gKiBAcGFyYW0geyp9IHByb3BzIENoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHsqfSBvbGRQcm9wcyBPbGQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVmZmVjdCByYW4gZm9yIHRoaXMgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBlZmZlY3RzLCBkZWR1cGVJZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSB7XG4gIGxldCByYW4gPSBmYWxzZTtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gcm9vdCQwKHByb3ApIDogcHJvcDtcbiAgbGV0IGZ4cyA9IGVmZmVjdHNbcm9vdFByb3BlcnR5XTtcbiAgaWYgKGZ4cykge1xuICAgIGZvciAobGV0IGk9MCwgbD1meHMubGVuZ3RoLCBmeDsgKGk8bCkgJiYgKGZ4PWZ4c1tpXSk7IGkrKykge1xuICAgICAgaWYgKCghZnguaW5mbyB8fCBmeC5pbmZvLmxhc3RSdW4gIT09IGRlZHVwZUlkKSAmJlxuICAgICAgICAgICghaGFzUGF0aHMgfHwgcGF0aE1hdGNoZXNUcmlnZ2VyKHByb3AsIGZ4LnRyaWdnZXIpKSkge1xuICAgICAgICBpZiAoZnguaW5mbykge1xuICAgICAgICAgIGZ4LmluZm8ubGFzdFJ1biA9IGRlZHVwZUlkO1xuICAgICAgICB9XG4gICAgICAgIGZ4LmZuKGluc3QsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgZnguaW5mbywgaGFzUGF0aHMsIGV4dHJhQXJncyk7XG4gICAgICAgIHJhbiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiByYW47XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIGEgcHJvcGVydHkvcGF0aCB0aGF0IGhhcyBjaGFuZ2VkIG1hdGNoZXMgdGhlIHRyaWdnZXJcbiAqIGNyaXRlcmlhIGZvciBhbiBlZmZlY3QuICBBIHRyaWdnZXIgaXMgYSBkZXNjcmlwdG9yIHdpdGggdGhlIGZvbGxvd2luZ1xuICogc3RydWN0dXJlLCB3aGljaCBtYXRjaGVzIHRoZSBkZXNjcmlwdG9ycyByZXR1cm5lZCBmcm9tIGBwYXJzZUFyZ2AuXG4gKiBlLmcuIGZvciBgZm9vLmJhci4qYDpcbiAqIGBgYFxuICogdHJpZ2dlcjoge1xuICogICBuYW1lOiAnYS5iJyxcbiAqICAgc3RydWN0dXJlZDogdHJ1ZSxcbiAqICAgd2lsZGNhcmQ6IHRydWVcbiAqIH1cbiAqIGBgYFxuICogSWYgbm8gdHJpZ2dlciBpcyBnaXZlbiwgdGhlIHBhdGggaXMgZGVlbWVkIHRvIG1hdGNoLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggb3IgcHJvcGVydHkgdGhhdCBjaGFuZ2VkXG4gKiBAcGFyYW0ge0RhdGFUcmlnZ2VyfSB0cmlnZ2VyIERlc2NyaXB0b3JcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHBhdGggbWF0Y2hlZCB0aGUgdHJpZ2dlclxuICovXG5mdW5jdGlvbiBwYXRoTWF0Y2hlc1RyaWdnZXIocGF0aCwgdHJpZ2dlcikge1xuICBpZiAodHJpZ2dlcikge1xuICAgIGxldCB0cmlnZ2VyUGF0aCA9IHRyaWdnZXIubmFtZTtcbiAgICByZXR1cm4gKHRyaWdnZXJQYXRoID09IHBhdGgpIHx8XG4gICAgICAodHJpZ2dlci5zdHJ1Y3R1cmVkICYmIGlzQW5jZXN0b3IodHJpZ2dlclBhdGgsIHBhdGgpKSB8fFxuICAgICAgKHRyaWdnZXIud2lsZGNhcmQgJiYgaXNEZXNjZW5kYW50KHRyaWdnZXJQYXRoLCBwYXRoKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcIm9ic2VydmVyXCIgZWZmZWN0LlxuICpcbiAqIENhbGxzIHRoZSBtZXRob2Qgd2l0aCBgaW5mby5tZXRob2ROYW1lYCBvbiB0aGUgaW5zdGFuY2UsIHBhc3NpbmcgdGhlXG4gKiBuZXcgYW5kIG9sZCB2YWx1ZXMuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5PYnNlcnZlckVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIGxldCBmbiA9IGluc3RbaW5mby5tZXRob2ROYW1lXTtcbiAgbGV0IGNoYW5nZWRQcm9wID0gaW5mby5wcm9wZXJ0eTtcbiAgaWYgKGZuKSB7XG4gICAgZm4uY2FsbChpbnN0LCBpbnN0Ll9fZGF0YVtjaGFuZ2VkUHJvcF0sIG9sZFByb3BzW2NoYW5nZWRQcm9wXSk7XG4gIH0gZWxzZSBpZiAoIWluZm8uZHluYW1pY0ZuKSB7XG4gICAgY29uc29sZS53YXJuKCdvYnNlcnZlciBtZXRob2QgYCcgKyBpbmZvLm1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICB9XG59XG5cbi8qKlxuICogUnVucyBcIm5vdGlmeVwiIGVmZmVjdHMgZm9yIGEgc2V0IG9mIGNoYW5nZWQgcHJvcGVydGllcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gdGhlIGdlbmVyaWMgYHJ1bkVmZmVjdHNgIG1ldGhvZCBpbiB0aGF0IGl0XG4gKiB3aWxsIGRpc3BhdGNoIHBhdGggbm90aWZpY2F0aW9uIGV2ZW50cyBpbiB0aGUgY2FzZSB0aGF0IHRoZSBwcm9wZXJ0eVxuICogY2hhbmdlZCB3YXMgYSBwYXRoIGFuZCB0aGUgcm9vdCBwcm9wZXJ0eSBmb3IgdGhhdCBwYXRoIGRpZG4ndCBoYXZlIGFcbiAqIFwibm90aWZ5XCIgZWZmZWN0LiAgVGhpcyBpcyB0byBtYWludGFpbiAxLjAgYmVoYXZpb3IgdGhhdCBkaWQgbm90IHJlcXVpcmVcbiAqIGBub3RpZnk6IHRydWVgIHRvIGVuc3VyZSBvYmplY3Qgc3ViLXByb3BlcnR5IG5vdGlmaWNhdGlvbnMgd2VyZVxuICogc2VudC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gKiBAcGFyYW0ge09iamVjdH0gbm90aWZ5UHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgdG8gbm90aWZ5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuTm90aWZ5RWZmZWN0cyhpbnN0LCBub3RpZnlQcm9wcywgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAvLyBOb3RpZnlcbiAgbGV0IGZ4cyA9IGluc3RbVFlQRVMuTk9USUZZXTtcbiAgbGV0IG5vdGlmaWVkO1xuICBsZXQgaWQgPSBkZWR1cGVJZCsrO1xuICAvLyBUcnkgbm9ybWFsIG5vdGlmeSBlZmZlY3RzOyBpZiBub25lLCBmYWxsIGJhY2sgdG8gdHJ5IHBhdGggbm90aWZpY2F0aW9uXG4gIGZvciAobGV0IHByb3AgaW4gbm90aWZ5UHJvcHMpIHtcbiAgICBpZiAobm90aWZ5UHJvcHNbcHJvcF0pIHtcbiAgICAgIGlmIChmeHMgJiYgcnVuRWZmZWN0c0ZvclByb3BlcnR5KGluc3QsIGZ4cywgaWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpKSB7XG4gICAgICAgIG5vdGlmaWVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzUGF0aHMgJiYgbm90aWZ5UGF0aChpbnN0LCBwcm9wLCBwcm9wcykpIHtcbiAgICAgICAgbm90aWZpZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBGbHVzaCBob3N0IGlmIHdlIGFjdHVhbGx5IG5vdGlmaWVkIGFuZCBob3N0IHdhcyBiYXRjaGluZ1xuICAvLyBBbmQgdGhlIGhvc3QgaGFzIGFscmVhZHkgaW5pdGlhbGl6ZWQgY2xpZW50czsgdGhpcyBwcmV2ZW50c1xuICAvLyBhbiBpc3N1ZSB3aXRoIGEgaG9zdCBvYnNlcnZpbmcgZGF0YSBjaGFuZ2VzIGJlZm9yZSBjbGllbnRzIGFyZSByZWFkeS5cbiAgbGV0IGhvc3Q7XG4gIGlmIChub3RpZmllZCAmJiAoaG9zdCA9IGluc3QuX19kYXRhSG9zdCkgJiYgaG9zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMpIHtcbiAgICBob3N0Ll9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2hlcyB7cHJvcGVydHl9LWNoYW5nZWQgZXZlbnRzIHdpdGggcGF0aCBpbmZvcm1hdGlvbiBpbiB0aGUgZGV0YWlsXG4gKiBvYmplY3QgdG8gaW5kaWNhdGUgYSBzdWItcGF0aCBvZiB0aGUgcHJvcGVydHkgd2FzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0aGF0IHdhcyBjaGFuZ2VkXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwYXRoIHdhcyBub3RpZmllZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm90aWZ5UGF0aChpbnN0LCBwYXRoLCBwcm9wcykge1xuICBsZXQgcm9vdFByb3BlcnR5ID0gcm9vdCQwKHBhdGgpO1xuICBpZiAocm9vdFByb3BlcnR5ICE9PSBwYXRoKSB7XG4gICAgbGV0IGV2ZW50TmFtZSA9IGNhbWVsVG9EYXNoQ2FzZSQwKHJvb3RQcm9wZXJ0eSkgKyAnLWNoYW5nZWQnO1xuICAgIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgZXZlbnROYW1lLCBwcm9wc1twYXRoXSwgcGF0aCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIERpc3BhdGNoZXMge3Byb3BlcnR5fS1jaGFuZ2VkIGV2ZW50cyB0byBpbmRpY2F0ZSBhIHByb3BlcnR5IChvciBwYXRoKVxuICogY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBlbGVtZW50IGZyb20gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgVGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIHNlbmQgKCd7cHJvcGVydHl9LWNoYW5nZWQnKVxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIGNoYW5nZWQgcHJvcGVydHlcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZH0gcGF0aCBJZiBhIHN1Yi1wYXRoIG9mIHRoaXMgcHJvcGVydHkgY2hhbmdlZCwgdGhlIHBhdGhcbiAqICAgdGhhdCBjaGFuZ2VkIChvcHRpb25hbCkuXG4gKiBAcHJpdmF0ZVxuICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gKi9cbmZ1bmN0aW9uIGRpc3BhdGNoTm90aWZ5RXZlbnQoaW5zdCwgZXZlbnROYW1lLCB2YWx1ZSwgcGF0aCkge1xuICBsZXQgZGV0YWlsID0ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBxdWV1ZVByb3BlcnR5OiB0cnVlXG4gIH07XG4gIGlmIChwYXRoKSB7XG4gICAgZGV0YWlsLnBhdGggPSBwYXRoO1xuICB9XG4gIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyhpbnN0KS5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChldmVudE5hbWUsIHsgZGV0YWlsIH0pKTtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcIm5vdGlmeVwiIGVmZmVjdC5cbiAqXG4gKiBEaXNwYXRjaGVzIGEgbm9uLWJ1YmJsaW5nIGV2ZW50IG5hbWVkIGBpbmZvLmV2ZW50TmFtZWAgb24gdGhlIGluc3RhbmNlXG4gKiB3aXRoIGEgZGV0YWlsIG9iamVjdCBjb250YWluaW5nIHRoZSBuZXcgYHZhbHVlYC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocykge1xuICBsZXQgcm9vdFByb3BlcnR5ID0gaGFzUGF0aHMgPyByb290JDAocHJvcGVydHkpIDogcHJvcGVydHk7XG4gIGxldCBwYXRoID0gcm9vdFByb3BlcnR5ICE9IHByb3BlcnR5ID8gcHJvcGVydHkgOiBudWxsO1xuICBsZXQgdmFsdWUgPSBwYXRoID8gZ2V0JDAoaW5zdCwgcGF0aCkgOiBpbnN0Ll9fZGF0YVtwcm9wZXJ0eV07XG4gIGlmIChwYXRoICYmIHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICB2YWx1ZSA9IHByb3BzW3Byb3BlcnR5XTsgIC8vIHNwZWNpZmljYWxseSBmb3IgLnNwbGljZXNcbiAgfVxuICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGluZm8uZXZlbnROYW1lLCB2YWx1ZSwgcGF0aCk7XG59XG5cbi8qKlxuICogSGFuZGxlciBmdW5jdGlvbiBmb3IgMi13YXkgbm90aWZpY2F0aW9uIGV2ZW50cy4gUmVjZWl2ZXMgY29udGV4dFxuICogaW5mb3JtYXRpb24gY2FwdHVyZWQgaW4gdGhlIGBhZGROb3RpZnlMaXN0ZW5lcmAgY2xvc3VyZSBmcm9tIHRoZVxuICogYF9fbm90aWZ5TGlzdGVuZXJzYCBtZXRhZGF0YS5cbiAqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgbm90aWZpZWQgcHJvcGVydHkgdG8gdGhlIGhvc3QgcHJvcGVydHkgb3IgcGF0aC4gIElmXG4gKiB0aGUgZXZlbnQgY29udGFpbmVkIHBhdGggaW5mb3JtYXRpb24sIHRyYW5zbGF0ZSB0aGF0IHBhdGggdG8gdGhlIGhvc3RcbiAqIHNjb3BlJ3MgbmFtZSBmb3IgdGhhdCBwYXRoIGZpcnN0LlxuICpcbiAqIEBwYXJhbSB7Q3VzdG9tRXZlbnR9IGV2ZW50IE5vdGlmaWNhdGlvbiBldmVudCAoZS5nLiAnPHByb3BlcnR5Pi1jaGFuZ2VkJylcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSG9zdCBlbGVtZW50IGluc3RhbmNlIGhhbmRsaW5nIHRoZSBub3RpZmljYXRpb24gZXZlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBmcm9tUHJvcCBDaGlsZCBlbGVtZW50IHByb3BlcnR5IHRoYXQgd2FzIGJvdW5kXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9QYXRoIEhvc3QgcHJvcGVydHkvcGF0aCB0aGF0IHdhcyBib3VuZFxuICogQHBhcmFtIHtib29sZWFufSBuZWdhdGUgV2hldGhlciB0aGUgYmluZGluZyB3YXMgbmVnYXRlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaGFuZGxlTm90aWZpY2F0aW9uKGV2ZW50LCBpbnN0LCBmcm9tUHJvcCwgdG9QYXRoLCBuZWdhdGUpIHtcbiAgbGV0IHZhbHVlO1xuICBsZXQgZGV0YWlsID0gLyoqIEB0eXBlIHtPYmplY3R9ICovKGV2ZW50LmRldGFpbCk7XG4gIGxldCBmcm9tUGF0aCA9IGRldGFpbCAmJiBkZXRhaWwucGF0aDtcbiAgaWYgKGZyb21QYXRoKSB7XG4gICAgdG9QYXRoID0gdHJhbnNsYXRlKGZyb21Qcm9wLCB0b1BhdGgsIGZyb21QYXRoKTtcbiAgICB2YWx1ZSA9IGRldGFpbCAmJiBkZXRhaWwudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBldmVudC50YXJnZXRbZnJvbVByb3BdO1xuICB9XG4gIHZhbHVlID0gbmVnYXRlID8gIXZhbHVlIDogdmFsdWU7XG4gIGlmICghaW5zdFtUWVBFUy5SRUFEX09OTFldIHx8ICFpbnN0W1RZUEVTLlJFQURfT05MWV1bdG9QYXRoXSkge1xuICAgIGlmIChpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgodG9QYXRoLCB2YWx1ZSwgdHJ1ZSwgQm9vbGVhbihmcm9tUGF0aCkpXG4gICAgICAmJiAoIWRldGFpbCB8fCAhZGV0YWlsLnF1ZXVlUHJvcGVydHkpKSB7XG4gICAgICBpbnN0Ll9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIFwicmVmbGVjdFwiIGVmZmVjdC5cbiAqXG4gKiBTZXRzIHRoZSBhdHRyaWJ1dGUgbmFtZWQgYGluZm8uYXR0ck5hbWVgIHRvIHRoZSBnaXZlbiBwcm9wZXJ0eSB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1blJlZmxlY3RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICBsZXQgdmFsdWUgPSBpbnN0Ll9fZGF0YVtwcm9wZXJ0eV07XG4gIGlmIChzYW5pdGl6ZURPTVZhbHVlKSB7XG4gICAgdmFsdWUgPSBzYW5pdGl6ZURPTVZhbHVlKHZhbHVlLCBpbmZvLmF0dHJOYW1lLCAnYXR0cmlidXRlJywgLyoqIEB0eXBlIHtOb2RlfSAqLyhpbnN0KSk7XG4gIH1cbiAgaW5zdC5fcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgaW5mby5hdHRyTmFtZSwgdmFsdWUpO1xufVxuXG4vKipcbiAqIFJ1bnMgXCJjb21wdXRlZFwiIGVmZmVjdHMgZm9yIGEgc2V0IG9mIGNoYW5nZWQgcHJvcGVydGllcy5cbiAqXG4gKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gdGhlIGdlbmVyaWMgYHJ1bkVmZmVjdHNgIG1ldGhvZCBpbiB0aGF0IGl0XG4gKiBjb250aW51ZXMgdG8gcnVuIGNvbXB1dGVkIGVmZmVjdHMgYmFzZWQgb24gdGhlIG91dHB1dCBvZiBlYWNoIHBhc3MgdW50aWxcbiAqIHRoZXJlIGFyZSBubyBtb3JlIG5ld2x5IGNvbXB1dGVkIHByb3BlcnRpZXMuICBUaGlzIGVuc3VyZXMgdGhhdCBhbGxcbiAqIHByb3BlcnRpZXMgdGhhdCB3aWxsIGJlIGNvbXB1dGVkIGJ5IHRoZSBpbml0aWFsIHNldCBvZiBjaGFuZ2VzIGFyZVxuICogY29tcHV0ZWQgYmVmb3JlIG90aGVyIGVmZmVjdHMgKGJpbmRpbmcgcHJvcGFnYXRpb24sIG9ic2VydmVycywgYW5kIG5vdGlmeSlcbiAqIHJ1bi5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0geyFPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0geyFPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuQ29tcHV0ZWRFZmZlY3RzKGluc3QsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gIGxldCBjb21wdXRlRWZmZWN0cyA9IGluc3RbVFlQRVMuQ09NUFVURV07XG4gIGlmIChjb21wdXRlRWZmZWN0cykge1xuICAgIGxldCBpbnB1dFByb3BzID0gY2hhbmdlZFByb3BzO1xuICAgIHdoaWxlIChydW5FZmZlY3RzKGluc3QsIGNvbXB1dGVFZmZlY3RzLCBpbnB1dFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpKSB7XG4gICAgICBPYmplY3QuYXNzaWduKG9sZFByb3BzLCBpbnN0Ll9fZGF0YU9sZCk7XG4gICAgICBPYmplY3QuYXNzaWduKGNoYW5nZWRQcm9wcywgaW5zdC5fX2RhdGFQZW5kaW5nKTtcbiAgICAgIGlucHV0UHJvcHMgPSBpbnN0Ll9fZGF0YVBlbmRpbmc7XG4gICAgICBpbnN0Ll9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgdGhlIFwiY29tcHV0ZWQgcHJvcGVydHlcIiBlZmZlY3QgYnkgcnVubmluZyB0aGUgbWV0aG9kIHdpdGggdGhlXG4gKiB2YWx1ZXMgb2YgdGhlIGFyZ3VtZW50cyBzcGVjaWZpZWQgaW4gdGhlIGBpbmZvYCBvYmplY3QgYW5kIHNldHRpbmcgdGhlXG4gKiByZXR1cm4gdmFsdWUgdG8gdGhlIGNvbXB1dGVkIHByb3BlcnR5IHNwZWNpZmllZC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgbGV0IHJlc3VsdCA9IHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKTtcbiAgbGV0IGNvbXB1dGVkUHJvcCA9IGluZm8ubWV0aG9kSW5mbztcbiAgaWYgKGluc3QuX19kYXRhSGFzQWNjZXNzb3IgJiYgaW5zdC5fX2RhdGFIYXNBY2Nlc3Nvcltjb21wdXRlZFByb3BdKSB7XG4gICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KGNvbXB1dGVkUHJvcCwgcmVzdWx0LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0W2NvbXB1dGVkUHJvcF0gPSByZXN1bHQ7XG4gIH1cbn1cblxuLyoqXG4gKiBDb21wdXRlcyBwYXRoIGNoYW5nZXMgYmFzZWQgb24gcGF0aCBsaW5rcyBzZXQgdXAgdXNpbmcgdGhlIGBsaW5rUGF0aHNgXG4gKiBBUEkuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2hvc2UgcHJvcHMgYXJlIGNoYW5naW5nXG4gKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTwoc3RyaW5nfG51bWJlcik+fSBwYXRoIFBhdGggdGhhdCBoYXMgY2hhbmdlZFxuICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiBjaGFuZ2VkIHBhdGhcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVMaW5rZWRQYXRocyhpbnN0LCBwYXRoLCB2YWx1ZSkge1xuICBsZXQgbGlua3MgPSBpbnN0Ll9fZGF0YUxpbmtlZFBhdGhzO1xuICBpZiAobGlua3MpIHtcbiAgICBsZXQgbGluaztcbiAgICBmb3IgKGxldCBhIGluIGxpbmtzKSB7XG4gICAgICBsZXQgYiA9IGxpbmtzW2FdO1xuICAgICAgaWYgKGlzRGVzY2VuZGFudChhLCBwYXRoKSkge1xuICAgICAgICBsaW5rID0gdHJhbnNsYXRlKGEsIGIsIHBhdGgpO1xuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgobGluaywgdmFsdWUsIHRydWUsIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChpc0Rlc2NlbmRhbnQoYiwgcGF0aCkpIHtcbiAgICAgICAgbGluayA9IHRyYW5zbGF0ZShiLCBhLCBwYXRoKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGxpbmssIHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gLS0gYmluZGluZ3MgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFkZHMgYmluZGluZyBtZXRhZGF0YSB0byB0aGUgY3VycmVudCBgbm9kZUluZm9gLCBhbmQgYmluZGluZyBlZmZlY3RzXG4gKiBmb3IgYWxsIHBhcnQgZGVwZW5kZW5jaWVzIHRvIGB0ZW1wbGF0ZUluZm9gLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbnN0cnVjdG9yIENsYXNzIHRoYXQgYF9wYXJzZVRlbXBsYXRlYCBpcyBjdXJyZW50bHlcbiAqICAgcnVubmluZyBvblxuICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30ga2luZCBCaW5kaW5nIGtpbmQsIGVpdGhlciAncHJvcGVydHknLCAnYXR0cmlidXRlJywgb3IgJ3RleHQnXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFyZ2V0IFRhcmdldCBwcm9wZXJ0eSBuYW1lXG4gKiBAcGFyYW0geyFBcnJheTwhQmluZGluZ1BhcnQ+fSBwYXJ0cyBBcnJheSBvZiBiaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbGl0ZXJhbCBMaXRlcmFsIHRleHQgc3Vycm91bmRpbmcgYmluZGluZyBwYXJ0cyAoc3BlY2lmaWVkXG4gKiAgIG9ubHkgZm9yICdwcm9wZXJ0eScgYmluZGluZ3MsIHNpbmNlIHRoZXNlIG11c3QgYmUgaW5pdGlhbGl6ZWQgYXMgcGFydFxuICogICBvZiBib290LXVwKVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkQmluZGluZyhjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCkge1xuICAvLyBDcmVhdGUgYmluZGluZyBtZXRhZGF0YSBhbmQgYWRkIHRvIG5vZGVJbmZvXG4gIG5vZGVJbmZvLmJpbmRpbmdzID0gbm9kZUluZm8uYmluZGluZ3MgfHwgW107XG4gIGxldCAvKiogQmluZGluZyAqLyBiaW5kaW5nID0geyBraW5kLCB0YXJnZXQsIHBhcnRzLCBsaXRlcmFsLCBpc0NvbXBvdW5kOiAocGFydHMubGVuZ3RoICE9PSAxKSB9O1xuICBub2RlSW5mby5iaW5kaW5ncy5wdXNoKGJpbmRpbmcpO1xuICAvLyBBZGQgbGlzdGVuZXIgaW5mbyB0byBiaW5kaW5nIG1ldGFkYXRhXG4gIGlmIChzaG91bGRBZGRMaXN0ZW5lcihiaW5kaW5nKSkge1xuICAgIGxldCB7ZXZlbnQsIG5lZ2F0ZX0gPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgIGJpbmRpbmcubGlzdGVuZXJFdmVudCA9IGV2ZW50IHx8IChDYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZSh0YXJnZXQpICsgJy1jaGFuZ2VkJyk7XG4gICAgYmluZGluZy5saXN0ZW5lck5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgfVxuICAvLyBBZGQgXCJwcm9wYWdhdGVcIiBwcm9wZXJ0eSBlZmZlY3RzIHRvIHRlbXBsYXRlSW5mb1xuICBsZXQgaW5kZXggPSB0ZW1wbGF0ZUluZm8ubm9kZUluZm9MaXN0Lmxlbmd0aDtcbiAgZm9yIChsZXQgaT0wOyBpPGJpbmRpbmcucGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcGFydCA9IGJpbmRpbmcucGFydHNbaV07XG4gICAgcGFydC5jb21wb3VuZEluZGV4ID0gaTtcbiAgICBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIHByb3BlcnR5IGVmZmVjdHMgdG8gdGhlIGdpdmVuIGB0ZW1wbGF0ZUluZm9gIGZvciB0aGUgZ2l2ZW4gYmluZGluZ1xuICogcGFydC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gKiAgIHJ1bm5pbmcgb25cbiAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggaW50byBgbm9kZUluZm9MaXN0YCBmb3IgdGhpcyBub2RlXG4gKi9cbmZ1bmN0aW9uIGFkZEVmZmVjdEZvckJpbmRpbmdQYXJ0KGNvbnN0cnVjdG9yLCB0ZW1wbGF0ZUluZm8sIGJpbmRpbmcsIHBhcnQsIGluZGV4KSB7XG4gIGlmICghcGFydC5saXRlcmFsKSB7XG4gICAgaWYgKGJpbmRpbmcua2luZCA9PT0gJ2F0dHJpYnV0ZScgJiYgYmluZGluZy50YXJnZXRbMF0gPT09ICctJykge1xuICAgICAgY29uc29sZS53YXJuKCdDYW5ub3Qgc2V0IGF0dHJpYnV0ZSAnICsgYmluZGluZy50YXJnZXQgK1xuICAgICAgICAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgYXR0cmlidXRlIHN0YXJ0aW5nIGNoYXJhY3RlcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGVwZW5kZW5jaWVzID0gcGFydC5kZXBlbmRlbmNpZXM7XG4gICAgICBsZXQgaW5mbyA9IHsgaW5kZXgsIGJpbmRpbmcsIHBhcnQsIGV2YWx1YXRvcjogY29uc3RydWN0b3IgfTtcbiAgICAgIGZvciAobGV0IGo9MDsgajxkZXBlbmRlbmNpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgbGV0IHRyaWdnZXIgPSBkZXBlbmRlbmNpZXNbal07XG4gICAgICAgIGlmICh0eXBlb2YgdHJpZ2dlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHRyaWdnZXIgPSBwYXJzZUFyZyh0cmlnZ2VyKTtcbiAgICAgICAgICB0cmlnZ2VyLndpbGRjYXJkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdHJ1Y3Rvci5fYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHRyaWdnZXIucm9vdFByb3BlcnR5LCB7XG4gICAgICAgICAgZm46IHJ1bkJpbmRpbmdFZmZlY3QsXG4gICAgICAgICAgaW5mbywgdHJpZ2dlclxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcImJpbmRpbmdcIiAocHJvcGVydHkvcGF0aCBiaW5kaW5nKSBlZmZlY3QuXG4gKlxuICogTm90ZSB0aGF0IGJpbmRpbmcgc3ludGF4IGlzIG92ZXJyaWRhYmxlIHZpYSBgX3BhcnNlQmluZGluZ3NgIGFuZFxuICogYF9ldmFsdWF0ZUJpbmRpbmdgLiAgVGhpcyBtZXRob2Qgd2lsbCBjYWxsIGBfZXZhbHVhdGVCaW5kaW5nYCBmb3IgYW55XG4gKiBub24tbGl0ZXJhbCBwYXJ0cyByZXR1cm5lZCBmcm9tIGBfcGFyc2VCaW5kaW5nc2AuICBIb3dldmVyLFxuICogdGhlcmUgaXMgbm8gc3VwcG9ydCBmb3IgX3BhdGhfIGJpbmRpbmdzIHZpYSBjdXN0b20gYmluZGluZyBwYXJ0cyxcbiAqIGFzIHRoaXMgaXMgc3BlY2lmaWMgdG8gUG9seW1lcidzIHBhdGggYmluZGluZyBzeW50YXguXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggTmFtZSBvZiBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwYXJhbSB7QXJyYXl9IG5vZGVMaXN0IExpc3Qgb2Ygbm9kZXMgYXNzb2NpYXRlZCB3aXRoIGBub2RlSW5mb0xpc3RgIHRlbXBsYXRlXG4gKiAgIG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5CaW5kaW5nRWZmZWN0KGluc3QsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMsIG5vZGVMaXN0KSB7XG4gIGxldCBub2RlID0gbm9kZUxpc3RbaW5mby5pbmRleF07XG4gIGxldCBiaW5kaW5nID0gaW5mby5iaW5kaW5nO1xuICBsZXQgcGFydCA9IGluZm8ucGFydDtcbiAgLy8gU3VicGF0aCBub3RpZmljYXRpb246IHRyYW5zZm9ybSBwYXRoIGFuZCBzZXQgdG8gY2xpZW50XG4gIC8vIGUuZy46IGZvbz1cInt7b2JqLnN1Yn19XCIsIHBhdGg6ICdvYmouc3ViLnByb3AnLCBzZXQgJ2Zvby5wcm9wJz1vYmouc3ViLnByb3BcbiAgaWYgKGhhc1BhdGhzICYmIHBhcnQuc291cmNlICYmIChwYXRoLmxlbmd0aCA+IHBhcnQuc291cmNlLmxlbmd0aCkgJiZcbiAgICAgIChiaW5kaW5nLmtpbmQgPT0gJ3Byb3BlcnR5JykgJiYgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvciAmJiBub2RlLl9fZGF0YUhhc0FjY2Vzc29yW2JpbmRpbmcudGFyZ2V0XSkge1xuICAgIGxldCB2YWx1ZSA9IHByb3BzW3BhdGhdO1xuICAgIHBhdGggPSB0cmFuc2xhdGUocGFydC5zb3VyY2UsIGJpbmRpbmcudGFyZ2V0LCBwYXRoKTtcbiAgICBpZiAobm9kZS5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCBmYWxzZSwgdHJ1ZSkpIHtcbiAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxldCB2YWx1ZSA9IGluZm8uZXZhbHVhdG9yLl9ldmFsdWF0ZUJpbmRpbmcoaW5zdCwgcGFydCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgLy8gUHJvcGFnYXRlIHZhbHVlIHRvIGNoaWxkXG4gICAgYXBwbHlCaW5kaW5nVmFsdWUoaW5zdCwgbm9kZSwgYmluZGluZywgcGFydCwgdmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIGFuIFwiYmluZGluZ1wiIChiaW5kaW5nKSBlZmZlY3QgdG8gYSBub2RlLFxuICogZWl0aGVyIGFzIGEgcHJvcGVydHkgb3IgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIG93bmluZyB0aGUgYmluZGluZyBlZmZlY3RcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBUYXJnZXQgbm9kZSBmb3IgYmluZGluZ1xuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhcHBseUJpbmRpbmdWYWx1ZShpbnN0LCBub2RlLCBiaW5kaW5nLCBwYXJ0LCB2YWx1ZSkge1xuICB2YWx1ZSA9IGNvbXB1dGVCaW5kaW5nVmFsdWUobm9kZSwgdmFsdWUsIGJpbmRpbmcsIHBhcnQpO1xuICBpZiAoc2FuaXRpemVET01WYWx1ZSkge1xuICAgIHZhbHVlID0gc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgYmluZGluZy50YXJnZXQsIGJpbmRpbmcua2luZCwgbm9kZSk7XG4gIH1cbiAgaWYgKGJpbmRpbmcua2luZCA9PSAnYXR0cmlidXRlJykge1xuICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5nXG4gICAgaW5zdC5fdmFsdWVUb05vZGVBdHRyaWJ1dGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyhub2RlKSwgdmFsdWUsIGJpbmRpbmcudGFyZ2V0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBQcm9wZXJ0eSBiaW5kaW5nXG4gICAgbGV0IHByb3AgPSBiaW5kaW5nLnRhcmdldDtcbiAgICBpZiAobm9kZS5fX2RhdGFIYXNBY2Nlc3NvciAmJiBub2RlLl9fZGF0YUhhc0FjY2Vzc29yW3Byb3BdKSB7XG4gICAgICBpZiAoIW5vZGVbVFlQRVMuUkVBRF9PTkxZXSB8fCAhbm9kZVtUWVBFUy5SRUFEX09OTFldW3Byb3BdKSB7XG4gICAgICAgIGlmIChub2RlLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcCwgdmFsdWUpKSB7XG4gICAgICAgICAgaW5zdC5fZW5xdWV1ZUNsaWVudChub2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSAge1xuICAgICAgaW5zdC5fc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYW4gXCJiaW5kaW5nXCIgZWZmZWN0IHZhbHVlIGJhc2VkIG9uIGNvbXBvdW5kICYgbmVnYXRpb25cbiAqIGVmZmVjdCBtZXRhZGF0YSwgYXMgd2VsbCBhcyBoYW5kbGluZyBmb3Igc3BlY2lhbC1jYXNlIHByb3BlcnRpZXNcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0aGUgdmFsdWUgd2lsbCBiZSBzZXQgdG9cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICogQHJldHVybiB7Kn0gVHJhbnNmb3JtZWQgdmFsdWUgdG8gc2V0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KSB7XG4gIGlmIChiaW5kaW5nLmlzQ29tcG91bmQpIHtcbiAgICBsZXQgc3RvcmFnZSA9IG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlW2JpbmRpbmcudGFyZ2V0XTtcbiAgICBzdG9yYWdlW3BhcnQuY29tcG91bmRJbmRleF0gPSB2YWx1ZTtcbiAgICB2YWx1ZSA9IHN0b3JhZ2Uuam9pbignJyk7XG4gIH1cbiAgaWYgKGJpbmRpbmcua2luZCAhPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAvLyBTb21lIGJyb3dzZXJzIHNlcmlhbGl6ZSBgdW5kZWZpbmVkYCB0byBgXCJ1bmRlZmluZWRcImBcbiAgICBpZiAoYmluZGluZy50YXJnZXQgPT09ICd0ZXh0Q29udGVudCcgfHxcbiAgICAgICAgKG5vZGUubG9jYWxOYW1lID09ICdpbnB1dCcgJiYgYmluZGluZy50YXJnZXQgPT0gJ3ZhbHVlJykpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgPT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGJpbmRpbmcncyBtZXRhZGF0YSBtZWV0cyBhbGwgdGhlIHJlcXVpcmVtZW50cyB0byBhbGxvd1xuICogMi13YXkgYmluZGluZywgYW5kIHRoZXJlZm9yZSBhIGA8cHJvcGVydHk+LWNoYW5nZWRgIGV2ZW50IGxpc3RlbmVyIHNob3VsZCBiZVxuICogYWRkZWQ6XG4gKiAtIHVzZWQgY3VybHkgYnJhY2VzXG4gKiAtIGlzIGEgcHJvcGVydHkgKG5vdCBhdHRyaWJ1dGUpIGJpbmRpbmdcbiAqIC0gaXMgbm90IGEgdGV4dENvbnRlbnQgYmluZGluZ1xuICogLSBpcyBub3QgY29tcG91bmRcbiAqXG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgMi13YXkgbGlzdGVuZXIgc2hvdWxkIGJlIGFkZGVkXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzaG91bGRBZGRMaXN0ZW5lcihiaW5kaW5nKSB7XG4gIHJldHVybiBCb29sZWFuKGJpbmRpbmcudGFyZ2V0KSAmJlxuICAgICAgICAgYmluZGluZy5raW5kICE9ICdhdHRyaWJ1dGUnICYmXG4gICAgICAgICBiaW5kaW5nLmtpbmQgIT0gJ3RleHQnICYmXG4gICAgICAgICAhYmluZGluZy5pc0NvbXBvdW5kICYmXG4gICAgICAgICBiaW5kaW5nLnBhcnRzWzBdLm1vZGUgPT09ICd7Jztcbn1cblxuLyoqXG4gKiBTZXR1cCBjb21wb3VuZCBiaW5kaW5nIHN0b3JhZ2Ugc3RydWN0dXJlcywgbm90aWZ5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0XG4gKiByZWZlcmVuY2VzIG9udG8gdGhlIGJvdW5kIG5vZGVMaXN0LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdGhhdCBiYXMgYmVlbiBwcmV2aW91c2x5IGJvdW5kXG4gKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cEJpbmRpbmdzKGluc3QsIHRlbXBsYXRlSW5mbykge1xuICAvLyBTZXR1cCBjb21wb3VuZCBzdG9yYWdlLCBkYXRhSG9zdCwgYW5kIG5vdGlmeSBsaXN0ZW5lcnNcbiAgbGV0IHtub2RlTGlzdCwgbm9kZUluZm9MaXN0fSA9IHRlbXBsYXRlSW5mbztcbiAgaWYgKG5vZGVJbmZvTGlzdC5sZW5ndGgpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBub2RlSW5mb0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBpbmZvID0gbm9kZUluZm9MaXN0W2ldO1xuICAgICAgbGV0IG5vZGUgPSBub2RlTGlzdFtpXTtcbiAgICAgIGxldCBiaW5kaW5ncyA9IGluZm8uYmluZGluZ3M7XG4gICAgICBpZiAoYmluZGluZ3MpIHtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpPGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgbGV0IGJpbmRpbmcgPSBiaW5kaW5nc1tpXTtcbiAgICAgICAgICBzZXR1cENvbXBvdW5kU3RvcmFnZShub2RlLCBiaW5kaW5nKTtcbiAgICAgICAgICBhZGROb3RpZnlMaXN0ZW5lcihub2RlLCBpbnN0LCBiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbm9kZS5fX2RhdGFIb3N0ID0gaW5zdDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbml0aWFsaXplcyBgX19kYXRhQ29tcG91bmRTdG9yYWdlYCBsb2NhbCBzdG9yYWdlIG9uIGEgYm91bmQgbm9kZSB3aXRoXG4gKiBpbml0aWFsIGxpdGVyYWwgZGF0YSBmb3IgY29tcG91bmQgYmluZGluZ3MsIGFuZCBzZXRzIHRoZSBqb2luZWRcbiAqIGxpdGVyYWwgcGFydHMgdG8gdGhlIGJvdW5kIHByb3BlcnR5LlxuICpcbiAqIFdoZW4gY2hhbmdlcyB0byBjb21wb3VuZCBwYXJ0cyBvY2N1ciwgdGhleSBhcmUgZmlyc3Qgc2V0IGludG8gdGhlIGNvbXBvdW5kXG4gKiBzdG9yYWdlIGFycmF5IGZvciB0aGF0IHByb3BlcnR5LCBhbmQgdGhlbiB0aGUgYXJyYXkgaXMgam9pbmVkIHRvIHJlc3VsdCBpblxuICogdGhlIGZpbmFsIHZhbHVlIHNldCB0byB0aGUgcHJvcGVydHkvYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBCb3VuZCBub2RlIHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7QmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXR1cENvbXBvdW5kU3RvcmFnZShub2RlLCBiaW5kaW5nKSB7XG4gIGlmIChiaW5kaW5nLmlzQ29tcG91bmQpIHtcbiAgICAvLyBDcmVhdGUgY29tcG91bmQgc3RvcmFnZSBtYXBcbiAgICBsZXQgc3RvcmFnZSA9IG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlIHx8XG4gICAgICAobm9kZS5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB7fSk7XG4gICAgbGV0IHBhcnRzID0gYmluZGluZy5wYXJ0cztcbiAgICAvLyBDb3B5IGxpdGVyYWxzIGZyb20gcGFydHMgaW50byBzdG9yYWdlIGZvciB0aGlzIGJpbmRpbmdcbiAgICBsZXQgbGl0ZXJhbHMgPSBuZXcgQXJyYXkocGFydHMubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBqPTA7IGo8cGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIGxpdGVyYWxzW2pdID0gcGFydHNbal0ubGl0ZXJhbDtcbiAgICB9XG4gICAgbGV0IHRhcmdldCA9IGJpbmRpbmcudGFyZ2V0O1xuICAgIHN0b3JhZ2VbdGFyZ2V0XSA9IGxpdGVyYWxzO1xuICAgIC8vIENvbmZpZ3VyZSBwcm9wZXJ0aWVzIHdpdGggdGhlaXIgbGl0ZXJhbCBwYXJ0c1xuICAgIGlmIChiaW5kaW5nLmxpdGVyYWwgJiYgYmluZGluZy5raW5kID09ICdwcm9wZXJ0eScpIHtcbiAgICAgIG5vZGVbdGFyZ2V0XSA9IGJpbmRpbmcubGl0ZXJhbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBZGRzIGEgMi13YXkgYmluZGluZyBub3RpZmljYXRpb24gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIG5vZGUgc3BlY2lmaWVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG5vZGUgQ2hpbGQgZWxlbWVudCB0byBhZGQgbGlzdGVuZXIgdG9cbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSG9zdCBlbGVtZW50IGluc3RhbmNlIHRvIGhhbmRsZSBub3RpZmljYXRpb24gZXZlbnRcbiAqIEBwYXJhbSB7QmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGROb3RpZnlMaXN0ZW5lcihub2RlLCBpbnN0LCBiaW5kaW5nKSB7XG4gIGlmIChiaW5kaW5nLmxpc3RlbmVyRXZlbnQpIHtcbiAgICBsZXQgcGFydCA9IGJpbmRpbmcucGFydHNbMF07XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGJpbmRpbmcubGlzdGVuZXJFdmVudCwgZnVuY3Rpb24oZSkge1xuICAgICAgaGFuZGxlTm90aWZpY2F0aW9uKGUsIGluc3QsIGJpbmRpbmcudGFyZ2V0LCBwYXJ0LnNvdXJjZSwgcGFydC5uZWdhdGUpO1xuICAgIH0pO1xuICB9XG59XG5cbi8vIC0tIGZvciBtZXRob2QtYmFzZWQgZWZmZWN0cyAoY29tcGxleE9ic2VydmVyICYgY29tcHV0ZWQpIC0tLS0tLS0tLS0tLS0tXG5cbi8qKlxuICogQWRkcyBwcm9wZXJ0eSBlZmZlY3RzIGZvciBlYWNoIGFyZ3VtZW50IGluIHRoZSBtZXRob2Qgc2lnbmF0dXJlIChhbmRcbiAqIG9wdGlvbmFsbHksIGZvciB0aGUgbWV0aG9kIG5hbWUgaWYgYGR5bmFtaWNgIGlzIHRydWUpIHRoYXQgY2FsbHMgdGhlXG4gKiBwcm92aWRlZCBlZmZlY3QgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtIHtFbGVtZW50IHwgT2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7IU1ldGhvZFNpZ25hdHVyZX0gc2lnIE1ldGhvZCBzaWduYXR1cmUgbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFR5cGUgb2YgcHJvcGVydHkgZWZmZWN0IHRvIGFkZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZWZmZWN0Rm4gRnVuY3Rpb24gdG8gcnVuIHdoZW4gYXJndW1lbnRzIGNoYW5nZVxuICogQHBhcmFtIHsqPX0gbWV0aG9kSW5mbyBFZmZlY3Qtc3BlY2lmaWMgaW5mb3JtYXRpb24gdG8gYmUgaW5jbHVkZWQgaW5cbiAqICAgbWV0aG9kIGVmZmVjdCBtZXRhZGF0YVxuICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZyB3aGV0aGVyXG4gKiAgIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuIE5vdGUsXG4gKiAgIGRlZmF1bHRzIHRvIHRydWUgaWYgdGhlIHNpZ25hdHVyZSBpcyBzdGF0aWMgKHNpZy5zdGF0aWMgaXMgdHJ1ZSkuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXRob2RFZmZlY3QobW9kZWwsIHNpZywgdHlwZSwgZWZmZWN0Rm4sIG1ldGhvZEluZm8sIGR5bmFtaWNGbikge1xuICBkeW5hbWljRm4gPSBzaWcuc3RhdGljIHx8IChkeW5hbWljRm4gJiZcbiAgICAodHlwZW9mIGR5bmFtaWNGbiAhPT0gJ29iamVjdCcgfHwgZHluYW1pY0ZuW3NpZy5tZXRob2ROYW1lXSkpO1xuICBsZXQgaW5mbyA9IHtcbiAgICBtZXRob2ROYW1lOiBzaWcubWV0aG9kTmFtZSxcbiAgICBhcmdzOiBzaWcuYXJncyxcbiAgICBtZXRob2RJbmZvLFxuICAgIGR5bmFtaWNGblxuICB9O1xuICBmb3IgKGxldCBpPTAsIGFyZzsgKGk8c2lnLmFyZ3MubGVuZ3RoKSAmJiAoYXJnPXNpZy5hcmdzW2ldKTsgaSsrKSB7XG4gICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgbW9kZWwuX2FkZFByb3BlcnR5RWZmZWN0KGFyZy5yb290UHJvcGVydHksIHR5cGUsIHtcbiAgICAgICAgZm46IGVmZmVjdEZuLCBpbmZvOiBpbmZvLCB0cmlnZ2VyOiBhcmdcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZHluYW1pY0ZuKSB7XG4gICAgbW9kZWwuX2FkZFByb3BlcnR5RWZmZWN0KHNpZy5tZXRob2ROYW1lLCB0eXBlLCB7XG4gICAgICBmbjogZWZmZWN0Rm4sIGluZm86IGluZm9cbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENhbGxzIGEgbWV0aG9kIHdpdGggYXJndW1lbnRzIG1hcnNoYWxlZCBmcm9tIHByb3BlcnRpZXMgb24gdGhlIGluc3RhbmNlXG4gKiBiYXNlZCBvbiB0aGUgbWV0aG9kIHNpZ25hdHVyZSBjb250YWluZWQgaW4gdGhlIGVmZmVjdCBtZXRhZGF0YS5cbiAqXG4gKiBNdWx0aS1wcm9wZXJ0eSBvYnNlcnZlcnMsIGNvbXB1dGVkIHByb3BlcnRpZXMsIGFuZCBpbmxpbmUgY29tcHV0aW5nXG4gKiBmdW5jdGlvbnMgY2FsbCB0aGlzIGZ1bmN0aW9uIHRvIGludm9rZSB0aGUgbWV0aG9kLCB0aGVuIHVzZSB0aGUgcmV0dXJuXG4gKiB2YWx1ZSBhY2NvcmRpbmdseS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB0aGUgZWZmZWN0IHdpbGwgYmUgcnVuIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiBwcm9wZXJ0eVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7P30gaW5mbyBFZmZlY3QgbWV0YWRhdGFcbiAqIEByZXR1cm4geyp9IFJldHVybnMgdGhlIHJldHVybiB2YWx1ZSBmcm9tIHRoZSBtZXRob2QgaW52b2NhdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuTWV0aG9kRWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgLy8gSW5zdGFuY2VzIGNhbiBvcHRpb25hbGx5IGhhdmUgYSBfbWV0aG9kSG9zdCB3aGljaCBhbGxvd3MgcmVkaXJlY3Rpbmcgd2hlcmVcbiAgLy8gdG8gZmluZCBtZXRob2RzLiBDdXJyZW50bHkgdXNlZCBieSBgdGVtcGxhdGl6ZWAuXG4gIGxldCBjb250ZXh0ID0gaW5zdC5fbWV0aG9kSG9zdCB8fCBpbnN0O1xuICBsZXQgZm4gPSBjb250ZXh0W2luZm8ubWV0aG9kTmFtZV07XG4gIGlmIChmbikge1xuICAgIGxldCBhcmdzID0gbWFyc2hhbEFyZ3MoaW5zdC5fX2RhdGEsIGluZm8uYXJncywgcHJvcGVydHksIHByb3BzKTtcbiAgICByZXR1cm4gZm4uYXBwbHkoY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSBpZiAoIWluZm8uZHluYW1pY0ZuKSB7XG4gICAgY29uc29sZS53YXJuKCdtZXRob2QgYCcgKyBpbmZvLm1ldGhvZE5hbWUgKyAnYCBub3QgZGVmaW5lZCcpO1xuICB9XG59XG5cbmNvbnN0IGVtcHR5QXJyYXkgPSBbXTtcblxuLy8gUmVndWxhciBleHByZXNzaW9ucyB1c2VkIGZvciBiaW5kaW5nXG5jb25zdCBJREVOVCAgPSAnKD86JyArICdbYS16QS1aXyRdW1xcXFx3LjokXFxcXC0qXSonICsgJyknO1xuY29uc3QgTlVNQkVSID0gJyg/OicgKyAnWy0rXT9bMC05XSpcXFxcLj9bMC05XSsoPzpbZUVdWy0rXT9bMC05XSspPycgKyAnKSc7XG5jb25zdCBTUVVPVEVfU1RSSU5HID0gJyg/OicgKyAnXFwnKD86W15cXCdcXFxcXFxcXF18XFxcXFxcXFwuKSpcXCcnICsgJyknO1xuY29uc3QgRFFVT1RFX1NUUklORyA9ICcoPzonICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXC4pKlwiJyArICcpJztcbmNvbnN0IFNUUklORyA9ICcoPzonICsgU1FVT1RFX1NUUklORyArICd8JyArIERRVU9URV9TVFJJTkcgKyAnKSc7XG5jb25zdCBBUkdVTUVOVCA9ICcoPzooJyArIElERU5UICsgJ3wnICsgTlVNQkVSICsgJ3wnICsgIFNUUklORyArICcpXFxcXHMqJyArICcpJztcbmNvbnN0IEFSR1VNRU5UUyA9ICcoPzonICsgQVJHVU1FTlQgKyAnKD86LFxcXFxzKicgKyBBUkdVTUVOVCArICcpKicgKyAnKSc7XG5jb25zdCBBUkdVTUVOVF9MSVNUID0gJyg/OicgKyAnXFxcXChcXFxccyonICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcoPzonICsgQVJHVU1FTlRTICsgJz8nICsgJyknICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnXFxcXClcXFxccyonICsgJyknO1xuY29uc3QgQklORElORyA9ICcoJyArIElERU5UICsgJ1xcXFxzKicgKyBBUkdVTUVOVF9MSVNUICsgJz8nICsgJyknOyAvLyBHcm91cCAzXG5jb25zdCBPUEVOX0JSQUNLRVQgPSAnKFxcXFxbXFxcXFt8e3spJyArICdcXFxccyonO1xuY29uc3QgQ0xPU0VfQlJBQ0tFVCA9ICcoPzpdXXx9fSknO1xuY29uc3QgTkVHQVRFID0gJyg/OighKVxcXFxzKik/JzsgLy8gR3JvdXAgMlxuY29uc3QgRVhQUkVTU0lPTiA9IE9QRU5fQlJBQ0tFVCArIE5FR0FURSArIEJJTkRJTkcgKyBDTE9TRV9CUkFDS0VUO1xuY29uc3QgYmluZGluZ1JlZ2V4ID0gbmV3IFJlZ0V4cChFWFBSRVNTSU9OLCBcImdcIik7XG5cbi8qKlxuICogQ3JlYXRlIGEgc3RyaW5nIGZyb20gYmluZGluZyBwYXJ0cyBvZiBhbGwgdGhlIGxpdGVyYWwgcGFydHNcbiAqXG4gKiBAcGFyYW0geyFBcnJheTxCaW5kaW5nUGFydD59IHBhcnRzIEFsbCBwYXJ0cyB0byBzdHJpbmdpZnlcbiAqIEByZXR1cm4ge3N0cmluZ30gU3RyaW5nIG1hZGUgZnJvbSB0aGUgbGl0ZXJhbCBwYXJ0c1xuICovXG5mdW5jdGlvbiBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB7XG4gIGxldCBzID0gJyc7XG4gIGZvciAobGV0IGk9MDsgaTxwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBsaXRlcmFsID0gcGFydHNbaV0ubGl0ZXJhbDtcbiAgICBzICs9IGxpdGVyYWwgfHwgJyc7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGV4cHJlc3Npb24gc3RyaW5nIGZvciBhIG1ldGhvZCBzaWduYXR1cmUsIGFuZCByZXR1cm5zIGEgbWV0YWRhdGFcbiAqIGRlc2NyaWJpbmcgdGhlIG1ldGhvZCBpbiB0ZXJtcyBvZiBgbWV0aG9kTmFtZWAsIGBzdGF0aWNgICh3aGV0aGVyIGFsbCB0aGVcbiAqIGFyZ3VtZW50cyBhcmUgbGl0ZXJhbHMpLCBhbmQgYW4gYXJyYXkgb2YgYGFyZ3NgXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gVGhlIGV4cHJlc3Npb24gdG8gcGFyc2VcbiAqIEByZXR1cm4gez9NZXRob2RTaWduYXR1cmV9IFRoZSBtZXRob2QgbWV0YWRhdGEgb2JqZWN0IGlmIGEgbWV0aG9kIGV4cHJlc3Npb24gd2FzXG4gKiAgIGZvdW5kLCBvdGhlcndpc2UgYHVuZGVmaW5lZGBcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTWV0aG9kKGV4cHJlc3Npb24pIHtcbiAgLy8gdHJpZXMgdG8gbWF0Y2ggdmFsaWQgamF2YXNjcmlwdCBwcm9wZXJ0eSBuYW1lc1xuICBsZXQgbSA9IGV4cHJlc3Npb24ubWF0Y2goLyhbXlxcc10rPylcXCgoW1xcc1xcU10qKVxcKS8pO1xuICBpZiAobSkge1xuICAgIGxldCBtZXRob2ROYW1lID0gbVsxXTtcbiAgICBsZXQgc2lnID0geyBtZXRob2ROYW1lLCBzdGF0aWM6IHRydWUsIGFyZ3M6IGVtcHR5QXJyYXkgfTtcbiAgICBpZiAobVsyXS50cmltKCkpIHtcbiAgICAgIC8vIHJlcGxhY2UgZXNjYXBlZCBjb21tYXMgd2l0aCBjb21tYSBlbnRpdHksIHNwbGl0IG9uIHVuLWVzY2FwZWQgY29tbWFzXG4gICAgICBsZXQgYXJncyA9IG1bMl0ucmVwbGFjZSgvXFxcXCwvZywgJyZjb21tYTsnKS5zcGxpdCgnLCcpO1xuICAgICAgcmV0dXJuIHBhcnNlQXJncyhhcmdzLCBzaWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2lnO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gYXJyYXkgb2YgYXJndW1lbnRzIGFuZCBzZXRzIHRoZSBgYXJnc2AgcHJvcGVydHkgb2YgdGhlIHN1cHBsaWVkXG4gKiBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0LiBTZXRzIHRoZSBgc3RhdGljYCBwcm9wZXJ0eSB0byBmYWxzZSBpZiBhbnlcbiAqIGFyZ3VtZW50IGlzIGEgbm9uLWxpdGVyYWwuXG4gKlxuICogQHBhcmFtIHshQXJyYXk8c3RyaW5nPn0gYXJnTGlzdCBBcnJheSBvZiBhcmd1bWVudCBuYW1lc1xuICogQHBhcmFtIHshTWV0aG9kU2lnbmF0dXJlfSBzaWcgTWV0aG9kIHNpZ25hdHVyZSBtZXRhZGF0YSBvYmplY3RcbiAqIEByZXR1cm4geyFNZXRob2RTaWduYXR1cmV9IFRoZSB1cGRhdGVkIHNpZ25hdHVyZSBtZXRhZGF0YSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXJncyhhcmdMaXN0LCBzaWcpIHtcbiAgc2lnLmFyZ3MgPSBhcmdMaXN0Lm1hcChmdW5jdGlvbihyYXdBcmcpIHtcbiAgICBsZXQgYXJnID0gcGFyc2VBcmcocmF3QXJnKTtcbiAgICBpZiAoIWFyZy5saXRlcmFsKSB7XG4gICAgICBzaWcuc3RhdGljID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBhcmc7XG4gIH0sIHRoaXMpO1xuICByZXR1cm4gc2lnO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBpbmRpdmlkdWFsIGFyZ3VtZW50LCBhbmQgcmV0dXJucyBhbiBhcmd1bWVudCBtZXRhZGF0YSBvYmplY3RcbiAqIHdpdGggdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gKlxuICogICB7XG4gKiAgICAgdmFsdWU6ICdwcm9wJywgICAgICAgIC8vIHByb3BlcnR5L3BhdGggb3IgbGl0ZXJhbCB2YWx1ZVxuICogICAgIGxpdGVyYWw6IGZhbHNlLCAgICAgICAvLyB3aGV0aGVyIGFyZ3VtZW50IGlzIGEgbGl0ZXJhbFxuICogICAgIHN0cnVjdHVyZWQ6IGZhbHNlLCAgICAvLyB3aGV0aGVyIHRoZSBwcm9wZXJ0eSBpcyBhIHBhdGhcbiAqICAgICByb290UHJvcGVydHk6ICdwcm9wJywgLy8gdGhlIHJvb3QgcHJvcGVydHkgb2YgdGhlIHBhdGhcbiAqICAgICB3aWxkY2FyZDogZmFsc2UgICAgICAgLy8gd2hldGhlciB0aGUgYXJndW1lbnQgd2FzIGEgd2lsZGNhcmQgJy4qJyBwYXRoXG4gKiAgIH1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmF3QXJnIFRoZSBzdHJpbmcgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gKiBAcmV0dXJuIHshTWV0aG9kQXJnfSBBcmd1bWVudCBtZXRhZGF0YSBvYmplY3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQXJnKHJhd0FyZykge1xuICAvLyBjbGVhbiB1cCB3aGl0ZXNwYWNlXG4gIGxldCBhcmcgPSByYXdBcmcudHJpbSgpXG4gICAgLy8gcmVwbGFjZSBjb21tYSBlbnRpdHkgd2l0aCBjb21tYVxuICAgIC5yZXBsYWNlKC8mY29tbWE7L2csICcsJylcbiAgICAvLyByZXBhaXIgZXh0cmEgZXNjYXBlIHNlcXVlbmNlczsgbm90ZSBvbmx5IGNvbW1hcyBzdHJpY3RseSBuZWVkXG4gICAgLy8gZXNjYXBpbmcsIGJ1dCB3ZSBhbGxvdyBhbnkgb3RoZXIgY2hhciB0byBiZSBlc2NhcGVkIHNpbmNlIGl0c1xuICAgIC8vIGxpa2VseSB1c2VycyB3aWxsIGRvIHRoaXNcbiAgICAucmVwbGFjZSgvXFxcXCguKS9nLCAnXFwkMScpXG4gICAgO1xuICAvLyBiYXNpYyBhcmd1bWVudCBkZXNjcmlwdG9yXG4gIGxldCBhID0ge1xuICAgIG5hbWU6IGFyZyxcbiAgICB2YWx1ZTogJycsXG4gICAgbGl0ZXJhbDogZmFsc2VcbiAgfTtcbiAgLy8gZGV0ZWN0IGxpdGVyYWwgdmFsdWUgKG11c3QgYmUgU3RyaW5nIG9yIE51bWJlcilcbiAgbGV0IGZjID0gYXJnWzBdO1xuICBpZiAoZmMgPT09ICctJykge1xuICAgIGZjID0gYXJnWzFdO1xuICB9XG4gIGlmIChmYyA+PSAnMCcgJiYgZmMgPD0gJzknKSB7XG4gICAgZmMgPSAnIyc7XG4gIH1cbiAgc3dpdGNoKGZjKSB7XG4gICAgY2FzZSBcIidcIjpcbiAgICBjYXNlICdcIic6XG4gICAgICBhLnZhbHVlID0gYXJnLnNsaWNlKDEsIC0xKTtcbiAgICAgIGEubGl0ZXJhbCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICcjJzpcbiAgICAgIGEudmFsdWUgPSBOdW1iZXIoYXJnKTtcbiAgICAgIGEubGl0ZXJhbCA9IHRydWU7XG4gICAgICBicmVhaztcbiAgfVxuICAvLyBpZiBub3QgbGl0ZXJhbCwgbG9vayBmb3Igc3RydWN0dXJlZCBwYXRoXG4gIGlmICghYS5saXRlcmFsKSB7XG4gICAgYS5yb290UHJvcGVydHkgPSByb290JDAoYXJnKTtcbiAgICAvLyBkZXRlY3Qgc3RydWN0dXJlZCBwYXRoIChoYXMgZG90cylcbiAgICBhLnN0cnVjdHVyZWQgPSBpc1BhdGgkMChhcmcpO1xuICAgIGlmIChhLnN0cnVjdHVyZWQpIHtcbiAgICAgIGEud2lsZGNhcmQgPSAoYXJnLnNsaWNlKC0yKSA9PSAnLionKTtcbiAgICAgIGlmIChhLndpbGRjYXJkKSB7XG4gICAgICAgIGEubmFtZSA9IGFyZy5zbGljZSgwLCAtMik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBhO1xufVxuXG4vKipcbiAqIEdhdGhlciB0aGUgYXJndW1lbnQgdmFsdWVzIGZvciBhIG1ldGhvZCBzcGVjaWZpZWQgaW4gdGhlIHByb3ZpZGVkIGFycmF5XG4gKiBvZiBhcmd1bWVudCBtZXRhZGF0YS5cbiAqXG4gKiBUaGUgYHBhdGhgIGFuZCBgdmFsdWVgIGFyZ3VtZW50cyBhcmUgdXNlZCB0byBmaWxsIGluIHdpbGRjYXJkIGRlc2NyaXB0b3JcbiAqIHdoZW4gdGhlIG1ldGhvZCBpcyBiZWluZyBjYWxsZWQgYXMgYSByZXN1bHQgb2YgYSBwYXRoIG5vdGlmaWNhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YSBJbnN0YW5jZSBkYXRhIHN0b3JhZ2Ugb2JqZWN0IHRvIHJlYWQgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0geyFBcnJheTwhTWV0aG9kQXJnPn0gYXJncyBBcnJheSBvZiBhcmd1bWVudCBtZXRhZGF0YVxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCBuYW1lIHRoYXQgdHJpZ2dlcmVkIHRoZSBtZXRob2QgZWZmZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHJldHVybiB7QXJyYXk8Kj59IEFycmF5IG9mIGFyZ3VtZW50IHZhbHVlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbWFyc2hhbEFyZ3MoZGF0YSwgYXJncywgcGF0aCwgcHJvcHMpIHtcbiAgbGV0IHZhbHVlcyA9IFtdO1xuICBmb3IgKGxldCBpPTAsIGw9YXJncy5sZW5ndGg7IGk8bDsgaSsrKSB7XG4gICAgbGV0IGFyZyA9IGFyZ3NbaV07XG4gICAgbGV0IG5hbWUgPSBhcmcubmFtZTtcbiAgICBsZXQgdjtcbiAgICBpZiAoYXJnLmxpdGVyYWwpIHtcbiAgICAgIHYgPSBhcmcudmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChhcmcuc3RydWN0dXJlZCkge1xuICAgICAgICB2ID0gZ2V0JDAoZGF0YSwgbmFtZSk7XG4gICAgICAgIC8vIHdoZW4gZGF0YSBpcyBub3Qgc3RvcmVkIGUuZy4gYHNwbGljZXNgXG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB2ID0gcHJvcHNbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHYgPSBkYXRhW25hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXJnLndpbGRjYXJkKSB7XG4gICAgICAvLyBPbmx5IHNlbmQgdGhlIGFjdHVhbCBwYXRoIGNoYW5nZWQgaW5mbyBpZiB0aGUgY2hhbmdlIHRoYXRcbiAgICAgIC8vIGNhdXNlZCB0aGUgb2JzZXJ2ZXIgdG8gcnVuIG1hdGNoZWQgdGhlIHdpbGRjYXJkXG4gICAgICBsZXQgYmFzZUNoYW5nZWQgPSAobmFtZS5pbmRleE9mKHBhdGggKyAnLicpID09PSAwKTtcbiAgICAgIGxldCBtYXRjaGVzID0gKHBhdGguaW5kZXhPZihuYW1lKSA9PT0gMCAmJiAhYmFzZUNoYW5nZWQpO1xuICAgICAgdmFsdWVzW2ldID0ge1xuICAgICAgICBwYXRoOiBtYXRjaGVzID8gcGF0aCA6IG5hbWUsXG4gICAgICAgIHZhbHVlOiBtYXRjaGVzID8gcHJvcHNbcGF0aF0gOiB2LFxuICAgICAgICBiYXNlOiB2XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZXNbaV0gPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsdWVzO1xufVxuXG4vLyBkYXRhIGFwaVxuXG4vKipcbiAqIFNlbmRzIGFycmF5IHNwbGljZSBub3RpZmljYXRpb25zIChgLnNwbGljZXNgIGFuZCBgLmxlbmd0aGApXG4gKlxuICogTm90ZTogdGhpcyBpbXBsZW1lbnRhdGlvbiBvbmx5IGFjY2VwdHMgbm9ybWFsaXplZCBwYXRoc1xuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgSW5zdGFuY2UgdG8gc2VuZCBub3RpZmljYXRpb25zIHRvXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdGhlIG11dGF0aW9ucyBvY2N1cnJlZCBvblxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdG8gdGhlIGFycmF5IHRoYXQgd2FzIG11dGF0ZWRcbiAqIEBwYXJhbSB7QXJyYXl9IHNwbGljZXMgQXJyYXkgb2Ygc3BsaWNlIHJlY29yZHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVNwbGljZXMoaW5zdCwgYXJyYXksIHBhdGgsIHNwbGljZXMpIHtcbiAgbGV0IHNwbGljZXNQYXRoID0gcGF0aCArICcuc3BsaWNlcyc7XG4gIGluc3Qubm90aWZ5UGF0aChzcGxpY2VzUGF0aCwgeyBpbmRleFNwbGljZXM6IHNwbGljZXMgfSk7XG4gIGluc3Qubm90aWZ5UGF0aChwYXRoICsgJy5sZW5ndGgnLCBhcnJheS5sZW5ndGgpO1xuICAvLyBOdWxsIGhlcmUgdG8gYWxsb3cgcG90ZW50aWFsbHkgbGFyZ2Ugc3BsaWNlIHJlY29yZHMgdG8gYmUgR0MnZWQuXG4gIGluc3QuX19kYXRhW3NwbGljZXNQYXRoXSA9IHtpbmRleFNwbGljZXM6IG51bGx9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzcGxpY2UgcmVjb3JkIGFuZCBzZW5kcyBhbiBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9uIGZvclxuICogdGhlIGRlc2NyaWJlZCBtdXRhdGlvblxuICpcbiAqIE5vdGU6IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG5vcm1hbGl6ZWQgcGF0aHNcbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRvIHNlbmQgbm90aWZpY2F0aW9ucyB0b1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRoZSBtdXRhdGlvbnMgb2NjdXJyZWQgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdGhlIGFycmF5IG11dGF0aW9uIG9jY3VycmVkXG4gKiBAcGFyYW0ge251bWJlcn0gYWRkZWRDb3VudCBOdW1iZXIgb2YgYWRkZWQgaXRlbXNcbiAqIEBwYXJhbSB7QXJyYXl9IHJlbW92ZWQgQXJyYXkgb2YgcmVtb3ZlZCBpdGVtc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm90aWZ5U3BsaWNlKGluc3QsIGFycmF5LCBwYXRoLCBpbmRleCwgYWRkZWRDb3VudCwgcmVtb3ZlZCkge1xuICBub3RpZnlTcGxpY2VzKGluc3QsIGFycmF5LCBwYXRoLCBbe1xuICAgIGluZGV4OiBpbmRleCxcbiAgICBhZGRlZENvdW50OiBhZGRlZENvdW50LFxuICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgb2JqZWN0OiBhcnJheSxcbiAgICB0eXBlOiAnc3BsaWNlJ1xuICB9XSk7XG59XG5cbi8qKlxuICogUmV0dXJucyBhbiB1cHBlci1jYXNlZCB2ZXJzaW9uIG9mIHRoZSBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgU3RyaW5nIHRvIHVwcGVyY2FzZVxuICogQHJldHVybiB7c3RyaW5nfSBVcHBlcmNhc2VkIHN0cmluZ1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdXBwZXIobmFtZSkge1xuICByZXR1cm4gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG59XG5cbmV4cG9ydCBjb25zdCBQcm9wZXJ0eUVmZmVjdHMgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge3N1cGVyQ2xhc3N9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5QWNjZXNzb3JzfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9UZW1wbGF0ZVN0YW1wfVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjb25zdCBwcm9wZXJ0eUVmZmVjdHNCYXNlID0gVGVtcGxhdGVTdGFtcChQcm9wZXJ0eUFjY2Vzc29ycyhzdXBlckNsYXNzKSk7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAgICogQGV4dGVuZHMge3Byb3BlcnR5RWZmZWN0c0Jhc2V9XG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICovXG4gIGNsYXNzIFByb3BlcnR5RWZmZWN0cyBleHRlbmRzIHByb3BlcnR5RWZmZWN0c0Jhc2Uge1xuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHk7XG4gICAgICAvKiogQHR5cGUge0FycmF5fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeTtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocztcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ29tcG91bmRTdG9yYWdlO1xuICAgICAgLyoqIEB0eXBlIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gKi9cbiAgICAgIHRoaXMuX19kYXRhSG9zdDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhVGVtcDtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGE7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YU9sZDtcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2NvbXB1dGVFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fcmVmbGVjdEVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19ub3RpZnlFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fcHJvcGFnYXRlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX29ic2VydmVFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fcmVhZE9ubHk7XG4gICAgICAvKiogQHR5cGUge251bWJlcn0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ291bnRlcjtcbiAgICAgIC8qKiBAdHlwZSB7IVRlbXBsYXRlSW5mb30gKi9cbiAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgfVxuXG4gICAgZ2V0IFBST1BFUlRZX0VGRkVDVF9UWVBFUygpIHtcbiAgICAgIHJldHVybiBUWVBFUztcbiAgICB9XG5cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICAgIGhvc3RTdGFjay5yZWdpc3Rlckhvc3QodGhpcyk7XG4gICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSA9IGZhbHNlO1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IGZhbHNlO1xuICAgICAgLy8gTWF5IGJlIHNldCBvbiBpbnN0YW5jZSBwcmlvciB0byB1cGdyYWRlXG4gICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSA9IHRoaXMuX19kYXRhQ29tcG91bmRTdG9yYWdlIHx8IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YUhvc3QgPSB0aGlzLl9fZGF0YUhvc3QgfHwgbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIHByb3ZpZGUgYVxuICAgICAqIG1vcmUgZWZmaWNpZW50IGltcGxlbWVudGF0aW9uIG9mIGluaXRpYWxpemluZyBwcm9wZXJ0aWVzIGZyb21cbiAgICAgKiB0aGUgcHJvdG90eXBlIG9uIHRoZSBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBQcm9wZXJ0aWVzIHRvIGluaXRpYWxpemUgb24gdGhlIHByb3RvdHlwZVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplUHJvdG9Qcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICB0aGlzLl9fZGF0YSA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gT2JqZWN0LmNyZWF0ZShwcm9wcyk7XG4gICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AgaW1wbGVtZW50YXRpb24gdG8gYXZvaWQgc2V0dGluZ1xuICAgICAqIGBfc2V0UHJvcGVydHlgJ3MgYHNob3VsZE5vdGlmeTogdHJ1ZWAuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBpbml0aWFsaXplIG9uIHRoZSBpbnN0YW5jZVxuICAgICAqL1xuICAgIF9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICBsZXQgcmVhZE9ubHkgPSB0aGlzW1RZUEVTLlJFQURfT05MWV07XG4gICAgICBmb3IgKGxldCBwcm9wIGluIHByb3BzKSB7XG4gICAgICAgIGlmICghcmVhZE9ubHkgfHwgIXJlYWRPbmx5W3Byb3BdKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nID0gdGhpcy5fX2RhdGFQZW5kaW5nIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0gdGhpcy5fX2RhdGFPbGQgfHwge307XG4gICAgICAgICAgdGhpcy5fX2RhdGFbcHJvcF0gPSB0aGlzLl9fZGF0YVBlbmRpbmdbcHJvcF0gPSBwcm9wc1twcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb3RvdHlwZSBzZXR1cCAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYWRkUHJvcGVydHlFZmZlY3RgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3IocHJvcGVydHksIHR5cGUgPT0gVFlQRVMuUkVBRF9PTkxZKTtcbiAgICAgIC8vIGVmZmVjdHMgYXJlIGFjY3VtdWxhdGVkIGludG8gYXJyYXlzIHBlciBwcm9wZXJ0eSBiYXNlZCBvbiB0eXBlXG4gICAgICBsZXQgZWZmZWN0cyA9IGVuc3VyZU93bkVmZmVjdE1hcCh0aGlzLCB0eXBlKVtwcm9wZXJ0eV07XG4gICAgICBpZiAoIWVmZmVjdHMpIHtcbiAgICAgICAgZWZmZWN0cyA9IHRoaXNbdHlwZV1bcHJvcGVydHldID0gW107XG4gICAgICB9XG4gICAgICBlZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBwcm9wZXJ0eSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhlIGVmZmVjdCB3YXMgYXNzb2NpYXRlZCB3aXRoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0IHRvIHJlbW92ZVxuICAgICAqL1xuICAgIF9yZW1vdmVQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICBsZXQgZWZmZWN0cyA9IGVuc3VyZU93bkVmZmVjdE1hcCh0aGlzLCB0eXBlKVtwcm9wZXJ0eV07XG4gICAgICBsZXQgaWR4ID0gZWZmZWN0cy5pbmRleE9mKGVmZmVjdCk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgZWZmZWN0cy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIHByb3BlcnR5IGVmZmVjdFxuICAgICAqIG9mIGEgY2VydGFpbiB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlKSB7XG4gICAgICBsZXQgZWZmZWN0cyA9IHRoaXNbdHlwZV07XG4gICAgICByZXR1cm4gQm9vbGVhbihlZmZlY3RzICYmIGVmZmVjdHNbcHJvcGVydHldKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwicmVhZCBvbmx5XCJcbiAgICAgKiBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc1JlYWRPbmx5RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcIm5vdGlmeVwiXG4gICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzTm90aWZ5RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLk5PVElGWSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcInJlZmxlY3QgdG8gYXR0cmlidXRlXCJcbiAgICAgKiBwcm9wZXJ0eSBlZmZlY3QgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNSZWZsZWN0RWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFRkxFQ1QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJjb21wdXRlZFwiXG4gICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzQ29tcHV0ZWRFZmZlY3QocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuQ09NUFVURSk7XG4gICAgfVxuXG4gICAgLy8gUnVudGltZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgcGVuZGluZyBwcm9wZXJ0eSBvciBwYXRoLiAgSWYgdGhlIHJvb3QgcHJvcGVydHkgb2YgdGhlIHBhdGggaW5cbiAgICAgKiBxdWVzdGlvbiBoYWQgbm8gYWNjZXNzb3IsIHRoZSBwYXRoIGlzIHNldCwgb3RoZXJ3aXNlIGl0IGlzIGVucXVldWVkXG4gICAgICogdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXNvbGF0ZXMgcmVsYXRpdmVseSBleHBlbnNpdmUgZnVuY3Rpb25hbGl0eSBuZWNlc3NhcnlcbiAgICAgKiBmb3IgdGhlIHB1YmxpYyBBUEkgKGBzZXRgLCBgc2V0UHJvcGVydGllc2AsIGBub3RpZnlQYXRoYCwgYW5kIHByb3BlcnR5XG4gICAgICogY2hhbmdlIGxpc3RlbmVycyB2aWEge3suLi59fSBiaW5kaW5ncyksIHN1Y2ggdGhhdCBpdCBpcyBvbmx5IGRvbmVcbiAgICAgKiB3aGVuIHBhdGhzIGVudGVyIHRoZSBzeXN0ZW0sIGFuZCBub3QgYXQgZXZlcnkgcHJvcGFnYXRpb24gc3RlcC4gIEl0XG4gICAgICogYWxzbyBzZXRzIGEgYF9fZGF0YUhhc1BhdGhzYCBmbGFnIG9uIHRoZSBpbnN0YW5jZSB3aGljaCBpcyB1c2VkIHRvXG4gICAgICogZmFzdC1wYXRoIHNsb3dlciBwYXRoLW1hdGNoaW5nIGNvZGUgaW4gdGhlIHByb3BlcnR5IGVmZmVjdHMgaG9zdCBwYXRocy5cbiAgICAgKlxuICAgICAqIGBwYXRoYCBjYW4gYmUgYSBwYXRoIHN0cmluZyBvciBhcnJheSBvZiBwYXRoIHBhcnRzIGFzIGFjY2VwdGVkIGJ5IHRoZVxuICAgICAqIHB1YmxpYyBBUEkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxudW1iZXJ8c3RyaW5nPn0gcGF0aCBQYXRoIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2V0XG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gc2hvdWxkTm90aWZ5IFNldCB0byB0cnVlIGlmIHRoaXMgY2hhbmdlIHNob3VsZFxuICAgICAqICBjYXVzZSBhIHByb3BlcnR5IG5vdGlmaWNhdGlvbiBldmVudCBkaXNwYXRjaFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGlzUGF0aE5vdGlmaWNhdGlvbiBJZiB0aGUgcGF0aCBiZWluZyBzZXQgaXMgYSBwYXRoXG4gICAgICogICBub3RpZmljYXRpb24gb2YgYW4gYWxyZWFkeSBjaGFuZ2VkIHZhbHVlLCBhcyBvcHBvc2VkIHRvIGEgcmVxdWVzdFxuICAgICAqICAgdG8gc2V0IGFuZCBub3RpZnkgdGhlIGNoYW5nZS4gIEluIHRoZSBsYXR0ZXIgYGZhbHNlYCBjYXNlLCBhIGRpcnR5XG4gICAgICogICBjaGVjayBpcyBwZXJmb3JtZWQgYW5kIHRoZW4gdGhlIHZhbHVlIGlzIHNldCB0byB0aGUgcGF0aCBiZWZvcmVcbiAgICAgKiAgIGVucXVldWluZyB0aGUgcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2UuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eS9wYXRoIHdhcyBlbnF1ZXVlZCBpblxuICAgICAqICAgdGhlIHBlbmRpbmcgY2hhbmdlcyBiYWcuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIHNob3VsZE5vdGlmeSwgaXNQYXRoTm90aWZpY2F0aW9uKSB7XG4gICAgICBpZiAoaXNQYXRoTm90aWZpY2F0aW9uIHx8XG4gICAgICAgICAgcm9vdCQwKEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoWzBdIDogcGF0aCkgIT09IHBhdGgpIHtcbiAgICAgICAgLy8gRGlydHkgY2hlY2sgY2hhbmdlcyBiZWluZyBzZXQgdG8gYSBwYXRoIGFnYWluc3QgdGhlIGFjdHVhbCBvYmplY3QsXG4gICAgICAgIC8vIHNpbmNlIHRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBwYXRocyBpbnRvIHRoZSBzeXN0ZW07IGZyb20gaGVyZVxuICAgICAgICAvLyB0aGUgb25seSBkaXJ0eSBjaGVja3MgYXJlIGFnYWluc3QgdGhlIGBfX2RhdGFUZW1wYCBjYWNoZSB0byBwcmV2ZW50XG4gICAgICAgIC8vIGR1cGxpY2F0ZSB3b3JrIGluIHRoZSBzYW1lIHR1cm4gb25seS4gTm90ZSwgaWYgdGhpcyB3YXMgYSBub3RpZmljYXRpb25cbiAgICAgICAgLy8gb2YgYSBjaGFuZ2UgYWxyZWFkeSBzZXQgdG8gYSBwYXRoIChpc1BhdGhOb3RpZmljYXRpb246IHRydWUpLFxuICAgICAgICAvLyB3ZSBhbHdheXMgbGV0IHRoZSBjaGFuZ2UgdGhyb3VnaCBhbmQgc2tpcCB0aGUgYHNldGAgc2luY2UgaXQgd2FzXG4gICAgICAgIC8vIGFscmVhZHkgZGlydHkgY2hlY2tlZCBhdCB0aGUgcG9pbnQgb2YgZW50cnkgYW5kIHRoZSB1bmRlcmx5aW5nXG4gICAgICAgIC8vIG9iamVjdCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICAgICAgaWYgKCFpc1BhdGhOb3RpZmljYXRpb24pIHtcbiAgICAgICAgICBsZXQgb2xkID0gZ2V0JDAodGhpcywgcGF0aCk7XG4gICAgICAgICAgcGF0aCA9IC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAoc2V0JDAodGhpcywgcGF0aCwgdmFsdWUpKTtcbiAgICAgICAgICAvLyBVc2UgcHJvcGVydHktYWNjZXNzb3IncyBzaW1wbGVyIGRpcnR5IGNoZWNrXG4gICAgICAgICAgaWYgKCFwYXRoIHx8ICFzdXBlci5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocGF0aCwgdmFsdWUsIG9sZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2RhdGFIYXNQYXRocyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoLyoqQHR5cGV7c3RyaW5nfSovKHBhdGgpLCB2YWx1ZSwgc2hvdWxkTm90aWZ5KSkge1xuICAgICAgICAgIGNvbXB1dGVMaW5rZWRQYXRocyh0aGlzLCBwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9fZGF0YUhhc0FjY2Vzc29yICYmIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcGF0aF0pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpc1twYXRoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyBhIHZhbHVlIHRvIGEgbm9uLVBvbHltZXIgZWxlbWVudC9ub2RlJ3MgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gbWFrZXMgYSBiZXN0LWVmZm9ydCBhdCBiaW5kaW5nIGludGVyb3A6XG4gICAgICogU29tZSBuYXRpdmUgZWxlbWVudCBwcm9wZXJ0aWVzIGhhdmUgc2lkZS1lZmZlY3RzIHdoZW5cbiAgICAgKiByZS1zZXR0aW5nIHRoZSBzYW1lIHZhbHVlIChlLmcuIHNldHRpbmcgYDxpbnB1dD4udmFsdWVgIHJlc2V0cyB0aGVcbiAgICAgKiBjdXJzb3IgcG9zaXRpb24pLCBzbyB3ZSBkbyBhIGRpcnR5LWNoZWNrIGJlZm9yZSBzZXR0aW5nIHRoZSB2YWx1ZS5cbiAgICAgKiBIb3dldmVyLCBmb3IgYmV0dGVyIGludGVyb3Agd2l0aCBub24tUG9seW1lciBjdXN0b20gZWxlbWVudHMgdGhhdFxuICAgICAqIGFjY2VwdCBvYmplY3RzLCB3ZSBleHBsaWNpdGx5IHJlLXNldCBvYmplY3QgY2hhbmdlcyBjb21pbmcgZnJvbSB0aGVcbiAgICAgKiBQb2x5bWVyIHdvcmxkICh3aGljaCBtYXkgaW5jbHVkZSBkZWVwIG9iamVjdCBjaGFuZ2VzIHdpdGhvdXQgdGhlXG4gICAgICogdG9wIHJlZmVyZW5jZSBjaGFuZ2luZyksIGVycmluZyBvbiB0aGUgc2lkZSBvZiBwcm92aWRpbmcgbW9yZVxuICAgICAqIGluZm9ybWF0aW9uLlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHByb3ZpZGUgYWx0ZXJuYXRlIGFwcHJvYWNoZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgVGhlIG5vZGUgdG8gc2V0IGEgcHJvcGVydHkgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBUaGUgcHJvcGVydHkgdG8gc2V0XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRVbm1hbmFnZWRQcm9wZXJ0eVRvTm9kZShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgICAgLy8gSXQgaXMgYSBqdWRnbWVudCBjYWxsIHRoYXQgcmVzZXR0aW5nIHByaW1pdGl2ZXMgaXNcbiAgICAgIC8vIFwiYmFkXCIgYW5kIHJlc2V0dGluZ3Mgb2JqZWN0cyBpcyBhbHNvIFwiZ29vZFwiOyBhbHRlcm5hdGl2ZWx5IHdlIGNvdWxkXG4gICAgICAvLyBpbXBsZW1lbnQgYSB3aGl0ZWxpc3Qgb2YgdGFnICYgcHJvcGVydHkgdmFsdWVzIHRoYXQgc2hvdWxkIG5ldmVyXG4gICAgICAvLyBiZSByZXNldCAoZS5nLiA8aW5wdXQ+LnZhbHVlICYmIDxzZWxlY3Q+LnZhbHVlKVxuICAgICAgaWYgKHZhbHVlICE9PSBub2RlW3Byb3BdIHx8IHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICBub2RlW3Byb3BdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIHRoZSBgUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIGludHJvZHVjZSBzcGVjaWFsXG4gICAgICogZGlydHkgY2hlY2sgbG9naWMgZGVwZW5kaW5nIG9uIHRoZSBwcm9wZXJ0eSAmIHZhbHVlIGJlaW5nIHNldDpcbiAgICAgKlxuICAgICAqIDEuIEFueSB2YWx1ZSBzZXQgdG8gYSBwYXRoIChlLmcuICdvYmoucHJvcCc6IDQyIG9yICdvYmoucHJvcCc6IHsuLi59KVxuICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhVGVtcGAsIGRpcnR5IGNoZWNrZWQgYWdhaW5zdCBgX19kYXRhVGVtcGBcbiAgICAgKiAyLiBPYmplY3Qgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IHsuLi59KVxuICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhVGVtcGAgYW5kIGBfX2RhdGFgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3RcbiAgICAgKiAgICBgX19kYXRhVGVtcGAgYnkgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgX3Nob3VsZFByb3BlcnR5Q2hhbmdlYFxuICAgICAqIDMuIFByaW1pdGl2ZSB2YWx1ZSBzZXQgdG8gc2ltcGxlIHByb3BlcnR5IChlLmcuICdwcm9wJzogNDIpXG4gICAgICogICAgU3RvcmVkIGluIGBfX2RhdGFgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YWBcbiAgICAgKlxuICAgICAqIFRoZSBkaXJ0eS1jaGVjayBpcyBpbXBvcnRhbnQgdG8gcHJldmVudCBjeWNsZXMgZHVlIHRvIHR3by13YXlcbiAgICAgKiBub3RpZmljYXRpb24sIGJ1dCBwYXRocyBhbmQgb2JqZWN0cyBhcmUgb25seSBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYW55XG4gICAgICogcHJldmlvdXMgdmFsdWUgc2V0IGR1cmluZyB0aGlzIHR1cm4gdmlhIGEgXCJ0ZW1wb3JhcnkgY2FjaGVcIiB0aGF0IGlzXG4gICAgICogY2xlYXJlZCB3aGVuIHRoZSBsYXN0IGBfcHJvcGVydGllc0NoYWdlZGAgZXhpdHMuIFRoaXMgaXMgc286XG4gICAgICogYS4gYW55IGNhY2hlZCBhcnJheSBwYXRocyAoZS5nLiAnYXJyYXkuMy5wcm9wJykgbWF5IGJlIGludmFsaWRhdGVkXG4gICAgICogICAgZHVlIHRvIGFycmF5IG11dGF0aW9ucyBsaWtlIHNoaWZ0L3Vuc2hpZnQvc3BsaWNlOyB0aGlzIGlzIGZpbmVcbiAgICAgKiAgICBzaW5jZSBwYXRoIGNoYW5nZXMgYXJlIGRpcnR5LWNoZWNrZWQgYXQgdXNlciBlbnRyeSBwb2ludHMgbGlrZSBgc2V0YFxuICAgICAqIGIuIGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIG9ubHkgbGFzdHMgb25lIHR1cm4gdG8gYWxsb3cgdGhlIHVzZXJcbiAgICAgKiAgICB0byBtdXRhdGUgdGhlIG9iamVjdCBpbi1wbGFjZSBhbmQgcmUtc2V0IGl0IHdpdGggdGhlIHNhbWUgaWRlbnRpdHlcbiAgICAgKiAgICBhbmQgaGF2ZSBhbGwgc3ViLXByb3BlcnRpZXMgcmUtcHJvcGFnYXRlZCBpbiBhIHN1YnNlcXVlbnQgdHVybi5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wIGNhY2hlIGlzIG5vdCBuZWNlc3NhcmlseSBzdWZmaWNpZW50IHRvIHByZXZlbnQgaW52YWxpZCBhcnJheVxuICAgICAqIHBhdGhzLCBzaW5jZSBhIHNwbGljZSBjYW4gaGFwcGVuIGR1cmluZyB0aGUgc2FtZSB0dXJuICh3aXRoIHBhdGhvbG9naWNhbFxuICAgICAqIHVzZXIgY29kZSk7IHdlIGNvdWxkIGludHJvZHVjZSBhIFwiZml4dXBcIiBmb3IgdGVtcG9yYXJpbHkgY2FjaGVkIGFycmF5XG4gICAgICogcGF0aHMgaWYgbmVlZGVkOiBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyL2lzc3Vlcy80MjI3XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBUcnVlIGlmIHByb3BlcnR5IHNob3VsZCBmaXJlIG5vdGlmaWNhdGlvblxuICAgICAqICAgZXZlbnQgKGFwcGxpZXMgb25seSBmb3IgYG5vdGlmeTogdHJ1ZWAgcHJvcGVydGllcylcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3BlcnR5IGNoYW5nZWRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSwgc2hvdWxkTm90aWZ5KSB7XG4gICAgICBsZXQgaXNQYXRoID0gdGhpcy5fX2RhdGFIYXNQYXRocyAmJiBpc1BhdGgkMChwcm9wZXJ0eSk7XG4gICAgICBsZXQgcHJldlByb3BzID0gaXNQYXRoID8gdGhpcy5fX2RhdGFUZW1wIDogdGhpcy5fX2RhdGE7XG4gICAgICBpZiAodGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBwcmV2UHJvcHNbcHJvcGVydHldKSkge1xuICAgICAgICBpZiAoIXRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkID0ge307XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIG9sZCBpcyBjYXB0dXJlZCBmcm9tIHRoZSBsYXN0IHR1cm5cbiAgICAgICAgaWYgKCEocHJvcGVydHkgaW4gdGhpcy5fX2RhdGFPbGQpKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFPbGRbcHJvcGVydHldID0gdGhpcy5fX2RhdGFbcHJvcGVydHldO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhdGhzIGFyZSBzdG9yZWQgaW4gdGVtcG9yYXJ5IGNhY2hlIChjbGVhcmVkIGF0IGVuZCBvZiB0dXJuKSxcbiAgICAgICAgLy8gd2hpY2ggaXMgdXNlZCBmb3IgZGlydHktY2hlY2tpbmcsIGFsbCBvdGhlcnMgc3RvcmVkIGluIF9fZGF0YVxuICAgICAgICBpZiAoaXNQYXRoKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFUZW1wW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFsbCBjaGFuZ2VzIGdvIGludG8gcGVuZGluZyBwcm9wZXJ0eSBiYWcsIHBhc3NlZCB0byBfcHJvcGVydGllc0NoYW5nZWRcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICAvLyBUcmFjayBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIG5vdGlmeSBzZXBhcmF0ZWx5XG4gICAgICAgIGlmIChpc1BhdGggfHwgKHRoaXNbVFlQRVMuTk9USUZZXSAmJiB0aGlzW1RZUEVTLk5PVElGWV1bcHJvcGVydHldKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnkgPSB0aGlzLl9fZGF0YVRvTm90aWZ5IHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnlbcHJvcGVydHldID0gc2hvdWxkTm90aWZ5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBiYXNlIGltcGxlbWVudGF0aW9uIHRvIGVuc3VyZSBhbGwgYWNjZXNzb3JzIHNldCBgc2hvdWxkTm90aWZ5YFxuICAgICAqIHRvIHRydWUsIGZvciBwZXItcHJvcGVydHkgbm90aWZpY2F0aW9uIHRyYWNraW5nLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQcm9wZXJ0eUFjY2Vzc29yYCdzIGRlZmF1bHQgYXN5bmMgcXVldWluZyBvZlxuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgOiBpZiBgX19kYXRhUmVhZHlgIGlzIGZhbHNlIChoYXMgbm90IHlldCBiZWVuXG4gICAgICogbWFudWFsbHkgZmx1c2hlZCksIHRoZSBmdW5jdGlvbiBuby1vcHM7IG90aGVyd2lzZSBmbHVzaGVzXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgc3luY2hyb25vdXNseS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9pbnZhbGlkYXRlUHJvcGVydGllcygpIHtcbiAgICAgIGlmICh0aGlzLl9fZGF0YVJlYWR5KSB7XG4gICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVucXVldWVzIHRoZSBnaXZlbiBjbGllbnQgb24gYSBsaXN0IG9mIHBlbmRpbmcgY2xpZW50cywgd2hvc2VcbiAgICAgKiBwZW5kaW5nIHByb3BlcnR5IGNoYW5nZXMgY2FuIGxhdGVyIGJlIGZsdXNoZWQgdmlhIGEgY2FsbCB0b1xuICAgICAqIGBfZmx1c2hDbGllbnRzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjbGllbnQgUHJvcGVydHlFZmZlY3RzIGNsaWVudCB0byBlbnF1ZXVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9lbnF1ZXVlQ2xpZW50KGNsaWVudCkge1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgfHwgW107XG4gICAgICBpZiAoY2xpZW50ICE9PSB0aGlzKSB7XG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMucHVzaChjbGllbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZsdXNoZXMgYW55IGNsaWVudHMgcHJldmlvdXNseSBlbnF1ZXVlZCB2aWEgYF9lbnF1ZXVlQ2xpZW50YCwgY2F1c2luZ1xuICAgICAqIHRoZWlyIGBfZmx1c2hQcm9wZXJ0aWVzYCBtZXRob2QgdG8gcnVuLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9mbHVzaENsaWVudHMoKSB7XG4gICAgICBpZiAoIXRoaXMuX19kYXRhQ2xpZW50c1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVhZHlDbGllbnRzKCk7XG4gICAgICAgIC8vIE92ZXJyaWRlIHBvaW50IHdoZXJlIGFjY2Vzc29ycyBhcmUgdHVybmVkIG9uOyBpbXBvcnRhbnRseSxcbiAgICAgICAgLy8gdGhpcyBpcyBhZnRlciBjbGllbnRzIGhhdmUgZnVsbHkgcmVhZGllZCwgcHJvdmlkaW5nIGEgZ3VhcmFudGVlXG4gICAgICAgIC8vIHRoYXQgYW55IHByb3BlcnR5IGVmZmVjdHMgb2NjdXIgb25seSBhZnRlciBhbGwgY2xpZW50cyBhcmUgcmVhZHkuXG4gICAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2VuYWJsZU9yRmx1c2hDbGllbnRzKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTk9URTogV2UgZW5zdXJlIGNsaWVudHMgZWl0aGVyIGVuYWJsZSBvciBmbHVzaCBhcyBhcHByb3ByaWF0ZS4gVGhpc1xuICAgIC8vIGhhbmRsZXMgdHdvIGNvcm5lciBjYXNlczpcbiAgICAvLyAoMSkgY2xpZW50cyBmbHVzaCBwcm9wZXJseSB3aGVuIGNvbm5lY3RlZC9lbmFibGVkIGJlZm9yZSB0aGUgaG9zdFxuICAgIC8vIGVuYWJsZXM7IGUuZy5cbiAgICAvLyAgIChhKSBUZW1wbGF0aXplIHN0YW1wcyB3aXRoIG5vIHByb3BlcnRpZXMgYW5kIGRvZXMgbm90IGZsdXNoIGFuZFxuICAgIC8vICAgKGIpIHRoZSBpbnN0YW5jZSBpcyBpbnNlcnRlZCBpbnRvIGRvbSBhbmRcbiAgICAvLyAgIChjKSB0aGVuIHRoZSBpbnN0YW5jZSBmbHVzaGVzLlxuICAgIC8vICgyKSBjbGllbnRzIGVuYWJsZSBwcm9wZXJseSB3aGVuIG5vdCBjb25uZWN0ZWQvZW5hYmxlZCB3aGVuIHRoZSBob3N0XG4gICAgLy8gZmx1c2hlczsgZS5nLlxuICAgIC8vICAgKGEpIGEgdGVtcGxhdGUgaXMgcnVudGltZSBzdGFtcGVkIGFuZCBub3QgeWV0IGNvbm5lY3RlZC9lbmFibGVkXG4gICAgLy8gICAoYikgYSBob3N0IHNldHMgYSBwcm9wZXJ0eSwgY2F1c2luZyBzdGFtcGVkIGRvbSB0byBmbHVzaFxuICAgIC8vICAgKGMpIHRoZSBzdGFtcGVkIGRvbSBlbmFibGVzLlxuICAgIF9fZW5hYmxlT3JGbHVzaENsaWVudHMoKSB7XG4gICAgICBsZXQgY2xpZW50cyA9IHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICBpZiAoY2xpZW50cykge1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzID0gbnVsbDtcbiAgICAgICAgZm9yIChsZXQgaT0wOyBpIDwgY2xpZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBjbGllbnQgPSBjbGllbnRzW2ldO1xuICAgICAgICAgIGlmICghY2xpZW50Ll9fZGF0YUVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNsaWVudC5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xpZW50Ll9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICAgIGNsaWVudC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybSBhbnkgaW5pdGlhbCBzZXR1cCBvbiBjbGllbnQgZG9tLiBDYWxsZWQgYmVmb3JlIHRoZSBmaXJzdFxuICAgICAqIGBfZmx1c2hQcm9wZXJ0aWVzYCBjYWxsIG9uIGNsaWVudCBkb20gYW5kIGJlZm9yZSBhbnkgZWxlbWVudFxuICAgICAqIG9ic2VydmVycyBhcmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZWFkeUNsaWVudHMoKSB7XG4gICAgICB0aGlzLl9fZW5hYmxlT3JGbHVzaENsaWVudHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgYmFnIG9mIHByb3BlcnR5IGNoYW5nZXMgdG8gdGhpcyBpbnN0YW5jZSwgYW5kXG4gICAgICogc3luY2hyb25vdXNseSBwcm9jZXNzZXMgYWxsIGVmZmVjdHMgb2YgdGhlIHByb3BlcnRpZXMgYXMgYSBiYXRjaC5cbiAgICAgKlxuICAgICAqIFByb3BlcnR5IG5hbWVzIG11c3QgYmUgc2ltcGxlIHByb3BlcnRpZXMsIG5vdCBwYXRocy4gIEJhdGNoZWRcbiAgICAgKiBwYXRoIHByb3BhZ2F0aW9uIGlzIG5vdCBzdXBwb3J0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIG9uZSBvciBtb3JlIGtleS12YWx1ZSBwYWlycyB3aG9zZSBrZXkgaXNcbiAgICAgKiAgIGEgcHJvcGVydHkgYW5kIHZhbHVlIGlzIHRoZSBuZXcgdmFsdWUgdG8gc2V0IGZvciB0aGF0IHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNldFJlYWRPbmx5IFdoZW4gdHJ1ZSwgYW55IHByaXZhdGUgdmFsdWVzIHNldCBpblxuICAgICAqICAgYHByb3BzYCB3aWxsIGJlIHNldC4gQnkgZGVmYXVsdCwgYHNldFByb3BlcnRpZXNgIHdpbGwgbm90IHNldFxuICAgICAqICAgYHJlYWRPbmx5OiB0cnVlYCByb290IHByb3BlcnRpZXMuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNldFByb3BlcnRpZXMocHJvcHMsIHNldFJlYWRPbmx5KSB7XG4gICAgICBmb3IgKGxldCBwYXRoIGluIHByb3BzKSB7XG4gICAgICAgIGlmIChzZXRSZWFkT25seSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bcGF0aF0pIHtcbiAgICAgICAgICAvL1RPRE8oa3NjaGFhZik6IGV4cGxpY2l0bHkgZGlzYWxsb3cgcGF0aHMgaW4gc2V0UHJvcGVydHk/XG4gICAgICAgICAgLy8gd2lsZGNhcmQgb2JzZXJ2ZXJzIGN1cnJlbnRseSBvbmx5IHBhc3MgdGhlIGZpcnN0IGNoYW5nZWQgcGF0aFxuICAgICAgICAgIC8vIGluIHRoZSBgaW5mb2Agb2JqZWN0LCBhbmQgeW91IGNvdWxkIGRvIHNvbWUgb2RkIHRoaW5ncyBiYXRjaGluZ1xuICAgICAgICAgIC8vIHBhdGhzLCBlLmcuIHsnZm9vLmJhcic6IHsuLi59LCAnZm9vJzogbnVsbH1cbiAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgcHJvcHNbcGF0aF0sIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcnNgIHNvIHRoYXQgcHJvcGVydHkgYWNjZXNzb3JcbiAgICAgKiBzaWRlIGVmZmVjdHMgYXJlIG5vdCBlbmFibGVkIHVudGlsIGFmdGVyIGNsaWVudCBkb20gaXMgZnVsbHkgcmVhZHkuXG4gICAgICogQWxzbyBjYWxscyBgX2ZsdXNoQ2xpZW50c2AgY2FsbGJhY2sgdG8gZW5zdXJlIGNsaWVudCBkb20gaXMgZW5hYmxlZFxuICAgICAqIHRoYXQgd2FzIG5vdCBlbmFibGVkIGFzIGEgcmVzdWx0IG9mIGZsdXNoaW5nIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIC8vIEl0IGlzIGltcG9ydGFudCB0aGF0IGBzdXBlci5yZWFkeSgpYCBpcyBub3QgY2FsbGVkIGhlcmUgYXMgaXRcbiAgICAgIC8vIGltbWVkaWF0ZWx5IHR1cm5zIG9uIGFjY2Vzc29ycy4gSW5zdGVhZCwgd2Ugd2FpdCB1bnRpbCBgcmVhZHlDbGllbnRzYFxuICAgICAgLy8gdG8gZW5hYmxlIGFjY2Vzc29ycyB0byBwcm92aWRlIGEgZ3VhcmFudGVlIHRoYXQgY2xpZW50cyBhcmUgcmVhZHlcbiAgICAgIC8vIGJlZm9yZSBwcm9jZXNzaW5nIGFueSBhY2Nlc3NvcnMgc2lkZSBlZmZlY3RzLlxuICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICAvLyBJZiBubyBkYXRhIHdhcyBwZW5kaW5nLCBgX2ZsdXNoUHJvcGVydGllc2Agd2lsbCBub3QgYGZsdXNoQ2xpZW50c2BcbiAgICAgIC8vIHNvIGVuc3VyZSB0aGlzIGlzIGRvbmUuXG4gICAgICBpZiAoIXRoaXMuX19kYXRhQ2xpZW50c1JlYWR5KSB7XG4gICAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgfVxuICAgICAgLy8gQmVmb3JlIHJlYWR5LCBjbGllbnQgbm90aWZpY2F0aW9ucyBkbyBub3QgdHJpZ2dlciBfZmx1c2hQcm9wZXJ0aWVzLlxuICAgICAgLy8gVGhlcmVmb3JlIGEgZmx1c2ggaXMgbmVjZXNzYXJ5IGhlcmUgaWYgZGF0YSBoYXMgYmVlbiBzZXQuXG4gICAgICBpZiAodGhpcy5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5QWNjZXNzb3JzYCdzIHByb3BlcnRpZXMgY2hhbmdlZCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIFJ1bnMgZWFjaCBjbGFzcyBvZiBlZmZlY3RzIGZvciB0aGUgYmF0Y2ggb2YgY2hhbmdlZCBwcm9wZXJ0aWVzIGluXG4gICAgICogYSBzcGVjaWZpYyBvcmRlciAoY29tcHV0ZSwgcHJvcGFnYXRlLCByZWZsZWN0LCBvYnNlcnZlLCBub3RpZnkpLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3Byb3BlcnRpZXNDaGFuZ2VkKGN1cnJlbnRQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcykge1xuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gbGV0IGMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjaGFuZ2VkUHJvcHMgfHwge30pO1xuICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXAodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgLy8gaWYgKHdpbmRvdy5kZWJ1ZykgeyBkZWJ1Z2dlcjsgfVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgbGV0IGhhc1BhdGhzID0gdGhpcy5fX2RhdGFIYXNQYXRocztcbiAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSBmYWxzZTtcbiAgICAgIC8vIENvbXB1dGUgcHJvcGVydGllc1xuICAgICAgcnVuQ29tcHV0ZWRFZmZlY3RzKHRoaXMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIC8vIENsZWFyIG5vdGlmeSBwcm9wZXJ0aWVzIHByaW9yIHRvIHBvc3NpYmxlIHJlZW50cnkgKHByb3BhZ2F0ZSwgb2JzZXJ2ZSksXG4gICAgICAvLyBidXQgYWZ0ZXIgY29tcHV0aW5nIGVmZmVjdHMgaGF2ZSBhIGNoYW5jZSB0byBhZGQgdG8gdGhlbVxuICAgICAgbGV0IG5vdGlmeVByb3BzID0gdGhpcy5fX2RhdGFUb05vdGlmeTtcbiAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnkgPSBudWxsO1xuICAgICAgLy8gUHJvcGFnYXRlIHByb3BlcnRpZXMgdG8gY2xpZW50c1xuICAgICAgdGhpcy5fcHJvcGFnYXRlUHJvcGVydHlDaGFuZ2VzKGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIC8vIEZsdXNoIGNsaWVudHNcbiAgICAgIHRoaXMuX2ZsdXNoQ2xpZW50cygpO1xuICAgICAgLy8gUmVmbGVjdCBwcm9wZXJ0aWVzXG4gICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuUkVGTEVDVF0sIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIC8vIE9ic2VydmUgcHJvcGVydGllc1xuICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLk9CU0VSVkVdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBOb3RpZnkgcHJvcGVydGllcyB0byBob3N0XG4gICAgICBpZiAobm90aWZ5UHJvcHMpIHtcbiAgICAgICAgcnVuTm90aWZ5RWZmZWN0cyh0aGlzLCBub3RpZnlQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgfVxuICAgICAgLy8gQ2xlYXIgdGVtcG9yYXJ5IGNhY2hlIGF0IGVuZCBvZiB0dXJuXG4gICAgICBpZiAodGhpcy5fX2RhdGFDb3VudGVyID09IDEpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFUZW1wID0ge307XG4gICAgICB9XG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAvLyB3aW5kb3cuZGVidWcgJiYgY29uc29sZS5ncm91cEVuZCh0aGlzLmxvY2FsTmFtZSArICcjJyArIHRoaXMuaWQgKyAnOiAnICsgYyk7XG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHRvIHByb3BhZ2F0ZSBhbnkgcHJvcGVydHkgY2hhbmdlcyB0byBzdGFtcGVkIHRlbXBsYXRlIG5vZGVzXG4gICAgICogbWFuYWdlZCBieSB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2hhbmdlZFByb3BzIEJhZyBvZiBjaGFuZ2VkIHByb3BlcnRpZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcHJvcGFnYXRlUHJvcGVydHlDaGFuZ2VzKGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICBpZiAodGhpc1tUWVBFUy5QUk9QQUdBVEVdKSB7XG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5QUk9QQUdBVEVdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICB9XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5fX3RlbXBsYXRlSW5mbztcbiAgICAgIHdoaWxlICh0ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLFxuICAgICAgICAgIGhhc1BhdGhzLCB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QpO1xuICAgICAgICB0ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBbGlhc2VzIG9uZSBkYXRhIHBhdGggYXMgYW5vdGhlciwgc3VjaCB0aGF0IHBhdGggbm90aWZpY2F0aW9ucyBmcm9tIG9uZVxuICAgICAqIGFyZSByb3V0ZWQgdG8gdGhlIG90aGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHRvIFRhcmdldCBwYXRoIHRvIGxpbmsuXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IGZyb20gU291cmNlIHBhdGggdG8gbGluay5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgbGlua1BhdGhzKHRvLCBmcm9tKSB7XG4gICAgICB0byA9IG5vcm1hbGl6ZSh0byk7XG4gICAgICBmcm9tID0gbm9ybWFsaXplKGZyb20pO1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IHRoaXMuX19kYXRhTGlua2VkUGF0aHMgfHwge307XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzW3RvXSA9IGZyb207XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGRhdGEgcGF0aCBhbGlhcyBwcmV2aW91c2x5IGVzdGFibGlzaGVkIHdpdGggYF9saW5rUGF0aHNgLlxuICAgICAqXG4gICAgICogTm90ZSwgdGhlIHBhdGggdG8gdW5saW5rIHNob3VsZCBiZSB0aGUgdGFyZ2V0IChgdG9gKSB1c2VkIHdoZW5cbiAgICAgKiBsaW5raW5nIHRoZSBwYXRocy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFRhcmdldCBwYXRoIHRvIHVubGluay5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdW5saW5rUGF0aHMocGF0aCkge1xuICAgICAgcGF0aCA9IG5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIGlmICh0aGlzLl9fZGF0YUxpbmtlZFBhdGhzKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzW3BhdGhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdGlmeSB0aGF0IGFuIGFycmF5IGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICB0aGlzLml0ZW1zID0gWyB7bmFtZTogJ0ppbSd9LCB7bmFtZTogJ1RvZGQnfSwge25hbWU6ICdCaWxsJ30gXTtcbiAgICAgKiAgICAgLi4uXG4gICAgICogICAgIHRoaXMuaXRlbXMuc3BsaWNlKDEsIDEsIHtuYW1lOiAnU2FtJ30pO1xuICAgICAqICAgICB0aGlzLml0ZW1zLnB1c2goe25hbWU6ICdCb2InfSk7XG4gICAgICogICAgIHRoaXMubm90aWZ5U3BsaWNlcygnaXRlbXMnLCBbXG4gICAgICogICAgICAgeyBpbmRleDogMSwgcmVtb3ZlZDogW3tuYW1lOiAnVG9kZCd9XSwgYWRkZWRDb3VudDogMSwgb2JlY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnIH0sXG4gICAgICogICAgICAgeyBpbmRleDogMywgcmVtb3ZlZDogW10sIGFkZGVkQ291bnQ6IDEsIG9iamVjdDogdGhpcy5pdGVtcywgdHlwZTogJ3NwbGljZSd9XG4gICAgICogICAgIF0pO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0aGF0IHNob3VsZCBiZSBub3RpZmllZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzIGluZGljYXRpbmcgb3JkZXJlZFxuICAgICAqICAgY2hhbmdlcyB0aGF0IG9jY3VycmVkIHRvIHRoZSBhcnJheS4gRWFjaCByZWNvcmQgc2hvdWxkIGhhdmUgdGhlXG4gICAgICogICBmb2xsb3dpbmcgZmllbGRzOlxuICAgICAqICAgICogaW5kZXg6IGluZGV4IGF0IHdoaWNoIHRoZSBjaGFuZ2Ugb2NjdXJyZWRcbiAgICAgKiAgICAqIHJlbW92ZWQ6IGFycmF5IG9mIGl0ZW1zIHRoYXQgd2VyZSByZW1vdmVkIGZyb20gdGhpcyBpbmRleFxuICAgICAqICAgICogYWRkZWRDb3VudDogbnVtYmVyIG9mIG5ldyBpdGVtcyBhZGRlZCBhdCB0aGlzIGluZGV4XG4gICAgICogICAgKiBvYmplY3Q6IGEgcmVmZXJlbmNlIHRvIHRoZSBhcnJheSBpbiBxdWVzdGlvblxuICAgICAqICAgICogdHlwZTogdGhlIHN0cmluZyBsaXRlcmFsICdzcGxpY2UnXG4gICAgICpcbiAgICAgKiAgIE5vdGUgdGhhdCBzcGxpY2UgcmVjb3JkcyBfbXVzdF8gYmUgbm9ybWFsaXplZCBzdWNoIHRoYXQgdGhleSBhcmVcbiAgICAgKiAgIHJlcG9ydGVkIGluIGluZGV4IG9yZGVyIChyYXcgcmVzdWx0cyBmcm9tIGBPYmplY3Qub2JzZXJ2ZWAgYXJlIG5vdFxuICAgICAqICAgb3JkZXJlZCBhbmQgbXVzdCBiZSBub3JtYWxpemVkL21lcmdlZCBiZWZvcmUgbm90aWZ5aW5nKS5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBub3RpZnlTcGxpY2VzKHBhdGgsIHNwbGljZXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIG5vdGlmeVNwbGljZXModGhpcywgYXJyYXksIGluZm8ucGF0aCwgc3BsaWNlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciByZWFkaW5nIGEgdmFsdWUgZnJvbSBhIHBhdGguXG4gICAgICpcbiAgICAgKiBOb3RlLCBpZiBhbnkgcGFydCBpbiB0aGUgcGF0aCBpcyB1bmRlZmluZWQsIHRoaXMgbWV0aG9kIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCAodGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgd2hlbiBkZXJlZmVyZW5jaW5nIHVuZGVmaW5lZFxuICAgICAqIHBhdGhzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3whQXJyYXk8KHN0cmluZ3xudW1iZXIpPil9IHBhdGggUGF0aCB0byB0aGUgdmFsdWVcbiAgICAgKiAgIHRvIHJlYWQuICBUaGUgcGF0aCBtYXkgYmUgc3BlY2lmaWVkIGFzIGEgc3RyaW5nIChlLmcuIGBmb28uYmFyLmJhemApXG4gICAgICogICBvciBhbiBhcnJheSBvZiBwYXRoIHBhcnRzIChlLmcuIGBbJ2Zvby5iYXInLCAnYmF6J11gKS4gIE5vdGUgdGhhdFxuICAgICAqICAgYnJhY2tldGVkIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkOyBzdHJpbmctYmFzZWQgcGF0aCBwYXJ0c1xuICAgICAqICAgKm11c3QqIGJlIHNlcGFyYXRlZCBieSBkb3RzLiAgTm90ZSB0aGF0IHdoZW4gZGVyZWZlcmVuY2luZyBhcnJheVxuICAgICAqICAgaW5kaWNlcywgdGhlIGluZGV4IG1heSBiZSB1c2VkIGFzIGEgZG90dGVkIHBhcnQgZGlyZWN0bHlcbiAgICAgKiAgIChlLmcuIGB1c2Vycy4xMi5uYW1lYCBvciBgWyd1c2VycycsIDEyLCAnbmFtZSddYCkuXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSByb290IFJvb3Qgb2JqZWN0IGZyb20gd2hpY2ggdGhlIHBhdGggaXMgZXZhbHVhdGVkLlxuICAgICAqIEByZXR1cm4geyp9IFZhbHVlIGF0IHRoZSBwYXRoLCBvciBgdW5kZWZpbmVkYCBpZiBhbnkgcGFydCBvZiB0aGUgcGF0aFxuICAgICAqICAgaXMgdW5kZWZpbmVkLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQocGF0aCwgcm9vdCkge1xuICAgICAgcmV0dXJuIGdldCQwKHJvb3QgfHwgdGhpcywgcGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBzZXR0aW5nIGEgdmFsdWUgdG8gYSBwYXRoIGFuZCBub3RpZnlpbmcgYW55XG4gICAgICogZWxlbWVudHMgYm91bmQgdG8gdGhlIHNhbWUgcGF0aC5cbiAgICAgKlxuICAgICAqIE5vdGUsIGlmIGFueSBwYXJ0IGluIHRoZSBwYXRoIGV4Y2VwdCBmb3IgdGhlIGxhc3QgaXMgdW5kZWZpbmVkLFxuICAgICAqIHRoaXMgbWV0aG9kIGRvZXMgbm90aGluZyAodGhpcyBtZXRob2QgZG9lcyBub3QgdGhyb3cgd2hlblxuICAgICAqIGRlcmVmZXJlbmNpbmcgdW5kZWZpbmVkIHBhdGhzKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KHN0cmluZ3whQXJyYXk8KHN0cmluZ3xudW1iZXIpPil9IHBhdGggUGF0aCB0byB0aGUgdmFsdWVcbiAgICAgKiAgIHRvIHdyaXRlLiAgVGhlIHBhdGggbWF5IGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZS5nLiBgJ2Zvby5iYXIuYmF6J2ApXG4gICAgICogICBvciBhbiBhcnJheSBvZiBwYXRoIHBhcnRzIChlLmcuIGBbJ2Zvby5iYXInLCAnYmF6J11gKS4gIE5vdGUgdGhhdFxuICAgICAqICAgYnJhY2tldGVkIGV4cHJlc3Npb25zIGFyZSBub3Qgc3VwcG9ydGVkOyBzdHJpbmctYmFzZWQgcGF0aCBwYXJ0c1xuICAgICAqICAgKm11c3QqIGJlIHNlcGFyYXRlZCBieSBkb3RzLiAgTm90ZSB0aGF0IHdoZW4gZGVyZWZlcmVuY2luZyBhcnJheVxuICAgICAqICAgaW5kaWNlcywgdGhlIGluZGV4IG1heSBiZSB1c2VkIGFzIGEgZG90dGVkIHBhcnQgZGlyZWN0bHlcbiAgICAgKiAgIChlLmcuIGAndXNlcnMuMTIubmFtZSdgIG9yIGBbJ3VzZXJzJywgMTIsICduYW1lJ11gKS5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSByb290IFJvb3Qgb2JqZWN0IGZyb20gd2hpY2ggdGhlIHBhdGggaXMgZXZhbHVhdGVkLlxuICAgICAqICAgV2hlbiBzcGVjaWZpZWQsIG5vIG5vdGlmaWNhdGlvbiB3aWxsIG9jY3VyLlxuICAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIHNldChwYXRoLCB2YWx1ZSwgcm9vdCkge1xuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgc2V0JDAocm9vdCwgcGF0aCwgdmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzW1RZUEVTLlJFQURfT05MWV0gfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXVsvKiogQHR5cGUge3N0cmluZ30gKi8ocGF0aCldKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBpdGVtcyBvbnRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucHVzaGAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcGFyYW0gey4uLip9IGl0ZW1zIEl0ZW1zIHRvIHB1c2ggb250byBhcnJheVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHB1c2gocGF0aCwgLi4uaXRlbXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9Ki8oZ2V0JDAodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IGxlbiA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGxldCByZXQgPSBhcnJheS5wdXNoKC4uLml0ZW1zKTtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIGxlbiwgaXRlbXMubGVuZ3RoLCBbXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBlbmQgb2YgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5wb3BgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHJldHVybiB7Kn0gSXRlbSB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwb3AocGF0aCkge1xuICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oZ2V0JDAodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgIGxldCByZXQgPSBhcnJheS5wb3AoKTtcbiAgICAgIGlmIChoYWRMZW5ndGgpIHtcbiAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIGFycmF5Lmxlbmd0aCwgMCwgW3JldF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFydGluZyBmcm9tIHRoZSBzdGFydCBpbmRleCBzcGVjaWZpZWQsIHJlbW92ZXMgMCBvciBtb3JlIGl0ZW1zXG4gICAgICogZnJvbSB0aGUgYXJyYXkgYW5kIGluc2VydHMgMCBvciBtb3JlIG5ldyBpdGVtcyBpbiB0aGVpciBwbGFjZS5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCBJbmRleCBmcm9tIHdoaWNoIHRvIHN0YXJ0IHJlbW92aW5nL2luc2VydGluZy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsZXRlQ291bnQgTnVtYmVyIG9mIGl0ZW1zIHRvIHJlbW92ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IGl0ZW1zIEl0ZW1zIHRvIGluc2VydCBpbnRvIGFycmF5LlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBvZiByZW1vdmVkIGl0ZW1zLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzcGxpY2UocGF0aCwgc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pdGVtcykge1xuICAgICAgbGV0IGluZm8gPSB7cGF0aCA6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIC8vIE5vcm1hbGl6ZSBmYW5jeSBuYXRpdmUgc3BsaWNlIGhhbmRsaW5nIG9mIGNyYXp5IHN0YXJ0IHZhbHVlc1xuICAgICAgaWYgKHN0YXJ0IDwgMCkge1xuICAgICAgICBzdGFydCA9IGFycmF5Lmxlbmd0aCAtIE1hdGguZmxvb3IoLXN0YXJ0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0ID0gTWF0aC5mbG9vcihzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgIH1cbiAgICAgIGxldCByZXQgPSBhcnJheS5zcGxpY2Uoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoIHx8IHJldC5sZW5ndGgpIHtcbiAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHN0YXJ0LCBpdGVtcy5sZW5ndGgsIHJldCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5wb3BgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHJldHVybiB7Kn0gSXRlbSB0aGF0IHdhcyByZW1vdmVkLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzaGlmdChwYXRoKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgaGFkTGVuZ3RoID0gQm9vbGVhbihhcnJheS5sZW5ndGgpO1xuICAgICAgbGV0IHJldCA9IGFycmF5LnNoaWZ0KCk7XG4gICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCAwLCBbcmV0XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgaXRlbXMgb250byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnB1c2hgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW5mbyBhcnJheVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gTmV3IGxlbmd0aCBvZiB0aGUgYXJyYXkuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVuc2hpZnQocGF0aCwgLi4uaXRlbXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCByZXQgPSBhcnJheS51bnNoaWZ0KC4uLml0ZW1zKTtcbiAgICAgIGlmIChpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgbm90aWZ5U3BsaWNlKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIDAsIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgdGhhdCBhIHBhdGggaGFzIGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIHRoaXMuaXRlbS51c2VyLm5hbWUgPSAnQm9iJztcbiAgICAgKiAgICAgdGhpcy5ub3RpZnlQYXRoKCdpdGVtLnVzZXIubmFtZScpO1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUGF0aCB0aGF0IHNob3VsZCBiZSBub3RpZmllZC5cbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBWYWx1ZSBhdCB0aGUgcGF0aCAob3B0aW9uYWwpLlxuICAgICAqIEBwdWJsaWNcbiAgICAqL1xuICAgIG5vdGlmeVBhdGgocGF0aCwgdmFsdWUpIHtcbiAgICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgICAgbGV0IHByb3BQYXRoO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICAvLyBHZXQgdmFsdWUgaWYgbm90IHN1cHBsaWVkXG4gICAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgICAgdmFsdWUgPSBnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKTtcbiAgICAgICAgcHJvcFBhdGggPSBpbmZvLnBhdGg7XG4gICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICAgICAgLy8gTm9ybWFsaXplIHBhdGggaWYgbmVlZGVkXG4gICAgICAgIHByb3BQYXRoID0gbm9ybWFsaXplKHBhdGgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcFBhdGggPSAvKiogQHR5cGV7c3RyaW5nfSAqLyhwYXRoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocHJvcFBhdGgsIHZhbHVlLCB0cnVlLCB0cnVlKSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWFkT25seVByb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHByb3RlY3RlZFNldHRlciBDcmVhdGVzIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXJcbiAgICAgKiAgIHdoZW4gYHRydWVgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eShwcm9wZXJ0eSwgcHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVBRF9PTkxZKTtcbiAgICAgIGlmIChwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgICAgdGhpc1snX3NldCcgKyB1cHBlcihwcm9wZXJ0eSldID0gLyoqIEB0aGlzIHtQcm9wZXJ0eUVmZmVjdHN9ICovZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVQcm9wZXJ0eU9ic2VydmVyYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICogICBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbikge1xuICAgICAgbGV0IGluZm8gPSB7IHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm46IEJvb2xlYW4oZHluYW1pY0ZuKSB9O1xuICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgZm46IHJ1bk9ic2VydmVyRWZmZWN0LCBpbmZvLCB0cmlnZ2VyOiB7bmFtZTogcHJvcGVydHl9XG4gICAgICB9KTtcbiAgICAgIGlmIChkeW5hbWljRm4pIHtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QobWV0aG9kTmFtZSwgVFlQRVMuT0JTRVJWRSwge1xuICAgICAgICAgIGZuOiBydW5PYnNlcnZlckVmZmVjdCwgaW5mbywgdHJpZ2dlcjoge25hbWU6IG1ldGhvZE5hbWV9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVNZXRob2RPYnNlcnZlcmAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWV0aG9kIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVNZXRob2RPYnNlcnZlcihleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgIGxldCBzaWcgPSBwYXJzZU1ldGhvZChleHByZXNzaW9uKTtcbiAgICAgIGlmICghc2lnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBvYnNlcnZlciBleHByZXNzaW9uICdcIiArIGV4cHJlc3Npb24gKyBcIidcIik7XG4gICAgICB9XG4gICAgICBjcmVhdGVNZXRob2RFZmZlY3QodGhpcywgc2lnLCBUWVBFUy5PQlNFUlZFLCBydW5NZXRob2RFZmZlY3QsIG51bGwsIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlksIHtcbiAgICAgICAgZm46IHJ1bk5vdGlmeUVmZmVjdCxcbiAgICAgICAgaW5mbzoge1xuICAgICAgICAgIGV2ZW50TmFtZTogQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UocHJvcGVydHkpICsgJy1jaGFuZ2VkJyxcbiAgICAgICAgICBwcm9wZXJ0eTogcHJvcGVydHlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZVJlZmxlY3RlZFByb3BlcnR5YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIGxldCBhdHRyID0gQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UocHJvcGVydHkpO1xuICAgICAgaWYgKGF0dHJbMF0gPT09ICctJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Byb3BlcnR5ICcgKyBwcm9wZXJ0eSArICcgY2Fubm90IGJlIHJlZmxlY3RlZCB0byBhdHRyaWJ1dGUgJyArXG4gICAgICAgICAgYXR0ciArICcgYmVjYXVzZSBcIi1cIiBpcyBub3QgYSB2YWxpZCBzdGFydGluZyBhdHRyaWJ1dGUgbmFtZS4gVXNlIGEgbG93ZXJjYXNlIGZpcnN0IGxldHRlciBmb3IgdGhlIHByb3BlcnR5IHRoaXNlYWQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuUkVGTEVDVCwge1xuICAgICAgICAgIGZuOiBydW5SZWZsZWN0RWZmZWN0LFxuICAgICAgICAgIGluZm86IHtcbiAgICAgICAgICAgIGF0dHJOYW1lOiBhdHRyXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgY29tcHV0ZWQgcHJvcGVydHkgdG8gc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWV0aG9kIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nXG4gICAgICogICB3aGV0aGVyIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVDb21wdXRlZFByb3BlcnR5KHByb3BlcnR5LCBleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgIGxldCBzaWcgPSBwYXJzZU1ldGhvZChleHByZXNzaW9uKTtcbiAgICAgIGlmICghc2lnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hbGZvcm1lZCBjb21wdXRlZCBleHByZXNzaW9uICdcIiArIGV4cHJlc3Npb24gKyBcIidcIik7XG4gICAgICB9XG4gICAgICBjcmVhdGVNZXRob2RFZmZlY3QodGhpcywgc2lnLCBUWVBFUy5DT01QVVRFLCBydW5Db21wdXRlZEVmZmVjdCwgcHJvcGVydHksIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLy8gLS0gc3RhdGljIGNsYXNzIG1ldGhvZHMgLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIGFuIGFjY2Vzc29yIGV4aXN0cyBmb3IgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSwgYW5kIGFkZHNcbiAgICAgKiB0byBhIGxpc3Qgb2YgXCJwcm9wZXJ0eSBlZmZlY3RzXCIgdGhhdCB3aWxsIHJ1biB3aGVuIHRoZSBhY2Nlc3NvciBmb3JcbiAgICAgKiB0aGUgc3BlY2lmaWVkIHByb3BlcnR5IGlzIHNldC4gIEVmZmVjdHMgYXJlIGdyb3VwZWQgYnkgXCJ0eXBlXCIsIHdoaWNoXG4gICAgICogcm91Z2hseSBjb3JyZXNwb25kcyB0byBhIHBoYXNlIGluIGVmZmVjdCBwcm9jZXNzaW5nLiAgVGhlIGVmZmVjdFxuICAgICAqIG1ldGFkYXRhIHNob3VsZCBiZSBpbiB0aGUgZm9sbG93aW5nIGZvcm06XG4gICAgICpcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgIGZuOiBlZmZlY3RGdW5jdGlvbiwgLy8gUmVmZXJlbmNlIHRvIGZ1bmN0aW9uIHRvIGNhbGwgdG8gcGVyZm9ybSBlZmZlY3RcbiAgICAgKiAgICAgICBpbmZvOiB7IC4uLiB9ICAgICAgIC8vIEVmZmVjdCBtZXRhZGF0YSBwYXNzZWQgdG8gZnVuY3Rpb25cbiAgICAgKiAgICAgICB0cmlnZ2VyOiB7ICAgICAgICAgIC8vIE9wdGlvbmFsIHRyaWdnZXJpbmcgbWV0YWRhdGE7IGlmIG5vdCBwcm92aWRlZFxuICAgICAqICAgICAgICAgbmFtZTogc3RyaW5nICAgICAgLy8gdGhlIHByb3BlcnR5IGlzIHRyZWF0ZWQgYXMgYSB3aWxkY2FyZFxuICAgICAqICAgICAgICAgc3RydWN0dXJlZDogYm9vbGVhblxuICAgICAqICAgICAgICAgd2lsZGNhcmQ6IGJvb2xlYW5cbiAgICAgKiAgICAgICB9XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEVmZmVjdHMgYXJlIGNhbGxlZCBmcm9tIGBfcHJvcGVydGllc0NoYW5nZWRgIGluIHRoZSBmb2xsb3dpbmcgb3JkZXIgYnlcbiAgICAgKiB0eXBlOlxuICAgICAqXG4gICAgICogMS4gQ09NUFVURVxuICAgICAqIDIuIFBST1BBR0FURVxuICAgICAqIDMuIFJFRkxFQ1RcbiAgICAgKiA0LiBPQlNFUlZFXG4gICAgICogNS4gTk9USUZZXG4gICAgICpcbiAgICAgKiBFZmZlY3QgZnVuY3Rpb25zIGFyZSBjYWxsZWQgd2l0aCB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZTpcbiAgICAgKlxuICAgICAqICAgICBlZmZlY3RGdW5jdGlvbihpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzaW5nbGUtcHJvcGVydHkgb2JzZXJ2ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBvYnNlcnZlciBtZXRob2QgdG8gY2FsbFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGR5bmFtaWNGbiBXaGV0aGVyIHRoZSBtZXRob2QgbmFtZSBzaG91bGQgYmUgaW5jbHVkZWQgYXNcbiAgICAgKiAgIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUHJvcGVydHlPYnNlcnZlcihwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuKSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUHJvcGVydHlPYnNlcnZlcihwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbXVsdGktcHJvcGVydHkgXCJtZXRob2Qgb2JzZXJ2ZXJcIiBiYXNlZCBvbiB0aGUgcHJvdmlkZWRcbiAgICAgKiBleHByZXNzaW9uLCB3aGljaCBzaG91bGQgYmUgYSBzdHJpbmcgaW4gdGhlIGZvcm0gb2YgYSBub3JtYWwgSmF2YXNjcmlwdFxuICAgICAqIGZ1bmN0aW9uIHNpZ25hdHVyZTogYCdtZXRob2ROYW1lKGFyZzEsIFsuLi4sIGFyZ25dKSdgLiAgRWFjaCBhcmd1bWVudFxuICAgICAqIHNob3VsZCBjb3JyZXNwb25kIHRvIGEgcHJvcGVydHkgb3IgcGF0aCBpbiB0aGUgY29udGV4dCBvZiB0aGlzXG4gICAgICogcHJvdG90eXBlIChvciBpbnN0YW5jZSksIG9yIG1heSBiZSBhIGxpdGVyYWwgc3RyaW5nIG9yIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXVzZXMgdGhlIHNldHRlciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5IHRvIGRpc3BhdGNoIGA8cHJvcGVydHk+LWNoYW5nZWRgXG4gICAgICogZXZlbnRzIHRvIG5vdGlmeSBvZiBjaGFuZ2VzIHRvIHRoZSBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgcmVhZC1vbmx5IGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUbyBzZXQgdGhlIHByb3BlcnR5LCB1c2UgdGhlIHByb3RlY3RlZCBgX3NldFByb3BlcnR5YCBBUEkuXG4gICAgICogVG8gY3JlYXRlIGEgY3VzdG9tIHByb3RlY3RlZCBzZXR0ZXIgKGUuZy4gYF9zZXRNeVByb3AoKWAgZm9yXG4gICAgICogcHJvcGVydHkgYG15UHJvcGApLCBwYXNzIGB0cnVlYCBmb3IgYHByb3RlY3RlZFNldHRlcmAuXG4gICAgICpcbiAgICAgKiBOb3RlLCBpZiB0aGUgcHJvcGVydHkgd2lsbCBoYXZlIG90aGVyIHByb3BlcnR5IGVmZmVjdHMsIHRoaXMgbWV0aG9kXG4gICAgICogc2hvdWxkIGJlIGNhbGxlZCBmaXJzdCwgYmVmb3JlIGFkZGluZyBvdGhlciBlZmZlY3RzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwcm90ZWN0ZWRTZXR0ZXIgQ3JlYXRlcyBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyXG4gICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byByZWZsZWN0IHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIHRvIGEgKGRhc2gtY2FzZWQpIGF0dHJpYnV0ZSBvZiB0aGUgc2FtZSBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkocHJvcGVydHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21wdXRlZCBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHJlc3VsdCBvZiB0aGVcbiAgICAgKiBtZXRob2QgZGVzY3JpYmVkIGJ5IHRoZSBnaXZlbiBgZXhwcmVzc2lvbmAgZWFjaCB0aW1lIG9uZSBvciBtb3JlXG4gICAgICogYXJndW1lbnRzIHRvIHRoZSBtZXRob2QgY2hhbmdlcy4gIFRoZSBleHByZXNzaW9uIHNob3VsZCBiZSBhIHN0cmluZ1xuICAgICAqIGluIHRoZSBmb3JtIG9mIGEgbm9ybWFsIEphdmFzY3JpcHQgZnVuY3Rpb24gc2lnbmF0dXJlOlxuICAgICAqIGAnbWV0aG9kTmFtZShhcmcxLCBbLi4uLCBhcmduXSknYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgY29tcHV0ZWQgcHJvcGVydHkgdG8gc2V0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV4cHJlc3Npb24gTWV0aG9kIGV4cHJlc3Npb25cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW58T2JqZWN0PX0gZHluYW1pY0ZuIEJvb2xlYW4gb3Igb2JqZWN0IG1hcCBpbmRpY2F0aW5nIHdoZXRoZXJcbiAgICAgKiAgIG1ldGhvZCBuYW1lcyBzaG91bGQgYmUgaW5jbHVkZWQgYXMgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVDb21wdXRlZFByb3BlcnR5KHByb3BlcnR5LCBleHByZXNzaW9uLCBkeW5hbWljRm4pIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVDb21wdXRlZFByb3BlcnR5KHByb3BlcnR5LCBleHByZXNzaW9uLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgdG8gZW5zdXJlIGJpbmRpbmcgZWZmZWN0cyBhcmUgY3JlYXRlZFxuICAgICAqIGZvciB0aGVtLCBhbmQgdGhlbiBlbnN1cmVzIHByb3BlcnR5IGFjY2Vzc29ycyBhcmUgY3JlYXRlZCBmb3IgYW55XG4gICAgICogZGVwZW5kZW50IHByb3BlcnRpZXMgaW4gdGhlIHRlbXBsYXRlLiAgQmluZGluZyBlZmZlY3RzIGZvciBib3VuZFxuICAgICAqIHRlbXBsYXRlcyBhcmUgc3RvcmVkIGluIGEgbGlua2VkIGxpc3Qgb24gdGhlIGluc3RhbmNlIHNvIHRoYXRcbiAgICAgKiB0ZW1wbGF0ZXMgY2FuIGJlIGVmZmljaWVudGx5IHN0YW1wZWQgYW5kIHVuc3RhbXBlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgY29udGFpbmluZyBiaW5kaW5nXG4gICAgICogICBiaW5kaW5nc1xuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBiaW5kVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3RvdHlwZS5fYmluZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICB9XG5cbiAgICAvLyAtLSBiaW5kaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBiaW5kVGVtcGxhdGVgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgb24gdGhlIHByb3RvdHlwZSAoZm9yIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZVxuICAgICAqIGJpbmRpbmcsIHRvIGF2b2lkIGNyZWF0aW5nIGFjY2Vzc29ycyBldmVyeSBpbnN0YW5jZSkgb25jZSBwZXIgcHJvdG90eXBlLFxuICAgICAqIGFuZCB3aWxsIGJlIGNhbGxlZCB3aXRoIGBydW50aW1lQmluZGluZzogdHJ1ZWAgYnkgYF9zdGFtcFRlbXBsYXRlYCB0b1xuICAgICAqIGNyZWF0ZSBhbmQgbGluayBhbiBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGUgbWV0YWRhdGEgYXNzb2NpYXRlZCB3aXRoIGFcbiAgICAgKiBwYXJ0aWN1bGFyIHN0YW1waW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSBjb250YWluaW5nIGJpbmRpbmdcbiAgICAgKiAgIGJpbmRpbmdzXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gaW5zdGFuY2VCaW5kaW5nIFdoZW4gZmFsc2UgKGRlZmF1bHQpLCBwZXJmb3Jtc1xuICAgICAqICAgXCJwcm90b3R5cGljYWxcIiBiaW5kaW5nIG9mIHRoZSB0ZW1wbGF0ZSBhbmQgb3ZlcndyaXRlcyBhbnkgcHJldmlvdXNseVxuICAgICAqICAgYm91bmQgdGVtcGxhdGUgZm9yIHRoZSBjbGFzcy4gV2hlbiB0cnVlIChhcyBwYXNzZWQgZnJvbVxuICAgICAqICAgYF9zdGFtcFRlbXBsYXRlYCksIHRoZSB0ZW1wbGF0ZSBpbmZvIGlzIGluc3RhbmNlZCBhbmQgbGlua2VkIGludG9cbiAgICAgKiAgIHRoZSBsaXN0IG9mIGJvdW5kIHRlbXBsYXRlcy5cbiAgICAgKiBAcmV0dXJuIHshVGVtcGxhdGVJbmZvfSBUZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3Q7IGZvciBgcnVudGltZUJpbmRpbmdgLFxuICAgICAqICAgdGhpcyBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgcHJvdG90eXBpY2FsIHRlbXBsYXRlIGluZm9cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgaW5zdGFuY2VCaW5kaW5nKSB7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gdGhpcy5jb25zdHJ1Y3Rvci5fcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICBsZXQgd2FzUHJlQm91bmQgPSB0aGlzLl9fdGVtcGxhdGVJbmZvID09IHRlbXBsYXRlSW5mbztcbiAgICAgIC8vIE9wdGltaXphdGlvbjogc2luY2UgdGhpcyBpcyBjYWxsZWQgdHdpY2UgZm9yIHByb3RvLWJvdW5kIHRlbXBsYXRlcyxcbiAgICAgIC8vIGRvbid0IGF0dGVtcHQgdG8gcmVjcmVhdGUgYWNjZXNzb3JzIGlmIHRoaXMgdGVtcGxhdGUgd2FzIHByZS1ib3VuZFxuICAgICAgaWYgKCF3YXNQcmVCb3VuZCkge1xuICAgICAgICBmb3IgKGxldCBwcm9wIGluIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMpIHtcbiAgICAgICAgICB0aGlzLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5zdGFuY2VCaW5kaW5nKSB7XG4gICAgICAgIC8vIEZvciBpbnN0YW5jZS10aW1lIGJpbmRpbmcsIGNyZWF0ZSBpbnN0YW5jZSBvZiB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAgICAvLyBhbmQgbGluayBpbnRvIGxpc3Qgb2YgdGVtcGxhdGVzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB0ZW1wbGF0ZUluZm8gPSAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovKE9iamVjdC5jcmVhdGUodGVtcGxhdGVJbmZvKSk7XG4gICAgICAgIHRlbXBsYXRlSW5mby53YXNQcmVCb3VuZCA9IHdhc1ByZUJvdW5kO1xuICAgICAgICBpZiAoIXdhc1ByZUJvdW5kICYmIHRoaXMuX190ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0IHx8IHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICAgICAgdGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgPSBsYXN0Lm5leHRUZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID0gbGFzdDtcbiAgICAgICAgICByZXR1cm4gdGVtcGxhdGVJbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fX3RlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgcHJvcGVydHkgZWZmZWN0IHRvIHRoZSBnaXZlbiB0ZW1wbGF0ZSBtZXRhZGF0YSwgd2hpY2ggaXMgcnVuXG4gICAgICogYXQgdGhlIFwicHJvcGFnYXRlXCIgc3RhZ2Ugb2YgYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgd2hlbiB0aGUgdGVtcGxhdGVcbiAgICAgKiBoYXMgYmVlbiBib3VuZCB0byB0aGUgZWxlbWVudCB2aWEgYF9iaW5kVGVtcGxhdGVgLlxuICAgICAqXG4gICAgICogVGhlIGBlZmZlY3RgIG9iamVjdCBzaG91bGQgbWF0Y2ggdGhlIGZvcm1hdCBpbiBgX2FkZFByb3BlcnR5RWZmZWN0YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgdG8gYWRkIGVmZmVjdCB0b1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRoYXQgc2hvdWxkIHRyaWdnZXIgdGhlIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIF9hZGRUZW1wbGF0ZVByb3BlcnR5RWZmZWN0KHRlbXBsYXRlSW5mbywgcHJvcCwgZWZmZWN0KSB7XG4gICAgICBsZXQgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgfHwge307XG4gICAgICBob3N0UHJvcHNbcHJvcF0gPSB0cnVlO1xuICAgICAgbGV0IGVmZmVjdHMgPSB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyB8fCB7fTtcbiAgICAgIGxldCBwcm9wRWZmZWN0cyA9IGVmZmVjdHNbcHJvcF0gPSBlZmZlY3RzW3Byb3BdIHx8IFtdO1xuICAgICAgcHJvcEVmZmVjdHMucHVzaChlZmZlY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFN0YW1wcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgYW5kIHBlcmZvcm1zIGluc3RhbmNlLXRpbWUgc2V0dXAgZm9yXG4gICAgICogUG9seW1lciB0ZW1wbGF0ZSBmZWF0dXJlcywgaW5jbHVkaW5nIGRhdGEgYmluZGluZ3MsIGRlY2xhcmF0aXZlIGV2ZW50XG4gICAgICogbGlzdGVuZXJzLCBhbmQgdGhlIGB0aGlzLiRgIG1hcCBvZiBgaWRgJ3MgdG8gbm9kZXMuICBBIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICogaXMgcmV0dXJuZWQgY29udGFpbmluZyB0aGUgc3RhbXBlZCBET00sIHJlYWR5IGZvciBpbnNlcnRpb24gaW50byB0aGVcbiAgICAgKiBET00uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG1vcmUgdGhhbiBvbmNlOyBob3dldmVyIG5vdGUgdGhhdCBkdWUgdG9cbiAgICAgKiBgc2hhZHljc3NgIHBvbHlmaWxsIGxpbWl0YXRpb25zLCBvbmx5IHN0eWxlcyBmcm9tIHRlbXBsYXRlcyBwcmVwYXJlZFxuICAgICAqIHVzaW5nIGBTaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVgIHdpbGwgYmUgY29ycmVjdGx5IHBvbHlmaWxsZWQgKHNjb3BlZFxuICAgICAqIHRvIHRoZSBzaGFkb3cgcm9vdCBhbmQgc3VwcG9ydCBDU1MgY3VzdG9tIHByb3BlcnRpZXMpLCBhbmQgbm90ZSB0aGF0XG4gICAgICogYFNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZWAgbWF5IG9ubHkgYmUgY2FsbGVkIG9uY2UgcGVyIGVsZW1lbnQuIEFzIHN1Y2gsXG4gICAgICogYW55IHN0eWxlcyByZXF1aXJlZCBieSBpbiBydW50aW1lLXN0YW1wZWQgdGVtcGxhdGVzIG11c3QgYmUgaW5jbHVkZWRcbiAgICAgKiBpbiB0aGUgbWFpbiBlbGVtZW50IHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gc3RhbXBcbiAgICAgKiBAcmV0dXJuIHshU3RhbXBlZFRlbXBsYXRlfSBDbG9uZWQgdGVtcGxhdGUgY29udGVudFxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAgICAgLy8gRW5zdXJlcyB0aGF0IGNyZWF0ZWQgZG9tIGlzIGBfZW5xdWV1ZUNsaWVudGAnZCB0byB0aGlzIGVsZW1lbnQgc29cbiAgICAgIC8vIHRoYXQgaXQgY2FuIGJlIGZsdXNoZWQgb24gbmV4dCBjYWxsIHRvIGBfZmx1c2hQcm9wZXJ0aWVzYFxuICAgICAgaG9zdFN0YWNrLmJlZ2luSG9zdGluZyh0aGlzKTtcbiAgICAgIGxldCBkb20gPSBzdXBlci5fc3RhbXBUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICBob3N0U3RhY2suZW5kSG9zdGluZyh0aGlzKTtcbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovKHRoaXMuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSwgdHJ1ZSkpO1xuICAgICAgLy8gQWRkIHRlbXBsYXRlLWluc3RhbmNlLXNwZWNpZmljIGRhdGEgdG8gaW5zdGFuY2VkIHRlbXBsYXRlSW5mb1xuICAgICAgdGVtcGxhdGVJbmZvLm5vZGVMaXN0ID0gZG9tLm5vZGVMaXN0O1xuICAgICAgLy8gQ2FwdHVyZSBjaGlsZCBub2RlcyB0byBhbGxvdyB1bnN0YW1waW5nIG9mIG5vbi1wcm90b3R5cGljYWwgdGVtcGxhdGVzXG4gICAgICBpZiAoIXRlbXBsYXRlSW5mby53YXNQcmVCb3VuZCkge1xuICAgICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBuPWRvbS5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICBub2Rlcy5wdXNoKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkb20udGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgMi13YXkgbGlzdGVuZXJzLCBhbmQgZGF0YUhvc3QgZm9yIGJpbmRpbmdzXG4gICAgICBzZXR1cEJpbmRpbmdzKHRoaXMsIHRlbXBsYXRlSW5mbyk7XG4gICAgICAvLyBGbHVzaCBwcm9wZXJ0aWVzIGludG8gdGVtcGxhdGUgbm9kZXMgaWYgYWxyZWFkeSBib290ZWRcbiAgICAgIGlmICh0aGlzLl9fZGF0YVJlYWR5KSB7XG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgdGhpcy5fX2RhdGEsIG51bGwsXG4gICAgICAgICAgZmFsc2UsIHRlbXBsYXRlSW5mby5ub2RlTGlzdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW5kIHVuYmluZHMgdGhlIG5vZGVzIHByZXZpb3VzbHkgY29udGFpbmVkIGluIHRoZSBwcm92aWRlZFxuICAgICAqIERvY3VtZW50RnJhZ21lbnQgcmV0dXJuZWQgZnJvbSBgX3N0YW1wVGVtcGxhdGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshU3RhbXBlZFRlbXBsYXRlfSBkb20gRG9jdW1lbnRGcmFnbWVudCBwcmV2aW91c2x5IHJldHVybmVkXG4gICAgICogICBmcm9tIGBfc3RhbXBUZW1wbGF0ZWAgYXNzb2NpYXRlZCB3aXRoIHRoZSBub2RlcyB0byBiZSByZW1vdmVkXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW1vdmVCb3VuZERvbShkb20pIHtcbiAgICAgIC8vIFVubGluayB0ZW1wbGF0ZSBpbmZvXG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gZG9tLnRlbXBsYXRlSW5mbztcbiAgICAgIGlmICh0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm8gPVxuICAgICAgICAgIHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID1cbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ucHJldmlvdXNUZW1wbGF0ZUluZm87XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fX3RlbXBsYXRlSW5mb0xhc3QgPT0gdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID0gdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm8gPSBudWxsO1xuICAgICAgLy8gUmVtb3ZlIHN0YW1wZWQgbm9kZXNcbiAgICAgIGxldCBub2RlcyA9IHRlbXBsYXRlSW5mby5jaGlsZE5vZGVzO1xuICAgICAgZm9yIChsZXQgaT0wOyBpPG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogcGFyc2luZyBiaW5kaW5ncyBmcm9tIGBUZXh0Tm9kZWAncycgYHRleHRDb250ZW50YC4gIEEgYGJpbmRpbmdzYFxuICAgICAqIGFycmF5IGlzIGFkZGVkIHRvIGBub2RlSW5mb2AgYW5kIHBvcHVsYXRlZCB3aXRoIGJpbmRpbmcgbWV0YWRhdGFcbiAgICAgKiB3aXRoIGluZm9ybWF0aW9uIGNhcHR1cmluZyB0aGUgYmluZGluZyB0YXJnZXQsIGFuZCBhIGBwYXJ0c2AgYXJyYXlcbiAgICAgKiB3aXRoIG9uZSBvciBtb3JlIG1ldGFkYXRhIG9iamVjdHMgY2FwdHVyaW5nIHRoZSBzb3VyY2Uocykgb2YgdGhlXG4gICAgICogYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgbm90ZWQgPSBzdXBlci5fcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gdGhpcy5fcGFyc2VCaW5kaW5ncyhub2RlLnRleHRDb250ZW50LCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgICAvLyBJbml0aWFsaXplIHRoZSB0ZXh0Q29udGVudCB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgICAgLy8gTk9URTogZGVmYXVsdCB0byBhIHNwYWNlIGhlcmUgc28gdGhlIHRleHROb2RlIHJlbWFpbnM7IHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICAvLyAoSUUpIGV2YWNpcGF0ZSBhbiBlbXB0eSB0ZXh0Tm9kZSBmb2xsb3dpbmcgY2xvbmVOb2RlL2ltcG9ydE5vZGUuXG4gICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IGxpdGVyYWxGcm9tUGFydHMocGFydHMpIHx8ICcgJztcbiAgICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sICd0ZXh0JywgJ3RleHRDb250ZW50JywgcGFydHMpO1xuICAgICAgICAgIG5vdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBkZWZhdWx0IGBUZW1wbGF0ZVN0YW1wYCBpbXBsZW1lbnRhdGlvbiB0byBhZGQgc3VwcG9ydCBmb3JcbiAgICAgKiBwYXJzaW5nIGJpbmRpbmdzIGZyb20gYXR0cmlidXRlcy4gIEEgYGJpbmRpbmdzYFxuICAgICAqIGFycmF5IGlzIGFkZGVkIHRvIGBub2RlSW5mb2AgYW5kIHBvcHVsYXRlZCB3aXRoIGJpbmRpbmcgbWV0YWRhdGFcbiAgICAgKiB3aXRoIGluZm9ybWF0aW9uIGNhcHR1cmluZyB0aGUgYmluZGluZyB0YXJnZXQsIGFuZCBhIGBwYXJ0c2AgYXJyYXlcbiAgICAgKiB3aXRoIG9uZSBvciBtb3JlIG1ldGFkYXRhIG9iamVjdHMgY2FwdHVyaW5nIHRoZSBzb3VyY2Uocykgb2YgdGhlXG4gICAgICogYmluZGluZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlTm9kZUF0dHJpYnV0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCBuYW1lLCB2YWx1ZSkge1xuICAgICAgbGV0IHBhcnRzID0gdGhpcy5fcGFyc2VCaW5kaW5ncyh2YWx1ZSwgdGVtcGxhdGVJbmZvKTtcbiAgICAgIGlmIChwYXJ0cykge1xuICAgICAgICAvLyBBdHRyaWJ1dGUgb3IgcHJvcGVydHlcbiAgICAgICAgbGV0IG9yaWdOYW1lID0gbmFtZTtcbiAgICAgICAgbGV0IGtpbmQgPSAncHJvcGVydHknO1xuICAgICAgICBpZiAobmFtZVtuYW1lLmxlbmd0aC0xXSA9PSAnJCcpIHtcbiAgICAgICAgICBuYW1lID0gbmFtZS5zbGljZSgwLCAtMSk7XG4gICAgICAgICAga2luZCA9ICdhdHRyaWJ1dGUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEluaXRpYWxpemUgYXR0cmlidXRlIGJpbmRpbmdzIHdpdGggYW55IGxpdGVyYWwgcGFydHNcbiAgICAgICAgbGV0IGxpdGVyYWwgPSBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKTtcbiAgICAgICAgaWYgKGxpdGVyYWwgJiYga2luZCA9PSAnYXR0cmlidXRlJykge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsIGxpdGVyYWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENsZWFyIGF0dHJpYnV0ZSBiZWZvcmUgcmVtb3ZpbmcsIHNpbmNlIElFIHdvbid0IGFsbG93IHJlbW92aW5nXG4gICAgICAgIC8vIGB2YWx1ZWAgYXR0cmlidXRlIGlmIGl0IHByZXZpb3VzbHkgaGFkIGEgdmFsdWUgKGNhbid0XG4gICAgICAgIC8vIHVuY29uZGl0aW9uYWxseSBzZXQgJycgYmVmb3JlIHJlbW92aW5nIHNpbmNlIGF0dHJpYnV0ZXMgd2l0aCBgJGBcbiAgICAgICAgLy8gY2FuJ3QgYmUgc2V0IHVzaW5nIHNldEF0dHJpYnV0ZSlcbiAgICAgICAgaWYgKG5vZGUubG9jYWxOYW1lID09PSAnaW5wdXQnICYmIG9yaWdOYW1lID09PSAndmFsdWUnKSB7XG4gICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUob3JpZ05hbWUsICcnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgYW5ub3RhdGlvblxuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShvcmlnTmFtZSk7XG4gICAgICAgIC8vIENhc2UgaGFja2VyeTogYXR0cmlidXRlcyBhcmUgbG93ZXItY2FzZSwgYnV0IGJpbmQgdGFyZ2V0c1xuICAgICAgICAvLyAocHJvcGVydGllcykgYXJlIGNhc2Ugc2Vuc2l0aXZlLiBHYW1iaXQgaXMgdG8gbWFwIGRhc2gtY2FzZSB0b1xuICAgICAgICAvLyBjYW1lbC1jYXNlOiBgZm9vLWJhcmAgYmVjb21lcyBgZm9vQmFyYC5cbiAgICAgICAgLy8gQXR0cmlidXRlIGJpbmRpbmdzIGFyZSBleGNlcHRlZC5cbiAgICAgICAgaWYgKGtpbmQgPT09ICdwcm9wZXJ0eScpIHtcbiAgICAgICAgICBuYW1lID0gZGFzaFRvQ2FtZWxDYXNlKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGFkZEJpbmRpbmcodGhpcywgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywga2luZCwgbmFtZSwgcGFydHMsIGxpdGVyYWwpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzdXBlci5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBkZWZhdWx0IGBUZW1wbGF0ZVN0YW1wYCBpbXBsZW1lbnRhdGlvbiB0byBhZGQgc3VwcG9ydCBmb3JcbiAgICAgKiBiaW5kaW5nIHRoZSBwcm9wZXJ0aWVzIHRoYXQgYSBuZXN0ZWQgdGVtcGxhdGUgZGVwZW5kcyBvbiB0byB0aGUgdGVtcGxhdGVcbiAgICAgKiBhcyBgX2hvc3RfPHByb3BlcnR5PmAuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGxldCBub3RlZCA9IHN1cGVyLl9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgICAvLyBNZXJnZSBob3N0IHByb3BzIGludG8gb3V0ZXIgdGVtcGxhdGUgYW5kIGFkZCBiaW5kaW5nc1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IG5vZGVJbmZvLnRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICBsZXQgbW9kZSA9ICd7JztcbiAgICAgIGZvciAobGV0IHNvdXJjZSBpbiBob3N0UHJvcHMpIHtcbiAgICAgICAgbGV0IHBhcnRzID0gW3sgbW9kZSwgc291cmNlLCBkZXBlbmRlbmNpZXM6IFtzb3VyY2VdIH1dO1xuICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sICdwcm9wZXJ0eScsICdfaG9zdF8nICsgc291cmNlLCBwYXJ0cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm90ZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHRvIHBhcnNlIHRleHQgaW4gYSB0ZW1wbGF0ZSAoZWl0aGVyIGF0dHJpYnV0ZSB2YWx1ZXMgb3JcbiAgICAgKiB0ZXh0Q29udGVudCkgaW50byBiaW5kaW5nIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQW55IG92ZXJyaWRlcyBvZiB0aGlzIG1ldGhvZCBzaG91bGQgcmV0dXJuIGFuIGFycmF5IG9mIGJpbmRpbmcgcGFydFxuICAgICAqIG1ldGFkYXRhICByZXByZXNlbnRpbmcgb25lIG9yIG1vcmUgYmluZGluZ3MgZm91bmQgaW4gdGhlIHByb3ZpZGVkIHRleHRcbiAgICAgKiBhbmQgYW55IFwibGl0ZXJhbFwiIHRleHQgaW4gYmV0d2Vlbi4gIEFueSBub24tbGl0ZXJhbCBwYXJ0cyB3aWxsIGJlIHBhc3NlZFxuICAgICAqIHRvIGBfZXZhbHVhdGVCaW5kaW5nYCB3aGVuIGFueSBkZXBlbmRlbmNpZXMgY2hhbmdlLiAgVGhlIG9ubHkgcmVxdWlyZWRcbiAgICAgKiBmaWVsZHMgb2YgZWFjaCBcInBhcnRcIiBpbiB0aGUgcmV0dXJuZWQgYXJyYXkgYXJlIGFzIGZvbGxvd3M6XG4gICAgICpcbiAgICAgKiAtIGBkZXBlbmRlbmNpZXNgIC0gQXJyYXkgY29udGFpbmluZyB0cmlnZ2VyIG1ldGFkYXRhIGZvciBlYWNoIHByb3BlcnR5XG4gICAgICogICB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBiaW5kaW5nIHRvIHVwZGF0ZVxuICAgICAqIC0gYGxpdGVyYWxgIC0gU3RyaW5nIGNvbnRhaW5pbmcgdGV4dCBpZiB0aGUgcGFydCByZXByZXNlbnRzIGEgbGl0ZXJhbDtcbiAgICAgKiAgIGluIHRoaXMgY2FzZSBubyBgZGVwZW5kZW5jaWVzYCBhcmUgbmVlZGVkXG4gICAgICpcbiAgICAgKiBBZGRpdGlvbmFsIG1ldGFkYXRhIGZvciB1c2UgYnkgYF9ldmFsdWF0ZUJpbmRpbmdgIG1heSBiZSBwcm92aWRlZCBpblxuICAgICAqIGVhY2ggcGFydCBvYmplY3QgYXMgbmVlZGVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGFuZGxlcyB0aGUgZm9sbG93aW5nIHR5cGVzIG9mIGJpbmRpbmdzXG4gICAgICogKG9uZSBvciBtb3JlIG1heSBiZSBpbnRlcm1peGVkIHdpdGggbGl0ZXJhbCBzdHJpbmdzKTpcbiAgICAgKiAtIFByb3BlcnR5IGJpbmRpbmc6IGBbW3Byb3BdXWBcbiAgICAgKiAtIFBhdGggYmluZGluZzogYFtbb2JqZWN0LnByb3BdXWBcbiAgICAgKiAtIE5lZ2F0ZWQgcHJvcGVydHkgb3IgcGF0aCBiaW5kaW5nczogYFtbIXByb3BdXWAgb3IgYFtbIW9iamVjdC5wcm9wXV1gXG4gICAgICogLSBUd28td2F5IHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3MgKHN1cHBvcnRzIG5lZ2F0aW9uKTpcbiAgICAgKiAgIGB7e3Byb3B9fWAsIGB7e29iamVjdC5wcm9wfX1gLCBge3shcHJvcH19YCBvciBge3shb2JqZWN0LnByb3B9fWBcbiAgICAgKiAtIElubGluZSBjb21wdXRlZCBtZXRob2QgKHN1cHBvcnRzIG5lZ2F0aW9uKTpcbiAgICAgKiAgIGBbW2NvbXB1dGUoYSwgJ2xpdGVyYWwnLCBiKV1dYCwgYFtbIWNvbXB1dGUoYSwgJ2xpdGVyYWwnLCBiKV1dYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgVGV4dCB0byBwYXJzZSBmcm9tIGF0dHJpYnV0ZSBvciB0ZXh0Q29udGVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0ZW1wbGF0ZUluZm8gQ3VycmVudCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqIEByZXR1cm4ge0FycmF5PCFCaW5kaW5nUGFydD59IEFycmF5IG9mIGJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlQmluZGluZ3ModGV4dCwgdGVtcGxhdGVJbmZvKSB7XG4gICAgICBsZXQgcGFydHMgPSBbXTtcbiAgICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgICAgbGV0IG07XG4gICAgICAvLyBFeGFtcGxlOiBcImxpdGVyYWwxe3twcm9wfX1saXRlcmFsMltbIWNvbXB1dGUoZm9vLGJhcildXWZpbmFsXCJcbiAgICAgIC8vIFJlZ2V4IG1hdGNoZXM6XG4gICAgICAvLyAgICAgICAgSXRlcmF0aW9uIDE6ICBJdGVyYXRpb24gMjpcbiAgICAgIC8vIG1bMV06ICd7eycgICAgICAgICAgJ1tbJ1xuICAgICAgLy8gbVsyXTogJycgICAgICAgICAgICAnISdcbiAgICAgIC8vIG1bM106ICdwcm9wJyAgICAgICAgJ2NvbXB1dGUoZm9vLGJhciknXG4gICAgICB3aGlsZSAoKG0gPSBiaW5kaW5nUmVnZXguZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQWRkIGxpdGVyYWwgcGFydFxuICAgICAgICBpZiAobS5pbmRleCA+IGxhc3RJbmRleCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goe2xpdGVyYWw6IHRleHQuc2xpY2UobGFzdEluZGV4LCBtLmluZGV4KX0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZCBiaW5kaW5nIHBhcnRcbiAgICAgICAgbGV0IG1vZGUgPSBtWzFdWzBdO1xuICAgICAgICBsZXQgbmVnYXRlID0gQm9vbGVhbihtWzJdKTtcbiAgICAgICAgbGV0IHNvdXJjZSA9IG1bM10udHJpbSgpO1xuICAgICAgICBsZXQgY3VzdG9tRXZlbnQgPSBmYWxzZSwgbm90aWZ5RXZlbnQgPSAnJywgY29sb24gPSAtMTtcbiAgICAgICAgaWYgKG1vZGUgPT0gJ3snICYmIChjb2xvbiA9IHNvdXJjZS5pbmRleE9mKCc6OicpKSA+IDApIHtcbiAgICAgICAgICBub3RpZnlFdmVudCA9IHNvdXJjZS5zdWJzdHJpbmcoY29sb24gKyAyKTtcbiAgICAgICAgICBzb3VyY2UgPSBzb3VyY2Uuc3Vic3RyaW5nKDAsIGNvbG9uKTtcbiAgICAgICAgICBjdXN0b21FdmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNpZ25hdHVyZSA9IHBhcnNlTWV0aG9kKHNvdXJjZSk7XG4gICAgICAgIGxldCBkZXBlbmRlbmNpZXMgPSBbXTtcbiAgICAgICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICAgIC8vIElubGluZSBjb21wdXRlZCBmdW5jdGlvblxuICAgICAgICAgIGxldCB7YXJncywgbWV0aG9kTmFtZX0gPSBzaWduYXR1cmU7XG4gICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBhcmcgPSBhcmdzW2ldO1xuICAgICAgICAgICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgZHluYW1pY0ZucyA9IHRlbXBsYXRlSW5mby5keW5hbWljRm5zO1xuICAgICAgICAgIGlmIChkeW5hbWljRm5zICYmIGR5bmFtaWNGbnNbbWV0aG9kTmFtZV0gfHwgc2lnbmF0dXJlLnN0YXRpYykge1xuICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgICAgICAgICBzaWduYXR1cmUuZHluYW1pY0ZuID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gUHJvcGVydHkgb3IgcGF0aFxuICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKHNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgc291cmNlLCBtb2RlLCBuZWdhdGUsIGN1c3RvbUV2ZW50LCBzaWduYXR1cmUsIGRlcGVuZGVuY2llcyxcbiAgICAgICAgICBldmVudDogbm90aWZ5RXZlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGxhc3RJbmRleCA9IGJpbmRpbmdSZWdleC5sYXN0SW5kZXg7XG4gICAgICB9XG4gICAgICAvLyBBZGQgYSBmaW5hbCBsaXRlcmFsIHBhcnRcbiAgICAgIGlmIChsYXN0SW5kZXggJiYgbGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGxpdGVyYWwgPSB0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgpO1xuICAgICAgICBpZiAobGl0ZXJhbCkge1xuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgbGl0ZXJhbDogbGl0ZXJhbFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFydHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBldmFsdWF0ZSBhIHByZXZpb3VzbHkgcGFyc2VkIGJpbmRpbmcgcGFydCBiYXNlZCBvbiBhIHNldCBvZlxuICAgICAqIG9uZSBvciBtb3JlIGNoYW5nZWQgZGVwZW5kZW5jaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt0aGlzfSBpbnN0IEVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBzY29wZSBmb3JcbiAgICAgKiAgIGJpbmRpbmcgZGVwZW5kZW5jaWVzXG4gICAgICogQHBhcmFtIHtCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQcm9wZXJ0eS9wYXRoIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZWZmZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtib29sZWFufSBoYXNQYXRocyBUcnVlIHdpdGggYHByb3BzYCBjb250YWlucyBvbmUgb3IgbW9yZSBwYXRoc1xuICAgICAqIEByZXR1cm4geyp9IFZhbHVlIHRoZSBiaW5kaW5nIHBhcnQgZXZhbHVhdGVkIHRvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBfZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgICAgIGxldCB2YWx1ZTtcbiAgICAgIGlmIChwYXJ0LnNpZ25hdHVyZSkge1xuICAgICAgICB2YWx1ZSA9IHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIHBhcnQuc2lnbmF0dXJlKTtcbiAgICAgIH0gZWxzZSBpZiAocGF0aCAhPSBwYXJ0LnNvdXJjZSkge1xuICAgICAgICB2YWx1ZSA9IGdldCQwKGluc3QsIHBhcnQuc291cmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChoYXNQYXRocyAmJiBpc1BhdGgkMChwYXRoKSkge1xuICAgICAgICAgIHZhbHVlID0gZ2V0JDAoaW5zdCwgcGF0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgPSBpbnN0Ll9fZGF0YVtwYXRoXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnQubmVnYXRlKSB7XG4gICAgICAgIHZhbHVlID0gIXZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICB9XG5cbiAgLy8gbWFrZSBhIHR5cGluZyBmb3IgY2xvc3VyZSA6UFxuICBQcm9wZXJ0eUVmZmVjdHNUeXBlID0gUHJvcGVydHlFZmZlY3RzO1xuXG4gIHJldHVybiBQcm9wZXJ0eUVmZmVjdHM7XG59KTtcblxuLyoqXG4gKiBIZWxwZXIgYXBpIGZvciBlbnF1ZWluZyBjbGllbnQgZG9tIGNyZWF0ZWQgYnkgYSBob3N0IGVsZW1lbnQuXG4gKlxuICogQnkgZGVmYXVsdCBlbGVtZW50cyBhcmUgZmx1c2hlZCB2aWEgYF9mbHVzaFByb3BlcnRpZXNgIHdoZW5cbiAqIGBjb25uZWN0ZWRDYWxsYmFja2AgaXMgY2FsbGVkLiBFbGVtZW50cyBhdHRhY2ggdGhlaXIgY2xpZW50IGRvbSB0b1xuICogdGhlbXNlbHZlcyBhdCBgcmVhZHlgIHRpbWUgd2hpY2ggcmVzdWx0cyBmcm9tIHRoaXMgZmlyc3QgZmx1c2guXG4gKiBUaGlzIHByb3ZpZGVzIGFuIG9yZGVyaW5nIGd1YXJhbnRlZSB0aGF0IHRoZSBjbGllbnQgZG9tIGFuIGVsZW1lbnRcbiAqIGNyZWF0ZXMgaXMgZmx1c2hlZCBiZWZvcmUgdGhlIGVsZW1lbnQgaXRzZWxmIChpLmUuIGNsaWVudCBgcmVhZHlgXG4gKiBmaXJlcyBiZWZvcmUgaG9zdCBgcmVhZHlgKS5cbiAqXG4gKiBIb3dldmVyLCBpZiBgX2ZsdXNoUHJvcGVydGllc2AgaXMgY2FsbGVkICpiZWZvcmUqIGFuIGVsZW1lbnQgaXMgY29ubmVjdGVkLFxuICogYXMgZm9yIGV4YW1wbGUgYFRlbXBsYXRpemVgIGRvZXMsIHRoaXMgb3JkZXJpbmcgZ3VhcmFudGVlIGNhbm5vdCBiZVxuICogc2F0aXNmaWVkIGJlY2F1c2Ugbm8gZWxlbWVudHMgYXJlIGNvbm5lY3RlZC4gKE5vdGU6IEJvdW5kIGVsZW1lbnRzIHRoYXRcbiAqIHJlY2VpdmUgZGF0YSBkbyBiZWNvbWUgZW5xdWV1ZWQgY2xpZW50cyBhbmQgYXJlIHByb3Blcmx5IG9yZGVyZWQgYnV0XG4gKiB1bmJvdW5kIGVsZW1lbnRzIGFyZSBub3QuKVxuICpcbiAqIFRvIG1haW50YWluIHRoZSBkZXNpcmVkIFwiY2xpZW50IGJlZm9yZSBob3N0XCIgb3JkZXJpbmcgZ3VhcmFudGVlIGZvciB0aGlzXG4gKiBjYXNlIHdlIHJlbHkgb24gdGhlIFwiaG9zdCBzdGFjay4gQ2xpZW50IG5vZGVzIHJlZ2lzdGVycyB0aGVtc2VsdmVzIHdpdGhcbiAqIHRoZSBjcmVhdGluZyBob3N0IGVsZW1lbnQgd2hlbiBjcmVhdGVkLiBUaGlzIGVuc3VyZXMgdGhhdCBhbGwgY2xpZW50IGRvbVxuICogaXMgcmVhZGllZCBpbiB0aGUgcHJvcGVyIG9yZGVyLCBtYWludGFpbmluZyB0aGUgZGVzaXJlZCBndWFyYW50ZWUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xubGV0IGhvc3RTdGFjayA9IHtcblxuICBzdGFjazogW10sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5zdCBJbnN0YW5jZSB0byBhZGQgdG8gaG9zdFN0YWNrXG4gICAqIEB0aGlzIHtob3N0U3RhY2t9XG4gICAqL1xuICByZWdpc3Rlckhvc3QoaW5zdCkge1xuICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCkge1xuICAgICAgbGV0IGhvc3QgPSB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoLTFdO1xuICAgICAgaG9zdC5fZW5xdWV1ZUNsaWVudChpbnN0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5zdCBJbnN0YW5jZSB0byBiZWdpbiBob3N0aW5nXG4gICAqIEB0aGlzIHtob3N0U3RhY2t9XG4gICAqL1xuICBiZWdpbkhvc3RpbmcoaW5zdCkge1xuICAgIHRoaXMuc3RhY2sucHVzaChpbnN0KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHsqfSBpbnN0IEluc3RhbmNlIHRvIGVuZCBob3N0aW5nXG4gICAqIEB0aGlzIHtob3N0U3RhY2t9XG4gICAqL1xuICBlbmRIb3N0aW5nKGluc3QpIHtcbiAgICBsZXQgc3RhY2tMZW4gPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICBpZiAoc3RhY2tMZW4gJiYgdGhpcy5zdGFja1tzdGFja0xlbi0xXSA9PSBpbnN0KSB7XG4gICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanNcbi8vIG1vZHVsZSBpZCA9IDI2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcblxubGV0IHNjaGVkdWxlZCA9IGZhbHNlO1xubGV0IGJlZm9yZVJlbmRlclF1ZXVlID0gW107XG5sZXQgYWZ0ZXJSZW5kZXJRdWV1ZSA9IFtdO1xuXG5mdW5jdGlvbiBzY2hlZHVsZSgpIHtcbiAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgLy8gYmVmb3JlIG5leHQgcmVuZGVyXG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBmbHVzaFF1ZXVlKGJlZm9yZVJlbmRlclF1ZXVlKTtcbiAgICAvLyBhZnRlciB0aGUgcmVuZGVyXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIHJ1blF1ZXVlKGFmdGVyUmVuZGVyUXVldWUpO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZmx1c2hRdWV1ZShxdWV1ZSkge1xuICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgY2FsbE1ldGhvZChxdWV1ZS5zaGlmdCgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBydW5RdWV1ZShxdWV1ZSkge1xuICBmb3IgKGxldCBpPTAsIGw9cXVldWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2FsbE1ldGhvZChxdWV1ZS5zaGlmdCgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsTWV0aG9kKGluZm8pIHtcbiAgY29uc3QgY29udGV4dCA9IGluZm9bMF07XG4gIGNvbnN0IGNhbGxiYWNrID0gaW5mb1sxXTtcbiAgY29uc3QgYXJncyA9IGluZm9bMl07XG4gIHRyeSB7XG4gICAgY2FsbGJhY2suYXBwbHkoY29udGV4dCwgYXJncyk7XG4gIH0gY2F0Y2goZSkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgd2hpbGUgKGJlZm9yZVJlbmRlclF1ZXVlLmxlbmd0aCB8fCBhZnRlclJlbmRlclF1ZXVlLmxlbmd0aCkge1xuICAgIGZsdXNoUXVldWUoYmVmb3JlUmVuZGVyUXVldWUpO1xuICAgIGZsdXNoUXVldWUoYWZ0ZXJSZW5kZXJRdWV1ZSk7XG4gIH1cbiAgc2NoZWR1bGVkID0gZmFsc2U7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiZWZvcmVOZXh0UmVuZGVyKGNvbnRleHQsIGNhbGxiYWNrLCBhcmdzKSB7XG4gIGlmICghc2NoZWR1bGVkKSB7XG4gICAgc2NoZWR1bGUoKTtcbiAgfVxuICBiZWZvcmVSZW5kZXJRdWV1ZS5wdXNoKFtjb250ZXh0LCBjYWxsYmFjaywgYXJnc10pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWZ0ZXJOZXh0UmVuZGVyKGNvbnRleHQsIGNhbGxiYWNrLCBhcmdzKSB7XG4gIGlmICghc2NoZWR1bGVkKSB7XG4gICAgc2NoZWR1bGUoKTtcbiAgfVxuICBhZnRlclJlbmRlclF1ZXVlLnB1c2goW2NvbnRleHQsIGNhbGxiYWNrLCBhcmdzXSk7XG59XG5cbmV4cG9ydCB7IGZsdXNoIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzXG4vLyBtb2R1bGUgaWQgPSAyN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBkZWJvdW5jZXJRdWV1ZSA9IFtdO1xuXG5leHBvcnQgY29uc3QgZW5xdWV1ZURlYm91bmNlciA9IGZ1bmN0aW9uKGRlYm91bmNlcikge1xuICBkZWJvdW5jZXJRdWV1ZS5wdXNoKGRlYm91bmNlcik7XG59O1xuXG5mdW5jdGlvbiBmbHVzaERlYm91bmNlcnMoKSB7XG4gIGNvbnN0IGRpZEZsdXNoID0gQm9vbGVhbihkZWJvdW5jZXJRdWV1ZS5sZW5ndGgpO1xuICB3aGlsZSAoZGVib3VuY2VyUXVldWUubGVuZ3RoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGRlYm91bmNlclF1ZXVlLnNoaWZ0KCkuZmx1c2goKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWRGbHVzaDtcbn1cblxuZXhwb3J0IGNvbnN0IGZsdXNoID0gZnVuY3Rpb24oKSB7XG4gIGxldCBzaGFkeURPTSwgZGVib3VuY2VycztcbiAgZG8ge1xuICAgIHNoYWR5RE9NID0gd2luZG93LlNoYWR5RE9NICYmIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgaWYgKHdpbmRvdy5TaGFkeUNTUyAmJiB3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0pIHtcbiAgICAgIHdpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbS5mbHVzaCgpO1xuICAgIH1cbiAgICBkZWJvdW5jZXJzID0gZmx1c2hEZWJvdW5jZXJzKCk7XG4gIH0gd2hpbGUgKHNoYWR5RE9NIHx8IGRlYm91bmNlcnMpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsdXNoLmpzXG4vLyBtb2R1bGUgaWQgPSAyOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5pbXBvcnQgeyBQcm9wZXJ0eUVmZmVjdHMgfSBmcm9tICcuLi9taXhpbnMvcHJvcGVydHktZWZmZWN0cy5qcyc7XG5pbXBvcnQgeyBNdXRhYmxlRGF0YSB9IGZyb20gJy4uL21peGlucy9tdXRhYmxlLWRhdGEuanMnO1xuXG4vLyBCYXNlIGNsYXNzIGZvciBIVE1MVGVtcGxhdGVFbGVtZW50IGV4dGVuc2lvbiB0aGF0IGhhcyBwcm9wZXJ0eSBlZmZlY3RzXG4vLyBtYWNoaW5lcnkgZm9yIHByb3BhZ2F0aW5nIGhvc3QgcHJvcGVydGllcyB0byBjaGlsZHJlbi4gVGhpcyBpcyBhbiBFUzVcbi8vIGNsYXNzIG9ubHkgYmVjYXVzZSBCYWJlbCAoaW5jb3JyZWN0bHkpIHJlcXVpcmVzIHN1cGVyKCkgaW4gdGhlIGNsYXNzXG4vLyBjb25zdHJ1Y3RvciBldmVuIHRob3VnaCBubyBgdGhpc2AgaXMgdXNlZCBhbmQgaXQgcmV0dXJucyBhbiBpbnN0YW5jZS5cbmxldCBuZXdJbnN0YW5jZSA9IG51bGw7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0hUTUxUZW1wbGF0ZUVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24oKSB7IHJldHVybiBuZXdJbnN0YW5jZTsgfVxuSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEhUTUxUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdG9yOiB7XG4gICAgdmFsdWU6IEhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfVxufSk7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICogQGV4dGVuZHMge0hUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb259XG4gKi9cbmNvbnN0IERhdGFUZW1wbGF0ZSA9IFByb3BlcnR5RWZmZWN0cyhIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uKTtcbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAqIEBleHRlbmRzIHtEYXRhVGVtcGxhdGV9XG4gKi9cbmNvbnN0IE11dGFibGVEYXRhVGVtcGxhdGUgPSBNdXRhYmxlRGF0YShEYXRhVGVtcGxhdGUpO1xuXG4vLyBBcHBsaWVzIGEgRGF0YVRlbXBsYXRlIHN1YmNsYXNzIHRvIGEgPHRlbXBsYXRlPiBpbnN0YW5jZVxuZnVuY3Rpb24gdXBncmFkZVRlbXBsYXRlKHRlbXBsYXRlLCBjb25zdHJ1Y3Rvcikge1xuICBuZXdJbnN0YW5jZSA9IHRlbXBsYXRlO1xuICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGVtcGxhdGUsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gIG5ldyBjb25zdHJ1Y3RvcigpO1xuICBuZXdJbnN0YW5jZSA9IG51bGw7XG59XG5cbi8vIEJhc2UgY2xhc3MgZm9yIFRlbXBsYXRlSW5zdGFuY2Unc1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAqL1xuY29uc3QgYmFzZSA9IFByb3BlcnR5RWZmZWN0cyhjbGFzcyB7fSk7XG5cbi8qKlxuICogQHBvbHltZXJcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuUHJvcGVydHlFZmZlY3RzXG4gKiBAdW5yZXN0cmljdGVkXG4gKi9cbmNsYXNzIFRlbXBsYXRlSW5zdGFuY2VCYXNlIGV4dGVuZHMgYmFzZSB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9jb25maWd1cmVQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRoaXMuX19kYXRhSG9zdCk7XG4gICAgLy8gU2F2ZSBsaXN0IG9mIHN0YW1wZWQgY2hpbGRyZW5cbiAgICBsZXQgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuID0gW107XG4gICAgZm9yIChsZXQgbiA9IHRoaXMucm9vdC5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgIGNoaWxkcmVuLnB1c2gobik7XG4gICAgICBuLl9fdGVtcGxhdGl6ZUluc3RhbmNlID0gdGhpcztcbiAgICB9XG4gICAgaWYgKHRoaXMuX190ZW1wbGF0aXplT3duZXIuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fKSB7XG4gICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKHRydWUpO1xuICAgIH1cbiAgICAvLyBGbHVzaCBwcm9wcyBvbmx5IHdoZW4gcHJvcHMgYXJlIHBhc3NlZCBpZiBpbnN0YW5jZSBwcm9wcyBleGlzdFxuICAgIC8vIG9yIHdoZW4gdGhlcmUgaXNuJ3QgaW5zdGFuY2UgcHJvcHMuXG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4gICAgaWYgKChwcm9wcyAmJiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHx8ICFvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgIHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIENvbmZpZ3VyZSB0aGUgZ2l2ZW4gYHByb3BzYCBieSBjYWxsaW5nIGBfc2V0UGVuZGluZ1Byb3BlcnR5YC4gQWxzb1xuICAgKiBzZXRzIGFueSBwcm9wZXJ0aWVzIHN0b3JlZCBpbiBgX19ob3N0UHJvcHNgLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgT2JqZWN0IG9mIHByb3BlcnR5IG5hbWUtdmFsdWUgcGFpcnMgdG8gc2V0LlxuICAgKi9cbiAgX2NvbmZpZ3VyZVByb3BlcnRpZXMocHJvcHMpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucztcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZvciAobGV0IGlwcm9wIGluIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgICAgICBpZiAoaXByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgICB0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkoaXByb3AsIHByb3BzW2lwcm9wXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaHByb3AgaW4gdGhpcy5fX2hvc3RQcm9wcykge1xuICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KGhwcm9wLCB0aGlzLl9fZGF0YUhvc3RbJ19ob3N0XycgKyBocHJvcF0pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRm9yd2FyZHMgYSBob3N0IHByb3BlcnR5IHRvIHRoaXMgaW5zdGFuY2UuICBUaGlzIG1ldGhvZCBzaG91bGQgYmVcbiAgICogY2FsbGVkIG9uIGluc3RhbmNlcyBmcm9tIHRoZSBgb3B0aW9ucy5mb3J3YXJkSG9zdFByb3BgIGNhbGxiYWNrXG4gICAqIHRvIHByb3BhZ2F0ZSBjaGFuZ2VzIG9mIGhvc3QgcHJvcGVydGllcyB0byBlYWNoIGluc3RhbmNlLlxuICAgKlxuICAgKiBOb3RlIHRoaXMgbWV0aG9kIGVucXVldWVzIHRoZSBjaGFuZ2UsIHdoaWNoIGFyZSBmbHVzaGVkIGFzIGEgYmF0Y2guXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IG9yIHBhdGggbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIHRoZSBwcm9wZXJ0eSB0byBmb3J3YXJkXG4gICAqL1xuICBmb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHByb3AsIHZhbHVlLCBmYWxzZSwgdHJ1ZSkpIHtcbiAgICAgIHRoaXMuX19kYXRhSG9zdC5fZW5xdWV1ZUNsaWVudCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgaWYgKHRoaXMuX21ldGhvZEhvc3QgJiYgdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zLnBhcmVudE1vZGVsKSB7XG4gICAgICAvLyBJZiB0aGlzIGluc3RhbmNlIHNob3VsZCBiZSBjb25zaWRlcmVkIGEgcGFyZW50IG1vZGVsLCBkZWNvcmF0ZVxuICAgICAgLy8gZXZlbnRzIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UgYXMgYG1vZGVsYFxuICAgICAgdGhpcy5fbWV0aG9kSG9zdC5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIChlKSA9PiB7XG4gICAgICAgIGUubW9kZWwgPSB0aGlzO1xuICAgICAgICBoYW5kbGVyKGUpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE90aGVyd2lzZSBkZWxlZ2F0ZSB0byB0aGUgdGVtcGxhdGUncyBob3N0ICh3aGljaCBjb3VsZCBiZSlcbiAgICAgIC8vIGFub3RoZXIgdGVtcGxhdGUgaW5zdGFuY2VcbiAgICAgIGxldCB0ZW1wbGF0ZUhvc3QgPSB0aGlzLl9fZGF0YUhvc3QuX19kYXRhSG9zdDtcbiAgICAgIGlmICh0ZW1wbGF0ZUhvc3QpIHtcbiAgICAgICAgdGVtcGxhdGVIb3N0Ll9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTaG93cyBvciBoaWRlcyB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdG9wIGxldmVsIGNoaWxkIGVsZW1lbnRzLiBGb3JcbiAgICogdGV4dCBub2RlcywgYHRleHRDb250ZW50YCBpcyByZW1vdmVkIHdoaWxlIFwiaGlkZGVuXCIgYW5kIHJlcGxhY2VkIHdoZW5cbiAgICogXCJzaG93bi5cIlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGhpZGUgU2V0IHRvIHRydWUgdG8gaGlkZSB0aGUgY2hpbGRyZW47XG4gICAqIHNldCB0byBmYWxzZSB0byBzaG93IHRoZW0uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zaG93SGlkZUNoaWxkcmVuKGhpZGUpIHtcbiAgICBsZXQgYyA9IHRoaXMuY2hpbGRyZW47XG4gICAgZm9yIChsZXQgaT0wOyBpPGMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuID0gY1tpXTtcbiAgICAgIC8vIElnbm9yZSBub24tY2hhbmdlc1xuICAgICAgaWYgKEJvb2xlYW4oaGlkZSkgIT0gQm9vbGVhbihuLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXykpIHtcbiAgICAgICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgIG4uX19wb2x5bWVyVGV4dENvbnRlbnRfXyA9IG4udGV4dENvbnRlbnQ7XG4gICAgICAgICAgICBuLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4udGV4dENvbnRlbnQgPSBuLl9fcG9seW1lclRleHRDb250ZW50X187XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG4uc3R5bGUpIHtcbiAgICAgICAgICBpZiAoaGlkZSkge1xuICAgICAgICAgICAgbi5fX3BvbHltZXJEaXNwbGF5X18gPSBuLnN0eWxlLmRpc3BsYXk7XG4gICAgICAgICAgICBuLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG4uc3R5bGUuZGlzcGxheSA9IG4uX19wb2x5bWVyRGlzcGxheV9fO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbi5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gPSBoaWRlO1xuICAgICAgaWYgKG4uX3Nob3dIaWRlQ2hpbGRyZW4pIHtcbiAgICAgICAgbi5fc2hvd0hpZGVDaGlsZHJlbihoaWRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBkZWZhdWx0IHByb3BlcnR5LWVmZmVjdHMgaW1wbGVtZW50YXRpb24gdG8gaW50ZXJjZXB0XG4gICAqIHRleHRDb250ZW50IGJpbmRpbmdzIHdoaWxlIGNoaWxkcmVuIGFyZSBcImhpZGRlblwiIGFuZCBjYWNoZSBpblxuICAgKiBwcml2YXRlIHN0b3JhZ2UgZm9yIGxhdGVyIHJldHJpZXZhbC5cbiAgICpcbiAgICogQG92ZXJyaWRlXG4gICAqL1xuICBfc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICBpZiAobm9kZS5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gJiZcbiAgICAgICAgbm9kZS5ub2RlVHlwZSA9PSBOb2RlLlRFWFRfTk9ERSAmJiBwcm9wID09ICd0ZXh0Q29udGVudCcpIHtcbiAgICAgIG5vZGUuX19wb2x5bWVyVGV4dENvbnRlbnRfXyA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5fc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmluZCB0aGUgcGFyZW50IG1vZGVsIG9mIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuICBUaGUgcGFyZW50IG1vZGVsXG4gICAqIGlzIGVpdGhlciBhbm90aGVyIHRlbXBsYXRpemUgaW5zdGFuY2UgdGhhdCBoYWQgb3B0aW9uIGBwYXJlbnRNb2RlbDogdHJ1ZWAsXG4gICAqIG9yIGVsc2UgdGhlIGhvc3QgZWxlbWVudC5cbiAgICpcbiAgICogQHJldHVybiB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9IFRoZSBwYXJlbnQgbW9kZWwgb2YgdGhpcyBpbnN0YW5jZVxuICAgKi9cbiAgZ2V0IHBhcmVudE1vZGVsKCkge1xuICAgIGxldCBtb2RlbCA9IHRoaXMuX19wYXJlbnRNb2RlbDtcbiAgICBpZiAoIW1vZGVsKSB7XG4gICAgICBsZXQgb3B0aW9ucztcbiAgICAgIG1vZGVsID0gdGhpcztcbiAgICAgIGRvIHtcbiAgICAgICAgLy8gQSB0ZW1wbGF0ZSBpbnN0YW5jZSdzIGBfX2RhdGFIb3N0YCBpcyBhIDx0ZW1wbGF0ZT5cbiAgICAgICAgLy8gYG1vZGVsLl9fZGF0YUhvc3QuX19kYXRhSG9zdGAgaXMgdGhlIHRlbXBsYXRlJ3MgaG9zdFxuICAgICAgICBtb2RlbCA9IG1vZGVsLl9fZGF0YUhvc3QuX19kYXRhSG9zdDtcbiAgICAgIH0gd2hpbGUgKChvcHRpb25zID0gbW9kZWwuX190ZW1wbGF0aXplT3B0aW9ucykgJiYgIW9wdGlvbnMucGFyZW50TW9kZWwpO1xuICAgICAgdGhpcy5fX3BhcmVudE1vZGVsID0gbW9kZWw7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbiAgfVxufVxuXG4vKiogQHR5cGUgeyFEYXRhVGVtcGxhdGV9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX19kYXRhSG9zdDtcbi8qKiBAdHlwZSB7IVRlbXBsYXRpemVPcHRpb25zfSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4vKiogQHR5cGUgeyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fbWV0aG9kSG9zdDtcbi8qKiBAdHlwZSB7IU9iamVjdH0gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPd25lcjtcbi8qKiBAdHlwZSB7IU9iamVjdH0gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX2hvc3RQcm9wcztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX1cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX011dGFibGVEYXRhfVxuICovXG5jb25zdCBNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBNdXRhYmxlRGF0YShUZW1wbGF0ZUluc3RhbmNlQmFzZSk7XG5cbmZ1bmN0aW9uIGZpbmRNZXRob2RIb3N0KHRlbXBsYXRlKSB7XG4gIC8vIFRlY2huaWNhbGx5IHRoaXMgc2hvdWxkIGJlIHRoZSBvd25lciBvZiB0aGUgb3V0ZXJtb3N0IHRlbXBsYXRlLlxuICAvLyBJbiBzaGFkb3cgZG9tLCB0aGlzIGlzIGFsd2F5cyBnZXRSb290Tm9kZSgpLmhvc3QsIGJ1dCB3ZSBjYW5cbiAgLy8gYXBwcm94aW1hdGUgdGhpcyB2aWEgY29vcGVyYXRpb24gd2l0aCBvdXIgZGF0YUhvc3QgYWx3YXlzIHNldHRpbmdcbiAgLy8gYF9tZXRob2RIb3N0YCBhcyBsb25nIGFzIHRoZXJlIHdlcmUgYmluZGluZ3MgKG9yIGlkJ3MpIG9uIHRoaXNcbiAgLy8gaW5zdGFuY2UgY2F1c2luZyBpdCB0byBnZXQgYSBkYXRhSG9zdC5cbiAgbGV0IHRlbXBsYXRlSG9zdCA9IHRlbXBsYXRlLl9fZGF0YUhvc3Q7XG4gIHJldHVybiB0ZW1wbGF0ZUhvc3QgJiYgdGVtcGxhdGVIb3N0Ll9tZXRob2RIb3N0IHx8IHRlbXBsYXRlSG9zdDtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbi8qKlxuICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gY2xhc3MucHJvdG90eXBlIGlzIG5vdCBkZWZpbmVkIGZvciBzb21lIHJlYXNvblxuICovXG5mdW5jdGlvbiBjcmVhdGVUZW1wbGF0aXplckNsYXNzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgLy8gQW5vbnltb3VzIGNsYXNzIGNyZWF0ZWQgYnkgdGhlIHRlbXBsYXRpemVcbiAgbGV0IGJhc2UgPSBvcHRpb25zLm11dGFibGVEYXRhID9cbiAgICBNdXRhYmxlVGVtcGxhdGVJbnN0YW5jZUJhc2UgOiBUZW1wbGF0ZUluc3RhbmNlQmFzZTtcbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICovXG4gIGxldCBrbGFzcyA9IGNsYXNzIGV4dGVuZHMgYmFzZSB7IH07XG4gIGtsYXNzLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPcHRpb25zID0gb3B0aW9ucztcbiAga2xhc3MucHJvdG90eXBlLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICBhZGROb3RpZnlFZmZlY3RzKGtsYXNzLCB0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKTtcbiAgcmV0dXJuIGtsYXNzO1xufVxuXG4vKipcbiAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgZGVmaW5lZCBmb3Igc29tZSByZWFzb25cbiAqL1xuZnVuY3Rpb24gYWRkUHJvcGFnYXRlRWZmZWN0cyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gIGxldCB1c2VyRm9yd2FyZEhvc3RQcm9wID0gb3B0aW9ucy5mb3J3YXJkSG9zdFByb3A7XG4gIGlmICh1c2VyRm9yd2FyZEhvc3RQcm9wKSB7XG4gICAgLy8gUHJvdmlkZSBkYXRhIEFQSSBhbmQgcHJvcGVydHkgZWZmZWN0cyBvbiBtZW1vaXplZCB0ZW1wbGF0ZSBjbGFzc1xuICAgIGxldCBrbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplVGVtcGxhdGVDbGFzcztcbiAgICBpZiAoIWtsYXNzKSB7XG4gICAgICBsZXQgYmFzZSA9IG9wdGlvbnMubXV0YWJsZURhdGEgPyBNdXRhYmxlRGF0YVRlbXBsYXRlIDogRGF0YVRlbXBsYXRlO1xuICAgICAga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3MgPVxuICAgICAgICBjbGFzcyBUZW1wbGF0aXplZFRlbXBsYXRlIGV4dGVuZHMgYmFzZSB7fTtcbiAgICAgIC8vIEFkZCB0ZW1wbGF0ZSAtID5pbnN0YW5jZXMgZWZmZWN0c1xuICAgICAgLy8gYW5kIGhvc3QgPC0gdGVtcGxhdGUgZWZmZWN0c1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgICBmb3IgKGxldCBwcm9wIGluIGhvc3RQcm9wcykge1xuICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2FkZFByb3BlcnR5RWZmZWN0KCdfaG9zdF8nICsgcHJvcCxcbiAgICAgICAgICBrbGFzcy5wcm90b3R5cGUuUFJPUEVSVFlfRUZGRUNUX1RZUEVTLlBST1BBR0FURSxcbiAgICAgICAgICB7Zm46IGNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdChwcm9wLCB1c2VyRm9yd2FyZEhvc3RQcm9wKX0pO1xuICAgICAgICBrbGFzcy5wcm90b3R5cGUuX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KCdfaG9zdF8nICsgcHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHVwZ3JhZGVUZW1wbGF0ZSh0ZW1wbGF0ZSwga2xhc3MpO1xuICAgIC8vIE1peCBhbnkgcHJlLWJvdW5kIGRhdGEgaW50byBfX2RhdGE7IG5vIG5lZWQgdG8gZmx1c2ggdGhpcyB0b1xuICAgIC8vIGluc3RhbmNlcyBzaW5jZSB0aGV5IHB1bGwgZnJvbSB0aGUgdGVtcGxhdGUgYXQgaW5zdGFuY2UtdGltZVxuICAgIGlmICh0ZW1wbGF0ZS5fX2RhdGFQcm90bykge1xuICAgICAgLy8gTm90ZSwgZ2VuZXJhbGx5IGBfX2RhdGFQcm90b2AgY291bGQgYmUgY2hhaW5lZCwgYnV0IGl0J3MgZ3VhcmFudGVlZFxuICAgICAgLy8gdG8gbm90IGJlIHNpbmNlIHRoaXMgaXMgYSB2YW5pbGxhIHRlbXBsYXRlIHdlIGp1c3QgYWRkZWQgZWZmZWN0cyB0b1xuICAgICAgT2JqZWN0LmFzc2lnbih0ZW1wbGF0ZS5fX2RhdGEsIHRlbXBsYXRlLl9fZGF0YVByb3RvKTtcbiAgICB9XG4gICAgLy8gQ2xlYXIgYW55IHBlbmRpbmcgZGF0YSBmb3IgcGVyZm9ybWFuY2VcbiAgICB0ZW1wbGF0ZS5fX2RhdGFUZW1wID0ge307XG4gICAgdGVtcGxhdGUuX19kYXRhUGVuZGluZyA9IG51bGw7XG4gICAgdGVtcGxhdGUuX19kYXRhT2xkID0gbnVsbDtcbiAgICB0ZW1wbGF0ZS5fZW5hYmxlUHJvcGVydGllcygpO1xuICB9XG59XG4vKiBlc2xpbnQtZW5hYmxlIHZhbGlkLWpzZG9jICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcndhcmRIb3N0UHJvcEVmZmVjdChob3N0UHJvcCwgdXNlckZvcndhcmRIb3N0UHJvcCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9yd2FyZEhvc3RQcm9wKHRlbXBsYXRlLCBwcm9wLCBwcm9wcykge1xuICAgIHVzZXJGb3J3YXJkSG9zdFByb3AuY2FsbCh0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lcixcbiAgICAgIHByb3Auc3Vic3RyaW5nKCdfaG9zdF8nLmxlbmd0aCksIHByb3BzW3Byb3BdKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYWRkTm90aWZ5RWZmZWN0cyhrbGFzcywgdGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucykge1xuICBsZXQgaG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcyB8fCB7fTtcbiAgZm9yIChsZXQgaXByb3AgaW4gb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB7XG4gICAgZGVsZXRlIGhvc3RQcm9wc1tpcHJvcF07XG4gICAgbGV0IHVzZXJOb3RpZnlJbnN0YW5jZVByb3AgPSBvcHRpb25zLm5vdGlmeUluc3RhbmNlUHJvcDtcbiAgICBpZiAodXNlck5vdGlmeUluc3RhbmNlUHJvcCkge1xuICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChpcHJvcCxcbiAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5OT1RJRlksXG4gICAgICAgIHtmbjogY3JlYXRlTm90aWZ5SW5zdGFuY2VQcm9wRWZmZWN0KGlwcm9wLCB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wKX0pO1xuICAgIH1cbiAgfVxuICBpZiAob3B0aW9ucy5mb3J3YXJkSG9zdFByb3AgJiYgdGVtcGxhdGUuX19kYXRhSG9zdCkge1xuICAgIGZvciAobGV0IGhwcm9wIGluIGhvc3RQcm9wcykge1xuICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChocHJvcCxcbiAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5OT1RJRlksXG4gICAgICAgIHtmbjogY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QoKX0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3RpZnlJbnN0YW5jZVByb3BFZmZlY3QoaW5zdFByb3AsIHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUluc3RhbmNlUHJvcChpbnN0LCBwcm9wLCBwcm9wcykge1xuICAgIHVzZXJOb3RpZnlJbnN0YW5jZVByb3AuY2FsbChpbnN0Ll9fdGVtcGxhdGl6ZU93bmVyLFxuICAgICAgaW5zdCwgcHJvcCwgcHJvcHNbcHJvcF0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb3RpZnlIb3N0UHJvcEVmZmVjdCgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIG5vdGlmeUhvc3RQcm9wKGluc3QsIHByb3AsIHByb3BzKSB7XG4gICAgaW5zdC5fX2RhdGFIb3N0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgoJ19ob3N0XycgKyBwcm9wLCBwcm9wc1twcm9wXSwgdHJ1ZSwgdHJ1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogTW9kdWxlIGZvciBwcmVwYXJpbmcgYW5kIHN0YW1waW5nIGluc3RhbmNlcyBvZiB0ZW1wbGF0ZXMgdGhhdCB1dGlsaXplXG4gKiBQb2x5bWVyJ3MgZGF0YS1iaW5kaW5nIGFuZCBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lciBmZWF0dXJlcy5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAvLyBHZXQgYSB0ZW1wbGF0ZSBmcm9tIHNvbWV3aGVyZSwgZS5nLiBsaWdodCBET01cbiAqICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gKiAgICAgLy8gUHJlcGFyZSB0aGUgdGVtcGxhdGVcbiAqICAgICBsZXQgVGVtcGxhdGVDbGFzcyA9IFBvbHltZXIuVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlKTtcbiAqICAgICAvLyBJbnN0YW5jZSB0aGUgdGVtcGxhdGUgd2l0aCBhbiBpbml0aWFsIGRhdGEgbW9kZWxcbiAqICAgICBsZXQgaW5zdGFuY2UgPSBuZXcgVGVtcGxhdGVDbGFzcyh7bXlQcm9wOiAnaW5pdGlhbCd9KTtcbiAqICAgICAvLyBJbnNlcnQgdGhlIGluc3RhbmNlJ3MgRE9NIHNvbWV3aGVyZSwgZS5nLiBlbGVtZW50J3Mgc2hhZG93IERPTVxuICogICAgIHRoaXMuc2hhZG93Um9vdC5hcHBlbmRDaGlsZChpbnN0YW5jZS5yb290KTtcbiAqICAgICAvLyBDaGFuZ2luZyBhIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZSB3aWxsIHByb3BhZ2F0ZSB0byBiaW5kaW5nc1xuICogICAgIC8vIGluIHRoZSB0ZW1wbGF0ZVxuICogICAgIGluc3RhbmNlLm15UHJvcCA9ICduZXcgdmFsdWUnO1xuICpcbiAqIFRoZSBgb3B0aW9uc2AgZGljdGlvbmFyeSBwYXNzZWQgdG8gYHRlbXBsYXRpemVgIGFsbG93cyBmb3IgY3VzdG9taXppbmdcbiAqIGZlYXR1cmVzIG9mIHRoZSBnZW5lcmF0ZWQgdGVtcGxhdGUgY2xhc3MsIGluY2x1ZGluZyBob3cgb3V0ZXItc2NvcGUgaG9zdFxuICogcHJvcGVydGllcyBzaG91bGQgYmUgZm9yd2FyZGVkIGludG8gdGVtcGxhdGUgaW5zdGFuY2VzLCBob3cgYW55IGluc3RhbmNlXG4gKiBwcm9wZXJ0aWVzIGFkZGVkIGludG8gdGhlIHRlbXBsYXRlJ3Mgc2NvcGUgc2hvdWxkIGJlIG5vdGlmaWVkIG91dCB0b1xuICogdGhlIGhvc3QsIGFuZCB3aGV0aGVyIHRoZSBpbnN0YW5jZSBzaG91bGQgYmUgZGVjb3JhdGVkIGFzIGEgXCJwYXJlbnQgbW9kZWxcIlxuICogb2YgYW55IGV2ZW50IGhhbmRsZXJzLlxuICpcbiAqICAgICAvLyBDdXN0b216ZSBwcm9wZXJ0eSBmb3J3YXJkaW5nIGFuZCBldmVudCBtb2RlbCBkZWNvcmF0aW9uXG4gKiAgICAgbGV0IFRlbXBsYXRlQ2xhc3MgPSBQb2x5bWVyLlRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgdGhpcywge1xuICogICAgICAgcGFyZW50TW9kZWw6IHRydWUsXG4gKiAgICAgICBpbnN0YW5jZVByb3BzOiB7Li4ufSxcbiAqICAgICAgIGZvcndhcmRIb3N0UHJvcChwcm9wZXJ0eSwgdmFsdWUpIHsuLi59LFxuICogICAgICAgbm90aWZ5SW5zdGFuY2VQcm9wKGluc3RhbmNlLCBwcm9wZXJ0eSwgdmFsdWUpIHsuLi59LFxuICogICAgIH0pO1xuICpcbiAqXG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgTW9kdWxlIGZvciBwcmVwYXJpbmcgYW5kIHN0YW1waW5nIGluc3RhbmNlcyBvZiB0ZW1wbGF0ZXNcbiAqICAgdXRpbGl6aW5nIFBvbHltZXIgdGVtcGxhdGluZyBmZWF0dXJlcy5cbiAqL1xuXG5jb25zdCBUZW1wbGF0aXplID0ge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGFub255bW91cyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIGNsYXNzIGJvdW5kIHRvIHRoZVxuICAgKiBgPHRlbXBsYXRlPmAgcHJvdmlkZWQuICBJbnN0YW5jaW5nIHRoZSBjbGFzcyB3aWxsIHJlc3VsdCBpbiB0aGVcbiAgICogdGVtcGxhdGUgYmVpbmcgc3RhbXBlZCBpbnRvIGRvY3VtZW50IGZyYWdtZW50IHN0b3JlZCBhcyB0aGUgaW5zdGFuY2Unc1xuICAgKiBgcm9vdGAgcHJvcGVydHksIGFmdGVyIHdoaWNoIGl0IGNhbiBiZSBhcHBlbmRlZCB0byB0aGUgRE9NLlxuICAgKlxuICAgKiBUZW1wbGF0ZXMgbWF5IHV0aWxpemUgYWxsIFBvbHltZXIgZGF0YS1iaW5kaW5nIGZlYXR1cmVzIGFzIHdlbGwgYXNcbiAgICogZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLiAgRXZlbnQgbGlzdGVuZXJzIGFuZCBpbmxpbmUgY29tcHV0aW5nXG4gICAqIGZ1bmN0aW9ucyBpbiB0aGUgdGVtcGxhdGUgd2lsbCBiZSBjYWxsZWQgb24gdGhlIGhvc3Qgb2YgdGhlIHRlbXBsYXRlLlxuICAgKlxuICAgKiBUaGUgY29uc3RydWN0b3IgcmV0dXJuZWQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQgZGljdGlvbmFyeSBvZiBpbml0aWFsXG4gICAqIHByb3BlcnR5IHZhbHVlcyB0byBwcm9wYWdhdGUgaW50byB0ZW1wbGF0ZSBiaW5kaW5ncy4gIEFkZGl0aW9uYWxseVxuICAgKiBob3N0IHByb3BlcnRpZXMgY2FuIGJlIGZvcndhcmRlZCBpbiwgYW5kIGluc3RhbmNlIHByb3BlcnRpZXMgY2FuIGJlXG4gICAqIG5vdGlmaWVkIG91dCBieSBwcm92aWRpbmcgb3B0aW9uYWwgY2FsbGJhY2tzIGluIHRoZSBgb3B0aW9uc2AgZGljdGlvbmFyeS5cbiAgICpcbiAgICogVmFsaWQgY29uZmlndXJhdGlvbiBpbiBgb3B0aW9uc2AgYXJlIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqIC0gYGZvcndhcmRIb3N0UHJvcChwcm9wZXJ0eSwgdmFsdWUpYDogQ2FsbGVkIHdoZW4gYSBwcm9wZXJ0eSByZWZlcmVuY2VkXG4gICAqICAgaW4gdGhlIHRlbXBsYXRlIGNoYW5nZWQgb24gdGhlIHRlbXBsYXRlJ3MgaG9zdC4gQXMgdGhpcyBsaWJyYXJ5IGRvZXNcbiAgICogICBub3QgcmV0YWluIHJlZmVyZW5jZXMgdG8gdGVtcGxhdGVzIGluc3RhbmNlZCBieSB0aGUgdXNlciwgaXQgaXMgdGhlXG4gICAqICAgdGVtcGxhdGl6ZSBvd25lcidzIHJlc3BvbnNpYmlsaXR5IHRvIGZvcndhcmQgaG9zdCBwcm9wZXJ0eSBjaGFuZ2VzIGludG9cbiAgICogICB1c2VyLXN0YW1wZWQgaW5zdGFuY2VzLiAgVGhlIGBpbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKWBcbiAgICogICAgbWV0aG9kIG9uIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgc2hvdWxkIGJlIGNhbGxlZCB0byBmb3J3YXJkIGhvc3RcbiAgICogICBwcm9wZXJ0aWVzIGludG8gdGhlIHRlbXBsYXRlIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcHJvcGVydHktY2hhbmdlZFxuICAgKiAgIG5vdGlmaWNhdGlvbnMuIEFueSBwcm9wZXJ0aWVzIHJlZmVyZW5jZWQgaW4gdGhlIHRlbXBsYXRlIHRoYXQgYXJlIG5vdFxuICAgKiAgIGRlZmluZWQgaW4gYGluc3RhbmNlUHJvcHNgIHdpbGwgYmUgbm90aWZpZWQgdXAgdG8gdGhlIHRlbXBsYXRlJ3MgaG9zdFxuICAgKiAgIGF1dG9tYXRpY2FsbHkuXG4gICAqIC0gYGluc3RhbmNlUHJvcHNgOiBEaWN0aW9uYXJ5IG9mIHByb3BlcnR5IG5hbWVzIHRoYXQgd2lsbCBiZSBhZGRlZFxuICAgKiAgIHRvIHRoZSBpbnN0YW5jZSBieSB0aGUgdGVtcGxhdGl6ZSBvd25lci4gIFRoZXNlIHByb3BlcnRpZXMgc2hhZG93IGFueVxuICAgKiAgIGhvc3QgcHJvcGVydGllcywgYW5kIGNoYW5nZXMgd2l0aGluIHRoZSB0ZW1wbGF0ZSB0byB0aGVzZSBwcm9wZXJ0aWVzXG4gICAqICAgd2lsbCByZXN1bHQgaW4gYG5vdGlmeUluc3RhbmNlUHJvcGAgYmVpbmcgY2FsbGVkLlxuICAgKiAtIGBtdXRhYmxlRGF0YWA6IFdoZW4gYHRydWVgLCB0aGUgZ2VuZXJhdGVkIGNsYXNzIHdpbGwgc2tpcCBzdHJpY3RcbiAgICogICBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0byBiZVxuICAgKiAgIFwiZGlydHlcIikuXG4gICAqIC0gYG5vdGlmeUluc3RhbmNlUHJvcChpbnN0YW5jZSwgcHJvcGVydHksIHZhbHVlKWA6IENhbGxlZCB3aGVuXG4gICAqICAgYW4gaW5zdGFuY2UgcHJvcGVydHkgY2hhbmdlcy4gIFVzZXJzIG1heSBjaG9vc2UgdG8gY2FsbCBgbm90aWZ5UGF0aGBcbiAgICogICBvbiBlLmcuIHRoZSBvd25lciB0byBub3RpZnkgdGhlIGNoYW5nZS5cbiAgICogLSBgcGFyZW50TW9kZWxgOiBXaGVuIGB0cnVlYCwgZXZlbnRzIGhhbmRsZWQgYnkgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzXG4gICAqICAgKGBvbi1ldmVudD1cImhhbmRsZXJcImApIHdpbGwgYmUgZGVjb3JhdGVkIHdpdGggYSBgbW9kZWxgIHByb3BlcnR5IHBvaW50aW5nXG4gICAqICAgdG8gdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRoYXQgc3RhbXBlZCBpdC4gIEl0IHdpbGwgYWxzbyBiZSByZXR1cm5lZFxuICAgKiAgIGZyb20gYGluc3RhbmNlLnBhcmVudE1vZGVsYCBpbiBjYXNlcyB3aGVyZSB0ZW1wbGF0ZSBpbnN0YW5jZSBuZXN0aW5nXG4gICAqICAgY2F1c2VzIGFuIGlubmVyIG1vZGVsIHRvIHNoYWRvdyBhbiBvdXRlciBtb2RlbC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjbGFzcyByZXR1cm5lZCBmcm9tIGB0ZW1wbGF0aXplYCBpcyBnZW5lcmF0ZWQgb25seSBvbmNlXG4gICAqIGZvciBhIGdpdmVuIGA8dGVtcGxhdGU+YCB1c2luZyBgb3B0aW9uc2AgZnJvbSB0aGUgZmlyc3QgY2FsbCBmb3IgdGhhdFxuICAgKiB0ZW1wbGF0ZSwgYW5kIHRoZSBjYWNoZWQgY2xhc3MgaXMgcmV0dXJuZWQgZm9yIGFsbCBzdWJzZXF1ZW50IGNhbGxzIHRvXG4gICAqIGB0ZW1wbGF0aXplYCBmb3IgdGhhdCB0ZW1wbGF0ZS4gIEFzIHN1Y2gsIGBvcHRpb25zYCBjYWxsYmFja3Mgc2hvdWxkIG5vdFxuICAgKiBjbG9zZSBvdmVyIG93bmVyLXNwZWNpZmljIHByb3BlcnRpZXMgc2luY2Ugb25seSB0aGUgZmlyc3QgYG9wdGlvbnNgIGlzXG4gICAqIHVzZWQ7IHJhdGhlciwgY2FsbGJhY2tzIGFyZSBjYWxsZWQgYm91bmQgdG8gdGhlIGBvd25lcmAsIGFuZCBzbyBjb250ZXh0XG4gICAqIG5lZWRlZCBmcm9tIHRoZSBjYWxsYmFja3MgKHN1Y2ggYXMgcmVmZXJlbmNlcyB0byBgaW5zdGFuY2VzYCBzdGFtcGVkKVxuICAgKiBzaG91bGQgYmUgc3RvcmVkIG9uIHRoZSBgb3duZXJgIHN1Y2ggdGhhdCB0aGV5IGNhbiBiZSByZXRyaWV2ZWQgdmlhIGB0aGlzYC5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuVGVtcGxhdGl6ZVxuICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byB0ZW1wbGF0aXplXG4gICAqIEBwYXJhbSB7IVBvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBvd25lciBPd25lciBvZiB0aGUgdGVtcGxhdGUgaW5zdGFuY2VzO1xuICAgKiAgIGFueSBvcHRpb25hbCBjYWxsYmFja3Mgd2lsbCBiZSBib3VuZCB0byB0aGlzIG93bmVyLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgT3B0aW9ucyBkaWN0aW9uYXJ5IChzZWUgc3VtbWFyeSBmb3IgZGV0YWlscylcbiAgICogQHJldHVybiB7ZnVuY3Rpb24obmV3OlRlbXBsYXRlSW5zdGFuY2VCYXNlKX0gR2VuZXJhdGVkIGNsYXNzIGJvdW5kIHRvIHRoZSB0ZW1wbGF0ZVxuICAgKiAgIHByb3ZpZGVkXG4gICAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICAgKi9cbiAgdGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgb3duZXIsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gLyoqIEB0eXBlIHshVGVtcGxhdGl6ZU9wdGlvbnN9ICovKG9wdGlvbnMgfHwge30pO1xuICAgIGlmICh0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIDx0ZW1wbGF0ZT4gY2FuIG9ubHkgYmUgdGVtcGxhdGl6ZWQgb25jZScpO1xuICAgIH1cbiAgICB0ZW1wbGF0ZS5fX3RlbXBsYXRpemVPd25lciA9IG93bmVyO1xuICAgIGxldCB0ZW1wbGF0ZUluZm8gPSBvd25lci5jb25zdHJ1Y3Rvci5fcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgLy8gR2V0IG1lbW9pemVkIGJhc2UgY2xhc3MgZm9yIHRoZSBwcm90b3R5cGljYWwgdGVtcGxhdGUsIHdoaWNoXG4gICAgLy8gaW5jbHVkZXMgcHJvcGVydHkgZWZmZWN0cyBmb3IgYmluZGluZyB0ZW1wbGF0ZSAmIGZvcndhcmRpbmdcbiAgICBsZXQgYmFzZUNsYXNzID0gdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVJbnN0YW5jZUNsYXNzO1xuICAgIGlmICghYmFzZUNsYXNzKSB7XG4gICAgICBiYXNlQ2xhc3MgPSBjcmVhdGVUZW1wbGF0aXplckNsYXNzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgICAgdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVJbnN0YW5jZUNsYXNzID0gYmFzZUNsYXNzO1xuICAgIH1cbiAgICAvLyBIb3N0IHByb3BlcnR5IGZvcndhcmRpbmcgbXVzdCBiZSBpbnN0YWxsZWQgb250byB0ZW1wbGF0ZSBpbnN0YW5jZVxuICAgIGFkZFByb3BhZ2F0ZUVmZmVjdHModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucyk7XG4gICAgLy8gU3ViY2xhc3MgYmFzZSBjbGFzcyBhbmQgYWRkIHJlZmVyZW5jZSBmb3IgdGhpcyBzcGVjaWZpYyB0ZW1wbGF0ZVxuICAgIGxldCBrbGFzcyA9IGNsYXNzIFRlbXBsYXRlSW5zdGFuY2UgZXh0ZW5kcyBiYXNlQ2xhc3Mge307XG4gICAga2xhc3MucHJvdG90eXBlLl9tZXRob2RIb3N0ID0gZmluZE1ldGhvZEhvc3QodGVtcGxhdGUpO1xuICAgIGtsYXNzLnByb3RvdHlwZS5fX2RhdGFIb3N0ID0gdGVtcGxhdGU7XG4gICAga2xhc3MucHJvdG90eXBlLl9fdGVtcGxhdGl6ZU93bmVyID0gb3duZXI7XG4gICAga2xhc3MucHJvdG90eXBlLl9faG9zdFByb3BzID0gdGVtcGxhdGVJbmZvLmhvc3RQcm9wcztcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtmdW5jdGlvbihuZXc6VGVtcGxhdGVJbnN0YW5jZUJhc2UpfSAqLyhrbGFzcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50LCB3aGljaFxuICAgKiBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGUgZWxlbWVudCBpc1xuICAgKiBjb250YWluZWQgaW4uIEEgdGVtcGxhdGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2ZcbiAgICogYFRlbXBsYXRlSW5zdGFuY2VCYXNlYCwgYW5kIHNob3VsZCBiZSB1c2VkIHRvIG1hbmlwdWxhdGUgZGF0YVxuICAgKiBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogRXhhbXBsZTpcbiAgICpcbiAgICogICBsZXQgbW9kZWwgPSBtb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgKiAgIGlmIChtb2RlbC5pbmRleCA8IDEwKSB7XG4gICAqICAgICBtb2RlbC5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuVGVtcGxhdGl6ZVxuICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRoZSBtb2RlbCB3aWxsIGJlIHJldHVybmVkIGZvclxuICAgKiAgIGVsZW1lbnRzIHN0YW1wZWQgZnJvbSB0aGlzIHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IFRlbXBsYXRlIGluc3RhbmNlIHJlcHJlc2VudGluZyB0aGVcbiAgICogICBiaW5kaW5nIHNjb3BlIGZvciB0aGUgZWxlbWVudFxuICAgKi9cbiAgbW9kZWxGb3JFbGVtZW50KHRlbXBsYXRlLCBub2RlKSB7XG4gICAgbGV0IG1vZGVsO1xuICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAvLyBBbiBlbGVtZW50IHdpdGggYSBfX3RlbXBsYXRpemVJbnN0YW5jZSBtYXJrcyB0aGUgdG9wIGJvdW5kYXJ5XG4gICAgICAvLyBvZiBhIHNjb3BlOyB3YWxrIHVwIHVudGlsIHdlIGZpbmQgb25lLCBhbmQgdGhlbiBlbnN1cmUgdGhhdFxuICAgICAgLy8gaXRzIF9fZGF0YUhvc3QgbWF0Y2hlcyBgdGhpc2AsIG1lYW5pbmcgdGhpcyBkb20tcmVwZWF0IHN0YW1wZWQgaXRcbiAgICAgIGlmICgobW9kZWwgPSBub2RlLl9fdGVtcGxhdGl6ZUluc3RhbmNlKSkge1xuICAgICAgICAvLyBGb3VuZCBhbiBlbGVtZW50IHN0YW1wZWQgYnkgYW5vdGhlciB0ZW1wbGF0ZTsga2VlcCB3YWxraW5nIHVwXG4gICAgICAgIC8vIGZyb20gaXRzIF9fZGF0YUhvc3RcbiAgICAgICAgaWYgKG1vZGVsLl9fZGF0YUhvc3QgIT0gdGVtcGxhdGUpIHtcbiAgICAgICAgICBub2RlID0gbW9kZWwuX19kYXRhSG9zdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFN0aWxsIGluIGEgdGVtcGxhdGUgc2NvcGUsIGtlZXAgZ29pbmcgdXAgdW50aWxcbiAgICAgICAgLy8gYSBfX3RlbXBsYXRpemVJbnN0YW5jZSBpcyBmb3VuZFxuICAgICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufTtcblxuZXhwb3J0IHsgVGVtcGxhdGl6ZSB9O1xuZXhwb3J0IHsgVGVtcGxhdGVJbnN0YW5jZUJhc2UgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3RlbXBsYXRpemUuanNcbi8vIG1vZHVsZSBpZCA9IDI5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25BMTF5S2V5c0JlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuanMnO1xuaW1wb3J0ICcuL2lyb24tY29udHJvbC1zdGF0ZS5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbkJ1dHRvblN0YXRlSW1wbCA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgdXNlciBpcyBjdXJyZW50bHkgaG9sZGluZyBkb3duIHRoZSBidXR0b24uXG4gICAgICovXG4gICAgcHJlc3NlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgb2JzZXJ2ZXI6ICdfcHJlc3NlZENoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBidXR0b24gdG9nZ2xlcyB0aGUgYWN0aXZlIHN0YXRlIHdpdGggZWFjaCB0YXAgb3IgcHJlc3NcbiAgICAgKiBvZiB0aGUgc3BhY2ViYXIuXG4gICAgICovXG4gICAgdG9nZ2xlczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIGlzIGEgdG9nZ2xlIGFuZCBpcyBjdXJyZW50bHkgaW4gdGhlIGFjdGl2ZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBhY3RpdmU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgZWxlbWVudCBpcyBjdXJyZW50bHkgYmVpbmcgcHJlc3NlZCBieSBhIFwicG9pbnRlcixcIiB3aGljaFxuICAgICAqIGlzIGxvb3NlbHkgZGVmaW5lZCBhcyBtb3VzZSBvciB0b3VjaCBpbnB1dCAoYnV0IHNwZWNpZmljYWxseSBleGNsdWRpbmdcbiAgICAgKiBrZXlib2FyZCBpbnB1dCkuXG4gICAgICovXG4gICAgcG9pbnRlckRvd246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBpbnB1dCBkZXZpY2UgdGhhdCBjYXVzZWQgdGhlIGVsZW1lbnQgdG8gcmVjZWl2ZSBmb2N1c1xuICAgICAqIHdhcyBhIGtleWJvYXJkLlxuICAgICAqL1xuICAgIHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZWFkT25seTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXJpYSBhdHRyaWJ1dGUgdG8gYmUgc2V0IGlmIHRoZSBidXR0b24gaXMgYSB0b2dnbGUgYW5kIGluIHRoZVxuICAgICAqIGFjdGl2ZSBzdGF0ZS5cbiAgICAgKi9cbiAgICBhcmlhQWN0aXZlQXR0cmlidXRlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2FyaWEtcHJlc3NlZCcsXG4gICAgICBvYnNlcnZlcjogJ19hcmlhQWN0aXZlQXR0cmlidXRlQ2hhbmdlZCdcbiAgICB9XG4gIH0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgZG93bjogJ19kb3duSGFuZGxlcicsXG4gICAgdXA6ICdfdXBIYW5kbGVyJyxcbiAgICB0YXA6ICdfdGFwSGFuZGxlcidcbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX2ZvY3VzQ2hhbmdlZChmb2N1c2VkKScsXG4gICAgJ19hY3RpdmVDaGFuZ2VkKGFjdGl2ZSwgYXJpYUFjdGl2ZUF0dHJpYnV0ZSknXG4gIF0sXG5cbiAga2V5QmluZGluZ3M6IHtcbiAgICAnZW50ZXI6a2V5ZG93bic6ICdfYXN5bmNDbGljaycsXG4gICAgJ3NwYWNlOmtleWRvd24nOiAnX3NwYWNlS2V5RG93bkhhbmRsZXInLFxuICAgICdzcGFjZTprZXl1cCc6ICdfc3BhY2VLZXlVcEhhbmRsZXInLFxuICB9LFxuXG4gIF9tb3VzZUV2ZW50UmU6IC9ebW91c2UvLFxuXG4gIF90YXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy50b2dnbGVzKSB7XG4gICAgIC8vIGEgdGFwIGlzIG5lZWRlZCB0byB0b2dnbGUgdGhlIGFjdGl2ZSBzdGF0ZVxuICAgICAgdGhpcy5fdXNlckFjdGl2YXRlKCF0aGlzLmFjdGl2ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICB9LFxuXG4gIF9mb2N1c0NoYW5nZWQ6IGZ1bmN0aW9uKGZvY3VzZWQpIHtcbiAgICB0aGlzLl9kZXRlY3RLZXlib2FyZEZvY3VzKGZvY3VzZWQpO1xuXG4gICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2RldGVjdEtleWJvYXJkRm9jdXM6IGZ1bmN0aW9uKGZvY3VzZWQpIHtcbiAgICB0aGlzLl9zZXRSZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKCF0aGlzLnBvaW50ZXJEb3duICYmIGZvY3VzZWQpO1xuICB9LFxuXG4gIC8vIHRvIGVtdWxhdGUgbmF0aXZlIGNoZWNrYm94LCAoZGUtKWFjdGl2YXRpb25zIGZyb20gYSB1c2VyIGludGVyYWN0aW9uIGZpcmVcbiAgLy8gJ2NoYW5nZScgZXZlbnRzXG4gIF91c2VyQWN0aXZhdGU6IGZ1bmN0aW9uKGFjdGl2ZSkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSAhPT0gYWN0aXZlKSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGFjdGl2ZTtcbiAgICAgIHRoaXMuZmlyZSgnY2hhbmdlJyk7XG4gICAgfVxuICB9LFxuXG4gIF9kb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB0aGlzLl9zZXRQb2ludGVyRG93bih0cnVlKTtcbiAgICB0aGlzLl9zZXRQcmVzc2VkKHRydWUpO1xuICAgIHRoaXMuX3NldFJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQoZmFsc2UpO1xuICB9LFxuXG4gIF91cEhhbmRsZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NldFBvaW50ZXJEb3duKGZhbHNlKTtcbiAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHshS2V5Ym9hcmRFdmVudH0gZXZlbnQgLlxuICAgKi9cbiAgX3NwYWNlS2V5RG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGtleWJvYXJkRXZlbnQgPSBldmVudC5kZXRhaWwua2V5Ym9hcmRFdmVudDtcbiAgICB2YXIgdGFyZ2V0ID0gZG9tKGtleWJvYXJkRXZlbnQpLmxvY2FsVGFyZ2V0O1xuXG4gICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiB0aGlzIGlzIGNvbWluZyBmcm9tIGEgZm9jdXNlZCBsaWdodCBjaGlsZCwgc2luY2UgdGhhdFxuICAgIC8vIGVsZW1lbnQgd2lsbCBkZWFsIHdpdGggaXQuXG4gICAgaWYgKHRoaXMuaXNMaWdodERlc2NlbmRhbnQoLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSlcbiAgICAgIHJldHVybjtcblxuICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBrZXlib2FyZEV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgIHRoaXMuX3NldFByZXNzZWQodHJ1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGV2ZW50IC5cbiAgICovXG4gIF9zcGFjZUtleVVwSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIga2V5Ym9hcmRFdmVudCA9IGV2ZW50LmRldGFpbC5rZXlib2FyZEV2ZW50O1xuICAgIHZhciB0YXJnZXQgPSBkb20oa2V5Ym9hcmRFdmVudCkubG9jYWxUYXJnZXQ7XG5cbiAgICAvLyBJZ25vcmUgdGhlIGV2ZW50IGlmIHRoaXMgaXMgY29taW5nIGZyb20gYSBmb2N1c2VkIGxpZ2h0IGNoaWxkLCBzaW5jZSB0aGF0XG4gICAgLy8gZWxlbWVudCB3aWxsIGRlYWwgd2l0aCBpdC5cbiAgICBpZiAodGhpcy5pc0xpZ2h0RGVzY2VuZGFudCgvKiogQHR5cGUge05vZGV9ICovKHRhcmdldCkpKVxuICAgICAgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMucHJlc3NlZCkge1xuICAgICAgdGhpcy5fYXN5bmNDbGljaygpO1xuICAgIH1cbiAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgfSxcblxuICAvLyB0cmlnZ2VyIGNsaWNrIGFzeW5jaHJvbm91c2x5LCB0aGUgYXN5bmNocm9ueSBpcyB1c2VmdWwgdG8gYWxsb3cgb25lXG4gIC8vIGV2ZW50IGhhbmRsZXIgdG8gdW53aW5kIGJlZm9yZSB0cmlnZ2VyaW5nIGFub3RoZXIgZXZlbnRcbiAgX2FzeW5jQ2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNsaWNrKCk7XG4gICAgfSwgMSk7XG4gIH0sXG5cbiAgLy8gYW55IG9mIHRoZXNlIGNoYW5nZXMgYXJlIGNvbnNpZGVyZWQgYSBjaGFuZ2UgdG8gYnV0dG9uIHN0YXRlXG5cbiAgX3ByZXNzZWRDaGFuZ2VkOiBmdW5jdGlvbihwcmVzc2VkKSB7XG4gICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gIH0sXG5cbiAgX2FyaWFBY3RpdmVBdHRyaWJ1dGVDaGFuZ2VkOiBmdW5jdGlvbih2YWx1ZSwgb2xkVmFsdWUpIHtcbiAgICBpZiAob2xkVmFsdWUgJiYgb2xkVmFsdWUgIT0gdmFsdWUgJiYgdGhpcy5oYXNBdHRyaWJ1dGUob2xkVmFsdWUpKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShvbGRWYWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9hY3RpdmVDaGFuZ2VkOiBmdW5jdGlvbihhY3RpdmUsIGFyaWFBY3RpdmVBdHRyaWJ1dGUpIHtcbiAgICBpZiAodGhpcy50b2dnbGVzKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSh0aGlzLmFyaWFBY3RpdmVBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUodGhpcy5hcmlhQWN0aXZlQXR0cmlidXRlKTtcbiAgICB9XG4gICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gIH0sXG5cbiAgX2NvbnRyb2xTdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICB0aGlzLl9zZXRQcmVzc2VkKGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2hhbmdlZEJ1dHRvblN0YXRlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8vIHByb3ZpZGUgaG9vayBmb3IgZm9sbG93LW9uIGJlaGF2aW9ycyB0byByZWFjdCB0byBidXR0b24tc3RhdGVcblxuICBfY2hhbmdlZEJ1dHRvblN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fYnV0dG9uU3RhdGVDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9idXR0b25TdGF0ZUNoYW5nZWQoKTsgLy8gYWJzdHJhY3RcbiAgICB9XG4gIH1cblxufTtcblxuZXhwb3J0IGNvbnN0IElyb25CdXR0b25TdGF0ZSA9IFtcbiAgSXJvbkExMXlLZXlzQmVoYXZpb3IsXG4gIElyb25CdXR0b25TdGF0ZUltcGxcbl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5qc1xuLy8gbW9kdWxlIGlkID0gMzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0IGZ1bmN0aW9uIGFqYXgodXJsLCBkYXRhLCBtZXRob2QsIGhlYWRlcnMsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICB2YXIgY29uZmlnID0ge21ldGhvZDogbWV0aG9kLCBoZWFkZXJzOiBoZWFkZXJzfTtcbiAgaWYgKHR5cGVvZiBkYXRhICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjb25maWcuYm9keSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICB9XG4gIGZldGNoKHVybCwgY29uZmlnKVxuICAudGhlbihyZXNwb25zZSA9PiB7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdGYWlsZWQgdG8gcG9zdCBkYXRhJykpO1xuICAgIH1cbiAgfSlcbiAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuanNvbigpKSAvLyBwYXJzZSByZXNwb25zZSBhcyBKU09OXG4gIC50aGVuKGRhdGEgPT4ge1xuICAgIGlmICh0eXBlb2Ygc3VjY2Vzc0NhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHN1Y2Nlc3NDYWxsYmFjayhkYXRhKTtcbiAgICB9XG4gIH0pXG4gIC5jYXRjaChmdW5jdGlvbihlcnJvcikge1xuICAgIGNvbnNvbGUubG9nKGBFcnJvcjogJHtlcnJvci5tZXNzYWdlfWApO1xuICAgIGlmICh0eXBlb2YgZXJyb3JDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBlcnJvckNhbGxiYWNrKGVycm9yKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWpheEdldCh1cmwsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGFqYXgodXJsLCB1bmRlZmluZWQsIFwiR0VUXCIsIGhlYWRlcnMsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhamF4UG9zdCh1cmwsIGRhdGEsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGhlYWRlcnMuYXBwZW5kKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgYWpheCh1cmwsIGRhdGEsIFwiUE9TVFwiLCBoZWFkZXJzLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWpheFB1dCh1cmwsIGRhdGEsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjaykge1xuICB2YXIgaGVhZGVycyA9IG5ldyBIZWFkZXJzKCk7XG4gIGhlYWRlcnMuYXBwZW5kKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgYWpheCh1cmwsIGRhdGEsIFwiUFVUXCIsIGhlYWRlcnMsIHN1Y2Nlc3NDYWxsYmFjaywgZXJyb3JDYWxsYmFjayk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhamF4RGVsZXRlKHVybCwgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gIHZhciBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgYWpheCh1cmwsIHVuZGVmaW5lZCwgXCJERUxFVEVcIiwgaGVhZGVycywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3RhY3RpbGUvY2xpZW50L2FqYXguanMiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQTExeUtleXNCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuXG52YXIgVXRpbGl0eSA9IHtcbiAgZGlzdGFuY2U6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIHhEZWx0YSA9ICh4MSAtIHgyKTtcbiAgICB2YXIgeURlbHRhID0gKHkxIC0geTIpO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCh4RGVsdGEgKiB4RGVsdGEgKyB5RGVsdGEgKiB5RGVsdGEpO1xuICB9LFxuXG4gIG5vdzogd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgP1xuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vd1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRWxlbWVudE1ldHJpY3MoZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLndpZHRoID0gdGhpcy5ib3VuZGluZ1JlY3Qud2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3VuZGluZ1JlY3QuaGVpZ2h0O1xuXG4gIHRoaXMuc2l6ZSA9IE1hdGgubWF4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn1cblxuRWxlbWVudE1ldHJpY3MucHJvdG90eXBlID0ge1xuICBnZXQgYm91bmRpbmdSZWN0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9LFxuXG4gIGZ1cnRoZXN0Q29ybmVyRGlzdGFuY2VGcm9tOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHRvcExlZnQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIDAsIDApO1xuICAgIHZhciB0b3BSaWdodCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgdGhpcy53aWR0aCwgMCk7XG4gICAgdmFyIGJvdHRvbUxlZnQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIDAsIHRoaXMuaGVpZ2h0KTtcbiAgICB2YXIgYm90dG9tUmlnaHQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIHJldHVybiBNYXRoLm1heCh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSaXBwbGUoZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmNvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuY29sb3I7XG5cbiAgdGhpcy53YXZlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMud2F2ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLndhdmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgdGhpcy53YXZlLmNsYXNzTGlzdC5hZGQoJ3dhdmUnKTtcbiAgdGhpcy53YXZlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3dhdmUtY29udGFpbmVyJyk7XG4gIGRvbSh0aGlzLndhdmVDb250YWluZXIpLmFwcGVuZENoaWxkKHRoaXMud2F2ZSk7XG5cbiAgdGhpcy5yZXNldEludGVyYWN0aW9uU3RhdGUoKTtcbn1cblxuUmlwcGxlLk1BWF9SQURJVVMgPSAzMDA7XG5cblJpcHBsZS5wcm90b3R5cGUgPSB7XG4gIGdldCByZWNlbnRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5yZWNlbnRlcnM7XG4gIH0sXG5cbiAgZ2V0IGNlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNlbnRlcjtcbiAgfSxcblxuICBnZXQgbW91c2VEb3duRWxhcHNlZCgpIHtcbiAgICB2YXIgZWxhcHNlZDtcblxuICAgIGlmICghdGhpcy5tb3VzZURvd25TdGFydCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZWxhcHNlZCA9IFV0aWxpdHkubm93KCkgLSB0aGlzLm1vdXNlRG93blN0YXJ0O1xuXG4gICAgaWYgKHRoaXMubW91c2VVcFN0YXJ0KSB7XG4gICAgICBlbGFwc2VkIC09IHRoaXMubW91c2VVcEVsYXBzZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsYXBzZWQ7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlVXBFbGFwc2VkKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlVXBTdGFydCA/XG4gICAgICBVdGlsaXR5Lm5vdyAoKSAtIHRoaXMubW91c2VVcFN0YXJ0IDogMDtcbiAgfSxcblxuICBnZXQgbW91c2VEb3duRWxhcHNlZFNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VEb3duRWxhcHNlZCAvIDEwMDA7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlVXBFbGFwc2VkU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZVVwRWxhcHNlZCAvIDEwMDA7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlSW50ZXJhY3Rpb25TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlRG93bkVsYXBzZWRTZWNvbmRzICsgdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHM7XG4gIH0sXG5cbiAgZ2V0IGluaXRpYWxPcGFjaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaW5pdGlhbE9wYWNpdHk7XG4gIH0sXG5cbiAgZ2V0IG9wYWNpdHlEZWNheVZlbG9jaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQub3BhY2l0eURlY2F5VmVsb2NpdHk7XG4gIH0sXG5cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICB2YXIgd2lkdGgyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoICogdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoO1xuICAgIHZhciBoZWlnaHQyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAqIHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQ7XG4gICAgdmFyIHdhdmVSYWRpdXMgPSBNYXRoLm1pbihcbiAgICAgIE1hdGguc3FydCh3aWR0aDIgKyBoZWlnaHQyKSxcbiAgICAgIFJpcHBsZS5NQVhfUkFESVVTXG4gICAgKSAqIDEuMSArIDU7XG5cbiAgICB2YXIgZHVyYXRpb24gPSAxLjEgLSAwLjIgKiAod2F2ZVJhZGl1cyAvIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgICB2YXIgdGltZU5vdyA9IHRoaXMubW91c2VJbnRlcmFjdGlvblNlY29uZHMgLyBkdXJhdGlvbjtcbiAgICB2YXIgc2l6ZSA9IHdhdmVSYWRpdXMgKiAoMSAtIE1hdGgucG93KDgwLCAtdGltZU5vdykpO1xuXG4gICAgcmV0dXJuIE1hdGguYWJzKHNpemUpO1xuICB9LFxuXG4gIGdldCBvcGFjaXR5KCkge1xuICAgIGlmICghdGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxPcGFjaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgIDAsXG4gICAgICB0aGlzLmluaXRpYWxPcGFjaXR5IC0gdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHMgKiB0aGlzLm9wYWNpdHlEZWNheVZlbG9jaXR5XG4gICAgKTtcbiAgfSxcblxuICBnZXQgb3V0ZXJPcGFjaXR5KCkge1xuICAgIC8vIExpbmVhciBpbmNyZWFzZSBpbiBiYWNrZ3JvdW5kIG9wYWNpdHksIGNhcHBlZCBhdCB0aGUgb3BhY2l0eVxuICAgIC8vIG9mIHRoZSB3YXZlZnJvbnQgKHdhdmVPcGFjaXR5KS5cbiAgICB2YXIgb3V0ZXJPcGFjaXR5ID0gdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHMgKiAwLjM7XG4gICAgdmFyIHdhdmVPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgMCxcbiAgICAgIE1hdGgubWluKG91dGVyT3BhY2l0eSwgd2F2ZU9wYWNpdHkpXG4gICAgKTtcbiAgfSxcblxuICBnZXQgaXNPcGFjaXR5RnVsbHlEZWNheWVkKCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPCAwLjAxICYmXG4gICAgICB0aGlzLnJhZGl1cyA+PSBNYXRoLm1pbih0aGlzLm1heFJhZGl1cywgUmlwcGxlLk1BWF9SQURJVVMpO1xuICB9LFxuXG4gIGdldCBpc1Jlc3RpbmdBdE1heFJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID49IHRoaXMuaW5pdGlhbE9wYWNpdHkgJiZcbiAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gIH0sXG5cbiAgZ2V0IGlzQW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgIHRoaXMuaXNPcGFjaXR5RnVsbHlEZWNheWVkIDogdGhpcy5pc1Jlc3RpbmdBdE1heFJhZGl1cztcbiAgfSxcblxuICBnZXQgdHJhbnNsYXRpb25GcmFjdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICAxLFxuICAgICAgdGhpcy5yYWRpdXMgLyB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAqIDIgLyBNYXRoLnNxcnQoMilcbiAgICApO1xuICB9LFxuXG4gIGdldCB4Tm93KCkge1xuICAgIGlmICh0aGlzLnhFbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnhTdGFydCArIHRoaXMudHJhbnNsYXRpb25GcmFjdGlvbiAqICh0aGlzLnhFbmQgLSB0aGlzLnhTdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMueFN0YXJ0O1xuICB9LFxuXG4gIGdldCB5Tm93KCkge1xuICAgIGlmICh0aGlzLnlFbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnlTdGFydCArIHRoaXMudHJhbnNsYXRpb25GcmFjdGlvbiAqICh0aGlzLnlFbmQgLSB0aGlzLnlTdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMueVN0YXJ0O1xuICB9LFxuXG4gIGdldCBpc01vdXNlRG93bigpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZURvd25TdGFydCAmJiAhdGhpcy5tb3VzZVVwU3RhcnQ7XG4gIH0sXG5cbiAgcmVzZXRJbnRlcmFjdGlvblN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1heFJhZGl1cyA9IDA7XG4gICAgdGhpcy5tb3VzZURvd25TdGFydCA9IDA7XG4gICAgdGhpcy5tb3VzZVVwU3RhcnQgPSAwO1xuXG4gICAgdGhpcy54U3RhcnQgPSAwO1xuICAgIHRoaXMueVN0YXJ0ID0gMDtcbiAgICB0aGlzLnhFbmQgPSAwO1xuICAgIHRoaXMueUVuZCA9IDA7XG4gICAgdGhpcy5zbGlkZURpc3RhbmNlID0gMDtcblxuICAgIHRoaXMuY29udGFpbmVyTWV0cmljcyA9IG5ldyBFbGVtZW50TWV0cmljcyh0aGlzLmVsZW1lbnQpO1xuICB9LFxuXG4gIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZTtcbiAgICB2YXIgdHJhbnNsYXRlU3RyaW5nO1xuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG5cbiAgICB0aGlzLndhdmUuc3R5bGUub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblxuICAgIHNjYWxlID0gdGhpcy5yYWRpdXMgLyAodGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgLyAyKTtcbiAgICBkeCA9IHRoaXMueE5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyKTtcbiAgICBkeSA9IHRoaXMueU5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMik7XG5cblxuICAgIC8vIDJkIHRyYW5zZm9ybSBmb3Igc2FmYXJpIGJlY2F1c2Ugb2YgYm9yZGVyLXJhZGl1cyBhbmQgb3ZlcmZsb3c6aGlkZGVuIGNsaXBwaW5nIGJ1Zy5cbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTg1MzhcbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZHggKyAncHgsICcgKyBkeSArICdweCknO1xuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoJyArIGR4ICsgJ3B4LCAnICsgZHkgKyAncHgsIDApJztcbiAgICB0aGlzLndhdmUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKCcgKyBzY2FsZSArICcsJyArIHNjYWxlICsgJyknO1xuICAgIHRoaXMud2F2ZS5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUzZCgnICsgc2NhbGUgKyAnLCcgKyBzY2FsZSArICcsMSknO1xuICB9LFxuXG4gIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgZG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgeENlbnRlciA9IHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDI7XG4gICAgdmFyIHlDZW50ZXIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMjtcblxuICAgIHRoaXMucmVzZXRJbnRlcmFjdGlvblN0YXRlKCk7XG4gICAgdGhpcy5tb3VzZURvd25TdGFydCA9IFV0aWxpdHkubm93KCk7XG5cbiAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgIHRoaXMueFN0YXJ0ID0geENlbnRlcjtcbiAgICAgIHRoaXMueVN0YXJ0ID0geUNlbnRlcjtcbiAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IFV0aWxpdHkuZGlzdGFuY2UoXG4gICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueFN0YXJ0ID0gZXZlbnQgP1xuICAgICAgICAgIGV2ZW50LmRldGFpbC54IC0gdGhpcy5jb250YWluZXJNZXRyaWNzLmJvdW5kaW5nUmVjdC5sZWZ0IDpcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyO1xuICAgICAgdGhpcy55U3RhcnQgPSBldmVudCA/XG4gICAgICAgICAgZXZlbnQuZGV0YWlsLnkgLSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuYm91bmRpbmdSZWN0LnRvcCA6XG4gICAgICAgICAgdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVjZW50ZXJzKSB7XG4gICAgICB0aGlzLnhFbmQgPSB4Q2VudGVyO1xuICAgICAgdGhpcy55RW5kID0geUNlbnRlcjtcbiAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IFV0aWxpdHkuZGlzdGFuY2UoXG4gICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXhSYWRpdXMgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb20oXG4gICAgICB0aGlzLnhTdGFydCxcbiAgICAgIHRoaXMueVN0YXJ0XG4gICAgKTtcblxuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS50b3AgPVxuICAgICAgKHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgLSB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSkgLyAyICsgJ3B4JztcbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUubGVmdCA9XG4gICAgICAodGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUpIC8gMiArICdweCc7XG5cbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUud2lkdGggPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSArICdweCc7XG4gICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgfSxcblxuICAvKiogQHBhcmFtIHtFdmVudD19IGV2ZW50ICovXG4gIHVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5pc01vdXNlRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubW91c2VVcFN0YXJ0ID0gVXRpbGl0eS5ub3coKTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIGRvbSh0aGlzLndhdmVDb250YWluZXIucGFyZW50Tm9kZSkucmVtb3ZlQ2hpbGQoXG4gICAgICB0aGlzLndhdmVDb250YWluZXJcbiAgICApO1xuICB9XG59O1xuXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG5cbiAgICAgICAgLyogU2VlIFBvbHltZXJFbGVtZW50cy9wYXBlci1iZWhhdmlvcnMvaXNzdWVzLzM0LiBPbiBub24tQ2hyb21lIGJyb3dzZXJzLFxuICAgICAgICAgKiBjcmVhdGluZyBhIG5vZGUgKHdpdGggYSBwb3NpdGlvbjphYnNvbHV0ZSkgaW4gdGhlIG1pZGRsZSBvZiBhbiBldmVudFxuICAgICAgICAgKiBoYW5kbGVyIFwiaW50ZXJydXB0c1wiIHRoYXQgZXZlbnQgaGFuZGxlciAod2hpY2ggaGFwcGVucyB3aGVuIHRoZVxuICAgICAgICAgKiByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQpICovXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbYW5pbWF0aW5nXSkge1xuICAgICAgICAvKiBUaGlzIHJlc29sdmVzIGEgcmVuZGVyaW5nIGlzc3VlIGluIENocm9tZSAoYXMgb2YgNDApIHdoZXJlIHRoZVxuICAgICAgICAgICByaXBwbGUgaXMgbm90IHByb3Blcmx5IGNsaXBwZWQgYnkgaXRzIHBhcmVudCAod2hpY2ggbWF5IGhhdmVcbiAgICAgICAgICAgcm91bmRlZCBjb3JuZXJzKS4gU2VlOiBodHRwOi8vanNiaW4uY29tL3RlbWV4YS80XG5cbiAgICAgICAgICAgTm90ZTogV2Ugb25seSBhcHBseSB0aGlzIHN0eWxlIGNvbmRpdGlvbmFsbHkuIE90aGVyd2lzZSwgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgd2lsbCBjcmVhdGUgYSBuZXcgY29tcG9zaXRpbmcgbGF5ZXIgZm9yIGV2ZXJ5IHJpcHBsZSBlbGVtZW50IG9uIHRoZVxuICAgICAgICAgICBwYWdlLCBhbmQgdGhhdCB3b3VsZCBiZSBiYWQuICovXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgI3dhdmVzLFxuICAgICAgLndhdmUtY29udGFpbmVyLFxuICAgICAgLndhdmUge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgLndhdmUge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgfVxuXG4gICAgICAjd2F2ZXMsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC53YXZlLWNvbnRhaW5lcixcbiAgICAgIC53YXZlIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCguY2lyY2xlKSAjYmFja2dyb3VuZCxcbiAgICAgIDpob3N0KC5jaXJjbGUpICN3YXZlcyB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoLmNpcmNsZSkgLndhdmUtY29udGFpbmVyIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cImJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGlkPVwid2F2ZXNcIj48L2Rpdj5cbmAsXG5cbiAgaXM6ICdwYXBlci1yaXBwbGUnLFxuXG4gIGJlaGF2aW9yczogW1xuICAgIElyb25BMTF5S2V5c0JlaGF2aW9yXG4gIF0sXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsIG9wYWNpdHkgc2V0IG9uIHRoZSB3YXZlLlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSBpbml0aWFsT3BhY2l0eVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuMjVcbiAgICAgKi9cbiAgICBpbml0aWFsT3BhY2l0eToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgdmFsdWU6IDAuMjVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSG93IGZhc3QgKG9wYWNpdHkgcGVyIHNlY29uZCkgdGhlIHdhdmUgZmFkZXMgb3V0LlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSBvcGFjaXR5RGVjYXlWZWxvY2l0eVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuOFxuICAgICAqL1xuICAgIG9wYWNpdHlEZWNheVZlbG9jaXR5OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB2YWx1ZTogMC44XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBleGhpYml0IGEgZ3Jhdml0YXRpb25hbCBwdWxsIHRvd2FyZHNcbiAgICAgKiB0aGUgY2VudGVyIG9mIHRoZWlyIGNvbnRhaW5lciBhcyB0aGV5IGZhZGUgYXdheS5cbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgcmVjZW50ZXJzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgcmVjZW50ZXJzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBjZW50ZXIgaW5zaWRlIGl0cyBjb250YWluZXJcbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgcmVjZW50ZXJzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgY2VudGVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiB0aGUgdmlzdWFsIHJpcHBsZXMuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIHJpcHBsZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG4gICAgcmlwcGxlczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aGVuIHRoZXJlIGFyZSB2aXNpYmxlIHJpcHBsZXMgYW5pbWF0aW5nIHdpdGhpbiB0aGVcbiAgICAgKiBlbGVtZW50LlxuICAgICAqL1xuICAgIGFuaW1hdGluZzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSByaXBwbGUgd2lsbCByZW1haW4gaW4gdGhlIFwiZG93blwiIHN0YXRlIHVudGlsIGBob2xkRG93bmBcbiAgICAgKiBpcyBzZXQgdG8gZmFsc2UgYWdhaW4uXG4gICAgICovXG4gICAgaG9sZERvd246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBvYnNlcnZlcjogJ19ob2xkRG93bkNoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSByaXBwbGUgd2lsbCBub3QgZ2VuZXJhdGUgYSByaXBwbGUgZWZmZWN0XG4gICAgICogdmlhIHBvaW50ZXIgaW50ZXJhY3Rpb24uXG4gICAgICogQ2FsbGluZyByaXBwbGUncyBpbXBlcmF0aXZlIGFwaSBsaWtlIGBzaW11bGF0ZWRSaXBwbGVgIHdpbGxcbiAgICAgKiBzdGlsbCBnZW5lcmF0ZSB0aGUgcmlwcGxlIGVmZmVjdC5cbiAgICAgKi9cbiAgICBub2luazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBfYW5pbWF0aW5nOiB7XG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcblxuICAgIF9ib3VuZEFuaW1hdGU6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldCB0YXJnZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmtleUV2ZW50VGFyZ2V0O1xuICB9LFxuXG4gIGtleUJpbmRpbmdzOiB7XG4gICAgJ2VudGVyOmtleWRvd24nOiAnX29uRW50ZXJLZXlkb3duJyxcbiAgICAnc3BhY2U6a2V5ZG93bic6ICdfb25TcGFjZUtleWRvd24nLFxuICAgICdzcGFjZTprZXl1cCc6ICdfb25TcGFjZUtleXVwJ1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBTZXQgdXAgYTExeUtleXNCZWhhdmlvciB0byBsaXN0ZW4gdG8ga2V5IGV2ZW50cyBvbiB0aGUgdGFyZ2V0LFxuICAgIC8vIHNvIHRoYXQgc3BhY2UgYW5kIGVudGVyIGFjdGl2YXRlIHRoZSByaXBwbGUgZXZlbiBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3RcbiAgICAvLyBoYW5kbGUga2V5IGV2ZW50cy4gVGhlIGtleSBoYW5kbGVycyBkZWFsIHdpdGggYG5vaW5rYCB0aGVtc2VsdmVzLlxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUubm9kZVR5cGUgPT0gMTEpIHsgLy8gRE9DVU1FTlRfRlJBR01FTlRfTk9ERVxuICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IGRvbSh0aGlzKS5nZXRPd25lclJvb3QoKS5ob3N0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB2YXIga2V5RXZlbnRUYXJnZXQgPSAvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKHRoaXMua2V5RXZlbnRUYXJnZXQpO1xuICAgIHRoaXMubGlzdGVuKGtleUV2ZW50VGFyZ2V0LCAndXAnLCAndWlVcEFjdGlvbicpO1xuICAgIHRoaXMubGlzdGVuKGtleUV2ZW50VGFyZ2V0LCAnZG93bicsICd1aURvd25BY3Rpb24nKTtcbiAgfSxcblxuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51bmxpc3Rlbih0aGlzLmtleUV2ZW50VGFyZ2V0LCAndXAnLCAndWlVcEFjdGlvbicpO1xuICAgIHRoaXMudW5saXN0ZW4odGhpcy5rZXlFdmVudFRhcmdldCwgJ2Rvd24nLCAndWlEb3duQWN0aW9uJyk7XG4gICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IG51bGw7XG4gIH0sXG5cbiAgZ2V0IHNob3VsZEtlZXBBbmltYXRpbmcgKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnJpcHBsZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICBpZiAoIXRoaXMucmlwcGxlc1tpbmRleF0uaXNBbmltYXRpb25Db21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgc2ltdWxhdGVkUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRvd25BY3Rpb24obnVsbCk7XG5cbiAgICAvLyBQbGVhc2Ugc2VlIHBvbHltZXIvcG9seW1lciMxMzA1XG4gICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICB9LCAxKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJvdm9rZXMgYSByaXBwbGUgZG93biBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgKi9cbiAgdWlEb3duQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgdGhpcy5kb3duQWN0aW9uKGV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3Zva2VzIGEgcmlwcGxlIGRvd24gZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgKiAqbm90KiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICovXG4gIGRvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaG9sZERvd24gJiYgdGhpcy5yaXBwbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmlwcGxlID0gdGhpcy5hZGRSaXBwbGUoKTtcblxuICAgIHJpcHBsZS5kb3duQWN0aW9uKGV2ZW50KTtcblxuICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICB0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5hbmltYXRlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQcm92b2tlcyBhIHJpcHBsZSB1cCBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgKi9cbiAgdWlVcEFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMubm9pbmspIHtcbiAgICAgIHRoaXMudXBBY3Rpb24oZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHJvdm9rZXMgYSByaXBwbGUgdXAgZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgKiAqbm90KiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICovXG4gIHVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLmhvbGREb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yaXBwbGVzLmZvckVhY2goZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgICByaXBwbGUudXBBY3Rpb24oZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmFuaW1hdGUoKTtcbiAgfSxcblxuICBvbkFuaW1hdGlvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLiQuYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBudWxsO1xuICAgIHRoaXMuZmlyZSgndHJhbnNpdGlvbmVuZCcpO1xuICB9LFxuXG4gIGFkZFJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJpcHBsZSA9IG5ldyBSaXBwbGUodGhpcyk7XG5cbiAgICBkb20odGhpcy4kLndhdmVzKS5hcHBlbmRDaGlsZChyaXBwbGUud2F2ZUNvbnRhaW5lcik7XG4gICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcmlwcGxlLmNvbG9yO1xuICAgIHRoaXMucmlwcGxlcy5wdXNoKHJpcHBsZSk7XG5cbiAgICB0aGlzLl9zZXRBbmltYXRpbmcodHJ1ZSk7XG5cbiAgICByZXR1cm4gcmlwcGxlO1xuICB9LFxuXG4gIHJlbW92ZVJpcHBsZTogZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgdmFyIHJpcHBsZUluZGV4ID0gdGhpcy5yaXBwbGVzLmluZGV4T2YocmlwcGxlKTtcblxuICAgIGlmIChyaXBwbGVJbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJpcHBsZXMuc3BsaWNlKHJpcHBsZUluZGV4LCAxKTtcblxuICAgIHJpcHBsZS5yZW1vdmUoKTtcblxuICAgIGlmICghdGhpcy5yaXBwbGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2V0QW5pbWF0aW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgY29uZmxpY3RzIHdpdGggRWxlbWVudCNhbnRpbWF0ZSgpLlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9hbmltYXRlXG4gICAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAgICovXG4gIGFuaW1hdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbmRleDtcbiAgICB2YXIgcmlwcGxlO1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5yaXBwbGVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgcmlwcGxlID0gdGhpcy5yaXBwbGVzW2luZGV4XTtcblxuICAgICAgcmlwcGxlLmRyYXcoKTtcblxuICAgICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IHJpcHBsZS5vdXRlck9wYWNpdHk7XG5cbiAgICAgIGlmIChyaXBwbGUuaXNPcGFjaXR5RnVsbHlEZWNheWVkICYmICFyaXBwbGUuaXNSZXN0aW5nQXRNYXhSYWRpdXMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVSaXBwbGUocmlwcGxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2hvdWxkS2VlcEFuaW1hdGluZyAmJiB0aGlzLnJpcHBsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm9uQW5pbWF0aW9uQ29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZEFuaW1hdGUpO1xuICAgIH1cbiAgfSxcblxuICBfb25FbnRlcktleWRvd246IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudWlEb3duQWN0aW9uKCk7XG4gICAgdGhpcy5hc3luYyh0aGlzLnVpVXBBY3Rpb24sIDEpO1xuICB9LFxuXG4gIF9vblNwYWNlS2V5ZG93bjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51aURvd25BY3Rpb24oKTtcbiAgfSxcblxuICBfb25TcGFjZUtleXVwOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVpVXBBY3Rpb24oKTtcbiAgfSxcblxuICAvLyBub3RlOiBob2xkRG93biBkb2VzIG5vdCByZXNwZWN0IG5vaW5rIHNpbmNlIGl0IGNhbiBiZSBhIGZvY3VzIGJhc2VkXG4gIC8vIGVmZmVjdC5cbiAgX2hvbGREb3duQ2hhbmdlZDogZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICBpZiAob2xkVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5ld1ZhbCkge1xuICAgICAgdGhpcy5kb3duQWN0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzLlxuICBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byB3YWl0IHVudGlsXG4gIHRoZSByaXBwbGUgYW5pbWF0aW9uIGZpbmlzaGVzIHRvIHBlcmZvcm0gc29tZSBhY3Rpb24uXG5cbiAgQGV2ZW50IHRyYW5zaXRpb25lbmRcbiAgQHBhcmFtIHt7bm9kZTogT2JqZWN0fX0gZGV0YWlsIENvbnRhaW5zIHRoZSBhbmltYXRlZCBub2RlLlxuICAqL1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSAzMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uLy4uLy4uLy4uL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2FwcGx5LXNoaW0uanMnO1xuaW1wb3J0IHsgRWxlbWVudE1peGluIH0gZnJvbSAnLi4vbWl4aW5zL2VsZW1lbnQtbWl4aW4uanMnO1xuaW1wb3J0IHsgR2VzdHVyZUV2ZW50TGlzdGVuZXJzIH0gZnJvbSAnLi4vbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgeyBpbXBvcnRIcmVmIGFzIGltcG9ydEhyZWYkMCB9IGZyb20gJy4uL3V0aWxzL2ltcG9ydC1ocmVmLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvcmVuZGVyLXN0YXR1cy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL3VucmVzb2x2ZWQuanMnO1xuaW1wb3J0IHsgZG9tIGFzIGRvbSQwLCBtYXRjaGVzU2VsZWN0b3IgfSBmcm9tICcuL3BvbHltZXIuZG9tLmpzJztcbmltcG9ydCB7IHNldFRvdWNoQWN0aW9uIH0gZnJvbSAnLi4vdXRpbHMvZ2VzdHVyZXMuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VyIH0gZnJvbSAnLi4vdXRpbHMvZGVib3VuY2UuanMnO1xuaW1wb3J0IHsgdGltZU91dCwgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuaW1wb3J0IHsgZ2V0IGFzIGdldCQwIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5qcyc7XG5cbmxldCBzdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUztcblxuZXhwb3J0IGNvbnN0IExlZ2FjeUVsZW1lbnRNaXhpbiA9IGRlZHVwaW5nTWl4aW4oKGJhc2UpID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtiYXNlfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICovXG4gIGNvbnN0IGxlZ2FjeUVsZW1lbnRCYXNlID0gR2VzdHVyZUV2ZW50TGlzdGVuZXJzKEVsZW1lbnRNaXhpbihiYXNlKSk7XG5cbiAgLyoqXG4gICAqIE1hcCBvZiBzaW1wbGUgbmFtZXMgdG8gdG91Y2ggYWN0aW9uIG5hbWVzXG4gICAqIEBkaWN0XG4gICAqL1xuICBjb25zdCBESVJFQ1RJT05fTUFQID0ge1xuICAgICd4JzogJ3Bhbi14JyxcbiAgICAneSc6ICdwYW4teScsXG4gICAgJ25vbmUnOiAnbm9uZScsXG4gICAgJ2FsbCc6ICdhdXRvJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAZXh0ZW5kcyB7bGVnYWN5RWxlbWVudEJhc2V9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0xlZ2FjeUVsZW1lbnRNaXhpbn1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY2xhc3MgTGVnYWN5RWxlbWVudCBleHRlbmRzIGxlZ2FjeUVsZW1lbnRCYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMucm9vdCA9IHRoaXM7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLmlzQXR0YWNoZWQ7XG4gICAgICAvKiogQHR5cGUge1dlYWtNYXA8IUVsZW1lbnQsICFPYmplY3Q8c3RyaW5nLCAhRnVuY3Rpb24+Pn0gKi9cbiAgICAgIHRoaXMuX19ib3VuZExpc3RlbmVycztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgRnVuY3Rpb24+fSAqL1xuICAgICAgdGhpcy5fZGVib3VuY2VycztcbiAgICAgIHRoaXMuY3JlYXRlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIHRoZSBgY29uc3RydWN0b3JgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIGNyZWF0ZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gb2YgYGNvbm5lY3RlZENhbGxiYWNrYFxuICAgICAqIHdoaWNoIGFkZHMgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGF0dGFjaGVkYCBtZXRob2QuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgICAgdGhpcy5pc0F0dGFjaGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuYXR0YWNoZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyBgY29ubmVjdGVkQ2FsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIGF0dGFjaGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIGBkaXNjb25uZWN0ZWRDYWxsYmFja2BcbiAgICAgKiB3aGljaCBhZGRzIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBkZXRhY2hlZGAgbWV0aG9kLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5kZXRhY2hlZCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBkaXNjb25uZWN0ZWRDYWxsYmFja2AsIGZvciBvdmVycmlkaW5nXG4gICAgICogYnkgdGhlIHVzZXIuXG4gICAgICovXG4gICAgZGV0YWNoZWQoKSB7fVxuXG4gICAgLyoqXG4gICAgICogUHJvdmlkZXMgYW4gb3ZlcnJpZGUgaW1wbGVtZW50YXRpb24gb2YgYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2BcbiAgICAgKiB3aGljaCBhZGRzIHRoZSBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgYXR0cmlidXRlQ2hhbmdlZGAgbWV0aG9kLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBDdXJyZW50IHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGF0dHJpYnV0ZUNoYW5nZWRDaGFsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZSBDdXJyZW50IHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIGltcGxlbWVudGF0aW9uIHRvXG4gICAgICogYWRkIHN1cHBvcnQgZm9yIGNsYXNzIGluaXRpYWxpemF0aW9uIHZpYSB0aGUgYF9yZWdpc3RlcmVkYCBjYWxsYmFjay5cbiAgICAgKiBUaGlzIGlzIGNhbGxlZCBvbmx5IHdoZW4gdGhlIGZpcnN0IGluc3RhbmNlIG9mIHRoZSBlbGVtZW50IGlzIGNyZWF0ZWQuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICBsZXQgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyk7XG4gICAgICBpZiAoIXByb3RvLmhhc093blByb3BlcnR5KCdfX2hhc1JlZ2lzdGVyRmluaXNoZWQnKSkge1xuICAgICAgICBwcm90by5fX2hhc1JlZ2lzdGVyRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9yZWdpc3RlcmVkKCk7XG4gICAgICB9XG4gICAgICBzdXBlci5faW5pdGlhbGl6ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXV0b21hdGljYWxseSB3aGVuIGFuIGVsZW1lbnQgaXMgaW5pdGlhbGl6aW5nLlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwZXJmb3JtIGNsYXNzIHJlZ2lzdHJhdGlvbiB0aW1lXG4gICAgICogd29yay4gVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCBlbnN1cmUgdGhlIHdvcmsgaXMgcGVyZm9ybWVkXG4gICAgICogb25seSBvbmNlIGZvciB0aGUgY2xhc3MuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZWdpc3RlcmVkKCkge31cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgZGVmYXVsdCBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIGltcGxlbWVudGF0aW9uIHRvXG4gICAgICogYWRkIHN1cHBvcnQgZm9yIGluc3RhbGxpbmcgYGhvc3RBdHRyaWJ1dGVzYCBhbmQgYGxpc3RlbmVyc2AuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIHRoaXMuX2Vuc3VyZUF0dHJpYnV0ZXMoKTtcbiAgICAgIHRoaXMuX2FwcGx5TGlzdGVuZXJzKCk7XG4gICAgICBzdXBlci5yZWFkeSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVuc3VyZXMgYW4gZWxlbWVudCBoYXMgcmVxdWlyZWQgYXR0cmlidXRlcy4gQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAgKiBpcyBiZWluZyByZWFkaWVkIHZpYSBgcmVhZHlgLiBVc2VycyBzaG91bGQgb3ZlcnJpZGUgdG8gc2V0IHRoZVxuICAgICAqIGVsZW1lbnQncyByZXF1aXJlZCBhdHRyaWJ1dGVzLiBUaGUgaW1wbGVtZW50YXRpb24gc2hvdWxkIGJlIHN1cmVcbiAgICAgKiB0byBjaGVjayBhbmQgbm90IG92ZXJyaWRlIGV4aXN0aW5nIGF0dHJpYnV0ZXMgYWRkZWQgYnlcbiAgICAgKiB0aGUgdXNlciBvZiB0aGUgZWxlbWVudC4gVHlwaWNhbGx5LCBzZXR0aW5nIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxlZnRcbiAgICAgKiB0byB0aGUgZWxlbWVudCB1c2VyIGFuZCBub3QgZG9uZSBoZXJlOyByZWFzb25hYmxlIGV4Y2VwdGlvbnMgaW5jbHVkZVxuICAgICAqIHNldHRpbmcgYXJpYSByb2xlcyBhbmQgZm9jdXNhYmlsaXR5LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZW5zdXJlQXR0cmlidXRlcygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGVsZW1lbnQgZXZlbnQgbGlzdGVuZXJzLiBDYWxsZWQgd2hlbiB0aGUgZWxlbWVudFxuICAgICAqIGlzIGJlaW5nIHJlYWRpZWQgdmlhIGByZWFkeWAuIFVzZXJzIHNob3VsZCBvdmVycmlkZSB0b1xuICAgICAqIGFkZCBhbnkgcmVxdWlyZWQgZWxlbWVudCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICogSW4gcGVyZm9ybWFuY2UgY3JpdGljYWwgZWxlbWVudHMsIHRoZSB3b3JrIGRvbmUgaGVyZSBzaG91bGQgYmUga2VwdFxuICAgICAqIHRvIGEgbWluaW11bSBzaW5jZSBpdCBpcyBkb25lIGJlZm9yZSB0aGUgZWxlbWVudCBpcyByZW5kZXJlZC4gSW5cbiAgICAgKiB0aGVzZSBlbGVtZW50cywgY29uc2lkZXIgYWRkaW5nIGxpc3RlbmVycyBhc3ljaHJvbm91c2x5IHNvIGFzIG5vdCB0b1xuICAgICAqIGJsb2NrIHJlbmRlci5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2FwcGx5TGlzdGVuZXJzKCkge31cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZSB0byBhIHN0cmluZy5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuIFRvIGN1c3RvbWl6ZVxuICAgICAqIGhvdyBwcm9wZXJ0aWVzIGFyZSBzZXJpYWxpemVkIHRvIGF0dHJpYnV0ZXMgZm9yIGF0dHJpYnV0ZSBiaW5kaW5ncyBhbmRcbiAgICAgKiBgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlYCBwcm9wZXJ0aWVzIGFzIHdlbGwgYXMgdGhpcyBtZXRob2QsIG92ZXJyaWRlXG4gICAgICogdGhlIGBfc2VyaWFsaXplVmFsdWVgIG1ldGhvZCBwcm92aWRlZCBieSBgUG9seW1lci5Qcm9wZXJ0eUFjY2Vzc29yc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGRlc2VyaWFsaXplXG4gICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBTZXJpYWxpemVkIHZhbHVlXG4gICAgICovXG4gICAgc2VyaWFsaXplKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgc3RyaW5nIHRvIGEgdHlwZWQgSmF2YVNjcmlwdCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuICBUbyBjdXN0b21pemVcbiAgICAgKiBob3cgYXR0cmlidXRlcyBhcmUgZGVzZXJpYWxpemVkIHRvIHByb3BlcnRpZXMgZm9yIGluXG4gICAgICogYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AsIG92ZXJyaWRlIGBfZGVzZXJpYWxpemVWYWx1ZWAgbWV0aG9kXG4gICAgICogcHJvdmlkZWQgYnkgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFN0cmluZyB0byBkZXNlcmlhbGl6ZVxuICAgICAqIEBwYXJhbSB7Kn0gdHlwZSBUeXBlIHRvIGRlc2VyaWFsaXplIHRoZSBzdHJpbmcgdG9cbiAgICAgKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSBkZXNlcmlhbGl6ZWQgdmFsdWUgaW4gdGhlIGB0eXBlYCBnaXZlbi5cbiAgICAgKi9cbiAgICBkZXNlcmlhbGl6ZSh2YWx1ZSwgdHlwZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNlcmlhbGl6ZXMgYSBwcm9wZXJ0eSB0byBpdHMgYXNzb2NpYXRlZCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byByZWZsZWN0LlxuICAgICAqIEBwYXJhbSB7Kj19IHZhbHVlIFByb3BlcnR5IHZhbHVlIHRvIHJlZmVjdC5cbiAgICAgKi9cbiAgICByZWZsZWN0UHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgdGhpcy5fcHJvcGVydHlUb0F0dHJpYnV0ZShwcm9wZXJ0eSwgYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHR5cGVkIHZhbHVlIHRvIGFuIEhUTUwgYXR0cmlidXRlIG9uIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIEF0dHJpYnV0ZSBuYW1lIHRvIHNlcmlhbGl6ZSB0by5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzZXQgYXR0cmlidXRlIHRvLlxuICAgICAqL1xuICAgIHNlcmlhbGl6ZVZhbHVlVG9BdHRyaWJ1dGUodmFsdWUsIGF0dHJpYnV0ZSwgbm9kZSkge1xuICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKSwgdmFsdWUsIGF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBwcm9wZXJ0aWVzIChpbmNsdWRpbmcgYWNjZXNzb3IgZGVzY3JpcHRvcnMpIGZyb20gYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUYXJnZXQgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXBpIFNvdXJjZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwcm90b3R5cGUgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBleHRlbmQocHJvdG90eXBlLCBhcGkpIHtcbiAgICAgIGlmICghKHByb3RvdHlwZSAmJiBhcGkpKSB7XG4gICAgICAgIHJldHVybiBwcm90b3R5cGUgfHwgYXBpO1xuICAgICAgfVxuICAgICAgbGV0IG4kID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXBpKTtcbiAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8biQubGVuZ3RoKSAmJiAobj1uJFtpXSk7IGkrKykge1xuICAgICAgICBsZXQgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFwaSwgbik7XG4gICAgICAgIGlmIChwZCkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIG4sIHBkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3RvdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgcHJvcHMgZnJvbSBhIHNvdXJjZSBvYmplY3QgdG8gYSB0YXJnZXQgb2JqZWN0LlxuICAgICAqXG4gICAgICogTm90ZSwgdGhpcyBtZXRob2QgdXNlcyBhIHNpbXBsZSBgZm9yLi4uaW5gIHN0cmF0ZWd5IGZvciBlbnVtZXJhdGluZ1xuICAgICAqIHByb3BlcnRpZXMuICBUbyBlbnN1cmUgb25seSBgb3duUHJvcGVydGllc2AgYXJlIGNvcGllZCBmcm9tIHNvdXJjZVxuICAgICAqIHRvIHRhcmdldCBhbmQgdGhhdCBhY2Nlc3NvciBpbXBsZW1lbnRhdGlvbnMgYXJlIGNvcGllZCwgdXNlIGBleHRlbmRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldCBUYXJnZXQgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFNvdXJjZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUYXJnZXQgb2JqZWN0IHRoYXQgd2FzIHBhc3NlZCBhcyBmaXJzdCBhcmd1bWVudC5cbiAgICAgKi9cbiAgICBtaXhpbih0YXJnZXQsIHNvdXJjZSkge1xuICAgICAgZm9yIChsZXQgaSBpbiBzb3VyY2UpIHtcbiAgICAgICAgdGFyZ2V0W2ldID0gc291cmNlW2ldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwcm90b3R5cGUgb2YgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3Qgb24gd2hpY2ggdG8gc2V0IHRoZSBwcm90b3R5cGUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3RvdHlwZSBUaGUgcHJvdG90eXBlIHRoYXQgd2lsbCBiZSBzZXQgb24gdGhlIGdpdmVuXG4gICAgICogYG9iamVjdGAuXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIHRoZSBnaXZlbiBgb2JqZWN0YCB3aXRoIGl0cyBwcm90b3R5cGUgc2V0XG4gICAgICogdG8gdGhlIGdpdmVuIGBwcm90b3R5cGVgIG9iamVjdC5cbiAgICAgKi9cbiAgICBjaGFpbk9iamVjdChvYmplY3QsIHByb3RvdHlwZSkge1xuICAgICAgaWYgKG9iamVjdCAmJiBwcm90b3R5cGUgJiYgb2JqZWN0ICE9PSBwcm90b3R5cGUpIHtcbiAgICAgICAgb2JqZWN0Ll9fcHJvdG9fXyA9IHByb3RvdHlwZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyogKioqKiBCZWdpbiBUZW1wbGF0ZSAqKioqICovXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBgaW1wb3J0Tm9kZWAgb24gdGhlIGBjb250ZW50YCBvZiB0aGUgYHRlbXBsYXRlYCBzcGVjaWZpZWQgYW5kXG4gICAgICogcmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50IGNvbnRhaW5pbmcgdGhlIGltcG9ydGVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIEhUTUwgdGVtcGxhdGUgZWxlbWVudCB0byBpbnN0YW5jZS5cbiAgICAgKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fSBEb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHRoZSBpbXBvcnRlZFxuICAgICAqICAgdGVtcGxhdGUgY29udGVudC5cbiAgICAqL1xuICAgIGluc3RhbmNlVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIGxldCBjb250ZW50ID0gdGhpcy5jb25zdHJ1Y3Rvci5fY29udGVudEZvclRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIGxldCBkb20gPSAvKiogQHR5cGUge0RvY3VtZW50RnJhZ21lbnR9ICovXG4gICAgICAgIChkb2N1bWVudC5pbXBvcnROb2RlKGNvbnRlbnQsIHRydWUpKTtcbiAgICAgIHJldHVybiBkb207XG4gICAgfVxuXG4gICAgLyogKioqKiBCZWdpbiBFdmVudHMgKioqKiAqL1xuXG5cblxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoZXMgYSBjdXN0b20gZXZlbnQgd2l0aCBhbiBvcHRpb25hbCBkZXRhaWwgdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBOYW1lIG9mIGV2ZW50IHR5cGUuXG4gICAgICogQHBhcmFtIHsqPX0gZGV0YWlsIERldGFpbCB2YWx1ZSBjb250YWluaW5nIGV2ZW50LXNwZWNpZmljXG4gICAgICogICBwYXlsb2FkLlxuICAgICAqIEBwYXJhbSB7eyBidWJibGVzOiAoYm9vbGVhbnx1bmRlZmluZWQpLCBjYW5jZWxhYmxlOiAoYm9vbGVhbnx1bmRlZmluZWQpLCBjb21wb3NlZDogKGJvb2xlYW58dW5kZWZpbmVkKSB9PX1cbiAgICAgKiAgb3B0aW9ucyBPYmplY3Qgc3BlY2lmeWluZyBvcHRpb25zLiAgVGhlc2UgbWF5IGluY2x1ZGU6XG4gICAgICogIGBidWJibGVzYCAoYm9vbGVhbiwgZGVmYXVsdHMgdG8gYHRydWVgKSxcbiAgICAgKiAgYGNhbmNlbGFibGVgIChib29sZWFuLCBkZWZhdWx0cyB0byBmYWxzZSksIGFuZFxuICAgICAqICBgbm9kZWAgb24gd2hpY2ggdG8gZmlyZSB0aGUgZXZlbnQgKEhUTUxFbGVtZW50LCBkZWZhdWx0cyB0byBgdGhpc2ApLlxuICAgICAqIEByZXR1cm4ge0V2ZW50fSBUaGUgbmV3IGV2ZW50IHRoYXQgd2FzIGZpcmVkLlxuICAgICAqL1xuICAgIGZpcmUodHlwZSwgZGV0YWlsLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGRldGFpbCA9IChkZXRhaWwgPT09IG51bGwgfHwgZGV0YWlsID09PSB1bmRlZmluZWQpID8ge30gOiBkZXRhaWw7XG4gICAgICBsZXQgZXZlbnQgPSBuZXcgRXZlbnQodHlwZSwge1xuICAgICAgICBidWJibGVzOiBvcHRpb25zLmJ1YmJsZXMgPT09IHVuZGVmaW5lZCA/IHRydWUgOiBvcHRpb25zLmJ1YmJsZXMsXG4gICAgICAgIGNhbmNlbGFibGU6IEJvb2xlYW4ob3B0aW9ucy5jYW5jZWxhYmxlKSxcbiAgICAgICAgY29tcG9zZWQ6IG9wdGlvbnMuY29tcG9zZWQgPT09IHVuZGVmaW5lZCA/IHRydWU6IG9wdGlvbnMuY29tcG9zZWRcbiAgICAgIH0pO1xuICAgICAgZXZlbnQuZGV0YWlsID0gZGV0YWlsO1xuICAgICAgbGV0IG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgdGhpcztcbiAgICAgIG5vZGUuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFkZCBhbiBldmVudCBsaXN0ZW5lciBvbiBhIGdpdmVuIGVsZW1lbnQsXG4gICAgICogbGF0ZSBib3VuZCB0byBhIG5hbWVkIG1ldGhvZCBvbiB0aGlzIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBhZGQgZXZlbnQgbGlzdGVuZXIgdG8uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50IHRvIGxpc3RlbiBmb3IuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTmFtZSBvZiBoYW5kbGVyIG1ldGhvZCBvbiBgdGhpc2AgdG8gY2FsbC5cbiAgICAgKi9cbiAgICBsaXN0ZW4obm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICBsZXQgaGJsID0gdGhpcy5fX2JvdW5kTGlzdGVuZXJzIHx8XG4gICAgICAgICh0aGlzLl9fYm91bmRMaXN0ZW5lcnMgPSBuZXcgV2Vha01hcCgpKTtcbiAgICAgIGxldCBibCA9IGhibC5nZXQobm9kZSk7XG4gICAgICBpZiAoIWJsKSB7XG4gICAgICAgIGJsID0ge307XG4gICAgICAgIGhibC5zZXQobm9kZSwgYmwpO1xuICAgICAgfVxuICAgICAgbGV0IGtleSA9IGV2ZW50TmFtZSArIG1ldGhvZE5hbWU7XG4gICAgICBpZiAoIWJsW2tleV0pIHtcbiAgICAgICAgYmxba2V5XSA9IHRoaXMuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUoXG4gICAgICAgICAgbm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcmVtb3ZlIGFuIGV2ZW50IGxpc3RlbmVyIGZyb20gYSBnaXZlbiBlbGVtZW50LFxuICAgICAqIGxhdGUgYm91bmQgdG8gYSBuYW1lZCBtZXRob2Qgb24gdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyIGZyb20uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50IHRvIHN0b3AgbGlzdGVuaW5nIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2YgaGFuZGxlciBtZXRob2Qgb24gYHRoaXNgIHRvIG5vdCBjYWxsXG4gICAgIGFueW1vcmUuXG4gICAgICovXG4gICAgdW5saXN0ZW4obm9kZSwgZXZlbnROYW1lLCBtZXRob2ROYW1lKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHshRWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICBsZXQgYmwgPSB0aGlzLl9fYm91bmRMaXN0ZW5lcnMgJiYgdGhpcy5fX2JvdW5kTGlzdGVuZXJzLmdldChub2RlKTtcbiAgICAgIGxldCBrZXkgPSBldmVudE5hbWUgKyBtZXRob2ROYW1lO1xuICAgICAgbGV0IGhhbmRsZXIgPSBibCAmJiBibFtrZXldO1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgICAgIGJsW2tleV0gPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHNjcm9sbGluZyBiZWhhdmlvciB0byBhbGwgZGlyZWN0aW9uLCBvbmUgZGlyZWN0aW9uLCBvciBub25lLlxuICAgICAqXG4gICAgICogVmFsaWQgc2Nyb2xsIGRpcmVjdGlvbnM6XG4gICAgICogICAtICdhbGwnOiBzY3JvbGwgaW4gYW55IGRpcmVjdGlvblxuICAgICAqICAgLSAneCc6IHNjcm9sbCBvbmx5IGluIHRoZSAneCcgZGlyZWN0aW9uXG4gICAgICogICAtICd5Jzogc2Nyb2xsIG9ubHkgaW4gdGhlICd5JyBkaXJlY3Rpb25cbiAgICAgKiAgIC0gJ25vbmUnOiBkaXNhYmxlIHNjcm9sbGluZyBmb3IgdGhpcyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGRpcmVjdGlvbiBEaXJlY3Rpb24gdG8gYWxsb3cgc2Nyb2xsaW5nXG4gICAgICogRGVmYXVsdHMgdG8gYGFsbGAuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHNjcm9sbCBkaXJlY3Rpb24gc2V0dGluZy5cbiAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICovXG4gICAgc2V0U2Nyb2xsRGlyZWN0aW9uKGRpcmVjdGlvbiwgbm9kZSkge1xuICAgICAgc2V0VG91Y2hBY3Rpb24oIChub2RlIHx8IHRoaXMpLCBESVJFQ1RJT05fTUFQW2RpcmVjdGlvbl0gfHwgJ2F1dG8nKTtcbiAgICB9XG4gICAgLyogKioqKiBFbmQgRXZlbnRzICoqKiogKi9cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBydW4gYHF1ZXJ5U2VsZWN0b3JgIG9uIHRoaXMgbG9jYWwgRE9NIHNjb3BlLlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBjYWxscyBgUG9seW1lci5kb20odGhpcy5yb290KS5xdWVyeVNlbGVjdG9yKHNsY3RyKWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2xjdHIgU2VsZWN0b3IgdG8gcnVuIG9uIHRoaXMgbG9jYWwgRE9NIHNjb3BlXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gRWxlbWVudCBmb3VuZCBieSB0aGUgc2VsZWN0b3IsIG9yIG51bGwgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgICQkKHNsY3RyKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3Ioc2xjdHIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgZWxlbWVudCB3aG9zZSBsb2NhbCBkb20gd2l0aGluIHdoaWNoIHRoaXMgZWxlbWVudFxuICAgICAqIGlzIGNvbnRhaW5lZC4gVGhpcyBpcyBhIHNob3J0aGFuZCBmb3JcbiAgICAgKiBgdGhpcy5nZXRSb290Tm9kZSgpLmhvc3RgLlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqL1xuICAgIGdldCBkb21Ib3N0KCkge1xuICAgICAgbGV0IHJvb3QgPSB0aGlzLmdldFJvb3ROb2RlKCk7XG4gICAgICByZXR1cm4gKHJvb3QgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KSA/IC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8gKHJvb3QpLmhvc3QgOiByb290O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcmNlIHRoaXMgZWxlbWVudCB0byBkaXN0cmlidXRlIGl0cyBjaGlsZHJlbiB0byBpdHMgbG9jYWwgZG9tLlxuICAgICAqIFRoaXMgc2hvdWxkIG5vdCBiZSBuZWNlc3NhcnkgYXMgb2YgUG9seW1lciAyLjAuMiBhbmQgaXMgcHJvdmlkZWQgb25seVxuICAgICAqIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgICAgKi9cbiAgICBkaXN0cmlidXRlQ29udGVudCgpIHtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlET00gJiYgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgdGhlIGVmZmVjdGl2ZSBjaGlsZE5vZGVzLiBUaGUgZWZmZWN0aXZlXG4gICAgICogY2hpbGROb2RlcyBsaXN0IGlzIHRoZSBzYW1lIGFzIHRoZSBlbGVtZW50J3MgY2hpbGROb2RlcyBleGNlcHQgdGhhdFxuICAgICAqIGFueSBgPGNvbnRlbnQ+YCBlbGVtZW50cyBhcmUgcmVwbGFjZWQgd2l0aCB0aGUgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZFxuICAgICAqIHRvIHRoZSBgPGNvbnRlbnQ+YCwgdGhlIHJlc3VsdCBvZiBpdHMgYGdldERpc3RyaWJ1dGVkTm9kZXNgIG1ldGhvZC5cbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZCBub2Rlcy5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8gKGRvbSQwKHRoaXMpKS5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWQgd2l0aGluIHRoaXMgZWxlbWVudCB0aGF0IG1hdGNoXG4gICAgICogYHNlbGVjdG9yYC4gVGhlc2UgY2FuIGJlIGRvbSBjaGlsZHJlbiBvciBlbGVtZW50cyBkaXN0cmlidXRlZCB0b1xuICAgICAqIGNoaWxkcmVuIHRoYXQgYXJlIGluc2VydGlvbiBwb2ludHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHJ1bi5cbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBkaXN0cmlidXRlZCBlbGVtZW50cyB0aGF0IG1hdGNoIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIHF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8gKGRvbSQwKHRoaXMpKS5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVsZW1lbnRzIHRoYXQgYXJlIHRoZSBlZmZlY3RpdmUgY2hpbGRyZW4uIFRoZSBlZmZlY3RpdmVcbiAgICAgKiBjaGlsZHJlbiBsaXN0IGlzIHRoZSBzYW1lIGFzIHRoZSBlbGVtZW50J3MgY2hpbGRyZW4gZXhjZXB0IHRoYXRcbiAgICAgKiBhbnkgYDxjb250ZW50PmAgZWxlbWVudHMgYXJlIHJlcGxhY2VkIHdpdGggdGhlIGxpc3Qgb2YgZWxlbWVudHNcbiAgICAgKiBkaXN0cmlidXRlZCB0byB0aGUgYDxjb250ZW50PmAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheTxOb2RlPn0gTGlzdCBvZiBlZmZjdGl2ZSBjaGlsZHJlbi5cbiAgICAgKi9cbiAgICBnZXRFZmZlY3RpdmVDaGlsZHJlbigpIHtcbiAgICAgIGxldCBsaXN0ID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICByZXR1cm4gbGlzdC5maWx0ZXIoZnVuY3Rpb24oLyoqIEB0eXBlIHtOb2RlfSAqLyBuKSB7XG4gICAgICAgIHJldHVybiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBvZiB0ZXh0IGNvbnRlbnQgdGhhdCBpcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiB0aGVcbiAgICAgKiB0ZXh0IGNvbnRlbnQncyBvZiB0aGUgZWxlbWVudCdzIGVmZmVjdGl2ZSBjaGlsZE5vZGVzICh0aGUgZWxlbWVudHNcbiAgICAgKiByZXR1cm5lZCBieSA8YSBocmVmPVwiI2dldEVmZmVjdGl2ZUNoaWxkTm9kZXM+Z2V0RWZmZWN0aXZlQ2hpbGROb2RlczwvYT4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IExpc3Qgb2YgZWZmY3RpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZ2V0RWZmZWN0aXZlVGV4dENvbnRlbnQoKSB7XG4gICAgICBsZXQgY24gPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkTm9kZXMoKTtcbiAgICAgIGxldCB0YyA9IFtdO1xuICAgICAgZm9yIChsZXQgaT0wLCBjOyAoYyA9IGNuW2ldKTsgaSsrKSB7XG4gICAgICAgIGlmIChjLm5vZGVUeXBlICE9PSBOb2RlLkNPTU1FTlRfTk9ERSkge1xuICAgICAgICAgIHRjLnB1c2goYy50ZXh0Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0Yy5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBlZmZlY3RpdmUgY2hpbGROb2RlIHdpdGhpbiB0aGlzIGVsZW1lbnQgdGhhdFxuICAgICAqIG1hdGNoIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGQgbm9kZXMgb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWRcbiAgICAgKiB0byBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBydW4uXG4gICAgICogQHJldHVybiB7T2JqZWN0PE5vZGU+fSBGaXJzdCBlZmZlY3RpdmUgY2hpbGQgbm9kZSB0aGF0IG1hdGNoZXMgc2VsZWN0b3IuXG4gICAgICovXG4gICAgcXVlcnlFZmZlY3RpdmVDaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgbGV0IGUkID0gdGhpcy5xdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgcmV0dXJuIGUkICYmIGUkWzBdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVmZmVjdGl2ZSBjaGlsZE5vZGVzIHdpdGhpbiB0aGlzIGVsZW1lbnQgdGhhdFxuICAgICAqIG1hdGNoIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGQgbm9kZXMgb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWRcbiAgICAgKiB0byBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBydW4uXG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmZWN0aXZlIGNoaWxkIG5vZGVzIHRoYXQgbWF0Y2ggc2VsZWN0b3IuXG4gICAgICovXG4gICAgcXVlcnlBbGxFZmZlY3RpdmVDaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIHRoaXMucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBub2RlcyBkaXN0cmlidXRlZCB0byB0aGlzIGVsZW1lbnQncyBgPHNsb3Q+YC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgZWxlbWVudCBjb250YWlucyBtb3JlIHRoYW4gb25lIGA8c2xvdD5gIGluIGl0cyBsb2NhbCBET00sXG4gICAgICogYW4gb3B0aW9uYWwgc2VsZWN0b3IgbWF5IGJlIHBhc3NlZCB0byBjaG9vc2UgdGhlIGRlc2lyZWQgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gc2xjdHIgQ1NTIHNlbGVjdG9yIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAqICAgYDxzbG90PmAuICBEZWZhdWx0cyB0byBgY29udGVudGAuXG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgbm9kZXMgZm9yIHRoZSBgPHNsb3Q+YC5cbiAgICAgKi9cbiAgICBnZXRDb250ZW50Q2hpbGROb2RlcyhzbGN0cikge1xuICAgICAgbGV0IGNvbnRlbnQgPSB0aGlzLnJvb3QucXVlcnlTZWxlY3RvcihzbGN0ciB8fCAnc2xvdCcpO1xuICAgICAgcmV0dXJuIGNvbnRlbnQgPyAvKiogQHR5cGUge1BvbHltZXIuRG9tQXBpfSAqLyhkb20kMChjb250ZW50KSkuZ2V0RGlzdHJpYnV0ZWROb2RlcygpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2YgZWxlbWVudCBjaGlsZHJlbiBkaXN0cmlidXRlZCB0byB0aGlzIGVsZW1lbnQnc1xuICAgICAqIGA8c2xvdD5gLlxuICAgICAqXG4gICAgICogSWYgdGhpcyBlbGVtZW50IGNvbnRhaW5zIG1vcmUgdGhhbiBvbmUgYDxzbG90PmAgaW4gaXRzXG4gICAgICogbG9jYWwgRE9NLCBhbiBvcHRpb25hbCBzZWxlY3RvciBtYXkgYmUgcGFzc2VkIHRvIGNob29zZSB0aGUgZGVzaXJlZFxuICAgICAqIGNvbnRlbnQuICBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYGdldENvbnRlbnRDaGlsZE5vZGVzYCBpbiB0aGF0IG9ubHlcbiAgICAgKiBlbGVtZW50cyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNsY3RyIENTUyBzZWxlY3RvciB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgKiAgIGA8Y29udGVudD5gLiAgRGVmYXVsdHMgdG8gYGNvbnRlbnRgLlxuICAgICAqIEByZXR1cm4ge0FycmF5PEhUTUxFbGVtZW50Pn0gTGlzdCBvZiBkaXN0cmlidXRlZCBub2RlcyBmb3IgdGhlXG4gICAgICogICBgPHNsb3Q+YC5cbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICBnZXRDb250ZW50Q2hpbGRyZW4oc2xjdHIpIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUge0FycmF5PEhUTUxFbGVtZW50Pn0gKi8odGhpcy5nZXRDb250ZW50Q2hpbGROb2RlcyhzbGN0cikuZmlsdGVyKGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSk7XG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgYW4gZWxlbWVudCBpcyBpbiB0aGlzIGVsZW1lbnQncyBsaWdodCBET00gdHJlZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P05vZGV9IG5vZGUgVGhlIGVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIG5vZGUgaXMgaW4gdGhpcyBlbGVtZW50J3MgbGlnaHQgRE9NIHRyZWUuXG4gICAgICovXG4gICAgaXNMaWdodERlc2NlbmRhbnQobm9kZSkge1xuICAgICAgcmV0dXJuIHRoaXMgIT09IG5vZGUgJiYgdGhpcy5jb250YWlucyhub2RlKSAmJlxuICAgICAgICAgIHRoaXMuZ2V0Um9vdE5vZGUoKSA9PT0gbm9kZS5nZXRSb290Tm9kZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgaW4gdGhpcyBlbGVtZW50J3MgbG9jYWwgRE9NIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBub2RlIGlzIGluIHRoaXMgZWxlbWVudCdzIGxvY2FsIERPTSB0cmVlLlxuICAgICAqL1xuICAgIGlzTG9jYWxEZXNjZW5kYW50KG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJvb3QgPT09IG5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBzaG91bGQgbm93IGJlIGhhbmRsZWQgYnkgU2hhZHlDc3MgbGlicmFyeS5cbiAgICBzY29wZVN1YnRyZWUoY29udGFpbmVyLCBzaG91bGRPYnNlcnZlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21wdXRlZCBzdHlsZSB2YWx1ZSBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBUaGUgY3NzIHByb3BlcnR5IG5hbWUuXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb21wdXRlZCBjc3MgcHJvcGVydHkgdmFsdWUgZm9yIHRoZSBnaXZlblxuICAgICAqIGBwcm9wZXJ0eWAuXG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gc3R5bGVJbnRlcmZhY2UuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKHRoaXMsIHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvLyBkZWJvdW5jZVxuXG4gICAgLyoqXG4gICAgICogQ2FsbCBgZGVib3VuY2VgIHRvIGNvbGxhcHNlIG11bHRpcGxlIHJlcXVlc3RzIGZvciBhIG5hbWVkIHRhc2sgaW50b1xuICAgICAqIG9uZSBpbnZvY2F0aW9uIHdoaWNoIGlzIG1hZGUgYWZ0ZXIgdGhlIHdhaXQgdGltZSBoYXMgZWxhcHNlZCB3aXRoXG4gICAgICogbm8gbmV3IHJlcXVlc3QuICBJZiBubyB3YWl0IHRpbWUgaXMgZ2l2ZW4sIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICAgICAqIGF0IG1pY3JvdGFzayB0aW1pbmcgKGd1YXJhbnRlZWQgYmVmb3JlIHBhaW50KS5cbiAgICAgKlxuICAgICAqICAgICBkZWJvdW5jZWRDbGlja0FjdGlvbihlKSB7XG4gICAgICogICAgICAgLy8gd2lsbCBub3QgY2FsbCBgcHJvY2Vzc0NsaWNrYCBtb3JlIHRoYW4gb25jZSBwZXIgMTAwbXNcbiAgICAgKiAgICAgICB0aGlzLmRlYm91bmNlKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICB0aGlzLnByb2Nlc3NDbGljaygpO1xuICAgICAqICAgICAgIH0gMTAwKTtcbiAgICAgKiAgICAgfVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgU3RyaW5nIHRvIGluZGVudGlmeSB0aGUgZGVib3VuY2Ugam9iLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgRnVuY3Rpb24gdGhhdCBpcyBjYWxsZWQgKHdpdGggYHRoaXNgXG4gICAgICogICBjb250ZXh0KSB3aGVuIHRoZSB3YWl0IHRpbWUgZWxhcHNlcy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2FpdCBPcHRpb25hbCB3YWl0IHRpbWUgaW4gbWlsbGlzZWNvbmRzIChtcykgYWZ0ZXIgdGhlXG4gICAgICogICBsYXN0IHNpZ25hbCB0aGF0IG11c3QgZWxhcHNlIGJlZm9yZSBpbnZva2luZyBgY2FsbGJhY2tgXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBSZXR1cm5zIGEgZGVib3VuY2VyIG9iamVjdCBvbiB3aGljaCBleGlzdHMgdGhlXG4gICAgICogZm9sbG93aW5nIG1ldGhvZHM6IGBpc0FjdGl2ZSgpYCByZXR1cm5zIHRydWUgaWYgdGhlIGRlYm91bmNlciBpc1xuICAgICAqIGFjdGl2ZTsgYGNhbmNlbCgpYCBjYW5jZWxzIHRoZSBkZWJvdW5jZXIgaWYgaXQgaXMgYWN0aXZlO1xuICAgICAqIGBmbHVzaCgpYCBpbW1lZGlhdGVseSBpbnZva2VzIHRoZSBkZWJvdW5jZWQgY2FsbGJhY2sgaWYgdGhlIGRlYm91bmNlclxuICAgICAqIGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBkZWJvdW5jZShqb2JOYW1lLCBjYWxsYmFjaywgd2FpdCkge1xuICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICByZXR1cm4gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXSA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICAgIHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV1cbiAgICAgICAgICAsIHdhaXQgPiAwID8gdGltZU91dC5hZnRlcih3YWl0KSA6IG1pY3JvVGFza1xuICAgICAgICAgICwgY2FsbGJhY2suYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIGEgbmFtZWQgZGVib3VuY2VyIGlzIGFjdGl2ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBkZWJvdW5jZXIgaXMgYWN0aXZlIChoYXMgbm90IHlldCBmaXJlZCkuXG4gICAgICovXG4gICAgaXNEZWJvdW5jZXJBY3RpdmUoam9iTmFtZSkge1xuICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgIHJldHVybiAhIShkZWJvdW5jZXIgJiYgZGVib3VuY2VyLmlzQWN0aXZlKCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltbWVkaWF0ZWx5IGNhbGxzIHRoZSBkZWJvdW5jZXIgYGNhbGxiYWNrYCBhbmQgaW5hY3RpdmF0ZXMgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVib3VuY2VyIHN0YXJ0ZWQgd2l0aCBgZGVib3VuY2VgXG4gICAgICovXG4gICAgZmx1c2hEZWJvdW5jZXIoam9iTmFtZSkge1xuICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgIGlmIChkZWJvdW5jZXIpIHtcbiAgICAgICAgZGVib3VuY2VyLmZsdXNoKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBhY3RpdmUgZGVib3VuY2VyLiAgVGhlIGBjYWxsYmFja2Agd2lsbCBub3QgYmUgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAqL1xuICAgIGNhbmNlbERlYm91bmNlcihqb2JOYW1lKSB7XG4gICAgICB0aGlzLl9kZWJvdW5jZXJzID0gdGhpcy5fZGVib3VuY2VycyB8fCB7fTtcbiAgICAgIGxldCBkZWJvdW5jZXIgPSB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdO1xuICAgICAgaWYgKGRlYm91bmNlcikge1xuICAgICAgICBkZWJvdW5jZXIuY2FuY2VsKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUnVucyBhIGNhbGxiYWNrIGZ1bmN0aW9uIGFzeW5jcm9ub3VzbHkuXG4gICAgICpcbiAgICAgKiBCeSBkZWZhdWx0IChpZiBubyB3YWl0VGltZSBpcyBzcGVjaWZpZWQpLCBhc3luYyBjYWxsYmFja3MgYXJlIHJ1biBhdFxuICAgICAqIG1pY3JvdGFzayB0aW1pbmcsIHdoaWNoIHdpbGwgb2NjdXIgYmVmb3JlIHBhaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIHJ1biwgYm91bmQgdG8gYHRoaXNgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyPX0gd2FpdFRpbWUgVGltZSB0byB3YWl0IGJlZm9yZSBjYWxsaW5nIHRoZVxuICAgICAqICAgYGNhbGxiYWNrYC4gIElmIHVuc3BlY2lmaWVkIG9yIDAsIHRoZSBjYWxsYmFjayB3aWxsIGJlIHJ1biBhdCBtaWNyb3Rhc2tcbiAgICAgKiAgIHRpbWluZyAoYmVmb3JlIHBhaW50KS5cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB0aGF0IG1heSBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgYXN5bmMgam9iLlxuICAgICAqL1xuICAgIGFzeW5jKGNhbGxiYWNrLCB3YWl0VGltZSkge1xuICAgICAgcmV0dXJuIHdhaXRUaW1lID4gMCA/IHRpbWVPdXQucnVuKGNhbGxiYWNrLmJpbmQodGhpcyksIHdhaXRUaW1lKSA6XG4gICAgICAgICAgfm1pY3JvVGFzay5ydW4oY2FsbGJhY2suYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FuY2VscyBhbiBhc3luYyBvcGVyYXRpb24gc3RhcnRlZCB3aXRoIGBhc3luY2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIG9yaWdpbmFsIGBhc3luY2AgY2FsbCB0b1xuICAgICAqICAgY2FuY2VsLlxuICAgICAqL1xuICAgIGNhbmNlbEFzeW5jKGhhbmRsZSkge1xuICAgICAgaGFuZGxlIDwgMCA/IG1pY3JvVGFzay5jYW5jZWwofmhhbmRsZSkgOlxuICAgICAgICAgIHRpbWVPdXQuY2FuY2VsKGhhbmRsZSk7XG4gICAgfVxuXG4gICAgLy8gb3RoZXJcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgY3JlYXRpbmcgYW4gZWxlbWVudCBhbmQgY29uZmlndXJpbmcgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGFnIEhUTUwgZWxlbWVudCB0YWcgdG8gY3JlYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBPYmplY3Qgb2YgcHJvcGVydGllcyB0byBjb25maWd1cmUgb24gdGhlXG4gICAgICogICAgaW5zdGFuY2UuXG4gICAgICogQHJldHVybiB7RWxlbWVudH0gTmV3bHkgY3JlYXRlZCBhbmQgY29uZmlndXJlZCBlbGVtZW50LlxuICAgICAqL1xuICAgIGNyZWF0ZSh0YWcsIHByb3BzKSB7XG4gICAgICBsZXQgZWx0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgICAgaWYgKHByb3BzKSB7XG4gICAgICAgIGlmIChlbHQuc2V0UHJvcGVydGllcykge1xuICAgICAgICAgIGVsdC5zZXRQcm9wZXJ0aWVzKHByb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGxldCBuIGluIHByb3BzKSB7XG4gICAgICAgICAgICBlbHRbbl0gPSBwcm9wc1tuXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIGZvciBpbXBvcnRpbmcgYW4gSFRNTCBkb2N1bWVudCBpbXBlcmF0aXZlbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjcmVhdGVzIGEgbmV3IGA8bGluayByZWw9XCJpbXBvcnRcIj5gIGVsZW1lbnQgd2l0aFxuICAgICAqIHRoZSBwcm92aWRlZCBVUkwgYW5kIGFwcGVuZHMgaXQgdG8gdGhlIGRvY3VtZW50IHRvIHN0YXJ0IGxvYWRpbmcuXG4gICAgICogSW4gdGhlIGBvbmxvYWRgIGNhbGxiYWNrLCB0aGUgYGltcG9ydGAgcHJvcGVydHkgb2YgdGhlIGBsaW5rYFxuICAgICAqIGVsZW1lbnQgd2lsbCBjb250YWluIHRoZSBpbXBvcnRlZCBkb2N1bWVudCBjb250ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBocmVmIFVSTCB0byBkb2N1bWVudCB0byBsb2FkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9ubG9hZCBDYWxsYmFjayB0byBub3RpZnkgd2hlbiBhbiBpbXBvcnQgc3VjY2Vzc2Z1bGx5XG4gICAgICogICBsb2FkZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gb25lcnJvciBDYWxsYmFjayB0byBub3RpZnkgd2hlbiBhbiBpbXBvcnRcbiAgICAgKiAgIHVuc3VjY2Vzc2Z1bGx5IGxvYWRlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wdEFzeW5jIFRydWUgaWYgdGhlIGltcG9ydCBzaG91bGQgYmUgbG9hZGVkIGBhc3luY2AuXG4gICAgICogICBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICAgICAqIEByZXR1cm4ge0hUTUxMaW5rRWxlbWVudH0gVGhlIGxpbmsgZWxlbWVudCBmb3IgdGhlIFVSTCB0byBiZSBsb2FkZWQuXG4gICAgICovXG4gICAgaW1wb3J0SHJlZihocmVmLCBvbmxvYWQsIG9uZXJyb3IsIG9wdEFzeW5jKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGxldCBsb2FkRm4gPSBvbmxvYWQgPyBvbmxvYWQuYmluZCh0aGlzKSA6IG51bGw7XG4gICAgICBsZXQgZXJyb3JGbiA9IG9uZXJyb3IgPyBvbmVycm9yLmJpbmQodGhpcykgOiBudWxsO1xuICAgICAgcmV0dXJuIGltcG9ydEhyZWYkMChocmVmLCBsb2FkRm4sIGVycm9yRm4sIG9wdEFzeW5jKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb2x5ZmlsbCBmb3IgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcywgd2hpY2ggaXMgc29tZXRpbWVzIHN0aWxsXG4gICAgICogcHJlZml4ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gdGVzdC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gdGVzdCB0aGUgc2VsZWN0b3IgYWdhaW5zdC5cbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBlbGVtZW50IG1hdGNoZXMgdGhlIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIGVsZW1lbnRNYXRjaGVzKHNlbGVjdG9yLCBub2RlKSB7XG4gICAgICByZXR1cm4gbWF0Y2hlc1NlbGVjdG9yKCAobm9kZSB8fCB0aGlzKSwgc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgYW4gSFRNTCBhdHRyaWJ1dGUgb24gb3Igb2ZmLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgSFRNTCBhdHRyaWJ1dGUgbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJvb2wgQm9vbGVhbiB0byBmb3JjZSB0aGUgYXR0cmlidXRlIG9uIG9yIG9mZi5cbiAgICAgKiAgICBXaGVuIHVuc3BlY2lmaWVkLCB0aGUgc3RhdGUgb2YgdGhlIGF0dHJpYnV0ZSB3aWxsIGJlIHJldmVyc2VkLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgTm9kZSB0byB0YXJnZXQuICBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICovXG4gICAgdG9nZ2xlQXR0cmlidXRlKG5hbWUsIGJvb2wsIG5vZGUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICBib29sID0gIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGEgQ1NTIGNsYXNzIG9uIG9yIG9mZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBjbGFzcyBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gYm9vbCBCb29sZWFuIHRvIGZvcmNlIHRoZSBjbGFzcyBvbiBvciBvZmYuXG4gICAgICogICAgV2hlbiB1bnNwZWNpZmllZCwgdGhlIHN0YXRlIG9mIHRoZSBjbGFzcyB3aWxsIGJlIHJldmVyc2VkLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgTm9kZSB0byB0YXJnZXQuICBEZWZhdWx0cyB0byBgdGhpc2AuXG4gICAgICovXG4gICAgdG9nZ2xlQ2xhc3MobmFtZSwgYm9vbCwgbm9kZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIGJvb2wgPSAhbm9kZS5jbGFzc0xpc3QuY29udGFpbnMobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAoYm9vbCkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MtcGxhdGZvcm0gaGVscGVyIGZvciBzZXR0aW5nIGFuIGVsZW1lbnQncyBDU1MgYHRyYW5zZm9ybWAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHJhbnNmb3JtVGV4dCBUcmFuc2Zvcm0gc2V0dGluZy5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIEVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSB0by5cbiAgICAgKiBEZWZhdWx0cyB0byBgdGhpc2BcbiAgICAgKi9cbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtVGV4dCwgbm9kZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyk7XG4gICAgICBub2RlLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRyYW5zZm9ybVRleHQ7XG4gICAgICBub2RlLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybVRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3Jvc3MtcGxhdGZvcm0gaGVscGVyIGZvciBzZXR0aW5nIGFuIGVsZW1lbnQncyBDU1MgYHRyYW5zbGF0ZTNkYFxuICAgICAqIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggWCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgWSBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHogWiBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8uXG4gICAgICogRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAqL1xuICAgIHRyYW5zbGF0ZTNkKHgsIHksIHosIG5vZGUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgdGhpcy50cmFuc2Zvcm0oJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJywnICsgeSArICcsJyArIHogKyAnKScsIG5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYW4gaXRlbSBmcm9tIGFuIGFycmF5LCBpZiBpdCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYXJyYXkgaXMgc3BlY2lmaWVkIGJ5IHBhdGgsIGEgY2hhbmdlIG5vdGlmaWNhdGlvbiBpc1xuICAgICAqIGdlbmVyYXRlZCwgc28gdGhhdCBvYnNlcnZlcnMsIGRhdGEgYmluZGluZ3MgYW5kIGNvbXB1dGVkXG4gICAgICogcHJvcGVydGllcyB3YXRjaGluZyB0aGF0IHBhdGggY2FuIHVwZGF0ZS5cbiAgICAgKlxuICAgICAqIElmIHRoZSBhcnJheSBpcyBwYXNzZWQgZGlyZWN0bHksICoqbm8gY2hhbmdlXG4gICAgICogbm90aWZpY2F0aW9uIGlzIGdlbmVyYXRlZCoqLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8bnVtYmVyfHN0cmluZz59IGFycmF5T3JQYXRoIFBhdGggdG8gYXJyYXkgZnJvbSB3aGljaCB0byByZW1vdmUgdGhlIGl0ZW1cbiAgICAgKiAgIChvciB0aGUgYXJyYXkgaXRzZWxmKS5cbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSB0byByZW1vdmUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgaXRlbSByZW1vdmVkLlxuICAgICAqL1xuICAgIGFycmF5RGVsZXRlKGFycmF5T3JQYXRoLCBpdGVtKSB7XG4gICAgICBsZXQgaW5kZXg7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcnJheU9yUGF0aCkpIHtcbiAgICAgICAgaW5kZXggPSBhcnJheU9yUGF0aC5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHJldHVybiBhcnJheU9yUGF0aC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgYXJyID0gZ2V0JDAodGhpcywgYXJyYXlPclBhdGgpO1xuICAgICAgICBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnNwbGljZShhcnJheU9yUGF0aCwgaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBsb2dnaW5nXG5cbiAgICAvKipcbiAgICAgKiBGYWNhZGVzIGBjb25zb2xlLmxvZ2AvYHdhcm5gL2BlcnJvcmAgYXMgb3ZlcnJpZGUgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGV2ZWwgT25lIG9mICdsb2cnLCAnd2FybicsICdlcnJvcidcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgKi9cbiAgICBfbG9nZ2VyKGxldmVsLCBhcmdzKSB7XG4gICAgICAvLyBhY2NlcHQgWydmb28nLCAnYmFyJ10gYW5kIFtbJ2ZvbycsICdiYXInXV1cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3MpICYmIGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGFyZ3MgPSBhcmdzWzBdO1xuICAgICAgfVxuICAgICAgc3dpdGNoKGxldmVsKSB7XG4gICAgICAgIGNhc2UgJ2xvZyc6XG4gICAgICAgIGNhc2UgJ3dhcm4nOlxuICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgY29uc29sZVtsZXZlbF0oLi4uYXJncyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmFjYWRlcyBgY29uc29sZS5sb2dgIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgKi9cbiAgICBfbG9nKC4uLmFyZ3MpIHtcbiAgICAgIHRoaXMuX2xvZ2dlcignbG9nJywgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmFjYWRlcyBgY29uc29sZS53YXJuYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICovXG4gICAgX3dhcm4oLi4uYXJncykge1xuICAgICAgdGhpcy5fbG9nZ2VyKCd3YXJuJywgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmFjYWRlcyBgY29uc29sZS5lcnJvcmAgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAqL1xuICAgIF9lcnJvciguLi5hcmdzKSB7XG4gICAgICB0aGlzLl9sb2dnZXIoJ2Vycm9yJywgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRm9ybWF0cyBhIG1lc3NhZ2UgdXNpbmcgdGhlIGVsZW1lbnQgdHlwZSBhbiBhIG1ldGhvZCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgTWV0aG9kIG5hbWUgdG8gYXNzb2NpYXRlIHdpdGggbWVzc2FnZVxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IHdpdGggZm9ybWF0dGluZyBpbmZvcm1hdGlvbiBmb3IgYGNvbnNvbGVgXG4gICAgICogICBsb2dnaW5nLlxuICAgICAqL1xuICAgIF9sb2dmKG1ldGhvZE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgIHJldHVybiBbJ1slczo6JXNdJywgdGhpcy5pcywgbWV0aG9kTmFtZSwgLi4uYXJnc107XG4gICAgfVxuXG4gIH1cblxuICBMZWdhY3lFbGVtZW50LnByb3RvdHlwZS5pcyA9ICcnO1xuXG4gIHJldHVybiBMZWdhY3lFbGVtZW50O1xuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5qc1xuLy8gbW9kdWxlIGlkID0gMzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge25hdGl2ZVNoYWRvdywgbmF0aXZlQ3NzVmFyaWFibGVzfSBmcm9tICcuL3N0eWxlLXNldHRpbmdzLmpzJztcbmltcG9ydCB7cGFyc2UsIHN0cmluZ2lmeSwgdHlwZXMsIFN0eWxlTm9kZX0gZnJvbSAnLi9jc3MtcGFyc2UuanMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQge01FRElBX01BVENIfSBmcm9tICcuL2NvbW1vbi1yZWdleC5qcyc7XG5pbXBvcnQge3Byb2Nlc3NVbnNjb3BlZFN0eWxlLCBpc1Vuc2NvcGVkU3R5bGV9IGZyb20gJy4vdW5zY29wZWQtc3R5bGUtaGFuZGxlci5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8U3R5bGVOb2RlfSBydWxlc1xuICogQHBhcmFtIHtmdW5jdGlvbihTdHlsZU5vZGUpPX0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQ3NzVGV4dCAocnVsZXMsIGNhbGxiYWNrKSB7XG4gIGlmICghcnVsZXMpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbiAgaWYgKHR5cGVvZiBydWxlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBydWxlcyA9IHBhcnNlKHJ1bGVzKTtcbiAgfVxuICBpZiAoY2FsbGJhY2spIHtcbiAgICBmb3JFYWNoUnVsZShydWxlcywgY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBzdHJpbmdpZnkocnVsZXMsIG5hdGl2ZUNzc1ZhcmlhYmxlcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICogQHJldHVybiB7U3R5bGVOb2RlfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcnVsZXNGb3JTdHlsZShzdHlsZSkge1xuICBpZiAoIXN0eWxlWydfX2Nzc1J1bGVzJ10gJiYgc3R5bGUudGV4dENvbnRlbnQpIHtcbiAgICBzdHlsZVsnX19jc3NSdWxlcyddID0gcGFyc2Uoc3R5bGUudGV4dENvbnRlbnQpO1xuICB9XG4gIHJldHVybiBzdHlsZVsnX19jc3NSdWxlcyddIHx8IG51bGw7XG59XG5cbi8vIFRlc3RzIGlmIGEgcnVsZSBpcyBhIGtleWZyYW1lcyBzZWxlY3Rvciwgd2hpY2ggbG9va3MgYWxtb3N0IGV4YWN0bHlcbi8vIGxpa2UgYSBub3JtYWwgc2VsZWN0b3IgYnV0IGlzIG5vdCAoaXQgaGFzIG5vdGhpbmcgdG8gZG8gd2l0aCBzY29waW5nXG4vLyBmb3IgZXhhbXBsZSkuXG4vKipcbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBydWxlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNLZXlmcmFtZXNTZWxlY3RvcihydWxlKSB7XG4gIHJldHVybiBCb29sZWFuKHJ1bGVbJ3BhcmVudCddKSAmJlxuICBydWxlWydwYXJlbnQnXVsndHlwZSddID09PSB0eXBlcy5LRVlGUkFNRVNfUlVMRTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtGdW5jdGlvbj19IHN0eWxlUnVsZUNhbGxiYWNrXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0ga2V5ZnJhbWVzUnVsZUNhbGxiYWNrXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBvbmx5QWN0aXZlUnVsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZvckVhY2hSdWxlKG5vZGUsIHN0eWxlUnVsZUNhbGxiYWNrLCBrZXlmcmFtZXNSdWxlQ2FsbGJhY2ssIG9ubHlBY3RpdmVSdWxlcykge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgbGV0IHNraXBSdWxlcyA9IGZhbHNlO1xuICBsZXQgdHlwZSA9IG5vZGVbJ3R5cGUnXTtcbiAgaWYgKG9ubHlBY3RpdmVSdWxlcykge1xuICAgIGlmICh0eXBlID09PSB0eXBlcy5NRURJQV9SVUxFKSB7XG4gICAgICBsZXQgbWF0Y2hNZWRpYSA9IG5vZGVbJ3NlbGVjdG9yJ10ubWF0Y2goTUVESUFfTUFUQ0gpO1xuICAgICAgaWYgKG1hdGNoTWVkaWEpIHtcbiAgICAgICAgLy8gaWYgcnVsZSBpcyBhIG5vbiBtYXRjaGluZyBAbWVkaWEgcnVsZSwgc2tpcCBzdWJydWxlc1xuICAgICAgICBpZiAoIXdpbmRvdy5tYXRjaE1lZGlhKG1hdGNoTWVkaWFbMV0pLm1hdGNoZXMpIHtcbiAgICAgICAgICBza2lwUnVsZXMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICh0eXBlID09PSB0eXBlcy5TVFlMRV9SVUxFKSB7XG4gICAgc3R5bGVSdWxlQ2FsbGJhY2sobm9kZSk7XG4gIH0gZWxzZSBpZiAoa2V5ZnJhbWVzUnVsZUNhbGxiYWNrICYmXG4gICAgdHlwZSA9PT0gdHlwZXMuS0VZRlJBTUVTX1JVTEUpIHtcbiAgICBrZXlmcmFtZXNSdWxlQ2FsbGJhY2sobm9kZSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gdHlwZXMuTUlYSU5fUlVMRSkge1xuICAgIHNraXBSdWxlcyA9IHRydWU7XG4gIH1cbiAgbGV0IHIkID0gbm9kZVsncnVsZXMnXTtcbiAgaWYgKHIkICYmICFza2lwUnVsZXMpIHtcbiAgICBmb3IgKGxldCBpPTAsIGw9ciQubGVuZ3RoLCByOyAoaTxsKSAmJiAocj1yJFtpXSk7IGkrKykge1xuICAgICAgZm9yRWFjaFJ1bGUociwgc3R5bGVSdWxlQ2FsbGJhY2ssIGtleWZyYW1lc1J1bGVDYWxsYmFjaywgb25seUFjdGl2ZVJ1bGVzKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gYWRkIGEgc3RyaW5nIG9mIGNzc1RleHQgdG8gdGhlIGRvY3VtZW50LlxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IG1vbmlrZXJcbiAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0ge05vZGV9IGNvbnRleHROb2RlXG4gKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlDc3MoY3NzVGV4dCwgbW9uaWtlciwgdGFyZ2V0LCBjb250ZXh0Tm9kZSkge1xuICBsZXQgc3R5bGUgPSBjcmVhdGVTY29wZVN0eWxlKGNzc1RleHQsIG1vbmlrZXIpO1xuICBhcHBseVN0eWxlKHN0eWxlLCB0YXJnZXQsIGNvbnRleHROb2RlKTtcbiAgcmV0dXJuIHN0eWxlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcGFyYW0ge3N0cmluZ30gbW9uaWtlclxuICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVNjb3BlU3R5bGUoY3NzVGV4dCwgbW9uaWtlcikge1xuICBsZXQgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJykpO1xuICBpZiAobW9uaWtlcikge1xuICAgIHN0eWxlLnNldEF0dHJpYnV0ZSgnc2NvcGUnLCBtb25pa2VyKTtcbiAgfVxuICBzdHlsZS50ZXh0Q29udGVudCA9IGNzc1RleHQ7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBUcmFjayB0aGUgcG9zaXRpb24gb2YgdGhlIGxhc3QgYWRkZWQgc3R5bGUgZm9yIHBsYWNpbmcgcGxhY2Vob2xkZXJzXG4gKiBAdHlwZSB7Tm9kZX1cbiAqL1xubGV0IGxhc3RIZWFkQXBwbHlOb2RlID0gbnVsbDtcblxuLy8gaW5zZXJ0IGEgY29tbWVudCBub2RlIGFzIGEgc3R5bGluZyBwb3NpdGlvbiBwbGFjZWhvbGRlci5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1vbmlrZXJcbiAqIEByZXR1cm4geyFDb21tZW50fVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTdHlsZVBsYWNlSG9sZGVyKG1vbmlrZXIpIHtcbiAgbGV0IHBsYWNlSG9sZGVyID0gZG9jdW1lbnQuY3JlYXRlQ29tbWVudCgnIFNoYWR5IERPTSBzdHlsZXMgZm9yICcgK1xuICAgIG1vbmlrZXIgKyAnICcpO1xuICBsZXQgYWZ0ZXIgPSBsYXN0SGVhZEFwcGx5Tm9kZSA/XG4gICAgbGFzdEhlYWRBcHBseU5vZGVbJ25leHRTaWJsaW5nJ10gOiBudWxsO1xuICBsZXQgc2NvcGUgPSBkb2N1bWVudC5oZWFkO1xuICBzY29wZS5pbnNlcnRCZWZvcmUocGxhY2VIb2xkZXIsIGFmdGVyIHx8IHNjb3BlLmZpcnN0Q2hpbGQpO1xuICBsYXN0SGVhZEFwcGx5Tm9kZSA9IHBsYWNlSG9sZGVyO1xuICByZXR1cm4gcGxhY2VIb2xkZXI7XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICogQHBhcmFtIHs/Tm9kZX0gdGFyZ2V0XG4gKiBAcGFyYW0gez9Ob2RlfSBjb250ZXh0Tm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlTdHlsZShzdHlsZSwgdGFyZ2V0LCBjb250ZXh0Tm9kZSkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwgZG9jdW1lbnQuaGVhZDtcbiAgbGV0IGFmdGVyID0gKGNvbnRleHROb2RlICYmIGNvbnRleHROb2RlLm5leHRTaWJsaW5nKSB8fFxuICAgIHRhcmdldC5maXJzdENoaWxkO1xuICB0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBhZnRlcik7XG4gIGlmICghbGFzdEhlYWRBcHBseU5vZGUpIHtcbiAgICBsYXN0SGVhZEFwcGx5Tm9kZSA9IHN0eWxlO1xuICB9IGVsc2Uge1xuICAgIC8vIG9ubHkgdXBkYXRlIGxhc3RIZWFkQXBwbHlOb2RlIGlmIHRoZSBuZXcgc3R5bGUgaXMgaW5zZXJ0ZWQgYWZ0ZXIgdGhlIG9sZCBsYXN0SGVhZEFwcGx5Tm9kZVxuICAgIGxldCBwb3NpdGlvbiA9IHN0eWxlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGxhc3RIZWFkQXBwbHlOb2RlKTtcbiAgICBpZiAocG9zaXRpb24gPT09IE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fUFJFQ0VESU5HKSB7XG4gICAgICBsYXN0SGVhZEFwcGx5Tm9kZSA9IHN0eWxlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBidWlsZFR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1RhcmdldGVkQnVpbGQoYnVpbGRUeXBlKSB7XG4gIHJldHVybiBuYXRpdmVTaGFkb3cgPyBidWlsZFR5cGUgPT09ICdzaGFkb3cnIDogYnVpbGRUeXBlID09PSAnc2hhZHknO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENzc0J1aWxkVHlwZShlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY3NzLWJ1aWxkJyk7XG59XG5cbi8qKlxuICogV2FsayBmcm9tIHRleHRbc3RhcnRdIG1hdGNoaW5nIHBhcmVucyBhbmRcbiAqIHJldHVybnMgcG9zaXRpb24gb2YgdGhlIG91dGVyIGVuZCBwYXJlblxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBmaW5kTWF0Y2hpbmdQYXJlbih0ZXh0LCBzdGFydCkge1xuICBsZXQgbGV2ZWwgPSAwO1xuICBmb3IgKGxldCBpPXN0YXJ0LCBsPXRleHQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHRleHRbaV0gPT09ICcoJykge1xuICAgICAgbGV2ZWwrKztcbiAgICB9IGVsc2UgaWYgKHRleHRbaV0gPT09ICcpJykge1xuICAgICAgaWYgKC0tbGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZyl9IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayhzdHIsIGNhbGxiYWNrKSB7XG4gIC8vIGZpbmQgJ3ZhcignXG4gIGxldCBzdGFydCA9IHN0ci5pbmRleE9mKCd2YXIoJyk7XG4gIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAvLyBubyB2YXI/LCBldmVyeXRoaW5nIGlzIHByZWZpeFxuICAgIHJldHVybiBjYWxsYmFjayhzdHIsICcnLCAnJywgJycpO1xuICB9XG4gIC8vJHtwcmVmaXh9dmFyKCR7aW5uZXJ9KSR7c3VmZml4fVxuICBsZXQgZW5kID0gZmluZE1hdGNoaW5nUGFyZW4oc3RyLCBzdGFydCArIDMpO1xuICBsZXQgaW5uZXIgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0ICsgNCwgZW5kKTtcbiAgbGV0IHByZWZpeCA9IHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpO1xuICAvLyBzdWZmaXggbWF5IGhhdmUgb3RoZXIgdmFyaWFibGVzXG4gIGxldCBzdWZmaXggPSBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayhzdHIuc3Vic3RyaW5nKGVuZCArIDEpLCBjYWxsYmFjayk7XG4gIGxldCBjb21tYSA9IGlubmVyLmluZGV4T2YoJywnKTtcbiAgLy8gdmFsdWUgYW5kIGZhbGxiYWNrIGFyZ3Mgc2hvdWxkIGJlIHRyaW1tZWQgdG8gbWF0Y2ggaW4gcHJvcGVydHkgbG9va3VwXG4gIGlmIChjb21tYSA9PT0gLTEpIHtcbiAgICAvLyB2YXJpYWJsZSwgbm8gZmFsbGJhY2tcbiAgICByZXR1cm4gY2FsbGJhY2socHJlZml4LCBpbm5lci50cmltKCksICcnLCBzdWZmaXgpO1xuICB9XG4gIC8vIHZhcigke3ZhbHVlfSwke2ZhbGxiYWNrfSlcbiAgbGV0IHZhbHVlID0gaW5uZXIuc3Vic3RyaW5nKDAsIGNvbW1hKS50cmltKCk7XG4gIGxldCBmYWxsYmFjayA9IGlubmVyLnN1YnN0cmluZyhjb21tYSArIDEpLnRyaW0oKTtcbiAgcmV0dXJuIGNhbGxiYWNrKHByZWZpeCwgdmFsdWUsIGZhbGxiYWNrLCBzdWZmaXgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbGVtZW50Q2xhc3NSYXcoZWxlbWVudCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBzZXRBdHRyaWJ1dGUgcHJvdmlkZWQgYnkgU2hhZHlET00gd2hlbiBzZXRBdHRyaWJ1dGUgaXMgcGF0Y2hlZFxuICBpZiAobmF0aXZlU2hhZG93KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvd1snU2hhZHlET00nXVsnbmF0aXZlTWV0aG9kcyddWydzZXRBdHRyaWJ1dGUnXS5jYWxsKGVsZW1lbnQsICdjbGFzcycsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCB8IHtpczogc3RyaW5nLCBleHRlbmRzOiBzdHJpbmd9fSBlbGVtZW50XG4gKiBAcmV0dXJuIHt7aXM6IHN0cmluZywgdHlwZUV4dGVuc2lvbjogc3RyaW5nfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElzRXh0ZW5kcyhlbGVtZW50KSB7XG4gIGxldCBsb2NhbE5hbWUgPSBlbGVtZW50Wydsb2NhbE5hbWUnXTtcbiAgbGV0IGlzID0gJycsIHR5cGVFeHRlbnNpb24gPSAnJztcbiAgLypcbiAgTk9URTogdGVjaG5pY2FsbHksIHRoaXMgY2FuIGJlIHdyb25nIGZvciBjZXJ0YWluIHN2ZyBlbGVtZW50c1xuICB3aXRoIGAtYCBpbiB0aGUgbmFtZSBsaWtlIGA8Zm9udC1mYWNlPmBcbiAgKi9cbiAgaWYgKGxvY2FsTmFtZSkge1xuICAgIGlmIChsb2NhbE5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGlzID0gbG9jYWxOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlRXh0ZW5zaW9uID0gbG9jYWxOYW1lO1xuICAgICAgaXMgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lzJykpIHx8ICcnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpcyA9IC8qKiBAdHlwZSB7P30gKi8oZWxlbWVudCkuaXM7XG4gICAgdHlwZUV4dGVuc2lvbiA9IC8qKiBAdHlwZSB7P30gKi8oZWxlbWVudCkuZXh0ZW5kcztcbiAgfVxuICByZXR1cm4ge2lzLCB0eXBlRXh0ZW5zaW9ufTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2F0aGVyU3R5bGVUZXh0KGVsZW1lbnQpIHtcbiAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3Qgc3R5bGVUZXh0UGFydHMgPSBbXTtcbiAgY29uc3Qgc3R5bGVzID0gLyoqIEB0eXBlIHshTm9kZUxpc3Q8IUhUTUxTdHlsZUVsZW1lbnQ+fSAqLyhlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJykpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzW2ldO1xuICAgIGlmIChpc1Vuc2NvcGVkU3R5bGUoc3R5bGUpKSB7XG4gICAgICBpZiAoIW5hdGl2ZVNoYWRvdykge1xuICAgICAgICBwcm9jZXNzVW5zY29wZWRTdHlsZShzdHlsZSk7XG4gICAgICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVRleHRQYXJ0cy5wdXNoKHN0eWxlLnRleHRDb250ZW50KTtcbiAgICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVUZXh0UGFydHMuam9pbignJykudHJpbSgpO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS11dGlsLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQGNvbnN0IHshT2JqZWN0PHN0cmluZywgIUhUTUxUZW1wbGF0ZUVsZW1lbnQ+fVxuICovXG5jb25zdCB0ZW1wbGF0ZU1hcCA9IHt9O1xuZXhwb3J0IGRlZmF1bHQgdGVtcGxhdGVNYXA7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvdGVtcGxhdGUtbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSAzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKiBAdHlwZSB7UHJvbWlzZTx2b2lkPn0gKi9cbmxldCByZWFkeVByb21pc2UgPSBudWxsO1xuXG4vKiogQHR5cGUgez9mdW5jdGlvbig/ZnVuY3Rpb24oKSl9ICovXG5sZXQgd2hlblJlYWR5ID0gd2luZG93WydIVE1MSW1wb3J0cyddICYmIHdpbmRvd1snSFRNTEltcG9ydHMnXVsnd2hlblJlYWR5J10gfHwgbnVsbDtcblxuLyoqIEB0eXBlIHtmdW5jdGlvbigpfSAqL1xubGV0IHJlc29sdmVGbjtcblxuLyoqXG4gKiBAcGFyYW0gez9mdW5jdGlvbigpfSBjYWxsYmFja1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBkb2N1bWVudFdhaXQoY2FsbGJhY2spIHtcbiAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgIGlmICh3aGVuUmVhZHkpIHtcbiAgICAgIHdoZW5SZWFkeShjYWxsYmFjaylcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFyZWFkeVByb21pc2UpIHtcbiAgICAgICAgcmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtyZXNvbHZlRm4gPSByZXNvbHZlfSk7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgcmVzb2x2ZUZuKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVGbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWFkeVByb21pc2UudGhlbihmdW5jdGlvbigpeyBjYWxsYmFjayAmJiBjYWxsYmFjaygpOyB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2RvY3VtZW50LXdhaXQuanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGRvY3VtZW50V2FpdCBmcm9tICcuL2RvY3VtZW50LXdhaXQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtIVE1MU3R5bGVFbGVtZW50IHwge2dldFN0eWxlOiBmdW5jdGlvbigpOkhUTUxTdHlsZUVsZW1lbnR9fVxuICovXG5leHBvcnQgbGV0IEN1c3RvbVN0eWxlUHJvdmlkZXI7XG5cbmNvbnN0IFNFRU5fTUFSS0VSID0gJ19fc2VlbkJ5U2hhZHlDU1MnO1xuY29uc3QgQ0FDSEVEX1NUWUxFID0gJ19fc2hhZHlDU1NDYWNoZWRTdHlsZSc7XG5cbi8qKiBAdHlwZSB7P2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KX0gKi9cbmxldCB0cmFuc2Zvcm1GbiA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P2Z1bmN0aW9uKCl9ICovXG5sZXQgdmFsaWRhdGVGbiA9IG51bGw7XG5cbi8qKlxuVGhpcyBpbnRlcmZhY2UgaXMgcHJvdmlkZWQgdG8gYWRkIGRvY3VtZW50LWxldmVsIDxzdHlsZT4gZWxlbWVudHMgdG8gU2hhZHlDU1MgZm9yIHByb2Nlc3NpbmcuXG5UaGVzZSBzdHlsZXMgbXVzdCBiZSBwcm9jZXNzZWQgYnkgU2hhZHlDU1MgdG8gc2ltdWxhdGUgU2hhZG93Um9vdCB1cHBlci1ib3VuZCBlbmNhcHN1bGF0aW9uIGZyb20gb3V0c2lkZSBzdHlsZXNcbkluIGFkZGl0aW9uLCB0aGVzZSBzdHlsZXMgbWF5IGFsc28gbmVlZCB0byBiZSBwcm9jZXNzZWQgZm9yIEBhcHBseSBydWxlcyBhbmQgQ1NTIEN1c3RvbSBQcm9wZXJ0aWVzXG5cblRvIGFkZCBkb2N1bWVudC1sZXZlbCBzdHlsZXMgdG8gU2hhZHlDU1MsIG9uZSBjYW4gY2FsbCBgU2hhZHlDU1MuYWRkRG9jdW1lbnRTdHlsZShzdHlsZUVsZW1lbnQpYCBvciBgU2hhZHlDU1MuYWRkRG9jdW1lbnRTdHlsZSh7Z2V0U3R5bGU6ICgpID0+IHN0eWxlRWxlbWVudH0pYFxuXG5JbiBhZGRpdGlvbiwgaWYgdGhlIHByb2Nlc3MgdXNlZCB0byBkaXNjb3ZlciBkb2N1bWVudC1sZXZlbCBzdHlsZXMgY2FuIGJlIHN5bmNocm9ub3VzbHkgZmx1c2hlZCwgb25lIHNob3VsZCBzZXQgYFNoYWR5Q1NTLmRvY3VtZW50U3R5bGVGbHVzaGAuXG5UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gY2FsY3VsYXRpbmcgc3R5bGVzLlxuXG5BbiBleGFtcGxlIHVzYWdlIG9mIHRoZSBkb2N1bWVudC1sZXZlbCBzdHlsaW5nIGFwaSBjYW4gYmUgZm91bmQgaW4gYGV4YW1wbGVzL2RvY3VtZW50LXN0eWxlLWxpYi5qc2BcblxuQHVucmVzdHJpY3RlZFxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbVN0eWxlSW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHshQXJyYXk8IUN1c3RvbVN0eWxlUHJvdmlkZXI+fSAqL1xuICAgIHRoaXNbJ2N1c3RvbVN0eWxlcyddID0gW107XG4gICAgdGhpc1snZW5xdWV1ZWQnXSA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBRdWV1ZSBhIHZhbGlkYXRpb24gZm9yIG5ldyBjdXN0b20gc3R5bGVzIHRvIGJhdGNoIHN0eWxlIHJlY2FsY3VsYXRpb25zXG4gICAqL1xuICBlbnF1ZXVlRG9jdW1lbnRWYWxpZGF0aW9uKCkge1xuICAgIGlmICh0aGlzWydlbnF1ZXVlZCddIHx8ICF2YWxpZGF0ZUZuKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXNbJ2VucXVldWVkJ10gPSB0cnVlO1xuICAgIGRvY3VtZW50V2FpdCh2YWxpZGF0ZUZuKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAgICovXG4gIGFkZEN1c3RvbVN0eWxlKHN0eWxlKSB7XG4gICAgaWYgKCFzdHlsZVtTRUVOX01BUktFUl0pIHtcbiAgICAgIHN0eWxlW1NFRU5fTUFSS0VSXSA9IHRydWU7XG4gICAgICB0aGlzWydjdXN0b21TdHlsZXMnXS5wdXNoKHN0eWxlKTtcbiAgICAgIHRoaXMuZW5xdWV1ZURvY3VtZW50VmFsaWRhdGlvbigpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshQ3VzdG9tU3R5bGVQcm92aWRlcn0gY3VzdG9tU3R5bGVcbiAgICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH1cbiAgICovXG4gIGdldFN0eWxlRm9yQ3VzdG9tU3R5bGUoY3VzdG9tU3R5bGUpIHtcbiAgICBpZiAoY3VzdG9tU3R5bGVbQ0FDSEVEX1NUWUxFXSkge1xuICAgICAgcmV0dXJuIGN1c3RvbVN0eWxlW0NBQ0hFRF9TVFlMRV07XG4gICAgfVxuICAgIGxldCBzdHlsZTtcbiAgICBpZiAoY3VzdG9tU3R5bGVbJ2dldFN0eWxlJ10pIHtcbiAgICAgIHN0eWxlID0gY3VzdG9tU3R5bGVbJ2dldFN0eWxlJ10oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUgPSBjdXN0b21TdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJuIHshQXJyYXk8IUN1c3RvbVN0eWxlUHJvdmlkZXI+fVxuICAgKi9cbiAgcHJvY2Vzc1N0eWxlcygpIHtcbiAgICBjb25zdCBjcyA9IHRoaXNbJ2N1c3RvbVN0eWxlcyddO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGN1c3RvbVN0eWxlID0gY3NbaV07XG4gICAgICBpZiAoY3VzdG9tU3R5bGVbQ0FDSEVEX1NUWUxFXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0eWxlID0gdGhpcy5nZXRTdHlsZUZvckN1c3RvbVN0eWxlKGN1c3RvbVN0eWxlKTtcbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAvLyBIVE1MSW1wb3J0cyBwb2x5ZmlsbCBtYXkgaGF2ZSBjbG9uZWQgdGhlIHN0eWxlIGludG8gdGhlIG1haW4gZG9jdW1lbnQsXG4gICAgICAgIC8vIHdoaWNoIGlzIHJlZmVyZW5jZWQgd2l0aCBfX2FwcGxpZWRFbGVtZW50LlxuICAgICAgICBjb25zdCBzdHlsZVRvVHJhbnNmb3JtID0gLyoqIEB0eXBlIHshSFRNTFN0eWxlRWxlbWVudH0gKi8oc3R5bGVbJ19fYXBwbGllZEVsZW1lbnQnXSB8fCBzdHlsZSk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1Gbikge1xuICAgICAgICAgIHRyYW5zZm9ybUZuKHN0eWxlVG9UcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgICAgIGN1c3RvbVN0eWxlW0NBQ0hFRF9TVFlMRV0gPSBzdHlsZVRvVHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3M7XG4gIH1cbn1cblxuQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlWydhZGRDdXN0b21TdHlsZSddID0gQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlLmFkZEN1c3RvbVN0eWxlO1xuQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlWydnZXRTdHlsZUZvckN1c3RvbVN0eWxlJ10gPSBDdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGUuZ2V0U3R5bGVGb3JDdXN0b21TdHlsZTtcbkN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZVsncHJvY2Vzc1N0eWxlcyddID0gQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlLnByb2Nlc3NTdHlsZXM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZSwge1xuICAndHJhbnNmb3JtQ2FsbGJhY2snOiB7XG4gICAgLyoqIEByZXR1cm4gez9mdW5jdGlvbighSFRNTFN0eWxlRWxlbWVudCl9ICovXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRyYW5zZm9ybUZuO1xuICAgIH0sXG4gICAgLyoqIEBwYXJhbSB7P2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KX0gZm4gKi9cbiAgICBzZXQoZm4pIHtcbiAgICAgIHRyYW5zZm9ybUZuID0gZm47XG4gICAgfVxuICB9LFxuICAndmFsaWRhdGVDYWxsYmFjayc6IHtcbiAgICAvKiogQHJldHVybiB7P2Z1bmN0aW9uKCl9ICovXG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlRm47XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gez9mdW5jdGlvbigpfSBmblxuICAgICAqIEB0aGlzIHtDdXN0b21TdHlsZUludGVyZmFjZX1cbiAgICAgKi9cbiAgICBzZXQoZm4pIHtcbiAgICAgIGxldCBuZWVkc0VucXVldWUgPSBmYWxzZTtcbiAgICAgIGlmICghdmFsaWRhdGVGbikge1xuICAgICAgICBuZWVkc0VucXVldWUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFsaWRhdGVGbiA9IGZuO1xuICAgICAgaWYgKG5lZWRzRW5xdWV1ZSkge1xuICAgICAgICB0aGlzLmVucXVldWVEb2N1bWVudFZhbGlkYXRpb24oKTtcbiAgICAgIH1cbiAgICB9LFxuICB9XG59KVxuXG4vKiogQHR5cGVkZWYge3tcbiAqIGN1c3RvbVN0eWxlczogIUFycmF5PCFDdXN0b21TdHlsZVByb3ZpZGVyPixcbiAqIGFkZEN1c3RvbVN0eWxlOiBmdW5jdGlvbighQ3VzdG9tU3R5bGVQcm92aWRlciksXG4gKiBnZXRTdHlsZUZvckN1c3RvbVN0eWxlOiBmdW5jdGlvbighQ3VzdG9tU3R5bGVQcm92aWRlcik6IEhUTUxTdHlsZUVsZW1lbnQsXG4gKiBmaW5kU3R5bGVzOiBmdW5jdGlvbigpLFxuICogdHJhbnNmb3JtQ2FsbGJhY2s6ID9mdW5jdGlvbighSFRNTFN0eWxlRWxlbWVudCksXG4gKiB2YWxpZGF0ZUNhbGxiYWNrOiA/ZnVuY3Rpb24oKVxuICogfX1cbiAqL1xuZXhwb3J0IGxldCBDdXN0b21TdHlsZUludGVyZmFjZUludGVyZmFjZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSAzN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyByZXNvbHZlQ3NzIH0gZnJvbSAnLi9yZXNvbHZlLXVybC5qcyc7XG5cbmNvbnN0IE1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SID0gJ2xpbmtbcmVsPWltcG9ydF1bdHlwZX49Y3NzXSc7XG5jb25zdCBJTkNMVURFX0FUVFIgPSAnaW5jbHVkZSc7XG5cbmZ1bmN0aW9uIGltcG9ydE1vZHVsZShtb2R1bGVJZCkge1xuICBjb25zdCAvKiogUG9seW1lci5Eb21Nb2R1bGUgKi8gUG9seW1lckRvbU1vZHVsZSA9IGN1c3RvbUVsZW1lbnRzLmdldCgnZG9tLW1vZHVsZScpO1xuICBpZiAoIVBvbHltZXJEb21Nb2R1bGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gUG9seW1lckRvbU1vZHVsZS5pbXBvcnQobW9kdWxlSWQpO1xufVxuXG4vKiogQHR5cGVkZWYge3thc3NldHBhdGg6IHN0cmluZ319ICovXG5sZXQgdGVtcGxhdGVXaXRoQXNzZXRQYXRoOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tTW9kdWxlcyhtb2R1bGVJZHMpIHtcbiAgbGV0IG1vZHVsZXMgPSBtb2R1bGVJZHMudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gIGxldCBjc3NUZXh0ID0gJyc7XG4gIGZvciAobGV0IGk9MDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjc3NUZXh0ICs9IGNzc0Zyb21Nb2R1bGUobW9kdWxlc1tpXSk7XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tTW9kdWxlKG1vZHVsZUlkKSB7XG4gIGxldCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcbiAgaWYgKG0gJiYgbS5fY3NzVGV4dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gbW9kdWxlIGltcG9ydHM6IDxsaW5rIHJlbD1cImltcG9ydFwiIHR5cGU9XCJjc3NcIj5cbiAgICBsZXQgY3NzVGV4dCA9IF9jc3NGcm9tTW9kdWxlSW1wb3J0cyhtKTtcbiAgICAvLyBpbmNsdWRlIGNzcyBmcm9tIHRoZSBmaXJzdCB0ZW1wbGF0ZSBpbiB0aGUgbW9kdWxlXG4gICAgbGV0IHQgPSBtLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgaWYgKHQpIHtcbiAgICAgIGNzc1RleHQgKz0gY3NzRnJvbVRlbXBsYXRlKHQsIC8qKiBAdHlwZSB7dGVtcGxhdGVXaXRoQXNzZXRQYXRofSAqLyhtKS5hc3NldHBhdGgpO1xuICAgIH1cbiAgICBtLl9jc3NUZXh0ID0gY3NzVGV4dCB8fCBudWxsO1xuICB9XG4gIGlmICghbSkge1xuICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGZpbmQgc3R5bGUgZGF0YSBpbiBtb2R1bGUgbmFtZWQnLCBtb2R1bGVJZCk7XG4gIH1cbiAgcmV0dXJuIG0gJiYgbS5fY3NzVGV4dCB8fCAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSkge1xuICBsZXQgY3NzVGV4dCA9ICcnO1xuICAvLyBpZiBlbGVtZW50IGlzIGEgdGVtcGxhdGUsIGdldCBjb250ZW50IGZyb20gaXRzIC5jb250ZW50XG4gIGxldCBlJCA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGUnKTtcbiAgZm9yIChsZXQgaT0wOyBpIDwgZSQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgZSA9IGUkW2ldO1xuICAgIC8vIHN1cHBvcnQgc3R5bGUgc2hhcmluZyBieSBhbGxvd2luZyBzdHlsZXMgdG8gXCJpbmNsdWRlXCJcbiAgICAvLyBvdGhlciBkb20tbW9kdWxlcyB0aGF0IGNvbnRhaW4gc3R5bGluZ1xuICAgIGxldCBpbmNsdWRlID0gZS5nZXRBdHRyaWJ1dGUoSU5DTFVERV9BVFRSKTtcbiAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgY3NzVGV4dCArPSBjc3NGcm9tTW9kdWxlcyhpbmNsdWRlKTtcbiAgICB9XG4gICAgZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpO1xuICAgIGNzc1RleHQgKz0gYmFzZVVSSSA/XG4gICAgICByZXNvbHZlQ3NzKGUudGV4dENvbnRlbnQsIGJhc2VVUkkpIDogZS50ZXh0Q29udGVudDtcbiAgfVxuICByZXR1cm4gY3NzVGV4dDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNzc0Zyb21Nb2R1bGVJbXBvcnRzKG1vZHVsZUlkKSB7XG4gIGxldCBtID0gaW1wb3J0TW9kdWxlKG1vZHVsZUlkKTtcbiAgcmV0dXJuIG0gPyBfY3NzRnJvbU1vZHVsZUltcG9ydHMobSkgOiAnJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9jc3NGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGUpIHtcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgbGV0IHAkID0gbW9kdWxlLnF1ZXJ5U2VsZWN0b3JBbGwoTU9EVUxFX1NUWUxFX0xJTktfU0VMRUNUT1IpO1xuICBmb3IgKGxldCBpPTA7IGkgPCBwJC5sZW5ndGg7IGkrKykge1xuICAgIGxldCBwID0gcCRbaV07XG4gICAgaWYgKHAuaW1wb3J0KSB7XG4gICAgICBsZXQgaW1wb3J0RG9jID0gcC5pbXBvcnQ7XG4gICAgICAvLyBOT1RFOiBwb2x5ZmlsbCBhZmZvcmRhbmNlLlxuICAgICAgLy8gdW5kZXIgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsLCB0aGVyZSB3aWxsIGJlIG5vICdib2R5JyxcbiAgICAgIC8vIGJ1dCB0aGUgaW1wb3J0IHBzZXVkby1kb2MgY2FuIGJlIHVzZWQgZGlyZWN0bHkuXG4gICAgICBsZXQgY29udGFpbmVyID0gaW1wb3J0RG9jLmJvZHkgPyBpbXBvcnREb2MuYm9keSA6IGltcG9ydERvYztcbiAgICAgIGNzc1RleHQgKz1cbiAgICAgICAgcmVzb2x2ZUNzcyhjb250YWluZXIudGV4dENvbnRlbnQsXG4gICAgICAgICAgaW1wb3J0RG9jLmJhc2VVUkkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY3NzVGV4dDtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3N0eWxlLWdhdGhlci5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgKiBhcyBnZXN0dXJlcyQwIGZyb20gJy4uL3V0aWxzL2dlc3R1cmVzLmpzJztcblxuLyoqXG4gKiBAY29uc3Qge1BvbHltZXIuR2VzdHVyZXN9XG4gKi9cbmNvbnN0IGdlc3R1cmVzID0gZ2VzdHVyZXMkMDtcblxuZXhwb3J0IGNvbnN0IEdlc3R1cmVFdmVudExpc3RlbmVycyA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICovXG4gIGNsYXNzIEdlc3R1cmVFdmVudExpc3RlbmVycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIWdlc3R1cmVzLmFkZExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikpIHtcbiAgICAgICAgc3VwZXIuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCFnZXN0dXJlcy5yZW1vdmVMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpKSB7XG4gICAgICAgIHN1cGVyLl9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBHZXN0dXJlRXZlbnRMaXN0ZW5lcnM7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmZ1bmN0aW9uIG5ld1NwbGljZShpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudCkge1xuICByZXR1cm4ge1xuICAgIGluZGV4OiBpbmRleCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnRcbiAgfTtcbn1cblxuY29uc3QgRURJVF9MRUFWRSA9IDA7XG5jb25zdCBFRElUX1VQREFURSA9IDE7XG5jb25zdCBFRElUX0FERCA9IDI7XG5jb25zdCBFRElUX0RFTEVURSA9IDM7XG5cbi8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgKmJhc2VkKiBvbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIExldmVuc2h0ZWluXG4vLyBcImVkaXRcIiBkaXN0YW5jZS4gVGhlIG9uZSBjaGFuZ2UgaXMgdGhhdCBcInVwZGF0ZXNcIiBhcmUgdHJlYXRlZCBhcyB0d29cbi8vIGVkaXRzIC0gbm90IG9uZS4gV2l0aCBBcnJheSBzcGxpY2VzLCBhbiB1cGRhdGUgaXMgcmVhbGx5IGEgZGVsZXRlXG4vLyBmb2xsb3dlZCBieSBhbiBhZGQuIEJ5IHJldGFpbmluZyB0aGlzLCB3ZSBvcHRpbWl6ZSBmb3IgXCJrZWVwaW5nXCIgdGhlXG4vLyBtYXhpbXVtIGFycmF5IGl0ZW1zIGluIHRoZSBvcmlnaW5hbCBhcnJheS4gRm9yIGV4YW1wbGU6XG4vL1xuLy8gICAneHh4eDEyMycgLT4gJzEyM3l5eXknXG4vL1xuLy8gV2l0aCAxLWVkaXQgdXBkYXRlcywgdGhlIHNob3J0ZXN0IHBhdGggd291bGQgYmUganVzdCB0byB1cGRhdGUgYWxsIHNldmVuXG4vLyBjaGFyYWN0ZXJzLiBXaXRoIDItZWRpdCB1cGRhdGVzLCB3ZSBkZWxldGUgNCwgbGVhdmUgMywgYW5kIGFkZCA0LiBUaGlzXG4vLyBsZWF2ZXMgdGhlIHN1YnN0cmluZyAnMTIzJyBpbnRhY3QuXG5mdW5jdGlvbiBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gIC8vIFwiRGVsZXRpb25cIiBjb2x1bW5zXG4gIGxldCByb3dDb3VudCA9IG9sZEVuZCAtIG9sZFN0YXJ0ICsgMTtcbiAgbGV0IGNvbHVtbkNvdW50ID0gY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCArIDE7XG4gIGxldCBkaXN0YW5jZXMgPSBuZXcgQXJyYXkocm93Q291bnQpO1xuXG4gIC8vIFwiQWRkaXRpb25cIiByb3dzLiBJbml0aWFsaXplIG51bGwgY29sdW1uLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBkaXN0YW5jZXNbaV0gPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpO1xuICAgIGRpc3RhbmNlc1tpXVswXSA9IGk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIG51bGwgcm93XG4gIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uQ291bnQ7IGorKylcbiAgICBkaXN0YW5jZXNbMF1bal0gPSBqO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDwgY29sdW1uQ291bnQ7IGorKykge1xuICAgICAgaWYgKGVxdWFscyhjdXJyZW50W2N1cnJlbnRTdGFydCArIGogLSAxXSwgb2xkW29sZFN0YXJ0ICsgaSAtIDFdKSlcbiAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IG5vcnRoID0gZGlzdGFuY2VzW2kgLSAxXVtqXSArIDE7XG4gICAgICAgIGxldCB3ZXN0ID0gZGlzdGFuY2VzW2ldW2ogLSAxXSArIDE7XG4gICAgICAgIGRpc3RhbmNlc1tpXVtqXSA9IG5vcnRoIDwgd2VzdCA/IG5vcnRoIDogd2VzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzdGFuY2VzO1xufVxuXG4vLyBUaGlzIHN0YXJ0cyBhdCB0aGUgZmluYWwgd2VpZ2h0LCBhbmQgd2Fsa3MgXCJiYWNrd2FyZFwiIGJ5IGZpbmRpbmdcbi8vIHRoZSBtaW5pbXVtIHByZXZpb3VzIHdlaWdodCByZWN1cnNpdmVseSB1bnRpbCB0aGUgb3JpZ2luIG9mIHRoZSB3ZWlnaHRcbi8vIG1hdHJpeC5cbmZ1bmN0aW9uIHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhkaXN0YW5jZXMpIHtcbiAgbGV0IGkgPSBkaXN0YW5jZXMubGVuZ3RoIC0gMTtcbiAgbGV0IGogPSBkaXN0YW5jZXNbMF0ubGVuZ3RoIC0gMTtcbiAgbGV0IGN1cnJlbnQgPSBkaXN0YW5jZXNbaV1bal07XG4gIGxldCBlZGl0cyA9IFtdO1xuICB3aGlsZSAoaSA+IDAgfHwgaiA+IDApIHtcbiAgICBpZiAoaSA9PSAwKSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgIGotLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaiA9PSAwKSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgIGktLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgbm9ydGhXZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgbGV0IHdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2pdO1xuICAgIGxldCBub3J0aCA9IGRpc3RhbmNlc1tpXVtqIC0gMV07XG5cbiAgICBsZXQgbWluO1xuICAgIGlmICh3ZXN0IDwgbm9ydGgpXG4gICAgICBtaW4gPSB3ZXN0IDwgbm9ydGhXZXN0ID8gd2VzdCA6IG5vcnRoV2VzdDtcbiAgICBlbHNlXG4gICAgICBtaW4gPSBub3J0aCA8IG5vcnRoV2VzdCA/IG5vcnRoIDogbm9ydGhXZXN0O1xuXG4gICAgaWYgKG1pbiA9PSBub3J0aFdlc3QpIHtcbiAgICAgIGlmIChub3J0aFdlc3QgPT0gY3VycmVudCkge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfTEVBVkUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX1VQREFURSk7XG4gICAgICAgIGN1cnJlbnQgPSBub3J0aFdlc3Q7XG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBqLS07XG4gICAgfSBlbHNlIGlmIChtaW4gPT0gd2VzdCkge1xuICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICBpLS07XG4gICAgICBjdXJyZW50ID0gd2VzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG4gICAgICBqLS07XG4gICAgICBjdXJyZW50ID0gbm9ydGg7XG4gICAgfVxuICB9XG5cbiAgZWRpdHMucmV2ZXJzZSgpO1xuICByZXR1cm4gZWRpdHM7XG59XG5cbi8qKlxuICogU3BsaWNlIFByb2plY3Rpb24gZnVuY3Rpb25zOlxuICpcbiAqIEEgc3BsaWNlIG1hcCBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIGhvdyBhIHByZXZpb3VzIGFycmF5IG9mIGl0ZW1zXG4gKiB3YXMgdHJhbnNmb3JtZWQgaW50byBhIG5ldyBhcnJheSBvZiBpdGVtcy4gQ29uY2VwdHVhbGx5IGl0IGlzIGEgbGlzdCBvZlxuICogdHVwbGVzIG9mXG4gKlxuICogICA8aW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQ+XG4gKlxuICogd2hpY2ggYXJlIGtlcHQgaW4gYXNjZW5kaW5nIGluZGV4IG9yZGVyIG9mLiBUaGUgdHVwbGUgcmVwcmVzZW50cyB0aGF0IGF0XG4gKiB0aGUgfGluZGV4fCwgfHJlbW92ZWR8IHNlcXVlbmNlIG9mIGl0ZW1zIHdlcmUgcmVtb3ZlZCwgYW5kIGNvdW50aW5nIGZvcndhcmRcbiAqIGZyb20gfGluZGV4fCwgfGFkZGVkQ291bnR8IGl0ZW1zIHdlcmUgYWRkZWQuXG4gKi9cblxuLyoqXG4gKiBMYWNraW5nIGluZGl2aWR1YWwgc3BsaWNlIG11dGF0aW9uIGluZm9ybWF0aW9uLCB0aGUgbWluaW1hbCBzZXQgb2ZcbiAqIHNwbGljZXMgY2FuIGJlIHN5bnRoZXNpemVkIGdpdmVuIHRoZSBwcmV2aW91cyBzdGF0ZSBhbmQgZmluYWwgc3RhdGUgb2YgYW5cbiAqIGFycmF5LiBUaGUgYmFzaWMgYXBwcm9hY2ggaXMgdG8gY2FsY3VsYXRlIHRoZSBlZGl0IGRpc3RhbmNlIG1hdHJpeCBhbmRcbiAqIGNob29zZSB0aGUgc2hvcnRlc3QgcGF0aCB0aHJvdWdoIGl0LlxuICpcbiAqIENvbXBsZXhpdHk6IE8obCAqIHApXG4gKiAgIGw6IFRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgYXJyYXlcbiAqICAgcDogVGhlIGxlbmd0aCBvZiB0aGUgb2xkIGFycmF5XG4gKlxuICogQHBhcmFtIHtBcnJheX0gY3VycmVudCBUaGUgY3VycmVudCBcImNoYW5nZWRcIiBhcnJheSBmb3Igd2hpY2ggdG9cbiAqIGNhbGN1bGF0ZSBzcGxpY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRTdGFydCBTdGFydGluZyBpbmRleCBpbiB0aGUgYGN1cnJlbnRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50RW5kIEVuZGluZyBpbmRleCBpbiB0aGUgYGN1cnJlbnRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEBwYXJhbSB7QXJyYXl9IG9sZCBUaGUgb3JpZ2luYWwgXCJ1bmNoYW5nZWRcIiBhcnJheSB0byBjb21wYXJlIGBjdXJyZW50YFxuICogYWdhaW5zdCB0byBkZXRlcm1pbmUgc3BsaWNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvbGRTdGFydCBTdGFydGluZyBpbmRleCBpbiB0aGUgYG9sZGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IG9sZEVuZCBFbmRpbmcgaW5kZXggaW4gdGhlIGBvbGRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNwbGljZSByZWNvcmQgb2JqZWN0cy4gRWFjaCBvZiB0aGVzZVxuICogY29udGFpbnM6IGBpbmRleGAgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBzcGxpY2Ugb2NjdXJyZWQ7IGByZW1vdmVkYFxuICogdGhlIGFycmF5IG9mIHJlbW92ZWQgaXRlbXMgZnJvbSB0aGlzIGxvY2F0aW9uOyBgYWRkZWRDb3VudGAgdGhlIG51bWJlclxuICogb2YgaXRlbXMgYWRkZWQgYXQgdGhpcyBsb2NhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FsY1NwbGljZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuICBsZXQgcHJlZml4Q291bnQgPSAwO1xuICBsZXQgc3VmZml4Q291bnQgPSAwO1xuICBsZXQgc3BsaWNlO1xuXG4gIGxldCBtaW5MZW5ndGggPSBNYXRoLm1pbihjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0LCBvbGRFbmQgLSBvbGRTdGFydCk7XG4gIGlmIChjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRTdGFydCA9PSAwKVxuICAgIHByZWZpeENvdW50ID0gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoKTtcblxuICBpZiAoY3VycmVudEVuZCA9PSBjdXJyZW50Lmxlbmd0aCAmJiBvbGRFbmQgPT0gb2xkLmxlbmd0aClcbiAgICBzdWZmaXhDb3VudCA9IHNoYXJlZFN1ZmZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCAtIHByZWZpeENvdW50KTtcblxuICBjdXJyZW50U3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gIG9sZFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICBjdXJyZW50RW5kIC09IHN1ZmZpeENvdW50O1xuICBvbGRFbmQgLT0gc3VmZml4Q291bnQ7XG5cbiAgaWYgKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRFbmQgLSBvbGRTdGFydCA9PSAwKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAoY3VycmVudFN0YXJ0ID09IGN1cnJlbnRFbmQpIHtcbiAgICBzcGxpY2UgPSBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgMCk7XG4gICAgd2hpbGUgKG9sZFN0YXJ0IDwgb2xkRW5kKVxuICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkU3RhcnQrK10pO1xuXG4gICAgcmV0dXJuIFsgc3BsaWNlIF07XG4gIH0gZWxzZSBpZiAob2xkU3RhcnQgPT0gb2xkRW5kKVxuICAgIHJldHVybiBbIG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0KSBdO1xuXG4gIGxldCBvcHMgPSBzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMoXG4gICAgICBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkpO1xuXG4gIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgbGV0IHNwbGljZXMgPSBbXTtcbiAgbGV0IGluZGV4ID0gY3VycmVudFN0YXJ0O1xuICBsZXQgb2xkSW5kZXggPSBvbGRTdGFydDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2gob3BzW2ldKSB7XG4gICAgICBjYXNlIEVESVRfTEVBVkU6XG4gICAgICAgIGlmIChzcGxpY2UpIHtcbiAgICAgICAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgICAgICAgICBzcGxpY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRURJVF9VUERBVEU6XG4gICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVESVRfQUREOlxuICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRURJVF9ERUxFVEU6XG4gICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzcGxpY2UpIHtcbiAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgfVxuICByZXR1cm4gc3BsaWNlcztcbn1cblxuZnVuY3Rpb24gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoTGVuZ3RoOyBpKyspXG4gICAgaWYgKCFlcXVhbHMoY3VycmVudFtpXSwgb2xkW2ldKSlcbiAgICAgIHJldHVybiBpO1xuICByZXR1cm4gc2VhcmNoTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgbGV0IGluZGV4MSA9IGN1cnJlbnQubGVuZ3RoO1xuICBsZXQgaW5kZXgyID0gb2xkLmxlbmd0aDtcbiAgbGV0IGNvdW50ID0gMDtcbiAgd2hpbGUgKGNvdW50IDwgc2VhcmNoTGVuZ3RoICYmIGVxdWFscyhjdXJyZW50Wy0taW5kZXgxXSwgb2xkWy0taW5kZXgyXSkpXG4gICAgY291bnQrKztcblxuICByZXR1cm4gY291bnQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwbGljZXMoY3VycmVudCwgcHJldmlvdXMpIHtcbiAgcmV0dXJuIGNhbGNTcGxpY2VzKGN1cnJlbnQsIDAsIGN1cnJlbnQubGVuZ3RoLCBwcmV2aW91cywgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gZXF1YWxzKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkge1xuICByZXR1cm4gY3VycmVudFZhbHVlID09PSBwcmV2aW91c1ZhbHVlO1xufVxuXG5leHBvcnQgeyBjYWxjdWxhdGVTcGxpY2VzIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudCc7XG5pbXBvcnQge2h0bWwsIHJlbmRlcn0gZnJvbSAnbGl0LWh0bWwnO1xuaW1wb3J0IHsgYWpheEdldCwgYWpheFBvc3QsIGFqYXhQdXQsIGFqYXhEZWxldGUgfSBmcm9tIFwiLi9hamF4LmpzXCI7XG5pbXBvcnQgXCJAcG9seW1lci9wYXBlci1kaWFsb2cvcGFwZXItZGlhbG9nXCI7XG5pbXBvcnQgXCJAcG9seW1lci9wYXBlci1idXR0b24vcGFwZXItYnV0dG9uXCI7XG5pbXBvcnQgXCJAcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dFwiO1xuaW1wb3J0IFwiQHBvbHltZXIvcGFwZXItY2hlY2tib3gvcGFwZXItY2hlY2tib3hcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFjdGlsZUVkaXRhYmxlIGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IGlzKCkge1xuICAgIHJldHVybiBcInRhY3RpbGUtZWRpdGFibGVcIjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB9LFxuICAgICAgY29tcFR5cGU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgfSxcbiAgICAgIGlubGluZToge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6IFwib3BlblwifSk7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLnJlbmRlcigpO1xuICB9XG5cbiAgcmVuZGVyKCkge1xuICAgIHZhciBpbnB1dHMgPSBgYDtcbiAgICB2YXIgbWVzc2FnZSA9IGBgO1xuICAgIHZhciBidXR0b25zID0gYGA7XG4gICAgdmFyIGNvbnRlbnQgPSBgYDtcblxuICAgIGlmICh0aGlzLmNvbXBvbmVudCkge1xuICAgICAgaW5wdXRzID0gdGhpcy5fY3JlYXRlSW5wdXRzKHRoaXMuY29tcG9uZW50KTtcbiAgICAgIG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVNZXNzYWdlKHRoaXMuY29tcG9uZW50KTtcbiAgICAgIGJ1dHRvbnMgPSB0aGlzLl9jcmVhdGVCdXR0b25zKHRoaXMuY29tcG9uZW50KTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgIGNvbnRlbnQgPSBodG1sYDxzbG90Pjwvc2xvdD5gO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb250ZW50ID0gaHRtbGBcbiAgICAgIDxkaXYgc3R5bGU9XCJwb3NpdGlvbjogcmVsYXRpdmU7XCI+XG4gICAgICAgIDxwYXBlci1yaXBwbGU+PC9wYXBlci1yaXBwbGU+XG4gICAgICAgIDxzbG90Pjwvc2xvdD5cbiAgICAgIDwvZGl2PmA7XG4gICAgfVxuXG4gICAgcmVuZGVyKGh0bWxgXG4gICAgPHBhcGVyLWRpYWxvZyBtb2RhbCBzdHlsZT1cIm1pbi13aWR0aDogNjAwcHg7XCI+XG4gICAgICAke21lc3NhZ2V9XG4gICAgICAke2lucHV0c31cbiAgICAgICR7YnV0dG9uc31cbiAgICA8L3BhcGVyLWRpYWxvZz5cbiAgICAke2NvbnRlbnR9XG4gICAgYCwgdGhpcy5zaGFkb3dSb290KTtcbiAgfVxuXG4gIG9wZW5EaWFsb2coY2FsbGJhY2spIHtcbiAgICBhamF4R2V0KHRoaXMucGF0aCtcIi5qc29uXCIsIChjb21wb25lbnQpID0+IHtcbiAgICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgIHZhciBwYXBlckRpYWxvZyA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwicGFwZXItZGlhbG9nXCIpXG4gICAgICBwYXBlckRpYWxvZy5vcGVuKCk7XG4gICAgICB0aGlzLl9hdHRhY2hCdXR0b25IYW5kbGVycygpO1xuICAgICAgdGhpcy5fYXR0YWNoQ2xvc2VkSGFuZGxlcnMoY2FsbGJhY2spO1xuICAgIH0pO1xuICB9XG5cbiAgZm9ybVZhbHVlcygpIHtcbiAgICB2YXIgdmFsdWVzID0ge307XG4gICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwYXBlci1pbnB1dFwiKS5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YWx1ZXNbaW5wdXQubmFtZV0gPSBpbnB1dC52YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlc1tpbnB1dC5uYW1lXSA9IFwiXCI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCJwYXBlci1jaGVja2JveFwiKS5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBpbnB1dC52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zb2xlLmxvZyhpbnB1dC5hY3RpdmUpO1xuICAgICAgICB2YWx1ZXNbaW5wdXQubmFtZV0gPSBpbnB1dC5hY3RpdmU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZXNbaW5wdXQubmFtZV0gPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdmFsdWVzO1xuICB9XG5cbiAgX2F0dGFjaENsb3NlZEhhbmRsZXJzKGNhbGxiYWNrKSB7XG4gICAgdmFyIHBhcGVyRGlhbG9nID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJwYXBlci1kaWFsb2dcIilcblxuICAgIHZhciBkaWFsb2dDbG9zZWQgPSAoZXZlbnQpID0+IHtcbiAgICAgIGlmIChldmVudC5kZXRhaWwuY29uZmlybWVkKSB7XG4gICAgICAgIGFqYXhQb3N0KHRoaXMucGF0aCwgdGhpcy5mb3JtVmFsdWVzKCkpO1xuICAgICAgfVxuICAgICAgcGFwZXJEaWFsb2cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlyb24tb3ZlcmxheS1jbG9zZWRcIiwgZGlhbG9nQ2xvc2VkKTtcbiAgICAgIGNhbGxiYWNrKGV2ZW50LmRldGFpbC5jb25maXJtZWQpO1xuICAgIH1cblxuICAgIHBhcGVyRGlhbG9nLmFkZEV2ZW50TGlzdGVuZXIoXCJpcm9uLW92ZXJsYXktY2xvc2VkXCIsIGRpYWxvZ0Nsb3NlZCk7XG4gIH1cblxuICBfYXR0YWNoQnV0dG9uSGFuZGxlcnMoKSB7XG4gICAgdmFyIHBhcGVyRGlhbG9nID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJwYXBlci1kaWFsb2dcIilcblxuICAgIEFycmF5LmZyb20ocGFwZXJEaWFsb2cucXVlcnlTZWxlY3RvckFsbChcInBhcGVyLWJ1dHRvbi50YWN0aWxlLWFkZFwiKSkuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoZSkgPT4ge1xuICAgICAgICB2YXIgcGF0aCA9IHRoaXMucGF0aCtcIi9cIitlLnRhcmdldC5kYXRhc2V0LnBhdGg7XG4gICAgICAgIHZhciB0ZW1wbGF0ZSA9IEpTT04ucGFyc2UoZS50YXJnZXQuZGF0YXNldC50ZW1wbGF0ZSk7XG4gICAgICAgIGFqYXhQdXQocGF0aCwgdGVtcGxhdGUsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgQXJyYXkuZnJvbShwYXBlckRpYWxvZy5xdWVyeVNlbGVjdG9yQWxsKFwicGFwZXItYnV0dG9uLnRhY3RpbGUtZGVsZXRlXCIpKS5mb3JFYWNoKGJ1dHRvbiA9PiB7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIChlKSA9PiB7XG4gICAgICAgIGFqYXhEZWxldGUodGhpcy5wYXRoLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIF9jcmVhdGVJbnB1dHMoY29tcG9uZW50KSB7XG4gICAgdmFyIGlucHV0cyA9IFsgXTtcbiAgICBjb21wb25lbnQuYXV0aG9yLmF0dHJzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpZiAoaW5wdXQudHlwZSA9PT0gXCJTdHJpbmdcIikge1xuICAgICAgICBpbnB1dHMucHVzaChcbiAgICAgICAgICBodG1sYDxwYXBlci1pbnB1dFxuICAgICAgICAgICAgICAgIG5hbWU9JHtpbnB1dC5uYW1lfVxuICAgICAgICAgICAgICAgIGxhYmVsPSR7aW5wdXQudGl0bGV9XG4gICAgICAgICAgICAgICAgdmFsdWU9JHtjb21wb25lbnRbaW5wdXQubmFtZV19PjwvcGFwZXItaW5wdXQ+YCk7XG4gICAgICB9IGVsc2UgaWYgKGlucHV0LnR5cGUgPT09IFwiQm9vbGVhblwiKSB7XG4gICAgICAgIGlmIChjb21wb25lbnRbaW5wdXQubmFtZV0pIHtcbiAgICAgICAgICBpbnB1dHMucHVzaChodG1sYDxwYXBlci1jaGVja2JveCBuYW1lPSR7aW5wdXQubmFtZX0gY2hlY2tlZD4ke2lucHV0LnRpdGxlfTwvcGFwZXItY2hlY2tib3g+YCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5wdXRzLnB1c2goaHRtbGA8cGFwZXItY2hlY2tib3ggbmFtZT0ke2lucHV0Lm5hbWV9PiR7aW5wdXQudGl0bGV9PC9wYXBlci1jaGVja2JveD5gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBpbnB1dHM7XG4gIH1cblxuICBfY3JlYXRlTWVzc2FnZShjb21wb25lbnQpIHtcbiAgICByZXR1cm4gaHRtbGBcbiAgICAgIDxoMj4ke2NvbXBvbmVudC5hdXRob3IudGl0bGV9PC9oMj5cbiAgICAgIDxwPiR7Y29tcG9uZW50LmF1dGhvci5kZXNjcmlwdGlvbn08L3A+YDtcbiAgfVxuXG4gIF9jcmVhdGVCdXR0b25zKGNvbXBvbmVudCkge1xuICAgIHZhciBleHRyYUJ1dHRvbnMgPSBbIF07XG4gICAgY29tcG9uZW50LmF1dGhvci5hdHRycy5mb3JFYWNoKChpbnB1dCkgPT4ge1xuICAgICAgaWYgKGlucHV0LnR5cGUgPT09IFwiQWRkXCIpIHtcbiAgICAgICAgdmFyIGJ1dHRvbiA9IGh0bWxgPHBhcGVyLWJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzPVwidGFjdGlsZS1hZGRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtcGF0aD0ke2lucHV0LnBhdGh9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS10ZW1wbGF0ZT0ke0pTT04uc3RyaW5naWZ5KGlucHV0LnRlbXBsYXRlKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWNvbXAtdHlwZT0ke2lucHV0LmNvbXBUeXBlfT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAke2lucHV0LnRpdGxlfVxuICAgICAgICAgICAgICAgICAgICAgICAgICA8L3BhcGVyLWJ1dHRvbj5gO1xuXG4gICAgICAgIGV4dHJhQnV0dG9ucy5wdXNoKGJ1dHRvbik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAoISBjb21wb25lbnQuYXV0aG9yLnByZXZlbnREZWxldGUgJiYgISBjb21wb25lbnQucHJldmVudERlbGV0ZSkge1xuICAgICAgdmFyIGRlbGV0ZUJ1dHRvbiA9IGh0bWxgXG4gICAgICAgIDxwYXBlci1idXR0b24gY2xhc3M9XCJ0YWN0aWxlLWRlbGV0ZVwiIGRhdGEtcGF0aD0ke3RoaXMucGF0aH0+RGVsZXRlPC9wYXBlci1idXR0b24+XG4gICAgICBgO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sYFxuICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnNcIj5cbiAgICAgICAgJHtleHRyYUJ1dHRvbnN9XG4gICAgICAgICR7ZGVsZXRlQnV0dG9ufVxuICAgICAgICA8cGFwZXItYnV0dG9uIGRpYWxvZy1kaXNtaXNzPkRlY2xpbmU8L3BhcGVyLWJ1dHRvbj5cbiAgICAgICAgPHBhcGVyLWJ1dHRvbiBkaWFsb2ctY29uZmlybSBhdXRvZm9jdXM+QWNjZXB0PC9wYXBlci1idXR0b24+XG4gICAgICA8L2Rpdj5gO1xuICB9XG59XG5cbi8vIFJlZ2lzdGVyIGN1c3RvbSBlbGVtZW50IGNsYXNzIHdpdGggYnJvd3NlclxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFRhY3RpbGVFZGl0YWJsZS5pcywgVGFjdGlsZUVkaXRhYmxlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3RhY3RpbGUvY2xpZW50L3RhY3RpbGUtZWRpdGFibGUuanMiLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0XG4gKiBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vKipcbiAqIFR5cGVTY3JpcHQgaGFzIGEgcHJvYmxlbSB3aXRoIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgbGl0ZXJhbHNcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvMTc5NTZcbiAqXG4gKiBUT0RPKGp1c3RpbmZhZ25hbmkpOiBSdW4gdGVzdHMgY29tcGlsZWQgdG8gRVM1IHdpdGggYm90aCBCYWJlbCBhbmRcbiAqIFR5cGVTY3JpcHQgdG8gdmVyaWZ5IGNvcnJlY3RuZXNzLlxuICovXG5jb25zdCBlbnZDYWNoZXNUZW1wbGF0ZXMgPSAoKHQpID0+IHQoKSA9PT0gdCgpKSgoKSA9PiAoKHMpID0+IHMpIGBgKTtcbi8vIFRoZSBmaXJzdCBhcmd1bWVudCB0byBKUyB0ZW1wbGF0ZSB0YWdzIHJldGFpbiBpZGVudGl0eSBhY3Jvc3MgbXVsdGlwbGVcbi8vIGNhbGxzIHRvIGEgdGFnIGZvciB0aGUgc2FtZSBsaXRlcmFsLCBzbyB3ZSBjYW4gY2FjaGUgd29yayBkb25lIHBlciBsaXRlcmFsXG4vLyBpbiBhIE1hcC5cbmNvbnN0IHRlbXBsYXRlcyA9IG5ldyBNYXAoKTtcbmNvbnN0IHN2Z1RlbXBsYXRlcyA9IG5ldyBNYXAoKTtcbi8qKlxuICogSW50ZXJwcmV0cyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYW4gSFRNTCB0ZW1wbGF0ZSB0aGF0IGNhbiBlZmZpY2llbnRseVxuICogcmVuZGVyIHRvIGFuZCB1cGRhdGUgYSBjb250YWluZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBodG1sID0gKHN0cmluZ3MsIC4uLnZhbHVlcykgPT4gbGl0VGFnKHN0cmluZ3MsIHZhbHVlcywgdGVtcGxhdGVzLCBmYWxzZSk7XG4vKipcbiAqIEludGVycHJldHMgYSB0ZW1wbGF0ZSBsaXRlcmFsIGFzIGFuIFNWRyB0ZW1wbGF0ZSB0aGF0IGNhbiBlZmZpY2llbnRseVxuICogcmVuZGVyIHRvIGFuZCB1cGRhdGUgYSBjb250YWluZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBzdmcgPSAoc3RyaW5ncywgLi4udmFsdWVzKSA9PiBsaXRUYWcoc3RyaW5ncywgdmFsdWVzLCBzdmdUZW1wbGF0ZXMsIHRydWUpO1xuZnVuY3Rpb24gbGl0VGFnKHN0cmluZ3MsIHZhbHVlcywgdGVtcGxhdGVzLCBpc1N2Zykge1xuICAgIGNvbnN0IGtleSA9IGVudkNhY2hlc1RlbXBsYXRlcyA/XG4gICAgICAgIHN0cmluZ3MgOlxuICAgICAgICBzdHJpbmdzLmpvaW4oJ3t7LS11bmlxdWVuZXNzLXdvcmthcm91bmQtLX19Jyk7XG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVzLmdldChrZXkpO1xuICAgIGlmICh0ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRlbXBsYXRlID0gbmV3IFRlbXBsYXRlKHN0cmluZ3MsIGlzU3ZnKTtcbiAgICAgICAgdGVtcGxhdGVzLnNldChrZXksIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUZW1wbGF0ZVJlc3VsdCh0ZW1wbGF0ZSwgdmFsdWVzKTtcbn1cbi8qKlxuICogVGhlIHJldHVybiB0eXBlIG9mIGBodG1sYCwgd2hpY2ggaG9sZHMgYSBUZW1wbGF0ZSBhbmQgdGhlIHZhbHVlcyBmcm9tXG4gKiBpbnRlcnBvbGF0ZWQgZXhwcmVzc2lvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZVJlc3VsdCB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGUsIHZhbHVlcykge1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgIH1cbn1cbi8qKlxuICogUmVuZGVycyBhIHRlbXBsYXRlIHRvIGEgY29udGFpbmVyLlxuICpcbiAqIFRvIHVwZGF0ZSBhIGNvbnRhaW5lciB3aXRoIG5ldyB2YWx1ZXMsIHJlZXZhbHVhdGUgdGhlIHRlbXBsYXRlIGxpdGVyYWwgYW5kXG4gKiBjYWxsIGByZW5kZXJgIHdpdGggdGhlIG5ldyByZXN1bHQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXIocmVzdWx0LCBjb250YWluZXIsIHBhcnRDYWxsYmFjayA9IGRlZmF1bHRQYXJ0Q2FsbGJhY2spIHtcbiAgICBsZXQgaW5zdGFuY2UgPSBjb250YWluZXIuX190ZW1wbGF0ZUluc3RhbmNlO1xuICAgIC8vIFJlcGVhdCByZW5kZXIsIGp1c3QgY2FsbCB1cGRhdGUoKVxuICAgIGlmIChpbnN0YW5jZSAhPT0gdW5kZWZpbmVkICYmIGluc3RhbmNlLnRlbXBsYXRlID09PSByZXN1bHQudGVtcGxhdGUgJiZcbiAgICAgICAgaW5zdGFuY2UuX3BhcnRDYWxsYmFjayA9PT0gcGFydENhbGxiYWNrKSB7XG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZShyZXN1bHQudmFsdWVzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGaXJzdCByZW5kZXIsIGNyZWF0ZSBhIG5ldyBUZW1wbGF0ZUluc3RhbmNlIGFuZCBhcHBlbmQgaXRcbiAgICBpbnN0YW5jZSA9IG5ldyBUZW1wbGF0ZUluc3RhbmNlKHJlc3VsdC50ZW1wbGF0ZSwgcGFydENhbGxiYWNrKTtcbiAgICBjb250YWluZXIuX190ZW1wbGF0ZUluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBpbnN0YW5jZS5fY2xvbmUoKTtcbiAgICBpbnN0YW5jZS51cGRhdGUocmVzdWx0LnZhbHVlcyk7XG4gICAgbGV0IGNoaWxkO1xuICAgIHdoaWxlICgoY2hpbGQgPSBjb250YWluZXIubGFzdENoaWxkKSkge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH1cbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xufVxuLyoqXG4gKiBBbiBleHByZXNzaW9uIG1hcmtlciB3aXRoIGVtYmVkZGVkIHVuaXF1ZSBrZXkgdG8gYXZvaWRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyTGFicy9saXQtaHRtbC9pc3N1ZXMvNjJcbiAqL1xuY29uc3QgYXR0cmlidXRlTWFya2VyID0gYHt7bGl0LSR7TWF0aC5yYW5kb20oKX19fWA7XG4vKipcbiAqIFJlZ2V4IHRvIHNjYW4gdGhlIHN0cmluZyBwcmVjZWRpbmcgYW4gZXhwcmVzc2lvbiB0byBzZWUgaWYgd2UncmUgaW4gYSB0ZXh0XG4gKiBjb250ZXh0LCBhbmQgbm90IGFuIGF0dHJpYnV0ZSBjb250ZXh0LlxuICpcbiAqIFRoaXMgd29ya3MgYnkgc2VlaW5nIGlmIHdlIGhhdmUgYSBgPmAgbm90IGZvbGxvd2VkIGJ5IGEgYDxgLiBJZiB0aGVyZSBpcyBhXG4gKiBgPGAgY2xvc2VyIHRvIHRoZSBlbmQgb2YgdGhlIHN0cmluZ3MsIHRoZW4gd2UncmUgaW5zaWRlIGEgdGFnLlxuICovXG5jb25zdCB0ZXh0UmVnZXggPSAvPltePF0qJC87XG5jb25zdCBoYXNUYWdzUmVnZXggPSAvW148XSovO1xuY29uc3QgdGV4dE1hcmtlckNvbnRlbnQgPSAnXy1saXQtaHRtbC1fJztcbmNvbnN0IHRleHRNYXJrZXIgPSBgPCEtLSR7dGV4dE1hcmtlckNvbnRlbnR9LS0+YDtcbmNvbnN0IGF0dHJPclRleHRSZWdleCA9IG5ldyBSZWdFeHAoYCR7YXR0cmlidXRlTWFya2VyfXwke3RleHRNYXJrZXJ9YCk7XG4vKipcbiAqIEEgcGxhY2Vob2xkZXIgZm9yIGEgZHluYW1pYyBleHByZXNzaW9uIGluIGFuIEhUTUwgdGVtcGxhdGUuXG4gKlxuICogVGhlcmUgYXJlIHR3byBidWlsdC1pbiBwYXJ0IHR5cGVzOiBBdHRyaWJ1dGVQYXJ0IGFuZCBOb2RlUGFydC4gTm9kZVBhcnRzXG4gKiBhbHdheXMgcmVwcmVzZW50IGEgc2luZ2xlIGR5bmFtaWMgZXhwcmVzc2lvbiwgd2hpbGUgQXR0cmlidXRlUGFydHMgbWF5XG4gKiByZXByZXNlbnQgYXMgbWFueSBleHByZXNzaW9ucyBhcmUgY29udGFpbmVkIGluIHRoZSBhdHRyaWJ1dGUuXG4gKlxuICogQSBUZW1wbGF0ZSdzIHBhcnRzIGFyZSBtdXRhYmxlLCBzbyBwYXJ0cyBjYW4gYmUgcmVwbGFjZWQgb3IgbW9kaWZpZWRcbiAqIChwb3NzaWJseSB0byBpbXBsZW1lbnQgZGlmZmVyZW50IHRlbXBsYXRlIHNlbWFudGljcykuIFRoZSBjb250cmFjdCBpcyB0aGF0XG4gKiBwYXJ0cyBjYW4gb25seSBiZSByZXBsYWNlZCwgbm90IHJlbW92ZWQsIGFkZGVkIG9yIHJlb3JkZXJlZCwgYW5kIHBhcnRzIG11c3RcbiAqIGFsd2F5cyBjb25zdW1lIHRoZSBjb3JyZWN0IG51bWJlciBvZiB2YWx1ZXMgaW4gdGhlaXIgYHVwZGF0ZSgpYCBtZXRob2QuXG4gKlxuICogVE9ETyhqdXN0aW5mYWduYW5pKTogVGhhdCByZXF1aXJlbWVudCBpcyBhIGxpdHRsZSBmcmFnaWxlLiBBXG4gKiBUZW1wbGF0ZUluc3RhbmNlIGNvdWxkIGluc3RlYWQgYmUgbW9yZSBjYXJlZnVsIGFib3V0IHdoaWNoIHZhbHVlcyBpdCBnaXZlc1xuICogdG8gUGFydC51cGRhdGUoKS5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlUGFydCB7XG4gICAgY29uc3RydWN0b3IodHlwZSwgaW5kZXgsIG5hbWUsIHJhd05hbWUsIHN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnJhd05hbWUgPSByYXdOYW1lO1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZSB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5ncywgc3ZnID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5wYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnN2ZyA9IHN2ZztcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LmlubmVySFRNTCA9IHRoaXMuX2dldEh0bWwoc3RyaW5ncywgc3ZnKTtcbiAgICAgICAgLy8gRWRnZSBuZWVkcyBhbGwgNCBwYXJhbWV0ZXJzIHByZXNlbnQ7IElFMTEgbmVlZHMgM3JkIHBhcmFtZXRlciB0byBiZSBudWxsXG4gICAgICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIodGhpcy5lbGVtZW50LmNvbnRlbnQsIDEzMyAvKiBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19DT01NRU5UIHxcbiAgICAgICAgICAgICAgIE5vZGVGaWx0ZXIuU0hPV19URVhUICovLCBudWxsLCBmYWxzZSk7XG4gICAgICAgIGxldCBpbmRleCA9IC0xO1xuICAgICAgICBsZXQgcGFydEluZGV4ID0gMDtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1JlbW92ZSA9IFtdO1xuICAgICAgICAvLyBUaGUgYWN0dWFsIHByZXZpb3VzIG5vZGUsIGFjY291bnRpbmcgZm9yIHJlbW92YWxzOiBpZiBhIG5vZGUgaXMgcmVtb3ZlZFxuICAgICAgICAvLyBpdCB3aWxsIG5ldmVyIGJlIHRoZSBwcmV2aW91c05vZGUuXG4gICAgICAgIGxldCBwcmV2aW91c05vZGU7XG4gICAgICAgIC8vIFVzZWQgdG8gc2V0IHByZXZpb3VzTm9kZSBhdCB0aGUgdG9wIG9mIHRoZSBsb29wLlxuICAgICAgICBsZXQgY3VycmVudE5vZGU7XG4gICAgICAgIHdoaWxlICh3YWxrZXIubmV4dE5vZGUoKSkge1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIHByZXZpb3VzTm9kZSA9IGN1cnJlbnROb2RlO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGN1cnJlbnROb2RlID0gd2Fsa2VyLmN1cnJlbnROb2RlO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IDEgLyogTm9kZS5FTEVNRU5UX05PREUgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVzID0gbm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzLml0ZW0oaSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVN0cmluZ3MgPSBhdHRyaWJ1dGUudmFsdWUuc3BsaXQoYXR0ck9yVGV4dFJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZVN0cmluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSB0ZW1wbGF0ZSBsaXRlcmFsIHNlY3Rpb24gbGVhZGluZyB1cCB0byB0aGUgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGV4cHJlc3Npb24gaW4gdGhpcyBhdHRyaWJ1dGUgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVTdHJpbmcgPSBzdHJpbmdzW3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUcmltIHRoZSB0cmFpbGluZyBsaXRlcmFsIHZhbHVlIGlmIHRoaXMgaXMgYW4gaW50ZXJwb2xhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3TmFtZVN0cmluZyA9IGF0dHJpYnV0ZVN0cmluZy5zdWJzdHJpbmcoMCwgYXR0cmlidXRlU3RyaW5nLmxlbmd0aCAtIGF0dHJpYnV0ZVN0cmluZ3NbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdOYW1lID0gcmF3TmFtZVN0cmluZy5tYXRjaCgvKCg/Olxcd3xbLlxcLV8kXSkrKT1bXCInXT8kLylbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2gobmV3IFRlbXBsYXRlUGFydCgnYXR0cmlidXRlJywgaW5kZXgsIGF0dHJpYnV0ZS5uYW1lLCByYXdOYW1lLCBhdHRyaWJ1dGVTdHJpbmdzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXggKz0gYXR0cmlidXRlU3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMyAvKiBOb2RlLlRFWFRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVWYWx1ZSA9IG5vZGUubm9kZVZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0cmluZ3MgPSBub2RlVmFsdWUuc3BsaXQoYXR0cmlidXRlTWFya2VyKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFzdEluZGV4ID0gc3RyaW5ncy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBoYXZlIGEgcGFydCBmb3IgZWFjaCBtYXRjaCBmb3VuZFxuICAgICAgICAgICAgICAgICAgICBwYXJ0SW5kZXggKz0gbGFzdEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBrZWVwIHRoaXMgY3VycmVudCBub2RlLCBidXQgcmVzZXQgaXRzIGNvbnRlbnQgdG8gdGhlIGxhc3RcbiAgICAgICAgICAgICAgICAgICAgLy8gbGl0ZXJhbCBwYXJ0LiBXZSBpbnNlcnQgbmV3IGxpdGVyYWwgbm9kZXMgYmVmb3JlIHRoaXMgc28gdGhhdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gdHJlZSB3YWxrZXIga2VlcHMgaXRzIHBvc2l0aW9uIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IHN0cmluZ3NbbGFzdEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgdGV4dCBub2RlIGZvciBlYWNoIGxpdGVyYWwgc2VjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBUaGVzZSBub2RlcyBhcmUgYWxzbyB1c2VkIGFzIHRoZSBtYXJrZXJzIGZvciBub2RlIHBhcnRzXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGFzdEluZGV4OyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nc1tpXSksIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKG5ldyBUZW1wbGF0ZVBhcnQoJ25vZGUnLCBpbmRleCsrKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFN0cmlwIHdoaXRlc3BhY2Utb25seSBub2Rlcywgb25seSBiZXR3ZWVuIGVsZW1lbnRzLCBvciBhdCB0aGVcbiAgICAgICAgICAgICAgICAgICAgLy8gYmVnaW5uaW5nIG9yIGVuZCBvZiBlbGVtZW50cy5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNTaWJsaW5nID0gbm9kZS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTaWJsaW5nID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgICAgICAgICAgaWYgKChwcmV2aW91c1NpYmxpbmcgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzU2libGluZy5ub2RlVHlwZSA9PT0gMSAvKiBOb2RlLkVMRU1FTlRfTk9ERSAqLykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIChuZXh0U2libGluZyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5leHRTaWJsaW5nLm5vZGVUeXBlID09PSAxIC8qIE5vZGUuRUxFTUVOVF9OT0RFICovKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZVZhbHVlLnRyaW0oKSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gcHJldmlvdXNOb2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IDggLyogTm9kZS5DT01NRU5UX05PREUgKi8gJiZcbiAgICAgICAgICAgICAgICBub2RlLm5vZGVWYWx1ZSA9PT0gdGV4dE1hcmtlckNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHByZXZpb3VzIG5vZGUgYWRkIGEgbWFya2VyIG5vZGUuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHByZXZpb3VzU2libGluZyBpcyByZW1vdmVkLCBiZWNhdXNlIGl0J3MgYW5vdGhlciBwYXJ0XG4gICAgICAgICAgICAgICAgLy8gcGxhY2hvbGRlciwgb3IgZW1wdHkgdGV4dCwgYWRkIGEgbWFya2VyIG5vZGUuXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucHJldmlvdXNTaWJsaW5nID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucHJldmlvdXNTaWJsaW5nICE9PSBwcmV2aW91c05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShuZXcgVGV4dCgpLCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaChuZXcgVGVtcGxhdGVQYXJ0KCdub2RlJywgaW5kZXgrKykpO1xuICAgICAgICAgICAgICAgIG5vZGVzVG9SZW1vdmUucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgbmV4dCBub2RlIGFkZCBhIG1hcmtlciBub2RlLlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgaWYgdGhlIG5leHQgbm9kZSBpcyBnb2luZyB0byBiZSByZW1vdmVkLFxuICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCBub2RlIHdpbGwgaW5kdWNlIGEgbWFya2VyIGlmIHNvLlxuICAgICAgICAgICAgICAgIGlmIChub2RlLm5leHRTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5pbnNlcnRCZWZvcmUobmV3IFRleHQoKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IHByZXZpb3VzTm9kZTtcbiAgICAgICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZW1vdmUgdGV4dCBiaW5kaW5nIG5vZGVzIGFmdGVyIHRoZSB3YWxrIHRvIG5vdCBkaXN0dXJiIHRoZSBUcmVlV2Fsa2VyXG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBub2Rlc1RvUmVtb3ZlKSB7XG4gICAgICAgICAgICBuLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmluZyBvZiBIVE1MIHVzZWQgdG8gY3JlYXRlIGEgPHRlbXBsYXRlPiBlbGVtZW50LlxuICAgICAqL1xuICAgIF9nZXRIdG1sKHN0cmluZ3MsIHN2Zykge1xuICAgICAgICBjb25zdCBsID0gc3RyaW5ncy5sZW5ndGg7XG4gICAgICAgIGNvbnN0IGEgPSBbXTtcbiAgICAgICAgbGV0IGlzVGV4dEJpbmRpbmcgPSBmYWxzZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gc3RyaW5nc1tpXTtcbiAgICAgICAgICAgIGEucHVzaChzKTtcbiAgICAgICAgICAgIC8vIFdlJ3JlIGluIGEgdGV4dCBwb3NpdGlvbiBpZiB0aGUgcHJldmlvdXMgc3RyaW5nIG1hdGNoZXMgdGhlXG4gICAgICAgICAgICAvLyB0ZXh0UmVnZXguIElmIGl0IGRvZXNuJ3QgYW5kIHRoZSBwcmV2aW91cyBzdHJpbmcgaGFzIG5vIHRhZ3MsIHRoZW5cbiAgICAgICAgICAgIC8vIHdlIHVzZSB0aGUgcHJldmlvdXMgdGV4dCBwb3NpdGlvbiBzdGF0ZS5cbiAgICAgICAgICAgIGlzVGV4dEJpbmRpbmcgPSBzLm1hdGNoKHRleHRSZWdleCkgIT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAocy5tYXRjaChoYXNUYWdzUmVnZXgpICE9PSBudWxsICYmIGlzVGV4dEJpbmRpbmcpO1xuICAgICAgICAgICAgYS5wdXNoKGlzVGV4dEJpbmRpbmcgPyB0ZXh0TWFya2VyIDogYXR0cmlidXRlTWFya2VyKTtcbiAgICAgICAgfVxuICAgICAgICBhLnB1c2goc3RyaW5nc1tsIC0gMV0pO1xuICAgICAgICBjb25zdCBodG1sID0gYS5qb2luKCcnKTtcbiAgICAgICAgcmV0dXJuIHN2ZyA/IGA8c3ZnPiR7aHRtbH08L3N2Zz5gIDogaHRtbDtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgZ2V0VmFsdWUgPSAocGFydCwgdmFsdWUpID0+IHtcbiAgICAvLyBgbnVsbGAgYXMgdGhlIHZhbHVlIG9mIGEgVGV4dCBub2RlIHdpbGwgcmVuZGVyIHRoZSBzdHJpbmcgJ251bGwnXG4gICAgLy8gc28gd2UgY29udmVydCBpdCB0byB1bmRlZmluZWRcbiAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB2YWx1ZS5fX2xpdERpcmVjdGl2ZSA9PT0gdHJ1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlKHBhcnQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgZGlyZWN0aXZlID0gKGYpID0+IHtcbiAgICBmLl9fbGl0RGlyZWN0aXZlID0gdHJ1ZTtcbiAgICByZXR1cm4gZjtcbn07XG5leHBvcnQgY2xhc3MgQXR0cmlidXRlUGFydCB7XG4gICAgY29uc3RydWN0b3IoaW5zdGFuY2UsIGVsZW1lbnQsIG5hbWUsIHN0cmluZ3MpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnN0cmluZ3MgPSBzdHJpbmdzO1xuICAgICAgICB0aGlzLnNpemUgPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlcywgc3RhcnRJbmRleCkge1xuICAgICAgICBjb25zdCBzdHJpbmdzID0gdGhpcy5zdHJpbmdzO1xuICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0cmluZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRleHQgKz0gc3RyaW5nc1tpXTtcbiAgICAgICAgICAgIGlmIChpIDwgc3RyaW5ncy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IGdldFZhbHVlKHRoaXMsIHZhbHVlc1tzdGFydEluZGV4ICsgaV0pO1xuICAgICAgICAgICAgICAgIGlmICh2ICYmXG4gICAgICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KHYpIHx8IHR5cGVvZiB2ICE9PSAnc3RyaW5nJyAmJiB2W1N5bWJvbC5pdGVyYXRvcl0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdCBvZiB2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiB3ZSBuZWVkIHRvIHJlY3Vyc2l2ZWx5IGNhbGwgZ2V0VmFsdWUgaW50byBpdGVyYWJsZXMuLi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgKz0gdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMubmFtZSwgdGV4dCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE5vZGVQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcihpbnN0YW5jZSwgc3RhcnROb2RlLCBlbmROb2RlKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICAgICAgdGhpcy5zdGFydE5vZGUgPSBzdGFydE5vZGU7XG4gICAgICAgIHRoaXMuZW5kTm9kZSA9IGVuZE5vZGU7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gZ2V0VmFsdWUodGhpcywgdmFsdWUpO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgICEodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgcHJpbWl0aXZlIHZhbHVlc1xuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGRpZG4ndCBjaGFuZ2UsIGRvIG5vdGhpbmdcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpcy5fcHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NldFRleHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgVGVtcGxhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFRlbXBsYXRlUmVzdWx0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZVtTeW1ib2wuaXRlcmF0b3JdKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRJdGVyYWJsZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXROb2RlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZS50aGVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFByb21pc2UodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbGJhY2ssIHdpbGwgcmVuZGVyIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb25cbiAgICAgICAgICAgIHRoaXMuX3NldFRleHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9pbnNlcnQobm9kZSkge1xuICAgICAgICB0aGlzLmVuZE5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm9kZSwgdGhpcy5lbmROb2RlKTtcbiAgICB9XG4gICAgX3NldE5vZGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLl9pbnNlcnQodmFsdWUpO1xuICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIF9zZXRUZXh0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnN0YXJ0Tm9kZS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuZW5kTm9kZS5wcmV2aW91c1NpYmxpbmcgJiZcbiAgICAgICAgICAgIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBvbmx5IGhhdmUgYSBzaW5nbGUgdGV4dCBub2RlIGJldHdlZW4gdGhlIG1hcmtlcnMsIHdlIGNhbiBqdXN0XG4gICAgICAgICAgICAvLyBzZXQgaXRzIHZhbHVlLCByYXRoZXIgdGhhbiByZXBsYWNpbmcgaXQuXG4gICAgICAgICAgICAvLyBUT0RPKGp1c3RpbmZhZ25hbmkpOiBDYW4gd2UganVzdCBjaGVjayBpZiBfcHJldmlvdXNWYWx1ZSBpc1xuICAgICAgICAgICAgLy8gcHJpbWl0aXZlP1xuICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0Tm9kZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSA9PT0gdW5kZWZpbmVkID8gJycgOiB2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgX3NldFRlbXBsYXRlUmVzdWx0KHZhbHVlKSB7XG4gICAgICAgIGxldCBpbnN0YW5jZTtcbiAgICAgICAgaWYgKHRoaXMuX3ByZXZpb3VzVmFsdWUgJiZcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUudGVtcGxhdGUgPT09IHZhbHVlLnRlbXBsYXRlKSB7XG4gICAgICAgICAgICBpbnN0YW5jZSA9IHRoaXMuX3ByZXZpb3VzVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbnN0YW5jZSA9XG4gICAgICAgICAgICAgICAgbmV3IFRlbXBsYXRlSW5zdGFuY2UodmFsdWUudGVtcGxhdGUsIHRoaXMuaW5zdGFuY2UuX3BhcnRDYWxsYmFjayk7XG4gICAgICAgICAgICB0aGlzLl9zZXROb2RlKGluc3RhbmNlLl9jbG9uZSgpKTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUgPSBpbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBpbnN0YW5jZS51cGRhdGUodmFsdWUudmFsdWVzKTtcbiAgICB9XG4gICAgX3NldEl0ZXJhYmxlKHZhbHVlKSB7XG4gICAgICAgIC8vIEZvciBhbiBJdGVyYWJsZSwgd2UgY3JlYXRlIGEgbmV3IEluc3RhbmNlUGFydCBwZXIgaXRlbSwgdGhlbiBzZXQgaXRzXG4gICAgICAgIC8vIHZhbHVlIHRvIHRoZSBpdGVtLiBUaGlzIGlzIGEgbGl0dGxlIGJpdCBvZiBvdmVyaGVhZCBmb3IgZXZlcnkgaXRlbSBpblxuICAgICAgICAvLyBhbiBJdGVyYWJsZSwgYnV0IGl0IGxldHMgdXMgcmVjdXJzZSBlYXNpbHkgYW5kIGVmZmljaWVudGx5IHVwZGF0ZSBBcnJheXNcbiAgICAgICAgLy8gb2YgVGVtcGxhdGVSZXN1bHRzIHRoYXQgd2lsbCBiZSBjb21tb25seSByZXR1cm5lZCBmcm9tIGV4cHJlc3Npb25zIGxpa2U6XG4gICAgICAgIC8vIGFycmF5Lm1hcCgoaSkgPT4gaHRtbGAke2l9YCksIGJ5IHJldXNpbmcgZXhpc3RpbmcgVGVtcGxhdGVJbnN0YW5jZXMuXG4gICAgICAgIC8vIElmIF9wcmV2aW91c1ZhbHVlIGlzIGFuIGFycmF5LCB0aGVuIHRoZSBwcmV2aW91cyByZW5kZXIgd2FzIG9mIGFuXG4gICAgICAgIC8vIGl0ZXJhYmxlIGFuZCBfcHJldmlvdXNWYWx1ZSB3aWxsIGNvbnRhaW4gdGhlIE5vZGVQYXJ0cyBmcm9tIHRoZSBwcmV2aW91c1xuICAgICAgICAvLyByZW5kZXIuIElmIF9wcmV2aW91c1ZhbHVlIGlzIG5vdCBhbiBhcnJheSwgY2xlYXIgdGhpcyBwYXJ0IGFuZCBtYWtlIGEgbmV3XG4gICAgICAgIC8vIGFycmF5IGZvciBOb2RlUGFydHMuXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLl9wcmV2aW91c1ZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIExldHMgdXMga2VlcCB0cmFjayBvZiBob3cgbWFueSBpdGVtcyB3ZSBzdGFtcGVkIHNvIHdlIGNhbiBjbGVhciBsZWZ0b3ZlclxuICAgICAgICAvLyBpdGVtcyBmcm9tIGEgcHJldmlvdXMgcmVuZGVyXG4gICAgICAgIGNvbnN0IGl0ZW1QYXJ0cyA9IHRoaXMuX3ByZXZpb3VzVmFsdWU7XG4gICAgICAgIGxldCBwYXJ0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIFRyeSB0byByZXVzZSBhbiBleGlzdGluZyBwYXJ0XG4gICAgICAgICAgICBsZXQgaXRlbVBhcnQgPSBpdGVtUGFydHNbcGFydEluZGV4XTtcbiAgICAgICAgICAgIC8vIElmIG5vIGV4aXN0aW5nIHBhcnQsIGNyZWF0ZSBhIG5ldyBvbmVcbiAgICAgICAgICAgIGlmIChpdGVtUGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgY3JlYXRpbmcgdGhlIGZpcnN0IGl0ZW0gcGFydCwgaXQncyBzdGFydE5vZGUgc2hvdWxkIGJlIHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5lcidzIHN0YXJ0Tm9kZVxuICAgICAgICAgICAgICAgIGxldCBpdGVtU3RhcnQgPSB0aGlzLnN0YXJ0Tm9kZTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgY3JlYXRpbmcgdGhlIGZpcnN0IHBhcnQsIGNyZWF0ZSBhIG5ldyBzZXBhcmF0b3IgbWFya2VyXG4gICAgICAgICAgICAgICAgLy8gbm9kZSwgYW5kIGZpeCB1cCB0aGUgcHJldmlvdXMgcGFydCdzIGVuZE5vZGUgdG8gcG9pbnQgdG8gaXRcbiAgICAgICAgICAgICAgICBpZiAocGFydEluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1BhcnQgPSBpdGVtUGFydHNbcGFydEluZGV4IC0gMV07XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1TdGFydCA9IHByZXZpb3VzUGFydC5lbmROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9pbnNlcnQoaXRlbVN0YXJ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaXRlbVBhcnQgPSBuZXcgTm9kZVBhcnQodGhpcy5pbnN0YW5jZSwgaXRlbVN0YXJ0LCB0aGlzLmVuZE5vZGUpO1xuICAgICAgICAgICAgICAgIGl0ZW1QYXJ0cy5wdXNoKGl0ZW1QYXJ0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW1QYXJ0LnNldFZhbHVlKGl0ZW0pO1xuICAgICAgICAgICAgcGFydEluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRJbmRleCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0SW5kZXggPCBpdGVtUGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBsYXN0UGFydCA9IGl0ZW1QYXJ0c1twYXJ0SW5kZXggLSAxXTtcbiAgICAgICAgICAgIC8vIFRydW5jYXRlIHRoZSBwYXJ0cyBhcnJheSBzbyBfcHJldmlvdXNWYWx1ZSByZWZsZWN0cyB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgICAgICAgaXRlbVBhcnRzLmxlbmd0aCA9IHBhcnRJbmRleDtcbiAgICAgICAgICAgIHRoaXMuY2xlYXIobGFzdFBhcnQuZW5kTm9kZS5wcmV2aW91c1NpYmxpbmcpO1xuICAgICAgICAgICAgbGFzdFBhcnQuZW5kTm9kZSA9IHRoaXMuZW5kTm9kZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc2V0UHJvbWlzZSh2YWx1ZSkge1xuICAgICAgICB2YWx1ZS50aGVuKCh2KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcHJldmlvdXNWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFZhbHVlKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBjbGVhcihzdGFydE5vZGUgPSB0aGlzLnN0YXJ0Tm9kZSkge1xuICAgICAgICBsZXQgbm9kZTtcbiAgICAgICAgd2hpbGUgKChub2RlID0gc3RhcnROb2RlLm5leHRTaWJsaW5nKSAhPT0gdGhpcy5lbmROb2RlKSB7XG4gICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgZGVmYXVsdFBhcnRDYWxsYmFjayA9IChpbnN0YW5jZSwgdGVtcGxhdGVQYXJ0LCBub2RlKSA9PiB7XG4gICAgaWYgKHRlbXBsYXRlUGFydC50eXBlID09PSAnYXR0cmlidXRlJykge1xuICAgICAgICByZXR1cm4gbmV3IEF0dHJpYnV0ZVBhcnQoaW5zdGFuY2UsIG5vZGUsIHRlbXBsYXRlUGFydC5uYW1lLCB0ZW1wbGF0ZVBhcnQuc3RyaW5ncyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRlbXBsYXRlUGFydC50eXBlID09PSAnbm9kZScpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlUGFydChpbnN0YW5jZSwgbm9kZSwgbm9kZS5uZXh0U2libGluZyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJ0IHR5cGUgJHt0ZW1wbGF0ZVBhcnQudHlwZX1gKTtcbn07XG4vKipcbiAqIEFuIGluc3RhbmNlIG9mIGEgYFRlbXBsYXRlYCB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgRE9NIGFuZCB1cGRhdGVkXG4gKiB3aXRoIG5ldyB2YWx1ZXMuXG4gKi9cbmV4cG9ydCBjbGFzcyBUZW1wbGF0ZUluc3RhbmNlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSwgcGFydENhbGxiYWNrID0gZGVmYXVsdFBhcnRDYWxsYmFjaykge1xuICAgICAgICB0aGlzLl9wYXJ0cyA9IFtdO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMuX3BhcnRDYWxsYmFjayA9IHBhcnRDYWxsYmFjaztcbiAgICB9XG4gICAgdXBkYXRlKHZhbHVlcykge1xuICAgICAgICBsZXQgdmFsdWVJbmRleCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcGFydCBvZiB0aGlzLl9wYXJ0cykge1xuICAgICAgICAgICAgaWYgKHBhcnQuc2l6ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcGFydC5zZXRWYWx1ZSh2YWx1ZXNbdmFsdWVJbmRleF0pO1xuICAgICAgICAgICAgICAgIHZhbHVlSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBhcnQuc2V0VmFsdWUodmFsdWVzLCB2YWx1ZUluZGV4KTtcbiAgICAgICAgICAgICAgICB2YWx1ZUluZGV4ICs9IHBhcnQuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBfY2xvbmUoKSB7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuaW1wb3J0Tm9kZSh0aGlzLnRlbXBsYXRlLmVsZW1lbnQuY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlLnBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEVkZ2UgbmVlZHMgYWxsIDQgcGFyYW1ldGVycyBwcmVzZW50OyBJRTExIG5lZWRzIDNyZCBwYXJhbWV0ZXIgdG8gYmVcbiAgICAgICAgICAgIC8vIG51bGxcbiAgICAgICAgICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZnJhZ21lbnQsIDEzMyAvKiBOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCB8IE5vZGVGaWx0ZXIuU0hPV19DT01NRU5UIHwgTm9kZUZpbHRlci5TSE9XX1RFWFQgKi8sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gdGhpcy50ZW1wbGF0ZS5wYXJ0cztcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgcGFydEluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCB0ZW1wbGF0ZVBhcnQgPSBwYXJ0c1swXTtcbiAgICAgICAgICAgIGxldCBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICB3aGlsZSAobm9kZSAhPSBudWxsICYmIHBhcnRJbmRleCA8IHBhcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PT0gdGVtcGxhdGVQYXJ0LmluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3BhcnRzLnB1c2godGhpcy5fcGFydENhbGxiYWNrKHRoaXMsIHRlbXBsYXRlUGFydCwgbm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZVBhcnQgPSBwYXJ0c1srK3BhcnRJbmRleF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBub2RlID0gd2Fsa2VyLm5leHROb2RlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnRlbXBsYXRlLnN2Zykge1xuICAgICAgICAgICAgY29uc3Qgc3ZnRWxlbWVudCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgICBmcmFnbWVudC5yZW1vdmVDaGlsZChzdmdFbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVzID0gc3ZnRWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKG5vZGVzLml0ZW0oaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmcmFnbWVudDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXQtaHRtbC5qcy5tYXBcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9saXQtaHRtbC9saXQtaHRtbC5qc1xuLy8gbW9kdWxlIGlkID0gNDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxjdXN0b20tc3R5bGU+XG4gIDxzdHlsZSBpcz1cImN1c3RvbS1zdHlsZVwiPlxuICAgIGh0bWwge1xuXG4gICAgICAvKiBNYXRlcmlhbCBEZXNpZ24gY29sb3IgcGFsZXR0ZSBmb3IgR29vZ2xlIHByb2R1Y3RzICovXG5cbiAgICAgIC0tZ29vZ2xlLXJlZC0xMDA6ICNmNGM3YzM7XG4gICAgICAtLWdvb2dsZS1yZWQtMzAwOiAjZTY3YzczO1xuICAgICAgLS1nb29nbGUtcmVkLTUwMDogI2RiNDQzNztcbiAgICAgIC0tZ29vZ2xlLXJlZC03MDA6ICNjNTM5Mjk7XG5cbiAgICAgIC0tZ29vZ2xlLWJsdWUtMTAwOiAjYzZkYWZjO1xuICAgICAgLS1nb29nbGUtYmx1ZS0zMDA6ICM3YmFhZjc7XG4gICAgICAtLWdvb2dsZS1ibHVlLTUwMDogIzQyODVmNDtcbiAgICAgIC0tZ29vZ2xlLWJsdWUtNzAwOiAjMzM2N2Q2O1xuXG4gICAgICAtLWdvb2dsZS1ncmVlbi0xMDA6ICNiN2UxY2Q7XG4gICAgICAtLWdvb2dsZS1ncmVlbi0zMDA6ICM1N2JiOGE7XG4gICAgICAtLWdvb2dsZS1ncmVlbi01MDA6ICMwZjlkNTg7XG4gICAgICAtLWdvb2dsZS1ncmVlbi03MDA6ICMwYjgwNDM7XG5cbiAgICAgIC0tZ29vZ2xlLXllbGxvdy0xMDA6ICNmY2U4YjI7XG4gICAgICAtLWdvb2dsZS15ZWxsb3ctMzAwOiAjZjdjYjRkO1xuICAgICAgLS1nb29nbGUteWVsbG93LTUwMDogI2Y0YjQwMDtcbiAgICAgIC0tZ29vZ2xlLXllbGxvdy03MDA6ICNmMDkzMDA7XG5cbiAgICAgIC0tZ29vZ2xlLWdyZXktMTAwOiAjZjVmNWY1O1xuICAgICAgLS1nb29nbGUtZ3JleS0zMDA6ICNlMGUwZTA7XG4gICAgICAtLWdvb2dsZS1ncmV5LTUwMDogIzllOWU5ZTtcbiAgICAgIC0tZ29vZ2xlLWdyZXktNzAwOiAjNjE2MTYxO1xuXG4gICAgICAvKiBNYXRlcmlhbCBEZXNpZ24gY29sb3IgcGFsZXR0ZSBmcm9tIG9ubGluZSBzcGVjIGRvY3VtZW50ICovXG5cbiAgICAgIC0tcGFwZXItcmVkLTUwOiAjZmZlYmVlO1xuICAgICAgLS1wYXBlci1yZWQtMTAwOiAjZmZjZGQyO1xuICAgICAgLS1wYXBlci1yZWQtMjAwOiAjZWY5YTlhO1xuICAgICAgLS1wYXBlci1yZWQtMzAwOiAjZTU3MzczO1xuICAgICAgLS1wYXBlci1yZWQtNDAwOiAjZWY1MzUwO1xuICAgICAgLS1wYXBlci1yZWQtNTAwOiAjZjQ0MzM2O1xuICAgICAgLS1wYXBlci1yZWQtNjAwOiAjZTUzOTM1O1xuICAgICAgLS1wYXBlci1yZWQtNzAwOiAjZDMyZjJmO1xuICAgICAgLS1wYXBlci1yZWQtODAwOiAjYzYyODI4O1xuICAgICAgLS1wYXBlci1yZWQtOTAwOiAjYjcxYzFjO1xuICAgICAgLS1wYXBlci1yZWQtYTEwMDogI2ZmOGE4MDtcbiAgICAgIC0tcGFwZXItcmVkLWEyMDA6ICNmZjUyNTI7XG4gICAgICAtLXBhcGVyLXJlZC1hNDAwOiAjZmYxNzQ0O1xuICAgICAgLS1wYXBlci1yZWQtYTcwMDogI2Q1MDAwMDtcblxuICAgICAgLS1wYXBlci1waW5rLTUwOiAjZmNlNGVjO1xuICAgICAgLS1wYXBlci1waW5rLTEwMDogI2Y4YmJkMDtcbiAgICAgIC0tcGFwZXItcGluay0yMDA6ICNmNDhmYjE7XG4gICAgICAtLXBhcGVyLXBpbmstMzAwOiAjZjA2MjkyO1xuICAgICAgLS1wYXBlci1waW5rLTQwMDogI2VjNDA3YTtcbiAgICAgIC0tcGFwZXItcGluay01MDA6ICNlOTFlNjM7XG4gICAgICAtLXBhcGVyLXBpbmstNjAwOiAjZDgxYjYwO1xuICAgICAgLS1wYXBlci1waW5rLTcwMDogI2MyMTg1YjtcbiAgICAgIC0tcGFwZXItcGluay04MDA6ICNhZDE0NTc7XG4gICAgICAtLXBhcGVyLXBpbmstOTAwOiAjODgwZTRmO1xuICAgICAgLS1wYXBlci1waW5rLWExMDA6ICNmZjgwYWI7XG4gICAgICAtLXBhcGVyLXBpbmstYTIwMDogI2ZmNDA4MTtcbiAgICAgIC0tcGFwZXItcGluay1hNDAwOiAjZjUwMDU3O1xuICAgICAgLS1wYXBlci1waW5rLWE3MDA6ICNjNTExNjI7XG5cbiAgICAgIC0tcGFwZXItcHVycGxlLTUwOiAjZjNlNWY1O1xuICAgICAgLS1wYXBlci1wdXJwbGUtMTAwOiAjZTFiZWU3O1xuICAgICAgLS1wYXBlci1wdXJwbGUtMjAwOiAjY2U5M2Q4O1xuICAgICAgLS1wYXBlci1wdXJwbGUtMzAwOiAjYmE2OGM4O1xuICAgICAgLS1wYXBlci1wdXJwbGUtNDAwOiAjYWI0N2JjO1xuICAgICAgLS1wYXBlci1wdXJwbGUtNTAwOiAjOWMyN2IwO1xuICAgICAgLS1wYXBlci1wdXJwbGUtNjAwOiAjOGUyNGFhO1xuICAgICAgLS1wYXBlci1wdXJwbGUtNzAwOiAjN2IxZmEyO1xuICAgICAgLS1wYXBlci1wdXJwbGUtODAwOiAjNmExYjlhO1xuICAgICAgLS1wYXBlci1wdXJwbGUtOTAwOiAjNGExNDhjO1xuICAgICAgLS1wYXBlci1wdXJwbGUtYTEwMDogI2VhODBmYztcbiAgICAgIC0tcGFwZXItcHVycGxlLWEyMDA6ICNlMDQwZmI7XG4gICAgICAtLXBhcGVyLXB1cnBsZS1hNDAwOiAjZDUwMGY5O1xuICAgICAgLS1wYXBlci1wdXJwbGUtYTcwMDogI2FhMDBmZjtcblxuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS01MDogI2VkZTdmNjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtMTAwOiAjZDFjNGU5O1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS0yMDA6ICNiMzlkZGI7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTMwMDogIzk1NzVjZDtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNDAwOiAjN2U1N2MyO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS01MDA6ICM2NzNhYjc7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTYwMDogIzVlMzViMTtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNzAwOiAjNTEyZGE4O1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS04MDA6ICM0NTI3YTA7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTkwMDogIzMxMWI5MjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtYTEwMDogI2IzODhmZjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtYTIwMDogIzdjNGRmZjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtYTQwMDogIzY1MWZmZjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtYTcwMDogIzYyMDBlYTtcblxuICAgICAgLS1wYXBlci1pbmRpZ28tNTA6ICNlOGVhZjY7XG4gICAgICAtLXBhcGVyLWluZGlnby0xMDA6ICNjNWNhZTk7XG4gICAgICAtLXBhcGVyLWluZGlnby0yMDA6ICM5ZmE4ZGE7XG4gICAgICAtLXBhcGVyLWluZGlnby0zMDA6ICM3OTg2Y2I7XG4gICAgICAtLXBhcGVyLWluZGlnby00MDA6ICM1YzZiYzA7XG4gICAgICAtLXBhcGVyLWluZGlnby01MDA6ICMzZjUxYjU7XG4gICAgICAtLXBhcGVyLWluZGlnby02MDA6ICMzOTQ5YWI7XG4gICAgICAtLXBhcGVyLWluZGlnby03MDA6ICMzMDNmOWY7XG4gICAgICAtLXBhcGVyLWluZGlnby04MDA6ICMyODM1OTM7XG4gICAgICAtLXBhcGVyLWluZGlnby05MDA6ICMxYTIzN2U7XG4gICAgICAtLXBhcGVyLWluZGlnby1hMTAwOiAjOGM5ZWZmO1xuICAgICAgLS1wYXBlci1pbmRpZ28tYTIwMDogIzUzNmRmZTtcbiAgICAgIC0tcGFwZXItaW5kaWdvLWE0MDA6ICMzZDVhZmU7XG4gICAgICAtLXBhcGVyLWluZGlnby1hNzAwOiAjMzA0ZmZlO1xuXG4gICAgICAtLXBhcGVyLWJsdWUtNTA6ICNlM2YyZmQ7XG4gICAgICAtLXBhcGVyLWJsdWUtMTAwOiAjYmJkZWZiO1xuICAgICAgLS1wYXBlci1ibHVlLTIwMDogIzkwY2FmOTtcbiAgICAgIC0tcGFwZXItYmx1ZS0zMDA6ICM2NGI1ZjY7XG4gICAgICAtLXBhcGVyLWJsdWUtNDAwOiAjNDJhNWY1O1xuICAgICAgLS1wYXBlci1ibHVlLTUwMDogIzIxOTZmMztcbiAgICAgIC0tcGFwZXItYmx1ZS02MDA6ICMxZTg4ZTU7XG4gICAgICAtLXBhcGVyLWJsdWUtNzAwOiAjMTk3NmQyO1xuICAgICAgLS1wYXBlci1ibHVlLTgwMDogIzE1NjVjMDtcbiAgICAgIC0tcGFwZXItYmx1ZS05MDA6ICMwZDQ3YTE7XG4gICAgICAtLXBhcGVyLWJsdWUtYTEwMDogIzgyYjFmZjtcbiAgICAgIC0tcGFwZXItYmx1ZS1hMjAwOiAjNDQ4YWZmO1xuICAgICAgLS1wYXBlci1ibHVlLWE0MDA6ICMyOTc5ZmY7XG4gICAgICAtLXBhcGVyLWJsdWUtYTcwMDogIzI5NjJmZjtcblxuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTUwOiAjZTFmNWZlO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTEwMDogI2IzZTVmYztcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS0yMDA6ICM4MWQ0ZmE7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtMzAwOiAjNGZjM2Y3O1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTQwMDogIzI5YjZmNjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS01MDA6ICMwM2E5ZjQ7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtNjAwOiAjMDM5YmU1O1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTcwMDogIzAyODhkMTtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS04MDA6ICMwMjc3YmQ7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtOTAwOiAjMDE1NzliO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLWExMDA6ICM4MGQ4ZmY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtYTIwMDogIzQwYzRmZjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS1hNDAwOiAjMDBiMGZmO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLWE3MDA6ICMwMDkxZWE7XG5cbiAgICAgIC0tcGFwZXItY3lhbi01MDogI2UwZjdmYTtcbiAgICAgIC0tcGFwZXItY3lhbi0xMDA6ICNiMmViZjI7XG4gICAgICAtLXBhcGVyLWN5YW4tMjAwOiAjODBkZWVhO1xuICAgICAgLS1wYXBlci1jeWFuLTMwMDogIzRkZDBlMTtcbiAgICAgIC0tcGFwZXItY3lhbi00MDA6ICMyNmM2ZGE7XG4gICAgICAtLXBhcGVyLWN5YW4tNTAwOiAjMDBiY2Q0O1xuICAgICAgLS1wYXBlci1jeWFuLTYwMDogIzAwYWNjMTtcbiAgICAgIC0tcGFwZXItY3lhbi03MDA6ICMwMDk3YTc7XG4gICAgICAtLXBhcGVyLWN5YW4tODAwOiAjMDA4MzhmO1xuICAgICAgLS1wYXBlci1jeWFuLTkwMDogIzAwNjA2NDtcbiAgICAgIC0tcGFwZXItY3lhbi1hMTAwOiAjODRmZmZmO1xuICAgICAgLS1wYXBlci1jeWFuLWEyMDA6ICMxOGZmZmY7XG4gICAgICAtLXBhcGVyLWN5YW4tYTQwMDogIzAwZTVmZjtcbiAgICAgIC0tcGFwZXItY3lhbi1hNzAwOiAjMDBiOGQ0O1xuXG4gICAgICAtLXBhcGVyLXRlYWwtNTA6ICNlMGYyZjE7XG4gICAgICAtLXBhcGVyLXRlYWwtMTAwOiAjYjJkZmRiO1xuICAgICAgLS1wYXBlci10ZWFsLTIwMDogIzgwY2JjNDtcbiAgICAgIC0tcGFwZXItdGVhbC0zMDA6ICM0ZGI2YWM7XG4gICAgICAtLXBhcGVyLXRlYWwtNDAwOiAjMjZhNjlhO1xuICAgICAgLS1wYXBlci10ZWFsLTUwMDogIzAwOTY4ODtcbiAgICAgIC0tcGFwZXItdGVhbC02MDA6ICMwMDg5N2I7XG4gICAgICAtLXBhcGVyLXRlYWwtNzAwOiAjMDA3OTZiO1xuICAgICAgLS1wYXBlci10ZWFsLTgwMDogIzAwNjk1YztcbiAgICAgIC0tcGFwZXItdGVhbC05MDA6ICMwMDRkNDA7XG4gICAgICAtLXBhcGVyLXRlYWwtYTEwMDogI2E3ZmZlYjtcbiAgICAgIC0tcGFwZXItdGVhbC1hMjAwOiAjNjRmZmRhO1xuICAgICAgLS1wYXBlci10ZWFsLWE0MDA6ICMxZGU5YjY7XG4gICAgICAtLXBhcGVyLXRlYWwtYTcwMDogIzAwYmZhNTtcblxuICAgICAgLS1wYXBlci1ncmVlbi01MDogI2U4ZjVlOTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tMTAwOiAjYzhlNmM5O1xuICAgICAgLS1wYXBlci1ncmVlbi0yMDA6ICNhNWQ2YTc7XG4gICAgICAtLXBhcGVyLWdyZWVuLTMwMDogIzgxYzc4NDtcbiAgICAgIC0tcGFwZXItZ3JlZW4tNDAwOiAjNjZiYjZhO1xuICAgICAgLS1wYXBlci1ncmVlbi01MDA6ICM0Y2FmNTA7XG4gICAgICAtLXBhcGVyLWdyZWVuLTYwMDogIzQzYTA0NztcbiAgICAgIC0tcGFwZXItZ3JlZW4tNzAwOiAjMzg4ZTNjO1xuICAgICAgLS1wYXBlci1ncmVlbi04MDA6ICMyZTdkMzI7XG4gICAgICAtLXBhcGVyLWdyZWVuLTkwMDogIzFiNWUyMDtcbiAgICAgIC0tcGFwZXItZ3JlZW4tYTEwMDogI2I5ZjZjYTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tYTIwMDogIzY5ZjBhZTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tYTQwMDogIzAwZTY3NjtcbiAgICAgIC0tcGFwZXItZ3JlZW4tYTcwMDogIzAwYzg1MztcblxuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi01MDogI2YxZjhlOTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tMTAwOiAjZGNlZGM4O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi0yMDA6ICNjNWUxYTU7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTMwMDogI2FlZDU4MTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNDAwOiAjOWNjYzY1O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi01MDA6ICM4YmMzNGE7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTYwMDogIzdjYjM0MjtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNzAwOiAjNjg5ZjM4O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi04MDA6ICM1NThiMmY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTkwMDogIzMzNjkxZTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tYTEwMDogI2NjZmY5MDtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tYTIwMDogI2IyZmY1OTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tYTQwMDogIzc2ZmYwMztcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tYTcwMDogIzY0ZGQxNztcblxuICAgICAgLS1wYXBlci1saW1lLTUwOiAjZjlmYmU3O1xuICAgICAgLS1wYXBlci1saW1lLTEwMDogI2YwZjRjMztcbiAgICAgIC0tcGFwZXItbGltZS0yMDA6ICNlNmVlOWM7XG4gICAgICAtLXBhcGVyLWxpbWUtMzAwOiAjZGNlNzc1O1xuICAgICAgLS1wYXBlci1saW1lLTQwMDogI2Q0ZTE1NztcbiAgICAgIC0tcGFwZXItbGltZS01MDA6ICNjZGRjMzk7XG4gICAgICAtLXBhcGVyLWxpbWUtNjAwOiAjYzBjYTMzO1xuICAgICAgLS1wYXBlci1saW1lLTcwMDogI2FmYjQyYjtcbiAgICAgIC0tcGFwZXItbGltZS04MDA6ICM5ZTlkMjQ7XG4gICAgICAtLXBhcGVyLWxpbWUtOTAwOiAjODI3NzE3O1xuICAgICAgLS1wYXBlci1saW1lLWExMDA6ICNmNGZmODE7XG4gICAgICAtLXBhcGVyLWxpbWUtYTIwMDogI2VlZmY0MTtcbiAgICAgIC0tcGFwZXItbGltZS1hNDAwOiAjYzZmZjAwO1xuICAgICAgLS1wYXBlci1saW1lLWE3MDA6ICNhZWVhMDA7XG5cbiAgICAgIC0tcGFwZXIteWVsbG93LTUwOiAjZmZmZGU3O1xuICAgICAgLS1wYXBlci15ZWxsb3ctMTAwOiAjZmZmOWM0O1xuICAgICAgLS1wYXBlci15ZWxsb3ctMjAwOiAjZmZmNTlkO1xuICAgICAgLS1wYXBlci15ZWxsb3ctMzAwOiAjZmZmMTc2O1xuICAgICAgLS1wYXBlci15ZWxsb3ctNDAwOiAjZmZlZTU4O1xuICAgICAgLS1wYXBlci15ZWxsb3ctNTAwOiAjZmZlYjNiO1xuICAgICAgLS1wYXBlci15ZWxsb3ctNjAwOiAjZmRkODM1O1xuICAgICAgLS1wYXBlci15ZWxsb3ctNzAwOiAjZmJjMDJkO1xuICAgICAgLS1wYXBlci15ZWxsb3ctODAwOiAjZjlhODI1O1xuICAgICAgLS1wYXBlci15ZWxsb3ctOTAwOiAjZjU3ZjE3O1xuICAgICAgLS1wYXBlci15ZWxsb3ctYTEwMDogI2ZmZmY4ZDtcbiAgICAgIC0tcGFwZXIteWVsbG93LWEyMDA6ICNmZmZmMDA7XG4gICAgICAtLXBhcGVyLXllbGxvdy1hNDAwOiAjZmZlYTAwO1xuICAgICAgLS1wYXBlci15ZWxsb3ctYTcwMDogI2ZmZDYwMDtcblxuICAgICAgLS1wYXBlci1hbWJlci01MDogI2ZmZjhlMTtcbiAgICAgIC0tcGFwZXItYW1iZXItMTAwOiAjZmZlY2IzO1xuICAgICAgLS1wYXBlci1hbWJlci0yMDA6ICNmZmUwODI7XG4gICAgICAtLXBhcGVyLWFtYmVyLTMwMDogI2ZmZDU0ZjtcbiAgICAgIC0tcGFwZXItYW1iZXItNDAwOiAjZmZjYTI4O1xuICAgICAgLS1wYXBlci1hbWJlci01MDA6ICNmZmMxMDc7XG4gICAgICAtLXBhcGVyLWFtYmVyLTYwMDogI2ZmYjMwMDtcbiAgICAgIC0tcGFwZXItYW1iZXItNzAwOiAjZmZhMDAwO1xuICAgICAgLS1wYXBlci1hbWJlci04MDA6ICNmZjhmMDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLTkwMDogI2ZmNmYwMDtcbiAgICAgIC0tcGFwZXItYW1iZXItYTEwMDogI2ZmZTU3ZjtcbiAgICAgIC0tcGFwZXItYW1iZXItYTIwMDogI2ZmZDc0MDtcbiAgICAgIC0tcGFwZXItYW1iZXItYTQwMDogI2ZmYzQwMDtcbiAgICAgIC0tcGFwZXItYW1iZXItYTcwMDogI2ZmYWIwMDtcblxuICAgICAgLS1wYXBlci1vcmFuZ2UtNTA6ICNmZmYzZTA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS0xMDA6ICNmZmUwYjI7XG4gICAgICAtLXBhcGVyLW9yYW5nZS0yMDA6ICNmZmNjODA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS0zMDA6ICNmZmI3NGQ7XG4gICAgICAtLXBhcGVyLW9yYW5nZS00MDA6ICNmZmE3MjY7XG4gICAgICAtLXBhcGVyLW9yYW5nZS01MDA6ICNmZjk4MDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS02MDA6ICNmYjhjMDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS03MDA6ICNmNTdjMDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS04MDA6ICNlZjZjMDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS05MDA6ICNlNjUxMDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS1hMTAwOiAjZmZkMTgwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtYTIwMDogI2ZmYWI0MDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLWE0MDA6ICNmZjkxMDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS1hNzAwOiAjZmY2NTAwO1xuXG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTUwOiAjZmJlOWU3O1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS0xMDA6ICNmZmNjYmM7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTIwMDogI2ZmYWI5MTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtMzAwOiAjZmY4YTY1O1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS00MDA6ICNmZjcwNDM7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTUwMDogI2ZmNTcyMjtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtNjAwOiAjZjQ1MTFlO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS03MDA6ICNlNjRhMTk7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTgwMDogI2Q4NDMxNTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtOTAwOiAjYmYzNjBjO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS1hMTAwOiAjZmY5ZTgwO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS1hMjAwOiAjZmY2ZTQwO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS1hNDAwOiAjZmYzZDAwO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS1hNzAwOiAjZGQyYzAwO1xuXG4gICAgICAtLXBhcGVyLWJyb3duLTUwOiAjZWZlYmU5O1xuICAgICAgLS1wYXBlci1icm93bi0xMDA6ICNkN2NjYzg7XG4gICAgICAtLXBhcGVyLWJyb3duLTIwMDogI2JjYWFhNDtcbiAgICAgIC0tcGFwZXItYnJvd24tMzAwOiAjYTE4ODdmO1xuICAgICAgLS1wYXBlci1icm93bi00MDA6ICM4ZDZlNjM7XG4gICAgICAtLXBhcGVyLWJyb3duLTUwMDogIzc5NTU0ODtcbiAgICAgIC0tcGFwZXItYnJvd24tNjAwOiAjNmQ0YzQxO1xuICAgICAgLS1wYXBlci1icm93bi03MDA6ICM1ZDQwMzc7XG4gICAgICAtLXBhcGVyLWJyb3duLTgwMDogIzRlMzQyZTtcbiAgICAgIC0tcGFwZXItYnJvd24tOTAwOiAjM2UyNzIzO1xuXG4gICAgICAtLXBhcGVyLWdyZXktNTA6ICNmYWZhZmE7XG4gICAgICAtLXBhcGVyLWdyZXktMTAwOiAjZjVmNWY1O1xuICAgICAgLS1wYXBlci1ncmV5LTIwMDogI2VlZWVlZTtcbiAgICAgIC0tcGFwZXItZ3JleS0zMDA6ICNlMGUwZTA7XG4gICAgICAtLXBhcGVyLWdyZXktNDAwOiAjYmRiZGJkO1xuICAgICAgLS1wYXBlci1ncmV5LTUwMDogIzllOWU5ZTtcbiAgICAgIC0tcGFwZXItZ3JleS02MDA6ICM3NTc1NzU7XG4gICAgICAtLXBhcGVyLWdyZXktNzAwOiAjNjE2MTYxO1xuICAgICAgLS1wYXBlci1ncmV5LTgwMDogIzQyNDI0MjtcbiAgICAgIC0tcGFwZXItZ3JleS05MDA6ICMyMTIxMjE7XG5cbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTUwOiAjZWNlZmYxO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktMTAwOiAjY2ZkOGRjO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktMjAwOiAjYjBiZWM1O1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktMzAwOiAjOTBhNGFlO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktNDAwOiAjNzg5MDljO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktNTAwOiAjNjA3ZDhiO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktNjAwOiAjNTQ2ZTdhO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktNzAwOiAjNDU1YTY0O1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktODAwOiAjMzc0NzRmO1xuICAgICAgLS1wYXBlci1ibHVlLWdyZXktOTAwOiAjMjYzMjM4O1xuXG4gICAgICAvKiBvcGFjaXR5IGZvciBkYXJrIHRleHQgb24gYSBsaWdodCBiYWNrZ3JvdW5kICovXG4gICAgICAtLWRhcmstZGl2aWRlci1vcGFjaXR5OiAwLjEyO1xuICAgICAgLS1kYXJrLWRpc2FibGVkLW9wYWNpdHk6IDAuMzg7IC8qIG9yIGhpbnQgdGV4dCBvciBpY29uICovXG4gICAgICAtLWRhcmstc2Vjb25kYXJ5LW9wYWNpdHk6IDAuNTQ7XG4gICAgICAtLWRhcmstcHJpbWFyeS1vcGFjaXR5OiAwLjg3O1xuXG4gICAgICAvKiBvcGFjaXR5IGZvciBsaWdodCB0ZXh0IG9uIGEgZGFyayBiYWNrZ3JvdW5kICovXG4gICAgICAtLWxpZ2h0LWRpdmlkZXItb3BhY2l0eTogMC4xMjtcbiAgICAgIC0tbGlnaHQtZGlzYWJsZWQtb3BhY2l0eTogMC4zOyAvKiBvciBoaW50IHRleHQgb3IgaWNvbiAqL1xuICAgICAgLS1saWdodC1zZWNvbmRhcnktb3BhY2l0eTogMC43O1xuICAgICAgLS1saWdodC1wcmltYXJ5LW9wYWNpdHk6IDEuMDtcblxuICAgIH1cblxuICA8L3N0eWxlPlxuPC9jdXN0b20tc3R5bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9jb2xvci5qc1xuLy8gbW9kdWxlIGlkID0gNDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxjdXN0b20tc3R5bGU+XG4gIDxzdHlsZSBpcz1cImN1c3RvbS1zdHlsZVwiPlxuICAgIGh0bWwge1xuXG4gICAgICAtLXNoYWRvdy10cmFuc2l0aW9uOiB7XG4gICAgICAgIHRyYW5zaXRpb246IGJveC1zaGFkb3cgMC4yOHMgY3ViaWMtYmV6aWVyKDAuNCwgMCwgMC4yLCAxKTtcbiAgICAgIH07XG5cbiAgICAgIC0tc2hhZG93LW5vbmU6IHtcbiAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICAgIH07XG5cbiAgICAgIC8qIGZyb20gaHR0cDovL2NvZGVwZW4uaW8vc2h5bmRtYW4vcGVuL2M1Mzk0ZGRmMmU4YjJhNWM5MTg1OTA0YjU3NDIxY2RiICovXG5cbiAgICAgIC0tc2hhZG93LWVsZXZhdGlvbi0yZHA6IHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggMnB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgMCAxcHggNXB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCAzcHggMXB4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjIpO1xuICAgICAgfTtcblxuICAgICAgLS1zaGFkb3ctZWxldmF0aW9uLTNkcDoge1xuICAgICAgICBib3gtc2hhZG93OiAwIDNweCA0cHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLFxuICAgICAgICAgICAgICAgICAgICAwIDFweCA4cHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpLFxuICAgICAgICAgICAgICAgICAgICAwIDNweCAzcHggLTJweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICB9O1xuXG4gICAgICAtLXNoYWRvdy1lbGV2YXRpb24tNGRwOiB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC4xNCksXG4gICAgICAgICAgICAgICAgICAgIDAgMXB4IDEwcHggMCByZ2JhKDAsIDAsIDAsIDAuMTIpLFxuICAgICAgICAgICAgICAgICAgICAwIDJweCA0cHggLTFweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICB9O1xuXG4gICAgICAtLXNoYWRvdy1lbGV2YXRpb24tNmRwOiB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgNnB4IDEwcHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLFxuICAgICAgICAgICAgICAgICAgICAwIDFweCAxOHB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCAzcHggNXB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgfTtcblxuICAgICAgLS1zaGFkb3ctZWxldmF0aW9uLThkcDoge1xuICAgICAgICBib3gtc2hhZG93OiAwIDhweCAxMHB4IDFweCByZ2JhKDAsIDAsIDAsIDAuMTQpLFxuICAgICAgICAgICAgICAgICAgICAwIDNweCAxNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTIpLFxuICAgICAgICAgICAgICAgICAgICAwIDVweCA1cHggLTNweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICB9O1xuXG4gICAgICAtLXNoYWRvdy1lbGV2YXRpb24tMTJkcDoge1xuICAgICAgICBib3gtc2hhZG93OiAwIDEycHggMTZweCAxcHggcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgMCA0cHggMjJweCAzcHggcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCA2cHggN3B4IC00cHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgfTtcblxuICAgICAgLS1zaGFkb3ctZWxldmF0aW9uLTE2ZHA6IHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxNnB4IDI0cHggMnB4IHJnYmEoMCwgMCwgMCwgMC4xNCksXG4gICAgICAgICAgICAgICAgICAgIDAgIDZweCAzMHB4IDVweCByZ2JhKDAsIDAsIDAsIDAuMTIpLFxuICAgICAgICAgICAgICAgICAgICAwICA4cHggMTBweCAtNXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAgIH07XG5cbiAgICAgIC0tc2hhZG93LWVsZXZhdGlvbi0yNGRwOiB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMjRweCAzOHB4IDNweCByZ2JhKDAsIDAsIDAsIDAuMTQpLFxuICAgICAgICAgICAgICAgICAgICAwIDlweCA0NnB4IDhweCByZ2JhKDAsIDAsIDAsIDAuMTIpLFxuICAgICAgICAgICAgICAgICAgICAwIDExcHggMTVweCAtN3B4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAgIH07XG4gICAgfVxuICA8L3N0eWxlPlxuPC9jdXN0b20tc3R5bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9zaGFkb3cuanNcbi8vIG1vZHVsZSBpZCA9IDQ0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uRm9ybUVsZW1lbnRCZWhhdmlvciA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBhZGRlZCB0byBhbiBgaXJvbi1mb3JtYC5cbiAgICAgKlxuICAgICAqIEBldmVudCBpcm9uLWZvcm0tZWxlbWVudC1yZWdpc3RlclxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgZWxlbWVudCBpcyByZW1vdmVkIGZyb20gYW4gYGlyb24tZm9ybWAuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1mb3JtLWVsZW1lbnQtdW5yZWdpc3RlclxuICAgICAqL1xuICAgICBcbiAgICAvKipcbiAgICAgKiBUaGUgbmFtZSBvZiB0aGlzIGVsZW1lbnQuXG4gICAgICovXG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBmb3IgdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIHZhbHVlOiB7XG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gbWFyayB0aGUgaW5wdXQgYXMgcmVxdWlyZWQuIElmIHVzZWQgaW4gYSBmb3JtLCBhXG4gICAgICogY3VzdG9tIGVsZW1lbnQgdGhhdCB1c2VzIHRoaXMgYmVoYXZpb3Igc2hvdWxkIGFsc28gdXNlXG4gICAgICogUG9seW1lci5Jcm9uVmFsaWRhdGFibGVCZWhhdmlvciBhbmQgZGVmaW5lIGEgY3VzdG9tIHZhbGlkYXRpb24gbWV0aG9kLlxuICAgICAqIE90aGVyd2lzZSwgYSBgcmVxdWlyZWRgIGVsZW1lbnQgd2lsbCBhbHdheXMgYmUgY29uc2lkZXJlZCB2YWxpZC5cbiAgICAgKiBJdCdzIGFsc28gc3Ryb25nbHkgcmVjb21tZW5kZWQgdG8gcHJvdmlkZSBhIHZpc3VhbCBzdHlsZSBmb3IgdGhlIGVsZW1lbnRcbiAgICAgKiB3aGVuIGl0cyB2YWx1ZSBpcyBpbnZhbGlkLlxuICAgICAqL1xuICAgIHJlcXVpcmVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBmb3JtIHRoYXQgdGhlIGVsZW1lbnQgaXMgcmVnaXN0ZXJlZCB0by5cbiAgICAgKi9cbiAgICBfcGFyZW50Rm9ybToge1xuICAgICAgdHlwZTogT2JqZWN0XG4gICAgfVxuICB9LFxuXG4gIGF0dGFjaGVkOiBFbGVtZW50ID8gbnVsbCA6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE5vdGU6IHRoZSBpcm9uLWZvcm0gdGhhdCB0aGlzIGVsZW1lbnQgYmVsb25ncyB0byB3aWxsIHNldCB0aGlzXG4gICAgLy8gZWxlbWVudCdzIF9wYXJlbnRGb3JtIHByb3BlcnR5IHdoZW4gaGFuZGxpbmcgdGhpcyBldmVudC5cbiAgICB0aGlzLmZpcmUoJ2lyb24tZm9ybS1lbGVtZW50LXJlZ2lzdGVyJyk7XG4gIH0sXG5cbiAgZGV0YWNoZWQ6IEVsZW1lbnQgPyBudWxsIDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BhcmVudEZvcm0pIHtcbiAgICAgIHRoaXMuX3BhcmVudEZvcm0uZmlyZSgnaXJvbi1mb3JtLWVsZW1lbnQtdW5yZWdpc3RlcicsIHt0YXJnZXQ6IHRoaXN9KTtcbiAgICB9XG4gIH1cblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tZm9ybS1lbGVtZW50LWJlaGF2aW9yL2lyb24tZm9ybS1lbGVtZW50LWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uTWV0YSB9IGZyb20gJy4uL2lyb24tbWV0YS9pcm9uLW1ldGEuanMnO1xuZXhwb3J0IGxldCBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEgPSBudWxsO1xuXG5leHBvcnQgY29uc3QgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IgPSB7XG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIHZhbGlkYXRvciB0byB1c2UuXG4gICAgICovXG4gICAgdmFsaWRhdG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgbGFzdCBjYWxsIHRvIGB2YWxpZGF0ZWAgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICBpbnZhbGlkOiB7XG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgb2JzZXJ2ZXI6ICdfaW52YWxpZENoYW5nZWQnXG4gICAgfSxcbiAgfSxcblxuICByZWdpc3RlcmVkOiBmdW5jdGlvbigpIHtcbiAgICBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEgPSBuZXcgSXJvbk1ldGEoe3R5cGU6ICd2YWxpZGF0b3InfSk7XG4gIH0sXG5cbiAgX2ludmFsaWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pbnZhbGlkKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1pbnZhbGlkJywgJ3RydWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKiBSZWNvbXB1dGUgdGhpcyBldmVyeSB0aW1lIGl0J3MgbmVlZGVkLCBiZWNhdXNlIHdlIGRvbid0IGtub3cgaWYgdGhlXG4gICAqIHVuZGVybHlpbmcgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhIGhhcyBjaGFuZ2VkLiAqL1xuICBnZXQgX3ZhbGlkYXRvcigpIHtcbiAgICByZXR1cm4gSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhICYmXG4gICAgICAgIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YS5ieUtleSh0aGlzLnZhbGlkYXRvcik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbGlkYXRvciBgdmFsaWRhdG9yYCBleGlzdHMuXG4gICAqL1xuICBoYXNWYWxpZGF0b3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IgIT0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBgdmFsdWVgIGlzIHZhbGlkLCBhbmQgdXBkYXRlcyBgaW52YWxpZGAuIElmIHlvdSB3YW50XG4gICAqIHlvdXIgZWxlbWVudCB0byBoYXZlIGN1c3RvbSB2YWxpZGF0aW9uIGxvZ2ljLCBkbyBub3Qgb3ZlcnJpZGUgdGhpcyBtZXRob2Q7XG4gICAqIG92ZXJyaWRlIGBfZ2V0VmFsaWRpdHkodmFsdWUpYCBpbnN0ZWFkLlxuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBEZXByZWNhdGVkOiBUaGUgdmFsdWUgdG8gYmUgdmFsaWRhdGVkLiBCeSBkZWZhdWx0LFxuICAgKiBpdCBpcyBwYXNzZWQgdG8gdGhlIHZhbGlkYXRvcidzIGB2YWxpZGF0ZSgpYCBmdW5jdGlvbiwgaWYgYSB2YWxpZGF0b3IgaXMgc2V0LlxuICAgKiBJZiB0aGlzIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWQsIHRoZW4gdGhlIGVsZW1lbnQncyBgdmFsdWVgIHByb3BlcnR5XG4gICAqIGlzIHVzZWQsIGlmIGl0IGV4aXN0cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLlxuICAgKi9cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhbiBlbGVtZW50IHRoYXQgYWxzbyBoYXMgYSB2YWx1ZSBwcm9wZXJ0eSwgYW5kIHRoZXJlIHdhc1xuICAgIC8vIG5vIGV4cGxpY2l0IHZhbHVlIGFyZ3VtZW50IHBhc3NlZCwgdXNlIHRoZSBlbGVtZW50J3MgcHJvcGVydHkgaW5zdGVhZC5cbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiB0aGlzLnZhbHVlICE9PSB1bmRlZmluZWQpXG4gICAgICB0aGlzLmludmFsaWQgPSAhdGhpcy5fZ2V0VmFsaWRpdHkodGhpcy52YWx1ZSk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5pbnZhbGlkID0gIXRoaXMuX2dldFZhbGlkaXR5KHZhbHVlKTtcbiAgICByZXR1cm4gIXRoaXMuaW52YWxpZDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQuICBCeSBkZWZhdWx0LCBpdCBpcyBwYXNzZWRcbiAgICogdG8gdGhlIHZhbGlkYXRvcidzIGB2YWxpZGF0ZSgpYCBmdW5jdGlvbiwgaWYgYSB2YWxpZGF0b3IgaXMgc2V0LiBZb3VcbiAgICogc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSB3YW50IHRvIGltcGxlbWVudCBjdXN0b20gdmFsaWRpdHlcbiAgICogbG9naWMgZm9yIHlvdXIgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIFRoZSB2YWx1ZSB0byBiZSB2YWxpZGF0ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC5cbiAgICovXG5cbiAgX2dldFZhbGlkaXR5OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICh0aGlzLmhhc1ZhbGlkYXRvcigpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdmFsaWRhdG9yLnZhbGlkYXRlKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IGZsdXNoIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IFBhcGVySW5wdXRBZGRvbkJlaGF2aW9yID0ge1xuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvc2hhZHlkb20vaXNzdWVzLzk2XG4gICAgZmx1c2goKTtcbiAgICB0aGlzLmZpcmUoJ2FkZG9uLWF0dGFjaGVkJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBmdW5jdGlvbiBjYWxsZWQgYnkgYDxwYXBlci1pbnB1dC1jb250YWluZXI+YCB3aGVuIHRoZSBpbnB1dCB2YWx1ZSBvciB2YWxpZGl0eSBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge3tcbiAgICogICBpbnB1dEVsZW1lbnQ6IChFbGVtZW50fHVuZGVmaW5lZCksXG4gICAqICAgdmFsdWU6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAgICogICBpbnZhbGlkOiBib29sZWFuXG4gICAqIH19IHN0YXRlIC1cbiAgICogICAgIGlucHV0RWxlbWVudDogVGhlIGlucHV0IGVsZW1lbnQuXG4gICAqICAgICB2YWx1ZTogVGhlIGlucHV0IHZhbHVlLlxuICAgKiAgICAgaW52YWxpZDogVHJ1ZSBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgaW52YWxpZC5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgfVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtYWRkb24tYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCwgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBQYXBlcklua3lGb2N1c0JlaGF2aW9yIH0gZnJvbSAnLi9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBhcGVyUmlwcGxlQmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyc7XG5cbmV4cG9ydCBjb25zdCBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsID0ge1xuICAvKipcbiAgICogU3luY2hyb25pemVzIHRoZSBlbGVtZW50J3MgY2hlY2tlZCBzdGF0ZSB3aXRoIGl0cyByaXBwbGUgZWZmZWN0LlxuICAgKi9cbiAgX2NoZWNrZWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGwuX2NoZWNrZWRDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuaGFzUmlwcGxlKCkpIHtcbiAgICAgIGlmICh0aGlzLmNoZWNrZWQpIHtcbiAgICAgICAgdGhpcy5fcmlwcGxlLnNldEF0dHJpYnV0ZSgnY2hlY2tlZCcsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZS5yZW1vdmVBdHRyaWJ1dGUoJ2NoZWNrZWQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyB0aGUgZWxlbWVudCdzIGBhY3RpdmVgIGFuZCBgY2hlY2tlZGAgc3RhdGUuXG4gICAqL1xuICBfYnV0dG9uU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBQYXBlclJpcHBsZUJlaGF2aW9yLl9idXR0b25TdGF0ZUNoYW5nZWQuY2FsbCh0aGlzKTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICB0aGlzLmNoZWNrZWQgPSB0aGlzLmFjdGl2ZTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3IgPSBbXG4gIFBhcGVySW5reUZvY3VzQmVoYXZpb3IsXG4gIElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9yLFxuICBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsXG5dO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNDhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkJ1dHRvblN0YXRlIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanMnO1xuaW1wb3J0IHsgUGFwZXJSaXBwbGVCZWhhdmlvciB9IGZyb20gJy4vcGFwZXItcmlwcGxlLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IElyb25Db250cm9sU3RhdGUgfSBmcm9tICcuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWNvbnRyb2wtc3RhdGUuanMnO1xuXG5leHBvcnQgY29uc3QgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGwgPSB7XG4gIG9ic2VydmVyczogW1xuICAgICdfZm9jdXNlZENoYW5nZWQocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCknXG4gIF0sXG5cbiAgX2ZvY3VzZWRDaGFuZ2VkOiBmdW5jdGlvbihyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSB7XG4gICAgaWYgKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICB0aGlzLl9yaXBwbGUuaG9sZERvd24gPSByZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkO1xuICAgIH1cbiAgfSxcblxuICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmlwcGxlID0gUGFwZXJSaXBwbGVCZWhhdmlvci5fY3JlYXRlUmlwcGxlKCk7XG4gICAgcmlwcGxlLmlkID0gJ2luayc7XG4gICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgnY2VudGVyJywgJycpO1xuICAgIHJpcHBsZS5jbGFzc0xpc3QuYWRkKCdjaXJjbGUnKTtcbiAgICByZXR1cm4gcmlwcGxlO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciA9IFtcbiAgSXJvbkJ1dHRvblN0YXRlLFxuICBJcm9uQ29udHJvbFN0YXRlLFxuICBQYXBlclJpcHBsZUJlaGF2aW9yLFxuICBQYXBlcklua3lGb2N1c0JlaGF2aW9ySW1wbFxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1pbmt5LWZvY3VzLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBFbGVtZW50IGFzIFBvbHltZXJFbGVtZW50IH0gZnJvbSAnQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQnO1xuaW1wb3J0IFwiQHBvbHltZXIvcGFwZXItdG9nZ2xlLWJ1dHRvbi9wYXBlci10b2dnbGUtYnV0dG9uXCI7XG5pbXBvcnQge2h0bWwsIHJlbmRlcn0gZnJvbSAnbGl0LWh0bWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUYWN0aWxlTW9kZSBleHRlbmRzIFBvbHltZXJFbGVtZW50IHtcbiAgc3RhdGljIGdldCBpcygpIHtcbiAgICByZXR1cm4gXCJ0YWN0aWxlLW1vZGVcIjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIFwiPHBhcGVyLXRvZ2dsZS1idXR0b24+RWRpdDwvcGFwZXItdG9nZ2xlLWJ1dHRvbj5cIjtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgdmFyIHRvZ2dsZSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwicGFwZXItdG9nZ2xlLWJ1dHRvblwiKTtcbiAgfVxuXG4gIHNldFRvRWRpdCgpIHtcbiAgICB2YXIgdG9nZ2xlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJwYXBlci10b2dnbGUtYnV0dG9uXCIpO1xuICAgIHRvZ2dsZS5jaGVja2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHNldFRvUHVibGlzaCgpIHtcbiAgICB2YXIgdG9nZ2xlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJwYXBlci10b2dnbGUtYnV0dG9uXCIpO1xuICAgIHRvZ2dsZS5jaGVja2VkID0gdHJ1ZTtcbiAgfVxuXG4gIHN3aXRjaGVkVG9FZGl0KGNhbGxiYWNrKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwicGFwZXItdG9nZ2xlLWJ1dHRvblwiKTtcbiAgICB0b2dnbGUuYWRkRXZlbnRMaXN0ZW5lcihcImlyb24tY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGlmICh0b2dnbGUuY2hlY2tlZCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3dpdGNoZWRUb1B1Ymxpc2goY2FsbGJhY2spIHtcbiAgICB2YXIgdG9nZ2xlID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoXCJwYXBlci10b2dnbGUtYnV0dG9uXCIpO1xuICAgIHRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKFwiaXJvbi1jaGFuZ2VcIiwgKCkgPT4ge1xuICAgICAgaWYgKCEgdG9nZ2xlLmNoZWNrZWQpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuXG4vLyBSZWdpc3RlciBjdXN0b20gZWxlbWVudCBjbGFzcyB3aXRoIGJyb3dzZXJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZShUYWN0aWxlTW9kZS5pcywgVGFjdGlsZU1vZGUpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdGFjdGlsZS9jbGllbnQvdGFjdGlsZS1tb2RlLmpzIiwiaW1wb3J0IFwiQHBvbHltZXIvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZVwiO1xuaW1wb3J0IFwiLi90YWN0aWxlLWVkaXRhYmxlLmpzXCI7XG5pbXBvcnQgXCIuL3RhY3RpbGUtbW9kZS5qc1wiO1xuXG5mdW5jdGlvbiB3YXRjaEZvckNvbXBvbmVudENsaWNrcyhldmVudCkge1xuICAvLyBUaGlzIHN0b3BzIHVzZXIgZnJvbSBpbnRlcmFjdGluZyB3aXRoIHBhZ2UgaW4gYXV0aG9yIG1vZGVcbiAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgdmFyIGNvbXBvbmVudCA9IGV2ZW50LnRhcmdldC5jbG9zZXN0KFwidGFjdGlsZS1lZGl0YWJsZVwiKTtcbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIGNvbXBvbmVudC5vcGVuRGlhbG9nKHdhdGNoRm9yQ29tcG9uZW50Q2xpY2tzKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgd2F0Y2hGb3JDb21wb25lbnRDbGlja3MpO1xuICB9XG59O1xuXG5cbmZ1bmN0aW9uIHdhdGNoRm9yQ29tcG9uZW50Q2xpY2tzKGV2ZW50KSB7XG4gIC8vIFRoaXMgc3RvcHMgdXNlciBmcm9tIGludGVyYWN0aW5nIHdpdGggcGFnZSBpbiBhdXRob3IgbW9kZVxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICB2YXIgdGFjdGlsZUVkaXRhYmxlID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoXCJ0YWN0aWxlLWVkaXRhYmxlXCIpO1xuICBpZiAodGFjdGlsZUVkaXRhYmxlKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHdhdGNoRm9yQ29tcG9uZW50Q2xpY2tzKTtcblxuICAgIHRhY3RpbGVFZGl0YWJsZS5vcGVuRGlhbG9nKGZ1bmN0aW9uKHJlcXVpcmVzUmVmcmVzaCA9IHRydWUpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB3YXRjaEZvckNvbXBvbmVudENsaWNrcyk7XG5cbiAgICAgIC8vIFRPRE8ganVzdCByZWxvYWQgdGhlIGNvbXBvbmVudCwgbm90IHRoZSBlbnRpcmUgcGFnZS5cbiAgICAgIGlmIChyZXF1aXJlc1JlZnJlc2gpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzZXR1cEVkaXRNb2RlKCkge1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgd2F0Y2hGb3JDb21wb25lbnRDbGlja3MpO1xuICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoXCJlZGl0XCIpO1xuICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShcInRhY3RpbGUtbW9kZVwiLCBcImVkaXRcIik7XG59XG5cbmZ1bmN0aW9uIHNldHVwUHVibGlzaE1vZGUoKSB7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB3YXRjaEZvckNvbXBvbmVudENsaWNrcyk7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShcImVkaXRcIik7XG4gIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwidGFjdGlsZS1tb2RlXCIsIFwicHVibGlzaFwiKTtcbn1cblxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgKGV2ZW50KSA9PiB7XG4gIGlmIChkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5jb250YWlucygnZWRpdCcpKSB7XG4gICAgdmFyIHRhY3RpbGVNb2RlVG9nZ2xlID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcInRhY3RpbGUtbW9kZVwiKTtcbiAgICB0YWN0aWxlTW9kZVRvZ2dsZS5zd2l0Y2hlZFRvRWRpdChzZXR1cEVkaXRNb2RlKTtcbiAgICB0YWN0aWxlTW9kZVRvZ2dsZS5zd2l0Y2hlZFRvUHVibGlzaChzZXR1cFB1Ymxpc2hNb2RlKTtcblxuICAgIHZhciBtb2RlID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oXCJ0YWN0aWxlLW1vZGVcIik7XG5cbiAgICBpZiAobW9kZSA9PT0gXCJlZGl0XCIpIHtcbiAgICAgIHRhY3RpbGVNb2RlVG9nZ2xlLnNldFRvRWRpdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXR1cFB1Ymxpc2hNb2RlKCk7XG4gICAgfVxuICB9XG59KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3RhY3RpbGUvY2xpZW50L2F1dGhvci5qcyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEFwcGx5U2hpbSBmcm9tICcuLi9zcmMvYXBwbHktc2hpbS5qcyc7XG5pbXBvcnQgdGVtcGxhdGVNYXAgZnJvbSAnLi4vc3JjL3RlbXBsYXRlLW1hcC5qcyc7XG5pbXBvcnQge2dldElzRXh0ZW5kcywgdG9Dc3NUZXh0fSBmcm9tICcuLi9zcmMvc3R5bGUtdXRpbC5qcyc7XG5pbXBvcnQgKiBhcyBBcHBseVNoaW1VdGlscyBmcm9tICcuLi9zcmMvYXBwbHktc2hpbS11dGlscy5qcyc7XG5pbXBvcnQgZG9jdW1lbnRXYWl0IGZyb20gJy4uL3NyYy9kb2N1bWVudC13YWl0LmpzJztcbmltcG9ydCB7Z2V0Q29tcHV0ZWRTdHlsZVZhbHVlLCB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzfSBmcm9tICcuLi9zcmMvY29tbW9uLXV0aWxzLmpzJztcbmltcG9ydCB7Q3VzdG9tU3R5bGVJbnRlcmZhY2VJbnRlcmZhY2V9IGZyb20gJy4uL3NyYy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHtuYXRpdmVDc3NWYXJpYWJsZXMsIG5hdGl2ZVNoYWRvd30gZnJvbSAnLi4vc3JjL3N0eWxlLXNldHRpbmdzLmpzJztcblxuLyoqIEBjb25zdCB7QXBwbHlTaGltfSAqL1xuY29uc3QgYXBwbHlTaGltID0gbmV3IEFwcGx5U2hpbSgpO1xuXG5jbGFzcyBBcHBseVNoaW1JbnRlcmZhY2Uge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgez9DdXN0b21TdHlsZUludGVyZmFjZUludGVyZmFjZX0gKi9cbiAgICB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlID0gbnVsbDtcbiAgICBkb2N1bWVudFdhaXQoKCkgPT4ge1xuICAgICAgdGhpcy5lbnN1cmUoKTtcbiAgICB9KTtcbiAgICBhcHBseVNoaW1bJ2ludmFsaWRDYWxsYmFjayddID0gQXBwbHlTaGltVXRpbHMuaW52YWxpZGF0ZTtcbiAgfVxuICBlbnN1cmUoKSB7XG4gICAgaWYgKHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZTtcbiAgICBpZiAodGhpcy5jdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgICAgdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsndHJhbnNmb3JtQ2FsbGJhY2snXSA9IChzdHlsZSkgPT4ge1xuICAgICAgICBhcHBseVNoaW0udHJhbnNmb3JtQ3VzdG9tU3R5bGUoc3R5bGUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ3ZhbGlkYXRlQ2FsbGJhY2snXSA9ICgpID0+IHtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsnZW5xdWV1ZWQnXSkge1xuICAgICAgICAgICAgdGhpcy5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICovXG4gIHByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUpIHtcbiAgICB0aGlzLmVuc3VyZSgpO1xuICAgIHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXSA9IHRlbXBsYXRlO1xuICAgIGxldCBhc3QgPSBhcHBseVNoaW0udHJhbnNmb3JtVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lKTtcbiAgICAvLyBzYXZlIG9yaWdpbmFsIHN0eWxlIGFzdCB0byB1c2UgZm9yIHJldmFsaWRhdGluZyBpbnN0YW5jZXNcbiAgICB0ZW1wbGF0ZVsnX3N0eWxlQXN0J10gPSBhc3Q7XG4gIH1cbiAgZmx1c2hDdXN0b21TdHlsZXMoKSB7XG4gICAgdGhpcy5lbnN1cmUoKTtcbiAgICBpZiAoIXRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHN0eWxlcyA9IHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ3Byb2Nlc3NTdHlsZXMnXSgpO1xuICAgIGlmICghdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsnZW5xdWV1ZWQnXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKyApIHtcbiAgICAgIGxldCBjcyA9IHN0eWxlc1tpXTtcbiAgICAgIGxldCBzdHlsZSA9IHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ2dldFN0eWxlRm9yQ3VzdG9tU3R5bGUnXShjcyk7XG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgYXBwbHlTaGltLnRyYW5zZm9ybUN1c3RvbVN0eWxlKHN0eWxlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsnZW5xdWV1ZWQnXSA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgKi9cbiAgc3R5bGVTdWJ0cmVlKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICB0aGlzLmVuc3VyZSgpO1xuICAgIGlmIChwcm9wZXJ0aWVzKSB7XG4gICAgICB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudC5zaGFkb3dSb290KSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudChlbGVtZW50KTtcbiAgICAgIGxldCBzaGFkb3dDaGlsZHJlbiA9IGVsZW1lbnQuc2hhZG93Um9vdC5jaGlsZHJlbiB8fCBlbGVtZW50LnNoYWRvd1Jvb3QuY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhZG93Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zdHlsZVN1YnRyZWUoLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oc2hhZG93Q2hpbGRyZW5baV0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbiB8fCBlbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuc3R5bGVTdWJ0cmVlKC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKGNoaWxkcmVuW2ldKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBzdHlsZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgbGV0IHtpc30gPSBnZXRJc0V4dGVuZHMoZWxlbWVudCk7XG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbaXNdO1xuICAgIGlmICh0ZW1wbGF0ZSAmJiAhQXBwbHlTaGltVXRpbHMudGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSkge1xuICAgICAgLy8gb25seSByZXZhbGlkYXRlIHRlbXBsYXRlIG9uY2VcbiAgICAgIGlmICghQXBwbHlTaGltVXRpbHMudGVtcGxhdGVJc1ZhbGlkYXRpbmcodGVtcGxhdGUpKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBpcyk7XG4gICAgICAgIEFwcGx5U2hpbVV0aWxzLnN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZSB0aGlzIGVsZW1lbnQgaW5zdGFuY2VcbiAgICAgIGxldCByb290ID0gZWxlbWVudC5zaGFkb3dSb290O1xuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgbGV0IHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqLyhyb290LnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpO1xuICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAvLyByZXVzZSB0aGUgdGVtcGxhdGUncyBzdHlsZSBhc3QsIGl0IGhhcyBhbGwgdGhlIG9yaWdpbmFsIGNzcyB0ZXh0XG4gICAgICAgICAgc3R5bGVbJ19fY3NzUnVsZXMnXSA9IHRlbXBsYXRlWydfc3R5bGVBc3QnXTtcbiAgICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHRvQ3NzVGV4dCh0ZW1wbGF0ZVsnX3N0eWxlQXN0J10pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgKi9cbiAgc3R5bGVEb2N1bWVudChwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5lbnN1cmUoKTtcbiAgICB0aGlzLnN0eWxlU3VidHJlZShkb2N1bWVudC5ib2R5LCBwcm9wZXJ0aWVzKTtcbiAgfVxufVxuXG5pZiAoIXdpbmRvdy5TaGFkeUNTUyB8fCAhd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltKSB7XG4gIGNvbnN0IGFwcGx5U2hpbUludGVyZmFjZSA9IG5ldyBBcHBseVNoaW1JbnRlcmZhY2UoKTtcbiAgbGV0IEN1c3RvbVN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZTtcblxuICB3aW5kb3cuU2hhZHlDU1MgPSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGVsZW1lbnRFeHRlbmRzXG4gICAgICovXG4gICAgcHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSwgZWxlbWVudEV4dGVuZHMpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2UucHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSlcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdHlsZVN1YnRyZWUoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2Uuc3R5bGVTdWJ0cmVlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIHN0eWxlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2UuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5zdHlsZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgICAqL1xuICAgIHN0eWxlRG9jdW1lbnQocHJvcGVydGllcykge1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2Uuc3R5bGVEb2N1bWVudChwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAgICogQHJldHVybiB7c3RyaW5nfVxuICAgICAqL1xuICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIGdldENvbXB1dGVkU3R5bGVWYWx1ZShlbGVtZW50LCBwcm9wZXJ0eSk7XG4gICAgfSxcbiAgICBuYXRpdmVDc3M6IG5hdGl2ZUNzc1ZhcmlhYmxlcyxcbiAgICBuYXRpdmVTaGFkb3c6IG5hdGl2ZVNoYWRvd1xuICB9O1xuXG4gIGlmIChDdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgIHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZSA9IEN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuICB9XG59XG5cbndpbmRvdy5TaGFkeUNTUy5BcHBseVNoaW0gPSBhcHBseVNoaW07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvYXBwbHktc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbi8qXG4gKiBUaGUgYXBwbHkgc2hpbSBzaW11bGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGBAYXBwbHlgIHByb3Bvc2VkIGF0XG4gKiBodHRwczovL3RhYmF0a2lucy5naXRodWIuaW8vc3BlY3MvY3NzLWFwcGx5LXJ1bGUvLlxuICogVGhlIGFwcHJvYWNoIGlzIHRvIGNvbnZlcnQgYSBwcm9wZXJ0eSBsaWtlIHRoaXM6XG4gKlxuICogICAgLS1mb286IHtjb2xvcjogcmVkOyBiYWNrZ3JvdW5kOiBibHVlO31cbiAqXG4gKiB0byB0aGlzOlxuICpcbiAqICAgIC0tZm9vXy1fY29sb3I6IHJlZDtcbiAqICAgIC0tZm9vXy1fYmFja2dyb3VuZDogYmx1ZTtcbiAqXG4gKiBUaGVuIHdoZXJlIGBAYXBwbHkgLS1mb29gIGlzIHVzZWQsIHRoYXQgaXMgY29udmVydGVkIHRvOlxuICpcbiAqICAgIGNvbG9yOiB2YXIoLS1mb29fLV9jb2xvcik7XG4gKiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mb29fLV9iYWNrZ3JvdW5kKTtcbiAqXG4gKiBUaGlzIGFwcHJvYWNoIGdlbmVyYWxseSB3b3JrcyBidXQgdGhlcmUgYXJlIHNvbWUgaXNzdWVzIGFuZCBsaW1pdGF0aW9ucy5cbiAqIENvbnNpZGVyLCBmb3IgZXhhbXBsZSwgdGhhdCBzb21ld2hlcmUgKmJldHdlZW4qIHdoZXJlIGAtLWZvb2AgaXMgc2V0IGFuZCB1c2VkLFxuICogYW5vdGhlciBlbGVtZW50IHNldHMgaXQgdG86XG4gKlxuICogICAgLS1mb286IHsgYm9yZGVyOiAycHggc29saWQgcmVkOyB9XG4gKlxuICogV2UgbXVzdCBub3cgZW5zdXJlIHRoYXQgdGhlIGNvbG9yIGFuZCBiYWNrZ3JvdW5kIGZyb20gdGhlIHByZXZpb3VzIHNldHRpbmdcbiAqIGRvIG5vdCBhcHBseS4gVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgY2hhbmdpbmcgdGhlIHByb3BlcnR5IHNldCB0byB0aGlzOlxuICpcbiAqICAgIC0tZm9vXy1fYm9yZGVyOiAycHggc29saWQgcmVkO1xuICogICAgLS1mb29fLV9jb2xvcjogaW5pdGlhbDtcbiAqICAgIC0tZm9vXy1fYmFja2dyb3VuZDogaW5pdGlhbDtcbiAqXG4gKiBUaGlzIHdvcmtzIGJ1dCBpbnRyb2R1Y2VzIG9uZSBuZXcgaXNzdWUuXG4gKiBDb25zaWRlciB0aGlzIHNldHVwIGF0IHRoZSBwb2ludCB3aGVyZSB0aGUgYEBhcHBseWAgaXMgdXNlZDpcbiAqXG4gKiAgICBiYWNrZ3JvdW5kOiBvcmFuZ2U7XG4gKiAgICBgQGFwcGx5YCAtLWZvbztcbiAqXG4gKiBJbiB0aGlzIGNhc2UgdGhlIGJhY2tncm91bmQgd2lsbCBiZSB1bnNldCAoaW5pdGlhbCkgcmF0aGVyIHRoYW4gdGhlIGRlc2lyZWRcbiAqIGBvcmFuZ2VgLiBXZSBhZGRyZXNzIHRoaXMgYnkgYWx0ZXJpbmcgdGhlIHByb3BlcnR5IHNldCB0byB1c2UgYSBmYWxsYmFja1xuICogdmFsdWUgbGlrZSB0aGlzOlxuICpcbiAqICAgIGNvbG9yOiB2YXIoLS1mb29fLV9jb2xvcik7XG4gKiAgICBiYWNrZ3JvdW5kOiB2YXIoLS1mb29fLV9iYWNrZ3JvdW5kLCBvcmFuZ2UpO1xuICogICAgYm9yZGVyOiB2YXIoLS1mb29fLV9ib3JkZXIpO1xuICpcbiAqIE5vdGUgdGhhdCB0aGUgZGVmYXVsdCBpcyByZXRhaW5lZCBpbiB0aGUgcHJvcGVydHkgc2V0IGFuZCB0aGUgYGJhY2tncm91bmRgIGlzXG4gKiB0aGUgZGVzaXJlZCBgb3JhbmdlYC4gVGhpcyBsZWFkcyB1cyB0byBhIGxpbWl0YXRpb24uXG4gKlxuICogTGltaXRhdGlvbiAxOlxuXG4gKiBPbmx5IHByb3BlcnRpZXMgaW4gdGhlIHJ1bGUgd2hlcmUgdGhlIGBAYXBwbHlgXG4gKiBpcyB1c2VkIGFyZSBjb25zaWRlcmVkIGFzIGRlZmF1bHQgdmFsdWVzLlxuICogSWYgYW5vdGhlciBydWxlIG1hdGNoZXMgdGhlIGVsZW1lbnQgYW5kIHNldHMgYGJhY2tncm91bmRgIHdpdGhcbiAqIGxlc3Mgc3BlY2lmaWNpdHkgdGhhbiB0aGUgcnVsZSBpbiB3aGljaCBgQGFwcGx5YCBhcHBlYXJzLFxuICogdGhlIGBiYWNrZ3JvdW5kYCB3aWxsIG5vdCBiZSBzZXQuXG4gKlxuICogTGltaXRhdGlvbiAyOlxuICpcbiAqIFdoZW4gdXNpbmcgUG9seW1lcidzIGB1cGRhdGVTdHlsZXNgIGFwaSwgbmV3IHByb3BlcnRpZXMgbWF5IG5vdCBiZSBzZXQgZm9yXG4gKiBgQGFwcGx5YCBwcm9wZXJ0aWVzLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7Zm9yRWFjaFJ1bGUsIHByb2Nlc3NWYXJpYWJsZUFuZEZhbGxiYWNrLCBydWxlc0ZvclN0eWxlLCB0b0Nzc1RleHQsIGdhdGhlclN0eWxlVGV4dH0gZnJvbSAnLi9zdHlsZS11dGlsLmpzJztcbmltcG9ydCB7TUlYSU5fTUFUQ0gsIFZBUl9BU1NJR059IGZyb20gJy4vY29tbW9uLXJlZ2V4LmpzJztcbmltcG9ydCB7ZGV0ZWN0TWl4aW59IGZyb20gJy4vY29tbW9uLXV0aWxzLmpzJztcbmltcG9ydCB7U3R5bGVOb2RlfSBmcm9tICcuL2Nzcy1wYXJzZS5qcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuY29uc3QgQVBQTFlfTkFNRV9DTEVBTiA9IC87XFxzKi9tO1xuY29uc3QgSU5JVElBTF9JTkhFUklUID0gL15cXHMqKGluaXRpYWwpfChpbmhlcml0KVxccyokLztcblxuLy8gc2VwYXJhdG9yIHVzZWQgYmV0d2VlbiBtaXhpbi1uYW1lIGFuZCBtaXhpbi1wcm9wZXJ0eS1uYW1lIHdoZW4gcHJvZHVjaW5nIHByb3BlcnRpZXNcbi8vIE5PVEU6IHBsYWluICctJyBtYXkgY2F1c2UgY29sbGlzaW9ucyBpbiB1c2VyIHN0eWxlc1xuY29uc3QgTUlYSU5fVkFSX1NFUCA9ICdfLV8nO1xuXG4vKipcbiAqIEB0eXBlZGVmIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAqL1xubGV0IFByb3BlcnR5RW50cnk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqXG4gKiBAdHlwZWRlZiB7IU9iamVjdDxzdHJpbmcsIGJvb2xlYW4+fVxuICovXG5sZXQgRGVwZW5kYW50c0VudHJ5OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKiBAdHlwZWRlZiB7e1xuICogICAgcHJvcGVydGllczogUHJvcGVydHlFbnRyeSxcbiAqICAgIGRlcGVuZGFudHM6IERlcGVuZGFudHNFbnRyeVxuICogfX1cbiAqL1xubGV0IE1peGluTWFwRW50cnk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLy8gbWFwIG9mIG1peGluIHRvIHByb3BlcnR5IG5hbWVzXG4vLyAtLWZvbzoge2JvcmRlcjogMnB4fSAtPiB7cHJvcGVydGllczogeygtLWZvbywgWydib3JkZXInXSl9LCBkZXBlbmRhbnRzOiB7J2VsZW1lbnQtbmFtZSc6IHByb3RvfX1cbmNsYXNzIE1peGluTWFwIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIU1peGluTWFwRW50cnk+fSAqL1xuICAgIHRoaXMuX21hcCA9IHt9O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyFQcm9wZXJ0eUVudHJ5fSBwcm9wc1xuICAgKi9cbiAgc2V0KG5hbWUsIHByb3BzKSB7XG4gICAgbmFtZSA9IG5hbWUudHJpbSgpO1xuICAgIHRoaXMuX21hcFtuYW1lXSA9IHtcbiAgICAgIHByb3BlcnRpZXM6IHByb3BzLFxuICAgICAgZGVwZW5kYW50czoge31cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm4ge01peGluTWFwRW50cnl9XG4gICAqL1xuICBnZXQobmFtZSkge1xuICAgIG5hbWUgPSBuYW1lLnRyaW0oKTtcbiAgICByZXR1cm4gdGhpcy5fbWFwW25hbWVdIHx8IG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3Igd2hlbiBhbiBlbGVtZW50IGlzIG1hcmtlZCBpbnZhbGlkXG4gKiBAdHlwZSB7P2Z1bmN0aW9uKHN0cmluZyl9XG4gKi9cbmxldCBpbnZhbGlkQ2FsbGJhY2sgPSBudWxsO1xuXG4vKiogQHVucmVzdHJpY3RlZCAqL1xuY2xhc3MgQXBwbHlTaGltIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHs/c3RyaW5nfSAqL1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0hUTUxNZXRhRWxlbWVudH0gKi9cbiAgICB0aGlzLl9tZWFzdXJlRWxlbWVudCA9IG51bGw7XG4gICAgdGhpcy5fbWFwID0gbmV3IE1peGluTWFwKCk7XG4gIH1cbiAgLyoqXG4gICAqIHJldHVybiB0cnVlIGlmIGBjc3NUZXh0YCBjb250YWlucyBhIG1peGluIGRlZmluaXRpb24gb3IgY29uc3VtcHRpb25cbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGRldGVjdE1peGluKGNzc1RleHQpIHtcbiAgICByZXR1cm4gZGV0ZWN0TWl4aW4oY3NzVGV4dCk7XG4gIH1cblxuICAvKipcbiAgICogR2F0aGVyIHN0eWxlcyBpbnRvIG9uZSBzdHlsZSBmb3IgZWFzaWVyIHByb2Nlc3NpbmdcbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH1cbiAgICovXG4gIGdhdGhlclN0eWxlcyh0ZW1wbGF0ZSkge1xuICAgIGNvbnN0IHN0eWxlVGV4dCA9IGdhdGhlclN0eWxlVGV4dCh0ZW1wbGF0ZS5jb250ZW50KTtcbiAgICBpZiAoc3R5bGVUZXh0KSB7XG4gICAgICBjb25zdCBzdHlsZSA9IC8qKiBAdHlwZSB7IUhUTUxTdHlsZUVsZW1lbnR9ICovKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJykpO1xuICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBzdHlsZVRleHQ7XG4gICAgICB0ZW1wbGF0ZS5jb250ZW50Lmluc2VydEJlZm9yZShzdHlsZSwgdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkKTtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gICAqL1xuICB0cmFuc2Zvcm1UZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUpIHtcbiAgICBpZiAodGVtcGxhdGUuX2dhdGhlcmVkU3R5bGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGVtcGxhdGUuX2dhdGhlcmVkU3R5bGUgPSB0aGlzLmdhdGhlclN0eWxlcyh0ZW1wbGF0ZSk7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7SFRNTFN0eWxlRWxlbWVudH0gKi9cbiAgICBjb25zdCBzdHlsZSA9IHRlbXBsYXRlLl9nYXRoZXJlZFN0eWxlO1xuICAgIHJldHVybiBzdHlsZSA/IHRoaXMudHJhbnNmb3JtU3R5bGUoc3R5bGUsIGVsZW1lbnROYW1lKSA6IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gICAqL1xuICB0cmFuc2Zvcm1TdHlsZShzdHlsZSwgZWxlbWVudE5hbWUgPSAnJykge1xuICAgIGxldCBhc3QgPSBydWxlc0ZvclN0eWxlKHN0eWxlKTtcbiAgICB0aGlzLnRyYW5zZm9ybVJ1bGVzKGFzdCwgZWxlbWVudE5hbWUpO1xuICAgIHN0eWxlLnRleHRDb250ZW50ID0gdG9Dc3NUZXh0KGFzdCk7XG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAgICogQHJldHVybiB7U3R5bGVOb2RlfVxuICAgKi9cbiAgdHJhbnNmb3JtQ3VzdG9tU3R5bGUoc3R5bGUpIHtcbiAgICBsZXQgYXN0ID0gcnVsZXNGb3JTdHlsZShzdHlsZSk7XG4gICAgZm9yRWFjaFJ1bGUoYXN0LCAocnVsZSkgPT4ge1xuICAgICAgaWYgKHJ1bGVbJ3NlbGVjdG9yJ10gPT09ICc6cm9vdCcpIHtcbiAgICAgICAgcnVsZVsnc2VsZWN0b3InXSA9ICdodG1sJztcbiAgICAgIH1cbiAgICAgIHRoaXMudHJhbnNmb3JtUnVsZShydWxlKTtcbiAgICB9KVxuICAgIHN0eWxlLnRleHRDb250ZW50ID0gdG9Dc3NUZXh0KGFzdCk7XG4gICAgcmV0dXJuIGFzdDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtTdHlsZU5vZGV9IHJ1bGVzXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgKi9cbiAgdHJhbnNmb3JtUnVsZXMocnVsZXMsIGVsZW1lbnROYW1lKSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50TmFtZTtcbiAgICBmb3JFYWNoUnVsZShydWxlcywgKHIpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtUnVsZShyKTtcbiAgICB9KTtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IVN0eWxlTm9kZX0gcnVsZVxuICAgKi9cbiAgdHJhbnNmb3JtUnVsZShydWxlKSB7XG4gICAgcnVsZVsnY3NzVGV4dCddID0gdGhpcy50cmFuc2Zvcm1Dc3NUZXh0KHJ1bGVbJ3BhcnNlZENzc1RleHQnXSk7XG4gICAgLy8gOnJvb3Qgd2FzIG9ubHkgdXNlZCBmb3IgdmFyaWFibGUgYXNzaWdubWVudCBpbiBwcm9wZXJ0eSBzaGltLFxuICAgIC8vIGJ1dCBnZW5lcmF0ZXMgaW52YWxpZCBzZWxlY3RvcnMgd2l0aCByZWFsIHByb3BlcnRpZXMuXG4gICAgLy8gcmVwbGFjZSB3aXRoIGA6aG9zdCA+ICpgLCB3aGljaCBzZXJ2ZXMgdGhlIHNhbWUgZWZmZWN0XG4gICAgaWYgKHJ1bGVbJ3NlbGVjdG9yJ10gPT09ICc6cm9vdCcpIHtcbiAgICAgIHJ1bGVbJ3NlbGVjdG9yJ10gPSAnOmhvc3QgPiAqJztcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHRyYW5zZm9ybUNzc1RleHQoY3NzVGV4dCkge1xuICAgIC8vIHByb2R1Y2UgdmFyaWFibGVzXG4gICAgY3NzVGV4dCA9IGNzc1RleHQucmVwbGFjZShWQVJfQVNTSUdOLCAobWF0Y2hUZXh0LCBwcm9wZXJ0eU5hbWUsIHZhbHVlUHJvcGVydHksIHZhbHVlTWl4aW4pID0+XG4gICAgICB0aGlzLl9wcm9kdWNlQ3NzUHJvcGVydGllcyhtYXRjaFRleHQsIHByb3BlcnR5TmFtZSwgdmFsdWVQcm9wZXJ0eSwgdmFsdWVNaXhpbikpO1xuICAgIC8vIGNvbnN1bWUgbWl4aW5zXG4gICAgcmV0dXJuIHRoaXMuX2NvbnN1bWVDc3NQcm9wZXJ0aWVzKGNzc1RleHQpO1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX2dldEluaXRpYWxWYWx1ZUZvclByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgaWYgKCF0aGlzLl9tZWFzdXJlRWxlbWVudCkge1xuICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQgPSAvKiogQHR5cGUge0hUTUxNZXRhRWxlbWVudH0gKi8oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbWV0YScpKTtcbiAgICAgIHRoaXMuX21lYXN1cmVFbGVtZW50LnNldEF0dHJpYnV0ZSgnYXBwbHktc2hpbS1tZWFzdXJlJywgJycpO1xuICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQuc3R5bGUuYWxsID0gJ2luaXRpYWwnO1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCh0aGlzLl9tZWFzdXJlRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLl9tZWFzdXJlRWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gIH1cbiAgLyoqXG4gICAqIHJlcGxhY2UgbWl4aW4gY29uc3VtcHRpb24gd2l0aCB2YXJpYWJsZSBjb25zdW1wdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfY29uc3VtZUNzc1Byb3BlcnRpZXModGV4dCkge1xuICAgIC8qKiBAdHlwZSB7QXJyYXl9ICovXG4gICAgbGV0IG0gPSBudWxsO1xuICAgIC8vIGxvb3Agb3ZlciB0ZXh0IHVudGlsIGFsbCBtaXhpbnMgd2l0aCBkZWZpbnRpb25zIGhhdmUgYmVlbiBhcHBsaWVkXG4gICAgd2hpbGUoKG0gPSBNSVhJTl9NQVRDSC5leGVjKHRleHQpKSkge1xuICAgICAgbGV0IG1hdGNoVGV4dCA9IG1bMF07XG4gICAgICBsZXQgbWl4aW5OYW1lID0gbVsxXTtcbiAgICAgIGxldCBpZHggPSBtLmluZGV4O1xuICAgICAgLy8gY29sbGVjdCBwcm9wZXJ0aWVzIGJlZm9yZSBhcHBseSB0byBiZSBcImRlZmF1bHRzXCIgaWYgbWl4aW4gbWlnaHQgb3ZlcnJpZGUgdGhlbVxuICAgICAgLy8gbWF0Y2ggaW5jbHVkZXMgYSBcInByZWZpeFwiLCBzbyBmaW5kIHRoZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9ucyBvZiBAYXBwbHlcbiAgICAgIGxldCBhcHBseVBvcyA9IGlkeCArIG1hdGNoVGV4dC5pbmRleE9mKCdAYXBwbHknKTtcbiAgICAgIGxldCBhZnRlckFwcGx5UG9zID0gaWR4ICsgbWF0Y2hUZXh0Lmxlbmd0aDtcbiAgICAgIC8vIGZpbmQgcHJvcHMgZGVmaW5lZCBiZWZvcmUgdGhpcyBAYXBwbHlcbiAgICAgIGxldCB0ZXh0QmVmb3JlQXBwbHkgPSB0ZXh0LnNsaWNlKDAsIGFwcGx5UG9zKTtcbiAgICAgIGxldCB0ZXh0QWZ0ZXJBcHBseSA9IHRleHQuc2xpY2UoYWZ0ZXJBcHBseVBvcyk7XG4gICAgICBsZXQgZGVmYXVsdHMgPSB0aGlzLl9jc3NUZXh0VG9NYXAodGV4dEJlZm9yZUFwcGx5KTtcbiAgICAgIGxldCByZXBsYWNlbWVudCA9IHRoaXMuX2F0QXBwbHlUb0Nzc1Byb3BlcnRpZXMobWl4aW5OYW1lLCBkZWZhdWx0cyk7XG4gICAgICAvLyB1c2UgcmVnZXggbWF0Y2ggcG9zaXRpb24gdG8gcmVwbGFjZSBtaXhpbiwga2VlcCBsaW5lYXIgcHJvY2Vzc2luZyB0aW1lXG4gICAgICB0ZXh0ID0gYCR7dGV4dEJlZm9yZUFwcGx5fSR7cmVwbGFjZW1lbnR9JHt0ZXh0QWZ0ZXJBcHBseX1gO1xuICAgICAgLy8gbW92ZSByZWdleCBzZWFyY2ggdG8gX2FmdGVyXyByZXBsYWNlbWVudFxuICAgICAgTUlYSU5fTUFUQ0gubGFzdEluZGV4ID0gaWR4ICsgcmVwbGFjZW1lbnQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICAvKipcbiAgICogcHJvZHVjZSB2YXJpYWJsZSBjb25zdW1wdGlvbiBhdCB0aGUgc2l0ZSBvZiBtaXhpbiBjb25zdW1wdGlvblxuICAgKiBgQGFwcGx5YCAtLWZvbzsgLT4gZm9yIGFsbCBwcm9wcyAoJHtwcm9wbmFtZX06IHZhcigtLWZvb18tXyR7cHJvcG5hbWV9LCAke2ZhbGxiYWNrW3Byb3BuYW1lXX19KSlcbiAgICogRXhhbXBsZTpcbiAgICogIGJvcmRlcjogdmFyKC0tZm9vXy1fYm9yZGVyKTsgcGFkZGluZzogdmFyKC0tZm9vXy1fcGFkZGluZywgMnB4KVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWl4aW5OYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBmYWxsYmFja3NcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX2F0QXBwbHlUb0Nzc1Byb3BlcnRpZXMobWl4aW5OYW1lLCBmYWxsYmFja3MpIHtcbiAgICBtaXhpbk5hbWUgPSBtaXhpbk5hbWUucmVwbGFjZShBUFBMWV9OQU1FX0NMRUFOLCAnJyk7XG4gICAgbGV0IHZhcnMgPSBbXTtcbiAgICBsZXQgbWl4aW5FbnRyeSA9IHRoaXMuX21hcC5nZXQobWl4aW5OYW1lKTtcbiAgICAvLyBpZiB3ZSBkZXBlbmQgb24gYSBtaXhpbiBiZWZvcmUgaXQgaXMgY3JlYXRlZFxuICAgIC8vIG1ha2UgYSBzZW50aW5lbCBlbnRyeSBpbiB0aGUgbWFwIHRvIGFkZCB0aGlzIGVsZW1lbnQgYXMgYSBkZXBlbmRlbmN5IGZvciB3aGVuIGl0IGlzIGRlZmluZWQuXG4gICAgaWYgKCFtaXhpbkVudHJ5KSB7XG4gICAgICB0aGlzLl9tYXAuc2V0KG1peGluTmFtZSwge30pO1xuICAgICAgbWl4aW5FbnRyeSA9IHRoaXMuX21hcC5nZXQobWl4aW5OYW1lKTtcbiAgICB9XG4gICAgaWYgKG1peGluRW50cnkpIHtcbiAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICBtaXhpbkVudHJ5LmRlcGVuZGFudHNbdGhpcy5fY3VycmVudEVsZW1lbnRdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGxldCBwLCBwYXJ0cywgZjtcbiAgICAgIGZvciAocCBpbiBtaXhpbkVudHJ5LnByb3BlcnRpZXMpIHtcbiAgICAgICAgZiA9IGZhbGxiYWNrcyAmJiBmYWxsYmFja3NbcF07XG4gICAgICAgIHBhcnRzID0gW3AsICc6IHZhcignLCBtaXhpbk5hbWUsIE1JWElOX1ZBUl9TRVAsIHBdO1xuICAgICAgICBpZiAoZikge1xuICAgICAgICAgIHBhcnRzLnB1c2goJywnLCBmKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKCcpJyk7XG4gICAgICAgIHZhcnMucHVzaChwYXJ0cy5qb2luKCcnKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YXJzLmpvaW4oJzsgJyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfcmVwbGFjZUluaXRpYWxPckluaGVyaXQocHJvcGVydHksIHZhbHVlKSB7XG4gICAgbGV0IG1hdGNoID0gSU5JVElBTF9JTkhFUklULmV4ZWModmFsdWUpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICAgIC8vIGluaXRpYWxcbiAgICAgICAgLy8gcmVwbGFjZSBgaW5pdGlhbGAgd2l0aCB0aGUgY29uY3JldGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhpcyBwcm9wZXJ0eVxuICAgICAgICB2YWx1ZSA9IHRoaXMuX2dldEluaXRpYWxWYWx1ZUZvclByb3BlcnR5KHByb3BlcnR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluaGVyaXRcbiAgICAgICAgLy8gd2l0aCB0aGlzIHB1cnBvc2Z1bGx5IGlsbGVnYWwgdmFsdWUsIHRoZSB2YXJpYWJsZSB3aWxsIGJlIGludmFsaWQgYXRcbiAgICAgICAgLy8gY29tcHV0ZSB0aW1lIChodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXZhcmlhYmxlcy8jaW52YWxpZC1hdC1jb21wdXRlZC12YWx1ZS10aW1lKVxuICAgICAgICAvLyBhbmQgZm9yIGluaGVyaXRpbmcgdmFsdWVzLCB3aWxsIGJlaGF2ZSBzaW1pbGFybHlcbiAgICAgICAgLy8gd2UgY2Fubm90IHN1cHBvcnQgdGhlIHNhbWUgYmVoYXZpb3IgZm9yIG5vbiBpbmhlcml0aW5nIHZhbHVlcyBsaWtlICdib3JkZXInXG4gICAgICAgIHZhbHVlID0gJ2FwcGx5LXNoaW0taW5oZXJpdCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBcInBhcnNlXCIgYSBtaXhpbiBkZWZpbml0aW9uIGludG8gYSBtYXAgb2YgcHJvcGVydGllcyBhbmQgdmFsdWVzXG4gICAqIGNzc1RleHRUb01hcCgnYm9yZGVyOiAycHggc29saWQgYmxhY2snKSAtPiAoJ2JvcmRlcicsICcycHggc29saWQgYmxhY2snKVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgKiBAcmV0dXJuIHshT2JqZWN0PHN0cmluZywgc3RyaW5nPn1cbiAgICovXG4gIF9jc3NUZXh0VG9NYXAodGV4dCkge1xuICAgIGxldCBwcm9wcyA9IHRleHQuc3BsaXQoJzsnKTtcbiAgICBsZXQgcHJvcGVydHksIHZhbHVlO1xuICAgIGxldCBvdXQgPSB7fTtcbiAgICBmb3IgKGxldCBpID0gMCwgcCwgc3A7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgcCA9IHByb3BzW2ldO1xuICAgICAgaWYgKHApIHtcbiAgICAgICAgc3AgPSBwLnNwbGl0KCc6Jyk7XG4gICAgICAgIC8vIGlnbm9yZSBsaW5lcyB0aGF0IGFyZW4ndCBkZWZpbml0aW9ucyBsaWtlIEBtZWRpYVxuICAgICAgICBpZiAoc3AubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHByb3BlcnR5ID0gc3BbMF0udHJpbSgpO1xuICAgICAgICAgIC8vIHNvbWUgcHJvcGVydGllcyBtYXkgaGF2ZSAnOicgaW4gdGhlIHZhbHVlLCBsaWtlIGRhdGEgdXJsc1xuICAgICAgICAgIHZhbHVlID0gdGhpcy5fcmVwbGFjZUluaXRpYWxPckluaGVyaXQocHJvcGVydHksIHNwLnNsaWNlKDEpLmpvaW4oJzonKSk7XG4gICAgICAgICAgb3V0W3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtNaXhpbk1hcEVudHJ5fSBtaXhpbkVudHJ5XG4gICAqL1xuICBfaW52YWxpZGF0ZU1peGluRW50cnkobWl4aW5FbnRyeSkge1xuICAgIGlmICghaW52YWxpZENhbGxiYWNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGVsZW1lbnROYW1lIGluIG1peGluRW50cnkuZGVwZW5kYW50cykge1xuICAgICAgaWYgKGVsZW1lbnROYW1lICE9PSB0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICBpbnZhbGlkQ2FsbGJhY2soZWxlbWVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hUZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZVByb3BlcnR5XG4gICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWVNaXhpblxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfcHJvZHVjZUNzc1Byb3BlcnRpZXMobWF0Y2hUZXh0LCBwcm9wZXJ0eU5hbWUsIHZhbHVlUHJvcGVydHksIHZhbHVlTWl4aW4pIHtcbiAgICAvLyBoYW5kbGUgY2FzZSB3aGVyZSBwcm9wZXJ0eSB2YWx1ZSBpcyBhIG1peGluXG4gICAgaWYgKHZhbHVlUHJvcGVydHkpIHtcbiAgICAgIC8vIGZvcm06IC0tbWl4aW4yOiB2YXIoLS1taXhpbjEpLCB3aGVyZSAtLW1peGluMSBpcyBpbiB0aGUgbWFwXG4gICAgICBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayh2YWx1ZVByb3BlcnR5LCAocHJlZml4LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodmFsdWUgJiYgdGhpcy5fbWFwLmdldCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZU1peGluID0gYEBhcHBseSAke3ZhbHVlfTtgXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXZhbHVlTWl4aW4pIHtcbiAgICAgIHJldHVybiBtYXRjaFRleHQ7XG4gICAgfVxuICAgIGxldCBtaXhpbkFzUHJvcGVydGllcyA9IHRoaXMuX2NvbnN1bWVDc3NQcm9wZXJ0aWVzKHZhbHVlTWl4aW4pO1xuICAgIGxldCBwcmVmaXggPSBtYXRjaFRleHQuc2xpY2UoMCwgbWF0Y2hUZXh0LmluZGV4T2YoJy0tJykpO1xuICAgIGxldCBtaXhpblZhbHVlcyA9IHRoaXMuX2Nzc1RleHRUb01hcChtaXhpbkFzUHJvcGVydGllcyk7XG4gICAgbGV0IGNvbWJpbmVkUHJvcHMgPSBtaXhpblZhbHVlcztcbiAgICBsZXQgbWl4aW5FbnRyeSA9IHRoaXMuX21hcC5nZXQocHJvcGVydHlOYW1lKTtcbiAgICBsZXQgb2xkUHJvcHMgPSBtaXhpbkVudHJ5ICYmIG1peGluRW50cnkucHJvcGVydGllcztcbiAgICBpZiAob2xkUHJvcHMpIHtcbiAgICAgIC8vIE5PVEU6IHNpbmNlIHdlIHVzZSBtaXhpbiwgdGhlIG1hcCBvZiBwcm9wZXJ0aWVzIGlzIHVwZGF0ZWQgaGVyZVxuICAgICAgLy8gYW5kIHRoaXMgaXMgd2hhdCB3ZSB3YW50LlxuICAgICAgY29tYmluZWRQcm9wcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShvbGRQcm9wcyksIG1peGluVmFsdWVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbWFwLnNldChwcm9wZXJ0eU5hbWUsIGNvbWJpbmVkUHJvcHMpO1xuICAgIH1cbiAgICBsZXQgb3V0ID0gW107XG4gICAgbGV0IHAsIHY7XG4gICAgLy8gc2V0IHZhcmlhYmxlcyBkZWZpbmVkIGJ5IGN1cnJlbnQgbWl4aW5cbiAgICBsZXQgbmVlZFRvSW52YWxpZGF0ZSA9IGZhbHNlO1xuICAgIGZvciAocCBpbiBjb21iaW5lZFByb3BzKSB7XG4gICAgICB2ID0gbWl4aW5WYWx1ZXNbcF07XG4gICAgICAvLyBpZiBwcm9wZXJ0eSBub3QgZGVmaW5lZCBieSBjdXJyZW50IG1peGluLCBzZXQgaW5pdGlhbFxuICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2ID0gJ2luaXRpYWwnO1xuICAgICAgfVxuICAgICAgaWYgKG9sZFByb3BzICYmICEocCBpbiBvbGRQcm9wcykpIHtcbiAgICAgICAgbmVlZFRvSW52YWxpZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBvdXQucHVzaChgJHtwcm9wZXJ0eU5hbWV9JHtNSVhJTl9WQVJfU0VQfSR7cH06ICR7dn1gKTtcbiAgICB9XG4gICAgaWYgKG5lZWRUb0ludmFsaWRhdGUpIHtcbiAgICAgIHRoaXMuX2ludmFsaWRhdGVNaXhpbkVudHJ5KG1peGluRW50cnkpO1xuICAgIH1cbiAgICBpZiAobWl4aW5FbnRyeSkge1xuICAgICAgbWl4aW5FbnRyeS5wcm9wZXJ0aWVzID0gY29tYmluZWRQcm9wcztcbiAgICB9XG4gICAgLy8gYmVjYXVzZSB0aGUgbWl4aW5NYXAgaXMgZ2xvYmFsLCB0aGUgbWl4aW4gbWlnaHQgY29uZmxpY3Qgd2l0aFxuICAgIC8vIGEgZGlmZmVyZW50IHNjb3BlJ3Mgc2ltcGxlIHZhcmlhYmxlIGRlZmluaXRpb246XG4gICAgLy8gRXhhbXBsZTpcbiAgICAvLyBzb21lIHN0eWxlIHNvbWV3aGVyZTpcbiAgICAvLyAtLW1peGluMTp7IC4uLiB9XG4gICAgLy8gLS1taXhpbjI6IHZhcigtLW1peGluMSk7XG4gICAgLy8gc29tZSBvdGhlciBlbGVtZW50OlxuICAgIC8vIC0tbWl4aW4xOiAxMHB4IHNvbGlkIHJlZDtcbiAgICAvLyAtLWZvbzogdmFyKC0tbWl4aW4xKTtcbiAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIGxlYXZlIHRoZSBvcmlnaW5hbCB2YXJpYWJsZSBkZWZpbml0aW9uIGluIHBsYWNlLlxuICAgIGlmICh2YWx1ZVByb3BlcnR5KSB7XG4gICAgICBwcmVmaXggPSBgJHttYXRjaFRleHR9OyR7cHJlZml4fWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcmVmaXh9JHtvdXQuam9pbignOyAnKX07YDtcbiAgfVxufVxuXG4vKiBleHBvcnRzICovXG5BcHBseVNoaW0ucHJvdG90eXBlWydkZXRlY3RNaXhpbiddID0gQXBwbHlTaGltLnByb3RvdHlwZS5kZXRlY3RNaXhpbjtcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ3RyYW5zZm9ybVN0eWxlJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLnRyYW5zZm9ybVN0eWxlO1xuQXBwbHlTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtQ3VzdG9tU3R5bGUnXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUudHJhbnNmb3JtQ3VzdG9tU3R5bGU7XG5BcHBseVNoaW0ucHJvdG90eXBlWyd0cmFuc2Zvcm1SdWxlcyddID0gQXBwbHlTaGltLnByb3RvdHlwZS50cmFuc2Zvcm1SdWxlcztcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ3RyYW5zZm9ybVJ1bGUnXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUudHJhbnNmb3JtUnVsZTtcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ3RyYW5zZm9ybVRlbXBsYXRlJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLnRyYW5zZm9ybVRlbXBsYXRlO1xuQXBwbHlTaGltLnByb3RvdHlwZVsnX3NlcGFyYXRvciddID0gTUlYSU5fVkFSX1NFUDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShBcHBseVNoaW0ucHJvdG90eXBlLCAnaW52YWxpZENhbGxiYWNrJywge1xuICAvKiogQHJldHVybiB7P2Z1bmN0aW9uKHN0cmluZyl9ICovXG4gIGdldCgpIHtcbiAgICByZXR1cm4gaW52YWxpZENhbGxiYWNrO1xuICB9LFxuICAvKiogQHBhcmFtIHs/ZnVuY3Rpb24oc3RyaW5nKX0gY2IgKi9cbiAgc2V0KGNiKSB7XG4gICAgaW52YWxpZENhbGxiYWNrID0gY2I7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBBcHBseVNoaW07XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2FwcGx5LXNoaW0uanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHshU2V0PHN0cmluZz59ICovXG5jb25zdCBzdHlsZVRleHRTZXQgPSBuZXcgU2V0KCk7XG5cbmV4cG9ydCBjb25zdCBzY29waW5nQXR0cmlidXRlID0gJ3NoYWR5LXVuc2NvcGVkJztcblxuLyoqXG4gKiBBZGQgYSBzcGVjaWZpY2FsbHktbWFya2VkIHN0eWxlIHRvIHRoZSBkb2N1bWVudCBkaXJlY3RseSwgYW5kIG9ubHkgb25lIGNvcHkgb2YgdGhhdCBzdHlsZS5cbiAqXG4gKiBAcGFyYW0geyFIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1Vuc2NvcGVkU3R5bGUoc3R5bGUpIHtcbiAgY29uc3QgdGV4dCA9IHN0eWxlLnRleHRDb250ZW50O1xuICBpZiAoIXN0eWxlVGV4dFNldC5oYXModGV4dCkpIHtcbiAgICBzdHlsZVRleHRTZXQuYWRkKHRleHQpO1xuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobmV3U3R5bGUpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHlsZSBpcyBzdXBwb3NlZCB0byBiZSB1bnNjb3BlZFxuICogQHBhcmFtIHshSFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHN0eWxlIGhhcyB0aGUgdW5zY29waW5nIGF0dHJpYnV0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVbnNjb3BlZFN0eWxlKHN0eWxlKSB7XG4gIHJldHVybiBzdHlsZS5oYXNBdHRyaWJ1dGUoc2NvcGluZ0F0dHJpYnV0ZSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3Vuc2NvcGVkLXN0eWxlLWhhbmRsZXIuanNcbi8vIG1vZHVsZSBpZCA9IDU1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB0ZW1wbGF0ZU1hcCBmcm9tICcuL3RlbXBsYXRlLW1hcC5qcyc7XG5pbXBvcnQge1N0eWxlTm9kZX0gZnJvbSAnLi9jc3MtcGFyc2UuanMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qXG4gKiBVdGlsaXRpZXMgZm9yIGhhbmRsaW5nIGludmFsaWRhdGluZyBhcHBseS1zaGltIG1peGlucyBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAqXG4gKiBUaGUgaW52YWxpZGF0aW9uIHN0cmF0ZWd5IGludm9sdmVzIGtlZXBpbmcgdHJhY2sgb2YgdGhlIFwiY3VycmVudFwiIHZlcnNpb24gb2YgYSB0ZW1wbGF0ZSdzIG1peGlucywgYW5kIHVwZGF0aW5nIHRoYXQgY291bnQgd2hlbiBhIG1peGluIGlzIGludmFsaWRhdGVkLlxuICogVGhlIHRlbXBsYXRlXG4gKi9cblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgQ1VSUkVOVF9WRVJTSU9OID0gJ19hcHBseVNoaW1DdXJyZW50VmVyc2lvbic7XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IE5FWFRfVkVSU0lPTiA9ICdfYXBwbHlTaGltTmV4dFZlcnNpb24nO1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBWQUxJREFUSU5HX1ZFUlNJT04gPSAnX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uJztcblxuLyoqXG4gKiBAY29uc3Qge1Byb21pc2U8dm9pZD59XG4gKi9cbmNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGUoZWxlbWVudE5hbWUpe1xuICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gIGlmICh0ZW1wbGF0ZSkge1xuICAgIGludmFsaWRhdGVUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gbWFyayBhIHRlbXBsYXRlIGludmFsaWRcbiAqIGFuZCBzaWduYWwgdGhhdCB0aGUgc3R5bGUgaW5zaWRlIG11c3QgYmUgcmVnZW5lcmF0ZWQuXG4gKlxuICogVXNlIGBzdGFydFZhbGlkYXRpbmdUZW1wbGF0ZWAgdG8gYmVnaW4gYW4gYXN5bmNocm9ub3VzIHZhbGlkYXRpb24gY3ljbGUuXG4gKiBEdXJpbmcgdGhhdCBjeWNsZSwgY2FsbCBgdGVtcGxhdGVJc1ZhbGlkYXRpbmdgIHRvIHNlZSBpZiB0aGUgdGVtcGxhdGUgbXVzdFxuICogYmUgcmV2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGVUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAvLyBkZWZhdWx0IHRoZSBjdXJyZW50IHZlcnNpb24gdG8gMFxuICB0ZW1wbGF0ZVtDVVJSRU5UX1ZFUlNJT05dID0gdGVtcGxhdGVbQ1VSUkVOVF9WRVJTSU9OXSB8fCAwO1xuICAvLyBlbnN1cmUgdGhlIFwidmFsaWRhdGluZyBmb3JcIiBmbGFnIGV4aXN0c1xuICB0ZW1wbGF0ZVtWQUxJREFUSU5HX1ZFUlNJT05dID0gdGVtcGxhdGVbVkFMSURBVElOR19WRVJTSU9OXSB8fCAwO1xuICAvLyBpbmNyZW1lbnQgdGhlIG5leHQgdmVyc2lvblxuICB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dID0gKHRlbXBsYXRlW05FWFRfVkVSU0lPTl0gfHwgMCkgKyAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWQoZWxlbWVudE5hbWUpIHtcbiAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICBpZiAodGVtcGxhdGUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSB7XG4gIHJldHVybiB0ZW1wbGF0ZVtDVVJSRU5UX1ZFUlNJT05dID09PSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRhdGluZyhlbGVtZW50TmFtZSkge1xuICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gIGlmICh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZUlzVmFsaWRhdGluZyh0ZW1wbGF0ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGVtcGxhdGUgaXMgY3VycmVudGx5IGludmFsaWQgYW5kIGBzdGFydFZhbGlkYXRpbmdgIGhhcyBiZWVuIGNhbGxlZCBzaW5jZSB0aGUgbGFzdCBpbnZhbGlkYXRpb24uXG4gKiBJZiBmYWxzZSwgdGhlIHRlbXBsYXRlIG11c3QgYmUgdmFsaWRhdGVkLlxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlSXNWYWxpZGF0aW5nKHRlbXBsYXRlKSB7XG4gIHJldHVybiAhdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSAmJiB0ZW1wbGF0ZVtWQUxJREFUSU5HX1ZFUlNJT05dID09PSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xufVxuXG4vKipcbiAqIHRoZSB0ZW1wbGF0ZSBpcyBtYXJrZWQgYXMgYHZhbGlkYXRpbmdgIGZvciBvbmUgbWljcm90YXNrIHNvIHRoYXQgYWxsIGluc3RhbmNlc1xuICogZm91bmQgaW4gdGhlIHRyZWUgY3Jhd2wgb2YgYGFwcGx5U3R5bGVgIHdpbGwgdXBkYXRlIHRoZW1zZWx2ZXMsXG4gKiBidXQgdGhlIHRlbXBsYXRlIHdpbGwgb25seSBiZSB1cGRhdGVkIG9uY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRWYWxpZGF0aW5nKGVsZW1lbnROYW1lKSB7XG4gIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgc3RhcnRWYWxpZGF0aW5nVGVtcGxhdGUodGVtcGxhdGUpO1xufVxuXG4vKipcbiAqIEJlZ2luIGFuIGFzeW5jaHJvbm91cyBpbnZhbGlkYXRpb24gY3ljbGUuXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgZXZlcnkgdmFsaWRhdGlvbiBvZiBhIHRlbXBsYXRlXG4gKlxuICogQWZ0ZXIgb25lIG1pY3JvdGFzaywgdGhlIHRlbXBsYXRlIHdpbGwgYmUgbWFya2VkIGFzIHZhbGlkIHVudGlsIHRoZSBuZXh0IGNhbGwgdG8gYGludmFsaWRhdGVUZW1wbGF0ZWBcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlKHRlbXBsYXRlKSB7XG4gIC8vIHJlbWVtYmVyIHRoYXQgdGhlIGN1cnJlbnQgXCJuZXh0IHZlcnNpb25cIiBpcyB0aGUgcmVhc29uIGZvciB0aGlzIHZhbGlkYXRpb24gY3ljbGVcbiAgdGVtcGxhdGVbVkFMSURBVElOR19WRVJTSU9OXSA9IHRlbXBsYXRlW05FWFRfVkVSU0lPTl07XG4gIC8vIGhvd2V2ZXIsIHRoZXJlIG9ubHkgbmVlZHMgdG8gYmUgb25lIGFzeW5jIHRhc2sgdG8gY2xlYXIgdGhlIGNvdW50ZXJzXG4gIGlmICghdGVtcGxhdGUuX3ZhbGlkYXRpbmcpIHtcbiAgICB0ZW1wbGF0ZS5fdmFsaWRhdGluZyA9IHRydWU7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gc3luYyB0aGUgY3VycmVudCB2ZXJzaW9uIHRvIGxldCBmdXR1cmUgaW52YWxpZGF0aW9ucyBjYXVzZSBhIHJlZnJlc2ggY3ljbGVcbiAgICAgIHRlbXBsYXRlW0NVUlJFTlRfVkVSU0lPTl0gPSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xuICAgICAgdGVtcGxhdGUuX3ZhbGlkYXRpbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50c0FyZUludmFsaWQoKSB7XG4gIGZvciAobGV0IGVsZW1lbnROYW1lIGluIHRlbXBsYXRlTWFwKSB7XG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICAgIGlmICghdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvYXBwbHktc2hpbS11dGlscy5qc1xuLy8gbW9kdWxlIGlkID0gNTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwJDAgZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuXG5sZXQgY2FzZU1hcCA9IGNhc2VNYXAkMDtcblxubGV0IG1pY3JvdGFzayA9IG1pY3JvVGFzaztcblxuLy8gU2F2ZSBtYXAgb2YgbmF0aXZlIHByb3BlcnRpZXM7IHRoaXMgZm9ybXMgYSBibGFja2xpc3Qgb3IgcHJvcGVydGllc1xuLy8gdGhhdCB3b24ndCBoYXZlIHRoZWlyIHZhbHVlcyBcInNhdmVkXCIgYnkgYHNhdmVBY2Nlc3NvclZhbHVlYCwgc2luY2Vcbi8vIHJlYWRpbmcgZnJvbSBhbiBIVE1MRWxlbWVudCBhY2Nlc3NvciBmcm9tIHRoZSBjb250ZXh0IG9mIGEgcHJvdG90eXBlIHRocm93c1xuY29uc3QgbmF0aXZlUHJvcGVydGllcyA9IHt9O1xubGV0IHByb3RvID0gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xud2hpbGUgKHByb3RvKSB7XG4gIGxldCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcbiAgZm9yIChsZXQgaT0wOyBpPHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgbmF0aXZlUHJvcGVydGllc1twcm9wc1tpXV0gPSB0cnVlO1xuICB9XG4gIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHNhdmUgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIG92ZXJyaWRkZW4gd2l0aFxuICogYW4gYWNjZXNzb3IuIElmIHRoZSBgbW9kZWxgIGlzIGEgcHJvdG90eXBlLCB0aGUgdmFsdWVzIHdpbGwgYmUgc2F2ZWRcbiAqIGluIGBfX2RhdGFQcm90b2AsIGFuZCBpdCdzIHVwIHRvIHRoZSB1c2VyIChvciBkb3duc3RyZWFtIG1peGluKSB0b1xuICogZGVjaWRlIGhvdy93aGVuIHRvIHNldCB0aGVzZSB2YWx1ZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3NvcnMuXG4gKiBJZiBgbW9kZWxgIGlzIGFscmVhZHkgYW4gaW5zdGFuY2UgKGl0IGhhcyBhIGBfX2RhdGFgIHByb3BlcnR5KSwgdGhlblxuICogdGhlIHZhbHVlIHdpbGwgYmUgc2V0IGFzIGEgcGVuZGluZyBwcm9wZXJ0eSwgbWVhbmluZyB0aGUgdXNlciBzaG91bGRcbiAqIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgIHRvIHRha2UgZWZmZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmVBY2Nlc3NvclZhbHVlKG1vZGVsLCBwcm9wZXJ0eSkge1xuICAvLyBEb24ndCByZWFkL3N0b3JlIHZhbHVlIGZvciBhbnkgbmF0aXZlIHByb3BlcnRpZXMgc2luY2UgdGhleSBjb3VsZCB0aHJvd1xuICBpZiAoIW5hdGl2ZVByb3BlcnRpZXNbcHJvcGVydHldKSB7XG4gICAgbGV0IHZhbHVlID0gbW9kZWxbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobW9kZWwuX19kYXRhKSB7XG4gICAgICAgIC8vIEFkZGluZyBhY2Nlc3NvciB0byBpbnN0YW5jZTsgdXBkYXRlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBJdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGNhbGwgX2ZsdXNoUHJvcGVydGllc1xuICAgICAgICBtb2RlbC5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gcHJvdG87IHNhdmUgcHJvdG8ncyB2YWx1ZSBmb3IgaW5zdGFuY2UtdGltZSB1c2VcbiAgICAgICAgaWYgKCFtb2RlbC5fX2RhdGFQcm90bykge1xuICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZGF0YVByb3RvJywgbW9kZWwpKSkge1xuICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0gT2JqZWN0LmNyZWF0ZShtb2RlbC5fX2RhdGFQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuX19kYXRhUHJvdG9bcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBQcm9wZXJ0eUFjY2Vzc29ycyA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5QWNjZXNzb3JzfVxuICAgKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUFjY2Vzc29ycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgYWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHN0YW5kYXJkXG4gICAgICogc3RhdGljIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogQXR0cmlidXRlIG5hbWVzIGFyZSBtYXBwZWQgdG8gcHJvcGVydHkgbmFtZXMgdXNpbmcgdGhlIGBkYXNoLWNhc2VgIHRvXG4gICAgICogYGNhbWVsQ2FzZWAgY29udmVudGlvblxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnRpZXNGb3JBdHRyaWJ1dGVzKCkge1xuICAgICAgbGV0IGEkID0gdGhpcy5vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBhJC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUHJvcGVydHlBY2Nlc3NvcihjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShhJFtpXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19zZXJpYWxpemluZztcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdGhpcy5fX2RhdGFDb3VudGVyO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFFbmFibGVkO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFSZWFkeTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhSW52YWxpZDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhT2xkO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVByb3RvO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHM7XG4gICAgICB0aGlzLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgbmF0aXZlIEN1c3RvbSBFbGVtZW50cyBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCB0b1xuICAgICAqIHNldCBhbiBhdHRyaWJ1dGUgdmFsdWUgdG8gYSBwcm9wZXJ0eSB2aWEgYF9hdHRyaWJ1dGVUb1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlIHRoYXQgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIE5ldyBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgKlxuICAgICAqIFByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlIHBvaW50IGZvciBwZXJmb3JtaW5nIGFueSBzZXR1cCB3b3JrIHByaW9yXG4gICAgICogdG8gaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eSBhY2Nlc3NvciBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFFbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YUludmFsaWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhID0ge307XG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFPbGQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyh0aGlzLl9fZGF0YVByb3RvKTtcbiAgICAgICAgdGhpcy5fX2RhdGFQcm90byA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBDYXB0dXJlIGluc3RhbmNlIHByb3BlcnRpZXM7IHRoZXNlIHdpbGwgYmUgc2V0IGludG8gYWNjZXNzb3JzXG4gICAgICAvLyBkdXJpbmcgZmlyc3QgZmx1c2guIERvbid0IHNldCB0aGVtIGhlcmUsIHNpbmNlIHdlIHdhbnRcbiAgICAgIC8vIHRoZXNlIHRvIG92ZXJ3cml0ZSBkZWZhdWx0cy9jb25zdHJ1Y3RvciBhc3NpZ25tZW50c1xuICAgICAgZm9yIChsZXQgcCBpbiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wc1twXSA9IHRoaXNbcF07XG4gICAgICAgICAgZGVsZXRlIHRoaXNbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXQgaW5zdGFuY2UgdGltZSB3aXRoIGJhZyBvZiBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqIGJ5IGFjY2Vzc29ycyBvbiB0aGUgcHJvdG90eXBlIHdoZW4gYWNjZXNzb3JzIHdlcmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICogc2V0dGVyIGF0IGluc3RhbmNlIHRpbWUuICBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBhbiBvdmVycmlkZVxuICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnR5IHZhbHVlcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwLCBwcm9wc1twXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF0IHJlYWR5IHRpbWUgd2l0aCBiYWcgb2YgaW5zdGFuY2UgcHJvcGVydGllcyB0aGF0IG92ZXJ3cm90ZVxuICAgICAqIGFjY2Vzc29ycyB3aGVuIHRoZSBlbGVtZW50IHVwZ3JhZGVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgKiBzZXR0ZXIgYXQgcmVhZHkgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICogcG9pbnQgZm9yIGN1c3RvbWl6aW5nIG9yIHByb3ZpZGluZyBtb3JlIGVmZmljaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqICAgd2hlbiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoZSBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gYXR0cmlidXRlLiBJZiBpdCBkb2VzIG5vdCxcbiAgICAgKiBhc3NpZ25zIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIE5hbWUgb2YgYXR0cmlidXRlIHRvIGVuc3VyZSBpcyBzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgX2Vuc3VyZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsIGF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGFuIGF0dHJpYnV0ZSB0byBpdHMgYXNzb2NpYXRlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG9cbiAgICAgKiBhIHR5cGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHsqPX0gdHlwZSB0eXBlIHRvIGRlc2VyaWFsaXplIHRvLlxuICAgICAqL1xuICAgIF9hdHRyaWJ1dGVUb1Byb3BlcnR5KGF0dHJpYnV0ZSwgdmFsdWUsIHR5cGUpIHtcbiAgICAgIC8vIERvbid0IGRlc2VyaWFsaXplIGJhY2sgdG8gcHJvcGVydHkgaWYgY3VycmVudGx5IHJlZmxlY3RpbmdcbiAgICAgIGlmICghdGhpcy5fX3NlcmlhbGl6aW5nKSB7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKGF0dHJpYnV0ZSk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gdGhpcy5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICovXG4gICAgX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IHRydWU7XG4gICAgICB2YWx1ZSA9IChhcmd1bWVudHMubGVuZ3RoIDwgMykgPyB0aGlzW3Byb3BlcnR5XSA6IHZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsXG4gICAgICAgIGF0dHJpYnV0ZSB8fCBjYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSkpO1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHR5cGVkIHZhbHVlIHRvIGFuIEhUTUwgYXR0cmlidXRlIG9uIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgdHlwZWRcbiAgICAgKiB2YWx1ZSB0byBhIHN0cmluZy4gIElmIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZCAodGhpcyBpcyB0aGUgZGVmYXVsdCBmb3IgYm9vbGVhblxuICAgICAqIHR5cGUgYGZhbHNlYCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzZXQgYXR0cmlidXRlIHRvLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gc2VyaWFsaXplIHRvLlxuICAgICAqL1xuICAgIF92YWx1ZVRvTm9kZUF0dHJpYnV0ZShub2RlLCB2YWx1ZSwgYXR0cmlidXRlKSB7XG4gICAgICBsZXQgc3RyID0gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHN0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFBvbHltZXIgd2hlbiBzZXR0aW5nIEpTIHByb3BlcnR5IHZhbHVlcyB0b1xuICAgICAqIEhUTUwgYXR0cmlidXRlcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgc2VyaWFsaXphdGlvbiBmb3IgY3VzdG9tIHR5cGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBTdHJpbmcgc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBfc2VyaWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPyAnJyA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUudG9TdHJpbmcoKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgUG9seW1lciB3aGVuIHJlYWRpbmcgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzIHRvXG4gICAgICogSlMgcHJvcGVydGllcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgZGVzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gYHR5cGVgcy4gIE5vdGUsXG4gICAgICogdGhlIGB0eXBlYCBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGB0eXBlYCBmaWVsZCBwcm92aWRlZCBpbiB0aGVcbiAgICAgKiBgcHJvcGVydGllc2AgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGEgZ2l2ZW4gcHJvcGVydHksIGFuZCBpc1xuICAgICAqIGJ5IGNvbnZlbnRpb24gdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoZSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgaXMgdXNlZCBhcyBhIHNlbnRpbmVsIHZhbHVlIHRvXG4gICAgICogaW5kaWNhdGUgdGhlIGF0dHJpYnV0ZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlIHRvIGRlc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgVHlwZSB0byBkZXNlcmlhbGl6ZSB0aGUgc3RyaW5nIHRvLlxuICAgICAqIEByZXR1cm4geyp9IFR5cGVkIHZhbHVlIGRlc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgKi9cbiAgICAgIGxldCBvdXRWYWx1ZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICBvdXRWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgIG91dFZhbHVlID0gKHZhbHVlICE9PSBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3V0VmFsdWUgPSBKU09OLnBhcnNlKC8qKiBAdHlwZSBzdHJpbmcgKi8odmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgIC8vIGFsbG93IG5vbi1KU09OIGxpdGVyYWxzIGxpa2UgU3RyaW5ncyBhbmQgTnVtYmVyc1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IEpTT04ucGFyc2UoLyoqIEB0eXBlIHN0cmluZyAqLyh2YWx1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2goeCkge1xuICAgICAgICAgICAgb3V0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBQb2x5bWVyOjpBdHRyaWJ1dGVzOiBjb3VsZG4ndCBkZWNvZGUgQXJyYXkgYXMgSlNPTjogJHt2YWx1ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgIG91dFZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG91dFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRWYWx1ZTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldHRlci9nZXR0ZXIgcGFpciBmb3IgdGhlIG5hbWVkIHByb3BlcnR5IHdpdGggaXRzIG93blxuICAgICAqIGxvY2FsIHN0b3JhZ2UuICBUaGUgZ2V0dGVyIHJldHVybnMgdGhlIHZhbHVlIGluIHRoZSBsb2NhbCBzdG9yYWdlLFxuICAgICAqIGFuZCB0aGUgc2V0dGVyIGNhbGxzIGBfc2V0UHJvcGVydHlgLCB3aGljaCB1cGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlXG4gICAgICogZm9yIHRoZSBwcm9wZXJ0eSBhbmQgZW5xdWV1ZXMgYSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgb24gYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuICBDYWxsaW5nXG4gICAgICogdGhpcyBtZXRob2QgbWF5IG92ZXJ3cml0ZSBhIHByb3BlcnR5IHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb25cbiAgICAgKiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGJ5IGNyZWF0aW5nIHRoZSBhY2Nlc3Nvci4gIFdoZW4gY2FsbGluZyBvblxuICAgICAqIGEgcHJvdG90eXBlLCBhbnkgb3ZlcndyaXR0ZW4gdmFsdWVzIGFyZSBzYXZlZCBpbiBgX19kYXRhUHJvdG9gLFxuICAgICAqIGFuZCBpdCBpcyB1cCB0byB0aGUgc3ViY2xhc3NlciB0byBkZWNpZGUgaG93L3doZW4gdG8gc2V0IHRob3NlXG4gICAgICogcHJvcGVydGllcyBiYWNrIGludG8gdGhlIGFjY2Vzc29yLiAgV2hlbiBjYWxsaW5nIG9uIGFuIGluc3RhbmNlLFxuICAgICAqIHRoZSBvdmVyd3JpdHRlbiB2YWx1ZSBpcyBzZXQgdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YCwgYW5kIHRoZVxuICAgICAqIHVzZXIgc2hvdWxkIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgXG4gICAgICogZm9yIHRoZSB2YWx1ZXMgdG8gdGFrZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWFkT25seSBXaGVuIHRydWUsIG5vIHNldHRlciBpcyBjcmVhdGVkOyB0aGVcbiAgICAgKiAgIHByb3RlY3RlZCBgX3NldFByb3BlcnR5YCBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gc2V0IHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgcmVhZE9ubHkpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19kYXRhSGFzQWNjZXNzb3InKSkge1xuICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldKSB7XG4gICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgc2F2ZUFjY2Vzc29yVmFsdWUodGhpcywgcHJvcGVydHkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAgICAgICAgIC8qKiBAdGhpcyB7UHJvcGVydHlBY2Nlc3NvcnN9ICovXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvKiogQHRoaXMge1Byb3BlcnR5QWNjZXNzb3JzfSAqL1xuICAgICAgICAgIHNldDogcmVhZE9ubHkgPyBmdW5jdGlvbigpIHt9IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGlicmFyeSBjcmVhdGVkIGFuIGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gYWNjZXNzb3Igd2FzIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBfaGFzQWNjZXNzb3IocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yICYmIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHkgKHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWApXG4gICAgICogYW5kIGVucXVldWVzIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBhIHByb3BlcnR5LCByZWNvcmRzIHRoZSBwcmV2aW91cyB2YWx1ZSxcbiAgICAgKiBhbmQgYWRkcyBpdCB0byB0aGUgc2V0IG9mIFwicGVuZGluZyBjaGFuZ2VzXCIgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay4gIFRoaXMgbWV0aG9kIGRvZXMgbm90IGVucXVldWUgdGhlXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgY2hhbmdlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgbGV0IG9sZCA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YU9sZCAmJiAhKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IG9sZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaGFzIGEgcGVuZGluZyBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaXNQcm9wZXJ0eVBlbmRpbmcocHJvcCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fX2RhdGFQZW5kaW5nICYmIChwcm9wIGluIHRoaXMuX19kYXRhUGVuZGluZykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBwcm9wZXJ0aWVzIGFzIGludmFsaWQsIGFuZCBlbnF1ZXVlcyBhbiBhc3luY1xuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbnZhbGlkYXRlUHJvcGVydGllcygpIHtcbiAgICAgIGlmICghdGhpcy5fX2RhdGFJbnZhbGlkICYmIHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgbWljcm90YXNrLnJ1bigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhSW52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdG8gZW5hYmxlIHByb3BlcnR5IGFjY2Vzc29yIHByb2Nlc3NpbmcuIEJlZm9yZSB0aGlzIG1ldGhvZCBpc1xuICAgICAqIGNhbGxlZCBhY2Nlc3NvciB2YWx1ZXMgd2lsbCBiZSBzZXQgYnV0IHNpZGUgZWZmZWN0cyBhcmVcbiAgICAgKiBxdWV1ZWQuIFdoZW4gY2FsbGVkLCBhbnkgcGVuZGluZyBzaWRlIGVmZmVjdHMgb2NjdXIgaW1tZWRpYXRlbHkuXG4gICAgICogRm9yIGVsZW1lbnRzLCBnZW5lcmFsbHkgYGNvbm5lY3RlZENhbGxiYWNrYCBpcyBhIG5vcm1hbCBzcG90IHRvIGRvIHNvLlxuICAgICAqIEl0IGlzIHNhZmUgdG8gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyBhcyBpdCBvbmx5IHR1cm5zIG9uXG4gICAgICogcHJvcGVydHkgYWNjZXNzb3JzIG9uY2UuXG4gICAgICovXG4gICAgX2VuYWJsZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX19kYXRhRW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9fZGF0YUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzKSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpO1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkeSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjayB3aXRoIHRoZSBjdXJyZW50IHNldCBvZlxuICAgICAqIHBlbmRpbmcgY2hhbmdlcyAoYW5kIG9sZCB2YWx1ZXMgcmVjb3JkZWQgd2hlbiBwZW5kaW5nIGNoYW5nZXMgd2VyZVxuICAgICAqIHNldCksIGFuZCByZXNldHMgdGhlIHBlbmRpbmcgc2V0IG9mIGNoYW5nZXMuIEdlbmVyYWxseSwgdGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgbm90IGJlIGNhbGxlZCBpbiB1c2VyIGNvZGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZmx1c2hQcm9wZXJ0aWVzKCkge1xuICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZyAmJiB0aGlzLl9fZGF0YU9sZCkge1xuICAgICAgICBsZXQgY2hhbmdlZFByb3BzID0gdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXIrKztcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc0NoYW5nZWQodGhpcy5fX2RhdGEsIGNoYW5nZWRQcm9wcywgdGhpcy5fX2RhdGFPbGQpO1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXItLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgY2FsbGJhY2sgY2FsbGVkIHRoZSBmaXJzdCB0aW1lIHByb3BlcnRpZXMgYXJlIGJlaW5nIGZsdXNoZWQuXG4gICAgICogUHJpb3IgdG8gYHJlYWR5YCwgYWxsIHByb3BlcnR5IHNldHMgdGhyb3VnaCBhY2Nlc3NvcnMgYXJlIHF1ZXVlZCBhbmRcbiAgICAgKiB0aGVpciBlZmZlY3RzIGFyZSBmbHVzaGVkIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMuXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBpbXBsZW1lbnQgYmVoYXZpb3IgdGhhdCBpc1xuICAgICAqIGRlcGVuZGVudCBvbiB0aGUgZWxlbWVudCBoYXZpbmcgaXRzIHByb3BlcnRpZXMgaW5pdGlhbGl6ZWQsIGUuZy5cbiAgICAgKiBmcm9tIGRlZmF1bHRzIChpbml0aWFsaXplZCBmcm9tIGBjb25zdHJ1Y3RvcmAsIGBfaW5pdGlhbGl6ZVByb3BlcnRpZXNgKSxcbiAgICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCwgb3IgdmFsdWVzIHByb3BhZ2F0ZWQgZnJvbSBob3N0IGUuZy4gdmlhXG4gICAgICogYmluZGluZ3MuICBgc3VwZXIucmVhZHkoKWAgbXVzdCBiZSBjYWxsZWQgdG8gZW5zdXJlIHRoZSBkYXRhIHN5c3RlbVxuICAgICAqIGJlY29tZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgLy8gUnVuIG5vcm1hbCBmbHVzaFxuICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYW55IHByb3BlcnRpZXMgd2l0aCBhY2Nlc3NvcnMgY3JlYXRlZCB2aWFcbiAgICAgKiBgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3JgIGhhdmUgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGN1cnJlbnRQcm9wcyBCYWcgb2YgYWxsIGN1cnJlbnQgYWNjZXNzb3IgdmFsdWVzXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAqICAgY2FsbCB0byBgX3Byb3BlcnRpZXNDaGFuZ2VkYFxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgaW4gYGNoYW5nZWRQcm9wc2BcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Byb3BlcnRpZXNDaGFuZ2VkKGN1cnJlbnRQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHByb3BlcnR5IHZhbHVlIHNob3VsZCBiZVxuICAgICAqIGNvbnNpZGVyZWQgYXMgYSBjaGFuZ2UgYW5kIGNhdXNlIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFja1xuICAgICAqIHRvIGJlIGVucXVldWVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIHByaW1pdGl2ZSB0eXBlcyBpZiBhXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrIGZhaWxzLCBhbmQgcmV0dXJucyBgdHJ1ZWAgZm9yIGFsbCBPYmplY3QvQXJyYXlzLlxuICAgICAqIFRoZSBtZXRob2QgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGBOYU5gLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZS5nLiBwcm92aWRlIHN0cmljdGVyIGNoZWNraW5nIGZvclxuICAgICAqIE9iamVjdHMvQXJyYXlzIHdoZW4gdXNpbmcgaW1tdXRhYmxlIHBhdHRlcm5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiAgIGFuZCBlbnF1ZXVlIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICAgICAgKG9sZCAhPT0gdmFsdWUgJiZcbiAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyAob2xkPT1OYU4sIHZhbHVlPT1OYU4pIGFsd2F5cyByZXR1cm5zIGZhbHNlXG4gICAgICAgICAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKSlcbiAgICAgICk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gUHJvcGVydHlBY2Nlc3NvcnM7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWFjY2Vzc29ycy5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5cbi8vIDEueCBiYWNrd2FyZHMtY29tcGF0aWJsZSBhdXRvLXdyYXBwZXIgZm9yIHRlbXBsYXRlIHR5cGUgZXh0ZW5zaW9uc1xuLy8gVGhpcyBpcyBhIGNsZWFyIGxheWVyaW5nIHZpb2xhdGlvbiBhbmQgZ2l2ZXMgZmF2b3JlZC1uYXRpb24gc3RhdHVzIHRvXG4vLyBkb20taWYgYW5kIGRvbS1yZXBlYXQgdGVtcGxhdGVzLiAgVGhpcyBpcyBhIGNvbmNlaXQgd2UncmUgY2hvb3NpbmcgdG8ga2VlcFxuLy8gYS4pIHRvIGVhc2UgMS54IGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGR1ZSB0byBsb3NzIG9mIGBpc2AsIGFuZFxuLy8gYi4pIHRvIG1haW50YWluIGlmL3JlcGVhdCBjYXBhYmlsaXR5IGluIHBhcnNlci1jb25zdHJhaW5lZCBlbGVtZW50c1xuLy8gICAgIChlLmcuIHRhYmxlLCBzZWxlY3QpIGluIGxpZXUgb2YgbmF0aXZlIENFIHR5cGUgZXh0ZW5zaW9ucyB3aXRob3V0XG4vLyAgICAgbWFzc2l2ZSBuZXcgaW52ZW50aW9uIGluIHRoaXMgc3BhY2UgKGUuZy4gZGlyZWN0aXZlIHN5c3RlbSlcbmNvbnN0IHRlbXBsYXRlRXh0ZW5zaW9ucyA9IHtcbiAgJ2RvbS1pZic6IHRydWUsXG4gICdkb20tcmVwZWF0JzogdHJ1ZVxufTtcbmZ1bmN0aW9uIHdyYXBUZW1wbGF0ZUV4dGVuc2lvbihub2RlKSB7XG4gIGxldCBpcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdpcycpO1xuICBpZiAoaXMgJiYgdGVtcGxhdGVFeHRlbnNpb25zW2lzXSkge1xuICAgIGxldCB0ID0gbm9kZTtcbiAgICB0LnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICBub2RlID0gdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXMpO1xuICAgIHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgdCk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0KTtcbiAgICB3aGlsZSh0LmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSh0LmF0dHJpYnV0ZXNbMF0ubmFtZSwgdC5hdHRyaWJ1dGVzWzBdLnZhbHVlKTtcbiAgICAgIHQucmVtb3ZlQXR0cmlidXRlKHQuYXR0cmlidXRlc1swXS5uYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRUZW1wbGF0ZU5vZGUocm9vdCwgbm9kZUluZm8pIHtcbiAgLy8gcmVjdXJzaXZlbHkgYXNjZW5kIHRyZWUgdW50aWwgd2UgaGl0IHJvb3RcbiAgbGV0IHBhcmVudCA9IG5vZGVJbmZvLnBhcmVudEluZm8gJiYgZmluZFRlbXBsYXRlTm9kZShyb290LCBub2RlSW5mby5wYXJlbnRJbmZvKTtcbiAgLy8gdW53aW5kIHRoZSBzdGFjaywgcmV0dXJuaW5nIHRoZSBpbmRleGVkIG5vZGUgYXQgZWFjaCBsZXZlbFxuICBpZiAocGFyZW50KSB7XG4gICAgLy8gbm90ZTogbWFyZ2luYWxseSBmYXN0ZXIgdGhhbiBpbmRleGluZyB2aWEgY2hpbGROb2Rlc1xuICAgIC8vIChodHRwOi8vanNwZXJmLmNvbS9jaGlsZG5vZGVzLWxvb2t1cClcbiAgICBmb3IgKGxldCBuPXBhcmVudC5maXJzdENoaWxkLCBpPTA7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgaWYgKG5vZGVJbmZvLnBhcmVudEluZGV4ID09PSBpKyspIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByb290O1xuICB9XG59XG5cbi8vIGNvbnN0cnVjdCBgJGAgbWFwIChmcm9tIGlkIGFubm90YXRpb25zKVxuZnVuY3Rpb24gYXBwbHlJZFRvTWFwKGluc3QsIG1hcCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgaWYgKG5vZGVJbmZvLmlkKSB7XG4gICAgbWFwW25vZGVJbmZvLmlkXSA9IG5vZGU7XG4gIH1cbn1cblxuLy8gaW5zdGFsbCBldmVudCBsaXN0ZW5lcnMgKGZyb20gZXZlbnQgYW5ub3RhdGlvbnMpXG5mdW5jdGlvbiBhcHBseUV2ZW50TGlzdGVuZXIoaW5zdCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgaWYgKG5vZGVJbmZvLmV2ZW50cyAmJiBub2RlSW5mby5ldmVudHMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaj0wLCBlJD1ub2RlSW5mby5ldmVudHMsIGU7IChqPGUkLmxlbmd0aCkgJiYgKGU9ZSRbal0pOyBqKyspIHtcbiAgICAgIGluc3QuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZS5uYW1lLCBlLnZhbHVlLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcHVzaCBjb25maWd1cmF0aW9uIHJlZmVyZW5jZXMgYXQgY29uZmlndXJlIHRpbWVcbmZ1bmN0aW9uIGFwcGx5VGVtcGxhdGVDb250ZW50KGluc3QsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby50ZW1wbGF0ZUluZm8pIHtcbiAgICBub2RlLl90ZW1wbGF0ZUluZm8gPSBub2RlSW5mby50ZW1wbGF0ZUluZm87XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUV2ZW50SGFuZGxlcihjb250ZXh0LCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgLy8gSW5zdGFuY2VzIGNhbiBvcHRpb25hbGx5IGhhdmUgYSBfbWV0aG9kSG9zdCB3aGljaCBhbGxvd3MgcmVkaXJlY3Rpbmcgd2hlcmVcbiAgLy8gdG8gZmluZCBtZXRob2RzLiBDdXJyZW50bHkgdXNlZCBieSBgdGVtcGxhdGl6ZWAuXG4gIGNvbnRleHQgPSBjb250ZXh0Ll9tZXRob2RIb3N0IHx8IGNvbnRleHQ7XG4gIGxldCBoYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChjb250ZXh0W21ldGhvZE5hbWVdKSB7XG4gICAgICBjb250ZXh0W21ldGhvZE5hbWVdKGUsIGUuZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdsaXN0ZW5lciBtZXRob2QgYCcgKyBtZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYW5kbGVyO1xufVxuXG5leHBvcnQgY29uc3QgVGVtcGxhdGVTdGFtcCA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1RlbXBsYXRlU3RhbXB9XG4gICAqL1xuICBjbGFzcyBUZW1wbGF0ZVN0YW1wIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAvKipcbiAgICAgKiBTY2FucyBhIHRlbXBsYXRlIHRvIHByb2R1Y2UgdGVtcGxhdGUgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBUZW1wbGF0ZS1zcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIHRoZSBvYmplY3QgcmV0dXJuZWQsIGFuZCBub2RlLVxuICAgICAqIHNwZWNpZmljIG1ldGFkYXRhIGFyZSBzdG9yZWQgaW4gb2JqZWN0cyBpbiBpdHMgZmxhdHRlbmVkIGBub2RlSW5mb0xpc3RgXG4gICAgICogYXJyYXkuICBPbmx5IG5vZGVzIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IHdlcmUgcGFyc2VkIGFzIG5vZGVzIG9mXG4gICAgICogaW50ZXJlc3QgY29udGFpbiBhbiBvYmplY3QgaW4gYG5vZGVJbmZvTGlzdGAuICBFYWNoIGBub2RlSW5mb2Agb2JqZWN0XG4gICAgICogY29udGFpbnMgYW4gYGluZGV4YCAoYGNoaWxkTm9kZXNgIGluZGV4IGluIHBhcmVudCkgYW5kIG9wdGlvbmFsbHlcbiAgICAgKiBgcGFyZW50YCwgd2hpY2ggcG9pbnRzIHRvIG5vZGUgaW5mbyBvZiBpdHMgcGFyZW50IChpbmNsdWRpbmcgaXRzIGluZGV4KS5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGlzIG1ldGhvZCBoYXMgdGhlIGZvbGxvd2luZ1xuICAgICAqIHN0cnVjdHVyZSAobWFueSBmaWVsZHMgb3B0aW9uYWwpOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAgIHtcbiAgICAgKiAgICAgLy8gRmxhdHRlbmVkIGxpc3Qgb2Ygbm9kZSBtZXRhZGF0YSAoZm9yIG5vZGVzIHRoYXQgZ2VuZXJhdGVkIG1ldGFkYXRhKVxuICAgICAqICAgICBub2RlSW5mb0xpc3Q6IFtcbiAgICAgKiAgICAgICB7XG4gICAgICogICAgICAgICAvLyBgaWRgIGF0dHJpYnV0ZSBmb3IgYW55IG5vZGVzIHdpdGggaWQncyBmb3IgZ2VuZXJhdGluZyBgJGAgbWFwXG4gICAgICogICAgICAgICBpZDoge3N0cmluZ30sXG4gICAgICogICAgICAgICAvLyBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIG1ldGFkYXRhXG4gICAgICogICAgICAgICBldmVudHM6IFtcbiAgICAgKiAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgIG5hbWU6IHtzdHJpbmd9LCAgIC8vIGV2ZW50IG5hbWVcbiAgICAgKiAgICAgICAgICAgICB2YWx1ZToge3N0cmluZ30sICAvLyBoYW5kbGVyIG1ldGhvZCBuYW1lXG4gICAgICogICAgICAgICAgIH0sIC4uLlxuICAgICAqICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgIC8vIE5vdGVzIHdoZW4gdGhlIHRlbXBsYXRlIGNvbnRhaW5lZCBhIGA8c2xvdD5gIGZvciBzaGFkeSBET01cbiAgICAgKiAgICAgICAgIC8vIG9wdGltaXphdGlvbiBwdXJwb3Nlc1xuICAgICAqICAgICAgICAgaGFzSW5zZXJ0aW9uUG9pbnQ6IHtib29sZWFufSxcbiAgICAgKiAgICAgICAgIC8vIEZvciBuZXN0ZWQgYDx0ZW1wbGF0ZT5gYCBub2RlcywgbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICogICAgICAgICB0ZW1wbGF0ZUluZm86IHtvYmplY3R9LCAvLyBuZXN0ZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiAgICAgICAgIC8vIE1ldGFkYXRhIHRvIGFsbG93IGVmZmljaWVudCByZXRyaWV2YWwgb2YgaW5zdGFuY2VkIG5vZGVcbiAgICAgKiAgICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZXRhZGF0YVxuICAgICAqICAgICAgICAgcGFyZW50SW5mbzoge251bWJlcn0sICAgLy8gcmVmZXJlbmNlIHRvIHBhcmVudCBub2RlSW5mbz5cbiAgICAgKiAgICAgICAgIHBhcmVudEluZGV4OiB7bnVtYmVyfSwgIC8vIGluZGV4IGluIHBhcmVudCdzIGBjaGlsZE5vZGVzYCBjb2xsZWN0aW9uXG4gICAgICogICAgICAgICBpbmZvSW5kZXg6IHtudW1iZXJ9LCAgICAvLyBpbmRleCBvZiB0aGlzIGBub2RlSW5mb2AgaW4gYHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3RgXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgICAuLi5cbiAgICAgKiAgICAgXSxcbiAgICAgKiAgICAgLy8gV2hlbiB0cnVlLCB0aGUgdGVtcGxhdGUgaGFkIHRoZSBgc3RyaXAtd2hpdGVzcGFjZWAgYXR0cmlidXRlXG4gICAgICogICAgIC8vIG9yIHdhcyBuZXN0ZWQgaW4gYSB0ZW1wbGF0ZSB3aXRoIHRoYXQgc2V0dGluZ1xuICAgICAqICAgICBzdHJpcFdoaXRlc3BhY2U6IHtib29sZWFufSxcbiAgICAgKiAgICAgLy8gRm9yIG5lc3RlZCB0ZW1wbGF0ZXMsIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50IGlzIG1vdmVkIGludG9cbiAgICAgKiAgICAgLy8gYSBkb2N1bWVudCBmcmFnbWVudCBzdG9yZWQgaGVyZTsgdGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gdG9cbiAgICAgKiAgICAgLy8gYXZvaWQgdGhlIGNvc3Qgb2YgbmVzdGVkIHRlbXBsYXRlIGNsb25pbmdcbiAgICAgKiAgICAgY29udGVudDoge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgICogICB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBraWNrcyBvZmYgYSByZWN1cnNpdmUgdHJlZXdhbGsgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgIF9wYXJzZVRlbXBsYXRlIDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgICBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlICA8LS0tLS0tLS0tLS0tfC0tK1xuICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUgLS0rICB8XG4gICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzIC0tLS0tLS0tLStcbiAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzXG4gICAgICogICAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhZGQgY3VzdG9tIG1ldGFkYXRhIGFib3V0IHRlbXBsYXRlc1xuICAgICAqIHRvIGVpdGhlciBgdGVtcGxhdGVJbmZvYCBvciBgbm9kZUluZm9gLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG1heSBiZSBkZXN0cnVjdGl2ZSB0byB0aGUgdGVtcGxhdGUsIGluIHRoYXRcbiAgICAgKiBlLmcuIGV2ZW50IGFubm90YXRpb25zIG1heSBiZSByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIHRoZVxuICAgICAqIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mbz19IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZyb20gdGhlIG91dGVyXG4gICAgICogICB0ZW1wbGF0ZSwgZm9yIHBhcnNpbmcgbmVzdGVkIHRlbXBsYXRlc1xuICAgICAqIEByZXR1cm4geyFUZW1wbGF0ZUluZm99IFBhcnNlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgb3V0ZXJUZW1wbGF0ZUluZm8pIHtcbiAgICAgIC8vIHNpbmNlIGEgdGVtcGxhdGUgbWF5IGJlIHJlLXVzZWQsIG1lbW8taXplIG1ldGFkYXRhXG4gICAgICBpZiAoIXRlbXBsYXRlLl90ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlLl90ZW1wbGF0ZUluZm8gPSB7fTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdCA9IFtdO1xuICAgICAgICB0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlID1cbiAgICAgICAgICAob3V0ZXJUZW1wbGF0ZUluZm8gJiYgb3V0ZXJUZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlKSB8fFxuICAgICAgICAgIHRlbXBsYXRlLmhhc0F0dHJpYnV0ZSgnc3RyaXAtd2hpdGVzcGFjZScpO1xuICAgICAgICB0aGlzLl9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCB7cGFyZW50OiBudWxsfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVtcGxhdGUuX3RlbXBsYXRlSW5mbztcbiAgICB9XG5cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGUodGVtcGxhdGUuY29udGVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIG5vZGUgYW5kIGFkZHMgdGVtcGxhdGUgYW5kIG5vZGUgbWV0YWRhdGEgYmFzZWQgb25cbiAgICAgKiB0aGUgY3VycmVudCBub2RlLCBhbmQgaXRzIGBjaGlsZE5vZGVzYCBhbmQgYGF0dHJpYnV0ZXNgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWRkIGN1c3RvbSBub2RlIG9yIHRlbXBsYXRlIHNwZWNpZmljXG4gICAgICogbWV0YWRhdGEgYmFzZWQgb24gdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGxldCBub3RlZDtcbiAgICAgIGxldCBlbGVtZW50ID0gLyoqIEB0eXBlIEVsZW1lbnQgKi8obm9kZSk7XG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJyAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3ByZXNlcnZlLWNvbnRlbnQnKSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdzbG90Jykge1xuICAgICAgICAvLyBGb3IgU2hhZHlEb20gb3B0aW1pemF0aW9uLCBpbmRpY2F0aW5nIHRoZXJlIGlzIGFuIGluc2VydGlvbiBwb2ludFxuICAgICAgICB0ZW1wbGF0ZUluZm8uaGFzSW5zZXJ0aW9uUG9pbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzKGVsZW1lbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHx8IG5vdGVkO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlcyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgY2hpbGQgbm9kZXMgZm9yIHRoZSBnaXZlbiByb290IG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbHNvIHdyYXBzIHdoaXRlbGlzdGVkIGxlZ2FjeSB0ZW1wbGF0ZSBleHRlbnNpb25zXG4gICAgICogKGBpcz1cImRvbS1pZlwiYCBhbmQgYGlzPVwiZG9tLXJlcGVhdFwiYCkgd2l0aCB0aGVpciBlcXVpdmFsZW50IGVsZW1lbnRcbiAgICAgKiB3cmFwcGVycywgY29sbGFwc2VzIHRleHQgbm9kZXMsIGFuZCBzdHJpcHMgd2hpdGVzcGFjZSBmcm9tIHRoZSB0ZW1wbGF0ZVxuICAgICAqIGlmIHRoZSBgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVzcGFjZWAgc2V0dGluZyB3YXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IHJvb3QgUm9vdCBub2RlIHdob3NlIGBjaGlsZE5vZGVzYCB3aWxsIGJlIHBhcnNlZFxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2Rlcyhyb290LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBmb3IgKGxldCBub2RlPXJvb3QuZmlyc3RDaGlsZCwgcGFyZW50SW5kZXg9MCwgbmV4dDsgbm9kZTsgbm9kZT1uZXh0KSB7XG4gICAgICAgIC8vIFdyYXAgdGVtcGxhdGVzXG4gICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgbm9kZSA9IHdyYXBUZW1wbGF0ZUV4dGVuc2lvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb2xsYXBzZSBhZGphY2VudCB0ZXh0Tm9kZXM6IGZpeGVzIGFuIElFIGlzc3VlIHRoYXQgY2FuIGNhdXNlXG4gICAgICAgIC8vIHRleHQgbm9kZXMgdG8gYmUgaW5leHBsaWNhYmx5IHNwbGl0ID0oXG4gICAgICAgIC8vIG5vdGUgdGhhdCByb290Lm5vcm1hbGl6ZSgpIHNob3VsZCB3b3JrIGJ1dCBkb2VzIG5vdCBzbyB3ZSBkbyB0aGlzXG4gICAgICAgIC8vIG1hbnVhbGx5LlxuICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgbGV0IC8qKiBOb2RlICovIG4gPSBuZXh0O1xuICAgICAgICAgIHdoaWxlIChuICYmIChuLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkpIHtcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgKz0gbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIG5leHQgPSBuLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChuKTtcbiAgICAgICAgICAgIG4gPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvcHRpb25hbGx5IHN0cmlwIHdoaXRlc3BhY2VcbiAgICAgICAgICBpZiAodGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSAmJiAhbm9kZS50ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkSW5mbyA9IHsgcGFyZW50SW5kZXgsIHBhcmVudEluZm86IG5vZGVJbmZvIH07XG4gICAgICAgIGlmICh0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIGNoaWxkSW5mbykpIHtcbiAgICAgICAgICBjaGlsZEluZm8uaW5mb0luZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5wdXNoKC8qKiBAdHlwZSB7IU5vZGVJbmZvfSAqLyhjaGlsZEluZm8pKSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5jcmVtZW50IGlmIG5vdCByZW1vdmVkXG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwYXJlbnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIGNvbnRlbnQgZm9yIHRoZSBnaXZlbiBuZXN0ZWQgYDx0ZW1wbGF0ZT5gLlxuICAgICAqXG4gICAgICogTmVzdGVkIHRlbXBsYXRlIGluZm8gaXMgc3RvcmVkIGFzIGB0ZW1wbGF0ZUluZm9gIGluIHRoZSBjdXJyZW50IG5vZGUnc1xuICAgICAqIGBub2RlSW5mb2AuIGB0ZW1wbGF0ZS5jb250ZW50YCBpcyByZW1vdmVkIGFuZCBzdG9yZWQgaW4gYHRlbXBsYXRlSW5mb2AuXG4gICAgICogSXQgd2lsbCB0aGVuIGJlIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgaG9zdCB0byBzZXQgaXQgYmFjayB0byB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBhbmQgZm9yIHVzZXJzIHN0YW1waW5nIG5lc3RlZCB0ZW1wbGF0ZXMgdG8gdXNlIHRoZVxuICAgICAqIGBfY29udGVudEZvclRlbXBsYXRlYCBtZXRob2QgdG8gcmV0cmlldmUgdGhlIGNvbnRlbnQgZm9yIHRoaXMgdGVtcGxhdGVcbiAgICAgKiAoYW4gb3B0aW1pemF0aW9uIHRvIGF2b2lkIHRoZSBjb3N0IG9mIGNsb25pbmcgbmVzdGVkIHRlbXBsYXRlIGNvbnRlbnQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2UgKGEgPHRlbXBsYXRlPilcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gb3V0ZXJUZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiAgIHRoYXQgaW5jbHVkZXMgdGhlIHRlbXBsYXRlIGBub2RlYFxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCBvdXRlclRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLl9wYXJzZVRlbXBsYXRlKG5vZGUsIG91dGVyVGVtcGxhdGVJbmZvKTtcbiAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgPVxuICAgICAgICBub2RlLmNvbnRlbnQub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUuY29udGVudCk7XG4gICAgICBub2RlSW5mby50ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgbm9kZSBhdHRyaWJ1dGVzIGFuZCBhZGRzIG5vZGUgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIGZvciBub2RlcyBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIC8vIE1ha2UgY29weSBvZiBvcmlnaW5hbCBhdHRyaWJ1dGUgbGlzdCwgc2luY2UgdGhlIG9yZGVyIG1heSBjaGFuZ2VcbiAgICAgIC8vIGFzIGF0dHJpYnV0ZXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkXG4gICAgICBsZXQgbm90ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBhdHRycyA9IEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgIGZvciAobGV0IGk9YXR0cnMubGVuZ3RoLTEsIGE7IChhPWF0dHJzW2ldKTsgaS0tKSB7XG4gICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgYS5uYW1lLCBhLnZhbHVlKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzaW5nbGUgdGVtcGxhdGUgbm9kZSBhdHRyaWJ1dGUgYW5kIGFkZHMgbm9kZSBtZXRhZGF0YSB0b1xuICAgICAqIGBub2RlSW5mb2AgZm9yIGF0dHJpYnV0ZXMgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGFkZHMgbWV0YWRhdGEgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAqIGFuZCBgaWRgIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgIC8vIGV2ZW50cyAob24tKilcbiAgICAgIGlmIChuYW1lLnNsaWNlKDAsIDMpID09PSAnb24tJykge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgbm9kZUluZm8uZXZlbnRzID0gbm9kZUluZm8uZXZlbnRzIHx8IFtdO1xuICAgICAgICBub2RlSW5mby5ldmVudHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogbmFtZS5zbGljZSgzKSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBzdGF0aWMgaWRcbiAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgbm9kZUluZm8uaWQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYGNvbnRlbnRgIGRvY3VtZW50IGZyYWdtZW50IGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogRm9yIG5lc3RlZCB0ZW1wbGF0ZXMsIFBvbHltZXIgcGVyZm9ybXMgYW4gb3B0aW1pemF0aW9uIHRvIGNhY2hlIG5lc3RlZFxuICAgICAqIHRlbXBsYXRlIGNvbnRlbnQgdG8gYXZvaWQgdGhlIGNvc3Qgb2YgY2xvbmluZyBkZWVwbHkgbmVzdGVkIHRlbXBsYXRlcy5cbiAgICAgKiBUaGlzIG1ldGhvZCByZXRyaWV2ZXMgdGhlIGNhY2hlZCBjb250ZW50IGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byByZXRyaWV2ZSBgY29udGVudGAgZm9yXG4gICAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH0gQ29udGVudCBmcmFnbWVudFxuICAgICAqL1xuICAgIHN0YXRpYyBfY29udGVudEZvclRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50V2l0aEluZm99ICovICh0ZW1wbGF0ZSkuX3RlbXBsYXRlSW5mbztcbiAgICAgIHJldHVybiAodGVtcGxhdGVJbmZvICYmIHRlbXBsYXRlSW5mby5jb250ZW50KSB8fCB0ZW1wbGF0ZS5jb250ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgY29udGVudCBhbmQgcmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICogY29udGFpbmluZyB0aGUgY2xvbmVkIGRvbS5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBpcyBwYXJzZWQgKG9uY2UgYW5kIG1lbW9pemVkKSB1c2luZyB0aGlzIGxpYnJhcnknc1xuICAgICAqIHRlbXBsYXRlIHBhcnNpbmcgZmVhdHVyZXMsIGFuZCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIHZhbHVlLWFkZGVkXG4gICAgICogZmVhdHVyZXM6XG4gICAgICogKiBBZGRzIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBmb3IgYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBhdHRyaWJ1dGVzXG4gICAgICogKiBHZW5lcmF0ZXMgYW4gXCJpZCBtYXBcIiBmb3IgYWxsIG5vZGVzIHdpdGggaWQncyB1bmRlciBgJGAgb24gcmV0dXJuZWRcbiAgICAgKiAgIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICogKiBQYXNzZXMgdGVtcGxhdGUgaW5mbyBpbmNsdWRpbmcgYGNvbnRlbnRgIGJhY2sgdG8gdGVtcGxhdGVzIGFzXG4gICAgICogICBgX3RlbXBsYXRlSW5mb2AgKGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRvIGF2b2lkIGRlZXAgdGVtcGxhdGVcbiAgICAgKiAgIGNsb25pbmcpXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIG1lbW9pemVkIHRlbXBsYXRlIHBhcnNpbmcgcHJvY2VzcyBpcyBkZXN0cnVjdGl2ZSB0byB0aGVcbiAgICAgKiB0ZW1wbGF0ZTogYXR0cmlidXRlcyBmb3IgYmluZGluZ3MgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBhcmVcbiAgICAgKiByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIG5vdGVzLCBhbmQgYW55IG5lc3RlZCBgPHRlbXBsYXRlPi5jb250ZW50YFxuICAgICAqIGlzIHJlbW92ZWQgYW5kIHN0b3JlZCBpbiBub3RlcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gc3RhbXBcbiAgICAgKiBAcmV0dXJuIHshU3RhbXBlZFRlbXBsYXRlfSBDbG9uZWQgdGVtcGxhdGUgY29udGVudFxuICAgICAqL1xuICAgIF9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAvLyBQb2x5ZmlsbCBzdXBwb3J0OiBib290c3RyYXAgdGhlIHRlbXBsYXRlIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuXG4gICAgICBpZiAodGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbnRlbnQgJiZcbiAgICAgICAgICB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCAmJiBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKSB7XG4gICAgICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUodGVtcGxhdGUpO1xuICAgICAgfVxuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IG5vZGVJbmZvID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdDtcbiAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICAgIGxldCBkb20gPSAvKiogQHR5cGUgRG9jdW1lbnRGcmFnbWVudCAqLyAoZG9jdW1lbnQuaW1wb3J0Tm9kZShjb250ZW50LCB0cnVlKSk7XG4gICAgICAvLyBOT1RFOiBTaGFkeURvbSBvcHRpbWl6YXRpb24gaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgIGRvbS5fX25vSW5zZXJ0aW9uUG9pbnQgPSAhdGVtcGxhdGVJbmZvLmhhc0luc2VydGlvblBvaW50O1xuICAgICAgbGV0IG5vZGVzID0gZG9tLm5vZGVMaXN0ID0gbmV3IEFycmF5KG5vZGVJbmZvLmxlbmd0aCk7XG4gICAgICBkb20uJCA9IHt9O1xuICAgICAgZm9yIChsZXQgaT0wLCBsPW5vZGVJbmZvLmxlbmd0aCwgaW5mbzsgKGk8bCkgJiYgKGluZm89bm9kZUluZm9baV0pOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXSA9IGZpbmRUZW1wbGF0ZU5vZGUoZG9tLCBpbmZvKTtcbiAgICAgICAgYXBwbHlJZFRvTWFwKHRoaXMsIGRvbS4kLCBub2RlLCBpbmZvKTtcbiAgICAgICAgYXBwbHlUZW1wbGF0ZUNvbnRlbnQodGhpcywgbm9kZSwgaW5mbyk7XG4gICAgICAgIGFwcGx5RXZlbnRMaXN0ZW5lcih0aGlzLCBub2RlLCBpbmZvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiogQHR5cGUgeyFTdGFtcGVkVGVtcGxhdGV9ICovKGRvbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBieSBtZXRob2QgbmFtZSBmb3IgdGhlIGV2ZW50IHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGEgaGFuZGxlciBmdW5jdGlvbiB0aGF0IGxvb2tzIHVwIHRoZSBtZXRob2RcbiAgICAgKiBuYW1lIGF0IGhhbmRsaW5nIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhZGQgbGlzdGVuZXIgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Kj19IGNvbnRleHQgQ29udGV4dCB0aGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uIChkZWZhdWx0c1xuICAgICAqICAgdG8gYG5vZGVgKVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBHZW5lcmF0ZWQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqL1xuICAgIF9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSwgY29udGV4dCkge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbm9kZTtcbiAgICAgIGxldCBoYW5kbGVyID0gY3JlYXRlTm9kZUV2ZW50SGFuZGxlcihjb250ZXh0LCBldmVudE5hbWUsIG1ldGhvZE5hbWUpO1xuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIGFkZGluZyBjdXN0b20gb3Igc2ltdWxhdGVkIGV2ZW50IGhhbmRsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBMaXN0ZW5lciBmdW5jdGlvbiB0byBhZGRcbiAgICAgKi9cbiAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBMaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gVGVtcGxhdGVTdGFtcDtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvdGVtcGxhdGUtc3RhbXAuanNcbi8vIG1vZHVsZSBpZCA9IDU4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcblxuLy8gcnVuIGEgY2FsbGJhY2sgd2hlbiBIVE1MSW1wb3J0cyBhcmUgcmVhZHkgb3IgaW1tZWRpYXRlbHkgaWZcbi8vIHRoaXMgYXBpIGlzIG5vdCBhdmFpbGFibGUuXG5mdW5jdGlvbiB3aGVuSW1wb3J0c1JlYWR5KGNiKSB7XG4gIGlmICh3aW5kb3cuSFRNTEltcG9ydHMpIHtcbiAgICBIVE1MSW1wb3J0cy53aGVuUmVhZHkoY2IpO1xuICB9IGVsc2Uge1xuICAgIGNiKCk7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGltcG9ydEhyZWYgPSBmdW5jdGlvbihocmVmLCBvbmxvYWQsIG9uZXJyb3IsIG9wdEFzeW5jKSB7XG4gIGxldCBsaW5rID0gLyoqIEB0eXBlIHtIVE1MTGlua0VsZW1lbnR9ICovXG4gICAgKGRvY3VtZW50LmhlYWQucXVlcnlTZWxlY3RvcignbGlua1tocmVmPVwiJyArIGhyZWYgKyAnXCJdW2ltcG9ydC1ocmVmXScpKTtcbiAgaWYgKCFsaW5rKSB7XG4gICAgbGluayA9IC8qKiBAdHlwZSB7SFRNTExpbmtFbGVtZW50fSAqLyAoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGluaycpKTtcbiAgICBsaW5rLnJlbCA9ICdpbXBvcnQnO1xuICAgIGxpbmsuaHJlZiA9IGhyZWY7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoJ2ltcG9ydC1ocmVmJywgJycpO1xuICB9XG4gIC8vIGFsd2F5cyBlbnN1cmUgbGluayBoYXMgYGFzeW5jYCBhdHRyaWJ1dGUgaWYgdXNlciBzcGVjaWZpZWQgb25lLFxuICAvLyBldmVuIGlmIGl0IHdhcyBwcmV2aW91c2x5IG5vdCBhc3luYy4gVGhpcyBpcyBjb25zaWRlcmVkIGxlc3MgY29uZnVzaW5nLlxuICBpZiAob3B0QXN5bmMpIHtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZSgnYXN5bmMnLCAnJyk7XG4gIH1cbiAgLy8gTk9URTogdGhlIGxpbmsgbWF5IG5vdyBiZSBpbiAzIHN0YXRlczogKDEpIHBlbmRpbmcgaW5zZXJ0aW9uLFxuICAvLyAoMikgaW5mbGlnaHQsICgzKSBhbHJlYWR5IGxhb2RlZC4gSW4gZWFjaCBjYXNlLCB3ZSBuZWVkIHRvIGFkZFxuICAvLyBldmVudCBsaXN0ZW5lcnMgdG8gcHJvY2VzcyBjYWxsYmFja3MuXG4gIGxldCBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgbGluay5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZExpc3RlbmVyKTtcbiAgICBsaW5rLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gIH07XG4gIGxldCBsb2FkTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGNsZWFudXAoKTtcbiAgICAvLyBJbiBjYXNlIG9mIGEgc3VjY2Vzc2Z1bCBsb2FkLCBjYWNoZSB0aGUgbG9hZCBldmVudCBvbiB0aGUgbGluayBzb1xuICAgIC8vIHRoYXQgaXQgY2FuIGJlIHVzZWQgdG8gc2hvcnQtY2lyY3VpdCB0aGlzIG1ldGhvZCBpbiB0aGUgZnV0dXJlIHdoZW5cbiAgICAvLyBpdCBpcyBjYWxsZWQgd2l0aCB0aGUgc2FtZSBocmVmIHBhcmFtLlxuICAgIGxpbmsuX19keW5hbWljSW1wb3J0TG9hZGVkID0gdHJ1ZTtcbiAgICBpZiAob25sb2FkKSB7XG4gICAgICB3aGVuSW1wb3J0c1JlYWR5KCgpID0+IHtcbiAgICAgICAgb25sb2FkKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgbGV0IGVycm9yTGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCkge1xuICAgIGNsZWFudXAoKTtcbiAgICAvLyBJbiBjYXNlIG9mIGFuIGVycm9yLCByZW1vdmUgdGhlIGxpbmsgZnJvbSB0aGUgZG9jdW1lbnQgc28gdGhhdCBpdFxuICAgIC8vIHdpbGwgYmUgYXV0b21hdGljYWxseSBjcmVhdGVkIGFnYWluIHRoZSBuZXh0IHRpbWUgYGltcG9ydEhyZWZgIGlzXG4gICAgLy8gY2FsbGVkLlxuICAgIGlmIChsaW5rLnBhcmVudE5vZGUpIHtcbiAgICAgIGxpbmsucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChsaW5rKTtcbiAgICB9XG4gICAgaWYgKG9uZXJyb3IpIHtcbiAgICAgIHdoZW5JbXBvcnRzUmVhZHkoKCkgPT4ge1xuICAgICAgICBvbmVycm9yKGV2ZW50KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgbGluay5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbG9hZExpc3RlbmVyKTtcbiAgbGluay5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICBpZiAobGluay5wYXJlbnROb2RlID09IG51bGwpIHtcbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGxpbmspO1xuICAvLyBpZiB0aGUgbGluayBhbHJlYWR5IGxvYWRlZCwgZGlzcGF0Y2ggYSBmYWtlIGxvYWQgZXZlbnRcbiAgLy8gc28gdGhhdCBsaXN0ZW5lcnMgYXJlIGNhbGxlZCBhbmQgZ2V0IGEgcHJvcGVyIGV2ZW50IGFyZ3VtZW50LlxuICB9IGVsc2UgaWYgKGxpbmsuX19keW5hbWljSW1wb3J0TG9hZGVkKSB7XG4gICAgbGluay5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbG9hZCcpKTtcbiAgfVxuICByZXR1cm4gbGluaztcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9pbXBvcnQtaHJlZi5qc1xuLy8gbW9kdWxlIGlkID0gNTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZnVuY3Rpb24gcmVzb2x2ZSgpIHtcbiAgZG9jdW1lbnQuYm9keS5yZW1vdmVBdHRyaWJ1dGUoJ3VucmVzb2x2ZWQnKTtcbn1cblxuaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdpbnRlcmFjdGl2ZScgfHwgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICByZXNvbHZlKCk7XG59IGVsc2Uge1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIHJlc29sdmUpO1xufVxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvdW5yZXNvbHZlZC5qc1xuLy8gbW9kdWxlIGlkID0gNjBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlU3BsaWNlcyB9IGZyb20gJy4vYXJyYXktc3BsaWNlLmpzJztcbmltcG9ydCB7IG1pY3JvVGFzayB9IGZyb20gJy4vYXN5bmMuanMnO1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBgbm9kZWAgaXMgYSBzbG90IGVsZW1lbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGUgTm9kZSB0byB0ZXN0LlxuICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBgbm9kZWAgaXMgYSBzbG90XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc1Nsb3Qobm9kZSkge1xuICByZXR1cm4gKG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcpO1xufVxuXG4vKipcbiAqIENsYXNzIHRoYXQgbGlzdGVucyBmb3IgY2hhbmdlcyAoYWRkaXRpb25zIG9yIHJlbW92YWxzKSB0b1xuICogXCJmbGF0dGVuZWQgbm9kZXNcIiBvbiBhIGdpdmVuIGBub2RlYC4gVGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGNvbnNpc3RzXG4gKiBvZiBhIG5vZGUncyBjaGlsZHJlbiBhbmQsIGZvciBhbnkgY2hpbGRyZW4gdGhhdCBhcmUgYDxzbG90PmAgZWxlbWVudHMsXG4gKiB0aGUgZXhwYW5kZWQgZmxhdHRlbmVkIGxpc3Qgb2YgYGFzc2lnbmVkTm9kZXNgLlxuICogRm9yIGV4YW1wbGUsIGlmIHRoZSBvYnNlcnZlZCBub2RlIGhhcyBjaGlsZHJlbiBgPGE+PC9hPjxzbG90Pjwvc2xvdD48Yj48L2I+YFxuICogYW5kIHRoZSBgPHNsb3Q+YCBoYXMgb25lIGA8ZGl2PmAgYXNzaWduZWQgdG8gaXQsIHRoZW4gdGhlIGZsYXR0ZW5lZFxuICogbm9kZXMgbGlzdCBpcyBgPGE+PC9hPjxkaXY+PC9kaXY+PGI+PC9iPmAuIElmIHRoZSBgPHNsb3Q+YCBoYXMgb3RoZXJcbiAqIGA8c2xvdD5gIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0LCB0aGVzZSBhcmUgZmxhdHRlbmVkIGFzIHdlbGwuXG4gKlxuICogVGhlIHByb3ZpZGVkIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdoZW5ldmVyIGFueSBjaGFuZ2UgdG8gdGhpcyBsaXN0XG4gKiBvZiBmbGF0dGVuZWQgbm9kZXMgb2NjdXJzLCB3aGVyZSBhbiBhZGRpdGlvbiBvciByZW1vdmFsIG9mIGEgbm9kZSBpc1xuICogY29uc2lkZXJlZCBhIGNoYW5nZS4gVGhlIGBjYWxsYmFja2AgaXMgY2FsbGVkIHdpdGggb25lIGFyZ3VtZW50LCBhbiBvYmplY3RcbiAqIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgYW55IGBhZGRlZE5vZGVzYCBhbmQgYHJlbW92ZWROb2Rlc2AuXG4gKlxuICogTm90ZTogdGhlIGNhbGxiYWNrIGlzIGNhbGxlZCBhc3luY2hyb25vdXMgdG8gYW55IGNoYW5nZXNcbiAqIGF0IGEgbWljcm90YXNrIGNoZWNrcG9pbnQuIFRoaXMgaXMgYmVjYXVzZSBvYnNlcnZhdGlvbiBpcyBwZXJmb3JtZWQgdXNpbmdcbiAqIGBNdXRhdGlvbk9ic2VydmVyYCBhbmQgdGhlIGA8c2xvdD5gIGVsZW1lbnQncyBgc2xvdGNoYW5nZWAgZXZlbnQgd2hpY2hcbiAqIGFyZSBhc3luY2hyb25vdXMuXG4gKlxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IENsYXNzIHRoYXQgbGlzdGVucyBmb3IgY2hhbmdlcyAoYWRkaXRpb25zIG9yIHJlbW92YWxzKSB0b1xuICogXCJmbGF0dGVuZWQgbm9kZXNcIiBvbiBhIGdpdmVuIGBub2RlYC5cbiAqL1xuY2xhc3MgRmxhdHRlbmVkTm9kZXNPYnNlcnZlciB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gYG5vZGVgLlxuICAgKiBUaGlzIGxpc3QgY29uc2lzdHMgb2YgYSBub2RlJ3MgY2hpbGRyZW4gYW5kLCBmb3IgYW55IGNoaWxkcmVuXG4gICAqIHRoYXQgYXJlIGA8c2xvdD5gIGVsZW1lbnRzLCB0aGUgZXhwYW5kZWQgZmxhdHRlbmVkIGxpc3Qgb2YgYGFzc2lnbmVkTm9kZXNgLlxuICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIG9ic2VydmVkIG5vZGUgaGFzIGNoaWxkcmVuIGA8YT48L2E+PHNsb3Q+PC9zbG90PjxiPjwvYj5gXG4gICAqIGFuZCB0aGUgYDxzbG90PmAgaGFzIG9uZSBgPGRpdj5gIGFzc2lnbmVkIHRvIGl0LCB0aGVuIHRoZSBmbGF0dGVuZWRcbiAgICogbm9kZXMgbGlzdCBpcyBgPGE+PC9hPjxkaXY+PC9kaXY+PGI+PC9iPmAuIElmIHRoZSBgPHNsb3Q+YCBoYXMgb3RoZXJcbiAgICogYDxzbG90PmAgZWxlbWVudHMgYXNzaWduZWQgdG8gaXQsIHRoZXNlIGFyZSBmbGF0dGVuZWQgYXMgd2VsbC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxIVE1MU2xvdEVsZW1lbnR9IG5vZGUgVGhlIG5vZGUgZm9yIHdoaWNoIHRvIHJldHVybiB0aGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMuXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgbGlzdCBvZiBmbGF0dGVuZWQgbm9kZXMgZm9yIHRoZSBnaXZlbiBgbm9kZWAuXG4gICovXG4gIHN0YXRpYyBnZXRGbGF0dGVuZWROb2Rlcyhub2RlKSB7XG4gICAgaWYgKGlzU2xvdChub2RlKSkge1xuICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTFNsb3RFbGVtZW50fSAqLyAobm9kZSkuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShub2RlLmNoaWxkTm9kZXMpLm1hcChub2RlID0+IHtcbiAgICAgICAgaWYgKGlzU2xvdChub2RlKSkge1xuICAgICAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxTbG90RWxlbWVudH0gKi8gKG5vZGUpLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gW25vZGVdO1xuICAgICAgICB9XG4gICAgICB9KS5yZWR1Y2UoKGEsIGIpID0+IGEuY29uY2F0KGIpLCBbXSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gdGFyZ2V0IE5vZGUgb24gd2hpY2ggdG8gbGlzdGVuIGZvciBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBGdW5jdGlvbiBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgYWRkaXRpb25zXG4gICAqIG9yIHJlbW92YWxzIGZyb20gdGhlIHRhcmdldCdzIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzLlxuICAqL1xuICBjb25zdHJ1Y3Rvcih0YXJnZXQsIGNhbGxiYWNrKSB7XG4gICAgLyoqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfSAqL1xuICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtNdXRhdGlvbk9ic2VydmVyfSAqL1xuICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMgPSBbXTtcbiAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgdGhpcy5fc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgLyoqIEB0eXBlIHtmdW5jdGlvbigpfSAqL1xuICAgIHRoaXMuX2JvdW5kU2NoZWR1bGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9zY2hlZHVsZSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25uZWN0KCk7XG4gICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY3RpdmF0ZXMgYW4gb2JzZXJ2ZXIuIFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgY2FsbGVkIHdoZW5cbiAgICogYSBgRmxhdHRlbmVkTm9kZXNPYnNlcnZlcmAgaXMgY3JlYXRlZC4gSXQgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIHRvXG4gICAqIHJlLWFjdGl2YXRlIGFuIG9ic2VydmVyIHRoYXQgaGFzIGJlZW4gZGVhY3RpdmF0ZWQgdmlhIHRoZSBgZGlzY29ubmVjdGAgbWV0aG9kLlxuICAgKi9cbiAgY29ubmVjdCgpIHtcbiAgICBpZiAoaXNTbG90KHRoaXMuX3RhcmdldCkpIHtcbiAgICAgIHRoaXMuX2xpc3RlblNsb3RzKFt0aGlzLl90YXJnZXRdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fbGlzdGVuU2xvdHModGhpcy5fdGFyZ2V0LmNoaWxkcmVuKTtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgICAgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyID1cbiAgICAgICAgICBTaGFkeURPTS5vYnNlcnZlQ2hpbGRyZW4odGhpcy5fdGFyZ2V0LCAobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID1cbiAgICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl90YXJnZXQsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWFjdGl2YXRlcyB0aGUgZmxhdHRlbmVkIG5vZGVzIG9ic2VydmVyLiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kXG4gICAqIHRoZSBvYnNlcnZlciBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgd2hlbiBjaGFuZ2VzIHRvIGZsYXR0ZW5lZCBub2Rlc1xuICAgKiBvY2N1ci4gVGhlIGBjb25uZWN0YCBtZXRob2QgbWF5IGJlIHN1YnNlcXVlbnRseSBjYWxsZWQgdG8gcmVhY3RpdmF0ZVxuICAgKiB0aGUgb2JzZXJ2ZXIuXG4gICAqL1xuICBkaXNjb25uZWN0KCkge1xuICAgIGlmIChpc1Nsb3QodGhpcy5fdGFyZ2V0KSkge1xuICAgICAgdGhpcy5fdW5saXN0ZW5TbG90cyhbdGhpcy5fdGFyZ2V0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHModGhpcy5fdGFyZ2V0LmNoaWxkcmVuKTtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlET00gJiYgdGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgIFNoYWR5RE9NLnVub2JzZXJ2ZUNoaWxkcmVuKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcik7XG4gICAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIF9zY2hlZHVsZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NjaGVkdWxlZCkge1xuICAgICAgdGhpcy5fc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIG1pY3JvVGFzay5ydW4oKCkgPT4gdGhpcy5mbHVzaCgpKTtcbiAgICB9XG4gIH1cblxuICBfcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgIHRoaXMuZmx1c2goKTtcbiAgfVxuXG4gIF9wcm9jZXNzU2xvdE11dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICBpZiAobXV0YXRpb25zKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBtdXRhdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG11dGF0aW9uID0gbXV0YXRpb25zW2ldO1xuICAgICAgICBpZiAobXV0YXRpb24uYWRkZWROb2Rlcykge1xuICAgICAgICAgIHRoaXMuX2xpc3RlblNsb3RzKG11dGF0aW9uLmFkZGVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtdXRhdGlvbi5yZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgICB0aGlzLl91bmxpc3RlblNsb3RzKG11dGF0aW9uLnJlbW92ZWROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmx1c2hlcyB0aGUgb2JzZXJ2ZXIgY2F1c2luZyBhbnkgcGVuZGluZyBjaGFuZ2VzIHRvIGJlIGltbWVkaWF0ZWx5XG4gICAqIGRlbGl2ZXJlZCB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2suIEJ5IGRlZmF1bHQgdGhlc2UgY2hhbmdlcyBhcmUgZGVsaXZlcmVkXG4gICAqIGFzeW5jaHJvbm91c2x5IGF0IHRoZSBuZXh0IG1pY3JvdGFzayBjaGVja3BvaW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgYW55IHBlbmRpbmcgY2hhbmdlcyBjYXVzZWQgdGhlIG9ic2VydmVyXG4gICAqIGNhbGxiYWNrIHRvIHJ1bi5cbiAgICovXG4gIGZsdXNoKCkge1xuICAgIGlmICghdGhpcy5fY29ubmVjdGVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh3aW5kb3cuU2hhZHlET00pIHtcbiAgICAgIFNoYWR5RE9NLmZsdXNoKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICB0aGlzLl9wcm9jZXNzU2xvdE11dGF0aW9ucyh0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gICAgfVxuICAgIHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIGxldCBpbmZvID0ge1xuICAgICAgdGFyZ2V0OiB0aGlzLl90YXJnZXQsXG4gICAgICBhZGRlZE5vZGVzOiBbXSxcbiAgICAgIHJlbW92ZWROb2RlczogW11cbiAgICB9O1xuICAgIGxldCBuZXdOb2RlcyA9IHRoaXMuY29uc3RydWN0b3IuZ2V0RmxhdHRlbmVkTm9kZXModGhpcy5fdGFyZ2V0KTtcbiAgICBsZXQgc3BsaWNlcyA9IGNhbGN1bGF0ZVNwbGljZXMobmV3Tm9kZXMsXG4gICAgICB0aGlzLl9lZmZlY3RpdmVOb2Rlcyk7XG4gICAgLy8gcHJvY2VzcyByZW1vdmFsc1xuICAgIGZvciAobGV0IGk9MCwgczsgKGk8c3BsaWNlcy5sZW5ndGgpICYmIChzPXNwbGljZXNbaV0pOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGo9MCwgbjsgKGogPCBzLnJlbW92ZWQubGVuZ3RoKSAmJiAobj1zLnJlbW92ZWRbal0pOyBqKyspIHtcbiAgICAgICAgaW5mby5yZW1vdmVkTm9kZXMucHVzaChuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gcHJvY2VzcyBhZGRzXG4gICAgZm9yIChsZXQgaT0wLCBzOyAoaTxzcGxpY2VzLmxlbmd0aCkgJiYgKHM9c3BsaWNlc1tpXSk7IGkrKykge1xuICAgICAgZm9yIChsZXQgaj1zLmluZGV4OyBqIDwgcy5pbmRleCArIHMuYWRkZWRDb3VudDsgaisrKSB7XG4gICAgICAgIGluZm8uYWRkZWROb2Rlcy5wdXNoKG5ld05vZGVzW2pdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gdXBkYXRlIGNhY2hlXG4gICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMgPSBuZXdOb2RlcztcbiAgICBsZXQgZGlkRmx1c2ggPSBmYWxzZTtcbiAgICBpZiAoaW5mby5hZGRlZE5vZGVzLmxlbmd0aCB8fCBpbmZvLnJlbW92ZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgIGRpZEZsdXNoID0gdHJ1ZTtcbiAgICAgIHRoaXMuY2FsbGJhY2suY2FsbCh0aGlzLl90YXJnZXQsIGluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gZGlkRmx1c2g7XG4gIH1cblxuICBfbGlzdGVuU2xvdHMobm9kZUxpc3QpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG4gPSBub2RlTGlzdFtpXTtcbiAgICAgIGlmIChpc1Nsb3QobikpIHtcbiAgICAgICAgbi5hZGRFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcy5fYm91bmRTY2hlZHVsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3VubGlzdGVuU2xvdHMobm9kZUxpc3QpIHtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBub2RlTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IG4gPSBub2RlTGlzdFtpXTtcbiAgICAgIGlmIChpc1Nsb3QobikpIHtcbiAgICAgICAgbi5yZW1vdmVFdmVudExpc3RlbmVyKCdzbG90Y2hhbmdlJywgdGhpcy5fYm91bmRTY2hlZHVsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IHsgRmxhdHRlbmVkTm9kZXNPYnNlcnZlciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA2MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBMZWdhY3lFbGVtZW50TWl4aW4gfSBmcm9tICcuL2xlZ2FjeS1lbGVtZW50LW1peGluLmpzJztcbmltcG9ydCB7IERvbU1vZHVsZSB9IGZyb20gJy4uL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMnO1xuXG5sZXQgbWV0YVByb3BzID0ge1xuICBhdHRhY2hlZDogdHJ1ZSxcbiAgZGV0YWNoZWQ6IHRydWUsXG4gIHJlYWR5OiB0cnVlLFxuICBjcmVhdGVkOiB0cnVlLFxuICBiZWZvcmVSZWdpc3RlcjogdHJ1ZSxcbiAgcmVnaXN0ZXJlZDogdHJ1ZSxcbiAgYXR0cmlidXRlQ2hhbmdlZDogdHJ1ZSxcbiAgLy8gbWV0YSBvYmplY3RzXG4gIGJlaGF2aW9yczogdHJ1ZVxufTtcblxuLyoqXG4gKiBBcHBsaWVzIGEgXCJsZWdhY3lcIiBiZWhhdmlvciBvciBhcnJheSBvZiBiZWhhdmlvcnMgdG8gdGhlIHByb3ZpZGVkIGNsYXNzLlxuICpcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIHdpbGwgYXV0b21hdGljYWxseSBhbHNvIGFwcGx5IHRoZSBgUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW5gXG4gKiB0byBlbnN1cmUgdGhhdCBhbnkgbGVnYWN5IGJlaGF2aW9ycyBjYW4gcmVseSBvbiBsZWdhY3kgUG9seW1lciBBUEkgb25cbiAqIHRoZSB1bmRlcmx5aW5nIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHshKE9iamVjdHxBcnJheSl9IGJlaGF2aW9ycyBCZWhhdmlvciBvYmplY3Qgb3IgYXJyYXkgb2YgYmVoYXZpb3JzLlxuICogQHBhcmFtIHshSFRNTEVsZW1lbnR8ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0ga2xhc3MgRWxlbWVudCBjbGFzcy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IFJldHVybnMgYSBuZXcgRWxlbWVudCBjbGFzcyBleHRlbmRlZCBieSB0aGVcbiAqIHBhc3NlZCBpbiBgYmVoYXZpb3JzYCBhbmQgYWxzbyBieSBgUG9seW1lci5MZWdhY3lFbGVtZW50TWl4aW5gLlxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzLCBjaGVja1R5cGVzfVxuICovXG5mdW5jdGlvbiBtaXhpbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGtsYXNzKSB7XG4gIGlmICghYmVoYXZpb3JzKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKGtsYXNzKTtcbiAgfVxuICAvLyBOT1RFOiBlbnN1cmUgdGhlIGJhaGV2aW9yIGlzIGV4dGVuZGluZyBhIGNsYXNzIHdpdGhcbiAgLy8gbGVnYWN5IGVsZW1lbnQgYXBpLiBUaGlzIGlzIG5lY2Vzc2FyeSBzaW5jZSBiZWhhdmlvcnMgZXhwZWN0IHRvIGJlIGFibGVcbiAgLy8gdG8gYWNjZXNzIDEueCBsZWdhY3kgYXBpLlxuICBrbGFzcyA9IExlZ2FjeUVsZW1lbnRNaXhpbihrbGFzcyk7XG4gIGlmICghQXJyYXkuaXNBcnJheShiZWhhdmlvcnMpKSB7XG4gICAgYmVoYXZpb3JzID0gW2JlaGF2aW9yc107XG4gIH1cbiAgbGV0IHN1cGVyQmVoYXZpb3JzID0ga2xhc3MucHJvdG90eXBlLmJlaGF2aW9ycztcbiAgLy8gZ2V0IGZsYXR0ZW5lZCwgZGVkdXBlZCBsaXN0IG9mIGJlaGF2aW9ycyAqbm90KiBhbHJlYWR5IG9uIHN1cGVyIGNsYXNzXG4gIGJlaGF2aW9ycyA9IGZsYXR0ZW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBudWxsLCBzdXBlckJlaGF2aW9ycyk7XG4gIC8vIG1peGluIG5ldyBiZWhhdmlvcnNcbiAga2xhc3MgPSBfbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcyk7XG4gIGlmIChzdXBlckJlaGF2aW9ycykge1xuICAgIGJlaGF2aW9ycyA9IHN1cGVyQmVoYXZpb3JzLmNvbmNhdChiZWhhdmlvcnMpO1xuICB9XG4gIC8vIFNldCBiZWhhdmlvcnMgb24gcHJvdG90eXBlIGZvciBCQy4uLlxuICBrbGFzcy5wcm90b3R5cGUuYmVoYXZpb3JzID0gYmVoYXZpb3JzO1xuICByZXR1cm4ga2xhc3M7XG59XG5cbi8vIE5PVEU6XG4vLyAxLnhcbi8vIEJlaGF2aW9ycyB3ZXJlIG1peGVkIGluICppbiByZXZlcnNlIG9yZGVyKiBhbmQgZGUtZHVwZWQgb24gdGhlIGZseS5cbi8vIFRoZSBydWxlIHdhcyB0aGF0IGJlaGF2aW9yIHByb3BlcnRpZXMgd2VyZSBjb3BpZWQgb250byB0aGUgZWxlbWVudFxuLy8gcHJvdG90eXBlIGlmIGFuZCBvbmx5IGlmIHRoZSBwcm9wZXJ0eSBkaWQgbm90IGFscmVhZHkgZXhpc3QuXG4vLyBHaXZlbjogUG9seW1lcnsgYmVoYXZpb3JzOiBbQSwgQiwgQywgQSwgQl19LCBwcm9wZXJ0eSBjb3B5IG9yZGVyIHdhczpcbi8vICgxKSwgQiwgKDIpLCBBLCAoMykgQy4gVGhpcyBtZWFucyBwcm90b3R5cGUgcHJvcGVydGllcyB3aW4gb3ZlclxuLy8gQiBwcm9wZXJ0aWVzIHdpbiBvdmVyIEEgd2luIG92ZXIgQy4gVGhpcyBtaXJyb3JzIHdoYXQgd291bGQgaGFwcGVuXG4vLyB3aXRoIGluaGVyaXRhbmNlIGlmIGVsZW1lbnQgZXh0ZW5kZWQgQiBleHRlbmRlZCBBIGV4dGVuZGVkIEMuXG4vL1xuLy8gQWdhaW4gZ2l2ZW4sIFBvbHltZXJ7IGJlaGF2aW9yczogW0EsIEIsIEMsIEEsIEJdfSwgdGhlIHJlc3VsdGluZ1xuLy8gYGJlaGF2aW9yc2AgYXJyYXkgd2FzIFtDLCBBLCBCXS5cbi8vIEJlaGF2aW9yIGxpZmVjeWNsZSBtZXRob2RzIHdlcmUgY2FsbGVkIGluIGJlaGF2aW9yIGFycmF5IG9yZGVyXG4vLyBmb2xsb3dlZCBieSB0aGUgZWxlbWVudCwgZS5nLiAoMSkgQy5jcmVhdGVkLCAoMikgQS5jcmVhdGVkLFxuLy8gKDMpIEIuY3JlYXRlZCwgKDQpIGVsZW1lbnQuY3JlYXRlZC4gVGhlcmUgd2FzIG5vIHN1cHBvcnQgZm9yXG4vLyBzdXBlciwgYW5kIFwic3VwZXItYmVoYXZpb3JcIiBtZXRob2RzIHdlcmUgY2FsbGFibGUgb25seSBieSBuYW1lKS5cbi8vXG4vLyAyLnhcbi8vIEJlaGF2aW9ycyBhcmUgbWFkZSBpbnRvIHByb3BlciBtaXhpbnMgd2hpY2ggbGl2ZSBpbiB0aGVcbi8vIGVsZW1lbnQncyBwcm90b3R5cGUgY2hhaW4uIEJlaGF2aW9ycyBhcmUgcGxhY2VkIGluIHRoZSBlbGVtZW50IHByb3RvdHlwZVxuLy8gZWxkZXN0IHRvIHlvdW5nZXN0IGFuZCBkZS1kdXBlZCB5b3VuZ2VzdCB0byBvbGRlc3Q6XG4vLyBTbywgZmlyc3QgW0EsIEIsIEMsIEEsIEJdIGJlY29tZXMgW0MsIEEsIEJdIHRoZW4sXG4vLyB0aGUgZWxlbWVudCBwcm90b3R5cGUgYmVjb21lcyAob2xkZXN0KSAoMSkgUG9seW1lci5FbGVtZW50LCAoMikgY2xhc3MoQyksXG4vLyAoMykgY2xhc3MoQSksICg0KSBjbGFzcyhCKSwgKDUpIGNsYXNzKFBvbHltZXIoey4uLn0pKS5cbi8vIFJlc3VsdDpcbi8vIFRoaXMgbWVhbnMgZWxlbWVudCBwcm9wZXJ0aWVzIHdpbiBvdmVyIEIgcHJvcGVydGllcyB3aW4gb3ZlciBBIHdpblxuLy8gb3ZlciBDLiAoc2FtZSBhcyAxLngpXG4vLyBJZiBsaWZlY3ljbGUgaXMgY2FsbGVkIChzdXBlciB0aGVuIG1lKSwgb3JkZXIgaXNcbi8vICgxKSBDLmNyZWF0ZWQsICgyKSBBLmNyZWF0ZWQsICgzKSBCLmNyZWF0ZWQsICg0KSBlbGVtZW50LmNyZWF0ZWRcbi8vIChhZ2FpbiBzYW1lIGFzIDEueClcbmZ1bmN0aW9uIF9taXhpbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGtsYXNzKSB7XG4gIGZvciAobGV0IGk9MDsgaTxiZWhhdmlvcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgYiA9IGJlaGF2aW9yc1tpXTtcbiAgICBpZiAoYikge1xuICAgICAga2xhc3MgPSBBcnJheS5pc0FycmF5KGIpID8gX21peGluQmVoYXZpb3JzKGIsIGtsYXNzKSA6XG4gICAgICAgIEdlbmVyYXRlQ2xhc3NGcm9tSW5mbyhiLCBrbGFzcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBrbGFzcztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5fSBiZWhhdmlvcnMgTGlzdCBvZiBiZWhhdmlvcnMgdG8gZmxhdHRlbi5cbiAqIEBwYXJhbSB7QXJyYXk9fSBsaXN0IFRhcmdldCBsaXN0IHRvIGZsYXR0ZW4gYmVoYXZpb3JzIGludG8uXG4gKiBAcGFyYW0ge0FycmF5PX0gZXhjbHVkZSBMaXN0IG9mIGJlaGF2aW9ycyB0byBleGNsdWRlIGZyb20gdGhlIGxpc3QuXG4gKiBAcmV0dXJuIHshQXJyYXl9IFJldHVybnMgdGhlIGxpc3Qgb2YgZmxhdHRlbmVkIGJlaGF2aW9ycy5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkJlaGF2aW9ycyhiZWhhdmlvcnMsIGxpc3QsIGV4Y2x1ZGUpIHtcbiAgbGlzdCA9IGxpc3QgfHwgW107XG4gIGZvciAobGV0IGk9YmVoYXZpb3JzLmxlbmd0aC0xOyBpID49IDA7IGktLSkge1xuICAgIGxldCBiID0gYmVoYXZpb3JzW2ldO1xuICAgIGlmIChiKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICBmbGF0dGVuQmVoYXZpb3JzKGIsIGxpc3QpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGVkdXBcbiAgICAgICAgaWYgKGxpc3QuaW5kZXhPZihiKSA8IDAgJiYgKCFleGNsdWRlIHx8IGV4Y2x1ZGUuaW5kZXhPZihiKSA8IDApKSB7XG4gICAgICAgICAgbGlzdC51bnNoaWZ0KGIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignYmVoYXZpb3IgaXMgbnVsbCwgY2hlY2sgZm9yIG1pc3Npbmcgb3IgNDA0IGltcG9ydCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGlzdDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFQb2x5bWVySW5pdH0gaW5mbyBQb2x5bWVyIGluZm8gb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IEJhc2UgYmFzZSBjbGFzcyB0byBleHRlbmQgd2l0aCBpbmZvIG9iamVjdFxuICogQHJldHVybiB7ZnVuY3Rpb24obmV3OkhUTUxFbGVtZW50KX0gR2VuZXJhdGVkIGNsYXNzXG4gKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oaW5mbywgQmFzZSkge1xuXG4gIGNsYXNzIFBvbHltZXJHZW5lcmF0ZWQgZXh0ZW5kcyBCYXNlIHtcblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICAgIHJldHVybiBpbmZvLnByb3BlcnRpZXM7XG4gICAgfVxuXG4gICAgc3RhdGljIGdldCBvYnNlcnZlcnMoKSB7XG4gICAgICByZXR1cm4gaW5mby5vYnNlcnZlcnM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHJldHVybiB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgZm9yIHRoaXMgY2xhc3NcbiAgICAgKi9cbiAgICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgICAgLy8gZ2V0IHRlbXBsYXRlIGZpcnN0IGZyb20gYW55IGltcGVyYXRpdmUgc2V0IGluIGBpbmZvLl90ZW1wbGF0ZWBcbiAgICAgIHJldHVybiBpbmZvLl90ZW1wbGF0ZSB8fFxuICAgICAgICAvLyBuZXh0IGxvb2sgaW4gZG9tLW1vZHVsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBlbGVtZW50J3MgaXMuXG4gICAgICAgIERvbU1vZHVsZSAmJiBEb21Nb2R1bGUuaW1wb3J0KHRoaXMuaXMsICd0ZW1wbGF0ZScpIHx8XG4gICAgICAgIC8vIG5leHQgbG9vayBmb3Igc3VwZXJjbGFzcyB0ZW1wbGF0ZSAobm90ZTogdXNlIHN1cGVyY2xhc3Mgc3ltYm9sXG4gICAgICAgIC8vIHRvIGVuc3VyZSBjb3JyZWN0IGB0aGlzLmlzYClcbiAgICAgICAgQmFzZS50ZW1wbGF0ZSB8fFxuICAgICAgICAvLyBmaW5hbGx5IGZhbGwgYmFjayB0byBgX3RlbXBsYXRlYCBpbiBlbGVtZW50J3MgcHJvdG95cGUuXG4gICAgICAgIHRoaXMucHJvdG90eXBlLl90ZW1wbGF0ZSB8fFxuICAgICAgICBudWxsO1xuICAgIH1cblxuICAgIGNyZWF0ZWQoKSB7XG4gICAgICBzdXBlci5jcmVhdGVkKCk7XG4gICAgICBpZiAoaW5mby5jcmVhdGVkKSB7XG4gICAgICAgIGluZm8uY3JlYXRlZC5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9yZWdpc3RlcmVkKCkge1xuICAgICAgc3VwZXIuX3JlZ2lzdGVyZWQoKTtcbiAgICAgIC8qIE5PVEU6IGBiZWZvcmVSZWdpc3RlcmAgaXMgY2FsbGVkIGhlcmUgZm9yIGJjLCBidXQgdGhlIGJlaGF2aW9yXG4gICAgICAgaXMgZGlmZmVyZW50IHRoYW4gaW4gMS54LiBJbiAxLjAsIHRoZSBtZXRob2Qgd2FzIGNhbGxlZCAqYWZ0ZXIqXG4gICAgICAgbWl4aW5nIHByb3RvdHlwZXMgdG9nZXRoZXIgYnV0ICpiZWZvcmUqIHByb2Nlc3Npbmcgb2YgbWV0YS1vYmplY3RzLlxuICAgICAgIEhvd2V2ZXIsIGR5bmFtaWMgZWZmZWN0cyBjYW4gc3RpbGwgYmUgc2V0IGhlcmUgYW5kIGNhbiBiZSBkb25lIGVpdGhlclxuICAgICAgIGluIGBiZWZvcmVSZWdpc3RlcmAgb3IgYHJlZ2lzdGVyZWRgLiBJdCBpcyBubyBsb25nZXIgcG9zc2libGUgdG8gc2V0XG4gICAgICAgYGlzYCBpbiBgYmVmb3JlUmVnaXN0ZXJgIGFzIHlvdSBjb3VsZCBpbiAxLnguXG4gICAgICAqL1xuICAgICAgaWYgKGluZm8uYmVmb3JlUmVnaXN0ZXIpIHtcbiAgICAgICAgaW5mby5iZWZvcmVSZWdpc3Rlci5jYWxsKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICB9XG4gICAgICBpZiAoaW5mby5yZWdpc3RlcmVkKSB7XG4gICAgICAgIGluZm8ucmVnaXN0ZXJlZC5jYWxsKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX2FwcGx5TGlzdGVuZXJzKCkge1xuICAgICAgc3VwZXIuX2FwcGx5TGlzdGVuZXJzKCk7XG4gICAgICBpZiAoaW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgZm9yIChsZXQgbCBpbiBpbmZvLmxpc3RlbmVycykge1xuICAgICAgICAgIHRoaXMuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUodGhpcywgbCwgaW5mby5saXN0ZW5lcnNbbF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gbm90ZTogZXhjZXB0aW9uIHRvIFwic3VwZXIgdGhlbiBtZVwiIHJ1bGU7XG4gICAgLy8gZG8gd29yayBiZWZvcmUgY2FsbGluZyBzdXBlciBzbyB0aGF0IHN1cGVyIGF0dHJpYnV0ZXNcbiAgICAvLyBvbmx5IGFwcGx5IGlmIG5vdCBhbHJlYWR5IHNldC5cbiAgICBfZW5zdXJlQXR0cmlidXRlcygpIHtcbiAgICAgIGlmIChpbmZvLmhvc3RBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAobGV0IGEgaW4gaW5mby5ob3N0QXR0cmlidXRlcykge1xuICAgICAgICAgIHRoaXMuX2Vuc3VyZUF0dHJpYnV0ZShhLCBpbmZvLmhvc3RBdHRyaWJ1dGVzW2FdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3VwZXIuX2Vuc3VyZUF0dHJpYnV0ZXMoKTtcbiAgICB9XG5cbiAgICByZWFkeSgpIHtcbiAgICAgIHN1cGVyLnJlYWR5KCk7XG4gICAgICBpZiAoaW5mby5yZWFkeSkge1xuICAgICAgICBpbmZvLnJlYWR5LmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0YWNoZWQoKSB7XG4gICAgICBzdXBlci5hdHRhY2hlZCgpO1xuICAgICAgaWYgKGluZm8uYXR0YWNoZWQpIHtcbiAgICAgICAgaW5mby5hdHRhY2hlZC5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRldGFjaGVkKCkge1xuICAgICAgc3VwZXIuZGV0YWNoZWQoKTtcbiAgICAgIGlmIChpbmZvLmRldGFjaGVkKSB7XG4gICAgICAgIGluZm8uZGV0YWNoZWQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWQobmFtZSwgb2xkLCB2YWx1ZSk7XG4gICAgICBpZiAoaW5mby5hdHRyaWJ1dGVDaGFuZ2VkKSB7XG4gICAgICAgIGluZm8uYXR0cmlidXRlQ2hhbmdlZC5jYWxsKHRoaXMsIG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgfVxuICAgfVxuICB9XG5cbiAgUG9seW1lckdlbmVyYXRlZC5nZW5lcmF0ZWRGcm9tID0gaW5mbztcblxuICBmb3IgKGxldCBwIGluIGluZm8pIHtcbiAgICAvLyBOT1RFOiBjYW5ub3QgY29weSBgbWV0YVByb3BzYCBtZXRob2RzIG9udG8gcHJvdG90eXBlIGF0IGxlYXN0IGJlY2F1c2VcbiAgICAvLyBgc3VwZXIucmVhZHlgIG11c3QgYmUgY2FsbGVkIGFuZCBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIHVzZXIgZm4uXG4gICAgaWYgKCEocCBpbiBtZXRhUHJvcHMpKSB7XG4gICAgICBsZXQgcGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGluZm8sIHApO1xuICAgICAgaWYgKHBkKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb2x5bWVyR2VuZXJhdGVkLnByb3RvdHlwZSwgcCwgcGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBQb2x5bWVyR2VuZXJhdGVkO1xufVxuXG5leHBvcnQgY29uc3QgQ2xhc3MgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmICghaW5mbykge1xuICAgIGNvbnNvbGUud2FybignUG9seW1lci5DbGFzcyByZXF1aXJlcyBgaW5mb2AgYXJndW1lbnQnKTtcbiAgfVxuICBsZXQga2xhc3MgPSBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oaW5mbywgaW5mby5iZWhhdmlvcnMgP1xuICAgIC8vIG5vdGU6IG1peGluQmVoYXZpb3JzIGVuc3VyZXMgYExlZ2FjeUVsZW1lbnRNaXhpbmAuXG4gICAgbWl4aW5CZWhhdmlvcnMoaW5mby5iZWhhdmlvcnMsIEhUTUxFbGVtZW50KSA6XG4gICAgTGVnYWN5RWxlbWVudE1peGluKEhUTUxFbGVtZW50KSk7XG4gIC8vIGRlY29yYXRlIGtsYXNzIHdpdGggcmVnaXN0cmF0aW9uIGluZm9cbiAga2xhc3MuaXMgPSBpbmZvLmlzO1xuICByZXR1cm4ga2xhc3M7XG59O1xuXG5leHBvcnQgeyBtaXhpbkJlaGF2aW9ycyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L2NsYXNzLmpzXG4vLyBtb2R1bGUgaWQgPSA2MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBhcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwLCBUZW1wbGF0aXplIH0gZnJvbSAnLi4vdXRpbHMvdGVtcGxhdGl6ZS5qcyc7XG5cbmxldCBUZW1wbGF0ZUluc3RhbmNlQmFzZSA9IFRlbXBsYXRlSW5zdGFuY2VCYXNlJDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBAdHlwZWRlZiB7e1xuICogICBfdGVtcGxhdGl6ZXJUZW1wbGF0ZTogSFRNTFRlbXBsYXRlRWxlbWVudCxcbiAqICAgX3BhcmVudE1vZGVsOiBib29sZWFuLFxuICogICBfaW5zdGFuY2VQcm9wczogT2JqZWN0LFxuICogICBfZm9yd2FyZEhvc3RQcm9wVjI6IEZ1bmN0aW9uLFxuICogICBfbm90aWZ5SW5zdGFuY2VQcm9wVjI6IEZ1bmN0aW9uLFxuICogICBjdG9yOiBUZW1wbGF0ZUluc3RhbmNlQmFzZVxuICogfX1cbiAqL1xubGV0IFRlbXBsYXRpemVyVXNlcjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIFRoZSBgUG9seW1lci5UZW1wbGF0aXplcmAgYmVoYXZpb3IgYWRkcyBtZXRob2RzIHRvIGdlbmVyYXRlIGluc3RhbmNlcyBvZlxuICogdGVtcGxhdGVzIHRoYXQgYXJlIGVhY2ggbWFuYWdlZCBieSBhbiBhbm9ueW1vdXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYFxuICogaW5zdGFuY2Ugd2hlcmUgZGF0YS1iaW5kaW5ncyBpbiB0aGUgc3RhbXBlZCB0ZW1wbGF0ZSBjb250ZW50IGFyZSBib3VuZCB0b1xuICogYWNjZXNzb3JzIG9uIGl0c2VsZi5cbiAqXG4gKiBUaGlzIGJlaGF2aW9yIGlzIHByb3ZpZGVkIGluIFBvbHltZXIgMi54IGFzIGEgaHlicmlkLWVsZW1lbnQgY29udmVuaWVuY2VcbiAqIG9ubHkuICBGb3Igbm9uLWh5YnJpZCB1c2FnZSwgdGhlIGBQb2x5bWVyLlRlbXBsYXRpemVgIGxpYnJhcnlcbiAqIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gR2V0IGEgdGVtcGxhdGUgZnJvbSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gKiAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICogICAgIC8vIFByZXBhcmUgdGhlIHRlbXBsYXRlXG4gKiAgICAgdGhpcy50ZW1wbGF0aXplKHRlbXBsYXRlKTtcbiAqICAgICAvLyBJbnN0YW5jZSB0aGUgdGVtcGxhdGUgd2l0aCBhbiBpbml0aWFsIGRhdGEgbW9kZWxcbiAqICAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLnN0YW1wKHtteVByb3A6ICdpbml0aWFsJ30pO1xuICogICAgIC8vIEluc2VydCB0aGUgaW5zdGFuY2UncyBET00gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICogICAgIFBvbHltZXIuZG9tKHRoaXMpLmFwcGVuZENoaWxkKGluc3RhbmNlLnJvb3QpO1xuICogICAgIC8vIENoYW5naW5nIGEgcHJvcGVydHkgb24gdGhlIGluc3RhbmNlIHdpbGwgcHJvcGFnYXRlIHRvIGJpbmRpbmdzXG4gKiAgICAgLy8gaW4gdGhlIHRlbXBsYXRlXG4gKiAgICAgaW5zdGFuY2UubXlQcm9wID0gJ25ldyB2YWx1ZSc7XG4gKlxuICogVXNlcnMgb2YgYFRlbXBsYXRpemVyYCBtYXkgbmVlZCB0byBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBhYnN0cmFjdFxuICogQVBJJ3MgdG8gZGV0ZXJtaW5lIGhvdyBwcm9wZXJ0aWVzIGFuZCBwYXRocyBmcm9tIHRoZSBob3N0IHNob3VsZCBiZVxuICogZm9yd2FyZGVkIGludG8gdG8gaW5zdGFuY2VzOlxuICpcbiAqICAgICBfZm9yd2FyZEhvc3RQcm9wVjI6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKVxuICpcbiAqIExpa2V3aXNlLCB1c2VycyBtYXkgaW1wbGVtZW50IHRoZXNlIGFkZGl0aW9uYWwgYWJzdHJhY3QgQVBJJ3MgdG8gZGV0ZXJtaW5lXG4gKiBob3cgaW5zdGFuY2Utc3BlY2lmaWMgcHJvcGVydGllcyB0aGF0IGNoYW5nZSBvbiB0aGUgaW5zdGFuY2Ugc2hvdWxkIGJlXG4gKiBmb3J3YXJkZWQgb3V0IHRvIHRoZSBob3N0LCBpZiBuZWNlc3NhcnkuXG4gKlxuICogICAgIF9ub3RpZnlJbnN0YW5jZVByb3BWMjogZnVuY3Rpb24oaW5zdCwgcHJvcCwgdmFsdWUpXG4gKlxuICogSW4gb3JkZXIgdG8gZGV0ZXJtaW5lIHdoaWNoIHByb3BlcnRpZXMgYXJlIGluc3RhbmNlLXNwZWNpZmljIGFuZCByZXF1aXJlXG4gKiBjdXN0b20gbm90aWZpY2F0aW9uIHZpYSBgX25vdGlmeUluc3RhbmNlUHJvcGAsIGRlZmluZSBhbiBgX2luc3RhbmNlUHJvcHNgXG4gKiBvYmplY3QgY29udGFpbmluZyBrZXlzIGZvciBlYWNoIGluc3RhbmNlIHByb3AsIGZvciBleGFtcGxlOlxuICpcbiAqICAgICBfaW5zdGFuY2VQcm9wczoge1xuICogICAgICAgaXRlbTogdHJ1ZSxcbiAqICAgICAgIGluZGV4OiB0cnVlXG4gKiAgICAgfVxuICpcbiAqIEFueSBwcm9wZXJ0aWVzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIHRoYXQgYXJlIG5vdCBkZWZpbmVkIGluIF9pbnN0YW5jZVByb3BcbiAqIHdpbGwgYmUgZm9yd2FyZGVkIG91dCB0byB0aGUgVGVtcGxhdGl6ZSBgb3duZXJgIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogVXNlcnMgbWF5IGFsc28gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgYWJzdHJhY3QgZnVuY3Rpb24gdG8gc2hvdyBvclxuICogaGlkZSBhbnkgRE9NIGdlbmVyYXRlZCB1c2luZyBgc3RhbXBgOlxuICpcbiAqICAgICBfc2hvd0hpZGVDaGlsZHJlbjogZnVuY3Rpb24oc2hvdWxkSGlkZSlcbiAqXG4gKiBOb3RlIHRoYXQgc29tZSBjYWxsYmFja3MgYXJlIHN1ZmZpeGVkIHdpdGggYFYyYCBpbiB0aGUgUG9seW1lciAyLnggYmVoYXZpb3JcbiAqIGFzIHRoZSBpbXBsZW1lbnRhdGlvbnMgd2lsbCBuZWVkIHRvIGRpZmZlciBmcm9tIHRoZSBjYWxsYmFja3MgcmVxdWlyZWRcbiAqIGJ5IHRoZSAxLnggVGVtcGxhdGl6ZXIgQVBJIGR1ZSB0byBjaGFuZ2VzIGluIHRoZSBgVGVtcGxhdGVJbnN0YW5jZWAgQVBJXG4gKiBiZXR3ZWVuIHZlcnNpb25zIDEueCBhbmQgMi54LlxuICpcbiAqIEBwb2x5bWVyQmVoYXZpb3JcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmxldCBUZW1wbGF0aXplciA9IHtcblxuICAvKipcbiAgICogR2VuZXJhdGVzIGFuIGFub255bW91cyBgVGVtcGxhdGVJbnN0YW5jZWAgY2xhc3MgKHN0b3JlZCBhcyBgdGhpcy5jdG9yYClcbiAgICogZm9yIHRoZSBwcm92aWRlZCB0ZW1wbGF0ZS4gIFRoaXMgbWV0aG9kIHNob3VsZCBiZSBjYWxsZWQgb25jZSBwZXJcbiAgICogdGVtcGxhdGUgdG8gcHJlcGFyZSBhbiBlbGVtZW50IGZvciBzdGFtcGluZyB0aGUgdGVtcGxhdGUsIGZvbGxvd2VkXG4gICAqIGJ5IGBzdGFtcGAgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb2YgdGhlIHRlbXBsYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHByZXBhcmVcbiAgICogQHBhcmFtIHtib29sZWFuPX0gbXV0YWJsZURhdGEgV2hlbiBgdHJ1ZWAsIHRoZSBnZW5lcmF0ZWQgY2xhc3Mgd2lsbCBza2lwXG4gICAqICAgc3RyaWN0IGRpcnR5LWNoZWNraW5nIGZvciBvYmplY3RzIGFuZCBhcnJheXMgKGFsd2F5cyBjb25zaWRlciB0aGVtIHRvXG4gICAqICAgYmUgXCJkaXJ0eVwiKS4gRGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqIEB0aGlzIHtUZW1wbGF0aXplclVzZXJ9XG4gICAqL1xuICB0ZW1wbGF0aXplKHRlbXBsYXRlLCBtdXRhYmxlRGF0YSkge1xuICAgIHRoaXMuX3RlbXBsYXRpemVyVGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB0aGlzLmN0b3IgPSBUZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgIG11dGFibGVEYXRhOiBCb29sZWFuKG11dGFibGVEYXRhKSxcbiAgICAgIHBhcmVudE1vZGVsOiB0aGlzLl9wYXJlbnRNb2RlbCxcbiAgICAgIGluc3RhbmNlUHJvcHM6IHRoaXMuX2luc3RhbmNlUHJvcHMsXG4gICAgICBmb3J3YXJkSG9zdFByb3A6IHRoaXMuX2ZvcndhcmRIb3N0UHJvcFYyLFxuICAgICAgbm90aWZ5SW5zdGFuY2VQcm9wOiB0aGlzLl9ub3RpZnlJbnN0YW5jZVByb3BWMlxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSB0ZW1wbGF0ZSBwcmVwYXJlZCBieSBgdGVtcGxhdGl6ZWAuICBUaGUgb2JqZWN0XG4gICAqIHJldHVybmVkIGlzIGFuIGluc3RhbmNlIG9mIHRoZSBhbm9ueW1vdXMgY2xhc3MgZ2VuZXJhdGVkIGJ5IGB0ZW1wbGF0aXplYFxuICAgKiB3aG9zZSBgcm9vdGAgcHJvcGVydHkgaXMgYSBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIG5ld2x5IGNsb25lZFxuICAgKiB0ZW1wbGF0ZSBjb250ZW50LCBhbmQgd2hpY2ggaGFzIHByb3BlcnR5IGFjY2Vzc29ycyBjb3JyZXNwb25kaW5nIHRvXG4gICAqIHByb3BlcnRpZXMgcmVmZXJlbmNlZCBpbiB0ZW1wbGF0ZSBiaW5kaW5ncy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBtb2RlbCBPYmplY3QgY29udGFpbmluZyBpbml0aWFsIHByb3BlcnR5IHZhbHVlcyB0b1xuICAgKiAgIHBvcHVsYXRlIGludG8gdGhlIHRlbXBsYXRlIGJpbmRpbmdzLlxuICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gUmV0dXJucyB0aGUgY3JlYXRlZCBpbnN0YW5jZSBvZlxuICAgKiB0aGUgdGVtcGxhdGUgcHJlcGFyZWQgYnkgYHRlbXBsYXRpemVgLlxuICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgKi9cbiAgc3RhbXAobW9kZWwpIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuY3Rvcihtb2RlbCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiAoYFRlbXBsYXRlSW5zdGFuY2VgKSBhc3NvY2lhdGVkIHdpdGhcbiAgICogYSBnaXZlbiBlbGVtZW50LCB3aGljaCBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZVxuICAgKiBpbnN0YW5jZSB0aGUgZWxlbWVudCBpcyBjb250YWluZWQgaW4uICBBIHRlbXBsYXRlIG1vZGVsIHNob3VsZCBiZSB1c2VkXG4gICAqIHRvIG1hbmlwdWxhdGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhpcyB0ZW1wbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIGEgdGVtcGxhdGUgbW9kZWwuXG4gICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBNb2RlbCByZXByZXNlbnRpbmcgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gICAqICAgdGhlIGVsZW1lbnQuXG4gICAqIEB0aGlzIHtUZW1wbGF0aXplclVzZXJ9XG4gICAqL1xuICBtb2RlbEZvckVsZW1lbnQoZWwpIHtcbiAgICByZXR1cm4gVGVtcGxhdGl6ZS5tb2RlbEZvckVsZW1lbnQodGhpcy5fdGVtcGxhdGl6ZXJUZW1wbGF0ZSwgZWwpO1xuICB9XG59O1xuXG5leHBvcnQgeyBUZW1wbGF0aXplciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlFZmZlY3RzIH0gZnJvbSAnLi4vbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanMnO1xuaW1wb3J0IHsgT3B0aW9uYWxNdXRhYmxlRGF0YSB9IGZyb20gJy4uL21peGlucy9tdXRhYmxlLWRhdGEuanMnO1xuaW1wb3J0IHsgR2VzdHVyZUV2ZW50TGlzdGVuZXJzIH0gZnJvbSAnLi4vbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmpzJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtIVE1MRWxlbWVudH1cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX09wdGlvbmFsTXV0YWJsZURhdGF9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9HZXN0dXJlRXZlbnRMaXN0ZW5lcnN9XG4gKi9cbmNvbnN0IGRvbUJpbmRCYXNlID1cbiAgR2VzdHVyZUV2ZW50TGlzdGVuZXJzKFxuICAgIE9wdGlvbmFsTXV0YWJsZURhdGEoXG4gICAgICBQcm9wZXJ0eUVmZmVjdHMoSFRNTEVsZW1lbnQpKSk7XG5cbi8qKlxuICogQ3VzdG9tIGVsZW1lbnQgdG8gYWxsb3cgdXNpbmcgUG9seW1lcidzIHRlbXBsYXRlIGZlYXR1cmVzIChkYXRhIGJpbmRpbmcsXG4gKiBkZWNsYXJhdGl2ZSBldmVudCBsaXN0ZW5lcnMsIGV0Yy4pIGluIHRoZSBtYWluIGRvY3VtZW50IHdpdGhvdXQgZGVmaW5pbmdcbiAqIGEgbmV3IGN1c3RvbSBlbGVtZW50LlxuICpcbiAqIGA8dGVtcGxhdGU+YCB0YWdzIHV0aWxpemluZyBiaW5kaW5ncyBtYXkgYmUgd3JhcHBlZCB3aXRoIHRoZSBgPGRvbS1iaW5kPmBcbiAqIGVsZW1lbnQsIHdoaWNoIHdpbGwgaW1tZWRpYXRlbHkgc3RhbXAgdGhlIHdyYXBwZWQgdGVtcGxhdGUgaW50byB0aGUgbWFpblxuICogZG9jdW1lbnQgYW5kIGJpbmQgZWxlbWVudHMgdG8gdGhlIGBkb20tYmluZGAgZWxlbWVudCBpdHNlbGYgYXMgdGhlXG4gKiBiaW5kaW5nIHNjb3BlLlxuICpcbiAqIEBwb2x5bWVyXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c1xuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5HZXN0dXJlRXZlbnRMaXN0ZW5lcnNcbiAqIEBleHRlbmRzIHtkb21CaW5kQmFzZX1cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0byBhbGxvdyB1c2luZyBQb2x5bWVyJ3MgdGVtcGxhdGUgZmVhdHVyZXMgKGRhdGFcbiAqICAgYmluZGluZywgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLCBldGMuKSBpbiB0aGUgbWFpbiBkb2N1bWVudC5cbiAqL1xuY2xhc3MgRG9tQmluZCBleHRlbmRzIGRvbUJpbmRCYXNlIHtcblxuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHsgcmV0dXJuIFsnbXV0YWJsZS1kYXRhJ107IH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMucm9vdCA9IG51bGw7XG4gICAgdGhpcy4kID0gbnVsbDtcbiAgICB0aGlzLl9fY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgLy8gYXNzdW1lcyBvbmx5IG9uZSBvYnNlcnZlZCBhdHRyaWJ1dGVcbiAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKCkge1xuICAgIHRoaXMubXV0YWJsZURhdGEgPSB0cnVlO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5yZW5kZXIoKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuX19yZW1vdmVDaGlsZHJlbigpO1xuICB9XG5cbiAgX19pbnNlcnRDaGlsZHJlbigpIHtcbiAgICB0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMucm9vdCwgdGhpcyk7XG4gIH1cblxuICBfX3JlbW92ZUNoaWxkcmVuKCkge1xuICAgIGlmICh0aGlzLl9fY2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9fY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5yb290LmFwcGVuZENoaWxkKHRoaXMuX19jaGlsZHJlbltpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIFRoaXMgaXMgdHlwaWNhbGx5IG9ubHlcbiAgICogbmVjZXNzYXJ5IHRvIGNhbGwgaWYgSFRNTEltcG9ydHMgd2l0aCB0aGUgYXN5bmMgYXR0cmlidXRlIGFyZSB1c2VkLlxuICAgKi9cbiAgcmVuZGVyKCkge1xuICAgIGxldCB0ZW1wbGF0ZTtcbiAgICBpZiAoIXRoaXMuX19jaGlsZHJlbikge1xuICAgICAgdGVtcGxhdGUgPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRlbXBsYXRlIHx8IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSk7XG4gICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIC8vIFdhaXQgdW50aWwgY2hpbGRMaXN0IGNoYW5nZXMgYW5kIHRlbXBsYXRlIHNob3VsZCBiZSB0aGVyZSBieSB0aGVuXG4gICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8odGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKTtcbiAgICAgICAgICBpZiAodGVtcGxhdGUpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLWJpbmQgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMucm9vdCA9IHRoaXMuX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgdGhpcy4kID0gdGhpcy5yb290LiQ7XG4gICAgICB0aGlzLl9fY2hpbGRyZW4gPSBbXTtcbiAgICAgIGZvciAobGV0IG49dGhpcy5yb290LmZpcnN0Q2hpbGQ7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgICB0aGlzLl9fY2hpbGRyZW5bdGhpcy5fX2NoaWxkcmVuLmxlbmd0aF0gPSBuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgIH1cbiAgICB0aGlzLl9faW5zZXJ0Q2hpbGRyZW4oKTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdkb20tY2hhbmdlJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgfSkpO1xuICB9XG5cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdkb20tYmluZCcsIERvbUJpbmQpO1xuXG5leHBvcnQgeyBEb21CaW5kIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tYmluZC5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uLy4uL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBhcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwLCBUZW1wbGF0aXplIH0gZnJvbSAnLi4vdXRpbHMvdGVtcGxhdGl6ZS5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgeyBlbnF1ZXVlRGVib3VuY2VyLCBmbHVzaCB9IGZyb20gJy4uL3V0aWxzL2ZsdXNoLmpzJztcbmltcG9ydCB7IE9wdGlvbmFsTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcbmltcG9ydCB7IG1hdGNoZXMsIHRyYW5zbGF0ZSB9IGZyb20gJy4uL3V0aWxzL3BhdGguanMnO1xuaW1wb3J0IHsgdGltZU91dCwgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuXG5sZXQgVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICogQGV4dGVuZHMge1BvbHltZXIuRWxlbWVudH1cbiAqL1xuY29uc3QgZG9tUmVwZWF0QmFzZSA9IE9wdGlvbmFsTXV0YWJsZURhdGEoRWxlbWVudCk7XG5cbi8qKlxuICogVGhlIGA8ZG9tLXJlcGVhdD5gIGVsZW1lbnQgd2lsbCBhdXRvbWF0aWNhbGx5IHN0YW1wIGFuZCBiaW5kcyBvbmUgaW5zdGFuY2VcbiAqIG9mIHRlbXBsYXRlIGNvbnRlbnQgdG8gZWFjaCBvYmplY3QgaW4gYSB1c2VyLXByb3ZpZGVkIGFycmF5LlxuICogYGRvbS1yZXBlYXRgIGFjY2VwdHMgYW4gYGl0ZW1zYCBwcm9wZXJ0eSwgYW5kIG9uZSBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGVcbiAqIGlzIHN0YW1wZWQgZm9yIGVhY2ggaXRlbSBpbnRvIHRoZSBET00gYXQgdGhlIGxvY2F0aW9uIG9mIHRoZSBgZG9tLXJlcGVhdGBcbiAqIGVsZW1lbnQuICBUaGUgYGl0ZW1gIHByb3BlcnR5IHdpbGwgYmUgc2V0IG9uIGVhY2ggaW5zdGFuY2UncyBiaW5kaW5nXG4gKiBzY29wZSwgdGh1cyB0ZW1wbGF0ZXMgc2hvdWxkIGJpbmQgdG8gc3ViLXByb3BlcnRpZXMgb2YgYGl0ZW1gLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgaHRtbFxuICogPGRvbS1tb2R1bGUgaWQ9XCJlbXBsb3llZS1saXN0XCI+XG4gKlxuICogICA8dGVtcGxhdGU+XG4gKlxuICogICAgIDxkaXY+IEVtcGxveWVlIGxpc3Q6IDwvZGl2PlxuICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIj5cbiAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgPC90ZW1wbGF0ZT5cbiAqXG4gKiAgIDwvdGVtcGxhdGU+XG4gKlxuICogICA8c2NyaXB0PlxuICogICAgIFBvbHltZXIoe1xuICogICAgICAgaXM6ICdlbXBsb3llZS1saXN0JyxcbiAqICAgICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAqICAgICAgICAgdGhpcy5lbXBsb3llZXMgPSBbXG4gKiAgICAgICAgICAgICB7Zmlyc3Q6ICdCb2InLCBsYXN0OiAnU21pdGgnfSxcbiAqICAgICAgICAgICAgIHtmaXJzdDogJ1NhbGx5JywgbGFzdDogJ0pvaG5zb24nfSxcbiAqICAgICAgICAgICAgIC4uLlxuICogICAgICAgICBdO1xuICogICAgICAgfVxuICogICAgIH0pO1xuICogICA8IC9zY3JpcHQ+XG4gKlxuICogPC9kb20tbW9kdWxlPlxuICogYGBgXG4gKlxuICogTm90aWZpY2F0aW9ucyBmb3IgY2hhbmdlcyB0byBpdGVtcyBzdWItcHJvcGVydGllcyB3aWxsIGJlIGZvcndhcmRlZCB0byB0ZW1wbGF0ZVxuICogaW5zdGFuY2VzLCB3aGljaCB3aWxsIHVwZGF0ZSB2aWEgdGhlIG5vcm1hbCBzdHJ1Y3R1cmVkIGRhdGEgbm90aWZpY2F0aW9uIHN5c3RlbS5cbiAqXG4gKiBNdXRhdGlvbnMgdG8gdGhlIGBpdGVtc2AgYXJyYXkgaXRzZWxmIHNob3VsZCBiZSBtYWRlIHVzaW5nIHRoZSBBcnJheVxuICogbXV0YXRpb24gQVBJJ3Mgb24gYFBvbHltZXIuQmFzZWAgKGBwdXNoYCwgYHBvcGAsIGBzcGxpY2VgLCBgc2hpZnRgLFxuICogYHVuc2hpZnRgKSwgYW5kIHRlbXBsYXRlIGluc3RhbmNlcyB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBkYXRhIGluIHRoZVxuICogYXJyYXkuXG4gKlxuICogRXZlbnRzIGNhdWdodCBieSBldmVudCBoYW5kbGVycyB3aXRoaW4gdGhlIGBkb20tcmVwZWF0YCB0ZW1wbGF0ZSB3aWxsIGJlXG4gKiBkZWNvcmF0ZWQgd2l0aCBhIGBtb2RlbGAgcHJvcGVydHksIHdoaWNoIHJlcHJlc2VudHMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yXG4gKiBlYWNoIHRlbXBsYXRlIGluc3RhbmNlLiAgVGhlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mIFBvbHltZXIuQmFzZSwgYW5kIHNob3VsZFxuICogYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgb24gdGhlIGluc3RhbmNlLCBmb3IgZXhhbXBsZVxuICogYGV2ZW50Lm1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7YC5cbiAqXG4gKiBBbHRlcm5hdGl2ZWx5LCB0aGUgbW9kZWwgZm9yIGEgdGVtcGxhdGUgaW5zdGFuY2UgZm9yIGFuIGVsZW1lbnQgc3RhbXBlZCBieVxuICogYSBgZG9tLXJlcGVhdGAgY2FuIGJlIG9idGFpbmVkIHVzaW5nIHRoZSBgbW9kZWxGb3JFbGVtZW50YCBBUEkgb24gdGhlXG4gKiBgZG9tLXJlcGVhdGAgdGhhdCBzdGFtcGVkIGl0LCBmb3IgZXhhbXBsZVxuICogYHRoaXMuJC5kb21SZXBlYXQubW9kZWxGb3JFbGVtZW50KGV2ZW50LnRhcmdldCkuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtgLlxuICogVGhpcyBtYXkgYmUgdXNlZnVsIGZvciBtYW5pcHVsYXRpbmcgaW5zdGFuY2UgZGF0YSBvZiBldmVudCB0YXJnZXRzIG9idGFpbmVkXG4gKiBieSBldmVudCBoYW5kbGVycyBvbiBwYXJlbnRzIG9mIHRoZSBgZG9tLXJlcGVhdGAgKGV2ZW50IGRlbGVnYXRpb24pLlxuICpcbiAqIEEgdmlldy1zcGVjaWZpYyBmaWx0ZXIvc29ydCBtYXkgYmUgYXBwbGllZCB0byBlYWNoIGBkb20tcmVwZWF0YCBieSBzdXBwbHlpbmcgYVxuICogYGZpbHRlcmAgYW5kL29yIGBzb3J0YCBwcm9wZXJ0eS4gIFRoaXMgbWF5IGJlIGEgc3RyaW5nIHRoYXQgbmFtZXMgYSBmdW5jdGlvbiBvblxuICogdGhlIGhvc3QsIG9yIGEgZnVuY3Rpb24gbWF5IGJlIGFzc2lnbmVkIHRvIHRoZSBwcm9wZXJ0eSBkaXJlY3RseS4gIFRoZSBmdW5jdGlvbnNcbiAqIHNob3VsZCBpbXBsZW1lbnRlZCBmb2xsb3dpbmcgdGhlIHN0YW5kYXJkIGBBcnJheWAgZmlsdGVyL3NvcnQgQVBJLlxuICpcbiAqIEluIG9yZGVyIHRvIHJlLXJ1biB0aGUgZmlsdGVyIG9yIHNvcnQgZnVuY3Rpb25zIGJhc2VkIG9uIGNoYW5nZXMgdG8gc3ViLWZpZWxkc1xuICogb2YgYGl0ZW1zYCwgdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eSBtYXkgYmUgc2V0IGFzIGEgc3BhY2Utc2VwYXJhdGVkIGxpc3Qgb2ZcbiAqIGBpdGVtYCBzdWItZmllbGRzIHRoYXQgc2hvdWxkIGNhdXNlIGEgcmUtZmlsdGVyL3NvcnQgd2hlbiBtb2RpZmllZC4gIElmXG4gKiB0aGUgZmlsdGVyIG9yIHNvcnQgZnVuY3Rpb24gZGVwZW5kcyBvbiBwcm9wZXJ0aWVzIG5vdCBjb250YWluZWQgaW4gYGl0ZW1zYCxcbiAqIHRoZSB1c2VyIHNob3VsZCBvYnNlcnZlIGNoYW5nZXMgdG8gdGhvc2UgcHJvcGVydGllcyBhbmQgY2FsbCBgcmVuZGVyYCB0byB1cGRhdGVcbiAqIHRoZSB2aWV3IGJhc2VkIG9uIHRoZSBkZXBlbmRlbmN5IGNoYW5nZS5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZm9yIGFuIGBkb20tcmVwZWF0YCB3aXRoIGEgZmlsdGVyIG9mIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogYGBganNcbiAqIGlzRW5naW5lZXI6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAqICAgICByZXR1cm4gaXRlbS50eXBlID09ICdlbmdpbmVlcicgfHwgaXRlbS5tYW5hZ2VyLnR5cGUgPT0gJ2VuZ2luZWVyJztcbiAqIH1cbiAqIGBgYFxuICpcbiAqIFRoZW4gdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eSBzaG91bGQgYmUgY29uZmlndXJlZCBhcyBmb2xsb3dzOlxuICpcbiAqIGBgYGh0bWxcbiAqIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIlxuICogICAgICAgICAgIGZpbHRlcj1cImlzRW5naW5lZXJcIiBvYnNlcnZlPVwidHlwZSBtYW5hZ2VyLnR5cGVcIj5cbiAqIGBgYFxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAcG9seW1lclxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBleHRlbmRzIHtkb21SZXBlYXRCYXNlfVxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLk9wdGlvbmFsTXV0YWJsZURhdGFcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGZvciBzdGFtcGluZyBpbnN0YW5jZSBvZiBhIHRlbXBsYXRlIGJvdW5kIHRvXG4gKiAgIGl0ZW1zIGluIGFuIGFycmF5LlxuICovXG5jbGFzcyBEb21SZXBlYXQgZXh0ZW5kcyBkb21SZXBlYXRCYXNlIHtcblxuICAvLyBOb3QgbmVlZGVkIHRvIGZpbmQgdGVtcGxhdGU7IGNhbiBiZSByZW1vdmVkIG9uY2UgdGhlIGFuYWx5emVyXG4gIC8vIGNhbiBmaW5kIHRoZSB0YWcgbmFtZSBmcm9tIGN1c3RvbUVsZW1lbnRzLmRlZmluZSBjYWxsXG4gIHN0YXRpYyBnZXQgaXMoKSB7IHJldHVybiAnZG9tLXJlcGVhdCc7IH1cblxuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW5ldmVyIERPTSBpcyBhZGRlZCBvciByZW1vdmVkIGJ5IHRoaXMgdGVtcGxhdGUgKGJ5XG4gICAgICogZGVmYXVsdCwgcmVuZGVyaW5nIG9jY3VycyBsYXppbHkpLiAgVG8gZm9yY2UgaW1tZWRpYXRlIHJlbmRlcmluZywgY2FsbFxuICAgICAqIGByZW5kZXJgLlxuICAgICAqXG4gICAgICogQGV2ZW50IGRvbS1jaGFuZ2VcbiAgICAgKi9cbiAgICByZXR1cm4ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaXRlbXMgZGV0ZXJtaW5pbmcgaG93IG1hbnkgaW5zdGFuY2VzIG9mIHRoZSB0ZW1wbGF0ZVxuICAgICAgICogdG8gc3RhbXAgYW5kIHRoYXQgdGhhdCBlYWNoIHRlbXBsYXRlIGluc3RhbmNlIHNob3VsZCBiaW5kIHRvLlxuICAgICAgICovXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiBBcnJheVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgYXJyYXlcbiAgICAgICAqIGVsZW1lbnQgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAgICAgKi9cbiAgICAgIGFzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpdGVtJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBUaGUgbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gYWRkIHRvIHRoZSBiaW5kaW5nIHNjb3BlIHdpdGggdGhlIGluZGV4XG4gICAgICAgKiBvZiB0aGUgaW5zdGFuY2UgaW4gdGhlIHNvcnRlZCBhbmQgZmlsdGVyZWQgbGlzdCBvZiByZW5kZXJlZCBpdGVtcy5cbiAgICAgICAqIE5vdGUsIGZvciB0aGUgaW5kZXggaW4gdGhlIGB0aGlzLml0ZW1zYCBhcnJheSwgdXNlIHRoZSB2YWx1ZSBvZiB0aGVcbiAgICAgICAqIGBpdGVtc0luZGV4QXNgIHByb3BlcnR5LlxuICAgICAgICovXG4gICAgICBpbmRleEFzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpbmRleCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSB3aXRoIHRoZSBpbmRleFxuICAgICAgICogb2YgdGhlIGluc3RhbmNlIGluIHRoZSBgdGhpcy5pdGVtc2AgYXJyYXkuIE5vdGUsIGZvciB0aGUgaW5kZXggb2ZcbiAgICAgICAqIHRoaXMgaW5zdGFuY2UgaW4gdGhlIHNvcnRlZCBhbmQgZmlsdGVyZWQgbGlzdCBvZiByZW5kZXJlZCBpdGVtcyxcbiAgICAgICAqIHVzZSB0aGUgdmFsdWUgb2YgdGhlIGBpbmRleEFzYCBwcm9wZXJ0eS5cbiAgICAgICAqL1xuICAgICAgaXRlbXNJbmRleEFzOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgdmFsdWU6ICdpdGVtc0luZGV4J1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGRldGVybWluZSB0aGUgc29ydCBvcmRlciBvZiB0aGUgaXRlbXMuICBUaGlzXG4gICAgICAgKiBwcm9wZXJ0eSBzaG91bGQgZWl0aGVyIGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLCBpbmRpY2F0aW5nIGEgbWV0aG9kXG4gICAgICAgKiBuYW1lIG9uIHRoZSBlbGVtZW50J3MgaG9zdCwgb3IgZWxzZSBiZSBhbiBhY3R1YWwgZnVuY3Rpb24uICBUaGVcbiAgICAgICAqIGZ1bmN0aW9uIHNob3VsZCBtYXRjaCB0aGUgc29ydCBmdW5jdGlvbiBwYXNzZWQgdG8gYEFycmF5LnNvcnRgLlxuICAgICAgICogVXNpbmcgYSBzb3J0IGZ1bmN0aW9uIGhhcyBubyBlZmZlY3Qgb24gdGhlIHVuZGVybHlpbmcgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAqL1xuICAgICAgc29ydDoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX3NvcnRDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZmlsdGVyIGl0ZW1zIG91dCBvZiB0aGUgdmlldy4gIFRoaXNcbiAgICAgICAqIHByb3BlcnR5IHNob3VsZCBlaXRoZXIgYmUgcHJvdmlkZWQgYXMgYSBzdHJpbmcsIGluZGljYXRpbmcgYSBtZXRob2RcbiAgICAgICAqIG5hbWUgb24gdGhlIGVsZW1lbnQncyBob3N0LCBvciBlbHNlIGJlIGFuIGFjdHVhbCBmdW5jdGlvbi4gIFRoZVxuICAgICAgICogZnVuY3Rpb24gc2hvdWxkIG1hdGNoIHRoZSBzb3J0IGZ1bmN0aW9uIHBhc3NlZCB0byBgQXJyYXkuZmlsdGVyYC5cbiAgICAgICAqIFVzaW5nIGEgZmlsdGVyIGZ1bmN0aW9uIGhhcyBubyBlZmZlY3Qgb24gdGhlIHVuZGVybHlpbmcgYGl0ZW1zYCBhcnJheS5cbiAgICAgICAqL1xuICAgICAgZmlsdGVyOiB7XG4gICAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgICBvYnNlcnZlcjogJ19fZmlsdGVyQ2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB1c2luZyBhIGBmaWx0ZXJgIG9yIGBzb3J0YCBmdW5jdGlvbiwgdGhlIGBvYnNlcnZlYCBwcm9wZXJ0eVxuICAgICAgICogc2hvdWxkIGJlIHNldCB0byBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mIHRoZSBuYW1lcyBvZiBpdGVtXG4gICAgICAgKiBzdWItZmllbGRzIHRoYXQgc2hvdWxkIHRyaWdnZXIgYSByZS1zb3J0IG9yIHJlLWZpbHRlciB3aGVuIGNoYW5nZWQuXG4gICAgICAgKiBUaGVzZSBzaG91bGQgZ2VuZXJhbGx5IGJlIGZpZWxkcyBvZiBgaXRlbWAgdGhhdCB0aGUgc29ydCBvciBmaWx0ZXJcbiAgICAgICAqIGZ1bmN0aW9uIGRlcGVuZHMgb24uXG4gICAgICAgKi9cbiAgICAgIG9ic2VydmU6IHtcbiAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICBvYnNlcnZlcjogJ19fb2JzZXJ2ZUNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdXNpbmcgYSBgZmlsdGVyYCBvciBgc29ydGAgZnVuY3Rpb24sIHRoZSBgZGVsYXlgIHByb3BlcnR5XG4gICAgICAgKiBkZXRlcm1pbmVzIGEgZGVib3VuY2UgdGltZSBhZnRlciBhIGNoYW5nZSB0byBvYnNlcnZlZCBpdGVtXG4gICAgICAgKiBwcm9wZXJ0aWVzIHRoYXQgbXVzdCBwYXNzIGJlZm9yZSB0aGUgZmlsdGVyIG9yIHNvcnQgaXMgcmUtcnVuLlxuICAgICAgICogVGhpcyBpcyB1c2VmdWwgaW4gcmF0ZS1saW1pdGluZyBzaHVmZmluZyBvZiB0aGUgdmlldyB3aGVuXG4gICAgICAgKiBpdGVtIGNoYW5nZXMgbWF5IGJlIGZyZXF1ZW50LlxuICAgICAgICovXG4gICAgICBkZWxheTogTnVtYmVyLFxuXG4gICAgICAvKipcbiAgICAgICAqIENvdW50IG9mIGN1cnJlbnRseSByZW5kZXJlZCBpdGVtcyBhZnRlciBgZmlsdGVyYCAoaWYgYW55KSBoYXMgYmVlbiBhcHBsaWVkLlxuICAgICAgICogSWYgXCJjaHVua2luZyBtb2RlXCIgaXMgZW5hYmxlZCwgYHJlbmRlcmVkSXRlbUNvdW50YCBpcyB1cGRhdGVkIGVhY2ggdGltZSBhXG4gICAgICAgKiBzZXQgb2YgdGVtcGxhdGUgaW5zdGFuY2VzIGlzIHJlbmRlcmVkLlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgcmVuZGVyZWRJdGVtQ291bnQ6IHtcbiAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICBub3RpZnk6IHRydWUsXG4gICAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIERlZmluZXMgYW4gaW5pdGlhbCBjb3VudCBvZiB0ZW1wbGF0ZSBpbnN0YW5jZXMgdG8gcmVuZGVyIGFmdGVyIHNldHRpbmdcbiAgICAgICAqIHRoZSBgaXRlbXNgIGFycmF5LCBiZWZvcmUgdGhlIG5leHQgcGFpbnQsIGFuZCBwdXRzIHRoZSBgZG9tLXJlcGVhdGBcbiAgICAgICAqIGludG8gXCJjaHVua2luZyBtb2RlXCIuICBUaGUgcmVtYWluaW5nIGl0ZW1zIHdpbGwgYmUgY3JlYXRlZCBhbmQgcmVuZGVyZWRcbiAgICAgICAqIGluY3JlbWVudGFsbHkgYXQgZWFjaCBhbmltYXRpb24gZnJhbWUgdGhlcm9mIHVudGlsIGFsbCBpbnN0YW5jZXMgaGF2ZVxuICAgICAgICogYmVlbiByZW5kZXJlZC5cbiAgICAgICAqL1xuICAgICAgaW5pdGlhbENvdW50OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2luaXRpYWxpemVDaHVua2luZydcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiBgaW5pdGlhbENvdW50YCBpcyB1c2VkLCB0aGlzIHByb3BlcnR5IGRlZmluZXMgYSBmcmFtZSByYXRlIHRvXG4gICAgICAgKiB0YXJnZXQgYnkgdGhyb3R0bGluZyB0aGUgbnVtYmVyIG9mIGluc3RhbmNlcyByZW5kZXJlZCBlYWNoIGZyYW1lIHRvXG4gICAgICAgKiBub3QgZXhjZWVkIHRoZSBidWRnZXQgZm9yIHRoZSB0YXJnZXQgZnJhbWUgcmF0ZS4gIFNldHRpbmcgdGhpcyB0byBhXG4gICAgICAgKiBoaWdoZXIgbnVtYmVyIHdpbGwgYWxsb3cgbG93ZXIgbGF0ZW5jeSBhbmQgaGlnaGVyIHRocm91Z2hwdXQgZm9yXG4gICAgICAgKiB0aGluZ3MgbGlrZSBldmVudCBoYW5kbGVycywgYnV0IHdpbGwgcmVzdWx0IGluIGEgbG9uZ2VyIHRpbWUgZm9yIHRoZVxuICAgICAgICogcmVtYWluaW5nIGl0ZW1zIHRvIGNvbXBsZXRlIHJlbmRlcmluZy5cbiAgICAgICAqL1xuICAgICAgdGFyZ2V0RnJhbWVyYXRlOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgdmFsdWU6IDIwXG4gICAgICB9LFxuXG4gICAgICBfdGFyZ2V0RnJhbWVUaW1lOiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgY29tcHV0ZWQ6ICdfX2NvbXB1dGVGcmFtZVRpbWUodGFyZ2V0RnJhbWVyYXRlKSdcbiAgICAgIH1cblxuICAgIH07XG5cbiAgfVxuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgIHJldHVybiBbICdfX2l0ZW1zQ2hhbmdlZChpdGVtcy4qKScgXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX2luc3RhbmNlcyA9IFtdO1xuICAgIHRoaXMuX19saW1pdCA9IEluZmluaXR5O1xuICAgIHRoaXMuX19wb29sID0gW107XG4gICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IG51bGw7XG4gICAgdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4ID0ge307XG4gICAgdGhpcy5fX2NodW5rQ291bnQgPSBudWxsO1xuICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gbnVsbDtcbiAgICB0aGlzLl9fc29ydEZuID0gbnVsbDtcbiAgICB0aGlzLl9fZmlsdGVyRm4gPSBudWxsO1xuICAgIHRoaXMuX19vYnNlcnZlUGF0aHMgPSBudWxsO1xuICAgIHRoaXMuX19jdG9yID0gbnVsbDtcbiAgICB0aGlzLl9faXNEZXRhY2hlZCA9IHRydWU7XG4gICAgdGhpcy50ZW1wbGF0ZSA9IG51bGw7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5kaXNjb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHRoaXMuX19pc0RldGFjaGVkID0gdHJ1ZTtcbiAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fX2RldGFjaEluc3RhbmNlKGkpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgLy8gb25seSBwZXJmb3JtIGF0dGFjaG1lbnQgaWYgdGhlIGVsZW1lbnQgd2FzIHByZXZpb3VzbHkgZGV0YWNoZWQuXG4gICAgaWYgKHRoaXMuX19pc0RldGFjaGVkKSB7XG4gICAgICB0aGlzLl9faXNEZXRhY2hlZCA9IGZhbHNlO1xuICAgICAgbGV0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX19hdHRhY2hJbnN0YW5jZShpLCBwYXJlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9fZW5zdXJlVGVtcGxhdGl6ZWQoKSB7XG4gICAgLy8gVGVtcGxhdGl6aW5nIChnZW5lcmF0aW5nIHRoZSBpbnN0YW5jZSBjb25zdHJ1Y3RvcikgbmVlZHMgdG8gd2FpdFxuICAgIC8vIHVudGlsIHJlYWR5LCBzaW5jZSB3b24ndCBoYXZlIGl0cyB0ZW1wbGF0ZSBjb250ZW50IGhhbmRlZCBiYWNrIHRvXG4gICAgLy8gaXQgdW50aWwgdGhlblxuICAgIGlmICghdGhpcy5fX2N0b3IpIHtcbiAgICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMudGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgIC8vIC8vIFdhaXQgdW50aWwgY2hpbGRMaXN0IGNoYW5nZXMgYW5kIHRlbXBsYXRlIHNob3VsZCBiZSB0aGVyZSBieSB0aGVuXG4gICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLl9fcmVuZGVyKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZG9tLXJlcGVhdCByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGVtcGxhdGUgaW5zdGFuY2UgcHJvcHMgdGhhdCBzaG91bGQgYmUgZXhjbHVkZWQgZnJvbSBmb3J3YXJkaW5nXG4gICAgICBsZXQgaW5zdGFuY2VQcm9wcyA9IHt9O1xuICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLmFzXSA9IHRydWU7XG4gICAgICBpbnN0YW5jZVByb3BzW3RoaXMuaW5kZXhBc10gPSB0cnVlO1xuICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLml0ZW1zSW5kZXhBc10gPSB0cnVlO1xuICAgICAgdGhpcy5fX2N0b3IgPSBUZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgbXV0YWJsZURhdGE6IHRoaXMubXV0YWJsZURhdGEsXG4gICAgICAgIHBhcmVudE1vZGVsOiB0cnVlLFxuICAgICAgICBpbnN0YW5jZVByb3BzOiBpbnN0YW5jZVByb3BzLFxuICAgICAgICAvKipcbiAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIHNldFxuICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldCBwcm9wZXJ0eSB0b1xuICAgICAgICAgKi9cbiAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgIGxldCBpJCA9IHRoaXMuX19pbnN0YW5jZXM7XG4gICAgICAgICAgZm9yIChsZXQgaT0wLCBpbnN0OyAoaTxpJC5sZW5ndGgpICYmIChpbnN0PWkkW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICBpbnN0LmZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0IEluc3RhbmNlIHRvIG5vdGlmeVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBub3RpZnlcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBub3RpZnlcbiAgICAgICAgICovXG4gICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcDogZnVuY3Rpb24oaW5zdCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICBpZiAobWF0Y2hlcyh0aGlzLmFzLCBwcm9wKSkge1xuICAgICAgICAgICAgbGV0IGlkeCA9IGluc3RbdGhpcy5pdGVtc0luZGV4QXNdO1xuICAgICAgICAgICAgaWYgKHByb3AgPT0gdGhpcy5hcykge1xuICAgICAgICAgICAgICB0aGlzLml0ZW1zW2lkeF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBwYXRoID0gdHJhbnNsYXRlKHRoaXMuYXMsICdpdGVtcy4nICsgaWR4LCBwcm9wKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5UGF0aChwYXRoLCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfX2dldE1ldGhvZEhvc3QoKSB7XG4gICAgLy8gVGVjaG5pY2FsbHkgdGhpcyBzaG91bGQgYmUgdGhlIG93bmVyIG9mIHRoZSBvdXRlcm1vc3QgdGVtcGxhdGUuXG4gICAgLy8gSW4gc2hhZG93IGRvbSwgdGhpcyBpcyBhbHdheXMgZ2V0Um9vdE5vZGUoKS5ob3N0LCBidXQgd2UgY2FuXG4gICAgLy8gYXBwcm94aW1hdGUgdGhpcyB2aWEgY29vcGVyYXRpb24gd2l0aCBvdXIgZGF0YUhvc3QgYWx3YXlzIHNldHRpbmdcbiAgICAvLyBgX21ldGhvZEhvc3RgIGFzIGxvbmcgYXMgdGhlcmUgd2VyZSBiaW5kaW5ncyAob3IgaWQncykgb24gdGhpc1xuICAgIC8vIGluc3RhbmNlIGNhdXNpbmcgaXQgdG8gZ2V0IGEgZGF0YUhvc3QuXG4gICAgcmV0dXJuIHRoaXMuX19kYXRhSG9zdC5fbWV0aG9kSG9zdCB8fCB0aGlzLl9fZGF0YUhvc3Q7XG4gIH1cblxuICBfX3NvcnRDaGFuZ2VkKHNvcnQpIHtcbiAgICBsZXQgbWV0aG9kSG9zdCA9IHRoaXMuX19nZXRNZXRob2RIb3N0KCk7XG4gICAgdGhpcy5fX3NvcnRGbiA9IHNvcnQgJiYgKHR5cGVvZiBzb3J0ID09ICdmdW5jdGlvbicgPyBzb3J0IDpcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kSG9zdFtzb3J0XS5hcHBseShtZXRob2RIb3N0LCBhcmd1bWVudHMpOyB9KTtcbiAgICBpZiAodGhpcy5pdGVtcykge1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgIH1cbiAgfVxuXG4gIF9fZmlsdGVyQ2hhbmdlZChmaWx0ZXIpIHtcbiAgICBsZXQgbWV0aG9kSG9zdCA9IHRoaXMuX19nZXRNZXRob2RIb3N0KCk7XG4gICAgdGhpcy5fX2ZpbHRlckZuID0gZmlsdGVyICYmICh0eXBlb2YgZmlsdGVyID09ICdmdW5jdGlvbicgPyBmaWx0ZXIgOlxuICAgICAgZnVuY3Rpb24oKSB7IHJldHVybiBtZXRob2RIb3N0W2ZpbHRlcl0uYXBwbHkobWV0aG9kSG9zdCwgYXJndW1lbnRzKTsgfSk7XG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG4gIH1cblxuICBfX2NvbXB1dGVGcmFtZVRpbWUocmF0ZSkge1xuICAgIHJldHVybiBNYXRoLmNlaWwoMTAwMC9yYXRlKTtcbiAgfVxuXG4gIF9faW5pdGlhbGl6ZUNodW5raW5nKCkge1xuICAgIGlmICh0aGlzLmluaXRpYWxDb3VudCkge1xuICAgICAgdGhpcy5fX2xpbWl0ID0gdGhpcy5pbml0aWFsQ291bnQ7XG4gICAgICB0aGlzLl9fY2h1bmtDb3VudCA9IHRoaXMuaW5pdGlhbENvdW50O1xuICAgICAgdGhpcy5fX2xhc3RDaHVua1RpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gIH1cblxuICBfX3RyeVJlbmRlckNodW5rKCkge1xuICAgIC8vIERlYm91bmNlZCBzbyB0aGF0IG11bHRpcGxlIGNhbGxzIHRocm91Z2ggYF9yZW5kZXJgIGJldHdlZW4gYW5pbWF0aW9uXG4gICAgLy8gZnJhbWVzIG9ubHkgcXVldWUgb25lIG5ldyByQUYgKGUuZy4gYXJyYXkgbXV0YXRpb24gJiBjaHVua2VkIHJlbmRlcilcbiAgICBpZiAodGhpcy5pdGVtcyAmJiB0aGlzLl9fbGltaXQgPCB0aGlzLml0ZW1zLmxlbmd0aCkge1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZXF1ZXN0UmVuZGVyQ2h1bmspO1xuICAgIH1cbiAgfVxuXG4gIF9fcmVxdWVzdFJlbmRlckNodW5rKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKT0+dGhpcy5fX3JlbmRlckNodW5rKCkpO1xuICB9XG5cbiAgX19yZW5kZXJDaHVuaygpIHtcbiAgICAvLyBTaW1wbGUgYXV0byBjaHVua1NpemUgdGhyb3R0bGluZyBhbGdvcml0aG0gYmFzZWQgb24gZmVlZGJhY2sgbG9vcDpcbiAgICAvLyBtZWFzdXJlIGFjdHVhbCB0aW1lIGJldHdlZW4gZnJhbWVzIGFuZCBzY2FsZSBjaHVuayBjb3VudCBieSByYXRpb1xuICAgIC8vIG9mIHRhcmdldC9hY3R1YWwgZnJhbWUgdGltZVxuICAgIGxldCBjdXJyQ2h1bmtUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgbGV0IHJhdGlvID0gdGhpcy5fdGFyZ2V0RnJhbWVUaW1lIC8gKGN1cnJDaHVua1RpbWUgLSB0aGlzLl9fbGFzdENodW5rVGltZSk7XG4gICAgdGhpcy5fX2NodW5rQ291bnQgPSBNYXRoLnJvdW5kKHRoaXMuX19jaHVua0NvdW50ICogcmF0aW8pIHx8IDE7XG4gICAgdGhpcy5fX2xpbWl0ICs9IHRoaXMuX19jaHVua0NvdW50O1xuICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gY3VyckNodW5rVGltZTtcbiAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gIH1cblxuICBfX29ic2VydmVDaGFuZ2VkKCkge1xuICAgIHRoaXMuX19vYnNlcnZlUGF0aHMgPSB0aGlzLm9ic2VydmUgJiZcbiAgICAgIHRoaXMub2JzZXJ2ZS5yZXBsYWNlKCcuKicsICcuJykuc3BsaXQoJyAnKTtcbiAgfVxuXG4gIF9faXRlbXNDaGFuZ2VkKGNoYW5nZSkge1xuICAgIGlmICh0aGlzLml0ZW1zICYmICFBcnJheS5pc0FycmF5KHRoaXMuaXRlbXMpKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2RvbS1yZXBlYXQgZXhwZWN0ZWQgYXJyYXkgZm9yIGBpdGVtc2AsIGZvdW5kJywgdGhpcy5pdGVtcyk7XG4gICAgfVxuICAgIC8vIElmIHBhdGggd2FzIHRvIGFuIGl0ZW0gKGUuZy4gJ2l0ZW1zLjMnIG9yICdpdGVtcy4zLmZvbycpLCBmb3J3YXJkIHRoZVxuICAgIC8vIHBhdGggdG8gdGhhdCBpbnN0YW5jZSBzeW5jaHJvbm91c2x5IChyZXR1bnMgZmFsc2UgZm9yIG5vbi1pdGVtIHBhdGhzKVxuICAgIGlmICghdGhpcy5fX2hhbmRsZUl0ZW1QYXRoKGNoYW5nZS5wYXRoLCBjaGFuZ2UudmFsdWUpKSB7XG4gICAgICAvLyBPdGhlcndpc2UsIHRoZSBhcnJheSB3YXMgcmVzZXQgKCdpdGVtcycpIG9yIHNwbGljZWQgKCdpdGVtcy5zcGxpY2VzJyksXG4gICAgICAvLyBzbyBxdWV1ZSBhIGZ1bGwgcmVmcmVzaFxuICAgICAgdGhpcy5fX2luaXRpYWxpemVDaHVua2luZygpO1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICAgIH1cbiAgfVxuXG4gIF9faGFuZGxlT2JzZXJ2ZWRQYXRocyhwYXRoKSB7XG4gICAgaWYgKHRoaXMuX19vYnNlcnZlUGF0aHMpIHtcbiAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZyhwYXRoLmluZGV4T2YoJy4nKSArIDEpO1xuICAgICAgbGV0IHBhdGhzID0gdGhpcy5fX29ic2VydmVQYXRocztcbiAgICAgIGZvciAobGV0IGk9MDsgaTxwYXRocy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aC5pbmRleE9mKHBhdGhzW2ldKSA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyLCB0aGlzLmRlbGF5KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKHRoaXM6RG9tUmVwZWF0KX0gZm4gRnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gZGVsYXkgRGVsYXkgaW4gbXMgdG8gZGVib3VuY2UgYnkuXG4gICAqL1xuICBfX2RlYm91bmNlUmVuZGVyKGZuLCBkZWxheSA9IDApIHtcbiAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gRGVib3VuY2VyLmRlYm91bmNlKFxuICAgICAgICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXJcbiAgICAgICAgLCBkZWxheSA+IDAgPyB0aW1lT3V0LmFmdGVyKGRlbGF5KSA6IG1pY3JvVGFza1xuICAgICAgICAsIGZuLmJpbmQodGhpcykpO1xuICAgIGVucXVldWVEZWJvdW5jZXIodGhpcy5fX3JlbmRlckRlYm91bmNlcik7XG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gTm9ybWFsbHkgcmVuZGVyaW5nIGlzXG4gICAqIGFzeW5jaHJvbm91cyB0byBhIHByb3Zva2luZyBjaGFuZ2UuIFRoaXMgaXMgZG9uZSBmb3IgZWZmaWNpZW5jeSBzb1xuICAgKiB0aGF0IG11bHRpcGxlIGNoYW5nZXMgdHJpZ2dlciBvbmx5IGEgc2luZ2xlIHJlbmRlci4gVGhlIHJlbmRlciBtZXRob2RcbiAgICogc2hvdWxkIGJlIGNhbGxlZCBpZiwgZm9yIGV4YW1wbGUsIHRlbXBsYXRlIHJlbmRlcmluZyBpcyByZXF1aXJlZCB0b1xuICAgKiB2YWxpZGF0ZSBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICAvLyBRdWV1ZSB0aGlzIHJlcGVhdGVyLCB0aGVuIGZsdXNoIGFsbCBpbiBvcmRlclxuICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICBmbHVzaCgpO1xuICB9XG5cbiAgX19yZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLl9fZW5zdXJlVGVtcGxhdGl6ZWQoKSkge1xuICAgICAgLy8gTm8gdGVtcGxhdGUgZm91bmQgeWV0XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX19hcHBseUZ1bGxSZWZyZXNoKCk7XG4gICAgLy8gUmVzZXQgdGhlIHBvb2xcbiAgICAvLyBUT0RPKGtzY2hhYWYpOiBSZXVzZSBwb29sIGFjcm9zcyB0dXJucyBhbmQgbmVzdGVkIHRlbXBsYXRlc1xuICAgIC8vIE5vdyB0aGF0IG9iamVjdHMvYXJyYXlzIGFyZSByZS1ldmFsdWF0ZWQgd2hlbiBzZXQsIHdlIGNhbiBzYWZlbHlcbiAgICAvLyByZXVzZSBwb29sZWQgaW5zdGFuY2VzIGFjcm9zcyB0dXJucywgaG93ZXZlciB3ZSBzdGlsbCBuZWVkIHRvIGRlY2lkZVxuICAgIC8vIHNlbWFudGljcyByZWdhcmRpbmcgaG93IGxvbmcgdG8gaG9sZCwgaG93IG1hbnkgdG8gaG9sZCwgZXRjLlxuICAgIHRoaXMuX19wb29sLmxlbmd0aCA9IDA7XG4gICAgLy8gU2V0IHJlbmRlcmVkIGl0ZW0gY291bnRcbiAgICB0aGlzLl9zZXRSZW5kZXJlZEl0ZW1Db3VudCh0aGlzLl9faW5zdGFuY2VzLmxlbmd0aCk7XG4gICAgLy8gTm90aWZ5IHVzZXJzXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH0pKTtcbiAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byByZW5kZXIgbW9yZSBpdGVtc1xuICAgIHRoaXMuX190cnlSZW5kZXJDaHVuaygpO1xuICB9XG5cbiAgX19hcHBseUZ1bGxSZWZyZXNoKCkge1xuICAgIGxldCBpdGVtcyA9IHRoaXMuaXRlbXMgfHwgW107XG4gICAgbGV0IGlzbnRJZHhUb0l0ZW1zSWR4ID0gbmV3IEFycmF5KGl0ZW1zLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaT0wOyBpPGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpc250SWR4VG9JdGVtc0lkeFtpXSA9IGk7XG4gICAgfVxuICAgIC8vIEFwcGx5IHVzZXIgZmlsdGVyXG4gICAgaWYgKHRoaXMuX19maWx0ZXJGbikge1xuICAgICAgaXNudElkeFRvSXRlbXNJZHggPSBpc250SWR4VG9JdGVtc0lkeC5maWx0ZXIoKGksIGlkeCwgYXJyYXkpID0+XG4gICAgICAgIHRoaXMuX19maWx0ZXJGbihpdGVtc1tpXSwgaWR4LCBhcnJheSkpO1xuICAgIH1cbiAgICAvLyBBcHBseSB1c2VyIHNvcnRcbiAgICBpZiAodGhpcy5fX3NvcnRGbikge1xuICAgICAgaXNudElkeFRvSXRlbXNJZHguc29ydCgoYSwgYikgPT4gdGhpcy5fX3NvcnRGbihpdGVtc1thXSwgaXRlbXNbYl0pKTtcbiAgICB9XG4gICAgLy8gaXRlbXMtPmluc3QgbWFwIGtlcHQgZm9yIGl0ZW0gcGF0aCBmb3J3YXJkaW5nXG4gICAgY29uc3QgaXRlbXNJZHhUb0luc3RJZHggPSB0aGlzLl9faXRlbXNJZHhUb0luc3RJZHggPSB7fTtcbiAgICBsZXQgaW5zdElkeCA9IDA7XG4gICAgLy8gR2VuZXJhdGUgaW5zdGFuY2VzIGFuZCBhc3NpZ24gaXRlbXNcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgubWluKGlzbnRJZHhUb0l0ZW1zSWR4Lmxlbmd0aCwgdGhpcy5fX2xpbWl0KTtcbiAgICBmb3IgKDsgaW5zdElkeDxsaW1pdDsgaW5zdElkeCsrKSB7XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF07XG4gICAgICBsZXQgaXRlbUlkeCA9IGlzbnRJZHhUb0l0ZW1zSWR4W2luc3RJZHhdO1xuICAgICAgbGV0IGl0ZW0gPSBpdGVtc1tpdGVtSWR4XTtcbiAgICAgIGl0ZW1zSWR4VG9JbnN0SWR4W2l0ZW1JZHhdID0gaW5zdElkeDtcbiAgICAgIGlmIChpbnN0ICYmIGluc3RJZHggPCB0aGlzLl9fbGltaXQpIHtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuYXMsIGl0ZW0pO1xuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pbmRleEFzLCBpbnN0SWR4KTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaXRlbXNJbmRleEFzLCBpdGVtSWR4KTtcbiAgICAgICAgaW5zdC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9faW5zZXJ0SW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSBhbnkgZXh0cmEgaW5zdGFuY2VzIGZyb20gcHJldmlvdXMgc3RhdGVcbiAgICBmb3IgKGxldCBpPXRoaXMuX19pbnN0YW5jZXMubGVuZ3RoLTE7IGk+PWluc3RJZHg7IGktLSkge1xuICAgICAgdGhpcy5fX2RldGFjaEFuZFJlbW92ZUluc3RhbmNlKGkpO1xuICAgIH1cbiAgfVxuXG4gIF9fZGV0YWNoSW5zdGFuY2UoaWR4KSB7XG4gICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2lkeF07XG4gICAgZm9yIChsZXQgaT0wOyBpPGluc3QuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBlbCA9IGluc3QuY2hpbGRyZW5baV07XG4gICAgICBpbnN0LnJvb3QuYXBwZW5kQ2hpbGQoZWwpO1xuICAgIH1cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIF9fYXR0YWNoSW5zdGFuY2UoaWR4LCBwYXJlbnQpIHtcbiAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaWR4XTtcbiAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGluc3Qucm9vdCwgdGhpcyk7XG4gIH1cblxuICBfX2RldGFjaEFuZFJlbW92ZUluc3RhbmNlKGlkeCkge1xuICAgIGxldCBpbnN0ID0gdGhpcy5fX2RldGFjaEluc3RhbmNlKGlkeCk7XG4gICAgaWYgKGluc3QpIHtcbiAgICAgIHRoaXMuX19wb29sLnB1c2goaW5zdCk7XG4gICAgfVxuICAgIHRoaXMuX19pbnN0YW5jZXMuc3BsaWNlKGlkeCwgMSk7XG4gIH1cblxuICBfX3N0YW1wSW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCkge1xuICAgIGxldCBtb2RlbCA9IHt9O1xuICAgIG1vZGVsW3RoaXMuYXNdID0gaXRlbTtcbiAgICBtb2RlbFt0aGlzLmluZGV4QXNdID0gaW5zdElkeDtcbiAgICBtb2RlbFt0aGlzLml0ZW1zSW5kZXhBc10gPSBpdGVtSWR4O1xuICAgIHJldHVybiBuZXcgdGhpcy5fX2N0b3IobW9kZWwpO1xuICB9XG5cbiAgX19pbnNlcnRJbnN0YW5jZShpdGVtLCBpbnN0SWR4LCBpdGVtSWR4KSB7XG4gICAgbGV0IGluc3QgPSB0aGlzLl9fcG9vbC5wb3AoKTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgLy8gVE9ETyhrc2NoYWFmKTogSWYgdGhlIHBvb2wgaXMgc2hhcmVkIGFjcm9zcyB0dXJucywgaG9zdFByb3BzXG4gICAgICAvLyBuZWVkIHRvIGJlIHJlLXNldCB0byByZXVzZWQgaW5zdGFuY2VzIGluIGFkZGl0aW9uIHRvIGl0ZW1cbiAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmFzLCBpdGVtKTtcbiAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmluZGV4QXMsIGluc3RJZHgpO1xuICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaXRlbXNJbmRleEFzLCBpdGVtSWR4KTtcbiAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0ID0gdGhpcy5fX3N0YW1wSW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCk7XG4gICAgfVxuICAgIGxldCBiZWZvcmVSb3cgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHggKyAxXTtcbiAgICBsZXQgYmVmb3JlTm9kZSA9IGJlZm9yZVJvdyA/IGJlZm9yZVJvdy5jaGlsZHJlblswXSA6IHRoaXM7XG4gICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShpbnN0LnJvb3QsIGJlZm9yZU5vZGUpO1xuICAgIHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF0gPSBpbnN0O1xuICAgIHJldHVybiBpbnN0O1xuICB9XG5cbiAgLy8gSW1wbGVtZW50cyBleHRlbnNpb24gcG9pbnQgZnJvbSBUZW1wbGF0aXplIG1peGluXG4gIF9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbikge1xuICAgIGZvciAobGV0IGk9MDsgaTx0aGlzLl9faW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9faW5zdGFuY2VzW2ldLl9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbik7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIGFzIGEgc2lkZSBlZmZlY3Qgb2YgYSBob3N0IGl0ZW1zLjxrZXk+LjxwYXRoPiBwYXRoIGNoYW5nZSxcbiAgLy8gcmVzcG9uc2libGUgZm9yIG5vdGlmeWluZyBpdGVtLjxwYXRoPiBjaGFuZ2VzIHRvIGluc3QgZm9yIGtleVxuICBfX2hhbmRsZUl0ZW1QYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgbGV0IGl0ZW1zUGF0aCA9IHBhdGguc2xpY2UoNik7IC8vICdpdGVtcy4nLmxlbmd0aCA9PSA2XG4gICAgbGV0IGRvdCA9IGl0ZW1zUGF0aC5pbmRleE9mKCcuJyk7XG4gICAgbGV0IGl0ZW1zSWR4ID0gZG90IDwgMCA/IGl0ZW1zUGF0aCA6IGl0ZW1zUGF0aC5zdWJzdHJpbmcoMCwgZG90KTtcbiAgICAvLyBJZiBwYXRoIHdhcyBpbmRleCBpbnRvIGFycmF5Li4uXG4gICAgaWYgKGl0ZW1zSWR4ID09IHBhcnNlSW50KGl0ZW1zSWR4LCAxMCkpIHtcbiAgICAgIGxldCBpdGVtU3ViUGF0aCA9IGRvdCA8IDAgPyAnJyA6IGl0ZW1zUGF0aC5zdWJzdHJpbmcoZG90KzEpO1xuICAgICAgLy8gSWYgdGhlIHBhdGggaXMgb2JzZXJ2ZWQsIGl0IHdpbGwgdHJpZ2dlciBhIGZ1bGwgcmVmcmVzaFxuICAgICAgdGhpcy5fX2hhbmRsZU9ic2VydmVkUGF0aHMoaXRlbVN1YlBhdGgpO1xuICAgICAgLy8gTm90ZSwgZXZlbiBpZiBhIHJ1bGwgcmVmcmVzaCBpcyB0cmlnZ2VyZWQsIGFsd2F5cyBkbyB0aGUgcGF0aFxuICAgICAgLy8gbm90aWZpY2F0aW9uIGJlY2F1c2UgdW5sZXNzIG11dGFibGVEYXRhIGlzIHVzZWQgZm9yIGRvbS1yZXBlYXRcbiAgICAgIC8vIGFuZCBhbGwgZWxlbWVudHMgaW4gdGhlIGluc3RhbmNlIHN1YnRyZWUsIGEgZnVsbCByZWZyZXNoIG1heVxuICAgICAgLy8gbm90IHRyaWdnZXIgdGhlIHByb3BlciB1cGRhdGUuXG4gICAgICBsZXQgaW5zdElkeCA9IHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeFtpdGVtc0lkeF07XG4gICAgICBsZXQgaW5zdCA9IHRoaXMuX19pbnN0YW5jZXNbaW5zdElkeF07XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICBsZXQgaXRlbVBhdGggPSB0aGlzLmFzICsgKGl0ZW1TdWJQYXRoID8gJy4nICsgaXRlbVN1YlBhdGggOiAnJyk7XG4gICAgICAgIC8vIFRoaXMgaXMgZWZmZWN0aXZlbHkgYG5vdGlmeVBhdGhgLCBidXQgYXZvaWRzIHNvbWUgb2YgdGhlIG92ZXJoZWFkXG4gICAgICAgIC8vIG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChpdGVtUGF0aCwgdmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgaW5zdC5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlbSBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50IHN0YW1wZWQgYnlcbiAgICogdGhpcyBgZG9tLXJlcGVhdGAuXG4gICAqXG4gICAqIE5vdGUsIHRvIG1vZGlmeSBzdWItcHJvcGVydGllcyBvZiB0aGUgaXRlbSxcbiAgICogYG1vZGVsRm9yRWxlbWVudChlbCkuc2V0KCdpdGVtLjxzdWItcHJvcD4nLCB2YWx1ZSlgXG4gICAqIHNob3VsZCBiZSB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gdGhlIGl0ZW0uXG4gICAqIEByZXR1cm4geyp9IEl0ZW0gYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgaXRlbUZvckVsZW1lbnQoZWwpIHtcbiAgICBsZXQgaW5zdGFuY2UgPSB0aGlzLm1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAgcmV0dXJuIGluc3RhbmNlICYmIGluc3RhbmNlW3RoaXMuYXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluc3QgaW5kZXggZm9yIGEgZ2l2ZW4gZWxlbWVudCBzdGFtcGVkIGJ5IHRoaXMgYGRvbS1yZXBlYXRgLlxuICAgKiBJZiBgc29ydGAgaXMgcHJvdmlkZWQsIHRoZSBpbmRleCB3aWxsIHJlZmxlY3QgdGhlIHNvcnRlZCBvcmRlciAocmF0aGVyXG4gICAqIHRoYW4gdGhlIG9yaWdpbmFsIGFycmF5IG9yZGVyKS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBpbmRleC5cbiAgICogQHJldHVybiB7Kn0gUm93IGluZGV4IGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudCAobm90ZSB0aGlzIG1heVxuICAgKiAgIG5vdCBjb3JyZXNwb25kIHRvIHRoZSBhcnJheSBpbmRleCBpZiBhIHVzZXIgYHNvcnRgIGlzIGFwcGxpZWQpLlxuICAgKi9cbiAgaW5kZXhGb3JFbGVtZW50KGVsKSB7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5tb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVt0aGlzLmluZGV4QXNdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRlbXBsYXRlIFwibW9kZWxcIiBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBlbGVtZW50LCB3aGljaFxuICAgKiBzZXJ2ZXMgYXMgdGhlIGJpbmRpbmcgc2NvcGUgZm9yIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGUgZWxlbWVudCBpc1xuICAgKiBjb250YWluZWQgaW4uIEEgdGVtcGxhdGUgbW9kZWwgaXMgYW4gaW5zdGFuY2Ugb2YgYFBvbHltZXIuQmFzZWAsIGFuZFxuICAgKiBzaG91bGQgYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgbGV0IG1vZGVsID0gbW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICogICBpZiAobW9kZWwuaW5kZXggPCAxMCkge1xuICAgKiAgICAgbW9kZWwuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtcbiAgICogICB9XG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgKiAgIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgbW9kZWxGb3JFbGVtZW50KGVsKSB7XG4gICAgcmV0dXJuIFRlbXBsYXRpemUubW9kZWxGb3JFbGVtZW50KHRoaXMudGVtcGxhdGUsIGVsKTtcbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShEb21SZXBlYXQuaXMsIERvbVJlcGVhdCk7XG5cbmV4cG9ydCB7IERvbVJlcGVhdCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLXJlcGVhdC5qc1xuLy8gbW9kdWxlIGlkID0gNjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uLy4uL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0aXplIH0gZnJvbSAnLi4vdXRpbHMvdGVtcGxhdGl6ZS5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9kZWJvdW5jZS5qcyc7XG5pbXBvcnQgeyBlbnF1ZXVlRGVib3VuY2VyLCBmbHVzaCB9IGZyb20gJy4uL3V0aWxzL2ZsdXNoLmpzJztcbmltcG9ydCB7IG1pY3JvVGFzayB9IGZyb20gJy4uL3V0aWxzL2FzeW5jLmpzJztcbmltcG9ydCB7IHJvb3QgYXMgcm9vdCQwIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5qcyc7XG5cbi8qKlxuICogVGhlIGA8ZG9tLWlmPmAgZWxlbWVudCB3aWxsIHN0YW1wIGEgbGlnaHQtZG9tIGA8dGVtcGxhdGU+YCBjaGlsZCB3aGVuXG4gKiB0aGUgYGlmYCBwcm9wZXJ0eSBiZWNvbWVzIHRydXRoeSwgYW5kIHRoZSB0ZW1wbGF0ZSBjYW4gdXNlIFBvbHltZXJcbiAqIGRhdGEtYmluZGluZyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgZmVhdHVyZXMgd2hlbiB1c2VkIGluIHRoZSBjb250ZXh0IG9mXG4gKiBhIFBvbHltZXIgZWxlbWVudCdzIHRlbXBsYXRlLlxuICpcbiAqIFdoZW4gYGlmYCBiZWNvbWVzIGZhbHNleSwgdGhlIHN0YW1wZWQgY29udGVudCBpcyBoaWRkZW4gYnV0IG5vdFxuICogcmVtb3ZlZCBmcm9tIGRvbS4gV2hlbiBgaWZgIHN1YnNlcXVlbnRseSBiZWNvbWVzIHRydXRoeSBhZ2FpbiwgdGhlIGNvbnRlbnRcbiAqIGlzIHNpbXBseSByZS1zaG93bi4gVGhpcyBhcHByb2FjaCBpcyB1c2VkIGR1ZSB0byBpdHMgZmF2b3JhYmxlIHBlcmZvcm1hbmNlXG4gKiBjaGFyYWN0ZXJpc3RpY3M6IHRoZSBleHBlbnNlIG9mIGNyZWF0aW5nIHRlbXBsYXRlIGNvbnRlbnQgaXMgcGFpZCBvbmx5XG4gKiBvbmNlIGFuZCBsYXppbHkuXG4gKlxuICogU2V0IHRoZSBgcmVzdGFtcGAgcHJvcGVydHkgdG8gdHJ1ZSB0byBmb3JjZSB0aGUgc3RhbXBlZCBjb250ZW50IHRvIGJlXG4gKiBjcmVhdGVkIC8gZGVzdHJveWVkIHdoZW4gdGhlIGBpZmAgY29uZGl0aW9uIGNoYW5nZXMuXG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBwb2x5bWVyXG4gKiBAZXh0ZW5kcyBQb2x5bWVyLkVsZW1lbnRcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IGNvbmRpdGlvbmFsbHkgc3RhbXBzIGFuZCBoaWRlcyBvciByZW1vdmVzXG4gKiAgIHRlbXBsYXRlIGNvbnRlbnQgYmFzZWQgb24gYSBib29sZWFuIGZsYWcuXG4gKi9cbmNsYXNzIERvbUlmIGV4dGVuZHMgRWxlbWVudCB7XG5cbiAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2RvbS1pZic7IH1cblxuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkgeyByZXR1cm4gbnVsbDsgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgIHJldHVybiB7XG5cbiAgICAgIC8qKlxuICAgICAgICogRmlyZWQgd2hlbmV2ZXIgRE9NIGlzIGFkZGVkIG9yIHJlbW92ZWQvaGlkZGVuIGJ5IHRoaXMgdGVtcGxhdGUgKGJ5XG4gICAgICAgKiBkZWZhdWx0LCByZW5kZXJpbmcgb2NjdXJzIGxhemlseSkuICBUbyBmb3JjZSBpbW1lZGlhdGUgcmVuZGVyaW5nLCBjYWxsXG4gICAgICAgKiBgcmVuZGVyYC5cbiAgICAgICAqXG4gICAgICAgKiBAZXZlbnQgZG9tLWNoYW5nZVxuICAgICAgICovXG5cbiAgICAgIC8qKlxuICAgICAgICogQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGlzIHRlbXBsYXRlIHNob3VsZCBzdGFtcC5cbiAgICAgICAqL1xuICAgICAgaWY6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2RlYm91bmNlUmVuZGVyJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHRydWUsIGVsZW1lbnRzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIERPTSBhbmQgZGlzY2FyZGVkIHdoZW4gYGlmYFxuICAgICAgICogYmVjb21lcyBmYWxzZSBhbmQgcmUtY3JlYXRlZCBhbmQgYWRkZWQgYmFjayB0byB0aGUgRE9NIHdoZW4gYGlmYFxuICAgICAgICogYmVjb21lcyB0cnVlLiAgQnkgZGVmYXVsdCwgc3RhbXBlZCBlbGVtZW50cyB3aWxsIGJlIGhpZGRlbiBidXQgbGVmdFxuICAgICAgICogaW4gdGhlIERPTSB3aGVuIGBpZmAgYmVjb21lcyBmYWxzZSwgd2hpY2ggaXMgZ2VuZXJhbGx5IHJlc3VsdHNcbiAgICAgICAqIGluIGJldHRlciBwZXJmb3JtYW5jZS5cbiAgICAgICAqL1xuICAgICAgcmVzdGFtcDoge1xuICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICBvYnNlcnZlcjogJ19fZGVib3VuY2VSZW5kZXInXG4gICAgICB9XG5cbiAgICB9O1xuXG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBudWxsO1xuICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgIHRoaXMuX19pbnN0YW5jZSA9IG51bGw7XG4gICAgdGhpcy5fbGFzdElmID0gZmFsc2U7XG4gICAgdGhpcy5fX2N0b3IgPSBudWxsO1xuICB9XG5cbiAgX19kZWJvdW5jZVJlbmRlcigpIHtcbiAgICAvLyBSZW5kZXIgaXMgYXN5bmMgZm9yIDIgcmVhc29uczpcbiAgICAvLyAxLiBUbyBlbGltaW5hdGUgZG9tIGNyZWF0aW9uIHRyYXNoaW5nIGlmIHVzZXIgY29kZSB0aHJhc2hlcyBgaWZgIGluIHRoZVxuICAgIC8vICAgIHNhbWUgdHVybi4gVGhpcyB3YXMgbW9yZSBjb21tb24gaW4gMS54IHdoZXJlIGEgY29tcG91bmQgY29tcHV0ZWRcbiAgICAvLyAgICBwcm9wZXJ0eSBjb3VsZCByZXN1bHQgaW4gdGhlIHJlc3VsdCBjaGFuZ2luZyBtdWx0aXBsZSB0aW1lcywgYnV0IGlzXG4gICAgLy8gICAgbWl0aWdhdGVkIHRvIGEgbGFyZ2UgZXh0ZW50IGJ5IGJhdGNoZWQgcHJvcGVydHkgcHJvY2Vzc2luZyBpbiAyLnguXG4gICAgLy8gMi4gVG8gYXZvaWQgZG91YmxlIG9iamVjdCBwcm9wYWdhdGlvbiB3aGVuIGEgYmFnIGluY2x1ZGluZyB2YWx1ZXMgYm91bmRcbiAgICAvLyAgICB0byB0aGUgYGlmYCBwcm9wZXJ0eSBhcyB3ZWxsIGFzIG9uZSBvciBtb3JlIGhvc3RQcm9wcyBjb3VsZCBlbnF1ZXVlXG4gICAgLy8gICAgdGhlIDxkb20taWY+IHRvIGZsdXNoIGJlZm9yZSB0aGUgPHRlbXBsYXRlPidzIGhvc3QgcHJvcGVydHlcbiAgICAvLyAgICBmb3J3YXJkaW5nLiBJbiB0aGF0IHNjZW5hcmlvIGNyZWF0aW5nIGFuIGluc3RhbmNlIHdvdWxkIHJlc3VsdCBpblxuICAgIC8vICAgIHRoZSBob3N0IHByb3BzIGJlaW5nIHNldCBvbmNlLCBhbmQgdGhlbiB0aGUgZW5xdWV1ZWQgY2hhbmdlcyBvbiB0aGVcbiAgICAvLyAgICB0ZW1wbGF0ZSB3b3VsZCBzZXQgcHJvcGVydGllcyBhIHNlY29uZCB0aW1lLCBwb3RlbnRpYWxseSBjYXVzaW5nIGFuXG4gICAgLy8gICAgb2JqZWN0IHRvIGJlIHNldCB0byBhbiBpbnN0YW5jZSBtb3JlIHRoYW4gb25jZS4gIENyZWF0aW5nIHRoZVxuICAgIC8vICAgIGluc3RhbmNlIGFzeW5jIGZyb20gZmx1c2hpbmcgZGF0YSBlbnN1cmVzIHRoaXMgZG9lc24ndCBoYXBwZW4uIElmXG4gICAgLy8gICAgd2Ugd2FudGVkIGEgc3luYyBvcHRpb24gaW4gdGhlIGZ1dHVyZSwgc2ltcGx5IGhhdmluZyA8ZG9tLWlmPiBmbHVzaFxuICAgIC8vICAgIChvciBjbGVhcikgaXRzIHRlbXBsYXRlJ3MgcGVuZGluZyBob3N0IHByb3BlcnRpZXMgYmVmb3JlIGNyZWF0aW5nXG4gICAgLy8gICAgdGhlIGluc3RhbmNlIHdvdWxkIGFsc28gYXZvaWQgdGhlIHByb2JsZW0uXG4gICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyXG4gICAgICAgICwgbWljcm9UYXNrXG4gICAgICAgICwgKCkgPT4gdGhpcy5fX3JlbmRlcigpKTtcbiAgICBlbnF1ZXVlRGVib3VuY2VyKHRoaXMuX19yZW5kZXJEZWJvdW5jZXIpO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBpZiAoIXRoaXMucGFyZW50Tm9kZSB8fFxuICAgICAgICAodGhpcy5wYXJlbnROb2RlLm5vZGVUeXBlID09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJlxuICAgICAgICAgIXRoaXMucGFyZW50Tm9kZS5ob3N0KSkge1xuICAgICAgdGhpcy5fX3RlYXJkb3duSW5zdGFuY2UoKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRm9yY2VzIHRoZSBlbGVtZW50IHRvIHJlbmRlciBpdHMgY29udGVudC4gTm9ybWFsbHkgcmVuZGVyaW5nIGlzXG4gICAqIGFzeW5jaHJvbm91cyB0byBhIHByb3Zva2luZyBjaGFuZ2UuIFRoaXMgaXMgZG9uZSBmb3IgZWZmaWNpZW5jeSBzb1xuICAgKiB0aGF0IG11bHRpcGxlIGNoYW5nZXMgdHJpZ2dlciBvbmx5IGEgc2luZ2xlIHJlbmRlci4gVGhlIHJlbmRlciBtZXRob2RcbiAgICogc2hvdWxkIGJlIGNhbGxlZCBpZiwgZm9yIGV4YW1wbGUsIHRlbXBsYXRlIHJlbmRlcmluZyBpcyByZXF1aXJlZCB0b1xuICAgKiB2YWxpZGF0ZSBhcHBsaWNhdGlvbiBzdGF0ZS5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBmbHVzaCgpO1xuICB9XG5cbiAgX19yZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuaWYpIHtcbiAgICAgIGlmICghdGhpcy5fX2Vuc3VyZUluc3RhbmNlKCkpIHtcbiAgICAgICAgLy8gTm8gdGVtcGxhdGUgZm91bmQgeWV0XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Nob3dIaWRlQ2hpbGRyZW4oKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMucmVzdGFtcCkge1xuICAgICAgdGhpcy5fX3RlYXJkb3duSW5zdGFuY2UoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlc3RhbXAgJiYgdGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlmICE9IHRoaXMuX2xhc3RJZikge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuX2xhc3RJZiA9IHRoaXMuaWY7XG4gICAgfVxuICB9XG5cbiAgX19lbnN1cmVJbnN0YW5jZSgpIHtcbiAgICBsZXQgcGFyZW50Tm9kZSA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAvLyBHdWFyZCBhZ2FpbnN0IGVsZW1lbnQgYmVpbmcgZGV0YWNoZWQgd2hpbGUgcmVuZGVyIHdhcyBxdWV1ZWRcbiAgICBpZiAocGFyZW50Tm9kZSkge1xuICAgICAgaWYgKCF0aGlzLl9fY3Rvcikge1xuICAgICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJyk7XG4gICAgICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgICAgICAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICAgIGxldCBvYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpIHtcbiAgICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICB0aGlzLl9fcmVuZGVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1pZiByZXF1aXJlcyBhIDx0ZW1wbGF0ZT4gY2hpbGQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvYnNlcnZlci5vYnNlcnZlKHRoaXMsIHtjaGlsZExpc3Q6IHRydWV9KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX2N0b3IgPSBUZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAgICAgICAgICAvLyBkb20taWYgdGVtcGxhdGl6ZXIgaW5zdGFuY2VzIHJlcXVpcmUgYG11dGFibGU6IHRydWVgLCBhc1xuICAgICAgICAgIC8vIGBfX3N5bmNIb3N0UHJvcGVydGllc2AgcmVsaWVzIG9uIHRoYXQgYmVoYXZpb3IgdG8gc3luYyBvYmplY3RzXG4gICAgICAgICAgbXV0YWJsZURhdGE6IHRydWUsXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gZm9yd2FyZFxuICAgICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgcHJvcGVydHlcbiAgICAgICAgICAgKiBAdGhpcyB7dGhpc31cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBmb3J3YXJkSG9zdFByb3A6IGZ1bmN0aW9uKHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICAgICAgICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2luc3RhbmNlLmZvcndhcmRIb3N0UHJvcChwcm9wLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBpbnN0YW5jZSBidXQgYXJlIHNxdWVsY2hpbmcgaG9zdCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIGZvcndhcmRpbmcgZHVlIHRvIGlmIGJlaW5nIGZhbHNlLCBub3RlIHRoZSBpbnZhbGlkYXRlZFxuICAgICAgICAgICAgICAgIC8vIHByb3BlcnRpZXMgc28gYF9fc3luY0hvc3RQcm9wZXJ0aWVzYCBjYW4gc3luYyB0aGVtIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgLy8gdGltZSBgaWZgIGJlY29tZXMgdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSB0aGlzLl9faW52YWxpZFByb3BzIHx8IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2ludmFsaWRQcm9wc1tyb290JDAocHJvcCldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICB0aGlzLl9faW5zdGFuY2UgPSBuZXcgdGhpcy5fX2N0b3IoKTtcbiAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodGhpcy5fX2luc3RhbmNlLnJvb3QsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX3N5bmNIb3N0UHJvcGVydGllcygpO1xuICAgICAgICBsZXQgYyQgPSB0aGlzLl9faW5zdGFuY2UuY2hpbGRyZW47XG4gICAgICAgIGlmIChjJCAmJiBjJC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBEZXRlY3QgY2FzZSB3aGVyZSBkb20taWYgd2FzIHJlLWF0dGFjaGVkIGluIG5ldyBwb3NpdGlvblxuICAgICAgICAgIGxldCBsYXN0Q2hpbGQgPSB0aGlzLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICBpZiAobGFzdENoaWxkICE9PSBjJFtjJC5sZW5ndGgtMV0pIHtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8YyQubGVuZ3RoKSAmJiAobj1jJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBfX3N5bmNIb3N0UHJvcGVydGllcygpIHtcbiAgICBsZXQgcHJvcHMgPSB0aGlzLl9faW52YWxpZFByb3BzO1xuICAgIGlmIChwcm9wcykge1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICB0aGlzLl9faW5zdGFuY2UuX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wLCB0aGlzLl9fZGF0YUhvc3RbcHJvcF0pO1xuICAgICAgfVxuICAgICAgdGhpcy5fX2ludmFsaWRQcm9wcyA9IG51bGw7XG4gICAgICB0aGlzLl9faW5zdGFuY2UuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgIH1cbiAgfVxuXG4gIF9fdGVhcmRvd25JbnN0YW5jZSgpIHtcbiAgICBpZiAodGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICBsZXQgYyQgPSB0aGlzLl9faW5zdGFuY2UuY2hpbGRyZW47XG4gICAgICBpZiAoYyQgJiYgYyQubGVuZ3RoKSB7XG4gICAgICAgIC8vIHVzZSBmaXJzdCBjaGlsZCBwYXJlbnQsIGZvciBjYXNlIHdoZW4gZG9tLWlmIG1heSBoYXZlIGJlZW4gZGV0YWNoZWRcbiAgICAgICAgbGV0IHBhcmVudCA9IGMkWzBdLnBhcmVudE5vZGU7XG4gICAgICAgIGZvciAobGV0IGk9MCwgbjsgKGk8YyQubGVuZ3RoKSAmJiAobj1jJFtpXSk7IGkrKykge1xuICAgICAgICAgIHBhcmVudC5yZW1vdmVDaGlsZChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fX2luc3RhbmNlID0gbnVsbDtcbiAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIF9zaG93SGlkZUNoaWxkcmVuKCkge1xuICAgIGxldCBoaWRkZW4gPSB0aGlzLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXyB8fCAhdGhpcy5pZjtcbiAgICBpZiAodGhpcy5fX2luc3RhbmNlKSB7XG4gICAgICB0aGlzLl9faW5zdGFuY2UuX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZGVuKTtcbiAgICB9XG4gIH1cblxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoRG9tSWYuaXMsIERvbUlmKTtcblxuZXhwb3J0IHsgRG9tSWYgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1pZi5qc1xuLy8gbW9kdWxlIGlkID0gNjZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uLy4uL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0IHsgY2FsY3VsYXRlU3BsaWNlcyB9IGZyb20gJy4uL3V0aWxzL2FycmF5LXNwbGljZS5qcyc7XG5pbXBvcnQgeyBFbGVtZW50TWl4aW4gfSBmcm9tICcuLi9taXhpbnMvZWxlbWVudC1taXhpbi5qcyc7XG5cbi8qKlxuICogRWxlbWVudCBtaXhpbiBmb3IgcmVjb3JkaW5nIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhXG4gKiBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYSBgc2VsZWN0ZWRgIGFycmF5IHN1Y2ggdGhhdCBwYXRoIGNoYW5nZXMgdG8gdGhlXG4gKiBtYXN0ZXIgYXJyYXkgKGF0IHRoZSBob3N0KSBlbGVtZW50IG9yIGVsc2V3aGVyZSB2aWEgZGF0YS1iaW5kaW5nKSBhcmVcbiAqIGNvcnJlY3RseSBwcm9wYWdhdGVkIHRvIGl0ZW1zIGluIHRoZSBzZWxlY3RlZCBhcnJheSBhbmQgdmljZS12ZXJzYS5cbiAqXG4gKiBUaGUgYGl0ZW1zYCBwcm9wZXJ0eSBhY2NlcHRzIGFuIGFycmF5IG9mIHVzZXIgZGF0YSwgYW5kIHZpYSB0aGVcbiAqIGBzZWxlY3QoaXRlbSlgIGFuZCBgZGVzZWxlY3QoaXRlbSlgIEFQSSwgdXBkYXRlcyB0aGUgYHNlbGVjdGVkYCBwcm9wZXJ0eVxuICogd2hpY2ggbWF5IGJlIGJvdW5kIHRvIG90aGVyIHBhcnRzIG9mIHRoZSBhcHBsaWNhdGlvbiwgYW5kIGFueSBjaGFuZ2VzIHRvXG4gKiBzdWItZmllbGRzIG9mIGBzZWxlY3RlZGAgaXRlbShzKSB3aWxsIGJlIGtlcHQgaW4gc3luYyB3aXRoIGl0ZW1zIGluIHRoZVxuICogYGl0ZW1zYCBhcnJheS4gIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgYHNlbGVjdGVkYCBpcyBhIHByb3BlcnR5XG4gKiByZXByZXNlbnRpbmcgdGhlIGxhc3Qgc2VsZWN0ZWQgaXRlbS4gIFdoZW4gYG11bHRpYCBpcyB0cnVlLCBgc2VsZWN0ZWRgXG4gKiBpcyBhbiBhcnJheSBvZiBtdWx0aXBseSBzZWxlY3RlZCBpdGVtcy5cbiAqXG4gKiBAcG9seW1lclxuICogQG1peGluRnVuY3Rpb25cbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5FbGVtZW50TWl4aW5cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBFbGVtZW50IG1peGluIGZvciByZWNvcmRpbmcgZHluYW1pYyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBpdGVtIHBhdGhzIGluIGFcbiAqIG1hc3RlciBgaXRlbXNgIGFycmF5IGFuZCBhIGBzZWxlY3RlZGAgYXJyYXlcbiAqL1xubGV0IEFycmF5U2VsZWN0b3JNaXhpbiA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7c3VwZXJDbGFzc31cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgKi9cbiAgbGV0IGVsZW1lbnRCYXNlID0gRWxlbWVudE1peGluKHN1cGVyQ2xhc3MpO1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9BcnJheVNlbGVjdG9yTWl4aW59XG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICovXG4gIGNsYXNzIEFycmF5U2VsZWN0b3JNaXhpbiBleHRlbmRzIGVsZW1lbnRCYXNlIHtcblxuICAgIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcblxuICAgICAgcmV0dXJuIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQW4gYXJyYXkgY29udGFpbmluZyBpdGVtcyBmcm9tIHdoaWNoIHNlbGVjdGlvbiB3aWxsIGJlIG1hZGUuXG4gICAgICAgICAqL1xuICAgICAgICBpdGVtczoge1xuICAgICAgICAgIHR5cGU6IEFycmF5LFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGB0cnVlYCwgbXVsdGlwbGUgaXRlbXMgbWF5IGJlIHNlbGVjdGVkIGF0IG9uY2UgKGluIHRoaXMgY2FzZSxcbiAgICAgICAgICogYHNlbGVjdGVkYCBpcyBhbiBhcnJheSBvZiBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbXMpLiAgV2hlbiBgZmFsc2VgLFxuICAgICAgICAgKiBvbmx5IG9uZSBpdGVtIG1heSBiZSBzZWxlY3RlZCBhdCBhIHRpbWUuXG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aToge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgdGhpcyBpcyBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIGFueSBzZWxlY3RlZC5cbiAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCB0aGlzIGlzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgYG51bGxgXG4gICAgICAgICAqIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqIEB0eXBlIHs/KE9iamVjdHxBcnJheTwhT2JqZWN0Pil9XG4gICAgICAgICAqL1xuICAgICAgICBzZWxlY3RlZDoge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCB0aGlzIGlzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaXRlbSwgb3IgYG51bGxgXG4gICAgICAgICAqIGlmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQuXG4gICAgICAgICAqIEB0eXBlIHs/T2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWRJdGVtOiB7XG4gICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgIG5vdGlmeTogdHJ1ZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIGB0cnVlYCwgY2FsbGluZyBgc2VsZWN0YCBvbiBhbiBpdGVtIHRoYXQgaXMgYWxyZWFkeSBzZWxlY3RlZFxuICAgICAgICAgKiB3aWxsIGRlc2VsZWN0IHRoZSBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgdG9nZ2xlOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfVxuXG4gICAgICB9O1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgcmV0dXJuIFsnX191cGRhdGVTZWxlY3Rpb24obXVsdGksIGl0ZW1zLiopJ107XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgdGhpcy5fX2xhc3RJdGVtcyA9IG51bGw7XG4gICAgICB0aGlzLl9fbGFzdE11bHRpID0gbnVsbDtcbiAgICAgIHRoaXMuX19zZWxlY3RlZE1hcCA9IG51bGw7XG4gICAgfVxuXG4gICAgX191cGRhdGVTZWxlY3Rpb24obXVsdGksIGl0ZW1zSW5mbykge1xuICAgICAgbGV0IHBhdGggPSBpdGVtc0luZm8ucGF0aDtcbiAgICAgIGlmIChwYXRoID09ICdpdGVtcycpIHtcbiAgICAgICAgLy8gQ2FzZSAxIC0gaXRlbXMgYXJyYXkgY2hhbmdlZCwgc28gZGlmZiBhZ2FpbnN0IHByZXZpb3VzIGFycmF5IGFuZFxuICAgICAgICAvLyBkZXNlbGVjdCBhbnkgcmVtb3ZlZCBpdGVtcyBhbmQgYWRqdXN0IHNlbGVjdGVkIGluZGljZXNcbiAgICAgICAgbGV0IG5ld0l0ZW1zID0gaXRlbXNJbmZvLmJhc2UgfHwgW107XG4gICAgICAgIGxldCBsYXN0SXRlbXMgPSB0aGlzLl9fbGFzdEl0ZW1zO1xuICAgICAgICBsZXQgbGFzdE11bHRpID0gdGhpcy5fX2xhc3RNdWx0aTtcbiAgICAgICAgaWYgKG11bHRpICE9PSBsYXN0TXVsdGkpIHtcbiAgICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RJdGVtcykge1xuICAgICAgICAgIGxldCBzcGxpY2VzID0gY2FsY3VsYXRlU3BsaWNlcyhuZXdJdGVtcywgbGFzdEl0ZW1zKTtcbiAgICAgICAgICB0aGlzLl9fYXBwbHlTcGxpY2VzKHNwbGljZXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19sYXN0SXRlbXMgPSBuZXdJdGVtcztcbiAgICAgICAgdGhpcy5fX2xhc3RNdWx0aSA9IG11bHRpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc0luZm8ucGF0aCA9PSAnaXRlbXMuc3BsaWNlcycpIHtcbiAgICAgICAgLy8gQ2FzZSAyIC0gZ290IHNwZWNpZmljIHNwbGljZSBpbmZvcm1hdGlvbiBkZXNjcmliaW5nIHRoZSBhcnJheSBtdXRhdGlvbjpcbiAgICAgICAgLy8gZGVzZWxlY3QgYW55IHJlbW92ZWQgaXRlbXMgYW5kIGFkanVzdCBzZWxlY3RlZCBpbmRpY2VzXG4gICAgICAgIHRoaXMuX19hcHBseVNwbGljZXMoaXRlbXNJbmZvLnZhbHVlLmluZGV4U3BsaWNlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDYXNlIDMgLSBhbiBhcnJheSBlbGVtZW50IHdhcyBjaGFuZ2VkLCBzbyBkZXNlbGVjdCB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gaXRlbSBmb3IgdGhhdCBpbmRleCBpZiBpdCB3YXMgcHJldmlvdXNseSBzZWxlY3RlZFxuICAgICAgICBsZXQgcGFydCA9IHBhdGguc2xpY2UoJ2l0ZW1zLicubGVuZ3RoKTtcbiAgICAgICAgbGV0IGlkeCA9IHBhcnNlSW50KHBhcnQsIDEwKTtcbiAgICAgICAgaWYgKChwYXJ0LmluZGV4T2YoJy4nKSA8IDApICYmIHBhcnQgPT0gaWR4KSB7XG4gICAgICAgICAgdGhpcy5fX2Rlc2VsZWN0Q2hhbmdlZElkeChpZHgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19hcHBseVNwbGljZXMoc3BsaWNlcykge1xuICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy5fX3NlbGVjdGVkTWFwO1xuICAgICAgLy8gQWRqdXN0IHNlbGVjdGVkIGluZGljZXMgYW5kIG1hcmsgcmVtb3ZhbHNcbiAgICAgIGZvciAobGV0IGk9MDsgaTxzcGxpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzID0gc3BsaWNlc1tpXTtcbiAgICAgICAgc2VsZWN0ZWQuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKGlkeCA8IHMuaW5kZXgpIHtcbiAgICAgICAgICAgIC8vIG5vIGNoYW5nZVxuICAgICAgICAgIH0gZWxzZSBpZiAoaWR4ID49IHMuaW5kZXggKyBzLnJlbW92ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBhZGp1c3QgaW5kZXhcbiAgICAgICAgICAgIHNlbGVjdGVkLnNldChpdGVtLCBpZHggKyBzLmFkZGVkQ291bnQgLSBzLnJlbW92ZWQubGVuZ3RoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGluZGV4XG4gICAgICAgICAgICBzZWxlY3RlZC5zZXQoaXRlbSwgLTEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGZvciAobGV0IGo9MDsgajxzLmFkZGVkQ291bnQ7IGorKykge1xuICAgICAgICAgIGxldCBpZHggPSBzLmluZGV4ICsgajtcbiAgICAgICAgICBpZiAoc2VsZWN0ZWQuaGFzKHRoaXMuaXRlbXNbaWR4XSkpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkLnNldCh0aGlzLml0ZW1zW2lkeF0sIGlkeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBVcGRhdGUgbGlua2VkIHBhdGhzXG4gICAgICB0aGlzLl9fdXBkYXRlTGlua3MoKTtcbiAgICAgIC8vIFJlbW92ZSBzZWxlY3RlZCBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoZSBpdGVtcyBhcnJheVxuICAgICAgbGV0IHNpZHggPSAwO1xuICAgICAgc2VsZWN0ZWQuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgIGlmIChpZHggPCAwKSB7XG4gICAgICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgICAgIHRoaXMuc3BsaWNlKCdzZWxlY3RlZCcsIHNpZHgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZWxlY3RlZC5kZWxldGUoaXRlbSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2lkeCsrO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBfX3VwZGF0ZUxpbmtzKCkge1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRocyA9IHt9O1xuICAgICAgaWYgKHRoaXMubXVsdGkpIHtcbiAgICAgICAgbGV0IHNpZHggPSAwO1xuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ2l0ZW1zLicgKyBpZHgsICdzZWxlY3RlZC4nICsgc2lkeCsrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICB0aGlzLmxpbmtQYXRocygnc2VsZWN0ZWQnLCAnaXRlbXMuJyArIGlkeCk7XG4gICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3NlbGVjdGVkSXRlbScsICdpdGVtcy4nICsgaWR4KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBzZWxlY3Rpb24gc3RhdGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBjbGVhclNlbGVjdGlvbigpIHtcbiAgICAgIC8vIFVuYmluZCBwcmV2aW91cyBzZWxlY3Rpb25cbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB7fTtcbiAgICAgIC8vIFRoZSBzZWxlY3RlZCBtYXAgc3RvcmVzIDMgcGllY2VzIG9mIGluZm9ybWF0aW9uOlxuICAgICAgLy8ga2V5OiBpdGVtcyBhcnJheSBvYmplY3RcbiAgICAgIC8vIHZhbHVlOiBpdGVtcyBhcnJheSBpbmRleFxuICAgICAgLy8gb3JkZXI6IHNlbGVjdGVkIGFycmF5IGluZGV4XG4gICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAvLyBJbml0aWFsaXplIHNlbGVjdGlvblxuICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMubXVsdGkgPyBbXSA6IG51bGw7XG4gICAgICB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQoaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuX19zZWxlY3RlZE1hcC5oYXMoaXRlbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBpdGVtIGlzIGN1cnJlbnRseSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIHRlc3RcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICovXG4gICAgaXNJbmRleFNlbGVjdGVkKGlkeCkge1xuICAgICAgcmV0dXJuIHRoaXMuaXNTZWxlY3RlZCh0aGlzLml0ZW1zW2lkeF0pO1xuICAgIH1cblxuICAgIF9fZGVzZWxlY3RDaGFuZ2VkSWR4KGlkeCkge1xuICAgICAgbGV0IHNpZHggPSB0aGlzLl9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpO1xuICAgICAgaWYgKHNpZHggPj0gMCkge1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKChpZHgsIGl0ZW0pID0+IHtcbiAgICAgICAgICBpZiAoc2lkeCA9PSBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGVzZWxlY3QoaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgoaWR4KSB7XG4gICAgICBsZXQgc2VsZWN0ZWQgPSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzWydpdGVtcy4nICsgaWR4XTtcbiAgICAgIGlmIChzZWxlY3RlZCkge1xuICAgICAgICByZXR1cm4gcGFyc2VJbnQoc2VsZWN0ZWQuc2xpY2UoJ3NlbGVjdGVkLicubGVuZ3RoKSwgMTApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyB0aGUgZ2l2ZW4gaXRlbSBpZiBpdCBpcyBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gZnJvbSBgaXRlbXNgIGFycmF5IHRvIGRlc2VsZWN0XG4gICAgICovXG4gICAgZGVzZWxlY3QoaXRlbSkge1xuICAgICAgbGV0IGlkeCA9IHRoaXMuX19zZWxlY3RlZE1hcC5nZXQoaXRlbSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmRlbGV0ZShpdGVtKTtcbiAgICAgICAgbGV0IHNpZHg7XG4gICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgc2lkeCA9IHRoaXMuX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgdGhpcy5zcGxpY2UoJ3NlbGVjdGVkJywgc2lkeCwgMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VsZWN0cyB0aGUgZ2l2ZW4gaW5kZXggaWYgaXQgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIGRlc2VsZWN0XG4gICAgICovXG4gICAgZGVzZWxlY3RJbmRleChpZHgpIHtcbiAgICAgIHRoaXMuZGVzZWxlY3QodGhpcy5pdGVtc1tpZHhdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiBpdGVtLiAgV2hlbiBgdG9nZ2xlYCBpcyB0cnVlLCB0aGlzIHdpbGwgYXV0b21hdGljYWxseVxuICAgICAqIGRlc2VsZWN0IHRoZSBpdGVtIGlmIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gc2VsZWN0XG4gICAgICovXG4gICAgc2VsZWN0KGl0ZW0pIHtcbiAgICAgIHRoaXMuc2VsZWN0SW5kZXgodGhpcy5pdGVtcy5pbmRleE9mKGl0ZW0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZWxlY3RzIHRoZSBnaXZlbiBpbmRleC4gIFdoZW4gYHRvZ2dsZWAgaXMgdHJ1ZSwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBkZXNlbGVjdCB0aGUgaXRlbSBpZiBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeCBJbmRleCBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gc2VsZWN0XG4gICAgICovXG4gICAgc2VsZWN0SW5kZXgoaWR4KSB7XG4gICAgICBsZXQgaXRlbSA9IHRoaXMuaXRlbXNbaWR4XTtcbiAgICAgIGlmICghdGhpcy5pc1NlbGVjdGVkKGl0ZW0pKSB7XG4gICAgICAgIGlmICghdGhpcy5tdWx0aSkge1xuICAgICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5jbGVhcigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5zZXQoaXRlbSwgaWR4KTtcbiAgICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgdGhpcy5wdXNoKCdzZWxlY3RlZCcsIGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy50b2dnbGUpIHtcbiAgICAgICAgdGhpcy5kZXNlbGVjdEluZGV4KGlkeCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gQXJyYXlTZWxlY3Rvck1peGluO1xuXG59KTtcblxuZXhwb3J0IHsgQXJyYXlTZWxlY3Rvck1peGluIH07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7UG9seW1lci5FbGVtZW50fVxuICogQGltcGxlbWVudHMge1BvbHltZXJfQXJyYXlTZWxlY3Rvck1peGlufVxuICovXG5sZXQgYmFzZUFycmF5U2VsZWN0b3IgPSBBcnJheVNlbGVjdG9yTWl4aW4oRWxlbWVudCk7XG5cbi8qKlxuICogRWxlbWVudCBpbXBsZW1lbnRpbmcgdGhlIGBQb2x5bWVyLkFycmF5U2VsZWN0b3JgIG1peGluLCB3aGljaCByZWNvcmRzXG4gKiBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYSBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYVxuICogYHNlbGVjdGVkYCBhcnJheSBzdWNoIHRoYXQgcGF0aCBjaGFuZ2VzIHRvIHRoZSBtYXN0ZXIgYXJyYXkgKGF0IHRoZSBob3N0KVxuICogZWxlbWVudCBvciBlbHNld2hlcmUgdmlhIGRhdGEtYmluZGluZykgYXJlIGNvcnJlY3RseSBwcm9wYWdhdGVkIHRvIGl0ZW1zXG4gKiBpbiB0aGUgc2VsZWN0ZWQgYXJyYXkgYW5kIHZpY2UtdmVyc2EuXG4gKlxuICogVGhlIGBpdGVtc2AgcHJvcGVydHkgYWNjZXB0cyBhbiBhcnJheSBvZiB1c2VyIGRhdGEsIGFuZCB2aWEgdGhlXG4gKiBgc2VsZWN0KGl0ZW0pYCBhbmQgYGRlc2VsZWN0KGl0ZW0pYCBBUEksIHVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcHJvcGVydHlcbiAqIHdoaWNoIG1heSBiZSBib3VuZCB0byBvdGhlciBwYXJ0cyBvZiB0aGUgYXBwbGljYXRpb24sIGFuZCBhbnkgY2hhbmdlcyB0b1xuICogc3ViLWZpZWxkcyBvZiBgc2VsZWN0ZWRgIGl0ZW0ocykgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCBpdGVtcyBpbiB0aGVcbiAqIGBpdGVtc2AgYXJyYXkuICBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIGBzZWxlY3RlZGAgaXMgYSBwcm9wZXJ0eVxuICogcmVwcmVzZW50aW5nIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW0uICBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgYHNlbGVjdGVkYFxuICogaXMgYW4gYXJyYXkgb2YgbXVsdGlwbHkgc2VsZWN0ZWQgaXRlbXMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBodG1sXG4gKiA8ZG9tLW1vZHVsZSBpZD1cImVtcGxveWVlLWxpc3RcIj5cbiAqXG4gKiAgIDx0ZW1wbGF0ZT5cbiAqXG4gKiAgICAgPGRpdj4gRW1wbG95ZWUgbGlzdDogPC9kaXY+XG4gKiAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLXJlcGVhdFwiIGlkPVwiZW1wbG95ZWVMaXN0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCI+XG4gKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgICAgIDxkaXY+TGFzdCBuYW1lOiA8c3Bhbj57e2l0ZW0ubGFzdH19PC9zcGFuPjwvZGl2PlxuICogICAgICAgICA8YnV0dG9uIG9uLWNsaWNrPVwidG9nZ2xlU2VsZWN0aW9uXCI+U2VsZWN0PC9idXR0b24+XG4gKiAgICAgPC90ZW1wbGF0ZT5cbiAqXG4gKiAgICAgPGFycmF5LXNlbGVjdG9yIGlkPVwic2VsZWN0b3JcIiBpdGVtcz1cInt7ZW1wbG95ZWVzfX1cIiBzZWxlY3RlZD1cInt7c2VsZWN0ZWR9fVwiIG11bHRpIHRvZ2dsZT48L2FycmF5LXNlbGVjdG9yPlxuICpcbiAqICAgICA8ZGl2PiBTZWxlY3RlZCBlbXBsb3llZXM6IDwvZGl2PlxuICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpdGVtcz1cInt7c2VsZWN0ZWR9fVwiPlxuICogICAgICAgICA8ZGl2PkZpcnN0IG5hbWU6IDxzcGFuPnt7aXRlbS5maXJzdH19PC9zcGFuPjwvZGl2PlxuICogICAgICAgICA8ZGl2Pkxhc3QgbmFtZTogPHNwYW4+e3tpdGVtLmxhc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICA8L3RlbXBsYXRlPlxuICpcbiAqICAgPC90ZW1wbGF0ZT5cbiAqXG4gKiA8L2RvbS1tb2R1bGU+XG4gKiBgYGBcbiAqXG4gKiBgYGBqc1xuICogUG9seW1lcih7XG4gKiAgIGlzOiAnZW1wbG95ZWUtbGlzdCcsXG4gKiAgIHJlYWR5KCkge1xuICogICAgIHRoaXMuZW1wbG95ZWVzID0gW1xuICogICAgICAgICB7Zmlyc3Q6ICdCb2InLCBsYXN0OiAnU21pdGgnfSxcbiAqICAgICAgICAge2ZpcnN0OiAnU2FsbHknLCBsYXN0OiAnSm9obnNvbid9LFxuICogICAgICAgICAuLi5cbiAqICAgICBdO1xuICogICB9LFxuICogICB0b2dnbGVTZWxlY3Rpb24oZSkge1xuICogICAgIGxldCBpdGVtID0gdGhpcy4kLmVtcGxveWVlTGlzdC5pdGVtRm9yRWxlbWVudChlLnRhcmdldCk7XG4gKiAgICAgdGhpcy4kLnNlbGVjdG9yLnNlbGVjdChpdGVtKTtcbiAqICAgfVxuICogfSk7XG4gKiBgYGBcbiAqXG4gKiBAcG9seW1lclxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBleHRlbmRzIHtiYXNlQXJyYXlTZWxlY3Rvcn1cbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5BcnJheVNlbGVjdG9yTWl4aW5cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCB0aGF0IGxpbmtzIHBhdGhzIGJldHdlZW4gYW4gaW5wdXQgYGl0ZW1zYCBhcnJheSBhbmRcbiAqICAgYW4gb3V0cHV0IGBzZWxlY3RlZGAgaXRlbSBvciBhcnJheSBiYXNlZCBvbiBjYWxscyB0byBpdHMgc2VsZWN0aW9uIEFQSS5cbiAqL1xuY2xhc3MgQXJyYXlTZWxlY3RvciBleHRlbmRzIGJhc2VBcnJheVNlbGVjdG9yIHtcbiAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2FycmF5LXNlbGVjdG9yJzsgfVxufVxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKEFycmF5U2VsZWN0b3IuaXMsIEFycmF5U2VsZWN0b3IpO1xuZXhwb3J0IHsgQXJyYXlTZWxlY3RvciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvYXJyYXktc2VsZWN0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vLi4vLi4vLi4vQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qcyc7XG5pbXBvcnQgeyBjc3NGcm9tTW9kdWxlcyB9IGZyb20gJy4uL3V0aWxzL3N0eWxlLWdhdGhlci5qcyc7XG5cbmNvbnN0IGF0dHIgPSAnaW5jbHVkZSc7XG5cbmNvbnN0IEN1c3RvbVN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuXG4vKipcbiAqIEN1c3RvbSBlbGVtZW50IGZvciBkZWZpbmluZyBzdHlsZXMgaW4gdGhlIG1haW4gZG9jdW1lbnQgdGhhdCBjYW4gdGFrZVxuICogYWR2YW50YWdlIG9mIFtzaGFkeSBET01dKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5Y3NzKSBzaGltc1xuICogZm9yIHN0eWxlIGVuY2Fwc3VsYXRpb24sIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgY3VzdG9tIG1peGlucy5cbiAqXG4gKiAtIERvY3VtZW50IHN0eWxlcyBkZWZpbmVkIGluIGEgYDxjdXN0b20tc3R5bGU+YCBhcmUgc2hpbW1lZCB0byBlbnN1cmUgdGhleVxuICogICBkbyBub3QgbGVhayBpbnRvIGxvY2FsIERPTSB3aGVuIHJ1bm5pbmcgb24gYnJvd3NlcnMgd2l0aG91dCBuYXRpdmVcbiAqICAgU2hhZG93IERPTS5cbiAqIC0gQ3VzdG9tIHByb3BlcnRpZXMgY2FuIGJlIGRlZmluZWQgaW4gYSBgPGN1c3RvbS1zdHlsZT5gLiBVc2UgdGhlIGBodG1sYCBzZWxlY3RvclxuICogICB0byBkZWZpbmUgY3VzdG9tIHByb3BlcnRpZXMgdGhhdCBhcHBseSB0byBhbGwgY3VzdG9tIGVsZW1lbnRzLlxuICogLSBDdXN0b20gbWl4aW5zIGNhbiBiZSBkZWZpbmVkIGluIGEgYDxjdXN0b20tc3R5bGU+YCwgaWYgeW91IGltcG9ydCB0aGUgb3B0aW9uYWxcbiAqICAgW2FwcGx5IHNoaW1dKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5Y3NzI2Fib3V0LWFwcGx5c2hpbSlcbiAqICAgKGBzaGFkeWNzcy9hcHBseS1zaGltLmh0bWxgKS5cbiAqXG4gKiBUbyB1c2U6XG4gKlxuICogLSBJbXBvcnQgYGN1c3RvbS1zdHlsZS5odG1sYC5cbiAqIC0gUGxhY2UgYSBgPGN1c3RvbS1zdHlsZT5gIGVsZW1lbnQgaW4gdGhlIG1haW4gZG9jdW1lbnQsIHdyYXBwaW5nIGFuIGlubGluZSBgPHN0eWxlPmAgdGFnIHRoYXRcbiAqICAgY29udGFpbnMgdGhlIENTUyBydWxlcyB5b3Ugd2FudCB0byBzaGltLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYFxuICogPCEtLSBpbXBvcnQgYXBwbHkgc2hpbS0tb25seSByZXF1aXJlZCBpZiB1c2luZyBtaXhpbnMgLS0+XG4gKiA8bGluayByZWw9XCJpbXBvcnQgaHJlZj1cImJvd2VyX2NvbXBvbmVudHMvc2hhZHljc3MvYXBwbHktc2hpbS5odG1sXCI+XG4gKiA8IS0tIGltcG9ydCBjdXN0b20tc3R5bGUgZWxlbWVudCAtLT5cbiAqIDxsaW5rIHJlbD1cImltcG9ydFwiIGhyZWY9XCJib3dlcl9jb21wb25lbnRzL3BvbHltZXIvbGliL2VsZW1lbnRzL2N1c3RvbS1zdHlsZS5odG1sXCI+XG4gKiAuLi5cbiAqIDxjdXN0b20tc3R5bGU+XG4gKiAgIDxzdHlsZT5cbiAqICAgICBodG1sIHtcbiAqICAgICAgIC0tY3VzdG9tLWNvbG9yOiBibHVlO1xuICogICAgICAgLS1jdXN0b20tbWl4aW46IHtcbiAqICAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gKiAgICAgICAgIGNvbG9yOiByZWQ7XG4gKiAgICAgICB9O1xuICogICAgIH1cbiAqICAgPC9zdHlsZT5cbiAqIDwvY3VzdG9tLXN0eWxlPlxuICogYGBgXG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgZm9yIGRlZmluaW5nIHN0eWxlcyBpbiB0aGUgbWFpbiBkb2N1bWVudCB0aGF0IGNhblxuICogICB0YWtlIGFkdmFudGFnZSBvZiBQb2x5bWVyJ3Mgc3R5bGUgc2NvcGluZyBhbmQgY3VzdG9tIHByb3BlcnRpZXMgc2hpbXMuXG4gKi9cbmNsYXNzIEN1c3RvbVN0eWxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3N0eWxlID0gbnVsbDtcbiAgICBDdXN0b21TdHlsZUludGVyZmFjZS5hZGRDdXN0b21TdHlsZSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlnaHQtRE9NIGA8c3R5bGU+YCBjaGlsZCB0aGlzIGVsZW1lbnQgd3JhcHMuICBVcG9uIGZpcnN0XG4gICAqIGNhbGwgYW55IHN0eWxlIG1vZHVsZXMgcmVmZXJlbmNlZCB2aWEgdGhlIGBpbmNsdWRlYCBhdHRyaWJ1dGUgd2lsbCBiZVxuICAgKiBjb25jYXRlbmF0ZWQgdG8gdGhpcyBlbGVtZW50J3MgYDxzdHlsZT5gLlxuICAgKlxuICAgKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fSBUaGlzIGVsZW1lbnQncyBsaWdodC1ET00gYDxzdHlsZT5gXG4gICAqL1xuICBnZXRTdHlsZSgpIHtcbiAgICBpZiAodGhpcy5fc3R5bGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9zdHlsZTtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovKHRoaXMucXVlcnlTZWxlY3Rvcignc3R5bGUnKSk7XG4gICAgaWYgKCFzdHlsZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHRoaXMuX3N0eWxlID0gc3R5bGU7XG4gICAgY29uc3QgaW5jbHVkZSA9IHN0eWxlLmdldEF0dHJpYnV0ZShhdHRyKTtcbiAgICBpZiAoaW5jbHVkZSkge1xuICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKGF0dHIpO1xuICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3NGcm9tTW9kdWxlcyhpbmNsdWRlKSArIHN0eWxlLnRleHRDb250ZW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gIH1cbn1cblxud2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnY3VzdG9tLXN0eWxlJywgQ3VzdG9tU3R5bGUpO1xuZXhwb3J0IHsgQ3VzdG9tU3R5bGUgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2N1c3RvbS1zdHlsZS5qc1xuLy8gbW9kdWxlIGlkID0gNjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQ3VzdG9tU3R5bGVJbnRlcmZhY2UgZnJvbSAnLi4vc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMnO1xuaW1wb3J0IHtnZXRDb21wdXRlZFN0eWxlVmFsdWUsIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXN9IGZyb20gJy4uL3NyYy9jb21tb24tdXRpbHMuanMnO1xuaW1wb3J0IHtuYXRpdmVDc3NWYXJpYWJsZXMsIG5hdGl2ZVNoYWRvd30gZnJvbSAnLi4vc3JjL3N0eWxlLXNldHRpbmdzLmpzJztcblxuY29uc3QgY3VzdG9tU3R5bGVJbnRlcmZhY2UgPSBuZXcgQ3VzdG9tU3R5bGVJbnRlcmZhY2UoKTtcblxuaWYgKCF3aW5kb3cuU2hhZHlDU1MpIHtcbiAgd2luZG93LlNoYWR5Q1NTID0ge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IGVsZW1lbnRFeHRlbmRzXG4gICAgICovXG4gICAgcHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSwgZWxlbWVudEV4dGVuZHMpIHt9LCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdHlsZVN1YnRyZWUoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgICAgY3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvY2Vzc1N0eWxlcygpO1xuICAgICAgdXBkYXRlTmF0aXZlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICovXG4gICAgc3R5bGVFbGVtZW50KGVsZW1lbnQpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgICAgY3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvY2Vzc1N0eWxlcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBzdHlsZURvY3VtZW50KHByb3BlcnRpZXMpIHtcbiAgICAgIGN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb2Nlc3NTdHlsZXMoKTtcbiAgICAgIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMoZG9jdW1lbnQuYm9keSwgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICAgIHJldHVybiBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpO1xuICAgIH0sXG4gICAgbmF0aXZlQ3NzOiBuYXRpdmVDc3NWYXJpYWJsZXMsXG4gICAgbmF0aXZlU2hhZG93OiBuYXRpdmVTaGFkb3dcbiAgfVxufVxuXG53aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2UgPSBjdXN0b21TdHlsZUludGVyZmFjZTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9lbnRyeXBvaW50cy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzXG4vLyBtb2R1bGUgaWQgPSA2OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBNdXRhYmxlRGF0YSB9IGZyb20gJy4uL21peGlucy9tdXRhYmxlLWRhdGEuanMnO1xuXG5sZXQgbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xuKFxuICAvKiogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gKi9cbiAgKGZ1bmN0aW9uKCkge1xuICBtdXRhYmxlUHJvcGVydHlDaGFuZ2UgPSBNdXRhYmxlRGF0YS5fbXV0YWJsZVByb3BlcnR5Q2hhbmdlO1xufSkpKCk7XG5cbmV4cG9ydCBjb25zdCBNdXRhYmxlRGF0YUJlaGF2aW9yID0ge1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBwcm92aWRlIG9wdGlvbiBmb3Igc2tpcHBpbmdcbiAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYFxuICAgKiBjYWNoZSAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zaG91bGRQcm9wZXJ0eUNoYW5nZShwcm9wZXJ0eSwgdmFsdWUsIG9sZCkge1xuICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRydWUpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgT3B0aW9uYWxNdXRhYmxlRGF0YUJlaGF2aW9yID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBJbnN0YW5jZS1sZXZlbCBmbGFnIGZvciBjb25maWd1cmluZyB0aGUgZGlydHktY2hlY2tpbmcgc3RyYXRlZ3lcbiAgICAgKiBmb3IgdGhpcyBlbGVtZW50LiAgV2hlbiB0cnVlLCBPYmplY3RzIGFuZCBBcnJheXMgd2lsbCBza2lwIGRpcnR5XG4gICAgICogY2hlY2tpbmcsIG90aGVyd2lzZSBzdHJpY3QgZXF1YWxpdHkgY2hlY2tpbmcgd2lsbCBiZSB1c2VkLlxuICAgICAqL1xuICAgIG11dGFibGVEYXRhOiBCb29sZWFuXG4gIH0sXG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHNraXAgc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nXG4gICAqIGZvciBPYmplY3RzIGFuZCBBcnJheXMuXG4gICAqXG4gICAqIFB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYCBjYWNoZVxuICAgKiAocmF0aGVyIHRoYW4gdGhlIG5vcm1hbCBgX19kYXRhYCBjYWNoZSkgZm9yIE9iamVjdHMuICBTaW5jZSB0aGUgdGVtcFxuICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICogc2FtZSBvYmplY3QgKHVzaW5nIHRoZSB0ZW1wIGNhY2hlIGFzIGFuIGluLXR1cm4gYmFja3N0b3AgdG8gcHJldmVudFxuICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSBjb25zaWRlcmVkIGEgY2hhbmdlXG4gICAqIEB0aGlzIHt0aGlzfVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0aGlzLm11dGFibGVEYXRhKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9tdXRhYmxlLWRhdGEtYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDcwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IE5lb25BbmltYXRpb25SdW5uZXJCZWhhdmlvciB9IGZyb20gJy4uL25lb24tYW5pbWF0aW9uL25lb24tYW5pbWF0aW9uLXJ1bm5lci1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBQYXBlckRpYWxvZ0JlaGF2aW9yIH0gZnJvbSAnLi4vcGFwZXItZGlhbG9nLWJlaGF2aW9yL3BhcGVyLWRpYWxvZy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLWRpYWxvZy1iZWhhdmlvci9wYXBlci1kaWFsb2ctc2hhcmVkLXN0eWxlcy5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlIGluY2x1ZGU9XCJwYXBlci1kaWFsb2ctc2hhcmVkLXN0eWxlc1wiPjwvc3R5bGU+XG4gICAgPHNsb3Q+PC9zbG90PlxuYCxcblxuICBpczogJ3BhcGVyLWRpYWxvZycsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgUGFwZXJEaWFsb2dCZWhhdmlvcixcbiAgICBOZW9uQW5pbWF0aW9uUnVubmVyQmVoYXZpb3JcbiAgXSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICAnbmVvbi1hbmltYXRpb24tZmluaXNoJzogJ19vbk5lb25BbmltYXRpb25GaW5pc2gnXG4gIH0sXG5cbiAgX3JlbmRlck9wZW5lZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICB0aGlzLnBsYXlBbmltYXRpb24oJ2VudHJ5Jyk7XG4gIH0sXG5cbiAgX3JlbmRlckNsb3NlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICB0aGlzLnBsYXlBbmltYXRpb24oJ2V4aXQnKTtcbiAgfSxcblxuICBfb25OZW9uQW5pbWF0aW9uRmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaFJlbmRlck9wZW5lZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9maW5pc2hSZW5kZXJDbG9zZWQoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItZGlhbG9nL3BhcGVyLWRpYWxvZy5qc1xuLy8gbW9kdWxlIGlkID0gNzFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgTmVvbkFuaW1hdGFibGVCZWhhdmlvciB9IGZyb20gJy4vbmVvbi1hbmltYXRhYmxlLWJlaGF2aW9yLmpzJztcblxuZXhwb3J0IGNvbnN0IE5lb25BbmltYXRpb25SdW5uZXJCZWhhdmlvckltcGwgPSB7XG5cbiAgX2NvbmZpZ3VyZUFuaW1hdGlvbnM6IGZ1bmN0aW9uKGNvbmZpZ3MpIHtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIGlmIChjb25maWdzLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGNvbmZpZywgaW5kZXggPSAwOyBjb25maWcgPSBjb25maWdzW2luZGV4XTsgaW5kZXgrKykge1xuICAgICAgICB2YXIgbmVvbkFuaW1hdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoY29uZmlnLm5hbWUpO1xuICAgICAgICAvLyBpcyB0aGlzIGVsZW1lbnQgYWN0dWFsbHkgYSBuZW9uIGFuaW1hdGlvbj9cbiAgICAgICAgaWYgKG5lb25BbmltYXRpb24uaXNOZW9uQW5pbWF0aW9uKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgLy8gY29uZmlndXJhdGlvbiBvciBwbGF5IGNvdWxkIGZhaWwgaWYgcG9seWZpbGxzIGFyZW4ndCBsb2FkZWRcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmVvbkFuaW1hdGlvbi5jb25maWd1cmUoY29uZmlnKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYW4gRWZmZWN0IHJhdGhlciB0aGFuIGFuIEFuaW1hdGlvblxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQuY2FuY2VsICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZG9jdW1lbnQudGltZWxpbmUucGxheShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkbnQgcGxheScsICcoJywgY29uZmlnLm5hbWUsICcpLicsIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBuZW9uQW5pbWF0aW9uOiBuZW9uQW5pbWF0aW9uLFxuICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgICAgICAgYW5pbWF0aW9uOiByZXN1bHQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKHRoaXMuaXMgKyAnOicsIGNvbmZpZy5uYW1lLCAnbm90IGZvdW5kIScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHRzO1xuICB9LFxuXG4gIF9zaG91bGRDb21wbGV0ZTogZnVuY3Rpb24oYWN0aXZlRW50cmllcykge1xuICAgIHZhciBmaW5pc2hlZCA9IHRydWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmVFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYWN0aXZlRW50cmllc1tpXS5hbmltYXRpb24ucGxheVN0YXRlICE9ICdmaW5pc2hlZCcpIHtcbiAgICAgICAgZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaW5pc2hlZDtcbiAgfSxcblxuICBfY29tcGxldGU6IGZ1bmN0aW9uKGFjdGl2ZUVudHJpZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGl2ZUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2ZUVudHJpZXNbaV0ubmVvbkFuaW1hdGlvbi5jb21wbGV0ZShhY3RpdmVFbnRyaWVzW2ldLmNvbmZpZyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aXZlRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZlRW50cmllc1tpXS5hbmltYXRpb24uY2FuY2VsKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQbGF5cyBhbiBhbmltYXRpb24gd2l0aCBhbiBvcHRpb25hbCBgdHlwZWAuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZVxuICAgKiBAcGFyYW0geyFPYmplY3Q9fSBjb29raWVcbiAgICovXG4gIHBsYXlBbmltYXRpb246IGZ1bmN0aW9uKHR5cGUsIGNvb2tpZSkge1xuICAgIHZhciBjb25maWdzID0gdGhpcy5nZXRBbmltYXRpb25Db25maWcodHlwZSk7XG4gICAgaWYgKCFjb25maWdzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2FjdGl2ZSA9IHRoaXMuX2FjdGl2ZSB8fCB7fTtcbiAgICBpZiAodGhpcy5fYWN0aXZlW3R5cGVdKSB7XG4gICAgICB0aGlzLl9jb21wbGV0ZSh0aGlzLl9hY3RpdmVbdHlwZV0pO1xuICAgICAgZGVsZXRlIHRoaXMuX2FjdGl2ZVt0eXBlXTtcbiAgICB9XG5cbiAgICB2YXIgYWN0aXZlRW50cmllcyA9IHRoaXMuX2NvbmZpZ3VyZUFuaW1hdGlvbnMoY29uZmlncyk7XG5cbiAgICBpZiAoYWN0aXZlRW50cmllcy5sZW5ndGggPT0gMCkge1xuICAgICAgdGhpcy5maXJlKCduZW9uLWFuaW1hdGlvbi1maW5pc2gnLCBjb29raWUsIHtidWJibGVzOiBmYWxzZX0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2FjdGl2ZVt0eXBlXSA9IGFjdGl2ZUVudHJpZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGl2ZUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2ZUVudHJpZXNbaV0uYW5pbWF0aW9uLm9uZmluaXNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRDb21wbGV0ZShhY3RpdmVFbnRyaWVzKSkge1xuICAgICAgICAgIHRoaXMuX2NvbXBsZXRlKGFjdGl2ZUVudHJpZXMpO1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hY3RpdmVbdHlwZV07XG4gICAgICAgICAgdGhpcy5maXJlKCduZW9uLWFuaW1hdGlvbi1maW5pc2gnLCBjb29raWUsIHtidWJibGVzOiBmYWxzZX0pO1xuICAgICAgICB9XG4gICAgICB9LmJpbmQodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIHRoZSBjdXJyZW50bHkgcnVubmluZyBhbmltYXRpb25zLlxuICAgKi9cbiAgY2FuY2VsQW5pbWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICBmb3IgKHZhciBrIGluIHRoaXMuX2FuaW1hdGlvbnMpIHtcbiAgICAgIHRoaXMuX2FuaW1hdGlvbnNba10uY2FuY2VsKCk7XG4gICAgfVxuICAgIHRoaXMuX2FuaW1hdGlvbnMgPSB7fTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IE5lb25BbmltYXRpb25SdW5uZXJCZWhhdmlvciA9IFtcbiAgTmVvbkFuaW1hdGFibGVCZWhhdmlvcixcbiAgTmVvbkFuaW1hdGlvblJ1bm5lckJlaGF2aW9ySW1wbFxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL25lb24tYW5pbWF0aW9uL25lb24tYW5pbWF0aW9uLXJ1bm5lci1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNzJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuXG5leHBvcnQgY29uc3QgTmVvbkFuaW1hdGFibGVCZWhhdmlvciA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBBbmltYXRpb24gY29uZmlndXJhdGlvbi4gU2VlIFJFQURNRSBmb3IgbW9yZSBpbmZvLlxuICAgICAqL1xuICAgIGFuaW1hdGlvbkNvbmZpZzoge1xuICAgICAgdHlwZTogT2JqZWN0XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHByb3BlcnR5IGZvciBzZXR0aW5nIGFuICdlbnRyeScgYW5pbWF0aW9uLiBEbyBub3Qgc2V0IGBhbmltYXRpb25Db25maWcuZW50cnlgXG4gICAgICogbWFudWFsbHkgaWYgdXNpbmcgdGhpcy4gVGhlIGFuaW1hdGVkIG5vZGUgaXMgc2V0IHRvIGB0aGlzYCBpZiB1c2luZyB0aGlzIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGVudHJ5QW5pbWF0aW9uOiB7XG4gICAgICBvYnNlcnZlcjogJ19lbnRyeUFuaW1hdGlvbkNoYW5nZWQnLFxuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIHByb3BlcnR5IGZvciBzZXR0aW5nIGFuICdleGl0JyBhbmltYXRpb24uIERvIG5vdCBzZXQgYGFuaW1hdGlvbkNvbmZpZy5leGl0YFxuICAgICAqIG1hbnVhbGx5IGlmIHVzaW5nIHRoaXMuIFRoZSBhbmltYXRlZCBub2RlIGlzIHNldCB0byBgdGhpc2AgaWYgdXNpbmcgdGhpcyBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBleGl0QW5pbWF0aW9uOiB7XG4gICAgICBvYnNlcnZlcjogJ19leGl0QW5pbWF0aW9uQ2hhbmdlZCcsXG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9XG5cbiAgfSxcblxuICBfZW50cnlBbmltYXRpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkNvbmZpZyA9IHRoaXMuYW5pbWF0aW9uQ29uZmlnIHx8IHt9O1xuICAgIHRoaXMuYW5pbWF0aW9uQ29uZmlnWydlbnRyeSddID0gW3tcbiAgICAgIG5hbWU6IHRoaXMuZW50cnlBbmltYXRpb24sXG4gICAgICBub2RlOiB0aGlzXG4gICAgfV07XG4gIH0sXG5cbiAgX2V4aXRBbmltYXRpb25DaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkNvbmZpZyA9IHRoaXMuYW5pbWF0aW9uQ29uZmlnIHx8IHt9O1xuICAgIHRoaXMuYW5pbWF0aW9uQ29uZmlnWydleGl0J10gPSBbe1xuICAgICAgbmFtZTogdGhpcy5leGl0QW5pbWF0aW9uLFxuICAgICAgbm9kZTogdGhpc1xuICAgIH1dO1xuICB9LFxuXG4gIF9jb3B5UHJvcGVydGllczogZnVuY3Rpb24oY29uZmlnMSwgY29uZmlnMikge1xuICAgIC8vIHNoYWxsb3dseSBjb3B5IHByb3BlcnRpZXMgZnJvbSBjb25maWcyIHRvIGNvbmZpZzFcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWcxW3Byb3BlcnR5XSA9IGNvbmZpZzJbcHJvcGVydHldO1xuICAgIH1cbiAgfSxcblxuICBfY2xvbmVDb25maWc6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgIHZhciBjbG9uZSA9IHtcbiAgICAgIGlzQ2xvbmU6IHRydWVcbiAgICB9O1xuICAgIHRoaXMuX2NvcHlQcm9wZXJ0aWVzKGNsb25lLCBjb25maWcpO1xuICAgIHJldHVybiBjbG9uZTtcbiAgfSxcblxuICBfZ2V0QW5pbWF0aW9uQ29uZmlnUmVjdXJzaXZlOiBmdW5jdGlvbih0eXBlLCBtYXAsIGFsbENvbmZpZ3MpIHtcbiAgICBpZiAoIXRoaXMuYW5pbWF0aW9uQ29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYodGhpcy5hbmltYXRpb25Db25maWcudmFsdWUgJiYgdHlwZW9mIHRoaXMuYW5pbWF0aW9uQ29uZmlnLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLl93YXJuKHRoaXMuX2xvZ2YoJ3BsYXlBbmltYXRpb24nLCBcIlBsZWFzZSBwdXQgJ2FuaW1hdGlvbkNvbmZpZycgaW5zaWRlIG9mIHlvdXIgY29tcG9uZW50cyAncHJvcGVydGllcycgb2JqZWN0IGluc3RlYWQgb2Ygb3V0c2lkZSBvZiBpdC5cIikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHR5cGUgaXMgb3B0aW9uYWxcbiAgICB2YXIgdGhpc0NvbmZpZztcbiAgICBpZiAodHlwZSkge1xuICAgICAgdGhpc0NvbmZpZyA9IHRoaXMuYW5pbWF0aW9uQ29uZmlnW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzQ29uZmlnID0gdGhpcy5hbmltYXRpb25Db25maWc7XG4gICAgfVxuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXNDb25maWcpKSB7XG4gICAgICB0aGlzQ29uZmlnID0gW3RoaXNDb25maWddO1xuICAgIH1cblxuICAgIC8vIGl0ZXJhdGUgYW5pbWF0aW9ucyBhbmQgcmVjdXJzZSB0byBwcm9jZXNzIGNvbmZpZ3VyYXRpb25zIGZyb20gY2hpbGQgbm9kZXNcbiAgICBpZiAodGhpc0NvbmZpZykge1xuICAgICAgZm9yICh2YXIgY29uZmlnLCBpbmRleCA9IDA7IGNvbmZpZyA9IHRoaXNDb25maWdbaW5kZXhdOyBpbmRleCsrKSB7XG4gICAgICAgIGlmIChjb25maWcuYW5pbWF0YWJsZSkge1xuICAgICAgICAgIGNvbmZpZy5hbmltYXRhYmxlLl9nZXRBbmltYXRpb25Db25maWdSZWN1cnNpdmUoY29uZmlnLnR5cGUgfHwgdHlwZSwgbWFwLCBhbGxDb25maWdzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29uZmlnLmlkKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGVkQ29uZmlnID0gbWFwW2NvbmZpZy5pZF07XG4gICAgICAgICAgICBpZiAoY2FjaGVkQ29uZmlnKSB7XG4gICAgICAgICAgICAgIC8vIG1lcmdlIGNvbmZpZ3VyYXRpb25zIHdpdGggdGhlIHNhbWUgaWQsIG1ha2luZyBhIGNsb25lIGxhemlseVxuICAgICAgICAgICAgICBpZiAoIWNhY2hlZENvbmZpZy5pc0Nsb25lKSB7XG4gICAgICAgICAgICAgICAgbWFwW2NvbmZpZy5pZF0gPSB0aGlzLl9jbG9uZUNvbmZpZyhjYWNoZWRDb25maWcpO1xuICAgICAgICAgICAgICAgIGNhY2hlZENvbmZpZyA9IG1hcFtjb25maWcuaWRdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX2NvcHlQcm9wZXJ0aWVzKGNhY2hlZENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIHB1dCBhbnkgY29uZmlncyB3aXRoIGFuIGlkIGludG8gYSBtYXBcbiAgICAgICAgICAgICAgbWFwW2NvbmZpZy5pZF0gPSBjb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFsbENvbmZpZ3MucHVzaChjb25maWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQW4gZWxlbWVudCBpbXBsZW1lbnRpbmcgYFBvbHltZXIuTmVvbkFuaW1hdGlvblJ1bm5lckJlaGF2aW9yYCBjYWxscyB0aGlzIG1ldGhvZCB0byBjb25maWd1cmVcbiAgICogYW4gYW5pbWF0aW9uIHdpdGggYW4gb3B0aW9uYWwgdHlwZS4gRWxlbWVudHMgaW1wbGVtZW50aW5nIGBQb2x5bWVyLk5lb25BbmltYXRhYmxlQmVoYXZpb3JgXG4gICAqIHNob3VsZCBkZWZpbmUgdGhlIHByb3BlcnR5IGBhbmltYXRpb25Db25maWdgLCB3aGljaCBpcyBlaXRoZXIgYSBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKiBvciBhIG1hcCBvZiBhbmltYXRpb24gdHlwZSB0byBhcnJheSBvZiBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gICAqL1xuICBnZXRBbmltYXRpb25Db25maWc6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICB2YXIgbWFwID0ge307XG4gICAgdmFyIGFsbENvbmZpZ3MgPSBbXTtcbiAgICB0aGlzLl9nZXRBbmltYXRpb25Db25maWdSZWN1cnNpdmUodHlwZSwgbWFwLCBhbGxDb25maWdzKTtcbiAgICAvLyBhcHBlbmQgdGhlIGNvbmZpZ3VyYXRpb25zIHNhdmVkIGluIHRoZSBtYXAgdG8gdGhlIGFycmF5XG4gICAgZm9yICh2YXIga2V5IGluIG1hcCkge1xuICAgICAgYWxsQ29uZmlncy5wdXNoKG1hcFtrZXldKTtcbiAgICB9XG4gICAgcmV0dXJuIGFsbENvbmZpZ3M7XG4gIH1cblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL25lb24tYW5pbWF0aW9uL25lb24tYW5pbWF0YWJsZS1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNzNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbk92ZXJsYXlCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tb3ZlcmxheS1iZWhhdmlvci9pcm9uLW92ZXJsYXktYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IFBhcGVyRGlhbG9nQmVoYXZpb3JJbXBsID0ge1xuXG4gIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgJ3JvbGUnOiAnZGlhbG9nJyxcbiAgICAndGFiaW5kZXgnOiAnLTEnXG4gIH0sXG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogSWYgYG1vZGFsYCBpcyB0cnVlLCB0aGlzIGltcGxpZXMgYG5vLWNhbmNlbC1vbi1vdXRzaWRlLWNsaWNrYCwgYG5vLWNhbmNlbC1vbi1lc2Mta2V5YCBhbmQgYHdpdGgtYmFja2Ryb3BgLlxuICAgICAqL1xuICAgIG1vZGFsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIF9fcmVhZGllZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH1cblxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfbW9kYWxDaGFuZ2VkKG1vZGFsLCBfX3JlYWRpZWQpJ1xuICBdLFxuXG4gIGxpc3RlbmVyczoge1xuICAgICd0YXAnOiAnX29uRGlhbG9nQ2xpY2snXG4gIH0sXG5cbiAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE9ubHkgbm93IHRoZXNlIHByb3BlcnRpZXMgY2FuIGJlIHJlYWQuXG4gICAgdGhpcy5fX3ByZXZOb0NhbmNlbE9uT3V0c2lkZUNsaWNrID0gdGhpcy5ub0NhbmNlbE9uT3V0c2lkZUNsaWNrO1xuICAgIHRoaXMuX19wcmV2Tm9DYW5jZWxPbkVzY0tleSA9IHRoaXMubm9DYW5jZWxPbkVzY0tleTtcbiAgICB0aGlzLl9fcHJldldpdGhCYWNrZHJvcCA9IHRoaXMud2l0aEJhY2tkcm9wO1xuICAgIHRoaXMuX19yZWFkaWVkID0gdHJ1ZTtcbiAgfSxcblxuICBfbW9kYWxDaGFuZ2VkOiBmdW5jdGlvbihtb2RhbCwgcmVhZGllZCkge1xuICAgIC8vIG1vZGFsIGltcGxpZXMgbm9DYW5jZWxPbk91dHNpZGVDbGljaywgbm9DYW5jZWxPbkVzY0tleSBhbmQgd2l0aEJhY2tkcm9wLlxuICAgIC8vIFdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIGVsZW1lbnQgdG8gYmUgcmVhZHkgYmVmb3JlIHdlIGNhbiByZWFkIHRoZVxuICAgIC8vIHByb3BlcnRpZXMgdmFsdWVzLlxuICAgIGlmICghcmVhZGllZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtb2RhbCkge1xuICAgICAgdGhpcy5fX3ByZXZOb0NhbmNlbE9uT3V0c2lkZUNsaWNrID0gdGhpcy5ub0NhbmNlbE9uT3V0c2lkZUNsaWNrO1xuICAgICAgdGhpcy5fX3ByZXZOb0NhbmNlbE9uRXNjS2V5ID0gdGhpcy5ub0NhbmNlbE9uRXNjS2V5O1xuICAgICAgdGhpcy5fX3ByZXZXaXRoQmFja2Ryb3AgPSB0aGlzLndpdGhCYWNrZHJvcDtcbiAgICAgIHRoaXMubm9DYW5jZWxPbk91dHNpZGVDbGljayA9IHRydWU7XG4gICAgICB0aGlzLm5vQ2FuY2VsT25Fc2NLZXkgPSB0cnVlO1xuICAgICAgdGhpcy53aXRoQmFja2Ryb3AgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGUgdmFsdWUgd2FzIGNoYW5nZWQgdG8gZmFsc2UsIGxldCBpdCBmYWxzZS5cbiAgICAgIHRoaXMubm9DYW5jZWxPbk91dHNpZGVDbGljayA9IHRoaXMubm9DYW5jZWxPbk91dHNpZGVDbGljayAmJlxuICAgICAgICB0aGlzLl9fcHJldk5vQ2FuY2VsT25PdXRzaWRlQ2xpY2s7XG4gICAgICB0aGlzLm5vQ2FuY2VsT25Fc2NLZXkgPSB0aGlzLm5vQ2FuY2VsT25Fc2NLZXkgJiZcbiAgICAgICAgdGhpcy5fX3ByZXZOb0NhbmNlbE9uRXNjS2V5O1xuICAgICAgdGhpcy53aXRoQmFja2Ryb3AgPSB0aGlzLndpdGhCYWNrZHJvcCAmJiB0aGlzLl9fcHJldldpdGhCYWNrZHJvcDtcbiAgICB9XG4gIH0sXG5cbiAgX3VwZGF0ZUNsb3NpbmdSZWFzb25Db25maXJtZWQ6IGZ1bmN0aW9uKGNvbmZpcm1lZCkge1xuICAgIHRoaXMuY2xvc2luZ1JlYXNvbiA9IHRoaXMuY2xvc2luZ1JlYXNvbiB8fCB7fTtcbiAgICB0aGlzLmNsb3NpbmdSZWFzb24uY29uZmlybWVkID0gY29uZmlybWVkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaWxsIGRpc21pc3MgdGhlIGRpYWxvZyBpZiB1c2VyIGNsaWNrZWQgb24gYW4gZWxlbWVudCB3aXRoIGRpYWxvZy1kaXNtaXNzXG4gICAqIG9yIGRpYWxvZy1jb25maXJtIGF0dHJpYnV0ZS5cbiAgICovXG4gIF9vbkRpYWxvZ0NsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgIC8vIFNlYXJjaCBmb3IgdGhlIGVsZW1lbnQgd2l0aCBkaWFsb2ctY29uZmlybSBvciBkaWFsb2ctZGlzbWlzcyxcbiAgICAvLyBmcm9tIHRoZSByb290IHRhcmdldCB1bnRpbCB0aGlzIChleGNsdWRlZCkuXG4gICAgdmFyIHBhdGggPSBkb20oZXZlbnQpLnBhdGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwYXRoLmluZGV4T2YodGhpcyk7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciB0YXJnZXQgPSBwYXRoW2ldO1xuICAgICAgaWYgKHRhcmdldC5oYXNBdHRyaWJ1dGUgJiYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RpYWxvZy1kaXNtaXNzJykgfHwgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlhbG9nLWNvbmZpcm0nKSkpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ2xvc2luZ1JlYXNvbkNvbmZpcm1lZCh0YXJnZXQuaGFzQXR0cmlidXRlKCdkaWFsb2ctY29uZmlybScpKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbmV4cG9ydCBjb25zdCBQYXBlckRpYWxvZ0JlaGF2aW9yID0gW0lyb25PdmVybGF5QmVoYXZpb3IsIFBhcGVyRGlhbG9nQmVoYXZpb3JJbXBsXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWRpYWxvZy1iZWhhdmlvci9wYXBlci1kaWFsb2ctYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDc0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25GaXRCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tZml0LWJlaGF2aW9yL2lyb24tZml0LWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IElyb25SZXNpemFibGVCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IElyb25PdmVybGF5TWFuYWdlciB9IGZyb20gJy4vaXJvbi1vdmVybGF5LW1hbmFnZXIuanMnO1xuaW1wb3J0IHsgSXJvbkZvY3VzYWJsZXNIZWxwZXIgfSBmcm9tICcuL2lyb24tZm9jdXNhYmxlcy1oZWxwZXIuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25PdmVybGF5QmVoYXZpb3JJbXBsID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIG92ZXJsYXkgaXMgY3VycmVudGx5IGRpc3BsYXllZC5cbiAgICAgKi9cbiAgICBvcGVuZWQ6IHtcbiAgICAgIG9ic2VydmVyOiAnX29wZW5lZENoYW5nZWQnLFxuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG5vdGlmeTogdHJ1ZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBvdmVybGF5IHdhcyBjYW5jZWxlZCB3aGVuIGl0IHdhcyBsYXN0IGNsb3NlZC5cbiAgICAgKi9cbiAgICBjYW5jZWxlZDoge1xuICAgICAgb2JzZXJ2ZXI6ICdfY2FuY2VsZWRDaGFuZ2VkJyxcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBkaXNwbGF5IGEgYmFja2Ryb3AgYmVoaW5kIHRoZSBvdmVybGF5LiBJdCB0cmFwcyB0aGUgZm9jdXNcbiAgICAgKiB3aXRoaW4gdGhlIGxpZ2h0IERPTSBvZiB0aGUgb3ZlcmxheS5cbiAgICAgKi9cbiAgICB3aXRoQmFja2Ryb3A6IHtcbiAgICAgIG9ic2VydmVyOiAnX3dpdGhCYWNrZHJvcENoYW5nZWQnLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIGF1dG8tZm9jdXNpbmcgdGhlIG92ZXJsYXkgb3IgY2hpbGQgbm9kZXMgd2l0aFxuICAgICAqIHRoZSBgYXV0b2ZvY3VzYCBhdHRyaWJ1dGVgIHdoZW4gdGhlIG92ZXJsYXkgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIG5vQXV0b0ZvY3VzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGRpc2FibGUgY2FuY2VsaW5nIHRoZSBvdmVybGF5IHdpdGggdGhlIEVTQyBrZXkuXG4gICAgICovXG4gICAgbm9DYW5jZWxPbkVzY0tleToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIGNhbmNlbGluZyB0aGUgb3ZlcmxheSBieSBjbGlja2luZyBvdXRzaWRlIGl0LlxuICAgICAqL1xuICAgIG5vQ2FuY2VsT25PdXRzaWRlQ2xpY2s6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udGFpbnMgdGhlIHJlYXNvbihzKSB0aGlzIG92ZXJsYXkgd2FzIGxhc3QgY2xvc2VkIChzZWUgYGlyb24tb3ZlcmxheS1jbG9zZWRgKS5cbiAgICAgKiBgSXJvbk92ZXJsYXlCZWhhdmlvcmAgcHJvdmlkZXMgdGhlIGBjYW5jZWxlZGAgcmVhc29uOyBpbXBsZW1lbnRlcnMgb2YgdGhlXG4gICAgICogYmVoYXZpb3IgY2FuIHByb3ZpZGUgb3RoZXIgcmVhc29ucyBpbiBhZGRpdGlvbiB0byBgY2FuY2VsZWRgLlxuICAgICAqL1xuICAgIGNsb3NpbmdSZWFzb246IHtcbiAgICAgIC8vIHdhcyBhIGdldHRlciBiZWZvcmUsIGJ1dCBuZWVkcyB0byBiZSBhIHByb3BlcnR5IHNvIG90aGVyXG4gICAgICAvLyBiZWhhdmlvcnMgY2FuIG92ZXJyaWRlIHRoaXMuXG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZW5hYmxlIHJlc3RvcmluZyBvZiBmb2N1cyB3aGVuIG92ZXJsYXkgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIHJlc3RvcmVGb2N1c09uQ2xvc2U6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8ga2VlcCBvdmVybGF5IGFsd2F5cyBvbiB0b3AuXG4gICAgICovXG4gICAgYWx3YXlzT25Ub3A6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2hvcnRjdXQgdG8gYWNjZXNzIHRvIHRoZSBvdmVybGF5IG1hbmFnZXIuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7UG9seW1lci5Jcm9uT3ZlcmxheU1hbmFnZXJDbGFzc31cbiAgICAgKi9cbiAgICBfbWFuYWdlcjoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgdmFsdWU6IElyb25PdmVybGF5TWFuYWdlclxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbm9kZSBiZWluZyBmb2N1c2VkLlxuICAgICAqIEB0eXBlIHs/Tm9kZX1cbiAgICAgKi9cbiAgICBfZm9jdXNlZENoaWxkOiB7XG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9XG5cbiAgfSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICAnaXJvbi1yZXNpemUnOiAnX29uSXJvblJlc2l6ZSdcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGJhY2tkcm9wIGVsZW1lbnQuXG4gICAqIEB0eXBlIHtFbGVtZW50fVxuICAgKi9cbiAgZ2V0IGJhY2tkcm9wRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWFuYWdlci5iYWNrZHJvcEVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5vZGUgdG8gZ2l2ZSBmb2N1cyB0by5cbiAgICogQHR5cGUge05vZGV9XG4gICAqL1xuICBnZXQgX2ZvY3VzTm9kZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZm9jdXNlZENoaWxkIHx8IGRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yKCdbYXV0b2ZvY3VzXScpIHx8IHRoaXM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIG5vZGVzIHRoYXQgY2FuIHJlY2VpdmUgZm9jdXMgKG92ZXJsYXkgaW5jbHVkZWQpLCBvcmRlcmVkIGJ5IGB0YWJpbmRleGAuXG4gICAqIFRoaXMgaXMgdXNlZCB0byByZXRyaWV2ZSB3aGljaCBpcyB0aGUgZmlyc3QgYW5kIGxhc3QgZm9jdXNhYmxlIG5vZGVzIGluIG9yZGVyXG4gICAqIHRvIHdyYXAgdGhlIGZvY3VzIGZvciBvdmVybGF5cyBgd2l0aC1iYWNrZHJvcGAuXG4gICAqXG4gICAqIElmIHlvdSBrbm93IHdoYXQgaXMgeW91ciBjb250ZW50IChzcGVjaWZpY2FsbHkgdGhlIGZpcnN0IGFuZCBsYXN0IGZvY3VzYWJsZSBjaGlsZHJlbiksXG4gICAqIHlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcmV0dXJuIG9ubHkgYFtmaXJzdEZvY3VzYWJsZSwgbGFzdEZvY3VzYWJsZV07YFxuICAgKiBAdHlwZSB7QXJyYXk8Tm9kZT59XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldCBfZm9jdXNhYmxlTm9kZXMoKSB7XG4gICAgcmV0dXJuIElyb25Gb2N1c2FibGVzSGVscGVyLmdldFRhYmJhYmxlTm9kZXModGhpcyk7XG4gIH0sXG5cbiAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVzZWQgdG8gc2tpcCBjYWxscyB0byBub3RpZnlSZXNpemUgYW5kIHJlZml0IHdoaWxlIHRoZSBvdmVybGF5IGlzIGFuaW1hdGluZy5cbiAgICB0aGlzLl9faXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICAvLyB3aXRoLWJhY2tkcm9wIG5lZWRzIHRhYmluZGV4IHRvIGJlIHNldCBpbiBvcmRlciB0byB0cmFwIHRoZSBmb2N1cy5cbiAgICAvLyBJZiBpdCBpcyBub3Qgc2V0LCBJcm9uT3ZlcmxheUJlaGF2aW9yIHdpbGwgc2V0IGl0LCBhbmQgcmVtb3ZlIGl0IGlmIHdpdGgtYmFja2Ryb3AgPSBmYWxzZS5cbiAgICB0aGlzLl9fc2hvdWxkUmVtb3ZlVGFiSW5kZXggPSBmYWxzZTtcbiAgICAvLyBVc2VkIGZvciB3cmFwcGluZyB0aGUgZm9jdXMgb24gVEFCIC8gU2hpZnQrVEFCLlxuICAgIHRoaXMuX19maXJzdEZvY3VzYWJsZU5vZGUgPSB0aGlzLl9fbGFzdEZvY3VzYWJsZU5vZGUgPSBudWxsO1xuICAgIC8vIFVzZWQgYnkgX19vbk5leHRBbmltYXRpb25GcmFtZSB0byBjYW5jZWwgYW55IHByZXZpb3VzIGNhbGxiYWNrLlxuICAgIHRoaXMuX19yYWYgPSBudWxsO1xuICAgIC8vIEZvY3VzZWQgbm9kZSBiZWZvcmUgb3ZlcmxheSBnZXRzIG9wZW5lZC4gQ2FuIGJlIHJlc3RvcmVkIG9uIGNsb3NlLlxuICAgIHRoaXMuX19yZXN0b3JlRm9jdXNOb2RlID0gbnVsbDtcbiAgICB0aGlzLl9lbnN1cmVTZXR1cCgpO1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBDYWxsIF9vcGVuZWRDaGFuZ2VkIGhlcmUgc28gdGhhdCBwb3NpdGlvbiBjYW4gYmUgY29tcHV0ZWQgY29ycmVjdGx5LlxuICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgdGhpcy5fb3BlbmVkQ2hhbmdlZCh0aGlzLm9wZW5lZCk7XG4gICAgfVxuICAgIHRoaXMuX29ic2VydmVyID0gZG9tKHRoaXMpLm9ic2VydmVOb2Rlcyh0aGlzLl9vbk5vZGVzQ2hhbmdlKTtcbiAgfSxcblxuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgZG9tKHRoaXMpLnVub2JzZXJ2ZU5vZGVzKHRoaXMuX29ic2VydmVyKTtcbiAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgaWYgKHRoaXMuX19yYWYpIHtcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLl9fcmFmKTtcbiAgICAgIHRoaXMuX19yYWYgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9tYW5hZ2VyLnJlbW92ZU92ZXJsYXkodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRvZ2dsZSB0aGUgb3BlbmVkIHN0YXRlIG9mIHRoZSBvdmVybGF5LlxuICAgKi9cbiAgdG9nZ2xlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZXRDYW5jZWxlZChmYWxzZSk7XG4gICAgdGhpcy5vcGVuZWQgPSAhdGhpcy5vcGVuZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIE9wZW4gdGhlIG92ZXJsYXkuXG4gICAqL1xuICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZXRDYW5jZWxlZChmYWxzZSk7XG4gICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDbG9zZSB0aGUgb3ZlcmxheS5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZXRDYW5jZWxlZChmYWxzZSk7XG4gICAgdGhpcy5vcGVuZWQgPSBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FuY2VscyB0aGUgb3ZlcmxheS5cbiAgICogQHBhcmFtIHtFdmVudD19IGV2ZW50IFRoZSBvcmlnaW5hbCBldmVudFxuICAgKi9cbiAgY2FuY2VsOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBjYW5jZWxFdmVudCA9IHRoaXMuZmlyZSgnaXJvbi1vdmVybGF5LWNhbmNlbGVkJywgZXZlbnQsIHtjYW5jZWxhYmxlOiB0cnVlfSk7XG4gICAgaWYgKGNhbmNlbEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRDYW5jZWxlZCh0cnVlKTtcbiAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZhbGlkYXRlcyB0aGUgY2FjaGVkIHRhYmJhYmxlIG5vZGVzLiBUbyBiZSBjYWxsZWQgd2hlbiBhbnkgb2YgdGhlIGZvY3VzYWJsZVxuICAgKiBjb250ZW50IGNoYW5nZXMgKGUuZy4gYSBidXR0b24gaXMgZGlzYWJsZWQpLlxuICAgKi9cbiAgaW52YWxpZGF0ZVRhYmJhYmxlczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fX2ZpcnN0Rm9jdXNhYmxlTm9kZSA9IHRoaXMuX19sYXN0Rm9jdXNhYmxlTm9kZSA9IG51bGw7XG4gIH0sXG5cbiAgX2Vuc3VyZVNldHVwOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fb3ZlcmxheVNldHVwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX292ZXJsYXlTZXR1cCA9IHRydWU7XG4gICAgdGhpcy5zdHlsZS5vdXRsaW5lID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgfSxcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gYG9wZW5lZGAgY2hhbmdlcy5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gb3BlbmVkXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vcGVuZWRDaGFuZ2VkOiBmdW5jdGlvbihvcGVuZWQpIHtcbiAgICBpZiAob3BlbmVkKSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICB9XG5cbiAgICAvLyBEZWZlciBhbnkgYW5pbWF0aW9uLXJlbGF0ZWQgY29kZSBvbiBhdHRhY2hlZFxuICAgIC8vIChfb3BlbmVkQ2hhbmdlZCBnZXRzIGNhbGxlZCBhZ2FpbiBvbiBhdHRhY2hlZCkuXG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9faXNBbmltYXRpbmcgPSB0cnVlO1xuXG4gICAgLy8gVXNlIHJlcXVlc3RBbmltYXRpb25GcmFtZSBmb3Igbm9uLWJsb2NraW5nIHJlbmRlcmluZy5cbiAgICB0aGlzLl9fb25OZXh0QW5pbWF0aW9uRnJhbWUodGhpcy5fX29wZW5lZENoYW5nZWQpO1xuICB9LFxuXG4gIF9jYW5jZWxlZENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuY2xvc2luZ1JlYXNvbiA9IHRoaXMuY2xvc2luZ1JlYXNvbiB8fCB7fTtcbiAgICB0aGlzLmNsb3NpbmdSZWFzb24uY2FuY2VsZWQgPSB0aGlzLmNhbmNlbGVkO1xuICB9LFxuXG4gIF93aXRoQmFja2Ryb3BDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBJZiB0YWJpbmRleCBpcyBhbHJlYWR5IHNldCwgbm8gbmVlZCB0byBvdmVycmlkZSBpdC5cbiAgICBpZiAodGhpcy53aXRoQmFja2Ryb3AgJiYgIXRoaXMuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgIHRoaXMuX19zaG91bGRSZW1vdmVUYWJJbmRleCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9fc2hvdWxkUmVtb3ZlVGFiSW5kZXgpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgICAgdGhpcy5fX3Nob3VsZFJlbW92ZVRhYkluZGV4ID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLm9wZW5lZCAmJiB0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIudHJhY2tCYWNrZHJvcCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogdGFza3Mgd2hpY2ggbXVzdCBvY2N1ciBiZWZvcmUgb3BlbmluZzsgZS5nLiBtYWtpbmcgdGhlIGVsZW1lbnQgdmlzaWJsZS5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3ByZXBhcmVSZW5kZXJPcGVuZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFN0b3JlIGZvY3VzZWQgbm9kZS5cbiAgICB0aGlzLl9fcmVzdG9yZUZvY3VzTm9kZSA9IHRoaXMuX21hbmFnZXIuZGVlcEFjdGl2ZUVsZW1lbnQ7XG5cbiAgICAvLyBOZWVkZWQgdG8gY2FsY3VsYXRlIHRoZSBzaXplIG9mIHRoZSBvdmVybGF5IHNvIHRoYXQgdHJhbnNpdGlvbnMgb24gaXRzIHNpemVcbiAgICAvLyB3aWxsIGhhdmUgdGhlIGNvcnJlY3Qgc3RhcnRpbmcgcG9pbnRzLlxuICAgIHRoaXMuX3ByZXBhcmVQb3NpdGlvbmluZygpO1xuICAgIHRoaXMucmVmaXQoKTtcbiAgICB0aGlzLl9maW5pc2hQb3NpdGlvbmluZygpO1xuXG4gICAgLy8gU2FmYXJpIHdpbGwgYXBwbHkgdGhlIGZvY3VzIHRvIHRoZSBhdXRvZm9jdXMgZWxlbWVudCB3aGVuIGRpc3BsYXllZFxuICAgIC8vIGZvciB0aGUgZmlyc3QgdGltZSwgc28gd2UgbWFrZSBzdXJlIHRvIHJldHVybiB0aGUgZm9jdXMgd2hlcmUgaXQgd2FzLlxuICAgIGlmICh0aGlzLm5vQXV0b0ZvY3VzICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuX2ZvY3VzTm9kZSkge1xuICAgICAgdGhpcy5fZm9jdXNOb2RlLmJsdXIoKTtcbiAgICAgIHRoaXMuX19yZXN0b3JlRm9jdXNOb2RlLmZvY3VzKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUYXNrcyB3aGljaCBjYXVzZSB0aGUgb3ZlcmxheSB0byBhY3R1YWxseSBvcGVuOyB0eXBpY2FsbHkgcGxheSBhbiBhbmltYXRpb24uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZW5kZXJPcGVuZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZpbmlzaFJlbmRlck9wZW5lZCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYXNrcyB3aGljaCBjYXVzZSB0aGUgb3ZlcmxheSB0byBhY3R1YWxseSBjbG9zZTsgdHlwaWNhbGx5IHBsYXkgYW4gYW5pbWF0aW9uLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcmVuZGVyQ2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9maW5pc2hSZW5kZXJDbG9zZWQoKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFza3MgdG8gYmUgcGVyZm9ybWVkIGF0IHRoZSBlbmQgb2Ygb3BlbiBhY3Rpb24uIFdpbGwgZmlyZSBgaXJvbi1vdmVybGF5LW9wZW5lZGAuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9maW5pc2hSZW5kZXJPcGVuZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubm90aWZ5UmVzaXplKCk7XG4gICAgdGhpcy5fX2lzQW5pbWF0aW5nID0gZmFsc2U7XG5cbiAgICB0aGlzLmZpcmUoJ2lyb24tb3ZlcmxheS1vcGVuZWQnKTtcbiAgfSxcblxuICAvKipcbiAgICogVGFza3MgdG8gYmUgcGVyZm9ybWVkIGF0IHRoZSBlbmQgb2YgY2xvc2UgYWN0aW9uLiBXaWxsIGZpcmUgYGlyb24tb3ZlcmxheS1jbG9zZWRgLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfZmluaXNoUmVuZGVyQ2xvc2VkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBIaWRlIHRoZSBvdmVybGF5LlxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAvLyBSZXNldCB6LWluZGV4IG9ubHkgYXQgdGhlIGVuZCBvZiB0aGUgYW5pbWF0aW9uLlxuICAgIHRoaXMuc3R5bGUuekluZGV4ID0gJyc7XG4gICAgdGhpcy5ub3RpZnlSZXNpemUoKTtcbiAgICB0aGlzLl9faXNBbmltYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmZpcmUoJ2lyb24tb3ZlcmxheS1jbG9zZWQnLCB0aGlzLmNsb3NpbmdSZWFzb24pO1xuICB9LFxuXG4gIF9wcmVwYXJlUG9zaXRpb25pbmc6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbiA9IHRoaXMuc3R5bGUud2Via2l0VHJhbnNpdGlvbiA9ICdub25lJztcbiAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9IHRoaXMuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICcnO1xuICB9LFxuXG4gIF9maW5pc2hQb3NpdGlvbmluZzogZnVuY3Rpb24oKSB7XG4gICAgLy8gRmlyc3QsIG1ha2UgaXQgaW52aXNpYmxlICYgcmVhY3RpdmF0ZSBhbmltYXRpb25zLlxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAvLyBGb3JjZSByZWZsb3cgYmVmb3JlIHJlLWVuYWJsaW5nIGFuaW1hdGlvbnMgc28gdGhhdCB0aGV5IGRvbid0IHN0YXJ0LlxuICAgIC8vIFNldCBzY3JvbGxUb3AgdG8gaXRzZWxmIHNvIHRoYXQgQ2xvc3VyZSBDb21waWxlciBkb2Vzbid0IHJlbW92ZSB0aGlzLlxuICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7XG4gICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uID0gdGhpcy5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gJyc7XG4gICAgdGhpcy5zdHlsZS50cmFuc2Zvcm0gPSB0aGlzLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9ICcnO1xuICAgIC8vIE5vdyB0aGF0IGFuaW1hdGlvbnMgYXJlIGVuYWJsZWQsIG1ha2UgaXQgdmlzaWJsZSBhZ2FpblxuICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICcnO1xuICAgIC8vIEZvcmNlIHJlZmxvdywgc28gdGhhdCBmb2xsb3dpbmcgYW5pbWF0aW9ucyBhcmUgcHJvcGVybHkgc3RhcnRlZC5cbiAgICAvLyBTZXQgc2Nyb2xsVG9wIHRvIGl0c2VsZiBzbyB0aGF0IENsb3N1cmUgQ29tcGlsZXIgZG9lc24ndCByZW1vdmUgdGhpcy5cbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVG9wO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIGZvY3VzIGFjY29yZGluZyB0byB0aGUgb3BlbmVkIHN0YXRlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfYXBwbHlGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICBpZiAoIXRoaXMubm9BdXRvRm9jdXMpIHtcbiAgICAgICAgdGhpcy5fZm9jdXNOb2RlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fZm9jdXNOb2RlLmJsdXIoKTtcbiAgICAgIHRoaXMuX2ZvY3VzZWRDaGlsZCA9IG51bGw7XG4gICAgICAvLyBSZXN0b3JlIGZvY3VzLlxuICAgICAgaWYgKHRoaXMucmVzdG9yZUZvY3VzT25DbG9zZSAmJiB0aGlzLl9fcmVzdG9yZUZvY3VzTm9kZSkge1xuICAgICAgICB0aGlzLl9fcmVzdG9yZUZvY3VzTm9kZS5mb2N1cygpO1xuICAgICAgfVxuICAgICAgdGhpcy5fX3Jlc3RvcmVGb2N1c05vZGUgPSBudWxsO1xuICAgICAgLy8gSWYgbWFueSBvdmVybGF5cyBnZXQgY2xvc2VkIGF0IHRoZSBzYW1lIHRpbWUsIG9uZSBvZiB0aGVtIHdvdWxkIHN0aWxsXG4gICAgICAvLyBiZSB0aGUgY3VycmVudE92ZXJsYXkgZXZlbiBpZiBhbHJlYWR5IGNsb3NlZCwgYW5kIHdvdWxkIGNhbGwgX2FwcGx5Rm9jdXNcbiAgICAgIC8vIGluZmluaXRlbHksIHNvIHdlIGNoZWNrIGZvciB0aGlzIG5vdCB0byBiZSB0aGUgY3VycmVudCBvdmVybGF5LlxuICAgICAgdmFyIGN1cnJlbnRPdmVybGF5ID0gdGhpcy5fbWFuYWdlci5jdXJyZW50T3ZlcmxheSgpO1xuICAgICAgaWYgKGN1cnJlbnRPdmVybGF5ICYmIHRoaXMgIT09IGN1cnJlbnRPdmVybGF5KSB7XG4gICAgICAgIGN1cnJlbnRPdmVybGF5Ll9hcHBseUZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIChjbG9zZXMpIHRoZSBvdmVybGF5LiBDYWxsIHdoZW4gY2xpY2sgaGFwcGVucyBvdXRzaWRlIHRoZSBvdmVybGF5LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29uQ2FwdHVyZUNsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5ub0NhbmNlbE9uT3V0c2lkZUNsaWNrKSB7XG4gICAgICB0aGlzLmNhbmNlbChldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBLZWVwcyB0cmFjayBvZiB0aGUgZm9jdXNlZCBjaGlsZC4gSWYgd2l0aEJhY2tkcm9wLCB0cmFwcyBmb2N1cyB3aXRoaW4gb3ZlcmxheS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vbkNhcHR1cmVGb2N1czogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLndpdGhCYWNrZHJvcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcGF0aCA9IGRvbShldmVudCkucGF0aDtcbiAgICBpZiAocGF0aC5pbmRleE9mKHRoaXMpID09PSAtMSkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB0aGlzLl9hcHBseUZvY3VzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2ZvY3VzZWRDaGlsZCA9IHBhdGhbMF07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBFU0Mga2V5IGV2ZW50IGFuZCBjYW5jZWxzIChjbG9zZXMpIHRoZSBvdmVybGF5LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29uQ2FwdHVyZUVzYzogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMubm9DYW5jZWxPbkVzY0tleSkge1xuICAgICAgdGhpcy5jYW5jZWwoZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSGFuZGxlcyBUQUIga2V5IGV2ZW50cyB0byB0cmFjayBmb2N1cyBjaGFuZ2VzLlxuICAgKiBXaWxsIHdyYXAgZm9jdXMgZm9yIG92ZXJsYXlzIHdpdGhCYWNrZHJvcC5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vbkNhcHR1cmVUYWI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLndpdGhCYWNrZHJvcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fZW5zdXJlRmlyc3RMYXN0Rm9jdXNhYmxlcygpO1xuICAgIC8vIFRBQiB3cmFwcyBmcm9tIGxhc3QgdG8gZmlyc3QgZm9jdXNhYmxlLlxuICAgIC8vIFNoaWZ0ICsgVEFCIHdyYXBzIGZyb20gZmlyc3QgdG8gbGFzdCBmb2N1c2FibGUuXG4gICAgdmFyIHNoaWZ0ID0gZXZlbnQuc2hpZnRLZXk7XG4gICAgdmFyIG5vZGVUb0NoZWNrID0gc2hpZnQgPyB0aGlzLl9fZmlyc3RGb2N1c2FibGVOb2RlIDogdGhpcy5fX2xhc3RGb2N1c2FibGVOb2RlO1xuICAgIHZhciBub2RlVG9TZXQgPSBzaGlmdCA/IHRoaXMuX19sYXN0Rm9jdXNhYmxlTm9kZSA6IHRoaXMuX19maXJzdEZvY3VzYWJsZU5vZGU7XG4gICAgdmFyIHNob3VsZFdyYXAgPSBmYWxzZTtcbiAgICBpZiAobm9kZVRvQ2hlY2sgPT09IG5vZGVUb1NldCkge1xuICAgICAgLy8gSWYgbm9kZVRvQ2hlY2sgaXMgdGhlIHNhbWUgYXMgbm9kZVRvU2V0LCBpdCBtZWFucyB3ZSBoYXZlIGFuIG92ZXJsYXlcbiAgICAgIC8vIHdpdGggMCBvciAxIGZvY3VzYWJsZXM7IGluIGVpdGhlciBjYXNlIHdlIHN0aWxsIG5lZWQgdG8gdHJhcCB0aGVcbiAgICAgIC8vIGZvY3VzIHdpdGhpbiB0aGUgb3ZlcmxheS5cbiAgICAgIHNob3VsZFdyYXAgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbiBkb209c2hhZG93LCB0aGUgbWFuYWdlciB3aWxsIHJlY2VpdmUgZm9jdXMgY2hhbmdlcyBvbiB0aGUgbWFpblxuICAgICAgLy8gcm9vdCBidXQgbm90IHRoZSBvbmVzIHdpdGhpbiBvdGhlciBzaGFkb3cgcm9vdHMsIHNvIHdlIGNhbid0IHJlbHkgb25cbiAgICAgIC8vIF9mb2N1c2VkQ2hpbGQsIGJ1dCB3ZSBzaG91bGQgY2hlY2sgdGhlIGRlZXBlc3QgYWN0aXZlIGVsZW1lbnQuXG4gICAgICB2YXIgZm9jdXNlZE5vZGUgPSB0aGlzLl9tYW5hZ2VyLmRlZXBBY3RpdmVFbGVtZW50O1xuICAgICAgLy8gSWYgdGhlIGFjdGl2ZSBlbGVtZW50IGlzIG5vdCB0aGUgbm9kZVRvQ2hlY2sgYnV0IHRoZSBvdmVybGF5IGl0c2VsZixcbiAgICAgIC8vIGl0IG1lYW5zIHRoZSBmb2N1cyBpcyBhYm91dCB0byBnbyBvdXRzaWRlIHRoZSBvdmVybGF5LCBoZW5jZSB3ZVxuICAgICAgLy8gc2hvdWxkIHByZXZlbnQgdGhhdCAoZS5nLiB1c2VyIG9wZW5zIHRoZSBvdmVybGF5IGFuZCBoaXQgU2hpZnQrVEFCKS5cbiAgICAgIHNob3VsZFdyYXAgPSAoZm9jdXNlZE5vZGUgPT09IG5vZGVUb0NoZWNrIHx8IGZvY3VzZWROb2RlID09PSB0aGlzKTtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkV3JhcCkge1xuICAgICAgLy8gV2hlbiB0aGUgb3ZlcmxheSBjb250YWlucyB0aGUgbGFzdCBmb2N1c2FibGUgZWxlbWVudCBvZiB0aGUgZG9jdW1lbnRcbiAgICAgIC8vIGFuZCBpdCdzIGFscmVhZHkgZm9jdXNlZCwgcHJlc3NpbmcgVEFCIHdvdWxkIG1vdmUgdGhlIGZvY3VzIG91dHNpZGVcbiAgICAgIC8vIHRoZSBkb2N1bWVudCAoZS5nLiB0byB0aGUgYnJvd3NlciBzZWFyY2ggYmFyKS4gU2ltaWxhcmx5LCB3aGVuIHRoZVxuICAgICAgLy8gb3ZlcmxheSBjb250YWlucyB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgb2YgdGhlIGRvY3VtZW50IGFuZCBpdCdzXG4gICAgICAvLyBhbHJlYWR5IGZvY3VzZWQsIHByZXNzaW5nIFNoaWZ0K1RBQiB3b3VsZCBtb3ZlIHRoZSBmb2N1cyBvdXRzaWRlIHRoZVxuICAgICAgLy8gZG9jdW1lbnQgKGUuZy4gdG8gdGhlIGJyb3dzZXIgc2VhcmNoIGJhcikuXG4gICAgICAvLyBJbiBib3RoIGNhc2VzLCB3ZSB3b3VsZCBub3QgcmVjZWl2ZSBhIGZvY3VzIGV2ZW50LCBidXQgb25seSBhIGJsdXIuXG4gICAgICAvLyBJbiBvcmRlciB0byBhY2hpZXZlIGZvY3VzIHdyYXBwaW5nLCB3ZSBwcmV2ZW50IHRoaXMgVEFCIGV2ZW50IGFuZFxuICAgICAgLy8gZm9yY2UgdGhlIGZvY3VzLiBUaGlzIHdpbGwgYWxzbyBwcmV2ZW50IHRoZSBmb2N1cyB0byB0ZW1wb3JhcmlseSBtb3ZlXG4gICAgICAvLyBvdXRzaWRlIHRoZSBvdmVybGF5LCB3aGljaCBtaWdodCBjYXVzZSBzY3JvbGxpbmcuXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fZm9jdXNlZENoaWxkID0gbm9kZVRvU2V0O1xuICAgICAgdGhpcy5fYXBwbHlGb2N1cygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVmaXRzIGlmIHRoZSBvdmVybGF5IGlzIG9wZW5lZCBhbmQgbm90IGFuaW1hdGluZy5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29uSXJvblJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkICYmICF0aGlzLl9faXNBbmltYXRpbmcpIHtcbiAgICAgIHRoaXMuX19vbk5leHRBbmltYXRpb25GcmFtZSh0aGlzLnJlZml0KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdpbGwgY2FsbCBub3RpZnlSZXNpemUgaWYgb3ZlcmxheSBpcyBvcGVuZWQuXG4gICAqIENhbiBiZSBvdmVycmlkZGVuIGluIG9yZGVyIHRvIGF2b2lkIG11bHRpcGxlIG9ic2VydmVycyBvbiB0aGUgc2FtZSBub2RlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb25Ob2Rlc0NoYW5nZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkICYmICF0aGlzLl9faXNBbmltYXRpbmcpIHtcbiAgICAgIC8vIEl0IG1pZ2h0IGhhdmUgYWRkZWQgZm9jdXNhYmxlIG5vZGVzLCBzbyBpbnZhbGlkYXRlIGNhY2hlZCB2YWx1ZXMuXG4gICAgICB0aGlzLmludmFsaWRhdGVUYWJiYWJsZXMoKTtcbiAgICAgIHRoaXMubm90aWZ5UmVzaXplKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBXaWxsIHNldCBmaXJzdCBhbmQgbGFzdCBmb2N1c2FibGUgbm9kZXMgaWYgYW55IG9mIHRoZW0gaXMgbm90IHNldC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fZW5zdXJlRmlyc3RMYXN0Rm9jdXNhYmxlczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLl9fZmlyc3RGb2N1c2FibGVOb2RlIHx8ICF0aGlzLl9fbGFzdEZvY3VzYWJsZU5vZGUpIHtcbiAgICAgIHZhciBmb2N1c2FibGVOb2RlcyA9IHRoaXMuX2ZvY3VzYWJsZU5vZGVzO1xuICAgICAgdGhpcy5fX2ZpcnN0Rm9jdXNhYmxlTm9kZSA9IGZvY3VzYWJsZU5vZGVzWzBdO1xuICAgICAgdGhpcy5fX2xhc3RGb2N1c2FibGVOb2RlID0gZm9jdXNhYmxlTm9kZXNbZm9jdXNhYmxlTm9kZXMubGVuZ3RoIC0gMV07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUYXNrcyBleGVjdXRlZCB3aGVuIG9wZW5lZCBjaGFuZ2VzOiBwcmVwYXJlIGZvciB0aGUgb3BlbmluZywgbW92ZSB0aGVcbiAgICogZm9jdXMsIHVwZGF0ZSB0aGUgbWFuYWdlciwgcmVuZGVyIG9wZW5lZC9jbG9zZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfX29wZW5lZENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZCkge1xuICAgICAgLy8gTWFrZSBvdmVybGF5IHZpc2libGUsIHRoZW4gYWRkIGl0IHRvIHRoZSBtYW5hZ2VyLlxuICAgICAgdGhpcy5fcHJlcGFyZVJlbmRlck9wZW5lZCgpO1xuICAgICAgdGhpcy5fbWFuYWdlci5hZGRPdmVybGF5KHRoaXMpO1xuICAgICAgLy8gTW92ZSB0aGUgZm9jdXMgdG8gdGhlIGNoaWxkIG5vZGUgd2l0aCBbYXV0b2ZvY3VzXS5cbiAgICAgIHRoaXMuX2FwcGx5Rm9jdXMoKTtcblxuICAgICAgdGhpcy5fcmVuZGVyT3BlbmVkKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSBvdmVybGF5LCB0aGVuIHJlc3RvcmUgdGhlIGZvY3VzIGJlZm9yZSBhY3R1YWxseSBjbG9zaW5nLlxuICAgICAgdGhpcy5fbWFuYWdlci5yZW1vdmVPdmVybGF5KHRoaXMpO1xuICAgICAgdGhpcy5fYXBwbHlGb2N1cygpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJDbG9zZWQoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgY2FsbGJhY2sgb24gdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLCBvdmVycmlkaW5nIGFueSBwcmV2aW91c1xuICAgKiBjYWxsYmFjayBhd2FpdGluZyBmb3IgdGhlIG5leHQgYW5pbWF0aW9uIGZyYW1lLiBlLmcuXG4gICAqIGBfX29uTmV4dEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrMSkgJiYgX19vbk5leHRBbmltYXRpb25GcmFtZShjYWxsYmFjazIpYDtcbiAgICogYGNhbGxiYWNrMWAgd2lsbCBuZXZlciBiZSBpbnZva2VkLlxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gY2FsbGJhY2sgSXRzIGB0aGlzYCBwYXJhbWV0ZXIgaXMgdGhlIG92ZXJsYXkgaXRzZWxmLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX19vbk5leHRBbmltYXRpb25GcmFtZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICBpZiAodGhpcy5fX3JhZikge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX19yYWYpO1xuICAgIH1cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fX3JhZiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbmV4dEFuaW1hdGlvbkZyYW1lKCkge1xuICAgICAgc2VsZi5fX3JhZiA9IG51bGw7XG4gICAgICBjYWxsYmFjay5jYWxsKHNlbGYpO1xuICAgIH0pO1xuICB9XG5cbn07XG5cbmV4cG9ydCBjb25zdCBJcm9uT3ZlcmxheUJlaGF2aW9yID0gW0lyb25GaXRCZWhhdmlvciwgSXJvblJlc2l6YWJsZUJlaGF2aW9yLCBJcm9uT3ZlcmxheUJlaGF2aW9ySW1wbF07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW92ZXJsYXktYmVoYXZpb3IvaXJvbi1vdmVybGF5LWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbkZpdEJlaGF2aW9yID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHRoYXQgd2lsbCByZWNlaXZlIGEgYG1heC1oZWlnaHRgL2B3aWR0aGAuIEJ5IGRlZmF1bHQgaXQgaXMgdGhlIHNhbWUgYXMgYHRoaXNgLFxuICAgICAqIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIGEgY2hpbGQgZWxlbWVudC4gVGhpcyBpcyB1c2VmdWwsIGZvciBleGFtcGxlLCBmb3IgaW1wbGVtZW50aW5nIGFcbiAgICAgKiBzY3JvbGxpbmcgcmVnaW9uIGluc2lkZSB0aGUgZWxlbWVudC5cbiAgICAgKiBAdHlwZSB7IUVsZW1lbnR9XG4gICAgICovXG4gICAgc2l6aW5nVGFyZ2V0OiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCB0byBmaXQgYHRoaXNgIGludG8uXG4gICAgICovXG4gICAgZml0SW50bzoge1xuICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgdmFsdWU6IHdpbmRvd1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaWxsIHBvc2l0aW9uIHRoZSBlbGVtZW50IGFyb3VuZCB0aGUgcG9zaXRpb25UYXJnZXQgd2l0aG91dCBvdmVybGFwcGluZyBpdC5cbiAgICAgKi9cbiAgICBub092ZXJsYXA6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBwb3NpdGlvbiB0aGUgZWxlbWVudC4gSWYgbm90IHNldCwgaXQgd2lsbFxuICAgICAqIGRlZmF1bHQgdG8gdGhlIHBhcmVudCBub2RlLlxuICAgICAqIEB0eXBlIHshRWxlbWVudH1cbiAgICAgKi9cbiAgICBwb3NpdGlvblRhcmdldDoge1xuICAgICAgdHlwZTogRWxlbWVudFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JpZW50YXRpb24gYWdhaW5zdCB3aGljaCB0byBhbGlnbiB0aGUgZWxlbWVudCBob3Jpem9udGFsbHlcbiAgICAgKiByZWxhdGl2ZSB0byB0aGUgYHBvc2l0aW9uVGFyZ2V0YC4gUG9zc2libGUgdmFsdWVzIGFyZSBcImxlZnRcIiwgXCJyaWdodFwiLCBcImF1dG9cIi5cbiAgICAgKi9cbiAgICBob3Jpem9udGFsQWxpZ246IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JpZW50YXRpb24gYWdhaW5zdCB3aGljaCB0byBhbGlnbiB0aGUgZWxlbWVudCB2ZXJ0aWNhbGx5XG4gICAgICogcmVsYXRpdmUgdG8gdGhlIGBwb3NpdGlvblRhcmdldGAuIFBvc3NpYmxlIHZhbHVlcyBhcmUgXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJhdXRvXCIuXG4gICAgICovXG4gICAgdmVydGljYWxBbGlnbjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIGl0IHdpbGwgdXNlIGBob3Jpem9udGFsQWxpZ25gIGFuZCBgdmVydGljYWxBbGlnbmAgdmFsdWVzIGFzIHByZWZlcnJlZCBhbGlnbm1lbnRcbiAgICAgKiBhbmQgaWYgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlLCBpdCB3aWxsIHBpY2sgdGhlIHZhbHVlcyB3aGljaCBtaW5pbWl6ZSB0aGUgY3JvcHBpbmcuXG4gICAgICovXG4gICAgZHluYW1pY0FsaWduOiB7XG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgcGl4ZWwgdmFsdWUgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBwb3NpdGlvbiBjYWxjdWxhdGVkIGZvciB0aGVcbiAgICAgKiBnaXZlbiBgaG9yaXpvbnRhbEFsaWduYCwgaW4gdGhlIGRpcmVjdGlvbiBvZiBhbGlnbm1lbnQuIFlvdSBjYW4gdGhpbmtcbiAgICAgKiBvZiBpdCBhcyBpbmNyZWFzaW5nIG9yIGRlY3JlYXNpbmcgdGhlIGRpc3RhbmNlIHRvIHRoZSBzaWRlIG9mIHRoZVxuICAgICAqIHNjcmVlbiBnaXZlbiBieSBgaG9yaXpvbnRhbEFsaWduYC5cbiAgICAgKlxuICAgICAqIElmIGBob3Jpem9udGFsQWxpZ25gIGlzIFwibGVmdFwiLCB0aGlzIG9mZnNldCB3aWxsIGluY3JlYXNlIG9yIGRlY3JlYXNlXG4gICAgICogdGhlIGRpc3RhbmNlIHRvIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHNjcmVlbjogYSBuZWdhdGl2ZSBvZmZzZXQgd2lsbFxuICAgICAqIG1vdmUgdGhlIGRyb3Bkb3duIHRvIHRoZSBsZWZ0OyBhIHBvc2l0aXZlIG9uZSwgdG8gdGhlIHJpZ2h0LlxuICAgICAqXG4gICAgICogQ29udmVyc2VseSBpZiBgaG9yaXpvbnRhbEFsaWduYCBpcyBcInJpZ2h0XCIsIHRoaXMgb2Zmc2V0IHdpbGwgaW5jcmVhc2VcbiAgICAgKiBvciBkZWNyZWFzZSB0aGUgZGlzdGFuY2UgdG8gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNjcmVlbjogYSBuZWdhdGl2ZVxuICAgICAqIG9mZnNldCB3aWxsIG1vdmUgdGhlIGRyb3Bkb3duIHRvIHRoZSByaWdodDsgYSBwb3NpdGl2ZSBvbmUsIHRvIHRoZSBsZWZ0LlxuICAgICAqL1xuICAgIGhvcml6b250YWxPZmZzZXQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgbm90aWZ5OiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgcGl4ZWwgdmFsdWUgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSBwb3NpdGlvbiBjYWxjdWxhdGVkIGZvciB0aGVcbiAgICAgKiBnaXZlbiBgdmVydGljYWxBbGlnbmAsIGluIHRoZSBkaXJlY3Rpb24gb2YgYWxpZ25tZW50LiBZb3UgY2FuIHRoaW5rXG4gICAgICogb2YgaXQgYXMgaW5jcmVhc2luZyBvciBkZWNyZWFzaW5nIHRoZSBkaXN0YW5jZSB0byB0aGUgc2lkZSBvZiB0aGVcbiAgICAgKiBzY3JlZW4gZ2l2ZW4gYnkgYHZlcnRpY2FsQWxpZ25gLlxuICAgICAqXG4gICAgICogSWYgYHZlcnRpY2FsQWxpZ25gIGlzIFwidG9wXCIsIHRoaXMgb2Zmc2V0IHdpbGwgaW5jcmVhc2Ugb3IgZGVjcmVhc2VcbiAgICAgKiB0aGUgZGlzdGFuY2UgdG8gdGhlIHRvcCBzaWRlIG9mIHRoZSBzY3JlZW46IGEgbmVnYXRpdmUgb2Zmc2V0IHdpbGxcbiAgICAgKiBtb3ZlIHRoZSBkcm9wZG93biB1cHdhcmRzOyBhIHBvc2l0aXZlIG9uZSwgZG93bndhcmRzLlxuICAgICAqXG4gICAgICogQ29udmVyc2VseSBpZiBgdmVydGljYWxBbGlnbmAgaXMgXCJib3R0b21cIiwgdGhpcyBvZmZzZXQgd2lsbCBpbmNyZWFzZVxuICAgICAqIG9yIGRlY3JlYXNlIHRoZSBkaXN0YW5jZSB0byB0aGUgYm90dG9tIHNpZGUgb2YgdGhlIHNjcmVlbjogYSBuZWdhdGl2ZVxuICAgICAqIG9mZnNldCB3aWxsIG1vdmUgdGhlIGRyb3Bkb3duIGRvd253YXJkczsgYSBwb3NpdGl2ZSBvbmUsIHVwd2FyZHMuXG4gICAgICovXG4gICAgdmVydGljYWxPZmZzZXQ6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgbm90aWZ5OiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGF1dG8tZml0IG9uIGF0dGFjaC5cbiAgICAgKi9cbiAgICBhdXRvRml0T25BdHRhY2g6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqIEB0eXBlIHs/T2JqZWN0fSAqL1xuICAgIF9maXRJbmZvOiB7XG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9XG4gIH0sXG5cbiAgZ2V0IF9maXRXaWR0aCgpIHtcbiAgICB2YXIgZml0V2lkdGg7XG4gICAgaWYgKHRoaXMuZml0SW50byA9PT0gd2luZG93KSB7XG4gICAgICBmaXRXaWR0aCA9IHRoaXMuZml0SW50by5pbm5lcldpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBmaXRXaWR0aCA9IHRoaXMuZml0SW50by5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIGZpdFdpZHRoO1xuICB9LFxuXG4gIGdldCBfZml0SGVpZ2h0KCkge1xuICAgIHZhciBmaXRIZWlnaHQ7XG4gICAgaWYgKHRoaXMuZml0SW50byA9PT0gd2luZG93KSB7XG4gICAgICBmaXRIZWlnaHQgPSB0aGlzLmZpdEludG8uaW5uZXJIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpdEhlaWdodCA9IHRoaXMuZml0SW50by5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgfVxuICAgIHJldHVybiBmaXRIZWlnaHQ7XG4gIH0sXG5cbiAgZ2V0IF9maXRMZWZ0KCkge1xuICAgIHZhciBmaXRMZWZ0O1xuICAgIGlmICh0aGlzLmZpdEludG8gPT09IHdpbmRvdykge1xuICAgICAgZml0TGVmdCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpdExlZnQgPSB0aGlzLmZpdEludG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIGZpdExlZnQ7XG4gIH0sXG5cbiAgZ2V0IF9maXRUb3AoKSB7XG4gICAgdmFyIGZpdFRvcDtcbiAgICBpZiAodGhpcy5maXRJbnRvID09PSB3aW5kb3cpIHtcbiAgICAgIGZpdFRvcCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpdFRvcCA9IHRoaXMuZml0SW50by5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XG4gICAgfVxuICAgIHJldHVybiBmaXRUb3A7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBlbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgdG8gcG9zaXRpb24gdGhlIGVsZW1lbnQsXG4gICAqIGlmIG5vIHBvc2l0aW9uIHRhcmdldCBpcyBjb25maWd1cmVkLlxuICAgKi9cbiAgZ2V0IF9kZWZhdWx0UG9zaXRpb25UYXJnZXQoKSB7XG4gICAgdmFyIHBhcmVudCA9IGRvbSh0aGlzKS5wYXJlbnROb2RlO1xuXG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcGFyZW50ID0gcGFyZW50Lmhvc3Q7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmVudDtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGhvcml6b250YWwgYWxpZ24gdmFsdWUsIGFjY291bnRpbmcgZm9yIHRoZSBSVEwvTFRSIHRleHQgZGlyZWN0aW9uLlxuICAgKi9cbiAgZ2V0IF9sb2NhbGVIb3Jpem9udGFsQWxpZ24oKSB7XG4gICAgaWYgKHRoaXMuX2lzUlRMKSB7XG4gICAgICAvLyBJbiBSVEwsIFwibGVmdFwiIGJlY29tZXMgXCJyaWdodFwiLlxuICAgICAgaWYgKHRoaXMuaG9yaXpvbnRhbEFsaWduID09PSAncmlnaHQnKSB7XG4gICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsQWxpZ24gPT09ICdsZWZ0Jykge1xuICAgICAgICByZXR1cm4gJ3JpZ2h0JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaG9yaXpvbnRhbEFsaWduO1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBNZW1vaXplIHRoaXMgdG8gYXZvaWQgZXhwZW5zaXZlIGNhbGN1bGF0aW9ucyAmIHJlbGF5b3V0cy5cbiAgICAvLyBNYWtlIHN1cmUgd2UgZG8gaXQgb25seSBvbmNlXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9pc1JUTCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMuX2lzUlRMID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZGlyZWN0aW9uID09ICdydGwnO1xuICAgIH1cbiAgICB0aGlzLnBvc2l0aW9uVGFyZ2V0ID0gdGhpcy5wb3NpdGlvblRhcmdldCB8fCB0aGlzLl9kZWZhdWx0UG9zaXRpb25UYXJnZXQ7XG4gICAgaWYgKHRoaXMuYXV0b0ZpdE9uQXR0YWNoKSB7XG4gICAgICBpZiAod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcykuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgdGhpcy5maXQoKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5PVEU6IHNoYWR5ZG9tIGFwcGxpZXMgZGlzdHJpYnV0aW9uIGFzeW5jaHJvbm91c2x5XG4gICAgICAgIC8vIGZvciBwZXJmb3JtYW5jZSByZWFzb25zIHdlYmNvbXBvbmVudHMvc2hhZHlkb20jMTIwXG4gICAgICAgIC8vIEZsdXNoIHRvIGdldCBjb3JyZWN0IGxheW91dCBpbmZvLlxuICAgICAgICB3aW5kb3cuU2hhZHlET00gJiYgU2hhZHlET00uZmx1c2goKTtcbiAgICAgICAgdGhpcy5maXQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9fZGVmZXJyZWRGaXQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9fZGVmZXJyZWRGaXQpO1xuICAgICAgdGhpcy5fX2RlZmVycmVkRml0ID0gbnVsbDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvc2l0aW9ucyBhbmQgZml0cyB0aGUgZWxlbWVudCBpbnRvIHRoZSBgZml0SW50b2AgZWxlbWVudC5cbiAgICovXG4gIGZpdDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5wb3NpdGlvbigpO1xuICAgIHRoaXMuY29uc3RyYWluKCk7XG4gICAgdGhpcy5jZW50ZXIoKTtcbiAgfSxcblxuICAvKipcbiAgICogTWVtb2l6ZSBpbmZvcm1hdGlvbiBuZWVkZWQgdG8gcG9zaXRpb24gYW5kIHNpemUgdGhlIHRhcmdldCBlbGVtZW50LlxuICAgKiBAc3VwcHJlc3Mge2RlcHJlY2F0ZWR9XG4gICAqL1xuICBfZGlzY292ZXJJbmZvOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fZml0SW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGFyZ2V0ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcyk7XG4gICAgdmFyIHNpemVyID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5zaXppbmdUYXJnZXQpO1xuXG4gICAgdGhpcy5fZml0SW5mbyA9IHtcbiAgICAgIGlubGluZVN0eWxlOiB7XG4gICAgICAgIHRvcDogdGhpcy5zdHlsZS50b3AgfHwgJycsXG4gICAgICAgIGxlZnQ6IHRoaXMuc3R5bGUubGVmdCB8fCAnJyxcbiAgICAgICAgcG9zaXRpb246IHRoaXMuc3R5bGUucG9zaXRpb24gfHwgJydcbiAgICAgIH0sXG4gICAgICBzaXplcklubGluZVN0eWxlOiB7XG4gICAgICAgIG1heFdpZHRoOiB0aGlzLnNpemluZ1RhcmdldC5zdHlsZS5tYXhXaWR0aCB8fCAnJyxcbiAgICAgICAgbWF4SGVpZ2h0OiB0aGlzLnNpemluZ1RhcmdldC5zdHlsZS5tYXhIZWlnaHQgfHwgJycsXG4gICAgICAgIGJveFNpemluZzogdGhpcy5zaXppbmdUYXJnZXQuc3R5bGUuYm94U2l6aW5nIHx8ICcnXG4gICAgICB9LFxuICAgICAgcG9zaXRpb25lZEJ5OiB7XG4gICAgICAgIHZlcnRpY2FsbHk6IHRhcmdldC50b3AgIT09ICdhdXRvJyA/ICd0b3AnIDogKHRhcmdldC5ib3R0b20gIT09ICdhdXRvJyA/XG4gICAgICAgICAgJ2JvdHRvbScgOiBudWxsKSxcbiAgICAgICAgaG9yaXpvbnRhbGx5OiB0YXJnZXQubGVmdCAhPT0gJ2F1dG8nID8gJ2xlZnQnIDogKHRhcmdldC5yaWdodCAhPT0gJ2F1dG8nID9cbiAgICAgICAgICAncmlnaHQnIDogbnVsbClcbiAgICAgIH0sXG4gICAgICBzaXplZEJ5OiB7XG4gICAgICAgIGhlaWdodDogc2l6ZXIubWF4SGVpZ2h0ICE9PSAnbm9uZScsXG4gICAgICAgIHdpZHRoOiBzaXplci5tYXhXaWR0aCAhPT0gJ25vbmUnLFxuICAgICAgICBtaW5XaWR0aDogcGFyc2VJbnQoc2l6ZXIubWluV2lkdGgsIDEwKSB8fCAwLFxuICAgICAgICBtaW5IZWlnaHQ6IHBhcnNlSW50KHNpemVyLm1pbkhlaWdodCwgMTApIHx8IDBcbiAgICAgIH0sXG4gICAgICBtYXJnaW46IHtcbiAgICAgICAgdG9wOiBwYXJzZUludCh0YXJnZXQubWFyZ2luVG9wLCAxMCkgfHwgMCxcbiAgICAgICAgcmlnaHQ6IHBhcnNlSW50KHRhcmdldC5tYXJnaW5SaWdodCwgMTApIHx8IDAsXG4gICAgICAgIGJvdHRvbTogcGFyc2VJbnQodGFyZ2V0Lm1hcmdpbkJvdHRvbSwgMTApIHx8IDAsXG4gICAgICAgIGxlZnQ6IHBhcnNlSW50KHRhcmdldC5tYXJnaW5MZWZ0LCAxMCkgfHwgMFxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgdGFyZ2V0IGVsZW1lbnQncyBwb3NpdGlvbiBhbmQgc2l6ZSBjb25zdHJhaW50cywgYW5kIGNsZWFyXG4gICAqIHRoZSBtZW1vaXplZCBkYXRhLlxuICAgKi9cbiAgcmVzZXRGaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpbmZvID0gdGhpcy5fZml0SW5mbyB8fCB7fTtcbiAgICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBpbmZvLnNpemVySW5saW5lU3R5bGUpIHtcbiAgICAgIHRoaXMuc2l6aW5nVGFyZ2V0LnN0eWxlW3Byb3BlcnR5XSA9IGluZm8uc2l6ZXJJbmxpbmVTdHlsZVtwcm9wZXJ0eV07XG4gICAgfVxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIGluZm8uaW5saW5lU3R5bGUpIHtcbiAgICAgIHRoaXMuc3R5bGVbcHJvcGVydHldID0gaW5mby5pbmxpbmVTdHlsZVtwcm9wZXJ0eV07XG4gICAgfVxuXG4gICAgdGhpcy5fZml0SW5mbyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVxdWl2YWxlbnQgdG8gY2FsbGluZyBgcmVzZXRGaXQoKWAgYW5kIGBmaXQoKWAuIFVzZWZ1bCB0byBjYWxsIHRoaXMgYWZ0ZXJcbiAgICogdGhlIGVsZW1lbnQgb3IgdGhlIGBmaXRJbnRvYCBlbGVtZW50IGhhcyBiZWVuIHJlc2l6ZWQsIG9yIGlmIGFueSBvZiB0aGVcbiAgICogcG9zaXRpb25pbmcgcHJvcGVydGllcyAoZS5nLiBgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduYCkgaXMgdXBkYXRlZC5cbiAgICogSXQgcHJlc2VydmVzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHNpemluZ1RhcmdldC5cbiAgICovXG4gIHJlZml0OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgc2Nyb2xsTGVmdCA9IHRoaXMuc2l6aW5nVGFyZ2V0LnNjcm9sbExlZnQ7XG4gICAgdmFyIHNjcm9sbFRvcCA9IHRoaXMuc2l6aW5nVGFyZ2V0LnNjcm9sbFRvcDtcbiAgICB0aGlzLnJlc2V0Rml0KCk7XG4gICAgdGhpcy5maXQoKTtcbiAgICB0aGlzLnNpemluZ1RhcmdldC5zY3JvbGxMZWZ0ID0gc2Nyb2xsTGVmdDtcbiAgICB0aGlzLnNpemluZ1RhcmdldC5zY3JvbGxUb3AgPSBzY3JvbGxUb3A7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBvc2l0aW9ucyB0aGUgZWxlbWVudCBhY2NvcmRpbmcgdG8gYGhvcml6b250YWxBbGlnbiwgdmVydGljYWxBbGlnbmAuXG4gICAqL1xuICBwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmhvcml6b250YWxBbGlnbiAmJiAhdGhpcy52ZXJ0aWNhbEFsaWduKSB7XG4gICAgICAvLyBuZWVkcyB0byBiZSBjZW50ZXJlZCwgYW5kIGl0IGlzIGRvbmUgYWZ0ZXIgY29uc3RyYWluLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kaXNjb3ZlckluZm8oKTtcblxuICAgIHRoaXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIC8vIE5lZWQgYm9yZGVyLWJveCBmb3IgbWFyZ2luL3BhZGRpbmcuXG4gICAgdGhpcy5zaXppbmdUYXJnZXQuc3R5bGUuYm94U2l6aW5nID0gJ2JvcmRlci1ib3gnO1xuICAgIC8vIFNldCB0byAwLCAwIGluIG9yZGVyIHRvIGRpc2NvdmVyIGFueSBvZmZzZXQgY2F1c2VkIGJ5IHBhcmVudCBzdGFja2luZyBjb250ZXh0cy5cbiAgICB0aGlzLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICB0aGlzLnN0eWxlLnRvcCA9ICcwcHgnO1xuXG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBwb3NpdGlvblJlY3QgPSB0aGlzLl9fZ2V0Tm9ybWFsaXplZFJlY3QodGhpcy5wb3NpdGlvblRhcmdldCk7XG4gICAgdmFyIGZpdFJlY3QgPSB0aGlzLl9fZ2V0Tm9ybWFsaXplZFJlY3QodGhpcy5maXRJbnRvKTtcblxuICAgIHZhciBtYXJnaW4gPSB0aGlzLl9maXRJbmZvLm1hcmdpbjtcblxuICAgIC8vIENvbnNpZGVyIHRoZSBtYXJnaW4gYXMgcGFydCBvZiB0aGUgc2l6ZSBmb3IgcG9zaXRpb24gY2FsY3VsYXRpb25zLlxuICAgIHZhciBzaXplID0ge1xuICAgICAgd2lkdGg6IHJlY3Qud2lkdGggKyBtYXJnaW4ubGVmdCArIG1hcmdpbi5yaWdodCxcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbVxuICAgIH07XG5cbiAgICB2YXIgcG9zaXRpb24gPSB0aGlzLl9fZ2V0UG9zaXRpb24odGhpcy5fbG9jYWxlSG9yaXpvbnRhbEFsaWduLCB0aGlzLnZlcnRpY2FsQWxpZ24sIHNpemUsIHBvc2l0aW9uUmVjdCxcbiAgICAgIGZpdFJlY3QpO1xuXG4gICAgdmFyIGxlZnQgPSBwb3NpdGlvbi5sZWZ0ICsgbWFyZ2luLmxlZnQ7XG4gICAgdmFyIHRvcCA9IHBvc2l0aW9uLnRvcCArIG1hcmdpbi50b3A7XG5cbiAgICAvLyBXZSBmaXJzdCBsaW1pdCByaWdodC9ib3R0b20gd2l0aGluIGZpdEludG8gcmVzcGVjdGluZyB0aGUgbWFyZ2luLFxuICAgIC8vIHRoZW4gdXNlIHRob3NlIHZhbHVlcyB0byBsaW1pdCB0b3AvbGVmdC5cbiAgICB2YXIgcmlnaHQgPSBNYXRoLm1pbihmaXRSZWN0LnJpZ2h0IC0gbWFyZ2luLnJpZ2h0LCBsZWZ0ICsgcmVjdC53aWR0aCk7XG4gICAgdmFyIGJvdHRvbSA9IE1hdGgubWluKGZpdFJlY3QuYm90dG9tIC0gbWFyZ2luLmJvdHRvbSwgdG9wICsgcmVjdC5oZWlnaHQpO1xuXG4gICAgLy8gS2VlcCBsZWZ0L3RvcCB3aXRoaW4gZml0SW50byByZXNwZWN0aW5nIHRoZSBtYXJnaW4uXG4gICAgbGVmdCA9IE1hdGgubWF4KGZpdFJlY3QubGVmdCArIG1hcmdpbi5sZWZ0LFxuICAgICAgTWF0aC5taW4obGVmdCwgcmlnaHQgLSB0aGlzLl9maXRJbmZvLnNpemVkQnkubWluV2lkdGgpKTtcbiAgICB0b3AgPSBNYXRoLm1heChmaXRSZWN0LnRvcCArIG1hcmdpbi50b3AsXG4gICAgICBNYXRoLm1pbih0b3AsIGJvdHRvbSAtIHRoaXMuX2ZpdEluZm8uc2l6ZWRCeS5taW5IZWlnaHQpKTtcblxuICAgIC8vIFVzZSByaWdodC9ib3R0b20gdG8gc2V0IG1heFdpZHRoL21heEhlaWdodCwgYW5kIHJlc3BlY3QgbWluV2lkdGgvbWluSGVpZ2h0LlxuICAgIHRoaXMuc2l6aW5nVGFyZ2V0LnN0eWxlLm1heFdpZHRoID0gTWF0aC5tYXgocmlnaHQgLSBsZWZ0LCB0aGlzLl9maXRJbmZvLnNpemVkQnkubWluV2lkdGgpICsgJ3B4JztcbiAgICB0aGlzLnNpemluZ1RhcmdldC5zdHlsZS5tYXhIZWlnaHQgPSBNYXRoLm1heChib3R0b20gLSB0b3AsIHRoaXMuX2ZpdEluZm8uc2l6ZWRCeS5taW5IZWlnaHQpICsgJ3B4JztcblxuICAgIC8vIFJlbW92ZSB0aGUgb2Zmc2V0IGNhdXNlZCBieSBhbnkgc3RhY2tpbmcgY29udGV4dC5cbiAgICB0aGlzLnN0eWxlLmxlZnQgPSAobGVmdCAtIHJlY3QubGVmdCkgKyAncHgnO1xuICAgIHRoaXMuc3R5bGUudG9wID0gKHRvcCAtIHJlY3QudG9wKSArICdweCc7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbnN0cmFpbnMgdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgdG8gYGZpdEludG9gIGJ5IHNldHRpbmcgYG1heC1oZWlnaHRgXG4gICAqIGFuZC9vciBgbWF4LXdpZHRoYC5cbiAgICovXG4gIGNvbnN0cmFpbjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaG9yaXpvbnRhbEFsaWduIHx8IHRoaXMudmVydGljYWxBbGlnbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kaXNjb3ZlckluZm8oKTtcblxuICAgIHZhciBpbmZvID0gdGhpcy5fZml0SW5mbztcbiAgICAvLyBwb3NpdGlvbiBhdCAoMHB4LCAwcHgpIGlmIG5vdCBhbHJlYWR5IHBvc2l0aW9uZWQsIHNvIHdlIGNhbiBtZWFzdXJlIHRoZSBuYXR1cmFsIHNpemUuXG4gICAgaWYgKCFpbmZvLnBvc2l0aW9uZWRCeS52ZXJ0aWNhbGx5KSB7XG4gICAgICB0aGlzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgIHRoaXMuc3R5bGUudG9wID0gJzBweCc7XG4gICAgfVxuICAgIGlmICghaW5mby5wb3NpdGlvbmVkQnkuaG9yaXpvbnRhbGx5KSB7XG4gICAgICB0aGlzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgIHRoaXMuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIH1cblxuICAgIC8vIG5lZWQgYm9yZGVyLWJveCBmb3IgbWFyZ2luL3BhZGRpbmdcbiAgICB0aGlzLnNpemluZ1RhcmdldC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gICAgLy8gY29uc3RyYWluIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGlmIG5vdCBhbHJlYWR5IHNldFxuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoIWluZm8uc2l6ZWRCeS5oZWlnaHQpIHtcbiAgICAgIHRoaXMuX19zaXplRGltZW5zaW9uKHJlY3QsIGluZm8ucG9zaXRpb25lZEJ5LnZlcnRpY2FsbHksICd0b3AnLCAnYm90dG9tJywgJ0hlaWdodCcpO1xuICAgIH1cbiAgICBpZiAoIWluZm8uc2l6ZWRCeS53aWR0aCkge1xuICAgICAgdGhpcy5fX3NpemVEaW1lbnNpb24ocmVjdCwgaW5mby5wb3NpdGlvbmVkQnkuaG9yaXpvbnRhbGx5LCAnbGVmdCcsICdyaWdodCcsICdXaWR0aCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgX3NpemVEaW1lbnNpb246IGZ1bmN0aW9uKHJlY3QsIHBvc2l0aW9uZWRCeSwgc3RhcnQsIGVuZCwgZXh0ZW50KSB7XG4gICAgdGhpcy5fX3NpemVEaW1lbnNpb24ocmVjdCwgcG9zaXRpb25lZEJ5LCBzdGFydCwgZW5kLCBleHRlbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX19zaXplRGltZW5zaW9uOiBmdW5jdGlvbihyZWN0LCBwb3NpdGlvbmVkQnksIHN0YXJ0LCBlbmQsIGV4dGVudCkge1xuICAgIHZhciBpbmZvID0gdGhpcy5fZml0SW5mbztcbiAgICB2YXIgZml0UmVjdCA9IHRoaXMuX19nZXROb3JtYWxpemVkUmVjdCh0aGlzLmZpdEludG8pO1xuICAgIHZhciBtYXggPSBleHRlbnQgPT09ICdXaWR0aCcgPyBmaXRSZWN0LndpZHRoIDogZml0UmVjdC5oZWlnaHQ7XG4gICAgdmFyIGZsaXAgPSAocG9zaXRpb25lZEJ5ID09PSBlbmQpO1xuICAgIHZhciBvZmZzZXQgPSBmbGlwID8gbWF4IC0gcmVjdFtlbmRdIDogcmVjdFtzdGFydF07XG4gICAgdmFyIG1hcmdpbiA9IGluZm8ubWFyZ2luW2ZsaXAgPyBzdGFydCA6IGVuZF07XG4gICAgdmFyIG9mZnNldEV4dGVudCA9ICdvZmZzZXQnICsgZXh0ZW50O1xuICAgIHZhciBzaXppbmdPZmZzZXQgPSB0aGlzW29mZnNldEV4dGVudF0gLSB0aGlzLnNpemluZ1RhcmdldFtvZmZzZXRFeHRlbnRdO1xuICAgIHRoaXMuc2l6aW5nVGFyZ2V0LnN0eWxlWydtYXgnICsgZXh0ZW50XSA9IChtYXggLSBtYXJnaW4gLSBvZmZzZXQgLSBzaXppbmdPZmZzZXQpICsgJ3B4JztcbiAgfSxcblxuICAvKipcbiAgICogQ2VudGVycyBob3Jpem9udGFsbHkgYW5kIHZlcnRpY2FsbHkgaWYgbm90IGFscmVhZHkgcG9zaXRpb25lZC4gVGhpcyBhbHNvIHNldHNcbiAgICogYHBvc2l0aW9uOmZpeGVkYC5cbiAgICovXG4gIGNlbnRlcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaG9yaXpvbnRhbEFsaWduIHx8IHRoaXMudmVydGljYWxBbGlnbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kaXNjb3ZlckluZm8oKTtcblxuICAgIHZhciBwb3NpdGlvbmVkQnkgPSB0aGlzLl9maXRJbmZvLnBvc2l0aW9uZWRCeTtcbiAgICBpZiAocG9zaXRpb25lZEJ5LnZlcnRpY2FsbHkgJiYgcG9zaXRpb25lZEJ5Lmhvcml6b250YWxseSkge1xuICAgICAgLy8gQWxyZWFkeSBwb3NpdGlvbmVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBOZWVkIHBvc2l0aW9uOmZpeGVkIHRvIGNlbnRlclxuICAgIHRoaXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIC8vIFRha2UgaW50byBhY2NvdW50IHRoZSBvZmZzZXQgY2F1c2VkIGJ5IHBhcmVudHMgdGhhdCBjcmVhdGUgc3RhY2tpbmdcbiAgICAvLyBjb250ZXh0cyAoZS5nLiB3aXRoIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QpLiBUcmFuc2xhdGUgdG8gMCwwIGFuZFxuICAgIC8vIG1lYXN1cmUgdGhlIGJvdW5kaW5nIHJlY3QuXG4gICAgaWYgKCFwb3NpdGlvbmVkQnkudmVydGljYWxseSkge1xuICAgICAgdGhpcy5zdHlsZS50b3AgPSAnMHB4JztcbiAgICB9XG4gICAgaWYgKCFwb3NpdGlvbmVkQnkuaG9yaXpvbnRhbGx5KSB7XG4gICAgICB0aGlzLnN0eWxlLmxlZnQgPSAnMHB4JztcbiAgICB9XG4gICAgLy8gSXQgd2lsbCB0YWtlIGluIGNvbnNpZGVyYXRpb24gbWFyZ2lucyBhbmQgdHJhbnNmb3Jtc1xuICAgIHZhciByZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB2YXIgZml0UmVjdCA9IHRoaXMuX19nZXROb3JtYWxpemVkUmVjdCh0aGlzLmZpdEludG8pO1xuICAgIGlmICghcG9zaXRpb25lZEJ5LnZlcnRpY2FsbHkpIHtcbiAgICAgIHZhciB0b3AgPSBmaXRSZWN0LnRvcCAtIHJlY3QudG9wICsgKGZpdFJlY3QuaGVpZ2h0IC0gcmVjdC5oZWlnaHQpIC8gMjtcbiAgICAgIHRoaXMuc3R5bGUudG9wID0gdG9wICsgJ3B4JztcbiAgICB9XG4gICAgaWYgKCFwb3NpdGlvbmVkQnkuaG9yaXpvbnRhbGx5KSB7XG4gICAgICB2YXIgbGVmdCA9IGZpdFJlY3QubGVmdCAtIHJlY3QubGVmdCArIChmaXRSZWN0LndpZHRoIC0gcmVjdC53aWR0aCkgLyAyO1xuICAgICAgdGhpcy5zdHlsZS5sZWZ0ID0gbGVmdCArICdweCc7XG4gICAgfVxuICB9LFxuXG4gIF9fZ2V0Tm9ybWFsaXplZFJlY3Q6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCB0YXJnZXQgPT09IHdpbmRvdykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxuICAgICAgICByaWdodDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgIGJvdHRvbTogd2luZG93LmlubmVySGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9LFxuXG4gIF9fZ2V0Q3JvcHBlZEFyZWE6IGZ1bmN0aW9uKHBvc2l0aW9uLCBzaXplLCBmaXRSZWN0KSB7XG4gICAgdmFyIHZlcnRpY2FsQ3JvcCA9IE1hdGgubWluKDAsIHBvc2l0aW9uLnRvcCkgKyBNYXRoLm1pbigwLCBmaXRSZWN0LmJvdHRvbSAtIChwb3NpdGlvbi50b3AgKyBzaXplLmhlaWdodCkpO1xuICAgIHZhciBob3Jpem9udGFsQ3JvcCA9IE1hdGgubWluKDAsIHBvc2l0aW9uLmxlZnQpICsgTWF0aC5taW4oMCwgZml0UmVjdC5yaWdodCAtIChwb3NpdGlvbi5sZWZ0ICsgc2l6ZS53aWR0aCkpO1xuICAgIHJldHVybiBNYXRoLmFicyh2ZXJ0aWNhbENyb3ApICogc2l6ZS53aWR0aCArIE1hdGguYWJzKGhvcml6b250YWxDcm9wKSAqIHNpemUuaGVpZ2h0O1xuICB9LFxuXG5cbiAgX19nZXRQb3NpdGlvbjogZnVuY3Rpb24oaEFsaWduLCB2QWxpZ24sIHNpemUsIHBvc2l0aW9uUmVjdCwgZml0UmVjdCkge1xuICAgIC8vIEFsbCB0aGUgcG9zc2libGUgY29uZmlndXJhdGlvbnMuXG4gICAgLy8gT3JkZXJlZCBhcyB0b3AtbGVmdCwgdG9wLXJpZ2h0LCBib3R0b20tbGVmdCwgYm90dG9tLXJpZ2h0LlxuICAgIHZhciBwb3NpdGlvbnMgPSBbe1xuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICBob3Jpem9udGFsQWxpZ246ICdsZWZ0JyxcbiAgICAgIHRvcDogcG9zaXRpb25SZWN0LnRvcCArIHRoaXMudmVydGljYWxPZmZzZXQsXG4gICAgICBsZWZ0OiBwb3NpdGlvblJlY3QubGVmdCArIHRoaXMuaG9yaXpvbnRhbE9mZnNldFxuICAgIH0sIHtcbiAgICAgIHZlcnRpY2FsQWxpZ246ICd0b3AnLFxuICAgICAgaG9yaXpvbnRhbEFsaWduOiAncmlnaHQnLFxuICAgICAgdG9wOiBwb3NpdGlvblJlY3QudG9wICsgdGhpcy52ZXJ0aWNhbE9mZnNldCxcbiAgICAgIGxlZnQ6IHBvc2l0aW9uUmVjdC5yaWdodCAtIHNpemUud2lkdGggLSB0aGlzLmhvcml6b250YWxPZmZzZXRcbiAgICB9LCB7XG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJyxcbiAgICAgIGhvcml6b250YWxBbGlnbjogJ2xlZnQnLFxuICAgICAgdG9wOiBwb3NpdGlvblJlY3QuYm90dG9tIC0gc2l6ZS5oZWlnaHQgLSB0aGlzLnZlcnRpY2FsT2Zmc2V0LFxuICAgICAgbGVmdDogcG9zaXRpb25SZWN0LmxlZnQgKyB0aGlzLmhvcml6b250YWxPZmZzZXRcbiAgICB9LCB7XG4gICAgICB2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJyxcbiAgICAgIGhvcml6b250YWxBbGlnbjogJ3JpZ2h0JyxcbiAgICAgIHRvcDogcG9zaXRpb25SZWN0LmJvdHRvbSAtIHNpemUuaGVpZ2h0IC0gdGhpcy52ZXJ0aWNhbE9mZnNldCxcbiAgICAgIGxlZnQ6IHBvc2l0aW9uUmVjdC5yaWdodCAtIHNpemUud2lkdGggLSB0aGlzLmhvcml6b250YWxPZmZzZXRcbiAgICB9XTtcblxuICAgIGlmICh0aGlzLm5vT3ZlcmxhcCkge1xuICAgICAgLy8gRHVwbGljYXRlLlxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBwb3NpdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjb3B5ID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBwb3NpdGlvbnNbaV0pIHtcbiAgICAgICAgICBjb3B5W2tleV0gPSBwb3NpdGlvbnNbaV1ba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbnMucHVzaChjb3B5KTtcbiAgICAgIH1cbiAgICAgIC8vIEhvcml6b250YWwgb3ZlcmxhcCBvbmx5LlxuICAgICAgcG9zaXRpb25zWzBdLnRvcCA9IHBvc2l0aW9uc1sxXS50b3AgKz0gcG9zaXRpb25SZWN0LmhlaWdodDtcbiAgICAgIHBvc2l0aW9uc1syXS50b3AgPSBwb3NpdGlvbnNbM10udG9wIC09IHBvc2l0aW9uUmVjdC5oZWlnaHQ7XG4gICAgICAvLyBWZXJ0aWNhbCBvdmVybGFwIG9ubHkuXG4gICAgICBwb3NpdGlvbnNbNF0ubGVmdCA9IHBvc2l0aW9uc1s2XS5sZWZ0ICs9IHBvc2l0aW9uUmVjdC53aWR0aDtcbiAgICAgIHBvc2l0aW9uc1s1XS5sZWZ0ID0gcG9zaXRpb25zWzddLmxlZnQgLT0gcG9zaXRpb25SZWN0LndpZHRoO1xuICAgIH1cblxuICAgIC8vIENvbnNpZGVyIGF1dG8gYXMgbnVsbCBmb3IgY29kaW5nIGNvbnZlbmllbmNlLlxuICAgIHZBbGlnbiA9IHZBbGlnbiA9PT0gJ2F1dG8nID8gbnVsbCA6IHZBbGlnbjtcbiAgICBoQWxpZ24gPSBoQWxpZ24gPT09ICdhdXRvJyA/IG51bGwgOiBoQWxpZ247XG5cbiAgICB2YXIgcG9zaXRpb247XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3NpdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwb3MgPSBwb3NpdGlvbnNbaV07XG5cbiAgICAgIC8vIElmIGJvdGggdkFsaWduIGFuZCBoQWxpZ24gYXJlIGRlZmluZWQsIHJldHVybiBleGFjdCBtYXRjaC5cbiAgICAgIC8vIEZvciBkeW5hbWljQWxpZ24gYW5kIG5vT3ZlcmxhcCB3ZSdsbCBoYXZlIG1vcmUgdGhhbiBvbmUgY2FuZGlkYXRlLCBzb1xuICAgICAgLy8gd2UnbGwgaGF2ZSB0byBjaGVjayB0aGUgY3JvcHBlZEFyZWEgdG8gbWFrZSB0aGUgYmVzdCBjaG9pY2UuXG4gICAgICBpZiAoIXRoaXMuZHluYW1pY0FsaWduICYmICF0aGlzLm5vT3ZlcmxhcCAmJlxuICAgICAgICBwb3MudmVydGljYWxBbGlnbiA9PT0gdkFsaWduICYmIHBvcy5ob3Jpem9udGFsQWxpZ24gPT09IGhBbGlnbikge1xuICAgICAgICBwb3NpdGlvbiA9IHBvcztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEFsaWduIGlzIG9rIGlmIGFsaWdubWVudCBwcmVmZXJlbmNlcyBhcmUgcmVzcGVjdGVkLiBJZiBubyBwcmVmZXJlbmNlcyxcbiAgICAgIC8vIGl0IGlzIGNvbnNpZGVyZWQgb2suXG4gICAgICB2YXIgYWxpZ25PayA9ICghdkFsaWduIHx8IHBvcy52ZXJ0aWNhbEFsaWduID09PSB2QWxpZ24pICYmXG4gICAgICAgICghaEFsaWduIHx8IHBvcy5ob3Jpem9udGFsQWxpZ24gPT09IGhBbGlnbik7XG5cbiAgICAgIC8vIEZpbHRlciBvdXQgZWxlbWVudHMgdGhhdCBkb24ndCBtYXRjaCB0aGUgYWxpZ25tZW50IChpZiBkZWZpbmVkKS5cbiAgICAgIC8vIFdpdGggZHluYW1pY0FsaWduLCB3ZSBuZWVkIHRvIGNvbnNpZGVyIGFsbCB0aGUgcG9zaXRpb25zIHRvIGZpbmQgdGhlXG4gICAgICAvLyBvbmUgdGhhdCBtaW5pbWl6ZXMgdGhlIGNyb3BwZWQgYXJlYS5cbiAgICAgIGlmICghdGhpcy5keW5hbWljQWxpZ24gJiYgIWFsaWduT2spIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHBvc2l0aW9uID0gcG9zaXRpb24gfHwgcG9zO1xuICAgICAgcG9zLmNyb3BwZWRBcmVhID0gdGhpcy5fX2dldENyb3BwZWRBcmVhKHBvcywgc2l6ZSwgZml0UmVjdCk7XG4gICAgICB2YXIgZGlmZiA9IHBvcy5jcm9wcGVkQXJlYSAtIHBvc2l0aW9uLmNyb3BwZWRBcmVhO1xuICAgICAgLy8gQ2hlY2sgd2hpY2ggY3JvcHMgbGVzcy4gSWYgaXQgY3JvcHMgZXF1YWxseSwgY2hlY2sgaWYgYWxpZ24gaXMgb2suXG4gICAgICBpZiAoZGlmZiA8IDAgfHwgKGRpZmYgPT09IDAgJiYgYWxpZ25PaykpIHtcbiAgICAgICAgcG9zaXRpb24gPSBwb3M7XG4gICAgICB9XG4gICAgICAvLyBJZiBub3QgY3JvcHBlZCBhbmQgcmVzcGVjdHMgdGhlIGFsaWduIHJlcXVpcmVtZW50cywga2VlcCBpdC5cbiAgICAgIC8vIFRoaXMgYWxsb3dzIHRvIHByZWZlciBwb3NpdGlvbnMgb3ZlcmxhcHBpbmcgaG9yaXpvbnRhbGx5IG92ZXIgdGhlXG4gICAgICAvLyBvbmVzIG92ZXJsYXBwaW5nIHZlcnRpY2FsbHkuXG4gICAgICBpZiAocG9zaXRpb24uY3JvcHBlZEFyZWEgPT09IDAgJiYgYWxpZ25Paykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcG9zaXRpb247XG4gIH1cblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tZml0LWJlaGF2aW9yL2lyb24tZml0LWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBTZXR0aW5ncyB9IGZyb20gJy4uL3BvbHltZXIvbGliL3V0aWxzL3NldHRpbmdzLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uUmVzaXphYmxlQmVoYXZpb3IgPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xvc2VzdCBhbmNlc3RvciBlbGVtZW50IHRoYXQgaW1wbGVtZW50cyBgSXJvblJlc2l6YWJsZUJlaGF2aW9yYC5cbiAgICAgKi9cbiAgICBfcGFyZW50UmVzaXphYmxlOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICBvYnNlcnZlcjogJ19wYXJlbnRSZXNpemFibGVDaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoaXMgZWxlbWVudCBpcyBjdXJyZW50bHkgbm90aWZ5aW5nIGl0cyBkZXNjZW5kYW50IGVsZW1lbnRzIG9mXG4gICAgICogcmVzaXplLlxuICAgICAqL1xuICAgIF9ub3RpZnlpbmdEZXNjZW5kYW50OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIGxpc3RlbmVyczoge1xuICAgICdpcm9uLXJlcXVlc3QtcmVzaXplLW5vdGlmaWNhdGlvbnMnOiAnX29uSXJvblJlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zJ1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFdlIGRvbid0IHJlYWxseSBuZWVkIHByb3BlcnR5IGVmZmVjdHMgb24gdGhlc2UsIGFuZCBhbHNvIHdlIHdhbnQgdGhlbVxuICAgIC8vIHRvIGJlIGNyZWF0ZWQgYmVmb3JlIHRoZSBgX3BhcmVudFJlc2l6YWJsZWAgb2JzZXJ2ZXIgZmlyZXM6XG4gICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMgPSBbXTtcbiAgICB0aGlzLl9ib3VuZE5vdGlmeVJlc2l6ZSA9IHRoaXMubm90aWZ5UmVzaXplLmJpbmQodGhpcyk7XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zKCk7XG4gIH0sXG5cbiAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnRSZXNpemFibGUpIHtcbiAgICAgIHRoaXMuX3BhcmVudFJlc2l6YWJsZS5zdG9wUmVzaXplTm90aWZpY2F0aW9uc0Zvcih0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplKTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJlbnRSZXNpemFibGUgPSBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYW4gYmUgY2FsbGVkIHRvIG1hbnVhbGx5IG5vdGlmeSBhIHJlc2l6YWJsZSBhbmQgaXRzIGRlc2NlbmRhbnRcbiAgICogcmVzaXphYmxlcyBvZiBhIHJlc2l6ZSBjaGFuZ2UuXG4gICAqL1xuICBub3RpZnlSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuZm9yRWFjaChmdW5jdGlvbihyZXNpemFibGUpIHtcbiAgICAgIGlmICh0aGlzLnJlc2l6ZXJTaG91bGROb3RpZnkocmVzaXphYmxlKSkge1xuICAgICAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50KHJlc2l6YWJsZSk7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG5cbiAgICB0aGlzLl9maXJlUmVzaXplKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gYXNzaWduIHRoZSBjbG9zZXN0IHJlc2l6YWJsZSBhbmNlc3RvciB0byB0aGlzIHJlc2l6YWJsZVxuICAgKiBpZiB0aGUgYW5jZXN0b3IgZGV0ZWN0cyBhIHJlcXVlc3QgZm9yIG5vdGlmaWNhdGlvbnMuXG4gICAqL1xuICBhc3NpZ25QYXJlbnRSZXNpemFibGU6IGZ1bmN0aW9uKHBhcmVudFJlc2l6YWJsZSkge1xuICAgIHRoaXMuX3BhcmVudFJlc2l6YWJsZSA9IHBhcmVudFJlc2l6YWJsZTtcbiAgfSxcblxuICAvKipcbiAgICogVXNlZCB0byByZW1vdmUgYSByZXNpemFibGUgZGVzY2VuZGFudCBmcm9tIHRoZSBsaXN0IG9mIGRlc2NlbmRhbnRzXG4gICAqIHRoYXQgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIGEgcmVzaXplIGNoYW5nZS5cbiAgICovXG4gIHN0b3BSZXNpemVOb3RpZmljYXRpb25zRm9yOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5pbmRleE9mKHRhcmdldCk7XG5cbiAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5faW50ZXJlc3RlZFJlc2l6YWJsZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIHRoaXMudW5saXN0ZW4odGFyZ2V0LCAnaXJvbi1yZXNpemUnLCAnX29uRGVzY2VuZGFudElyb25SZXNpemUnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgbWV0aG9kIGNhbiBiZSBvdmVycmlkZGVuIHRvIGZpbHRlciBuZXN0ZWQgZWxlbWVudHMgdGhhdCBzaG91bGQgb3JcbiAgICogc2hvdWxkIG5vdCBiZSBub3RpZmllZCBieSB0aGUgY3VycmVudCBlbGVtZW50LiBSZXR1cm4gdHJ1ZSBpZiBhbiBlbGVtZW50XG4gICAqIHNob3VsZCBiZSBub3RpZmllZCwgb3IgZmFsc2UgaWYgaXQgc2hvdWxkIG5vdCBiZSBub3RpZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBBIGNhbmRpZGF0ZSBkZXNjZW5kYW50IGVsZW1lbnQgdGhhdFxuICAgKiBpbXBsZW1lbnRzIGBJcm9uUmVzaXphYmxlQmVoYXZpb3JgLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBgZWxlbWVudGAgc2hvdWxkIGJlIG5vdGlmaWVkIG9mIHJlc2l6ZS5cbiAgICovXG4gIHJlc2l6ZXJTaG91bGROb3RpZnk6IGZ1bmN0aW9uKGVsZW1lbnQpIHsgcmV0dXJuIHRydWU7IH0sXG5cbiAgX29uRGVzY2VuZGFudElyb25SZXNpemU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuX25vdGlmeWluZ0Rlc2NlbmRhbnQpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5PVEUoY2RhdGEpOiBJbiBTaGFkb3dET00sIGV2ZW50IHJldGFyZ2V0aW5nIG1ha2VzIGVjaG9pbmcgb2YgdGhlXG4gICAgLy8gb3RoZXJ3aXNlIG5vbi1idWJibGluZyBldmVudCBcImp1c3Qgd29yay5cIiBXZSBkbyBpdCBtYW51YWxseSBoZXJlIGZvclxuICAgIC8vIHRoZSBjYXNlIHdoZXJlIFBvbHltZXIgaXMgbm90IHVzaW5nIHNoYWRvdyByb290cyBmb3Igd2hhdGV2ZXIgcmVhc29uOlxuICAgIGlmICghU2V0dGluZ3MudXNlU2hhZG93KSB7XG4gICAgICB0aGlzLl9maXJlUmVzaXplKCk7XG4gICAgfVxuICB9LFxuXG4gIF9maXJlUmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmZpcmUoJ2lyb24tcmVzaXplJywgbnVsbCwge1xuICAgICAgbm9kZTogdGhpcyxcbiAgICAgIGJ1YmJsZXM6IGZhbHNlXG4gICAgfSk7XG4gIH0sXG5cbiAgX29uSXJvblJlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSAvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKGRvbShldmVudCkucm9vdFRhcmdldCk7XG4gICAgaWYgKHRhcmdldCA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5pbmRleE9mKHRhcmdldCkgPT09IC0xKSB7XG4gICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5wdXNoKHRhcmdldCk7XG4gICAgICB0aGlzLmxpc3Rlbih0YXJnZXQsICdpcm9uLXJlc2l6ZScsICdfb25EZXNjZW5kYW50SXJvblJlc2l6ZScpO1xuICAgIH1cblxuICAgIHRhcmdldC5hc3NpZ25QYXJlbnRSZXNpemFibGUodGhpcyk7XG4gICAgdGhpcy5fbm90aWZ5RGVzY2VuZGFudCh0YXJnZXQpO1xuXG4gICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH0sXG5cbiAgX3BhcmVudFJlc2l6YWJsZUNoYW5nZWQ6IGZ1bmN0aW9uKHBhcmVudFJlc2l6YWJsZSkge1xuICAgIGlmIChwYXJlbnRSZXNpemFibGUpIHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE5vdGlmeVJlc2l6ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9ub3RpZnlEZXNjZW5kYW50OiBmdW5jdGlvbihkZXNjZW5kYW50KSB7XG4gICAgLy8gTk9URShjZGF0YSk6IEluIElFMTAsIGF0dGFjaGVkIGlzIGZpcmVkIG9uIGNoaWxkcmVuIGZpcnN0LCBzbyBpdCdzXG4gICAgLy8gaW1wb3J0YW50IG5vdCB0byBub3RpZnkgdGhlbSBpZiB0aGUgcGFyZW50IGlzIG5vdCBhdHRhY2hlZCB5ZXQgKG9yXG4gICAgLy8gZWxzZSB0aGV5IHdpbGwgZ2V0IHJlZHVuZGFudGx5IG5vdGlmaWVkIHdoZW4gdGhlIHBhcmVudCBhdHRhY2hlcykuXG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9ub3RpZnlpbmdEZXNjZW5kYW50ID0gdHJ1ZTtcbiAgICBkZXNjZW5kYW50Lm5vdGlmeVJlc2l6ZSgpO1xuICAgIHRoaXMuX25vdGlmeWluZ0Rlc2NlbmRhbnQgPSBmYWxzZTtcbiAgfSxcbiAgXG4gIF9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpXG4gICAgICByZXR1cm47XG4gICAgXG4gICAgLy8gTk9URSh2YWxkcmluKSBJbiBDdXN0b21FbGVtZW50cyB2MSB3aXRoIG5hdGl2ZSBIVE1MSW1wb3J0cywgdGhlIG9yZGVyXG4gICAgLy8gb2YgaW1wb3J0cyBhZmZlY3RzIHRoZSBvcmRlciBvZiBgYXR0YWNoZWRgIGNhbGxiYWNrcyAoc2VlIHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzIzE1KS5cbiAgICAvLyBUaGlzIG1pZ2h0IGNhdXNlIGEgY2hpbGQgdG8gbm90aWZ5IHBhcmVudHMgdG9vIGVhcmx5IChhcyB0aGUgcGFyZW50XG4gICAgLy8gc3RpbGwgaGFzIHRvIGJlIHVwZ3JhZGVkKSwgcmVzdWx0aW5nIGluIGEgcGFyZW50IG5vdCBhYmxlIHRvIGtlZXAgdHJhY2tcbiAgICAvLyBvZiB0aGUgYF9pbnRlcmVzdGVkUmVzaXphYmxlc2AuIFRvIHNvbHZlIHRoaXMsIHdlIHdhaXQgZm9yIHRoZSBkb2N1bWVudFxuICAgIC8vIHRvIGJlIGRvbmUgbG9hZGluZyBiZWZvcmUgZmlyaW5nIHRoZSBldmVudC5cbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICB2YXIgX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zID0gdGhpcy5fcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMuYmluZCh0aGlzKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCBmdW5jdGlvbiByZWFkeXN0YXRlY2hhbmdlZCgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIHJlYWR5c3RhdGVjaGFuZ2VkKTtcbiAgICAgICAgX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maXJlKCdpcm9uLXJlcXVlc3QtcmVzaXplLW5vdGlmaWNhdGlvbnMnLCBudWxsLCB7XG4gICAgICAgIG5vZGU6IHRoaXMsXG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIXRoaXMuX3BhcmVudFJlc2l6YWJsZSkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmROb3RpZnlSZXNpemUpO1xuICAgICAgICB0aGlzLm5vdGlmeVJlc2l6ZSgpO1xuICAgICAgfSBcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci9pcm9uLXJlc2l6YWJsZS1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkExMXlLZXlzQmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgJy4vaXJvbi1vdmVybGF5LWJhY2tkcm9wLmpzJztcbmltcG9ydCAqIGFzIGdlc3R1cmVzIGZyb20gJy4uL3BvbHltZXIvbGliL3V0aWxzL2dlc3R1cmVzLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uT3ZlcmxheU1hbmFnZXJDbGFzcyA9IGZ1bmN0aW9uKCkge1xuICAvKipcbiAgICogVXNlZCB0byBrZWVwIHRyYWNrIG9mIHRoZSBvcGVuZWQgb3ZlcmxheXMuXG4gICAqIEBwcml2YXRlIHtBcnJheTxFbGVtZW50Pn1cbiAgICovXG4gIHRoaXMuX292ZXJsYXlzID0gW107XG5cbiAgLyoqXG4gICAqIGlmcmFtZXMgaGF2ZSBhIGRlZmF1bHQgei1pbmRleCBvZiAxMDAsXG4gICAqIHNvIHRoaXMgZGVmYXVsdCBzaG91bGQgYmUgYXQgbGVhc3QgdGhhdC5cbiAgICogQHByaXZhdGUge251bWJlcn1cbiAgICovXG4gIHRoaXMuX21pbmltdW1aID0gMTAxO1xuXG4gIC8qKlxuICAgKiBNZW1vaXplZCBiYWNrZHJvcCBlbGVtZW50LlxuICAgKiBAcHJpdmF0ZSB7RWxlbWVudHxudWxsfVxuICAgKi9cbiAgdGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gbnVsbDtcblxuICAvLyBFbmFibGUgZG9jdW1lbnQtd2lkZSB0YXAgcmVjb2duaXplci5cbiAgLy8gTk9URTogVXNlIHVzZUNhcHR1cmU9dHJ1ZSB0byBhdm9pZCBhY2NpZGVudGFsbHkgcHJldmVudGlvbiBvZiB0aGUgY2xvc2luZ1xuICAvLyBvZiBhbiBvdmVybGF5IHZpYSBldmVudC5zdG9wUHJvcGFnYXRpb24oKS4gVGhlIG9ubHkgd2F5IHRvIHByZXZlbnRcbiAgLy8gY2xvc2luZyBvZiBhbiBvdmVybGF5IHNob3VsZCBiZSB0aHJvdWdoIGl0cyBBUElzLlxuICAvLyBOT1RFOiBlbmFibGUgdGFwIG9uIDxodG1sPiB0byB3b3JrYXJvdW5kIFBvbHltZXIvcG9seW1lciM0NDU5XG4gIGdlc3R1cmVzLmFkZChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsICd0YXAnLCBudWxsKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndGFwJywgdGhpcy5fb25DYXB0dXJlQ2xpY2suYmluZCh0aGlzKSwgdHJ1ZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5fb25DYXB0dXJlRm9jdXMuYmluZCh0aGlzKSwgdHJ1ZSk7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLl9vbkNhcHR1cmVLZXlEb3duLmJpbmQodGhpcyksIHRydWUpO1xufTtcblxuSXJvbk92ZXJsYXlNYW5hZ2VyQ2xhc3MucHJvdG90eXBlID0ge1xuXG4gIGNvbnN0cnVjdG9yOiBJcm9uT3ZlcmxheU1hbmFnZXJDbGFzcyxcblxuICAvKipcbiAgICogVGhlIHNoYXJlZCBiYWNrZHJvcCBlbGVtZW50LlxuICAgKiBAdHlwZSB7IUVsZW1lbnR9IGJhY2tkcm9wRWxlbWVudFxuICAgKi9cbiAgZ2V0IGJhY2tkcm9wRWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuX2JhY2tkcm9wRWxlbWVudCkge1xuICAgICAgdGhpcy5fYmFja2Ryb3BFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaXJvbi1vdmVybGF5LWJhY2tkcm9wJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9iYWNrZHJvcEVsZW1lbnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoZSBkZWVwZXN0IGFjdGl2ZSBlbGVtZW50LlxuICAgKiBAdHlwZSB7IUVsZW1lbnR9IGFjdGl2ZUVsZW1lbnQgdGhlIGFjdGl2ZSBlbGVtZW50XG4gICAqL1xuICBnZXQgZGVlcEFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgLy8gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gYmUgbnVsbFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Eb2N1bWVudC9hY3RpdmVFbGVtZW50XG4gICAgLy8gSW4gY2FzZSBvZiBudWxsLCBkZWZhdWx0IGl0IHRvIGRvY3VtZW50LmJvZHkuXG4gICAgdmFyIGFjdGl2ZSA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgZG9jdW1lbnQuYm9keTtcbiAgICB3aGlsZSAoYWN0aXZlLnJvb3QgJiYgZG9tKGFjdGl2ZS5yb290KS5hY3RpdmVFbGVtZW50KSB7XG4gICAgICBhY3RpdmUgPSBkb20oYWN0aXZlLnJvb3QpLmFjdGl2ZUVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBhY3RpdmU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEJyaW5ncyB0aGUgb3ZlcmxheSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4IHRvIHRoZSBmcm9udC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGlcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9icmluZ092ZXJsYXlBdEluZGV4VG9Gcm9udDogZnVuY3Rpb24oaSkge1xuICAgIHZhciBvdmVybGF5ID0gdGhpcy5fb3ZlcmxheXNbaV07XG4gICAgaWYgKCFvdmVybGF5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsYXN0SSA9IHRoaXMuX292ZXJsYXlzLmxlbmd0aCAtIDE7XG4gICAgdmFyIGN1cnJlbnRPdmVybGF5ID0gdGhpcy5fb3ZlcmxheXNbbGFzdEldO1xuICAgIC8vIEVuc3VyZSBhbHdheXMtb24tdG9wIG92ZXJsYXkgc3RheXMgb24gdG9wLlxuICAgIGlmIChjdXJyZW50T3ZlcmxheSAmJiB0aGlzLl9zaG91bGRCZUJlaGluZE92ZXJsYXkob3ZlcmxheSwgY3VycmVudE92ZXJsYXkpKSB7XG4gICAgICBsYXN0SS0tO1xuICAgIH1cbiAgICAvLyBJZiBhbHJlYWR5IHRoZSB0b3AgZWxlbWVudCwgcmV0dXJuLlxuICAgIGlmIChpID49IGxhc3RJKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFVwZGF0ZSB6LWluZGV4IHRvIGJlIG9uIHRvcC5cbiAgICB2YXIgbWluaW11bVogPSBNYXRoLm1heCh0aGlzLmN1cnJlbnRPdmVybGF5WigpLCB0aGlzLl9taW5pbXVtWik7XG4gICAgaWYgKHRoaXMuX2dldFoob3ZlcmxheSkgPD0gbWluaW11bVopIHtcbiAgICAgIHRoaXMuX2FwcGx5T3ZlcmxheVoob3ZlcmxheSwgbWluaW11bVopO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IG90aGVyIG92ZXJsYXlzIGJlaGluZCB0aGUgbmV3IG9uIHRvcC5cbiAgICB3aGlsZSAoaSA8IGxhc3RJKSB7XG4gICAgICB0aGlzLl9vdmVybGF5c1tpXSA9IHRoaXMuX292ZXJsYXlzW2kgKyAxXTtcbiAgICAgIGkrKztcbiAgICB9XG4gICAgdGhpcy5fb3ZlcmxheXNbbGFzdEldID0gb3ZlcmxheTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyB0aGUgb3ZlcmxheSBhbmQgdXBkYXRlcyBpdHMgei1pbmRleCBpZiBpdCdzIG9wZW5lZCwgb3IgcmVtb3ZlcyBpdCBpZiBpdCdzIGNsb3NlZC5cbiAgICogQWxzbyB1cGRhdGVzIHRoZSBiYWNrZHJvcCB6LWluZGV4LlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBvdmVybGF5XG4gICAqL1xuICBhZGRPclJlbW92ZU92ZXJsYXk6IGZ1bmN0aW9uKG92ZXJsYXkpIHtcbiAgICBpZiAob3ZlcmxheS5vcGVuZWQpIHtcbiAgICAgIHRoaXMuYWRkT3ZlcmxheShvdmVybGF5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVPdmVybGF5KG92ZXJsYXkpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVHJhY2tzIG92ZXJsYXlzIGZvciB6LWluZGV4IGFuZCBmb2N1cyBtYW5hZ2VtZW50LlxuICAgKiBFbnN1cmVzIHRoZSBsYXN0IGFkZGVkIG92ZXJsYXkgd2l0aCBhbHdheXMtb24tdG9wIHJlbWFpbnMgb24gdG9wLlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBvdmVybGF5XG4gICAqL1xuICBhZGRPdmVybGF5OiBmdW5jdGlvbihvdmVybGF5KSB7XG4gICAgdmFyIGkgPSB0aGlzLl9vdmVybGF5cy5pbmRleE9mKG92ZXJsYXkpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIHRoaXMuX2JyaW5nT3ZlcmxheUF0SW5kZXhUb0Zyb250KGkpO1xuICAgICAgdGhpcy50cmFja0JhY2tkcm9wKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbnNlcnRpb25JbmRleCA9IHRoaXMuX292ZXJsYXlzLmxlbmd0aDtcbiAgICB2YXIgY3VycmVudE92ZXJsYXkgPSB0aGlzLl9vdmVybGF5c1tpbnNlcnRpb25JbmRleCAtIDFdO1xuICAgIHZhciBtaW5pbXVtWiA9IE1hdGgubWF4KHRoaXMuX2dldFooY3VycmVudE92ZXJsYXkpLCB0aGlzLl9taW5pbXVtWik7XG4gICAgdmFyIG5ld1ogPSB0aGlzLl9nZXRaKG92ZXJsYXkpO1xuXG4gICAgLy8gRW5zdXJlIGFsd2F5cy1vbi10b3Agb3ZlcmxheSBzdGF5cyBvbiB0b3AuXG4gICAgaWYgKGN1cnJlbnRPdmVybGF5ICYmIHRoaXMuX3Nob3VsZEJlQmVoaW5kT3ZlcmxheShvdmVybGF5LCBjdXJyZW50T3ZlcmxheSkpIHtcbiAgICAgIC8vIFRoaXMgYnVtcHMgdGhlIHotaW5kZXggb2YgKzIuXG4gICAgICB0aGlzLl9hcHBseU92ZXJsYXlaKGN1cnJlbnRPdmVybGF5LCBtaW5pbXVtWik7XG4gICAgICBpbnNlcnRpb25JbmRleC0tO1xuICAgICAgLy8gVXBkYXRlIG1pbmltdW1aIHRvIG1hdGNoIHByZXZpb3VzIG92ZXJsYXkncyB6LWluZGV4LlxuICAgICAgdmFyIHByZXZpb3VzT3ZlcmxheSA9IHRoaXMuX292ZXJsYXlzW2luc2VydGlvbkluZGV4IC0gMV07XG4gICAgICBtaW5pbXVtWiA9IE1hdGgubWF4KHRoaXMuX2dldFoocHJldmlvdXNPdmVybGF5KSwgdGhpcy5fbWluaW11bVopO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB6LWluZGV4IGFuZCBpbnNlcnQgb3ZlcmxheS5cbiAgICBpZiAobmV3WiA8PSBtaW5pbXVtWikge1xuICAgICAgdGhpcy5fYXBwbHlPdmVybGF5WihvdmVybGF5LCBtaW5pbXVtWik7XG4gICAgfVxuICAgIHRoaXMuX292ZXJsYXlzLnNwbGljZShpbnNlcnRpb25JbmRleCwgMCwgb3ZlcmxheSk7XG5cbiAgICB0aGlzLnRyYWNrQmFja2Ryb3AoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gb3ZlcmxheVxuICAgKi9cbiAgcmVtb3ZlT3ZlcmxheTogZnVuY3Rpb24ob3ZlcmxheSkge1xuICAgIHZhciBpID0gdGhpcy5fb3ZlcmxheXMuaW5kZXhPZihvdmVybGF5KTtcbiAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fb3ZlcmxheXMuc3BsaWNlKGksIDEpO1xuXG4gICAgdGhpcy50cmFja0JhY2tkcm9wKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGN1cnJlbnQgb3ZlcmxheS5cbiAgICogQHJldHVybiB7RWxlbWVudHx1bmRlZmluZWR9XG4gICAqL1xuICBjdXJyZW50T3ZlcmxheTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGkgPSB0aGlzLl9vdmVybGF5cy5sZW5ndGggLSAxO1xuICAgIHJldHVybiB0aGlzLl9vdmVybGF5c1tpXTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBvdmVybGF5IHotaW5kZXguXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGN1cnJlbnRPdmVybGF5WjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFoodGhpcy5jdXJyZW50T3ZlcmxheSgpKTtcbiAgfSxcblxuICAvKipcbiAgICogRW5zdXJlcyB0aGF0IHRoZSBtaW5pbXVtIHotaW5kZXggb2YgbmV3IG92ZXJsYXlzIGlzIGF0IGxlYXN0IGBtaW5pbXVtWmAuXG4gICAqIFRoaXMgZG9lcyBub3QgZWZmZWN0IHRoZSB6LWluZGV4IG9mIGFueSBleGlzdGluZyBvdmVybGF5cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbmltdW1aXG4gICAqL1xuICBlbnN1cmVNaW5pbXVtWjogZnVuY3Rpb24obWluaW11bVopIHtcbiAgICB0aGlzLl9taW5pbXVtWiA9IE1hdGgubWF4KHRoaXMuX21pbmltdW1aLCBtaW5pbXVtWik7XG4gIH0sXG5cbiAgZm9jdXNPdmVybGF5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgY3VycmVudCA9IC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuY3VycmVudE92ZXJsYXkoKSk7XG4gICAgaWYgKGN1cnJlbnQpIHtcbiAgICAgIGN1cnJlbnQuX2FwcGx5Rm9jdXMoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgdGhlIGJhY2tkcm9wIHotaW5kZXguXG4gICAqL1xuICB0cmFja0JhY2tkcm9wOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgb3ZlcmxheSA9IHRoaXMuX292ZXJsYXlXaXRoQmFja2Ryb3AoKTtcbiAgICAvLyBBdm9pZCBjcmVhdGluZyB0aGUgYmFja2Ryb3AgaWYgdGhlcmUgaXMgbm8gb3ZlcmxheSB3aXRoIGJhY2tkcm9wLlxuICAgIGlmICghb3ZlcmxheSAmJiAhdGhpcy5fYmFja2Ryb3BFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYmFja2Ryb3BFbGVtZW50LnN0eWxlLnpJbmRleCA9IHRoaXMuX2dldFoob3ZlcmxheSkgLSAxO1xuICAgIHRoaXMuYmFja2Ryb3BFbGVtZW50Lm9wZW5lZCA9ICEhb3ZlcmxheTtcbiAgICAvLyBQcm9wZXJ0eSBvYnNlcnZlcnMgYXJlIG5vdCBmaXJlZCB1bnRpbCBlbGVtZW50IGlzIGF0dGFjaGVkXG4gICAgLy8gaW4gUG9seW1lciAyLngsIHNvIHdlIGVuc3VyZSBlbGVtZW50IGlzIGF0dGFjaGVkIGlmIG5lZWRlZC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vUG9seW1lci9wb2x5bWVyL2lzc3Vlcy80NTI2XG4gICAgdGhpcy5iYWNrZHJvcEVsZW1lbnQucHJlcGFyZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxFbGVtZW50Pn1cbiAgICovXG4gIGdldEJhY2tkcm9wczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGJhY2tkcm9wcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3ZlcmxheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9vdmVybGF5c1tpXS53aXRoQmFja2Ryb3ApIHtcbiAgICAgICAgYmFja2Ryb3BzLnB1c2godGhpcy5fb3ZlcmxheXNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYmFja2Ryb3BzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB6LWluZGV4IGZvciB0aGUgYmFja2Ryb3AuXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGJhY2tkcm9wWjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFoodGhpcy5fb3ZlcmxheVdpdGhCYWNrZHJvcCgpKSAtIDE7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IG9wZW5lZCBvdmVybGF5IHRoYXQgaGFzIGEgYmFja2Ryb3AuXG4gICAqIEByZXR1cm4ge0VsZW1lbnR8dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX292ZXJsYXlXaXRoQmFja2Ryb3A6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fb3ZlcmxheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh0aGlzLl9vdmVybGF5c1tpXS53aXRoQmFja2Ryb3ApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX292ZXJsYXlzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsY3VsYXRlcyB0aGUgbWluaW11bSB6LWluZGV4IGZvciB0aGUgb3ZlcmxheS5cbiAgICogQHBhcmFtIHtFbGVtZW50PX0gb3ZlcmxheVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFo6IGZ1bmN0aW9uKG92ZXJsYXkpIHtcbiAgICB2YXIgeiA9IHRoaXMuX21pbmltdW1aO1xuICAgIGlmIChvdmVybGF5KSB7XG4gICAgICB2YXIgejEgPSBOdW1iZXIob3ZlcmxheS5zdHlsZS56SW5kZXggfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUob3ZlcmxheSkuekluZGV4KTtcbiAgICAgIC8vIENoZWNrIGlmIGlzIGEgbnVtYmVyXG4gICAgICAvLyBOdW1iZXIuaXNOYU4gbm90IHN1cHBvcnRlZCBpbiBJRSAxMCtcbiAgICAgIGlmICh6MSA9PT0gejEpIHtcbiAgICAgICAgeiA9IHoxO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gejtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zZXRaOiBmdW5jdGlvbihlbGVtZW50LCB6KSB7XG4gICAgZWxlbWVudC5zdHlsZS56SW5kZXggPSB6O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBvdmVybGF5XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhYm92ZVpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9hcHBseU92ZXJsYXlaOiBmdW5jdGlvbihvdmVybGF5LCBhYm92ZVopIHtcbiAgICB0aGlzLl9zZXRaKG92ZXJsYXksIGFib3ZlWiArIDIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWVwZXN0IG92ZXJsYXkgaW4gdGhlIHBhdGguXG4gICAqIEBwYXJhbSB7QXJyYXk8RWxlbWVudD49fSBwYXRoXG4gICAqIEByZXR1cm4ge0VsZW1lbnR8dW5kZWZpbmVkfVxuICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX292ZXJsYXlJblBhdGg6IGZ1bmN0aW9uKHBhdGgpIHtcbiAgICBwYXRoID0gcGF0aCB8fCBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwYXRoW2ldLl9tYW5hZ2VyID09PSB0aGlzKSB7XG4gICAgICAgIHJldHVybiBwYXRoW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5zdXJlcyB0aGUgY2xpY2sgZXZlbnQgaXMgZGVsZWdhdGVkIHRvIHRoZSByaWdodCBvdmVybGF5LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNhcHR1cmVDbGljazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgb3ZlcmxheSA9IC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuY3VycmVudE92ZXJsYXkoKSk7XG4gICAgLy8gQ2hlY2sgaWYgY2xpY2tlZCBvdXRzaWRlIG9mIHRvcCBvdmVybGF5LlxuICAgIGlmIChvdmVybGF5ICYmIHRoaXMuX292ZXJsYXlJblBhdGgoZG9tKGV2ZW50KS5wYXRoKSAhPT0gb3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5fb25DYXB0dXJlQ2xpY2soZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5zdXJlcyB0aGUgZm9jdXMgZXZlbnQgaXMgZGVsZWdhdGVkIHRvIHRoZSByaWdodCBvdmVybGF5LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkNhcHR1cmVGb2N1czogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgb3ZlcmxheSA9IC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuY3VycmVudE92ZXJsYXkoKSk7XG4gICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgIG92ZXJsYXkuX29uQ2FwdHVyZUZvY3VzKGV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVuc3VyZXMgVEFCIGFuZCBFU0Mga2V5Ym9hcmQgZXZlbnRzIGFyZSBkZWxlZ2F0ZWQgdG8gdGhlIHJpZ2h0IG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2FwdHVyZUtleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIG92ZXJsYXkgPSAvKiogQHR5cGUgez99ICovICh0aGlzLmN1cnJlbnRPdmVybGF5KCkpO1xuICAgIGlmIChvdmVybGF5KSB7XG4gICAgICBpZiAoSXJvbkExMXlLZXlzQmVoYXZpb3Iua2V5Ym9hcmRFdmVudE1hdGNoZXNLZXlzKGV2ZW50LCAnZXNjJykpIHtcbiAgICAgICAgb3ZlcmxheS5fb25DYXB0dXJlRXNjKGV2ZW50KTtcbiAgICAgIH0gZWxzZSBpZiAoSXJvbkExMXlLZXlzQmVoYXZpb3Iua2V5Ym9hcmRFdmVudE1hdGNoZXNLZXlzKGV2ZW50LCAndGFiJykpIHtcbiAgICAgICAgb3ZlcmxheS5fb25DYXB0dXJlVGFiKGV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgdGhlIG92ZXJsYXkxIHNob3VsZCBiZSBiZWhpbmQgb3ZlcmxheTIuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG92ZXJsYXkxXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG92ZXJsYXkyXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc2hvdWxkQmVCZWhpbmRPdmVybGF5OiBmdW5jdGlvbihvdmVybGF5MSwgb3ZlcmxheTIpIHtcbiAgICByZXR1cm4gIW92ZXJsYXkxLmFsd2F5c09uVG9wICYmIG92ZXJsYXkyLmFsd2F5c09uVG9wO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgSXJvbk92ZXJsYXlNYW5hZ2VyID0gbmV3IElyb25PdmVybGF5TWFuYWdlckNsYXNzKCk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW92ZXJsYXktYmVoYXZpb3IvaXJvbi1vdmVybGF5LW1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDc4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGhlaWdodDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0taXJvbi1vdmVybGF5LWJhY2tkcm9wLWJhY2tncm91bmQtY29sb3IsICMwMDApO1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgICB0cmFuc2l0aW9uOiBvcGFjaXR5IDAuMnM7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBAYXBwbHkgLS1pcm9uLW92ZXJsYXktYmFja2Ryb3A7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KC5vcGVuZWQpIHtcbiAgICAgICAgb3BhY2l0eTogdmFyKC0taXJvbi1vdmVybGF5LWJhY2tkcm9wLW9wYWNpdHksIDAuNik7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBhdXRvO1xuICAgICAgICBAYXBwbHkgLS1pcm9uLW92ZXJsYXktYmFja2Ryb3Atb3BlbmVkO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8c2xvdD48L3Nsb3Q+XG5gLFxuXG4gIGlzOiAnaXJvbi1vdmVybGF5LWJhY2tkcm9wJyxcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGJhY2tkcm9wIGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBvcGVuZWQ6IHtcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBvYnNlcnZlcjogJ19vcGVuZWRDaGFuZ2VkJ1xuICAgIH1cblxuICB9LFxuXG4gIGxpc3RlbmVyczoge1xuICAgICd0cmFuc2l0aW9uZW5kJzogJ19vblRyYW5zaXRpb25lbmQnXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gVXNlZCB0byBjYW5jZWwgcHJldmlvdXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGNhbGxzIHdoZW4gb3BlbmVkIGNoYW5nZXMuXG4gICAgdGhpcy5fX29wZW5lZFJhZiA9IG51bGw7XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3BlbmVkICYmIHRoaXMuX29wZW5lZENoYW5nZWQodGhpcy5vcGVuZWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIHRoZSBiYWNrZHJvcCB0byBkb2N1bWVudCBib2R5IGlmIG5lZWRlZC5cbiAgICovXG4gIHByZXBhcmU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLm9wZW5lZCAmJiAhdGhpcy5wYXJlbnROb2RlKSB7XG4gICAgICBkb20oZG9jdW1lbnQuYm9keSkuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaG93cyB0aGUgYmFja2Ryb3AuXG4gICAqL1xuICBvcGVuOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhpZGVzIHRoZSBiYWNrZHJvcC5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBiYWNrZHJvcCBmcm9tIGRvY3VtZW50IGJvZHkgaWYgbmVlZGVkLlxuICAgKi9cbiAgY29tcGxldGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5vcGVuZWQgJiYgdGhpcy5wYXJlbnROb2RlID09PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICBkb20odGhpcy5wYXJlbnROb2RlKS5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgX29uVHJhbnNpdGlvbmVuZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG9wZW5lZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29wZW5lZENoYW5nZWQ6IGZ1bmN0aW9uKG9wZW5lZCkge1xuICAgIGlmIChvcGVuZWQpIHtcbiAgICAgIC8vIEF1dG8tYXR0YWNoLlxuICAgICAgdGhpcy5wcmVwYXJlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFuaW1hdGlvbiBtaWdodCBiZSBkaXNhYmxlZCB2aWEgdGhlIG1peGluIG9yIG9wYWNpdHkgY3VzdG9tIHByb3BlcnR5LlxuICAgICAgLy8gSWYgaXQgaXMgZGlzYWJsZWQgaW4gb3RoZXIgd2F5cywgaXQncyB1cCB0byB0aGUgdXNlciB0byBjYWxsIGNvbXBsZXRlLlxuICAgICAgdmFyIGNzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcyk7XG4gICAgICBpZiAoY3MudHJhbnNpdGlvbkR1cmF0aW9uID09PSAnMHMnIHx8IGNzLm9wYWNpdHkgPT0gMCkge1xuICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBBbHdheXMgY2FuY2VsIHByZXZpb3VzIHJlcXVlc3RBbmltYXRpb25GcmFtZS5cbiAgICBpZiAodGhpcy5fX29wZW5lZFJhZikge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX19vcGVuZWRSYWYpO1xuICAgICAgdGhpcy5fX29wZW5lZFJhZiA9IG51bGw7XG4gICAgfVxuICAgIC8vIEZvcmNlIHJlbGF5b3V0IHRvIGVuc3VyZSBwcm9wZXIgdHJhbnNpdGlvbnMuXG4gICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcDtcbiAgICB0aGlzLl9fb3BlbmVkUmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX19vcGVuZWRSYWYgPSBudWxsO1xuICAgICAgdGhpcy50b2dnbGVDbGFzcygnb3BlbmVkJywgdGhpcy5vcGVuZWQpO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lyb24tb3ZlcmxheS1iYWNrZHJvcC5qc1xuLy8gbW9kdWxlIGlkID0gNzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxudmFyIHAgPSBFbGVtZW50LnByb3RvdHlwZTtcbnZhciBtYXRjaGVzID0gcC5tYXRjaGVzIHx8IHAubWF0Y2hlc1NlbGVjdG9yIHx8IHAubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG4gIHAubXNNYXRjaGVzU2VsZWN0b3IgfHwgcC5vTWF0Y2hlc1NlbGVjdG9yIHx8IHAud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG5leHBvcnQgY29uc3QgSXJvbkZvY3VzYWJsZXNIZWxwZXIgPSB7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzb3J0ZWQgYXJyYXkgb2YgdGFiYmFibGUgbm9kZXMsIGluY2x1ZGluZyB0aGUgcm9vdCBub2RlLlxuICAgKiBJdCBzZWFyY2hlcyB0aGUgdGFiYmFibGUgbm9kZXMgaW4gdGhlIGxpZ2h0IGFuZCBzaGFkb3cgZG9tIG9mIHRoZSBjaGlkcmVuLFxuICAgKiBzb3J0aW5nIHRoZSByZXN1bHQgYnkgdGFiaW5kZXguXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fVxuICAgKi9cbiAgZ2V0VGFiYmFibGVOb2RlczogZnVuY3Rpb24obm9kZSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAvLyBJZiB0aGVyZSBpcyBhdCBsZWFzdCBvbmUgZWxlbWVudCB3aXRoIHRhYmluZGV4ID4gMCwgd2UgbmVlZCB0byBzb3J0XG4gICAgLy8gdGhlIGZpbmFsIGFycmF5IGJ5IHRhYmluZGV4LlxuICAgIHZhciBuZWVkc1NvcnRCeVRhYkluZGV4ID0gdGhpcy5fY29sbGVjdFRhYmJhYmxlTm9kZXMobm9kZSwgcmVzdWx0KTtcbiAgICBpZiAobmVlZHNTb3J0QnlUYWJJbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NvcnRCeVRhYkluZGV4KHJlc3VsdCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgYSBlbGVtZW50IGlzIGZvY3VzYWJsZS5cbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzRm9jdXNhYmxlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgLy8gRnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjAwMTk0LzQyMjg3MDM6XG4gICAgLy8gVGhlcmUgaXNuJ3QgYSBkZWZpbml0ZSBsaXN0LCBpdCdzIHVwIHRvIHRoZSBicm93c2VyLiBUaGUgb25seVxuICAgIC8vIHN0YW5kYXJkIHdlIGhhdmUgaXMgRE9NIExldmVsIDIgSFRNTCBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItSFRNTC9odG1sLmh0bWwsXG4gICAgLy8gYWNjb3JkaW5nIHRvIHdoaWNoIHRoZSBvbmx5IGVsZW1lbnRzIHRoYXQgaGF2ZSBhIGZvY3VzKCkgbWV0aG9kIGFyZVxuICAgIC8vIEhUTUxJbnB1dEVsZW1lbnQsICBIVE1MU2VsZWN0RWxlbWVudCwgSFRNTFRleHRBcmVhRWxlbWVudCBhbmRcbiAgICAvLyBIVE1MQW5jaG9yRWxlbWVudC4gVGhpcyBub3RhYmx5IG9taXRzIEhUTUxCdXR0b25FbGVtZW50IGFuZFxuICAgIC8vIEhUTUxBcmVhRWxlbWVudC5cbiAgICAvLyBSZWZlcnJpbmcgdG8gdGhlc2UgdGVzdHMgd2l0aCB0YWJiYWJsZXMgaW4gZGlmZmVyZW50IGJyb3dzZXJzXG4gICAgLy8gaHR0cDovL2FsbHlqcy5pby9kYXRhLXRhYmxlcy9mb2N1c2FibGUuaHRtbFxuXG4gICAgLy8gRWxlbWVudHMgdGhhdCBjYW5ub3QgYmUgZm9jdXNlZCBpZiB0aGV5IGhhdmUgW2Rpc2FibGVkXSBhdHRyaWJ1dGUuXG4gICAgaWYgKG1hdGNoZXMuY2FsbChlbGVtZW50LCAnaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIGJ1dHRvbiwgb2JqZWN0JykpIHtcbiAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwoZWxlbWVudCwgJzpub3QoW2Rpc2FibGVkXSknKTtcbiAgICB9XG4gICAgLy8gRWxlbWVudHMgdGhhdCBjYW4gYmUgZm9jdXNlZCBldmVuIGlmIHRoZXkgaGF2ZSBbZGlzYWJsZWRdIGF0dHJpYnV0ZS5cbiAgICByZXR1cm4gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsXG4gICAgICAnYVtocmVmXSwgYXJlYVtocmVmXSwgaWZyYW1lLCBbdGFiaW5kZXhdLCBbY29udGVudEVkaXRhYmxlXScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGlmIGEgZWxlbWVudCBpcyB0YWJiYWJsZS4gVG8gYmUgdGFiYmFibGUsIGEgZWxlbWVudCBtdXN0IGJlXG4gICAqIGZvY3VzYWJsZSwgdmlzaWJsZSwgYW5kIHdpdGggYSB0YWJpbmRleCAhPT0gLTEuXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc1RhYmJhYmxlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgcmV0dXJuIHRoaXMuaXNGb2N1c2FibGUoZWxlbWVudCkgJiZcbiAgICAgIG1hdGNoZXMuY2FsbChlbGVtZW50LCAnOm5vdChbdGFiaW5kZXg9XCItMVwiXSknKSAmJlxuICAgICAgdGhpcy5faXNWaXNpYmxlKGVsZW1lbnQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBub3JtYWxpemVkIGVsZW1lbnQgdGFiaW5kZXguIElmIG5vdCBmb2N1c2FibGUsIHJldHVybnMgLTEuXG4gICAqIEl0IGNoZWNrcyBmb3IgdGhlIGF0dHJpYnV0ZSBcInRhYmluZGV4XCIgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBwcm9wZXJ0eVxuICAgKiBgdGFiSW5kZXhgIHNpbmNlIGJyb3dzZXJzIGFzc2lnbiBkaWZmZXJlbnQgdmFsdWVzIHRvIGl0LlxuICAgKiBlLmcuIGluIEZpcmVmb3ggYDxkaXYgY29udGVudGVkaXRhYmxlPmAgaGFzIGB0YWJJbmRleCA9IC0xYFxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHshbnVtYmVyfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX25vcm1hbGl6ZWRUYWJJbmRleDogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIGlmICh0aGlzLmlzRm9jdXNhYmxlKGVsZW1lbnQpKSB7XG4gICAgICB2YXIgdGFiSW5kZXggPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSB8fCAwO1xuICAgICAgcmV0dXJuIE51bWJlcih0YWJJbmRleCk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSxcblxuICAvKipcbiAgICogU2VhcmNoZXMgZm9yIG5vZGVzIHRoYXQgYXJlIHRhYmJhYmxlIGFuZCBhZGRzIHRoZW0gdG8gdGhlIGByZXN1bHRgIGFycmF5LlxuICAgKiBSZXR1cm5zIGlmIHRoZSBgcmVzdWx0YCBhcnJheSBuZWVkcyB0byBiZSBzb3J0ZWQgYnkgdGFiaW5kZXguXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGUgVGhlIHN0YXJ0aW5nIHBvaW50IGZvciB0aGUgc2VhcmNoOyBhZGRlZCB0byBgcmVzdWx0YFxuICAgKiBpZiB0YWJiYWJsZS5cbiAgICogQHBhcmFtIHshQXJyYXk8SFRNTEVsZW1lbnQ+fSByZXN1bHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb2xsZWN0VGFiYmFibGVOb2RlczogZnVuY3Rpb24obm9kZSwgcmVzdWx0KSB7XG4gICAgLy8gSWYgbm90IGFuIGVsZW1lbnQgb3Igbm90IHZpc2libGUsIG5vIG5lZWQgdG8gZXhwbG9yZSBjaGlsZHJlbi5cbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUgfHwgIXRoaXMuX2lzVmlzaWJsZShub2RlKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB2YXIgZWxlbWVudCA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChub2RlKTtcbiAgICB2YXIgdGFiSW5kZXggPSB0aGlzLl9ub3JtYWxpemVkVGFiSW5kZXgoZWxlbWVudCk7XG4gICAgdmFyIG5lZWRzU29ydCA9IHRhYkluZGV4ID4gMDtcbiAgICBpZiAodGFiSW5kZXggPj0gMCkge1xuICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gICAgfVxuXG4gICAgLy8gSW4gU2hhZG93RE9NIHYxLCB0YWIgb3JkZXIgaXMgYWZmZWN0ZWQgYnkgdGhlIG9yZGVyIG9mIGRpc3RydWJ1dGlvbi5cbiAgICAvLyBFLmcuIGdldFRhYmJhYmxlTm9kZXMoI3Jvb3QpIGluIFNoYWRvd0RPTSB2MSBzaG91bGQgcmV0dXJuIFsjQSwgI0JdO1xuICAgIC8vIGluIFNoYWRvd0RPTSB2MCB0YWIgb3JkZXIgaXMgbm90IGFmZmVjdGVkIGJ5IHRoZSBkaXN0cnVidXRpb24gb3JkZXIsXG4gICAgLy8gaW4gZmFjdCBnZXRUYWJiYWJsZU5vZGVzKCNyb290KSByZXR1cm5zIFsjQiwgI0FdLlxuICAgIC8vICA8ZGl2IGlkPVwicm9vdFwiPlxuICAgIC8vICAgPCEtLSBzaGFkb3cgLS0+XG4gICAgLy8gICAgIDxzbG90IG5hbWU9XCJhXCI+XG4gICAgLy8gICAgIDxzbG90IG5hbWU9XCJiXCI+XG4gICAgLy8gICA8IS0tIC9zaGFkb3cgLS0+XG4gICAgLy8gICA8aW5wdXQgaWQ9XCJBXCIgc2xvdD1cImFcIj5cbiAgICAvLyAgIDxpbnB1dCBpZD1cIkJcIiBzbG90PVwiYlwiIHRhYmluZGV4PVwiMVwiPlxuICAgIC8vICA8L2Rpdj5cbiAgICAvLyBUT0RPKHZhbGRyaW4pIHN1cHBvcnQgU2hhZG93RE9NIHYxIHdoZW4gdXBncmFkaW5nIHRvIFBvbHltZXIgdjIuMC5cbiAgICB2YXIgY2hpbGRyZW47XG4gICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09PSAnY29udGVudCcgfHwgZWxlbWVudC5sb2NhbE5hbWUgPT09ICdzbG90Jykge1xuICAgICAgY2hpbGRyZW4gPSBkb20oZWxlbWVudCkuZ2V0RGlzdHJpYnV0ZWROb2RlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVc2Ugc2hhZG93IHJvb3QgaWYgcG9zc2libGUsIHdpbGwgY2hlY2sgZm9yIGRpc3RyaWJ1dGVkIG5vZGVzLlxuICAgICAgY2hpbGRyZW4gPSBkb20oZWxlbWVudC5yb290IHx8IGVsZW1lbnQpLmNoaWxkcmVuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBFbnN1cmUgbWV0aG9kIGlzIGFsd2F5cyBpbnZva2VkIHRvIGNvbGxlY3QgdGFiYmFibGUgY2hpbGRyZW4uXG4gICAgICBuZWVkc1NvcnQgPSB0aGlzLl9jb2xsZWN0VGFiYmFibGVOb2RlcyhjaGlsZHJlbltpXSwgcmVzdWx0KSB8fCBuZWVkc1NvcnQ7XG4gICAgfVxuICAgIHJldHVybiBuZWVkc1NvcnQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFsc2UgaWYgdGhlIGVsZW1lbnQgaGFzIGB2aXNpYmlsaXR5OiBoaWRkZW5gIG9yIGBkaXNwbGF5OiBub25lYFxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2lzVmlzaWJsZTogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgIC8vIENoZWNrIGlubGluZSBzdHlsZSBmaXJzdCB0byBzYXZlIGEgcmUtZmxvdy4gSWYgbG9va3MgZ29vZCwgY2hlY2sgYWxzb1xuICAgIC8vIGNvbXB1dGVkIHN0eWxlLlxuICAgIHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG4gICAgaWYgKHN0eWxlLnZpc2liaWxpdHkgIT09ICdoaWRkZW4nICYmIHN0eWxlLmRpc3BsYXkgIT09ICdub25lJykge1xuICAgICAgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICAgIHJldHVybiAoc3R5bGUudmlzaWJpbGl0eSAhPT0gJ2hpZGRlbicgJiYgc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTb3J0cyBhbiBhcnJheSBvZiB0YWJiYWJsZSBlbGVtZW50cyBieSB0YWJpbmRleC4gUmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICogQHBhcmFtIHshQXJyYXk8SFRNTEVsZW1lbnQ+fSB0YWJiYWJsZXNcbiAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NvcnRCeVRhYkluZGV4OiBmdW5jdGlvbih0YWJiYWJsZXMpIHtcbiAgICAvLyBJbXBsZW1lbnQgYSBtZXJnZSBzb3J0IGFzIEFycmF5LnByb3RvdHlwZS5zb3J0IGRvZXMgYSBub24tc3RhYmxlIHNvcnRcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9zb3J0XG4gICAgdmFyIGxlbiA9IHRhYmJhYmxlcy5sZW5ndGg7XG4gICAgaWYgKGxlbiA8IDIpIHtcbiAgICAgIHJldHVybiB0YWJiYWJsZXM7XG4gICAgfVxuICAgIHZhciBwaXZvdCA9IE1hdGguY2VpbChsZW4gLyAyKTtcbiAgICB2YXIgbGVmdCA9IHRoaXMuX3NvcnRCeVRhYkluZGV4KHRhYmJhYmxlcy5zbGljZSgwLCBwaXZvdCkpO1xuICAgIHZhciByaWdodCA9IHRoaXMuX3NvcnRCeVRhYkluZGV4KHRhYmJhYmxlcy5zbGljZShwaXZvdCkpO1xuICAgIHJldHVybiB0aGlzLl9tZXJnZVNvcnRCeVRhYkluZGV4KGxlZnQsIHJpZ2h0KTtcbiAgfSxcblxuICAvKipcbiAgICogTWVyZ2Ugc29ydCBpdGVyYXRvciwgbWVyZ2VzIHRoZSB0d28gYXJyYXlzIGludG8gb25lLCBzb3J0ZWQgYnkgdGFiIGluZGV4LlxuICAgKiBAcGFyYW0geyFBcnJheTxIVE1MRWxlbWVudD59IGxlZnRcbiAgICogQHBhcmFtIHshQXJyYXk8SFRNTEVsZW1lbnQ+fSByaWdodFxuICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbWVyZ2VTb3J0QnlUYWJJbmRleDogZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKChsZWZ0Lmxlbmd0aCA+IDApICYmIChyaWdodC5sZW5ndGggPiAwKSkge1xuICAgICAgaWYgKHRoaXMuX2hhc0xvd2VyVGFiT3JkZXIobGVmdFswXSwgcmlnaHRbMF0pKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHJpZ2h0LnNoaWZ0KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0LnB1c2gobGVmdC5zaGlmdCgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0LmNvbmNhdChsZWZ0LCByaWdodCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgZWxlbWVudCBgYWAgaGFzIGxvd2VyIHRhYiBvcmRlciBjb21wYXJlZCB0byBlbGVtZW50IGBiYFxuICAgKiAoYm90aCBlbGVtZW50cyBhcmUgYXNzdW1lZCB0byBiZSBmb2N1c2FibGUgYW5kIHRhYmJhYmxlKS5cbiAgICogRWxlbWVudHMgd2l0aCB0YWJpbmRleCA9IDAgaGF2ZSBsb3dlciB0YWIgb3JkZXIgY29tcGFyZWQgdG8gZWxlbWVudHNcbiAgICogd2l0aCB0YWJpbmRleCA+IDAuXG4gICAqIElmIGJvdGggaGF2ZSBzYW1lIHRhYmluZGV4LCBpdCByZXR1cm5zIGZhbHNlLlxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gYVxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gYlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2hhc0xvd2VyVGFiT3JkZXI6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAvLyBOb3JtYWxpemUgdGFiSW5kZXhlc1xuICAgIC8vIGUuZy4gaW4gRmlyZWZveCBgPGRpdiBjb250ZW50ZWRpdGFibGU+YCBoYXMgYHRhYkluZGV4ID0gLTFgXG4gICAgdmFyIGF0aSA9IE1hdGgubWF4KGEudGFiSW5kZXgsIDApO1xuICAgIHZhciBidGkgPSBNYXRoLm1heChiLnRhYkluZGV4LCAwKTtcbiAgICByZXR1cm4gKGF0aSA9PT0gMCB8fCBidGkgPT09IDApID8gYnRpID4gYXRpIDogYXRpID4gYnRpO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lyb24tZm9jdXNhYmxlcy1oZWxwZXIuanNcbi8vIG1vZHVsZSBpZCA9IDgwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0LmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvdHlwb2dyYXBoeS5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9zaGFkb3cuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxkb20tbW9kdWxlIGlkPVwicGFwZXItZGlhbG9nLXNoYXJlZC1zdHlsZXNcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogYmxvY2s7XG4gICAgICAgIG1hcmdpbjogMjRweCA0MHB4O1xuXG4gICAgICAgIGJhY2tncm91bmQ6IHZhcigtLXBhcGVyLWRpYWxvZy1iYWNrZ3JvdW5kLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWJhY2tncm91bmQtY29sb3IpKTtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWRpYWxvZy1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1ib2R5MTtcbiAgICAgICAgQGFwcGx5IC0tc2hhZG93LWVsZXZhdGlvbi0xNmRwO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1kaWFsb2c7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gOjpzbG90dGVkKCopIHtcbiAgICAgICAgbWFyZ2luLXRvcDogMjBweDtcbiAgICAgICAgcGFkZGluZzogMCAyNHB4O1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA+IDo6c2xvdHRlZCgubm8tcGFkZGluZykge1xuICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgfVxuXG4gICAgICAvKiBJbiAxLngsIHRoaXMgc2VsZWN0b3Igd2FzIFxcYDpob3N0ID4gOjpjb250ZW50IGgyXFxgLiBJbiAyLnggPHNsb3Q+IGFsbG93c1xuICAgICAgdG8gc2VsZWN0IGRpcmVjdCBjaGlsZHJlbiBvbmx5LCB3aGljaCBpbmNyZWFzZXMgdGhlIHdlaWdodCBvZiB0aGlzXG4gICAgICBzZWxlY3Rvciwgc28gd2UgaGF2ZSB0byBtb3ZlIGl0IGJlZm9yZSBmaXJzdC1jaGlsZC9sYXN0LWNoaWxkIHNlbGVjdG9ycyAqL1xuICAgICAgOmhvc3QgPiA6OnNsb3R0ZWQoaDIpIHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW46IDA7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC10aXRsZTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZGlhbG9nLXRpdGxlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA+IDo6c2xvdHRlZCgqOmZpcnN0LWNoaWxkKSB7XG4gICAgICAgIG1hcmdpbi10b3A6IDI0cHg7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gOjpzbG90dGVkKCo6bGFzdC1jaGlsZCkge1xuICAgICAgICBtYXJnaW4tYm90dG9tOiAyNHB4O1xuICAgICAgfVxuXG4gICAgICA6aG9zdCA+IDo6c2xvdHRlZCguYnV0dG9ucykge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHBhZGRpbmc6IDhweCA4cHggOHB4IDI0cHg7XG4gICAgICAgIG1hcmdpbjogMDtcblxuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItZGlhbG9nLWJ1dHRvbi1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLWxheW91dC1ob3Jpem9udGFsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZW5kLWp1c3RpZmllZDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICA8L3RlbXBsYXRlPlxuPC9kb20tbW9kdWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1kaWFsb2ctYmVoYXZpb3IvcGFwZXItZGlhbG9nLXNoYXJlZC1zdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDgxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGBcbjxsaW5rIHJlbD1cInN0eWxlc2hlZXRcIiB0eXBlPVwidGV4dC9jc3NcIiBocmVmPVwiaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9jc3M/ZmFtaWx5PVJvYm90bytNb25vOjQwMCw3MDB8Um9ib3RvOjQwMCwzMDAsMzAwaXRhbGljLDQwMGl0YWxpYyw1MDAsNTAwaXRhbGljLDcwMCw3MDBpdGFsaWNcIiBjcm9zc29yaWdpbj1cImFub255bW91c1wiPlxuYDtcbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9mb250LXJvYm90by9yb2JvdG8uanNcbi8vIG1vZHVsZSBpZCA9IDgyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0LmpzJztcbmltcG9ydCB7IFBhcGVyQnV0dG9uQmVoYXZpb3IsIFBhcGVyQnV0dG9uQmVoYXZpb3JJbXBsIH0gZnJvbSAnLi4vcGFwZXItYmVoYXZpb3JzL3BhcGVyLWJ1dHRvbi1iZWhhdmlvci5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9lbGVtZW50LXN0eWxlcy9wYXBlci1tYXRlcmlhbC1zdHlsZXMuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8ZG9tLW1vZHVsZSBpZD1cInBhcGVyLWJ1dHRvblwiPlxuICA8dGVtcGxhdGUgc3RyaXAtd2hpdGVzcGFjZT1cIlwiPlxuICAgIDxzdHlsZSBpbmNsdWRlPVwicGFwZXItbWF0ZXJpYWwtc3R5bGVzXCI+XG4gICAgICAvKiBOZWVkIHRvIHNwZWNpZnkgdGhlIHNhbWUgc3BlY2lmaWNpdHkgYXMgdGhlIHN0eWxlcyBpbXBvcnRlZCBmcm9tIHBhcGVyLW1hdGVyaWFsLiAqL1xuICAgICAgOmhvc3Qge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtaW5saW5lO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyLWNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBtaW4td2lkdGg6IDUuMTRlbTtcbiAgICAgICAgbWFyZ2luOiAwIDAuMjllbTtcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogcmdiYSgwLCAwLCAwLCAwKTtcbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgZm9udDogaW5oZXJpdDtcbiAgICAgICAgdGV4dC10cmFuc2Zvcm06IHVwcGVyY2FzZTtcbiAgICAgICAgb3V0bGluZS13aWR0aDogMDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogM3B4O1xuICAgICAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIHVzZXItc2VsZWN0OiBub25lO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIHotaW5kZXg6IDA7XG4gICAgICAgIHBhZGRpbmc6IDAuN2VtIDAuNTdlbTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1idXR0b247XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtlbGV2YXRpb249XCIxXCJdKSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi0xO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZWxldmF0aW9uPVwiMlwiXSkge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tMjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2VsZXZhdGlvbj1cIjNcIl0pIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTM7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtlbGV2YXRpb249XCI0XCJdKSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi00O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZWxldmF0aW9uPVwiNVwiXSkge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tNTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbcmFpc2VkXS5rZXlib2FyZC1mb2N1cykge1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItYnV0dG9uLXJhaXNlZC1rZXlib2FyZC1mb2N1cztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoOm5vdChbcmFpc2VkXSkua2V5Ym9hcmQtZm9jdXMpIHtcbiAgICAgICAgZm9udC13ZWlnaHQ6IGJvbGQ7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWJ1dHRvbi1mbGF0LWtleWJvYXJkLWZvY3VzO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSB7XG4gICAgICAgIGJhY2tncm91bmQ6ICNlYWVhZWE7XG4gICAgICAgIGNvbG9yOiAjYThhOGE4O1xuICAgICAgICBjdXJzb3I6IGF1dG87XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWJ1dHRvbi1kaXNhYmxlZDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2FuaW1hdGVkXSkge1xuICAgICAgICBAYXBwbHkgLS1zaGFkb3ctdHJhbnNpdGlvbjtcbiAgICAgIH1cblxuICAgICAgcGFwZXItcmlwcGxlIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWJ1dHRvbi1pbmstY29sb3IpO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvdGVtcGxhdGU+XG5cbiAgXG48L2RvbS1tb2R1bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblBvbHltZXIoe1xuICBpczogJ3BhcGVyLWJ1dHRvbicsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgUGFwZXJCdXR0b25CZWhhdmlvclxuICBdLFxuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIHNob3VsZCBiZSBzdHlsZWQgd2l0aCBhIHNoYWRvdy5cbiAgICAgKi9cbiAgICByYWlzZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBvYnNlcnZlcjogJ19jYWxjdWxhdGVFbGV2YXRpb24nXG4gICAgfVxuICB9LFxuXG4gIF9jYWxjdWxhdGVFbGV2YXRpb246IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5yYWlzZWQpIHtcbiAgICAgIHRoaXMuX3NldEVsZXZhdGlvbigwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUGFwZXJCdXR0b25CZWhhdmlvckltcGwuX2NhbGN1bGF0ZUVsZXZhdGlvbi5hcHBseSh0aGlzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzLlxuICBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byB3YWl0IHVudGlsXG4gIHRoZSByaXBwbGUgYW5pbWF0aW9uIGZpbmlzaGVzIHRvIHBlcmZvcm0gc29tZSBhY3Rpb24uXG5cbiAgQGV2ZW50IHRyYW5zaXRpb25lbmRcbiAgRXZlbnQgcGFyYW06IHt7bm9kZTogT2JqZWN0fX0gZGV0YWlsIENvbnRhaW5zIHRoZSBhbmltYXRlZCBub2RlLlxuICAqL1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1idXR0b24vcGFwZXItYnV0dG9uLmpzXG4vLyBtb2R1bGUgaWQgPSA4M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQnV0dG9uU3RhdGVJbXBsLCBJcm9uQnV0dG9uU3RhdGUgfSBmcm9tICcuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5qcyc7XG5pbXBvcnQgeyBQYXBlclJpcHBsZUJlaGF2aW9yIH0gZnJvbSAnLi9wYXBlci1yaXBwbGUtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgSXJvbkNvbnRyb2xTdGF0ZSB9IGZyb20gJy4uL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5qcyc7XG5cbmV4cG9ydCBjb25zdCBQYXBlckJ1dHRvbkJlaGF2aW9ySW1wbCA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFRoZSB6LWRlcHRoIG9mIHRoaXMgZWxlbWVudCwgZnJvbSAwLTUuIFNldHRpbmcgdG8gMCB3aWxsIHJlbW92ZSB0aGVcbiAgICAgKiBzaGFkb3csIGFuZCBlYWNoIGluY3JlYXNpbmcgbnVtYmVyIGdyZWF0ZXIgdGhhbiAwIHdpbGwgYmUgXCJkZWVwZXJcIlxuICAgICAqIHRoYW4gdGhlIGxhc3QuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIGVsZXZhdGlvblxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDFcbiAgICAgKi9cbiAgICBlbGV2YXRpb246IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIHJlYWRPbmx5OiB0cnVlXG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfY2FsY3VsYXRlRWxldmF0aW9uKGZvY3VzZWQsIGRpc2FibGVkLCBhY3RpdmUsIHByZXNzZWQsIHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpJyxcbiAgICAnX2NvbXB1dGVLZXlib2FyZENsYXNzKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpJ1xuICBdLFxuXG4gIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgcm9sZTogJ2J1dHRvbicsXG4gICAgdGFiaW5kZXg6ICcwJyxcbiAgICBhbmltYXRlZDogdHJ1ZVxuICB9LFxuXG4gIF9jYWxjdWxhdGVFbGV2YXRpb246IGZ1bmN0aW9uKCkge1xuICAgIHZhciBlID0gMTtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgZSA9IDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFjdGl2ZSB8fCB0aGlzLnByZXNzZWQpIHtcbiAgICAgIGUgPSA0O1xuICAgIH0gZWxzZSBpZiAodGhpcy5yZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSB7XG4gICAgICBlID0gMztcbiAgICB9XG4gICAgdGhpcy5fc2V0RWxldmF0aW9uKGUpO1xuICB9LFxuXG4gIF9jb21wdXRlS2V5Ym9hcmRDbGFzczogZnVuY3Rpb24ocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCkge1xuICAgIHRoaXMudG9nZ2xlQ2xhc3MoJ2tleWJvYXJkLWZvY3VzJywgcmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluIGFkZGl0aW9uIHRvIGBJcm9uQnV0dG9uU3RhdGVgIGJlaGF2aW9yLCB3aGVuIHNwYWNlIGtleSBnb2VzIGRvd24sXG4gICAqIGNyZWF0ZSBhIHJpcHBsZSBkb3duIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHshS2V5Ym9hcmRFdmVudH0gZXZlbnQgLlxuICAgKi9cbiAgX3NwYWNlS2V5RG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgSXJvbkJ1dHRvblN0YXRlSW1wbC5fc3BhY2VLZXlEb3duSGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBhdCBtb3N0IG9uZSByaXBwbGUgd2hlbiB0aGUgc3BhY2Uga2V5IGlzIGhlbGQgZG93bi5cbiAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSAmJiB0aGlzLmdldFJpcHBsZSgpLnJpcHBsZXMubGVuZ3RoIDwgMSkge1xuICAgICAgdGhpcy5fcmlwcGxlLnVpRG93bkFjdGlvbigpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW4gYWRkaXRpb24gdG8gYElyb25CdXR0b25TdGF0ZWAgYmVoYXZpb3IsIHdoZW4gc3BhY2Uga2V5IGdvZXMgdXAsXG4gICAqIGNyZWF0ZSBhIHJpcHBsZSB1cCBlZmZlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGV2ZW50IC5cbiAgICovXG4gIF9zcGFjZUtleVVwSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBJcm9uQnV0dG9uU3RhdGVJbXBsLl9zcGFjZUtleVVwSGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgdGhpcy5fcmlwcGxlLnVpVXBBY3Rpb24oKTtcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBQYXBlckJ1dHRvbkJlaGF2aW9yID0gW1xuICBJcm9uQnV0dG9uU3RhdGUsXG4gIElyb25Db250cm9sU3RhdGUsXG4gIFBhcGVyUmlwcGxlQmVoYXZpb3IsXG4gIFBhcGVyQnV0dG9uQmVoYXZpb3JJbXBsXG5dO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWJ1dHRvbi1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gODRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi8uLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9zaGFkb3cuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxkb20tbW9kdWxlIGlkPVwicGFwZXItbWF0ZXJpYWwtc3R5bGVzXCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCwgaHRtbCB7XG4gICAgICAgIC0tcGFwZXItbWF0ZXJpYWw6IHtcbiAgICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIH07XG4gICAgICAgIC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTE6IHtcbiAgICAgICAgICBAYXBwbHkgLS1zaGFkb3ctZWxldmF0aW9uLTJkcDtcbiAgICAgICAgfTtcbiAgICAgICAgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tMjoge1xuICAgICAgICAgIEBhcHBseSAtLXNoYWRvdy1lbGV2YXRpb24tNGRwO1xuICAgICAgICB9O1xuICAgICAgICAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi0zOiB7XG4gICAgICAgICAgQGFwcGx5IC0tc2hhZG93LWVsZXZhdGlvbi02ZHA7XG4gICAgICAgIH07XG4gICAgICAgIC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTQ6IHtcbiAgICAgICAgICBAYXBwbHkgLS1zaGFkb3ctZWxldmF0aW9uLThkcDtcbiAgICAgICAgfTtcbiAgICAgICAgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tNToge1xuICAgICAgICAgIEBhcHBseSAtLXNoYWRvdy1lbGV2YXRpb24tMTZkcDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIDpob3N0KC5wYXBlci1tYXRlcmlhbCksIC5wYXBlci1tYXRlcmlhbCB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsO1xuICAgICAgfVxuICAgICAgOmhvc3QoLnBhcGVyLW1hdGVyaWFsW2VsZXZhdGlvbj1cIjFcIl0pLCAucGFwZXItbWF0ZXJpYWxbZWxldmF0aW9uPVwiMVwiXSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi0xO1xuICAgICAgfVxuICAgICAgOmhvc3QoLnBhcGVyLW1hdGVyaWFsW2VsZXZhdGlvbj1cIjJcIl0pLCAucGFwZXItbWF0ZXJpYWxbZWxldmF0aW9uPVwiMlwiXSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi0yO1xuICAgICAgfVxuICAgICAgOmhvc3QoLnBhcGVyLW1hdGVyaWFsW2VsZXZhdGlvbj1cIjNcIl0pLCAucGFwZXItbWF0ZXJpYWxbZWxldmF0aW9uPVwiM1wiXSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi0zO1xuICAgICAgfVxuICAgICAgOmhvc3QoLnBhcGVyLW1hdGVyaWFsW2VsZXZhdGlvbj1cIjRcIl0pLCAucGFwZXItbWF0ZXJpYWxbZWxldmF0aW9uPVwiNFwiXSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi00O1xuICAgICAgfVxuICAgICAgOmhvc3QoLnBhcGVyLW1hdGVyaWFsW2VsZXZhdGlvbj1cIjVcIl0pLCAucGFwZXItbWF0ZXJpYWxbZWxldmF0aW9uPVwiNVwiXSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi01O1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG4gIDwvdGVtcGxhdGU+XG48L2RvbS1tb2R1bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9lbGVtZW50LXN0eWxlcy9wYXBlci1tYXRlcmlhbC1zdHlsZXMuanNcbi8vIG1vZHVsZSBpZCA9IDg1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25Gb3JtRWxlbWVudEJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuaW1wb3J0ICcuLi9pcm9uLWlucHV0L2lyb24taW5wdXQuanMnO1xuaW1wb3J0IHsgUGFwZXJJbnB1dEJlaGF2aW9yIH0gZnJvbSAnLi9wYXBlci1pbnB1dC1iZWhhdmlvci5qcyc7XG5pbXBvcnQgJy4vcGFwZXItaW5wdXQtY2hhci1jb3VudGVyLmpzJztcbmltcG9ydCAnLi9wYXBlci1pbnB1dC1jb250YWluZXIuanMnO1xuaW1wb3J0ICcuL3BhcGVyLWlucHV0LWVycm9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQgeyBEb21Nb2R1bGUgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tbW9kdWxlLmpzJztcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci1pbnB1dFwiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2ZvY3VzZWRdKSB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgaW5wdXQge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7IC8qIHRvIG1ha2UgYSBzdGFja2luZyBjb250ZXh0ICovXG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQtY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gICAgICAgIHRleHQtYWxpZ246IGluaGVyaXQ7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiBib3R0b207XG5cbiAgICAgICAgLyogRmlyZWZveCBzZXRzIGEgbWluLXdpZHRoIG9uIHRoZSBpbnB1dCwgd2hpY2ggY2FuIGNhdXNlIGxheW91dCBpc3N1ZXMgKi9cbiAgICAgICAgbWluLXdpZHRoOiAwO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtc3ViaGVhZDtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWlucHV0O1xuICAgICAgfVxuXG4gICAgICBpbnB1dDo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcbiAgICAgIGlucHV0Ojotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWlucHV0LXdlYmtpdC1zcGlubmVyO1xuICAgICAgfVxuXG4gICAgICBpbnB1dDo6LXdlYmtpdC1jbGVhci1idXR0b24ge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQtd2Via2l0LWNsZWFyO1xuICAgICAgfVxuXG4gICAgICBpbnB1dDo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItY29sb3IsIHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIGlucHV0Oi1tb3otcGxhY2Vob2xkZXIge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWNvbG9yLCB2YXIoLS1zZWNvbmRhcnktdGV4dC1jb2xvcikpO1xuICAgICAgfVxuXG4gICAgICBpbnB1dDo6LW1vei1wbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItY29sb3IsIHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIGlucHV0OjotbXMtY2xlYXIge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItbXMtY2xlYXI7XG4gICAgICB9XG5cbiAgICAgIGlucHV0Oi1tcy1pbnB1dC1wbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItY29sb3IsIHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIGxhYmVsIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxwYXBlci1pbnB1dC1jb250YWluZXIgaWQ9XCJjb250YWluZXJcIiBuby1sYWJlbC1mbG9hdD1cIltbbm9MYWJlbEZsb2F0XV1cIiBhbHdheXMtZmxvYXQtbGFiZWw9XCJbW19jb21wdXRlQWx3YXlzRmxvYXRMYWJlbChhbHdheXNGbG9hdExhYmVsLHBsYWNlaG9sZGVyKV1dXCIgYXV0by12YWxpZGF0ZVxcJD1cIltbYXV0b1ZhbGlkYXRlXV1cIiBkaXNhYmxlZFxcJD1cIltbZGlzYWJsZWRdXVwiIGludmFsaWQ9XCJbW2ludmFsaWRdXVwiPlxuXG4gICAgICA8c2xvdCBuYW1lPVwicHJlZml4XCIgc2xvdD1cInByZWZpeFwiPjwvc2xvdD5cblxuICAgICAgPGxhYmVsIGhpZGRlblxcJD1cIltbIWxhYmVsXV1cIiBhcmlhLWhpZGRlbj1cInRydWVcIiBmb3I9XCJpbnB1dFwiIHNsb3Q9XCJsYWJlbFwiPltbbGFiZWxdXTwvbGFiZWw+XG5cbiAgICAgIDxzcGFuIGlkPVwidGVtcGxhdGUtcGxhY2Vob2xkZXJcIj48L3NwYW4+XG5cbiAgICAgIDxzbG90IG5hbWU9XCJzdWZmaXhcIiBzbG90PVwic3VmZml4XCI+PC9zbG90PlxuXG4gICAgICA8dGVtcGxhdGUgaXM9XCJkb20taWZcIiBpZj1cIltbZXJyb3JNZXNzYWdlXV1cIj5cbiAgICAgICAgPHBhcGVyLWlucHV0LWVycm9yIGFyaWEtbGl2ZT1cImFzc2VydGl2ZVwiIHNsb3Q9XCJhZGQtb25cIj5bW2Vycm9yTWVzc2FnZV1dPC9wYXBlci1pbnB1dC1lcnJvcj5cbiAgICAgIDwvdGVtcGxhdGU+XG5cbiAgICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1pZlwiIGlmPVwiW1tjaGFyQ291bnRlcl1dXCI+XG4gICAgICAgIDxwYXBlci1pbnB1dC1jaGFyLWNvdW50ZXIgc2xvdD1cImFkZC1vblwiPjwvcGFwZXItaW5wdXQtY2hhci1jb3VudGVyPlxuICAgICAgPC90ZW1wbGF0ZT5cblxuICAgIDwvcGFwZXItaW5wdXQtY29udGFpbmVyPlxuICA8L3RlbXBsYXRlPlxuXG4gIDwhLS0gVGhpcyBpcyBhIGZyZXNoIG5ldyBoZWxsIHRvIG1ha2UgdGhpcyBlbGVtZW50IGh5YnJpZC4gQmFzaWNhbGx5LCBpbiAyLjBcbiAgICB3ZSBsb3N0IGlzPSwgc28gdGhlIGV4YW1wbGUgc2FtZSB0ZW1wbGF0ZSBjYW4ndCBiZSB1c2VkIHdpdGggaXJvbi1pbnB1dCAxLjAgYW5kIDIuMC5cbiAgICBFeHBlY3Qgc29tZSBjb25kaXRpb25hbCBjb2RlIChlc3BlY2lhbGx5IGluIHRoZSB0ZXN0cykuXG4gICAtLT5cbiAgPHRlbXBsYXRlIGlkPVwidjBcIj5cbiAgICA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCIgaWQ9XCJpbnB1dFwiIHNsb3Q9XCJpbnB1dFwiIGFyaWEtbGFiZWxsZWRieVxcJD1cIltbX2FyaWFMYWJlbGxlZEJ5XV1cIiBhcmlhLWRlc2NyaWJlZGJ5XFwkPVwiW1tfYXJpYURlc2NyaWJlZEJ5XV1cIiBkaXNhYmxlZFxcJD1cIltbZGlzYWJsZWRdXVwiIHRpdGxlXFwkPVwiW1t0aXRsZV1dXCIgYmluZC12YWx1ZT1cInt7dmFsdWV9fVwiIGludmFsaWQ9XCJ7e2ludmFsaWR9fVwiIHByZXZlbnQtaW52YWxpZC1pbnB1dD1cIltbcHJldmVudEludmFsaWRJbnB1dF1dXCIgYWxsb3dlZC1wYXR0ZXJuPVwiW1thbGxvd2VkUGF0dGVybl1dXCIgdmFsaWRhdG9yPVwiW1t2YWxpZGF0b3JdXVwiIHR5cGVcXCQ9XCJbW3R5cGVdXVwiIHBhdHRlcm5cXCQ9XCJbW3BhdHRlcm5dXVwiIHJlcXVpcmVkXFwkPVwiW1tyZXF1aXJlZF1dXCIgYXV0b2NvbXBsZXRlXFwkPVwiW1thdXRvY29tcGxldGVdXVwiIGF1dG9mb2N1c1xcJD1cIltbYXV0b2ZvY3VzXV1cIiBpbnB1dG1vZGVcXCQ9XCJbW2lucHV0bW9kZV1dXCIgbWlubGVuZ3RoXFwkPVwiW1ttaW5sZW5ndGhdXVwiIG1heGxlbmd0aFxcJD1cIltbbWF4bGVuZ3RoXV1cIiBtaW5cXCQ9XCJbW21pbl1dXCIgbWF4XFwkPVwiW1ttYXhdXVwiIHN0ZXBcXCQ9XCJbW3N0ZXBdXVwiIG5hbWVcXCQ9XCJbW25hbWVdXVwiIHBsYWNlaG9sZGVyXFwkPVwiW1twbGFjZWhvbGRlcl1dXCIgcmVhZG9ubHlcXCQ9XCJbW3JlYWRvbmx5XV1cIiBsaXN0XFwkPVwiW1tsaXN0XV1cIiBzaXplXFwkPVwiW1tzaXplXV1cIiBhdXRvY2FwaXRhbGl6ZVxcJD1cIltbYXV0b2NhcGl0YWxpemVdXVwiIGF1dG9jb3JyZWN0XFwkPVwiW1thdXRvY29ycmVjdF1dXCIgb24tY2hhbmdlPVwiX29uQ2hhbmdlXCIgdGFiaW5kZXhcXCQ9XCJbW3RhYkluZGV4XV1cIiBhdXRvc2F2ZVxcJD1cIltbYXV0b3NhdmVdXVwiIHJlc3VsdHNcXCQ9XCJbW3Jlc3VsdHNdXVwiIGFjY2VwdFxcJD1cIltbYWNjZXB0XV1cIiBtdWx0aXBsZVxcJD1cIltbbXVsdGlwbGVdXVwiPlxuICA8L3RlbXBsYXRlPlxuXG4gIDx0ZW1wbGF0ZSBpZD1cInYxXCI+XG4gICAgPCEtLSBOZWVkIHRvIGJpbmQgbWF4bGVuZ3RoIHNvIHRoYXQgdGhlIHBhcGVyLWlucHV0LWNoYXItY291bnRlciB3b3JrcyBjb3JyZWN0bHkgLS0+XG4gICAgPGlyb24taW5wdXQgYmluZC12YWx1ZT1cInt7dmFsdWV9fVwiIGlkPVwiaW5wdXRcIiBzbG90PVwiaW5wdXRcIiBtYXhsZW5ndGhcXCQ9XCJbW21heGxlbmd0aF1dXCIgYWxsb3dlZC1wYXR0ZXJuPVwiW1thbGxvd2VkUGF0dGVybl1dXCIgaW52YWxpZD1cInt7aW52YWxpZH19XCIgdmFsaWRhdG9yPVwiW1t2YWxpZGF0b3JdXVwiPlxuICAgICAgPGlucHV0IGlkPVwibmF0aXZlSW5wdXRcIiBhcmlhLWxhYmVsbGVkYnlcXCQ9XCJbW19hcmlhTGFiZWxsZWRCeV1dXCIgYXJpYS1kZXNjcmliZWRieVxcJD1cIltbX2FyaWFEZXNjcmliZWRCeV1dXCIgZGlzYWJsZWRcXCQ9XCJbW2Rpc2FibGVkXV1cIiB0aXRsZVxcJD1cIltbdGl0bGVdXVwiIHR5cGVcXCQ9XCJbW3R5cGVdXVwiIHBhdHRlcm5cXCQ9XCJbW3BhdHRlcm5dXVwiIHJlcXVpcmVkXFwkPVwiW1tyZXF1aXJlZF1dXCIgYXV0b2NvbXBsZXRlXFwkPVwiW1thdXRvY29tcGxldGVdXVwiIGF1dG9mb2N1c1xcJD1cIltbYXV0b2ZvY3VzXV1cIiBpbnB1dG1vZGVcXCQ9XCJbW2lucHV0bW9kZV1dXCIgbWlubGVuZ3RoXFwkPVwiW1ttaW5sZW5ndGhdXVwiIG1heGxlbmd0aFxcJD1cIltbbWF4bGVuZ3RoXV1cIiBtaW5cXCQ9XCJbW21pbl1dXCIgbWF4XFwkPVwiW1ttYXhdXVwiIHN0ZXBcXCQ9XCJbW3N0ZXBdXVwiIG5hbWVcXCQ9XCJbW25hbWVdXVwiIHBsYWNlaG9sZGVyXFwkPVwiW1twbGFjZWhvbGRlcl1dXCIgcmVhZG9ubHlcXCQ9XCJbW3JlYWRvbmx5XV1cIiBsaXN0XFwkPVwiW1tsaXN0XV1cIiBzaXplXFwkPVwiW1tzaXplXV1cIiBhdXRvY2FwaXRhbGl6ZVxcJD1cIltbYXV0b2NhcGl0YWxpemVdXVwiIGF1dG9jb3JyZWN0XFwkPVwiW1thdXRvY29ycmVjdF1dXCIgb24tY2hhbmdlPVwiX29uQ2hhbmdlXCIgdGFiaW5kZXhcXCQ9XCJbW3RhYkluZGV4XV1cIiBhdXRvc2F2ZVxcJD1cIltbYXV0b3NhdmVdXVwiIHJlc3VsdHNcXCQ9XCJbW3Jlc3VsdHNdXVwiIGFjY2VwdFxcJD1cIltbYWNjZXB0XV1cIiBtdWx0aXBsZVxcJD1cIltbbXVsdGlwbGVdXVwiPlxuICAgIDwvaXJvbi1pbnB1dD5cbiAgPC90ZW1wbGF0ZT5cblxuPC9kb20tbW9kdWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5Qb2x5bWVyKHtcbiAgaXM6ICdwYXBlci1pbnB1dCcsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgUGFwZXJJbnB1dEJlaGF2aW9yLFxuICAgIElyb25Gb3JtRWxlbWVudEJlaGF2aW9yXG4gIF0sXG5cbiAgYmVmb3JlUmVnaXN0ZXI6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFdlIG5lZWQgdG8gdGVsbCB3aGljaCBraW5kIG9mIG9mIHRlbXBsYXRlIHRvIHN0YW1wIGJhc2VkIG9uXG4gICAgLy8gd2hhdCBraW5kIG9mIGBpcm9uLWlucHV0YCB3ZSBnb3QsIGJ1dCBiZWNhdXNlIG9mIHBvbHlmaWxscyBhbmRcbiAgICAvLyBjdXN0b20gZWxlbWVudHMgZGlmZmVyZW5jZXMgYmV0d2VlbiB2MCBhbmQgdjEsIHRoZSBzYWZlc3QgYmV0IGlzXG4gICAgLy8gdG8gY2hlY2sgYSBwYXJ0aWN1bGFyIG1ldGhvZCB3ZSBrbm93IHRoZSBpcm9uLWlucHV0IzIueCBjYW4gaGF2ZS5cbiAgICAvLyBJZiBpdCBkb2Vzbid0IGhhdmUgaXQsIHRoZW4gaXQncyBhbiBpcm9uLWlucHV0IzEueC5cbiAgICB2YXIgaXJvbklucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaXJvbi1pbnB1dCcpO1xuICAgIHZhciB2ZXJzaW9uID0gdHlwZW9mIGlyb25JbnB1dC5faW5pdFNsb3R0ZWRJbnB1dCA9PSAnZnVuY3Rpb24nID8gJ3YxJyA6ICd2MCc7XG4gICAgdmFyIHRlbXBsYXRlID0gRG9tTW9kdWxlLmltcG9ydCgncGFwZXItaW5wdXQnLCAndGVtcGxhdGUnKTtcbiAgICB2YXIgaW5wdXRUZW1wbGF0ZSA9IERvbU1vZHVsZS5pbXBvcnQoJ3BhcGVyLWlucHV0JywgJ3RlbXBsYXRlIycgKyB2ZXJzaW9uKTtcbiAgICB2YXIgaW5wdXRQbGFjZWhvbGRlciA9IHRlbXBsYXRlLmNvbnRlbnQucXVlcnlTZWxlY3RvcignI3RlbXBsYXRlLXBsYWNlaG9sZGVyJyk7XG4gICAgaWYgKGlucHV0UGxhY2Vob2xkZXIpIHtcbiAgICAgIGlucHV0UGxhY2Vob2xkZXIucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoaW5wdXRUZW1wbGF0ZS5jb250ZW50LCBpbnB1dFBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgLy8gZWxzZSBpdCdzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQsIHByb2JhYmx5IGluIHN1cGVyY2xhc3NcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgZm9jdXNhYmxlIGVsZW1lbnQuIE92ZXJyaWRkZW4gZnJvbSBQYXBlcklucHV0QmVoYXZpb3JcbiAgICogdG8gY29ycmVjdGx5IGZvY3VzIHRoZSBuYXRpdmUgaW5wdXQuXG4gICAqL1xuICBnZXQgX2ZvY3VzYWJsZUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQgPyB0aGlzLmlucHV0RWxlbWVudC5faW5wdXRFbGVtZW50IDogdGhpcy5pbnB1dEVsZW1lbnQ7XG4gIH0sXG5cbiAgLy8gTm90ZTogVGhpcyBldmVudCBpcyBvbmx5IGF2YWlsYWJsZSBpbiB0aGUgMS4wIHZlcnNpb24gb2YgdGhpcyBlbGVtZW50LlxuICAvLyBJbiAyLjAsIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGBfb25Jcm9uSW5wdXRSZWFkeWAgaXMgZG9uZSBpblxuICAvLyBQYXBlcklucHV0QmVoYXZpb3I6OmF0dGFjaGVkLlxuICBsaXN0ZW5lcnM6IHtcbiAgICAnaXJvbi1pbnB1dC1yZWFkeSc6ICdfb25Jcm9uSW5wdXRSZWFkeSdcbiAgfSxcblxuICBfb25Jcm9uSW5wdXRSZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaW5wdXRFbGVtZW50ICYmXG4gICAgICAgIHRoaXMuX3R5cGVzVGhhdEhhdmVUZXh0LmluZGV4T2YodGhpcy4kLm5hdGl2ZUlucHV0LnR5cGUpICE9PSAtMSkge1xuICAgICAgdGhpcy5hbHdheXNGbG9hdExhYmVsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IHZhbGlkYXRlIHdoZW4gYXR0YWNoZWQgaWYgdGhlIGlucHV0IGFscmVhZHkgaGFzIGEgdmFsdWUuXG4gICAgaWYgKCEhdGhpcy5pbnB1dEVsZW1lbnQuYmluZFZhbHVlKSB7XG4gICAgICB0aGlzLiQuY29udGFpbmVyLl9oYW5kbGVWYWx1ZUFuZEF1dG9WYWxpZGF0ZSh0aGlzLmlucHV0RWxlbWVudCk7XG4gICAgfVxuICB9LFxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkExMXlBbm5vdW5jZXIgfSBmcm9tICcuLi9pcm9uLWExMXktYW5ub3VuY2VyL2lyb24tYTExeS1hbm5vdW5jZXIuanMnO1xuaW1wb3J0IHsgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgICA8c2xvdCBpZD1cImNvbnRlbnRcIj48L3Nsb3Q+XG5gLFxuXG4gIGlzOiAnaXJvbi1pbnB1dCcsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JcbiAgXSxcblxuICAvKipcbiAgICogRmlyZWQgd2hlbmV2ZXIgYHZhbGlkYXRlKClgIGlzIGNhbGxlZC5cbiAgICpcbiAgICogQGV2ZW50IGlyb24taW5wdXQtdmFsaWRhdGVcbiAgICovXG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogVXNlIHRoaXMgcHJvcGVydHkgaW5zdGVhZCBvZiBgdmFsdWVgIGZvciB0d28td2F5IGRhdGEgYmluZGluZywgb3IgdG9cbiAgICAgKiBzZXQgYSBkZWZhdWx0IHZhbHVlIGZvciB0aGUgaW5wdXQuICoqRG8gbm90KiogdXNlIHRoZSBkaXN0cmlidXRlZFxuICAgICAqIGlucHV0J3MgYHZhbHVlYCBwcm9wZXJ0eSB0byBzZXQgYSBkZWZhdWx0IHZhbHVlLlxuICAgICAqL1xuICAgIGJpbmRWYWx1ZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVkIHByb3BlcnR5IHRoYXQgZWNob2VzIGBiaW5kVmFsdWVgIChtb3N0bHkgdXNlZCBmb3IgUG9seW1lciAxLjBcbiAgICAgKiBiYWNrY29tcGF0aWJpbGl0eSwgaWYgeW91IHdlcmUgb25lLXdheSBiaW5kaW5nIHRvIHRoZSBQb2x5bWVyIDEuMFxuICAgICAqIGBpbnB1dCBpcz1cImlyb24taW5wdXRcImAgdmFsdWUgYXR0cmlidXRlKS5cbiAgICAgKi9cbiAgICB2YWx1ZToge1xuICAgICAgY29tcHV0ZWQ6ICdfY29tcHV0ZVZhbHVlKGJpbmRWYWx1ZSknXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlZ2V4LWxpa2UgbGlzdCBvZiBjaGFyYWN0ZXJzIGFsbG93ZWQgYXMgaW5wdXQ7IGFsbCBjaGFyYWN0ZXJzIG5vdCBpbiB0aGUgbGlzdFxuICAgICAqIHdpbGwgYmUgcmVqZWN0ZWQuIFRoZSByZWNvbW1lbmRlZCBmb3JtYXQgc2hvdWxkIGJlIGEgbGlzdCBvZiBhbGxvd2VkIGNoYXJhY3RlcnMsXG4gICAgICogZm9yIGV4YW1wbGUsIGBbYS16QS1aMC05ListITs6XWAuXG4gICAgICpcbiAgICAgKiBUaGlzIHBhdHRlcm4gcmVwcmVzZW50cyB0aGUgYWxsb3dlZCBjaGFyYWN0ZXJzIGZvciB0aGUgZmllbGQ7IGFzIHRoZSB1c2VyIGlucHV0cyB0ZXh0LFxuICAgICAqIGVhY2ggaW5kaXZpZHVhbCBjaGFyYWN0ZXIgd2lsbCBiZSBjaGVja2VkIGFnYWluc3QgdGhlIHBhdHRlcm4gKHJhdGhlciB0aGFuIGNoZWNraW5nXG4gICAgICogdGhlIGVudGlyZSB2YWx1ZSBhcyBhIHdob2xlKS4gSWYgYSBjaGFyYWN0ZXIgaXMgbm90IGEgbWF0Y2gsIGl0IHdpbGwgYmUgcmVqZWN0ZWQuXG4gICAgICpcbiAgICAgKiBQYXN0ZWQgaW5wdXQgd2lsbCBoYXZlIGVhY2ggY2hhcmFjdGVyIGNoZWNrZWQgaW5kaXZpZHVhbGx5OyBpZiBhbnkgY2hhcmFjdGVyXG4gICAgICogZG9lc24ndCBtYXRjaCBgYWxsb3dlZFBhdHRlcm5gLCB0aGUgZW50aXJlIHBhc3RlZCBzdHJpbmcgd2lsbCBiZSByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIE5vdGU6IGlmIHlvdSB3ZXJlIHVzaW5nIGBpcm9uLWlucHV0YCBpbiAxLjAsIHlvdSB3ZXJlIGFsc28gcmVxdWlyZWQgdG9cbiAgICAgKiBzZXQgYHByZXZlbnQtaW52YWxpZC1pbnB1dGAuIFRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCBhcyBvZiBQb2x5bWVyIDIuMCxcbiAgICAgKiBhbmQgd2lsbCBiZSBzZXQgYXV0b21hdGljYWxseSBmb3IgeW91IGlmIGFuIGBhbGxvd2VkUGF0dGVybmAgaXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKi9cbiAgICBhbGxvd2VkUGF0dGVybjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGF1dG8tdmFsaWRhdGUgdGhlIGlucHV0IHZhbHVlIGFzIHlvdSB0eXBlLlxuICAgICAqL1xuICAgIGF1dG9WYWxpZGF0ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH1cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX2JpbmRWYWx1ZUNoYW5nZWQoYmluZFZhbHVlLCBfaW5wdXRFbGVtZW50KSdcbiAgXSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICAnaW5wdXQnOiAnX29uSW5wdXQnLFxuICAgICdrZXlwcmVzcyc6ICdfb25LZXlwcmVzcydcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICBJcm9uQTExeUFubm91bmNlci5yZXF1ZXN0QXZhaWxhYmlsaXR5KCk7XG4gICAgdGhpcy5fcHJldmlvdXNWYWxpZElucHV0ID0gJyc7XG4gICAgdGhpcy5fcGF0dGVybkFscmVhZHlDaGVja2VkID0gZmFsc2U7XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIHRoZSBpbnB1dCBpcyBhZGRlZCBhdCBhIGxhdGVyIHRpbWUsIHVwZGF0ZSB0aGUgaW50ZXJuYWwgcmVmZXJlbmNlLlxuICAgIHRoaXMuX29ic2VydmVyID0gZG9tKHRoaXMpLm9ic2VydmVOb2RlcyhmdW5jdGlvbihpbmZvKSB7XG4gICAgICB0aGlzLl9pbml0U2xvdHRlZElucHV0KCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX29ic2VydmVyKSB7XG4gICAgICBkb20odGhpcykudW5vYnNlcnZlTm9kZXModGhpcy5fb2JzZXJ2ZXIpO1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZGlzdHJpYnV0ZWQgPGlucHV0PiBlbGVtZW50LlxuICAgKi9cbiAgZ2V0IGlucHV0RWxlbWVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0RWxlbWVudDtcbiAgfSxcblxuICBfaW5pdFNsb3R0ZWRJbnB1dDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW5wdXRFbGVtZW50ID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZHJlbigpWzBdO1xuXG4gICAgaWYgKHRoaXMuaW5wdXRFbGVtZW50ICYmIHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlKSB7XG4gICAgICB0aGlzLmJpbmRWYWx1ZSA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlO1xuICAgIH1cblxuICAgIHRoaXMuZmlyZSgnaXJvbi1pbnB1dC1yZWFkeScpO1xuICB9LFxuXG4gIGdldCBfcGF0dGVyblJlZ0V4cCgpIHtcbiAgICB2YXIgcGF0dGVybjtcbiAgICBpZiAodGhpcy5hbGxvd2VkUGF0dGVybikge1xuICAgICAgcGF0dGVybiA9IG5ldyBSZWdFeHAodGhpcy5hbGxvd2VkUGF0dGVybik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgcGF0dGVybiA9IC9bMC05LixlLV0vO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfSxcblxuICAvKipcbiAgICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICAgKi9cbiAgX2JpbmRWYWx1ZUNoYW5nZWQ6IGZ1bmN0aW9uKGJpbmRWYWx1ZSwgaW5wdXRFbGVtZW50KSB7XG4gICAgLy8gVGhlIG9ic2VydmVyIGNvdWxkIGhhdmUgcnVuIGJlZm9yZSBhdHRhY2hlZCgpIHdoZW4gd2UgaGF2ZSBhY3R1YWxseSBpbml0aWFsaXplZFxuICAgIC8vIHRoaXMgcHJvcGVydHkuXG4gICAgaWYgKCFpbnB1dEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoYmluZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlucHV0RWxlbWVudC52YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChiaW5kVmFsdWUgIT09IGlucHV0RWxlbWVudC52YWx1ZSl7XG4gICAgICB0aGlzLmlucHV0RWxlbWVudC52YWx1ZSA9IGJpbmRWYWx1ZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5hdXRvVmFsaWRhdGUpIHtcbiAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgICB9XG5cbiAgICAvLyBtYW51YWxseSBub3RpZnkgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRvIG5vdGlmeSB1bnRpbCBhZnRlciBzZXR0aW5nIHZhbHVlXG4gICAgdGhpcy5maXJlKCdiaW5kLXZhbHVlLWNoYW5nZWQnLCB7dmFsdWU6IGJpbmRWYWx1ZX0pO1xuICB9LFxuXG4gIF9vbklucHV0OiBmdW5jdGlvbigpIHtcbiAgICAvLyBOZWVkIHRvIHZhbGlkYXRlIGVhY2ggb2YgdGhlIGNoYXJhY3RlcnMgcGFzdGVkIGlmIHRoZXkgaGF2ZW4ndFxuICAgIC8vIGJlZW4gdmFsaWRhdGVkIGluc2lkZSBgX29uS2V5cHJlc3NgIGFscmVhZHkuXG4gICAgaWYgKHRoaXMuYWxsb3dlZFBhdHRlcm4gJiYgIXRoaXMuX3BhdHRlcm5BbHJlYWR5Q2hlY2tlZCkge1xuICAgICAgdmFyIHZhbGlkID0gdGhpcy5fY2hlY2tQYXR0ZXJuVmFsaWRpdHkoKTtcbiAgICAgIGlmICghdmFsaWQpIHtcbiAgICAgICAgdGhpcy5fYW5ub3VuY2VJbnZhbGlkQ2hhcmFjdGVyKCdJbnZhbGlkIHN0cmluZyBvZiBjaGFyYWN0ZXJzIG5vdCBlbnRlcmVkLicpO1xuICAgICAgICB0aGlzLmlucHV0RWxlbWVudC52YWx1ZSA9IHRoaXMuX3ByZXZpb3VzVmFsaWRJbnB1dDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5iaW5kVmFsdWUgPSB0aGlzLl9wcmV2aW91c1ZhbGlkSW5wdXQgPSB0aGlzLmlucHV0RWxlbWVudC52YWx1ZTtcbiAgICB0aGlzLl9wYXR0ZXJuQWxyZWFkeUNoZWNrZWQgPSBmYWxzZTtcbiAgfSxcblxuICBfaXNQcmludGFibGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gV2hhdCBhIGNvbnRyb2wvcHJpbnRhYmxlIGNoYXJhY3RlciBpcyB2YXJpZXMgd2lsZGx5IGJhc2VkIG9uIHRoZSBicm93c2VyLlxuICAgIC8vIC0gbW9zdCBjb250cm9sIGNoYXJhY3RlcnMgKGFycm93cywgYmFja3NwYWNlKSBkbyBub3Qgc2VuZCBhIGBrZXlwcmVzc2AgZXZlbnRcbiAgICAvLyAgIGluIENocm9tZSwgYnV0IHRoZSAqZG8qIG9uIEZpcmVmb3hcbiAgICAvLyAtIGluIEZpcmVmb3gsIHdoZW4gdGhleSBkbyBzZW5kIGEgYGtleXByZXNzYCBldmVudCwgY29udHJvbCBjaGFycyBoYXZlXG4gICAgLy8gICBhIGNoYXJDb2RlID0gMCwga2V5Q29kZSA9IHh4IChmb3IgZXguIDQwIGZvciBkb3duIGFycm93KVxuICAgIC8vIC0gcHJpbnRhYmxlIGNoYXJhY3RlcnMgYWx3YXlzIHNlbmQgYSBrZXlwcmVzcyBldmVudC5cbiAgICAvLyAtIGluIEZpcmVmb3gsIHByaW50YWJsZSBjaGFycyBhbHdheXMgaGF2ZSBhIGtleUNvZGUgPSAwLiBJbiBDaHJvbWUsIHRoZSBrZXlDb2RlXG4gICAgLy8gICBhbHdheXMgbWF0Y2hlcyB0aGUgY2hhckNvZGUuXG4gICAgLy8gTm9uZSBvZiB0aGlzIG1ha2VzIGFueSBzZW5zZS5cblxuICAgIC8vIEZvciB0aGVzZSBrZXlzLCBBU0NJSSBjb2RlID09IGJyb3dzZXIga2V5Y29kZS5cbiAgICB2YXIgYW55Tm9uUHJpbnRhYmxlID1cbiAgICAgIChldmVudC5rZXlDb2RlID09IDgpICAgfHwgIC8vIGJhY2tzcGFjZVxuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gOSkgICB8fCAgLy8gdGFiXG4gICAgICAoZXZlbnQua2V5Q29kZSA9PSAxMykgIHx8ICAvLyBlbnRlclxuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMjcpOyAgICAgLy8gZXNjYXBlXG5cbiAgICAvLyBGb3IgdGhlc2Uga2V5cywgbWFrZSBzdXJlIGl0J3MgYSBicm93c2VyIGtleWNvZGUgYW5kIG5vdCBhbiBBU0NJSSBjb2RlLlxuICAgIHZhciBtb3pOb25QcmludGFibGUgPVxuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMTkpICB8fCAgLy8gcGF1c2VcbiAgICAgIChldmVudC5rZXlDb2RlID09IDIwKSAgfHwgIC8vIGNhcHMgbG9ja1xuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gNDUpICB8fCAgLy8gaW5zZXJ0XG4gICAgICAoZXZlbnQua2V5Q29kZSA9PSA0NikgIHx8ICAvLyBkZWxldGVcbiAgICAgIChldmVudC5rZXlDb2RlID09IDE0NCkgfHwgIC8vIG51bSBsb2NrXG4gICAgICAoZXZlbnQua2V5Q29kZSA9PSAxNDUpIHx8ICAvLyBzY3JvbGwgbG9ja1xuICAgICAgKGV2ZW50LmtleUNvZGUgPiAzMiAmJiBldmVudC5rZXlDb2RlIDwgNDEpICAgfHwgLy8gcGFnZSB1cC9kb3duLCBlbmQsIGhvbWUsIGFycm93c1xuICAgICAgKGV2ZW50LmtleUNvZGUgPiAxMTEgJiYgZXZlbnQua2V5Q29kZSA8IDEyNCk7IC8vIGZuIGtleXNcblxuICAgIHJldHVybiAhYW55Tm9uUHJpbnRhYmxlICYmICEoZXZlbnQuY2hhckNvZGUgPT0gMCAmJiBtb3pOb25QcmludGFibGUpO1xuICB9LFxuXG4gIF9vbktleXByZXNzOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5hbGxvd2VkUGF0dGVybiAmJiB0aGlzLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciByZWdleHAgPSB0aGlzLl9wYXR0ZXJuUmVnRXhwO1xuICAgIGlmICghcmVnZXhwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHNwZWNpYWwga2V5cyBhbmQgYmFja3NwYWNlXG4gICAgaWYgKGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5hbHRLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgcGF0dGVybiBlaXRoZXIgaGVyZSBvciBpbiBgX29uSW5wdXRgLCBidXQgbm90IGluIGJvdGguXG4gICAgdGhpcy5fcGF0dGVybkFscmVhZHlDaGVja2VkID0gdHJ1ZTtcblxuICAgIHZhciB0aGlzQ2hhciA9IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQuY2hhckNvZGUpO1xuICAgIGlmICh0aGlzLl9pc1ByaW50YWJsZShldmVudCkgJiYgIXJlZ2V4cC50ZXN0KHRoaXNDaGFyKSkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIHRoaXMuX2Fubm91bmNlSW52YWxpZENoYXJhY3RlcignSW52YWxpZCBjaGFyYWN0ZXIgJyArIHRoaXNDaGFyICsgJyBub3QgZW50ZXJlZC4nKTtcbiAgICB9XG4gIH0sXG5cbiAgX2NoZWNrUGF0dGVyblZhbGlkaXR5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVnZXhwID0gdGhpcy5fcGF0dGVyblJlZ0V4cDtcbiAgICBpZiAoIXJlZ2V4cCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5pbnB1dEVsZW1lbnQudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcmVnZXhwLnRlc3QodGhpcy5pbnB1dEVsZW1lbnQudmFsdWVbaV0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLiBUaGUgdmFsaWRhdG9yIHByb3ZpZGVkIGluIGB2YWxpZGF0b3JgIHdpbGwgYmUgdXNlZCBmaXJzdCxcbiAgICogdGhlbiBhbnkgY29uc3RyYWludHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHZhbGlkLlxuICAgKi9cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5pbnB1dEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuaW52YWxpZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gVXNlIHRoZSBuZXN0ZWQgaW5wdXQncyBuYXRpdmUgdmFsaWRpdHkuXG4gICAgdmFyIHZhbGlkID0gIHRoaXMuaW5wdXRFbGVtZW50LmNoZWNrVmFsaWRpdHkoKTtcblxuICAgIC8vIE9ubHkgZG8gZXh0cmEgY2hlY2tpbmcgaWYgdGhlIGJyb3dzZXIgdGhvdWdodCB0aGlzIHdhcyB2YWxpZC5cbiAgICBpZiAodmFsaWQpIHtcbiAgICAgIC8vIEVtcHR5LCByZXF1aXJlZCBpbnB1dCBpcyBpbnZhbGlkXG4gICAgICBpZiAodGhpcy5yZXF1aXJlZCAmJiB0aGlzLmJpbmRWYWx1ZSA9PT0gJycpIHtcbiAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5oYXNWYWxpZGF0b3IoKSkge1xuICAgICAgICB2YWxpZCA9IElyb25WYWxpZGF0YWJsZUJlaGF2aW9yLnZhbGlkYXRlLmNhbGwodGhpcywgdGhpcy5iaW5kVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW52YWxpZCA9ICF2YWxpZDtcbiAgICB0aGlzLmZpcmUoJ2lyb24taW5wdXQtdmFsaWRhdGUnKTtcbiAgICByZXR1cm4gdmFsaWQ7XG4gIH0sXG5cbiAgX2Fubm91bmNlSW52YWxpZENoYXJhY3RlcjogZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHRoaXMuZmlyZSgnaXJvbi1hbm5vdW5jZScsIHsgdGV4dDogbWVzc2FnZSB9KTtcbiAgfSxcblxuICBfY29tcHV0ZVZhbHVlOiBmdW5jdGlvbihiaW5kVmFsdWUpIHtcbiAgICByZXR1cm4gYmluZFZhbHVlO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24taW5wdXQvaXJvbi1pbnB1dC5qc1xuLy8gbW9kdWxlIGlkID0gODdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgUG9seW1lciBhcyBQb2x5bWVyJDAgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uQTExeUFubm91bmNlciA9IFBvbHltZXIkMCh7XG4gIF90ZW1wbGF0ZTogYFxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIGNsaXA6IHJlY3QoMHB4LDBweCwwcHgsMHB4KTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICAgIDxkaXYgYXJpYS1saXZlXFwkPVwiW1ttb2RlXV1cIj5bW190ZXh0XV08L2Rpdj5cbmAsXG5cbiAgaXM6ICdpcm9uLWExMXktYW5ub3VuY2VyJyxcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgb2YgbW9kZSBpcyB1c2VkIHRvIHNldCB0aGUgYGFyaWEtbGl2ZWAgYXR0cmlidXRlXG4gICAgICogZm9yIHRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSBhbm5vdW5jZWQuIFZhbGlkIHZhbHVlcyBhcmU6IGBvZmZgLFxuICAgICAqIGBwb2xpdGVgIGFuZCBgYXNzZXJ0aXZlYC5cbiAgICAgKi9cbiAgICBtb2RlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ3BvbGl0ZSdcbiAgICB9LFxuXG4gICAgX3RleHQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnJ1xuICAgIH1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIUlyb25BMTF5QW5ub3VuY2VyLmluc3RhbmNlKSB7XG4gICAgICBJcm9uQTExeUFubm91bmNlci5pbnN0YW5jZSA9IHRoaXM7XG4gICAgfVxuXG4gICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdpcm9uLWFubm91bmNlJywgdGhpcy5fb25Jcm9uQW5ub3VuY2UuYmluZCh0aGlzKSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhdXNlIGEgdGV4dCBzdHJpbmcgdG8gYmUgYW5ub3VuY2VkIGJ5IHNjcmVlbiByZWFkZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCBUaGUgdGV4dCB0aGF0IHNob3VsZCBiZSBhbm5vdW5jZWQuXG4gICAqL1xuICBhbm5vdW5jZTogZnVuY3Rpb24odGV4dCkge1xuICAgIHRoaXMuX3RleHQgPSAnJztcbiAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fdGV4dCA9IHRleHQ7XG4gICAgfSwgMTAwKTtcbiAgfSxcblxuICBfb25Jcm9uQW5ub3VuY2U6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmRldGFpbCAmJiBldmVudC5kZXRhaWwudGV4dCkge1xuICAgICAgdGhpcy5hbm5vdW5jZShldmVudC5kZXRhaWwudGV4dCk7XG4gICAgfVxuICB9XG59KTtcblxuSXJvbkExMXlBbm5vdW5jZXIuaW5zdGFuY2UgPSBudWxsO1xuXG5Jcm9uQTExeUFubm91bmNlci5yZXF1ZXN0QXZhaWxhYmlsaXR5ID0gZnVuY3Rpb24oKSB7XG4gIGlmICghSXJvbkExMXlBbm5vdW5jZXIuaW5zdGFuY2UpIHtcbiAgICBJcm9uQTExeUFubm91bmNlci5pbnN0YW5jZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lyb24tYTExeS1hbm5vdW5jZXInKTtcbiAgfVxuXG4gIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoSXJvbkExMXlBbm5vdW5jZXIuaW5zdGFuY2UpO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYTExeS1hbm5vdW5jZXIvaXJvbi1hMTF5LWFubm91bmNlci5qc1xuLy8gbW9kdWxlIGlkID0gODhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgUG9seW1lciBhcyBQb2x5bWVyJDAgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3t0eXBlOiAoc3RyaW5nfG51bGwpLCBrZXk6IChzdHJpbmd8bnVsbCksIHZhbHVlOiAqfX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBJcm9uTWV0YShvcHRpb25zKSB7XG4gIHRoaXMudHlwZSA9IChvcHRpb25zICYmIG9wdGlvbnMudHlwZSkgfHwgJ2RlZmF1bHQnO1xuICB0aGlzLmtleSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5rZXk7XG4gIGlmICgndmFsdWUnIGluIG9wdGlvbnMpIHtcbiAgICB0aGlzLnZhbHVlID0gb3B0aW9ucy52YWx1ZTtcbiAgfVxufVxuXG5Jcm9uTWV0YS50eXBlcyA9IHt9O1xuXG5Jcm9uTWV0YS5wcm90b3R5cGUgPSB7XG4gIGdldCB2YWx1ZSgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICBpZiAodHlwZSAmJiBrZXkpIHtcbiAgICAgIHJldHVybiBJcm9uTWV0YS50eXBlc1t0eXBlXSAmJiBJcm9uTWV0YS50eXBlc1t0eXBlXVtrZXldO1xuICAgIH1cbiAgfSxcblxuICBzZXQgdmFsdWUodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcbiAgICB2YXIga2V5ID0gdGhpcy5rZXk7XG5cbiAgICBpZiAodHlwZSAmJiBrZXkpIHtcbiAgICAgIHR5cGUgPSBJcm9uTWV0YS50eXBlc1t0eXBlXSA9IElyb25NZXRhLnR5cGVzW3R5cGVdIHx8IHt9O1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIHR5cGVba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVba2V5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBnZXQgbGlzdCgpIHtcbiAgICB2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuICAgIGlmICh0eXBlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmtleXMoSXJvbk1ldGEudHlwZXNbdGhpcy50eXBlXSkubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gbWV0YURhdGFzW3RoaXMudHlwZV1ba2V5XTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICBieUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gIH1cbn07XG5cbmV4cG9ydCB7IElyb25NZXRhIH07XG5cbnZhciBtZXRhRGF0YXMgPSBJcm9uTWV0YS50eXBlcztcblxuUG9seW1lciQwKHtcblxuICBpczogJ2lyb24tbWV0YScsXG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgbWV0YS1kYXRhLiAgQWxsIG1ldGEtZGF0YSBvZiB0aGUgc2FtZSB0eXBlIGlzIHN0b3JlZFxuICAgICAqIHRvZ2V0aGVyLlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgdHlwZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdkZWZhdWx0JyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGtleSB1c2VkIHRvIHN0b3JlIGB2YWx1ZWAgdW5kZXIgdGhlIGB0eXBlYCBuYW1lc3BhY2UuXG4gICAgICogQHR5cGUgez9zdHJpbmd9XG4gICAgICovXG4gICAga2V5OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtZXRhLWRhdGEgdG8gc3RvcmUgb3IgcmV0cmlldmUuXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgYHZhbHVlYCBpcyBzZXQgdG8gdGhlIGlyb24tbWV0YSBpbnN0YW5jZSBpdHNlbGYuXG4gICAgICovXG4gICAgIHNlbGY6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBvYnNlcnZlcjogJ19zZWxmQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgX19tZXRhOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgY29tcHV0ZWQ6ICdfX2NvbXB1dGVNZXRhKHR5cGUsIGtleSwgdmFsdWUpJ1xuICAgIH1cbiAgfSxcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgIGhpZGRlbjogdHJ1ZVxuICB9LFxuXG4gIF9fY29tcHV0ZU1ldGE6IGZ1bmN0aW9uKHR5cGUsIGtleSwgdmFsdWUpIHtcbiAgICB2YXIgbWV0YSA9IG5ldyBJcm9uTWV0YSh7XG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAga2V5OiBrZXlcbiAgICB9KTtcblxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICBtZXRhLnZhbHVlID0gdmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLnZhbHVlICE9PSBtZXRhLnZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gbWV0YS52YWx1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfSxcblxuICBnZXQgbGlzdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fX21ldGEgJiYgdGhpcy5fX21ldGEubGlzdDtcbiAgfSxcblxuICBfc2VsZkNoYW5nZWQ6IGZ1bmN0aW9uKHNlbGYpIHtcbiAgICBpZiAoc2VsZikge1xuICAgICAgdGhpcy52YWx1ZSA9IHRoaXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgbWV0YSBkYXRhIHZhbHVlIGJ5IGtleS5cbiAgICpcbiAgICogQG1ldGhvZCBieUtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIG1ldGEtZGF0YSB0byBiZSByZXR1cm5lZC5cbiAgICogQHJldHVybiB7Kn1cbiAgICovXG4gIGJ5S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gbmV3IElyb25NZXRhKHtcbiAgICAgIHR5cGU6IHRoaXMudHlwZSxcbiAgICAgIGtleToga2V5XG4gICAgfSkudmFsdWU7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1tZXRhL2lyb24tbWV0YS5qc1xuLy8gbW9kdWxlIGlkID0gODlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkExMXlLZXlzQmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBJcm9uQ29udHJvbFN0YXRlIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmpzJztcbmltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi9wb2x5bWVyL3BvbHltZXItZWxlbWVudC5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuZXhwb3J0IGNvbnN0IFBhcGVySW5wdXRIZWxwZXIgPSB7fTtcblBhcGVySW5wdXRIZWxwZXIuTmV4dExhYmVsSUQgPSAxO1xuUGFwZXJJbnB1dEhlbHBlci5OZXh0QWRkb25JRCA9IDE7XG5cbmV4cG9ydCBjb25zdCBQYXBlcklucHV0QmVoYXZpb3JJbXBsID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBpbnB1dCBjaGFuZ2VzIGR1ZSB0byB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogVGhlIGxhYmVsIGZvciB0aGlzIGlucHV0LiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogYDxsYWJlbD5gJ3MgY29udGVudCBhbmQgYGhpZGRlbmAgcHJvcGVydHksIGUuZy5cbiAgICAgKiBgPGxhYmVsIGhpZGRlbiQ9XCJbWyFsYWJlbF1dXCI+W1tsYWJlbF1dPC9sYWJlbD5gIGluIHlvdXIgYHRlbXBsYXRlYFxuICAgICAqL1xuICAgIGxhYmVsOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHZhbHVlIGZvciB0aGlzIGlucHV0LiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogdGhlIGA8aXJvbi1pbnB1dD5gJ3MgYGJpbmRWYWx1ZWBcbiAgICAgKiBwcm9wZXJ0eSwgb3IgdGhlIHZhbHVlIHByb3BlcnR5IG9mIHlvdXIgaW5wdXQgdGhhdCBpcyBgbm90aWZ5OnRydWVgLlxuICAgICAqL1xuICAgIHZhbHVlOiB7XG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGlzIGlucHV0LiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogYm90aCB0aGUgYDxwYXBlci1pbnB1dC1jb250YWluZXI+YCdzIGFuZCB0aGUgaW5wdXQncyBgZGlzYWJsZWRgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGRpc2FibGVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdmFsdWUgaXMgaW52YWxpZC4gSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0b1xuICAgICAqIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlIGVsZW1lbnQsIGJpbmQgdGhpcyB0byBib3RoIHRoZVxuICAgICAqIGA8cGFwZXItaW5wdXQtY29udGFpbmVyPmAncyBhbmQgdGhlIGlucHV0J3MgYGludmFsaWRgIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogSWYgYGF1dG9WYWxpZGF0ZWAgaXMgdHJ1ZSwgdGhlIGBpbnZhbGlkYCBhdHRyaWJ1dGUgaXMgbWFuYWdlZCBhdXRvbWF0aWNhbGx5LFxuICAgICAqIHdoaWNoIGNhbiBjbG9iYmVyIGF0dGVtcHRzIHRvIG1hbmFnZSBpdCBtYW51YWxseS5cbiAgICAgKi9cbiAgICBpbnZhbGlkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGlzIHRvIHNwZWNpZnkgdGhlIHBhdHRlcm4gYWxsb3dlZCBieSBgcHJldmVudEludmFsaWRJbnB1dGAuIElmXG4gICAgICogeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYGFsbG93ZWRQYXR0ZXJuYFxuICAgICAqIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGFsbG93ZWRQYXR0ZXJuOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIHR5cGUgb2YgdGhlIGlucHV0LiBUaGUgc3VwcG9ydGVkIHR5cGVzIGFyZSBgdGV4dGAsIGBudW1iZXJgIGFuZCBgcGFzc3dvcmRgLlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCxcbiAgICAgKiBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGB0eXBlYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGRhdGFsaXN0IG9mIHRoZSBpbnB1dCAoaWYgYW55KS4gVGhpcyBzaG91bGQgbWF0Y2ggdGhlIGlkIG9mIGFuIGV4aXN0aW5nIGA8ZGF0YWxpc3Q+YC5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgbGlzdGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgbGlzdDoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgcGF0dGVybiB0byB2YWxpZGF0ZSB0aGUgYGlucHV0YCB3aXRoLiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBwYXR0ZXJuYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBwYXR0ZXJuOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gbWFyayB0aGUgaW5wdXQgYXMgcmVxdWlyZWQuIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG9cbiAgICAgKiBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LCBiaW5kIHRoaXMgdG9cbiAgICAgKiB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYHJlcXVpcmVkYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICByZXF1aXJlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZXJyb3IgbWVzc2FnZSB0byBkaXNwbGF5IHdoZW4gdGhlIGlucHV0IGlzIGludmFsaWQuIElmIHlvdSdyZSB1c2luZ1xuICAgICAqIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LFxuICAgICAqIGJpbmQgdGhpcyB0byB0aGUgYDxwYXBlci1pbnB1dC1lcnJvcj5gJ3MgY29udGVudCwgaWYgdXNpbmcuXG4gICAgICovXG4gICAgZXJyb3JNZXNzYWdlOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gc2hvdyBhIGNoYXJhY3RlciBjb3VudGVyLlxuICAgICAqL1xuICAgIGNoYXJDb3VudGVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdGhlIGZsb2F0aW5nIGxhYmVsLiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogdGhlIGA8cGFwZXItaW5wdXQtY29udGFpbmVyPmAncyBgbm9MYWJlbEZsb2F0YCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBub0xhYmVsRmxvYXQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gYWx3YXlzIGZsb2F0IHRoZSBsYWJlbC4gSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0b1xuICAgICAqIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlIGVsZW1lbnQsIGJpbmQgdGhpcyB0b1xuICAgICAqIHRoZSBgPHBhcGVyLWlucHV0LWNvbnRhaW5lcj5gJ3MgYGFsd2F5c0Zsb2F0TGFiZWxgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGFsd2F5c0Zsb2F0TGFiZWw6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gYXV0by12YWxpZGF0ZSB0aGUgaW5wdXQgdmFsdWUuIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG9cbiAgICAgKiBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LCBiaW5kIHRoaXMgdG9cbiAgICAgKiB0aGUgYDxwYXBlci1pbnB1dC1jb250YWluZXI+YCdzIGBhdXRvVmFsaWRhdGVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGF1dG9WYWxpZGF0ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSB2YWxpZGF0b3IgdG8gdXNlLiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGB2YWxpZGF0b3JgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHZhbGlkYXRvcjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8vIEhUTUxJbnB1dEVsZW1lbnQgYXR0cmlidXRlcyBmb3IgYmluZGluZyBpZiBuZWVkZWRcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBhdXRvY29tcGxldGVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGF1dG9jb21wbGV0ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdvZmYnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBhdXRvZm9jdXNgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGF1dG9mb2N1czoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIG9ic2VydmVyOiAnX2F1dG9mb2N1c0NoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBpbnB1dG1vZGVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGlucHV0bW9kZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIGxlbmd0aCBvZiB0aGUgaW5wdXQgdmFsdWUuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYG1pbmxlbmd0aGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgbWlubGVuZ3RoOiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgbWF4bGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBtYXhsZW5ndGg6IHtcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWluaW11bSAobnVtZXJpYyBvciBkYXRlLXRpbWUpIGlucHV0IHZhbHVlLlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBtaW5gIHByb3BlcnR5LlxuICAgICAqL1xuICAgIG1pbjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtYXhpbXVtIChudW1lcmljIG9yIGRhdGUtdGltZSkgaW5wdXQgdmFsdWUuXG4gICAgICogQ2FuIGJlIGEgU3RyaW5nIChlLmcuIGBcIjIwMDAtMDEtMDFcImApIG9yIGEgTnVtYmVyIChlLmcuIGAyYCkuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYG1heGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgbWF4OiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTGltaXRzIHRoZSBudW1lcmljIG9yIGRhdGUtdGltZSBpbmNyZW1lbnRzLlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBzdGVwYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBzdGVwOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYG5hbWVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBIHBsYWNlaG9sZGVyIHN0cmluZyBpbiBhZGRpdGlvbiB0byB0aGUgbGFiZWwuIElmIHRoaXMgaXMgc2V0LCB0aGUgbGFiZWwgd2lsbCBhbHdheXMgZmxvYXQuXG4gICAgICovXG4gICAgcGxhY2Vob2xkZXI6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIC8vIG5lZWQgdG8gc2V0IGEgZGVmYXVsdCBzbyBfY29tcHV0ZUFsd2F5c0Zsb2F0TGFiZWwgaXMgcnVuXG4gICAgICB2YWx1ZTogJydcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYHJlYWRvbmx5YCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICByZWFkb25seToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgc2l6ZWAgcHJvcGVydHkuXG4gICAgICovXG4gICAgc2l6ZToge1xuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcblxuICAgIC8vIE5vbnN0YW5kYXJkIGF0dHJpYnV0ZXMgZm9yIGJpbmRpbmcgaWYgbmVlZGVkXG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgYXV0b2NhcGl0YWxpemVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGF1dG9jYXBpdGFsaXplOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ25vbmUnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBhdXRvY29ycmVjdGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgYXV0b2NvcnJlY3Q6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnb2ZmJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgYXV0b3NhdmVgIHByb3BlcnR5LFxuICAgICAqIHVzZWQgd2l0aCB0eXBlPXNlYXJjaC5cbiAgICAgKi9cbiAgICBhdXRvc2F2ZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGByZXN1bHRzYCBwcm9wZXJ0eSxcbiAgICAgKiB1c2VkIHdpdGggdHlwZT1zZWFyY2guXG4gICAgICovXG4gICAgcmVzdWx0czoge1xuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBhY2NlcHRgIHByb3BlcnR5LFxuICAgICAqIHVzZWQgd2l0aCB0eXBlPWZpbGUuXG4gICAgICovXG4gICAgYWNjZXB0OiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGVgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgbXVsdGlwbGVgIHByb3BlcnR5LFxuICAgICAqIHVzZWQgd2l0aCB0eXBlPWZpbGUuXG4gICAgICovXG4gICAgbXVsdGlwbGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuXG4gICAgX2FyaWFEZXNjcmliZWRCeToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICcnXG4gICAgfSxcblxuICAgIF9hcmlhTGFiZWxsZWRCeToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICcnXG4gICAgfVxuXG4gIH0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgJ2FkZG9uLWF0dGFjaGVkJzogJ19vbkFkZG9uQXR0YWNoZWQnLFxuICB9LFxuXG4gIGtleUJpbmRpbmdzOiB7XG4gICAgJ3NoaWZ0K3RhYjprZXlkb3duJzogJ19vblNoaWZ0VGFiRG93bidcbiAgfSxcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgIHRhYmluZGV4OiAwXG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGlucHV0IGVsZW1lbnQuXG4gICAqL1xuICBnZXQgaW5wdXRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLiQuaW5wdXQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGZvY3VzYWJsZSBlbGVtZW50LlxuICAgKi9cbiAgZ2V0IF9mb2N1c2FibGVFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0RWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBUaGVzZSB0eXBlcyBoYXZlIHNvbWUgZGVmYXVsdCBwbGFjZWhvbGRlciB0ZXh0OyBvdmVybGFwcGluZ1xuICAgIC8vIHRoZSBsYWJlbCBvbiB0b3Agb2YgaXQgbG9va3MgdGVycmlibGUuIEF1dG8tZmxvYXQgdGhlIGxhYmVsIGluIHRoaXMgY2FzZS5cbiAgICB0aGlzLl90eXBlc1RoYXRIYXZlVGV4dCA9IFtcImRhdGVcIiwgXCJkYXRldGltZVwiLCBcImRhdGV0aW1lLWxvY2FsXCIsIFwibW9udGhcIixcbiAgICAgICAgXCJ0aW1lXCIsIFwid2Vla1wiLCBcImZpbGVcIl07XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VwZGF0ZUFyaWFMYWJlbGxlZEJ5KCk7XG5cbiAgICAvLyBJbiB0aGUgMi4wIHZlcnNpb24gb2YgdGhlIGVsZW1lbnQsIHRoaXMgaXMgaGFuZGxlZCBpbiBgb25Jcm9uSW5wdXRSZWFkeWAsXG4gICAgLy8gaS5lLiBhZnRlciB0aGUgbmF0aXZlIGlucHV0IGhhcyBmaW5pc2hlZCBkaXN0cmlidXRpbmcuIEluIHRoZSAxLjAgdmVyc2lvbixcbiAgICAvLyB0aGUgaW5wdXQgaXMgaW4gdGhlIHNoYWRvdyB0cmVlLCBzbyBpdCdzIGFscmVhZHkgYXZhaWxhYmxlLlxuICAgIGlmICghRWxlbWVudCAmJiB0aGlzLmlucHV0RWxlbWVudCAmJlxuICAgICAgICB0aGlzLl90eXBlc1RoYXRIYXZlVGV4dC5pbmRleE9mKHRoaXMuaW5wdXRFbGVtZW50LnR5cGUpICE9PSAtMSkge1xuICAgICAgdGhpcy5hbHdheXNGbG9hdExhYmVsID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG5cbiAgX2FwcGVuZFN0cmluZ1dpdGhTcGFjZTogZnVuY3Rpb24oc3RyLCBtb3JlKSB7XG4gICAgaWYgKHN0cikge1xuICAgICAgc3RyID0gc3RyICsgJyAnICsgbW9yZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gbW9yZTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbiAgfSxcblxuICBfb25BZGRvbkF0dGFjaGVkOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBkb20oZXZlbnQpLnJvb3RUYXJnZXQ7XG4gICAgaWYgKHRhcmdldC5pZCkge1xuICAgICAgdGhpcy5fYXJpYURlc2NyaWJlZEJ5ID0gdGhpcy5fYXBwZW5kU3RyaW5nV2l0aFNwYWNlKHRoaXMuX2FyaWFEZXNjcmliZWRCeSwgdGFyZ2V0LmlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGlkID0gJ3BhcGVyLWlucHV0LWFkZC1vbi0nICsgUGFwZXJJbnB1dEhlbHBlci5OZXh0QWRkb25JRCsrO1xuICAgICAgdGFyZ2V0LmlkID0gaWQ7XG4gICAgICB0aGlzLl9hcmlhRGVzY3JpYmVkQnkgPSB0aGlzLl9hcHBlbmRTdHJpbmdXaXRoU3BhY2UodGhpcy5fYXJpYURlc2NyaWJlZEJ5LCBpZCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIGlucHV0IGVsZW1lbnQgYW5kIHNldHMgYW4gZXJyb3Igc3R5bGUgaWYgbmVlZGVkLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgdmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlucHV0RWxlbWVudC52YWxpZGF0ZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3J3YXJkIGZvY3VzIHRvIGlucHV0RWxlbWVudC4gT3ZlcnJpZGVuIGZyb20gSXJvbkNvbnRyb2xTdGF0ZS5cbiAgICovXG4gIF9mb2N1c0JsdXJIYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIElyb25Db250cm9sU3RhdGUuX2ZvY3VzQmx1ckhhbmRsZXIuY2FsbCh0aGlzLCBldmVudCk7XG5cbiAgICAvLyBGb3J3YXJkIHRoZSBmb2N1cyB0byB0aGUgbmVzdGVkIGlucHV0LlxuICAgIGlmICh0aGlzLmZvY3VzZWQgJiYgIXRoaXMuX3NoaWZ0VGFiUHJlc3NlZCAmJiB0aGlzLl9mb2N1c2FibGVFbGVtZW50KSB7XG4gICAgICB0aGlzLl9mb2N1c2FibGVFbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVyIHRoYXQgaXMgY2FsbGVkIHdoZW4gYSBzaGlmdCt0YWIga2V5cHJlc3MgaXMgZGV0ZWN0ZWQgYnkgdGhlIG1lbnUuXG4gICAqXG4gICAqIEBwYXJhbSB7Q3VzdG9tRXZlbnR9IGV2ZW50IEEga2V5IGNvbWJpbmF0aW9uIGV2ZW50LlxuICAgKi9cbiAgX29uU2hpZnRUYWJEb3duOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBvbGRUYWJJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIHRoaXMuX3NoaWZ0VGFiUHJlc3NlZCA9IHRydWU7XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XG4gICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIG9sZFRhYkluZGV4KTtcbiAgICAgIHRoaXMuX3NoaWZ0VGFiUHJlc3NlZCA9IGZhbHNlO1xuICAgIH0sIDEpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBJZiBgYXV0b1ZhbGlkYXRlYCBpcyB0cnVlLCB0aGVuIHZhbGlkYXRlcyB0aGUgZWxlbWVudC5cbiAgICovXG4gIF9oYW5kbGVBdXRvVmFsaWRhdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmF1dG9WYWxpZGF0ZSlcbiAgICAgIHRoaXMudmFsaWRhdGUoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzdG9yZXMgdGhlIGN1cnNvciB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb24gYWZ0ZXIgdXBkYXRpbmcgdGhlIHZhbHVlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWUgVGhlIHZhbHVlIHRoYXQgc2hvdWxkIGJlIHNhdmVkLlxuICAgKi9cbiAgdXBkYXRlVmFsdWVBbmRQcmVzZXJ2ZUNhcmV0OiBmdW5jdGlvbihuZXdWYWx1ZSkge1xuICAgIC8vIE5vdCBhbGwgZWxlbWVudHMgbWlnaHQgaGF2ZSBzZWxlY3Rpb24sIGFuZCBldmVuIGlmIHRoZXkgaGF2ZSB0aGVcbiAgICAvLyByaWdodCBwcm9wZXJ0aWVzLCBhY2Nlc3NpbmcgdGhlbSBtaWdodCB0aHJvdyBhbiBleGNlcHRpb24gKGxpa2UgZm9yXG4gICAgLy8gPGlucHV0IHR5cGU9bnVtYmVyPilcbiAgICB0cnkge1xuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5pbnB1dEVsZW1lbnQuc2VsZWN0aW9uU3RhcnQ7XG4gICAgICB0aGlzLnZhbHVlID0gbmV3VmFsdWU7XG5cbiAgICAgIC8vIFRoZSBjdXJzb3IgYXV0b21hdGljYWxseSBqdW1wcyB0byB0aGUgZW5kIGFmdGVyIHJlLXNldHRpbmcgdGhlIHZhbHVlLFxuICAgICAgLy8gc28gcmVzdG9yZSBpdCB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb24uXG4gICAgICB0aGlzLmlucHV0RWxlbWVudC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgdGhpcy5pbnB1dEVsZW1lbnQuc2VsZWN0aW9uRW5kID0gc3RhcnQ7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSnVzdCBzZXQgdGhlIHZhbHVlIGFuZCBnaXZlIHVwIG9uIHRoZSBjYXJldC5cbiAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH0sXG5cbiAgX2NvbXB1dGVBbHdheXNGbG9hdExhYmVsOiBmdW5jdGlvbihhbHdheXNGbG9hdExhYmVsLCBwbGFjZWhvbGRlcikge1xuICAgIHJldHVybiBwbGFjZWhvbGRlciB8fCBhbHdheXNGbG9hdExhYmVsO1xuICB9LFxuXG4gIF91cGRhdGVBcmlhTGFiZWxsZWRCeTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGxhYmVsID0gZG9tKHRoaXMucm9vdCkucXVlcnlTZWxlY3RvcignbGFiZWwnKTtcbiAgICBpZiAoIWxhYmVsKSB7XG4gICAgICB0aGlzLl9hcmlhTGFiZWxsZWRCeSA9ICcnO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbGFiZWxsZWRCeTtcbiAgICBpZiAobGFiZWwuaWQpIHtcbiAgICAgIGxhYmVsbGVkQnkgPSBsYWJlbC5pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFiZWxsZWRCeSA9ICdwYXBlci1pbnB1dC1sYWJlbC0nICsgUGFwZXJJbnB1dEhlbHBlci5OZXh0TGFiZWxJRCsrO1xuICAgICAgbGFiZWwuaWQgPSBsYWJlbGxlZEJ5O1xuICAgIH1cbiAgICB0aGlzLl9hcmlhTGFiZWxsZWRCeSA9IGxhYmVsbGVkQnk7XG4gIH0sXG5cbiAgX29uQ2hhbmdlOmZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gSW4gdGhlIFNoYWRvdyBET00sIHRoZSBgY2hhbmdlYCBldmVudCBpcyBub3QgbGVha2VkIGludG8gdGhlXG4gICAgLy8gYW5jZXN0b3IgdHJlZSwgc28gd2UgbXVzdCBkbyB0aGlzIG1hbnVhbGx5LlxuICAgIC8vIFNlZSBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL3NoYWRvdy8jZXZlbnRzLXRoYXQtYXJlLW5vdC1sZWFrZWQtaW50by1hbmNlc3Rvci10cmVlcy5cbiAgICBpZiAodGhpcy5zaGFkb3dSb290KSB7XG4gICAgICB0aGlzLmZpcmUoZXZlbnQudHlwZSwge3NvdXJjZUV2ZW50OiBldmVudH0sIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgYnViYmxlczogZXZlbnQuYnViYmxlcyxcbiAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZVxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIF9hdXRvZm9jdXNDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBGaXJlZm94IGRvZXNuJ3QgcmVzcGVjdCB0aGUgYXV0b2ZvY3VzIGF0dHJpYnV0ZSBpZiBpdCdzIGFwcGxpZWQgYWZ0ZXJcbiAgICAvLyB0aGUgcGFnZSBpcyBsb2FkZWQgKENocm9tZS9XZWJLaXQgZG8gcmVzcGVjdCBpdCksIHByZXZlbnRpbmcgYW5cbiAgICAvLyBhdXRvZm9jdXMgYXR0cmlidXRlIHNwZWNpZmllZCBpbiBtYXJrdXAgZnJvbSB0YWtpbmcgZWZmZWN0IHdoZW4gdGhlXG4gICAgLy8gZWxlbWVudCBpcyB1cGdyYWRlZC4gQXMgYSB3b3JrYXJvdW5kLCBpZiB0aGUgYXV0b2ZvY3VzIHByb3BlcnR5IGlzIHNldCxcbiAgICAvLyBhbmQgdGhlIGZvY3VzIGhhc24ndCBhbHJlYWR5IGJlZW4gbW92ZWQgZWxzZXdoZXJlLCB3ZSB0YWtlIGZvY3VzLlxuICAgIGlmICh0aGlzLmF1dG9mb2N1cyAmJiB0aGlzLl9mb2N1c2FibGVFbGVtZW50KSB7XG5cbiAgICAgIC8vIEluIElFIDExLCB0aGUgZGVmYXVsdCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSB0aGUgcGFnZSdzXG4gICAgICAvLyBvdXRlcm1vc3QgaHRtbCBlbGVtZW50LCBidXQgdGhlcmUgYXJlIGFsc28gY2FzZXMgKHVuZGVyIHRoZVxuICAgICAgLy8gcG9seWZpbGw/KSBpbiB3aGljaCB0aGUgYWN0aXZlRWxlbWVudCBpcyBub3QgYSByZWFsIEhUTUxFbGVtZW50LCBidXRcbiAgICAgIC8vIGp1c3QgYSBwbGFpbiBvYmplY3QuIFdlIGlkZW50aWZ5IHRoZSBsYXR0ZXIgY2FzZSBhcyBoYXZpbmcgbm8gdmFsaWRcbiAgICAgIC8vIGFjdGl2ZUVsZW1lbnQuXG4gICAgICB2YXIgYWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICB2YXIgaXNBY3RpdmVFbGVtZW50VmFsaWQgPSBhY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQ7XG5cbiAgICAgIC8vIEhhcyBzb21lIG90aGVyIGVsZW1lbnQgaGFzIGFscmVhZHkgdGFrZW4gdGhlIGZvY3VzP1xuICAgICAgdmFyIGlzU29tZUVsZW1lbnRBY3RpdmUgPSBpc0FjdGl2ZUVsZW1lbnRWYWxpZCAmJlxuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgIT09IGRvY3VtZW50LmJvZHkgJiZcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7IC8qIElFIDExICovXG4gICAgICBpZiAoIWlzU29tZUVsZW1lbnRBY3RpdmUpIHtcbiAgICAgICAgLy8gTm8gc3BlY2lmaWMgZWxlbWVudCBoYXMgdGFrZW4gdGhlIGZvY3VzIHlldCwgc28gd2UgY2FuIHRha2UgaXQuXG4gICAgICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBQYXBlcklucHV0QmVoYXZpb3IgPSBbXG4gIElyb25Db250cm9sU3RhdGUsXG4gIElyb25BMTF5S2V5c0JlaGF2aW9yLFxuICBQYXBlcklucHV0QmVoYXZpb3JJbXBsXG5dO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDkwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL3R5cG9ncmFwaHkuanMnO1xuaW1wb3J0IHsgUGFwZXJJbnB1dEFkZG9uQmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLWlucHV0LWFkZG9uLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIGZsb2F0OiByaWdodDtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNhcHRpb247XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNoYXItY291bnRlcjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICA6aG9zdC1jb250ZXh0KFtkaXI9XCJydGxcIl0pIHtcbiAgICAgICAgZmxvYXQ6IGxlZnQ7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxzcGFuPltbX2NoYXJDb3VudGVyU3RyXV08L3NwYW4+XG5gLFxuXG4gIGlzOiAncGFwZXItaW5wdXQtY2hhci1jb3VudGVyJyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBQYXBlcklucHV0QWRkb25CZWhhdmlvclxuICBdLFxuXG4gIHByb3BlcnRpZXM6IHtcbiAgICBfY2hhckNvdW50ZXJTdHI6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnMCdcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgb3ZlcnJpZGVzIHRoZSB1cGRhdGUgZnVuY3Rpb24gaW4gUGFwZXJJbnB1dEFkZG9uQmVoYXZpb3IuXG4gICAqIEBwYXJhbSB7e1xuICAgKiAgIGlucHV0RWxlbWVudDogKEVsZW1lbnR8dW5kZWZpbmVkKSxcbiAgICogICB2YWx1ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICAgKiAgIGludmFsaWQ6IGJvb2xlYW5cbiAgICogfX0gc3RhdGUgLVxuICAgKiAgICAgaW5wdXRFbGVtZW50OiBUaGUgaW5wdXQgZWxlbWVudC5cbiAgICogICAgIHZhbHVlOiBUaGUgaW5wdXQgdmFsdWUuXG4gICAqICAgICBpbnZhbGlkOiBUcnVlIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBpbnZhbGlkLlxuICAgKi9cbiAgdXBkYXRlOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuaW5wdXRFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3RhdGUudmFsdWUgPSBzdGF0ZS52YWx1ZSB8fCAnJztcblxuICAgIHZhciBjb3VudGVyID0gc3RhdGUudmFsdWUudG9TdHJpbmcoKS5sZW5ndGgudG9TdHJpbmcoKTtcblxuICAgIGlmIChzdGF0ZS5pbnB1dEVsZW1lbnQuaGFzQXR0cmlidXRlKCdtYXhsZW5ndGgnKSkge1xuICAgICAgY291bnRlciArPSAnLycgKyBzdGF0ZS5pbnB1dEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdtYXhsZW5ndGgnKTtcbiAgICB9XG5cbiAgICB0aGlzLl9jaGFyQ291bnRlclN0ciA9IGNvdW50ZXI7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtY2hhci1jb3VudGVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL3R5cG9ncmFwaHkuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCB7IGRhc2hUb0NhbWVsQ2FzZSB9IGZyb20gJy4uL3BvbHltZXIvbGliL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcGFkZGluZzogOHB4IDA7XG5cbiAgICAgICAgLS1wYXBlci1pbnB1dC1jb250YWluZXItc2hhcmVkLWlucHV0LXN0eWxlOiB7XG4gICAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlOyAvKiB0byBtYWtlIGEgc3RhY2tpbmcgY29udGV4dCAqL1xuICAgICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1pbnB1dC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICAgICAgICAgIHRleHQtYWxpZ246IGluaGVyaXQ7XG4gICAgICAgICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcblxuICAgICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtc3ViaGVhZDtcbiAgICAgICAgfTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXI7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtpbmxpbmVdKSB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgb3BhY2l0eTogMC4zMztcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItZGlzYWJsZWQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgW2hpZGRlbl0ge1xuICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIC5mbG9hdGVkLWxhYmVsLXBsYWNlaG9sZGVyIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jYXB0aW9uO1xuICAgICAgfVxuXG4gICAgICAudW5kZXJsaW5lIHtcbiAgICAgICAgaGVpZ2h0OiAycHg7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH1cblxuICAgICAgLmZvY3VzZWQtbGluZSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDJweCBzb2xpZCB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItZm9jdXMtY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcblxuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG4gICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IGNlbnRlciBjZW50ZXI7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZTNkKDAsMSwxKTtcbiAgICAgICAgdHJhbnNmb3JtOiBzY2FsZTNkKDAsMSwxKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItdW5kZXJsaW5lLWZvY3VzO1xuICAgICAgfVxuXG4gICAgICAudW5kZXJsaW5lLmlzLWhpZ2hsaWdodGVkIC5mb2N1c2VkLWxpbmUge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogbm9uZTtcbiAgICAgICAgdHJhbnNmb3JtOiBub25lO1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIDAuMjVzO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4yNXM7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdHJhbnNpdGlvbi1lYXNpbmc7XG4gICAgICB9XG5cbiAgICAgIC51bmRlcmxpbmUuaXMtaW52YWxpZCAuZm9jdXNlZC1saW5lIHtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItaW52YWxpZC1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IG5vbmU7XG4gICAgICAgIHRyYW5zZm9ybTogbm9uZTtcbiAgICAgICAgLXdlYmtpdC10cmFuc2l0aW9uOiAtd2Via2l0LXRyYW5zZm9ybSAwLjI1cztcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMjVzO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRyYW5zaXRpb24tZWFzaW5nO1xuICAgICAgfVxuXG4gICAgICAudW5mb2N1c2VkLWxpbmUge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZml0O1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWNvbG9yLCB2YXIoLS1zZWNvbmRhcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItdW5kZXJsaW5lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAudW5mb2N1c2VkLWxpbmUge1xuICAgICAgICBib3JkZXItYm90dG9tOiAxcHggZGFzaGVkO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1jb2xvciwgdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLXVuZGVybGluZS1kaXNhYmxlZDtcbiAgICAgIH1cblxuICAgICAgLmlucHV0LXdyYXBwZXIge1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtaG9yaXpvbnRhbDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAuaW5wdXQtY29udGVudCB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1mbGV4LWF1dG87XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1yZWxhdGl2ZTtcbiAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgfVxuXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQobGFiZWwpLFxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKC5wYXBlci1pbnB1dC1sYWJlbCkge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBmb250OiBpbmhlcml0O1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWNvbG9yLCB2YXIoLS1zZWNvbmRhcnktdGV4dC1jb2xvcikpO1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIDAuMjVzLCB3aWR0aCAwLjI1cztcbiAgICAgICAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuMjVzLCB3aWR0aCAwLjI1cztcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcDtcbiAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogbGVmdCB0b3A7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tbm93cmFwO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LXN1YmhlYWQ7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1sYWJlbDtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdHJhbnNpdGlvbi1lYXNpbmc7XG4gICAgICB9XG5cbiAgICAgIC5pbnB1dC1jb250ZW50LmxhYmVsLWlzLWZsb2F0aW5nIDo6c2xvdHRlZChsYWJlbCksXG4gICAgICAuaW5wdXQtY29udGVudC5sYWJlbC1pcy1mbG9hdGluZyA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWxhYmVsKSB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVZKC03NSUpIHNjYWxlKDAuNzUpO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTc1JSkgc2NhbGUoMC43NSk7XG5cbiAgICAgICAgLyogU2luY2Ugd2Ugc2NhbGUgdG8gNzUvMTAwIG9mIHRoZSBzaXplLCB3ZSBhY3R1YWxseSBoYXZlIDEwMC83NSBvZiB0aGVcbiAgICAgICAgb3JpZ2luYWwgc3BhY2Ugbm93IGF2YWlsYWJsZSAqL1xuICAgICAgICB3aWR0aDogMTMzJTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItbGFiZWwtZmxvYXRpbmc7XG4gICAgICB9XG5cbiAgICAgIDpob3N0LWNvbnRleHQoW2Rpcj1cInJ0bFwiXSkgLmlucHV0LWNvbnRlbnQubGFiZWwtaXMtZmxvYXRpbmcgOjpzbG90dGVkKGxhYmVsKSxcbiAgICAgIDpob3N0LWNvbnRleHQoW2Rpcj1cInJ0bFwiXSkgLmlucHV0LWNvbnRlbnQubGFiZWwtaXMtZmxvYXRpbmcgOjpzbG90dGVkKC5wYXBlci1pbnB1dC1sYWJlbCkge1xuICAgICAgICAvKiBUT0RPKG5vbXMpOiBGaWd1cmUgb3V0IHdoeSBsZWF2aW5nIHRoZSB3aWR0aCBhdCAxMzMlIGJlZm9yZSB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAqIGFjdHVhbGx5IG1ha2VzXG4gICAgICAgICAqIGl0IHdpZGVyIG9uIHRoZSByaWdodCBzaWRlLCBub3QgbGVmdCBzaWRlLCBhcyB5b3Ugd291bGQgZXhwZWN0IGluIFJUTCAqL1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiByaWdodCB0b3A7XG4gICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IHJpZ2h0IHRvcDtcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQubGFiZWwtaXMtaGlnaGxpZ2h0ZWQgOjpzbG90dGVkKGxhYmVsKSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmxhYmVsLWlzLWhpZ2hsaWdodGVkIDo6c2xvdHRlZCgucGFwZXItaW5wdXQtbGFiZWwpIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1mb2N1cy1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1sYWJlbC1mb2N1cztcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQobGFiZWwpLFxuICAgICAgLmlucHV0LWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWxhYmVsKSB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItaW52YWxpZC1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQubGFiZWwtaXMtaGlkZGVuIDo6c2xvdHRlZChsYWJlbCksXG4gICAgICAuaW5wdXQtY29udGVudC5sYWJlbC1pcy1oaWRkZW4gOjpzbG90dGVkKC5wYXBlci1pbnB1dC1sYWJlbCkge1xuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC5pbnB1dC1jb250ZW50IDo6c2xvdHRlZChpcm9uLWlucHV0KSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1zaGFyZWQtaW5wdXQtc3R5bGU7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5pbnB1dC1jb250ZW50IDo6c2xvdHRlZChpbnB1dCksXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQodGV4dGFyZWEpLFxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKGlyb24tYXV0b2dyb3ctdGV4dGFyZWEpLFxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKC5wYXBlci1pbnB1dC1pbnB1dCkge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItc2hhcmVkLWlucHV0LXN0eWxlO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIC5pbnB1dC1jb250ZW50IDo6c2xvdHRlZChpbnB1dCk6Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24sXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQoaW5wdXQpOjotd2Via2l0LWlubmVyLXNwaW4tYnV0dG9uIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWlucHV0LXdlYmtpdC1zcGlubmVyO1xuICAgICAgfVxuICAgICAgXG4gICAgICAuaW5wdXQtY29udGVudC5mb2N1c2VkIDo6c2xvdHRlZChpbnB1dCksXG4gICAgICAuaW5wdXQtY29udGVudC5mb2N1c2VkIDo6c2xvdHRlZCh0ZXh0YXJlYSksXG4gICAgICAuaW5wdXQtY29udGVudC5mb2N1c2VkIDo6c2xvdHRlZChpcm9uLWF1dG9ncm93LXRleHRhcmVhKSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmZvY3VzZWQgOjpzbG90dGVkKC5wYXBlci1pbnB1dC1pbnB1dCkge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQtZm9jdXM7XG4gICAgICB9XG5cbiAgICAgIC5pbnB1dC1jb250ZW50LmlzLWludmFsaWQgOjpzbG90dGVkKGlucHV0KSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmlzLWludmFsaWQgOjpzbG90dGVkKHRleHRhcmVhKSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmlzLWludmFsaWQgOjpzbG90dGVkKGlyb24tYXV0b2dyb3ctdGV4dGFyZWEpLFxuICAgICAgLmlucHV0LWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWlucHV0KSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1pbnB1dC1pbnZhbGlkO1xuICAgICAgfVxuICAgICAgXG4gICAgICAucHJlZml4IDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1zdWJoZWFkO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtZmxleC1ub25lO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1wcmVmaXg7XG4gICAgICB9XG5cbiAgICAgIC5zdWZmaXggOjpzbG90dGVkKCopIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LXN1YmhlYWQ7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1mbGV4LW5vbmU7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtc3VmZml4O1xuICAgICAgfVxuXG4gICAgICAvKiBGaXJlZm94IHNldHMgYSBtaW4td2lkdGggb24gdGhlIGlucHV0LCB3aGljaCBjYW4gY2F1c2UgbGF5b3V0IGlzc3VlcyAqL1xuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKGlucHV0KSB7XG4gICAgICAgIG1pbi13aWR0aDogMDtcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKHRleHRhcmVhKSB7XG4gICAgICAgIHJlc2l6ZTogbm9uZTtcbiAgICAgIH1cblxuICAgICAgLmFkZC1vbi1jb250ZW50IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAuYWRkLW9uLWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQoKikge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWludmFsaWQtY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIC5hZGQtb24tY29udGVudC5pcy1oaWdobGlnaHRlZCA6OnNsb3R0ZWQoKikge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWZvY3VzLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxkaXYgY2xhc3M9XCJmbG9hdGVkLWxhYmVsLXBsYWNlaG9sZGVyXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCIgaGlkZGVuPVwiW1tub0xhYmVsRmxvYXRdXVwiPiZuYnNwOzwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImlucHV0LXdyYXBwZXJcIj5cbiAgICAgIDxzcGFuIGNsYXNzPVwicHJlZml4XCI+PHNsb3QgbmFtZT1cInByZWZpeFwiPjwvc2xvdD48L3NwYW4+XG5cbiAgICAgIDxkaXYgY2xhc3NcXCQ9XCJbW19jb21wdXRlSW5wdXRDb250ZW50Q2xhc3Mobm9MYWJlbEZsb2F0LGFsd2F5c0Zsb2F0TGFiZWwsZm9jdXNlZCxpbnZhbGlkLF9pbnB1dEhhc0NvbnRlbnQpXV1cIiBpZD1cImxhYmVsQW5kSW5wdXRDb250YWluZXJcIj5cbiAgICAgICAgPHNsb3QgbmFtZT1cImxhYmVsXCI+PC9zbG90PlxuICAgICAgICA8c2xvdCBuYW1lPVwiaW5wdXRcIj48L3Nsb3Q+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPHNwYW4gY2xhc3M9XCJzdWZmaXhcIj48c2xvdCBuYW1lPVwic3VmZml4XCI+PC9zbG90Pjwvc3Bhbj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3NcXCQ9XCJbW19jb21wdXRlVW5kZXJsaW5lQ2xhc3MoZm9jdXNlZCxpbnZhbGlkKV1dXCI+XG4gICAgICA8ZGl2IGNsYXNzPVwidW5mb2N1c2VkLWxpbmVcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJmb2N1c2VkLWxpbmVcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3NcXCQ9XCJbW19jb21wdXRlQWRkT25Db250ZW50Q2xhc3MoZm9jdXNlZCxpbnZhbGlkKV1dXCI+XG4gICAgICA8c2xvdCBuYW1lPVwiYWRkLW9uXCI+PC9zbG90PlxuICAgIDwvZGl2PlxuYCxcblxuICBpczogJ3BhcGVyLWlucHV0LWNvbnRhaW5lcicsXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGRpc2FibGUgdGhlIGZsb2F0aW5nIGxhYmVsLiBUaGUgbGFiZWwgZGlzYXBwZWFycyB3aGVuIHRoZSBpbnB1dCB2YWx1ZSBpc1xuICAgICAqIG5vdCBudWxsLlxuICAgICAqL1xuICAgIG5vTGFiZWxGbG9hdDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBhbHdheXMgZmxvYXQgdGhlIGZsb2F0aW5nIGxhYmVsLlxuICAgICAqL1xuICAgIGFsd2F5c0Zsb2F0TGFiZWw6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGF0dHJpYnV0ZSB0byBsaXN0ZW4gZm9yIHZhbHVlIGNoYW5nZXMgb24uXG4gICAgICovXG4gICAgYXR0ckZvclZhbHVlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2JpbmQtdmFsdWUnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGF1dG8tdmFsaWRhdGUgdGhlIGlucHV0IHZhbHVlIHdoZW4gaXQgY2hhbmdlcy5cbiAgICAgKi9cbiAgICBhdXRvVmFsaWRhdGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgaW5wdXQgaXMgaW52YWxpZC4gVGhpcyBwcm9wZXJ0eSBpcyBzZXQgYXV0b21hdGljYWxseSB3aGVuIHRoZSBpbnB1dCB2YWx1ZVxuICAgICAqIGNoYW5nZXMgaWYgYXV0by12YWxpZGF0aW5nLCBvciB3aGVuIHRoZSBgaXJvbi1pbnB1dC12YWxpZGF0ZWAgZXZlbnQgaXMgaGVhcmQgZnJvbSBhIGNoaWxkLlxuICAgICAqL1xuICAgIGludmFsaWQ6IHtcbiAgICAgIG9ic2VydmVyOiAnX2ludmFsaWRDaGFuZ2VkJyxcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgaW5wdXQgaGFzIGZvY3VzLlxuICAgICAqL1xuICAgIGZvY3VzZWQ6IHtcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG5vdGlmeTogdHJ1ZVxuICAgIH0sXG5cbiAgICBfYWRkb25zOiB7XG4gICAgICB0eXBlOiBBcnJheVxuICAgICAgLy8gZG8gbm90IHNldCBhIGRlZmF1bHQgdmFsdWUgaGVyZSBpbnRlbnRpb25hbGx5IC0gaXQgd2lsbCBiZSBpbml0aWFsaXplZCBsYXppbHkgd2hlbiBhXG4gICAgICAvLyBkaXN0cmlidXRlZCBjaGlsZCBpcyBhdHRhY2hlZCwgd2hpY2ggbWF5IG9jY3VyIGJlZm9yZSBjb25maWd1cmF0aW9uIGZvciB0aGlzIGVsZW1lbnRcbiAgICAgIC8vIGluIHBvbHlmaWxsLlxuICAgIH0sXG5cbiAgICBfaW5wdXRIYXNDb250ZW50OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIF9pbnB1dFNlbGVjdG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2lucHV0LGlyb24taW5wdXQsdGV4dGFyZWEsLnBhcGVyLWlucHV0LWlucHV0J1xuICAgIH0sXG5cbiAgICBfYm91bmRPbkZvY3VzOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uRm9jdXMuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2JvdW5kT25CbHVyOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uQmx1ci5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfYm91bmRPbklucHV0OiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uSW5wdXQuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgX2JvdW5kVmFsdWVDaGFuZ2VkOiB7XG4gICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uVmFsdWVDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGxpc3RlbmVyczoge1xuICAgICdhZGRvbi1hdHRhY2hlZCc6ICdfb25BZGRvbkF0dGFjaGVkJyxcbiAgICAnaXJvbi1pbnB1dC12YWxpZGF0ZSc6ICdfb25Jcm9uSW5wdXRWYWxpZGF0ZSdcbiAgfSxcblxuICBnZXQgX3ZhbHVlQ2hhbmdlZEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmF0dHJGb3JWYWx1ZSArICctY2hhbmdlZCc7XG4gIH0sXG5cbiAgZ2V0IF9wcm9wZXJ0eUZvclZhbHVlKCkge1xuICAgIHJldHVybiBkYXNoVG9DYW1lbENhc2UodGhpcy5hdHRyRm9yVmFsdWUpO1xuICB9LFxuXG4gIGdldCBfaW5wdXRFbGVtZW50KCkge1xuICAgIHJldHVybiBkb20odGhpcykucXVlcnlTZWxlY3Rvcih0aGlzLl9pbnB1dFNlbGVjdG9yKTtcbiAgfSxcblxuICBnZXQgX2lucHV0RWxlbWVudFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLl9pbnB1dEVsZW1lbnRbdGhpcy5fcHJvcGVydHlGb3JWYWx1ZV0gfHwgdGhpcy5faW5wdXRFbGVtZW50LnZhbHVlO1xuICB9LFxuXG4gIHJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX2FkZG9ucykge1xuICAgICAgdGhpcy5fYWRkb25zID0gW107XG4gICAgfVxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZE9uRm9jdXMsIHRydWUpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kT25CbHVyLCB0cnVlKTtcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYXR0ckZvclZhbHVlKSB7XG4gICAgICB0aGlzLl9pbnB1dEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLl92YWx1ZUNoYW5nZWRFdmVudCwgdGhpcy5fYm91bmRWYWx1ZUNoYW5nZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5fb25JbnB1dCk7XG4gICAgfVxuXG4gICAgLy8gT25seSB2YWxpZGF0ZSB3aGVuIGF0dGFjaGVkIGlmIHRoZSBpbnB1dCBhbHJlYWR5IGhhcyBhIHZhbHVlLlxuICAgIGlmICh0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSAmJiB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSAhPSAnJykge1xuICAgICAgdGhpcy5faGFuZGxlVmFsdWVBbmRBdXRvVmFsaWRhdGUodGhpcy5faW5wdXRFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faGFuZGxlVmFsdWUodGhpcy5faW5wdXRFbGVtZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgX29uQWRkb25BdHRhY2hlZDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2FkZG9ucykge1xuICAgICAgdGhpcy5fYWRkb25zID0gW107XG4gICAgfVxuICAgIHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgaWYgKHRoaXMuX2FkZG9ucy5pbmRleE9mKHRhcmdldCkgPT09IC0xKSB7XG4gICAgICB0aGlzLl9hZGRvbnMucHVzaCh0YXJnZXQpO1xuICAgICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVWYWx1ZSh0aGlzLl9pbnB1dEVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBfb25Gb2N1czogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fc2V0Rm9jdXNlZCh0cnVlKTtcbiAgfSxcblxuICBfb25CbHVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZXRGb2N1c2VkKGZhbHNlKTtcbiAgICB0aGlzLl9oYW5kbGVWYWx1ZUFuZEF1dG9WYWxpZGF0ZSh0aGlzLl9pbnB1dEVsZW1lbnQpO1xuICB9LFxuXG4gIF9vbklucHV0OiBmdW5jdGlvbihldmVudCkge1xuICAgIHRoaXMuX2hhbmRsZVZhbHVlQW5kQXV0b1ZhbGlkYXRlKGV2ZW50LnRhcmdldCk7XG4gIH0sXG5cbiAgX29uVmFsdWVDaGFuZ2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBpbnB1dCA9IGV2ZW50LnRhcmdldDtcblxuICAgIC8vIFByb2JsZW06IGlmIHRoZSBpbnB1dCBpcyByZXF1aXJlZCBidXQgaGFzIG5vIHRleHQgZW50ZXJlZCwgd2Ugc2hvdWxkXG4gICAgLy8gb25seSB2YWxpZGF0ZSBpdCBvbiBibHVyIChzbyB0aGF0IGFuIGVtcHR5IGZvcm0gZG9lc24ndCBjb21lIHVwIHJlZFxuICAgIC8vIGltbWVkaWF0ZWx5OyBob3dldmVyLCBpbiB0aGlzIGhhbmRsZXIsIHdlIGRvbid0IGtub3cgd2hldGhlciB0aGlzIGlzXG4gICAgLy8gdGhlIGJvb3RpbmcgdXAgdmFsdWUgb3IgYSB2YWx1ZSBpbiB0aGUgZnV0dXJlLiBJIGFtIGFzc3VtaW5nIHRoYXQgdGhlXG4gICAgLy8gY2FzZSAgd2UgY2FyZSBhYm91dCBtYW5pZmVzdHMgaXRzZWxmIHdoZW4gdGhlIHZhbHVlIGlzIHVuZGVmaW5lZC5cbiAgICAvLyBJZiB0aGlzIGNhdXNlcyBmdXR1cmUgcHJvYmxlbXMsIHdlIG5lZWQgdG8gZG8gc29tZXRoaW5nIGxpa2UgdHJhY2sgd2hldGhlclxuICAgIC8vIHRoZSBpcm9uLWlucHV0LXJlYWR5IGV2ZW50IGhhcyBmaXJlZCwgYW5kIHRoaXMgaGFuZGxlciBjYW1lIGJlZm9yZSB0aGF0LlxuXG4gICAgaWYgKGlucHV0LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9oYW5kbGVWYWx1ZUFuZEF1dG9WYWxpZGF0ZShldmVudC50YXJnZXQpO1xuICB9LFxuXG4gIF9oYW5kbGVWYWx1ZTogZnVuY3Rpb24oaW5wdXRFbGVtZW50KSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5faW5wdXRFbGVtZW50VmFsdWU7XG5cbiAgICAvLyB0eXBlPVwibnVtYmVyXCIgaGFjayBuZWVkZWQgYmVjYXVzZSB0aGlzLnZhbHVlIGlzIGVtcHR5IHVudGlsIGl0J3MgdmFsaWRcbiAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09IDAgfHwgKGlucHV0RWxlbWVudC50eXBlID09PSAnbnVtYmVyJyAmJiAhaW5wdXRFbGVtZW50LmNoZWNrVmFsaWRpdHkoKSkpIHtcbiAgICAgIHRoaXMuX2lucHV0SGFzQ29udGVudCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2lucHV0SGFzQ29udGVudCA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMudXBkYXRlQWRkb25zKHtcbiAgICAgIGlucHV0RWxlbWVudDogaW5wdXRFbGVtZW50LFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgaW52YWxpZDogdGhpcy5pbnZhbGlkXG4gICAgfSk7XG4gIH0sXG5cbiAgX2hhbmRsZVZhbHVlQW5kQXV0b1ZhbGlkYXRlOiBmdW5jdGlvbihpbnB1dEVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5hdXRvVmFsaWRhdGUgJiYgaW5wdXRFbGVtZW50KSB7XG4gICAgICB2YXIgdmFsaWQ7XG5cbiAgICAgIGlmIChpbnB1dEVsZW1lbnQudmFsaWRhdGUpIHtcbiAgICAgICAgdmFsaWQgPSBpbnB1dEVsZW1lbnQudmFsaWRhdGUodGhpcy5faW5wdXRFbGVtZW50VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsaWQgPSBpbnB1dEVsZW1lbnQuY2hlY2tWYWxpZGl0eSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5pbnZhbGlkID0gIXZhbGlkO1xuICAgIH1cblxuICAgIC8vIENhbGwgdGhpcyBsYXN0IHRvIG5vdGlmeSB0aGUgYWRkLW9ucy5cbiAgICB0aGlzLl9oYW5kbGVWYWx1ZShpbnB1dEVsZW1lbnQpO1xuICB9LFxuXG4gIF9vbklyb25JbnB1dFZhbGlkYXRlOiBmdW5jdGlvbihldmVudCkge1xuICAgIHRoaXMuaW52YWxpZCA9IHRoaXMuX2lucHV0RWxlbWVudC5pbnZhbGlkO1xuICB9LFxuXG4gIF9pbnZhbGlkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2FkZG9ucykge1xuICAgICAgdGhpcy51cGRhdGVBZGRvbnMoe2ludmFsaWQ6IHRoaXMuaW52YWxpZH0pO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGlzIHRvIHVwZGF0ZSB0aGUgc3RhdGUgb2YgYWRkLW9ucy5cbiAgICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIEFkZC1vbiBzdGF0ZS5cbiAgICovXG4gIHVwZGF0ZUFkZG9uczogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICBmb3IgKHZhciBhZGRvbiwgaW5kZXggPSAwOyBhZGRvbiA9IHRoaXMuX2FkZG9uc1tpbmRleF07IGluZGV4KyspIHtcbiAgICAgIGFkZG9uLnVwZGF0ZShzdGF0ZSk7XG4gICAgfVxuICB9LFxuXG4gIF9jb21wdXRlSW5wdXRDb250ZW50Q2xhc3M6IGZ1bmN0aW9uKG5vTGFiZWxGbG9hdCwgYWx3YXlzRmxvYXRMYWJlbCwgZm9jdXNlZCwgaW52YWxpZCwgX2lucHV0SGFzQ29udGVudCkge1xuICAgIHZhciBjbHMgPSAnaW5wdXQtY29udGVudCc7XG4gICAgaWYgKCFub0xhYmVsRmxvYXQpIHtcbiAgICAgIHZhciBsYWJlbCA9IHRoaXMucXVlcnlTZWxlY3RvcignbGFiZWwnKTtcblxuICAgICAgaWYgKGFsd2F5c0Zsb2F0TGFiZWwgfHwgX2lucHV0SGFzQ29udGVudCkge1xuICAgICAgICBjbHMgKz0gJyBsYWJlbC1pcy1mbG9hdGluZyc7XG4gICAgICAgIC8vIElmIHRoZSBsYWJlbCBpcyBmbG9hdGluZywgaWdub3JlIGFueSBvZmZzZXRzIHRoYXQgbWF5IGhhdmUgYmVlblxuICAgICAgICAvLyBhcHBsaWVkIGZyb20gYSBwcmVmaXggZWxlbWVudC5cbiAgICAgICAgdGhpcy4kLmxhYmVsQW5kSW5wdXRDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnc3RhdGljJztcblxuICAgICAgICBpZiAoaW52YWxpZCkge1xuICAgICAgICAgIGNscyArPSAnIGlzLWludmFsaWQnO1xuICAgICAgICB9IGVsc2UgaWYgKGZvY3VzZWQpIHtcbiAgICAgICAgICBjbHMgKz0gXCIgbGFiZWwtaXMtaGlnaGxpZ2h0ZWRcIjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2hlbiB0aGUgbGFiZWwgaXMgbm90IGZsb2F0aW5nLCBpdCBzaG91bGQgb3ZlcmxhcCB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICAgICAgaWYgKGxhYmVsKSB7XG4gICAgICAgICAgdGhpcy4kLmxhYmVsQW5kSW5wdXRDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICAgICAgY2xzICs9ICcgaXMtaW52YWxpZCc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKF9pbnB1dEhhc0NvbnRlbnQpIHtcbiAgICAgICAgY2xzICs9ICcgbGFiZWwtaXMtaGlkZGVuJztcbiAgICAgIH1cbiAgICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICAgIGNscyArPSAnIGlzLWludmFsaWQnO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZm9jdXNlZCkge1xuICAgICAgY2xzICs9ICcgZm9jdXNlZCc7XG4gICAgfVxuICAgIHJldHVybiBjbHM7XG4gIH0sXG5cbiAgX2NvbXB1dGVVbmRlcmxpbmVDbGFzczogZnVuY3Rpb24oZm9jdXNlZCwgaW52YWxpZCkge1xuICAgIHZhciBjbHMgPSAndW5kZXJsaW5lJztcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgY2xzICs9ICcgaXMtaW52YWxpZCc7XG4gICAgfSBlbHNlIGlmIChmb2N1c2VkKSB7XG4gICAgICBjbHMgKz0gJyBpcy1oaWdobGlnaHRlZCdcbiAgICB9XG4gICAgcmV0dXJuIGNscztcbiAgfSxcblxuICBfY29tcHV0ZUFkZE9uQ29udGVudENsYXNzOiBmdW5jdGlvbihmb2N1c2VkLCBpbnZhbGlkKSB7XG4gICAgdmFyIGNscyA9ICdhZGQtb24tY29udGVudCc7XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIGNscyArPSAnIGlzLWludmFsaWQnO1xuICAgIH0gZWxzZSBpZiAoZm9jdXNlZCkge1xuICAgICAgY2xzICs9ICcgaXMtaGlnaGxpZ2h0ZWQnXG4gICAgfVxuICAgIHJldHVybiBjbHM7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtY29udGFpbmVyLmpzXG4vLyBtb2R1bGUgaWQgPSA5MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL3R5cG9ncmFwaHkuanMnO1xuaW1wb3J0IHsgUGFwZXJJbnB1dEFkZG9uQmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLWlucHV0LWFkZG9uLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcblxuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWludmFsaWQtY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jYXB0aW9uO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1lcnJvcjtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBsZWZ0OjA7XG4gICAgICAgIHJpZ2h0OjA7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtpbnZhbGlkXSkge1xuICAgICAgICB2aXNpYmlsaXR5OiB2aXNpYmxlO1xuICAgICAgfTtcbiAgICA8L3N0eWxlPlxuXG4gICAgPHNsb3Q+PC9zbG90PlxuYCxcblxuICBpczogJ3BhcGVyLWlucHV0LWVycm9yJyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBQYXBlcklucHV0QWRkb25CZWhhdmlvclxuICBdLFxuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBlcnJvciBpcyBzaG93aW5nLlxuICAgICAqL1xuICAgIGludmFsaWQ6IHtcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBvdmVycmlkZXMgdGhlIHVwZGF0ZSBmdW5jdGlvbiBpbiBQYXBlcklucHV0QWRkb25CZWhhdmlvci5cbiAgICogQHBhcmFtIHt7XG4gICAqICAgaW5wdXRFbGVtZW50OiAoRWxlbWVudHx1bmRlZmluZWQpLFxuICAgKiAgIHZhbHVlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICAqICAgaW52YWxpZDogYm9vbGVhblxuICAgKiB9fSBzdGF0ZSAtXG4gICAqICAgICBpbnB1dEVsZW1lbnQ6IFRoZSBpbnB1dCBlbGVtZW50LlxuICAgKiAgICAgdmFsdWU6IFRoZSBpbnB1dCB2YWx1ZS5cbiAgICogICAgIGludmFsaWQ6IFRydWUgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGludmFsaWQuXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgdGhpcy5fc2V0SW52YWxpZChzdGF0ZS5pbnZhbGlkKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC1lcnJvci5qc1xuLy8gbW9kdWxlIGlkID0gOTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyc7XG5pbXBvcnQgeyBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3IgfSBmcm9tICcuLi9wYXBlci1iZWhhdmlvcnMvcGFwZXItY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQgeyBhZnRlck5leHRSZW5kZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzJztcbmltcG9ydCB7IFBhcGVySW5reUZvY3VzQmVoYXZpb3JJbXBsIH0gZnJvbSAnLi4vcGFwZXItYmVoYXZpb3JzL3BhcGVyLWlua3ktZm9jdXMtYmVoYXZpb3IuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxkb20tbW9kdWxlIGlkPVwicGFwZXItY2hlY2tib3hcIj5cbiAgPHRlbXBsYXRlIHN0cmlwLXdoaXRlc3BhY2U9XCJcIj5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZTogdmFyKC0tcGFwZXItY2hlY2tib3gtc2l6ZSwgMThweCk7XG4gICAgICAgIC8qIC0xcHggaXMgYSBzZW50aW5lbCBmb3IgdGhlIGRlZmF1bHQgYW5kIGlzIHJlcGxhY2VkIGluIFxcYGF0dGFjaGVkXFxgLiAqL1xuICAgICAgICAtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtaW5rLXNpemU6IHZhcigtLXBhcGVyLWNoZWNrYm94LWluay1zaXplLCAtMXB4KTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDA7XG4gICAgICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtoaWRkZW5dKSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoOmZvY3VzKSB7XG4gICAgICAgIG91dGxpbmU6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIC5oaWRkZW4ge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgfVxuXG4gICAgICAjY2hlY2tib3hDb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZSk7XG4gICAgICAgIGhlaWdodDogdmFyKC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1zaXplKTtcbiAgICAgICAgbWluLXdpZHRoOiB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUpO1xuICAgICAgICBtYXJnaW46IHZhcigtLXBhcGVyLWNoZWNrYm94LW1hcmdpbiwgaW5pdGlhbCk7XG4gICAgICAgIHZlcnRpY2FsLWFsaWduOiB2YXIoLS1wYXBlci1jaGVja2JveC12ZXJ0aWNhbC1hbGlnbiwgbWlkZGxlKTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtdW5jaGVja2VkLWJhY2tncm91bmQtY29sb3IsIHRyYW5zcGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgI2luayB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcblxuICAgICAgICAvKiBDZW50ZXIgdGhlIHJpcHBsZSBpbiB0aGUgY2hlY2tib3ggYnkgbmVnYXRpdmUgb2Zmc2V0dGluZyBpdCBieVxuICAgICAgICAgKiAoaW5rV2lkdGggLSByaXBwbGVXaWR0aCkgLyAyICovXG4gICAgICAgIHRvcDogY2FsYygwcHggLSAodmFyKC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1pbmstc2l6ZSkgLSB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUpKSAvIDIpO1xuICAgICAgICBsZWZ0OiBjYWxjKDBweCAtICh2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LWluay1zaXplKSAtIHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZSkpIC8gMik7XG4gICAgICAgIHdpZHRoOiB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LWluay1zaXplKTtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LWluay1zaXplKTtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LXVuY2hlY2tlZC1pbmstY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBvcGFjaXR5OiAwLjY7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdC1jb250ZXh0KFtkaXI9XCJydGxcIl0pICNpbmsge1xuICAgICAgICByaWdodDogY2FsYygwcHggLSAodmFyKC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1pbmstc2l6ZSkgLSB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUpKSAvIDIpO1xuICAgICAgICBsZWZ0OiBhdXRvO1xuICAgICAgfVxuXG4gICAgICAjaW5rW2NoZWNrZWRdIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LWNoZWNrZWQtaW5rLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgICNjaGVja2JveCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBib3JkZXI6IHNvbGlkIDJweDtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1wYXBlci1jaGVja2JveC11bmNoZWNrZWQtY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAycHg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgMTQwbXMsIGJvcmRlci1jb2xvciAxNDBtcztcbiAgICAgICAgdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAxNDBtcywgYm9yZGVyLWNvbG9yIDE0MG1zO1xuICAgICAgfVxuXG4gICAgICAvKiBjaGVja2JveCBjaGVja2VkIGFuaW1hdGlvbnMgKi9cbiAgICAgICNjaGVja2JveC5jaGVja2VkICNjaGVja21hcmsge1xuICAgICAgICAtd2Via2l0LWFuaW1hdGlvbjogY2hlY2ttYXJrLWV4cGFuZCAxNDBtcyBlYXNlLW91dCBmb3J3YXJkcztcbiAgICAgICAgYW5pbWF0aW9uOiBjaGVja21hcmstZXhwYW5kIDE0MG1zIGVhc2Utb3V0IGZvcndhcmRzO1xuICAgICAgfVxuXG4gICAgICBALXdlYmtpdC1rZXlmcmFtZXMgY2hlY2ttYXJrLWV4cGFuZCB7XG4gICAgICAgIDAlIHtcbiAgICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMCwgMCkgcm90YXRlKDQ1ZGVnKTtcbiAgICAgICAgfVxuICAgICAgICAxMDAlIHtcbiAgICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSwgMSkgcm90YXRlKDQ1ZGVnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBAa2V5ZnJhbWVzIGNoZWNrbWFyay1leHBhbmQge1xuICAgICAgICAwJSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgwLCAwKSByb3RhdGUoNDVkZWcpO1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMSwgMSkgcm90YXRlKDQ1ZGVnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAjY2hlY2tib3guY2hlY2tlZCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LWNoZWNrZWQtY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1wYXBlci1jaGVja2JveC1jaGVja2VkLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgICNjaGVja21hcmsge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHdpZHRoOiAzNiU7XG4gICAgICAgIGhlaWdodDogNzAlO1xuICAgICAgICBib3JkZXItc3R5bGU6IHNvbGlkO1xuICAgICAgICBib3JkZXItdG9wOiBub25lO1xuICAgICAgICBib3JkZXItbGVmdDogbm9uZTtcbiAgICAgICAgYm9yZGVyLXJpZ2h0LXdpZHRoOiBjYWxjKDIvMTUgKiB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUpKTtcbiAgICAgICAgYm9yZGVyLWJvdHRvbS13aWR0aDogY2FsYygyLzE1ICogdmFyKC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1zaXplKSk7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtY2hlY2ttYXJrLWNvbG9yLCB3aGl0ZSk7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogOTclIDg2JTtcbiAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogOTclIDg2JTtcbiAgICAgICAgYm94LXNpemluZzogY29udGVudC1ib3g7IC8qIHByb3RlY3QgYWdhaW5zdCBwYWdlLWxldmVsIGJveC1zaXppbmcgKi9cbiAgICAgIH1cblxuICAgICAgOmhvc3QtY29udGV4dChbZGlyPVwicnRsXCJdKSAjY2hlY2ttYXJrIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMTQlO1xuICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA1MCUgMTQlO1xuICAgICAgfVxuXG4gICAgICAvKiBsYWJlbCAqL1xuICAgICAgI2NoZWNrYm94TGFiZWwge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiB2YXIoLS1wYXBlci1jaGVja2JveC1sYWJlbC1zcGFjaW5nLCA4cHgpO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm9ybWFsO1xuICAgICAgICBsaW5lLWhlaWdodDogbm9ybWFsO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtbGFiZWwtY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1jaGVja2JveC1sYWJlbDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2NoZWNrZWRdKSAjY2hlY2tib3hMYWJlbCB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1jaGVja2JveC1sYWJlbC1jaGVja2VkLWNvbG9yLCB2YXIoLS1wYXBlci1jaGVja2JveC1sYWJlbC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSkpO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1jaGVja2JveC1sYWJlbC1jaGVja2VkO1xuICAgICAgfVxuXG4gICAgICA6aG9zdC1jb250ZXh0KFtkaXI9XCJydGxcIl0pICNjaGVja2JveExhYmVsIHtcbiAgICAgICAgcGFkZGluZy1yaWdodDogdmFyKC0tcGFwZXItY2hlY2tib3gtbGFiZWwtc3BhY2luZywgOHB4KTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiAwO1xuICAgICAgfVxuXG4gICAgICAjY2hlY2tib3hMYWJlbFtoaWRkZW5dIHtcbiAgICAgICAgZGlzcGxheTogbm9uZTtcbiAgICAgIH1cblxuICAgICAgLyogZGlzYWJsZWQgc3RhdGUgKi9cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgI2NoZWNrYm94IHtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LXVuY2hlY2tlZC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF1bY2hlY2tlZF0pICNjaGVja2JveCB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LXVuY2hlY2tlZC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgI2NoZWNrYm94TGFiZWwgIHtcbiAgICAgICAgb3BhY2l0eTogMC42NTtcbiAgICAgIH1cblxuICAgICAgLyogaW52YWxpZCBzdGF0ZSAqL1xuICAgICAgI2NoZWNrYm94LmludmFsaWQ6bm90KC5jaGVja2VkKSB7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtZXJyb3ItY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxkaXYgaWQ9XCJjaGVja2JveENvbnRhaW5lclwiPlxuICAgICAgPGRpdiBpZD1cImNoZWNrYm94XCIgY2xhc3NcXCQ9XCJbW19jb21wdXRlQ2hlY2tib3hDbGFzcyhjaGVja2VkLCBpbnZhbGlkKV1dXCI+XG4gICAgICAgIDxkaXYgaWQ9XCJjaGVja21hcmtcIiBjbGFzc1xcJD1cIltbX2NvbXB1dGVDaGVja21hcmtDbGFzcyhjaGVja2VkKV1dXCI+PC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgaWQ9XCJjaGVja2JveExhYmVsXCI+PHNsb3Q+PC9zbG90PjwvZGl2PlxuICA8L3RlbXBsYXRlPlxuXG4gIFxuPC9kb20tbW9kdWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5Qb2x5bWVyKHtcbiAgaXM6ICdwYXBlci1jaGVja2JveCcsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9yXG4gIF0sXG5cbiAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICByb2xlOiAnY2hlY2tib3gnLFxuICAgICdhcmlhLWNoZWNrZWQnOiBmYWxzZSxcbiAgICB0YWJpbmRleDogMFxuICB9LFxuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMgZHVlIHRvIHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1jaGFuZ2VcbiAgICAgKi9cbiAgICBhcmlhQWN0aXZlQXR0cmlidXRlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2FyaWEtY2hlY2tlZCdcbiAgICB9XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFdhaXQgdW50aWwgc3R5bGVzIGhhdmUgcmVzb2x2ZWQgdG8gY2hlY2sgZm9yIHRoZSBkZWZhdWx0IHNlbnRpbmVsLlxuICAgIC8vIFNlZSBwb2x5bWVyIzQwMDkgZm9yIG1vcmUgZGV0YWlscy5cbiAgICBhZnRlck5leHRSZW5kZXIodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaW5rU2l6ZSA9IHRoaXMuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCctLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtaW5rLXNpemUnKS50cmltKCk7XG4gICAgICAvLyBJZiB1bnNldCwgY29tcHV0ZSBhbmQgc2V0IHRoZSBkZWZhdWx0IGAtLXBhcGVyLWNoZWNrYm94LWluay1zaXplYC5cbiAgICAgIGlmIChpbmtTaXplID09PSAnLTFweCcpIHtcbiAgICAgICAgdmFyIGNoZWNrYm94U2l6ZVRleHQgPSB0aGlzLmdldENvbXB1dGVkU3R5bGVWYWx1ZSgnLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUnKS50cmltKCk7XG5cbiAgICAgICAgdmFyIHVuaXRzID0gY2hlY2tib3hTaXplVGV4dC5tYXRjaCgvW0EtWmEtel0rJC8pWzBdIHx8ICdweCc7XG4gICAgICAgIHZhciBjaGVja2JveFNpemUgPSBwYXJzZUZsb2F0KGNoZWNrYm94U2l6ZVRleHQsIDEwKTtcbiAgICAgICAgdmFyIGRlZmF1bHRJbmtTaXplID0gKDggLyAzKSAqIGNoZWNrYm94U2l6ZTtcblxuICAgICAgICBpZiAodW5pdHMgPT09ICdweCcpIHtcbiAgICAgICAgICBkZWZhdWx0SW5rU2l6ZSA9IE1hdGguZmxvb3IoZGVmYXVsdElua1NpemUpO1xuXG4gICAgICAgICAgLy8gVGhlIGNoZWNrYm94IGFuZCByaXBwbGUgbmVlZCB0byBoYXZlIHRoZSBzYW1lIHBhcml0eSBzbyB0aGF0IHRoZWlyXG4gICAgICAgICAgLy8gY2VudGVycyBhbGlnbi5cbiAgICAgICAgICBpZiAoZGVmYXVsdElua1NpemUgJSAyICE9PSBjaGVja2JveFNpemUgJSAyKSB7XG4gICAgICAgICAgICBkZWZhdWx0SW5rU2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlU3R5bGVzKHtcbiAgICAgICAgICAnLS1wYXBlci1jaGVja2JveC1pbmstc2l6ZSc6IGRlZmF1bHRJbmtTaXplICsgdW5pdHMsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIF9jb21wdXRlQ2hlY2tib3hDbGFzczogZnVuY3Rpb24oY2hlY2tlZCwgaW52YWxpZCkge1xuICAgIHZhciBjbGFzc05hbWUgPSAnJztcbiAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgY2xhc3NOYW1lICs9ICdjaGVja2VkICc7XG4gICAgfVxuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gJ2ludmFsaWQnO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3NOYW1lO1xuICB9LFxuXG4gIF9jb21wdXRlQ2hlY2ttYXJrQ2xhc3M6IGZ1bmN0aW9uKGNoZWNrZWQpIHtcbiAgICByZXR1cm4gY2hlY2tlZCA/ICcnIDogJ2hpZGRlbic7XG4gIH0sXG5cbiAgLy8gY3JlYXRlIHJpcHBsZSBpbnNpZGUgdGhlIGNoZWNrYm94Q29udGFpbmVyXG4gIF9jcmVhdGVSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3JpcHBsZUNvbnRhaW5lciA9IHRoaXMuJC5jaGVja2JveENvbnRhaW5lcjtcbiAgICByZXR1cm4gUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGwuX2NyZWF0ZVJpcHBsZS5jYWxsKHRoaXMpO1xuICB9XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItY2hlY2tib3gvcGFwZXItY2hlY2tib3guanNcbi8vIG1vZHVsZSBpZCA9IDk0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25WYWxpZGF0YWJsZUJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IElyb25Gb3JtRWxlbWVudEJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1mb3JtLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1jaGFuZ2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgb3Igc2V0cyB0aGUgc3RhdGUsIGB0cnVlYCBpcyBjaGVja2VkIGFuZCBgZmFsc2VgIGlzIHVuY2hlY2tlZC5cbiAgICAgKi9cbiAgICBjaGVja2VkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgb2JzZXJ2ZXI6ICdfY2hlY2tlZENoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBidXR0b24gdG9nZ2xlcyB0aGUgYWN0aXZlIHN0YXRlIHdpdGggZWFjaCB0YXAgb3IgcHJlc3NcbiAgICAgKiBvZiB0aGUgc3BhY2ViYXIuXG4gICAgICovXG4gICAgdG9nZ2xlczoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qIE92ZXJyaWRlbiBmcm9tIFBvbHltZXIuSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IgKi9cbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdvbicsXG4gICAgICBvYnNlcnZlcjogJ192YWx1ZUNoYW5nZWQnXG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfcmVxdWlyZWRDaGFuZ2VkKHJlcXVpcmVkKSdcbiAgXSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBVc2VkIGJ5IGBpcm9uLWZvcm1gIHRvIGhhbmRsZSB0aGUgY2FzZSB0aGF0IGFuIGVsZW1lbnQgd2l0aCB0aGlzIGJlaGF2aW9yXG4gICAgLy8gZG9lc24ndCBoYXZlIGEgcm9sZSBvZiAnY2hlY2tib3gnIG9yICdyYWRpbycsIGJ1dCBzaG91bGQgc3RpbGwgb25seSBiZVxuICAgIC8vIGluY2x1ZGVkIHdoZW4gdGhlIGZvcm0gaXMgc2VyaWFsaXplZCBpZiBgdGhpcy5jaGVja2VkID09PSB0cnVlYC5cbiAgICB0aGlzLl9oYXNJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgZmFsc2UgaWYgdGhlIGVsZW1lbnQgaXMgcmVxdWlyZWQgYW5kIG5vdCBjaGVja2VkLCBhbmQgdHJ1ZSBvdGhlcndpc2UuXG4gICAqIEBwYXJhbSB7Kj19IF92YWx1ZSBJZ25vcmVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB0cnVlIGlmIGByZXF1aXJlZGAgaXMgZmFsc2Ugb3IgaWYgYGNoZWNrZWRgIGlzIHRydWUuXG4gICAqL1xuICBfZ2V0VmFsaWRpdHk6IGZ1bmN0aW9uKF92YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmRpc2FibGVkIHx8ICF0aGlzLnJlcXVpcmVkIHx8IHRoaXMuY2hlY2tlZDtcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBhcmlhLXJlcXVpcmVkIGxhYmVsIHdoZW4gYHJlcXVpcmVkYCBpcyBjaGFuZ2VkLlxuICAgKi9cbiAgX3JlcXVpcmVkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucmVxdWlyZWQpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLXJlcXVpcmVkJywgJ3RydWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtcmVxdWlyZWQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpcmUgYGlyb24tY2hhbmdlZGAgd2hlbiB0aGUgY2hlY2tlZCBzdGF0ZSBjaGFuZ2VzLlxuICAgKi9cbiAgX2NoZWNrZWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFjdGl2ZSA9IHRoaXMuY2hlY2tlZDtcbiAgICB0aGlzLmZpcmUoJ2lyb24tY2hhbmdlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0IHZhbHVlIHRvICdvbicgaWYgaXQgaXMgc2V0IHRvIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgX3ZhbHVlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLnZhbHVlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnZhbHVlID0gJ29uJztcbiAgICB9XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciA9IFtcbiAgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IsXG4gIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yLFxuICBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGxcbl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci9pcm9uLWNoZWNrZWQtZWxlbWVudC1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvY29sb3IuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyc7XG5pbXBvcnQgeyBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3IgfSBmcm9tICcuLi9wYXBlci1iZWhhdmlvcnMvcGFwZXItY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IFBvbHltZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyc7XG5pbXBvcnQgeyBhZnRlck5leHRSZW5kZXIgfSBmcm9tICcuLi9wb2x5bWVyL2xpYi91dGlscy9yZW5kZXItc3RhdHVzLmpzJztcbmltcG9ydCB7IHNldFRvdWNoQWN0aW9uIH0gZnJvbSAnLi4vcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanMnO1xuaW1wb3J0IHsgUGFwZXJSaXBwbGVCZWhhdmlvciB9IGZyb20gJy4uL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1yaXBwbGUtYmVoYXZpb3IuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxkb20tbW9kdWxlIGlkPVwicGFwZXItdG9nZ2xlLWJ1dHRvblwiPlxuICA8dGVtcGxhdGUgc3RyaXAtd2hpdGVzcGFjZT1cIlwiPlxuXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1ob3Jpem9udGFsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCg6Zm9jdXMpIHtcbiAgICAgICAgb3V0bGluZTpub25lO1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWJhciB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogOHB4O1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgb3BhY2l0eTogMC40O1xuICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIGxpbmVhciAuMDhzO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1iYXItY29sb3IsICMwMDAwMDApO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJhcjtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTNweDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgaGVpZ2h0OiAyMHB4O1xuICAgICAgICB3aWR0aDogMjBweDtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgICBib3gtc2hhZG93OiAwIDFweCA1cHggMCByZ2JhKDAsIDAsIDAsIDAuNik7XG4gICAgICAgIHRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIGxpbmVhciAuMDhzLCBiYWNrZ3JvdW5kLWNvbG9yIGxpbmVhciAuMDhzO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gbGluZWFyIC4wOHMsIGJhY2tncm91bmQtY29sb3IgbGluZWFyIC4wOHM7XG4gICAgICAgIHdpbGwtY2hhbmdlOiB0cmFuc2Zvcm07XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJ1dHRvbi1jb2xvciwgdmFyKC0tcGFwZXItZ3JleS01MCkpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1idXR0b24uZHJhZ2dpbmcge1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IG5vbmU7XG4gICAgICAgIHRyYW5zaXRpb246IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXTpub3QoW2Rpc2FibGVkXSkpIC50b2dnbGUtYmFyIHtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtYmFyLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWJhcjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgLnRvZ2dsZS1iYXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjMDAwO1xuICAgICAgICBvcGFjaXR5OiAwLjEyO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbY2hlY2tlZF0pIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZSgxNnB4LCAwKTtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoMTZweCwgMCk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXTpub3QoW2Rpc2FibGVkXSkpIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWJ1dHRvbi1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1idXR0b247XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2JkYmRiZDtcbiAgICAgICAgb3BhY2l0eTogMTtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1pbmsge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogLTE0cHg7XG4gICAgICAgIGxlZnQ6IC0xNHB4O1xuICAgICAgICByaWdodDogYXV0bztcbiAgICAgICAgYm90dG9tOiBhdXRvO1xuICAgICAgICB3aWR0aDogNDhweDtcbiAgICAgICAgaGVpZ2h0OiA0OHB4O1xuICAgICAgICBvcGFjaXR5OiAwLjU7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtaW5rLWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1pbms7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXSkgLnRvZ2dsZS1pbmsge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWluay1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1pbms7XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtY29udGFpbmVyIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIHdpZHRoOiAzNnB4O1xuICAgICAgICBoZWlnaHQ6IDE0cHg7XG4gICAgICAgIC8qIFRoZSB0b2dnbGUgYnV0dG9uIGhhcyBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvZiAtM3B4OyBUaGUgZXh0cmEgMXB4XG4gICAgICAgIC8qIGFjY291bnRzIGZvciB0aGUgdG9nZ2xlIGJ1dHRvbiBzaGFkb3cgYm94LiAqL1xuICAgICAgICBtYXJnaW46IDRweCAxcHg7XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtbGFiZWwge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgdmVydGljYWwtYWxpZ246IG1pZGRsZTtcbiAgICAgICAgcGFkZGluZy1sZWZ0OiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWxhYmVsLXNwYWNpbmcsIDhweCk7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1sYWJlbC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIC8qIGludmFsaWQgc3RhdGUgKi9cbiAgICAgIDpob3N0KFtpbnZhbGlkXSkgLnRvZ2dsZS1iYXIge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWludmFsaWQtYmFyLWNvbG9yLCB2YXIoLS1lcnJvci1jb2xvcikpO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaW52YWxpZF0pIC50b2dnbGUtYnV0dG9uIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1pbnZhbGlkLWJ1dHRvbi1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2ludmFsaWRdKSAudG9nZ2xlLWluayB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWludmFsaWQtaW5rLWNvbG9yLCB2YXIoLS1lcnJvci1jb2xvcikpO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG5cbiAgICA8ZGl2IGNsYXNzPVwidG9nZ2xlLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBpZD1cInRvZ2dsZUJhclwiIGNsYXNzPVwidG9nZ2xlLWJhclwiPjwvZGl2PlxuICAgICAgPGRpdiBpZD1cInRvZ2dsZUJ1dHRvblwiIGNsYXNzPVwidG9nZ2xlLWJ1dHRvblwiPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cInRvZ2dsZS1sYWJlbFwiPjxzbG90Pjwvc2xvdD48L2Rpdj5cblxuICA8L3RlbXBsYXRlPlxuXG4gIFxuPC9kb20tbW9kdWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5Qb2x5bWVyKHtcbiAgaXM6ICdwYXBlci10b2dnbGUtYnV0dG9uJyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3JcbiAgXSxcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgIHJvbGU6ICdidXR0b24nLFxuICAgICdhcmlhLXByZXNzZWQnOiAnZmFsc2UnLFxuICAgIHRhYmluZGV4OiAwXG4gIH0sXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgY2hhbmdlcyBkdWUgdG8gdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBldmVudCBjaGFuZ2VcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1jaGFuZ2VcbiAgICAgKi9cbiAgfSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICB0cmFjazogJ19vbnRyYWNrJ1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICBhZnRlck5leHRSZW5kZXIodGhpcywgZnVuY3Rpb24oKSB7XG4gICAgICBzZXRUb3VjaEFjdGlvbih0aGlzLCAncGFuLXknKTtcbiAgICB9KTtcbiAgfSxcblxuICBfb250cmFjazogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgdHJhY2sgPSBldmVudC5kZXRhaWw7XG4gICAgaWYgKHRyYWNrLnN0YXRlID09PSAnc3RhcnQnKSB7XG4gICAgICB0aGlzLl90cmFja1N0YXJ0KHRyYWNrKTtcbiAgICB9IGVsc2UgaWYgKHRyYWNrLnN0YXRlID09PSAndHJhY2snKSB7XG4gICAgICB0aGlzLl90cmFja01vdmUodHJhY2spO1xuICAgIH0gZWxzZSBpZiAodHJhY2suc3RhdGUgPT09ICdlbmQnKSB7XG4gICAgICB0aGlzLl90cmFja0VuZCh0cmFjayk7XG4gICAgfVxuICB9LFxuXG4gIF90cmFja1N0YXJ0OiBmdW5jdGlvbih0cmFjaykge1xuICAgIHRoaXMuX3dpZHRoID0gdGhpcy4kLnRvZ2dsZUJhci5vZmZzZXRXaWR0aCAvIDI7XG4gICAgLypcbiAgICAgKiBrZWVwIGFuIHRyYWNrLW9ubHkgY2hlY2sgc3RhdGUgdG8ga2VlcCB0aGUgZHJhZ2dpbmcgYmVoYXZpb3Igc21vb3RoXG4gICAgICogd2hpbGUgdG9nZ2xpbmcgYWN0aXZhdGlvbnNcbiAgICAgKi9cbiAgICB0aGlzLl90cmFja0NoZWNrZWQgPSB0aGlzLmNoZWNrZWQ7XG4gICAgdGhpcy4kLnRvZ2dsZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdkcmFnZ2luZycpO1xuICB9LFxuXG4gIF90cmFja01vdmU6IGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgdmFyIGR4ID0gdHJhY2suZHg7XG4gICAgdGhpcy5feCA9IE1hdGgubWluKHRoaXMuX3dpZHRoLFxuICAgICAgICBNYXRoLm1heCgwLCB0aGlzLl90cmFja0NoZWNrZWQgPyB0aGlzLl93aWR0aCArIGR4IDogZHgpKTtcbiAgICB0aGlzLnRyYW5zbGF0ZTNkKHRoaXMuX3ggKyAncHgnLCAwLCAwLCB0aGlzLiQudG9nZ2xlQnV0dG9uKTtcbiAgICB0aGlzLl91c2VyQWN0aXZhdGUodGhpcy5feCA+ICh0aGlzLl93aWR0aCAvIDIpKTtcbiAgfSxcblxuICBfdHJhY2tFbmQ6IGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgdGhpcy4kLnRvZ2dsZUJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnZ2luZycpO1xuICAgIHRoaXMudHJhbnNmb3JtKCcnLCB0aGlzLiQudG9nZ2xlQnV0dG9uKTtcbiAgfSxcblxuICAvLyBjdXN0b21pemUgdGhlIGVsZW1lbnQncyByaXBwbGVcbiAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmlwcGxlQ29udGFpbmVyID0gdGhpcy4kLnRvZ2dsZUJ1dHRvbjtcbiAgICB2YXIgcmlwcGxlID0gUGFwZXJSaXBwbGVCZWhhdmlvci5fY3JlYXRlUmlwcGxlKCk7XG4gICAgcmlwcGxlLmlkID0gJ2luayc7XG4gICAgcmlwcGxlLnNldEF0dHJpYnV0ZSgncmVjZW50ZXJzJywgJycpO1xuICAgIHJpcHBsZS5jbGFzc0xpc3QuYWRkKCdjaXJjbGUnLCAndG9nZ2xlLWluaycpO1xuICAgIHJldHVybiByaXBwbGU7XG4gIH1cblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci10b2dnbGUtYnV0dG9uL3BhcGVyLXRvZ2dsZS1idXR0b24uanNcbi8vIG1vZHVsZSBpZCA9IDk2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBXZWJDb21wb25lbnRzIGZyb20gJ0B3ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy93ZWJjb21wb25lbnRzLWxpdGUuanMnO1xuXG52YXIgZ2V0QnJlYWtwb2ludCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHdpbmRvdy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdib2R5JyksICc6YmVmb3JlJykuZ2V0UHJvcGVydHlWYWx1ZSgnY29udGVudCcpLnJlcGxhY2UoL1wiL2csICcnKTtcbn07XG5cbmZ1bmN0aW9uIGJyZWFrcG9pbnQoYnJlYWtwb2ludCwgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgaWYgKGdldEJyZWFrcG9pbnQoKSA9PT0gYnJlYWtwb2ludCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gICAgJCh3aW5kb3cpLnJlc2l6ZShmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZ2V0QnJlYWtwb2ludCgpID09PSBicmVha3BvaW50KSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGdldEJyZWFrcG9pbnQoKSA9PT0gYnJlYWtwb2ludDtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNrdG9wKGNhbGxiYWNrKSB7XG4gIHJldHVybiBicmVha3BvaW50KFwiZGVza3RvcFwiLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHRhYmxldChjYWxsYmFjaykge1xuICByZXR1cm4gYnJlYWtwb2ludChcInRhYmxldFwiLCBjYWxsYmFjayk7XG59XG5cbmZ1bmN0aW9uIHBob25lKGNhbGxiYWNrKSB7XG4gIHJldHVybiBicmVha3BvaW50KFwicGhvbmVcIiwgY2FsbGJhY2spO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vZ2xvYmFsL2NsaWVudC5qcyIsIihmdW5jdGlvbigpey8qXG5cbiBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG4ndXNlIHN0cmljdCc7dmFyIHAscT1cInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3c9PT10aGlzP3RoaXM6XCJ1bmRlZmluZWRcIiE9dHlwZW9mIGdsb2JhbCYmbnVsbCE9Z2xvYmFsP2dsb2JhbDp0aGlzLGJhPVwiZnVuY3Rpb25cIj09dHlwZW9mIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzP09iamVjdC5kZWZpbmVQcm9wZXJ0eTpmdW5jdGlvbihhLGIsYyl7YSE9QXJyYXkucHJvdG90eXBlJiZhIT1PYmplY3QucHJvdG90eXBlJiYoYVtiXT1jLnZhbHVlKX07ZnVuY3Rpb24gY2EoKXtjYT1mdW5jdGlvbigpe307cS5TeW1ib2x8fChxLlN5bWJvbD1kYSl9dmFyIGRhPWZ1bmN0aW9uKCl7dmFyIGE9MDtyZXR1cm4gZnVuY3Rpb24oYil7cmV0dXJuXCJqc2NvbXBfc3ltYm9sX1wiKyhifHxcIlwiKSthKyt9fSgpO1xuZnVuY3Rpb24gZWEoKXtjYSgpO3ZhciBhPXEuU3ltYm9sLml0ZXJhdG9yO2F8fChhPXEuU3ltYm9sLml0ZXJhdG9yPXEuU3ltYm9sKFwiaXRlcmF0b3JcIikpO1wiZnVuY3Rpb25cIiE9dHlwZW9mIEFycmF5LnByb3RvdHlwZVthXSYmYmEoQXJyYXkucHJvdG90eXBlLGEse2NvbmZpZ3VyYWJsZTohMCx3cml0YWJsZTohMCx2YWx1ZTpmdW5jdGlvbigpe3JldHVybiBmYSh0aGlzKX19KTtlYT1mdW5jdGlvbigpe319ZnVuY3Rpb24gZmEoYSl7dmFyIGI9MDtyZXR1cm4gaGEoZnVuY3Rpb24oKXtyZXR1cm4gYjxhLmxlbmd0aD97ZG9uZTohMSx2YWx1ZTphW2IrK119Ontkb25lOiEwfX0pfWZ1bmN0aW9uIGhhKGEpe2VhKCk7YT17bmV4dDphfTthW3EuU3ltYm9sLml0ZXJhdG9yXT1mdW5jdGlvbigpe3JldHVybiB0aGlzfTtyZXR1cm4gYX1mdW5jdGlvbiBpYShhKXtlYSgpO3ZhciBiPWFbU3ltYm9sLml0ZXJhdG9yXTtyZXR1cm4gYj9iLmNhbGwoYSk6ZmEoYSl9XG5mdW5jdGlvbiBqYShhKXtmb3IodmFyIGIsYz1bXTshKGI9YS5uZXh0KCkpLmRvbmU7KWMucHVzaChiLnZhbHVlKTtyZXR1cm4gY31cbihmdW5jdGlvbigpe2lmKCFmdW5jdGlvbigpe3ZhciBhPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7YS5pbml0RXZlbnQoXCJmb29cIiwhMCwhMCk7YS5wcmV2ZW50RGVmYXVsdCgpO3JldHVybiBhLmRlZmF1bHRQcmV2ZW50ZWR9KCkpe3ZhciBhPUV2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdDtFdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQ9ZnVuY3Rpb24oKXt0aGlzLmNhbmNlbGFibGUmJihhLmNhbGwodGhpcyksT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsXCJkZWZhdWx0UHJldmVudGVkXCIse2dldDpmdW5jdGlvbigpe3JldHVybiEwfSxjb25maWd1cmFibGU6ITB9KSl9fXZhciBiPS9UcmlkZW50Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO2lmKCF3aW5kb3cuQ3VzdG9tRXZlbnR8fGImJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQpd2luZG93LkN1c3RvbUV2ZW50PWZ1bmN0aW9uKGEsYil7Yj1ifHx7fTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFdmVudChcIkN1c3RvbUV2ZW50XCIpO1xuYy5pbml0Q3VzdG9tRXZlbnQoYSwhIWIuYnViYmxlcywhIWIuY2FuY2VsYWJsZSxiLmRldGFpbCk7cmV0dXJuIGN9LHdpbmRvdy5DdXN0b21FdmVudC5wcm90b3R5cGU9d2luZG93LkV2ZW50LnByb3RvdHlwZTtpZighd2luZG93LkV2ZW50fHxiJiZcImZ1bmN0aW9uXCIhPT10eXBlb2Ygd2luZG93LkV2ZW50KXt2YXIgYz13aW5kb3cuRXZlbnQ7d2luZG93LkV2ZW50PWZ1bmN0aW9uKGEsYil7Yj1ifHx7fTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFdmVudChcIkV2ZW50XCIpO2MuaW5pdEV2ZW50KGEsISFiLmJ1YmJsZXMsISFiLmNhbmNlbGFibGUpO3JldHVybiBjfTtpZihjKWZvcih2YXIgZCBpbiBjKXdpbmRvdy5FdmVudFtkXT1jW2RdO3dpbmRvdy5FdmVudC5wcm90b3R5cGU9Yy5wcm90b3R5cGV9aWYoIXdpbmRvdy5Nb3VzZUV2ZW50fHxiJiZcImZ1bmN0aW9uXCIhPT10eXBlb2Ygd2luZG93Lk1vdXNlRXZlbnQpe2I9d2luZG93Lk1vdXNlRXZlbnQ7d2luZG93Lk1vdXNlRXZlbnQ9ZnVuY3Rpb24oYSxcbmIpe2I9Ynx8e307dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJNb3VzZUV2ZW50XCIpO2MuaW5pdE1vdXNlRXZlbnQoYSwhIWIuYnViYmxlcywhIWIuY2FuY2VsYWJsZSxiLnZpZXd8fHdpbmRvdyxiLmRldGFpbCxiLnNjcmVlblgsYi5zY3JlZW5ZLGIuY2xpZW50WCxiLmNsaWVudFksYi5jdHJsS2V5LGIuYWx0S2V5LGIuc2hpZnRLZXksYi5tZXRhS2V5LGIuYnV0dG9uLGIucmVsYXRlZFRhcmdldCk7cmV0dXJuIGN9O2lmKGIpZm9yKGQgaW4gYil3aW5kb3cuTW91c2VFdmVudFtkXT1iW2RdO3dpbmRvdy5Nb3VzZUV2ZW50LnByb3RvdHlwZT1iLnByb3RvdHlwZX1BcnJheS5mcm9tfHwoQXJyYXkuZnJvbT1mdW5jdGlvbihhKXtyZXR1cm5bXS5zbGljZS5jYWxsKGEpfSk7T2JqZWN0LmFzc2lnbnx8KE9iamVjdC5hc3NpZ249ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9W10uc2xpY2UuY2FsbChhcmd1bWVudHMsMSksZD0wLGU7ZDxjLmxlbmd0aDtkKyspaWYoZT1jW2RdKWZvcih2YXIgZj1cbmEsbT1lLG49T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobSksdz0wO3c8bi5sZW5ndGg7dysrKWU9blt3XSxmW2VdPW1bZV07cmV0dXJuIGF9KX0pKHdpbmRvdy5XZWJDb21wb25lbnRzKTsoZnVuY3Rpb24oKXtmdW5jdGlvbiBhKCl7fWZ1bmN0aW9uIGIoYSxiKXtzd2l0Y2goYS5ub2RlVHlwZSl7Y2FzZSBOb2RlLkRPQ1VNRU5UX05PREU6cmV0dXJuIHcuY2FsbChhLGIpO2Nhc2UgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFOnJldHVybiBJLmNhbGwoYSxiKTtkZWZhdWx0OnJldHVybiBuLmNhbGwoYSxiKX19dmFyIGM9XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBIVE1MVGVtcGxhdGVFbGVtZW50LGQ9IShkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCkuY2xvbmVOb2RlKClpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpLGU9ITE7L1RyaWRlbnQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkmJmZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShhLGIpe2lmKGEgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KWZvcih2YXIgZDtkPWEuZmlyc3RDaGlsZDspYy5jYWxsKHRoaXMsZCxiKTtlbHNlIGMuY2FsbCh0aGlzLGEsYik7cmV0dXJuIGF9ZT0hMDt2YXIgYj1Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGU7XG5Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGU9ZnVuY3Rpb24oYSl7YT1iLmNhbGwodGhpcyxhKTt0aGlzIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCYmKGEuX19wcm90b19fPURvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlKTtyZXR1cm4gYX07RG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbD1IVE1MRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbDtEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yPUhUTUxFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLHtub2RlVHlwZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERX0sY29uZmlndXJhYmxlOiEwfSxsb2NhbE5hbWU6e2dldDpmdW5jdGlvbigpe30sY29uZmlndXJhYmxlOiEwfSxub2RlTmFtZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCIjZG9jdW1lbnQtZnJhZ21lbnRcIn0sXG5jb25maWd1cmFibGU6ITB9fSk7dmFyIGM9Tm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlO05vZGUucHJvdG90eXBlLmluc2VydEJlZm9yZT1hO3ZhciBkPU5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkO05vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkPWZ1bmN0aW9uKGIpe2IgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50P2EuY2FsbCh0aGlzLGIsbnVsbCk6ZC5jYWxsKHRoaXMsYik7cmV0dXJuIGJ9O3ZhciBmPU5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkLGg9Tm9kZS5wcm90b3R5cGUucmVwbGFjZUNoaWxkO05vZGUucHJvdG90eXBlLnJlcGxhY2VDaGlsZD1mdW5jdGlvbihiLGMpe2IgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50PyhhLmNhbGwodGhpcyxiLGMpLGYuY2FsbCh0aGlzLGMpKTpoLmNhbGwodGhpcyxiLGMpO3JldHVybiBjfTtEb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRG9jdW1lbnRGcmFnbWVudD1mdW5jdGlvbigpe3ZhciBhPXRoaXMuY3JlYXRlRWxlbWVudChcImRmXCIpO1xuYS5fX3Byb3RvX189RG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGU7cmV0dXJuIGF9O3ZhciBnPURvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlO0RvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlPWZ1bmN0aW9uKGEsYil7Yj1nLmNhbGwodGhpcyxhLGJ8fCExKTthIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCYmKGIuX19wcm90b19fPURvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlKTtyZXR1cm4gYn19KCk7dmFyIGY9Tm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlLGg9RG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQsZz1Eb2N1bWVudC5wcm90b3R5cGUuaW1wb3J0Tm9kZSxrPU5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkLGw9Tm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQsbT1Ob2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQsbj1FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLHc9RG9jdW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwsST1Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLFxuWmE9ZnVuY3Rpb24oKXtpZighYyl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpLGI9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRlbXBsYXRlXCIpO2IuY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpKTthLmNvbnRlbnQuYXBwZW5kQ2hpbGQoYik7YT1hLmNsb25lTm9kZSghMCk7cmV0dXJuIDA9PT1hLmNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGh8fDA9PT1hLmNvbnRlbnQuZmlyc3RDaGlsZC5jb250ZW50LmNoaWxkTm9kZXMubGVuZ3RofHxkfX0oKTtpZihjKXt2YXIgdD1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJ0ZW1wbGF0ZVwiKSxuYT0hMCxhYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7YWEudGV4dENvbnRlbnQ9XCJ0ZW1wbGF0ZXtkaXNwbGF5Om5vbmU7fVwiO3ZhciBUPWRvY3VtZW50LmhlYWQ7VC5pbnNlcnRCZWZvcmUoYWEsVC5maXJzdEVsZW1lbnRDaGlsZCk7XG5hLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKEhUTUxFbGVtZW50LnByb3RvdHlwZSk7dmFyIFU9IWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuaGFzT3duUHJvcGVydHkoXCJpbm5lckhUTUxcIik7YS5EPWZ1bmN0aW9uKGIpe2lmKCFiLmNvbnRlbnQpe2IuY29udGVudD10LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtmb3IodmFyIGM7Yz1iLmZpcnN0Q2hpbGQ7KWwuY2FsbChiLmNvbnRlbnQsYyk7aWYoVSliLl9fcHJvdG9fXz1hLnByb3RvdHlwZTtlbHNlIGlmKGIuY2xvbmVOb2RlPWZ1bmN0aW9uKGIpe3JldHVybiBhLmEodGhpcyxiKX0sbmEpdHJ5e25jKGIpLG9jKGIpfWNhdGNoKE5nKXtuYT0hMX1hLkooYi5jb250ZW50KX19O3ZhciBuYz1mdW5jdGlvbihiKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcImlubmVySFRNTFwiLHtnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGE9XCJcIixiPXRoaXMuY29udGVudC5maXJzdENoaWxkO2I7Yj1iLm5leHRTaWJsaW5nKWErPWIub3V0ZXJIVE1MfHxcbmIuZGF0YS5yZXBsYWNlKEdlLHBjKTtyZXR1cm4gYX0sc2V0OmZ1bmN0aW9uKGIpe3QuYm9keS5pbm5lckhUTUw9Yjtmb3IoYS5KKHQpO3RoaXMuY29udGVudC5maXJzdENoaWxkOylrLmNhbGwodGhpcy5jb250ZW50LHRoaXMuY29udGVudC5maXJzdENoaWxkKTtmb3IoO3QuYm9keS5maXJzdENoaWxkOylsLmNhbGwodGhpcy5jb250ZW50LHQuYm9keS5maXJzdENoaWxkKX0sY29uZmlndXJhYmxlOiEwfSl9LG9jPWZ1bmN0aW9uKGEpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLFwib3V0ZXJIVE1MXCIse2dldDpmdW5jdGlvbigpe3JldHVyblwiPHRlbXBsYXRlPlwiK3RoaXMuaW5uZXJIVE1MK1wiPC90ZW1wbGF0ZT5cIn0sc2V0OmZ1bmN0aW9uKGEpe2lmKHRoaXMucGFyZW50Tm9kZSl7dC5ib2R5LmlubmVySFRNTD1hO2ZvcihhPXRoaXMub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7dC5ib2R5LmZpcnN0Q2hpbGQ7KWwuY2FsbChhLHQuYm9keS5maXJzdENoaWxkKTttLmNhbGwodGhpcy5wYXJlbnROb2RlLFxuYSx0aGlzKX1lbHNlIHRocm93IEVycm9yKFwiRmFpbGVkIHRvIHNldCB0aGUgJ291dGVySFRNTCcgcHJvcGVydHkgb24gJ0VsZW1lbnQnOiBUaGlzIGVsZW1lbnQgaGFzIG5vIHBhcmVudCBub2RlLlwiKTt9LGNvbmZpZ3VyYWJsZTohMH0pfTtuYyhhLnByb3RvdHlwZSk7b2MoYS5wcm90b3R5cGUpO2EuSj1mdW5jdGlvbihjKXtjPWIoYyxcInRlbXBsYXRlXCIpO2Zvcih2YXIgZD0wLGU9Yy5sZW5ndGgsZjtkPGUmJihmPWNbZF0pO2QrKylhLkQoZil9O2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJET01Db250ZW50TG9hZGVkXCIsZnVuY3Rpb24oKXthLkooZG9jdW1lbnQpfSk7RG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQ9ZnVuY3Rpb24oKXt2YXIgYj1oLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcInRlbXBsYXRlXCI9PT1iLmxvY2FsTmFtZSYmYS5EKGIpO3JldHVybiBifTt2YXIgR2U9L1smXFx1MDBBMDw+XS9nLHBjPWZ1bmN0aW9uKGEpe3N3aXRjaChhKXtjYXNlIFwiJlwiOnJldHVyblwiJmFtcDtcIjtcbmNhc2UgXCI8XCI6cmV0dXJuXCImbHQ7XCI7Y2FzZSBcIj5cIjpyZXR1cm5cIiZndDtcIjtjYXNlIFwiXFx1MDBhMFwiOnJldHVyblwiJm5ic3A7XCJ9fX1pZihjfHxaYSl7YS5hPWZ1bmN0aW9uKGEsYil7dmFyIGM9Zi5jYWxsKGEsITEpO3RoaXMuRCYmdGhpcy5EKGMpO2ImJihsLmNhbGwoYy5jb250ZW50LGYuY2FsbChhLmNvbnRlbnQsITApKSwkYShjLmNvbnRlbnQsYS5jb250ZW50KSk7cmV0dXJuIGN9O3ZhciAkYT1mdW5jdGlvbihjLGQpe2lmKGQucXVlcnlTZWxlY3RvckFsbCYmKGQ9YihkLFwidGVtcGxhdGVcIiksMCE9PWQubGVuZ3RoKSl7Yz1iKGMsXCJ0ZW1wbGF0ZVwiKTtmb3IodmFyIGU9MCxmPWMubGVuZ3RoLGgsZztlPGY7ZSsrKWc9ZFtlXSxoPWNbZV0sYSYmYS5EJiZhLkQoZyksbS5jYWxsKGgucGFyZW50Tm9kZSxIZS5jYWxsKGcsITApLGgpfX0sSGU9Tm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlPWZ1bmN0aW9uKGIpe2lmKCFlJiZkJiZ0aGlzIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudClpZihiKXZhciBjPVxuSWUuY2FsbCh0aGlzLm93bmVyRG9jdW1lbnQsdGhpcywhMCk7ZWxzZSByZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtlbHNlIHRoaXMubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmXCJ0ZW1wbGF0ZVwiPT09dGhpcy5sb2NhbE5hbWU/Yz1hLmEodGhpcyxiKTpjPWYuY2FsbCh0aGlzLGIpO2ImJiRhKGMsdGhpcyk7cmV0dXJuIGN9LEllPURvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlPWZ1bmN0aW9uKGIsYyl7Yz1jfHwhMTtpZihcInRlbXBsYXRlXCI9PT1iLmxvY2FsTmFtZSlyZXR1cm4gYS5hKGIsYyk7dmFyIGQ9Zy5jYWxsKHRoaXMsYixjKTtjJiYkYShkLGIpO3JldHVybiBkfX1jJiYod2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQ9YSl9KSgpO3ZhciBrYTtBcnJheS5pc0FycmF5P2thPUFycmF5LmlzQXJyYXk6a2E9ZnVuY3Rpb24oYSl7cmV0dXJuXCJbb2JqZWN0IEFycmF5XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGEpfTt2YXIgbGE9a2E7dmFyIG1hPTAsb2EscGE9XCJ1bmRlZmluZWRcIiE9PXR5cGVvZiB3aW5kb3c/d2luZG93OnZvaWQgMCxxYT1wYXx8e30scmE9cWEuTXV0YXRpb25PYnNlcnZlcnx8cWEuV2ViS2l0TXV0YXRpb25PYnNlcnZlcixzYT1cInVuZGVmaW5lZFwiIT09dHlwZW9mIFVpbnQ4Q2xhbXBlZEFycmF5JiZcInVuZGVmaW5lZFwiIT09dHlwZW9mIGltcG9ydFNjcmlwdHMmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgTWVzc2FnZUNoYW5uZWw7ZnVuY3Rpb24gdGEoKXtyZXR1cm5cInVuZGVmaW5lZFwiIT09dHlwZW9mIG9hP2Z1bmN0aW9uKCl7b2EodWEpfTp2YSgpfWZ1bmN0aW9uIHdhKCl7dmFyIGE9MCxiPW5ldyByYSh1YSksYz1kb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcIlwiKTtiLm9ic2VydmUoYyx7Y2hhcmFjdGVyRGF0YTohMH0pO3JldHVybiBmdW5jdGlvbigpe2MuZGF0YT1hPSsrYSUyfX1cbmZ1bmN0aW9uIHhhKCl7dmFyIGE9bmV3IE1lc3NhZ2VDaGFubmVsO2EucG9ydDEub25tZXNzYWdlPXVhO3JldHVybiBmdW5jdGlvbigpe3JldHVybiBhLnBvcnQyLnBvc3RNZXNzYWdlKDApfX1mdW5jdGlvbiB2YSgpe3ZhciBhPXNldFRpbWVvdXQ7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEodWEsMSl9fXZhciB5YT1BcnJheSgxRTMpO2Z1bmN0aW9uIHVhKCl7Zm9yKHZhciBhPTA7YTxtYTthKz0yKSgwLHlhW2FdKSh5YVthKzFdKSx5YVthXT12b2lkIDAseWFbYSsxXT12b2lkIDA7bWE9MH12YXIgemEsQWE7XG5pZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIHNlbGYmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgcHJvY2VzcyYmXCJbb2JqZWN0IHByb2Nlc3NdXCI9PT17fS50b1N0cmluZy5jYWxsKHByb2Nlc3MpKUFhPWZ1bmN0aW9uKCl7cmV0dXJuIHByb2Nlc3MuamIodWEpfTtlbHNle3ZhciBCYTtpZihyYSlCYT13YSgpO2Vsc2V7dmFyIENhO2lmKHNhKUNhPXhhKCk7ZWxzZXt2YXIgRGE7aWYodm9pZCAwPT09cGEmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiByZXF1aXJlKXRyeXt2YXIgRWE9cmVxdWlyZShcInZlcnR4XCIpO29hPUVhLmxifHxFYS5rYjtEYT10YSgpfWNhdGNoKGEpe0RhPXZhKCl9ZWxzZSBEYT12YSgpO0NhPURhfUJhPUNhfUFhPUJhfXphPUFhO2Z1bmN0aW9uIEZhKGEsYil7eWFbbWFdPWE7eWFbbWErMV09YjttYSs9MjsyPT09bWEmJnphKCl9O2Z1bmN0aW9uIEdhKGEsYil7dmFyIGM9dGhpcyxkPW5ldyB0aGlzLmNvbnN0cnVjdG9yKEhhKTt2b2lkIDA9PT1kW0lhXSYmSmEoZCk7dmFyIGU9Yy5nO2lmKGUpe3ZhciBmPWFyZ3VtZW50c1tlLTFdO0ZhKGZ1bmN0aW9uKCl7cmV0dXJuIEthKGUsZCxmLGMuZil9KX1lbHNlIExhKGMsZCxhLGIpO3JldHVybiBkfTtmdW5jdGlvbiBNYShhKXtpZihhJiZcIm9iamVjdFwiPT09dHlwZW9mIGEmJmEuY29uc3RydWN0b3I9PT10aGlzKXJldHVybiBhO3ZhciBiPW5ldyB0aGlzKEhhKTtOYShiLGEpO3JldHVybiBifTt2YXIgSWE9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc3Vic3RyaW5nKDE2KTtmdW5jdGlvbiBIYSgpe312YXIgUGE9bmV3IE9hO2Z1bmN0aW9uIFFhKGEpe3RyeXtyZXR1cm4gYS50aGVufWNhdGNoKGIpe3JldHVybiBQYS5lcnJvcj1iLFBhfX1mdW5jdGlvbiBSYShhLGIsYyxkKXt0cnl7YS5jYWxsKGIsYyxkKX1jYXRjaChlKXtyZXR1cm4gZX19ZnVuY3Rpb24gU2EoYSxiLGMpe0ZhKGZ1bmN0aW9uKGEpe3ZhciBkPSExLGY9UmEoYyxiLGZ1bmN0aW9uKGMpe2R8fChkPSEwLGIhPT1jP05hKGEsYyk6cihhLGMpKX0sZnVuY3Rpb24oYil7ZHx8KGQ9ITAsdShhLGIpKX0pOyFkJiZmJiYoZD0hMCx1KGEsZikpfSxhKX1mdW5jdGlvbiBUYShhLGIpezE9PT1iLmc/cihhLGIuZik6Mj09PWIuZz91KGEsYi5mKTpMYShiLHZvaWQgMCxmdW5jdGlvbihiKXtyZXR1cm4gTmEoYSxiKX0sZnVuY3Rpb24oYil7cmV0dXJuIHUoYSxiKX0pfVxuZnVuY3Rpb24gVWEoYSxiLGMpe2IuY29uc3RydWN0b3I9PT1hLmNvbnN0cnVjdG9yJiZjPT09R2EmJmIuY29uc3RydWN0b3IucmVzb2x2ZT09PU1hP1RhKGEsYik6Yz09PVBhPyh1KGEsUGEuZXJyb3IpLFBhLmVycm9yPW51bGwpOnZvaWQgMD09PWM/cihhLGIpOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjP1NhKGEsYixjKTpyKGEsYil9ZnVuY3Rpb24gTmEoYSxiKXtpZihhPT09Yil1KGEsbmV3IFR5cGVFcnJvcihcIllvdSBjYW5ub3QgcmVzb2x2ZSBhIHByb21pc2Ugd2l0aCBpdHNlbGZcIikpO2Vsc2V7dmFyIGM9dHlwZW9mIGI7bnVsbD09PWJ8fFwib2JqZWN0XCIhPT1jJiZcImZ1bmN0aW9uXCIhPT1jP3IoYSxiKTpVYShhLGIsUWEoYikpfX1mdW5jdGlvbiBWYShhKXthLnBhJiZhLnBhKGEuZik7V2EoYSl9ZnVuY3Rpb24gcihhLGIpe3ZvaWQgMD09PWEuZyYmKGEuZj1iLGEuZz0xLDAhPT1hLkkubGVuZ3RoJiZGYShXYSxhKSl9XG5mdW5jdGlvbiB1KGEsYil7dm9pZCAwPT09YS5nJiYoYS5nPTIsYS5mPWIsRmEoVmEsYSkpfWZ1bmN0aW9uIExhKGEsYixjLGQpe3ZhciBlPWEuSSxmPWUubGVuZ3RoO2EucGE9bnVsbDtlW2ZdPWI7ZVtmKzFdPWM7ZVtmKzJdPWQ7MD09PWYmJmEuZyYmRmEoV2EsYSl9ZnVuY3Rpb24gV2EoYSl7dmFyIGI9YS5JLGM9YS5nO2lmKDAhPT1iLmxlbmd0aCl7Zm9yKHZhciBkLGUsZj1hLmYsaD0wO2g8Yi5sZW5ndGg7aCs9MylkPWJbaF0sZT1iW2grY10sZD9LYShjLGQsZSxmKTplKGYpO2EuSS5sZW5ndGg9MH19ZnVuY3Rpb24gT2EoKXt0aGlzLmVycm9yPW51bGx9dmFyIFhhPW5ldyBPYTtcbmZ1bmN0aW9uIEthKGEsYixjLGQpe3ZhciBlPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBjO2lmKGUpe3RyeXt2YXIgZj1jKGQpfWNhdGNoKGwpe1hhLmVycm9yPWwsZj1YYX1pZihmPT09WGEpe3ZhciBoPSEwO3ZhciBnPWYuZXJyb3I7Zi5lcnJvcj1udWxsfWVsc2UgdmFyIGs9ITA7aWYoYj09PWYpe3UoYixuZXcgVHlwZUVycm9yKFwiQSBwcm9taXNlcyBjYWxsYmFjayBjYW5ub3QgcmV0dXJuIHRoYXQgc2FtZSBwcm9taXNlLlwiKSk7cmV0dXJufX1lbHNlIGY9ZCxrPSEwO3ZvaWQgMD09PWIuZyYmKGUmJms/TmEoYixmKTpoP3UoYixnKToxPT09YT9yKGIsZik6Mj09PWEmJnUoYixmKSl9ZnVuY3Rpb24gWWEoYSxiKXt0cnl7YihmdW5jdGlvbihiKXtOYShhLGIpfSxmdW5jdGlvbihiKXt1KGEsYil9KX1jYXRjaChjKXt1KGEsYyl9fXZhciBhYj0wO2Z1bmN0aW9uIEphKGEpe2FbSWFdPWFiKys7YS5nPXZvaWQgMDthLmY9dm9pZCAwO2EuST1bXX07ZnVuY3Rpb24gYmIoYSxiKXt0aGlzLkdhPWE7dGhpcy5BPW5ldyBhKEhhKTt0aGlzLkFbSWFdfHxKYSh0aGlzLkEpO2lmKGxhKGIpKWlmKHRoaXMuUz10aGlzLmxlbmd0aD1iLmxlbmd0aCx0aGlzLmY9QXJyYXkodGhpcy5sZW5ndGgpLDA9PT10aGlzLmxlbmd0aClyKHRoaXMuQSx0aGlzLmYpO2Vsc2V7dGhpcy5sZW5ndGg9dGhpcy5sZW5ndGh8fDA7Zm9yKGE9MDt2b2lkIDA9PT10aGlzLmcmJmE8Yi5sZW5ndGg7YSsrKWNiKHRoaXMsYlthXSxhKTswPT09dGhpcy5TJiZyKHRoaXMuQSx0aGlzLmYpfWVsc2UgdSh0aGlzLkEsRXJyb3IoXCJBcnJheSBNZXRob2RzIG11c3QgYmUgcHJvdmlkZWQgYW4gQXJyYXlcIikpfVxuZnVuY3Rpb24gY2IoYSxiLGMpe3ZhciBkPWEuR2EsZT1kLnJlc29sdmU7ZT09PU1hPyhlPVFhKGIpLGU9PT1HYSYmdm9pZCAwIT09Yi5nP2RiKGEsYi5nLGMsYi5mKTpcImZ1bmN0aW9uXCIhPT10eXBlb2YgZT8oYS5TLS0sYS5mW2NdPWIpOmQ9PT12PyhkPW5ldyBkKEhhKSxVYShkLGIsZSksZWIoYSxkLGMpKTplYihhLG5ldyBkKGZ1bmN0aW9uKGEpe3JldHVybiBhKGIpfSksYykpOmViKGEsZShiKSxjKX1mdW5jdGlvbiBkYihhLGIsYyxkKXt2YXIgZT1hLkE7dm9pZCAwPT09ZS5nJiYoYS5TLS0sMj09PWI/dShlLGQpOmEuZltjXT1kKTswPT09YS5TJiZyKGUsYS5mKX1mdW5jdGlvbiBlYihhLGIsYyl7TGEoYix2b2lkIDAsZnVuY3Rpb24oYil7cmV0dXJuIGRiKGEsMSxjLGIpfSxmdW5jdGlvbihiKXtyZXR1cm4gZGIoYSwyLGMsYil9KX07ZnVuY3Rpb24gZmIoYSl7cmV0dXJuKG5ldyBiYih0aGlzLGEpKS5BfTtmdW5jdGlvbiBnYihhKXt2YXIgYj10aGlzO3JldHVybiBsYShhKT9uZXcgYihmdW5jdGlvbihjLGQpe2Zvcih2YXIgZT1hLmxlbmd0aCxmPTA7ZjxlO2YrKyliLnJlc29sdmUoYVtmXSkudGhlbihjLGQpfSk6bmV3IGIoZnVuY3Rpb24oYSxiKXtyZXR1cm4gYihuZXcgVHlwZUVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSB0byByYWNlLlwiKSl9KX07ZnVuY3Rpb24gaGIoYSl7dmFyIGI9bmV3IHRoaXMoSGEpO3UoYixhKTtyZXR1cm4gYn07ZnVuY3Rpb24gdihhKXt0aGlzW0lhXT1hYisrO3RoaXMuZj10aGlzLmc9dm9pZCAwO3RoaXMuST1bXTtpZihIYSE9PWEpe2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBhKXRocm93IG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGEgcmVzb2x2ZXIgZnVuY3Rpb24gYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBwcm9taXNlIGNvbnN0cnVjdG9yXCIpO2lmKHRoaXMgaW5zdGFuY2VvZiB2KVlhKHRoaXMsYSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnUHJvbWlzZSc6IFBsZWFzZSB1c2UgdGhlICduZXcnIG9wZXJhdG9yLCB0aGlzIG9iamVjdCBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGFzIGEgZnVuY3Rpb24uXCIpO319di5wcm90b3R5cGU9e2NvbnN0cnVjdG9yOnYsdGhlbjpHYSxhOmZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnRoZW4obnVsbCxhKX19Oy8qXG5cbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG53aW5kb3cuUHJvbWlzZXx8KHdpbmRvdy5Qcm9taXNlPXYsdi5wcm90b3R5cGVbXCJjYXRjaFwiXT12LnByb3RvdHlwZS5hLHYucHJvdG90eXBlLnRoZW49di5wcm90b3R5cGUudGhlbix2LmFsbD1mYix2LnJhY2U9Z2Isdi5yZXNvbHZlPU1hLHYucmVqZWN0PWhiKTsoZnVuY3Rpb24oYSl7ZnVuY3Rpb24gYihhLGIpe2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQpcmV0dXJuIG5ldyBDdXN0b21FdmVudChhLGIpO3ZhciBjPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7Yy5pbml0Q3VzdG9tRXZlbnQoYSwhIWIuYnViYmxlcywhIWIuY2FuY2VsYWJsZSxiLmRldGFpbCk7cmV0dXJuIGN9ZnVuY3Rpb24gYyhhKXtpZihtKXJldHVybiBhLm93bmVyRG9jdW1lbnQhPT1kb2N1bWVudD9hLm93bmVyRG9jdW1lbnQ6bnVsbDt2YXIgYj1hLl9faW1wb3J0RG9jO2lmKCFiJiZhLnBhcmVudE5vZGUpe2I9YS5wYXJlbnROb2RlO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBiLmNsb3Nlc3QpYj1iLmNsb3Nlc3QoXCJsaW5rW3JlbD1pbXBvcnRdXCIpO2Vsc2UgZm9yKDshZyhiKSYmKGI9Yi5wYXJlbnROb2RlKTspO2EuX19pbXBvcnREb2M9Yn1yZXR1cm4gYn1mdW5jdGlvbiBkKGEpe3ZhciBiPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3JlbD1pbXBvcnRdOm5vdChbaW1wb3J0LWRlcGVuZGVuY3ldKVwiKSxcbmM9Yi5sZW5ndGg7Yz9sKGIsZnVuY3Rpb24oYil7cmV0dXJuIGgoYixmdW5jdGlvbigpezA9PT0tLWMmJmEoKX0pfSk6YSgpfWZ1bmN0aW9uIGUoYSl7ZnVuY3Rpb24gYigpe1wibG9hZGluZ1wiIT09ZG9jdW1lbnQucmVhZHlTdGF0ZSYmZG9jdW1lbnQuYm9keSYmKGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsYiksYSgpKX1kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGIpO2IoKX1mdW5jdGlvbiBmKGEpe2UoZnVuY3Rpb24oKXtyZXR1cm4gZChmdW5jdGlvbigpe3JldHVybiBhJiZhKCl9KX0pfWZ1bmN0aW9uIGgoYSxiKXtpZihhLl9fbG9hZGVkKWImJmIoKTtlbHNlIGlmKFwic2NyaXB0XCI9PT1hLmxvY2FsTmFtZSYmIWEuc3JjfHxcInN0eWxlXCI9PT1hLmxvY2FsTmFtZSYmIWEuZmlyc3RDaGlsZClhLl9fbG9hZGVkPSEwLGImJmIoKTtlbHNle3ZhciBjPWZ1bmN0aW9uKGQpe2EucmVtb3ZlRXZlbnRMaXN0ZW5lcihkLnR5cGUsXG5jKTthLl9fbG9hZGVkPSEwO2ImJmIoKX07YS5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLGMpO2FhJiZcInN0eWxlXCI9PT1hLmxvY2FsTmFtZXx8YS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIixjKX19ZnVuY3Rpb24gZyhhKXtyZXR1cm4gYS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZcImxpbmtcIj09PWEubG9jYWxOYW1lJiZcImltcG9ydFwiPT09YS5yZWx9ZnVuY3Rpb24gaygpe3ZhciBhPXRoaXM7dGhpcy5hPXt9O3RoaXMuYj0wO3RoaXMuaD1uZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbihiKXtyZXR1cm4gYS5RYShiKX0pO3RoaXMuaC5vYnNlcnZlKGRvY3VtZW50LmhlYWQse2NoaWxkTGlzdDohMCxzdWJ0cmVlOiEwfSk7dGhpcy5jKGRvY3VtZW50KX1mdW5jdGlvbiBsKGEsYixjKXt2YXIgZD1hP2EubGVuZ3RoOjAsZT1jPy0xOjE7Zm9yKGM9Yz9kLTE6MDtjPGQmJjA8PWM7Yys9ZSliKGFbY10sYyl9dmFyIG09XCJpbXBvcnRcImluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaW5rXCIpLFxubj1udWxsOyExPT09XCJjdXJyZW50U2NyaXB0XCJpbiBkb2N1bWVudCYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LFwiY3VycmVudFNjcmlwdFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnx8KFwiY29tcGxldGVcIiE9PWRvY3VtZW50LnJlYWR5U3RhdGU/ZG9jdW1lbnQuc2NyaXB0c1tkb2N1bWVudC5zY3JpcHRzLmxlbmd0aC0xXTpudWxsKX0sY29uZmlndXJhYmxlOiEwfSk7dmFyIHc9Lyh1cmxcXCgpKFteKV0qKShcXCkpL2csST0vKEBpbXBvcnRbXFxzXSsoPyF1cmxcXCgpKShbXjtdKikoOykvZyxaYT0vKDxsaW5rW14+XSopKHJlbD1bJ3xcIl0/c3R5bGVzaGVldFsnfFwiXT9bXj5dKj4pL2csdD17S2E6ZnVuY3Rpb24oYSxiKXthLmhyZWYmJmEuc2V0QXR0cmlidXRlKFwiaHJlZlwiLHQuWShhLmdldEF0dHJpYnV0ZShcImhyZWZcIiksYikpO2Euc3JjJiZhLnNldEF0dHJpYnV0ZShcInNyY1wiLHQuWShhLmdldEF0dHJpYnV0ZShcInNyY1wiKSxiKSk7aWYoXCJzdHlsZVwiPT09YS5sb2NhbE5hbWUpe3ZhciBjPVxudC51YShhLnRleHRDb250ZW50LGIsdyk7YS50ZXh0Q29udGVudD10LnVhKGMsYixJKX19LHVhOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gYS5yZXBsYWNlKGMsZnVuY3Rpb24oYSxjLGQsZSl7YT1kLnJlcGxhY2UoL1tcIiddL2csXCJcIik7YiYmKGE9dC5ZKGEsYikpO3JldHVybiBjK1wiJ1wiK2ErXCInXCIrZX0pfSxZOmZ1bmN0aW9uKGEsYil7aWYodm9pZCAwPT09dC5jYSl7dC5jYT0hMTt0cnl7dmFyIGM9bmV3IFVSTChcImJcIixcImh0dHA6Ly9hXCIpO2MucGF0aG5hbWU9XCJjJTIwZFwiO3QuY2E9XCJodHRwOi8vYS9jJTIwZFwiPT09Yy5ocmVmfWNhdGNoKHBjKXt9fWlmKHQuY2EpcmV0dXJuKG5ldyBVUkwoYSxiKSkuaHJlZjtjPXQuRGE7Y3x8KGM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwidGVtcFwiKSx0LkRhPWMsYy5tYT1jLmNyZWF0ZUVsZW1lbnQoXCJiYXNlXCIpLGMuaGVhZC5hcHBlbmRDaGlsZChjLm1hKSxjLmxhPWMuY3JlYXRlRWxlbWVudChcImFcIikpO2MubWEuaHJlZj1cbmI7Yy5sYS5ocmVmPWE7cmV0dXJuIGMubGEuaHJlZnx8YX19LG5hPXthc3luYzohMCxsb2FkOmZ1bmN0aW9uKGEsYixjKXtpZihhKWlmKGEubWF0Y2goL15kYXRhOi8pKXthPWEuc3BsaXQoXCIsXCIpO3ZhciBkPWFbMV07ZD0tMTxhWzBdLmluZGV4T2YoXCI7YmFzZTY0XCIpP2F0b2IoZCk6ZGVjb2RlVVJJQ29tcG9uZW50KGQpO2IoZCl9ZWxzZXt2YXIgZT1uZXcgWE1MSHR0cFJlcXVlc3Q7ZS5vcGVuKFwiR0VUXCIsYSxuYS5hc3luYyk7ZS5vbmxvYWQ9ZnVuY3Rpb24oKXt2YXIgYT1lLnJlc3BvbnNlVVJMfHxlLmdldFJlc3BvbnNlSGVhZGVyKFwiTG9jYXRpb25cIik7YSYmMD09PWEuaW5kZXhPZihcIi9cIikmJihhPShsb2NhdGlvbi5vcmlnaW58fGxvY2F0aW9uLnByb3RvY29sK1wiLy9cIitsb2NhdGlvbi5ob3N0KSthKTt2YXIgZD1lLnJlc3BvbnNlfHxlLnJlc3BvbnNlVGV4dDszMDQ9PT1lLnN0YXR1c3x8MD09PWUuc3RhdHVzfHwyMDA8PWUuc3RhdHVzJiYzMDA+ZS5zdGF0dXM/YihkLGEpOmMoZCl9O1xuZS5zZW5kKCl9ZWxzZSBjKFwiZXJyb3I6IGhyZWYgbXVzdCBiZSBzcGVjaWZpZWRcIil9fSxhYT0vVHJpZGVudC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KXx8L0VkZ2VcXC9cXGQuL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtrLnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7YT1hLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3JlbD1pbXBvcnRdXCIpO2woYSxmdW5jdGlvbihhKXtyZXR1cm4gYi5MKGEpfSl9O2sucHJvdG90eXBlLkw9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpcyxjPWEuaHJlZjtpZih2b2lkIDAhPT10aGlzLmFbY10pe3ZhciBkPXRoaXMuYVtjXTtkJiZkLl9fbG9hZGVkJiYoYS5pbXBvcnQ9ZCx0aGlzLm8oYSkpfWVsc2UgdGhpcy5iKyssdGhpcy5hW2NdPVwicGVuZGluZ1wiLG5hLmxvYWQoYyxmdW5jdGlvbihhLGQpe2E9Yi5SYShhLGR8fGMpO2IuYVtjXT1hO2IuYi0tO2IuYyhhKTtiLnNhKCl9LGZ1bmN0aW9uKCl7Yi5hW2NdPW51bGw7Yi5iLS07Yi5zYSgpfSl9O1xuay5wcm90b3R5cGUuUmE9ZnVuY3Rpb24oYSxiKXtpZighYSlyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2FhJiYoYT1hLnJlcGxhY2UoWmEsZnVuY3Rpb24oYSxiLGMpe3JldHVybi0xPT09YS5pbmRleE9mKFwidHlwZT1cIik/YitcIiB0eXBlPWltcG9ydC1kaXNhYmxlIFwiK2M6YX0pKTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7Yy5pbm5lckhUTUw9YTtpZihjLmNvbnRlbnQpYT1jLmNvbnRlbnQ7ZWxzZSBmb3IoYT1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7Yy5maXJzdENoaWxkOylhLmFwcGVuZENoaWxkKGMuZmlyc3RDaGlsZCk7aWYoYz1hLnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpKWI9dC5ZKGMuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxiKSxjLnJlbW92ZUF0dHJpYnV0ZShcImhyZWZcIik7Yz1hLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbcmVsPWltcG9ydF0sIGxpbmtbcmVsPXN0eWxlc2hlZXRdW2hyZWZdW3R5cGU9aW1wb3J0LWRpc2FibGVdLFxcbiAgICBzdHlsZTpub3QoW3R5cGVdKSwgbGlua1tyZWw9c3R5bGVzaGVldF1baHJlZl06bm90KFt0eXBlXSksXFxuICAgIHNjcmlwdDpub3QoW3R5cGVdKSwgc2NyaXB0W3R5cGU9XCJhcHBsaWNhdGlvbi9qYXZhc2NyaXB0XCJdLFxcbiAgICBzY3JpcHRbdHlwZT1cInRleHQvamF2YXNjcmlwdFwiXScpO1xudmFyIGQ9MDtsKGMsZnVuY3Rpb24oYSl7aChhKTt0LkthKGEsYik7YS5zZXRBdHRyaWJ1dGUoXCJpbXBvcnQtZGVwZW5kZW5jeVwiLFwiXCIpO1wic2NyaXB0XCI9PT1hLmxvY2FsTmFtZSYmIWEuc3JjJiZhLnRleHRDb250ZW50JiYoYS5zZXRBdHRyaWJ1dGUoXCJzcmNcIixcImRhdGE6dGV4dC9qYXZhc2NyaXB0O2NoYXJzZXQ9dXRmLTgsXCIrZW5jb2RlVVJJQ29tcG9uZW50KGEudGV4dENvbnRlbnQrKFwiXFxuLy8jIHNvdXJjZVVSTD1cIitiKyhkP1wiLVwiK2Q6XCJcIikrXCIuanNcXG5cIikpKSxhLnRleHRDb250ZW50PVwiXCIsZCsrKX0pO3JldHVybiBhfTtrLnByb3RvdHlwZS5zYT1mdW5jdGlvbigpe3ZhciBhPXRoaXM7aWYoIXRoaXMuYil7dGhpcy5oLmRpc2Nvbm5lY3QoKTt0aGlzLmZsYXR0ZW4oZG9jdW1lbnQpO3ZhciBiPSExLGM9ITEsZD1mdW5jdGlvbigpe2MmJmImJihhLmMoZG9jdW1lbnQpLGEuYnx8KGEuaC5vYnNlcnZlKGRvY3VtZW50LmhlYWQse2NoaWxkTGlzdDohMCxzdWJ0cmVlOiEwfSksYS5QYSgpKSl9O1xudGhpcy5XYShmdW5jdGlvbigpe2M9ITA7ZCgpfSk7dGhpcy5TYShmdW5jdGlvbigpe2I9ITA7ZCgpfSl9fTtrLnByb3RvdHlwZS5mbGF0dGVuPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7YT1hLnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3JlbD1pbXBvcnRdXCIpO2woYSxmdW5jdGlvbihhKXt2YXIgYz1iLmFbYS5ocmVmXTsoYS5pbXBvcnQ9YykmJmMubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUmJihiLmFbYS5ocmVmXT1hLGEucmVhZHlTdGF0ZT1cImxvYWRpbmdcIixhLmltcG9ydD1hLGIuZmxhdHRlbihjKSxhLmFwcGVuZENoaWxkKGMpKX0pfTtrLnByb3RvdHlwZS5TYT1mdW5jdGlvbihhKXtmdW5jdGlvbiBiKGUpe2lmKGU8ZCl7dmFyIGY9Y1tlXSxnPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7Zi5yZW1vdmVBdHRyaWJ1dGUoXCJpbXBvcnQtZGVwZW5kZW5jeVwiKTtsKGYuYXR0cmlidXRlcyxmdW5jdGlvbihhKXtyZXR1cm4gZy5zZXRBdHRyaWJ1dGUoYS5uYW1lLFxuYS52YWx1ZSl9KTtuPWc7Zi5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChnLGYpO2goZyxmdW5jdGlvbigpe249bnVsbDtiKGUrMSl9KX1lbHNlIGEoKX12YXIgYz1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic2NyaXB0W2ltcG9ydC1kZXBlbmRlbmN5XVwiKSxkPWMubGVuZ3RoO2IoMCl9O2sucHJvdG90eXBlLldhPWZ1bmN0aW9uKGEpe3ZhciBiPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzdHlsZVtpbXBvcnQtZGVwZW5kZW5jeV0sXFxuICAgIGxpbmtbcmVsPXN0eWxlc2hlZXRdW2ltcG9ydC1kZXBlbmRlbmN5XVwiKSxkPWIubGVuZ3RoO2lmKGQpe3ZhciBlPWFhJiYhIWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJsaW5rW3JlbD1zdHlsZXNoZWV0XVtocmVmXVt0eXBlPWltcG9ydC1kaXNhYmxlXVwiKTtsKGIsZnVuY3Rpb24oYil7aChiLGZ1bmN0aW9uKCl7Yi5yZW1vdmVBdHRyaWJ1dGUoXCJpbXBvcnQtZGVwZW5kZW5jeVwiKTswPT09LS1kJiZhKCl9KTtpZihlJiZiLnBhcmVudE5vZGUhPT1cbmRvY3VtZW50LmhlYWQpe3ZhciBmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoYi5sb2NhbE5hbWUpO2YuX19hcHBsaWVkRWxlbWVudD1iO2Yuc2V0QXR0cmlidXRlKFwidHlwZVwiLFwiaW1wb3J0LXBsYWNlaG9sZGVyXCIpO2IucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZixiLm5leHRTaWJsaW5nKTtmb3IoZj1jKGIpO2YmJmMoZik7KWY9YyhmKTtmLnBhcmVudE5vZGUhPT1kb2N1bWVudC5oZWFkJiYoZj1udWxsKTtkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZShiLGYpO2IucmVtb3ZlQXR0cmlidXRlKFwidHlwZVwiKX19KX1lbHNlIGEoKX07ay5wcm90b3R5cGUuUGE9ZnVuY3Rpb24oKXt2YXIgYT10aGlzLGI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtbcmVsPWltcG9ydF1cIik7bChiLGZ1bmN0aW9uKGIpe3JldHVybiBhLm8oYil9LCEwKX07ay5wcm90b3R5cGUubz1mdW5jdGlvbihhKXthLl9fbG9hZGVkfHwoYS5fX2xvYWRlZD0hMCxhLmltcG9ydCYmKGEuaW1wb3J0LnJlYWR5U3RhdGU9XG5cImNvbXBsZXRlXCIpLGEuZGlzcGF0Y2hFdmVudChiKGEuaW1wb3J0P1wibG9hZFwiOlwiZXJyb3JcIix7YnViYmxlczohMSxjYW5jZWxhYmxlOiExLGRldGFpbDp2b2lkIDB9KSkpfTtrLnByb3RvdHlwZS5RYT1mdW5jdGlvbihhKXt2YXIgYj10aGlzO2woYSxmdW5jdGlvbihhKXtyZXR1cm4gbChhLmFkZGVkTm9kZXMsZnVuY3Rpb24oYSl7YSYmYS5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiYoZyhhKT9iLkwoYSk6Yi5jKGEpKX0pfSl9O2lmKG0pe3ZhciBUPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rW3JlbD1pbXBvcnRdXCIpO2woVCxmdW5jdGlvbihhKXthLmltcG9ydCYmXCJsb2FkaW5nXCI9PT1hLmltcG9ydC5yZWFkeVN0YXRlfHwoYS5fX2xvYWRlZD0hMCl9KTtUPWZ1bmN0aW9uKGEpe2E9YS50YXJnZXQ7ZyhhKSYmKGEuX19sb2FkZWQ9ITApfTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLFQsITApO2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLFxuVCwhMCl9ZWxzZXt2YXIgVT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5vZGUucHJvdG90eXBlLFwiYmFzZVVSSVwiKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoKCFVfHxVLmNvbmZpZ3VyYWJsZT9Ob2RlOkVsZW1lbnQpLnByb3RvdHlwZSxcImJhc2VVUklcIix7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9Zyh0aGlzKT90aGlzOmModGhpcyk7cmV0dXJuIGE/YS5ocmVmOlUmJlUuZ2V0P1UuZ2V0LmNhbGwodGhpcyk6KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJiYXNlXCIpfHx3aW5kb3cubG9jYXRpb24pLmhyZWZ9LGNvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwfSk7ZShmdW5jdGlvbigpe3JldHVybiBuZXcga30pfWYoZnVuY3Rpb24oKXtyZXR1cm4gZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChiKFwiSFRNTEltcG9ydHNMb2FkZWRcIix7Y2FuY2VsYWJsZTohMCxidWJibGVzOiEwLGRldGFpbDp2b2lkIDB9KSl9KTthLnVzZU5hdGl2ZT1tO2Eud2hlblJlYWR5PWY7YS5pbXBvcnRGb3JFbGVtZW50PVxuY30pKHdpbmRvdy5IVE1MSW1wb3J0cz13aW5kb3cuSFRNTEltcG9ydHN8fHt9KTsvKlxuXG4gQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xud2luZG93LldlYkNvbXBvbmVudHM9d2luZG93LldlYkNvbXBvbmVudHN8fHtmbGFnczp7fX07dmFyIGliPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtzcmMqPVwid2ViY29tcG9uZW50cy1saXRlLmpzXCJdJyksamI9L3djLSguKykvLHg9e307aWYoIXgubm9PcHRzKXtsb2NhdGlvbi5zZWFyY2guc2xpY2UoMSkuc3BsaXQoXCImXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7YT1hLnNwbGl0KFwiPVwiKTt2YXIgYjthWzBdJiYoYj1hWzBdLm1hdGNoKGpiKSkmJih4W2JbMV1dPWFbMV18fCEwKX0pO2lmKGliKWZvcih2YXIga2I9MCxsYjtsYj1pYi5hdHRyaWJ1dGVzW2tiXTtrYisrKVwic3JjXCIhPT1sYi5uYW1lJiYoeFtsYi5uYW1lXT1sYi52YWx1ZXx8ITApO2lmKHgubG9nJiZ4LmxvZy5zcGxpdCl7dmFyIG1iPXgubG9nLnNwbGl0KFwiLFwiKTt4LmxvZz17fTttYi5mb3JFYWNoKGZ1bmN0aW9uKGEpe3gubG9nW2FdPSEwfSl9ZWxzZSB4LmxvZz17fX1cbndpbmRvdy5XZWJDb21wb25lbnRzLmZsYWdzPXg7dmFyIG5iPXguc2hhZHlkb207bmImJih3aW5kb3cuU2hhZHlET009d2luZG93LlNoYWR5RE9NfHx7fSx3aW5kb3cuU2hhZHlET00uZm9yY2U9bmIpO3ZhciBvYj14LnJlZ2lzdGVyfHx4LmNlO29iJiZ3aW5kb3cuY3VzdG9tRWxlbWVudHMmJih3aW5kb3cuY3VzdG9tRWxlbWVudHMuZm9yY2VQb2x5ZmlsbD1vYik7LypcblxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbnZhciB5PXdpbmRvdy5TaGFkeURPTXx8e307eS5NYT0hKCFFbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3d8fCFOb2RlLnByb3RvdHlwZS5nZXRSb290Tm9kZSk7dmFyIHBiPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsXCJmaXJzdENoaWxkXCIpO3kuTT0hIShwYiYmcGIuY29uZmlndXJhYmxlJiZwYi5nZXQpO3kudGE9eS5mb3JjZXx8IXkuTWE7ZnVuY3Rpb24gcWIoYSl7cmV0dXJuIGEuX19zaGFkeSYmdm9pZCAwIT09YS5fX3NoYWR5LmZpcnN0Q2hpbGR9ZnVuY3Rpb24geihhKXtyZXR1cm5cIlNoYWR5Um9vdFwiPT09YS5BYX1mdW5jdGlvbiByYihhKXthPWEuZ2V0Um9vdE5vZGUoKTtpZih6KGEpKXJldHVybiBhfXZhciBzYj1FbGVtZW50LnByb3RvdHlwZSx0Yj1zYi5tYXRjaGVzfHxzYi5tYXRjaGVzU2VsZWN0b3J8fHNiLm1vek1hdGNoZXNTZWxlY3Rvcnx8c2IubXNNYXRjaGVzU2VsZWN0b3J8fHNiLm9NYXRjaGVzU2VsZWN0b3J8fHNiLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbmZ1bmN0aW9uIHViKGEsYil7aWYoYSYmYilmb3IodmFyIGM9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYiksZD0wLGU7ZDxjLmxlbmd0aCYmKGU9Y1tkXSk7ZCsrKXt2YXIgZj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsZSk7ZiYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZSxmKX19ZnVuY3Rpb24gdmIoYSxiKXtmb3IodmFyIGM9W10sZD0xO2Q8YXJndW1lbnRzLmxlbmd0aDsrK2QpY1tkLTFdPWFyZ3VtZW50c1tkXTtmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKXViKGEsY1tkXSk7cmV0dXJuIGF9ZnVuY3Rpb24gd2IoYSxiKXtmb3IodmFyIGMgaW4gYilhW2NdPWJbY119dmFyIHhiPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpLHliPTAsemI9W107KG5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKCl7Zm9yKDt6Yi5sZW5ndGg7KXRyeXt6Yi5zaGlmdCgpKCl9Y2F0Y2goYSl7dGhyb3cgeGIudGV4dENvbnRlbnQ9eWIrKyxhO319KSkub2JzZXJ2ZSh4Yix7Y2hhcmFjdGVyRGF0YTohMH0pO1xuZnVuY3Rpb24gQWIoYSl7emIucHVzaChhKTt4Yi50ZXh0Q29udGVudD15YisrfXZhciBCYj0hIWRvY3VtZW50LmNvbnRhaW5zO2Z1bmN0aW9uIENiKGEsYil7Zm9yKDtiOyl7aWYoYj09YSlyZXR1cm4hMDtiPWIucGFyZW50Tm9kZX1yZXR1cm4hMX07dmFyIERiPVtdLEViO2Z1bmN0aW9uIEZiKGEpe0VifHwoRWI9ITAsQWIoR2IpKTtEYi5wdXNoKGEpfWZ1bmN0aW9uIEdiKCl7RWI9ITE7Zm9yKHZhciBhPSEhRGIubGVuZ3RoO0RiLmxlbmd0aDspRGIuc2hpZnQoKSgpO3JldHVybiBhfUdiLmxpc3Q9RGI7ZnVuY3Rpb24gSGIoKXt0aGlzLmE9ITE7dGhpcy5hZGRlZE5vZGVzPVtdO3RoaXMucmVtb3ZlZE5vZGVzPVtdO3RoaXMuVj1uZXcgU2V0fWZ1bmN0aW9uIEliKGEpe2EuYXx8KGEuYT0hMCxBYihmdW5jdGlvbigpe0piKGEpfSkpfWZ1bmN0aW9uIEpiKGEpe2lmKGEuYSl7YS5hPSExO3ZhciBiPWEudGFrZVJlY29yZHMoKTtiLmxlbmd0aCYmYS5WLmZvckVhY2goZnVuY3Rpb24oYSl7YShiKX0pfX1IYi5wcm90b3R5cGUudGFrZVJlY29yZHM9ZnVuY3Rpb24oKXtpZih0aGlzLmFkZGVkTm9kZXMubGVuZ3RofHx0aGlzLnJlbW92ZWROb2Rlcy5sZW5ndGgpe3ZhciBhPVt7YWRkZWROb2Rlczp0aGlzLmFkZGVkTm9kZXMscmVtb3ZlZE5vZGVzOnRoaXMucmVtb3ZlZE5vZGVzfV07dGhpcy5hZGRlZE5vZGVzPVtdO3RoaXMucmVtb3ZlZE5vZGVzPVtdO3JldHVybiBhfXJldHVybltdfTtcbmZ1bmN0aW9uIEtiKGEsYil7YS5fX3NoYWR5PWEuX19zaGFkeXx8e307YS5fX3NoYWR5Lk58fChhLl9fc2hhZHkuTj1uZXcgSGIpO2EuX19zaGFkeS5OLlYuYWRkKGIpO3ZhciBjPWEuX19zaGFkeS5OO3JldHVybntFYTpiLEM6YyxIYTphLHRha2VSZWNvcmRzOmZ1bmN0aW9uKCl7cmV0dXJuIGMudGFrZVJlY29yZHMoKX19fWZ1bmN0aW9uIExiKGEpe3ZhciBiPWEmJmEuQztiJiYoYi5WLmRlbGV0ZShhLkVhKSxiLlYuc2l6ZXx8KGEuSGEuX19zaGFkeS5OPW51bGwpKX1cbmZ1bmN0aW9uIE1iKGEsYil7dmFyIGM9Yi5nZXRSb290Tm9kZSgpO3JldHVybiBhLm1hcChmdW5jdGlvbihhKXt2YXIgYj1jPT09YS50YXJnZXQuZ2V0Um9vdE5vZGUoKTtpZihiJiZhLmFkZGVkTm9kZXMpe2lmKGI9QXJyYXkuZnJvbShhLmFkZGVkTm9kZXMpLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYz09PWEuZ2V0Um9vdE5vZGUoKX0pLGIubGVuZ3RoKXJldHVybiBhPU9iamVjdC5jcmVhdGUoYSksT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJhZGRlZE5vZGVzXCIse3ZhbHVlOmIsY29uZmlndXJhYmxlOiEwfSksYX1lbHNlIGlmKGIpcmV0dXJuIGF9KS5maWx0ZXIoZnVuY3Rpb24oYSl7cmV0dXJuIGF9KX07dmFyIEE9e30sTmI9RWxlbWVudC5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlLE9iPUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUNoaWxkLFBiPUVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZSxRYj1FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUsUmI9RWxlbWVudC5wcm90b3R5cGUuY2xvbmVOb2RlLFNiPURvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlLFRiPUVsZW1lbnQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIsVWI9RWxlbWVudC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lcixWYj1XaW5kb3cucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIsV2I9V2luZG93LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyLFhiPUVsZW1lbnQucHJvdG90eXBlLmRpc3BhdGNoRXZlbnQsWWI9RWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvcixaYj1FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsLCRiPU5vZGUucHJvdG90eXBlLmNvbnRhaW5zfHxcbkhUTUxFbGVtZW50LnByb3RvdHlwZS5jb250YWlucztBLmFwcGVuZENoaWxkPUVsZW1lbnQucHJvdG90eXBlLmFwcGVuZENoaWxkO0EuaW5zZXJ0QmVmb3JlPU5iO0EucmVtb3ZlQ2hpbGQ9T2I7QS5zZXRBdHRyaWJ1dGU9UGI7QS5yZW1vdmVBdHRyaWJ1dGU9UWI7QS5jbG9uZU5vZGU9UmI7QS5pbXBvcnROb2RlPVNiO0EuYWRkRXZlbnRMaXN0ZW5lcj1UYjtBLnJlbW92ZUV2ZW50TGlzdGVuZXI9VWI7QS5hYj1WYjtBLmJiPVdiO0EuZGlzcGF0Y2hFdmVudD1YYjtBLnF1ZXJ5U2VsZWN0b3I9WWI7QS5xdWVyeVNlbGVjdG9yQWxsPVpiO0EuY29udGFpbnM9JGI7dmFyIGFjPS9bJlxcdTAwQTBcIl0vZyxiYz0vWyZcXHUwMEEwPD5dL2c7ZnVuY3Rpb24gY2MoYSl7c3dpdGNoKGEpe2Nhc2UgXCImXCI6cmV0dXJuXCImYW1wO1wiO2Nhc2UgXCI8XCI6cmV0dXJuXCImbHQ7XCI7Y2FzZSBcIj5cIjpyZXR1cm5cIiZndDtcIjtjYXNlICdcIic6cmV0dXJuXCImcXVvdDtcIjtjYXNlIFwiXFx1MDBhMFwiOnJldHVyblwiJm5ic3A7XCJ9fWZ1bmN0aW9uIGRjKGEpe2Zvcih2YXIgYj17fSxjPTA7YzxhLmxlbmd0aDtjKyspYlthW2NdXT0hMDtyZXR1cm4gYn12YXIgZWM9ZGMoXCJhcmVhIGJhc2UgYnIgY29sIGNvbW1hbmQgZW1iZWQgaHIgaW1nIGlucHV0IGtleWdlbiBsaW5rIG1ldGEgcGFyYW0gc291cmNlIHRyYWNrIHdiclwiLnNwbGl0KFwiIFwiKSksZmM9ZGMoXCJzdHlsZSBzY3JpcHQgeG1wIGlmcmFtZSBub2VtYmVkIG5vZnJhbWVzIHBsYWludGV4dCBub3NjcmlwdFwiLnNwbGl0KFwiIFwiKSk7XG5mdW5jdGlvbiBnYyhhLGIpe1widGVtcGxhdGVcIj09PWEubG9jYWxOYW1lJiYoYT1hLmNvbnRlbnQpO2Zvcih2YXIgYz1cIlwiLGQ9Yj9iKGEpOmEuY2hpbGROb2RlcyxlPTAsZj1kLmxlbmd0aCxoO2U8ZiYmKGg9ZFtlXSk7ZSsrKXthOnt2YXIgZz1oO3ZhciBrPWE7dmFyIGw9Yjtzd2l0Y2goZy5ub2RlVHlwZSl7Y2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpmb3IodmFyIG09Zy5sb2NhbE5hbWUsbj1cIjxcIittLHc9Zy5hdHRyaWJ1dGVzLEk9MDtrPXdbSV07SSsrKW4rPVwiIFwiK2submFtZSsnPVwiJytrLnZhbHVlLnJlcGxhY2UoYWMsY2MpKydcIic7bis9XCI+XCI7Zz1lY1ttXT9uOm4rZ2MoZyxsKStcIjwvXCIrbStcIj5cIjticmVhayBhO2Nhc2UgTm9kZS5URVhUX05PREU6Zz1nLmRhdGE7Zz1rJiZmY1trLmxvY2FsTmFtZV0/ZzpnLnJlcGxhY2UoYmMsY2MpO2JyZWFrIGE7Y2FzZSBOb2RlLkNPTU1FTlRfTk9ERTpnPVwiXFx4M2MhLS1cIitnLmRhdGErXCItLVxceDNlXCI7YnJlYWsgYTtkZWZhdWx0OnRocm93IHdpbmRvdy5jb25zb2xlLmVycm9yKGcpLFxuRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7fX1jKz1nfXJldHVybiBjfTt2YXIgQj17fSxDPWRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZG9jdW1lbnQsTm9kZUZpbHRlci5TSE9XX0FMTCxudWxsLCExKSxEPWRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZG9jdW1lbnQsTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsbnVsbCwhMSk7ZnVuY3Rpb24gaGMoYSl7dmFyIGI9W107Qy5jdXJyZW50Tm9kZT1hO2ZvcihhPUMuZmlyc3RDaGlsZCgpO2E7KWIucHVzaChhKSxhPUMubmV4dFNpYmxpbmcoKTtyZXR1cm4gYn1CLnBhcmVudE5vZGU9ZnVuY3Rpb24oYSl7Qy5jdXJyZW50Tm9kZT1hO3JldHVybiBDLnBhcmVudE5vZGUoKX07Qi5maXJzdENoaWxkPWZ1bmN0aW9uKGEpe0MuY3VycmVudE5vZGU9YTtyZXR1cm4gQy5maXJzdENoaWxkKCl9O0IubGFzdENoaWxkPWZ1bmN0aW9uKGEpe0MuY3VycmVudE5vZGU9YTtyZXR1cm4gQy5sYXN0Q2hpbGQoKX07Qi5wcmV2aW91c1NpYmxpbmc9ZnVuY3Rpb24oYSl7Qy5jdXJyZW50Tm9kZT1hO3JldHVybiBDLnByZXZpb3VzU2libGluZygpfTtcbkIubmV4dFNpYmxpbmc9ZnVuY3Rpb24oYSl7Qy5jdXJyZW50Tm9kZT1hO3JldHVybiBDLm5leHRTaWJsaW5nKCl9O0IuY2hpbGROb2Rlcz1oYztCLnBhcmVudEVsZW1lbnQ9ZnVuY3Rpb24oYSl7RC5jdXJyZW50Tm9kZT1hO3JldHVybiBELnBhcmVudE5vZGUoKX07Qi5maXJzdEVsZW1lbnRDaGlsZD1mdW5jdGlvbihhKXtELmN1cnJlbnROb2RlPWE7cmV0dXJuIEQuZmlyc3RDaGlsZCgpfTtCLmxhc3RFbGVtZW50Q2hpbGQ9ZnVuY3Rpb24oYSl7RC5jdXJyZW50Tm9kZT1hO3JldHVybiBELmxhc3RDaGlsZCgpfTtCLnByZXZpb3VzRWxlbWVudFNpYmxpbmc9ZnVuY3Rpb24oYSl7RC5jdXJyZW50Tm9kZT1hO3JldHVybiBELnByZXZpb3VzU2libGluZygpfTtCLm5leHRFbGVtZW50U2libGluZz1mdW5jdGlvbihhKXtELmN1cnJlbnROb2RlPWE7cmV0dXJuIEQubmV4dFNpYmxpbmcoKX07XG5CLmNoaWxkcmVuPWZ1bmN0aW9uKGEpe3ZhciBiPVtdO0QuY3VycmVudE5vZGU9YTtmb3IoYT1ELmZpcnN0Q2hpbGQoKTthOyliLnB1c2goYSksYT1ELm5leHRTaWJsaW5nKCk7cmV0dXJuIGJ9O0IuaW5uZXJIVE1MPWZ1bmN0aW9uKGEpe3JldHVybiBnYyhhLGZ1bmN0aW9uKGEpe3JldHVybiBoYyhhKX0pfTtCLnRleHRDb250ZW50PWZ1bmN0aW9uKGEpe3N3aXRjaChhLm5vZGVUeXBlKXtjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOmNhc2UgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFOmE9ZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihhLE5vZGVGaWx0ZXIuU0hPV19URVhULG51bGwsITEpO2Zvcih2YXIgYj1cIlwiLGM7Yz1hLm5leHROb2RlKCk7KWIrPWMubm9kZVZhbHVlO3JldHVybiBiO2RlZmF1bHQ6cmV0dXJuIGEubm9kZVZhbHVlfX07dmFyIGljPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRWxlbWVudC5wcm90b3R5cGUsXCJpbm5lckhUTUxcIil8fE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLFwiaW5uZXJIVE1MXCIpLGpjPWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcImluZXJ0XCIpLGtjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRG9jdW1lbnQucHJvdG90eXBlLFwiYWN0aXZlRWxlbWVudFwiKSxsYz17cGFyZW50RWxlbWVudDp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkucGFyZW50Tm9kZTthJiZhLm5vZGVUeXBlIT09Tm9kZS5FTEVNRU5UX05PREUmJihhPW51bGwpO3JldHVybiB2b2lkIDAhPT1hP2E6Qi5wYXJlbnRFbGVtZW50KHRoaXMpfSxjb25maWd1cmFibGU6ITB9LHBhcmVudE5vZGU6e2dldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX19zaGFkeSYmdGhpcy5fX3NoYWR5LnBhcmVudE5vZGU7XG5yZXR1cm4gdm9pZCAwIT09YT9hOkIucGFyZW50Tm9kZSh0aGlzKX0sY29uZmlndXJhYmxlOiEwfSxuZXh0U2libGluZzp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkubmV4dFNpYmxpbmc7cmV0dXJuIHZvaWQgMCE9PWE/YTpCLm5leHRTaWJsaW5nKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LHByZXZpb3VzU2libGluZzp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nO3JldHVybiB2b2lkIDAhPT1hP2E6Qi5wcmV2aW91c1NpYmxpbmcodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH0sY2xhc3NOYW1lOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKXx8XCJcIn0sc2V0OmZ1bmN0aW9uKGEpe3RoaXMuc2V0QXR0cmlidXRlKFwiY2xhc3NcIixhKX0sY29uZmlndXJhYmxlOiEwfSxuZXh0RWxlbWVudFNpYmxpbmc6e2dldDpmdW5jdGlvbigpe2lmKHRoaXMuX19zaGFkeSYmXG52b2lkIDAhPT10aGlzLl9fc2hhZHkubmV4dFNpYmxpbmcpe2Zvcih2YXIgYT10aGlzLm5leHRTaWJsaW5nO2EmJmEubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERTspYT1hLm5leHRTaWJsaW5nO3JldHVybiBhfXJldHVybiBCLm5leHRFbGVtZW50U2libGluZyh0aGlzKX0sY29uZmlndXJhYmxlOiEwfSxwcmV2aW91c0VsZW1lbnRTaWJsaW5nOntnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9fc2hhZHkmJnZvaWQgMCE9PXRoaXMuX19zaGFkeS5wcmV2aW91c1NpYmxpbmcpe2Zvcih2YXIgYT10aGlzLnByZXZpb3VzU2libGluZzthJiZhLm5vZGVUeXBlIT09Tm9kZS5FTEVNRU5UX05PREU7KWE9YS5wcmV2aW91c1NpYmxpbmc7cmV0dXJuIGF9cmV0dXJuIEIucHJldmlvdXNFbGVtZW50U2libGluZyh0aGlzKX0sY29uZmlndXJhYmxlOiEwfX0sbWM9e2NoaWxkTm9kZXM6e2dldDpmdW5jdGlvbigpe2lmKHFiKHRoaXMpKXtpZighdGhpcy5fX3NoYWR5LmNoaWxkTm9kZXMpe3RoaXMuX19zaGFkeS5jaGlsZE5vZGVzPVxuW107Zm9yKHZhciBhPXRoaXMuZmlyc3RDaGlsZDthO2E9YS5uZXh0U2libGluZyl0aGlzLl9fc2hhZHkuY2hpbGROb2Rlcy5wdXNoKGEpfXZhciBiPXRoaXMuX19zaGFkeS5jaGlsZE5vZGVzfWVsc2UgYj1CLmNoaWxkTm9kZXModGhpcyk7Yi5pdGVtPWZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfTtyZXR1cm4gYn0sY29uZmlndXJhYmxlOiEwfSxjaGlsZEVsZW1lbnRDb3VudDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hpbGRyZW4ubGVuZ3RofSxjb25maWd1cmFibGU6ITB9LGZpcnN0Q2hpbGQ6e2dldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX19zaGFkeSYmdGhpcy5fX3NoYWR5LmZpcnN0Q2hpbGQ7cmV0dXJuIHZvaWQgMCE9PWE/YTpCLmZpcnN0Q2hpbGQodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH0sbGFzdENoaWxkOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5sYXN0Q2hpbGQ7cmV0dXJuIHZvaWQgMCE9PWE/YTpCLmxhc3RDaGlsZCh0aGlzKX0sXG5jb25maWd1cmFibGU6ITB9LHRleHRDb250ZW50OntnZXQ6ZnVuY3Rpb24oKXtpZihxYih0aGlzKSl7Zm9yKHZhciBhPVtdLGI9MCxjPXRoaXMuY2hpbGROb2RlcyxkO2Q9Y1tiXTtiKyspZC5ub2RlVHlwZSE9PU5vZGUuQ09NTUVOVF9OT0RFJiZhLnB1c2goZC50ZXh0Q29udGVudCk7cmV0dXJuIGEuam9pbihcIlwiKX1yZXR1cm4gQi50ZXh0Q29udGVudCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGEpe3N3aXRjaCh0aGlzLm5vZGVUeXBlKXtjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOmNhc2UgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFOmZvcig7dGhpcy5maXJzdENoaWxkOyl0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7KDA8YS5sZW5ndGh8fHRoaXMubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSkmJnRoaXMuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYSkpO2JyZWFrO2RlZmF1bHQ6dGhpcy5ub2RlVmFsdWU9YX19LGNvbmZpZ3VyYWJsZTohMH0sZmlyc3RFbGVtZW50Q2hpbGQ6e2dldDpmdW5jdGlvbigpe2lmKHRoaXMuX19zaGFkeSYmXG52b2lkIDAhPT10aGlzLl9fc2hhZHkuZmlyc3RDaGlsZCl7Zm9yKHZhciBhPXRoaXMuZmlyc3RDaGlsZDthJiZhLm5vZGVUeXBlIT09Tm9kZS5FTEVNRU5UX05PREU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX1yZXR1cm4gQi5maXJzdEVsZW1lbnRDaGlsZCh0aGlzKX0sY29uZmlndXJhYmxlOiEwfSxsYXN0RWxlbWVudENoaWxkOntnZXQ6ZnVuY3Rpb24oKXtpZih0aGlzLl9fc2hhZHkmJnZvaWQgMCE9PXRoaXMuX19zaGFkeS5sYXN0Q2hpbGQpe2Zvcih2YXIgYT10aGlzLmxhc3RDaGlsZDthJiZhLm5vZGVUeXBlIT09Tm9kZS5FTEVNRU5UX05PREU7KWE9YS5wcmV2aW91c1NpYmxpbmc7cmV0dXJuIGF9cmV0dXJuIEIubGFzdEVsZW1lbnRDaGlsZCh0aGlzKX0sY29uZmlndXJhYmxlOiEwfSxjaGlsZHJlbjp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE7cWIodGhpcyk/YT1BcnJheS5wcm90b3R5cGUuZmlsdGVyLmNhbGwodGhpcy5jaGlsZE5vZGVzLGZ1bmN0aW9uKGEpe3JldHVybiBhLm5vZGVUeXBlPT09XG5Ob2RlLkVMRU1FTlRfTk9ERX0pOmE9Qi5jaGlsZHJlbih0aGlzKTthLml0ZW09ZnVuY3Rpb24oYil7cmV0dXJuIGFbYl19O3JldHVybiBhfSxjb25maWd1cmFibGU6ITB9LGlubmVySFRNTDp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9XCJ0ZW1wbGF0ZVwiPT09dGhpcy5sb2NhbE5hbWU/dGhpcy5jb250ZW50OnRoaXM7cmV0dXJuIHFiKHRoaXMpP2djKGEpOkIuaW5uZXJIVE1MKGEpfSxzZXQ6ZnVuY3Rpb24oYSl7Zm9yKHZhciBiPVwidGVtcGxhdGVcIj09PXRoaXMubG9jYWxOYW1lP3RoaXMuY29udGVudDp0aGlzO2IuZmlyc3RDaGlsZDspYi5yZW1vdmVDaGlsZChiLmZpcnN0Q2hpbGQpO3ZhciBjPXRoaXMubG9jYWxOYW1lO2MmJlwidGVtcGxhdGVcIiE9PWN8fChjPVwiZGl2XCIpO2M9amMuY3JlYXRlRWxlbWVudChjKTtmb3IoaWMmJmljLnNldD9pYy5zZXQuY2FsbChjLGEpOmMuaW5uZXJIVE1MPWE7Yy5maXJzdENoaWxkOyliLmFwcGVuZENoaWxkKGMuZmlyc3RDaGlsZCl9LGNvbmZpZ3VyYWJsZTohMH19LFxucWM9e3NoYWRvd1Jvb3Q6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5VYXx8bnVsbH0sY29uZmlndXJhYmxlOiEwfX0scmM9e2FjdGl2ZUVsZW1lbnQ6e2dldDpmdW5jdGlvbigpe3ZhciBhPWtjJiZrYy5nZXQ/a2MuZ2V0LmNhbGwoZG9jdW1lbnQpOnkuTT92b2lkIDA6ZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtpZihhJiZhLm5vZGVUeXBlKXt2YXIgYj0hIXoodGhpcyk7aWYodGhpcz09PWRvY3VtZW50fHxiJiZ0aGlzLmhvc3QhPT1hJiZBLmNvbnRhaW5zLmNhbGwodGhpcy5ob3N0LGEpKXtmb3IoYj1yYihhKTtiJiZiIT09dGhpczspYT1iLmhvc3QsYj1yYihhKTthPXRoaXM9PT1kb2N1bWVudD9iP251bGw6YTpiPT09dGhpcz9hOm51bGx9ZWxzZSBhPW51bGx9ZWxzZSBhPW51bGw7cmV0dXJuIGF9LHNldDpmdW5jdGlvbigpe30sY29uZmlndXJhYmxlOiEwfX07XG5mdW5jdGlvbiBFKGEsYixjKXtmb3IodmFyIGQgaW4gYil7dmFyIGU9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLGQpO2UmJmUuY29uZmlndXJhYmxlfHwhZSYmYz9PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxkLGJbZF0pOmMmJmNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBkZWZpbmVcIixkLFwib25cIixhKX19ZnVuY3Rpb24gRihhKXtFKGEsbGMpO0UoYSxtYyk7RShhLHJjKX12YXIgc2M9eS5NP2Z1bmN0aW9uKCl7fTpmdW5jdGlvbihhKXthLl9fc2hhZHkmJmEuX19zaGFkeS5CYXx8KGEuX19zaGFkeT1hLl9fc2hhZHl8fHt9LGEuX19zaGFkeS5CYT0hMCxFKGEsbGMsITApKX0sdGM9eS5NP2Z1bmN0aW9uKCl7fTpmdW5jdGlvbihhKXthLl9fc2hhZHkmJmEuX19zaGFkeS56YXx8KGEuX19zaGFkeT1hLl9fc2hhZHl8fHt9LGEuX19zaGFkeS56YT0hMCxFKGEsbWMsITApLEUoYSxxYywhMCkpfTtmdW5jdGlvbiB1YyhhLGIsYyl7c2MoYSk7Yz1jfHxudWxsO2EuX19zaGFkeT1hLl9fc2hhZHl8fHt9O2IuX19zaGFkeT1iLl9fc2hhZHl8fHt9O2MmJihjLl9fc2hhZHk9Yy5fX3NoYWR5fHx7fSk7YS5fX3NoYWR5LnByZXZpb3VzU2libGluZz1jP2MuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc6Yi5sYXN0Q2hpbGQ7dmFyIGQ9YS5fX3NoYWR5LnByZXZpb3VzU2libGluZztkJiZkLl9fc2hhZHkmJihkLl9fc2hhZHkubmV4dFNpYmxpbmc9YSk7KGQ9YS5fX3NoYWR5Lm5leHRTaWJsaW5nPWMpJiZkLl9fc2hhZHkmJihkLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nPWEpO2EuX19zaGFkeS5wYXJlbnROb2RlPWI7Yz9jPT09Yi5fX3NoYWR5LmZpcnN0Q2hpbGQmJihiLl9fc2hhZHkuZmlyc3RDaGlsZD1hKTooYi5fX3NoYWR5Lmxhc3RDaGlsZD1hLGIuX19zaGFkeS5maXJzdENoaWxkfHwoYi5fX3NoYWR5LmZpcnN0Q2hpbGQ9YSkpO2IuX19zaGFkeS5jaGlsZE5vZGVzPW51bGx9XG5mdW5jdGlvbiB2YyhhKXtpZighYS5fX3NoYWR5fHx2b2lkIDA9PT1hLl9fc2hhZHkuZmlyc3RDaGlsZCl7YS5fX3NoYWR5PWEuX19zaGFkeXx8e307YS5fX3NoYWR5LmZpcnN0Q2hpbGQ9Qi5maXJzdENoaWxkKGEpO2EuX19zaGFkeS5sYXN0Q2hpbGQ9Qi5sYXN0Q2hpbGQoYSk7dGMoYSk7Zm9yKHZhciBiPWEuX19zaGFkeS5jaGlsZE5vZGVzPUIuY2hpbGROb2RlcyhhKSxjPTAsZDtjPGIubGVuZ3RoJiYoZD1iW2NdKTtjKyspZC5fX3NoYWR5PWQuX19zaGFkeXx8e30sZC5fX3NoYWR5LnBhcmVudE5vZGU9YSxkLl9fc2hhZHkubmV4dFNpYmxpbmc9YltjKzFdfHxudWxsLGQuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc9YltjLTFdfHxudWxsLHNjKGQpfX07ZnVuY3Rpb24gd2MoYSxiLGMpe2lmKGI9PT1hKXRocm93IEVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2FwcGVuZENoaWxkJyBvbiAnTm9kZSc6IFRoZSBuZXcgY2hpbGQgZWxlbWVudCBjb250YWlucyB0aGUgcGFyZW50LlwiKTtpZihjKXt2YXIgZD1jLl9fc2hhZHkmJmMuX19zaGFkeS5wYXJlbnROb2RlO2lmKHZvaWQgMCE9PWQmJmQhPT1hfHx2b2lkIDA9PT1kJiZCLnBhcmVudE5vZGUoYykhPT1hKXRocm93IEVycm9yKFwiRmFpbGVkIHRvIGV4ZWN1dGUgJ2luc2VydEJlZm9yZScgb24gJ05vZGUnOiBUaGUgbm9kZSBiZWZvcmUgd2hpY2ggdGhlIG5ldyBub2RlIGlzIHRvIGJlIGluc2VydGVkIGlzIG5vdCBhIGNoaWxkIG9mIHRoaXMgbm9kZS5cIik7fWlmKGM9PT1iKXJldHVybiBiO2IucGFyZW50Tm9kZSYmeGMoYi5wYXJlbnROb2RlLGIpO2Q9cmIoYSk7dmFyIGU7aWYoZT1kKWE6e2lmKCFiLl9fbm9JbnNlcnRpb25Qb2ludCl7dmFyIGY7XCJzbG90XCI9PT1iLmxvY2FsTmFtZT9mPVtiXTpcbmIucXVlcnlTZWxlY3RvckFsbCYmKGY9Yi5xdWVyeVNlbGVjdG9yQWxsKFwic2xvdFwiKSk7aWYoZiYmZi5sZW5ndGgpe2U9ZjticmVhayBhfX1lPXZvaWQgMH0oZj1lKSYmZC5ILnB1c2guYXBwbHkoZC5ILFtdLmNvbmNhdChmIGluc3RhbmNlb2YgQXJyYXk/ZjpqYShpYShmKSkpKTtkJiYoXCJzbG90XCI9PT1hLmxvY2FsTmFtZXx8ZikmJnljKGQpO2lmKHFiKGEpKXtkPWM7dGMoYSk7YS5fX3NoYWR5PWEuX19zaGFkeXx8e307dm9pZCAwIT09YS5fX3NoYWR5LmZpcnN0Q2hpbGQmJihhLl9fc2hhZHkuY2hpbGROb2Rlcz1udWxsKTtpZihiLm5vZGVUeXBlPT09Tm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKXtmPWIuY2hpbGROb2Rlcztmb3IoZT0wO2U8Zi5sZW5ndGg7ZSsrKXVjKGZbZV0sYSxkKTtiLl9fc2hhZHk9Yi5fX3NoYWR5fHx7fTtkPXZvaWQgMCE9PWIuX19zaGFkeS5maXJzdENoaWxkP251bGw6dm9pZCAwO2IuX19zaGFkeS5maXJzdENoaWxkPWIuX19zaGFkeS5sYXN0Q2hpbGQ9XG5kO2IuX19zaGFkeS5jaGlsZE5vZGVzPWR9ZWxzZSB1YyhiLGEsZCk7aWYoemMoYSkpe3ljKGEuX19zaGFkeS5yb290KTt2YXIgaD0hMH1lbHNlIGEuX19zaGFkeS5yb290JiYoaD0hMCl9aHx8KGg9eihhKT9hLmhvc3Q6YSxjPyhjPUFjKGMpLEEuaW5zZXJ0QmVmb3JlLmNhbGwoaCxiLGMpKTpBLmFwcGVuZENoaWxkLmNhbGwoaCxiKSk7QmMoYSxiKTtyZXR1cm4gYn1cbmZ1bmN0aW9uIHhjKGEsYil7aWYoYi5wYXJlbnROb2RlIT09YSl0aHJvdyBFcnJvcihcIlRoZSBub2RlIHRvIGJlIHJlbW92ZWQgaXMgbm90IGEgY2hpbGQgb2YgdGhpcyBub2RlOiBcIitiKTt2YXIgYz1yYihiKTtpZihxYihhKSl7Yi5fX3NoYWR5PWIuX19zaGFkeXx8e307YS5fX3NoYWR5PWEuX19zaGFkeXx8e307Yj09PWEuX19zaGFkeS5maXJzdENoaWxkJiYoYS5fX3NoYWR5LmZpcnN0Q2hpbGQ9Yi5fX3NoYWR5Lm5leHRTaWJsaW5nKTtiPT09YS5fX3NoYWR5Lmxhc3RDaGlsZCYmKGEuX19zaGFkeS5sYXN0Q2hpbGQ9Yi5fX3NoYWR5LnByZXZpb3VzU2libGluZyk7dmFyIGQ9Yi5fX3NoYWR5LnByZXZpb3VzU2libGluZyxlPWIuX19zaGFkeS5uZXh0U2libGluZztkJiYoZC5fX3NoYWR5PWQuX19zaGFkeXx8e30sZC5fX3NoYWR5Lm5leHRTaWJsaW5nPWUpO2UmJihlLl9fc2hhZHk9ZS5fX3NoYWR5fHx7fSxlLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nPWQpO2IuX19zaGFkeS5wYXJlbnROb2RlPVxuYi5fX3NoYWR5LnByZXZpb3VzU2libGluZz1iLl9fc2hhZHkubmV4dFNpYmxpbmc9dm9pZCAwO3ZvaWQgMCE9PWEuX19zaGFkeS5jaGlsZE5vZGVzJiYoYS5fX3NoYWR5LmNoaWxkTm9kZXM9bnVsbCk7aWYoemMoYSkpe3ljKGEuX19zaGFkeS5yb290KTt2YXIgZj0hMH19Q2MoYik7aWYoYyl7KGQ9YSYmXCJzbG90XCI9PT1hLmxvY2FsTmFtZSkmJihmPSEwKTtEYyhjKTtlPWMubDtmb3IodmFyIGggaW4gZSlmb3IodmFyIGc9ZVtoXSxrPTA7azxnLmxlbmd0aDtrKyspe3ZhciBsPWdba107aWYoQ2IoYixsKSl7Zy5zcGxpY2UoaywxKTt2YXIgbT1jLnMuaW5kZXhPZihsKTswPD1tJiZjLnMuc3BsaWNlKG0sMSk7ay0tO2lmKG09bC5fX3NoYWR5LkspZm9yKGw9MDtsPG0ubGVuZ3RoO2wrKyl7dmFyIG49bVtsXSx3PUIucGFyZW50Tm9kZShuKTt3JiZBLnJlbW92ZUNoaWxkLmNhbGwodyxuKX1tPSEwfX0obXx8ZCkmJnljKGMpfWZ8fChmPXooYSk/YS5ob3N0OmEsKCFhLl9fc2hhZHkucm9vdCYmXG5cInNsb3RcIiE9PWIubG9jYWxOYW1lfHxmPT09Qi5wYXJlbnROb2RlKGIpKSYmQS5yZW1vdmVDaGlsZC5jYWxsKGYsYikpO0JjKGEsbnVsbCxiKTtyZXR1cm4gYn1mdW5jdGlvbiBDYyhhKXtpZihhLl9fc2hhZHkmJnZvaWQgMCE9PWEuX19zaGFkeS5rYSlmb3IodmFyIGI9YS5jaGlsZE5vZGVzLGM9MCxkPWIubGVuZ3RoLGU7YzxkJiYoZT1iW2NdKTtjKyspQ2MoZSk7YS5fX3NoYWR5JiYoYS5fX3NoYWR5LmthPXZvaWQgMCl9ZnVuY3Rpb24gQWMoYSl7dmFyIGI9YTthJiZcInNsb3RcIj09PWEubG9jYWxOYW1lJiYoYj0oYj1hLl9fc2hhZHkmJmEuX19zaGFkeS5LKSYmYi5sZW5ndGg/YlswXTpBYyhhLm5leHRTaWJsaW5nKSk7cmV0dXJuIGJ9ZnVuY3Rpb24gemMoYSl7cmV0dXJuKGE9YSYmYS5fX3NoYWR5JiZhLl9fc2hhZHkucm9vdCkmJkVjKGEpfVxuZnVuY3Rpb24gRmMoYSxiKXtpZihcInNsb3RcIj09PWIpYT1hLnBhcmVudE5vZGUsemMoYSkmJnljKGEuX19zaGFkeS5yb290KTtlbHNlIGlmKFwic2xvdFwiPT09YS5sb2NhbE5hbWUmJlwibmFtZVwiPT09YiYmKGI9cmIoYSkpKXt2YXIgYz1hLkNhLGQ9R2MoYSk7aWYoZCE9PWMpe2M9Yi5sW2NdO3ZhciBlPWMuaW5kZXhPZihhKTswPD1lJiZjLnNwbGljZShlLDEpO2M9Yi5sW2RdfHwoYi5sW2RdPVtdKTtjLnB1c2goYSk7MTxjLmxlbmd0aCYmKGIubFtkXT1IYyhjKSl9eWMoYil9fWZ1bmN0aW9uIEJjKGEsYixjKXtpZihhPWEuX19zaGFkeSYmYS5fX3NoYWR5Lk4pYiYmYS5hZGRlZE5vZGVzLnB1c2goYiksYyYmYS5yZW1vdmVkTm9kZXMucHVzaChjKSxJYihhKX1cbmZ1bmN0aW9uIEljKGEpe2lmKGEmJmEubm9kZVR5cGUpe2EuX19zaGFkeT1hLl9fc2hhZHl8fHt9O3ZhciBiPWEuX19zaGFkeS5rYTt2b2lkIDA9PT1iJiYoeihhKT9iPWE6Yj0oYj1hLnBhcmVudE5vZGUpP0ljKGIpOmEsQS5jb250YWlucy5jYWxsKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxhKSYmKGEuX19zaGFkeS5rYT1iKSk7cmV0dXJuIGJ9fWZ1bmN0aW9uIEpjKGEsYixjKXt2YXIgZD1bXTtLYyhhLmNoaWxkTm9kZXMsYixjLGQpO3JldHVybiBkfWZ1bmN0aW9uIEtjKGEsYixjLGQpe2Zvcih2YXIgZT0wLGY9YS5sZW5ndGgsaDtlPGYmJihoPWFbZV0pO2UrKyl7dmFyIGc7aWYoZz1oLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUpe2c9aDt2YXIgaz1iLGw9YyxtPWQsbj1rKGcpO24mJm0ucHVzaChnKTtsJiZsKG4pP2c9bjooS2MoZy5jaGlsZE5vZGVzLGssbCxtKSxnPXZvaWQgMCl9aWYoZylicmVha319dmFyIExjPW51bGw7XG5mdW5jdGlvbiBNYyhhLGIsYyl7TGN8fChMYz13aW5kb3cuU2hhZHlDU1MmJndpbmRvdy5TaGFkeUNTUy5TY29waW5nU2hpbSk7TGMmJlwiY2xhc3NcIj09PWI/TGMuc2V0RWxlbWVudENsYXNzKGEsYyk6KEEuc2V0QXR0cmlidXRlLmNhbGwoYSxiLGMpLEZjKGEsYikpfWZ1bmN0aW9uIE5jKGEsYil7aWYoYS5vd25lckRvY3VtZW50IT09ZG9jdW1lbnQpcmV0dXJuIEEuaW1wb3J0Tm9kZS5jYWxsKGRvY3VtZW50LGEsYik7dmFyIGM9QS5pbXBvcnROb2RlLmNhbGwoZG9jdW1lbnQsYSwhMSk7aWYoYil7YT1hLmNoaWxkTm9kZXM7Yj0wO2Zvcih2YXIgZDtiPGEubGVuZ3RoO2IrKylkPU5jKGFbYl0sITApLGMuYXBwZW5kQ2hpbGQoZCl9cmV0dXJuIGN9O3ZhciBPYz1cIl9fZXZlbnRXcmFwcGVyc1wiK0RhdGUubm93KCksUGM9e2JsdXI6ITAsZm9jdXM6ITAsZm9jdXNpbjohMCxmb2N1c291dDohMCxjbGljazohMCxkYmxjbGljazohMCxtb3VzZWRvd246ITAsbW91c2VlbnRlcjohMCxtb3VzZWxlYXZlOiEwLG1vdXNlbW92ZTohMCxtb3VzZW91dDohMCxtb3VzZW92ZXI6ITAsbW91c2V1cDohMCx3aGVlbDohMCxiZWZvcmVpbnB1dDohMCxpbnB1dDohMCxrZXlkb3duOiEwLGtleXVwOiEwLGNvbXBvc2l0aW9uc3RhcnQ6ITAsY29tcG9zaXRpb251cGRhdGU6ITAsY29tcG9zaXRpb25lbmQ6ITAsdG91Y2hzdGFydDohMCx0b3VjaGVuZDohMCx0b3VjaG1vdmU6ITAsdG91Y2hjYW5jZWw6ITAscG9pbnRlcm92ZXI6ITAscG9pbnRlcmVudGVyOiEwLHBvaW50ZXJkb3duOiEwLHBvaW50ZXJtb3ZlOiEwLHBvaW50ZXJ1cDohMCxwb2ludGVyY2FuY2VsOiEwLHBvaW50ZXJvdXQ6ITAscG9pbnRlcmxlYXZlOiEwLGdvdHBvaW50ZXJjYXB0dXJlOiEwLGxvc3Rwb2ludGVyY2FwdHVyZTohMCxcbmRyYWdzdGFydDohMCxkcmFnOiEwLGRyYWdlbnRlcjohMCxkcmFnbGVhdmU6ITAsZHJhZ292ZXI6ITAsZHJvcDohMCxkcmFnZW5kOiEwLERPTUFjdGl2YXRlOiEwLERPTUZvY3VzSW46ITAsRE9NRm9jdXNPdXQ6ITAsa2V5cHJlc3M6ITB9O2Z1bmN0aW9uIFFjKGEsYil7dmFyIGM9W10sZD1hO2ZvcihhPWE9PT13aW5kb3c/d2luZG93OmEuZ2V0Um9vdE5vZGUoKTtkOyljLnB1c2goZCksZD1kLmFzc2lnbmVkU2xvdD9kLmFzc2lnbmVkU2xvdDpkLm5vZGVUeXBlPT09Tm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFJiZkLmhvc3QmJihifHxkIT09YSk/ZC5ob3N0OmQucGFyZW50Tm9kZTtjW2MubGVuZ3RoLTFdPT09ZG9jdW1lbnQmJmMucHVzaCh3aW5kb3cpO3JldHVybiBjfVxuZnVuY3Rpb24gUmMoYSxiKXtpZigheilyZXR1cm4gYTthPVFjKGEsITApO2Zvcih2YXIgYz0wLGQsZSxmLGg7YzxiLmxlbmd0aDtjKyspaWYoZD1iW2NdLGY9ZD09PXdpbmRvdz93aW5kb3c6ZC5nZXRSb290Tm9kZSgpLGYhPT1lJiYoaD1hLmluZGV4T2YoZiksZT1mKSwheihmKXx8LTE8aClyZXR1cm4gZH1cbnZhciBTYz17Z2V0IGNvbXBvc2VkKCl7ITEhPT10aGlzLmlzVHJ1c3RlZCYmdm9pZCAwPT09dGhpcy5aJiYodGhpcy5aPVBjW3RoaXMudHlwZV0pO3JldHVybiB0aGlzLlp8fCExfSxjb21wb3NlZFBhdGg6ZnVuY3Rpb24oKXt0aGlzLm5hfHwodGhpcy5uYT1RYyh0aGlzLl9fdGFyZ2V0LHRoaXMuY29tcG9zZWQpKTtyZXR1cm4gdGhpcy5uYX0sZ2V0IHRhcmdldCgpe3JldHVybiBSYyh0aGlzLmN1cnJlbnRUYXJnZXQsdGhpcy5jb21wb3NlZFBhdGgoKSl9LGdldCByZWxhdGVkVGFyZ2V0KCl7aWYoIXRoaXMuYWEpcmV0dXJuIG51bGw7dGhpcy5vYXx8KHRoaXMub2E9UWModGhpcy5hYSwhMCkpO3JldHVybiBSYyh0aGlzLmN1cnJlbnRUYXJnZXQsdGhpcy5vYSl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe0V2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24uY2FsbCh0aGlzKTt0aGlzLiQ9ITB9LHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjpmdW5jdGlvbigpe0V2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24uY2FsbCh0aGlzKTtcbnRoaXMuJD10aGlzLnlhPSEwfX07ZnVuY3Rpb24gVGMoYSl7ZnVuY3Rpb24gYihiLGQpe2I9bmV3IGEoYixkKTtiLlo9ZCYmISFkLmNvbXBvc2VkO3JldHVybiBifXdiKGIsYSk7Yi5wcm90b3R5cGU9YS5wcm90b3R5cGU7cmV0dXJuIGJ9dmFyIFVjPXtmb2N1czohMCxibHVyOiEwfTtmdW5jdGlvbiBWYyhhKXtyZXR1cm4gYS5fX3RhcmdldCE9PWEudGFyZ2V0fHxhLmFhIT09YS5yZWxhdGVkVGFyZ2V0fWZ1bmN0aW9uIFdjKGEsYixjKXtpZihjPWIuX19oYW5kbGVycyYmYi5fX2hhbmRsZXJzW2EudHlwZV0mJmIuX19oYW5kbGVyc1thLnR5cGVdW2NdKWZvcih2YXIgZD0wLGU7KGU9Y1tkXSkmJighVmMoYSl8fGEudGFyZ2V0IT09YS5yZWxhdGVkVGFyZ2V0KSYmKGUuY2FsbChiLGEpLCFhLnlhKTtkKyspO31cbmZ1bmN0aW9uIFhjKGEpe3ZhciBiPWEuY29tcG9zZWRQYXRoKCk7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJjdXJyZW50VGFyZ2V0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiBkfSxjb25maWd1cmFibGU6ITB9KTtmb3IodmFyIGM9Yi5sZW5ndGgtMTswPD1jO2MtLSl7dmFyIGQ9YltjXTtXYyhhLGQsXCJjYXB0dXJlXCIpO2lmKGEuJClyZXR1cm59T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJldmVudFBoYXNlXCIse2dldDpmdW5jdGlvbigpe3JldHVybiBFdmVudC5BVF9UQVJHRVR9fSk7dmFyIGU7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKyl7ZD1iW2NdO3ZhciBmPWQuX19zaGFkeSYmZC5fX3NoYWR5LnJvb3Q7aWYoMD09PWN8fGYmJmY9PT1lKWlmKFdjKGEsZCxcImJ1YmJsZVwiKSxkIT09d2luZG93JiYoZT1kLmdldFJvb3ROb2RlKCkpLGEuJClicmVha319XG5mdW5jdGlvbiBZYyhhLGIsYyxkLGUsZil7Zm9yKHZhciBoPTA7aDxhLmxlbmd0aDtoKyspe3ZhciBnPWFbaF0saz1nLnR5cGUsbD1nLmNhcHR1cmUsbT1nLm9uY2Usbj1nLnBhc3NpdmU7aWYoYj09PWcubm9kZSYmYz09PWsmJmQ9PT1sJiZlPT09bSYmZj09PW4pcmV0dXJuIGh9cmV0dXJuLTF9XG5mdW5jdGlvbiBaYyhhLGIsYyl7aWYoYil7aWYoYyYmXCJvYmplY3RcIj09PXR5cGVvZiBjKXt2YXIgZD0hIWMuY2FwdHVyZTt2YXIgZT0hIWMub25jZTt2YXIgZj0hIWMucGFzc2l2ZX1lbHNlIGQ9ISFjLGY9ZT0hMTt2YXIgaD1jJiZjLmJhfHx0aGlzLGc9YltPY107aWYoZyl7aWYoLTE8WWMoZyxoLGEsZCxlLGYpKXJldHVybn1lbHNlIGJbT2NdPVtdO2c9ZnVuY3Rpb24oZCl7ZSYmdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGEsYixjKTtkLl9fdGFyZ2V0fHwkYyhkKTtpZihoIT09dGhpcyl7dmFyIGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkLFwiY3VycmVudFRhcmdldFwiKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoZCxcImN1cnJlbnRUYXJnZXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGh9LGNvbmZpZ3VyYWJsZTohMH0pfWlmKGQuY29tcG9zZWR8fC0xPGQuY29tcG9zZWRQYXRoKCkuaW5kZXhPZihoKSlpZihWYyhkKSYmZC50YXJnZXQ9PT1kLnJlbGF0ZWRUYXJnZXQpZC5ldmVudFBoYXNlPT09XG5FdmVudC5CVUJCTElOR19QSEFTRSYmZC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtlbHNlIGlmKGQuZXZlbnRQaGFzZT09PUV2ZW50LkNBUFRVUklOR19QSEFTRXx8ZC5idWJibGVzfHxkLnRhcmdldD09PWh8fGggaW5zdGFuY2VvZiBXaW5kb3cpe3ZhciBnPVwib2JqZWN0XCI9PT10eXBlb2YgYiYmYi5oYW5kbGVFdmVudD9iLmhhbmRsZUV2ZW50KGQpOmIuY2FsbChoLGQpO2ghPT10aGlzJiYoZj8oT2JqZWN0LmRlZmluZVByb3BlcnR5KGQsXCJjdXJyZW50VGFyZ2V0XCIsZiksZj1udWxsKTpkZWxldGUgZC5jdXJyZW50VGFyZ2V0KTtyZXR1cm4gZ319O2JbT2NdLnB1c2goe25vZGU6dGhpcyx0eXBlOmEsY2FwdHVyZTpkLG9uY2U6ZSxwYXNzaXZlOmYsY2I6Z30pO1VjW2FdPyh0aGlzLl9faGFuZGxlcnM9dGhpcy5fX2hhbmRsZXJzfHx7fSx0aGlzLl9faGFuZGxlcnNbYV09dGhpcy5fX2hhbmRsZXJzW2FdfHx7Y2FwdHVyZTpbXSxidWJibGU6W119LHRoaXMuX19oYW5kbGVyc1thXVtkP1xuXCJjYXB0dXJlXCI6XCJidWJibGVcIl0ucHVzaChnKSk6KHRoaXMgaW5zdGFuY2VvZiBXaW5kb3c/QS5hYjpBLmFkZEV2ZW50TGlzdGVuZXIpLmNhbGwodGhpcyxhLGcsYyl9fVxuZnVuY3Rpb24gYWQoYSxiLGMpe2lmKGIpe2lmKGMmJlwib2JqZWN0XCI9PT10eXBlb2YgYyl7dmFyIGQ9ISFjLmNhcHR1cmU7dmFyIGU9ISFjLm9uY2U7dmFyIGY9ISFjLnBhc3NpdmV9ZWxzZSBkPSEhYyxmPWU9ITE7dmFyIGg9YyYmYy5iYXx8dGhpcyxnPXZvaWQgMDt2YXIgaz1udWxsO3RyeXtrPWJbT2NdfWNhdGNoKGwpe31rJiYoZT1ZYyhrLGgsYSxkLGUsZiksLTE8ZSYmKGc9ay5zcGxpY2UoZSwxKVswXS5jYixrLmxlbmd0aHx8KGJbT2NdPXZvaWQgMCkpKTsodGhpcyBpbnN0YW5jZW9mIFdpbmRvdz9BLmJiOkEucmVtb3ZlRXZlbnRMaXN0ZW5lcikuY2FsbCh0aGlzLGEsZ3x8YixjKTtnJiZVY1thXSYmdGhpcy5fX2hhbmRsZXJzJiZ0aGlzLl9faGFuZGxlcnNbYV0mJihhPXRoaXMuX19oYW5kbGVyc1thXVtkP1wiY2FwdHVyZVwiOlwiYnViYmxlXCJdLGc9YS5pbmRleE9mKGcpLC0xPGcmJmEuc3BsaWNlKGcsMSkpfX1cbmZ1bmN0aW9uIGJkKCl7Zm9yKHZhciBhIGluIFVjKXdpbmRvdy5hZGRFdmVudExpc3RlbmVyKGEsZnVuY3Rpb24oYSl7YS5fX3RhcmdldHx8KCRjKGEpLFhjKGEpKX0sITApfWZ1bmN0aW9uICRjKGEpe2EuX190YXJnZXQ9YS50YXJnZXQ7YS5hYT1hLnJlbGF0ZWRUYXJnZXQ7aWYoeS5NKXt2YXIgYj1PYmplY3QuZ2V0UHJvdG90eXBlT2YoYSk7aWYoIWIuaGFzT3duUHJvcGVydHkoXCJfX3BhdGNoUHJvdG9cIikpe3ZhciBjPU9iamVjdC5jcmVhdGUoYik7Yy5mYj1iO3ViKGMsU2MpO2IuX19wYXRjaFByb3RvPWN9YS5fX3Byb3RvX189Yi5fX3BhdGNoUHJvdG99ZWxzZSB1YihhLFNjKX12YXIgY2Q9VGMod2luZG93LkV2ZW50KSxkZD1UYyh3aW5kb3cuQ3VzdG9tRXZlbnQpLGVkPVRjKHdpbmRvdy5Nb3VzZUV2ZW50KTtmdW5jdGlvbiBmZChhLGIpe3JldHVybntpbmRleDphLE86W10sVTpifX1cbmZ1bmN0aW9uIGdkKGEsYixjLGQpe3ZhciBlPTAsZj0wLGg9MCxnPTAsaz1NYXRoLm1pbihiLWUsZC1mKTtpZigwPT1lJiYwPT1mKWE6e2ZvcihoPTA7aDxrO2grKylpZihhW2hdIT09Y1toXSlicmVhayBhO2g9a31pZihiPT1hLmxlbmd0aCYmZD09Yy5sZW5ndGgpe2c9YS5sZW5ndGg7Zm9yKHZhciBsPWMubGVuZ3RoLG09MDttPGstaCYmaGQoYVstLWddLGNbLS1sXSk7KW0rKztnPW19ZSs9aDtmKz1oO2ItPWc7ZC09ZztpZigwPT1iLWUmJjA9PWQtZilyZXR1cm5bXTtpZihlPT1iKXtmb3IoYj1mZChlLDApO2Y8ZDspYi5PLnB1c2goY1tmKytdKTtyZXR1cm5bYl19aWYoZj09ZClyZXR1cm5bZmQoZSxiLWUpXTtrPWU7aD1mO2Q9ZC1oKzE7Zz1iLWsrMTtiPUFycmF5KGQpO2ZvcihsPTA7bDxkO2wrKyliW2xdPUFycmF5KGcpLGJbbF1bMF09bDtmb3IobD0wO2w8ZztsKyspYlswXVtsXT1sO2ZvcihsPTE7bDxkO2wrKylmb3IobT0xO208ZzttKyspaWYoYVtrK20tMV09PT1jW2grbC0xXSliW2xdW21dPVxuYltsLTFdW20tMV07ZWxzZXt2YXIgbj1iW2wtMV1bbV0rMSx3PWJbbF1bbS0xXSsxO2JbbF1bbV09bjx3P246d31rPWIubGVuZ3RoLTE7aD1iWzBdLmxlbmd0aC0xO2Q9YltrXVtoXTtmb3IoYT1bXTswPGt8fDA8aDspMD09az8oYS5wdXNoKDIpLGgtLSk6MD09aD8oYS5wdXNoKDMpLGstLSk6KGc9YltrLTFdW2gtMV0sbD1iW2stMV1baF0sbT1iW2tdW2gtMV0sbj1sPG0/bDxnP2w6ZzptPGc/bTpnLG49PWc/KGc9PWQ/YS5wdXNoKDApOihhLnB1c2goMSksZD1nKSxrLS0saC0tKTpuPT1sPyhhLnB1c2goMyksay0tLGQ9bCk6KGEucHVzaCgyKSxoLS0sZD1tKSk7YS5yZXZlcnNlKCk7Yj12b2lkIDA7az1bXTtmb3IoaD0wO2g8YS5sZW5ndGg7aCsrKXN3aXRjaChhW2hdKXtjYXNlIDA6YiYmKGsucHVzaChiKSxiPXZvaWQgMCk7ZSsrO2YrKzticmVhaztjYXNlIDE6Ynx8KGI9ZmQoZSwwKSk7Yi5VKys7ZSsrO2IuTy5wdXNoKGNbZl0pO2YrKzticmVhaztjYXNlIDI6Ynx8KGI9ZmQoZSwwKSk7XG5iLlUrKztlKys7YnJlYWs7Y2FzZSAzOmJ8fChiPWZkKGUsMCkpLGIuTy5wdXNoKGNbZl0pLGYrK31iJiZrLnB1c2goYik7cmV0dXJuIGt9ZnVuY3Rpb24gaGQoYSxiKXtyZXR1cm4gYT09PWJ9O3ZhciBpZD17fTtmdW5jdGlvbiBHKGEsYixjKXtpZihhIT09aWQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIklsbGVnYWwgY29uc3RydWN0b3JcIik7YT1kb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7YS5fX3Byb3RvX189Ry5wcm90b3R5cGU7YS5BYT1cIlNoYWR5Um9vdFwiO3ZjKGIpO3ZjKGEpO2EuaG9zdD1iO2EuYT1jJiZjLm1vZGU7Yi5fX3NoYWR5PWIuX19zaGFkeXx8e307Yi5fX3NoYWR5LnJvb3Q9YTtiLl9fc2hhZHkuVWE9XCJjbG9zZWRcIiE9PWEuYT9hOm51bGw7YS5UPSExO2Eucz1bXTthLmw9e307YS5IPVtdO2M9Qi5jaGlsZE5vZGVzKGIpO2Zvcih2YXIgZD0wLGU9Yy5sZW5ndGg7ZDxlO2QrKylBLnJlbW92ZUNoaWxkLmNhbGwoYixjW2RdKTtyZXR1cm4gYX1HLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlKTtmdW5jdGlvbiB5YyhhKXthLlR8fChhLlQ9ITAsRmIoZnVuY3Rpb24oKXtyZXR1cm4gamQoYSl9KSl9XG5mdW5jdGlvbiBqZChhKXtmb3IodmFyIGI7YTspe2EuVCYmKGI9YSk7YTp7dmFyIGM9YTthPWMuaG9zdC5nZXRSb290Tm9kZSgpO2lmKHooYSkpZm9yKHZhciBkPWMuaG9zdC5jaGlsZE5vZGVzLGU9MDtlPGQubGVuZ3RoO2UrKylpZihjPWRbZV0sXCJzbG90XCI9PWMubG9jYWxOYW1lKWJyZWFrIGE7YT12b2lkIDB9fWImJmIuX3JlbmRlclJvb3QoKX1cbkcucHJvdG90eXBlLl9yZW5kZXJSb290PWZ1bmN0aW9uKCl7dGhpcy5UPSExO0RjKHRoaXMpO2Zvcih2YXIgYT0wLGI7YTx0aGlzLnMubGVuZ3RoO2ErKyl7Yj10aGlzLnNbYV07dmFyIGM9Yi5fX3NoYWR5LmFzc2lnbmVkTm9kZXM7Yi5fX3NoYWR5LmFzc2lnbmVkTm9kZXM9W107Yi5fX3NoYWR5Lks9W107aWYoYi5fX3NoYWR5LnFhPWMpZm9yKHZhciBkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF07ZS5fX3NoYWR5LmdhPWUuX19zaGFkeS5hc3NpZ25lZFNsb3Q7ZS5fX3NoYWR5LmFzc2lnbmVkU2xvdD09PWImJihlLl9fc2hhZHkuYXNzaWduZWRTbG90PW51bGwpfX1mb3IoYj10aGlzLmhvc3QuZmlyc3RDaGlsZDtiO2I9Yi5uZXh0U2libGluZylrZCh0aGlzLGIpO2ZvcihhPTA7YTx0aGlzLnMubGVuZ3RoO2ErKyl7Yj10aGlzLnNbYV07aWYoIWIuX19zaGFkeS5hc3NpZ25lZE5vZGVzLmxlbmd0aClmb3IoYz1iLmZpcnN0Q2hpbGQ7YztjPWMubmV4dFNpYmxpbmcpa2QodGhpcyxcbmMsYik7Yz1iLnBhcmVudE5vZGU7KGM9Yy5fX3NoYWR5JiZjLl9fc2hhZHkucm9vdCkmJkVjKGMpJiZjLl9yZW5kZXJSb290KCk7bGQodGhpcyxiLl9fc2hhZHkuSyxiLl9fc2hhZHkuYXNzaWduZWROb2Rlcyk7aWYoYz1iLl9fc2hhZHkucWEpe2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspY1tkXS5fX3NoYWR5LmdhPW51bGw7Yi5fX3NoYWR5LnFhPW51bGw7Yy5sZW5ndGg+Yi5fX3NoYWR5LmFzc2lnbmVkTm9kZXMubGVuZ3RoJiYoYi5fX3NoYWR5LmlhPSEwKX1iLl9fc2hhZHkuaWEmJihiLl9fc2hhZHkuaWE9ITEsbWQodGhpcyxiKSl9YT10aGlzLnM7Yj1bXTtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWQ9YVtjXS5wYXJlbnROb2RlLGQuX19zaGFkeSYmZC5fX3NoYWR5LnJvb3R8fCEoMD5iLmluZGV4T2YoZCkpfHxiLnB1c2goZCk7Zm9yKGE9MDthPGIubGVuZ3RoO2ErKyl7Yz1iW2FdO2Q9Yz09PXRoaXM/dGhpcy5ob3N0OmM7ZT1bXTtjPWMuY2hpbGROb2Rlcztmb3IodmFyIGY9MDtmPFxuYy5sZW5ndGg7ZisrKXt2YXIgaD1jW2ZdO2lmKFwic2xvdFwiPT1oLmxvY2FsTmFtZSl7aD1oLl9fc2hhZHkuSztmb3IodmFyIGc9MDtnPGgubGVuZ3RoO2crKyllLnB1c2goaFtnXSl9ZWxzZSBlLnB1c2goaCl9Yz12b2lkIDA7Zj1CLmNoaWxkTm9kZXMoZCk7aD1nZChlLGUubGVuZ3RoLGYsZi5sZW5ndGgpO2Zvcih2YXIgaz1nPTA7ZzxoLmxlbmd0aCYmKGM9aFtnXSk7ZysrKXtmb3IodmFyIGw9MCxtO2w8Yy5PLmxlbmd0aCYmKG09Yy5PW2xdKTtsKyspQi5wYXJlbnROb2RlKG0pPT09ZCYmQS5yZW1vdmVDaGlsZC5jYWxsKGQsbSksZi5zcGxpY2UoYy5pbmRleCtrLDEpO2stPWMuVX1mb3Ioaz0wO2s8aC5sZW5ndGgmJihjPWhba10pO2srKylmb3IoZz1mW2MuaW5kZXhdLGw9Yy5pbmRleDtsPGMuaW5kZXgrYy5VO2wrKyltPWVbbF0sQS5pbnNlcnRCZWZvcmUuY2FsbChkLG0sZyksZi5zcGxpY2UobCwwLG0pfX07XG5mdW5jdGlvbiBrZChhLGIsYyl7Yi5fX3NoYWR5PWIuX19zaGFkeXx8e307dmFyIGQ9Yi5fX3NoYWR5LmdhO2IuX19zaGFkeS5nYT1udWxsO2N8fChjPShhPWEubFtiLnNsb3R8fFwiX19jYXRjaGFsbFwiXSkmJmFbMF0pO2M/KGMuX19zaGFkeS5hc3NpZ25lZE5vZGVzLnB1c2goYiksYi5fX3NoYWR5LmFzc2lnbmVkU2xvdD1jKTpiLl9fc2hhZHkuYXNzaWduZWRTbG90PXZvaWQgMDtkIT09Yi5fX3NoYWR5LmFzc2lnbmVkU2xvdCYmYi5fX3NoYWR5LmFzc2lnbmVkU2xvdCYmKGIuX19zaGFkeS5hc3NpZ25lZFNsb3QuX19zaGFkeS5pYT0hMCl9ZnVuY3Rpb24gbGQoYSxiLGMpe2Zvcih2YXIgZD0wLGU7ZDxjLmxlbmd0aCYmKGU9Y1tkXSk7ZCsrKWlmKFwic2xvdFwiPT1lLmxvY2FsTmFtZSl7dmFyIGY9ZS5fX3NoYWR5LmFzc2lnbmVkTm9kZXM7ZiYmZi5sZW5ndGgmJmxkKGEsYixmKX1lbHNlIGIucHVzaChjW2RdKX1cbmZ1bmN0aW9uIG1kKGEsYil7QS5kaXNwYXRjaEV2ZW50LmNhbGwoYixuZXcgRXZlbnQoXCJzbG90Y2hhbmdlXCIpKTtiLl9fc2hhZHkuYXNzaWduZWRTbG90JiZtZChhLGIuX19zaGFkeS5hc3NpZ25lZFNsb3QpfWZ1bmN0aW9uIERjKGEpe2lmKGEuSC5sZW5ndGgpe2Zvcih2YXIgYj1hLkgsYyxkPTA7ZDxiLmxlbmd0aDtkKyspe3ZhciBlPWJbZF07ZS5fX3NoYWR5PWUuX19zaGFkeXx8e307dmMoZSk7dmMoZS5wYXJlbnROb2RlKTt2YXIgZj1HYyhlKTthLmxbZl0/KGM9Y3x8e30sY1tmXT0hMCxhLmxbZl0ucHVzaChlKSk6YS5sW2ZdPVtlXTthLnMucHVzaChlKX1pZihjKWZvcih2YXIgaCBpbiBjKWEubFtoXT1IYyhhLmxbaF0pO2EuSD1bXX19ZnVuY3Rpb24gR2MoYSl7dmFyIGI9YS5uYW1lfHxhLmdldEF0dHJpYnV0ZShcIm5hbWVcIil8fFwiX19jYXRjaGFsbFwiO3JldHVybiBhLkNhPWJ9XG5mdW5jdGlvbiBIYyhhKXtyZXR1cm4gYS5zb3J0KGZ1bmN0aW9uKGEsYyl7YT1uZChhKTtmb3IodmFyIGI9bmQoYyksZT0wO2U8YS5sZW5ndGg7ZSsrKXtjPWFbZV07dmFyIGY9YltlXTtpZihjIT09ZilyZXR1cm4gYT1BcnJheS5mcm9tKGMucGFyZW50Tm9kZS5jaGlsZE5vZGVzKSxhLmluZGV4T2YoYyktYS5pbmRleE9mKGYpfX0pfWZ1bmN0aW9uIG5kKGEpe3ZhciBiPVtdO2RvIGIudW5zaGlmdChhKTt3aGlsZShhPWEucGFyZW50Tm9kZSk7cmV0dXJuIGJ9ZnVuY3Rpb24gRWMoYSl7RGMoYSk7cmV0dXJuISFhLnMubGVuZ3RofUcucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiLGMpe1wib2JqZWN0XCIhPT10eXBlb2YgYyYmKGM9e2NhcHR1cmU6ISFjfSk7Yy5iYT10aGlzO3RoaXMuaG9zdC5hZGRFdmVudExpc3RlbmVyKGEsYixjKX07XG5HLnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyPWZ1bmN0aW9uKGEsYixjKXtcIm9iamVjdFwiIT09dHlwZW9mIGMmJihjPXtjYXB0dXJlOiEhY30pO2MuYmE9dGhpczt0aGlzLmhvc3QucmVtb3ZlRXZlbnRMaXN0ZW5lcihhLGIsYyl9O0cucHJvdG90eXBlLmdldEVsZW1lbnRCeUlkPWZ1bmN0aW9uKGEpe3JldHVybiBKYyh0aGlzLGZ1bmN0aW9uKGIpe3JldHVybiBiLmlkPT1hfSxmdW5jdGlvbihhKXtyZXR1cm4hIWF9KVswXXx8bnVsbH07dmFyIG9kPUcucHJvdG90eXBlO0Uob2QsbWMsITApO0Uob2QscmMsITApO2Z1bmN0aW9uIHBkKGEpe3ZhciBiPWEuZ2V0Um9vdE5vZGUoKTt6KGIpJiZqZChiKTtyZXR1cm4gYS5fX3NoYWR5JiZhLl9fc2hhZHkuYXNzaWduZWRTbG90fHxudWxsfVxudmFyIHFkPXthZGRFdmVudExpc3RlbmVyOlpjLmJpbmQod2luZG93KSxyZW1vdmVFdmVudExpc3RlbmVyOmFkLmJpbmQod2luZG93KX0scmQ9e2FkZEV2ZW50TGlzdGVuZXI6WmMscmVtb3ZlRXZlbnRMaXN0ZW5lcjphZCxhcHBlbmRDaGlsZDpmdW5jdGlvbihhKXtyZXR1cm4gd2ModGhpcyxhKX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIHdjKHRoaXMsYSxiKX0scmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24oYSl7cmV0dXJuIHhjKHRoaXMsYSl9LHJlcGxhY2VDaGlsZDpmdW5jdGlvbihhLGIpe3djKHRoaXMsYSxiKTt4Yyh0aGlzLGIpO3JldHVybiBhfSxjbG9uZU5vZGU6ZnVuY3Rpb24oYSl7aWYoXCJ0ZW1wbGF0ZVwiPT10aGlzLmxvY2FsTmFtZSl2YXIgYj1BLmNsb25lTm9kZS5jYWxsKHRoaXMsYSk7ZWxzZSBpZihiPUEuY2xvbmVOb2RlLmNhbGwodGhpcywhMSksYSl7YT10aGlzLmNoaWxkTm9kZXM7Zm9yKHZhciBjPTAsZDtjPGEubGVuZ3RoO2MrKylkPWFbY10uY2xvbmVOb2RlKCEwKSxcbmIuYXBwZW5kQ2hpbGQoZCl9cmV0dXJuIGJ9LGdldFJvb3ROb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIEljKHRoaXMpfSxjb250YWluczpmdW5jdGlvbihhKXtyZXR1cm4gQ2IodGhpcyxhKX0sZ2V0IGlzQ29ubmVjdGVkKCl7dmFyIGE9dGhpcy5vd25lckRvY3VtZW50O2lmKEJiJiZBLmNvbnRhaW5zLmNhbGwoYSx0aGlzKXx8YS5kb2N1bWVudEVsZW1lbnQmJkEuY29udGFpbnMuY2FsbChhLmRvY3VtZW50RWxlbWVudCx0aGlzKSlyZXR1cm4hMDtmb3IoYT10aGlzO2EmJiEoYSBpbnN0YW5jZW9mIERvY3VtZW50KTspYT1hLnBhcmVudE5vZGV8fChhIGluc3RhbmNlb2YgRz9hLmhvc3Q6dm9pZCAwKTtyZXR1cm4hIShhJiZhIGluc3RhbmNlb2YgRG9jdW1lbnQpfSxkaXNwYXRjaEV2ZW50OmZ1bmN0aW9uKGEpe0diKCk7cmV0dXJuIEEuZGlzcGF0Y2hFdmVudC5jYWxsKHRoaXMsYSl9fSxzZD17Z2V0IGFzc2lnbmVkU2xvdCgpe3JldHVybiBwZCh0aGlzKX19LHRkPXtxdWVyeVNlbGVjdG9yOmZ1bmN0aW9uKGEpe3JldHVybiBKYyh0aGlzLFxuZnVuY3Rpb24oYil7cmV0dXJuIHRiLmNhbGwoYixhKX0sZnVuY3Rpb24oYSl7cmV0dXJuISFhfSlbMF18fG51bGx9LHF1ZXJ5U2VsZWN0b3JBbGw6ZnVuY3Rpb24oYSl7cmV0dXJuIEpjKHRoaXMsZnVuY3Rpb24oYil7cmV0dXJuIHRiLmNhbGwoYixhKX0pfX0sdWQ9e2Fzc2lnbmVkTm9kZXM6ZnVuY3Rpb24oYSl7aWYoXCJzbG90XCI9PT10aGlzLmxvY2FsTmFtZSl7dmFyIGI9dGhpcy5nZXRSb290Tm9kZSgpO3ooYikmJmpkKGIpO3JldHVybiB0aGlzLl9fc2hhZHk/KGEmJmEuZmxhdHRlbj90aGlzLl9fc2hhZHkuSzp0aGlzLl9fc2hhZHkuYXNzaWduZWROb2Rlcyl8fFtdOltdfX19LHZkPXZiKHtzZXRBdHRyaWJ1dGU6ZnVuY3Rpb24oYSxiKXtNYyh0aGlzLGEsYil9LHJlbW92ZUF0dHJpYnV0ZTpmdW5jdGlvbihhKXtBLnJlbW92ZUF0dHJpYnV0ZS5jYWxsKHRoaXMsYSk7RmModGhpcyxhKX0sYXR0YWNoU2hhZG93OmZ1bmN0aW9uKGEpe2lmKCF0aGlzKXRocm93XCJNdXN0IHByb3ZpZGUgYSBob3N0LlwiO1xuaWYoIWEpdGhyb3dcIk5vdCBlbm91Z2ggYXJndW1lbnRzLlwiO3JldHVybiBuZXcgRyhpZCx0aGlzLGEpfSxnZXQgc2xvdCgpe3JldHVybiB0aGlzLmdldEF0dHJpYnV0ZShcInNsb3RcIil9LHNldCBzbG90KGEpe01jKHRoaXMsXCJzbG90XCIsYSl9LGdldCBhc3NpZ25lZFNsb3QoKXtyZXR1cm4gcGQodGhpcyl9fSx0ZCx1ZCk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXModmQscWMpO3ZhciB3ZD12Yih7aW1wb3J0Tm9kZTpmdW5jdGlvbihhLGIpe3JldHVybiBOYyhhLGIpfSxnZXRFbGVtZW50QnlJZDpmdW5jdGlvbihhKXtyZXR1cm4gSmModGhpcyxmdW5jdGlvbihiKXtyZXR1cm4gYi5pZD09YX0sZnVuY3Rpb24oYSl7cmV0dXJuISFhfSlbMF18fG51bGx9fSx0ZCk7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMod2Qse19hY3RpdmVFbGVtZW50OnJjLmFjdGl2ZUVsZW1lbnR9KTtcbnZhciB4ZD1IVE1MRWxlbWVudC5wcm90b3R5cGUuYmx1cix5ZD12Yih7Ymx1cjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX19zaGFkeSYmdGhpcy5fX3NoYWR5LnJvb3Q7KGE9YSYmYS5hY3RpdmVFbGVtZW50KT9hLmJsdXIoKTp4ZC5jYWxsKHRoaXMpfX0pO2Z1bmN0aW9uIEgoYSxiKXtmb3IodmFyIGM9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYiksZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLGY9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiLGUpO2YudmFsdWU/YVtlXT1mLnZhbHVlOk9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGUsZil9fTtpZih5LnRhKXt2YXIgU2hhZHlET009e2luVXNlOnkudGEscGF0Y2g6ZnVuY3Rpb24oYSl7cmV0dXJuIGF9LGlzU2hhZHlSb290OnosZW5xdWV1ZTpGYixmbHVzaDpHYixzZXR0aW5nczp5LGZpbHRlck11dGF0aW9uczpNYixvYnNlcnZlQ2hpbGRyZW46S2IsdW5vYnNlcnZlQ2hpbGRyZW46TGIsbmF0aXZlTWV0aG9kczpBLG5hdGl2ZVRyZWU6Qn07d2luZG93LlNoYWR5RE9NPVNoYWR5RE9NO3dpbmRvdy5FdmVudD1jZDt3aW5kb3cuQ3VzdG9tRXZlbnQ9ZGQ7d2luZG93Lk1vdXNlRXZlbnQ9ZWQ7YmQoKTt2YXIgemQ9d2luZG93LmN1c3RvbUVsZW1lbnRzJiZ3aW5kb3cuY3VzdG9tRWxlbWVudHMubmF0aXZlSFRNTEVsZW1lbnR8fEhUTUxFbGVtZW50O0god2luZG93Lk5vZGUucHJvdG90eXBlLHJkKTtIKHdpbmRvdy5XaW5kb3cucHJvdG90eXBlLHFkKTtIKHdpbmRvdy5UZXh0LnByb3RvdHlwZSxzZCk7SCh3aW5kb3cuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUsdGQpO0god2luZG93LkVsZW1lbnQucHJvdG90eXBlLFxudmQpO0god2luZG93LkRvY3VtZW50LnByb3RvdHlwZSx3ZCk7d2luZG93LkhUTUxTbG90RWxlbWVudCYmSCh3aW5kb3cuSFRNTFNsb3RFbGVtZW50LnByb3RvdHlwZSx1ZCk7SCh6ZC5wcm90b3R5cGUseWQpO3kuTSYmKEYod2luZG93Lk5vZGUucHJvdG90eXBlKSxGKHdpbmRvdy5UZXh0LnByb3RvdHlwZSksRih3aW5kb3cuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUpLEYod2luZG93LkVsZW1lbnQucHJvdG90eXBlKSxGKHpkLnByb3RvdHlwZSksRih3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlKSx3aW5kb3cuSFRNTFNsb3RFbGVtZW50JiZGKHdpbmRvdy5IVE1MU2xvdEVsZW1lbnQucHJvdG90eXBlKSk7d2luZG93LlNoYWRvd1Jvb3Q9R307dmFyIEFkPW5ldyBTZXQoXCJhbm5vdGF0aW9uLXhtbCBjb2xvci1wcm9maWxlIGZvbnQtZmFjZSBmb250LWZhY2Utc3JjIGZvbnQtZmFjZS11cmkgZm9udC1mYWNlLWZvcm1hdCBmb250LWZhY2UtbmFtZSBtaXNzaW5nLWdseXBoXCIuc3BsaXQoXCIgXCIpKTtmdW5jdGlvbiBCZChhKXt2YXIgYj1BZC5oYXMoYSk7YT0vXlthLXpdWy4wLTlfYS16XSotW1xcLS4wLTlfYS16XSokLy50ZXN0KGEpO3JldHVybiFiJiZhfWZ1bmN0aW9uIEooYSl7dmFyIGI9YS5pc0Nvbm5lY3RlZDtpZih2b2lkIDAhPT1iKXJldHVybiBiO2Zvcig7YSYmIShhLl9fQ0VfaXNJbXBvcnREb2N1bWVudHx8YSBpbnN0YW5jZW9mIERvY3VtZW50KTspYT1hLnBhcmVudE5vZGV8fCh3aW5kb3cuU2hhZG93Um9vdCYmYSBpbnN0YW5jZW9mIFNoYWRvd1Jvb3Q/YS5ob3N0OnZvaWQgMCk7cmV0dXJuISghYXx8IShhLl9fQ0VfaXNJbXBvcnREb2N1bWVudHx8YSBpbnN0YW5jZW9mIERvY3VtZW50KSl9XG5mdW5jdGlvbiBDZChhLGIpe2Zvcig7YiYmYiE9PWEmJiFiLm5leHRTaWJsaW5nOyliPWIucGFyZW50Tm9kZTtyZXR1cm4gYiYmYiE9PWE/Yi5uZXh0U2libGluZzpudWxsfVxuZnVuY3Rpb24gSyhhLGIsYyl7Yz12b2lkIDA9PT1jP25ldyBTZXQ6Yztmb3IodmFyIGQ9YTtkOyl7aWYoZC5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFKXt2YXIgZT1kO2IoZSk7dmFyIGY9ZS5sb2NhbE5hbWU7aWYoXCJsaW5rXCI9PT1mJiZcImltcG9ydFwiPT09ZS5nZXRBdHRyaWJ1dGUoXCJyZWxcIikpe2Q9ZS5pbXBvcnQ7aWYoZCBpbnN0YW5jZW9mIE5vZGUmJiFjLmhhcyhkKSlmb3IoYy5hZGQoZCksZD1kLmZpcnN0Q2hpbGQ7ZDtkPWQubmV4dFNpYmxpbmcpSyhkLGIsYyk7ZD1DZChhLGUpO2NvbnRpbnVlfWVsc2UgaWYoXCJ0ZW1wbGF0ZVwiPT09Zil7ZD1DZChhLGUpO2NvbnRpbnVlfWlmKGU9ZS5fX0NFX3NoYWRvd1Jvb3QpZm9yKGU9ZS5maXJzdENoaWxkO2U7ZT1lLm5leHRTaWJsaW5nKUsoZSxiLGMpfWQ9ZC5maXJzdENoaWxkP2QuZmlyc3RDaGlsZDpDZChhLGQpfX1mdW5jdGlvbiBMKGEsYixjKXthW2JdPWN9O2Z1bmN0aW9uIERkKCl7dGhpcy5hPW5ldyBNYXA7dGhpcy5vPW5ldyBNYXA7dGhpcy5oPVtdO3RoaXMuYz0hMX1mdW5jdGlvbiBFZChhLGIsYyl7YS5hLnNldChiLGMpO2Euby5zZXQoYy5jb25zdHJ1Y3RvcixjKX1mdW5jdGlvbiBGZChhLGIpe2EuYz0hMDthLmgucHVzaChiKX1mdW5jdGlvbiBHZChhLGIpe2EuYyYmSyhiLGZ1bmN0aW9uKGIpe3JldHVybiBhLmIoYil9KX1EZC5wcm90b3R5cGUuYj1mdW5jdGlvbihhKXtpZih0aGlzLmMmJiFhLl9fQ0VfcGF0Y2hlZCl7YS5fX0NFX3BhdGNoZWQ9ITA7Zm9yKHZhciBiPTA7Yjx0aGlzLmgubGVuZ3RoO2IrKyl0aGlzLmhbYl0oYSl9fTtmdW5jdGlvbiBNKGEsYil7dmFyIGM9W107SyhiLGZ1bmN0aW9uKGEpe3JldHVybiBjLnB1c2goYSl9KTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdOzE9PT1kLl9fQ0Vfc3RhdGU/YS5jb25uZWN0ZWRDYWxsYmFjayhkKTpIZChhLGQpfX1cbmZ1bmN0aW9uIE4oYSxiKXt2YXIgYz1bXTtLKGIsZnVuY3Rpb24oYSl7cmV0dXJuIGMucHVzaChhKX0pO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspe3ZhciBkPWNbYl07MT09PWQuX19DRV9zdGF0ZSYmYS5kaXNjb25uZWN0ZWRDYWxsYmFjayhkKX19XG5mdW5jdGlvbiBPKGEsYixjKXtjPXZvaWQgMD09PWM/e306Yzt2YXIgZD1jLiRhfHxuZXcgU2V0LGU9Yy53YXx8ZnVuY3Rpb24oYil7cmV0dXJuIEhkKGEsYil9LGY9W107SyhiLGZ1bmN0aW9uKGIpe2lmKFwibGlua1wiPT09Yi5sb2NhbE5hbWUmJlwiaW1wb3J0XCI9PT1iLmdldEF0dHJpYnV0ZShcInJlbFwiKSl7dmFyIGM9Yi5pbXBvcnQ7YyBpbnN0YW5jZW9mIE5vZGUmJihjLl9fQ0VfaXNJbXBvcnREb2N1bWVudD0hMCxjLl9fQ0VfaGFzUmVnaXN0cnk9ITApO2MmJlwiY29tcGxldGVcIj09PWMucmVhZHlTdGF0ZT9jLl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZD0hMDpiLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsZnVuY3Rpb24oKXt2YXIgYz1iLmltcG9ydDtpZighYy5fX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQpe2MuX19DRV9kb2N1bWVudExvYWRIYW5kbGVkPSEwO3ZhciBmPW5ldyBTZXQoZCk7Zi5kZWxldGUoYyk7TyhhLGMseyRhOmYsd2E6ZX0pfX0pfWVsc2UgZi5wdXNoKGIpfSxkKTtpZihhLmMpZm9yKGI9XG4wO2I8Zi5sZW5ndGg7YisrKWEuYihmW2JdKTtmb3IoYj0wO2I8Zi5sZW5ndGg7YisrKWUoZltiXSl9XG5mdW5jdGlvbiBIZChhLGIpe2lmKHZvaWQgMD09PWIuX19DRV9zdGF0ZSl7dmFyIGM9Yi5vd25lckRvY3VtZW50O2lmKGMuZGVmYXVsdFZpZXd8fGMuX19DRV9pc0ltcG9ydERvY3VtZW50JiZjLl9fQ0VfaGFzUmVnaXN0cnkpaWYoYz1hLmEuZ2V0KGIubG9jYWxOYW1lKSl7Yy5jb25zdHJ1Y3Rpb25TdGFjay5wdXNoKGIpO3ZhciBkPWMuY29uc3RydWN0b3I7dHJ5e3RyeXtpZihuZXcgZCE9PWIpdGhyb3cgRXJyb3IoXCJUaGUgY3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3IgZGlkIG5vdCBwcm9kdWNlIHRoZSBlbGVtZW50IGJlaW5nIHVwZ3JhZGVkLlwiKTt9ZmluYWxseXtjLmNvbnN0cnVjdGlvblN0YWNrLnBvcCgpfX1jYXRjaChoKXt0aHJvdyBiLl9fQ0Vfc3RhdGU9MixoO31iLl9fQ0Vfc3RhdGU9MTtiLl9fQ0VfZGVmaW5pdGlvbj1jO2lmKGMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKWZvcihjPWMub2JzZXJ2ZWRBdHRyaWJ1dGVzLGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXSxcbmY9Yi5nZXRBdHRyaWJ1dGUoZSk7bnVsbCE9PWYmJmEuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGIsZSxudWxsLGYsbnVsbCl9SihiKSYmYS5jb25uZWN0ZWRDYWxsYmFjayhiKX19fURkLnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjaz1mdW5jdGlvbihhKXt2YXIgYj1hLl9fQ0VfZGVmaW5pdGlvbjtiLmNvbm5lY3RlZENhbGxiYWNrJiZiLmNvbm5lY3RlZENhbGxiYWNrLmNhbGwoYSl9O0RkLnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjaz1mdW5jdGlvbihhKXt2YXIgYj1hLl9fQ0VfZGVmaW5pdGlvbjtiLmRpc2Nvbm5lY3RlZENhbGxiYWNrJiZiLmRpc2Nvbm5lY3RlZENhbGxiYWNrLmNhbGwoYSl9O1xuRGQucHJvdG90eXBlLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaz1mdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEuX19DRV9kZWZpbml0aW9uO2YuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrJiYtMTxmLm9ic2VydmVkQXR0cmlidXRlcy5pbmRleE9mKGIpJiZmLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjay5jYWxsKGEsYixjLGQsZSl9O2Z1bmN0aW9uIElkKGEpe3ZhciBiPWRvY3VtZW50O3RoaXMuaj1hO3RoaXMuYT1iO3RoaXMuQz12b2lkIDA7Tyh0aGlzLmosdGhpcy5hKTtcImxvYWRpbmdcIj09PXRoaXMuYS5yZWFkeVN0YXRlJiYodGhpcy5DPW5ldyBNdXRhdGlvbk9ic2VydmVyKHRoaXMuYi5iaW5kKHRoaXMpKSx0aGlzLkMub2JzZXJ2ZSh0aGlzLmEse2NoaWxkTGlzdDohMCxzdWJ0cmVlOiEwfSkpfWZ1bmN0aW9uIEpkKGEpe2EuQyYmYS5DLmRpc2Nvbm5lY3QoKX1JZC5wcm90b3R5cGUuYj1mdW5jdGlvbihhKXt2YXIgYj10aGlzLmEucmVhZHlTdGF0ZTtcImludGVyYWN0aXZlXCIhPT1iJiZcImNvbXBsZXRlXCIhPT1ifHxKZCh0aGlzKTtmb3IoYj0wO2I8YS5sZW5ndGg7YisrKWZvcih2YXIgYz1hW2JdLmFkZGVkTm9kZXMsZD0wO2Q8Yy5sZW5ndGg7ZCsrKU8odGhpcy5qLGNbZF0pfTtmdW5jdGlvbiBLZCgpe3ZhciBhPXRoaXM7dGhpcy5iPXRoaXMuYT12b2lkIDA7dGhpcy5jPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGIpe2EuYj1iO2EuYSYmYihhLmEpfSl9S2QucHJvdG90eXBlLnJlc29sdmU9ZnVuY3Rpb24oYSl7aWYodGhpcy5hKXRocm93IEVycm9yKFwiQWxyZWFkeSByZXNvbHZlZC5cIik7dGhpcy5hPWE7dGhpcy5iJiZ0aGlzLmIoYSl9O2Z1bmN0aW9uIFAoYSl7dGhpcy5kYT0hMTt0aGlzLmo9YTt0aGlzLmhhPW5ldyBNYXA7dGhpcy5lYT1mdW5jdGlvbihhKXtyZXR1cm4gYSgpfTt0aGlzLlI9ITE7dGhpcy5mYT1bXTt0aGlzLkZhPW5ldyBJZChhKX1cblAucHJvdG90eXBlLmRlZmluZT1mdW5jdGlvbihhLGIpe3ZhciBjPXRoaXM7aWYoIShiIGluc3RhbmNlb2YgRnVuY3Rpb24pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvcnMgbXVzdCBiZSBmdW5jdGlvbnMuXCIpO2lmKCFCZChhKSl0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgZWxlbWVudCBuYW1lICdcIithK1wiJyBpcyBub3QgdmFsaWQuXCIpO2lmKHRoaXMuai5hLmdldChhKSl0aHJvdyBFcnJvcihcIkEgY3VzdG9tIGVsZW1lbnQgd2l0aCBuYW1lICdcIithK1wiJyBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuXCIpO2lmKHRoaXMuZGEpdGhyb3cgRXJyb3IoXCJBIGN1c3RvbSBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgZGVmaW5lZC5cIik7dGhpcy5kYT0hMDt0cnl7dmFyIGQ9ZnVuY3Rpb24oYSl7dmFyIGI9ZVthXTtpZih2b2lkIDAhPT1iJiYhKGIgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgRXJyb3IoXCJUaGUgJ1wiK2ErXCInIGNhbGxiYWNrIG11c3QgYmUgYSBmdW5jdGlvbi5cIik7XG5yZXR1cm4gYn0sZT1iLnByb3RvdHlwZTtpZighKGUgaW5zdGFuY2VvZiBPYmplY3QpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgY3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3IncyBwcm90b3R5cGUgaXMgbm90IGFuIG9iamVjdC5cIik7dmFyIGY9ZChcImNvbm5lY3RlZENhbGxiYWNrXCIpO3ZhciBoPWQoXCJkaXNjb25uZWN0ZWRDYWxsYmFja1wiKTt2YXIgZz1kKFwiYWRvcHRlZENhbGxiYWNrXCIpO3ZhciBrPWQoXCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tcIik7dmFyIGw9Yi5vYnNlcnZlZEF0dHJpYnV0ZXN8fFtdfWNhdGNoKG0pe3JldHVybn1maW5hbGx5e3RoaXMuZGE9ITF9Yj17bG9jYWxOYW1lOmEsY29uc3RydWN0b3I6Yixjb25uZWN0ZWRDYWxsYmFjazpmLGRpc2Nvbm5lY3RlZENhbGxiYWNrOmgsYWRvcHRlZENhbGxiYWNrOmcsYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrOmssb2JzZXJ2ZWRBdHRyaWJ1dGVzOmwsY29uc3RydWN0aW9uU3RhY2s6W119O0VkKHRoaXMuaixhLGIpO3RoaXMuZmEucHVzaChiKTtcbnRoaXMuUnx8KHRoaXMuUj0hMCx0aGlzLmVhKGZ1bmN0aW9uKCl7cmV0dXJuIExkKGMpfSkpfTtmdW5jdGlvbiBMZChhKXtpZighMSE9PWEuUil7YS5SPSExO2Zvcih2YXIgYj1hLmZhLGM9W10sZD1uZXcgTWFwLGU9MDtlPGIubGVuZ3RoO2UrKylkLnNldChiW2VdLmxvY2FsTmFtZSxbXSk7TyhhLmosZG9jdW1lbnQse3dhOmZ1bmN0aW9uKGIpe2lmKHZvaWQgMD09PWIuX19DRV9zdGF0ZSl7dmFyIGU9Yi5sb2NhbE5hbWUsZj1kLmdldChlKTtmP2YucHVzaChiKTphLmouYS5nZXQoZSkmJmMucHVzaChiKX19fSk7Zm9yKGU9MDtlPGMubGVuZ3RoO2UrKylIZChhLmosY1tlXSk7Zm9yKDswPGIubGVuZ3RoOyl7dmFyIGY9Yi5zaGlmdCgpO2U9Zi5sb2NhbE5hbWU7Zj1kLmdldChmLmxvY2FsTmFtZSk7Zm9yKHZhciBoPTA7aDxmLmxlbmd0aDtoKyspSGQoYS5qLGZbaF0pOyhlPWEuaGEuZ2V0KGUpKSYmZS5yZXNvbHZlKHZvaWQgMCl9fX1cblAucHJvdG90eXBlLmdldD1mdW5jdGlvbihhKXtpZihhPXRoaXMuai5hLmdldChhKSlyZXR1cm4gYS5jb25zdHJ1Y3Rvcn07UC5wcm90b3R5cGUud2hlbkRlZmluZWQ9ZnVuY3Rpb24oYSl7aWYoIUJkKGEpKXJldHVybiBQcm9taXNlLnJlamVjdChuZXcgU3ludGF4RXJyb3IoXCInXCIrYStcIicgaXMgbm90IGEgdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZS5cIikpO3ZhciBiPXRoaXMuaGEuZ2V0KGEpO2lmKGIpcmV0dXJuIGIuYztiPW5ldyBLZDt0aGlzLmhhLnNldChhLGIpO3RoaXMuai5hLmdldChhKSYmIXRoaXMuZmEuc29tZShmdW5jdGlvbihiKXtyZXR1cm4gYi5sb2NhbE5hbWU9PT1hfSkmJmIucmVzb2x2ZSh2b2lkIDApO3JldHVybiBiLmN9O1AucHJvdG90eXBlLlRhPWZ1bmN0aW9uKGEpe0pkKHRoaXMuRmEpO3ZhciBiPXRoaXMuZWE7dGhpcy5lYT1mdW5jdGlvbihjKXtyZXR1cm4gYShmdW5jdGlvbigpe3JldHVybiBiKGMpfSl9fTtcbndpbmRvdy5DdXN0b21FbGVtZW50UmVnaXN0cnk9UDtQLnByb3RvdHlwZS5kZWZpbmU9UC5wcm90b3R5cGUuZGVmaW5lO1AucHJvdG90eXBlLmdldD1QLnByb3RvdHlwZS5nZXQ7UC5wcm90b3R5cGUud2hlbkRlZmluZWQ9UC5wcm90b3R5cGUud2hlbkRlZmluZWQ7UC5wcm90b3R5cGUucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjaz1QLnByb3RvdHlwZS5UYTt2YXIgTWQ9d2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LE5kPXdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudE5TLE9kPXdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuaW1wb3J0Tm9kZSxQZD13aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLnByZXBlbmQsUWQ9d2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5hcHBlbmQsUmQ9d2luZG93LkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnByZXBlbmQsU2Q9d2luZG93LkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLmFwcGVuZCxUZD13aW5kb3cuTm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlLFVkPXdpbmRvdy5Ob2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCxWZD13aW5kb3cuTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlLFdkPXdpbmRvdy5Ob2RlLnByb3RvdHlwZS5yZW1vdmVDaGlsZCxYZD13aW5kb3cuTm9kZS5wcm90b3R5cGUucmVwbGFjZUNoaWxkLFlkPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93Lk5vZGUucHJvdG90eXBlLFxuXCJ0ZXh0Q29udGVudFwiKSxaZD13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYXR0YWNoU2hhZG93LCRkPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LkVsZW1lbnQucHJvdG90eXBlLFwiaW5uZXJIVE1MXCIpLGFlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUsYmU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnNldEF0dHJpYnV0ZSxjZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlLGRlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVOUyxlZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMsZmU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZU5TLGdlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5pbnNlcnRBZGphY2VudEVsZW1lbnQsaGU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnByZXBlbmQsaWU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFwcGVuZCxcbmplPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5iZWZvcmUsa2U9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmFmdGVyLGxlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZXBsYWNlV2l0aCxtZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlLG5lPXdpbmRvdy5IVE1MRWxlbWVudCxvZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUsXCJpbm5lckhUTUxcIikscGU9d2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZS5pbnNlcnRBZGphY2VudEVsZW1lbnQ7dmFyIHFlPW5ldyBmdW5jdGlvbigpe307ZnVuY3Rpb24gcmUoKXt2YXIgYT1zZTt3aW5kb3cuSFRNTEVsZW1lbnQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBiKCl7dmFyIGI9dGhpcy5jb25zdHJ1Y3RvcixkPWEuby5nZXQoYik7aWYoIWQpdGhyb3cgRXJyb3IoXCJUaGUgY3VzdG9tIGVsZW1lbnQgYmVpbmcgY29uc3RydWN0ZWQgd2FzIG5vdCByZWdpc3RlcmVkIHdpdGggYGN1c3RvbUVsZW1lbnRzYC5cIik7dmFyIGU9ZC5jb25zdHJ1Y3Rpb25TdGFjaztpZigwPT09ZS5sZW5ndGgpcmV0dXJuIGU9TWQuY2FsbChkb2N1bWVudCxkLmxvY2FsTmFtZSksT2JqZWN0LnNldFByb3RvdHlwZU9mKGUsYi5wcm90b3R5cGUpLGUuX19DRV9zdGF0ZT0xLGUuX19DRV9kZWZpbml0aW9uPWQsYS5iKGUpLGU7ZD1lLmxlbmd0aC0xO3ZhciBmPWVbZF07aWYoZj09PXFlKXRocm93IEVycm9yKFwiVGhlIEhUTUxFbGVtZW50IGNvbnN0cnVjdG9yIHdhcyBlaXRoZXIgY2FsbGVkIHJlZW50cmFudGx5IGZvciB0aGlzIGNvbnN0cnVjdG9yIG9yIGNhbGxlZCBtdWx0aXBsZSB0aW1lcy5cIik7XG5lW2RdPXFlO09iamVjdC5zZXRQcm90b3R5cGVPZihmLGIucHJvdG90eXBlKTthLmIoZik7cmV0dXJuIGZ9Yi5wcm90b3R5cGU9bmUucHJvdG90eXBlO3JldHVybiBifSgpfTtmdW5jdGlvbiB0ZShhLGIsYyl7ZnVuY3Rpb24gZChiKXtyZXR1cm4gZnVuY3Rpb24oYyl7Zm9yKHZhciBkPVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7KytlKWRbZS0wXT1hcmd1bWVudHNbZV07ZT1bXTtmb3IodmFyIGY9W10sbD0wO2w8ZC5sZW5ndGg7bCsrKXt2YXIgbT1kW2xdO20gaW5zdGFuY2VvZiBFbGVtZW50JiZKKG0pJiZmLnB1c2gobSk7aWYobSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpZm9yKG09bS5maXJzdENoaWxkO207bT1tLm5leHRTaWJsaW5nKWUucHVzaChtKTtlbHNlIGUucHVzaChtKX1iLmFwcGx5KHRoaXMsZCk7Zm9yKGQ9MDtkPGYubGVuZ3RoO2QrKylOKGEsZltkXSk7aWYoSih0aGlzKSlmb3IoZD0wO2Q8ZS5sZW5ndGg7ZCsrKWY9ZVtkXSxmIGluc3RhbmNlb2YgRWxlbWVudCYmTShhLGYpfX12b2lkIDAhPT1jLlgmJihiLnByZXBlbmQ9ZChjLlgpKTt2b2lkIDAhPT1jLmFwcGVuZCYmKGIuYXBwZW5kPWQoYy5hcHBlbmQpKX07ZnVuY3Rpb24gdWUoKXt2YXIgYT1zZTtMKERvY3VtZW50LnByb3RvdHlwZSxcImNyZWF0ZUVsZW1lbnRcIixmdW5jdGlvbihiKXtpZih0aGlzLl9fQ0VfaGFzUmVnaXN0cnkpe3ZhciBjPWEuYS5nZXQoYik7aWYoYylyZXR1cm4gbmV3IGMuY29uc3RydWN0b3J9Yj1NZC5jYWxsKHRoaXMsYik7YS5iKGIpO3JldHVybiBifSk7TChEb2N1bWVudC5wcm90b3R5cGUsXCJpbXBvcnROb2RlXCIsZnVuY3Rpb24oYixjKXtiPU9kLmNhbGwodGhpcyxiLGMpO3RoaXMuX19DRV9oYXNSZWdpc3RyeT9PKGEsYik6R2QoYSxiKTtyZXR1cm4gYn0pO0woRG9jdW1lbnQucHJvdG90eXBlLFwiY3JlYXRlRWxlbWVudE5TXCIsZnVuY3Rpb24oYixjKXtpZih0aGlzLl9fQ0VfaGFzUmVnaXN0cnkmJihudWxsPT09Ynx8XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI9PT1iKSl7dmFyIGQ9YS5hLmdldChjKTtpZihkKXJldHVybiBuZXcgZC5jb25zdHJ1Y3Rvcn1iPU5kLmNhbGwodGhpcyxiLGMpO2EuYihiKTtyZXR1cm4gYn0pO1xudGUoYSxEb2N1bWVudC5wcm90b3R5cGUse1g6UGQsYXBwZW5kOlFkfSl9O2Z1bmN0aW9uIHZlKCl7dmFyIGE9c2U7ZnVuY3Rpb24gYihiLGQpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwidGV4dENvbnRlbnRcIix7ZW51bWVyYWJsZTpkLmVudW1lcmFibGUsY29uZmlndXJhYmxlOiEwLGdldDpkLmdldCxzZXQ6ZnVuY3Rpb24oYil7aWYodGhpcy5ub2RlVHlwZT09PU5vZGUuVEVYVF9OT0RFKWQuc2V0LmNhbGwodGhpcyxiKTtlbHNle3ZhciBjPXZvaWQgMDtpZih0aGlzLmZpcnN0Q2hpbGQpe3ZhciBlPXRoaXMuY2hpbGROb2RlcyxnPWUubGVuZ3RoO2lmKDA8ZyYmSih0aGlzKSl7Yz1BcnJheShnKTtmb3IodmFyIGs9MDtrPGc7aysrKWNba109ZVtrXX19ZC5zZXQuY2FsbCh0aGlzLGIpO2lmKGMpZm9yKGI9MDtiPGMubGVuZ3RoO2IrKylOKGEsY1tiXSl9fX0pfUwoTm9kZS5wcm90b3R5cGUsXCJpbnNlcnRCZWZvcmVcIixmdW5jdGlvbihiLGQpe2lmKGIgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYi5jaGlsZE5vZGVzKTtcbmI9VmQuY2FsbCh0aGlzLGIsZCk7aWYoSih0aGlzKSlmb3IoZD0wO2Q8Yy5sZW5ndGg7ZCsrKU0oYSxjW2RdKTtyZXR1cm4gYn1jPUooYik7ZD1WZC5jYWxsKHRoaXMsYixkKTtjJiZOKGEsYik7Sih0aGlzKSYmTShhLGIpO3JldHVybiBkfSk7TChOb2RlLnByb3RvdHlwZSxcImFwcGVuZENoaWxkXCIsZnVuY3Rpb24oYil7aWYoYiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShiLmNoaWxkTm9kZXMpO2I9VWQuY2FsbCh0aGlzLGIpO2lmKEoodGhpcykpZm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspTShhLGNbZV0pO3JldHVybiBifWM9SihiKTtlPVVkLmNhbGwodGhpcyxiKTtjJiZOKGEsYik7Sih0aGlzKSYmTShhLGIpO3JldHVybiBlfSk7TChOb2RlLnByb3RvdHlwZSxcImNsb25lTm9kZVwiLGZ1bmN0aW9uKGIpe2I9VGQuY2FsbCh0aGlzLGIpO3RoaXMub3duZXJEb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5P08oYSxiKTpcbkdkKGEsYik7cmV0dXJuIGJ9KTtMKE5vZGUucHJvdG90eXBlLFwicmVtb3ZlQ2hpbGRcIixmdW5jdGlvbihiKXt2YXIgYz1KKGIpLGU9V2QuY2FsbCh0aGlzLGIpO2MmJk4oYSxiKTtyZXR1cm4gZX0pO0woTm9kZS5wcm90b3R5cGUsXCJyZXBsYWNlQ2hpbGRcIixmdW5jdGlvbihiLGQpe2lmKGIgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KXt2YXIgYz1BcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoYi5jaGlsZE5vZGVzKTtiPVhkLmNhbGwodGhpcyxiLGQpO2lmKEoodGhpcykpZm9yKE4oYSxkKSxkPTA7ZDxjLmxlbmd0aDtkKyspTShhLGNbZF0pO3JldHVybiBifWM9SihiKTt2YXIgZj1YZC5jYWxsKHRoaXMsYixkKSxoPUoodGhpcyk7aCYmTihhLGQpO2MmJk4oYSxiKTtoJiZNKGEsYik7cmV0dXJuIGZ9KTtZZCYmWWQuZ2V0P2IoTm9kZS5wcm90b3R5cGUsWWQpOkZkKGEsZnVuY3Rpb24oYSl7YihhLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtmb3IodmFyIGE9XG5bXSxiPTA7Yjx0aGlzLmNoaWxkTm9kZXMubGVuZ3RoO2IrKylhLnB1c2godGhpcy5jaGlsZE5vZGVzW2JdLnRleHRDb250ZW50KTtyZXR1cm4gYS5qb2luKFwiXCIpfSxzZXQ6ZnVuY3Rpb24oYSl7Zm9yKDt0aGlzLmZpcnN0Q2hpbGQ7KVdkLmNhbGwodGhpcyx0aGlzLmZpcnN0Q2hpbGQpO1VkLmNhbGwodGhpcyxkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKSl9fSl9KX07ZnVuY3Rpb24gd2UoYSl7dmFyIGI9RWxlbWVudC5wcm90b3R5cGU7ZnVuY3Rpb24gYyhiKXtyZXR1cm4gZnVuY3Rpb24oYyl7Zm9yKHZhciBkPVtdLGU9MDtlPGFyZ3VtZW50cy5sZW5ndGg7KytlKWRbZS0wXT1hcmd1bWVudHNbZV07ZT1bXTtmb3IodmFyIGc9W10saz0wO2s8ZC5sZW5ndGg7aysrKXt2YXIgbD1kW2tdO2wgaW5zdGFuY2VvZiBFbGVtZW50JiZKKGwpJiZnLnB1c2gobCk7aWYobCBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpZm9yKGw9bC5maXJzdENoaWxkO2w7bD1sLm5leHRTaWJsaW5nKWUucHVzaChsKTtlbHNlIGUucHVzaChsKX1iLmFwcGx5KHRoaXMsZCk7Zm9yKGQ9MDtkPGcubGVuZ3RoO2QrKylOKGEsZ1tkXSk7aWYoSih0aGlzKSlmb3IoZD0wO2Q8ZS5sZW5ndGg7ZCsrKWc9ZVtkXSxnIGluc3RhbmNlb2YgRWxlbWVudCYmTShhLGcpfX12b2lkIDAhPT1qZSYmKGIuYmVmb3JlPWMoamUpKTt2b2lkIDAhPT1qZSYmKGIuYWZ0ZXI9YyhrZSkpO3ZvaWQgMCE9PVxubGUmJkwoYixcInJlcGxhY2VXaXRoXCIsZnVuY3Rpb24oYil7Zm9yKHZhciBjPVtdLGQ9MDtkPGFyZ3VtZW50cy5sZW5ndGg7KytkKWNbZC0wXT1hcmd1bWVudHNbZF07ZD1bXTtmb3IodmFyIGg9W10sZz0wO2c8Yy5sZW5ndGg7ZysrKXt2YXIgaz1jW2ddO2sgaW5zdGFuY2VvZiBFbGVtZW50JiZKKGspJiZoLnB1c2goayk7aWYoayBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpZm9yKGs9ay5maXJzdENoaWxkO2s7az1rLm5leHRTaWJsaW5nKWQucHVzaChrKTtlbHNlIGQucHVzaChrKX1nPUoodGhpcyk7bGUuYXBwbHkodGhpcyxjKTtmb3IoYz0wO2M8aC5sZW5ndGg7YysrKU4oYSxoW2NdKTtpZihnKWZvcihOKGEsdGhpcyksYz0wO2M8ZC5sZW5ndGg7YysrKWg9ZFtjXSxoIGluc3RhbmNlb2YgRWxlbWVudCYmTShhLGgpfSk7dm9pZCAwIT09bWUmJkwoYixcInJlbW92ZVwiLGZ1bmN0aW9uKCl7dmFyIGI9Sih0aGlzKTttZS5jYWxsKHRoaXMpO2ImJk4oYSx0aGlzKX0pfTtmdW5jdGlvbiB4ZSgpe3ZhciBhPXNlO2Z1bmN0aW9uIGIoYixjKXtPYmplY3QuZGVmaW5lUHJvcGVydHkoYixcImlubmVySFRNTFwiLHtlbnVtZXJhYmxlOmMuZW51bWVyYWJsZSxjb25maWd1cmFibGU6ITAsZ2V0OmMuZ2V0LHNldDpmdW5jdGlvbihiKXt2YXIgZD10aGlzLGU9dm9pZCAwO0oodGhpcykmJihlPVtdLEsodGhpcyxmdW5jdGlvbihhKXthIT09ZCYmZS5wdXNoKGEpfSkpO2Muc2V0LmNhbGwodGhpcyxiKTtpZihlKWZvcih2YXIgZj0wO2Y8ZS5sZW5ndGg7ZisrKXt2YXIgbD1lW2ZdOzE9PT1sLl9fQ0Vfc3RhdGUmJmEuZGlzY29ubmVjdGVkQ2FsbGJhY2sobCl9dGhpcy5vd25lckRvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnk/TyhhLHRoaXMpOkdkKGEsdGhpcyk7cmV0dXJuIGJ9fSl9ZnVuY3Rpb24gYyhiLGMpe0woYixcImluc2VydEFkamFjZW50RWxlbWVudFwiLGZ1bmN0aW9uKGIsZCl7dmFyIGU9SihkKTtiPWMuY2FsbCh0aGlzLGIsZCk7ZSYmTihhLGQpO0ooYikmJk0oYSxkKTtcbnJldHVybiBifSl9WmQmJkwoRWxlbWVudC5wcm90b3R5cGUsXCJhdHRhY2hTaGFkb3dcIixmdW5jdGlvbihhKXtyZXR1cm4gdGhpcy5fX0NFX3NoYWRvd1Jvb3Q9YT1aZC5jYWxsKHRoaXMsYSl9KTskZCYmJGQuZ2V0P2IoRWxlbWVudC5wcm90b3R5cGUsJGQpOm9lJiZvZS5nZXQ/YihIVE1MRWxlbWVudC5wcm90b3R5cGUsb2UpOkZkKGEsZnVuY3Rpb24oYSl7YihhLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gVGQuY2FsbCh0aGlzLCEwKS5pbm5lckhUTUx9LHNldDpmdW5jdGlvbihhKXt2YXIgYj1cInRlbXBsYXRlXCI9PT10aGlzLmxvY2FsTmFtZSxjPWI/dGhpcy5jb250ZW50OnRoaXMsZD1NZC5jYWxsKGRvY3VtZW50LHRoaXMubG9jYWxOYW1lKTtmb3IoZC5pbm5lckhUTUw9YTswPGMuY2hpbGROb2Rlcy5sZW5ndGg7KVdkLmNhbGwoYyxjLmNoaWxkTm9kZXNbMF0pO2ZvcihhPWI/ZC5jb250ZW50OmQ7MDxhLmNoaWxkTm9kZXMubGVuZ3RoOylVZC5jYWxsKGMsXG5hLmNoaWxkTm9kZXNbMF0pfX0pfSk7TChFbGVtZW50LnByb3RvdHlwZSxcInNldEF0dHJpYnV0ZVwiLGZ1bmN0aW9uKGIsYyl7aWYoMSE9PXRoaXMuX19DRV9zdGF0ZSlyZXR1cm4gYmUuY2FsbCh0aGlzLGIsYyk7dmFyIGQ9YWUuY2FsbCh0aGlzLGIpO2JlLmNhbGwodGhpcyxiLGMpO2M9YWUuY2FsbCh0aGlzLGIpO2EuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsYixkLGMsbnVsbCl9KTtMKEVsZW1lbnQucHJvdG90eXBlLFwic2V0QXR0cmlidXRlTlNcIixmdW5jdGlvbihiLGMsZil7aWYoMSE9PXRoaXMuX19DRV9zdGF0ZSlyZXR1cm4gZWUuY2FsbCh0aGlzLGIsYyxmKTt2YXIgZD1kZS5jYWxsKHRoaXMsYixjKTtlZS5jYWxsKHRoaXMsYixjLGYpO2Y9ZGUuY2FsbCh0aGlzLGIsYyk7YS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcyxjLGQsZixiKX0pO0woRWxlbWVudC5wcm90b3R5cGUsXCJyZW1vdmVBdHRyaWJ1dGVcIixmdW5jdGlvbihiKXtpZigxIT09dGhpcy5fX0NFX3N0YXRlKXJldHVybiBjZS5jYWxsKHRoaXMsXG5iKTt2YXIgYz1hZS5jYWxsKHRoaXMsYik7Y2UuY2FsbCh0aGlzLGIpO251bGwhPT1jJiZhLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLGIsYyxudWxsLG51bGwpfSk7TChFbGVtZW50LnByb3RvdHlwZSxcInJlbW92ZUF0dHJpYnV0ZU5TXCIsZnVuY3Rpb24oYixjKXtpZigxIT09dGhpcy5fX0NFX3N0YXRlKXJldHVybiBmZS5jYWxsKHRoaXMsYixjKTt2YXIgZD1kZS5jYWxsKHRoaXMsYixjKTtmZS5jYWxsKHRoaXMsYixjKTt2YXIgZT1kZS5jYWxsKHRoaXMsYixjKTtkIT09ZSYmYS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcyxjLGQsZSxiKX0pO3BlP2MoSFRNTEVsZW1lbnQucHJvdG90eXBlLHBlKTpnZT9jKEVsZW1lbnQucHJvdG90eXBlLGdlKTpjb25zb2xlLndhcm4oXCJDdXN0b20gRWxlbWVudHM6IGBFbGVtZW50I2luc2VydEFkamFjZW50RWxlbWVudGAgd2FzIG5vdCBwYXRjaGVkLlwiKTt0ZShhLEVsZW1lbnQucHJvdG90eXBlLHtYOmhlLGFwcGVuZDppZX0pO3dlKGEpfVxuO3ZhciB5ZT13aW5kb3cuY3VzdG9tRWxlbWVudHM7aWYoIXllfHx5ZS5mb3JjZVBvbHlmaWxsfHxcImZ1bmN0aW9uXCIhPXR5cGVvZiB5ZS5kZWZpbmV8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHllLmdldCl7dmFyIHNlPW5ldyBEZDtyZSgpO3VlKCk7dGUoc2UsRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUse1g6UmQsYXBwZW5kOlNkfSk7dmUoKTt4ZSgpO2RvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnk9ITA7dmFyIGN1c3RvbUVsZW1lbnRzPW5ldyBQKHNlKTtPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LFwiY3VzdG9tRWxlbWVudHNcIix7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsdmFsdWU6Y3VzdG9tRWxlbWVudHN9KX07ZnVuY3Rpb24gemUoKXt0aGlzLmVuZD10aGlzLnN0YXJ0PTA7dGhpcy5ydWxlcz10aGlzLnBhcmVudD10aGlzLnByZXZpb3VzPW51bGw7dGhpcy5jc3NUZXh0PXRoaXMucGFyc2VkQ3NzVGV4dD1cIlwiO3RoaXMuYXRSdWxlPSExO3RoaXMudHlwZT0wO3RoaXMucGFyc2VkU2VsZWN0b3I9dGhpcy5zZWxlY3Rvcj10aGlzLmtleWZyYW1lc05hbWU9XCJcIn1cbmZ1bmN0aW9uIEFlKGEpe2E9YS5yZXBsYWNlKEJlLFwiXCIpLnJlcGxhY2UoQ2UsXCJcIik7dmFyIGI9RGUsYz1hLGQ9bmV3IHplO2Quc3RhcnQ9MDtkLmVuZD1jLmxlbmd0aDtmb3IodmFyIGU9ZCxmPTAsaD1jLmxlbmd0aDtmPGg7ZisrKWlmKFwie1wiPT09Y1tmXSl7ZS5ydWxlc3x8KGUucnVsZXM9W10pO3ZhciBnPWUsaz1nLnJ1bGVzW2cucnVsZXMubGVuZ3RoLTFdfHxudWxsO2U9bmV3IHplO2Uuc3RhcnQ9ZisxO2UucGFyZW50PWc7ZS5wcmV2aW91cz1rO2cucnVsZXMucHVzaChlKX1lbHNlXCJ9XCI9PT1jW2ZdJiYoZS5lbmQ9ZisxLGU9ZS5wYXJlbnR8fGQpO3JldHVybiBiKGQsYSl9XG5mdW5jdGlvbiBEZShhLGIpe3ZhciBjPWIuc3Vic3RyaW5nKGEuc3RhcnQsYS5lbmQtMSk7YS5wYXJzZWRDc3NUZXh0PWEuY3NzVGV4dD1jLnRyaW0oKTthLnBhcmVudCYmKGM9Yi5zdWJzdHJpbmcoYS5wcmV2aW91cz9hLnByZXZpb3VzLmVuZDphLnBhcmVudC5zdGFydCxhLnN0YXJ0LTEpLGM9RWUoYyksYz1jLnJlcGxhY2UoRmUsXCIgXCIpLGM9Yy5zdWJzdHJpbmcoYy5sYXN0SW5kZXhPZihcIjtcIikrMSksYz1hLnBhcnNlZFNlbGVjdG9yPWEuc2VsZWN0b3I9Yy50cmltKCksYS5hdFJ1bGU9MD09PWMuaW5kZXhPZihcIkBcIiksYS5hdFJ1bGU/MD09PWMuaW5kZXhPZihcIkBtZWRpYVwiKT9hLnR5cGU9SmU6Yy5tYXRjaChLZSkmJihhLnR5cGU9TGUsYS5rZXlmcmFtZXNOYW1lPWEuc2VsZWN0b3Iuc3BsaXQoRmUpLnBvcCgpKTphLnR5cGU9MD09PWMuaW5kZXhPZihcIi0tXCIpP01lOk5lKTtpZihjPWEucnVsZXMpZm9yKHZhciBkPTAsZT1jLmxlbmd0aCxmO2Q8ZSYmKGY9Y1tkXSk7ZCsrKURlKGYsXG5iKTtyZXR1cm4gYX1mdW5jdGlvbiBFZShhKXtyZXR1cm4gYS5yZXBsYWNlKC9cXFxcKFswLTlhLWZdezEsNn0pXFxzL2dpLGZ1bmN0aW9uKGEsYyl7YT1jO2ZvcihjPTYtYS5sZW5ndGg7Yy0tOylhPVwiMFwiK2E7cmV0dXJuXCJcXFxcXCIrYX0pfVxuZnVuY3Rpb24gT2UoYSxiLGMpe2M9dm9pZCAwPT09Yz9cIlwiOmM7dmFyIGQ9XCJcIjtpZihhLmNzc1RleHR8fGEucnVsZXMpe3ZhciBlPWEucnVsZXMsZjtpZihmPWUpZj1lWzBdLGY9IShmJiZmLnNlbGVjdG9yJiYwPT09Zi5zZWxlY3Rvci5pbmRleE9mKFwiLS1cIikpO2lmKGYpe2Y9MDtmb3IodmFyIGg9ZS5sZW5ndGgsZztmPGgmJihnPWVbZl0pO2YrKylkPU9lKGcsYixkKX1lbHNlIGI/Yj1hLmNzc1RleHQ6KGI9YS5jc3NUZXh0LGI9Yi5yZXBsYWNlKFBlLFwiXCIpLnJlcGxhY2UoUWUsXCJcIiksYj1iLnJlcGxhY2UoUmUsXCJcIikucmVwbGFjZShTZSxcIlwiKSksKGQ9Yi50cmltKCkpJiYoZD1cIiAgXCIrZCtcIlxcblwiKX1kJiYoYS5zZWxlY3RvciYmKGMrPWEuc2VsZWN0b3IrXCIge1xcblwiKSxjKz1kLGEuc2VsZWN0b3ImJihjKz1cIn1cXG5cXG5cIikpO3JldHVybiBjfVxudmFyIE5lPTEsTGU9NyxKZT00LE1lPTFFMyxCZT0vXFwvXFwqW14qXSpcXCorKFteLypdW14qXSpcXCorKSpcXC8vZ2ltLENlPS9AaW1wb3J0W147XSo7L2dpbSxQZT0vKD86XlteO1xcLVxcc31dKyk/LS1bXjt7fV0qPzpbXnt9O10qPyg/Ols7XFxuXXwkKS9naW0sUWU9Lyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj97W159XSo/fSg/Ols7XFxuXXwkKT8vZ2ltLFJlPS9AYXBwbHlcXHMqXFwoP1teKTtdKlxcKT9cXHMqKD86WztcXG5dfCQpPy9naW0sU2U9L1teOzpdKj86W147XSo/dmFyXFwoW147XSpcXCkoPzpbO1xcbl18JCk/L2dpbSxLZT0vXkBbXlxcc10qa2V5ZnJhbWVzLyxGZT0vXFxzKy9nO3ZhciBRPSEod2luZG93LlNoYWR5RE9NJiZ3aW5kb3cuU2hhZHlET00uaW5Vc2UpLFRlO2Z1bmN0aW9uIFVlKGEpe1RlPWEmJmEuc2hpbWNzc3Byb3BlcnRpZXM/ITE6UXx8IShuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9BcHBsZVdlYktpdFxcLzYwMXxFZGdlXFwvMTUvKXx8IXdpbmRvdy5DU1N8fCFDU1Muc3VwcG9ydHN8fCFDU1Muc3VwcG9ydHMoXCJib3gtc2hhZG93XCIsXCIwIDAgMCB2YXIoLS1mb28pXCIpKX13aW5kb3cuU2hhZHlDU1MmJnZvaWQgMCE9PXdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3M/VGU9d2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzczp3aW5kb3cuU2hhZHlDU1M/KFVlKHdpbmRvdy5TaGFkeUNTUyksd2luZG93LlNoYWR5Q1NTPXZvaWQgMCk6VWUod2luZG93LldlYkNvbXBvbmVudHMmJndpbmRvdy5XZWJDb21wb25lbnRzLmZsYWdzKTt2YXIgUj1UZTt2YXIgVmU9Lyg/Ol58WztcXHN7XVxccyopKC0tW1xcdy1dKj8pXFxzKjpcXHMqKD86KCg/OicoPzpcXFxcJ3wuKSo/J3xcIig/OlxcXFxcInwuKSo/XCJ8XFwoW14pXSo/XFwpfFtefTt7XSkrKXxcXHsoW159XSopXFx9KD86KD89WztcXHN9XSl8JCkpL2dpLFdlPS8oPzpefFxcVyspQGFwcGx5XFxzKlxcKD8oW14pO1xcbl0qKVxcKT8vZ2ksWGU9LygtLVtcXHctXSspXFxzKihbOiw7KV18JCkvZ2ksWWU9LyhhbmltYXRpb25cXHMqOil8KGFuaW1hdGlvbi1uYW1lXFxzKjopLyxaZT0vQG1lZGlhXFxzKC4qKS8sJGU9L1xce1tefV0qXFx9L2c7dmFyIGFmPW5ldyBTZXQ7ZnVuY3Rpb24gYmYoYSxiKXtpZighYSlyZXR1cm5cIlwiO1wic3RyaW5nXCI9PT10eXBlb2YgYSYmKGE9QWUoYSkpO2ImJmNmKGEsYik7cmV0dXJuIE9lKGEsUil9ZnVuY3Rpb24gZGYoYSl7IWEuX19jc3NSdWxlcyYmYS50ZXh0Q29udGVudCYmKGEuX19jc3NSdWxlcz1BZShhLnRleHRDb250ZW50KSk7cmV0dXJuIGEuX19jc3NSdWxlc3x8bnVsbH1mdW5jdGlvbiBlZihhKXtyZXR1cm4hIWEucGFyZW50JiZhLnBhcmVudC50eXBlPT09TGV9ZnVuY3Rpb24gY2YoYSxiLGMsZCl7aWYoYSl7dmFyIGU9ITEsZj1hLnR5cGU7aWYoZCYmZj09PUplKXt2YXIgaD1hLnNlbGVjdG9yLm1hdGNoKFplKTtoJiYod2luZG93Lm1hdGNoTWVkaWEoaFsxXSkubWF0Y2hlc3x8KGU9ITApKX1mPT09TmU/YihhKTpjJiZmPT09TGU/YyhhKTpmPT09TWUmJihlPSEwKTtpZigoYT1hLnJ1bGVzKSYmIWUpe2U9MDtmPWEubGVuZ3RoO2Zvcih2YXIgZztlPGYmJihnPWFbZV0pO2UrKyljZihnLGIsYyxkKX19fVxuZnVuY3Rpb24gZmYoYSxiLGMsZCl7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO2ImJmUuc2V0QXR0cmlidXRlKFwic2NvcGVcIixiKTtlLnRleHRDb250ZW50PWE7Z2YoZSxjLGQpO3JldHVybiBlfXZhciBTPW51bGw7ZnVuY3Rpb24gZ2YoYSxiLGMpe2I9Ynx8ZG9jdW1lbnQuaGVhZDtiLmluc2VydEJlZm9yZShhLGMmJmMubmV4dFNpYmxpbmd8fGIuZmlyc3RDaGlsZCk7Uz9hLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKFMpPT09Tm9kZS5ET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkcmJihTPWEpOlM9YX1cbmZ1bmN0aW9uIGhmKGEsYil7dmFyIGM9YS5pbmRleE9mKFwidmFyKFwiKTtpZigtMT09PWMpcmV0dXJuIGIoYSxcIlwiLFwiXCIsXCJcIik7YTp7dmFyIGQ9MDt2YXIgZT1jKzM7Zm9yKHZhciBmPWEubGVuZ3RoO2U8ZjtlKyspaWYoXCIoXCI9PT1hW2VdKWQrKztlbHNlIGlmKFwiKVwiPT09YVtlXSYmMD09PS0tZClicmVhayBhO2U9LTF9ZD1hLnN1YnN0cmluZyhjKzQsZSk7Yz1hLnN1YnN0cmluZygwLGMpO2E9aGYoYS5zdWJzdHJpbmcoZSsxKSxiKTtlPWQuaW5kZXhPZihcIixcIik7cmV0dXJuLTE9PT1lP2IoYyxkLnRyaW0oKSxcIlwiLGEpOmIoYyxkLnN1YnN0cmluZygwLGUpLnRyaW0oKSxkLnN1YnN0cmluZyhlKzEpLnRyaW0oKSxhKX1mdW5jdGlvbiBqZihhLGIpe1E/YS5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGIpOndpbmRvdy5TaGFkeURPTS5uYXRpdmVNZXRob2RzLnNldEF0dHJpYnV0ZS5jYWxsKGEsXCJjbGFzc1wiLGIpfVxuZnVuY3Rpb24gVihhKXt2YXIgYj1hLmxvY2FsTmFtZSxjPVwiXCI7Yj8tMTxiLmluZGV4T2YoXCItXCIpfHwoYz1iLGI9YS5nZXRBdHRyaWJ1dGUmJmEuZ2V0QXR0cmlidXRlKFwiaXNcIil8fFwiXCIpOihiPWEuaXMsYz1hLmV4dGVuZHMpO3JldHVybntpczpiLFA6Y319O2Z1bmN0aW9uIGtmKCl7fWZ1bmN0aW9uIGxmKGEsYixjKXt2YXIgZD1XO2EuX19zdHlsZVNjb3BlZD9hLl9fc3R5bGVTY29wZWQ9bnVsbDptZihkLGEsYnx8XCJcIixjKX1mdW5jdGlvbiBtZihhLGIsYyxkKXtiLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJm5mKGIsYyxkKTtpZihiPVwidGVtcGxhdGVcIj09PWIubG9jYWxOYW1lPyhiLmNvbnRlbnR8fGIuZ2IpLmNoaWxkTm9kZXM6Yi5jaGlsZHJlbnx8Yi5jaGlsZE5vZGVzKWZvcih2YXIgZT0wO2U8Yi5sZW5ndGg7ZSsrKW1mKGEsYltlXSxjLGQpfVxuZnVuY3Rpb24gbmYoYSxiLGMpe2lmKGIpaWYoYS5jbGFzc0xpc3QpYz8oYS5jbGFzc0xpc3QucmVtb3ZlKFwic3R5bGUtc2NvcGVcIiksYS5jbGFzc0xpc3QucmVtb3ZlKGIpKTooYS5jbGFzc0xpc3QuYWRkKFwic3R5bGUtc2NvcGVcIiksYS5jbGFzc0xpc3QuYWRkKGIpKTtlbHNlIGlmKGEuZ2V0QXR0cmlidXRlKXt2YXIgZD1hLmdldEF0dHJpYnV0ZShvZik7Yz9kJiYoYj1kLnJlcGxhY2UoXCJzdHlsZS1zY29wZVwiLFwiXCIpLnJlcGxhY2UoYixcIlwiKSxqZihhLGIpKTpqZihhLChkP2QrXCIgXCI6XCJcIikrXCJzdHlsZS1zY29wZSBcIitiKX19ZnVuY3Rpb24gcGYoYSxiLGMpe3ZhciBkPVcsZT1hLl9fY3NzQnVpbGQ7UXx8XCJzaGFkeVwiPT09ZT9iPWJmKGIsYyk6KGE9VihhKSxiPXFmKGQsYixhLmlzLGEuUCxjKStcIlxcblxcblwiKTtyZXR1cm4gYi50cmltKCl9XG5mdW5jdGlvbiBxZihhLGIsYyxkLGUpe3ZhciBmPXJmKGMsZCk7Yz1jP3NmK2M6XCJcIjtyZXR1cm4gYmYoYixmdW5jdGlvbihiKXtiLmN8fChiLnNlbGVjdG9yPWIubT10ZihhLGIsYS5iLGMsZiksYi5jPSEwKTtlJiZlKGIsYyxmKX0pfWZ1bmN0aW9uIHJmKGEsYil7cmV0dXJuIGI/XCJbaXM9XCIrYStcIl1cIjphfWZ1bmN0aW9uIHRmKGEsYixjLGQsZSl7dmFyIGY9Yi5zZWxlY3Rvci5zcGxpdCh1Zik7aWYoIWVmKGIpKXtiPTA7Zm9yKHZhciBoPWYubGVuZ3RoLGc7YjxoJiYoZz1mW2JdKTtiKyspZltiXT1jLmNhbGwoYSxnLGQsZSl9cmV0dXJuIGYuam9pbih1Zil9ZnVuY3Rpb24gdmYoYSl7cmV0dXJuIGEucmVwbGFjZSh3ZixmdW5jdGlvbihhLGMsZCl7LTE8ZC5pbmRleE9mKFwiK1wiKT9kPWQucmVwbGFjZSgvXFwrL2csXCJfX19cIik6LTE8ZC5pbmRleE9mKFwiX19fXCIpJiYoZD1kLnJlcGxhY2UoL19fXy9nLFwiK1wiKSk7cmV0dXJuXCI6XCIrYytcIihcIitkK1wiKVwifSl9XG5rZi5wcm90b3R5cGUuYj1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9ITE7YT1hLnRyaW0oKTt2YXIgZT13Zi50ZXN0KGEpO2UmJihhPWEucmVwbGFjZSh3ZixmdW5jdGlvbihhLGIsYyl7cmV0dXJuXCI6XCIrYitcIihcIitjLnJlcGxhY2UoL1xccy9nLFwiXCIpK1wiKVwifSksYT12ZihhKSk7YT1hLnJlcGxhY2UoeGYseWYrXCIgJDFcIik7YT1hLnJlcGxhY2UoemYsZnVuY3Rpb24oYSxlLGcpe2R8fChhPUFmKGcsZSxiLGMpLGQ9ZHx8YS5zdG9wLGU9YS5KYSxnPWEudmFsdWUpO3JldHVybiBlK2d9KTtlJiYoYT12ZihhKSk7cmV0dXJuIGF9O1xuZnVuY3Rpb24gQWYoYSxiLGMsZCl7dmFyIGU9YS5pbmRleE9mKEJmKTswPD1hLmluZGV4T2YoeWYpP2E9Q2YoYSxkKTowIT09ZSYmKGE9Yz9EZihhLGMpOmEpO2M9ITE7MDw9ZSYmKGI9XCJcIixjPSEwKTtpZihjKXt2YXIgZj0hMDtjJiYoYT1hLnJlcGxhY2UoRWYsZnVuY3Rpb24oYSxiKXtyZXR1cm5cIiA+IFwiK2J9KSl9YT1hLnJlcGxhY2UoRmYsZnVuY3Rpb24oYSxiLGMpe3JldHVybidbZGlyPVwiJytjKydcIl0gJytiK1wiLCBcIitiKydbZGlyPVwiJytjKydcIl0nfSk7cmV0dXJue3ZhbHVlOmEsSmE6YixzdG9wOmZ9fWZ1bmN0aW9uIERmKGEsYil7YT1hLnNwbGl0KEdmKTthWzBdKz1iO3JldHVybiBhLmpvaW4oR2YpfVxuZnVuY3Rpb24gQ2YoYSxiKXt2YXIgYz1hLm1hdGNoKEhmKTtyZXR1cm4oYz1jJiZjWzJdLnRyaW0oKXx8XCJcIik/Y1swXS5tYXRjaChJZik/YS5yZXBsYWNlKEhmLGZ1bmN0aW9uKGEsYyxmKXtyZXR1cm4gYitmfSk6Yy5zcGxpdChJZilbMF09PT1iP2M6SmY6YS5yZXBsYWNlKHlmLGIpfWZ1bmN0aW9uIEtmKGEpe2Euc2VsZWN0b3I9PT1MZiYmKGEuc2VsZWN0b3I9XCJodG1sXCIpfWtmLnByb3RvdHlwZS5jPWZ1bmN0aW9uKGEpe3JldHVybiBhLm1hdGNoKEJmKT90aGlzLmIoYSxNZik6RGYoYS50cmltKCksTWYpfTtxLk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGtmLnByb3RvdHlwZSx7YTp7Y29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCJzdHlsZS1zY29wZVwifX19KTtcbnZhciB3Zj0vOihudGhbLVxcd10rKVxcKChbXildKylcXCkvLE1mPVwiOm5vdCguc3R5bGUtc2NvcGUpXCIsdWY9XCIsXCIsemY9LyhefFtcXHM+K35dKykoKD86XFxbLis/XFxdfFteXFxzPit+PVtdKSspL2csSWY9L1tbLjojKl0vLHlmPVwiOmhvc3RcIixMZj1cIjpyb290XCIsQmY9XCI6OnNsb3R0ZWRcIix4Zj1uZXcgUmVnRXhwKFwiXihcIitCZitcIilcIiksSGY9Lyg6aG9zdCkoPzpcXCgoKD86XFwoW14pKF0qXFwpfFteKShdKikrPylcXCkpLyxFZj0vKD86OjpzbG90dGVkKSg/OlxcKCgoPzpcXChbXikoXSpcXCl8W14pKF0qKSs/KVxcKSkvLEZmPS8oLiopOmRpclxcKCg/OihsdHJ8cnRsKSlcXCkvLHNmPVwiLlwiLEdmPVwiOlwiLG9mPVwiY2xhc3NcIixKZj1cInNob3VsZF9ub3RfbWF0Y2hcIixXPW5ldyBrZjtmdW5jdGlvbiBOZihhLGIsYyxkKXt0aGlzLnc9YXx8bnVsbDt0aGlzLmI9Ynx8bnVsbDt0aGlzLmphPWN8fFtdO3RoaXMuRz1udWxsO3RoaXMuUD1kfHxcIlwiO3RoaXMuYT10aGlzLnU9dGhpcy5CPW51bGx9ZnVuY3Rpb24gWChhKXtyZXR1cm4gYT9hLl9fc3R5bGVJbmZvOm51bGx9ZnVuY3Rpb24gT2YoYSxiKXtyZXR1cm4gYS5fX3N0eWxlSW5mbz1ifU5mLnByb3RvdHlwZS5jPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMud307TmYucHJvdG90eXBlLl9nZXRTdHlsZVJ1bGVzPU5mLnByb3RvdHlwZS5jO3ZhciBQZixRZj13aW5kb3cuRWxlbWVudC5wcm90b3R5cGU7UGY9UWYubWF0Y2hlc3x8UWYubWF0Y2hlc1NlbGVjdG9yfHxRZi5tb3pNYXRjaGVzU2VsZWN0b3J8fFFmLm1zTWF0Y2hlc1NlbGVjdG9yfHxRZi5vTWF0Y2hlc1NlbGVjdG9yfHxRZi53ZWJraXRNYXRjaGVzU2VsZWN0b3I7dmFyIFJmPW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goXCJUcmlkZW50XCIpO2Z1bmN0aW9uIFNmKCl7fWZ1bmN0aW9uIFRmKGEpe3ZhciBiPXt9LGM9W10sZD0wO2NmKGEsZnVuY3Rpb24oYSl7VWYoYSk7YS5pbmRleD1kKys7YT1hLmkuY3NzVGV4dDtmb3IodmFyIGM7Yz1YZS5leGVjKGEpOyl7dmFyIGU9Y1sxXTtcIjpcIiE9PWNbMl0mJihiW2VdPSEwKX19LGZ1bmN0aW9uKGEpe2MucHVzaChhKX0pO2EuYj1jO2E9W107Zm9yKHZhciBlIGluIGIpYS5wdXNoKGUpO3JldHVybiBhfVxuZnVuY3Rpb24gVWYoYSl7aWYoIWEuaSl7dmFyIGI9e30sYz17fTtWZihhLGMpJiYoYi52PWMsYS5ydWxlcz1udWxsKTtiLmNzc1RleHQ9YS5wYXJzZWRDc3NUZXh0LnJlcGxhY2UoJGUsXCJcIikucmVwbGFjZShWZSxcIlwiKTthLmk9Yn19ZnVuY3Rpb24gVmYoYSxiKXt2YXIgYz1hLmk7aWYoYyl7aWYoYy52KXJldHVybiBPYmplY3QuYXNzaWduKGIsYy52KSwhMH1lbHNle2M9YS5wYXJzZWRDc3NUZXh0O2Zvcih2YXIgZDthPVZlLmV4ZWMoYyk7KXtkPShhWzJdfHxhWzNdKS50cmltKCk7aWYoXCJpbmhlcml0XCIhPT1kfHxcInVuc2V0XCIhPT1kKWJbYVsxXS50cmltKCldPWQ7ZD0hMH1yZXR1cm4gZH19XG5mdW5jdGlvbiBXZihhLGIsYyl7YiYmKGI9MDw9Yi5pbmRleE9mKFwiO1wiKT9YZihhLGIsYyk6aGYoYixmdW5jdGlvbihiLGUsZixoKXtpZighZSlyZXR1cm4gYitoOyhlPVdmKGEsY1tlXSxjKSkmJlwiaW5pdGlhbFwiIT09ZT9cImFwcGx5LXNoaW0taW5oZXJpdFwiPT09ZSYmKGU9XCJpbmhlcml0XCIpOmU9V2YoYSxjW2ZdfHxmLGMpfHxmO3JldHVybiBiKyhlfHxcIlwiKStofSkpO3JldHVybiBiJiZiLnRyaW0oKXx8XCJcIn1cbmZ1bmN0aW9uIFhmKGEsYixjKXtiPWIuc3BsaXQoXCI7XCIpO2Zvcih2YXIgZD0wLGUsZjtkPGIubGVuZ3RoO2QrKylpZihlPWJbZF0pe1dlLmxhc3RJbmRleD0wO2lmKGY9V2UuZXhlYyhlKSllPVdmKGEsY1tmWzFdXSxjKTtlbHNlIGlmKGY9ZS5pbmRleE9mKFwiOlwiKSwtMSE9PWYpe3ZhciBoPWUuc3Vic3RyaW5nKGYpO2g9aC50cmltKCk7aD1XZihhLGgsYyl8fGg7ZT1lLnN1YnN0cmluZygwLGYpK2h9YltkXT1lJiZlLmxhc3RJbmRleE9mKFwiO1wiKT09PWUubGVuZ3RoLTE/ZS5zbGljZSgwLC0xKTplfHxcIlwifXJldHVybiBiLmpvaW4oXCI7XCIpfVxuZnVuY3Rpb24gWWYoYSxiKXt2YXIgYz17fSxkPVtdO2NmKGEsZnVuY3Rpb24oYSl7YS5pfHxVZihhKTt2YXIgZT1hLm18fGEucGFyc2VkU2VsZWN0b3I7YiYmYS5pLnYmJmUmJlBmLmNhbGwoYixlKSYmKFZmKGEsYyksYT1hLmluZGV4LGU9cGFyc2VJbnQoYS8zMiwxMCksZFtlXT0oZFtlXXx8MCl8MTw8YSUzMil9LG51bGwsITApO3JldHVybnt2OmMsa2V5OmR9fVxuZnVuY3Rpb24gWmYoYSxiLGMsZCl7Yi5pfHxVZihiKTtpZihiLmkudil7dmFyIGU9VihhKTthPWUuaXM7ZT1lLlA7ZT1hP3JmKGEsZSk6XCJodG1sXCI7dmFyIGY9Yi5wYXJzZWRTZWxlY3RvcixoPVwiOmhvc3QgPiAqXCI9PT1mfHxcImh0bWxcIj09PWYsZz0wPT09Zi5pbmRleE9mKFwiOmhvc3RcIikmJiFoO1wic2hhZHlcIj09PWMmJihoPWY9PT1lK1wiID4gKi5cIitlfHwtMSE9PWYuaW5kZXhPZihcImh0bWxcIiksZz0haCYmMD09PWYuaW5kZXhPZihlKSk7XCJzaGFkb3dcIj09PWMmJihoPVwiOmhvc3QgPiAqXCI9PT1mfHxcImh0bWxcIj09PWYsZz1nJiYhaCk7aWYoaHx8ZyljPWUsZyYmKFEmJiFiLm0mJihiLm09dGYoVyxiLFcuYixhP3NmK2E6XCJcIixlKSksYz1iLm18fGUpLGQoe1hhOmMsT2E6ZyxpYjpofSl9fVxuZnVuY3Rpb24gJGYoYSxiKXt2YXIgYz17fSxkPXt9LGU9YiYmYi5fX2Nzc0J1aWxkO2NmKGIsZnVuY3Rpb24oYil7WmYoYSxiLGUsZnVuY3Rpb24oZSl7UGYuY2FsbChhLmhifHxhLGUuWGEpJiYoZS5PYT9WZihiLGMpOlZmKGIsZCkpfSl9LG51bGwsITApO3JldHVybntWYTpkLE5hOmN9fVxuZnVuY3Rpb24gYWcoYSxiLGMsZCl7dmFyIGU9VihiKSxmPXJmKGUuaXMsZS5QKSxoPW5ldyBSZWdFeHAoXCIoPzpefFteLiNbOl0pXCIrKGIuZXh0ZW5kcz9cIlxcXFxcIitmLnNsaWNlKDAsLTEpK1wiXFxcXF1cIjpmKStcIigkfFsuOltcXFxccz4rfl0pXCIpO2U9WChiKS53O3ZhciBnPWJnKGUsZCk7cmV0dXJuIHBmKGIsZSxmdW5jdGlvbihiKXt2YXIgZT1cIlwiO2IuaXx8VWYoYik7Yi5pLmNzc1RleHQmJihlPVhmKGEsYi5pLmNzc1RleHQsYykpO2IuY3NzVGV4dD1lO2lmKCFRJiYhZWYoYikmJmIuY3NzVGV4dCl7dmFyIGs9ZT1iLmNzc1RleHQ7bnVsbD09Yi5yYSYmKGIucmE9WWUudGVzdChlKSk7aWYoYi5yYSlpZihudWxsPT1iLlcpe2IuVz1bXTtmb3IodmFyIG4gaW4gZylrPWdbbl0saz1rKGUpLGUhPT1rJiYoZT1rLGIuVy5wdXNoKG4pKX1lbHNle2ZvcihuPTA7bjxiLlcubGVuZ3RoOysrbilrPWdbYi5XW25dXSxlPWsoZSk7az1lfWIuY3NzVGV4dD1rO2IubT1iLm18fGIuc2VsZWN0b3I7ZT1cIi5cIitkO1xubj1iLm0uc3BsaXQoXCIsXCIpO2s9MDtmb3IodmFyIHc9bi5sZW5ndGgsSTtrPHcmJihJPW5ba10pO2srKyluW2tdPUkubWF0Y2goaCk/SS5yZXBsYWNlKGYsZSk6ZStcIiBcIitJO2Iuc2VsZWN0b3I9bi5qb2luKFwiLFwiKX19KX1mdW5jdGlvbiBiZyhhLGIpe2E9YS5iO3ZhciBjPXt9O2lmKCFRJiZhKWZvcih2YXIgZD0wLGU9YVtkXTtkPGEubGVuZ3RoO2U9YVsrK2RdKXt2YXIgZj1lLGg9YjtmLmg9bmV3IFJlZ0V4cChmLmtleWZyYW1lc05hbWUsXCJnXCIpO2YuYT1mLmtleWZyYW1lc05hbWUrXCItXCIraDtmLm09Zi5tfHxmLnNlbGVjdG9yO2Yuc2VsZWN0b3I9Zi5tLnJlcGxhY2UoZi5rZXlmcmFtZXNOYW1lLGYuYSk7Y1tlLmtleWZyYW1lc05hbWVdPWNnKGUpfXJldHVybiBjfWZ1bmN0aW9uIGNnKGEpe3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm4gYi5yZXBsYWNlKGEuaCxhLmEpfX1cbmZ1bmN0aW9uIGRnKGEsYil7dmFyIGM9ZWcsZD1kZihhKTthLnRleHRDb250ZW50PWJmKGQsZnVuY3Rpb24oYSl7dmFyIGQ9YS5jc3NUZXh0PWEucGFyc2VkQ3NzVGV4dDthLmkmJmEuaS5jc3NUZXh0JiYoZD1kLnJlcGxhY2UoUGUsXCJcIikucmVwbGFjZShRZSxcIlwiKSxhLmNzc1RleHQ9WGYoYyxkLGIpKX0pfXEuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoU2YucHJvdG90eXBlLHthOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIngtc2NvcGVcIn19fSk7dmFyIGVnPW5ldyBTZjt2YXIgZmc9e30sZ2c9d2luZG93LmN1c3RvbUVsZW1lbnRzO2lmKGdnJiYhUSl7dmFyIGhnPWdnLmRlZmluZTtnZy5kZWZpbmU9ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoXCIgU2hhZHkgRE9NIHN0eWxlcyBmb3IgXCIrYStcIiBcIiksZT1kb2N1bWVudC5oZWFkO2UuaW5zZXJ0QmVmb3JlKGQsKFM/Uy5uZXh0U2libGluZzpudWxsKXx8ZS5maXJzdENoaWxkKTtTPWQ7ZmdbYV09ZDtyZXR1cm4gaGcuY2FsbChnZyxhLGIsYyl9fTtmdW5jdGlvbiBpZygpe3RoaXMuY2FjaGU9e319aWcucHJvdG90eXBlLnN0b3JlPWZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPXRoaXMuY2FjaGVbYV18fFtdO2UucHVzaCh7djpiLHN0eWxlRWxlbWVudDpjLHU6ZH0pOzEwMDxlLmxlbmd0aCYmZS5zaGlmdCgpO3RoaXMuY2FjaGVbYV09ZX07aWcucHJvdG90eXBlLmZldGNoPWZ1bmN0aW9uKGEsYixjKXtpZihhPXRoaXMuY2FjaGVbYV0pZm9yKHZhciBkPWEubGVuZ3RoLTE7MDw9ZDtkLS0pe3ZhciBlPWFbZF0sZjthOntmb3IoZj0wO2Y8Yy5sZW5ndGg7ZisrKXt2YXIgaD1jW2ZdO2lmKGUudltoXSE9PWJbaF0pe2Y9ITE7YnJlYWsgYX19Zj0hMH1pZihmKXJldHVybiBlfX07ZnVuY3Rpb24gamcoKXt9XG5mdW5jdGlvbiBrZyhhKXtmb3IodmFyIGI9MDtiPGEubGVuZ3RoO2IrKyl7dmFyIGM9YVtiXTtpZihjLnRhcmdldCE9PWRvY3VtZW50LmRvY3VtZW50RWxlbWVudCYmYy50YXJnZXQhPT1kb2N1bWVudC5oZWFkKWZvcih2YXIgZD0wO2Q8Yy5hZGRlZE5vZGVzLmxlbmd0aDtkKyspe3ZhciBlPWMuYWRkZWROb2Rlc1tkXTtpZihlLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBmPWUuZ2V0Um9vdE5vZGUoKTt2YXIgaD1lO3ZhciBnPVtdO2guY2xhc3NMaXN0P2c9QXJyYXkuZnJvbShoLmNsYXNzTGlzdCk6aCBpbnN0YW5jZW9mIHdpbmRvdy5TVkdFbGVtZW50JiZoLmhhc0F0dHJpYnV0ZShcImNsYXNzXCIpJiYoZz1oLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpLnNwbGl0KC9cXHMrLykpO2g9ZztnPWguaW5kZXhPZihXLmEpO2lmKChoPS0xPGc/aFtnKzFdOlwiXCIpJiZmPT09ZS5vd25lckRvY3VtZW50KWxmKGUsaCwhMCk7ZWxzZSBpZihmLm5vZGVUeXBlPT09Tm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFJiZcbihmPWYuaG9zdCkpaWYoZj1WKGYpLmlzLGg9PT1mKWZvcihlPXdpbmRvdy5TaGFkeURPTS5uYXRpdmVNZXRob2RzLnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChlLFwiOm5vdCguXCIrVy5hK1wiKVwiKSxmPTA7ZjxlLmxlbmd0aDtmKyspbmYoZVtmXSxoKTtlbHNlIGgmJmxmKGUsaCwhMCksbGYoZSxmKX19fX1cbmlmKCFRKXt2YXIgbGc9bmV3IE11dGF0aW9uT2JzZXJ2ZXIoa2cpLG1nPWZ1bmN0aW9uKGEpe2xnLm9ic2VydmUoYSx7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9KX07aWYod2luZG93LmN1c3RvbUVsZW1lbnRzJiYhd2luZG93LmN1c3RvbUVsZW1lbnRzLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2spbWcoZG9jdW1lbnQpO2Vsc2V7dmFyIG5nPWZ1bmN0aW9uKCl7bWcoZG9jdW1lbnQuYm9keSl9O3dpbmRvdy5IVE1MSW1wb3J0cz93aW5kb3cuSFRNTEltcG9ydHMud2hlblJlYWR5KG5nKTpyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXtpZihcImxvYWRpbmdcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUpe3ZhciBhPWZ1bmN0aW9uKCl7bmcoKTtkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGEpfTtkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLGEpfWVsc2UgbmcoKX0pfWpnPWZ1bmN0aW9uKCl7a2cobGcudGFrZVJlY29yZHMoKSl9fVxudmFyIG9nPWpnO3ZhciBwZz17fTt2YXIgcWc9UHJvbWlzZS5yZXNvbHZlKCk7ZnVuY3Rpb24gcmcoYSl7aWYoYT1wZ1thXSlhLl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbj1hLl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbnx8MCxhLl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbj1hLl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbnx8MCxhLl9hcHBseVNoaW1OZXh0VmVyc2lvbj0oYS5fYXBwbHlTaGltTmV4dFZlcnNpb258fDApKzF9ZnVuY3Rpb24gc2coYSl7cmV0dXJuIGEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uPT09YS5fYXBwbHlTaGltTmV4dFZlcnNpb259ZnVuY3Rpb24gdGcoYSl7YS5fYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb249YS5fYXBwbHlTaGltTmV4dFZlcnNpb247YS5ifHwoYS5iPSEwLHFnLnRoZW4oZnVuY3Rpb24oKXthLl9hcHBseVNoaW1DdXJyZW50VmVyc2lvbj1hLl9hcHBseVNoaW1OZXh0VmVyc2lvbjthLmI9ITF9KSl9O3ZhciB1Zz1udWxsLHZnPXdpbmRvdy5IVE1MSW1wb3J0cyYmd2luZG93LkhUTUxJbXBvcnRzLndoZW5SZWFkeXx8bnVsbCx3ZztmdW5jdGlvbiB4ZyhhKXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXt2Zz92ZyhhKToodWd8fCh1Zz1uZXcgUHJvbWlzZShmdW5jdGlvbihhKXt3Zz1hfSksXCJjb21wbGV0ZVwiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZT93ZygpOmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsZnVuY3Rpb24oKXtcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlJiZ3ZygpfSkpLHVnLnRoZW4oZnVuY3Rpb24oKXthJiZhKCl9KSl9KX07dmFyIHlnPW5ldyBpZztmdW5jdGlvbiBZKCl7dmFyIGE9dGhpczt0aGlzLkw9e307dGhpcy5jPWRvY3VtZW50LmRvY3VtZW50RWxlbWVudDt2YXIgYj1uZXcgemU7Yi5ydWxlcz1bXTt0aGlzLmg9T2YodGhpcy5jLG5ldyBOZihiKSk7dGhpcy5vPSExO3RoaXMuYj10aGlzLmE9bnVsbDt4ZyhmdW5jdGlvbigpe3pnKGEpfSl9cD1ZLnByb3RvdHlwZTtwLnhhPWZ1bmN0aW9uKCl7b2coKX07cC5MYT1mdW5jdGlvbihhKXtyZXR1cm4gZGYoYSl9O3AuWmE9ZnVuY3Rpb24oYSl7cmV0dXJuIGJmKGEpfTtcbnAucHJlcGFyZVRlbXBsYXRlPWZ1bmN0aW9uKGEsYixjKXtpZighYS5oKXthLmg9ITA7YS5uYW1lPWI7YS5leHRlbmRzPWM7cGdbYl09YTt2YXIgZD0oZD1hLmNvbnRlbnQucXVlcnlTZWxlY3RvcihcInN0eWxlXCIpKT9kLmdldEF0dHJpYnV0ZShcImNzcy1idWlsZFwiKXx8XCJcIjpcIlwiO3ZhciBlPVtdO2Zvcih2YXIgZj1hLmNvbnRlbnQucXVlcnlTZWxlY3RvckFsbChcInN0eWxlXCIpLGg9MDtoPGYubGVuZ3RoO2grKyl7dmFyIGc9ZltoXTtpZihnLmhhc0F0dHJpYnV0ZShcInNoYWR5LXVuc2NvcGVkXCIpKXtpZighUSl7dmFyIGs9Zy50ZXh0Q29udGVudDthZi5oYXMoayl8fChhZi5hZGQoayksaz1nLmNsb25lTm9kZSghMCksZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChrKSk7Zy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGcpfX1lbHNlIGUucHVzaChnLnRleHRDb250ZW50KSxnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZyl9ZT1lLmpvaW4oXCJcIikudHJpbSgpO2M9e2lzOmIsZXh0ZW5kczpjLGViOmR9O1xuUXx8bGYoYS5jb250ZW50LGIpO3pnKHRoaXMpO2Y9V2UudGVzdChlKXx8VmUudGVzdChlKTtXZS5sYXN0SW5kZXg9MDtWZS5sYXN0SW5kZXg9MDtlPUFlKGUpO2YmJlImJnRoaXMuYSYmdGhpcy5hLnRyYW5zZm9ybVJ1bGVzKGUsYik7YS5fc3R5bGVBc3Q9ZTthLm89ZDtkPVtdO1J8fChkPVRmKGEuX3N0eWxlQXN0KSk7aWYoIWQubGVuZ3RofHxSKWU9UT9hLmNvbnRlbnQ6bnVsbCxiPWZnW2JdLGY9cGYoYyxhLl9zdHlsZUFzdCksYj1mLmxlbmd0aD9mZihmLGMuaXMsZSxiKTp2b2lkIDAsYS5hPWI7YS5jPWR9fTtcbmZ1bmN0aW9uIEFnKGEpeyFhLmImJndpbmRvdy5TaGFkeUNTUyYmd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlJiYoYS5iPXdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZSxhLmIudHJhbnNmb3JtQ2FsbGJhY2s9ZnVuY3Rpb24oYil7YS52YShiKX0sYS5iLnZhbGlkYXRlQ2FsbGJhY2s9ZnVuY3Rpb24oKXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXsoYS5iLmVucXVldWVkfHxhLm8pJiZhLkYoKX0pfSl9ZnVuY3Rpb24gemcoYSl7IWEuYSYmd2luZG93LlNoYWR5Q1NTJiZ3aW5kb3cuU2hhZHlDU1MuQXBwbHlTaGltJiYoYS5hPXdpbmRvdy5TaGFkeUNTUy5BcHBseVNoaW0sYS5hLmludmFsaWRDYWxsYmFjaz1yZyk7QWcoYSl9XG5wLkY9ZnVuY3Rpb24oKXt6Zyh0aGlzKTtpZih0aGlzLmIpe3ZhciBhPXRoaXMuYi5wcm9jZXNzU3R5bGVzKCk7aWYodGhpcy5iLmVucXVldWVkKXtpZihSKWZvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz10aGlzLmIuZ2V0U3R5bGVGb3JDdXN0b21TdHlsZShhW2JdKTtpZihjJiZSJiZ0aGlzLmEpe3ZhciBkPWRmKGMpO3pnKHRoaXMpO3RoaXMuYS50cmFuc2Zvcm1SdWxlcyhkKTtjLnRleHRDb250ZW50PWJmKGQpfX1lbHNlIGZvcihCZyh0aGlzLHRoaXMuYyx0aGlzLmgpLGI9MDtiPGEubGVuZ3RoO2IrKykoYz10aGlzLmIuZ2V0U3R5bGVGb3JDdXN0b21TdHlsZShhW2JdKSkmJmRnKGMsdGhpcy5oLkIpO3RoaXMuYi5lbnF1ZXVlZD0hMTt0aGlzLm8mJiFSJiZ0aGlzLnN0eWxlRG9jdW1lbnQoKX19fTtcbnAuc3R5bGVFbGVtZW50PWZ1bmN0aW9uKGEsYil7dmFyIGM9VihhKS5pcyxkPVgoYSk7aWYoIWQpe3ZhciBlPVYoYSk7ZD1lLmlzO2U9ZS5QO3ZhciBmPWZnW2RdO2Q9cGdbZF07aWYoZCl7dmFyIGg9ZC5fc3R5bGVBc3Q7dmFyIGc9ZC5jfWQ9T2YoYSxuZXcgTmYoaCxmLGcsZSkpfWEhPT10aGlzLmMmJih0aGlzLm89ITApO2ImJihkLkc9ZC5HfHx7fSxPYmplY3QuYXNzaWduKGQuRyxiKSk7aWYoUil7aWYoZC5HKXtiPWQuRztmb3IodmFyIGsgaW4gYiludWxsPT09az9hLnN0eWxlLnJlbW92ZVByb3BlcnR5KGspOmEuc3R5bGUuc2V0UHJvcGVydHkoayxiW2tdKX1pZigoKGs9cGdbY10pfHxhPT09dGhpcy5jKSYmayYmay5hJiYhc2coaykpe2lmKHNnKGspfHxrLl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbiE9PWsuX2FwcGx5U2hpbU5leHRWZXJzaW9uKXpnKHRoaXMpLHRoaXMuYSYmdGhpcy5hLnRyYW5zZm9ybVJ1bGVzKGsuX3N0eWxlQXN0LGMpLGsuYS50ZXh0Q29udGVudD1wZihhLFxuZC53KSx0ZyhrKTtRJiYoYz1hLnNoYWRvd1Jvb3QpJiYoYy5xdWVyeVNlbGVjdG9yKFwic3R5bGVcIikudGV4dENvbnRlbnQ9cGYoYSxkLncpKTtkLnc9ay5fc3R5bGVBc3R9fWVsc2UgaWYoQmcodGhpcyxhLGQpLGQuamEmJmQuamEubGVuZ3RoKXtjPWQ7az1WKGEpLmlzO2Q9KGI9eWcuZmV0Y2goayxjLkIsYy5qYSkpP2Iuc3R5bGVFbGVtZW50Om51bGw7aD1jLnU7KGc9YiYmYi51KXx8KGc9dGhpcy5MW2tdPSh0aGlzLkxba118fDApKzEsZz1rK1wiLVwiK2cpO2MudT1nO2c9Yy51O2U9ZWc7ZT1kP2QudGV4dENvbnRlbnR8fFwiXCI6YWcoZSxhLGMuQixnKTtmPVgoYSk7dmFyIGw9Zi5hO2wmJiFRJiZsIT09ZCYmKGwuX3VzZUNvdW50LS0sMD49bC5fdXNlQ291bnQmJmwucGFyZW50Tm9kZSYmbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGwpKTtRP2YuYT8oZi5hLnRleHRDb250ZW50PWUsZD1mLmEpOmUmJihkPWZmKGUsZyxhLnNoYWRvd1Jvb3QsZi5iKSk6ZD9kLnBhcmVudE5vZGV8fChSZiYmXG4tMTxlLmluZGV4T2YoXCJAbWVkaWFcIikmJihkLnRleHRDb250ZW50PWUpLGdmKGQsbnVsbCxmLmIpKTplJiYoZD1mZihlLGcsbnVsbCxmLmIpKTtkJiYoZC5fdXNlQ291bnQ9ZC5fdXNlQ291bnR8fDAsZi5hIT1kJiZkLl91c2VDb3VudCsrLGYuYT1kKTtnPWQ7UXx8KGQ9Yy51LGY9ZT1hLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwiLGgmJihmPWUucmVwbGFjZShuZXcgUmVnRXhwKFwiXFxcXHMqeC1zY29wZVxcXFxzKlwiK2grXCJcXFxccypcIixcImdcIiksXCIgXCIpKSxmKz0oZj9cIiBcIjpcIlwiKStcIngtc2NvcGUgXCIrZCxlIT09ZiYmamYoYSxmKSk7Ynx8eWcuc3RvcmUoayxjLkIsZyxjLnUpfX07ZnVuY3Rpb24gQ2coYSxiKXtyZXR1cm4oYj1iLmdldFJvb3ROb2RlKCkuaG9zdCk/WChiKT9iOkNnKGEsYik6YS5jfVxuZnVuY3Rpb24gQmcoYSxiLGMpe2E9Q2coYSxiKTt2YXIgZD1YKGEpO2E9T2JqZWN0LmNyZWF0ZShkLkJ8fG51bGwpO3ZhciBlPSRmKGIsYy53KTtiPVlmKGQudyxiKS52O09iamVjdC5hc3NpZ24oYSxlLk5hLGIsZS5WYSk7Yj1jLkc7Zm9yKHZhciBmIGluIGIpaWYoKGU9YltmXSl8fDA9PT1lKWFbZl09ZTtmPWVnO2I9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYSk7Zm9yKGU9MDtlPGIubGVuZ3RoO2UrKylkPWJbZV0sYVtkXT1XZihmLGFbZF0sYSk7Yy5CPWF9cC5zdHlsZURvY3VtZW50PWZ1bmN0aW9uKGEpe3RoaXMuc3R5bGVTdWJ0cmVlKHRoaXMuYyxhKX07XG5wLnN0eWxlU3VidHJlZT1mdW5jdGlvbihhLGIpe3ZhciBjPWEuc2hhZG93Um9vdDsoY3x8YT09PXRoaXMuYykmJnRoaXMuc3R5bGVFbGVtZW50KGEsYik7aWYoYj1jJiYoYy5jaGlsZHJlbnx8Yy5jaGlsZE5vZGVzKSlmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKXRoaXMuc3R5bGVTdWJ0cmVlKGJbYV0pO2Vsc2UgaWYoYT1hLmNoaWxkcmVufHxhLmNoaWxkTm9kZXMpZm9yKGI9MDtiPGEubGVuZ3RoO2IrKyl0aGlzLnN0eWxlU3VidHJlZShhW2JdKX07cC52YT1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9ZGYoYSk7Y2YoYyxmdW5jdGlvbihhKXtpZihRKUtmKGEpO2Vsc2V7dmFyIGM9VzthLnNlbGVjdG9yPWEucGFyc2VkU2VsZWN0b3I7S2YoYSk7YS5zZWxlY3Rvcj1hLm09dGYoYyxhLGMuYyx2b2lkIDAsdm9pZCAwKX1SJiYoemcoYiksYi5hJiZiLmEudHJhbnNmb3JtUnVsZShhKSl9KTtSP2EudGV4dENvbnRlbnQ9YmYoYyk6dGhpcy5oLncucnVsZXMucHVzaChjKX07XG5wLmdldENvbXB1dGVkU3R5bGVWYWx1ZT1mdW5jdGlvbihhLGIpe3ZhciBjO1J8fChjPShYKGEpfHxYKENnKHRoaXMsYSkpKS5CW2JdKTtyZXR1cm4oYz1jfHx3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShhKS5nZXRQcm9wZXJ0eVZhbHVlKGIpKT9jLnRyaW0oKTpcIlwifTtwLllhPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5nZXRSb290Tm9kZSgpO2I9Yj9iLnNwbGl0KC9cXHMvKTpbXTtjPWMuaG9zdCYmYy5ob3N0LmxvY2FsTmFtZTtpZighYyl7dmFyIGQ9YS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKTtpZihkKXtkPWQuc3BsaXQoL1xccy8pO2Zvcih2YXIgZT0wO2U8ZC5sZW5ndGg7ZSsrKWlmKGRbZV09PT1XLmEpe2M9ZFtlKzFdO2JyZWFrfX19YyYmYi5wdXNoKFcuYSxjKTtSfHwoYz1YKGEpKSYmYy51JiZiLnB1c2goZWcuYSxjLnUpO2pmKGEsYi5qb2luKFwiIFwiKSl9O3AuSWE9ZnVuY3Rpb24oYSl7cmV0dXJuIFgoYSl9O1kucHJvdG90eXBlLmZsdXNoPVkucHJvdG90eXBlLnhhO1xuWS5wcm90b3R5cGUucHJlcGFyZVRlbXBsYXRlPVkucHJvdG90eXBlLnByZXBhcmVUZW1wbGF0ZTtZLnByb3RvdHlwZS5zdHlsZUVsZW1lbnQ9WS5wcm90b3R5cGUuc3R5bGVFbGVtZW50O1kucHJvdG90eXBlLnN0eWxlRG9jdW1lbnQ9WS5wcm90b3R5cGUuc3R5bGVEb2N1bWVudDtZLnByb3RvdHlwZS5zdHlsZVN1YnRyZWU9WS5wcm90b3R5cGUuc3R5bGVTdWJ0cmVlO1kucHJvdG90eXBlLmdldENvbXB1dGVkU3R5bGVWYWx1ZT1ZLnByb3RvdHlwZS5nZXRDb21wdXRlZFN0eWxlVmFsdWU7WS5wcm90b3R5cGUuc2V0RWxlbWVudENsYXNzPVkucHJvdG90eXBlLllhO1kucHJvdG90eXBlLl9zdHlsZUluZm9Gb3JOb2RlPVkucHJvdG90eXBlLklhO1kucHJvdG90eXBlLnRyYW5zZm9ybUN1c3RvbVN0eWxlRm9yRG9jdW1lbnQ9WS5wcm90b3R5cGUudmE7WS5wcm90b3R5cGUuZ2V0U3R5bGVBc3Q9WS5wcm90b3R5cGUuTGE7WS5wcm90b3R5cGUuc3R5bGVBc3RUb1N0cmluZz1ZLnByb3RvdHlwZS5aYTtcblkucHJvdG90eXBlLmZsdXNoQ3VzdG9tU3R5bGVzPVkucHJvdG90eXBlLkY7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoWS5wcm90b3R5cGUse25hdGl2ZVNoYWRvdzp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFF9fSxuYXRpdmVDc3M6e2dldDpmdW5jdGlvbigpe3JldHVybiBSfX19KTt2YXIgWj1uZXcgWSxEZyxFZzt3aW5kb3cuU2hhZHlDU1MmJihEZz13aW5kb3cuU2hhZHlDU1MuQXBwbHlTaGltLEVnPXdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZSk7d2luZG93LlNoYWR5Q1NTPXtTY29waW5nU2hpbTpaLHByZXBhcmVUZW1wbGF0ZTpmdW5jdGlvbihhLGIsYyl7Wi5GKCk7Wi5wcmVwYXJlVGVtcGxhdGUoYSxiLGMpfSxzdHlsZVN1YnRyZWU6ZnVuY3Rpb24oYSxiKXtaLkYoKTtaLnN0eWxlU3VidHJlZShhLGIpfSxzdHlsZUVsZW1lbnQ6ZnVuY3Rpb24oYSl7Wi5GKCk7Wi5zdHlsZUVsZW1lbnQoYSl9LHN0eWxlRG9jdW1lbnQ6ZnVuY3Rpb24oYSl7Wi5GKCk7Wi5zdHlsZURvY3VtZW50KGEpfSxnZXRDb21wdXRlZFN0eWxlVmFsdWU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gWi5nZXRDb21wdXRlZFN0eWxlVmFsdWUoYSxiKX0sbmF0aXZlQ3NzOlIsbmF0aXZlU2hhZG93OlF9O0RnJiYod2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbT1EZyk7XG5FZyYmKHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZT1FZyk7dmFyIEZnPXdpbmRvdy5jdXN0b21FbGVtZW50cyxHZz13aW5kb3cuSFRNTEltcG9ydHMsSGc9d2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQ7d2luZG93LldlYkNvbXBvbmVudHM9d2luZG93LldlYkNvbXBvbmVudHN8fHt9O2lmKEZnJiZGZy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKXt2YXIgSWcsSmc9ZnVuY3Rpb24oKXtpZihJZyl7SGcuSiYmSGcuSih3aW5kb3cuZG9jdW1lbnQpO3ZhciBhPUlnO0lnPW51bGw7YSgpO3JldHVybiEwfX0sS2c9R2cud2hlblJlYWR5O0ZnLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2soZnVuY3Rpb24oYSl7SWc9YTtLZyhKZyl9KTtHZy53aGVuUmVhZHk9ZnVuY3Rpb24oYSl7S2coZnVuY3Rpb24oKXtKZygpP0dnLndoZW5SZWFkeShhKTphKCl9KX19XG5HZy53aGVuUmVhZHkoZnVuY3Rpb24oKXtyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKXt3aW5kb3cuV2ViQ29tcG9uZW50cy5yZWFkeT0hMDtkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcIldlYkNvbXBvbmVudHNSZWFkeVwiLHtidWJibGVzOiEwfSkpfSl9KTt2YXIgTGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO0xnLnRleHRDb250ZW50PVwiYm9keSB7dHJhbnNpdGlvbjogb3BhY2l0eSBlYXNlLWluIDAuMnM7IH0gXFxuYm9keVt1bnJlc29sdmVkXSB7b3BhY2l0eTogMDsgZGlzcGxheTogYmxvY2s7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsgfSBcXG5cIjt2YXIgTWc9ZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImhlYWRcIik7TWcuaW5zZXJ0QmVmb3JlKExnLE1nLmZpcnN0Q2hpbGQpO30pLmNhbGwodGhpcyk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlYmNvbXBvbmVudHMtbGl0ZS5qcy5tYXBcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3dlYmNvbXBvbmVudHNqcy93ZWJjb21wb25lbnRzLWxpdGUuanNcbi8vIG1vZHVsZSBpZCA9IDk4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpIHx8ICgxLGV2YWwpKFwidGhpc1wiKTtcclxufSBjYXRjaChlKSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcclxuXHRpZih0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKVxyXG5cdFx0ZyA9IHdpbmRvdztcclxufVxyXG5cclxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxyXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xyXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IGc7XHJcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=