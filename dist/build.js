/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 51);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_legacy_legacy_element_mixin_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_legacy_templatizer_behavior_js__ = __webpack_require__(64);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_elements_dom_bind_js__ = __webpack_require__(65);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_elements_dom_repeat_js__ = __webpack_require__(66);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__lib_elements_dom_if_js__ = __webpack_require__(67);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__lib_elements_array_selector_js__ = __webpack_require__(68);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__lib_elements_custom_style_js__ = __webpack_require__(69);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__lib_legacy_mutable_data_behavior_js__ = __webpack_require__(71);









const Base = Object(__WEBPACK_IMPORTED_MODULE_0__lib_legacy_legacy_element_mixin_js__["a" /* LegacyElementMixin */])(HTMLElement).prototype;
/* unused harmony export Base */



/***/ }),
/* 1 */
/***/ (function(module, exports) {

window.JSCompiler_renameProperty = function(prop, obj) { return prop; }

/** @namespace */
let Polymer;


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomApi */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return matchesSelector; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_flattened_nodes_observer_js__ = __webpack_require__(62);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__ = __webpack_require__(28);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["b"]; });
/* unused harmony reexport addDebouncer */





const p = Element.prototype;
/**
 * @const {function(this:Element, string): boolean}
 */
const normalizedMatchesSelector = p.matches || p.matchesSelector ||
  p.mozMatchesSelector || p.msMatchesSelector ||
  p.oMatchesSelector || p.webkitMatchesSelector;

/**
 * Cross-platform `element.matches` shim.
 *
 * @function matchesSelector
 * @memberof Polymer.dom
 * @param {!Element} node Node to check selector against
 * @param {string} selector Selector to match
 * @return {boolean} True if node matched selector
 */
const matchesSelector = function(node, selector) {
  return normalizedMatchesSelector.call(node, selector);
};

/**
 * Node API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is a `Node`.
 */
class DomApi {

  /**
   * @param {Node} node Node for which to create a Polymer.dom helper object.
   */
  constructor(node) {
    this.node = node;
  }

  /**
   * Returns an instance of `Polymer.FlattenedNodesObserver` that
   * listens for node changes on this element.
   *
   * @param {Function} callback Called when direct or distributed children
   *   of this element changes
   * @return {Polymer.FlattenedNodesObserver} Observer instance
   */
  observeNodes(callback) {
    return new __WEBPACK_IMPORTED_MODULE_2__utils_flattened_nodes_observer_js__["a" /* FlattenedNodesObserver */](this.node, callback);
  }

  /**
   * Disconnects an observer previously created via `observeNodes`
   *
   * @param {Polymer.FlattenedNodesObserver} observerHandle Observer instance
   *   to disconnect.
   */
  unobserveNodes(observerHandle) {
    observerHandle.disconnect();
  }

  /**
   * Provided as a backwards-compatible API only.  This method does nothing.
   */
  notifyObserver() {}

  /**
   * Returns true if the provided node is contained with this element's
   * light-DOM children or shadow root, including any nested shadow roots
   * of children therein.
   *
   * @param {Node} node Node to test
   * @return {boolean} Returns true if the given `node` is contained within
   *   this element's light or shadow DOM.
   */
  deepContains(node) {
    if (this.node.contains(node)) {
      return true;
    }
    let n = node;
    let doc = node.ownerDocument;
    // walk from node to `this` or `document`
    while (n && n !== doc && n !== this.node) {
      // use logical parentnode, or native ShadowRoot host
      n = n.parentNode || n.host;
    }
    return n === this.node;
  }

  /**
   * Returns the root node of this node.  Equivalent to `getRoodNode()`.
   *
   * @return {Node} Top most element in the dom tree in which the node
   * exists. If the node is connected to a document this is either a
   * shadowRoot or the document; otherwise, it may be the node
   * itself or a node or document fragment containing it.
   */
  getOwnerRoot() {
    return this.node.getRootNode();
  }

  /**
   * For slot elements, returns the nodes assigned to the slot; otherwise
   * an empty array. It is equivalent to `<slot>.addignedNodes({flatten:true})`.
   *
   * @return {Array<Node>} Array of assigned nodes
   */
  getDistributedNodes() {
    return (this.node.localName === 'slot') ?
      this.node.assignedNodes({flatten: true}) :
      [];
  }

  /**
   * Returns an array of all slots this element was distributed to.
   *
   * @return {Array<HTMLSlotElement>} Description
   */
  getDestinationInsertionPoints() {
    let ip$ = [];
    let n = this.node.assignedSlot;
    while (n) {
      ip$.push(n);
      n = n.assignedSlot;
    }
    return ip$;
  }

  /**
   * Calls `importNode` on the `ownerDocument` for this node.
   *
   * @param {Node} node Node to import
   * @param {boolean} deep True if the node should be cloned deeply during
   *   import
   * @return {Node} Clone of given node imported to this owner document
   */
  importNode(node, deep) {
    let doc = this.node instanceof Document ? this.node :
      this.node.ownerDocument;
    return doc.importNode(node, deep);
  }

  /**
   * @return {Array} Returns a flattened list of all child nodes and nodes assigned
   * to child slots.
   */
  getEffectiveChildNodes() {
    return __WEBPACK_IMPORTED_MODULE_2__utils_flattened_nodes_observer_js__["a" /* FlattenedNodesObserver */].getFlattenedNodes(this.node);
  }

  /**
   * Returns a filtered list of flattened child elements for this element based
   * on the given selector.
   *
   * @param {string} selector Selector to filter nodes against
   * @return {Array<HTMLElement>} List of flattened child elements
   */
  queryDistributedElements(selector) {
    let c$ = this.getEffectiveChildNodes();
    let list = [];
    for (let i=0, l=c$.length, c; (i<l) && (c=c$[i]); i++) {
      if ((c.nodeType === Node.ELEMENT_NODE) &&
          matchesSelector(c, selector)) {
        list.push(c);
      }
    }
    return list;
  }

  /**
   * For shadow roots, returns the currently focused element within this
   * shadow root.
   *
   * @return {Node|undefined} Currently focused element
   */
  get activeElement() {
    let node = this.node;
    return node._activeElement !== undefined ? node._activeElement : node.activeElement;
  }
}

function forwardMethods(proto, methods) {
  for (let i=0; i < methods.length; i++) {
    let method = methods[i];
    proto[method] = /** @this {DomApi} */ function() {
      return this.node[method].apply(this.node, arguments);
    };
  }
}

function forwardReadOnlyProperties(proto, properties) {
  for (let i=0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        return /** @type {DomApi} */ (this).node[name];
      },
      configurable: true
    });
  }
}

function forwardProperties(proto, properties) {
  for (let i=0; i < properties.length; i++) {
    let name = properties[i];
    Object.defineProperty(proto, name, {
      get: function() {
        return /** @type {DomApi} */ (this).node[name];
      },
      set: function(value) {
        /** @type {DomApi} */ (this).node[name] = value;
      },
      configurable: true
    });
  }
}

forwardMethods(DomApi.prototype, [
  'cloneNode', 'appendChild', 'insertBefore', 'removeChild',
  'replaceChild', 'setAttribute', 'removeAttribute',
  'querySelector', 'querySelectorAll'
]);

forwardReadOnlyProperties(DomApi.prototype, [
  'parentNode', 'firstChild', 'lastChild',
  'nextSibling', 'previousSibling', 'firstElementChild',
  'lastElementChild', 'nextElementSibling', 'previousElementSibling',
  'childNodes', 'children', 'classList'
]);

forwardProperties(DomApi.prototype, [
  'textContent', 'innerHTML'
]);


/**
 * Event API wrapper class returned from `Polymer.dom.(target)` when
 * `target` is an `Event`.
 */
class EventApi {
  constructor(event) {
    this.event = event;
  }

  /**
   * Returns the first node on the `composedPath` of this event.
   *
   * @return {Node} The node this event was dispatched to
   */
  get rootTarget() {
    return this.event.composedPath()[0];
  }

  /**
   * Returns the local (re-targeted) target for this event.
   *
   * @return {Node} The local (re-targeted) target for this event.
   */
  get localTarget() {
    return this.event.target;
  }

  /**
   * Returns the `composedPath` for this event.
   */
  get path() {
    return this.event.composedPath();
  }
}



const dom = function(obj) {
  obj = obj || document;
  if (!obj.__domApi) {
    let helper;
    if (obj instanceof Event) {
      helper = new EventApi(obj);
    } else {
      helper = new DomApi(obj);
    }
    obj.__domApi = helper;
  }
  return obj.__domApi;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = dom;







/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__class_js__ = __webpack_require__(63);


const Polymer = function(info) {
  // if input is a `class` (aka a function with a prototype), use the prototype
  // remember that the `constructor` will never be called
  let klass;
  if (typeof info === 'function') {
    klass = info;
  } else {
    klass = Object(__WEBPACK_IMPORTED_MODULE_0__class_js__["a" /* Class */])(info);
  }
  customElements.define(klass.is, /** @type {!HTMLElement} */(klass));
  return klass;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = Polymer;



/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Element; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_mixins_element_mixin_js__ = __webpack_require__(20);


/**
 * Base class that provides the core API for Polymer's meta-programming
 * features including template stamping, data-binding, attribute deserialization,
 * and property change observation.
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @constructor
 * @implements {Polymer_ElementMixin}
 * @extends HTMLElement
 * @appliesMixin Polymer.ElementMixin
 * @summary Custom element base class that provides the core API for Polymer's
 *   key meta-programming features including template stamping, data-binding,
 *   attribute deserialization, and property change observation
 */
const Element = Object(__WEBPACK_IMPORTED_MODULE_0__lib_mixins_element_mixin_js__["a" /* ElementMixin */])(HTMLElement);



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


// unique global id for deduping mixins.
let dedupeId = 0;

/**
 * @constructor
 * @extends {Function}
 */
function MixinFunction(){}
/** @type {(WeakMap | undefined)} */
MixinFunction.prototype.__mixinApplications;
/** @type {(Object | undefined)} */
MixinFunction.prototype.__mixinSet;

const dedupingMixin = function(mixin) {
  let mixinApplications = /** @type {!MixinFunction} */(mixin).__mixinApplications;
  if (!mixinApplications) {
    mixinApplications = new WeakMap();
    /** @type {!MixinFunction} */(mixin).__mixinApplications = mixinApplications;
  }
  // maintain a unique id for each mixin
  let mixinDedupeId = dedupeId++;
  function dedupingMixin(base) {
    let baseSet = /** @type {!MixinFunction} */(base).__mixinSet;
    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }
    let map = mixinApplications;
    let extended = map.get(base);
    if (!extended) {
      extended = /** @type {!Function} */(mixin)(base);
      map.set(base, extended);
    }
    // copy inherited mixin set from the extended class, or the base class
    // NOTE: we avoid use of Set here because some browser (IE11)
    // cannot extend a base Set via the constructor.
    let mixinSet = Object.create(/** @type {!MixinFunction} */(extended).__mixinSet || baseSet || null);
    mixinSet[mixinDedupeId] = true;
    /** @type {!MixinFunction} */(extended).__mixinSet = mixinSet;
    return extended;
  }

  return dedupingMixin;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = dedupingMixin;



/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
let AsyncInterface; // eslint-disable-line no-unused-vars

// Microtask implemented using Mutation Observer
let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskNode = document.createTextNode('');
new window.MutationObserver(microtaskFlush).observe(microtaskNode, {characterData: true});

function microtaskFlush() {
  const len = microtaskCallbacks.length;
  for (let i = 0; i < len; i++) {
    let cb = microtaskCallbacks[i];
    if (cb) {
      try {
        cb();
      } catch (e) {
        setTimeout(() => { throw e; });
      }
    }
  }
  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}

const timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} delay Time to wait before calling callbacks in ms
   * @return {AsyncInterface} An async timeout interface
   */
  after(delay) {
    return  {
      run(fn) { return setTimeout(fn, delay); },
      cancel: window.clearTimeout.bind(window)
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof Polymer.Async.timeOut
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.setTimeout.bind(window),
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.clearTimeout.bind(window)
};
/* harmony export (immutable) */ __webpack_exports__["b"] = timeOut;


const animationFrame = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof Polymer.Async.animationFrame
   * @param {Function} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run: window.requestAnimationFrame.bind(window),
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof Polymer.Async.timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel: window.cancelAnimationFrame.bind(window)
};
/* unused harmony export animationFrame */


const idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {function(IdleDeadline)} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestIdleCallback ?
      window.requestIdleCallback(fn) :
      window.setTimeout(fn, 16);
  },
  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof Polymer.Async.idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel(handle) {
    window.cancelIdleCallback ?
      window.cancelIdleCallback(handle) :
      window.clearTimeout(handle);
  }
};
/* unused harmony export idlePeriod */


const microTask = {

  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof Polymer.Async.microTask
   * @param {Function} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    microtaskNode.textContent = microtaskNodeContent++;
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },

  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof Polymer.Async.microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle;
    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error('invalid async handle: ' + handle);
      }
      microtaskCallbacks[idx] = null;
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = microTask;



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["dashToCamelCase"] = dashToCamelCase;
/* harmony export (immutable) */ __webpack_exports__["camelToDashCase"] = camelToDashCase;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


const caseMap = {};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH = /([A-Z])/g;

function dashToCamelCase(dash) {
  return caseMap[dash] || (
    caseMap[dash] = dash.indexOf('-') < 0 ? dash : dash.replace(DASH_TO_CAMEL,
      (m) => m[1].toUpperCase()
    )
  );
}

function camelToDashCase(camel) {
  return caseMap[camel] || (
    caseMap[camel] = camel.replace(CAMEL_TO_DASH, '-$1').toLowerCase()
  );
}


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__color_js__ = __webpack_require__(43);


const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {
      /*
       * You can use these generic variables in your elements for easy theming.
       * For example, if all your elements use \`--primary-text-color\` as its main
       * color, then switching from a light to a dark theme is just a matter of
       * changing the value of \`--primary-text-color\` in your application.
       */
      --primary-text-color: var(--light-theme-text-color);
      --primary-background-color: var(--light-theme-background-color);
      --secondary-text-color: var(--light-theme-secondary-color);
      --disabled-text-color: var(--light-theme-disabled-color);
      --divider-color: var(--light-theme-divider-color);
      --error-color: var(--paper-deep-orange-a700);

      /*
       * Primary and accent colors. Also see color.html for more colors.
       */
      --primary-color: var(--paper-indigo-500);
      --light-primary-color: var(--paper-indigo-100);
      --dark-primary-color: var(--paper-indigo-700);

      --accent-color: var(--paper-pink-a200);
      --light-accent-color: var(--paper-pink-a100);
      --dark-accent-color: var(--paper-pink-a400);


      /*
       * Material Design Light background theme
       */
      --light-theme-background-color: #ffffff;
      --light-theme-base-color: #000000;
      --light-theme-text-color: var(--paper-grey-900);
      --light-theme-secondary-color: #737373;  /* for secondary text and icons */
      --light-theme-disabled-color: #9b9b9b;  /* disabled/hint text */
      --light-theme-divider-color: #dbdbdb;

      /*
       * Material Design Dark background theme
       */
      --dark-theme-background-color: var(--paper-grey-900);
      --dark-theme-base-color: #ffffff;
      --dark-theme-text-color: #ffffff;
      --dark-theme-secondary-color: #bcbcbc;  /* for secondary text and icons */
      --dark-theme-disabled-color: #646464;  /* disabled/hint text */
      --dark-theme-divider-color: #3c3c3c;

      /*
       * Deprecated values because of their confusing names.
       */
      --text-primary-color: var(--dark-theme-text-color);
      --default-primary-color: var(--primary-color);
    }
  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return settings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return rootPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return sanitizeDOMValue; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__resolve_url_js__ = __webpack_require__(10);



/**
 * Legacy settings.
 * @namespace
 * @memberof Polymer
 */
const settings = undefined || {};
const useShadow = !(window.ShadyDOM);
/* unused harmony export useShadow */

const useNativeCSSProperties = Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
/* unused harmony export useNativeCSSProperties */

const useNativeCustomElements = !(window.customElements.polyfillWrapFlushCallback);
/* unused harmony export useNativeCustomElements */



/**
 * Globally settable property that is automatically assigned to
 * `Polymer.ElementMixin` instances, useful for binding in templates to
 * make URL's relative to an application's root.  Defaults to the main
 * document URL, but can be overridden by users.  It may be useful to set
 * `Polymer.rootPath` to provide a stable application mount path when
 * using client side routing.
 *
 * @memberof Polymer
 */
let rootPath = undefined ||
  Object(__WEBPACK_IMPORTED_MODULE_1__resolve_url_js__["a" /* pathFromUrl */])(document.baseURI || window.location.href);



const setRootPath = function(path) {
  rootPath = path;
};
/* unused harmony export setRootPath */


/**
 * A global callback used to sanitize any value before inserting it into the DOM. The callback signature is:
 *
 *     Polymer = {
 *       sanitizeDOMValue: function(value, name, type, node) { ... }
 *     }
 *
 * Where:
 *
 * `value` is the value to sanitize.
 * `name` is the name of an attribute or property (for example, href).
 * `type` indicates where the value is being inserted: one of property, attribute, or text.
 * `node` is the node where the value is being inserted.
 *
 * @type {(function(*,string,string,Node):*)|undefined}
 * @memberof Polymer
 */
let sanitizeDOMValue = undefined;



const setSanitizeDOMValue = function(newSanitizeDOMValue) {
  sanitizeDOMValue = newSanitizeDOMValue;
};
/* unused harmony export setSanitizeDOMValue */



/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return resolveCss; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return resolveUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return pathFromUrl; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/)|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
/**
 * Resolves the given URL against the provided `baseUri'.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to resolve
 * @param {?string=} baseURI Base URI to resolve the URL against
 * @return {string} resolved URL
 */
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  // Lazy feature detection.
  if (workingURL === undefined) {
    workingURL = false;
    try {
      const u = new URL('b', 'http://a');
      u.pathname = 'c%20d';
      workingURL = (u.href === 'http://a/c%20d');
    } catch (e) {
      // silently fail
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    return (new URL(url, baseURI)).href;
  }
  // Fallback to creating an anchor into a disconnected document.
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument('temp');
    resolveDoc.base = resolveDoc.createElement('base');
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement('a');
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;

}

/**
 * Resolves any relative URL's in the given CSS text against the provided
 * `ownerDocument`'s `baseURI`.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} cssText CSS text to process
 * @param {string} baseURI Base URI to resolve the URL against
 * @return {string} Processed CSS text with resolved URL's
 */
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function(m, pre, url, post) {
    return pre + '\'' +
      resolveUrl(url.replace(/["']/g, ''), baseURI) +
      '\'' + post;
  });
}

/**
 * Returns a path from a given `url`. The path includes the trailing
 * `/` from the url.
 *
 * @memberof Polymer.ResolveUrl
 * @param {string} url Input URL to transform
 * @return {string} resolved path
 */
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf('/') + 1);
}






/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["d"] = isPath;
/* harmony export (immutable) */ __webpack_exports__["g"] = root;
/* harmony export (immutable) */ __webpack_exports__["b"] = isAncestor;
/* harmony export (immutable) */ __webpack_exports__["c"] = isDescendant;
/* harmony export (immutable) */ __webpack_exports__["i"] = translate;
/* harmony export (immutable) */ __webpack_exports__["e"] = matches;
/* harmony export (immutable) */ __webpack_exports__["f"] = normalize;
/* unused harmony export split */
/* harmony export (immutable) */ __webpack_exports__["a"] = get;
/* harmony export (immutable) */ __webpack_exports__["h"] = set;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


function isPath(path) {
  return path.indexOf('.') >= 0;
}

function root(path) {
  let dotIndex = path.indexOf('.');
  if (dotIndex === -1) {
    return path;
  }
  return path.slice(0, dotIndex);
}

function isAncestor(base, path) {
  //     base.startsWith(path + '.');
  return base.indexOf(path + '.') === 0;
}

function isDescendant(base, path) {
  //     path.startsWith(base + '.');
  return path.indexOf(base + '.') === 0;
}

function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}

function matches(base, path) {
  return (base === path) ||
         isAncestor(base, path) ||
         isDescendant(base, path);
}

function normalize(path) {
  if (Array.isArray(path)) {
    let parts = [];
    for (let i=0; i<path.length; i++) {
      let args = path[i].toString().split('.');
      for (let j=0; j<args.length; j++) {
        parts.push(args[j]);
      }
    }
    return parts.join('.');
  } else {
    return path;
  }
}

function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split('.');
  }
  return path.toString().split('.');
}

function get(root, path, info) {
  let prop = root;
  let parts = split(path);
  // Loop over path parts[0..n-1] and dereference
  for (let i=0; i<parts.length; i++) {
    if (!prop) {
      return;
    }
    let part = parts[i];
    prop = prop[part];
  }
  if (info) {
    info.path = parts.join('.');
  }
  return prop;
}

function set(root, path, value) {
  let prop = root;
  let parts = split(path);
  let last = parts[parts.length-1];
  if (parts.length > 1) {
    // Loop over path parts[0..n-2] and dereference
    for (let i=0; i<parts.length-1; i++) {
      let part = parts[i];
      prop = prop[part];
      if (!prop) {
        return;
      }
    }
    // Set value to object at end of path
    prop[last] = value;
  } else {
    // Simple property set
    prop[path] = value;
  }
  return parts.join('.');
}

const isDeep = isPath;
/* unused harmony export isDeep */



/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["deepTargetFind"] = deepTargetFind;
/* harmony export (immutable) */ __webpack_exports__["_findOriginalTarget"] = _findOriginalTarget;
/* harmony export (immutable) */ __webpack_exports__["_handleNative"] = _handleNative;
/* harmony export (immutable) */ __webpack_exports__["_handleTouchAction"] = _handleTouchAction;
/* harmony export (immutable) */ __webpack_exports__["addListener"] = addListener;
/* harmony export (immutable) */ __webpack_exports__["removeListener"] = removeListener;
/* harmony export (immutable) */ __webpack_exports__["_add"] = _add;
/* harmony export (immutable) */ __webpack_exports__["_remove"] = _remove;
/* harmony export (immutable) */ __webpack_exports__["register"] = register;
/* harmony export (immutable) */ __webpack_exports__["_findRecognizerByEvent"] = _findRecognizerByEvent;
/* harmony export (immutable) */ __webpack_exports__["setTouchAction"] = setTouchAction;
/* harmony export (immutable) */ __webpack_exports__["_fire"] = _fire;
/* harmony export (immutable) */ __webpack_exports__["prevent"] = prevent;
/* harmony export (immutable) */ __webpack_exports__["resetMouseCanceller"] = resetMouseCanceller;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__async_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__debounce_js__ = __webpack_require__(13);




// detect native touch action support
let HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';
let GESTURE_KEY = '__polymerGestures';
let HANDLED_OBJ = '__polymerGesturesHandled';
let TOUCH_ACTION = '__polymerGesturesTouchAction';
// radius for tap and track
let TAP_DISTANCE = 25;
let TRACK_DISTANCE = 5;
// number of last N track positions to keep
let TRACK_LENGTH = 2;

// Disabling "mouse" handlers for 2500ms is enough
let MOUSE_TIMEOUT = 2500;
let MOUSE_EVENTS = ['mousedown', 'mousemove', 'mouseup', 'click'];
// an array of bitmask values for mapping MouseEvent.which to MouseEvent.buttons
let MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
let MOUSE_HAS_BUTTONS = (function() {
  try {
    return new MouseEvent('test', {buttons: 1}).buttons === 1;
  } catch (e) {
    return false;
  }
})();

/* eslint no-empty: ["error", { "allowEmptyCatch": true }] */
// check for passive event listeners
let SUPPORTS_PASSIVE = false;
(function() {
  try {
    let opts = Object.defineProperty({}, 'passive', {get: function() {SUPPORTS_PASSIVE = true;}});
    window.addEventListener('test', null, opts);
    window.removeEventListener('test', null, opts);
  } catch(e) {}
})();

// Check for touch-only devices
let IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);

let GestureRecognizer = function(){}; // eslint-disable-line no-unused-vars
GestureRecognizer.prototype.reset = function(){};
/** @type {function(MouseEvent) | undefined} */
GestureRecognizer.prototype.mousedown;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mousemove;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.mouseup;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchstart;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchmove;
/** @type {(function(TouchEvent) | undefined)} */
GestureRecognizer.prototype.touchend;
/** @type {(function(MouseEvent) | undefined)} */
GestureRecognizer.prototype.click;

// touch will make synthetic mouse events
// `preventDefault` on touchend will cancel them,
// but this breaks `<input>` focus and link clicks
// disable mouse handlers for MOUSE_TIMEOUT ms after
// a touchend to ignore synthetic mouse events
let mouseCanceller = function(mouseEvent) {
  // Check for sourceCapabilities, used to distinguish synthetic events
  // if mouseEvent did not come from a device that fires touch events,
  // it was made by a real mouse and should be counted
  // http://wicg.github.io/InputDeviceCapabilities/#dom-inputdevicecapabilities-firestouchevents
  let sc = mouseEvent.sourceCapabilities;
  if (sc && !sc.firesTouchEvents) {
    return;
  }
  // skip synthetic mouse events
  mouseEvent[HANDLED_OBJ] = {skip: true};
  // disable "ghost clicks"
  if (mouseEvent.type === 'click') {
    let path = mouseEvent.composedPath && mouseEvent.composedPath();
    if (path) {
      for (let i = 0; i < path.length; i++) {
        if (path[i] === POINTERSTATE.mouse.target) {
          return;
        }
      }
    }
    mouseEvent.preventDefault();
    mouseEvent.stopPropagation();
  }
};

/**
 * @param {boolean=} setup True to add, false to remove.
 */
function setupTeardownMouseCanceller(setup) {
  let events = IS_TOUCH_ONLY ? ['click'] : MOUSE_EVENTS;
  for (let i = 0, en; i < events.length; i++) {
    en = events[i];
    if (setup) {
      document.addEventListener(en, mouseCanceller, true);
    } else {
      document.removeEventListener(en, mouseCanceller, true);
    }
  }
}

function ignoreMouse(e) {
  if (!POINTERSTATE.mouse.mouseIgnoreJob) {
    setupTeardownMouseCanceller(true);
  }
  let unset = function() {
    setupTeardownMouseCanceller();
    POINTERSTATE.mouse.target = null;
    POINTERSTATE.mouse.mouseIgnoreJob = null;
  };
  POINTERSTATE.mouse.target = e.composedPath()[0];
  POINTERSTATE.mouse.mouseIgnoreJob = __WEBPACK_IMPORTED_MODULE_2__debounce_js__["a" /* Debouncer */].debounce(
        POINTERSTATE.mouse.mouseIgnoreJob
      , __WEBPACK_IMPORTED_MODULE_1__async_js__["b" /* timeOut */].after(MOUSE_TIMEOUT)
      , unset);
}

/**
 * @param {MouseEvent} ev event to test for left mouse button down
 * @return {boolean} has left mouse button down
 */
function hasLeftMouseButton(ev) {
  let type = ev.type;
  // exit early if the event is not a mouse event
  if (MOUSE_EVENTS.indexOf(type) === -1) {
    return false;
  }
  // ev.button is not reliable for mousemove (0 is overloaded as both left button and no buttons)
  // instead we use ev.buttons (bitmask of buttons) or fall back to ev.which (deprecated, 0 for no buttons, 1 for left button)
  if (type === 'mousemove') {
    // allow undefined for testing events
    let buttons = ev.buttons === undefined ? 1 : ev.buttons;
    if ((ev instanceof window.MouseEvent) && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    // buttons is a bitmask, check that the left button bit is set (1)
    return Boolean(buttons & 1);
  } else {
    // allow undefined for testing events
    let button = ev.button === undefined ? 0 : ev.button;
    // ev.button is 0 in mousedown/mouseup/click for left button activation
    return button === 0;
  }
}

function isSyntheticClick(ev) {
  if (ev.type === 'click') {
    // ev.detail is 0 for HTMLElement.click in most browsers
    if (ev.detail === 0) {
      return true;
    }
    // in the worst case, check that the x/y position of the click is within
    // the bounding box of the target of the event
    // Thanks IE 10 >:(
    let t = _findOriginalTarget(ev);
    // make sure the target of the event is an element so we can use getBoundingClientRect,
    // if not, just assume it is a synthetic click
    if (!t.nodeType || /** @type {Element} */(t).nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    let bcr = /** @type {Element} */(t).getBoundingClientRect();
    // use page x/y to account for scrolling
    let x = ev.pageX, y = ev.pageY;
    // ev is a synthetic click if the position is outside the bounding box of the target
    return !((x >= bcr.left && x <= bcr.right) && (y >= bcr.top && y <= bcr.bottom));
  }
  return false;
}

let POINTERSTATE = {
  mouse: {
    target: null,
    mouseIgnoreJob: null
  },
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};

function firstTouchAction(ev) {
  let ta = 'auto';
  let path = ev.composedPath && ev.composedPath();
  if (path) {
    for (let i = 0, n; i < path.length; i++) {
      n = path[i];
      if (n[TOUCH_ACTION]) {
        ta = n[TOUCH_ACTION];
        break;
      }
    }
  }
  return ta;
}

function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener('mousemove', movefn);
  document.addEventListener('mouseup', upfn);
}

function untrackDocument(stateObj) {
  document.removeEventListener('mousemove', stateObj.movefn);
  document.removeEventListener('mouseup', stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}

// use a document-wide touchend listener to start the ghost-click prevention mechanism
// Use passive event listeners, if supported, to not affect scrolling performance
document.addEventListener('touchend', ignoreMouse, SUPPORTS_PASSIVE ? {passive: true} : false);

const gestures = {};
/* harmony export (immutable) */ __webpack_exports__["gestures"] = gestures;

const recognizers = [];
/* harmony export (immutable) */ __webpack_exports__["recognizers"] = recognizers;


function deepTargetFind(x, y) {
  let node = document.elementFromPoint(x, y);
  let next = node;
  // this code path is only taken when native ShadowDOM is used
  // if there is a shadowroot, it may have a node at x/y
  // if there is not a shadowroot, exit the loop
  while (next && next.shadowRoot && !window.ShadyDOM) {
    // if there is a node at x/y in the shadowroot, look deeper
    let oldNext = next;
    next = next.shadowRoot.elementFromPoint(x, y);
    // on Safari, elementFromPoint may return the shadowRoot host
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}

function _findOriginalTarget(ev) {
  // shadowdom
  if (ev.composedPath) {
    return /** @type {EventTarget} */(ev.composedPath()[0]);
  }
  // shadydom
  return ev.target;
}

function _handleNative(ev) {
  let handled;
  let type = ev.type;
  let node = ev.currentTarget;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  let gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.slice(0, 5) === 'touch') {
      ev = /** @type {TouchEvent} */(ev); // eslint-disable-line no-self-assign
      let t = ev.changedTouches[0];
      if (type === 'touchstart') {
        // only handle the first finger
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === 'touchstart' || type === 'touchmove') {
          _handleTouchAction(ev);
        }
      }
    }
  }
  handled = ev[HANDLED_OBJ];
  // used to ignore synthetic mouse events
  if (handled.skip) {
    return;
  }
  // reset recognizer state
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  // enforce gesture recognizer order
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    if (gs[r.name] && !handled[r.name]) {
      handled[r.name] = true;
      r[type](ev);
    }
  }
}

function _handleTouchAction(ev) {
  let t = ev.changedTouches[0];
  let type = ev.type;
  if (type === 'touchstart') {
    POINTERSTATE.touch.x = t.clientX;
    POINTERSTATE.touch.y = t.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === 'touchmove') {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    let ta = firstTouchAction(ev);
    let prevent = false;
    let dx = Math.abs(POINTERSTATE.touch.x - t.clientX);
    let dy = Math.abs(POINTERSTATE.touch.y - t.clientY);
    if (!ev.cancelable) {
      // scrolling is happening
    } else if (ta === 'none') {
      prevent = true;
    } else if (ta === 'pan-x') {
      prevent = dy > dx;
    } else if (ta === 'pan-y') {
      prevent = dx > dy;
    }
    if (prevent) {
      ev.preventDefault();
    } else {
      prevent('track');
    }
  }
}

function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}

function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}

function _add(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (let i = 0, dep, gd; i < deps.length; i++) {
    dep = deps[i];
    // don't add mouse handlers on iOS because they cause gray selection overlays
    if (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1 && dep !== 'click') {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = {_count: 0};
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative);
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}

function _remove(node, evType, handler) {
  let recognizer = gestures[evType];
  let deps = recognizer.deps;
  let name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (gobj) {
    for (let i = 0, dep, gd; i < deps.length; i++) {
      dep = deps[i];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative);
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}

function register(recog) {
  recognizers.push(recog);
  for (let i = 0; i < recog.emits.length; i++) {
    gestures[recog.emits[i]] = recog;
  }
}

function _findRecognizerByEvent(evName) {
  for (let i = 0, r; i < recognizers.length; i++) {
    r = recognizers[i];
    for (let j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}

function setTouchAction(node, value) {
  if (HAS_NATIVE_TA) {
    node.style.touchAction = value;
  }
  node[TOUCH_ACTION] = value;
}

function _fire(target, type, detail) {
  let ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  target.dispatchEvent(ev);
  // forward `preventDefault` in a clean way
  if (ev.defaultPrevented) {
    let preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}

function prevent(evName) {
  let recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}

function resetMouseCanceller() {
  if (POINTERSTATE.mouse.mouseIgnoreJob) {
    POINTERSTATE.mouse.mouseIgnoreJob.flush();
  }
}

/* eslint-disable valid-jsdoc */

register({
  name: 'downup',
  deps: ['mousedown', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['down', 'up'],

  info: {
    movefn: null,
    upfn: null
  },

  /** @this {GestureRecognizer} */
  reset: function() {
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn(e) {
      if (!hasLeftMouseButton(e)) {
        self._fire('up', t, e);
        untrackDocument(self.info);
      }
    };
    let upfn = function upfn(e) {
      if (hasLeftMouseButton(e)) {
        self._fire('up', t, e);
      }
      untrackDocument(self.info);
    };
    trackDocument(this.info, movefn, upfn);
    this._fire('down', t, e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function(e) {
    this._fire('down', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function(e) {
    this._fire('up', _findOriginalTarget(e), e.changedTouches[0], e);
  },
  /**
   * @param {string} type
   * @param {EventTarget} target
   * @param {Event} event
   * @param {Function} preventer
   */
  _fire: function(type, target, event, preventer) {
    _fire(target, type, {
      x: event.clientX,
      y: event.clientY,
      sourceEvent: event,
      preventer: preventer,
      prevent: function(e) {
        return prevent(e);
      }
    });
  }
});

register({
  name: 'track',
  touchAction: 'none',
  deps: ['mousedown', 'touchstart', 'touchmove', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['mouseup', 'touchend']
  },
  emits: ['track'],

  info: {
    x: 0,
    y: 0,
    state: 'start',
    started: false,
    moves: [],
    /** @this {GestureRecognizer} */
    addMove: function(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },

  /** @this {GestureRecognizer} */
  reset: function() {
    this.info.state = 'start';
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },

  /**
   * @this {GestureRecognizer}
   * @param {number} x
   * @param {number} y
   * @return {boolean}
   */
  hasMovedEnough: function(x, y) {
    if (this.info.prevent) {
      return false;
    }
    if (this.info.started) {
      return true;
    }
    let dx = Math.abs(this.info.x - x);
    let dy = Math.abs(this.info.y - y);
    return (dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function(e) {
    if (!hasLeftMouseButton(e)) {
      return;
    }
    let t = _findOriginalTarget(e);
    let self = this;
    let movefn = function movefn(e) {
      let x = e.clientX, y = e.clientY;
      if (self.hasMovedEnough(x, y)) {
        // first move is 'start', subsequent moves are 'move', mouseup is 'end'
        self.info.state = self.info.started ? (e.type === 'mouseup' ? 'end' : 'track') : 'start';
        if (self.info.state === 'start') {
          // if and only if tracking, always prevent tap
          prevent('tap');
        }
        self.info.addMove({x: x, y: y});
        if (!hasLeftMouseButton(e)) {
          // always _fire "end"
          self.info.state = 'end';
          untrackDocument(self.info);
        }
        self._fire(t, e);
        self.info.started = true;
      }
    };
    let upfn = function upfn(e) {
      if (self.info.started) {
        movefn(e);
      }

      // remove the temporary listeners
      untrackDocument(self.info);
    };
    // add temporary document listeners as mouse retargets
    trackDocument(this.info, movefn, upfn);
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function(e) {
    let ct = e.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchmove: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    let x = ct.clientX, y = ct.clientY;
    if (this.hasMovedEnough(x, y)) {
      if (this.info.state === 'start') {
        // if and only if tracking, always prevent tap
        prevent('tap');
      }
      this.info.addMove({x: x, y: y});
      this._fire(t, ct);
      this.info.state = 'track';
      this.info.started = true;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function(e) {
    let t = _findOriginalTarget(e);
    let ct = e.changedTouches[0];
    // only trackend if track was started and not aborted
    if (this.info.started) {
      // reset started state on up
      this.info.state = 'end';
      this.info.addMove({x: ct.clientX, y: ct.clientY});
      this._fire(t, ct, e);
    }
  },

  /**
   * @this {GestureRecognizer}
   * @param {EventTarget} target
   * @param {Touch} touch
   */
  _fire: function(target, touch) {
    let secondlast = this.info.moves[this.info.moves.length - 2];
    let lastmove = this.info.moves[this.info.moves.length - 1];
    let dx = lastmove.x - this.info.x;
    let dy = lastmove.y - this.info.y;
    let ddx, ddy = 0;
    if (secondlast) {
      ddx = lastmove.x - secondlast.x;
      ddy = lastmove.y - secondlast.y;
    }
    _fire(target, 'track', {
      state: this.info.state,
      x: touch.clientX,
      y: touch.clientY,
      dx: dx,
      dy: dy,
      ddx: ddx,
      ddy: ddy,
      sourceEvent: touch,
      hover: function() {
        return deepTargetFind(touch.clientX, touch.clientY);
      }
    });
  }

});

register({
  name: 'tap',
  deps: ['mousedown', 'click', 'touchstart', 'touchend'],
  flow: {
    start: ['mousedown', 'touchstart'],
    end: ['click', 'touchend']
  },
  emits: ['tap'],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  /** @this {GestureRecognizer} */
  reset: function() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  /** @this {GestureRecognizer} */
  save: function(e) {
    this.info.x = e.clientX;
    this.info.y = e.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  mousedown: function(e) {
    if (hasLeftMouseButton(e)) {
      this.save(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   */
  click: function(e) {
    if (hasLeftMouseButton(e)) {
      this.forward(e);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchstart: function(e) {
    this.save(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   */
  touchend: function(e) {
    this.forward(e.changedTouches[0], e);
  },
  /**
   * @this {GestureRecognizer}
   * @param {Event | Touch} e
   * @param {Event=} preventer
   */
  forward: function(e, preventer) {
    let dx = Math.abs(e.clientX - this.info.x);
    let dy = Math.abs(e.clientY - this.info.y);
    // find original target from `preventer` for TouchEvents, or `e` for MouseEvents
    let t = _findOriginalTarget((preventer || e));
    // dx,dy can be NaN if `click` has been simulated and there was no `down` for `start`
    if (isNaN(dx) || isNaN(dy) || (dx <= TAP_DISTANCE && dy <= TAP_DISTANCE) || isSyntheticClick(e)) {
      // prevent taps from being generated if an event has canceled them
      if (!this.info.prevent) {
        _fire(t, 'tap', {
          x: e.clientX,
          y: e.clientY,
          sourceEvent: e,
          preventer: preventer
        });
      }
    }
  }
});

const findOriginalTarget = _findOriginalTarget;
/* harmony export (immutable) */ __webpack_exports__["findOriginalTarget"] = findOriginalTarget;

const add = addListener;
/* harmony export (immutable) */ __webpack_exports__["add"] = add;

const remove = removeListener;
/* harmony export (immutable) */ __webpack_exports__["remove"] = remove;



/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Debouncer; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixin_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__async_js__ = __webpack_require__(6);




/** @typedef {{run: function(function(), number=):number, cancel: function(number)}} */
let AsyncModule; // eslint-disable-line no-unused-vars

/**
 * @summary Collapse multiple callbacks into one invocation after a timer.
 * @memberof Polymer
 */
class Debouncer {
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncModule} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   */
  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   */
  cancel() {
    if (this.isActive()) {
      this._asyncModule.cancel(this._timer);
      this._timer = null;
    }
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   */
  flush() {
    if (this.isActive()) {
      this.cancel();
      this._callback();
    }
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
/**
 * Creates a debouncer if no debouncer is passed as a parameter
 * or it cancels an active debouncer otherwise. The following
 * example shows how a debouncer can be called multiple times within a
 * microtask and "debounced" such that the provided callback function is
 * called once. Add this method to a custom element:
 *
 * _debounceWork() {
 *   this._debounceJob = Polymer.Debouncer.debounce(this._debounceJob,
 *       Polymer.Async.microTask, () => {
 *     this._doWork();
 *   });
 * }
 *
 * If the `_debounceWork` method is called multiple times within the same
 * microtask, the `_doWork` function will be called only once at the next
 * microtask checkpoint.
 *
 * Note: In testing it is often convenient to avoid asynchrony. To accomplish
 * this with a debouncer, you can use `Polymer.enqueueDebouncer` and
 * `Polymer.flush`. For example, extend the above example by adding
 * `Polymer.enqueueDebouncer(this._debounceJob)` at the end of the
 * `_debounceWork` method. Then in a test, call `Polymer.flush` to ensure
 * the debouncer has completed.
 *
 * @param {Debouncer?} debouncer Debouncer object.
 * @param {!AsyncModule} asyncModule Object with Async interface
 * @param {function()} callback Callback to run.
 * @return {!Debouncer} Returns a debouncer object.
 */
  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer) {
      debouncer.cancel();
    } else {
      debouncer = new Debouncer();
    }
    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }
}




/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_mixin_js__ = __webpack_require__(5);


// Common implementation for mixin & behavior
function mutablePropertyChange(inst, property, value, old, mutableData) {
  let isObject;
  if (mutableData) {
    isObject = (typeof value === 'object' && value !== null);
    // Pull `old` for Objects from temp cache, but treat `null` as a primitive
    if (isObject) {
      old = inst.__dataTemp[property];
    }
  }
  // Strict equality check, but return false for NaN===NaN
  let shouldChange = (old !== value && (old === old || value === value));
  // Objects are stored in temporary cache (cleared at end of
  // turn), which is used for dirty-checking
  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }
  return shouldChange;
}

const MutableData = Object(__WEBPACK_IMPORTED_MODULE_0__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_MutableData}
   */
  class MutableData extends superClass {
    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }

  }
  /** @type {boolean} */
  MutableData.prototype.mutableData = false;

  return MutableData;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = MutableData;


const OptionalMutableData = Object(__WEBPACK_IMPORTED_MODULE_0__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @mixinClass
   * @polymer
   * @implements {Polymer_OptionalMutableData}
   */
  class OptionalMutableData extends superClass {

    static get properties() {
      return {
        /**
         * Instance-level flag for configuring the dirty-checking strategy
         * for this element.  When true, Objects and Arrays will skip dirty
         * checking, otherwise strict equality checking will be used.
         */
        mutableData: Boolean
      };
    }

    /**
     * Overrides `Polymer.PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * When `this.mutableData` is true on this instance, this method
     * pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  }

  return OptionalMutableData;

});
/* harmony export (immutable) */ __webpack_exports__["b"] = OptionalMutableData;


// Export for use by legacy behavior
MutableData._mutablePropertyChange = mutablePropertyChange;


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);


/**
 * Chrome uses an older version of DOM Level 3 Keyboard Events
 *
 * Most keys are labeled as text, but some are Unicode codepoints.
 * Values taken from: http://www.w3.org/TR/2007/WD-DOM-Level-3-Events-20071221/keyset.html#KeySet-Set
 */
var KEY_IDENTIFIER = {
  'U+0008': 'backspace',
  'U+0009': 'tab',
  'U+001B': 'esc',
  'U+0020': 'space',
  'U+007F': 'del'
};

/**
 * Special table for KeyboardEvent.keyCode.
 * KeyboardEvent.keyIdentifier is better, and KeyBoardEvent.key is even better
 * than that.
 *
 * Values from: https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent.keyCode#Value_of_keyCode
 */
var KEY_CODE = {
  8: 'backspace',
  9: 'tab',
  13: 'enter',
  27: 'esc',
  33: 'pageup',
  34: 'pagedown',
  35: 'end',
  36: 'home',
  32: 'space',
  37: 'left',
  38: 'up',
  39: 'right',
  40: 'down',
  46: 'del',
  106: '*'
};

/**
 * MODIFIER_KEYS maps the short name for modifier keys used in a key
 * combo string to the property name that references those same keys
 * in a KeyboardEvent instance.
 */
var MODIFIER_KEYS = {
  'shift': 'shiftKey',
  'ctrl': 'ctrlKey',
  'alt': 'altKey',
  'meta': 'metaKey'
};

/**
 * KeyboardEvent.key is mostly represented by printable character made by
 * the keyboard, with unprintable keys labeled nicely.
 *
 * However, on OS X, Alt+char can make a Unicode character that follows an
 * Apple-specific mapping. In this case, we fall back to .keyCode.
 */
var KEY_CHAR = /[a-z0-9*]/;

/**
 * Matches a keyIdentifier string.
 */
var IDENT_CHAR = /U\+/;

/**
 * Matches arrow keys in Gecko 27.0+
 */
var ARROW_KEY = /^arrow/;

/**
 * Matches space keys everywhere (notably including IE10's exceptional name
 * `spacebar`).
 */
var SPACE_KEY = /^space(bar)?/;

/**
 * Matches ESC key.
 *
 * Value from: http://w3c.github.io/uievents-key/#key-Escape
 */
var ESC_KEY = /^escape$/;

/**
 * Transforms the key.
 * @param {string} key The KeyBoardEvent.key
 * @param {Boolean} [noSpecialChars] Limits the transformation to
 * alpha-numeric characters.
 */
function transformKey(key, noSpecialChars) {
  var validKey = '';
  if (key) {
    var lKey = key.toLowerCase();
    if (lKey === ' ' || SPACE_KEY.test(lKey)) {
      validKey = 'space';
    } else if (ESC_KEY.test(lKey)) {
      validKey = 'esc';
    } else if (lKey.length == 1) {
      if (!noSpecialChars || KEY_CHAR.test(lKey)) {
        validKey = lKey;
      }
    } else if (ARROW_KEY.test(lKey)) {
      validKey = lKey.replace('arrow', '');
    } else if (lKey == 'multiply') {
      // numpad '*' can map to Multiply on IE/Windows
      validKey = '*';
    } else {
      validKey = lKey;
    }
  }
  return validKey;
}

function transformKeyIdentifier(keyIdent) {
  var validKey = '';
  if (keyIdent) {
    if (keyIdent in KEY_IDENTIFIER) {
      validKey = KEY_IDENTIFIER[keyIdent];
    } else if (IDENT_CHAR.test(keyIdent)) {
      keyIdent = parseInt(keyIdent.replace('U+', '0x'), 16);
      validKey = String.fromCharCode(keyIdent).toLowerCase();
    } else {
      validKey = keyIdent.toLowerCase();
    }
  }
  return validKey;
}

function transformKeyCode(keyCode) {
  var validKey = '';
  if (Number(keyCode)) {
    if (keyCode >= 65 && keyCode <= 90) {
      // ascii a-z
      // lowercase is 32 offset from uppercase
      validKey = String.fromCharCode(32 + keyCode);
    } else if (keyCode >= 112 && keyCode <= 123) {
      // function keys f1-f12
      validKey = 'f' + (keyCode - 112 + 1);
    } else if (keyCode >= 48 && keyCode <= 57) {
      // top 0-9 keys
      validKey = String(keyCode - 48);
    } else if (keyCode >= 96 && keyCode <= 105) {
      // num pad 0-9
      validKey = String(keyCode - 96);
    } else {
      validKey = KEY_CODE[keyCode];
    }
  }
  return validKey;
}

/**
  * Calculates the normalized key for a KeyboardEvent.
  * @param {KeyboardEvent} keyEvent
  * @param {Boolean} [noSpecialChars] Set to true to limit keyEvent.key
  * transformation to alpha-numeric chars. This is useful with key
  * combinations like shift + 2, which on FF for MacOS produces
  * keyEvent.key = @
  * To get 2 returned, set noSpecialChars = true
  * To get @ returned, set noSpecialChars = false
 */
function normalizedKeyForEvent(keyEvent, noSpecialChars) {
  // Fall back from .key, to .detail.key for artifical keyboard events,
  // and then to deprecated .keyIdentifier and .keyCode.
  if (keyEvent.key) {
    return transformKey(keyEvent.key, noSpecialChars);
  }
  if (keyEvent.detail && keyEvent.detail.key) {
    return transformKey(keyEvent.detail.key, noSpecialChars);
  }
  return transformKeyIdentifier(keyEvent.keyIdentifier) ||
    transformKeyCode(keyEvent.keyCode) || '';
}

function keyComboMatchesEvent(keyCombo, event) {
  // For combos with modifiers we support only alpha-numeric keys
  var keyEvent = normalizedKeyForEvent(event, keyCombo.hasModifiers);
  return keyEvent === keyCombo.key &&
    (!keyCombo.hasModifiers || (
      !!event.shiftKey === !!keyCombo.shiftKey &&
      !!event.ctrlKey === !!keyCombo.ctrlKey &&
      !!event.altKey === !!keyCombo.altKey &&
      !!event.metaKey === !!keyCombo.metaKey)
    );
}

function parseKeyComboString(keyComboString) {
  if (keyComboString.length === 1) {
    return {
      combo: keyComboString,
      key: keyComboString,
      event: 'keydown'
    };
  }
  return keyComboString.split('+').reduce(function(parsedKeyCombo, keyComboPart) {
    var eventParts = keyComboPart.split(':');
    var keyName = eventParts[0];
    var event = eventParts[1];

    if (keyName in MODIFIER_KEYS) {
      parsedKeyCombo[MODIFIER_KEYS[keyName]] = true;
      parsedKeyCombo.hasModifiers = true;
    } else {
      parsedKeyCombo.key = keyName;
      parsedKeyCombo.event = event || 'keydown';
    }

    return parsedKeyCombo;
  }, {
    combo: keyComboString.split(':').shift()
  });
}

function parseEventString(eventString) {
  return eventString.trim().split(' ').map(function(keyComboString) {
    return parseKeyComboString(keyComboString);
  });
}

const IronA11yKeysBehavior = {
  properties: {
    /**
     * The EventTarget that will be firing relevant KeyboardEvents. Set it to
     * `null` to disable the listeners.
     * @type {?EventTarget}
     */
    keyEventTarget: {
      type: Object,
      value: function() {
        return this;
      }
    },

    /**
     * If true, this property will cause the implementing element to
     * automatically stop propagation on any handled KeyboardEvents.
     */
    stopKeyboardEventPropagation: {
      type: Boolean,
      value: false
    },

    _boundKeyHandlers: {
      type: Array,
      value: function() {
        return [];
      }
    },

    // We use this due to a limitation in IE10 where instances will have
    // own properties of everything on the "prototype".
    _imperativeKeyBindings: {
      type: Object,
      value: function() {
        return {};
      }
    }
  },

  observers: [
    '_resetKeyEventListeners(keyEventTarget, _boundKeyHandlers)'
  ],


  /**
   * To be used to express what combination of keys  will trigger the relative
   * callback. e.g. `keyBindings: { 'esc': '_onEscPressed'}`
   * @type {!Object}
   */
  keyBindings: {},

  registered: function() {
    this._prepKeyBindings();
  },

  attached: function() {
    this._listenKeyEventListeners();
  },

  detached: function() {
    this._unlistenKeyEventListeners();
  },

  /**
   * Can be used to imperatively add a key binding to the implementing
   * element. This is the imperative equivalent of declaring a keybinding
   * in the `keyBindings` prototype property.
   *
   * @param {string} eventString
   * @param {string} handlerName
   */
  addOwnKeyBinding: function(eventString, handlerName) {
    this._imperativeKeyBindings[eventString] = handlerName;
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * When called, will remove all imperatively-added key bindings.
   */
  removeOwnKeyBindings: function() {
    this._imperativeKeyBindings = {};
    this._prepKeyBindings();
    this._resetKeyEventListeners();
  },

  /**
   * Returns true if a keyboard event matches `eventString`.
   *
   * @param {KeyboardEvent} event
   * @param {string} eventString
   * @return {boolean}
   */
  keyboardEventMatchesKeys: function(event, eventString) {
    var keyCombos = parseEventString(eventString);
    for (var i = 0; i < keyCombos.length; ++i) {
      if (keyComboMatchesEvent(keyCombos[i], event)) {
        return true;
      }
    }
    return false;
  },

  _collectKeyBindings: function() {
    var keyBindings = this.behaviors.map(function(behavior) {
      return behavior.keyBindings;
    });

    if (keyBindings.indexOf(this.keyBindings) === -1) {
      keyBindings.push(this.keyBindings);
    }

    return keyBindings;
  },

  _prepKeyBindings: function() {
    this._keyBindings = {};

    this._collectKeyBindings().forEach(function(keyBindings) {
      for (var eventString in keyBindings) {
        this._addKeyBinding(eventString, keyBindings[eventString]);
      }
    }, this);

    for (var eventString in this._imperativeKeyBindings) {
      this._addKeyBinding(eventString, this._imperativeKeyBindings[eventString]);
    }

    // Give precedence to combos with modifiers to be checked first.
    for (var eventName in this._keyBindings) {
      this._keyBindings[eventName].sort(function (kb1, kb2) {
        var b1 = kb1[0].hasModifiers;
        var b2 = kb2[0].hasModifiers;
        return (b1 === b2) ? 0 : b1 ? -1 : 1;
      })
    }
  },

  _addKeyBinding: function(eventString, handlerName) {
    parseEventString(eventString).forEach(function(keyCombo) {
      this._keyBindings[keyCombo.event] =
        this._keyBindings[keyCombo.event] || [];

      this._keyBindings[keyCombo.event].push([
        keyCombo,
        handlerName
      ]);
    }, this);
  },

  _resetKeyEventListeners: function() {
    this._unlistenKeyEventListeners();

    if (this.isAttached) {
      this._listenKeyEventListeners();
    }
  },

  _listenKeyEventListeners: function() {
    if (!this.keyEventTarget) {
      return;
    }
    Object.keys(this._keyBindings).forEach(function(eventName) {
      var keyBindings = this._keyBindings[eventName];
      var boundKeyHandler = this._onKeyBindingEvent.bind(this, keyBindings);

      this._boundKeyHandlers.push([this.keyEventTarget, eventName, boundKeyHandler]);

      this.keyEventTarget.addEventListener(eventName, boundKeyHandler);
    }, this);
  },

  _unlistenKeyEventListeners: function() {
    var keyHandlerTuple;
    var keyEventTarget;
    var eventName;
    var boundKeyHandler;

    while (this._boundKeyHandlers.length) {
      // My kingdom for block-scope binding and destructuring assignment..
      keyHandlerTuple = this._boundKeyHandlers.pop();
      keyEventTarget = keyHandlerTuple[0];
      eventName = keyHandlerTuple[1];
      boundKeyHandler = keyHandlerTuple[2];

      keyEventTarget.removeEventListener(eventName, boundKeyHandler);
    }
  },

  _onKeyBindingEvent: function(keyBindings, event) {
    if (this.stopKeyboardEventPropagation) {
      event.stopPropagation();
    }

    // if event has been already prevented, don't do anything
    if (event.defaultPrevented) {
      return;
    }

    for (var i = 0; i < keyBindings.length; i++) {
      var keyCombo = keyBindings[i][0];
      var handlerName = keyBindings[i][1];
      if (keyComboMatchesEvent(keyCombo, event)) {
        this._triggerKeyHandler(keyCombo, handlerName, event);
        // exit the loop if eventDefault was prevented
        if (event.defaultPrevented) {
          return;
        }
      }
    }
  },

  _triggerKeyHandler: function(keyCombo, handlerName, keyboardEvent) {
    var detail = Object.create(keyCombo);
    detail.keyboardEvent = keyboardEvent;
    var event = new CustomEvent(keyCombo.event, {
      detail: detail,
      cancelable: true
    });
    this[handlerName].call(this, event);
    if (event.defaultPrevented) {
      keyboardEvent.preventDefault();
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronA11yKeysBehavior;



/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      --layout: {
        display: -ms-flexbox;
        display: -webkit-flex;
        display: flex;
      };

      --layout-inline: {
        display: -ms-inline-flexbox;
        display: -webkit-inline-flex;
        display: inline-flex;
      };

      --layout-horizontal: {
        @apply --layout;

        -ms-flex-direction: row;
        -webkit-flex-direction: row;
        flex-direction: row;
      };

      --layout-horizontal-reverse: {
        @apply --layout;

        -ms-flex-direction: row-reverse;
        -webkit-flex-direction: row-reverse;
        flex-direction: row-reverse;
      };

      --layout-vertical: {
        @apply --layout;

        -ms-flex-direction: column;
        -webkit-flex-direction: column;
        flex-direction: column;
      };

      --layout-vertical-reverse: {
        @apply --layout;

        -ms-flex-direction: column-reverse;
        -webkit-flex-direction: column-reverse;
        flex-direction: column-reverse;
      };

      --layout-wrap: {
        -ms-flex-wrap: wrap;
        -webkit-flex-wrap: wrap;
        flex-wrap: wrap;
      };

      --layout-wrap-reverse: {
        -ms-flex-wrap: wrap-reverse;
        -webkit-flex-wrap: wrap-reverse;
        flex-wrap: wrap-reverse;
      };

      --layout-flex-auto: {
        -ms-flex: 1 1 auto;
        -webkit-flex: 1 1 auto;
        flex: 1 1 auto;
      };

      --layout-flex-none: {
        -ms-flex: none;
        -webkit-flex: none;
        flex: none;
      };

      --layout-flex: {
        -ms-flex: 1 1 0.000000001px;
        -webkit-flex: 1;
        flex: 1;
        -webkit-flex-basis: 0.000000001px;
        flex-basis: 0.000000001px;
      };

      --layout-flex-2: {
        -ms-flex: 2;
        -webkit-flex: 2;
        flex: 2;
      };

      --layout-flex-3: {
        -ms-flex: 3;
        -webkit-flex: 3;
        flex: 3;
      };

      --layout-flex-4: {
        -ms-flex: 4;
        -webkit-flex: 4;
        flex: 4;
      };

      --layout-flex-5: {
        -ms-flex: 5;
        -webkit-flex: 5;
        flex: 5;
      };

      --layout-flex-6: {
        -ms-flex: 6;
        -webkit-flex: 6;
        flex: 6;
      };

      --layout-flex-7: {
        -ms-flex: 7;
        -webkit-flex: 7;
        flex: 7;
      };

      --layout-flex-8: {
        -ms-flex: 8;
        -webkit-flex: 8;
        flex: 8;
      };

      --layout-flex-9: {
        -ms-flex: 9;
        -webkit-flex: 9;
        flex: 9;
      };

      --layout-flex-10: {
        -ms-flex: 10;
        -webkit-flex: 10;
        flex: 10;
      };

      --layout-flex-11: {
        -ms-flex: 11;
        -webkit-flex: 11;
        flex: 11;
      };

      --layout-flex-12: {
        -ms-flex: 12;
        -webkit-flex: 12;
        flex: 12;
      };

      /* alignment in cross axis */

      --layout-start: {
        -ms-flex-align: start;
        -webkit-align-items: flex-start;
        align-items: flex-start;
      };

      --layout-center: {
        -ms-flex-align: center;
        -webkit-align-items: center;
        align-items: center;
      };

      --layout-end: {
        -ms-flex-align: end;
        -webkit-align-items: flex-end;
        align-items: flex-end;
      };

      --layout-baseline: {
        -ms-flex-align: baseline;
        -webkit-align-items: baseline;
        align-items: baseline;
      };

      /* alignment in main axis */

      --layout-start-justified: {
        -ms-flex-pack: start;
        -webkit-justify-content: flex-start;
        justify-content: flex-start;
      };

      --layout-center-justified: {
        -ms-flex-pack: center;
        -webkit-justify-content: center;
        justify-content: center;
      };

      --layout-end-justified: {
        -ms-flex-pack: end;
        -webkit-justify-content: flex-end;
        justify-content: flex-end;
      };

      --layout-around-justified: {
        -ms-flex-pack: distribute;
        -webkit-justify-content: space-around;
        justify-content: space-around;
      };

      --layout-justified: {
        -ms-flex-pack: justify;
        -webkit-justify-content: space-between;
        justify-content: space-between;
      };

      --layout-center-center: {
        @apply --layout-center;
        @apply --layout-center-justified;
      };

      /* self alignment */

      --layout-self-start: {
        -ms-align-self: flex-start;
        -webkit-align-self: flex-start;
        align-self: flex-start;
      };

      --layout-self-center: {
        -ms-align-self: center;
        -webkit-align-self: center;
        align-self: center;
      };

      --layout-self-end: {
        -ms-align-self: flex-end;
        -webkit-align-self: flex-end;
        align-self: flex-end;
      };

      --layout-self-stretch: {
        -ms-align-self: stretch;
        -webkit-align-self: stretch;
        align-self: stretch;
      };

      --layout-self-baseline: {
        -ms-align-self: baseline;
        -webkit-align-self: baseline;
        align-self: baseline;
      };

      /* multi-line alignment in main axis */

      --layout-start-aligned: {
        -ms-flex-line-pack: start;  /* IE10 */
        -ms-align-content: flex-start;
        -webkit-align-content: flex-start;
        align-content: flex-start;
      };

      --layout-end-aligned: {
        -ms-flex-line-pack: end;  /* IE10 */
        -ms-align-content: flex-end;
        -webkit-align-content: flex-end;
        align-content: flex-end;
      };

      --layout-center-aligned: {
        -ms-flex-line-pack: center;  /* IE10 */
        -ms-align-content: center;
        -webkit-align-content: center;
        align-content: center;
      };

      --layout-between-aligned: {
        -ms-flex-line-pack: justify;  /* IE10 */
        -ms-align-content: space-between;
        -webkit-align-content: space-between;
        align-content: space-between;
      };

      --layout-around-aligned: {
        -ms-flex-line-pack: distribute;  /* IE10 */
        -ms-align-content: space-around;
        -webkit-align-content: space-around;
        align-content: space-around;
      };

      /*******************************
                Other Layout
      *******************************/

      --layout-block: {
        display: block;
      };

      --layout-invisible: {
        visibility: hidden !important;
      };

      --layout-relative: {
        position: relative;
      };

      --layout-fit: {
        position: absolute;
        top: 0;
        right: 0;
        bottom: 0;
        left: 0;
      };

      --layout-scroll: {
        -webkit-overflow-scrolling: touch;
        overflow: auto;
      };

      --layout-fullbleed: {
        margin: 0;
        height: 100vh;
      };

      /* fixed position */

      --layout-fixed-top: {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
      };

      --layout-fixed-right: {
        position: fixed;
        top: 0;
        right: 0;
        bottom: 0;
      };

      --layout-fixed-bottom: {
        position: fixed;
        right: 0;
        bottom: 0;
        left: 0;
      };

      --layout-fixed-left: {
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
      };

    }
  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__font_roboto_roboto_js__ = __webpack_require__(82);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__font_roboto_roboto_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__font_roboto_roboto_js__);


const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      /* Shared Styles */
      --paper-font-common-base: {
        font-family: 'Roboto', 'Noto', sans-serif;
        -webkit-font-smoothing: antialiased;
      };

      --paper-font-common-code: {
        font-family: 'Roboto Mono', 'Consolas', 'Menlo', monospace;
        -webkit-font-smoothing: antialiased;
      };

      --paper-font-common-expensive-kerning: {
        text-rendering: optimizeLegibility;
      };

      --paper-font-common-nowrap: {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      };

      /* Material Font Styles */

      --paper-font-display4: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 112px;
        font-weight: 300;
        letter-spacing: -.044em;
        line-height: 120px;
      };

      --paper-font-display3: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 56px;
        font-weight: 400;
        letter-spacing: -.026em;
        line-height: 60px;
      };

      --paper-font-display2: {
        @apply --paper-font-common-base;

        font-size: 45px;
        font-weight: 400;
        letter-spacing: -.018em;
        line-height: 48px;
      };

      --paper-font-display1: {
        @apply --paper-font-common-base;

        font-size: 34px;
        font-weight: 400;
        letter-spacing: -.01em;
        line-height: 40px;
      };

      --paper-font-headline: {
        @apply --paper-font-common-base;

        font-size: 24px;
        font-weight: 400;
        letter-spacing: -.012em;
        line-height: 32px;
      };

      --paper-font-title: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 20px;
        font-weight: 500;
        line-height: 28px;
      };

      --paper-font-subhead: {
        @apply --paper-font-common-base;

        font-size: 16px;
        font-weight: 400;
        line-height: 24px;
      };

      --paper-font-body2: {
        @apply --paper-font-common-base;

        font-size: 14px;
        font-weight: 500;
        line-height: 24px;
      };

      --paper-font-body1: {
        @apply --paper-font-common-base;

        font-size: 14px;
        font-weight: 400;
        line-height: 20px;
      };

      --paper-font-caption: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 12px;
        font-weight: 400;
        letter-spacing: 0.011em;
        line-height: 20px;
      };

      --paper-font-menu: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 13px;
        font-weight: 500;
        line-height: 24px;
      };

      --paper-font-button: {
        @apply --paper-font-common-base;
        @apply --paper-font-common-nowrap;

        font-size: 14px;
        font-weight: 500;
        letter-spacing: 0.018em;
        line-height: 24px;
        text-transform: uppercase;
      };

      --paper-font-code2: {
        @apply --paper-font-common-code;

        font-size: 14px;
        font-weight: 700;
        line-height: 20px;
      };

      --paper-font-code1: {
        @apply --paper-font-common-code;

        font-size: 14px;
        font-weight: 500;
        line-height: 20px;
      };

    }

  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




const IronControlState = {

  properties: {

    /**
     * If true, the element currently has focus.
     */
    focused: {
      type: Boolean,
      value: false,
      notify: true,
      readOnly: true,
      reflectToAttribute: true
    },

    /**
     * If true, the user cannot interact with this element.
     */
    disabled: {
      type: Boolean,
      value: false,
      notify: true,
      observer: '_disabledChanged',
      reflectToAttribute: true
    },

    _oldTabIndex: {
      type: Number
    },

    _boundFocusBlurHandler: {
      type: Function,
      value: function() {
        return this._focusBlurHandler.bind(this);
      }
    },

    __handleEventRetargeting: {
      type: Boolean,
      value: function() {
        return !this.shadowRoot && !__WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */];
      }
    }
  },

  observers: [
    '_changedControlState(focused, disabled)'
  ],

  ready: function() {
    this.addEventListener('focus', this._boundFocusBlurHandler, true);
    this.addEventListener('blur', this._boundFocusBlurHandler, true);
  },

  _focusBlurHandler: function(event) {
    // In Polymer 2.0, the library takes care of retargeting events.
    if (__WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */]) {
      this._setFocused(event.type === 'focus');
      return;
    }

    // NOTE(cdata):  if we are in ShadowDOM land, `event.target` will
    // eventually become `this` due to retargeting; if we are not in
    // ShadowDOM land, `event.target` will eventually become `this` due
    // to the second conditional which fires a synthetic event (that is also
    // handled). In either case, we can disregard `event.path`.
    if (event.target === this) {
      this._setFocused(event.type === 'focus');
    } else if (this.__handleEventRetargeting) {
      var target = /** @type {Node} */(Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).localTarget);
      if (!this.isLightDescendant(target)) {
        this.fire(event.type, {sourceEvent: event}, {
          node: this,
          bubbles: event.bubbles,
          cancelable: event.cancelable
        });
      }
    }
  },

  _disabledChanged: function(disabled, old) {
    this.setAttribute('aria-disabled', disabled ? 'true' : 'false');
    this.style.pointerEvents = disabled ? 'none' : '';
    if (disabled) {
      this._oldTabIndex = this.tabIndex;
      this._setFocused(false);
      this.tabIndex = -1;
      this.blur();
    } else if (this._oldTabIndex !== undefined) {
      this.tabIndex = this._oldTabIndex;
    }
  },

  _changedControlState: function() {
    // _controlStateChanged is abstract, follow-on behaviors may implement it
    if (this._controlStateChanged) {
      this._controlStateChanged();
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronControlState;



/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_ripple_paper_ripple_js__ = __webpack_require__(85);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_button_state_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





const PaperRippleBehavior = {
  properties: {
    /**
     * If true, the element will not produce a ripple effect when interacted
     * with via the pointer.
     */
    noink: {
      type: Boolean,
      observer: '_noinkChanged'
    },

    /**
     * @type {Element|undefined}
     */
    _rippleContainer: {
      type: Object,
    }
  },

  /**
   * Ensures a `<paper-ripple>` element is available when the element is
   * focused.
   */
  _buttonStateChanged: function() {
    if (this.focused) {
      this.ensureRipple();
    }
  },

  /**
   * In addition to the functionality provided in `IronButtonState`, ensures
   * a ripple effect is created when the element is in a `pressed` state.
   */
  _downHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_button_state_js__["b" /* IronButtonStateImpl */]._downHandler.call(this, event);
    if (this.pressed) {
      this.ensureRipple(event);
    }
  },

  /**
   * Ensures this element contains a ripple effect. For startup efficiency
   * the ripple effect is dynamically on demand when needed.
   * @param {!Event=} optTriggeringEvent (optional) event that triggered the
   * ripple.
   */
  ensureRipple: function(optTriggeringEvent) {
    if (!this.hasRipple()) {
      this._ripple = this._createRipple();
      this._ripple.noink = this.noink;
      var rippleContainer = this._rippleContainer || this.root;
      if (rippleContainer) {
        Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(rippleContainer).appendChild(this._ripple);
      }
      if (optTriggeringEvent) {
        // Check if the event happened inside of the ripple container
        // Fall back to host instead of the root because distributed text
        // nodes are not valid event targets
        var domContainer = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this._rippleContainer || this);
        var target = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(optTriggeringEvent).rootTarget;
        if (domContainer.deepContains( /** @type {Node} */(target))) {
          this._ripple.uiDownAction(optTriggeringEvent);
        }
      }
    }
  },

  /**
   * Returns the `<paper-ripple>` element used by this element to create
   * ripple effects. The element's ripple is created on demand, when
   * necessary, and calling this method will force the
   * ripple to be created.
   */
  getRipple: function() {
    this.ensureRipple();
    return this._ripple;
  },

  /**
   * Returns true if this element currently contains a ripple effect.
   * @return {boolean}
   */
  hasRipple: function() {
    return Boolean(this._ripple);
  },

  /**
   * Create the element's ripple effect via creating a `<paper-ripple>`.
   * Override this method to customize the ripple element.
   * @return {!PaperRippleElement} Returns a `<paper-ripple>` element.
   */
  _createRipple: function() {
    return /** @type {!PaperRippleElement} */ (
        document.createElement('paper-ripple'));
  },

  _noinkChanged: function(noink) {
    if (this.hasRipple()) {
      this._ripple.noink = noink;
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperRippleBehavior;



/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export instanceCount */
/* unused harmony export _regLog */
/* unused harmony export register */
/* unused harmony export dumpRegistrations */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_mixin_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__ = __webpack_require__(33);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__property_effects_js__ = __webpack_require__(22);










const ElementMixin = Object(__WEBPACK_IMPORTED_MODULE_2__utils_mixin_js__["a" /* dedupingMixin */])(base => {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_PropertyEffects}
   */
  const polymerElementBase = Object(__WEBPACK_IMPORTED_MODULE_7__property_effects_js__["a" /* PropertyEffects */])(base);

  let caseMap = __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__;

  /**
   * Returns the `properties` object specifically on `klass`. Use for:
   * (1) super chain mixes togther to make `propertiesForClass` which is
   * then used to make `observedAttributes`.
   * (2) properties effects and observers are created from it at `finalize` time.
   *
   * @param {HTMLElement} klass Element class
   * @return {Object} Object containing own properties for this class
   * @private
   */
  function ownPropertiesForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__ownProperties', klass))) {
      klass.__ownProperties =
        klass.hasOwnProperty(JSCompiler_renameProperty('properties', klass)) ?
        /** @type PolymerElementConstructor */ (klass).properties : {};
    }
    return klass.__ownProperties;
  }

  /**
   * Returns the `observers` array specifically on `klass`. Use for
   * setting up observers.
   *
   * @param {HTMLElement} klass Element class
   * @return {Array} Array containing own observers for this class
   * @private
   */
  function ownObserversForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__ownObservers', klass))) {
      klass.__ownObservers =
        klass.hasOwnProperty(JSCompiler_renameProperty('observers', klass)) ?
        /** @type PolymerElementConstructor */ (klass).observers : [];
    }
    return klass.__ownObservers;
  }

  /**
   * Mixes `props` into `flattenedProps` but upgrades shorthand type
   * syntax to { type: Type}.
   *
   * @param {Object} flattenedProps Bag to collect flattened properties into
   * @param {Object} props Bag of properties to add to `flattenedProps`
   * @return {Object} The input `flattenedProps` bag
   * @private
   */
  function flattenProperties(flattenedProps, props) {
    for (let p in props) {
      let o = props[p];
      if (typeof o == 'function') {
        o = { type: o };
      }
      flattenedProps[p] = o;
    }
    return flattenedProps;
  }

  /**
   * Returns a flattened list of properties mixed together from the chain of all
   * constructor's `config.properties`. This list is used to create
   * (1) observedAttributes,
   * (2) class property default values
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   * @suppress {missingProperties} class.prototype is not a property for some reason?
   * @private
   */
  function propertiesForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__classProperties', klass))) {
      klass.__classProperties =
      flattenProperties({}, ownPropertiesForClass(klass));
      let superCtor = Object.getPrototypeOf(klass.prototype).constructor;
      if (superCtor.prototype instanceof PolymerElement) {
        klass.__classProperties = Object.assign(
          Object.create(propertiesForClass(/** @type PolymerElementConstructor */(superCtor))),
          klass.__classProperties);
      }
    }
    return klass.__classProperties;
  }

  /**
   * Returns a list of properties with default values.
   * This list is created as an optimization since it is a subset of
   * the list returned from `propertiesForClass`.
   * This list is used in `_initializeProperties` to set property defaults.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @return {PolymerElementProperties} Flattened properties for this class
   *   that have default values
   * @private
   */
  function propertyDefaultsForClass(klass) {
    if (!klass.hasOwnProperty(
      JSCompiler_renameProperty('__classPropertyDefaults', klass))) {
      klass.__classPropertyDefaults = null;
      let props = propertiesForClass(klass);
      for (let p in props) {
        let info = props[p];
        if ('value' in info) {
          klass.__classPropertyDefaults = klass.__classPropertyDefaults || {};
          klass.__classPropertyDefaults[p] = info;
        }
      }
    }
    return klass.__classPropertyDefaults;
  }

  /**
   * Returns true if a `klass` has finalized. Called in `ElementClass.finalize()`
   * @param {PolymerElementConstructor} klass Element class
   * @return {boolean} True if all metaprogramming for this class has been
   *   completed
   * @private
   */
  function hasClassFinalized(klass) {
    return klass.hasOwnProperty(JSCompiler_renameProperty('__finalized', klass));
  }

  /**
   * Called by `ElementClass.finalize()`. Ensures this `klass` and
   * *all superclasses* are finalized by traversing the prototype chain
   * and calling `klass.finalize()`.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClassAndSuper(klass) {
    let proto = /** @type PolymerElementConstructor */ (klass).prototype;
    let superCtor = Object.getPrototypeOf(proto).constructor;
    if (superCtor.prototype instanceof PolymerElement) {
      superCtor.finalize();
    }
    finalizeClass(klass);
  }

  /**
   * Configures a `klass` based on a staic `klass.config` object and
   * a `template`. This includes creating accessors and effects
   * for properties in `config` and the `template` as well as preparing the
   * `template` for stamping.
   *
   * @param {PolymerElementConstructor} klass Element class
   * @private
   */
  function finalizeClass(klass) {
    klass.__finalized = true;
    let proto = /** @type PolymerElementConstructor */ (klass).prototype;
    if (klass.hasOwnProperty(
      JSCompiler_renameProperty('is', klass)) && klass.is) {
      register(proto);
    }
    let props = ownPropertiesForClass(klass);
    if (props) {
      finalizeProperties(proto, props);
    }
    let observers = ownObserversForClass(klass);
    if (observers) {
      finalizeObservers(proto, observers, props);
    }
    // note: create "working" template that is finalized at instance time
    let template = /** @type PolymerElementConstructor */ (klass).template;
    if (template) {
      if (typeof template === 'string') {
        let t = document.createElement('template');
        t.innerHTML = template;
        template = t;
      } else {
        template = template.cloneNode(true);
      }
      proto._template = template;
    }
  }

  /**
   * Configures a `proto` based on a `properties` object.
   * Leverages `PropertyEffects` to create property accessors and effects
   * supporting, observers, reflecting to attributes, change notification,
   * computed properties, and read only properties.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *    and effects to
   * @param {Object} properties Flattened bag of property descriptors for
   *    this class
   * @private
   */
  function finalizeProperties(proto, properties) {
    for (let p in properties) {
      createPropertyFromConfig(proto, p, properties[p], properties);
    }
  }

  /**
   * Configures a `proto` based on a `observers` array.
   * Leverages `PropertyEffects` to create observers.
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {Object} observers Flattened array of observer descriptors for
   *   this class
   * @param {Object} dynamicFns Object containing keys for any properties
   *   that are functions and should trigger the effect when the function
   *   reference is changed
   * @private
   */
  function finalizeObservers(proto, observers, dynamicFns) {
    for (let i=0; i < observers.length; i++) {
      proto._createMethodObserver(observers[i], dynamicFns);
    }
  }

  /**
   * Creates effects for a property.
   *
   * Note, once a property has been set to
   * `readOnly`, `computed`, `reflectToAttribute`, or `notify`
   * these values may not be changed. For example, a subclass cannot
   * alter these settings. However, additional `observers` may be added
   * by subclasses.
   *
   * The info object should may contain property metadata as follows:
   *
   * * `type`: {function} type to which an attribute matching the property
   * is deserialized. Note the property is camel-cased from a dash-cased
   * attribute. For example, 'foo-bar' attribute is dersialized to a
   * property named 'fooBar'.
   *
   * * `readOnly`: {boolean} creates a readOnly property and
   * makes a private setter for the private of the form '_setFoo' for a
   * property 'foo',
   *
   * * `computed`: {string} creates a computed property. A computed property
   * also automatically is set to `readOnly: true`. The value is calculated
   * by running a method and arguments parsed from the given string. For
   * example 'compute(foo)' will compute a given property when the
   * 'foo' property changes by executing the 'compute' method. This method
   * must return the computed value.
   *
   * * `reflectToAttriute`: {boolean} If true, the property value is reflected
   * to an attribute of the same name. Note, the attribute is dash-cased
   * so a property named 'fooBar' is reflected as 'foo-bar'.
   *
   * * `notify`: {boolean} sends a non-bubbling notification event when
   * the property changes. For example, a property named 'foo' sends an
   * event named 'foo-changed' with `event.detail` set to the value of
   * the property.
   *
   * * observer: {string} name of a method that runs when the property
   * changes. The arguments of the method are (value, previousValue).
   *
   * Note: Users may want control over modifying property
   * effects via subclassing. For example, a user might want to make a
   * reflectToAttribute property not do so in a subclass. We've chosen to
   * disable this because it leads to additional complication.
   * For example, a readOnly effect generates a special setter. If a subclass
   * disables the effect, the setter would fail unexpectedly.
   * Based on feedback, we may want to try to make effects more malleable
   * and/or provide an advanced api for manipulating them.
   * Also consider adding warnings when an effect cannot be changed.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {string} name Name of the property.
   * @param {Object} info Info object from which to create property effects.
   * Supported keys:
   * @param {Object} allProps Flattened map of all properties defined in this
   *   element (including inherited properties)
   * @private
   */
  function createPropertyFromConfig(proto, name, info, allProps) {
    // computed forces readOnly...
    if (info.computed) {
      info.readOnly = true;
    }
    // Note, since all computed properties are readOnly, this prevents
    // adding additional computed property effects (which leads to a confusing
    // setup where multiple triggers for setting a property)
    // While we do have `hasComputedEffect` this is set on the property's
    // dependencies rather than itself.
    if (info.computed  && !proto._hasReadOnlyEffect(name)) {
      proto._createComputedProperty(name, info.computed, allProps);
    }
    if (info.readOnly && !proto._hasReadOnlyEffect(name)) {
      proto._createReadOnlyProperty(name, !info.computed);
    }
    if (info.reflectToAttribute && !proto._hasReflectEffect(name)) {
      proto._createReflectedProperty(name);
    }
    if (info.notify && !proto._hasNotifyEffect(name)) {
      proto._createNotifyingProperty(name);
    }
    // always add observer
    if (info.observer) {
      proto._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
  }

  /**
   * Configures an element `proto` to function with a given `template`.
   * The element name `is` and extends `ext` must be specified for ShadyCSS
   * style scoping.
   *
   * @param {PolymerElement} proto Element class prototype to add accessors
   *   and effects to
   * @param {!HTMLTemplateElement} template Template to process and bind
   * @param {string} baseURI URL against which to resolve urls in
   *   style element cssText
   * @param {string} is Tag name (or type extension name) for this element
   * @param {string=} ext For type extensions, the tag name that was extended
   * @private
   */
  function finalizeTemplate(proto, template, baseURI, is, ext) {
    // support `include="module-name"`
    let cssText =
      Object(__WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__["a" /* cssFromModuleImports */])(is) +
      Object(__WEBPACK_IMPORTED_MODULE_4__utils_style_gather_js__["c" /* cssFromTemplate */])(template, baseURI);
    if (cssText) {
      let style = document.createElement('style');
      style.textContent = cssText;
      template.content.insertBefore(style, template.content.firstChild);
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template, is, ext);
    }
    proto._bindTemplate(template);
  }

  /**
   * @polymer
   * @mixinClass
   * @unrestricted
   * @implements {Polymer_ElementMixin}
   */
  class PolymerElement extends polymerElementBase {

    /**
     * Standard Custom Elements V1 API.  The default implementation returns
     * a list of dash-cased attributes based on a flattening of all properties
     * declared in `static get properties()` for this element and any
     * superclasses.
     *
     * @return {Array} Observed attribute list
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('__observedAttributes', this))) {
        let list = [];
        let properties = propertiesForClass(this);
        for (let prop in properties) {
          list.push(Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["camelToDashCase"])(prop));
        }
        this.__observedAttributes = list;
      }
      return this.__observedAttributes;
    }

    /**
     * Called automatically when the first element instance is created to
     * ensure that class finalization work has been completed.
     * May be called by users to eagerly perform class finalization work
     * prior to the creation of the first element instance.
     *
     * Class finalization work generally includes meta-programming such as
     * creating property accessors and any property effect metadata needed for
     * the features used.
     *
     * @public
     */
    static finalize() {
      if (!hasClassFinalized(this)) {
        finalizeClassAndSuper(this);
      }
    }

    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation
     * will return the first `<template>` in a `dom-module` whose `id`
     * matches this element's `is`.
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * may be either an `HTMLTemplateElement` or a string that will be
     * automatically parsed into a template.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `Polymer.DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {HTMLTemplateElement|string} Template to be stamped
     */
    static get template() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_template', this))) {
        this._template = __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */].import(
          /** @type PolymerElementConstructor*/ (this).is, 'template') ||
          // note: implemented so a subclass can retrieve the super
          // template; call the super impl this way so that `this` points
          // to the superclass.
          Object.getPrototypeOf(/** @type PolymerElementConstructor*/ (this).prototype).constructor.template;
      }
      return this._template;
    }

    /**
     * Path matching the url from which the element was imported.
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     * Defaults to the path matching the url containing a `dom-module` element
     * matching this element's static `is` property.
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     */
    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty('_importPath', this))) {
          const module = __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_6__elements_dom_module_js__["a" /* DomModule */].import(/** @type PolymerElementConstructor */ (this).is);
          this._importPath = module ? module.assetpath : '' ||
          Object.getPrototypeOf(/** @type PolymerElementConstructor*/ (this).prototype).constructor.importPath;
      }
      return this._importPath;
    }

    constructor() {
      super();
      /** @type {HTMLTemplateElement} */
      this._template;
      /** @type {string} */
      this._importPath;
      /** @type {string} */
      this.rootPath;
      /** @type {string} */
      this.importPath;
      /** @type {StampedTemplate | HTMLElement | ShadowRoot} */
      this.root;
      /** @type {!Object<string, !Node>} */
      this.$;
    }

    /**
     * Overrides the default `Polymer.PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @override
     * @suppress {invalidCasts}
     */
    _initializeProperties() {
      instanceCount++;
      this.constructor.finalize();
      const importPath = this.constructor.importPath;
      // note: finalize template when we have access to `localName` to
      // avoid dependence on `is` for polyfilling styling.
      if (this._template && !this._template.__polymerFinalized) {
        this._template.__polymerFinalized = true;
        const baseURI =
          importPath ? Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(importPath) : '';
        finalizeTemplate(/** @type {!PolymerElement} */(this.__proto__), this._template, baseURI,
          /**@type {!HTMLElement}*/(this).localName);
      }
      super._initializeProperties();
      // set path defaults
      this.rootPath = __WEBPACK_IMPORTED_MODULE_1__utils_settings_js__["b" /* rootPath */];
      this.importPath = importPath;
      // apply property defaults...
      let p$ = propertyDefaultsForClass(this.constructor);
      if (!p$) {
        return;
      }
      for (let p in p$) {
        let info = p$[p];
        // Don't set default value if there is already an own property, which
        // happens when a `properties` property with default but no effects had
        // a property set (e.g. bound) by its host before upgrade
        if (!this.hasOwnProperty(p)) {
          let value = typeof info.value == 'function' ?
            info.value.call(this) :
            info.value;
          // Set via `_setProperty` if there is an accessor, to enable
          // initializing readOnly property defaults
          if (this._hasAccessor(p)) {
            this._setPendingProperty(p, value, true);
          } else {
            this[p] = value;
          }
        }
      }
    }

    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @suppress {invalidCasts}
     */
    connectedCallback() {
      if (window.ShadyCSS && this._template) {
        window.ShadyCSS.styleElement(/** @type {!HTMLElement} */(this));
      }
      this._enableProperties();
    }

    /**
     * Provides a default implementation of the standard Custom Elements
     * `disconnectedCallback`.
     */
    disconnectedCallback() {}

    /**
     * Stamps the element template.
     *
     * @override
     */
    ready() {
      if (this._template) {
        this.root = this._stampTemplate(this._template);
        this.$ = this.root.$;
      }
      super.ready();
    }

    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @override
     */
    _readyClients() {
      if (this._template) {
        this.root = this._attachDom(/** @type {StampedTemplate} */(this.root));
      }
      // The super._readyClients here sets the clients initialized flag.
      // We must wait to do this until after client dom is created/attached
      // so that this flag can be checked to prevent notifications fired
      // during this process from being handled before clients are ready.
      super._readyClients();
    }


    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */
    _attachDom(dom) {
      if (this.attachShadow) {
        if (dom) {
          if (!this.shadowRoot) {
            this.attachShadow({mode: 'open'});
          }
          this.shadowRoot.appendChild(dom);
          return this.shadowRoot;
        }
        return null;
      } else {
        throw new Error('ShadowDOM not available. ' +
          // TODO(sorvell): move to compile-time conditional when supported
        'Polymer.Element can create dom as children instead of in ' +
        'ShadowDOM by setting `this.root = this;\` before \`ready\`.');
      }
    }

    /**
     * Provides a default implementation of the standard Custom Elements
     * `attributeChangedCallback`.
     *
     * By default, attributes declared in `properties` metadata are
     * deserialized using their `type` information to properties of the
     * same name.  "Dash-cased" attributes are deserialzed to "camelCase"
     * properties.
     *
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @override
     */
    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        let property = caseMap.dashToCamelCase(name);
        let type = propertiesForClass(this.constructor)[property].type;
        if (!this._hasReadOnlyEffect(property)) {
          this._attributeToProperty(name, value, type);
        }
      }
    }

    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @suppress {invalidCasts}
     */
    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree(/** @type {!HTMLElement} */(this), properties);
      }
    }

    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */
    resolveUrl(url, base) {
      if (!base && this.importPath) {
        base = Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(this.importPath);
      }
      return Object(__WEBPACK_IMPORTED_MODULE_5__utils_resolve_url_js__["c" /* resolveUrl */])(url, base);
    }

    /**
     * Overrides `PropertyAccessors` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @override
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      templateInfo.dynamicFns = templateInfo.dynamicFns || propertiesForClass(this);
      return super._parseTemplateContent(template, templateInfo, nodeInfo);
    }

  }

  return PolymerElement;
});
/* harmony export (immutable) */ __webpack_exports__["a"] = ElementMixin;


let instanceCount = 0;
const registrations = [];
/* unused harmony export registrations */


function _regLog(prototype) {
  console.log('[' + prototype.is + ']: registered');
}

function register(prototype) {
  registrations.push(prototype);
  undefined && _regLog(prototype);
}

function dumpRegistrations() {
  registrations.forEach(_regLog);
}

const updateStyles = function(props) {
  if (window.ShadyCSS) {
    window.ShadyCSS.styleDocument(props);
  }
};
/* unused harmony export updateStyles */



/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return DomModule; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__ = __webpack_require__(10);



let modules = {};
let lcModules = {};
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}

function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector('style')) {
    console.warn('dom-module %s has style outside template', inst.id);
  }
}

/**
 * The `dom-module` element registers the dom it contains to the name given
 * by the module's id attribute. It provides a unified database of dom
 * accessible via its static `import` API.
 *
 * A key use case of `dom-module` is for providing custom element `<template>`s
 * via HTML imports that are parsed by the native HTML parser, that can be
 * relocated during a bundling pass and still looked up by `id`.
 *
 * Example:
 *
 *     <dom-module id="foo">
 *       <img src="stuff.png">
 *     </dom-module>
 *
 * Then in code in some other location that cannot access the dom-module above
 *
 *     let img = customElements.get('dom-module').import('foo', 'img');
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element that provides a registry of relocatable DOM content
 *   by `id` that is agnostic to bundling.
 * @unrestricted
 */
class DomModule extends HTMLElement {

  static get observedAttributes() { return ['id']; }

  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   */
  static import(id, selector) {
    if (id) {
      let m = findModule(id);
      if (m && selector) {
        return m.querySelector(selector);
      }
      return m;
    }
    return null;
  }

  attributeChangedCallback(name, old, value) {
    if (old !== value) {
      this.register();
    }
  }

  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */
  get assetpath() {
    // Don't override existing assetpath.
    if (!this.__assetpath) {
      // note: assetpath set via an attribute must be relative to this
      // element's location; accomodate polyfilled HTMLImports
      const owner = window.HTMLImports && HTMLImports.importForElement ?
        HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = Object(__WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__["c" /* resolveUrl */])(
        this.getAttribute('assetpath') || '', owner.baseURI);
      this.__assetpath = Object(__WEBPACK_IMPORTED_MODULE_1__utils_resolve_url_js__["a" /* pathFromUrl */])(url);
    }
    return this.__assetpath;
  }

  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   */
  register(id) {
    id = id || this.id;
    if (id) {
      this.id = id;
      // store id separate from lowercased id so that
      // in all cases mixedCase id will stored distinctly
      // and lowercase version is a fallback
      modules[id] = this;
      lcModules[id.toLowerCase()] = this;
      styleOutsideTemplateCheck(this);
    }
  }
}

DomModule.prototype['modules'] = modules;

customElements.define('dom-module', DomModule);




/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_path_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__property_accessors_js__ = __webpack_require__(53);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__template_stamp_js__ = __webpack_require__(54);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_settings_js__ = __webpack_require__(9);









/** @const {Object} */
const CaseMap = __WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__;

// Monotonically increasing unique ID used for de-duping effects triggered
// from multiple properties in the same turn
let dedupeId = 0;

/**
 * Property effect types; effects are stored on the prototype using these keys
 * @enum {string}
 */
const TYPES = {
  COMPUTE: '__computeEffects',
  REFLECT: '__reflectEffects',
  NOTIFY: '__notifyEffects',
  PROPAGATE: '__propagateEffects',
  OBSERVE: '__observeEffects',
  READ_ONLY: '__readOnly'
};

/**
 * @typedef {{
 * name: (string | undefined),
 * structured: (boolean | undefined),
 * wildcard: (boolean | undefined)
 * }}
 */
let DataTrigger; //eslint-disable-line no-unused-vars

/**
 * @typedef {{
 * info: ?,
 * trigger: (!DataTrigger | undefined),
 * fn: (!Function | undefined)
 * }}
 */
let DataEffect; //eslint-disable-line no-unused-vars

let PropertyEffectsType; //eslint-disable-line no-unused-vars

/**
 * Ensures that the model has an own-property map of effects for the given type.
 * The model may be a prototype or an instance.
 *
 * Property effects are stored as arrays of effects by property in a map,
 * by named type on the model. e.g.
 *
 *   __computeEffects: {
 *     foo: [ ... ],
 *     bar: [ ... ]
 *   }
 *
 * If the model does not yet have an effect map for the type, one is created
 * and returned.  If it does, but it is not an own property (i.e. the
 * prototype had effects), the the map is deeply cloned and the copy is
 * set on the model and returned, ready for new effects to be added.
 *
 * @param {Object} model Prototype or instance
 * @param {string} type Property effect type
 * @return {Object} The own-property map of effects for the given type
 * @private
 */
function ensureOwnEffectMap(model, type) {
  let effects = model[type];
  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);
    for (let p in effects) {
      let protoFx = effects[p];
      let instFx = effects[p] = Array(protoFx.length);
      for (let i=0; i<protoFx.length; i++) {
        instFx[i] = protoFx[i];
      }
    }
  }
  return effects;
}

// -- effects ----------------------------------------------

/**
 * Runs all effects of a given type for the given set of property changes
 * on an instance.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {Object} props Bag of current property changes
 * @param {Object=} oldProps Bag of previous values for changed properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    let ran = false;
    let id = dedupeId++;
    for (let prop in props) {
      if (runEffectsForProperty(inst, effects, id, prop, props, oldProps, hasPaths, extraArgs)) {
        ran = true;
      }
    }
    return ran;
  }
  return false;
}

/**
 * Runs a list of effects for a given property.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} effects Object map of property-to-Array of effects
 * @param {number} dedupeId Counter used for de-duping effects
 * @param {string} prop Name of changed property
 * @param {*} props Changed properties
 * @param {*} oldProps Old properties
 * @param {boolean=} hasPaths True with `props` contains one or more paths
 * @param {*=} extraArgs Additional metadata to pass to effect function
 * @return {boolean} True if an effect ran for this property
 * @private
 */
function runEffectsForProperty(inst, effects, dedupeId, prop, props, oldProps, hasPaths, extraArgs) {
  let ran = false;
  let rootProperty = hasPaths ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(prop) : prop;
  let fxs = effects[rootProperty];
  if (fxs) {
    for (let i=0, l=fxs.length, fx; (i<l) && (fx=fxs[i]); i++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId) &&
          (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId;
        }
        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }
  return ran;
}

/**
 * Determines whether a property/path that has changed matches the trigger
 * criteria for an effect.  A trigger is a descriptor with the following
 * structure, which matches the descriptors returned from `parseArg`.
 * e.g. for `foo.bar.*`:
 * ```
 * trigger: {
 *   name: 'a.b',
 *   structured: true,
 *   wildcard: true
 * }
 * ```
 * If no trigger is given, the path is deemed to match.
 *
 * @param {string} path Path or property that changed
 * @param {DataTrigger} trigger Descriptor
 * @return {boolean} Whether the path matched the trigger
 */
function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    let triggerPath = trigger.name;
    return (triggerPath == path) ||
      (trigger.structured && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["b" /* isAncestor */])(triggerPath, path)) ||
      (trigger.wildcard && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(triggerPath, path));
  } else {
    return true;
  }
}

/**
 * Implements the "observer" effect.
 *
 * Calls the method with `info.methodName` on the instance, passing the
 * new and old values.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runObserverEffect(inst, property, props, oldProps, info) {
  let fn = inst[info.methodName];
  let changedProp = info.property;
  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn('observer method `' + info.methodName + '` not defined');
  }
}

/**
 * Runs "notify" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * will dispatch path notification events in the case that the property
 * changed was a path and the root property for that path didn't have a
 * "notify" effect.  This is to maintain 1.0 behavior that did not require
 * `notify: true` to ensure object sub-property notifications were
 * sent.
 *
 * @param {!PropertyEffectsType} inst The instance with effects to run
 * @param {Object} notifyProps Bag of properties to notify
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  // Notify
  let fxs = inst[TYPES.NOTIFY];
  let notified;
  let id = dedupeId++;
  // Try normal notify effects; if none, fall back to try path notification
  for (let prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  }
  // Flush host if we actually notified and host was batching
  // And the host has already initialized clients; this prevents
  // an issue with a host observing data changes before clients are ready.
  let host;
  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}

/**
 * Dispatches {property}-changed events with path information in the detail
 * object to indicate a sub-path of the property was changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} path The path that was changed
 * @param {Object} props Bag of current property changes
 * @return {boolean} Returns true if the path was notified
 * @private
 */
function notifyPath(inst, path, props) {
  let rootProperty = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(path);
  if (rootProperty !== path) {
    let eventName = Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["camelToDashCase"])(rootProperty) + '-changed';
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }
  return false;
}

/**
 * Dispatches {property}-changed events to indicate a property (or path)
 * changed.
 *
 * @param {!PropertyEffectsType} inst The element from which to fire the event
 * @param {string} eventName The name of the event to send ('{property}-changed')
 * @param {*} value The value of the changed property
 * @param {string | null | undefined} path If a sub-path of this property changed, the path
 *   that changed (optional).
 * @private
 * @suppress {invalidCasts}
 */
function dispatchNotifyEvent(inst, eventName, value, path) {
  let detail = {
    value: value,
    queueProperty: true
  };
  if (path) {
    detail.path = path;
  }
  /** @type {!HTMLElement} */(inst).dispatchEvent(new CustomEvent(eventName, { detail }));
}

/**
 * Implements the "notify" effect.
 *
 * Dispatches a non-bubbling event named `info.eventName` on the instance
 * with a detail object containing the new `value`.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  let rootProperty = hasPaths ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(property) : property;
  let path = rootProperty != property ? property : null;
  let value = path ? Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, path) : inst.__data[property];
  if (path && value === undefined) {
    value = props[property];  // specifically for .splices
  }
  dispatchNotifyEvent(inst, info.eventName, value, path);
}

/**
 * Handler function for 2-way notification events. Receives context
 * information captured in the `addNotifyListener` closure from the
 * `__notifyListeners` metadata.
 *
 * Sets the value of the notified property to the host property or path.  If
 * the event contained path information, translate that path to the host
 * scope's name for that path first.
 *
 * @param {CustomEvent} event Notification event (e.g. '<property>-changed')
 * @param {!PropertyEffectsType} inst Host element instance handling the notification event
 * @param {string} fromProp Child element property that was bound
 * @param {string} toPath Host property/path that was bound
 * @param {boolean} negate Whether the binding was negated
 * @private
 */
function handleNotification(event, inst, fromProp, toPath, negate) {
  let value;
  let detail = /** @type {Object} */(event.detail);
  let fromPath = detail && detail.path;
  if (fromPath) {
    toPath = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.target[fromProp];
  }
  value = negate ? !value : value;
  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath))
      && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}

/**
 * Implements the "reflect" effect.
 *
 * Sets the attribute named `info.attrName` to the given property value.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runReflectEffect(inst, property, props, oldProps, info) {
  let value = inst.__data[property];
  if (__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */]) {
    value = Object(__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */])(value, info.attrName, 'attribute', /** @type {Node} */(inst));
  }
  inst._propertyToAttribute(property, info.attrName, value);
}

/**
 * Runs "computed" effects for a set of changed properties.
 *
 * This method differs from the generic `runEffects` method in that it
 * continues to run computed effects based on the output of each pass until
 * there are no more newly computed properties.  This ensures that all
 * properties that will be computed by the initial set of changes are
 * computed before other effects (binding propagation, observers, and notify)
 * run.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {!Object} changedProps Bag of changed properties
 * @param {!Object} oldProps Bag of previous values for changed properties
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @private
 */
function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  let computeEffects = inst[TYPES.COMPUTE];
  if (computeEffects) {
    let inputProps = changedProps;
    while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
      Object.assign(oldProps, inst.__dataOld);
      Object.assign(changedProps, inst.__dataPending);
      inputProps = inst.__dataPending;
      inst.__dataPending = null;
    }
  }
}

/**
 * Implements the "computed property" effect by running the method with the
 * values of the arguments specified in the `info` object and setting the
 * return value to the computed property specified.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @private
 */
function runComputedEffect(inst, property, props, oldProps, info) {
  let result = runMethodEffect(inst, property, props, oldProps, info);
  let computedProp = info.methodInfo;
  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
  }
}

/**
 * Computes path changes based on path links set up using the `linkPaths`
 * API.
 *
 * @param {!PropertyEffectsType} inst The instance whose props are changing
 * @param {string | !Array<(string|number)>} path Path that has changed
 * @param {*} value Value of changed path
 * @private
 */
function computeLinkedPaths(inst, path, value) {
  let links = inst.__dataLinkedPaths;
  if (links) {
    let link;
    for (let a in links) {
      let b = links[a];
      if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(a, path)) {
        link = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(a, b, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["c" /* isDescendant */])(b, path)) {
        link = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(b, a, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
}

// -- bindings ----------------------------------------------

/**
 * Adds binding metadata to the current `nodeInfo`, and binding effects
 * for all part dependencies to `templateInfo`.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {NodeInfo} nodeInfo Node metadata for current template node
 * @param {string} kind Binding kind, either 'property', 'attribute', or 'text'
 * @param {string} target Target property name
 * @param {!Array<!BindingPart>} parts Array of binding part metadata
 * @param {string=} literal Literal text surrounding binding parts (specified
 *   only for 'property' bindings, since these must be initialized as part
 *   of boot-up)
 * @private
 */
function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  // Create binding metadata and add to nodeInfo
  nodeInfo.bindings = nodeInfo.bindings || [];
  let /** Binding */ binding = { kind, target, parts, literal, isCompound: (parts.length !== 1) };
  nodeInfo.bindings.push(binding);
  // Add listener info to binding metadata
  if (shouldAddListener(binding)) {
    let {event, negate} = binding.parts[0];
    binding.listenerEvent = event || (CaseMap.camelToDashCase(target) + '-changed');
    binding.listenerNegate = negate;
  }
  // Add "propagate" property effects to templateInfo
  let index = templateInfo.nodeInfoList.length;
  for (let i=0; i<binding.parts.length; i++) {
    let part = binding.parts[i];
    part.compoundIndex = i;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}

/**
 * Adds property effects to the given `templateInfo` for the given binding
 * part.
 *
 * @param {Function} constructor Class that `_parseTemplate` is currently
 *   running on
 * @param {TemplateInfo} templateInfo Template metadata for current template
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {number} index Index into `nodeInfoList` for this node
 */
function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === 'attribute' && binding.target[0] === '-') {
      console.warn('Cannot set attribute ' + binding.target +
        ' because "-" is not a valid attribute starting character');
    } else {
      let dependencies = part.dependencies;
      let info = { index, binding, part, evaluator: constructor };
      for (let j=0; j<dependencies.length; j++) {
        let trigger = dependencies[j];
        if (typeof trigger == 'string') {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }
        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info, trigger
        });
      }
    }
  }
}

/**
 * Implements the "binding" (property/path binding) effect.
 *
 * Note that binding syntax is overridable via `_parseBindings` and
 * `_evaluateBinding`.  This method will call `_evaluateBinding` for any
 * non-literal parts returned from `_parseBindings`.  However,
 * there is no support for _path_ bindings via custom binding parts,
 * as this is specific to Polymer's path binding syntax.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} path Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @param {boolean} hasPaths True with `props` contains one or more paths
 * @param {Array} nodeList List of nodes associated with `nodeInfoList` template
 *   metadata
 * @private
 */
function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  let node = nodeList[info.index];
  let binding = info.binding;
  let part = info.part;
  // Subpath notification: transform path and set to client
  // e.g.: foo="{{obj.sub}}", path: 'obj.sub.prop', set 'foo.prop'=obj.sub.prop
  if (hasPaths && part.source && (path.length > part.source.length) &&
      (binding.kind == 'property') && !binding.isCompound &&
      node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    let value = props[path];
    path = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["i" /* translate */])(part.source, binding.target, path);
    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
    // Propagate value to child
    applyBindingValue(inst, node, binding, part, value);
  }
}

/**
 * Sets the value for an "binding" (binding) effect to a node,
 * either as a property or attribute.
 *
 * @param {!PropertyEffectsType} inst The instance owning the binding effect
 * @param {Node} node Target node for binding
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @param {*} value Value to set
 * @private
 */
function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);
  if (__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */]) {
    value = Object(__WEBPACK_IMPORTED_MODULE_6__utils_settings_js__["c" /* sanitizeDOMValue */])(value, binding.target, binding.kind, node);
  }
  if (binding.kind == 'attribute') {
    // Attribute binding
    inst._valueToNodeAttribute(/** @type {Element} */(node), value, binding.target);
  } else {
    // Property binding
    let prop = binding.target;
    if (node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else  {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}

/**
 * Transforms an "binding" effect value based on compound & negation
 * effect metadata, as well as handling for special-case properties
 *
 * @param {Node} node Node the value will be set to
 * @param {*} value Value to set
 * @param {!Binding} binding Binding metadata
 * @param {!BindingPart} part Binding part metadata
 * @return {*} Transformed value to set
 * @private
 */
function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join('');
  }
  if (binding.kind !== 'attribute') {
    // Some browsers serialize `undefined` to `"undefined"`
    if (binding.target === 'textContent' ||
        (node.localName == 'input' && binding.target == 'value')) {
      value = value == undefined ? '' : value;
    }
  }
  return value;
}

/**
 * Returns true if a binding's metadata meets all the requirements to allow
 * 2-way binding, and therefore a `<property>-changed` event listener should be
 * added:
 * - used curly braces
 * - is a property (not attribute) binding
 * - is not a textContent binding
 * - is not compound
 *
 * @param {!Binding} binding Binding metadata
 * @return {boolean} True if 2-way listener should be added
 * @private
 */
function shouldAddListener(binding) {
  return Boolean(binding.target) &&
         binding.kind != 'attribute' &&
         binding.kind != 'text' &&
         !binding.isCompound &&
         binding.parts[0].mode === '{';
}

/**
 * Setup compound binding storage structures, notify listeners, and dataHost
 * references onto the bound nodeList.
 *
 * @param {!PropertyEffectsType} inst Instance that bas been previously bound
 * @param {TemplateInfo} templateInfo Template metadata
 * @private
 */
function setupBindings(inst, templateInfo) {
  // Setup compound storage, dataHost, and notify listeners
  let {nodeList, nodeInfoList} = templateInfo;
  if (nodeInfoList.length) {
    for (let i=0; i < nodeInfoList.length; i++) {
      let info = nodeInfoList[i];
      let node = nodeList[i];
      let bindings = info.bindings;
      if (bindings) {
        for (let i=0; i<bindings.length; i++) {
          let binding = bindings[i];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }
      node.__dataHost = inst;
    }
  }
}

/**
 * Initializes `__dataCompoundStorage` local storage on a bound node with
 * initial literal data for compound bindings, and sets the joined
 * literal parts to the bound property.
 *
 * When changes to compound parts occur, they are first set into the compound
 * storage array for that property, and then the array is joined to result in
 * the final value set to the property/attribute.
 *
 * @param {Node} node Bound node to initialize
 * @param {Binding} binding Binding metadata
 * @private
 */
function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    // Create compound storage map
    let storage = node.__dataCompoundStorage ||
      (node.__dataCompoundStorage = {});
    let parts = binding.parts;
    // Copy literals from parts into storage for this binding
    let literals = new Array(parts.length);
    for (let j=0; j<parts.length; j++) {
      literals[j] = parts[j].literal;
    }
    let target = binding.target;
    storage[target] = literals;
    // Configure properties with their literal parts
    if (binding.literal && binding.kind == 'property') {
      node[target] = binding.literal;
    }
  }
}

/**
 * Adds a 2-way binding notification event listener to the node specified
 *
 * @param {Object} node Child element to add listener to
 * @param {!PropertyEffectsType} inst Host element instance to handle notification event
 * @param {Binding} binding Binding metadata
 * @private
 */
function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    let part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function(e) {
      handleNotification(e, inst, binding.target, part.source, part.negate);
    });
  }
}

// -- for method-based effects (complexObserver & computed) --------------

/**
 * Adds property effects for each argument in the method signature (and
 * optionally, for the method name if `dynamic` is true) that calls the
 * provided effect function.
 *
 * @param {Element | Object} model Prototype or instance
 * @param {!MethodSignature} sig Method signature metadata
 * @param {string} type Type of property effect to add
 * @param {Function} effectFn Function to run when arguments change
 * @param {*=} methodInfo Effect-specific information to be included in
 *   method effect metadata
 * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
 *   method names should be included as a dependency to the effect. Note,
 *   defaults to true if the signature is static (sig.static is true).
 * @private
 */
function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || (dynamicFn &&
    (typeof dynamicFn !== 'object' || dynamicFn[sig.methodName]));
  let info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo,
    dynamicFn
  };
  for (let i=0, arg; (i<sig.args.length) && (arg=sig.args[i]); i++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn, info: info, trigger: arg
      });
    }
  }
  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn, info: info
    });
  }
}

/**
 * Calls a method with arguments marshaled from properties on the instance
 * based on the method signature contained in the effect metadata.
 *
 * Multi-property observers, computed properties, and inline computing
 * functions call this function to invoke the method, then use the return
 * value accordingly.
 *
 * @param {!PropertyEffectsType} inst The instance the effect will be run on
 * @param {string} property Name of property
 * @param {Object} props Bag of current property changes
 * @param {Object} oldProps Bag of previous values for changed properties
 * @param {?} info Effect metadata
 * @return {*} Returns the return value from the method invocation
 * @private
 */
function runMethodEffect(inst, property, props, oldProps, info) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  let context = inst._methodHost || inst;
  let fn = context[info.methodName];
  if (fn) {
    let args = marshalArgs(inst.__data, info.args, property, props);
    return fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn('method `' + info.methodName + '` not defined');
  }
}

const emptyArray = [];

// Regular expressions used for binding
const IDENT  = '(?:' + '[a-zA-Z_$][\\w.:$\\-*]*' + ')';
const NUMBER = '(?:' + '[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';
const SQUOTE_STRING = '(?:' + '\'(?:[^\'\\\\]|\\\\.)*\'' + ')';
const DQUOTE_STRING = '(?:' + '"(?:[^"\\\\]|\\\\.)*"' + ')';
const STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';
const ARGUMENT = '(?:(' + IDENT + '|' + NUMBER + '|' +  STRING + ')\\s*' + ')';
const ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\s*' + ARGUMENT + ')*' + ')';
const ARGUMENT_LIST = '(?:' + '\\(\\s*' +
                              '(?:' + ARGUMENTS + '?' + ')' +
                            '\\)\\s*' + ')';
const BINDING = '(' + IDENT + '\\s*' + ARGUMENT_LIST + '?' + ')'; // Group 3
const OPEN_BRACKET = '(\\[\\[|{{)' + '\\s*';
const CLOSE_BRACKET = '(?:]]|}})';
const NEGATE = '(?:(!)\\s*)?'; // Group 2
const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");

/**
 * Create a string from binding parts of all the literal parts
 *
 * @param {!Array<BindingPart>} parts All parts to stringify
 * @return {string} String made from the literal parts
 */
function literalFromParts(parts) {
  let s = '';
  for (let i=0; i<parts.length; i++) {
    let literal = parts[i].literal;
    s += literal || '';
  }
  return s;
}

/**
 * Parses an expression string for a method signature, and returns a metadata
 * describing the method in terms of `methodName`, `static` (whether all the
 * arguments are literals), and an array of `args`
 *
 * @param {string} expression The expression to parse
 * @return {?MethodSignature} The method metadata object if a method expression was
 *   found, otherwise `undefined`
 * @private
 */
function parseMethod(expression) {
  // tries to match valid javascript property names
  let m = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m) {
    let methodName = m[1];
    let sig = { methodName, static: true, args: emptyArray };
    if (m[2].trim()) {
      // replace escaped commas with comma entity, split on un-escaped commas
      let args = m[2].replace(/\\,/g, '&comma;').split(',');
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }
  return null;
}

/**
 * Parses an array of arguments and sets the `args` property of the supplied
 * signature metadata object. Sets the `static` property to false if any
 * argument is a non-literal.
 *
 * @param {!Array<string>} argList Array of argument names
 * @param {!MethodSignature} sig Method signature metadata object
 * @return {!MethodSignature} The updated signature metadata object
 * @private
 */
function parseArgs(argList, sig) {
  sig.args = argList.map(function(rawArg) {
    let arg = parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}

/**
 * Parses an individual argument, and returns an argument metadata object
 * with the following fields:
 *
 *   {
 *     value: 'prop',        // property/path or literal value
 *     literal: false,       // whether argument is a literal
 *     structured: false,    // whether the property is a path
 *     rootProperty: 'prop', // the root property of the path
 *     wildcard: false       // whether the argument was a wildcard '.*' path
 *   }
 *
 * @param {string} rawArg The string value of the argument
 * @return {!MethodArg} Argument metadata object
 * @private
 */
function parseArg(rawArg) {
  // clean up whitespace
  let arg = rawArg.trim()
    // replace comma entity with comma
    .replace(/&comma;/g, ',')
    // repair extra escape sequences; note only commas strictly need
    // escaping, but we allow any other char to be escaped since its
    // likely users will do this
    .replace(/\\(.)/g, '\$1')
    ;
  // basic argument descriptor
  let a = {
    name: arg,
    value: '',
    literal: false
  };
  // detect literal value (must be String or Number)
  let fc = arg[0];
  if (fc === '-') {
    fc = arg[1];
  }
  if (fc >= '0' && fc <= '9') {
    fc = '#';
  }
  switch(fc) {
    case "'":
    case '"':
      a.value = arg.slice(1, -1);
      a.literal = true;
      break;
    case '#':
      a.value = Number(arg);
      a.literal = true;
      break;
  }
  // if not literal, look for structured path
  if (!a.literal) {
    a.rootProperty = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(arg);
    // detect structured path (has dots)
    a.structured = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(arg);
    if (a.structured) {
      a.wildcard = (arg.slice(-2) == '.*');
      if (a.wildcard) {
        a.name = arg.slice(0, -2);
      }
    }
  }
  return a;
}

/**
 * Gather the argument values for a method specified in the provided array
 * of argument metadata.
 *
 * The `path` and `value` arguments are used to fill in wildcard descriptor
 * when the method is being called as a result of a path notification.
 *
 * @param {Object} data Instance data storage object to read properties from
 * @param {!Array<!MethodArg>} args Array of argument metadata
 * @param {string} path Property/path name that triggered the method effect
 * @param {Object} props Bag of current property changes
 * @return {Array<*>} Array of argument values
 * @private
 */
function marshalArgs(data, args, path, props) {
  let values = [];
  for (let i=0, l=args.length; i<l; i++) {
    let arg = args[i];
    let name = arg.name;
    let v;
    if (arg.literal) {
      v = arg.value;
    } else {
      if (arg.structured) {
        v = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(data, name);
        // when data is not stored e.g. `splices`
        if (v === undefined) {
          v = props[name];
        }
      } else {
        v = data[name];
      }
    }
    if (arg.wildcard) {
      // Only send the actual path changed info if the change that
      // caused the observer to run matched the wildcard
      let baseChanged = (name.indexOf(path + '.') === 0);
      let matches = (path.indexOf(name) === 0 && !baseChanged);
      values[i] = {
        path: matches ? path : name,
        value: matches ? props[path] : v,
        base: v
      };
    } else {
      values[i] = v;
    }
  }
  return values;
}

// data api

/**
 * Sends array splice notifications (`.splices` and `.length`)
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {Array} splices Array of splice records
 * @private
 */
function notifySplices(inst, array, path, splices) {
  let splicesPath = path + '.splices';
  inst.notifyPath(splicesPath, { indexSplices: splices });
  inst.notifyPath(path + '.length', array.length);
  // Null here to allow potentially large splice records to be GC'ed.
  inst.__data[splicesPath] = {indexSplices: null};
}

/**
 * Creates a splice record and sends an array splice notification for
 * the described mutation
 *
 * Note: this implementation only accepts normalized paths
 *
 * @param {!PropertyEffectsType} inst Instance to send notifications to
 * @param {Array} array The array the mutations occurred on
 * @param {string} path The path to the array that was mutated
 * @param {number} index Index at which the array mutation occurred
 * @param {number} addedCount Number of added items
 * @param {Array} removed Array of removed items
 * @private
 */
function notifySplice(inst, array, path, index, addedCount, removed) {
  notifySplices(inst, array, path, [{
    index: index,
    addedCount: addedCount,
    removed: removed,
    object: array,
    type: 'splice'
  }]);
}

/**
 * Returns an upper-cased version of the string.
 *
 * @param {string} name String to uppercase
 * @return {string} Uppercased string
 * @private
 */
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}

const PropertyEffects = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_PropertyAccessors}
   * @implements {Polymer_TemplateStamp}
   * @unrestricted
   */
  const propertyEffectsBase = Object(__WEBPACK_IMPORTED_MODULE_5__template_stamp_js__["a" /* TemplateStamp */])(Object(__WEBPACK_IMPORTED_MODULE_4__property_accessors_js__["a" /* PropertyAccessors */])(superClass));

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyEffects}
   * @extends {propertyEffectsBase}
   * @unrestricted
   */
  class PropertyEffects extends propertyEffectsBase {

    constructor() {
      super();
      /** @type {boolean} */
      this.__dataClientsReady;
      /** @type {Array} */
      this.__dataPendingClients;
      /** @type {Object} */
      this.__dataToNotify;
      /** @type {Object} */
      this.__dataLinkedPaths;
      /** @type {boolean} */
      this.__dataHasPaths;
      /** @type {Object} */
      this.__dataCompoundStorage;
      /** @type {Polymer_PropertyEffects} */
      this.__dataHost;
      /** @type {!Object} */
      this.__dataTemp;
      /** @type {boolean} */
      this.__dataClientsInitialized;
      /** @type {!Object} */
      this.__data;
      /** @type {!Object} */
      this.__dataPending;
      /** @type {!Object} */
      this.__dataOld;
      /** @type {Object} */
      this.__computeEffects;
      /** @type {Object} */
      this.__reflectEffects;
      /** @type {Object} */
      this.__notifyEffects;
      /** @type {Object} */
      this.__propagateEffects;
      /** @type {Object} */
      this.__observeEffects;
      /** @type {Object} */
      this.__readOnly;
      /** @type {number} */
      this.__dataCounter;
      /** @type {!TemplateInfo} */
      this.__templateInfo;
    }

    get PROPERTY_EFFECT_TYPES() {
      return TYPES;
    }

    _initializeProperties() {
      super._initializeProperties();
      hostStack.registerHost(this);
      this.__dataClientsReady = false;
      this.__dataPendingClients = null;
      this.__dataToNotify = null;
      this.__dataLinkedPaths = null;
      this.__dataHasPaths = false;
      // May be set on instance prior to upgrade
      this.__dataCompoundStorage = this.__dataCompoundStorage || null;
      this.__dataHost = this.__dataHost || null;
      this.__dataTemp = {};
      this.__dataClientsInitialized = false;
    }

    /**
     * Overrides `Polymer.PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     */
    _initializeProtoProperties(props) {
      this.__data = Object.create(props);
      this.__dataPending = Object.create(props);
      this.__dataOld = {};
    }

    /**
     * Overrides `Polymer.PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     */
    _initializeInstanceProperties(props) {
      let readOnly = this[TYPES.READ_ONLY];
      for (let prop in props) {
        if (!readOnly || !readOnly[prop]) {
          this.__dataPending = this.__dataPending || {};
          this.__dataOld = this.__dataOld || {};
          this.__data[prop] = this.__dataPending[prop] = props[prop];
        }
      }
    }

    // Prototype setup ----------------------------------------

    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @protected
     */
    _addPropertyEffect(property, type, effect) {
      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
      // effects are accumulated into arrays per property based on type
      let effects = ensureOwnEffectMap(this, type)[property];
      if (!effects) {
        effects = this[type][property] = [];
      }
      effects.push(effect);
    }

    /**
     * Removes the given property effect.
     *
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     */
    _removePropertyEffect(property, type, effect) {
      let effects = ensureOwnEffectMap(this, type)[property];
      let idx = effects.indexOf(effect);
      if (idx >= 0) {
        effects.splice(idx, 1);
      }
    }

    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasPropertyEffect(property, type) {
      let effects = this[type];
      return Boolean(effects && effects[property]);
    }

    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasReadOnlyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.READ_ONLY);
    }

    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasNotifyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.NOTIFY);
    }

    /**
     * Returns whether the current prototype/instance has a "reflect to attribute"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasReflectEffect(property) {
      return this._hasPropertyEffect(property, TYPES.REFLECT);
    }

    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this type
     * @protected
     */
    _hasComputedEffect(property) {
      return this._hasPropertyEffect(property, TYPES.COMPUTE);
    }

    // Runtime ----------------------------------------

    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */
    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
      if (isPathNotification ||
          Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["g" /* root */])(Array.isArray(path) ? path[0] : path) !== path) {
        // Dirty check changes being set to a path against the actual object,
        // since this is the entry point for paths into the system; from here
        // the only dirty checks are against the `__dataTemp` cache to prevent
        // duplicate work in the same turn only. Note, if this was a notification
        // of a change already set to a path (isPathNotification: true),
        // we always let the change through and skip the `set` since it was
        // already dirty checked at the point of entry and the underlying
        // object has already been updated
        if (!isPathNotification) {
          let old = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path);
          path = /** @type {string} */ (Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["h" /* set */])(this, path, value));
          // Use property-accessor's simpler dirty check
          if (!path || !super._shouldPropertyChange(path, value, old)) {
            return false;
          }
        }
        this.__dataHasPaths = true;
        if (this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify)) {
          computeLinkedPaths(this, path, value);
          return true;
        }
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
          return this._setPendingProperty(/**@type{string}*/(path), value, shouldNotify);
        } else {
          this[path] = value;
        }
      }
      return false;
    }

    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @param {Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @protected
     */
    _setUnmanagedPropertyToNode(node, prop, value) {
      // It is a judgment call that resetting primitives is
      // "bad" and resettings objects is also "good"; alternatively we could
      // implement a whitelist of tag & property values that should never
      // be reset (e.g. <input>.value && <select>.value)
      if (value !== node[prop] || typeof value == 'object') {
        node[prop] = value;
      }
    }

    /**
     * Overrides the `PropertyAccessors` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChaged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     * @override
     */
    _setPendingProperty(property, value, shouldNotify) {
      let isPath = this.__dataHasPaths && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(property);
      let prevProps = isPath ? this.__dataTemp : this.__data;
      if (this._shouldPropertyChange(property, value, prevProps[property])) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        // Ensure old is captured from the last turn
        if (!(property in this.__dataOld)) {
          this.__dataOld[property] = this.__data[property];
        }
        // Paths are stored in temporary cache (cleared at end of turn),
        // which is used for dirty-checking, all others stored in __data
        if (isPath) {
          this.__dataTemp[property] = value;
        } else {
          this.__data[property] = value;
        }
        // All changes go into pending property bag, passed to _propertiesChanged
        this.__dataPending[property] = value;
        // Track properties that should notify separately
        if (isPath || (this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property])) {
          this.__dataToNotify = this.__dataToNotify || {};
          this.__dataToNotify[property] = shouldNotify;
        }
        return true;
      }
      return false;
    }

    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     */
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value, true)) {
        this._invalidateProperties();
      }
    }

    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     */
    _invalidateProperties() {
      if (this.__dataReady) {
        this._flushProperties();
      }
    }

    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @param {Object} client PropertyEffects client to enqueue
     * @protected
     */
    _enqueueClient(client) {
      this.__dataPendingClients = this.__dataPendingClients || [];
      if (client !== this) {
        this.__dataPendingClients.push(client);
      }
    }

    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @protected
     */
    _flushClients() {
      if (!this.__dataClientsReady) {
        this.__dataClientsReady = true;
        this._readyClients();
        // Override point where accessors are turned on; importantly,
        // this is after clients have fully readied, providing a guarantee
        // that any property effects occur only after all clients are ready.
        this.__dataReady = true;
      } else {
        this.__enableOrFlushClients();
      }
    }

    // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.
    __enableOrFlushClients() {
      let clients = this.__dataPendingClients;
      if (clients) {
        this.__dataPendingClients = null;
        for (let i=0; i < clients.length; i++) {
          let client = clients[i];
          if (!client.__dataEnabled) {
            client._enableProperties();
          } else if (client.__dataPending) {
            client._flushProperties();
          }
        }
      }
    }

    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @protected
     */
    _readyClients() {
      this.__enableOrFlushClients();
    }

    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @public
     */
    setProperties(props, setReadOnly) {
      for (let path in props) {
        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
          //TODO(kschaaf): explicitly disallow paths in setProperty?
          // wildcard observers currently only pass the first changed path
          // in the `info` object, and you could do some odd things batching
          // paths, e.g. {'foo.bar': {...}, 'foo': null}
          this._setPendingPropertyOrPath(path, props[path], true);
        }
      }
      this._invalidateProperties();
    }

    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     */
    ready() {
      // It is important that `super.ready()` is not called here as it
      // immediately turns on accessors. Instead, we wait until `readyClients`
      // to enable accessors to provide a guarantee that clients are ready
      // before processing any accessors side effects.
      this._flushProperties();
      // If no data was pending, `_flushProperties` will not `flushClients`
      // so ensure this is done.
      if (!this.__dataClientsReady) {
        this._flushClients();
      }
      // Before ready, client notifications do not trigger _flushProperties.
      // Therefore a flush is necessary here if data has been set.
      if (this.__dataPending) {
        this._flushProperties();
      }
    }

    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     */
    _propertiesChanged(currentProps, changedProps, oldProps) {
      // ----------------------------
      // let c = Object.getOwnPropertyNames(changedProps || {});
      // window.debug && console.group(this.localName + '#' + this.id + ': ' + c);
      // if (window.debug) { debugger; }
      // ----------------------------
      let hasPaths = this.__dataHasPaths;
      this.__dataHasPaths = false;
      // Compute properties
      runComputedEffects(this, changedProps, oldProps, hasPaths);
      // Clear notify properties prior to possible reentry (propagate, observe),
      // but after computing effects have a chance to add to them
      let notifyProps = this.__dataToNotify;
      this.__dataToNotify = null;
      // Propagate properties to clients
      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
      // Flush clients
      this._flushClients();
      // Reflect properties
      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
      // Observe properties
      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
      // Notify properties to host
      if (notifyProps) {
        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
      }
      // Clear temporary cache at end of turn
      if (this.__dataCounter == 1) {
        this.__dataTemp = {};
      }
      // ----------------------------
      // window.debug && console.groupEnd(this.localName + '#' + this.id + ': ' + c);
      // ----------------------------
    }

    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @protected
     */
    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
      if (this[TYPES.PROPAGATE]) {
        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
      }
      let templateInfo = this.__templateInfo;
      while (templateInfo) {
        runEffects(this, templateInfo.propertyEffects, changedProps, oldProps,
          hasPaths, templateInfo.nodeList);
        templateInfo = templateInfo.nextTemplateInfo;
      }
    }

    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @public
     */
    linkPaths(to, from) {
      to = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(to);
      from = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(from);
      this.__dataLinkedPaths = this.__dataLinkedPaths || {};
      this.__dataLinkedPaths[to] = from;
    }

    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @public
     */
    unlinkPaths(path) {
      path = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(path);
      if (this.__dataLinkedPaths) {
        delete this.__dataLinkedPaths[path];
      }
    }

    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1, obect: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1, object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     * @public
    */
    notifySplices(path, splices) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      notifySplices(this, array, info.path, splices);
    }

    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */
    get(path, root) {
      return Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(root || this, path);
    }

    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @public
    */
    set(path, value, root) {
      if (root) {
        Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["h" /* set */])(root, path, value);
      } else {
        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][/** @type {string} */(path)]) {
          if (this._setPendingPropertyOrPath(path, value, true)) {
            this._invalidateProperties();
          }
        }
      }
    }

    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */
    push(path, ...items) {
      let info = {path: ''};
      let array = /** @type {Array}*/(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let len = array.length;
      let ret = array.push(...items);
      if (items.length) {
        notifySplice(this, array, info.path, len, items.length, []);
      }
      return ret;
    }

    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    pop(path) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let hadLength = Boolean(array.length);
      let ret = array.pop();
      if (hadLength) {
        notifySplice(this, array, info.path, array.length, 0, [ret]);
      }
      return ret;
    }

    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {Array} Array of removed items.
     * @public
     */
    splice(path, start, deleteCount, ...items) {
      let info = {path : ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      // Normalize fancy native splice handling of crazy start values
      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else {
        start = Math.floor(start);
      }
      if (!start) {
        start = 0;
      }
      let ret = array.splice(start, deleteCount, ...items);
      if (items.length || ret.length) {
        notifySplice(this, array, info.path, start, items.length, ret);
      }
      return ret;
    }

    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    shift(path) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let hadLength = Boolean(array.length);
      let ret = array.shift();
      if (hadLength) {
        notifySplice(this, array, info.path, 0, 0, [ret]);
      }
      return ret;
    }

    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */
    unshift(path, ...items) {
      let info = {path: ''};
      let array = /** @type {Array} */(Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info));
      let ret = array.unshift(...items);
      if (items.length) {
        notifySplice(this, array, info.path, 0, items.length, []);
      }
      return ret;
    }

    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @public
    */
    notifyPath(path, value) {
      /** @type {string} */
      let propPath;
      if (arguments.length == 1) {
        // Get value if not supplied
        let info = {path: ''};
        value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(this, path, info);
        propPath = info.path;
      } else if (Array.isArray(path)) {
        // Normalize path if needed
        propPath = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["f" /* normalize */])(path);
      } else {
        propPath = /** @type{string} */(path);
      }
      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
        this._invalidateProperties();
      }
    }

    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @protected
     */
    _createReadOnlyProperty(property, protectedSetter) {
      this._addPropertyEffect(property, TYPES.READ_ONLY);
      if (protectedSetter) {
        this['_set' + upper(property)] = /** @this {PropertyEffects} */function(value) {
          this._setProperty(property, value);
        };
      }
    }

    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @param {string} methodName Name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @protected
     */
    _createPropertyObserver(property, methodName, dynamicFn) {
      let info = { property, methodName, dynamicFn: Boolean(dynamicFn) };
      this._addPropertyEffect(property, TYPES.OBSERVE, {
        fn: runObserverEffect, info, trigger: {name: property}
      });
      if (dynamicFn) {
        this._addPropertyEffect(methodName, TYPES.OBSERVE, {
          fn: runObserverEffect, info, trigger: {name: methodName}
        });
      }
    }

    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */
    _createMethodObserver(expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed observer expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
    }

    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @protected
     */
    _createNotifyingProperty(property) {
      this._addPropertyEffect(property, TYPES.NOTIFY, {
        fn: runNotifyEffect,
        info: {
          eventName: CaseMap.camelToDashCase(property) + '-changed',
          property: property
        }
      });
    }

    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Property name
     * @protected
     */
    _createReflectedProperty(property) {
      let attr = CaseMap.camelToDashCase(property);
      if (attr[0] === '-') {
        console.warn('Property ' + property + ' cannot be reflected to attribute ' +
          attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property thisead.');
      } else {
        this._addPropertyEffect(property, TYPES.REFLECT, {
          fn: runReflectEffect,
          info: {
            attrName: attr
          }
        });
      }
    }

    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */
    _createComputedProperty(property, expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed computed expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
    }

    // -- static class methods ------------

    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @protected
     */
    static addPropertyEffect(property, type, effect) {
      this.prototype._addPropertyEffect(property, type, effect);
    }

    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string} methodName Name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @protected
     */
    static createPropertyObserver(property, methodName, dynamicFn) {
      this.prototype._createPropertyObserver(property, methodName, dynamicFn);
    }

    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal Javascript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @protected
     */
    static createMethodObserver(expression, dynamicFn) {
      this.prototype._createMethodObserver(expression, dynamicFn);
    }

    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @protected
     */
    static createNotifyingProperty(property) {
      this.prototype._createNotifyingProperty(property);
    }

    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @protected
     */
    static createReadOnlyProperty(property, protectedSetter) {
      this.prototype._createReadOnlyProperty(property, protectedSetter);
    }

    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @protected
     */
    static createReflectedProperty(property) {
      this.prototype._createReflectedProperty(property);
    }

    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal Javascript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @protected
     */
    static createComputedProperty(property, expression, dynamicFn) {
      this.prototype._createComputedProperty(property, expression, dynamicFn);
    }

    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {Object} Template metadata object
     * @protected
     */
    static bindTemplate(template) {
      return this.prototype._bindTemplate(template);
    }

    // -- binding ----------------------------------------------

    /**
     * Equivalent to static `bindTemplate` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @param {HTMLTemplateElement} template Template containing binding
     *   bindings
     * @param {boolean=} instanceBinding When false (default), performs
     *   "prototypical" binding of the template and overwrites any previously
     *   bound template for the class. When true (as passed from
     *   `_stampTemplate`), the template info is instanced and linked into
     *   the list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     *   this is an instance of the prototypical template info
     * @protected
     */
    _bindTemplate(template, instanceBinding) {
      let templateInfo = this.constructor._parseTemplate(template);
      let wasPreBound = this.__templateInfo == templateInfo;
      // Optimization: since this is called twice for proto-bound templates,
      // don't attempt to recreate accessors if this template was pre-bound
      if (!wasPreBound) {
        for (let prop in templateInfo.propertyEffects) {
          this._createPropertyAccessor(prop);
        }
      }
      if (instanceBinding) {
        // For instance-time binding, create instance of template metadata
        // and link into list of templates if necessary
        templateInfo = /** @type {!TemplateInfo} */(Object.create(templateInfo));
        templateInfo.wasPreBound = wasPreBound;
        if (!wasPreBound && this.__templateInfo) {
          let last = this.__templateInfoLast || this.__templateInfo;
          this.__templateInfoLast = last.nextTemplateInfo = templateInfo;
          templateInfo.previousTemplateInfo = last;
          return templateInfo;
        }
      }
      return this.__templateInfo = templateInfo;
    }

    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @protected
     */
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
      hostProps[prop] = true;
      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
      let propEffects = effects[prop] = effects[prop] || [];
      propEffects.push(effect);
    }

    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */
    _stampTemplate(template) {
      // Ensures that created dom is `_enqueueClient`'d to this element so
      // that it can be flushed on next call to `_flushProperties`
      hostStack.beginHosting(this);
      let dom = super._stampTemplate(template);
      hostStack.endHosting(this);
      let templateInfo = /** @type {!TemplateInfo} */(this._bindTemplate(template, true));
      // Add template-instance-specific data to instanced templateInfo
      templateInfo.nodeList = dom.nodeList;
      // Capture child nodes to allow unstamping of non-prototypical templates
      if (!templateInfo.wasPreBound) {
        let nodes = templateInfo.childNodes = [];
        for (let n=dom.firstChild; n; n=n.nextSibling) {
          nodes.push(n);
        }
      }
      dom.templateInfo = templateInfo;
      // Setup compound storage, 2-way listeners, and dataHost for bindings
      setupBindings(this, templateInfo);
      // Flush properties into template nodes if already booted
      if (this.__dataReady) {
        runEffects(this, templateInfo.propertyEffects, this.__data, null,
          false, templateInfo.nodeList);
      }
      return dom;
    }

    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @protected
     */
    _removeBoundDom(dom) {
      // Unlink template info
      let templateInfo = dom.templateInfo;
      if (templateInfo.previousTemplateInfo) {
        templateInfo.previousTemplateInfo.nextTemplateInfo =
          templateInfo.nextTemplateInfo;
      }
      if (templateInfo.nextTemplateInfo) {
        templateInfo.nextTemplateInfo.previousTemplateInfo =
          templateInfo.previousTemplateInfo;
      }
      if (this.__templateInfoLast == templateInfo) {
        this.__templateInfoLast = templateInfo.previousTemplateInfo;
      }
      templateInfo.previousTemplateInfo = templateInfo.nextTemplateInfo = null;
      // Remove stamped nodes
      let nodes = templateInfo.childNodes;
      for (let i=0; i<nodes.length; i++) {
        let node = nodes[i];
        node.parentNode.removeChild(node);
      }
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @override
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = super._parseTemplateNode(node, templateInfo, nodeInfo);
      if (node.nodeType === Node.TEXT_NODE) {
        let parts = this._parseBindings(node.textContent, templateInfo);
        if (parts) {
          // Initialize the textContent with any literal parts
          // NOTE: default to a space here so the textNode remains; some browsers
          // (IE) evacipate an empty textNode following cloneNode/importNode.
          node.textContent = literalFromParts(parts) || ' ';
          addBinding(this, templateInfo, nodeInfo, 'text', 'textContent', parts);
          noted = true;
        }
      }
      return noted;
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @override
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      let parts = this._parseBindings(value, templateInfo);
      if (parts) {
        // Attribute or property
        let origName = name;
        let kind = 'property';
        if (name[name.length-1] == '$') {
          name = name.slice(0, -1);
          kind = 'attribute';
        }
        // Initialize attribute bindings with any literal parts
        let literal = literalFromParts(parts);
        if (literal && kind == 'attribute') {
          node.setAttribute(name, literal);
        }
        // Clear attribute before removing, since IE won't allow removing
        // `value` attribute if it previously had a value (can't
        // unconditionally set '' before removing since attributes with `$`
        // can't be set using setAttribute)
        if (node.localName === 'input' && origName === 'value') {
          node.setAttribute(origName, '');
        }
        // Remove annotation
        node.removeAttribute(origName);
        // Case hackery: attributes are lower-case, but bind targets
        // (properties) are case sensitive. Gambit is to map dash-case to
        // camel-case: `foo-bar` becomes `fooBar`.
        // Attribute bindings are excepted.
        if (kind === 'property') {
          name = Object(__WEBPACK_IMPORTED_MODULE_3__utils_case_map_js__["dashToCamelCase"])(name);
        }
        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
        return true;
      } else {
        return super._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value);
      }
    }

    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @override
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     */
    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
      let noted = super._parseTemplateNestedTemplate(node, templateInfo, nodeInfo);
      // Merge host props into outer template and add bindings
      let hostProps = nodeInfo.templateInfo.hostProps;
      let mode = '{';
      for (let source in hostProps) {
        let parts = [{ mode, source, dependencies: [source] }];
        addBinding(this, templateInfo, nodeInfo, 'property', '_host_' + source, parts);
      }
      return noted;
    }

    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     */
    static _parseBindings(text, templateInfo) {
      let parts = [];
      let lastIndex = 0;
      let m;
      // Example: "literal1{{prop}}literal2[[!compute(foo,bar)]]final"
      // Regex matches:
      //        Iteration 1:  Iteration 2:
      // m[1]: '{{'          '[['
      // m[2]: ''            '!'
      // m[3]: 'prop'        'compute(foo,bar)'
      while ((m = bindingRegex.exec(text)) !== null) {
        // Add literal part
        if (m.index > lastIndex) {
          parts.push({literal: text.slice(lastIndex, m.index)});
        }
        // Add binding part
        let mode = m[1][0];
        let negate = Boolean(m[2]);
        let source = m[3].trim();
        let customEvent = false, notifyEvent = '', colon = -1;
        if (mode == '{' && (colon = source.indexOf('::')) > 0) {
          notifyEvent = source.substring(colon + 2);
          source = source.substring(0, colon);
          customEvent = true;
        }
        let signature = parseMethod(source);
        let dependencies = [];
        if (signature) {
          // Inline computed function
          let {args, methodName} = signature;
          for (let i=0; i<args.length; i++) {
            let arg = args[i];
            if (!arg.literal) {
              dependencies.push(arg);
            }
          }
          let dynamicFns = templateInfo.dynamicFns;
          if (dynamicFns && dynamicFns[methodName] || signature.static) {
            dependencies.push(methodName);
            signature.dynamicFn = true;
          }
        } else {
          // Property or path
          dependencies.push(source);
        }
        parts.push({
          source, mode, negate, customEvent, signature, dependencies,
          event: notifyEvent
        });
        lastIndex = bindingRegex.lastIndex;
      }
      // Add a final literal part
      if (lastIndex && lastIndex < text.length) {
        let literal = text.substring(lastIndex);
        if (literal) {
          parts.push({
            literal: literal
          });
        }
      }
      if (parts.length) {
        return parts;
      } else {
        return null;
      }
    }

    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {this} inst Element that should be used as scope for
     *   binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     */
    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
      let value;
      if (part.signature) {
        value = runMethodEffect(inst, path, props, oldProps, part.signature);
      } else if (path != part.source) {
        value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, part.source);
      } else {
        if (hasPaths && Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["d" /* isPath */])(path)) {
          value = Object(__WEBPACK_IMPORTED_MODULE_2__utils_path_js__["a" /* get */])(inst, path);
        } else {
          value = inst.__data[path];
        }
      }
      if (part.negate) {
        value = !value;
      }
      return value;
    }

  }

  // make a typing for closure :P
  PropertyEffectsType = PropertyEffects;

  return PropertyEffects;
});
/* harmony export (immutable) */ __webpack_exports__["a"] = PropertyEffects;


/**
 * Helper api for enqueing client dom created by a host element.
 *
 * By default elements are flushed via `_flushProperties` when
 * `connectedCallback` is called. Elements attach their client dom to
 * themselves at `ready` time which results from this first flush.
 * This provides an ordering guarantee that the client dom an element
 * creates is flushed before the element itself (i.e. client `ready`
 * fires before host `ready`).
 *
 * However, if `_flushProperties` is called *before* an element is connected,
 * as for example `Templatize` does, this ordering guarantee cannot be
 * satisfied because no elements are connected. (Note: Bound elements that
 * receive data do become enqueued clients and are properly ordered but
 * unbound elements are not.)
 *
 * To maintain the desired "client before host" ordering guarantee for this
 * case we rely on the "host stack. Client nodes registers themselves with
 * the creating host element when created. This ensures that all client dom
 * is readied in the proper order, maintaining the desired guarantee.
 *
 * @private
 */
let hostStack = {

  stack: [],

  /**
   * @param {*} inst Instance to add to hostStack
   * @this {hostStack}
   */
  registerHost(inst) {
    if (this.stack.length) {
      let host = this.stack[this.stack.length-1];
      host._enqueueClient(inst);
    }
  },

  /**
   * @param {*} inst Instance to begin hosting
   * @this {hostStack}
   */
  beginHosting(inst) {
    this.stack.push(inst);
  },

  /**
   * @param {*} inst Instance to end hosting
   * @this {hostStack}
   */
  endHosting(inst) {
    let stackLen = this.stack.length;
    if (stackLen && this.stack[stackLen-1] == inst) {
      this.stack.pop();
    }
  }

};


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return nativeShadow; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return nativeCssVariables; });
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



let nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
let nativeCssVariables;

/**
 * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings
 */
function calcCssVariables(settings) {
  if (settings && settings['shimcssproperties']) {
    nativeCssVariables = false;
  } else {
    // chrome 49 has semi-working css vars, check if box-shadow works
    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
    // However, shim css custom properties are only supported with ShadyDOM enabled,
    // so fall back on native if we do not detect ShadyDOM
    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/
    nativeCssVariables = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) &&
      window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));
  }
}

if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {
  nativeCssVariables = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS);
  // reset window variable to let ShadyCSS API take its place
  window.ShadyCSS = undefined;
} else {
  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
}

/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export StyleNode */
/* harmony export (immutable) */ __webpack_exports__["a"] = parse;
/* harmony export (immutable) */ __webpack_exports__["b"] = stringify;
/* unused harmony export removeCustomPropAssignment */
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/*
Extremely simple css parser. Intended to be not more than what we need
and definitely not necessarily correct =).
*/



/** @unrestricted */
class StyleNode {
  constructor() {
    /** @type {number} */
    this['start'] = 0;
    /** @type {number} */
    this['end'] = 0;
    /** @type {StyleNode} */
    this['previous'] = null;
    /** @type {StyleNode} */
    this['parent'] = null;
    /** @type {Array<StyleNode>} */
    this['rules'] = null;
    /** @type {string} */
    this['parsedCssText'] = '';
    /** @type {string} */
    this['cssText'] = '';
    /** @type {boolean} */
    this['atRule'] = false;
    /** @type {number} */
    this['type'] = 0;
    /** @type {string} */
    this['keyframesName'] = '';
    /** @type {string} */
    this['selector'] = '';
    /** @type {string} */
    this['parsedSelector'] = '';
  }
}



// given a string of css, return a simple rule tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function parse(text) {
  text = clean(text);
  return parseCss(lex(text), text);
}

// remove stuff we don't care about that may hinder parsing
/**
 * @param {string} cssText
 * @return {string}
 */
function clean(cssText) {
  return cssText.replace(RX.comments, '').replace(RX.port, '');
}

// super simple {...} lexer that returns a node tree
/**
 * @param {string} text
 * @return {StyleNode}
 */
function lex(text) {
  let root = new StyleNode();
  root['start'] = 0;
  root['end'] = text.length
  let n = root;
  for (let i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n['rules']) {
        n['rules'] = [];
      }
      let p = n;
      let previous = p['rules'][p['rules'].length - 1] || null;
      n = new StyleNode();
      n['start'] = i + 1;
      n['parent'] = p;
      n['previous'] = previous;
      p['rules'].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n['end'] = i + 1;
      n = n['parent'] || root;
    }
  }
  return root;
}

// add selectors/cssText to node tree
/**
 * @param {StyleNode} node
 * @param {string} text
 * @return {StyleNode}
 */
function parseCss(node, text) {
  let t = text.substring(node['start'], node['end'] - 1);
  node['parsedCssText'] = node['cssText'] = t.trim();
  if (node['parent']) {
    let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];
    t = text.substring(ss, node['start'] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, ' ');
    // TODO(sorvell): ad hoc; make selector include only after last ;
    // helps with mixin syntax
    t = t.substring(t.lastIndexOf(';') + 1);
    let s = node['parsedSelector'] = node['selector'] = t.trim();
    node['atRule'] = (s.indexOf(AT_START) === 0);
    // note, support a subset of rule types...
    if (node['atRule']) {
      if (s.indexOf(MEDIA_START) === 0) {
        node['type'] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node['type'] = types.KEYFRAMES_RULE;
        node['keyframesName'] =
          node['selector'].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node['type'] = types.MIXIN_RULE;
      } else {
        node['type'] = types.STYLE_RULE;
      }
    }
  }
  let r$ = node['rules'];
  if (r$) {
    for (let i = 0, l = r$.length, r;
      (i < l) && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }
  return node;
}

/**
 * conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
 * expanded form that doesn't require trailing space `\000033`
 * @param {string} s
 * @return {string}
 */
function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function() {
    let code = arguments[1],
      repeat = 6 - code.length;
    while (repeat--) {
      code = '0' + code;
    }
    return '\\' + code;
  });
}

/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */
function stringify(node, preserveProperties, text = '') {
  // calc rule cssText
  let cssText = '';
  if (node['cssText'] || node['rules']) {
    let r$ = node['rules'];
    if (r$ && !_hasMixinRules(r$)) {
      for (let i = 0, l = r$.length, r;
        (i < l) && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node['cssText'] :
        removeCustomProps(node['cssText']);
      cssText = cssText.trim();
      if (cssText) {
        cssText = '  ' + cssText + '\n';
      }
    }
  }
  // emit rule if there is cssText
  if (cssText) {
    if (node['selector']) {
      text += node['selector'] + ' ' + OPEN_BRACE + '\n';
    }
    text += cssText;
    if (node['selector']) {
      text += CLOSE_BRACE + '\n\n';
    }
  }
  return text;
}

/**
 * @param {Array<StyleNode>} rules
 * @return {boolean}
 */
function _hasMixinRules(rules) {
  let r = rules[0];
  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropAssignment(cssText) {
  return cssText
    .replace(RX.customProp, '')
    .replace(RX.mixinProp, '');
}

/**
 * @param {string} cssText
 * @return {string}
 */
function removeCustomPropApply(cssText) {
  return cssText
    .replace(RX.mixinApply, '')
    .replace(RX.varApply, '');
}

/** @enum {number} */
const types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1000
}
/* harmony export (immutable) */ __webpack_exports__["c"] = types;


const OPEN_BRACE = '{';
const CLOSE_BRACE = '}';

// helper regexp's
const RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
}

const VAR_START = '--';
const MEDIA_START = '@media';
const AT_START = '@';


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
/* harmony export (immutable) */ __webpack_exports__["c"] = VAR_ASSIGN;

const MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
/* harmony export (immutable) */ __webpack_exports__["b"] = MIXIN_MATCH;

const VAR_CONSUMED = /(--[\w-]+)\s*([:,;)]|$)/gi;
/* unused harmony export VAR_CONSUMED */

const ANIMATION_MATCH = /(animation\s*:)|(animation-name\s*:)/;
/* unused harmony export ANIMATION_MATCH */

const MEDIA_MATCH = /@media\s(.*)/;
/* harmony export (immutable) */ __webpack_exports__["a"] = MEDIA_MATCH;

const IS_VAR = /^--/;
/* unused harmony export IS_VAR */

const BRACKETED = /\{[^}]*\}/g;
/* unused harmony export BRACKETED */

const HOST_PREFIX = '(?:^|[^.#[:])';
/* unused harmony export HOST_PREFIX */

const HOST_SUFFIX = '($|[.:[\\s>+~])';
/* unused harmony export HOST_SUFFIX */



/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["c"] = updateNativeProperties;
/* harmony export (immutable) */ __webpack_exports__["b"] = getComputedStyleValue;
/* harmony export (immutable) */ __webpack_exports__["a"] = detectMixin;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__common_regex_js__ = __webpack_require__(25);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/





/**
 * @param {Element} element
 * @param {Object=} properties
 */
function updateNativeProperties(element, properties) {
  // remove previous properties
  for (let p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}

/**
 * @param {Element} element
 * @param {string} property
 * @return {string}
 */
function getComputedStyleValue(element, property) {
  /**
   * @const {string}
   */
  const value = window.getComputedStyle(element).getPropertyValue(property);
  if (!value) {
    return '';
  } else {
    return value.trim();
  }
}

/**
 * return true if `cssText` contains a mixin definition or consumption
 * @param {string} cssText
 * @return {boolean}
 */
function detectMixin(cssText) {
  const has = __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["b" /* MIXIN_MATCH */].test(cssText) || __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["c" /* VAR_ASSIGN */].test(cssText);
  // reset state of the regexes
  __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["b" /* MIXIN_MATCH */].lastIndex = 0;
  __WEBPACK_IMPORTED_MODULE_0__common_regex_js__["c" /* VAR_ASSIGN */].lastIndex = 0;
  return has;
}


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export beforeNextRender */
/* harmony export (immutable) */ __webpack_exports__["a"] = afterNextRender;
/* unused harmony export flush */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


let scheduled = false;
let beforeRenderQueue = [];
let afterRenderQueue = [];

function schedule() {
  scheduled = true;
  // before next render
  requestAnimationFrame(function() {
    scheduled = false;
    flushQueue(beforeRenderQueue);
    // after the render
    setTimeout(function() {
      runQueue(afterRenderQueue);
    });
  });
}

function flushQueue(queue) {
  while (queue.length) {
    callMethod(queue.shift());
  }
}

function runQueue(queue) {
  for (let i=0, l=queue.length; i < l; i++) {
    callMethod(queue.shift());
  }
}

function callMethod(info) {
  const context = info[0];
  const callback = info[1];
  const args = info[2];
  try {
    callback.apply(context, args);
  } catch(e) {
    setTimeout(() => {
      throw e;
    });
  }
}

function flush() {
  while (beforeRenderQueue.length || afterRenderQueue.length) {
    flushQueue(beforeRenderQueue);
    flushQueue(afterRenderQueue);
  }
  scheduled = false;
}

function beforeNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  beforeRenderQueue.push([context, callback, args]);
}

function afterNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  afterRenderQueue.push([context, callback, args]);
}




/***/ }),
/* 28 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


let debouncerQueue = [];

const enqueueDebouncer = function(debouncer) {
  debouncerQueue.push(debouncer);
};
/* harmony export (immutable) */ __webpack_exports__["a"] = enqueueDebouncer;


function flushDebouncers() {
  const didFlush = Boolean(debouncerQueue.length);
  while (debouncerQueue.length) {
    try {
      debouncerQueue.shift().flush();
    } catch(e) {
      setTimeout(() => {
        throw e;
      });
    }
  }
  return didFlush;
}

const flush = function() {
  let shadyDOM, debouncers;
  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();
    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }
    debouncers = flushDebouncers();
  } while (shadyDOM || debouncers);
};
/* harmony export (immutable) */ __webpack_exports__["b"] = flush;



/***/ }),
/* 29 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return Templatize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return TemplateInstanceBase; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__ = __webpack_require__(14);




// Base class for HTMLTemplateElement extension that has property effects
// machinery for propagating host properties to children. This is an ES5
// class only because Babel (incorrectly) requires super() in the class
// constructor even though no `this` is used and it returns an instance.
let newInstance = null;
/**
 * @constructor
 * @extends {HTMLTemplateElement}
 */
function HTMLTemplateElementExtension() { return newInstance; }
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 * @extends {HTMLTemplateElementExtension}
 */
const DataTemplate = Object(__WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__["a" /* PropertyEffects */])(HTMLTemplateElementExtension);
/**
 * @constructor
 * @implements {Polymer_MutableData}
 * @extends {DataTemplate}
 */
const MutableDataTemplate = Object(__WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__["a" /* MutableData */])(DataTemplate);

// Applies a DataTemplate subclass to a <template> instance
function upgradeTemplate(template, constructor) {
  newInstance = template;
  Object.setPrototypeOf(template, constructor.prototype);
  new constructor();
  newInstance = null;
}

// Base class for TemplateInstance's
/**
 * @constructor
 * @implements {Polymer_PropertyEffects}
 */
const base = Object(__WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__["a" /* PropertyEffects */])(class {});

/**
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @unrestricted
 */
class TemplateInstanceBase extends base {
  constructor(props) {
    super();
    this._configureProperties(props);
    this.root = this._stampTemplate(this.__dataHost);
    // Save list of stamped children
    let children = this.children = [];
    for (let n = this.root.firstChild; n; n=n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = this;
    }
    if (this.__templatizeOwner.__hideTemplateChildren__) {
      this._showHideChildren(true);
    }
    // Flush props only when props are passed if instance props exist
    // or when there isn't instance props.
    let options = this.__templatizeOptions;
    if ((props && options.instanceProps) || !options.instanceProps) {
      this._enableProperties();
    }
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   */
  _configureProperties(props) {
    let options = this.__templatizeOptions;
    if (props) {
      for (let iprop in options.instanceProps) {
        if (iprop in props) {
          this._setPendingProperty(iprop, props[iprop]);
        }
      }
    }
    for (let hprop in this.__hostProps) {
      this._setPendingProperty(hprop, this.__dataHost['_host_' + hprop]);
    }
  }
  /**
   * Forwards a host property to this instance.  This method should be
   * called on instances from the `options.forwardHostProp` callback
   * to propagate changes of host properties to each instance.
   *
   * Note this method enqueues the change, which are flushed as a batch.
   *
   * @param {string} prop Property or path name
   * @param {*} value Value of the property to forward
   */
  forwardHostProp(prop, value) {
    if (this._setPendingPropertyOrPath(prop, value, false, true)) {
      this.__dataHost._enqueueClient(this);
    }
  }
  /**
   * @override
   */
  _addEventListenerToNode(node, eventName, handler) {
    if (this._methodHost && this.__templatizeOptions.parentModel) {
      // If this instance should be considered a parent model, decorate
      // events this template instance as `model`
      this._methodHost._addEventListenerToNode(node, eventName, (e) => {
        e.model = this;
        handler(e);
      });
    } else {
      // Otherwise delegate to the template's host (which could be)
      // another template instance
      let templateHost = this.__dataHost.__dataHost;
      if (templateHost) {
        templateHost._addEventListenerToNode(node, eventName, handler);
      }
    }
  }
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hide Set to true to hide the children;
   * set to false to show them.
   * @protected
   */
  _showHideChildren(hide) {
    let c = this.children;
    for (let i=0; i<c.length; i++) {
      let n = c[i];
      // Ignore non-changes
      if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
        if (n.nodeType === Node.TEXT_NODE) {
          if (hide) {
            n.__polymerTextContent__ = n.textContent;
            n.textContent = '';
          } else {
            n.textContent = n.__polymerTextContent__;
          }
        } else if (n.style) {
          if (hide) {
            n.__polymerDisplay__ = n.style.display;
            n.style.display = 'none';
          } else {
            n.style.display = n.__polymerDisplay__;
          }
        }
      }
      n.__hideTemplateChildren__ = hide;
      if (n._showHideChildren) {
        n._showHideChildren(hide);
      }
    }
  }
  /**
   * Overrides default property-effects implementation to intercept
   * textContent bindings while children are "hidden" and cache in
   * private storage for later retrieval.
   *
   * @override
   */
  _setUnmanagedPropertyToNode(node, prop, value) {
    if (node.__hideTemplateChildren__ &&
        node.nodeType == Node.TEXT_NODE && prop == 'textContent') {
      node.__polymerTextContent__ = value;
    } else {
      super._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
  /**
   * Find the parent model of this template instance.  The parent model
   * is either another templatize instance that had option `parentModel: true`,
   * or else the host element.
   *
   * @return {Polymer_PropertyEffects} The parent model of this instance
   */
  get parentModel() {
    let model = this.__parentModel;
    if (!model) {
      let options;
      model = this;
      do {
        // A template instance's `__dataHost` is a <template>
        // `model.__dataHost.__dataHost` is the template's host
        model = model.__dataHost.__dataHost;
      } while ((options = model.__templatizeOptions) && !options.parentModel);
      this.__parentModel = model;
    }
    return model;
  }
}

/** @type {!DataTemplate} */
TemplateInstanceBase.prototype.__dataHost;
/** @type {!TemplatizeOptions} */
TemplateInstanceBase.prototype.__templatizeOptions;
/** @type {!Polymer_PropertyEffects} */
TemplateInstanceBase.prototype._methodHost;
/** @type {!Object} */
TemplateInstanceBase.prototype.__templatizeOwner;
/** @type {!Object} */
TemplateInstanceBase.prototype.__hostProps;

/**
 * @constructor
 * @extends {TemplateInstanceBase}
 * @implements {Polymer_MutableData}
 */
const MutableTemplateInstanceBase = Object(__WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__["a" /* MutableData */])(TemplateInstanceBase);

function findMethodHost(template) {
  // Technically this should be the owner of the outermost template.
  // In shadow dom, this is always getRootNode().host, but we can
  // approximate this via cooperation with our dataHost always setting
  // `_methodHost` as long as there were bindings (or id's) on this
  // instance causing it to get a dataHost.
  let templateHost = template.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}

/* eslint-disable valid-jsdoc */
/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function createTemplatizerClass(template, templateInfo, options) {
  // Anonymous class created by the templatize
  let base = options.mutableData ?
    MutableTemplateInstanceBase : TemplateInstanceBase;
  /**
   * @constructor
   * @extends {base}
   */
  let klass = class extends base { };
  klass.prototype.__templatizeOptions = options;
  klass.prototype._bindTemplate(template);
  addNotifyEffects(klass, template, templateInfo, options);
  return klass;
}

/**
 * @suppress {missingProperties} class.prototype is not defined for some reason
 */
function addPropagateEffects(template, templateInfo, options) {
  let userForwardHostProp = options.forwardHostProp;
  if (userForwardHostProp) {
    // Provide data API and property effects on memoized template class
    let klass = templateInfo.templatizeTemplateClass;
    if (!klass) {
      let base = options.mutableData ? MutableDataTemplate : DataTemplate;
      klass = templateInfo.templatizeTemplateClass =
        class TemplatizedTemplate extends base {};
      // Add template - >instances effects
      // and host <- template effects
      let hostProps = templateInfo.hostProps;
      for (let prop in hostProps) {
        klass.prototype._addPropertyEffect('_host_' + prop,
          klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
          {fn: createForwardHostPropEffect(prop, userForwardHostProp)});
        klass.prototype._createNotifyingProperty('_host_' + prop);
      }
    }
    upgradeTemplate(template, klass);
    // Mix any pre-bound data into __data; no need to flush this to
    // instances since they pull from the template at instance-time
    if (template.__dataProto) {
      // Note, generally `__dataProto` could be chained, but it's guaranteed
      // to not be since this is a vanilla template we just added effects to
      Object.assign(template.__data, template.__dataProto);
    }
    // Clear any pending data for performance
    template.__dataTemp = {};
    template.__dataPending = null;
    template.__dataOld = null;
    template._enableProperties();
  }
}
/* eslint-enable valid-jsdoc */

function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template, prop, props) {
    userForwardHostProp.call(template.__templatizeOwner,
      prop.substring('_host_'.length), props[prop]);
  };
}

function addNotifyEffects(klass, template, templateInfo, options) {
  let hostProps = templateInfo.hostProps || {};
  for (let iprop in options.instanceProps) {
    delete hostProps[iprop];
    let userNotifyInstanceProp = options.notifyInstanceProp;
    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(iprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        {fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp)});
    }
  }
  if (options.forwardHostProp && template.__dataHost) {
    for (let hprop in hostProps) {
      klass.prototype._addPropertyEffect(hprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        {fn: createNotifyHostPropEffect()});
    }
  }
}

function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(inst.__templatizeOwner,
      inst, prop, props[prop]);
  };
}

function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath('_host_' + prop, props[prop], true, true);
  };
}

/**
 * Module for preparing and stamping instances of templates that utilize
 * Polymer's data-binding and declarative event listener features.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     let TemplateClass = Polymer.Templatize.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = new TemplateClass({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. element's shadow DOM
 *     this.shadowRoot.appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * The `options` dictionary passed to `templatize` allows for customizing
 * features of the generated template class, including how outer-scope host
 * properties should be forwarded into template instances, how any instance
 * properties added into the template's scope should be notified out to
 * the host, and whether the instance should be decorated as a "parent model"
 * of any event handlers.
 *
 *     // Customze property forwarding and event model decoration
 *     let TemplateClass = Polymer.Templatize.templatize(template, this, {
 *       parentModel: true,
 *       instanceProps: {...},
 *       forwardHostProp(property, value) {...},
 *       notifyInstanceProp(instance, property, value) {...},
 *     });
 *
 *
 * @namespace
 * @memberof Polymer
 * @summary Module for preparing and stamping instances of templates
 *   utilizing Polymer templating features.
 */

const Templatize = {

  /**
   * Returns an anonymous `Polymer.PropertyEffects` class bound to the
   * `<template>` provided.  Instancing the class will result in the
   * template being stamped into document fragment stored as the instance's
   * `root` property, after which it can be appended to the DOM.
   *
   * Templates may utilize all Polymer data-binding features as well as
   * declarative event listeners.  Event listeners and inline computing
   * functions in the template will be called on the host of the template.
   *
   * The constructor returned takes a single argument dictionary of initial
   * property values to propagate into template bindings.  Additionally
   * host properties can be forwarded in, and instance properties can be
   * notified out by providing optional callbacks in the `options` dictionary.
   *
   * Valid configuration in `options` are as follows:
   *
   * - `forwardHostProp(property, value)`: Called when a property referenced
   *   in the template changed on the template's host. As this library does
   *   not retain references to templates instanced by the user, it is the
   *   templatize owner's responsibility to forward host property changes into
   *   user-stamped instances.  The `instance.forwardHostProp(property, value)`
   *    method on the generated class should be called to forward host
   *   properties into the template to prevent unnecessary property-changed
   *   notifications. Any properties referenced in the template that are not
   *   defined in `instanceProps` will be notified up to the template's host
   *   automatically.
   * - `instanceProps`: Dictionary of property names that will be added
   *   to the instance by the templatize owner.  These properties shadow any
   *   host properties, and changes within the template to these properties
   *   will result in `notifyInstanceProp` being called.
   * - `mutableData`: When `true`, the generated class will skip strict
   *   dirty-checking for objects and arrays (always consider them to be
   *   "dirty").
   * - `notifyInstanceProp(instance, property, value)`: Called when
   *   an instance property changes.  Users may choose to call `notifyPath`
   *   on e.g. the owner to notify the change.
   * - `parentModel`: When `true`, events handled by declarative event listeners
   *   (`on-event="handler"`) will be decorated with a `model` property pointing
   *   to the template instance that stamped it.  It will also be returned
   *   from `instance.parentModel` in cases where template instance nesting
   *   causes an inner model to shadow an outer model.
   *
   * Note that the class returned from `templatize` is generated only once
   * for a given `<template>` using `options` from the first call for that
   * template, and the cached class is returned for all subsequent calls to
   * `templatize` for that template.  As such, `options` callbacks should not
   * close over owner-specific properties since only the first `options` is
   * used; rather, callbacks are called bound to the `owner`, and so context
   * needed from the callbacks (such as references to `instances` stamped)
   * should be stored on the `owner` such that they can be retrieved via `this`.
   *
   * @memberof Polymer.Templatize
   * @param {!HTMLTemplateElement} template Template to templatize
   * @param {!Polymer_PropertyEffects} owner Owner of the template instances;
   *   any optional callbacks will be bound to this owner.
   * @param {Object=} options Options dictionary (see summary for details)
   * @return {function(new:TemplateInstanceBase)} Generated class bound to the template
   *   provided
   * @suppress {invalidCasts}
   */
  templatize(template, owner, options) {
    options = /** @type {!TemplatizeOptions} */(options || {});
    if (template.__templatizeOwner) {
      throw new Error('A <template> can only be templatized once');
    }
    template.__templatizeOwner = owner;
    let templateInfo = owner.constructor._parseTemplate(template);
    // Get memoized base class for the prototypical template, which
    // includes property effects for binding template & forwarding
    let baseClass = templateInfo.templatizeInstanceClass;
    if (!baseClass) {
      baseClass = createTemplatizerClass(template, templateInfo, options);
      templateInfo.templatizeInstanceClass = baseClass;
    }
    // Host property forwarding must be installed onto template instance
    addPropagateEffects(template, templateInfo, options);
    // Subclass base class and add reference for this specific template
    let klass = class TemplateInstance extends baseClass {};
    klass.prototype._methodHost = findMethodHost(template);
    klass.prototype.__dataHost = template;
    klass.prototype.__templatizeOwner = owner;
    klass.prototype.__hostProps = templateInfo.hostProps;
    return /** @type {function(new:TemplateInstanceBase)} */(klass);
  },

  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model is an instance of
   * `TemplateInstanceBase`, and should be used to manipulate data
   * associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @memberof Polymer.Templatize
   * @param {HTMLTemplateElement} template The model will be returned for
   *   elements stamped from this template
   * @param {Node} node Node for which to return a template model.
   * @return {TemplateInstanceBase} Template instance representing the
   *   binding scope for the element
   */
  modelForElement(template, node) {
    let model;
    while (node) {
      // An element with a __templatizeInstance marks the top boundary
      // of a scope; walk up until we find one, and then ensure that
      // its __dataHost matches `this`, meaning this dom-repeat stamped it
      if ((model = node.__templatizeInstance)) {
        // Found an element stamped by another template; keep walking up
        // from its __dataHost
        if (model.__dataHost != template) {
          node = model.__dataHost;
        } else {
          return model;
        }
      } else {
        // Still in a template scope, keep going up until
        // a __templatizeInstance is found
        node = node.parentNode;
      }
    }
    return null;
  }
};





/***/ }),
/* 30 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_control_state_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





const IronButtonStateImpl = {

  properties: {

    /**
     * If true, the user is currently holding down the button.
     */
    pressed: {
      type: Boolean,
      readOnly: true,
      value: false,
      reflectToAttribute: true,
      observer: '_pressedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: false,
      reflectToAttribute: true
    },

    /**
     * If true, the button is a toggle and is currently in the active state.
     */
    active: {
      type: Boolean,
      value: false,
      notify: true,
      reflectToAttribute: true
    },

    /**
     * True if the element is currently being pressed by a "pointer," which
     * is loosely defined as mouse or touch input (but specifically excluding
     * keyboard input).
     */
    pointerDown: {
      type: Boolean,
      readOnly: true,
      value: false
    },

    /**
     * True if the input device that caused the element to receive focus
     * was a keyboard.
     */
    receivedFocusFromKeyboard: {
      type: Boolean,
      readOnly: true
    },

    /**
     * The aria attribute to be set if the button is a toggle and in the
     * active state.
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-pressed',
      observer: '_ariaActiveAttributeChanged'
    }
  },

  listeners: {
    down: '_downHandler',
    up: '_upHandler',
    tap: '_tapHandler'
  },

  observers: [
    '_focusChanged(focused)',
    '_activeChanged(active, ariaActiveAttribute)'
  ],

  keyBindings: {
    'enter:keydown': '_asyncClick',
    'space:keydown': '_spaceKeyDownHandler',
    'space:keyup': '_spaceKeyUpHandler',
  },

  _mouseEventRe: /^mouse/,

  _tapHandler: function() {
    if (this.toggles) {
     // a tap is needed to toggle the active state
      this._userActivate(!this.active);
    } else {
      this.active = false;
    }
  },

  _focusChanged: function(focused) {
    this._detectKeyboardFocus(focused);

    if (!focused) {
      this._setPressed(false);
    }
  },

  _detectKeyboardFocus: function(focused) {
    this._setReceivedFocusFromKeyboard(!this.pointerDown && focused);
  },

  // to emulate native checkbox, (de-)activations from a user interaction fire
  // 'change' events
  _userActivate: function(active) {
    if (this.active !== active) {
      this.active = active;
      this.fire('change');
    }
  },

  _downHandler: function(event) {
    this._setPointerDown(true);
    this._setPressed(true);
    this._setReceivedFocusFromKeyboard(false);
  },

  _upHandler: function() {
    this._setPointerDown(false);
    this._setPressed(false);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant(/** @type {Node} */(target)))
      return;

    keyboardEvent.preventDefault();
    keyboardEvent.stopImmediatePropagation();
    this._setPressed(true);
  },

  /**
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function(event) {
    var keyboardEvent = event.detail.keyboardEvent;
    var target = Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(keyboardEvent).localTarget;

    // Ignore the event if this is coming from a focused light child, since that
    // element will deal with it.
    if (this.isLightDescendant(/** @type {Node} */(target)))
      return;

    if (this.pressed) {
      this._asyncClick();
    }
    this._setPressed(false);
  },

  // trigger click asynchronously, the asynchrony is useful to allow one
  // event handler to unwind before triggering another event
  _asyncClick: function() {
    this.async(function() {
      this.click();
    }, 1);
  },

  // any of these changes are considered a change to button state

  _pressedChanged: function(pressed) {
    this._changedButtonState();
  },

  _ariaActiveAttributeChanged: function(value, oldValue) {
    if (oldValue && oldValue != value && this.hasAttribute(oldValue)) {
      this.removeAttribute(oldValue);
    }
  },

  _activeChanged: function(active, ariaActiveAttribute) {
    if (this.toggles) {
      this.setAttribute(this.ariaActiveAttribute,
                        active ? 'true' : 'false');
    } else {
      this.removeAttribute(this.ariaActiveAttribute);
    }
    this._changedButtonState();
  },

  _controlStateChanged: function() {
    if (this.disabled) {
      this._setPressed(false);
    } else {
      this._changedButtonState();
    }
  },

  // provide hook for follow-on behaviors to react to button-state

  _changedButtonState: function() {
    if (this._buttonStateChanged) {
      this._buttonStateChanged(); // abstract
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["b"] = IronButtonStateImpl;


const IronButtonState = [
  __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */],
  IronButtonStateImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = IronButtonState;



/***/ }),
/* 31 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["ajax"] = ajax;
/* harmony export (immutable) */ __webpack_exports__["ajaxGet"] = ajaxGet;
/* harmony export (immutable) */ __webpack_exports__["ajaxPost"] = ajaxPost;
/* harmony export (immutable) */ __webpack_exports__["ajaxPut"] = ajaxPut;
function ajax(url, data, method, headers, successCallback, errorCallback) {
  var config = {
    method: method,
    headers: headers
  };

  if (typeof data != "undefined") {
    config.body = JSON.stringify(data);
  }

  fetch(url, config).then(response => {
    if (response.ok) {
      return Promise.resolve(response);
    } else {
      return Promise.reject(new Error('Failed to post data'));
    }
  }).then(response => response.json()) // parse response as JSON
  .then(data => {
    if (typeof successCallback === "function") {
      successCallback(data);
    }
  }).catch(function (error) {
    console.log(`Error: ${error.message}`);

    if (typeof errorCallback === "function") {
      errorCallback(error);
    }
  });
}
function ajaxGet(url, successCallback, errorCallback) {
  var headers = new Headers();
  ajax(url, undefined, "GET", headers, successCallback, errorCallback);
}
function ajaxPost(url, data, successCallback, errorCallback) {
  var headers = new Headers();
  headers.append("Content-Type", "application/json");
  ajax(url, data, "POST", headers, successCallback, errorCallback);
}
function ajaxPut(url, data, successCallback, errorCallback) {
  var headers = new Headers();
  headers.append("Content-Type", "application/json");
  ajax(url, data, "PUT", headers, successCallback, errorCallback);
}

/***/ }),
/* 32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ajax_js__ = __webpack_require__(31);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lit_html__ = __webpack_require__(34);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__stringUtils_js__ = __webpack_require__(35);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_paper_dialog_paper_dialog__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_paper_button_paper_button__ = __webpack_require__(83);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polymer_paper_input_paper_input__ = __webpack_require__(87);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_paper_checkbox_paper_checkbox__ = __webpack_require__(95);








class TactileAuthor extends __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__["a" /* Element */] {
  static get is() {
    return "tactile-author";
  }

  constructor() {
    super();
  }

  static get properties() {
    return {
      path: {
        type: String
      }
    };
  }

  _createInputs(component) {
    var inputs = [];
    component.author.attrs.forEach(input => {
      if (input.type === "String") {
        inputs.push(__WEBPACK_IMPORTED_MODULE_2_lit_html__["a" /* html */]`<paper-input
                name=${input.name}
                label=${input.title}
                value=${component[input.name]}></paper-input>`);
      } else if (input.type === "Boolean") {
        if (component[input.name]) {
          inputs.push(__WEBPACK_IMPORTED_MODULE_2_lit_html__["a" /* html */]`<paper-checkbox name=${input.name} checked>${input.title}</paper-checkbox>`);
        } else {
          inputs.push(__WEBPACK_IMPORTED_MODULE_2_lit_html__["a" /* html */]`<paper-checkbox name=${input.name}>${input.title}</paper-checkbox>`);
        }
      }
    });
    return inputs;
  }

  _createMessage(component) {
    return __WEBPACK_IMPORTED_MODULE_2_lit_html__["a" /* html */]`
      <h2>${component.author.title}</h2>
      <p>${component.author.description}</p>`;
  }

  _createButtons(component) {
    var extraButtons = [];
    component.author.attrs.forEach(input => {
      if (input.type === "Add") {
        var button = __WEBPACK_IMPORTED_MODULE_2_lit_html__["a" /* html */]`<paper-button
                            class="tactile-add"
                            data-path=${input.path}
                            data-template=${JSON.stringify(input.template)}
                            data-comp-type=${input.compType}>
                            ${input.title}
                          </paper-button>`;
        extraButtons.push(button);
      }
    });
    return __WEBPACK_IMPORTED_MODULE_2_lit_html__["a" /* html */]`
      <div class="buttons">
        ${extraButtons}
        <paper-button dialog-dismiss>Decline</paper-button>
        <paper-button dialog-confirm autofocus>Accept</paper-button>
      </div>`;
  }

  openDialog(callback) {
    Object(__WEBPACK_IMPORTED_MODULE_1__ajax_js__["ajaxGet"])(this.path + ".json", component => {
      var shadow = this.shadowRoot;

      if (!this.shadowRoot) {
        shadow = this.attachShadow({
          mode: "open"
        });
      }

      var inputs = this._createInputs(component);

      var message = this._createMessage(component);

      var buttons = this._createButtons(component);

      Object(__WEBPACK_IMPORTED_MODULE_2_lit_html__["b" /* render */])(__WEBPACK_IMPORTED_MODULE_2_lit_html__["a" /* html */]`
        <paper-dialog modal style="min-width: 600px;">
          ${message}
          ${inputs}
          ${buttons}
        </paper-dialog>`, shadow);
      var paperDialog = shadow.querySelector("paper-dialog");
      paperDialog.open();
      paperDialog.querySelector("paper-button").addEventListener("click", e => {
        if (e.target.classList.contains("tactile-add")) {
          var path = this.path + "/" + e.target.dataset.path;
          var template = JSON.parse(e.target.dataset.template);
          Object(__WEBPACK_IMPORTED_MODULE_1__ajax_js__["ajaxPut"])(path, template, callback);
        }
      });

      var ironOverlayClosedHandler = e => {
        // TODO Inspect the input elements for the values to send over a POST
        // API for updating content.json
        if (e.detail.confirmed) {
          var newValues = {};
          shadow.querySelectorAll("paper-input").forEach(input => {
            if (typeof input.value !== "undefined") {
              newValues[input.name] = input.value;
            } else {
              newValues[input.name] = "";
            }
          });
          shadow.querySelectorAll("paper-checkbox").forEach(input => {
            if (typeof input.value !== "undefined") {
              console.log(input.active);
              newValues[input.name] = input.active;
            } else {
              newValues[input.name] = false;
            }
          });
          Object(__WEBPACK_IMPORTED_MODULE_1__ajax_js__["ajaxPost"])(this.path, newValues);
        }

        paperDialog.removeEventListener("iron-overlay-closed", ironOverlayClosedHandler);
        callback();
      };

      paperDialog.addEventListener("iron-overlay-closed", ironOverlayClosedHandler);
    });
  }

}
/* harmony export (immutable) */ __webpack_exports__["default"] = TactileAuthor;
 // Register custom element class with browser

customElements.define(TactileAuthor.is, TactileAuthor);

/***/ }),
/* 33 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = cssFromModules;
/* unused harmony export cssFromModule */
/* harmony export (immutable) */ __webpack_exports__["c"] = cssFromTemplate;
/* harmony export (immutable) */ __webpack_exports__["a"] = cssFromModuleImports;
/* unused harmony export _cssFromModuleImports */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__resolve_url_js__ = __webpack_require__(10);


const MODULE_STYLE_LINK_SELECTOR = 'link[rel=import][type~=css]';
const INCLUDE_ATTR = 'include';

function importModule(moduleId) {
  const /** Polymer.DomModule */ PolymerDomModule = customElements.get('dom-module');
  if (!PolymerDomModule) {
    return null;
  }
  return PolymerDomModule.import(moduleId);
}

/** @typedef {{assetpath: string}} */
let templateWithAssetPath; // eslint-disable-line no-unused-vars

function cssFromModules(moduleIds) {
  let modules = moduleIds.trim().split(/\s+/);
  let cssText = '';
  for (let i=0; i < modules.length; i++) {
    cssText += cssFromModule(modules[i]);
  }
  return cssText;
}

function cssFromModule(moduleId) {
  let m = importModule(moduleId);
  if (m && m._cssText === undefined) {
    // module imports: <link rel="import" type="css">
    let cssText = _cssFromModuleImports(m);
    // include css from the first template in the module
    let t = m.querySelector('template');
    if (t) {
      cssText += cssFromTemplate(t, /** @type {templateWithAssetPath} */(m).assetpath);
    }
    m._cssText = cssText || null;
  }
  if (!m) {
    console.warn('Could not find style data in module named', moduleId);
  }
  return m && m._cssText || '';
}

function cssFromTemplate(template, baseURI) {
  let cssText = '';
  // if element is a template, get content from its .content
  let e$ = template.content.querySelectorAll('style');
  for (let i=0; i < e$.length; i++) {
    let e = e$[i];
    // support style sharing by allowing styles to "include"
    // other dom-modules that contain styling
    let include = e.getAttribute(INCLUDE_ATTR);
    if (include) {
      cssText += cssFromModules(include);
    }
    e.parentNode.removeChild(e);
    cssText += baseURI ?
      Object(__WEBPACK_IMPORTED_MODULE_0__resolve_url_js__["b" /* resolveCss */])(e.textContent, baseURI) : e.textContent;
  }
  return cssText;
}

function cssFromModuleImports(moduleId) {
  let m = importModule(moduleId);
  return m ? _cssFromModuleImports(m) : '';
}

function _cssFromModuleImports(module) {
  let cssText = '';
  let p$ = module.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (let i=0; i < p$.length; i++) {
    let p = p$[i];
    if (p.import) {
      let importDoc = p.import;
      // NOTE: polyfill affordance.
      // under the HTMLImports polyfill, there will be no 'body',
      // but the import pseudo-doc can be used directly.
      let container = importDoc.body ? importDoc.body : importDoc;
      cssText +=
        Object(__WEBPACK_IMPORTED_MODULE_0__resolve_url_js__["b" /* resolveCss */])(container.textContent,
          importDoc.baseURI);
    }
  }
  return cssText;
}


/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = render;
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */
/**
 * TypeScript has a problem with precompiling templates literals
 * https://github.com/Microsoft/TypeScript/issues/17956
 *
 * TODO(justinfagnani): Run tests compiled to ES5 with both Babel and
 * TypeScript to verify correctness.
 */
const envCachesTemplates = ((t) => t() === t())(() => ((s) => s) ``);
// The first argument to JS template tags retain identity across multiple
// calls to a tag for the same literal, so we can cache work done per literal
// in a Map.
const templates = new Map();
const svgTemplates = new Map();
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 */
const html = (strings, ...values) => litTag(strings, values, templates, false);
/* harmony export (immutable) */ __webpack_exports__["a"] = html;

/**
 * Interprets a template literal as an SVG template that can efficiently
 * render to and update a container.
 */
const svg = (strings, ...values) => litTag(strings, values, svgTemplates, true);
/* unused harmony export svg */

function litTag(strings, values, templates, isSvg) {
    const key = envCachesTemplates ?
        strings :
        strings.join('{{--uniqueness-workaround--}}');
    let template = templates.get(key);
    if (template === undefined) {
        template = new Template(strings, isSvg);
        templates.set(key, template);
    }
    return new TemplateResult(template, values);
}
/**
 * The return type of `html`, which holds a Template and the values from
 * interpolated expressions.
 */
class TemplateResult {
    constructor(template, values) {
        this.template = template;
        this.values = values;
    }
}
/* unused harmony export TemplateResult */

/**
 * Renders a template to a container.
 *
 * To update a container with new values, reevaluate the template literal and
 * call `render` with the new result.
 */
function render(result, container, partCallback = defaultPartCallback) {
    let instance = container.__templateInstance;
    // Repeat render, just call update()
    if (instance !== undefined && instance.template === result.template &&
        instance._partCallback === partCallback) {
        instance.update(result.values);
        return;
    }
    // First render, create a new TemplateInstance and append it
    instance = new TemplateInstance(result.template, partCallback);
    container.__templateInstance = instance;
    const fragment = instance._clone();
    instance.update(result.values);
    let child;
    while ((child = container.lastChild)) {
        container.removeChild(child);
    }
    container.appendChild(fragment);
}
/**
 * An expression marker with embedded unique key to avoid
 * https://github.com/PolymerLabs/lit-html/issues/62
 */
const attributeMarker = `{{lit-${Math.random()}}}`;
/**
 * Regex to scan the string preceding an expression to see if we're in a text
 * context, and not an attribute context.
 *
 * This works by seeing if we have a `>` not followed by a `<`. If there is a
 * `<` closer to the end of the strings, then we're inside a tag.
 */
const textRegex = />[^<]*$/;
const hasTagsRegex = /[^<]*/;
const textMarkerContent = '_-lit-html-_';
const textMarker = `<!--${textMarkerContent}-->`;
const attrOrTextRegex = new RegExp(`${attributeMarker}|${textMarker}`);
/**
 * A placeholder for a dynamic expression in an HTML template.
 *
 * There are two built-in part types: AttributePart and NodePart. NodeParts
 * always represent a single dynamic expression, while AttributeParts may
 * represent as many expressions are contained in the attribute.
 *
 * A Template's parts are mutable, so parts can be replaced or modified
 * (possibly to implement different template semantics). The contract is that
 * parts can only be replaced, not removed, added or reordered, and parts must
 * always consume the correct number of values in their `update()` method.
 *
 * TODO(justinfagnani): That requirement is a little fragile. A
 * TemplateInstance could instead be more careful about which values it gives
 * to Part.update().
 */
class TemplatePart {
    constructor(type, index, name, rawName, strings) {
        this.type = type;
        this.index = index;
        this.name = name;
        this.rawName = rawName;
        this.strings = strings;
    }
}
/* unused harmony export TemplatePart */

class Template {
    constructor(strings, svg = false) {
        this.parts = [];
        this.svg = svg;
        this.element = document.createElement('template');
        this.element.innerHTML = this._getHtml(strings, svg);
        // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be null
        const walker = document.createTreeWalker(this.element.content, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT |
               NodeFilter.SHOW_TEXT */, null, false);
        let index = -1;
        let partIndex = 0;
        const nodesToRemove = [];
        // The actual previous node, accounting for removals: if a node is removed
        // it will never be the previousNode.
        let previousNode;
        // Used to set previousNode at the top of the loop.
        let currentNode;
        while (walker.nextNode()) {
            index++;
            previousNode = currentNode;
            const node = currentNode = walker.currentNode;
            if (node.nodeType === 1 /* Node.ELEMENT_NODE */) {
                if (!node.hasAttributes()) {
                    continue;
                }
                const attributes = node.attributes;
                for (let i = 0; i < attributes.length; i++) {
                    const attribute = attributes.item(i);
                    const attributeStrings = attribute.value.split(attrOrTextRegex);
                    if (attributeStrings.length > 1) {
                        // Get the template literal section leading up to the first
                        // expression in this attribute attribute
                        const attributeString = strings[partIndex];
                        // Trim the trailing literal value if this is an interpolation
                        const rawNameString = attributeString.substring(0, attributeString.length - attributeStrings[0].length);
                        // Find the attribute name
                        const rawName = rawNameString.match(/((?:\w|[.\-_$])+)=["']?$/)[1];
                        this.parts.push(new TemplatePart('attribute', index, attribute.name, rawName, attributeStrings));
                        node.removeAttribute(attribute.name);
                        partIndex += attributeStrings.length - 1;
                        i--;
                    }
                }
            }
            else if (node.nodeType === 3 /* Node.TEXT_NODE */) {
                const nodeValue = node.nodeValue;
                const strings = nodeValue.split(attributeMarker);
                if (strings.length > 1) {
                    const parent = node.parentNode;
                    const lastIndex = strings.length - 1;
                    // We have a part for each match found
                    partIndex += lastIndex;
                    // We keep this current node, but reset its content to the last
                    // literal part. We insert new literal nodes before this so that the
                    // tree walker keeps its position correctly.
                    node.textContent = strings[lastIndex];
                    // Generate a new text node for each literal section
                    // These nodes are also used as the markers for node parts
                    for (let i = 0; i < lastIndex; i++) {
                        parent.insertBefore(document.createTextNode(strings[i]), node);
                        this.parts.push(new TemplatePart('node', index++));
                    }
                }
                else {
                    // Strip whitespace-only nodes, only between elements, or at the
                    // beginning or end of elements.
                    const previousSibling = node.previousSibling;
                    const nextSibling = node.nextSibling;
                    if ((previousSibling === null ||
                        previousSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&
                        (nextSibling === null ||
                            nextSibling.nodeType === 1 /* Node.ELEMENT_NODE */) &&
                        nodeValue.trim() === '') {
                        nodesToRemove.push(node);
                        currentNode = previousNode;
                        index--;
                    }
                }
            }
            else if (node.nodeType === 8 /* Node.COMMENT_NODE */ &&
                node.nodeValue === textMarkerContent) {
                const parent = node.parentNode;
                // If we don't have a previous node add a marker node.
                // If the previousSibling is removed, because it's another part
                // placholder, or empty text, add a marker node.
                if (node.previousSibling === null ||
                    node.previousSibling !== previousNode) {
                    parent.insertBefore(new Text(), node);
                }
                else {
                    index--;
                }
                this.parts.push(new TemplatePart('node', index++));
                nodesToRemove.push(node);
                // If we don't have a next node add a marker node.
                // We don't have to check if the next node is going to be removed,
                // because that node will induce a marker if so.
                if (node.nextSibling === null) {
                    parent.insertBefore(new Text(), node);
                }
                else {
                    index--;
                }
                currentNode = previousNode;
                partIndex++;
            }
        }
        // Remove text binding nodes after the walk to not disturb the TreeWalker
        for (const n of nodesToRemove) {
            n.parentNode.removeChild(n);
        }
    }
    /**
     * Returns a string of HTML used to create a <template> element.
     */
    _getHtml(strings, svg) {
        const l = strings.length;
        const a = [];
        let isTextBinding = false;
        for (let i = 0; i < l - 1; i++) {
            const s = strings[i];
            a.push(s);
            // We're in a text position if the previous string matches the
            // textRegex. If it doesn't and the previous string has no tags, then
            // we use the previous text position state.
            isTextBinding = s.match(textRegex) !== null ||
                (s.match(hasTagsRegex) !== null && isTextBinding);
            a.push(isTextBinding ? textMarker : attributeMarker);
        }
        a.push(strings[l - 1]);
        const html = a.join('');
        return svg ? `<svg>${html}</svg>` : html;
    }
}
/* unused harmony export Template */

const getValue = (part, value) => {
    // `null` as the value of a Text node will render the string 'null'
    // so we convert it to undefined
    if (value != null && value.__litDirective === true) {
        value = value(part);
    }
    return value === null ? undefined : value;
};
/* unused harmony export getValue */

const directive = (f) => {
    f.__litDirective = true;
    return f;
};
/* unused harmony export directive */

class AttributePart {
    constructor(instance, element, name, strings) {
        this.instance = instance;
        this.element = element;
        this.name = name;
        this.strings = strings;
        this.size = strings.length - 1;
    }
    setValue(values, startIndex) {
        const strings = this.strings;
        let text = '';
        for (let i = 0; i < strings.length; i++) {
            text += strings[i];
            if (i < strings.length - 1) {
                const v = getValue(this, values[startIndex + i]);
                if (v &&
                    (Array.isArray(v) || typeof v !== 'string' && v[Symbol.iterator])) {
                    for (const t of v) {
                        // TODO: we need to recursively call getValue into iterables...
                        text += t;
                    }
                }
                else {
                    text += v;
                }
            }
        }
        this.element.setAttribute(this.name, text);
    }
}
/* unused harmony export AttributePart */

class NodePart {
    constructor(instance, startNode, endNode) {
        this.instance = instance;
        this.startNode = startNode;
        this.endNode = endNode;
        this._previousValue = undefined;
    }
    setValue(value) {
        value = getValue(this, value);
        if (value === null ||
            !(typeof value === 'object' || typeof value === 'function')) {
            // Handle primitive values
            // If the value didn't change, do nothing
            if (value === this._previousValue) {
                return;
            }
            this._setText(value);
        }
        else if (value instanceof TemplateResult) {
            this._setTemplateResult(value);
        }
        else if (Array.isArray(value) || value[Symbol.iterator]) {
            this._setIterable(value);
        }
        else if (value instanceof Node) {
            this._setNode(value);
        }
        else if (value.then !== undefined) {
            this._setPromise(value);
        }
        else {
            // Fallback, will render the string representation
            this._setText(value);
        }
    }
    _insert(node) {
        this.endNode.parentNode.insertBefore(node, this.endNode);
    }
    _setNode(value) {
        this.clear();
        this._insert(value);
        this._previousValue = value;
    }
    _setText(value) {
        const node = this.startNode.nextSibling;
        if (node === this.endNode.previousSibling &&
            node.nodeType === Node.TEXT_NODE) {
            // If we only have a single text node between the markers, we can just
            // set its value, rather than replacing it.
            // TODO(justinfagnani): Can we just check if _previousValue is
            // primitive?
            node.textContent = value;
        }
        else {
            this._setNode(document.createTextNode(value === undefined ? '' : value));
        }
        this._previousValue = value;
    }
    _setTemplateResult(value) {
        let instance;
        if (this._previousValue &&
            this._previousValue.template === value.template) {
            instance = this._previousValue;
        }
        else {
            instance =
                new TemplateInstance(value.template, this.instance._partCallback);
            this._setNode(instance._clone());
            this._previousValue = instance;
        }
        instance.update(value.values);
    }
    _setIterable(value) {
        // For an Iterable, we create a new InstancePart per item, then set its
        // value to the item. This is a little bit of overhead for every item in
        // an Iterable, but it lets us recurse easily and efficiently update Arrays
        // of TemplateResults that will be commonly returned from expressions like:
        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.
        // If _previousValue is an array, then the previous render was of an
        // iterable and _previousValue will contain the NodeParts from the previous
        // render. If _previousValue is not an array, clear this part and make a new
        // array for NodeParts.
        if (!Array.isArray(this._previousValue)) {
            this.clear();
            this._previousValue = [];
        }
        // Lets us keep track of how many items we stamped so we can clear leftover
        // items from a previous render
        const itemParts = this._previousValue;
        let partIndex = 0;
        for (const item of value) {
            // Try to reuse an existing part
            let itemPart = itemParts[partIndex];
            // If no existing part, create a new one
            if (itemPart === undefined) {
                // If we're creating the first item part, it's startNode should be the
                // container's startNode
                let itemStart = this.startNode;
                // If we're not creating the first part, create a new separator marker
                // node, and fix up the previous part's endNode to point to it
                if (partIndex > 0) {
                    const previousPart = itemParts[partIndex - 1];
                    itemStart = previousPart.endNode = document.createTextNode('');
                    this._insert(itemStart);
                }
                itemPart = new NodePart(this.instance, itemStart, this.endNode);
                itemParts.push(itemPart);
            }
            itemPart.setValue(item);
            partIndex++;
        }
        if (partIndex === 0) {
            this.clear();
            this._previousValue = undefined;
        }
        else if (partIndex < itemParts.length) {
            const lastPart = itemParts[partIndex - 1];
            // Truncate the parts array so _previousValue reflects the current state
            itemParts.length = partIndex;
            this.clear(lastPart.endNode.previousSibling);
            lastPart.endNode = this.endNode;
        }
    }
    _setPromise(value) {
        value.then((v) => {
            if (this._previousValue === value) {
                this.setValue(v);
            }
        });
        this._previousValue = value;
    }
    clear(startNode = this.startNode) {
        let node;
        while ((node = startNode.nextSibling) !== this.endNode) {
            node.parentNode.removeChild(node);
        }
    }
}
/* unused harmony export NodePart */

const defaultPartCallback = (instance, templatePart, node) => {
    if (templatePart.type === 'attribute') {
        return new AttributePart(instance, node, templatePart.name, templatePart.strings);
    }
    else if (templatePart.type === 'node') {
        return new NodePart(instance, node, node.nextSibling);
    }
    throw new Error(`Unknown part type ${templatePart.type}`);
};
/* unused harmony export defaultPartCallback */

/**
 * An instance of a `Template` that can be attached to the DOM and updated
 * with new values.
 */
class TemplateInstance {
    constructor(template, partCallback = defaultPartCallback) {
        this._parts = [];
        this.template = template;
        this._partCallback = partCallback;
    }
    update(values) {
        let valueIndex = 0;
        for (const part of this._parts) {
            if (part.size === undefined) {
                part.setValue(values[valueIndex]);
                valueIndex++;
            }
            else {
                part.setValue(values, valueIndex);
                valueIndex += part.size;
            }
        }
    }
    _clone() {
        const fragment = document.importNode(this.template.element.content, true);
        if (this.template.parts.length > 0) {
            // Edge needs all 4 parameters present; IE11 needs 3rd parameter to be
            // null
            const walker = document.createTreeWalker(fragment, 133 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT */, null, false);
            const parts = this.template.parts;
            let index = 0;
            let partIndex = 0;
            let templatePart = parts[0];
            let node = walker.nextNode();
            while (node != null && partIndex < parts.length) {
                if (index === templatePart.index) {
                    this._parts.push(this._partCallback(this, templatePart, node));
                    templatePart = parts[++partIndex];
                }
                else {
                    index++;
                    node = walker.nextNode();
                }
            }
        }
        if (this.template.svg) {
            const svgElement = fragment.firstChild;
            fragment.removeChild(svgElement);
            const nodes = svgElement.childNodes;
            for (let i = 0; i < nodes.length; i++) {
                fragment.appendChild(nodes.item(i));
            }
        }
        return fragment;
    }
}
/* unused harmony export TemplateInstance */

//# sourceMappingURL=lit-html.js.map

/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["camelCaseToTitle"] = camelCaseToTitle;
function camelCaseToTitle(str) {
  return str.replace(/([A-Z])/g, ' $1').replace(/^./, function (str) {
    return str.toUpperCase();
  });
}

/***/ }),
/* 36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_shadycss_entrypoints_apply_shim_js__ = __webpack_require__(56);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_element_mixin_js__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixins_gesture_event_listeners_js__ = __webpack_require__(41);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_mixin_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_import_href_js__ = __webpack_require__(60);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_render_status_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_unresolved_js__ = __webpack_require__(61);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_unresolved_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__utils_unresolved_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__utils_gestures_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__utils_debounce_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__utils_async_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__utils_path_js__ = __webpack_require__(11);













let styleInterface = window.ShadyCSS;

const LegacyElementMixin = Object(__WEBPACK_IMPORTED_MODULE_3__utils_mixin_js__["a" /* dedupingMixin */])((base) => {

  /**
   * @constructor
   * @extends {base}
   * @implements {Polymer_ElementMixin}
   * @implements {Polymer_GestureEventListeners}
   */
  const legacyElementBase = Object(__WEBPACK_IMPORTED_MODULE_2__mixins_gesture_event_listeners_js__["a" /* GestureEventListeners */])(Object(__WEBPACK_IMPORTED_MODULE_1__mixins_element_mixin_js__["a" /* ElementMixin */])(base));

  /**
   * Map of simple names to touch action names
   * @dict
   */
  const DIRECTION_MAP = {
    'x': 'pan-x',
    'y': 'pan-y',
    'none': 'none',
    'all': 'auto'
  };

  /**
   * @polymer
   * @mixinClass
   * @extends {legacyElementBase}
   * @implements {Polymer_LegacyElementMixin}
   * @unrestricted
   */
  class LegacyElement extends legacyElementBase {

    constructor() {
      super();
      this.root = this;
      /** @type {boolean} */
      this.isAttached;
      /** @type {WeakMap<!Element, !Object<string, !Function>>} */
      this.__boundListeners;
      /** @type {Object<string, Function>} */
      this._debouncers;
      this.created();
    }

    /**
     * Legacy callback called during the `constructor`, for overriding
     * by the user.
     */
    created() {}

    /**
     * Provides an implementation of `connectedCallback`
     * which adds Polymer legacy API's `attached` method.
     * @override
     */
    connectedCallback() {
      super.connectedCallback();
      this.isAttached = true;
      this.attached();
    }

    /**
     * Legacy callback called during `connectedCallback`, for overriding
     * by the user.
     */
    attached() {}

    /**
     * Provides an implementation of `disconnectedCallback`
     * which adds Polymer legacy API's `detached` method.
     * @override
     */
    disconnectedCallback() {
      super.disconnectedCallback();
      this.isAttached = false;
      this.detached();
    }

    /**
     * Legacy callback called during `disconnectedCallback`, for overriding
     * by the user.
     */
    detached() {}

    /**
     * Provides an override implementation of `attributeChangedCallback`
     * which adds the Polymer legacy API's `attributeChanged` method.
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     * @override
     */
    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        super.attributeChangedCallback(name, old, value);
        this.attributeChanged(name, old, value);
      }
    }

    /**
     * Legacy callback called during `attributeChangedChallback`, for overriding
     * by the user.
     * @param {string} name Name of attribute.
     * @param {?string} old Old value of attribute.
     * @param {?string} value Current value of attribute.
     */
    attributeChanged(name, old, value) {} // eslint-disable-line no-unused-vars

    /**
     * Overrides the default `Polymer.PropertyEffects` implementation to
     * add support for class initialization via the `_registered` callback.
     * This is called only when the first instance of the element is created.
     *
     * @override
     */
    _initializeProperties() {
      let proto = Object.getPrototypeOf(this);
      if (!proto.hasOwnProperty('__hasRegisterFinished')) {
        proto.__hasRegisterFinished = true;
        this._registered();
      }
      super._initializeProperties();
    }

    /**
     * Called automatically when an element is initializing.
     * Users may override this method to perform class registration time
     * work. The implementation should ensure the work is performed
     * only once for the class.
     * @protected
     */
    _registered() {}

    /**
     * Overrides the default `Polymer.PropertyEffects` implementation to
     * add support for installing `hostAttributes` and `listeners`.
     *
     * @override
     */
    ready() {
      this._ensureAttributes();
      this._applyListeners();
      super.ready();
    }

    /**
     * Ensures an element has required attributes. Called when the element
     * is being readied via `ready`. Users should override to set the
     * element's required attributes. The implementation should be sure
     * to check and not override existing attributes added by
     * the user of the element. Typically, setting attributes should be left
     * to the element user and not done here; reasonable exceptions include
     * setting aria roles and focusability.
     * @protected
     */
    _ensureAttributes() {}

    /**
     * Adds element event listeners. Called when the element
     * is being readied via `ready`. Users should override to
     * add any required element event listeners.
     * In performance critical elements, the work done here should be kept
     * to a minimum since it is done before the element is rendered. In
     * these elements, consider adding listeners asychronously so as not to
     * block render.
     * @protected
     */
    _applyListeners() {}

    /**
     * Converts a typed JavaScript value to a string.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features. To customize
     * how properties are serialized to attributes for attribute bindings and
     * `reflectToAttribute: true` properties as well as this method, override
     * the `_serializeValue` method provided by `Polymer.PropertyAccessors`.
     *
     * @param {*} value Value to deserialize
     * @return {string | undefined} Serialized value
     */
    serialize(value) {
      return this._serializeValue(value);
    }

    /**
     * Converts a string to a typed JavaScript value.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.  To customize
     * how attributes are deserialized to properties for in
     * `attributeChangedCallback`, override `_deserializeValue` method
     * provided by `Polymer.PropertyAccessors`.
     *
     * @param {string} value String to deserialize
     * @param {*} type Type to deserialize the string to
     * @return {*} Returns the deserialized value in the `type` given.
     */
    deserialize(value, type) {
      return this._deserializeValue(value, type);
    }

    /**
     * Serializes a property to its associated attribute.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect.
     * @param {*=} value Property value to refect.
     */
    reflectPropertyToAttribute(property, attribute, value) {
      this._propertyToAttribute(property, attribute, value);
    }

    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     *
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     * @param {Element} node Element to set attribute to.
     */
    serializeValueToAttribute(value, attribute, node) {
      this._valueToNodeAttribute(/** @type {Element} */ (node || this), value, attribute);
    }

    /**
     * Copies own properties (including accessor descriptors) from a source
     * object to a target object.
     *
     * @param {Object} prototype Target object to copy properties to.
     * @param {Object} api Source object to copy properties from.
     * @return {Object} prototype object that was passed as first argument.
     */
    extend(prototype, api) {
      if (!(prototype && api)) {
        return prototype || api;
      }
      let n$ = Object.getOwnPropertyNames(api);
      for (let i=0, n; (i<n$.length) && (n=n$[i]); i++) {
        let pd = Object.getOwnPropertyDescriptor(api, n);
        if (pd) {
          Object.defineProperty(prototype, n, pd);
        }
      }
      return prototype;
    }

    /**
     * Copies props from a source object to a target object.
     *
     * Note, this method uses a simple `for...in` strategy for enumerating
     * properties.  To ensure only `ownProperties` are copied from source
     * to target and that accessor implementations are copied, use `extend`.
     *
     * @param {Object} target Target object to copy properties to.
     * @param {Object} source Source object to copy properties from.
     * @return {Object} Target object that was passed as first argument.
     */
    mixin(target, source) {
      for (let i in source) {
        target[i] = source[i];
      }
      return target;
    }

    /**
     * Sets the prototype of an object.
     *
     * Note this method is provided as backward-compatible legacy API
     * only.  It is not directly called by any Polymer features.
     * @param {Object} object The object on which to set the prototype.
     * @param {Object} prototype The prototype that will be set on the given
     * `object`.
     * @return {Object} Returns the given `object` with its prototype set
     * to the given `prototype` object.
     */
    chainObject(object, prototype) {
      if (object && prototype && object !== prototype) {
        object.__proto__ = prototype;
      }
      return object;
    }

    /* **** Begin Template **** */

    /**
     * Calls `importNode` on the `content` of the `template` specified and
     * returns a document fragment containing the imported content.
     *
     * @param {HTMLTemplateElement} template HTML template element to instance.
     * @return {DocumentFragment} Document fragment containing the imported
     *   template content.
    */
    instanceTemplate(template) {
      let content = this.constructor._contentForTemplate(template);
      let dom = /** @type {DocumentFragment} */
        (document.importNode(content, true));
      return dom;
    }

    /* **** Begin Events **** */



    /**
     * Dispatches a custom event with an optional detail value.
     *
     * @param {string} type Name of event type.
     * @param {*=} detail Detail value containing event-specific
     *   payload.
     * @param {{ bubbles: (boolean|undefined), cancelable: (boolean|undefined), composed: (boolean|undefined) }=}
     *  options Object specifying options.  These may include:
     *  `bubbles` (boolean, defaults to `true`),
     *  `cancelable` (boolean, defaults to false), and
     *  `node` on which to fire the event (HTMLElement, defaults to `this`).
     * @return {Event} The new event that was fired.
     */
    fire(type, detail, options) {
      options = options || {};
      detail = (detail === null || detail === undefined) ? {} : detail;
      let event = new Event(type, {
        bubbles: options.bubbles === undefined ? true : options.bubbles,
        cancelable: Boolean(options.cancelable),
        composed: options.composed === undefined ? true: options.composed
      });
      event.detail = detail;
      let node = options.node || this;
      node.dispatchEvent(event);
      return event;
    }

    /**
     * Convenience method to add an event listener on a given element,
     * late bound to a named method on this element.
     *
     * @param {Element} node Element to add event listener to.
     * @param {string} eventName Name of event to listen for.
     * @param {string} methodName Name of handler method on `this` to call.
     */
    listen(node, eventName, methodName) {
      node = /** @type {!Element} */ (node || this);
      let hbl = this.__boundListeners ||
        (this.__boundListeners = new WeakMap());
      let bl = hbl.get(node);
      if (!bl) {
        bl = {};
        hbl.set(node, bl);
      }
      let key = eventName + methodName;
      if (!bl[key]) {
        bl[key] = this._addMethodEventListenerToNode(
          node, eventName, methodName, this);
      }
    }

    /**
     * Convenience method to remove an event listener from a given element,
     * late bound to a named method on this element.
     *
     * @param {Element} node Element to remove event listener from.
     * @param {string} eventName Name of event to stop listening to.
     * @param {string} methodName Name of handler method on `this` to not call
     anymore.
     */
    unlisten(node, eventName, methodName) {
      node = /** @type {!Element} */ (node || this);
      let bl = this.__boundListeners && this.__boundListeners.get(node);
      let key = eventName + methodName;
      let handler = bl && bl[key];
      if (handler) {
        this._removeEventListenerFromNode(node, eventName, handler);
        bl[key] = null;
      }
    }

    /**
     * Override scrolling behavior to all direction, one direction, or none.
     *
     * Valid scroll directions:
     *   - 'all': scroll in any direction
     *   - 'x': scroll only in the 'x' direction
     *   - 'y': scroll only in the 'y' direction
     *   - 'none': disable scrolling for this node
     *
     * @param {string=} direction Direction to allow scrolling
     * Defaults to `all`.
     * @param {Element=} node Element to apply scroll direction setting.
     * Defaults to `this`.
     */
    setScrollDirection(direction, node) {
      Object(__WEBPACK_IMPORTED_MODULE_8__utils_gestures_js__["setTouchAction"])( (node || this), DIRECTION_MAP[direction] || 'auto');
    }
    /* **** End Events **** */

    /**
     * Convenience method to run `querySelector` on this local DOM scope.
     *
     * This function calls `Polymer.dom(this.root).querySelector(slctr)`.
     *
     * @param {string} slctr Selector to run on this local DOM scope
     * @return {Element} Element found by the selector, or null if not found.
     */
    $$(slctr) {
      return this.root.querySelector(slctr);
    }

    /**
     * Return the element whose local dom within which this element
     * is contained. This is a shorthand for
     * `this.getRootNode().host`.
     * @this {Element}
     */
    get domHost() {
      let root = this.getRootNode();
      return (root instanceof DocumentFragment) ? /** @type {ShadowRoot} */ (root).host : root;
    }

    /**
     * Force this element to distribute its children to its local dom.
     * This should not be necessary as of Polymer 2.0.2 and is provided only
     * for backwards compatibility.
     */
    distributeContent() {
      if (window.ShadyDOM && this.shadowRoot) {
        ShadyDOM.flush();
      }
    }

    /**
     * Returns a list of nodes that are the effective childNodes. The effective
     * childNodes list is the same as the element's childNodes except that
     * any `<content>` elements are replaced with the list of nodes distributed
     * to the `<content>`, the result of its `getDistributedNodes` method.
     * @this {Element}
     * @return {Array<Node>} List of effctive child nodes.
     */
    getEffectiveChildNodes() {
      return (
        /** @type {Polymer.DomApi} */ (Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["a" /* dom */])(this)).getEffectiveChildNodes()
      );
    }

    /**
     * Returns a list of nodes distributed within this element that match
     * `selector`. These can be dom children or elements distributed to
     * children that are insertion points.
     * @param {string} selector Selector to run.
     * @this {Element}
     * @return {Array<Node>} List of distributed elements that match selector.
     */
    queryDistributedElements(selector) {
      return (
        /** @type {Polymer.DomApi} */ (Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["a" /* dom */])(this)).queryDistributedElements(selector)
      );
    }

    /**
     * Returns a list of elements that are the effective children. The effective
     * children list is the same as the element's children except that
     * any `<content>` elements are replaced with the list of elements
     * distributed to the `<content>`.
     *
     * @return {Array<Node>} List of effctive children.
     */
    getEffectiveChildren() {
      let list = this.getEffectiveChildNodes();
      return list.filter(function(/** @type {Node} */ n) {
        return (n.nodeType === Node.ELEMENT_NODE);
      });
    }

    /**
     * Returns a string of text content that is the concatenation of the
     * text content's of the element's effective childNodes (the elements
     * returned by <a href="#getEffectiveChildNodes>getEffectiveChildNodes</a>.
     *
     * @return {string} List of effctive children.
     */
    getEffectiveTextContent() {
      let cn = this.getEffectiveChildNodes();
      let tc = [];
      for (let i=0, c; (c = cn[i]); i++) {
        if (c.nodeType !== Node.COMMENT_NODE) {
          tc.push(c.textContent);
        }
      }
      return tc.join('');
    }

    /**
     * Returns the first effective childNode within this element that
     * match `selector`. These can be dom child nodes or elements distributed
     * to children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {Object<Node>} First effective child node that matches selector.
     */
    queryEffectiveChildren(selector) {
      let e$ = this.queryDistributedElements(selector);
      return e$ && e$[0];
    }

    /**
     * Returns a list of effective childNodes within this element that
     * match `selector`. These can be dom child nodes or elements distributed
     * to children that are insertion points.
     * @param {string} selector Selector to run.
     * @return {Array<Node>} List of effective child nodes that match selector.
     */
    queryAllEffectiveChildren(selector) {
      return this.queryDistributedElements(selector);
    }

    /**
     * Returns a list of nodes distributed to this element's `<slot>`.
     *
     * If this element contains more than one `<slot>` in its local DOM,
     * an optional selector may be passed to choose the desired content.
     *
     * @param {string=} slctr CSS selector to choose the desired
     *   `<slot>`.  Defaults to `content`.
     * @return {Array<Node>} List of distributed nodes for the `<slot>`.
     */
    getContentChildNodes(slctr) {
      let content = this.root.querySelector(slctr || 'slot');
      return content ? /** @type {Polymer.DomApi} */(Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["a" /* dom */])(content)).getDistributedNodes() : [];
    }

    /**
     * Returns a list of element children distributed to this element's
     * `<slot>`.
     *
     * If this element contains more than one `<slot>` in its
     * local DOM, an optional selector may be passed to choose the desired
     * content.  This method differs from `getContentChildNodes` in that only
     * elements are returned.
     *
     * @param {string=} slctr CSS selector to choose the desired
     *   `<content>`.  Defaults to `content`.
     * @return {Array<HTMLElement>} List of distributed nodes for the
     *   `<slot>`.
     * @suppress {invalidCasts}
     */
    getContentChildren(slctr) {
      return /** @type {Array<HTMLElement>} */(this.getContentChildNodes(slctr).filter(function(n) {
        return (n.nodeType === Node.ELEMENT_NODE);
      }));
    }

    /**
     * Checks whether an element is in this element's light DOM tree.
     *
     * @param {?Node} node The element to be checked.
     * @this {Element}
     * @return {boolean} true if node is in this element's light DOM tree.
     */
    isLightDescendant(node) {
      return this !== node && this.contains(node) &&
          this.getRootNode() === node.getRootNode();
    }

    /**
     * Checks whether an element is in this element's local DOM tree.
     *
     * @param {Element=} node The element to be checked.
     * @return {boolean} true if node is in this element's local DOM tree.
     */
    isLocalDescendant(node) {
      return this.root === node.getRootNode();
    }

    // NOTE: should now be handled by ShadyCss library.
    scopeSubtree(container, shouldObserve) { // eslint-disable-line no-unused-vars
    }

    /**
     * Returns the computed style value for the given property.
     * @param {string} property The css property name.
     * @return {string} Returns the computed css property value for the given
     * `property`.
     */
    getComputedStyleValue(property) {
      return styleInterface.getComputedStyleValue(this, property);
    }

    // debounce

    /**
     * Call `debounce` to collapse multiple requests for a named task into
     * one invocation which is made after the wait time has elapsed with
     * no new request.  If no wait time is given, the callback will be called
     * at microtask timing (guaranteed before paint).
     *
     *     debouncedClickAction(e) {
     *       // will not call `processClick` more than once per 100ms
     *       this.debounce('click', function() {
     *        this.processClick();
     *       } 100);
     *     }
     *
     * @param {string} jobName String to indentify the debounce job.
     * @param {function()} callback Function that is called (with `this`
     *   context) when the wait time elapses.
     * @param {number} wait Optional wait time in milliseconds (ms) after the
     *   last signal that must elapse before invoking `callback`
     * @return {Object} Returns a debouncer object on which exists the
     * following methods: `isActive()` returns true if the debouncer is
     * active; `cancel()` cancels the debouncer if it is active;
     * `flush()` immediately invokes the debounced callback if the debouncer
     * is active.
     */
    debounce(jobName, callback, wait) {
      this._debouncers = this._debouncers || {};
      return this._debouncers[jobName] = __WEBPACK_IMPORTED_MODULE_9__utils_debounce_js__["a" /* Debouncer */].debounce(
            this._debouncers[jobName]
          , wait > 0 ? __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["b" /* timeOut */].after(wait) : __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["a" /* microTask */]
          , callback.bind(this));
    }

    /**
     * Returns whether a named debouncer is active.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     * @return {boolean} Whether the debouncer is active (has not yet fired).
     */
    isDebouncerActive(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      return !!(debouncer && debouncer.isActive());
    }

    /**
     * Immediately calls the debouncer `callback` and inactivates it.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     */
    flushDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.flush();
      }
    }

    /**
     * Cancels an active debouncer.  The `callback` will not be called.
     *
     * @param {string} jobName The name of the debouncer started with `debounce`
     */
    cancelDebouncer(jobName) {
      this._debouncers = this._debouncers || {};
      let debouncer = this._debouncers[jobName];
      if (debouncer) {
        debouncer.cancel();
      }
    }

    /**
     * Runs a callback function asyncronously.
     *
     * By default (if no waitTime is specified), async callbacks are run at
     * microtask timing, which will occur before paint.
     *
     * @param {Function} callback The callback function to run, bound to `this`.
     * @param {number=} waitTime Time to wait before calling the
     *   `callback`.  If unspecified or 0, the callback will be run at microtask
     *   timing (before paint).
     * @return {number} Handle that may be used to cancel the async job.
     */
    async(callback, waitTime) {
      return waitTime > 0 ? __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["b" /* timeOut */].run(callback.bind(this), waitTime) :
          ~__WEBPACK_IMPORTED_MODULE_10__utils_async_js__["a" /* microTask */].run(callback.bind(this));
    }

    /**
     * Cancels an async operation started with `async`.
     *
     * @param {number} handle Handle returned from original `async` call to
     *   cancel.
     */
    cancelAsync(handle) {
      handle < 0 ? __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["a" /* microTask */].cancel(~handle) :
          __WEBPACK_IMPORTED_MODULE_10__utils_async_js__["b" /* timeOut */].cancel(handle);
    }

    // other

    /**
     * Convenience method for creating an element and configuring it.
     *
     * @param {string} tag HTML element tag to create.
     * @param {Object} props Object of properties to configure on the
     *    instance.
     * @return {Element} Newly created and configured element.
     */
    create(tag, props) {
      let elt = document.createElement(tag);
      if (props) {
        if (elt.setProperties) {
          elt.setProperties(props);
        } else {
          for (let n in props) {
            elt[n] = props[n];
          }
        }
      }
      return elt;
    }

    /**
     * Convenience method for importing an HTML document imperatively.
     *
     * This method creates a new `<link rel="import">` element with
     * the provided URL and appends it to the document to start loading.
     * In the `onload` callback, the `import` property of the `link`
     * element will contain the imported document contents.
     *
     * @param {string} href URL to document to load.
     * @param {Function} onload Callback to notify when an import successfully
     *   loaded.
     * @param {Function} onerror Callback to notify when an import
     *   unsuccessfully loaded.
     * @param {boolean} optAsync True if the import should be loaded `async`.
     *   Defaults to `false`.
     * @return {HTMLLinkElement} The link element for the URL to be loaded.
     */
    importHref(href, onload, onerror, optAsync) { // eslint-disable-line no-unused-vars
      let loadFn = onload ? onload.bind(this) : null;
      let errorFn = onerror ? onerror.bind(this) : null;
      return Object(__WEBPACK_IMPORTED_MODULE_4__utils_import_href_js__["a" /* importHref */])(href, loadFn, errorFn, optAsync);
    }

    /**
     * Polyfill for Element.prototype.matches, which is sometimes still
     * prefixed.
     *
     * @param {string} selector Selector to test.
     * @param {Element=} node Element to test the selector against.
     * @return {boolean} Whether the element matches the selector.
     */
    elementMatches(selector, node) {
      return Object(__WEBPACK_IMPORTED_MODULE_7__polymer_dom_js__["c" /* matchesSelector */])( (node || this), selector);
    }

    /**
     * Toggles an HTML attribute on or off.
     *
     * @param {string} name HTML attribute name
     * @param {boolean=} bool Boolean to force the attribute on or off.
     *    When unspecified, the state of the attribute will be reversed.
     * @param {Element=} node Node to target.  Defaults to `this`.
     */
    toggleAttribute(name, bool, node) {
      node = /** @type {Element} */ (node || this);
      if (arguments.length == 1) {
        bool = !node.hasAttribute(name);
      }
      if (bool) {
        node.setAttribute(name, '');
      } else {
        node.removeAttribute(name);
      }
    }


    /**
     * Toggles a CSS class on or off.
     *
     * @param {string} name CSS class name
     * @param {boolean=} bool Boolean to force the class on or off.
     *    When unspecified, the state of the class will be reversed.
     * @param {Element=} node Node to target.  Defaults to `this`.
     */
    toggleClass(name, bool, node) {
      node = /** @type {Element} */ (node || this);
      if (arguments.length == 1) {
        bool = !node.classList.contains(name);
      }
      if (bool) {
        node.classList.add(name);
      } else {
        node.classList.remove(name);
      }
    }

    /**
     * Cross-platform helper for setting an element's CSS `transform` property.
     *
     * @param {string} transformText Transform setting.
     * @param {Element=} node Element to apply the transform to.
     * Defaults to `this`
     */
    transform(transformText, node) {
      node = /** @type {Element} */ (node || this);
      node.style.webkitTransform = transformText;
      node.style.transform = transformText;
    }

    /**
     * Cross-platform helper for setting an element's CSS `translate3d`
     * property.
     *
     * @param {number} x X offset.
     * @param {number} y Y offset.
     * @param {number} z Z offset.
     * @param {Element=} node Element to apply the transform to.
     * Defaults to `this`.
     */
    translate3d(x, y, z, node) {
      node = /** @type {Element} */ (node || this);
      this.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);
    }

    /**
     * Removes an item from an array, if it exists.
     *
     * If the array is specified by path, a change notification is
     * generated, so that observers, data bindings and computed
     * properties watching that path can update.
     *
     * If the array is passed directly, **no change
     * notification is generated**.
     *
     * @param {string | !Array<number|string>} arrayOrPath Path to array from which to remove the item
     *   (or the array itself).
     * @param {*} item Item to remove.
     * @return {Array} Array containing item removed.
     */
    arrayDelete(arrayOrPath, item) {
      let index;
      if (Array.isArray(arrayOrPath)) {
        index = arrayOrPath.indexOf(item);
        if (index >= 0) {
          return arrayOrPath.splice(index, 1);
        }
      } else {
        let arr = Object(__WEBPACK_IMPORTED_MODULE_11__utils_path_js__["a" /* get */])(this, arrayOrPath);
        index = arr.indexOf(item);
        if (index >= 0) {
          return this.splice(arrayOrPath, index, 1);
        }
      }
      return null;
    }

    // logging

    /**
     * Facades `console.log`/`warn`/`error` as override point.
     *
     * @param {string} level One of 'log', 'warn', 'error'
     * @param {Array} args Array of strings or objects to log
     */
    _logger(level, args) {
      // accept ['foo', 'bar'] and [['foo', 'bar']]
      if (Array.isArray(args) && args.length === 1) {
        args = args[0];
      }
      switch(level) {
        case 'log':
        case 'warn':
        case 'error':
          console[level](...args);
      }
    }

    /**
     * Facades `console.log` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     */
    _log(...args) {
      this._logger('log', args);
    }

    /**
     * Facades `console.warn` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     */
    _warn(...args) {
      this._logger('warn', args);
    }

    /**
     * Facades `console.error` as an override point.
     *
     * @param {...*} args Array of strings or objects to log
     */
    _error(...args) {
      this._logger('error', args);
    }

    /**
     * Formats a message using the element type an a method name.
     *
     * @param {string} methodName Method name to associate with message
     * @param {...*} args Array of strings or objects to log
     * @return {Array} Array with formatting information for `console`
     *   logging.
     */
    _logf(methodName, ...args) {
      return ['[%s::%s]', this.is, methodName, ...args];
    }

  }

  LegacyElement.prototype.is = '';

  return LegacyElement;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = LegacyElementMixin;



/***/ }),
/* 37 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["f"] = toCssText;
/* harmony export (immutable) */ __webpack_exports__["e"] = rulesForStyle;
/* unused harmony export isKeyframesSelector */
/* harmony export (immutable) */ __webpack_exports__["a"] = forEachRule;
/* unused harmony export applyCss */
/* unused harmony export createScopeStyle */
/* unused harmony export applyStylePlaceHolder */
/* unused harmony export applyStyle */
/* unused harmony export isTargetedBuild */
/* unused harmony export getCssBuildType */
/* harmony export (immutable) */ __webpack_exports__["d"] = processVariableAndFallback;
/* unused harmony export setElementClassRaw */
/* harmony export (immutable) */ __webpack_exports__["c"] = getIsExtends;
/* harmony export (immutable) */ __webpack_exports__["b"] = gatherStyleText;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_settings_js__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_parse_js__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_regex_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__unscoped_style_handler_js__ = __webpack_require__(58);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/




 // eslint-disable-line no-unused-vars



/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 * @return {string}
 */
function toCssText (rules, callback) {
  if (!rules) {
    return '';
  }
  if (typeof rules === 'string') {
    rules = Object(__WEBPACK_IMPORTED_MODULE_1__css_parse_js__["a" /* parse */])(rules);
  }
  if (callback) {
    forEachRule(rules, callback);
  }
  return Object(__WEBPACK_IMPORTED_MODULE_1__css_parse_js__["b" /* stringify */])(rules, __WEBPACK_IMPORTED_MODULE_0__style_settings_js__["a" /* nativeCssVariables */]);
}

/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */
function rulesForStyle(style) {
  if (!style['__cssRules'] && style.textContent) {
    style['__cssRules'] = Object(__WEBPACK_IMPORTED_MODULE_1__css_parse_js__["a" /* parse */])(style.textContent);
  }
  return style['__cssRules'] || null;
}

// Tests if a rule is a keyframes selector, which looks almost exactly
// like a normal selector but is not (it has nothing to do with scoping
// for example).
/**
 * @param {StyleNode} rule
 * @return {boolean}
 */
function isKeyframesSelector(rule) {
  return Boolean(rule['parent']) &&
  rule['parent']['type'] === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].KEYFRAMES_RULE;
}

/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */
function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }
  let skipRules = false;
  let type = node['type'];
  if (onlyActiveRules) {
    if (type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].MEDIA_RULE) {
      let matchMedia = node['selector'].match(__WEBPACK_IMPORTED_MODULE_2__common_regex_js__["a" /* MEDIA_MATCH */]);
      if (matchMedia) {
        // if rule is a non matching @media rule, skip subrules
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }
  if (type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback &&
    type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === __WEBPACK_IMPORTED_MODULE_1__css_parse_js__["c" /* types */].MIXIN_RULE) {
    skipRules = true;
  }
  let r$ = node['rules'];
  if (r$ && !skipRules) {
    for (let i=0, l=r$.length, r; (i<l) && (r=r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
}

// add a string of cssText to the document.
/**
 * @param {string} cssText
 * @param {string} moniker
 * @param {Node} target
 * @param {Node} contextNode
 * @return {HTMLStyleElement}
 */
function applyCss(cssText, moniker, target, contextNode) {
  let style = createScopeStyle(cssText, moniker);
  applyStyle(style, target, contextNode);
  return style;
}

/**
 * @param {string} cssText
 * @param {string} moniker
 * @return {HTMLStyleElement}
 */
function createScopeStyle(cssText, moniker) {
  let style = /** @type {HTMLStyleElement} */(document.createElement('style'));
  if (moniker) {
    style.setAttribute('scope', moniker);
  }
  style.textContent = cssText;
  return style;
}

/**
 * Track the position of the last added style for placing placeholders
 * @type {Node}
 */
let lastHeadApplyNode = null;

// insert a comment node as a styling position placeholder.
/**
 * @param {string} moniker
 * @return {!Comment}
 */
function applyStylePlaceHolder(moniker) {
  let placeHolder = document.createComment(' Shady DOM styles for ' +
    moniker + ' ');
  let after = lastHeadApplyNode ?
    lastHeadApplyNode['nextSibling'] : null;
  let scope = document.head;
  scope.insertBefore(placeHolder, after || scope.firstChild);
  lastHeadApplyNode = placeHolder;
  return placeHolder;
}

/**
 * @param {HTMLStyleElement} style
 * @param {?Node} target
 * @param {?Node} contextNode
 */
function applyStyle(style, target, contextNode) {
  target = target || document.head;
  let after = (contextNode && contextNode.nextSibling) ||
    target.firstChild;
  target.insertBefore(style, after);
  if (!lastHeadApplyNode) {
    lastHeadApplyNode = style;
  } else {
    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode
    let position = style.compareDocumentPosition(lastHeadApplyNode);
    if (position === Node.DOCUMENT_POSITION_PRECEDING) {
      lastHeadApplyNode = style;
    }
  }
}

/**
 * @param {string} buildType
 * @return {boolean}
 */
function isTargetedBuild(buildType) {
  return __WEBPACK_IMPORTED_MODULE_0__style_settings_js__["b" /* nativeShadow */] ? buildType === 'shadow' : buildType === 'shady';
}

/**
 * @param {Element} element
 * @return {?string}
 */
function getCssBuildType(element) {
  return element.getAttribute('css-build');
}

/**
 * Walk from text[start] matching parens and
 * returns position of the outer end paren
 * @param {string} text
 * @param {number} start
 * @return {number}
 */
function findMatchingParen(text, start) {
  let level = 0;
  for (let i=start, l=text.length; i < l; i++) {
    if (text[i] === '(') {
      level++;
    } else if (text[i] === ')') {
      if (--level === 0) {
        return i;
      }
    }
  }
  return -1;
}

/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */
function processVariableAndFallback(str, callback) {
  // find 'var('
  let start = str.indexOf('var(');
  if (start === -1) {
    // no var?, everything is prefix
    return callback(str, '', '', '');
  }
  //${prefix}var(${inner})${suffix}
  let end = findMatchingParen(str, start + 3);
  let inner = str.substring(start + 4, end);
  let prefix = str.substring(0, start);
  // suffix may have other variables
  let suffix = processVariableAndFallback(str.substring(end + 1), callback);
  let comma = inner.indexOf(',');
  // value and fallback args should be trimmed to match in property lookup
  if (comma === -1) {
    // variable, no fallback
    return callback(prefix, inner.trim(), '', suffix);
  }
  // var(${value},${fallback})
  let value = inner.substring(0, comma).trim();
  let fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}

/**
 * @param {Element} element
 * @param {string} value
 */
function setElementClassRaw(element, value) {
  // use native setAttribute provided by ShadyDOM when setAttribute is patched
  if (__WEBPACK_IMPORTED_MODULE_0__style_settings_js__["b" /* nativeShadow */]) {
    element.setAttribute('class', value);
  } else {
    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);
  }
}

/**
 * @param {Element | {is: string, extends: string}} element
 * @return {{is: string, typeExtension: string}}
 */
function getIsExtends(element) {
  let localName = element['localName'];
  let is = '', typeExtension = '';
  /*
  NOTE: technically, this can be wrong for certain svg elements
  with `-` in the name like `<font-face>`
  */
  if (localName) {
    if (localName.indexOf('-') > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = (element.getAttribute && element.getAttribute('is')) || '';
    }
  } else {
    is = /** @type {?} */(element).is;
    typeExtension = /** @type {?} */(element).extends;
  }
  return {is, typeExtension};
}

/**
 * @param {Element|DocumentFragment} element
 * @return {string}
 */
function gatherStyleText(element) {
  /** @type {!Array<string>} */
  const styleTextParts = [];
  const styles = /** @type {!NodeList<!HTMLStyleElement>} */(element.querySelectorAll('style'));
  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];
    if (Object(__WEBPACK_IMPORTED_MODULE_3__unscoped_style_handler_js__["a" /* isUnscopedStyle */])(style)) {
      if (!__WEBPACK_IMPORTED_MODULE_0__style_settings_js__["b" /* nativeShadow */]) {
        Object(__WEBPACK_IMPORTED_MODULE_3__unscoped_style_handler_js__["b" /* processUnscopedStyle */])(style);
        style.parentNode.removeChild(style);
      }
    } else {
      styleTextParts.push(style.textContent);
      style.parentNode.removeChild(style);
    }
  }
  return styleTextParts.join('').trim();
}

/***/ }),
/* 38 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * @const {!Object<string, !HTMLTemplateElement>}
 */
const templateMap = {};
/* harmony default export */ __webpack_exports__["a"] = (templateMap);


/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = documentWait;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/** @type {Promise<void>} */
let readyPromise = null;

/** @type {?function(?function())} */
let whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;

/** @type {function()} */
let resolveFn;

/**
 * @param {?function()} callback
 */
function documentWait(callback) {
  requestAnimationFrame(function() {
    if (whenReady) {
      whenReady(callback)
    } else {
      if (!readyPromise) {
        readyPromise = new Promise((resolve) => {resolveFn = resolve});
        if (document.readyState === 'complete') {
          resolveFn();
        } else {
          document.addEventListener('readystatechange', () => {
            if (document.readyState === 'complete') {
              resolveFn();
            }
          });
        }
      }
      readyPromise.then(function(){ callback && callback(); });
    }
  });
}


/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CustomStyleProvider */
/* unused harmony export CustomStyleInterfaceInterface */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__document_wait_js__ = __webpack_require__(39);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/





/**
 * @typedef {HTMLStyleElement | {getStyle: function():HTMLStyleElement}}
 */
let CustomStyleProvider;

const SEEN_MARKER = '__seenByShadyCSS';
const CACHED_STYLE = '__shadyCSSCachedStyle';

/** @type {?function(!HTMLStyleElement)} */
let transformFn = null;

/** @type {?function()} */
let validateFn = null;

/**
This interface is provided to add document-level <style> elements to ShadyCSS for processing.
These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties

To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`

In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
This function will be called when calculating styles.

An example usage of the document-level styling api can be found in `examples/document-style-lib.js`

@unrestricted
*/
class CustomStyleInterface {
  constructor() {
    /** @type {!Array<!CustomStyleProvider>} */
    this['customStyles'] = [];
    this['enqueued'] = false;
  }
  /**
   * Queue a validation for new custom styles to batch style recalculations
   */
  enqueueDocumentValidation() {
    if (this['enqueued'] || !validateFn) {
      return;
    }
    this['enqueued'] = true;
    Object(__WEBPACK_IMPORTED_MODULE_0__document_wait_js__["a" /* default */])(validateFn);
  }
  /**
   * @param {!HTMLStyleElement} style
   */
  addCustomStyle(style) {
    if (!style[SEEN_MARKER]) {
      style[SEEN_MARKER] = true;
      this['customStyles'].push(style);
      this.enqueueDocumentValidation();
    }
  }
  /**
   * @param {!CustomStyleProvider} customStyle
   * @return {HTMLStyleElement}
   */
  getStyleForCustomStyle(customStyle) {
    if (customStyle[CACHED_STYLE]) {
      return customStyle[CACHED_STYLE];
    }
    let style;
    if (customStyle['getStyle']) {
      style = customStyle['getStyle']();
    } else {
      style = customStyle;
    }
    return style;
  }
  /**
   * @return {!Array<!CustomStyleProvider>}
   */
  processStyles() {
    const cs = this['customStyles'];
    for (let i = 0; i < cs.length; i++) {
      const customStyle = cs[i];
      if (customStyle[CACHED_STYLE]) {
        continue;
      }
      const style = this.getStyleForCustomStyle(customStyle);
      if (style) {
        // HTMLImports polyfill may have cloned the style into the main document,
        // which is referenced with __appliedElement.
        const styleToTransform = /** @type {!HTMLStyleElement} */(style['__appliedElement'] || style);
        if (transformFn) {
          transformFn(styleToTransform);
        }
        customStyle[CACHED_STYLE] = styleToTransform;
      }
    }
    return cs;
  }
}
/* harmony export (immutable) */ __webpack_exports__["a"] = CustomStyleInterface;


CustomStyleInterface.prototype['addCustomStyle'] = CustomStyleInterface.prototype.addCustomStyle;
CustomStyleInterface.prototype['getStyleForCustomStyle'] = CustomStyleInterface.prototype.getStyleForCustomStyle;
CustomStyleInterface.prototype['processStyles'] = CustomStyleInterface.prototype.processStyles;

Object.defineProperties(CustomStyleInterface.prototype, {
  'transformCallback': {
    /** @return {?function(!HTMLStyleElement)} */
    get() {
      return transformFn;
    },
    /** @param {?function(!HTMLStyleElement)} fn */
    set(fn) {
      transformFn = fn;
    }
  },
  'validateCallback': {
    /** @return {?function()} */
    get() {
      return validateFn;
    },
    /**
     * @param {?function()} fn
     * @this {CustomStyleInterface}
     */
    set(fn) {
      let needsEnqueue = false;
      if (!validateFn) {
        needsEnqueue = true;
      }
      validateFn = fn;
      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    },
  }
})

/** @typedef {{
 * customStyles: !Array<!CustomStyleProvider>,
 * addCustomStyle: function(!CustomStyleProvider),
 * getStyleForCustomStyle: function(!CustomStyleProvider): HTMLStyleElement,
 * findStyles: function(),
 * transformCallback: ?function(!HTMLStyleElement),
 * validateCallback: ?function()
 * }}
 */
let CustomStyleInterfaceInterface;


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_gestures_js__ = __webpack_require__(12);




/**
 * @const {Polymer.Gestures}
 */
const gestures = __WEBPACK_IMPORTED_MODULE_2__utils_gestures_js__;

const GestureEventListeners = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_GestureEventListeners}
   */
  class GestureEventListeners extends superClass {

    _addEventListenerToNode(node, eventName, handler) {
      if (!gestures.addListener(node, eventName, handler)) {
        super._addEventListenerToNode(node, eventName, handler);
      }
    }

    _removeEventListenerFromNode(node, eventName, handler) {
      if (!gestures.removeListener(node, eventName, handler)) {
        super._removeEventListenerFromNode(node, eventName, handler);
      }
    }

  }

  return GestureEventListeners;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = GestureEventListeners;



/***/ }),
/* 42 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return calculateSplices; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3;

// Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.
function calcEditDistances(current, currentStart, currentEnd,
                            old, oldStart, oldEnd) {
  // "Deletion" columns
  let rowCount = oldEnd - oldStart + 1;
  let columnCount = currentEnd - currentStart + 1;
  let distances = new Array(rowCount);

  // "Addition" rows. Initialize null column.
  for (let i = 0; i < rowCount; i++) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  }

  // Initialize null row
  for (let j = 0; j < columnCount; j++)
    distances[0][j] = j;

  for (let i = 1; i < rowCount; i++) {
    for (let j = 1; j < columnCount; j++) {
      if (equals(current[currentStart + j - 1], old[oldStart + i - 1]))
        distances[i][j] = distances[i - 1][j - 1];
      else {
        let north = distances[i - 1][j] + 1;
        let west = distances[i][j - 1] + 1;
        distances[i][j] = north < west ? north : west;
      }
    }
  }

  return distances;
}

// This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.
function spliceOperationsFromEditDistances(distances) {
  let i = distances.length - 1;
  let j = distances[0].length - 1;
  let current = distances[i][j];
  let edits = [];
  while (i > 0 || j > 0) {
    if (i == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }
    if (j == 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }
    let northWest = distances[i - 1][j - 1];
    let west = distances[i - 1][j];
    let north = distances[i][j - 1];

    let min;
    if (west < north)
      min = west < northWest ? west : northWest;
    else
      min = north < northWest ? north : northWest;

    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }
      i--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }

  edits.reverse();
  return edits;
}

/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */

/**
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 *
 * @param {Array} current The current "changed" array for which to
 * calculate splices.
 * @param {number} currentStart Starting index in the `current` array for
 * which splices are calculated.
 * @param {number} currentEnd Ending index in the `current` array for
 * which splices are calculated.
 * @param {Array} old The original "unchanged" array to compare `current`
 * against to determine splices.
 * @param {number} oldStart Starting index in the `old` array for
 * which splices are calculated.
 * @param {number} oldEnd Ending index in the `old` array for
 * which splices are calculated.
 * @return {Array} Returns an array of splice record objects. Each of these
 * contains: `index` the location where the splice occurred; `removed`
 * the array of removed items from this location; `addedCount` the number
 * of items added at this location.
 */
function calcSplices(current, currentStart, currentEnd,
                      old, oldStart, oldEnd) {
  let prefixCount = 0;
  let suffixCount = 0;
  let splice;

  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0)
    prefixCount = sharedPrefix(current, old, minLength);

  if (currentEnd == current.length && oldEnd == old.length)
    suffixCount = sharedSuffix(current, old, minLength - prefixCount);

  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;

  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)
    return [];

  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);
    while (oldStart < oldEnd)
      splice.removed.push(old[oldStart++]);

    return [ splice ];
  } else if (oldStart == oldEnd)
    return [ newSplice(currentStart, [], currentEnd - currentStart) ];

  let ops = spliceOperationsFromEditDistances(
      calcEditDistances(current, currentStart, currentEnd,
                             old, oldStart, oldEnd));

  splice = undefined;
  let splices = [];
  let index = currentStart;
  let oldIndex = oldStart;
  for (let i = 0; i < ops.length; i++) {
    switch(ops[i]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = undefined;
        }

        index++;
        oldIndex++;
        break;
      case EDIT_UPDATE:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
      case EDIT_ADD:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.addedCount++;
        index++;
        break;
      case EDIT_DELETE:
        if (!splice)
          splice = newSplice(index, [], 0);

        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }

  if (splice) {
    splices.push(splice);
  }
  return splices;
}

function sharedPrefix(current, old, searchLength) {
  for (let i = 0; i < searchLength; i++)
    if (!equals(current[i], old[i]))
      return i;
  return searchLength;
}

function sharedSuffix(current, old, searchLength) {
  let index1 = current.length;
  let index2 = old.length;
  let count = 0;
  while (count < searchLength && equals(current[--index1], old[--index2]))
    count++;

  return count;
}

function calculateSplices(current, previous) {
  return calcSplices(current, 0, current.length, previous, 0,
                          previous.length);
}

function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}




/***/ }),
/* 43 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      /* Material Design color palette for Google products */

      --google-red-100: #f4c7c3;
      --google-red-300: #e67c73;
      --google-red-500: #db4437;
      --google-red-700: #c53929;

      --google-blue-100: #c6dafc;
      --google-blue-300: #7baaf7;
      --google-blue-500: #4285f4;
      --google-blue-700: #3367d6;

      --google-green-100: #b7e1cd;
      --google-green-300: #57bb8a;
      --google-green-500: #0f9d58;
      --google-green-700: #0b8043;

      --google-yellow-100: #fce8b2;
      --google-yellow-300: #f7cb4d;
      --google-yellow-500: #f4b400;
      --google-yellow-700: #f09300;

      --google-grey-100: #f5f5f5;
      --google-grey-300: #e0e0e0;
      --google-grey-500: #9e9e9e;
      --google-grey-700: #616161;

      /* Material Design color palette from online spec document */

      --paper-red-50: #ffebee;
      --paper-red-100: #ffcdd2;
      --paper-red-200: #ef9a9a;
      --paper-red-300: #e57373;
      --paper-red-400: #ef5350;
      --paper-red-500: #f44336;
      --paper-red-600: #e53935;
      --paper-red-700: #d32f2f;
      --paper-red-800: #c62828;
      --paper-red-900: #b71c1c;
      --paper-red-a100: #ff8a80;
      --paper-red-a200: #ff5252;
      --paper-red-a400: #ff1744;
      --paper-red-a700: #d50000;

      --paper-pink-50: #fce4ec;
      --paper-pink-100: #f8bbd0;
      --paper-pink-200: #f48fb1;
      --paper-pink-300: #f06292;
      --paper-pink-400: #ec407a;
      --paper-pink-500: #e91e63;
      --paper-pink-600: #d81b60;
      --paper-pink-700: #c2185b;
      --paper-pink-800: #ad1457;
      --paper-pink-900: #880e4f;
      --paper-pink-a100: #ff80ab;
      --paper-pink-a200: #ff4081;
      --paper-pink-a400: #f50057;
      --paper-pink-a700: #c51162;

      --paper-purple-50: #f3e5f5;
      --paper-purple-100: #e1bee7;
      --paper-purple-200: #ce93d8;
      --paper-purple-300: #ba68c8;
      --paper-purple-400: #ab47bc;
      --paper-purple-500: #9c27b0;
      --paper-purple-600: #8e24aa;
      --paper-purple-700: #7b1fa2;
      --paper-purple-800: #6a1b9a;
      --paper-purple-900: #4a148c;
      --paper-purple-a100: #ea80fc;
      --paper-purple-a200: #e040fb;
      --paper-purple-a400: #d500f9;
      --paper-purple-a700: #aa00ff;

      --paper-deep-purple-50: #ede7f6;
      --paper-deep-purple-100: #d1c4e9;
      --paper-deep-purple-200: #b39ddb;
      --paper-deep-purple-300: #9575cd;
      --paper-deep-purple-400: #7e57c2;
      --paper-deep-purple-500: #673ab7;
      --paper-deep-purple-600: #5e35b1;
      --paper-deep-purple-700: #512da8;
      --paper-deep-purple-800: #4527a0;
      --paper-deep-purple-900: #311b92;
      --paper-deep-purple-a100: #b388ff;
      --paper-deep-purple-a200: #7c4dff;
      --paper-deep-purple-a400: #651fff;
      --paper-deep-purple-a700: #6200ea;

      --paper-indigo-50: #e8eaf6;
      --paper-indigo-100: #c5cae9;
      --paper-indigo-200: #9fa8da;
      --paper-indigo-300: #7986cb;
      --paper-indigo-400: #5c6bc0;
      --paper-indigo-500: #3f51b5;
      --paper-indigo-600: #3949ab;
      --paper-indigo-700: #303f9f;
      --paper-indigo-800: #283593;
      --paper-indigo-900: #1a237e;
      --paper-indigo-a100: #8c9eff;
      --paper-indigo-a200: #536dfe;
      --paper-indigo-a400: #3d5afe;
      --paper-indigo-a700: #304ffe;

      --paper-blue-50: #e3f2fd;
      --paper-blue-100: #bbdefb;
      --paper-blue-200: #90caf9;
      --paper-blue-300: #64b5f6;
      --paper-blue-400: #42a5f5;
      --paper-blue-500: #2196f3;
      --paper-blue-600: #1e88e5;
      --paper-blue-700: #1976d2;
      --paper-blue-800: #1565c0;
      --paper-blue-900: #0d47a1;
      --paper-blue-a100: #82b1ff;
      --paper-blue-a200: #448aff;
      --paper-blue-a400: #2979ff;
      --paper-blue-a700: #2962ff;

      --paper-light-blue-50: #e1f5fe;
      --paper-light-blue-100: #b3e5fc;
      --paper-light-blue-200: #81d4fa;
      --paper-light-blue-300: #4fc3f7;
      --paper-light-blue-400: #29b6f6;
      --paper-light-blue-500: #03a9f4;
      --paper-light-blue-600: #039be5;
      --paper-light-blue-700: #0288d1;
      --paper-light-blue-800: #0277bd;
      --paper-light-blue-900: #01579b;
      --paper-light-blue-a100: #80d8ff;
      --paper-light-blue-a200: #40c4ff;
      --paper-light-blue-a400: #00b0ff;
      --paper-light-blue-a700: #0091ea;

      --paper-cyan-50: #e0f7fa;
      --paper-cyan-100: #b2ebf2;
      --paper-cyan-200: #80deea;
      --paper-cyan-300: #4dd0e1;
      --paper-cyan-400: #26c6da;
      --paper-cyan-500: #00bcd4;
      --paper-cyan-600: #00acc1;
      --paper-cyan-700: #0097a7;
      --paper-cyan-800: #00838f;
      --paper-cyan-900: #006064;
      --paper-cyan-a100: #84ffff;
      --paper-cyan-a200: #18ffff;
      --paper-cyan-a400: #00e5ff;
      --paper-cyan-a700: #00b8d4;

      --paper-teal-50: #e0f2f1;
      --paper-teal-100: #b2dfdb;
      --paper-teal-200: #80cbc4;
      --paper-teal-300: #4db6ac;
      --paper-teal-400: #26a69a;
      --paper-teal-500: #009688;
      --paper-teal-600: #00897b;
      --paper-teal-700: #00796b;
      --paper-teal-800: #00695c;
      --paper-teal-900: #004d40;
      --paper-teal-a100: #a7ffeb;
      --paper-teal-a200: #64ffda;
      --paper-teal-a400: #1de9b6;
      --paper-teal-a700: #00bfa5;

      --paper-green-50: #e8f5e9;
      --paper-green-100: #c8e6c9;
      --paper-green-200: #a5d6a7;
      --paper-green-300: #81c784;
      --paper-green-400: #66bb6a;
      --paper-green-500: #4caf50;
      --paper-green-600: #43a047;
      --paper-green-700: #388e3c;
      --paper-green-800: #2e7d32;
      --paper-green-900: #1b5e20;
      --paper-green-a100: #b9f6ca;
      --paper-green-a200: #69f0ae;
      --paper-green-a400: #00e676;
      --paper-green-a700: #00c853;

      --paper-light-green-50: #f1f8e9;
      --paper-light-green-100: #dcedc8;
      --paper-light-green-200: #c5e1a5;
      --paper-light-green-300: #aed581;
      --paper-light-green-400: #9ccc65;
      --paper-light-green-500: #8bc34a;
      --paper-light-green-600: #7cb342;
      --paper-light-green-700: #689f38;
      --paper-light-green-800: #558b2f;
      --paper-light-green-900: #33691e;
      --paper-light-green-a100: #ccff90;
      --paper-light-green-a200: #b2ff59;
      --paper-light-green-a400: #76ff03;
      --paper-light-green-a700: #64dd17;

      --paper-lime-50: #f9fbe7;
      --paper-lime-100: #f0f4c3;
      --paper-lime-200: #e6ee9c;
      --paper-lime-300: #dce775;
      --paper-lime-400: #d4e157;
      --paper-lime-500: #cddc39;
      --paper-lime-600: #c0ca33;
      --paper-lime-700: #afb42b;
      --paper-lime-800: #9e9d24;
      --paper-lime-900: #827717;
      --paper-lime-a100: #f4ff81;
      --paper-lime-a200: #eeff41;
      --paper-lime-a400: #c6ff00;
      --paper-lime-a700: #aeea00;

      --paper-yellow-50: #fffde7;
      --paper-yellow-100: #fff9c4;
      --paper-yellow-200: #fff59d;
      --paper-yellow-300: #fff176;
      --paper-yellow-400: #ffee58;
      --paper-yellow-500: #ffeb3b;
      --paper-yellow-600: #fdd835;
      --paper-yellow-700: #fbc02d;
      --paper-yellow-800: #f9a825;
      --paper-yellow-900: #f57f17;
      --paper-yellow-a100: #ffff8d;
      --paper-yellow-a200: #ffff00;
      --paper-yellow-a400: #ffea00;
      --paper-yellow-a700: #ffd600;

      --paper-amber-50: #fff8e1;
      --paper-amber-100: #ffecb3;
      --paper-amber-200: #ffe082;
      --paper-amber-300: #ffd54f;
      --paper-amber-400: #ffca28;
      --paper-amber-500: #ffc107;
      --paper-amber-600: #ffb300;
      --paper-amber-700: #ffa000;
      --paper-amber-800: #ff8f00;
      --paper-amber-900: #ff6f00;
      --paper-amber-a100: #ffe57f;
      --paper-amber-a200: #ffd740;
      --paper-amber-a400: #ffc400;
      --paper-amber-a700: #ffab00;

      --paper-orange-50: #fff3e0;
      --paper-orange-100: #ffe0b2;
      --paper-orange-200: #ffcc80;
      --paper-orange-300: #ffb74d;
      --paper-orange-400: #ffa726;
      --paper-orange-500: #ff9800;
      --paper-orange-600: #fb8c00;
      --paper-orange-700: #f57c00;
      --paper-orange-800: #ef6c00;
      --paper-orange-900: #e65100;
      --paper-orange-a100: #ffd180;
      --paper-orange-a200: #ffab40;
      --paper-orange-a400: #ff9100;
      --paper-orange-a700: #ff6500;

      --paper-deep-orange-50: #fbe9e7;
      --paper-deep-orange-100: #ffccbc;
      --paper-deep-orange-200: #ffab91;
      --paper-deep-orange-300: #ff8a65;
      --paper-deep-orange-400: #ff7043;
      --paper-deep-orange-500: #ff5722;
      --paper-deep-orange-600: #f4511e;
      --paper-deep-orange-700: #e64a19;
      --paper-deep-orange-800: #d84315;
      --paper-deep-orange-900: #bf360c;
      --paper-deep-orange-a100: #ff9e80;
      --paper-deep-orange-a200: #ff6e40;
      --paper-deep-orange-a400: #ff3d00;
      --paper-deep-orange-a700: #dd2c00;

      --paper-brown-50: #efebe9;
      --paper-brown-100: #d7ccc8;
      --paper-brown-200: #bcaaa4;
      --paper-brown-300: #a1887f;
      --paper-brown-400: #8d6e63;
      --paper-brown-500: #795548;
      --paper-brown-600: #6d4c41;
      --paper-brown-700: #5d4037;
      --paper-brown-800: #4e342e;
      --paper-brown-900: #3e2723;

      --paper-grey-50: #fafafa;
      --paper-grey-100: #f5f5f5;
      --paper-grey-200: #eeeeee;
      --paper-grey-300: #e0e0e0;
      --paper-grey-400: #bdbdbd;
      --paper-grey-500: #9e9e9e;
      --paper-grey-600: #757575;
      --paper-grey-700: #616161;
      --paper-grey-800: #424242;
      --paper-grey-900: #212121;

      --paper-blue-grey-50: #eceff1;
      --paper-blue-grey-100: #cfd8dc;
      --paper-blue-grey-200: #b0bec5;
      --paper-blue-grey-300: #90a4ae;
      --paper-blue-grey-400: #78909c;
      --paper-blue-grey-500: #607d8b;
      --paper-blue-grey-600: #546e7a;
      --paper-blue-grey-700: #455a64;
      --paper-blue-grey-800: #37474f;
      --paper-blue-grey-900: #263238;

      /* opacity for dark text on a light background */
      --dark-divider-opacity: 0.12;
      --dark-disabled-opacity: 0.38; /* or hint text or icon */
      --dark-secondary-opacity: 0.54;
      --dark-primary-opacity: 0.87;

      /* opacity for light text on a dark background */
      --light-divider-opacity: 0.12;
      --light-disabled-opacity: 0.3; /* or hint text or icon */
      --light-secondary-opacity: 0.7;
      --light-primary-opacity: 1.0;

    }

  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 44 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<custom-style>
  <style is="custom-style">
    html {

      --shadow-transition: {
        transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
      };

      --shadow-none: {
        box-shadow: none;
      };

      /* from http://codepen.io/shyndman/pen/c5394ddf2e8b2a5c9185904b57421cdb */

      --shadow-elevation-2dp: {
        box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                    0 1px 5px 0 rgba(0, 0, 0, 0.12),
                    0 3px 1px -2px rgba(0, 0, 0, 0.2);
      };

      --shadow-elevation-3dp: {
        box-shadow: 0 3px 4px 0 rgba(0, 0, 0, 0.14),
                    0 1px 8px 0 rgba(0, 0, 0, 0.12),
                    0 3px 3px -2px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-4dp: {
        box-shadow: 0 4px 5px 0 rgba(0, 0, 0, 0.14),
                    0 1px 10px 0 rgba(0, 0, 0, 0.12),
                    0 2px 4px -1px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-6dp: {
        box-shadow: 0 6px 10px 0 rgba(0, 0, 0, 0.14),
                    0 1px 18px 0 rgba(0, 0, 0, 0.12),
                    0 3px 5px -1px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-8dp: {
        box-shadow: 0 8px 10px 1px rgba(0, 0, 0, 0.14),
                    0 3px 14px 2px rgba(0, 0, 0, 0.12),
                    0 5px 5px -3px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-12dp: {
        box-shadow: 0 12px 16px 1px rgba(0, 0, 0, 0.14),
                    0 4px 22px 3px rgba(0, 0, 0, 0.12),
                    0 6px 7px -4px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-16dp: {
        box-shadow: 0 16px 24px 2px rgba(0, 0, 0, 0.14),
                    0  6px 30px 5px rgba(0, 0, 0, 0.12),
                    0  8px 10px -5px rgba(0, 0, 0, 0.4);
      };

      --shadow-elevation-24dp: {
        box-shadow: 0 24px 38px 3px rgba(0, 0, 0, 0.14),
                    0 9px 46px 8px rgba(0, 0, 0, 0.12),
                    0 11px 15px -7px rgba(0, 0, 0, 0.4);
      };
    }
  </style>
</custom-style>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__ = __webpack_require__(4);



const IronFormElementBehavior = {

  properties: {
    /**
     * Fired when the element is added to an `iron-form`.
     *
     * @event iron-form-element-register
     */

    /**
     * Fired when the element is removed from an `iron-form`.
     *
     * @event iron-form-element-unregister
     */
     
    /**
     * The name of this element.
     */
    name: {
      type: String
    },

    /**
     * The value for this element.
     */
    value: {
      notify: true,
      type: String
    },

    /**
     * Set to true to mark the input as required. If used in a form, a
     * custom element that uses this behavior should also use
     * Polymer.IronValidatableBehavior and define a custom validation method.
     * Otherwise, a `required` element will always be considered valid.
     * It's also strongly recommended to provide a visual style for the element
     * when its value is invalid.
     */
    required: {
      type: Boolean,
      value: false
    },

    /**
     * The form that the element is registered to.
     */
    _parentForm: {
      type: Object
    }
  },

  attached: __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */] ? null : function() {
    // Note: the iron-form that this element belongs to will set this
    // element's _parentForm property when handling this event.
    this.fire('iron-form-element-register');
  },

  detached: __WEBPACK_IMPORTED_MODULE_1__polymer_polymer_element_js__["a" /* Element */] ? null : function() {
    if (this._parentForm) {
      this._parentForm.fire('iron-form-element-unregister', {target: this});
    }
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronFormElementBehavior;



/***/ }),
/* 46 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export IronValidatableBehaviorMeta */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_meta_iron_meta_js__ = __webpack_require__(90);


let IronValidatableBehaviorMeta = null;

const IronValidatableBehavior = {

  properties: {
    /**
     * Name of the validator to use.
     */
    validator: {
      type: String
    },

    /**
     * True if the last call to `validate` is invalid.
     */
    invalid: {
      notify: true,
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_invalidChanged'
    },
  },

  registered: function() {
    IronValidatableBehaviorMeta = new __WEBPACK_IMPORTED_MODULE_1__iron_meta_iron_meta_js__["a" /* IronMeta */]({type: 'validator'});
  },

  _invalidChanged: function() {
    if (this.invalid) {
      this.setAttribute('aria-invalid', 'true');
    } else {
      this.removeAttribute('aria-invalid');
    }
  },

  /* Recompute this every time it's needed, because we don't know if the
   * underlying IronValidatableBehaviorMeta has changed. */
  get _validator() {
    return IronValidatableBehaviorMeta &&
        IronValidatableBehaviorMeta.byKey(this.validator);
  },

  /**
   * @return {boolean} True if the validator `validator` exists.
   */
  hasValidator: function() {
    return this._validator != null;
  },

  /**
   * Returns true if the `value` is valid, and updates `invalid`. If you want
   * your element to have custom validation logic, do not override this method;
   * override `_getValidity(value)` instead.

   * @param {Object} value Deprecated: The value to be validated. By default,
   * it is passed to the validator's `validate()` function, if a validator is set.
   * If this argument is not specified, then the element's `value` property
   * is used, if it exists.
   * @return {boolean} True if `value` is valid.
   */
  validate: function(value) {
    // If this is an element that also has a value property, and there was
    // no explicit value argument passed, use the element's property instead.
    if (value === undefined && this.value !== undefined)
      this.invalid = !this._getValidity(this.value);
    else
      this.invalid = !this._getValidity(value);
    return !this.invalid;
  },

  /**
   * Returns true if `value` is valid.  By default, it is passed
   * to the validator's `validate()` function, if a validator is set. You
   * should override this method if you want to implement custom validity
   * logic for your element.
   *
   * @param {Object} value The value to be validated.
   * @return {boolean} True if `value` is valid.
   */

  _getValidity: function(value) {
    if (this.hasValidator()) {
      return this._validator.validate(value);
    }
    return true;
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronValidatableBehavior;



/***/ }),
/* 47 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);



const PaperInputAddonBehavior = {
  attached: function() {
    // Workaround for https://github.com/webcomponents/shadydom/issues/96
    Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["b" /* flush */])();
    this.fire('addon-attached');
  },

  /**
   * The function called by `<paper-input-container>` when the input value or validity changes.
   * @param {{
   *   inputElement: (Element|undefined),
   *   value: (string|undefined),
   *   invalid: boolean
   * }} state -
   *     inputElement: The input element.
   *     value: The input value.
   *     invalid: True if the input value is invalid.
   */
  update: function(state) {
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperInputAddonBehavior;



/***/ }),
/* 48 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_checked_element_behavior_iron_checked_element_behavior_js__ = __webpack_require__(96);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_inky_focus_behavior_js__ = __webpack_require__(49);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_ripple_behavior_js__ = __webpack_require__(19);





const PaperCheckedElementBehaviorImpl = {
  /**
   * Synchronizes the element's checked state with its ripple effect.
   */
  _checkedChanged: function() {
    __WEBPACK_IMPORTED_MODULE_1__iron_checked_element_behavior_iron_checked_element_behavior_js__["b" /* IronCheckedElementBehaviorImpl */]._checkedChanged.call(this);
    if (this.hasRipple()) {
      if (this.checked) {
        this._ripple.setAttribute('checked', '');
      } else {
        this._ripple.removeAttribute('checked');
      }
    }
  },

  /**
   * Synchronizes the element's `active` and `checked` state.
   */
  _buttonStateChanged: function() {
    __WEBPACK_IMPORTED_MODULE_3__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */]._buttonStateChanged.call(this);
    if (this.disabled) {
      return;
    }
    if (this.isAttached) {
      this.checked = this.active;
    }
  }
};
/* unused harmony export PaperCheckedElementBehaviorImpl */


const PaperCheckedElementBehavior = [
  __WEBPACK_IMPORTED_MODULE_2__paper_inky_focus_behavior_js__["a" /* PaperInkyFocusBehavior */],
  __WEBPACK_IMPORTED_MODULE_1__iron_checked_element_behavior_iron_checked_element_behavior_js__["a" /* IronCheckedElementBehavior */],
  PaperCheckedElementBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperCheckedElementBehavior;



/***/ }),
/* 49 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__ = __webpack_require__(18);





const PaperInkyFocusBehaviorImpl = {
  observers: [
    '_focusedChanged(receivedFocusFromKeyboard)'
  ],

  _focusedChanged: function(receivedFocusFromKeyboard) {
    if (receivedFocusFromKeyboard) {
      this.ensureRipple();
    }
    if (this.hasRipple()) {
      this._ripple.holdDown = receivedFocusFromKeyboard;
    }
  },

  _createRipple: function() {
    var ripple = __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */]._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('center', '');
    ripple.classList.add('circle');
    return ripple;
  }
};
/* harmony export (immutable) */ __webpack_exports__["b"] = PaperInkyFocusBehaviorImpl;


const PaperInkyFocusBehavior = [
  __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["a" /* IronButtonState */],
  __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__["a" /* IronControlState */],
  __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */],
  PaperInkyFocusBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperInkyFocusBehavior;



/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_paper_toggle_button_paper_toggle_button__ = __webpack_require__(97);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_lit_html__ = __webpack_require__(34);



class TactileMode extends __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__["a" /* Element */] {
  static get is() {
    return "tactile-mode";
  }

  static get template() {
    return "<paper-toggle-button>Edit</paper-toggle-button>";
  }

  connectedCallback() {
    super.connectedCallback();
    var toggle = this.shadowRoot.querySelector("paper-toggle-button");
  }

  setToEdit() {
    var toggle = this.shadowRoot.querySelector("paper-toggle-button");
    toggle.checked = true;
  }

  setToPublish() {
    var toggle = this.shadowRoot.querySelector("paper-toggle-button");
    toggle.checked = true;
  }

  switchedToEdit(callback) {
    var toggle = this.shadowRoot.querySelector("paper-toggle-button");
    toggle.addEventListener("iron-change", () => {
      if (toggle.checked) {
        callback();
      }
    });
  }

  switchedToPublish(callback) {
    var toggle = this.shadowRoot.querySelector("paper-toggle-button");
    toggle.addEventListener("iron-change", () => {
      if (!toggle.checked) {
        callback();
      }
    });
  }

}
/* harmony export (immutable) */ __webpack_exports__["default"] = TactileMode;
 // Register custom element class with browser

customElements.define(TactileMode.is, TactileMode);

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(31);
__webpack_require__(52);
__webpack_require__(35);
__webpack_require__(32);
__webpack_require__(50);
__webpack_require__(98);
module.exports = __webpack_require__(102);


/***/ }),
/* 52 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__tactile_author_js__ = __webpack_require__(32);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tactile_mode_js__ = __webpack_require__(50);



function watchForComponentClicks(event) {
  // This stops user from interacting with page in author mode
  event.stopPropagation();
  event.preventDefault();
  var component = event.target.closest(".tactile");

  if (component) {
    var authorElement = component.querySelector("tactile-author");

    if (authorElement) {
      var path = authorElement.getAttribute("path");

      if (authorElement) {
        document.removeEventListener("click", watchForComponentClicks);
        authorElement.openDialog(function () {
          document.addEventListener("click", watchForComponentClicks); // TODO just reload the component, not the entire page.

          window.location.reload();
        });
      }
    }
  }
}

;

function setupEditMode() {
  document.addEventListener("click", watchForComponentClicks);
  document.body.classList.add("edit");
  window.sessionStorage.setItem("tactile-mode", "edit");
}

function setupPublishMode() {
  document.removeEventListener("click", watchForComponentClicks);
  document.body.classList.remove("edit");
  window.sessionStorage.setItem("tactile-mode", "publish");
}

document.addEventListener("DOMContentLoaded", event => {
  if (document.body.classList.contains('edit')) {
    var tactileModeToggle = document.querySelector("tactile-mode");
    tactileModeToggle.switchedToEdit(setupEditMode);
    tactileModeToggle.switchedToPublish(setupPublishMode);
    var mode = window.sessionStorage.getItem("tactile-mode");

    if (mode === "edit") {
      tactileModeToggle.setToEdit();
    } else {
      setupPublishMode();
    }
  }
});

/***/ }),
/* 53 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_async_js__ = __webpack_require__(6);





let caseMap = __WEBPACK_IMPORTED_MODULE_2__utils_case_map_js__;

let microtask = __WEBPACK_IMPORTED_MODULE_3__utils_async_js__["a" /* microTask */];

// Save map of native properties; this forms a blacklist or properties
// that won't have their values "saved" by `saveAccessorValue`, since
// reading from an HTMLElement accessor from the context of a prototype throws
const nativeProperties = {};
let proto = HTMLElement.prototype;
while (proto) {
  let props = Object.getOwnPropertyNames(proto);
  for (let i=0; i<props.length; i++) {
    nativeProperties[props[i]] = true;
  }
  proto = Object.getPrototypeOf(proto);
}

/**
 * Used to save the value of a property that will be overridden with
 * an accessor. If the `model` is a prototype, the values will be saved
 * in `__dataProto`, and it's up to the user (or downstream mixin) to
 * decide how/when to set these values back into the accessors.
 * If `model` is already an instance (it has a `__data` property), then
 * the value will be set as a pending property, meaning the user should
 * call `_invalidateProperties` or `_flushProperties` to take effect
 *
 * @param {Object} model Prototype or instance
 * @param {string} property Name of property
 * @private
 */
function saveAccessorValue(model, property) {
  // Don't read/store value for any native properties since they could throw
  if (!nativeProperties[property]) {
    let value = model[property];
    if (value !== undefined) {
      if (model.__data) {
        // Adding accessor to instance; update the property
        // It is the user's responsibility to call _flushProperties
        model._setPendingProperty(property, value);
      } else {
        // Adding accessor to proto; save proto's value for instance-time use
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty('__dataProto', model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }
        model.__dataProto[property] = value;
      }
    }
  }
}

const PropertyAccessors = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_PropertyAccessors}
   * @extends HTMLElement
   * @unrestricted
   */
  class PropertyAccessors extends superClass {

    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     */
    static createPropertiesForAttributes() {
      let a$ = this.observedAttributes;
      for (let i=0; i < a$.length; i++) {
        this.prototype._createPropertyAccessor(caseMap.dashToCamelCase(a$[i]));
      }
    }

    constructor() {
      super();
      /** @type {boolean} */
      this.__serializing;
      /** @type {number} */
      this.__dataCounter;
      /** @type {boolean} */
      this.__dataEnabled;
      /** @type {boolean} */
      this.__dataReady;
      /** @type {boolean} */
      this.__dataInvalid;
      /** @type {!Object} */
      this.__data;
      /** @type {Object} */
      this.__dataPending;
      /** @type {Object} */
      this.__dataOld;
      /** @type {Object} */
      this.__dataProto;
      /** @type {Object} */
      this.__dataHasAccessor;
      /** @type {Object} */
      this.__dataInstanceProps;
      this._initializeProperties();
    }

    /**
     * Implements native Custom Elements `attributeChangedCallback` to
     * set an attribute value to a property via `_attributeToProperty`.
     *
     * @param {string} name Name of attribute that changed
     * @param {?string} old Old attribute value
     * @param {?string} value New attribute value
     */
    attributeChangedCallback(name, old, value) {
      if (old !== value) {
        this._attributeToProperty(name, value);
      }
    }

    /**
     * Initializes the local storage for property accessors.
     *
     * Provided as an override point for performing any setup work prior
     * to initializing the property accessor system.
     *
     * @protected
     */
    _initializeProperties() {
      this.__serializing = false;
      this.__dataCounter = 0;
      this.__dataEnabled = false;
      this.__dataReady = false;
      this.__dataInvalid = false;
      this.__data = {};
      this.__dataPending = null;
      this.__dataOld = null;
      if (this.__dataProto) {
        this._initializeProtoProperties(this.__dataProto);
        this.__dataProto = null;
      }
      // Capture instance properties; these will be set into accessors
      // during first flush. Don't set them here, since we want
      // these to overwrite defaults/constructor assignments
      for (let p in this.__dataHasAccessor) {
        if (this.hasOwnProperty(p)) {
          this.__dataInstanceProps = this.__dataInstanceProps || {};
          this.__dataInstanceProps[p] = this[p];
          delete this[p];
        }
      }
    }

    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @protected
     */
    _initializeProtoProperties(props) {
      for (let p in props) {
        this._setProperty(p, props[p]);
      }
    }

    /**
     * Called at ready time with bag of instance properties that overwrote
     * accessors when the element upgraded.
     *
     * The default implementation sets these properties back into the
     * setter at ready time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @protected
     */
    _initializeInstanceProperties(props) {
      Object.assign(this, props);
    }

    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     */
    _ensureAttribute(attribute, value) {
      if (!this.hasAttribute(attribute)) {
        this._valueToNodeAttribute(this, value, attribute);
      }
    }

    /**
     * Deserializes an attribute to its associated property.
     *
     * This method calls the `_deserializeValue` method to convert the string to
     * a typed value.
     *
     * @param {string} attribute Name of attribute to deserialize.
     * @param {?string} value of the attribute.
     * @param {*=} type type to deserialize to.
     */
    _attributeToProperty(attribute, value, type) {
      // Don't deserialize back to property if currently reflecting
      if (!this.__serializing) {
        let property = caseMap.dashToCamelCase(attribute);
        this[property] = this._deserializeValue(value, type);
      }
    }

    /**
     * Serializes a property to its associated attribute.
     *
     * @param {string} property Property name to reflect.
     * @param {string=} attribute Attribute name to reflect.
     * @param {*=} value Property value to refect.
     */
    _propertyToAttribute(property, attribute, value) {
      this.__serializing = true;
      value = (arguments.length < 3) ? this[property] : value;
      this._valueToNodeAttribute(this, value,
        attribute || caseMap.camelToDashCase(property));
      this.__serializing = false;
    }

    /**
     * Sets a typed value to an HTML attribute on a node.
     *
     * This method calls the `_serializeValue` method to convert the typed
     * value to a string.  If the `_serializeValue` method returns `undefined`,
     * the attribute will be removed (this is the default for boolean
     * type `false`).
     *
     * @param {Element} node Element to set attribute to.
     * @param {*} value Value to serialize.
     * @param {string} attribute Attribute name to serialize to.
     */
    _valueToNodeAttribute(node, value, attribute) {
      let str = this._serializeValue(value);
      if (str === undefined) {
        node.removeAttribute(attribute);
      } else {
        node.setAttribute(attribute, str);
      }
    }

    /**
     * Converts a typed JavaScript value to a string.
     *
     * This method is called by Polymer when setting JS property values to
     * HTML attributes.  Users may override this method on Polymer element
     * prototypes to provide serialization for custom types.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property value.
     */
    _serializeValue(value) {
      /* eslint-disable no-fallthrough */
      switch (typeof value) {
        case 'boolean':
          return value ? '' : undefined;

        case 'object':
          if (value instanceof Date) {
            return value.toString();
          } else if (value) {
            try {
              return JSON.stringify(value);
            } catch(x) {
              return '';
            }
          }

        default:
          return value != null ? value.toString() : undefined;
      }
    }

    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     * Note: The return value of `undefined` is used as a sentinel value to
     * indicate the attribute should be removed.
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     */
    _deserializeValue(value, type) {
      /**
       * @type {*}
       */
      let outValue;
      switch (type) {
        case Number:
          outValue = Number(value);
          break;

        case Boolean:
          outValue = (value !== null);
          break;

        case Object:
          try {
            outValue = JSON.parse(/** @type string */(value));
          } catch(x) {
            // allow non-JSON literals like Strings and Numbers
          }
          break;

        case Array:
          try {
            outValue = JSON.parse(/** @type string */(value));
          } catch(x) {
            outValue = null;
            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
          }
          break;

        case Date:
          outValue = new Date(value);
          break;

        case String:
        default:
          outValue = value;
          break;
      }

      return outValue;
    }
    /* eslint-enable no-fallthrough */

    /**
     * Creates a setter/getter pair for the named property with its own
     * local storage.  The getter returns the value in the local storage,
     * and the setter calls `_setProperty`, which updates the local storage
     * for the property and enqueues a `_propertiesChanged` callback.
     *
     * This method may be called on a prototype or an instance.  Calling
     * this method may overwrite a property value that already exists on
     * the prototype/instance by creating the accessor.  When calling on
     * a prototype, any overwritten values are saved in `__dataProto`,
     * and it is up to the subclasser to decide how/when to set those
     * properties back into the accessor.  When calling on an instance,
     * the overwritten value is set via `_setPendingProperty`, and the
     * user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     *
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created; the
     *   protected `_setProperty` function must be used to set the property
     * @protected
     */
    _createPropertyAccessor(property, readOnly) {
      if (!this.hasOwnProperty('__dataHasAccessor')) {
        this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
      }
      if (!this.__dataHasAccessor[property]) {
        this.__dataHasAccessor[property] = true;
        saveAccessorValue(this, property);
        Object.defineProperty(this, property, {
          /* eslint-disable valid-jsdoc */
          /** @this {PropertyAccessors} */
          get: function() {
            return this.__data[property];
          },
          /** @this {PropertyAccessors} */
          set: readOnly ? function() {} : function(value) {
            this._setProperty(property, value);
          }
          /* eslint-enable */
        });
      }
    }

    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     */
    _hasAccessor(property) {
      return this.__dataHasAccessor && this.__dataHasAccessor[property];
    }

    /**
     * Updates the local storage for a property (via `_setPendingProperty`)
     * and enqueues a `_proeprtiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @protected
     */
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value)) {
        this._invalidateProperties();
      }
    }

    /**
     * Updates the local storage for a property, records the previous value,
     * and adds it to the set of "pending changes" that will be passed to the
     * `_propertiesChanged` callback.  This method does not enqueue the
     * `_propertiesChanged` callback.
     *
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {boolean} Returns true if the property changed
     * @protected
     */
    _setPendingProperty(property, value) {
      let old = this.__data[property];
      let changed = this._shouldPropertyChange(property, value, old);
      if (changed) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        // Ensure old is captured from the last turn
        if (this.__dataOld && !(property in this.__dataOld)) {
          this.__dataOld[property] = old;
        }
        this.__data[property] = value;
        this.__dataPending[property] = value;
      }
      return changed;
    }

    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     */
    _isPropertyPending(prop) {
      return Boolean(this.__dataPending && (prop in this.__dataPending));
    }

    /**
     * Marks the properties as invalid, and enqueues an async
     * `_propertiesChanged` callback.
     *
     * @protected
     */
    _invalidateProperties() {
      if (!this.__dataInvalid && this.__dataReady) {
        this.__dataInvalid = true;
        microtask.run(() => {
          if (this.__dataInvalid) {
            this.__dataInvalid = false;
            this._flushProperties();
          }
        });
      }
    }

    /**
     * Call to enable property accessor processing. Before this method is
     * called accessor values will be set but side effects are
     * queued. When called, any pending side effects occur immediately.
     * For elements, generally `connectedCallback` is a normal spot to do so.
     * It is safe to call this method multiple times as it only turns on
     * property accessors once.
     */
    _enableProperties() {
      if (!this.__dataEnabled) {
        this.__dataEnabled = true;
        if (this.__dataInstanceProps) {
          this._initializeInstanceProperties(this.__dataInstanceProps);
          this.__dataInstanceProps = null;
        }
        this.ready();
      }
    }

    /**
     * Calls the `_propertiesChanged` callback with the current set of
     * pending changes (and old values recorded when pending changes were
     * set), and resets the pending set of changes. Generally, this method
     * should not be called in user code.
     *
     *
     * @protected
     */
    _flushProperties() {
      if (this.__dataPending && this.__dataOld) {
        let changedProps = this.__dataPending;
        this.__dataPending = null;
        this.__dataCounter++;
        this._propertiesChanged(this.__data, changedProps, this.__dataOld);
        this.__dataCounter--;
      }
    }

    /**
     * Lifecycle callback called the first time properties are being flushed.
     * Prior to `ready`, all property sets through accessors are queued and
     * their effects are flushed after this method returns.
     *
     * Users may override this function to implement behavior that is
     * dependent on the element having its properties initialized, e.g.
     * from defaults (initialized from `constructor`, `_initializeProperties`),
     * `attributeChangedCallback`, or values propagated from host e.g. via
     * bindings.  `super.ready()` must be called to ensure the data system
     * becomes enabled.
     *
     * @public
     */
    ready() {
      this.__dataReady = true;
      // Run normal flush
      this._flushProperties();
    }

    /**
     * Callback called when any properties with accessors created via
     * `_createPropertyAccessor` have been set.
     *
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {!Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {!Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @protected
     */
    _propertiesChanged(currentProps, changedProps, oldProps) { // eslint-disable-line no-unused-vars
    }

    /**
     * Method called to determine whether a property value should be
     * considered as a change and cause the `_propertiesChanged` callback
     * to be enqueued.
     *
     * The default implementation returns `true` for primitive types if a
     * strict equality check fails, and returns `true` for all Object/Arrays.
     * The method always returns false for `NaN`.
     *
     * Override this method to e.g. provide stricter checking for
     * Objects/Arrays when using immutable patterns.
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     *   and enqueue a `_proeprtiesChanged` callback
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return (
        // Strict equality check
        (old !== value &&
         // This ensures (old==NaN, value==NaN) always returns false
         (old === old || value === value))
      );
    }

  }

  return PropertyAccessors;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = PropertyAccessors;



/***/ }),
/* 54 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(5);



// 1.x backwards-compatible auto-wrapper for template type extensions
// This is a clear layering violation and gives favored-nation status to
// dom-if and dom-repeat templates.  This is a conceit we're choosing to keep
// a.) to ease 1.x backwards-compatibility due to loss of `is`, and
// b.) to maintain if/repeat capability in parser-constrained elements
//     (e.g. table, select) in lieu of native CE type extensions without
//     massive new invention in this space (e.g. directive system)
const templateExtensions = {
  'dom-if': true,
  'dom-repeat': true
};
function wrapTemplateExtension(node) {
  let is = node.getAttribute('is');
  if (is && templateExtensions[is]) {
    let t = node;
    t.removeAttribute('is');
    node = t.ownerDocument.createElement(is);
    t.parentNode.replaceChild(node, t);
    node.appendChild(t);
    while(t.attributes.length) {
      node.setAttribute(t.attributes[0].name, t.attributes[0].value);
      t.removeAttribute(t.attributes[0].name);
    }
  }
  return node;
}

function findTemplateNode(root, nodeInfo) {
  // recursively ascend tree until we hit root
  let parent = nodeInfo.parentInfo && findTemplateNode(root, nodeInfo.parentInfo);
  // unwind the stack, returning the indexed node at each level
  if (parent) {
    // note: marginally faster than indexing via childNodes
    // (http://jsperf.com/childnodes-lookup)
    for (let n=parent.firstChild, i=0; n; n=n.nextSibling) {
      if (nodeInfo.parentIndex === i++) {
        return n;
      }
    }
  } else {
    return root;
  }
}

// construct `$` map (from id annotations)
function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
}

// install event listeners (from event annotations)
function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (let j=0, e$=nodeInfo.events, e; (j<e$.length) && (e=e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e.name, e.value, inst);
    }
  }
}

// push configuration references at configure time
function applyTemplateContent(inst, node, nodeInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
  }
}

function createNodeEventHandler(context, eventName, methodName) {
  // Instances can optionally have a _methodHost which allows redirecting where
  // to find methods. Currently used by `templatize`.
  context = context._methodHost || context;
  let handler = function(e) {
    if (context[methodName]) {
      context[methodName](e, e.detail);
    } else {
      console.warn('listener method `' + methodName + '` not defined');
    }
  };
  return handler;
}

const TemplateStamp = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_TemplateStamp}
   */
  class TemplateStamp extends superClass {

    /**
     * Scans a template to produce template metadata.
     *
     * Template-specific metadata are stored in the object returned, and node-
     * specific metadata are stored in objects in its flattened `nodeInfoList`
     * array.  Only nodes in the template that were parsed as nodes of
     * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
     * contains an `index` (`childNodes` index in parent) and optionally
     * `parent`, which points to node info of its parent (including its index).
     *
     * The template metadata object returned from this method has the following
     * structure (many fields optional):
     *
     * ```js
     *   {
     *     // Flattened list of node metadata (for nodes that generated metadata)
     *     nodeInfoList: [
     *       {
     *         // `id` attribute for any nodes with id's for generating `$` map
     *         id: {string},
     *         // `on-event="handler"` metadata
     *         events: [
     *           {
     *             name: {string},   // event name
     *             value: {string},  // handler method name
     *           }, ...
     *         ],
     *         // Notes when the template contained a `<slot>` for shady DOM
     *         // optimization purposes
     *         hasInsertionPoint: {boolean},
     *         // For nested `<template>`` nodes, nested template metadata
     *         templateInfo: {object}, // nested template metadata
     *         // Metadata to allow efficient retrieval of instanced node
     *         // corresponding to this metadata
     *         parentInfo: {number},   // reference to parent nodeInfo>
     *         parentIndex: {number},  // index in parent's `childNodes` collection
     *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
     *       },
     *       ...
     *     ],
     *     // When true, the template had the `strip-whitespace` attribute
     *     // or was nested in a template with that setting
     *     stripWhitespace: {boolean},
     *     // For nested templates, nested template content is moved into
     *     // a document fragment stored here; this is an optimization to
     *     // avoid the cost of nested template cloning
     *     content: {DocumentFragment}
     *   }
     * ```
     *
     * This method kicks off a recursive treewalk as follows:
     *
     * ```
     *    _parseTemplate <---------------------+
     *      _parseTemplateContent              |
     *        _parseTemplateNode  <------------|--+
     *          _parseTemplateNestedTemplate --+  |
     *          _parseTemplateChildNodes ---------+
     *          _parseTemplateNodeAttributes
     *            _parseTemplateNodeAttribute
     *
     * ```
     *
     * These methods may be overridden to add custom metadata about templates
     * to either `templateInfo` or `nodeInfo`.
     *
     * Note that this method may be destructive to the template, in that
     * e.g. event annotations may be removed after being noted in the
     * template metadata.
     *
     * @param {!HTMLTemplateElement} template Template to parse
     * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
     *   template, for parsing nested templates
     * @return {!TemplateInfo} Parsed template metadata
     */
    static _parseTemplate(template, outerTemplateInfo) {
      // since a template may be re-used, memo-ize metadata
      if (!template._templateInfo) {
        let templateInfo = template._templateInfo = {};
        templateInfo.nodeInfoList = [];
        templateInfo.stripWhiteSpace =
          (outerTemplateInfo && outerTemplateInfo.stripWhiteSpace) ||
          template.hasAttribute('strip-whitespace');
        this._parseTemplateContent(template, templateInfo, {parent: null});
      }
      return template._templateInfo;
    }

    static _parseTemplateContent(template, templateInfo, nodeInfo) {
      return this._parseTemplateNode(template.content, templateInfo, nodeInfo);
    }

    /**
     * Parses template node and adds template and node metadata based on
     * the current node, and its `childNodes` and `attributes`.
     *
     * This method may be overridden to add custom node or template specific
     * metadata based on this node.
     *
     * @param {Node} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted;
      let element = /** @type Element */(node);
      if (element.localName == 'template' && !element.hasAttribute('preserve-content')) {
        noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
      } else if (element.localName === 'slot') {
        // For ShadyDom optimization, indicating there is an insertion point
        templateInfo.hasInsertionPoint = true;
      }
      if (element.firstChild) {
        noted = this._parseTemplateChildNodes(element, templateInfo, nodeInfo) || noted;
      }
      if (element.hasAttributes && element.hasAttributes()) {
        noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
      }
      return noted;
    }

    /**
     * Parses template child nodes for the given root node.
     *
     * This method also wraps whitelisted legacy template extensions
     * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
     * wrappers, collapses text nodes, and strips whitespace from the template
     * if the `templateInfo.stripWhitespace` setting was provided.
     *
     * @param {Node} root Root node whose `childNodes` will be parsed
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     */
    static _parseTemplateChildNodes(root, templateInfo, nodeInfo) {
      for (let node=root.firstChild, parentIndex=0, next; node; node=next) {
        // Wrap templates
        if (node.localName == 'template') {
          node = wrapTemplateExtension(node);
        }
        // collapse adjacent textNodes: fixes an IE issue that can cause
        // text nodes to be inexplicably split =(
        // note that root.normalize() should work but does not so we do this
        // manually.
        next = node.nextSibling;
        if (node.nodeType === Node.TEXT_NODE) {
          let /** Node */ n = next;
          while (n && (n.nodeType === Node.TEXT_NODE)) {
            node.textContent += n.textContent;
            next = n.nextSibling;
            root.removeChild(n);
            n = next;
          }
          // optionally strip whitespace
          if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
            root.removeChild(node);
            continue;
          }
        }
        let childInfo = { parentIndex, parentInfo: nodeInfo };
        if (this._parseTemplateNode(node, templateInfo, childInfo)) {
          childInfo.infoIndex = templateInfo.nodeInfoList.push(/** @type {!NodeInfo} */(childInfo)) - 1;
        }
        // Increment if not removed
        if (node.parentNode) {
          parentIndex++;
        }
      }
    }

    /**
     * Parses template content for the given nested `<template>`.
     *
     * Nested template info is stored as `templateInfo` in the current node's
     * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
     * It will then be the responsibility of the host to set it back to the
     * template and for users stamping nested templates to use the
     * `_contentForTemplate` method to retrieve the content for this template
     * (an optimization to avoid the cost of cloning nested template content).
     *
     * @param {HTMLTemplateElement} node Node to parse (a <template>)
     * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
     *   that includes the template `node`
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
      let templateInfo = this._parseTemplate(node, outerTemplateInfo);
      let content = templateInfo.content =
        node.content.ownerDocument.createDocumentFragment();
      content.appendChild(node.content);
      nodeInfo.templateInfo = templateInfo;
      return true;
    }

    /**
     * Parses template node attributes and adds node metadata to `nodeInfo`
     * for nodes of interest.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
      // Make copy of original attribute list, since the order may change
      // as attributes are added and removed
      let noted = false;
      let attrs = Array.from(node.attributes);
      for (let i=attrs.length-1, a; (a=attrs[i]); i--) {
        noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a.name, a.value) || noted;
      }
      return noted;
    }

    /**
     * Parses a single template node attribute and adds node metadata to
     * `nodeInfo` for attributes of interest.
     *
     * This implementation adds metadata for `on-event="handler"` attributes
     * and `id` attributes.
     *
     * @param {Element} node Node to parse
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     */
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      // events (on-*)
      if (name.slice(0, 3) === 'on-') {
        node.removeAttribute(name);
        nodeInfo.events = nodeInfo.events || [];
        nodeInfo.events.push({
          name: name.slice(3),
          value
        });
        return true;
      }
      // static id
      else if (name === 'id') {
        nodeInfo.id = value;
        return true;
      }
      return false;
    }

    /**
     * Returns the `content` document fragment for a given template.
     *
     * For nested templates, Polymer performs an optimization to cache nested
     * template content to avoid the cost of cloning deeply nested templates.
     * This method retrieves the cached content for a given template.
     *
     * @param {HTMLTemplateElement} template Template to retrieve `content` for
     * @return {DocumentFragment} Content fragment
     */
    static _contentForTemplate(template) {
      let templateInfo = /** @type {HTMLTemplateElementWithInfo} */ (template)._templateInfo;
      return (templateInfo && templateInfo.content) || template.content;
    }

    /**
     * Clones the provided template content and returns a document fragment
     * containing the cloned dom.
     *
     * The template is parsed (once and memoized) using this library's
     * template parsing features, and provides the following value-added
     * features:
     * * Adds declarative event listeners for `on-event="handler"` attributes
     * * Generates an "id map" for all nodes with id's under `$` on returned
     *   document fragment
     * * Passes template info including `content` back to templates as
     *   `_templateInfo` (a performance optimization to avoid deep template
     *   cloning)
     *
     * Note that the memoized template parsing process is destructive to the
     * template: attributes for bindings and declarative event listeners are
     * removed after being noted in notes, and any nested `<template>.content`
     * is removed and stored in notes as well.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @return {!StampedTemplate} Cloned template content
     */
    _stampTemplate(template) {
      // Polyfill support: bootstrap the template if it has not already been
      if (template && !template.content &&
          window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
        HTMLTemplateElement.decorate(template);
      }
      let templateInfo = this.constructor._parseTemplate(template);
      let nodeInfo = templateInfo.nodeInfoList;
      let content = templateInfo.content || template.content;
      let dom = /** @type DocumentFragment */ (document.importNode(content, true));
      // NOTE: ShadyDom optimization indicating there is an insertion point
      dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
      let nodes = dom.nodeList = new Array(nodeInfo.length);
      dom.$ = {};
      for (let i=0, l=nodeInfo.length, info; (i<l) && (info=nodeInfo[i]); i++) {
        let node = nodes[i] = findTemplateNode(dom, info);
        applyIdToMap(this, dom.$, node, info);
        applyTemplateContent(this, node, info);
        applyEventListener(this, node, info);
      }
      return /** @type {!StampedTemplate} */(dom);
    }

    /**
     * Adds an event listener by method name for the event provided.
     *
     * This method generates a handler function that looks up the method
     * name at handling time.
     *
     * @param {Node} node Node to add listener on
     * @param {string} eventName Name of event
     * @param {string} methodName Name of method
     * @param {*=} context Context the method will be called on (defaults
     *   to `node`)
     * @return {Function} Generated handler function
     */
    _addMethodEventListenerToNode(node, eventName, methodName, context) {
      context = context || node;
      let handler = createNodeEventHandler(context, eventName, methodName);
      this._addEventListenerToNode(node, eventName, handler);
      return handler;
    }

    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {Node} node Node to add event listener to
     * @param {string} eventName Name of event
     * @param {Function} handler Listener function to add
     */
    _addEventListenerToNode(node, eventName, handler) {
      node.addEventListener(eventName, handler);
    }

    /**
     * Override point for adding custom or simulated event handling.
     *
     * @param {Node} node Node to remove event listener from
     * @param {string} eventName Name of event
     * @param {Function} handler Listener function to remove
     */
    _removeEventListenerFromNode(node, eventName, handler) {
      node.removeEventListener(eventName, handler);
    }

  }

  return TemplateStamp;

});
/* harmony export (immutable) */ __webpack_exports__["a"] = TemplateStamp;



/***/ }),
/* 55 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__neon_animation_neon_animation_runner_behavior_js__ = __webpack_require__(72);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_dialog_behavior_paper_dialog_behavior_js__ = __webpack_require__(74);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_dialog_behavior_paper_dialog_shared_styles_js__ = __webpack_require__(81);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);






Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style include="paper-dialog-shared-styles"></style>
    <slot></slot>
`,

  is: 'paper-dialog',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_dialog_behavior_paper_dialog_behavior_js__["a" /* PaperDialogBehavior */],
    __WEBPACK_IMPORTED_MODULE_1__neon_animation_neon_animation_runner_behavior_js__["a" /* NeonAnimationRunnerBehavior */]
  ],

  listeners: {
    'neon-animation-finish': '_onNeonAnimationFinish'
  },

  _renderOpened: function() {
    this.cancelAnimation();
    this.playAnimation('entry');
  },

  _renderClosed: function() {
    this.cancelAnimation();
    this.playAnimation('exit');
  },

  _onNeonAnimationFinish: function() {
    if (this.opened) {
      this._finishRenderOpened();
    } else {
      this._finishRenderClosed();
    }
  }
});


/***/ }),
/* 56 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_apply_shim_js__ = __webpack_require__(57);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_template_map_js__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_style_util_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__ = __webpack_require__(59);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_document_wait_js__ = __webpack_require__(39);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__src_common_utils_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__src_custom_style_interface_js__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__src_style_settings_js__ = __webpack_require__(23);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/









 // eslint-disable-line no-unused-vars


/** @const {ApplyShim} */
const applyShim = new __WEBPACK_IMPORTED_MODULE_0__src_apply_shim_js__["a" /* default */]();

class ApplyShimInterface {
  constructor() {
    /** @type {?CustomStyleInterfaceInterface} */
    this.customStyleInterface = null;
    Object(__WEBPACK_IMPORTED_MODULE_4__src_document_wait_js__["a" /* default */])(() => {
      this.ensure();
    });
    applyShim['invalidCallback'] = __WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["a" /* invalidate */];
  }
  ensure() {
    if (this.customStyleInterface) {
      return;
    }
    this.customStyleInterface = window.ShadyCSS.CustomStyleInterface;
    if (this.customStyleInterface) {
      this.customStyleInterface['transformCallback'] = (style) => {
        applyShim.transformCustomStyle(style);
      };
      this.customStyleInterface['validateCallback'] = () => {
        requestAnimationFrame(() => {
          if (this.customStyleInterface['enqueued']) {
            this.flushCustomStyles();
          }
        });
      }
    }
  }
  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   */
  prepareTemplate(template, elementName) {
    this.ensure();
    __WEBPACK_IMPORTED_MODULE_1__src_template_map_js__["a" /* default */][elementName] = template;
    let ast = applyShim.transformTemplate(template, elementName);
    // save original style ast to use for revalidating instances
    template['_styleAst'] = ast;
  }
  flushCustomStyles() {
    this.ensure();
    if (!this.customStyleInterface) {
      return;
    }
    let styles = this.customStyleInterface['processStyles']();
    if (!this.customStyleInterface['enqueued']) {
      return;
    }
    for (let i = 0; i < styles.length; i++ ) {
      let cs = styles[i];
      let style = this.customStyleInterface['getStyleForCustomStyle'](cs);
      if (style) {
        applyShim.transformCustomStyle(style);
      }
    }
    this.customStyleInterface['enqueued'] = false;
  }
  /**
   * @param {HTMLElement} element
   * @param {Object=} properties
   */
  styleSubtree(element, properties) {
    this.ensure();
    if (properties) {
      Object(__WEBPACK_IMPORTED_MODULE_5__src_common_utils_js__["c" /* updateNativeProperties */])(element, properties);
    }
    if (element.shadowRoot) {
      this.styleElement(element);
      let shadowChildren = element.shadowRoot.children || element.shadowRoot.childNodes;
      for (let i = 0; i < shadowChildren.length; i++) {
        this.styleSubtree(/** @type {HTMLElement} */(shadowChildren[i]));
      }
    } else {
      let children = element.children || element.childNodes;
      for (let i = 0; i < children.length; i++) {
        this.styleSubtree(/** @type {HTMLElement} */(children[i]));
      }
    }
  }
  /**
   * @param {HTMLElement} element
   */
  styleElement(element) {
    this.ensure();
    let {is} = Object(__WEBPACK_IMPORTED_MODULE_2__src_style_util_js__["c" /* getIsExtends */])(element);
    let template = __WEBPACK_IMPORTED_MODULE_1__src_template_map_js__["a" /* default */][is];
    if (template && !__WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["c" /* templateIsValid */](template)) {
      // only revalidate template once
      if (!__WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["d" /* templateIsValidating */](template)) {
        this.prepareTemplate(template, is);
        __WEBPACK_IMPORTED_MODULE_3__src_apply_shim_utils_js__["b" /* startValidatingTemplate */](template);
      }
      // update this element instance
      let root = element.shadowRoot;
      if (root) {
        let style = /** @type {HTMLStyleElement} */(root.querySelector('style'));
        if (style) {
          // reuse the template's style ast, it has all the original css text
          style['__cssRules'] = template['_styleAst'];
          style.textContent = Object(__WEBPACK_IMPORTED_MODULE_2__src_style_util_js__["f" /* toCssText */])(template['_styleAst'])
        }
      }
    }
  }
  /**
   * @param {Object=} properties
   */
  styleDocument(properties) {
    this.ensure();
    this.styleSubtree(document.body, properties);
  }
}

if (!window.ShadyCSS || !window.ShadyCSS.ScopingShim) {
  const applyShimInterface = new ApplyShimInterface();
  let CustomStyleInterface = window.ShadyCSS && window.ShadyCSS.CustomStyleInterface;

  window.ShadyCSS = {
    /**
     * @param {!HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate(template, elementName, elementExtends) { // eslint-disable-line no-unused-vars
      applyShimInterface.flushCustomStyles();
      applyShimInterface.prepareTemplate(template, elementName)
    },

    /**
     * @param {!HTMLElement} element
     * @param {Object=} properties
     */
    styleSubtree(element, properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleSubtree(element, properties);
    },

    /**
     * @param {!HTMLElement} element
     */
    styleElement(element) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleElement(element);
    },

    /**
     * @param {Object=} properties
     */
    styleDocument(properties) {
      applyShimInterface.flushCustomStyles();
      applyShimInterface.styleDocument(properties);
    },

    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue(element, property) {
      return Object(__WEBPACK_IMPORTED_MODULE_5__src_common_utils_js__["b" /* getComputedStyleValue */])(element, property);
    },
    nativeCss: __WEBPACK_IMPORTED_MODULE_7__src_style_settings_js__["a" /* nativeCssVariables */],
    nativeShadow: __WEBPACK_IMPORTED_MODULE_7__src_style_settings_js__["b" /* nativeShadow */]
  };

  if (CustomStyleInterface) {
    window.ShadyCSS.CustomStyleInterface = CustomStyleInterface;
  }
}

window.ShadyCSS.ApplyShim = applyShim;

/***/ }),
/* 57 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__style_util_js__ = __webpack_require__(37);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__common_regex_js__ = __webpack_require__(25);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__common_utils_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__css_parse_js__ = __webpack_require__(24);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
/*
 * The apply shim simulates the behavior of `@apply` proposed at
 * https://tabatkins.github.io/specs/css-apply-rule/.
 * The approach is to convert a property like this:
 *
 *    --foo: {color: red; background: blue;}
 *
 * to this:
 *
 *    --foo_-_color: red;
 *    --foo_-_background: blue;
 *
 * Then where `@apply --foo` is used, that is converted to:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background);
 *
 * This approach generally works but there are some issues and limitations.
 * Consider, for example, that somewhere *between* where `--foo` is set and used,
 * another element sets it to:
 *
 *    --foo: { border: 2px solid red; }
 *
 * We must now ensure that the color and background from the previous setting
 * do not apply. This is accomplished by changing the property set to this:
 *
 *    --foo_-_border: 2px solid red;
 *    --foo_-_color: initial;
 *    --foo_-_background: initial;
 *
 * This works but introduces one new issue.
 * Consider this setup at the point where the `@apply` is used:
 *
 *    background: orange;
 *    `@apply` --foo;
 *
 * In this case the background will be unset (initial) rather than the desired
 * `orange`. We address this by altering the property set to use a fallback
 * value like this:
 *
 *    color: var(--foo_-_color);
 *    background: var(--foo_-_background, orange);
 *    border: var(--foo_-_border);
 *
 * Note that the default is retained in the property set and the `background` is
 * the desired `orange`. This leads us to a limitation.
 *
 * Limitation 1:

 * Only properties in the rule where the `@apply`
 * is used are considered as default values.
 * If another rule matches the element and sets `background` with
 * less specificity than the rule in which `@apply` appears,
 * the `background` will not be set.
 *
 * Limitation 2:
 *
 * When using Polymer's `updateStyles` api, new properties may not be set for
 * `@apply` properties.

*/






 // eslint-disable-line no-unused-vars

const APPLY_NAME_CLEAN = /;\s*/m;
const INITIAL_INHERIT = /^\s*(initial)|(inherit)\s*$/;

// separator used between mixin-name and mixin-property-name when producing properties
// NOTE: plain '-' may cause collisions in user styles
const MIXIN_VAR_SEP = '_-_';

/**
 * @typedef {!Object<string, string>}
 */
let PropertyEntry; // eslint-disable-line no-unused-vars

/**
 * @typedef {!Object<string, boolean>}
 */
let DependantsEntry; // eslint-disable-line no-unused-vars

/** @typedef {{
 *    properties: PropertyEntry,
 *    dependants: DependantsEntry
 * }}
 */
let MixinMapEntry; // eslint-disable-line no-unused-vars

// map of mixin to property names
// --foo: {border: 2px} -> {properties: {(--foo, ['border'])}, dependants: {'element-name': proto}}
class MixinMap {
  constructor() {
    /** @type {!Object<string, !MixinMapEntry>} */
    this._map = {};
  }
  /**
   * @param {string} name
   * @param {!PropertyEntry} props
   */
  set(name, props) {
    name = name.trim();
    this._map[name] = {
      properties: props,
      dependants: {}
    }
  }
  /**
   * @param {string} name
   * @return {MixinMapEntry}
   */
  get(name) {
    name = name.trim();
    return this._map[name] || null;
  }
}

/**
 * Callback for when an element is marked invalid
 * @type {?function(string)}
 */
let invalidCallback = null;

/** @unrestricted */
class ApplyShim {
  constructor() {
    /** @type {?string} */
    this._currentElement = null;
    /** @type {HTMLMetaElement} */
    this._measureElement = null;
    this._map = new MixinMap();
  }
  /**
   * return true if `cssText` contains a mixin definition or consumption
   * @param {string} cssText
   * @return {boolean}
   */
  detectMixin(cssText) {
    return Object(__WEBPACK_IMPORTED_MODULE_2__common_utils_js__["a" /* detectMixin */])(cssText);
  }

  /**
   * Gather styles into one style for easier processing
   * @param {!HTMLTemplateElement} template
   * @return {HTMLStyleElement}
   */
  gatherStyles(template) {
    const styleText = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["b" /* gatherStyleText */])(template.content);
    if (styleText) {
      const style = /** @type {!HTMLStyleElement} */(document.createElement('style'));
      style.textContent = styleText;
      template.content.insertBefore(style, template.content.firstChild);
      return style;
    }
    return null;
  }
  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @return {StyleNode}
   */
  transformTemplate(template, elementName) {
    if (template._gatheredStyle === undefined) {
      template._gatheredStyle = this.gatherStyles(template);
    }
    /** @type {HTMLStyleElement} */
    const style = template._gatheredStyle;
    return style ? this.transformStyle(style, elementName) : null;
  }
  /**
   * @param {!HTMLStyleElement} style
   * @param {string} elementName
   * @return {StyleNode}
   */
  transformStyle(style, elementName = '') {
    let ast = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["e" /* rulesForStyle */])(style);
    this.transformRules(ast, elementName);
    style.textContent = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["f" /* toCssText */])(ast);
    return ast;
  }
  /**
   * @param {!HTMLStyleElement} style
   * @return {StyleNode}
   */
  transformCustomStyle(style) {
    let ast = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["e" /* rulesForStyle */])(style);
    Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["a" /* forEachRule */])(ast, (rule) => {
      if (rule['selector'] === ':root') {
        rule['selector'] = 'html';
      }
      this.transformRule(rule);
    })
    style.textContent = Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["f" /* toCssText */])(ast);
    return ast;
  }
  /**
   * @param {StyleNode} rules
   * @param {string} elementName
   */
  transformRules(rules, elementName) {
    this._currentElement = elementName;
    Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["a" /* forEachRule */])(rules, (r) => {
      this.transformRule(r);
    });
    this._currentElement = null;
  }
  /**
   * @param {!StyleNode} rule
   */
  transformRule(rule) {
    rule['cssText'] = this.transformCssText(rule['parsedCssText']);
    // :root was only used for variable assignment in property shim,
    // but generates invalid selectors with real properties.
    // replace with `:host > *`, which serves the same effect
    if (rule['selector'] === ':root') {
      rule['selector'] = ':host > *';
    }
  }
  /**
   * @param {string} cssText
   * @return {string}
   */
  transformCssText(cssText) {
    // produce variables
    cssText = cssText.replace(__WEBPACK_IMPORTED_MODULE_1__common_regex_js__["c" /* VAR_ASSIGN */], (matchText, propertyName, valueProperty, valueMixin) =>
      this._produceCssProperties(matchText, propertyName, valueProperty, valueMixin));
    // consume mixins
    return this._consumeCssProperties(cssText);
  }
  /**
   * @param {string} property
   * @return {string}
   */
  _getInitialValueForProperty(property) {
    if (!this._measureElement) {
      this._measureElement = /** @type {HTMLMetaElement} */(document.createElement('meta'));
      this._measureElement.setAttribute('apply-shim-measure', '');
      this._measureElement.style.all = 'initial';
      document.head.appendChild(this._measureElement);
    }
    return window.getComputedStyle(this._measureElement).getPropertyValue(property);
  }
  /**
   * replace mixin consumption with variable consumption
   * @param {string} text
   * @return {string}
   */
  _consumeCssProperties(text) {
    /** @type {Array} */
    let m = null;
    // loop over text until all mixins with defintions have been applied
    while((m = __WEBPACK_IMPORTED_MODULE_1__common_regex_js__["b" /* MIXIN_MATCH */].exec(text))) {
      let matchText = m[0];
      let mixinName = m[1];
      let idx = m.index;
      // collect properties before apply to be "defaults" if mixin might override them
      // match includes a "prefix", so find the start and end positions of @apply
      let applyPos = idx + matchText.indexOf('@apply');
      let afterApplyPos = idx + matchText.length;
      // find props defined before this @apply
      let textBeforeApply = text.slice(0, applyPos);
      let textAfterApply = text.slice(afterApplyPos);
      let defaults = this._cssTextToMap(textBeforeApply);
      let replacement = this._atApplyToCssProperties(mixinName, defaults);
      // use regex match position to replace mixin, keep linear processing time
      text = `${textBeforeApply}${replacement}${textAfterApply}`;
      // move regex search to _after_ replacement
      __WEBPACK_IMPORTED_MODULE_1__common_regex_js__["b" /* MIXIN_MATCH */].lastIndex = idx + replacement.length;
    }
    return text;
  }
  /**
   * produce variable consumption at the site of mixin consumption
   * `@apply` --foo; -> for all props (${propname}: var(--foo_-_${propname}, ${fallback[propname]}}))
   * Example:
   *  border: var(--foo_-_border); padding: var(--foo_-_padding, 2px)
   *
   * @param {string} mixinName
   * @param {Object} fallbacks
   * @return {string}
   */
  _atApplyToCssProperties(mixinName, fallbacks) {
    mixinName = mixinName.replace(APPLY_NAME_CLEAN, '');
    let vars = [];
    let mixinEntry = this._map.get(mixinName);
    // if we depend on a mixin before it is created
    // make a sentinel entry in the map to add this element as a dependency for when it is defined.
    if (!mixinEntry) {
      this._map.set(mixinName, {});
      mixinEntry = this._map.get(mixinName);
    }
    if (mixinEntry) {
      if (this._currentElement) {
        mixinEntry.dependants[this._currentElement] = true;
      }
      let p, parts, f;
      for (p in mixinEntry.properties) {
        f = fallbacks && fallbacks[p];
        parts = [p, ': var(', mixinName, MIXIN_VAR_SEP, p];
        if (f) {
          parts.push(',', f);
        }
        parts.push(')');
        vars.push(parts.join(''));
      }
    }
    return vars.join('; ');
  }

  /**
   * @param {string} property
   * @param {string} value
   * @return {string}
   */
  _replaceInitialOrInherit(property, value) {
    let match = INITIAL_INHERIT.exec(value);
    if (match) {
      if (match[1]) {
        // initial
        // replace `initial` with the concrete initial value for this property
        value = this._getInitialValueForProperty(property);
      } else {
        // inherit
        // with this purposfully illegal value, the variable will be invalid at
        // compute time (https://www.w3.org/TR/css-variables/#invalid-at-computed-value-time)
        // and for inheriting values, will behave similarly
        // we cannot support the same behavior for non inheriting values like 'border'
        value = 'apply-shim-inherit';
      }
    }
    return value;
  }

  /**
   * "parse" a mixin definition into a map of properties and values
   * cssTextToMap('border: 2px solid black') -> ('border', '2px solid black')
   * @param {string} text
   * @return {!Object<string, string>}
   */
  _cssTextToMap(text) {
    let props = text.split(';');
    let property, value;
    let out = {};
    for (let i = 0, p, sp; i < props.length; i++) {
      p = props[i];
      if (p) {
        sp = p.split(':');
        // ignore lines that aren't definitions like @media
        if (sp.length > 1) {
          property = sp[0].trim();
          // some properties may have ':' in the value, like data urls
          value = this._replaceInitialOrInherit(property, sp.slice(1).join(':'));
          out[property] = value;
        }
      }
    }
    return out;
  }

  /**
   * @param {MixinMapEntry} mixinEntry
   */
  _invalidateMixinEntry(mixinEntry) {
    if (!invalidCallback) {
      return;
    }
    for (let elementName in mixinEntry.dependants) {
      if (elementName !== this._currentElement) {
        invalidCallback(elementName);
      }
    }
  }

  /**
   * @param {string} matchText
   * @param {string} propertyName
   * @param {?string} valueProperty
   * @param {?string} valueMixin
   * @return {string}
   */
  _produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {
    // handle case where property value is a mixin
    if (valueProperty) {
      // form: --mixin2: var(--mixin1), where --mixin1 is in the map
      Object(__WEBPACK_IMPORTED_MODULE_0__style_util_js__["d" /* processVariableAndFallback */])(valueProperty, (prefix, value) => {
        if (value && this._map.get(value)) {
          valueMixin = `@apply ${value};`
        }
      });
    }
    if (!valueMixin) {
      return matchText;
    }
    let mixinAsProperties = this._consumeCssProperties(valueMixin);
    let prefix = matchText.slice(0, matchText.indexOf('--'));
    let mixinValues = this._cssTextToMap(mixinAsProperties);
    let combinedProps = mixinValues;
    let mixinEntry = this._map.get(propertyName);
    let oldProps = mixinEntry && mixinEntry.properties;
    if (oldProps) {
      // NOTE: since we use mixin, the map of properties is updated here
      // and this is what we want.
      combinedProps = Object.assign(Object.create(oldProps), mixinValues);
    } else {
      this._map.set(propertyName, combinedProps);
    }
    let out = [];
    let p, v;
    // set variables defined by current mixin
    let needToInvalidate = false;
    for (p in combinedProps) {
      v = mixinValues[p];
      // if property not defined by current mixin, set initial
      if (v === undefined) {
        v = 'initial';
      }
      if (oldProps && !(p in oldProps)) {
        needToInvalidate = true;
      }
      out.push(`${propertyName}${MIXIN_VAR_SEP}${p}: ${v}`);
    }
    if (needToInvalidate) {
      this._invalidateMixinEntry(mixinEntry);
    }
    if (mixinEntry) {
      mixinEntry.properties = combinedProps;
    }
    // because the mixinMap is global, the mixin might conflict with
    // a different scope's simple variable definition:
    // Example:
    // some style somewhere:
    // --mixin1:{ ... }
    // --mixin2: var(--mixin1);
    // some other element:
    // --mixin1: 10px solid red;
    // --foo: var(--mixin1);
    // In this case, we leave the original variable definition in place.
    if (valueProperty) {
      prefix = `${matchText};${prefix}`;
    }
    return `${prefix}${out.join('; ')};`;
  }
}

/* exports */
ApplyShim.prototype['detectMixin'] = ApplyShim.prototype.detectMixin;
ApplyShim.prototype['transformStyle'] = ApplyShim.prototype.transformStyle;
ApplyShim.prototype['transformCustomStyle'] = ApplyShim.prototype.transformCustomStyle;
ApplyShim.prototype['transformRules'] = ApplyShim.prototype.transformRules;
ApplyShim.prototype['transformRule'] = ApplyShim.prototype.transformRule;
ApplyShim.prototype['transformTemplate'] = ApplyShim.prototype.transformTemplate;
ApplyShim.prototype['_separator'] = MIXIN_VAR_SEP;
Object.defineProperty(ApplyShim.prototype, 'invalidCallback', {
  /** @return {?function(string)} */
  get() {
    return invalidCallback;
  },
  /** @param {?function(string)} cb */
  set(cb) {
    invalidCallback = cb;
  }
});

/* harmony default export */ __webpack_exports__["a"] = (ApplyShim);

/***/ }),
/* 58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = processUnscopedStyle;
/* harmony export (immutable) */ __webpack_exports__["a"] = isUnscopedStyle;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/** @type {!Set<string>} */
const styleTextSet = new Set();

const scopingAttribute = 'shady-unscoped';
/* unused harmony export scopingAttribute */


/**
 * Add a specifically-marked style to the document directly, and only one copy of that style.
 *
 * @param {!HTMLStyleElement} style
 * @return {undefined}
 */
function processUnscopedStyle(style) {
  const text = style.textContent;
  if (!styleTextSet.has(text)) {
    styleTextSet.add(text);
    const newStyle = style.cloneNode(true);
    document.head.appendChild(newStyle);
  }
}

/**
 * Check if a style is supposed to be unscoped
 * @param {!HTMLStyleElement} style
 * @return {boolean} true if the style has the unscoping attribute
 */
function isUnscopedStyle(style) {
  return style.hasAttribute(scopingAttribute);
}

/***/ }),
/* 59 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = invalidate;
/* unused harmony export invalidateTemplate */
/* unused harmony export isValid */
/* harmony export (immutable) */ __webpack_exports__["c"] = templateIsValid;
/* unused harmony export isValidating */
/* harmony export (immutable) */ __webpack_exports__["d"] = templateIsValidating;
/* unused harmony export startValidating */
/* harmony export (immutable) */ __webpack_exports__["b"] = startValidatingTemplate;
/* unused harmony export elementsAreInvalid */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__template_map_js__ = __webpack_require__(38);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__css_parse_js__ = __webpack_require__(24);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



 // eslint-disable-line no-unused-vars

/*
 * Utilities for handling invalidating apply-shim mixins for a given template.
 *
 * The invalidation strategy involves keeping track of the "current" version of a template's mixins, and updating that count when a mixin is invalidated.
 * The template
 */

/** @const {string} */
const CURRENT_VERSION = '_applyShimCurrentVersion';

/** @const {string} */
const NEXT_VERSION = '_applyShimNextVersion';

/** @const {string} */
const VALIDATING_VERSION = '_applyShimValidatingVersion';

/**
 * @const {Promise<void>}
 */
const promise = Promise.resolve();

/**
 * @param {string} elementName
 */
function invalidate(elementName){
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  if (template) {
    invalidateTemplate(template);
  }
}

/**
 * This function can be called multiple times to mark a template invalid
 * and signal that the style inside must be regenerated.
 *
 * Use `startValidatingTemplate` to begin an asynchronous validation cycle.
 * During that cycle, call `templateIsValidating` to see if the template must
 * be revalidated
 * @param {HTMLTemplateElement} template
 */
function invalidateTemplate(template) {
  // default the current version to 0
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0;
  // ensure the "validating for" flag exists
  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0;
  // increment the next version
  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValid(elementName) {
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  if (template) {
    return templateIsValid(template);
  }
  return true;
}

/**
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}

/**
 * @param {string} elementName
 * @return {boolean}
 */
function isValidating(elementName) {
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  if (template) {
    return templateIsValidating(template);
  }
  return false;
}

/**
 * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.
 * If false, the template must be validated.
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */
function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}

/**
 * the template is marked as `validating` for one microtask so that all instances
 * found in the tree crawl of `applyStyle` will update themselves,
 * but the template will only be updated once.
 * @param {string} elementName
*/
function startValidating(elementName) {
  let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
  startValidatingTemplate(template);
}

/**
 * Begin an asynchronous invalidation cycle.
 * This should be called after every validation of a template
 *
 * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`
 * @param {HTMLTemplateElement} template
 */
function startValidatingTemplate(template) {
  // remember that the current "next version" is the reason for this validation cycle
  template[VALIDATING_VERSION] = template[NEXT_VERSION];
  // however, there only needs to be one async task to clear the counters
  if (!template._validating) {
    template._validating = true;
    promise.then(function() {
      // sync the current version to let future invalidations cause a refresh cycle
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}

/**
 * @return {boolean}
 */
function elementsAreInvalid() {
  for (let elementName in __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */]) {
    let template = __WEBPACK_IMPORTED_MODULE_0__template_map_js__["a" /* default */][elementName];
    if (!templateIsValid(template)) {
      return true;
    }
  }
  return false;
}

/***/ }),
/* 60 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);


// run a callback when HTMLImports are ready or immediately if
// this api is not available.
function whenImportsReady(cb) {
  if (window.HTMLImports) {
    HTMLImports.whenReady(cb);
  } else {
    cb();
  }
}

const importHref = function(href, onload, onerror, optAsync) {
  let link = /** @type {HTMLLinkElement} */
    (document.head.querySelector('link[href="' + href + '"][import-href]'));
  if (!link) {
    link = /** @type {HTMLLinkElement} */ (document.createElement('link'));
    link.rel = 'import';
    link.href = href;
    link.setAttribute('import-href', '');
  }
  // always ensure link has `async` attribute if user specified one,
  // even if it was previously not async. This is considered less confusing.
  if (optAsync) {
    link.setAttribute('async', '');
  }
  // NOTE: the link may now be in 3 states: (1) pending insertion,
  // (2) inflight, (3) already laoded. In each case, we need to add
  // event listeners to process callbacks.
  let cleanup = function() {
    link.removeEventListener('load', loadListener);
    link.removeEventListener('error', errorListener);
  };
  let loadListener = function(event) {
    cleanup();
    // In case of a successful load, cache the load event on the link so
    // that it can be used to short-circuit this method in the future when
    // it is called with the same href param.
    link.__dynamicImportLoaded = true;
    if (onload) {
      whenImportsReady(() => {
        onload(event);
      });
    }
  };
  let errorListener = function(event) {
    cleanup();
    // In case of an error, remove the link from the document so that it
    // will be automatically created again the next time `importHref` is
    // called.
    if (link.parentNode) {
      link.parentNode.removeChild(link);
    }
    if (onerror) {
      whenImportsReady(() => {
        onerror(event);
      });
    }
  };
  link.addEventListener('load', loadListener);
  link.addEventListener('error', errorListener);
  if (link.parentNode == null) {
    document.head.appendChild(link);
  // if the link already loaded, dispatch a fake load event
  // so that listeners are called and get a proper event argument.
  } else if (link.__dynamicImportLoaded) {
    link.dispatchEvent(new Event('load'));
  }
  return link;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = importHref;



/***/ }),
/* 61 */
/***/ (function(module, exports) {

function resolve() {
  document.body.removeAttribute('unresolved');
}

if (document.readyState === 'interactive' || document.readyState === 'complete') {
  resolve();
} else {
  window.addEventListener('DOMContentLoaded', resolve);
}


/***/ }),
/* 62 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FlattenedNodesObserver; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__array_splice_js__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__async_js__ = __webpack_require__(6);




/**
 * Returns true if `node` is a slot element
 * @param {HTMLElement} node Node to test.
 * @return {boolean} Returns true if the given `node` is a slot
 * @private
 */
function isSlot(node) {
  return (node.localName === 'slot');
}

/**
 * Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`. The list of flattened nodes consists
 * of a node's children and, for any children that are `<slot>` elements,
 * the expanded flattened list of `assignedNodes`.
 * For example, if the observed node has children `<a></a><slot></slot><b></b>`
 * and the `<slot>` has one `<div>` assigned to it, then the flattened
 * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
 * `<slot>` elements assigned to it, these are flattened as well.
 *
 * The provided `callback` is called whenever any change to this list
 * of flattened nodes occurs, where an addition or removal of a node is
 * considered a change. The `callback` is called with one argument, an object
 * containing an array of any `addedNodes` and `removedNodes`.
 *
 * Note: the callback is called asynchronous to any changes
 * at a microtask checkpoint. This is because observation is performed using
 * `MutationObserver` and the `<slot>` element's `slotchange` event which
 * are asynchronous.
 *
 * @memberof Polymer
 * @summary Class that listens for changes (additions or removals) to
 * "flattened nodes" on a given `node`.
 */
class FlattenedNodesObserver {

  /**
   * Returns the list of flattened nodes for the given `node`.
   * This list consists of a node's children and, for any children
   * that are `<slot>` elements, the expanded flattened list of `assignedNodes`.
   * For example, if the observed node has children `<a></a><slot></slot><b></b>`
   * and the `<slot>` has one `<div>` assigned to it, then the flattened
   * nodes list is `<a></a><div></div><b></b>`. If the `<slot>` has other
   * `<slot>` elements assigned to it, these are flattened as well.
   *
   * @param {HTMLElement|HTMLSlotElement} node The node for which to return the list of flattened nodes.
   * @return {Array} The list of flattened nodes for the given `node`.
  */
  static getFlattenedNodes(node) {
    if (isSlot(node)) {
      return /** @type {HTMLSlotElement} */ (node).assignedNodes({flatten: true});
    } else {
      return Array.from(node.childNodes).map(node => {
        if (isSlot(node)) {
          return /** @type {HTMLSlotElement} */ (node).assignedNodes({flatten: true});
        } else {
          return [node];
        }
      }).reduce((a, b) => a.concat(b), []);
    }
  }

  /**
   * @param {Node} target Node on which to listen for changes.
   * @param {Function} callback Function called when there are additions
   * or removals from the target's list of flattened nodes.
  */
  constructor(target, callback) {
    /** @type {MutationObserver} */
    this._shadyChildrenObserver = null;
    /** @type {MutationObserver} */
    this._nativeChildrenObserver = null;
    this._connected = false;
    this._target = target;
    this.callback = callback;
    this._effectiveNodes = [];
    this._observer = null;
    this._scheduled = false;
    /** @type {function()} */
    this._boundSchedule = () => {
      this._schedule();
    };
    this.connect();
    this._schedule();
  }

  /**
   * Activates an observer. This method is automatically called when
   * a `FlattenedNodesObserver` is created. It should only be called to
   * re-activate an observer that has been deactivated via the `disconnect` method.
   */
  connect() {
    if (isSlot(this._target)) {
      this._listenSlots([this._target]);
    } else {
      this._listenSlots(this._target.children);
      if (window.ShadyDOM) {
        this._shadyChildrenObserver =
          ShadyDOM.observeChildren(this._target, (mutations) => {
            this._processMutations(mutations);
          });
      } else {
        this._nativeChildrenObserver =
          new MutationObserver((mutations) => {
            this._processMutations(mutations);
          });
        this._nativeChildrenObserver.observe(this._target, {childList: true});
      }
    }
    this._connected = true;
  }

  /**
   * Deactivates the flattened nodes observer. After calling this method
   * the observer callback will not be called when changes to flattened nodes
   * occur. The `connect` method may be subsequently called to reactivate
   * the observer.
   */
  disconnect() {
    if (isSlot(this._target)) {
      this._unlistenSlots([this._target]);
    } else {
      this._unlistenSlots(this._target.children);
      if (window.ShadyDOM && this._shadyChildrenObserver) {
        ShadyDOM.unobserveChildren(this._shadyChildrenObserver);
        this._shadyChildrenObserver = null;
      } else if (this._nativeChildrenObserver) {
        this._nativeChildrenObserver.disconnect();
        this._nativeChildrenObserver = null;
      }
    }
    this._connected = false;
  }

  _schedule() {
    if (!this._scheduled) {
      this._scheduled = true;
      __WEBPACK_IMPORTED_MODULE_2__async_js__["a" /* microTask */].run(() => this.flush());
    }
  }

  _processMutations(mutations) {
    this._processSlotMutations(mutations);
    this.flush();
  }

  _processSlotMutations(mutations) {
    if (mutations) {
      for (let i=0; i < mutations.length; i++) {
        let mutation = mutations[i];
        if (mutation.addedNodes) {
          this._listenSlots(mutation.addedNodes);
        }
        if (mutation.removedNodes) {
          this._unlistenSlots(mutation.removedNodes);
        }
      }
    }
  }

  /**
   * Flushes the observer causing any pending changes to be immediately
   * delivered the observer callback. By default these changes are delivered
   * asynchronously at the next microtask checkpoint.
   *
   * @return {boolean} Returns true if any pending changes caused the observer
   * callback to run.
   */
  flush() {
    if (!this._connected) {
      return false;
    }
    if (window.ShadyDOM) {
      ShadyDOM.flush();
    }
    if (this._nativeChildrenObserver) {
      this._processSlotMutations(this._nativeChildrenObserver.takeRecords());
    } else if (this._shadyChildrenObserver) {
      this._processSlotMutations(this._shadyChildrenObserver.takeRecords());
    }
    this._scheduled = false;
    let info = {
      target: this._target,
      addedNodes: [],
      removedNodes: []
    };
    let newNodes = this.constructor.getFlattenedNodes(this._target);
    let splices = Object(__WEBPACK_IMPORTED_MODULE_1__array_splice_js__["a" /* calculateSplices */])(newNodes,
      this._effectiveNodes);
    // process removals
    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (let j=0, n; (j < s.removed.length) && (n=s.removed[j]); j++) {
        info.removedNodes.push(n);
      }
    }
    // process adds
    for (let i=0, s; (i<splices.length) && (s=splices[i]); i++) {
      for (let j=s.index; j < s.index + s.addedCount; j++) {
        info.addedNodes.push(newNodes[j]);
      }
    }
    // update cache
    this._effectiveNodes = newNodes;
    let didFlush = false;
    if (info.addedNodes.length || info.removedNodes.length) {
      didFlush = true;
      this.callback.call(this._target, info);
    }
    return didFlush;
  }

  _listenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      let n = nodeList[i];
      if (isSlot(n)) {
        n.addEventListener('slotchange', this._boundSchedule);
      }
    }
  }

  _unlistenSlots(nodeList) {
    for (let i=0; i < nodeList.length; i++) {
      let n = nodeList[i];
      if (isSlot(n)) {
        n.removeEventListener('slotchange', this._boundSchedule);
      }
    }
  }

}




/***/ }),
/* 63 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export mixinBehaviors */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__legacy_element_mixin_js__ = __webpack_require__(36);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__elements_dom_module_js__ = __webpack_require__(21);



let metaProps = {
  attached: true,
  detached: true,
  ready: true,
  created: true,
  beforeRegister: true,
  registered: true,
  attributeChanged: true,
  // meta objects
  behaviors: true
};

/**
 * Applies a "legacy" behavior or array of behaviors to the provided class.
 *
 * Note: this method will automatically also apply the `Polymer.LegacyElementMixin`
 * to ensure that any legacy behaviors can rely on legacy Polymer API on
 * the underlying element.
 *
 * @param {!(Object|Array)} behaviors Behavior object or array of behaviors.
 * @param {!HTMLElement|function(new:HTMLElement)} klass Element class.
 * @return {function(new:HTMLElement)} Returns a new Element class extended by the
 * passed in `behaviors` and also by `Polymer.LegacyElementMixin`.
 * @memberof Polymer
 * @suppress {invalidCasts, checkTypes}
 */
function mixinBehaviors(behaviors, klass) {
  if (!behaviors) {
    return /** @type {HTMLElement} */(klass);
  }
  // NOTE: ensure the bahevior is extending a class with
  // legacy element api. This is necessary since behaviors expect to be able
  // to access 1.x legacy api.
  klass = Object(__WEBPACK_IMPORTED_MODULE_0__legacy_element_mixin_js__["a" /* LegacyElementMixin */])(klass);
  if (!Array.isArray(behaviors)) {
    behaviors = [behaviors];
  }
  let superBehaviors = klass.prototype.behaviors;
  // get flattened, deduped list of behaviors *not* already on super class
  behaviors = flattenBehaviors(behaviors, null, superBehaviors);
  // mixin new behaviors
  klass = _mixinBehaviors(behaviors, klass);
  if (superBehaviors) {
    behaviors = superBehaviors.concat(behaviors);
  }
  // Set behaviors on prototype for BC...
  klass.prototype.behaviors = behaviors;
  return klass;
}

// NOTE:
// 1.x
// Behaviors were mixed in *in reverse order* and de-duped on the fly.
// The rule was that behavior properties were copied onto the element
// prototype if and only if the property did not already exist.
// Given: Polymer{ behaviors: [A, B, C, A, B]}, property copy order was:
// (1), B, (2), A, (3) C. This means prototype properties win over
// B properties win over A win over C. This mirrors what would happen
// with inheritance if element extended B extended A extended C.
//
// Again given, Polymer{ behaviors: [A, B, C, A, B]}, the resulting
// `behaviors` array was [C, A, B].
// Behavior lifecycle methods were called in behavior array order
// followed by the element, e.g. (1) C.created, (2) A.created,
// (3) B.created, (4) element.created. There was no support for
// super, and "super-behavior" methods were callable only by name).
//
// 2.x
// Behaviors are made into proper mixins which live in the
// element's prototype chain. Behaviors are placed in the element prototype
// eldest to youngest and de-duped youngest to oldest:
// So, first [A, B, C, A, B] becomes [C, A, B] then,
// the element prototype becomes (oldest) (1) Polymer.Element, (2) class(C),
// (3) class(A), (4) class(B), (5) class(Polymer({...})).
// Result:
// This means element properties win over B properties win over A win
// over C. (same as 1.x)
// If lifecycle is called (super then me), order is
// (1) C.created, (2) A.created, (3) B.created, (4) element.created
// (again same as 1.x)
function _mixinBehaviors(behaviors, klass) {
  for (let i=0; i<behaviors.length; i++) {
    let b = behaviors[i];
    if (b) {
      klass = Array.isArray(b) ? _mixinBehaviors(b, klass) :
        GenerateClassFromInfo(b, klass);
    }
  }
  return klass;
}

/**
 * @param {Array} behaviors List of behaviors to flatten.
 * @param {Array=} list Target list to flatten behaviors into.
 * @param {Array=} exclude List of behaviors to exclude from the list.
 * @return {!Array} Returns the list of flattened behaviors.
 */
function flattenBehaviors(behaviors, list, exclude) {
  list = list || [];
  for (let i=behaviors.length-1; i >= 0; i--) {
    let b = behaviors[i];
    if (b) {
      if (Array.isArray(b)) {
        flattenBehaviors(b, list);
      } else {
        // dedup
        if (list.indexOf(b) < 0 && (!exclude || exclude.indexOf(b) < 0)) {
          list.unshift(b);
        }
      }
    } else {
      console.warn('behavior is null, check for missing or 404 import');
    }
  }
  return list;
}

/**
 * @param {!PolymerInit} info Polymer info object
 * @param {function(new:HTMLElement)} Base base class to extend with info object
 * @return {function(new:HTMLElement)} Generated class
 * @suppress {checkTypes}
 * @private
 */
function GenerateClassFromInfo(info, Base) {

  class PolymerGenerated extends Base {

    static get properties() {
      return info.properties;
    }

    static get observers() {
      return info.observers;
    }

    /**
     * @return {HTMLTemplateElement} template for this class
     */
    static get template() {
      // get template first from any imperative set in `info._template`
      return info._template ||
        // next look in dom-module associated with this element's is.
        __WEBPACK_IMPORTED_MODULE_1__elements_dom_module_js__["a" /* DomModule */] && __WEBPACK_IMPORTED_MODULE_1__elements_dom_module_js__["a" /* DomModule */].import(this.is, 'template') ||
        // next look for superclass template (note: use superclass symbol
        // to ensure correct `this.is`)
        Base.template ||
        // finally fall back to `_template` in element's protoype.
        this.prototype._template ||
        null;
    }

    created() {
      super.created();
      if (info.created) {
        info.created.call(this);
      }
    }

    _registered() {
      super._registered();
      /* NOTE: `beforeRegister` is called here for bc, but the behavior
       is different than in 1.x. In 1.0, the method was called *after*
       mixing prototypes together but *before* processing of meta-objects.
       However, dynamic effects can still be set here and can be done either
       in `beforeRegister` or `registered`. It is no longer possible to set
       `is` in `beforeRegister` as you could in 1.x.
      */
      if (info.beforeRegister) {
        info.beforeRegister.call(Object.getPrototypeOf(this));
      }
      if (info.registered) {
        info.registered.call(Object.getPrototypeOf(this));
      }
    }

    _applyListeners() {
      super._applyListeners();
      if (info.listeners) {
        for (let l in info.listeners) {
          this._addMethodEventListenerToNode(this, l, info.listeners[l]);
        }
      }
    }

    // note: exception to "super then me" rule;
    // do work before calling super so that super attributes
    // only apply if not already set.
    _ensureAttributes() {
      if (info.hostAttributes) {
        for (let a in info.hostAttributes) {
          this._ensureAttribute(a, info.hostAttributes[a]);
        }
      }
      super._ensureAttributes();
    }

    ready() {
      super.ready();
      if (info.ready) {
        info.ready.call(this);
      }
    }

    attached() {
      super.attached();
      if (info.attached) {
        info.attached.call(this);
      }
    }

    detached() {
      super.detached();
      if (info.detached) {
        info.detached.call(this);
      }
    }

    attributeChanged(name, old, value) {
      super.attributeChanged(name, old, value);
      if (info.attributeChanged) {
        info.attributeChanged.call(this, name, old, value);
      }
   }
  }

  PolymerGenerated.generatedFrom = info;

  for (let p in info) {
    // NOTE: cannot copy `metaProps` methods onto prototype at least because
    // `super.ready` must be called and is not included in the user fn.
    if (!(p in metaProps)) {
      let pd = Object.getOwnPropertyDescriptor(info, p);
      if (pd) {
        Object.defineProperty(PolymerGenerated.prototype, p, pd);
      }
    }
  }

  return PolymerGenerated;
}

const Class = function(info) {
  if (!info) {
    console.warn('Polymer.Class requires `info` argument');
  }
  let klass = GenerateClassFromInfo(info, info.behaviors ?
    // note: mixinBehaviors ensures `LegacyElementMixin`.
    mixinBehaviors(info.behaviors, HTMLElement) :
    Object(__WEBPACK_IMPORTED_MODULE_0__legacy_element_mixin_js__["a" /* LegacyElementMixin */])(HTMLElement));
  // decorate klass with registration info
  klass.is = info.is;
  return klass;
};
/* harmony export (immutable) */ __webpack_exports__["a"] = Class;





/***/ }),
/* 64 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export Templatizer */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__ = __webpack_require__(29);


let TemplateInstanceBase = __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__["a" /* TemplateInstanceBase */]; // eslint-disable-line

/**
 * @typedef {{
 *   _templatizerTemplate: HTMLTemplateElement,
 *   _parentModel: boolean,
 *   _instanceProps: Object,
 *   _forwardHostPropV2: Function,
 *   _notifyInstancePropV2: Function,
 *   ctor: TemplateInstanceBase
 * }}
 */
let TemplatizerUser; // eslint-disable-line

/**
 * The `Polymer.Templatizer` behavior adds methods to generate instances of
 * templates that are each managed by an anonymous `Polymer.PropertyEffects`
 * instance where data-bindings in the stamped template content are bound to
 * accessors on itself.
 *
 * This behavior is provided in Polymer 2.x as a hybrid-element convenience
 * only.  For non-hybrid usage, the `Polymer.Templatize` library
 * should be used instead.
 *
 * Example:
 *
 *     // Get a template from somewhere, e.g. light DOM
 *     let template = this.querySelector('template');
 *     // Prepare the template
 *     this.templatize(template);
 *     // Instance the template with an initial data model
 *     let instance = this.stamp({myProp: 'initial'});
 *     // Insert the instance's DOM somewhere, e.g. light DOM
 *     Polymer.dom(this).appendChild(instance.root);
 *     // Changing a property on the instance will propagate to bindings
 *     // in the template
 *     instance.myProp = 'new value';
 *
 * Users of `Templatizer` may need to implement the following abstract
 * API's to determine how properties and paths from the host should be
 * forwarded into to instances:
 *
 *     _forwardHostPropV2: function(prop, value)
 *
 * Likewise, users may implement these additional abstract API's to determine
 * how instance-specific properties that change on the instance should be
 * forwarded out to the host, if necessary.
 *
 *     _notifyInstancePropV2: function(inst, prop, value)
 *
 * In order to determine which properties are instance-specific and require
 * custom notification via `_notifyInstanceProp`, define an `_instanceProps`
 * object containing keys for each instance prop, for example:
 *
 *     _instanceProps: {
 *       item: true,
 *       index: true
 *     }
 *
 * Any properties used in the template that are not defined in _instanceProp
 * will be forwarded out to the Templatize `owner` automatically.
 *
 * Users may also implement the following abstract function to show or
 * hide any DOM generated using `stamp`:
 *
 *     _showHideChildren: function(shouldHide)
 *
 * Note that some callbacks are suffixed with `V2` in the Polymer 2.x behavior
 * as the implementations will need to differ from the callbacks required
 * by the 1.x Templatizer API due to changes in the `TemplateInstance` API
 * between versions 1.x and 2.x.
 *
 * @polymerBehavior
 * @memberof Polymer
 */
let Templatizer = {

  /**
   * Generates an anonymous `TemplateInstance` class (stored as `this.ctor`)
   * for the provided template.  This method should be called once per
   * template to prepare an element for stamping the template, followed
   * by `stamp` to create new instances of the template.
   *
   * @param {HTMLTemplateElement} template Template to prepare
   * @param {boolean=} mutableData When `true`, the generated class will skip
   *   strict dirty-checking for objects and arrays (always consider them to
   *   be "dirty"). Defaults to false.
   * @this {TemplatizerUser}
   */
  templatize(template, mutableData) {
    this._templatizerTemplate = template;
    this.ctor = __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__["b" /* Templatize */].templatize(template, this, {
      mutableData: Boolean(mutableData),
      parentModel: this._parentModel,
      instanceProps: this._instanceProps,
      forwardHostProp: this._forwardHostPropV2,
      notifyInstanceProp: this._notifyInstancePropV2
    });
  },

  /**
   * Creates an instance of the template prepared by `templatize`.  The object
   * returned is an instance of the anonymous class generated by `templatize`
   * whose `root` property is a document fragment containing newly cloned
   * template content, and which has property accessors corresponding to
   * properties referenced in template bindings.
   *
   * @param {Object=} model Object containing initial property values to
   *   populate into the template bindings.
   * @return {TemplateInstanceBase} Returns the created instance of
   * the template prepared by `templatize`.
   * @this {TemplatizerUser}
   */
  stamp(model) {
    return new this.ctor(model);
  },

  /**
   * Returns the template "model" (`TemplateInstance`) associated with
   * a given element, which serves as the binding scope for the template
   * instance the element is contained in.  A template model should be used
   * to manipulate data associated with this template instance.
   *
   * @param {HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   * @this {TemplatizerUser}
   */
  modelForElement(el) {
    return __WEBPACK_IMPORTED_MODULE_0__utils_templatize_js__["b" /* Templatize */].modelForElement(this._templatizerTemplate, el);
  }
};




/***/ }),
/* 65 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomBind */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_boot_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__utils_boot_js__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mixins_gesture_event_listeners_js__ = __webpack_require__(41);





/**
 * @constructor
 * @extends {HTMLElement}
 * @implements {Polymer_PropertyEffects}
 * @implements {Polymer_OptionalMutableData}
 * @implements {Polymer_GestureEventListeners}
 */
const domBindBase =
  Object(__WEBPACK_IMPORTED_MODULE_3__mixins_gesture_event_listeners_js__["a" /* GestureEventListeners */])(
    Object(__WEBPACK_IMPORTED_MODULE_2__mixins_mutable_data_js__["b" /* OptionalMutableData */])(
      Object(__WEBPACK_IMPORTED_MODULE_1__mixins_property_effects_js__["a" /* PropertyEffects */])(HTMLElement)));

/**
 * Custom element to allow using Polymer's template features (data binding,
 * declarative event listeners, etc.) in the main document without defining
 * a new custom element.
 *
 * `<template>` tags utilizing bindings may be wrapped with the `<dom-bind>`
 * element, which will immediately stamp the wrapped template into the main
 * document and bind elements to the `dom-bind` element itself as the
 * binding scope.
 *
 * @polymer
 * @customElement
 * @appliesMixin Polymer.PropertyEffects
 * @appliesMixin Polymer.OptionalMutableData
 * @appliesMixin Polymer.GestureEventListeners
 * @extends {domBindBase}
 * @memberof Polymer
 * @summary Custom element to allow using Polymer's template features (data
 *   binding, declarative event listeners, etc.) in the main document.
 */
class DomBind extends domBindBase {

  static get observedAttributes() { return ['mutable-data']; }

  constructor() {
    super();
    this.root = null;
    this.$ = null;
    this.__children = null;
  }

  // assumes only one observed attribute
  attributeChangedCallback() {
    this.mutableData = true;
  }

  connectedCallback() {
    this.render();
  }

  disconnectedCallback() {
    this.__removeChildren();
  }

  __insertChildren() {
    this.parentNode.insertBefore(this.root, this);
  }

  __removeChildren() {
    if (this.__children) {
      for (let i=0; i<this.__children.length; i++) {
        this.root.appendChild(this.__children[i]);
      }
    }
  }

  /**
   * Forces the element to render its content. This is typically only
   * necessary to call if HTMLImports with the async attribute are used.
   */
  render() {
    let template;
    if (!this.__children) {
      template = /** @type {HTMLTemplateElement} */(template || this.querySelector('template'));
      if (!template) {
        // Wait until childList changes and template should be there by then
        let observer = new MutationObserver(() => {
          template = /** @type {HTMLTemplateElement} */(this.querySelector('template'));
          if (template) {
            observer.disconnect();
            this.render();
          } else {
            throw new Error('dom-bind requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return;
      }
      this.root = this._stampTemplate(template);
      this.$ = this.root.$;
      this.__children = [];
      for (let n=this.root.firstChild; n; n=n.nextSibling) {
        this.__children[this.__children.length] = n;
      }
      this._enableProperties();
    }
    this.__insertChildren();
    this.dispatchEvent(new CustomEvent('dom-change', {
      bubbles: true,
      composed: true
    }));
  }

}

customElements.define('dom-bind', DomBind);




/***/ }),
/* 66 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomRepeat */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__mixins_mutable_data_js__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_path_js__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_async_js__ = __webpack_require__(6);








let TemplateInstanceBase = __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["a" /* TemplateInstanceBase */]; // eslint-disable-line

/**
 * @constructor
 * @implements {Polymer_OptionalMutableData}
 * @extends {Polymer.Element}
 */
const domRepeatBase = Object(__WEBPACK_IMPORTED_MODULE_4__mixins_mutable_data_js__["b" /* OptionalMutableData */])(__WEBPACK_IMPORTED_MODULE_0__polymer_element_js__["a" /* Element */]);

/**
 * The `<dom-repeat>` element will automatically stamp and binds one instance
 * of template content to each object in a user-provided array.
 * `dom-repeat` accepts an `items` property, and one instance of the template
 * is stamped for each item into the DOM at the location of the `dom-repeat`
 * element.  The `item` property will be set on each instance's binding
 * scope, thus templates should bind to sub-properties of `item`.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 *   <script>
 *     Polymer({
 *       is: 'employee-list',
 *       ready: function() {
 *         this.employees = [
 *             {first: 'Bob', last: 'Smith'},
 *             {first: 'Sally', last: 'Johnson'},
 *             ...
 *         ];
 *       }
 *     });
 *   < /script>
 *
 * </dom-module>
 * ```
 *
 * Notifications for changes to items sub-properties will be forwarded to template
 * instances, which will update via the normal structured data notification system.
 *
 * Mutations to the `items` array itself should be made using the Array
 * mutation API's on `Polymer.Base` (`push`, `pop`, `splice`, `shift`,
 * `unshift`), and template instances will be kept in sync with the data in the
 * array.
 *
 * Events caught by event handlers within the `dom-repeat` template will be
 * decorated with a `model` property, which represents the binding scope for
 * each template instance.  The model is an instance of Polymer.Base, and should
 * be used to manipulate data on the instance, for example
 * `event.model.set('item.checked', true);`.
 *
 * Alternatively, the model for a template instance for an element stamped by
 * a `dom-repeat` can be obtained using the `modelForElement` API on the
 * `dom-repeat` that stamped it, for example
 * `this.$.domRepeat.modelForElement(event.target).set('item.checked', true);`.
 * This may be useful for manipulating instance data of event targets obtained
 * by event handlers on parents of the `dom-repeat` (event delegation).
 *
 * A view-specific filter/sort may be applied to each `dom-repeat` by supplying a
 * `filter` and/or `sort` property.  This may be a string that names a function on
 * the host, or a function may be assigned to the property directly.  The functions
 * should implemented following the standard `Array` filter/sort API.
 *
 * In order to re-run the filter or sort functions based on changes to sub-fields
 * of `items`, the `observe` property may be set as a space-separated list of
 * `item` sub-fields that should cause a re-filter/sort when modified.  If
 * the filter or sort function depends on properties not contained in `items`,
 * the user should observe changes to those properties and call `render` to update
 * the view based on the dependency change.
 *
 * For example, for an `dom-repeat` with a filter of the following:
 *
 * ```js
 * isEngineer: function(item) {
 *     return item.type == 'engineer' || item.manager.type == 'engineer';
 * }
 * ```
 *
 * Then the `observe` property should be configured as follows:
 *
 * ```html
 * <template is="dom-repeat" items="{{employees}}"
 *           filter="isEngineer" observe="type manager.type">
 * ```
 *
 * @customElement
 * @polymer
 * @memberof Polymer
 * @extends {domRepeatBase}
 * @appliesMixin Polymer.OptionalMutableData
 * @summary Custom element for stamping instance of a template bound to
 *   items in an array.
 */
class DomRepeat extends domRepeatBase {

  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'dom-repeat'; }

  static get template() { return null; }

  static get properties() {

    /**
     * Fired whenever DOM is added or removed by this template (by
     * default, rendering occurs lazily).  To force immediate rendering, call
     * `render`.
     *
     * @event dom-change
     */
    return {

      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },

      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: 'item'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the sorted and filtered list of rendered items.
       * Note, for the index in the `this.items` array, use the value of the
       * `itemsIndexAs` property.
       */
      indexAs: {
        type: String,
        value: 'index'
      },

      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the `this.items` array. Note, for the index of
       * this instance in the sorted and filtered list of rendered items,
       * use the value of the `indexAs` property.
       */
      itemsIndexAs: {
        type: String,
        value: 'itemsIndex'
      },

      /**
       * A function that should determine the sort order of the items.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.sort`.
       * Using a sort function has no effect on the underlying `items` array.
       */
      sort: {
        type: Function,
        observer: '__sortChanged'
      },

      /**
       * A function that can be used to filter items out of the view.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.filter`.
       * Using a filter function has no effect on the underlying `items` array.
       */
      filter: {
        type: Function,
        observer: '__filterChanged'
      },

      /**
       * When using a `filter` or `sort` function, the `observe` property
       * should be set to a space-separated list of the names of item
       * sub-fields that should trigger a re-sort or re-filter when changed.
       * These should generally be fields of `item` that the sort or filter
       * function depends on.
       */
      observe: {
        type: String,
        observer: '__observeChanged'
      },

      /**
       * When using a `filter` or `sort` function, the `delay` property
       * determines a debounce time after a change to observed item
       * properties that must pass before the filter or sort is re-run.
       * This is useful in rate-limiting shuffing of the view when
       * item changes may be frequent.
       */
      delay: Number,

      /**
       * Count of currently rendered items after `filter` (if any) has been applied.
       * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
       * set of template instances is rendered.
       *
       */
      renderedItemCount: {
        type: Number,
        notify: true,
        readOnly: true
      },

      /**
       * Defines an initial count of template instances to render after setting
       * the `items` array, before the next paint, and puts the `dom-repeat`
       * into "chunking mode".  The remaining items will be created and rendered
       * incrementally at each animation frame therof until all instances have
       * been rendered.
       */
      initialCount: {
        type: Number,
        observer: '__initializeChunking'
      },

      /**
       * When `initialCount` is used, this property defines a frame rate to
       * target by throttling the number of instances rendered each frame to
       * not exceed the budget for the target frame rate.  Setting this to a
       * higher number will allow lower latency and higher throughput for
       * things like event handlers, but will result in a longer time for the
       * remaining items to complete rendering.
       */
      targetFramerate: {
        type: Number,
        value: 20
      },

      _targetFrameTime: {
        type: Number,
        computed: '__computeFrameTime(targetFramerate)'
      }

    };

  }

  static get observers() {
    return [ '__itemsChanged(items.*)' ];
  }

  constructor() {
    super();
    this.__instances = [];
    this.__limit = Infinity;
    this.__pool = [];
    this.__renderDebouncer = null;
    this.__itemsIdxToInstIdx = {};
    this.__chunkCount = null;
    this.__lastChunkTime = null;
    this.__sortFn = null;
    this.__filterFn = null;
    this.__observePaths = null;
    this.__ctor = null;
    this.__isDetached = true;
    this.template = null;
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isDetached = true;
    for (let i=0; i<this.__instances.length; i++) {
      this.__detachInstance(i);
    }
  }

  connectedCallback() {
    super.connectedCallback();
    // only perform attachment if the element was previously detached.
    if (this.__isDetached) {
      this.__isDetached = false;
      let parent = this.parentNode;
      for (let i=0; i<this.__instances.length; i++) {
        this.__attachInstance(i, parent);
      }
    }
  }

  __ensureTemplatized() {
    // Templatizing (generating the instance constructor) needs to wait
    // until ready, since won't have its template content handed back to
    // it until then
    if (!this.__ctor) {
      let template = this.template = this.querySelector('template');
      if (!template) {
        // // Wait until childList changes and template should be there by then
        let observer = new MutationObserver(() => {
          if (this.querySelector('template')) {
            observer.disconnect();
            this.__render();
          } else {
            throw new Error('dom-repeat requires a <template> child');
          }
        });
        observer.observe(this, {childList: true});
        return false;
      }
      // Template instance props that should be excluded from forwarding
      let instanceProps = {};
      instanceProps[this.as] = true;
      instanceProps[this.indexAs] = true;
      instanceProps[this.itemsIndexAs] = true;
      this.__ctor = __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["b" /* Templatize */].templatize(template, this, {
        mutableData: this.mutableData,
        parentModel: true,
        instanceProps: instanceProps,
        /**
         * @this {this}
         * @param {string} prop Property to set
         * @param {*} value Value to set property to
         */
        forwardHostProp: function(prop, value) {
          let i$ = this.__instances;
          for (let i=0, inst; (i<i$.length) && (inst=i$[i]); i++) {
            inst.forwardHostProp(prop, value);
          }
        },
        /**
         * @this {this}
         * @param {Object} inst Instance to notify
         * @param {string} prop Property to notify
         * @param {*} value Value to notify
         */
        notifyInstanceProp: function(inst, prop, value) {
          if (Object(__WEBPACK_IMPORTED_MODULE_5__utils_path_js__["e" /* matches */])(this.as, prop)) {
            let idx = inst[this.itemsIndexAs];
            if (prop == this.as) {
              this.items[idx] = value;
            }
            let path = Object(__WEBPACK_IMPORTED_MODULE_5__utils_path_js__["i" /* translate */])(this.as, 'items.' + idx, prop);
            this.notifyPath(path, value);
          }
        }
      });
    }
    return true;
  }

  __getMethodHost() {
    // Technically this should be the owner of the outermost template.
    // In shadow dom, this is always getRootNode().host, but we can
    // approximate this via cooperation with our dataHost always setting
    // `_methodHost` as long as there were bindings (or id's) on this
    // instance causing it to get a dataHost.
    return this.__dataHost._methodHost || this.__dataHost;
  }

  __sortChanged(sort) {
    let methodHost = this.__getMethodHost();
    this.__sortFn = sort && (typeof sort == 'function' ? sort :
      function() { return methodHost[sort].apply(methodHost, arguments); });
    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }

  __filterChanged(filter) {
    let methodHost = this.__getMethodHost();
    this.__filterFn = filter && (typeof filter == 'function' ? filter :
      function() { return methodHost[filter].apply(methodHost, arguments); });
    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }

  __computeFrameTime(rate) {
    return Math.ceil(1000/rate);
  }

  __initializeChunking() {
    if (this.initialCount) {
      this.__limit = this.initialCount;
      this.__chunkCount = this.initialCount;
      this.__lastChunkTime = performance.now();
    }
  }

  __tryRenderChunk() {
    // Debounced so that multiple calls through `_render` between animation
    // frames only queue one new rAF (e.g. array mutation & chunked render)
    if (this.items && this.__limit < this.items.length) {
      this.__debounceRender(this.__requestRenderChunk);
    }
  }

  __requestRenderChunk() {
    requestAnimationFrame(()=>this.__renderChunk());
  }

  __renderChunk() {
    // Simple auto chunkSize throttling algorithm based on feedback loop:
    // measure actual time between frames and scale chunk count by ratio
    // of target/actual frame time
    let currChunkTime = performance.now();
    let ratio = this._targetFrameTime / (currChunkTime - this.__lastChunkTime);
    this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
    this.__limit += this.__chunkCount;
    this.__lastChunkTime = currChunkTime;
    this.__debounceRender(this.__render);
  }

  __observeChanged() {
    this.__observePaths = this.observe &&
      this.observe.replace('.*', '.').split(' ');
  }

  __itemsChanged(change) {
    if (this.items && !Array.isArray(this.items)) {
      console.warn('dom-repeat expected array for `items`, found', this.items);
    }
    // If path was to an item (e.g. 'items.3' or 'items.3.foo'), forward the
    // path to that instance synchronously (retuns false for non-item paths)
    if (!this.__handleItemPath(change.path, change.value)) {
      // Otherwise, the array was reset ('items') or spliced ('items.splices'),
      // so queue a full refresh
      this.__initializeChunking();
      this.__debounceRender(this.__render);
    }
  }

  __handleObservedPaths(path) {
    if (this.__observePaths) {
      path = path.substring(path.indexOf('.') + 1);
      let paths = this.__observePaths;
      for (let i=0; i<paths.length; i++) {
        if (path.indexOf(paths[i]) === 0) {
          this.__debounceRender(this.__render, this.delay);
          return true;
        }
      }
    }
  }

  /**
   * @param {function(this:DomRepeat)} fn Function to debounce.
   * @param {number=} delay Delay in ms to debounce by.
   */
  __debounceRender(fn, delay = 0) {
    this.__renderDebouncer = __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__["a" /* Debouncer */].debounce(
          this.__renderDebouncer
        , delay > 0 ? __WEBPACK_IMPORTED_MODULE_6__utils_async_js__["b" /* timeOut */].after(delay) : __WEBPACK_IMPORTED_MODULE_6__utils_async_js__["a" /* microTask */]
        , fn.bind(this));
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["a" /* enqueueDebouncer */])(this.__renderDebouncer);
  }

  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   */
  render() {
    // Queue this repeater, then flush all in order
    this.__debounceRender(this.__render);
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["b" /* flush */])();
  }

  __render() {
    if (!this.__ensureTemplatized()) {
      // No template found yet
      return;
    }
    this.__applyFullRefresh();
    // Reset the pool
    // TODO(kschaaf): Reuse pool across turns and nested templates
    // Now that objects/arrays are re-evaluated when set, we can safely
    // reuse pooled instances across turns, however we still need to decide
    // semantics regarding how long to hold, how many to hold, etc.
    this.__pool.length = 0;
    // Set rendered item count
    this._setRenderedItemCount(this.__instances.length);
    // Notify users
    this.dispatchEvent(new CustomEvent('dom-change', {
      bubbles: true,
      composed: true
    }));
    // Check to see if we need to render more items
    this.__tryRenderChunk();
  }

  __applyFullRefresh() {
    let items = this.items || [];
    let isntIdxToItemsIdx = new Array(items.length);
    for (let i=0; i<items.length; i++) {
      isntIdxToItemsIdx[i] = i;
    }
    // Apply user filter
    if (this.__filterFn) {
      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i, idx, array) =>
        this.__filterFn(items[i], idx, array));
    }
    // Apply user sort
    if (this.__sortFn) {
      isntIdxToItemsIdx.sort((a, b) => this.__sortFn(items[a], items[b]));
    }
    // items->inst map kept for item path forwarding
    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
    let instIdx = 0;
    // Generate instances and assign items
    const limit = Math.min(isntIdxToItemsIdx.length, this.__limit);
    for (; instIdx<limit; instIdx++) {
      let inst = this.__instances[instIdx];
      let itemIdx = isntIdxToItemsIdx[instIdx];
      let item = items[itemIdx];
      itemsIdxToInstIdx[itemIdx] = instIdx;
      if (inst && instIdx < this.__limit) {
        inst._setPendingProperty(this.as, item);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        this.__insertInstance(item, instIdx, itemIdx);
      }
    }
    // Remove any extra instances from previous state
    for (let i=this.__instances.length-1; i>=instIdx; i--) {
      this.__detachAndRemoveInstance(i);
    }
  }

  __detachInstance(idx) {
    let inst = this.__instances[idx];
    for (let i=0; i<inst.children.length; i++) {
      let el = inst.children[i];
      inst.root.appendChild(el);
    }
    return inst;
  }

  __attachInstance(idx, parent) {
    let inst = this.__instances[idx];
    parent.insertBefore(inst.root, this);
  }

  __detachAndRemoveInstance(idx) {
    let inst = this.__detachInstance(idx);
    if (inst) {
      this.__pool.push(inst);
    }
    this.__instances.splice(idx, 1);
  }

  __stampInstance(item, instIdx, itemIdx) {
    let model = {};
    model[this.as] = item;
    model[this.indexAs] = instIdx;
    model[this.itemsIndexAs] = itemIdx;
    return new this.__ctor(model);
  }

  __insertInstance(item, instIdx, itemIdx) {
    let inst = this.__pool.pop();
    if (inst) {
      // TODO(kschaaf): If the pool is shared across turns, hostProps
      // need to be re-set to reused instances in addition to item
      inst._setPendingProperty(this.as, item);
      inst._setPendingProperty(this.indexAs, instIdx);
      inst._setPendingProperty(this.itemsIndexAs, itemIdx);
      inst._flushProperties();
    } else {
      inst = this.__stampInstance(item, instIdx, itemIdx);
    }
    let beforeRow = this.__instances[instIdx + 1];
    let beforeNode = beforeRow ? beforeRow.children[0] : this;
    this.parentNode.insertBefore(inst.root, beforeNode);
    this.__instances[instIdx] = inst;
    return inst;
  }

  // Implements extension point from Templatize mixin
  _showHideChildren(hidden) {
    for (let i=0; i<this.__instances.length; i++) {
      this.__instances[i]._showHideChildren(hidden);
    }
  }

  // Called as a side effect of a host items.<key>.<path> path change,
  // responsible for notifying item.<path> changes to inst for key
  __handleItemPath(path, value) {
    let itemsPath = path.slice(6); // 'items.'.length == 6
    let dot = itemsPath.indexOf('.');
    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
    // If path was index into array...
    if (itemsIdx == parseInt(itemsIdx, 10)) {
      let itemSubPath = dot < 0 ? '' : itemsPath.substring(dot+1);
      // If the path is observed, it will trigger a full refresh
      this.__handleObservedPaths(itemSubPath);
      // Note, even if a rull refresh is triggered, always do the path
      // notification because unless mutableData is used for dom-repeat
      // and all elements in the instance subtree, a full refresh may
      // not trigger the proper update.
      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
      let inst = this.__instances[instIdx];
      if (inst) {
        let itemPath = this.as + (itemSubPath ? '.' + itemSubPath : '');
        // This is effectively `notifyPath`, but avoids some of the overhead
        // of the public API
        inst._setPendingPropertyOrPath(itemPath, value, false, true);
        inst._flushProperties();
      }
      return true;
    }
  }

  /**
   * Returns the item associated with a given element stamped by
   * this `dom-repeat`.
   *
   * Note, to modify sub-properties of the item,
   * `modelForElement(el).set('item.<sub-prop>', value)`
   * should be used.
   *
   * @param {HTMLElement} el Element for which to return the item.
   * @return {*} Item associated with the element.
   */
  itemForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.as];
  }

  /**
   * Returns the inst index for a given element stamped by this `dom-repeat`.
   * If `sort` is provided, the index will reflect the sorted order (rather
   * than the original array order).
   *
   * @param {HTMLElement} el Element for which to return the index.
   * @return {*} Row index associated with the element (note this may
   *   not correspond to the array index if a user `sort` is applied).
   */
  indexForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.indexAs];
  }

  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model is an instance of `Polymer.Base`, and
   * should be used to manipulate data associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @param {HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   */
  modelForElement(el) {
    return __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["b" /* Templatize */].modelForElement(this.template, el);
  }

}

customElements.define(DomRepeat.is, DomRepeat);




/***/ }),
/* 67 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export DomIf */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__ = __webpack_require__(29);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_flush_js__ = __webpack_require__(28);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_async_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_path_js__ = __webpack_require__(11);







/**
 * The `<dom-if>` element will stamp a light-dom `<template>` child when
 * the `if` property becomes truthy, and the template can use Polymer
 * data-binding and declarative event features when used in the context of
 * a Polymer element's template.
 *
 * When `if` becomes falsey, the stamped content is hidden but not
 * removed from dom. When `if` subsequently becomes truthy again, the content
 * is simply re-shown. This approach is used due to its favorable performance
 * characteristics: the expense of creating template content is paid only
 * once and lazily.
 *
 * Set the `restamp` property to true to force the stamped content to be
 * created / destroyed when the `if` condition changes.
 *
 * @customElement
 * @polymer
 * @extends Polymer.Element
 * @memberof Polymer
 * @summary Custom element that conditionally stamps and hides or removes
 *   template content based on a boolean flag.
 */
class DomIf extends __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__["a" /* Element */] {

  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'dom-if'; }

  static get template() { return null; }

  static get properties() {

    return {

      /**
       * Fired whenever DOM is added or removed/hidden by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */

      /**
       * A boolean indicating whether this template should stamp.
       */
      if: {
        type: Boolean,
        observer: '__debounceRender'
      },

      /**
       * When true, elements will be removed from DOM and discarded when `if`
       * becomes false and re-created and added back to the DOM when `if`
       * becomes true.  By default, stamped elements will be hidden but left
       * in the DOM when `if` becomes false, which is generally results
       * in better performance.
       */
      restamp: {
        type: Boolean,
        observer: '__debounceRender'
      }

    };

  }

  constructor() {
    super();
    this.__renderDebouncer = null;
    this.__invalidProps = null;
    this.__instance = null;
    this._lastIf = false;
    this.__ctor = null;
  }

  __debounceRender() {
    // Render is async for 2 reasons:
    // 1. To eliminate dom creation trashing if user code thrashes `if` in the
    //    same turn. This was more common in 1.x where a compound computed
    //    property could result in the result changing multiple times, but is
    //    mitigated to a large extent by batched property processing in 2.x.
    // 2. To avoid double object propagation when a bag including values bound
    //    to the `if` property as well as one or more hostProps could enqueue
    //    the <dom-if> to flush before the <template>'s host property
    //    forwarding. In that scenario creating an instance would result in
    //    the host props being set once, and then the enqueued changes on the
    //    template would set properties a second time, potentially causing an
    //    object to be set to an instance more than once.  Creating the
    //    instance async from flushing data ensures this doesn't happen. If
    //    we wanted a sync option in the future, simply having <dom-if> flush
    //    (or clear) its template's pending host properties before creating
    //    the instance would also avoid the problem.
    this.__renderDebouncer = __WEBPACK_IMPORTED_MODULE_2__utils_debounce_js__["a" /* Debouncer */].debounce(
          this.__renderDebouncer
        , __WEBPACK_IMPORTED_MODULE_4__utils_async_js__["a" /* microTask */]
        , () => this.__render());
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["a" /* enqueueDebouncer */])(this.__renderDebouncer);
  }

  disconnectedCallback() {
    super.disconnectedCallback();
    if (!this.parentNode ||
        (this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE &&
         !this.parentNode.host)) {
      this.__teardownInstance();
    }
  }

  connectedCallback() {
    super.connectedCallback();
    if (this.if) {
      this.__debounceRender();
    }
  }

  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   */
  render() {
    Object(__WEBPACK_IMPORTED_MODULE_3__utils_flush_js__["b" /* flush */])();
  }

  __render() {
    if (this.if) {
      if (!this.__ensureInstance()) {
        // No template found yet
        return;
      }
      this._showHideChildren();
    } else if (this.restamp) {
      this.__teardownInstance();
    }
    if (!this.restamp && this.__instance) {
      this._showHideChildren();
    }
    if (this.if != this._lastIf) {
      this.dispatchEvent(new CustomEvent('dom-change', {
        bubbles: true,
        composed: true
      }));
      this._lastIf = this.if;
    }
  }

  __ensureInstance() {
    let parentNode = this.parentNode;
    // Guard against element being detached while render was queued
    if (parentNode) {
      if (!this.__ctor) {
        let template = this.querySelector('template');
        if (!template) {
          // Wait until childList changes and template should be there by then
          let observer = new MutationObserver(() => {
            if (this.querySelector('template')) {
              observer.disconnect();
              this.__render();
            } else {
              throw new Error('dom-if requires a <template> child');
            }
          });
          observer.observe(this, {childList: true});
          return false;
        }
        this.__ctor = __WEBPACK_IMPORTED_MODULE_1__utils_templatize_js__["b" /* Templatize */].templatize(template, this, {
          // dom-if templatizer instances require `mutable: true`, as
          // `__syncHostProperties` relies on that behavior to sync objects
          mutableData: true,
          /**
           * @param {string} prop Property to forward
           * @param {*} value Value of property
           * @this {this}
           */
          forwardHostProp: function(prop, value) {
            if (this.__instance) {
              if (this.if) {
                this.__instance.forwardHostProp(prop, value);
              } else {
                // If we have an instance but are squelching host property
                // forwarding due to if being false, note the invalidated
                // properties so `__syncHostProperties` can sync them the next
                // time `if` becomes true
                this.__invalidProps = this.__invalidProps || Object.create(null);
                this.__invalidProps[Object(__WEBPACK_IMPORTED_MODULE_5__utils_path_js__["g" /* root */])(prop)] = true;
              }
            }
          }
        });
      }
      if (!this.__instance) {
        this.__instance = new this.__ctor();
        parentNode.insertBefore(this.__instance.root, this);
      } else {
        this.__syncHostProperties();
        let c$ = this.__instance.children;
        if (c$ && c$.length) {
          // Detect case where dom-if was re-attached in new position
          let lastChild = this.previousSibling;
          if (lastChild !== c$[c$.length-1]) {
            for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
              parentNode.insertBefore(n, this);
            }
          }
        }
      }
    }
    return true;
  }

  __syncHostProperties() {
    let props = this.__invalidProps;
    if (props) {
      for (let prop in props) {
        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
      }
      this.__invalidProps = null;
      this.__instance._flushProperties();
    }
  }

  __teardownInstance() {
    if (this.__instance) {
      let c$ = this.__instance.children;
      if (c$ && c$.length) {
        // use first child parent, for case when dom-if may have been detached
        let parent = c$[0].parentNode;
        for (let i=0, n; (i<c$.length) && (n=c$[i]); i++) {
          parent.removeChild(n);
        }
      }
      this.__instance = null;
      this.__invalidProps = null;
    }
  }

  _showHideChildren() {
    let hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance) {
      this.__instance._showHideChildren(hidden);
    }
  }

}

customElements.define(DomIf.is, DomIf);




/***/ }),
/* 68 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export ArraySelectorMixin */
/* unused harmony export ArraySelector */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_element_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_array_splice_js__ = __webpack_require__(42);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__mixins_element_mixin_js__ = __webpack_require__(20);





/**
 * Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array such that path changes to the
 * master array (at the host) element or elsewhere via data-binding) are
 * correctly propagated to items in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * @polymer
 * @mixinFunction
 * @appliesMixin Polymer.ElementMixin
 * @memberof Polymer
 * @summary Element mixin for recording dynamic associations between item paths in a
 * master `items` array and a `selected` array
 */
let ArraySelectorMixin = Object(__WEBPACK_IMPORTED_MODULE_1__utils_mixin_js__["a" /* dedupingMixin */])(superClass => {

  /**
   * @constructor
   * @extends {superClass}
   * @implements {Polymer_ElementMixin}
   */
  let elementBase = Object(__WEBPACK_IMPORTED_MODULE_3__mixins_element_mixin_js__["a" /* ElementMixin */])(superClass);

  /**
   * @polymer
   * @mixinClass
   * @implements {Polymer_ArraySelectorMixin}
   * @unrestricted
   */
  class ArraySelectorMixin extends elementBase {

    static get properties() {

      return {

        /**
         * An array containing items from which selection will be made.
         */
        items: {
          type: Array,
        },

        /**
         * When `true`, multiple items may be selected at once (in this case,
         * `selected` is an array of currently selected items).  When `false`,
         * only one item may be selected at a time.
         */
        multi: {
          type: Boolean,
          value: false,
        },

        /**
         * When `multi` is true, this is an array that contains any selected.
         * When `multi` is false, this is the currently selected item, or `null`
         * if no item is selected.
         * @type {?(Object|Array<!Object>)}
         */
        selected: {
          type: Object,
          notify: true
        },

        /**
         * When `multi` is false, this is the currently selected item, or `null`
         * if no item is selected.
         * @type {?Object}
         */
        selectedItem: {
          type: Object,
          notify: true
        },

        /**
         * When `true`, calling `select` on an item that is already selected
         * will deselect the item.
         */
        toggle: {
          type: Boolean,
          value: false
        }

      };
    }

    static get observers() {
      return ['__updateSelection(multi, items.*)'];
    }

    constructor() {
      super();
      this.__lastItems = null;
      this.__lastMulti = null;
      this.__selectedMap = null;
    }

    __updateSelection(multi, itemsInfo) {
      let path = itemsInfo.path;
      if (path == 'items') {
        // Case 1 - items array changed, so diff against previous array and
        // deselect any removed items and adjust selected indices
        let newItems = itemsInfo.base || [];
        let lastItems = this.__lastItems;
        let lastMulti = this.__lastMulti;
        if (multi !== lastMulti) {
          this.clearSelection();
        }
        if (lastItems) {
          let splices = Object(__WEBPACK_IMPORTED_MODULE_2__utils_array_splice_js__["a" /* calculateSplices */])(newItems, lastItems);
          this.__applySplices(splices);
        }
        this.__lastItems = newItems;
        this.__lastMulti = multi;
      } else if (itemsInfo.path == 'items.splices') {
        // Case 2 - got specific splice information describing the array mutation:
        // deselect any removed items and adjust selected indices
        this.__applySplices(itemsInfo.value.indexSplices);
      } else {
        // Case 3 - an array element was changed, so deselect the previous
        // item for that index if it was previously selected
        let part = path.slice('items.'.length);
        let idx = parseInt(part, 10);
        if ((part.indexOf('.') < 0) && part == idx) {
          this.__deselectChangedIdx(idx);
        }
      }
    }

    __applySplices(splices) {
      let selected = this.__selectedMap;
      // Adjust selected indices and mark removals
      for (let i=0; i<splices.length; i++) {
        let s = splices[i];
        selected.forEach((idx, item) => {
          if (idx < s.index) {
            // no change
          } else if (idx >= s.index + s.removed.length) {
            // adjust index
            selected.set(item, idx + s.addedCount - s.removed.length);
          } else {
            // remove index
            selected.set(item, -1);
          }
        });
        for (let j=0; j<s.addedCount; j++) {
          let idx = s.index + j;
          if (selected.has(this.items[idx])) {
            selected.set(this.items[idx], idx);
          }
        }
      }
      // Update linked paths
      this.__updateLinks();
      // Remove selected items that were removed from the items array
      let sidx = 0;
      selected.forEach((idx, item) => {
        if (idx < 0) {
          if (this.multi) {
            this.splice('selected', sidx, 1);
          } else {
            this.selected = this.selectedItem = null;
          }
          selected.delete(item);
        } else {
          sidx++;
        }
      });
    }

    __updateLinks() {
      this.__dataLinkedPaths = {};
      if (this.multi) {
        let sidx = 0;
        this.__selectedMap.forEach(idx => {
          if (idx >= 0) {
            this.linkPaths('items.' + idx, 'selected.' + sidx++);
          }
        });
      } else {
        this.__selectedMap.forEach(idx => {
          this.linkPaths('selected', 'items.' + idx);
          this.linkPaths('selectedItem', 'items.' + idx);
        });
      }
    }

    /**
     * Clears the selection state.
     *
     */
    clearSelection() {
      // Unbind previous selection
      this.__dataLinkedPaths = {};
      // The selected map stores 3 pieces of information:
      // key: items array object
      // value: items array index
      // order: selected array index
      this.__selectedMap = new Map();
      // Initialize selection
      this.selected = this.multi ? [] : null;
      this.selectedItem = null;
    }

    /**
     * Returns whether the item is currently selected.
     *
     * @param {*} item Item from `items` array to test
     * @return {boolean} Whether the item is selected
     */
    isSelected(item) {
      return this.__selectedMap.has(item);
    }

    /**
     * Returns whether the item is currently selected.
     *
     * @param {number} idx Index from `items` array to test
     * @return {boolean} Whether the item is selected
     */
    isIndexSelected(idx) {
      return this.isSelected(this.items[idx]);
    }

    __deselectChangedIdx(idx) {
      let sidx = this.__selectedIndexForItemIndex(idx);
      if (sidx >= 0) {
        let i = 0;
        this.__selectedMap.forEach((idx, item) => {
          if (sidx == i++) {
            this.deselect(item);
          }
        });
      }
    }

    __selectedIndexForItemIndex(idx) {
      let selected = this.__dataLinkedPaths['items.' + idx];
      if (selected) {
        return parseInt(selected.slice('selected.'.length), 10);
      }
    }

    /**
     * Deselects the given item if it is already selected.
     *
     * @param {*} item Item from `items` array to deselect
     */
    deselect(item) {
      let idx = this.__selectedMap.get(item);
      if (idx >= 0) {
        this.__selectedMap.delete(item);
        let sidx;
        if (this.multi) {
          sidx = this.__selectedIndexForItemIndex(idx);
        }
        this.__updateLinks();
        if (this.multi) {
          this.splice('selected', sidx, 1);
        } else {
          this.selected = this.selectedItem = null;
        }
      }
    }

    /**
     * Deselects the given index if it is already selected.
     *
     * @param {number} idx Index from `items` array to deselect
     */
    deselectIndex(idx) {
      this.deselect(this.items[idx]);
    }

    /**
     * Selects the given item.  When `toggle` is true, this will automatically
     * deselect the item if already selected.
     *
     * @param {*} item Item from `items` array to select
     */
    select(item) {
      this.selectIndex(this.items.indexOf(item));
    }

    /**
     * Selects the given index.  When `toggle` is true, this will automatically
     * deselect the item if already selected.
     *
     * @param {number} idx Index from `items` array to select
     */
    selectIndex(idx) {
      let item = this.items[idx];
      if (!this.isSelected(item)) {
        if (!this.multi) {
          this.__selectedMap.clear();
        }
        this.__selectedMap.set(item, idx);
        this.__updateLinks();
        if (this.multi) {
          this.push('selected', item);
        } else {
          this.selected = this.selectedItem = item;
        }
      } else if (this.toggle) {
        this.deselectIndex(idx);
      }
    }

  }

  return ArraySelectorMixin;

});



/**
 * @constructor
 * @extends {Polymer.Element}
 * @implements {Polymer_ArraySelectorMixin}
 */
let baseArraySelector = ArraySelectorMixin(__WEBPACK_IMPORTED_MODULE_0__polymer_element_js__["a" /* Element */]);

/**
 * Element implementing the `Polymer.ArraySelector` mixin, which records
 * dynamic associations between item paths in a master `items` array and a
 * `selected` array such that path changes to the master array (at the host)
 * element or elsewhere via data-binding) are correctly propagated to items
 * in the selected array and vice-versa.
 *
 * The `items` property accepts an array of user data, and via the
 * `select(item)` and `deselect(item)` API, updates the `selected` property
 * which may be bound to other parts of the application, and any changes to
 * sub-fields of `selected` item(s) will be kept in sync with items in the
 * `items` array.  When `multi` is false, `selected` is a property
 * representing the last selected item.  When `multi` is true, `selected`
 * is an array of multiply selected items.
 *
 * Example:
 *
 * ```html
 * <dom-module id="employee-list">
 *
 *   <template>
 *
 *     <div> Employee list: </div>
 *     <template is="dom-repeat" id="employeeList" items="{{employees}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *         <button on-click="toggleSelection">Select</button>
 *     </template>
 *
 *     <array-selector id="selector" items="{{employees}}" selected="{{selected}}" multi toggle></array-selector>
 *
 *     <div> Selected employees: </div>
 *     <template is="dom-repeat" items="{{selected}}">
 *         <div>First name: <span>{{item.first}}</span></div>
 *         <div>Last name: <span>{{item.last}}</span></div>
 *     </template>
 *
 *   </template>
 *
 * </dom-module>
 * ```
 *
 * ```js
 * Polymer({
 *   is: 'employee-list',
 *   ready() {
 *     this.employees = [
 *         {first: 'Bob', last: 'Smith'},
 *         {first: 'Sally', last: 'Johnson'},
 *         ...
 *     ];
 *   },
 *   toggleSelection(e) {
 *     let item = this.$.employeeList.itemForElement(e.target);
 *     this.$.selector.select(item);
 *   }
 * });
 * ```
 *
 * @polymer
 * @customElement
 * @extends {baseArraySelector}
 * @appliesMixin Polymer.ArraySelectorMixin
 * @memberof Polymer
 * @summary Custom element that links paths between an input `items` array and
 *   an output `selected` item or array based on calls to its selection API.
 */
class ArraySelector extends baseArraySelector {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() { return 'array-selector'; }
}
customElements.define(ArraySelector.is, ArraySelector);



/***/ }),
/* 69 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export CustomStyle */
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_shadycss_entrypoints_custom_style_interface_js__ = __webpack_require__(70);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_style_gather_js__ = __webpack_require__(33);



const attr = 'include';

const CustomStyleInterface = window.ShadyCSS.CustomStyleInterface;

/**
 * Custom element for defining styles in the main document that can take
 * advantage of [shady DOM](https://github.com/webcomponents/shadycss) shims
 * for style encapsulation, custom properties, and custom mixins.
 *
 * - Document styles defined in a `<custom-style>` are shimmed to ensure they
 *   do not leak into local DOM when running on browsers without native
 *   Shadow DOM.
 * - Custom properties can be defined in a `<custom-style>`. Use the `html` selector
 *   to define custom properties that apply to all custom elements.
 * - Custom mixins can be defined in a `<custom-style>`, if you import the optional
 *   [apply shim](https://github.com/webcomponents/shadycss#about-applyshim)
 *   (`shadycss/apply-shim.html`).
 *
 * To use:
 *
 * - Import `custom-style.html`.
 * - Place a `<custom-style>` element in the main document, wrapping an inline `<style>` tag that
 *   contains the CSS rules you want to shim.
 *
 * For example:
 *
 * ```
 * <!-- import apply shim--only required if using mixins -->
 * <link rel="import href="bower_components/shadycss/apply-shim.html">
 * <!-- import custom-style element -->
 * <link rel="import" href="bower_components/polymer/lib/elements/custom-style.html">
 * ...
 * <custom-style>
 *   <style>
 *     html {
 *       --custom-color: blue;
 *       --custom-mixin: {
 *         font-weight: bold;
 *         color: red;
 *       };
 *     }
 *   </style>
 * </custom-style>
 * ```
 *
 * @customElement
 * @extends HTMLElement
 * @memberof Polymer
 * @summary Custom element for defining styles in the main document that can
 *   take advantage of Polymer's style scoping and custom properties shims.
 */
class CustomStyle extends HTMLElement {
  constructor() {
    super();
    this._style = null;
    CustomStyleInterface.addCustomStyle(this);
  }
  /**
   * Returns the light-DOM `<style>` child this element wraps.  Upon first
   * call any style modules referenced via the `include` attribute will be
   * concatenated to this element's `<style>`.
   *
   * @return {HTMLStyleElement} This element's light-DOM `<style>`
   */
  getStyle() {
    if (this._style) {
      return this._style;
    }
    const style = /** @type {HTMLStyleElement} */(this.querySelector('style'));
    if (!style) {
      return null;
    }
    this._style = style;
    const include = style.getAttribute(attr);
    if (include) {
      style.removeAttribute(attr);
      style.textContent = Object(__WEBPACK_IMPORTED_MODULE_1__utils_style_gather_js__["b" /* cssFromModules */])(include) + style.textContent;
    }
    return this._style;
  }
}

window.customElements.define('custom-style', CustomStyle);



/***/ }),
/* 70 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_custom_style_interface_js__ = __webpack_require__(40);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__ = __webpack_require__(26);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_style_settings_js__ = __webpack_require__(23);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/







const customStyleInterface = new __WEBPACK_IMPORTED_MODULE_0__src_custom_style_interface_js__["a" /* default */]();

if (!window.ShadyCSS) {
  window.ShadyCSS = {
    /**
     * @param {HTMLTemplateElement} template
     * @param {string} elementName
     * @param {string=} elementExtends
     */
    prepareTemplate(template, elementName, elementExtends) {}, // eslint-disable-line no-unused-vars

    /**
     * @param {Element} element
     * @param {Object=} properties
     */
    styleSubtree(element, properties) {
      customStyleInterface.processStyles();
      Object(__WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__["c" /* updateNativeProperties */])(element, properties);
    },

    /**
     * @param {Element} element
     */
    styleElement(element) { // eslint-disable-line no-unused-vars
      customStyleInterface.processStyles();
    },

    /**
     * @param {Object=} properties
     */
    styleDocument(properties) {
      customStyleInterface.processStyles();
      Object(__WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__["c" /* updateNativeProperties */])(document.body, properties);
    },

    /**
     * @param {Element} element
     * @param {string} property
     * @return {string}
     */
    getComputedStyleValue(element, property) {
      return Object(__WEBPACK_IMPORTED_MODULE_1__src_common_utils_js__["b" /* getComputedStyleValue */])(element, property);
    },
    nativeCss: __WEBPACK_IMPORTED_MODULE_2__src_style_settings_js__["a" /* nativeCssVariables */],
    nativeShadow: __WEBPACK_IMPORTED_MODULE_2__src_style_settings_js__["b" /* nativeShadow */]
  }
}

window.ShadyCSS.CustomStyleInterface = customStyleInterface;

/***/ }),
/* 71 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__mixins_mutable_data_js__ = __webpack_require__(14);


let mutablePropertyChange;
(
  /** @suppress {missingProperties} */
  (function() {
  mutablePropertyChange = __WEBPACK_IMPORTED_MODULE_0__mixins_mutable_data_js__["a" /* MutableData */]._mutablePropertyChange;
}))();

const MutableDataBehavior = {

  /**
   * Overrides `Polymer.PropertyEffects` to provide option for skipping
   * strict equality checking for Objects and Arrays.
   *
   * This method pulls the value to dirty check against from the `__dataTemp`
   * cache (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @protected
   */
  _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, true);
  }
};
/* unused harmony export MutableDataBehavior */


const OptionalMutableDataBehavior = {

  properties: {
    /**
     * Instance-level flag for configuring the dirty-checking strategy
     * for this element.  When true, Objects and Arrays will skip dirty
     * checking, otherwise strict equality checking will be used.
     */
    mutableData: Boolean
  },

  /**
   * Overrides `Polymer.PropertyEffects` to skip strict equality checking
   * for Objects and Arrays.
   *
   * Pulls the value to dirty check against from the `__dataTemp` cache
   * (rather than the normal `__data` cache) for Objects.  Since the temp
   * cache is cleared at the end of a turn, this implementation allows
   * side-effects of deep object changes to be processed by re-setting the
   * same object (using the temp cache as an in-turn backstop to prevent
   * cycles due to 2-way notification).
   *
   * @param {string} property Property name
   * @param {*} value New property value
   * @param {*} old Previous property value
   * @return {boolean} Whether the property should be considered a change
   * @this {this}
   * @protected
   */
  _shouldPropertyChange(property, value, old) {
    return mutablePropertyChange(this, property, value, old, this.mutableData);
  }
};
/* unused harmony export OptionalMutableDataBehavior */



/***/ }),
/* 72 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__neon_animatable_behavior_js__ = __webpack_require__(73);



const NeonAnimationRunnerBehaviorImpl = {

  _configureAnimations: function(configs) {
    var results = [];
    if (configs.length > 0) {
      for (var config, index = 0; config = configs[index]; index++) {
        var neonAnimation = document.createElement(config.name);
        // is this element actually a neon animation?
        if (neonAnimation.isNeonAnimation) {
          var result = null;
          // configuration or play could fail if polyfills aren't loaded
          try {
            result = neonAnimation.configure(config);
            // Check if we have an Effect rather than an Animation
            if (typeof result.cancel != 'function') {
              result = document.timeline.play(result);
            }
          } catch (e) {
            result = null;
            console.warn('Couldnt play', '(', config.name, ').', e);
          }
          if (result) {
            results.push({
              neonAnimation: neonAnimation,
              config: config,
              animation: result,
            });
          }
        } else {
          console.warn(this.is + ':', config.name, 'not found!');
        }
      }
    }
    return results;
  },

  _shouldComplete: function(activeEntries) {
    var finished = true;
    for (var i = 0; i < activeEntries.length; i++) {
      if (activeEntries[i].animation.playState != 'finished') {
        finished = false;
        break;
      }
    }
    return finished;
  },

  _complete: function(activeEntries) {
    for (var i = 0; i < activeEntries.length; i++) {
      activeEntries[i].neonAnimation.complete(activeEntries[i].config);
    }
    for (var i = 0; i < activeEntries.length; i++) {
      activeEntries[i].animation.cancel();
    }
  },

  /**
   * Plays an animation with an optional `type`.
   * @param {string=} type
   * @param {!Object=} cookie
   */
  playAnimation: function(type, cookie) {
    var configs = this.getAnimationConfig(type);
    if (!configs) {
      return;
    }
    this._active = this._active || {};
    if (this._active[type]) {
      this._complete(this._active[type]);
      delete this._active[type];
    }

    var activeEntries = this._configureAnimations(configs);

    if (activeEntries.length == 0) {
      this.fire('neon-animation-finish', cookie, {bubbles: false});
      return;
    }

    this._active[type] = activeEntries;

    for (var i = 0; i < activeEntries.length; i++) {
      activeEntries[i].animation.onfinish = function() {
        if (this._shouldComplete(activeEntries)) {
          this._complete(activeEntries);
          delete this._active[type];
          this.fire('neon-animation-finish', cookie, {bubbles: false});
        }
      }.bind(this);
    }
  },

  /**
   * Cancels the currently running animations.
   */
  cancelAnimation: function() {
    for (var k in this._animations) {
      this._animations[k].cancel();
    }
    this._animations = {};
  }
};
/* unused harmony export NeonAnimationRunnerBehaviorImpl */


const NeonAnimationRunnerBehavior = [
  __WEBPACK_IMPORTED_MODULE_1__neon_animatable_behavior_js__["a" /* NeonAnimatableBehavior */],
  NeonAnimationRunnerBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = NeonAnimationRunnerBehavior;



/***/ }),
/* 73 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);


const NeonAnimatableBehavior = {

  properties: {

    /**
     * Animation configuration. See README for more info.
     */
    animationConfig: {
      type: Object
    },

    /**
     * Convenience property for setting an 'entry' animation. Do not set `animationConfig.entry`
     * manually if using this. The animated node is set to `this` if using this property.
     */
    entryAnimation: {
      observer: '_entryAnimationChanged',
      type: String
    },

    /**
     * Convenience property for setting an 'exit' animation. Do not set `animationConfig.exit`
     * manually if using this. The animated node is set to `this` if using this property.
     */
    exitAnimation: {
      observer: '_exitAnimationChanged',
      type: String
    }

  },

  _entryAnimationChanged: function() {
    this.animationConfig = this.animationConfig || {};
    this.animationConfig['entry'] = [{
      name: this.entryAnimation,
      node: this
    }];
  },

  _exitAnimationChanged: function() {
    this.animationConfig = this.animationConfig || {};
    this.animationConfig['exit'] = [{
      name: this.exitAnimation,
      node: this
    }];
  },

  _copyProperties: function(config1, config2) {
    // shallowly copy properties from config2 to config1
    for (var property in config2) {
      config1[property] = config2[property];
    }
  },

  _cloneConfig: function(config) {
    var clone = {
      isClone: true
    };
    this._copyProperties(clone, config);
    return clone;
  },

  _getAnimationConfigRecursive: function(type, map, allConfigs) {
    if (!this.animationConfig) {
      return;
    }

    if(this.animationConfig.value && typeof this.animationConfig.value === 'function') {
      this._warn(this._logf('playAnimation', "Please put 'animationConfig' inside of your components 'properties' object instead of outside of it."));
      return;
    }

    // type is optional
    var thisConfig;
    if (type) {
      thisConfig = this.animationConfig[type];
    } else {
      thisConfig = this.animationConfig;
    }

    if (!Array.isArray(thisConfig)) {
      thisConfig = [thisConfig];
    }

    // iterate animations and recurse to process configurations from child nodes
    if (thisConfig) {
      for (var config, index = 0; config = thisConfig[index]; index++) {
        if (config.animatable) {
          config.animatable._getAnimationConfigRecursive(config.type || type, map, allConfigs);
        } else {
          if (config.id) {
            var cachedConfig = map[config.id];
            if (cachedConfig) {
              // merge configurations with the same id, making a clone lazily
              if (!cachedConfig.isClone) {
                map[config.id] = this._cloneConfig(cachedConfig);
                cachedConfig = map[config.id];
              }
              this._copyProperties(cachedConfig, config);
            } else {
              // put any configs with an id into a map
              map[config.id] = config;
            }
          } else {
            allConfigs.push(config);
          }
        }
      }
    }
  },

  /**
   * An element implementing `Polymer.NeonAnimationRunnerBehavior` calls this method to configure
   * an animation with an optional type. Elements implementing `Polymer.NeonAnimatableBehavior`
   * should define the property `animationConfig`, which is either a configuration object
   * or a map of animation type to array of configuration objects.
   */
  getAnimationConfig: function(type) {
    var map = {};
    var allConfigs = [];
    this._getAnimationConfigRecursive(type, map, allConfigs);
    // append the configurations saved in the map to the array
    for (var key in map) {
      allConfigs.push(map[key]);
    }
    return allConfigs;
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = NeonAnimatableBehavior;



/***/ }),
/* 74 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_overlay_behavior_iron_overlay_behavior_js__ = __webpack_require__(75);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




const PaperDialogBehaviorImpl = {

  hostAttributes: {
    'role': 'dialog',
    'tabindex': '-1'
  },

  properties: {

    /**
     * If `modal` is true, this implies `no-cancel-on-outside-click`, `no-cancel-on-esc-key` and `with-backdrop`.
     */
    modal: {
      type: Boolean,
      value: false
    },

    __readied: {
      type: Boolean,
      value: false
    }

  },

  observers: [
    '_modalChanged(modal, __readied)'
  ],

  listeners: {
    'tap': '_onDialogClick'
  },

  ready: function() {
    // Only now these properties can be read.
    this.__prevNoCancelOnOutsideClick = this.noCancelOnOutsideClick;
    this.__prevNoCancelOnEscKey = this.noCancelOnEscKey;
    this.__prevWithBackdrop = this.withBackdrop;
    this.__readied = true;
  },

  _modalChanged: function(modal, readied) {
    // modal implies noCancelOnOutsideClick, noCancelOnEscKey and withBackdrop.
    // We need to wait for the element to be ready before we can read the
    // properties values.
    if (!readied) {
      return;
    }

    if (modal) {
      this.__prevNoCancelOnOutsideClick = this.noCancelOnOutsideClick;
      this.__prevNoCancelOnEscKey = this.noCancelOnEscKey;
      this.__prevWithBackdrop = this.withBackdrop;
      this.noCancelOnOutsideClick = true;
      this.noCancelOnEscKey = true;
      this.withBackdrop = true;
    } else {
      // If the value was changed to false, let it false.
      this.noCancelOnOutsideClick = this.noCancelOnOutsideClick &&
        this.__prevNoCancelOnOutsideClick;
      this.noCancelOnEscKey = this.noCancelOnEscKey &&
        this.__prevNoCancelOnEscKey;
      this.withBackdrop = this.withBackdrop && this.__prevWithBackdrop;
    }
  },

  _updateClosingReasonConfirmed: function(confirmed) {
    this.closingReason = this.closingReason || {};
    this.closingReason.confirmed = confirmed;
  },

  /**
   * Will dismiss the dialog if user clicked on an element with dialog-dismiss
   * or dialog-confirm attribute.
   */
  _onDialogClick: function(event) {
    // Search for the element with dialog-confirm or dialog-dismiss,
    // from the root target until this (excluded).
    var path = Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).path;
    for (var i = 0, l = path.indexOf(this); i < l; i++) {
      var target = path[i];
      if (target.hasAttribute && (target.hasAttribute('dialog-dismiss') || target.hasAttribute('dialog-confirm'))) {
        this._updateClosingReasonConfirmed(target.hasAttribute('dialog-confirm'));
        this.close();
        event.stopPropagation();
        break;
      }
    }
  }

};
/* unused harmony export PaperDialogBehaviorImpl */


const PaperDialogBehavior = [__WEBPACK_IMPORTED_MODULE_1__iron_overlay_behavior_iron_overlay_behavior_js__["a" /* IronOverlayBehavior */], PaperDialogBehaviorImpl];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperDialogBehavior;



/***/ }),
/* 75 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_fit_behavior_iron_fit_behavior_js__ = __webpack_require__(76);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_resizable_behavior_iron_resizable_behavior_js__ = __webpack_require__(77);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__iron_overlay_manager_js__ = __webpack_require__(78);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__iron_focusables_helper_js__ = __webpack_require__(80);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);







const IronOverlayBehaviorImpl = {

  properties: {

    /**
     * True if the overlay is currently displayed.
     */
    opened: {
      observer: '_openedChanged',
      type: Boolean,
      value: false,
      notify: true
    },

    /**
     * True if the overlay was canceled when it was last closed.
     */
    canceled: {
      observer: '_canceledChanged',
      readOnly: true,
      type: Boolean,
      value: false
    },

    /**
     * Set to true to display a backdrop behind the overlay. It traps the focus
     * within the light DOM of the overlay.
     */
    withBackdrop: {
      observer: '_withBackdropChanged',
      type: Boolean
    },

    /**
     * Set to true to disable auto-focusing the overlay or child nodes with
     * the `autofocus` attribute` when the overlay is opened.
     */
    noAutoFocus: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to disable canceling the overlay with the ESC key.
     */
    noCancelOnEscKey: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to disable canceling the overlay by clicking outside it.
     */
    noCancelOnOutsideClick: {
      type: Boolean,
      value: false
    },

    /**
     * Contains the reason(s) this overlay was last closed (see `iron-overlay-closed`).
     * `IronOverlayBehavior` provides the `canceled` reason; implementers of the
     * behavior can provide other reasons in addition to `canceled`.
     */
    closingReason: {
      // was a getter before, but needs to be a property so other
      // behaviors can override this.
      type: Object
    },

    /**
     * Set to true to enable restoring of focus when overlay is closed.
     */
    restoreFocusOnClose: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to keep overlay always on top.
     */
    alwaysOnTop: {
      type: Boolean
    },

    /**
     * Shortcut to access to the overlay manager.
     * @private
     * @type {Polymer.IronOverlayManagerClass}
     */
    _manager: {
      type: Object,
      value: __WEBPACK_IMPORTED_MODULE_3__iron_overlay_manager_js__["a" /* IronOverlayManager */]
    },

    /**
     * The node being focused.
     * @type {?Node}
     */
    _focusedChild: {
      type: Object
    }

  },

  listeners: {
    'iron-resize': '_onIronResize'
  },

  /**
   * The backdrop element.
   * @type {Element}
   */
  get backdropElement() {
    return this._manager.backdropElement;
  },

  /**
   * Returns the node to give focus to.
   * @type {Node}
   */
  get _focusNode() {
    return this._focusedChild || Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).querySelector('[autofocus]') || this;
  },

  /**
   * Array of nodes that can receive focus (overlay included), ordered by `tabindex`.
   * This is used to retrieve which is the first and last focusable nodes in order
   * to wrap the focus for overlays `with-backdrop`.
   *
   * If you know what is your content (specifically the first and last focusable children),
   * you can override this method to return only `[firstFocusable, lastFocusable];`
   * @type {Array<Node>}
   * @protected
   */
  get _focusableNodes() {
    return __WEBPACK_IMPORTED_MODULE_4__iron_focusables_helper_js__["a" /* IronFocusablesHelper */].getTabbableNodes(this);
  },

  ready: function() {
    // Used to skip calls to notifyResize and refit while the overlay is animating.
    this.__isAnimating = false;
    // with-backdrop needs tabindex to be set in order to trap the focus.
    // If it is not set, IronOverlayBehavior will set it, and remove it if with-backdrop = false.
    this.__shouldRemoveTabIndex = false;
    // Used for wrapping the focus on TAB / Shift+TAB.
    this.__firstFocusableNode = this.__lastFocusableNode = null;
    // Used by __onNextAnimationFrame to cancel any previous callback.
    this.__raf = null;
    // Focused node before overlay gets opened. Can be restored on close.
    this.__restoreFocusNode = null;
    this._ensureSetup();
  },

  attached: function() {
    // Call _openedChanged here so that position can be computed correctly.
    if (this.opened) {
      this._openedChanged(this.opened);
    }
    this._observer = Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).observeNodes(this._onNodesChange);
  },

  detached: function() {
    Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).unobserveNodes(this._observer);
    this._observer = null;
    if (this.__raf) {
      window.cancelAnimationFrame(this.__raf);
      this.__raf = null;
    }
    this._manager.removeOverlay(this);
  },

  /**
   * Toggle the opened state of the overlay.
   */
  toggle: function() {
    this._setCanceled(false);
    this.opened = !this.opened;
  },

  /**
   * Open the overlay.
   */
  open: function() {
    this._setCanceled(false);
    this.opened = true;
  },

  /**
   * Close the overlay.
   */
  close: function() {
    this._setCanceled(false);
    this.opened = false;
  },

  /**
   * Cancels the overlay.
   * @param {Event=} event The original event
   */
  cancel: function(event) {
    var cancelEvent = this.fire('iron-overlay-canceled', event, {cancelable: true});
    if (cancelEvent.defaultPrevented) {
      return;
    }

    this._setCanceled(true);
    this.opened = false;
  },

  /**
   * Invalidates the cached tabbable nodes. To be called when any of the focusable
   * content changes (e.g. a button is disabled).
   */
  invalidateTabbables: function() {
    this.__firstFocusableNode = this.__lastFocusableNode = null;
  },

  _ensureSetup: function() {
    if (this._overlaySetup) {
      return;
    }
    this._overlaySetup = true;
    this.style.outline = 'none';
    this.style.display = 'none';
  },

  /**
   * Called when `opened` changes.
   * @param {boolean=} opened
   * @protected
   */
  _openedChanged: function(opened) {
    if (opened) {
      this.removeAttribute('aria-hidden');
    } else {
      this.setAttribute('aria-hidden', 'true');
    }

    // Defer any animation-related code on attached
    // (_openedChanged gets called again on attached).
    if (!this.isAttached) {
      return;
    }

    this.__isAnimating = true;

    // Use requestAnimationFrame for non-blocking rendering.
    this.__onNextAnimationFrame(this.__openedChanged);
  },

  _canceledChanged: function() {
    this.closingReason = this.closingReason || {};
    this.closingReason.canceled = this.canceled;
  },

  _withBackdropChanged: function() {
    // If tabindex is already set, no need to override it.
    if (this.withBackdrop && !this.hasAttribute('tabindex')) {
      this.setAttribute('tabindex', '-1');
      this.__shouldRemoveTabIndex = true;
    } else if (this.__shouldRemoveTabIndex) {
      this.removeAttribute('tabindex');
      this.__shouldRemoveTabIndex = false;
    }
    if (this.opened && this.isAttached) {
      this._manager.trackBackdrop();
    }
  },

  /**
   * tasks which must occur before opening; e.g. making the element visible.
   * @protected
   */
  _prepareRenderOpened: function() {
    // Store focused node.
    this.__restoreFocusNode = this._manager.deepActiveElement;

    // Needed to calculate the size of the overlay so that transitions on its size
    // will have the correct starting points.
    this._preparePositioning();
    this.refit();
    this._finishPositioning();

    // Safari will apply the focus to the autofocus element when displayed
    // for the first time, so we make sure to return the focus where it was.
    if (this.noAutoFocus && document.activeElement === this._focusNode) {
      this._focusNode.blur();
      this.__restoreFocusNode.focus();
    }
  },

  /**
   * Tasks which cause the overlay to actually open; typically play an animation.
   * @protected
   */
  _renderOpened: function() {
    this._finishRenderOpened();
  },

  /**
   * Tasks which cause the overlay to actually close; typically play an animation.
   * @protected
   */
  _renderClosed: function() {
    this._finishRenderClosed();
  },

  /**
   * Tasks to be performed at the end of open action. Will fire `iron-overlay-opened`.
   * @protected
   */
  _finishRenderOpened: function() {
    this.notifyResize();
    this.__isAnimating = false;

    this.fire('iron-overlay-opened');
  },

  /**
   * Tasks to be performed at the end of close action. Will fire `iron-overlay-closed`.
   * @protected
   */
  _finishRenderClosed: function() {
    // Hide the overlay.
    this.style.display = 'none';
    // Reset z-index only at the end of the animation.
    this.style.zIndex = '';
    this.notifyResize();
    this.__isAnimating = false;
    this.fire('iron-overlay-closed', this.closingReason);
  },

  _preparePositioning: function() {
    this.style.transition = this.style.webkitTransition = 'none';
    this.style.transform = this.style.webkitTransform = 'none';
    this.style.display = '';
  },

  _finishPositioning: function() {
    // First, make it invisible & reactivate animations.
    this.style.display = 'none';
    // Force reflow before re-enabling animations so that they don't start.
    // Set scrollTop to itself so that Closure Compiler doesn't remove this.
    this.scrollTop = this.scrollTop;
    this.style.transition = this.style.webkitTransition = '';
    this.style.transform = this.style.webkitTransform = '';
    // Now that animations are enabled, make it visible again
    this.style.display = '';
    // Force reflow, so that following animations are properly started.
    // Set scrollTop to itself so that Closure Compiler doesn't remove this.
    this.scrollTop = this.scrollTop;
  },

  /**
   * Applies focus according to the opened state.
   * @protected
   */
  _applyFocus: function() {
    if (this.opened) {
      if (!this.noAutoFocus) {
        this._focusNode.focus();
      }
    }
    else {
      this._focusNode.blur();
      this._focusedChild = null;
      // Restore focus.
      if (this.restoreFocusOnClose && this.__restoreFocusNode) {
        this.__restoreFocusNode.focus();
      }
      this.__restoreFocusNode = null;
      // If many overlays get closed at the same time, one of them would still
      // be the currentOverlay even if already closed, and would call _applyFocus
      // infinitely, so we check for this not to be the current overlay.
      var currentOverlay = this._manager.currentOverlay();
      if (currentOverlay && this !== currentOverlay) {
        currentOverlay._applyFocus();
      }
    }
  },

  /**
   * Cancels (closes) the overlay. Call when click happens outside the overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureClick: function(event) {
    if (!this.noCancelOnOutsideClick) {
      this.cancel(event);
    }
  },

  /**
   * Keeps track of the focused child. If withBackdrop, traps focus within overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureFocus: function (event) {
    if (!this.withBackdrop) {
      return;
    }
    var path = Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).path;
    if (path.indexOf(this) === -1) {
      event.stopPropagation();
      this._applyFocus();
    } else {
      this._focusedChild = path[0];
    }
  },

  /**
   * Handles the ESC key event and cancels (closes) the overlay.
   * @param {!Event} event
   * @protected
   */
  _onCaptureEsc: function(event) {
    if (!this.noCancelOnEscKey) {
      this.cancel(event);
    }
  },

  /**
   * Handles TAB key events to track focus changes.
   * Will wrap focus for overlays withBackdrop.
   * @param {!Event} event
   * @protected
   */
  _onCaptureTab: function(event) {
    if (!this.withBackdrop) {
      return;
    }
    this.__ensureFirstLastFocusables();
    // TAB wraps from last to first focusable.
    // Shift + TAB wraps from first to last focusable.
    var shift = event.shiftKey;
    var nodeToCheck = shift ? this.__firstFocusableNode : this.__lastFocusableNode;
    var nodeToSet = shift ? this.__lastFocusableNode : this.__firstFocusableNode;
    var shouldWrap = false;
    if (nodeToCheck === nodeToSet) {
      // If nodeToCheck is the same as nodeToSet, it means we have an overlay
      // with 0 or 1 focusables; in either case we still need to trap the
      // focus within the overlay.
      shouldWrap = true;
    } else {
      // In dom=shadow, the manager will receive focus changes on the main
      // root but not the ones within other shadow roots, so we can't rely on
      // _focusedChild, but we should check the deepest active element.
      var focusedNode = this._manager.deepActiveElement;
      // If the active element is not the nodeToCheck but the overlay itself,
      // it means the focus is about to go outside the overlay, hence we
      // should prevent that (e.g. user opens the overlay and hit Shift+TAB).
      shouldWrap = (focusedNode === nodeToCheck || focusedNode === this);
    }

    if (shouldWrap) {
      // When the overlay contains the last focusable element of the document
      // and it's already focused, pressing TAB would move the focus outside
      // the document (e.g. to the browser search bar). Similarly, when the
      // overlay contains the first focusable element of the document and it's
      // already focused, pressing Shift+TAB would move the focus outside the
      // document (e.g. to the browser search bar).
      // In both cases, we would not receive a focus event, but only a blur.
      // In order to achieve focus wrapping, we prevent this TAB event and
      // force the focus. This will also prevent the focus to temporarily move
      // outside the overlay, which might cause scrolling.
      event.preventDefault();
      this._focusedChild = nodeToSet;
      this._applyFocus();
    }
  },

  /**
   * Refits if the overlay is opened and not animating.
   * @protected
   */
  _onIronResize: function() {
    if (this.opened && !this.__isAnimating) {
      this.__onNextAnimationFrame(this.refit);
    }
  },

  /**
   * Will call notifyResize if overlay is opened.
   * Can be overridden in order to avoid multiple observers on the same node.
   * @protected
   */
  _onNodesChange: function() {
    if (this.opened && !this.__isAnimating) {
      // It might have added focusable nodes, so invalidate cached values.
      this.invalidateTabbables();
      this.notifyResize();
    }
  },

  /**
   * Will set first and last focusable nodes if any of them is not set.
   * @private
   */
  __ensureFirstLastFocusables: function() {
    if (!this.__firstFocusableNode || !this.__lastFocusableNode) {
      var focusableNodes = this._focusableNodes;
      this.__firstFocusableNode = focusableNodes[0];
      this.__lastFocusableNode = focusableNodes[focusableNodes.length - 1];
    }
  },

  /**
   * Tasks executed when opened changes: prepare for the opening, move the
   * focus, update the manager, render opened/closed.
   * @private
   */
  __openedChanged: function() {
    if (this.opened) {
      // Make overlay visible, then add it to the manager.
      this._prepareRenderOpened();
      this._manager.addOverlay(this);
      // Move the focus to the child node with [autofocus].
      this._applyFocus();

      this._renderOpened();
    } else {
      // Remove overlay, then restore the focus before actually closing.
      this._manager.removeOverlay(this);
      this._applyFocus();

      this._renderClosed();
    }
  },

  /**
   * Executes a callback on the next animation frame, overriding any previous
   * callback awaiting for the next animation frame. e.g.
   * `__onNextAnimationFrame(callback1) && __onNextAnimationFrame(callback2)`;
   * `callback1` will never be invoked.
   * @param {!Function} callback Its `this` parameter is the overlay itself.
   * @private
   */
  __onNextAnimationFrame: function(callback) {
    if (this.__raf) {
      window.cancelAnimationFrame(this.__raf);
    }
    var self = this;
    this.__raf = window.requestAnimationFrame(function nextAnimationFrame() {
      self.__raf = null;
      callback.call(self);
    });
  }

};
/* unused harmony export IronOverlayBehaviorImpl */


const IronOverlayBehavior = [__WEBPACK_IMPORTED_MODULE_1__iron_fit_behavior_iron_fit_behavior_js__["a" /* IronFitBehavior */], __WEBPACK_IMPORTED_MODULE_2__iron_resizable_behavior_iron_resizable_behavior_js__["a" /* IronResizableBehavior */], IronOverlayBehaviorImpl];
/* harmony export (immutable) */ __webpack_exports__["a"] = IronOverlayBehavior;



/***/ }),
/* 76 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);



const IronFitBehavior = {

  properties: {

    /**
     * The element that will receive a `max-height`/`width`. By default it is the same as `this`,
     * but it can be set to a child element. This is useful, for example, for implementing a
     * scrolling region inside the element.
     * @type {!Element}
     */
    sizingTarget: {
      type: Object,
      value: function() {
        return this;
      }
    },

    /**
     * The element to fit `this` into.
     */
    fitInto: {
      type: Object,
      value: window
    },

    /**
     * Will position the element around the positionTarget without overlapping it.
     */
    noOverlap: {
      type: Boolean
    },

    /**
     * The element that should be used to position the element. If not set, it will
     * default to the parent node.
     * @type {!Element}
     */
    positionTarget: {
      type: Element
    },

    /**
     * The orientation against which to align the element horizontally
     * relative to the `positionTarget`. Possible values are "left", "right", "auto".
     */
    horizontalAlign: {
      type: String
    },

    /**
     * The orientation against which to align the element vertically
     * relative to the `positionTarget`. Possible values are "top", "bottom", "auto".
     */
    verticalAlign: {
      type: String
    },

    /**
     * If true, it will use `horizontalAlign` and `verticalAlign` values as preferred alignment
     * and if there's not enough space, it will pick the values which minimize the cropping.
     */
    dynamicAlign: {
      type: Boolean
    },

    /**
     * A pixel value that will be added to the position calculated for the
     * given `horizontalAlign`, in the direction of alignment. You can think
     * of it as increasing or decreasing the distance to the side of the
     * screen given by `horizontalAlign`.
     *
     * If `horizontalAlign` is "left", this offset will increase or decrease
     * the distance to the left side of the screen: a negative offset will
     * move the dropdown to the left; a positive one, to the right.
     *
     * Conversely if `horizontalAlign` is "right", this offset will increase
     * or decrease the distance to the right side of the screen: a negative
     * offset will move the dropdown to the right; a positive one, to the left.
     */
    horizontalOffset: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * A pixel value that will be added to the position calculated for the
     * given `verticalAlign`, in the direction of alignment. You can think
     * of it as increasing or decreasing the distance to the side of the
     * screen given by `verticalAlign`.
     *
     * If `verticalAlign` is "top", this offset will increase or decrease
     * the distance to the top side of the screen: a negative offset will
     * move the dropdown upwards; a positive one, downwards.
     *
     * Conversely if `verticalAlign` is "bottom", this offset will increase
     * or decrease the distance to the bottom side of the screen: a negative
     * offset will move the dropdown downwards; a positive one, upwards.
     */
    verticalOffset: {
      type: Number,
      value: 0,
      notify: true
    },

    /**
     * Set to true to auto-fit on attach.
     */
    autoFitOnAttach: {
      type: Boolean,
      value: false
    },

    /** @type {?Object} */
    _fitInfo: {
      type: Object
    }
  },

  get _fitWidth() {
    var fitWidth;
    if (this.fitInto === window) {
      fitWidth = this.fitInto.innerWidth;
    } else {
      fitWidth = this.fitInto.getBoundingClientRect().width;
    }
    return fitWidth;
  },

  get _fitHeight() {
    var fitHeight;
    if (this.fitInto === window) {
      fitHeight = this.fitInto.innerHeight;
    } else {
      fitHeight = this.fitInto.getBoundingClientRect().height;
    }
    return fitHeight;
  },

  get _fitLeft() {
    var fitLeft;
    if (this.fitInto === window) {
      fitLeft = 0;
    } else {
      fitLeft = this.fitInto.getBoundingClientRect().left;
    }
    return fitLeft;
  },

  get _fitTop() {
    var fitTop;
    if (this.fitInto === window) {
      fitTop = 0;
    } else {
      fitTop = this.fitInto.getBoundingClientRect().top;
    }
    return fitTop;
  },

  /**
   * The element that should be used to position the element,
   * if no position target is configured.
   */
  get _defaultPositionTarget() {
    var parent = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).parentNode;

    if (parent && parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      parent = parent.host;
    }

    return parent;
  },

  /**
   * The horizontal align value, accounting for the RTL/LTR text direction.
   */
  get _localeHorizontalAlign() {
    if (this._isRTL) {
      // In RTL, "left" becomes "right".
      if (this.horizontalAlign === 'right') {
        return 'left';
      }
      if (this.horizontalAlign === 'left') {
        return 'right';
      }
    }
    return this.horizontalAlign;
  },

  attached: function() {
    // Memoize this to avoid expensive calculations & relayouts.
    // Make sure we do it only once
    if (typeof this._isRTL === 'undefined') {
      this._isRTL = window.getComputedStyle(this).direction == 'rtl';
    }
    this.positionTarget = this.positionTarget || this._defaultPositionTarget;
    if (this.autoFitOnAttach) {
      if (window.getComputedStyle(this).display === 'none') {
        setTimeout(function() {
          this.fit();
        }.bind(this));
      } else {
        // NOTE: shadydom applies distribution asynchronously
        // for performance reasons webcomponents/shadydom#120
        // Flush to get correct layout info.
        window.ShadyDOM && ShadyDOM.flush();
        this.fit();
      }
    }
  },

  detached: function() {
    if (this.__deferredFit) {
      clearTimeout(this.__deferredFit);
      this.__deferredFit = null;
    }
  },

  /**
   * Positions and fits the element into the `fitInto` element.
   */
  fit: function() {
    this.position();
    this.constrain();
    this.center();
  },

  /**
   * Memoize information needed to position and size the target element.
   * @suppress {deprecated}
   */
  _discoverInfo: function() {
    if (this._fitInfo) {
      return;
    }
    var target = window.getComputedStyle(this);
    var sizer = window.getComputedStyle(this.sizingTarget);

    this._fitInfo = {
      inlineStyle: {
        top: this.style.top || '',
        left: this.style.left || '',
        position: this.style.position || ''
      },
      sizerInlineStyle: {
        maxWidth: this.sizingTarget.style.maxWidth || '',
        maxHeight: this.sizingTarget.style.maxHeight || '',
        boxSizing: this.sizingTarget.style.boxSizing || ''
      },
      positionedBy: {
        vertically: target.top !== 'auto' ? 'top' : (target.bottom !== 'auto' ?
          'bottom' : null),
        horizontally: target.left !== 'auto' ? 'left' : (target.right !== 'auto' ?
          'right' : null)
      },
      sizedBy: {
        height: sizer.maxHeight !== 'none',
        width: sizer.maxWidth !== 'none',
        minWidth: parseInt(sizer.minWidth, 10) || 0,
        minHeight: parseInt(sizer.minHeight, 10) || 0
      },
      margin: {
        top: parseInt(target.marginTop, 10) || 0,
        right: parseInt(target.marginRight, 10) || 0,
        bottom: parseInt(target.marginBottom, 10) || 0,
        left: parseInt(target.marginLeft, 10) || 0
      }
    };
  },

  /**
   * Resets the target element's position and size constraints, and clear
   * the memoized data.
   */
  resetFit: function() {
    var info = this._fitInfo || {};
    for (var property in info.sizerInlineStyle) {
      this.sizingTarget.style[property] = info.sizerInlineStyle[property];
    }
    for (var property in info.inlineStyle) {
      this.style[property] = info.inlineStyle[property];
    }

    this._fitInfo = null;
  },

  /**
   * Equivalent to calling `resetFit()` and `fit()`. Useful to call this after
   * the element or the `fitInto` element has been resized, or if any of the
   * positioning properties (e.g. `horizontalAlign, verticalAlign`) is updated.
   * It preserves the scroll position of the sizingTarget.
   */
  refit: function() {
    var scrollLeft = this.sizingTarget.scrollLeft;
    var scrollTop = this.sizingTarget.scrollTop;
    this.resetFit();
    this.fit();
    this.sizingTarget.scrollLeft = scrollLeft;
    this.sizingTarget.scrollTop = scrollTop;
  },

  /**
   * Positions the element according to `horizontalAlign, verticalAlign`.
   */
  position: function() {
    if (!this.horizontalAlign && !this.verticalAlign) {
      // needs to be centered, and it is done after constrain.
      return;
    }
    this._discoverInfo();

    this.style.position = 'fixed';
    // Need border-box for margin/padding.
    this.sizingTarget.style.boxSizing = 'border-box';
    // Set to 0, 0 in order to discover any offset caused by parent stacking contexts.
    this.style.left = '0px';
    this.style.top = '0px';

    var rect = this.getBoundingClientRect();
    var positionRect = this.__getNormalizedRect(this.positionTarget);
    var fitRect = this.__getNormalizedRect(this.fitInto);

    var margin = this._fitInfo.margin;

    // Consider the margin as part of the size for position calculations.
    var size = {
      width: rect.width + margin.left + margin.right,
      height: rect.height + margin.top + margin.bottom
    };

    var position = this.__getPosition(this._localeHorizontalAlign, this.verticalAlign, size, positionRect,
      fitRect);

    var left = position.left + margin.left;
    var top = position.top + margin.top;

    // We first limit right/bottom within fitInto respecting the margin,
    // then use those values to limit top/left.
    var right = Math.min(fitRect.right - margin.right, left + rect.width);
    var bottom = Math.min(fitRect.bottom - margin.bottom, top + rect.height);

    // Keep left/top within fitInto respecting the margin.
    left = Math.max(fitRect.left + margin.left,
      Math.min(left, right - this._fitInfo.sizedBy.minWidth));
    top = Math.max(fitRect.top + margin.top,
      Math.min(top, bottom - this._fitInfo.sizedBy.minHeight));

    // Use right/bottom to set maxWidth/maxHeight, and respect minWidth/minHeight.
    this.sizingTarget.style.maxWidth = Math.max(right - left, this._fitInfo.sizedBy.minWidth) + 'px';
    this.sizingTarget.style.maxHeight = Math.max(bottom - top, this._fitInfo.sizedBy.minHeight) + 'px';

    // Remove the offset caused by any stacking context.
    this.style.left = (left - rect.left) + 'px';
    this.style.top = (top - rect.top) + 'px';
  },

  /**
   * Constrains the size of the element to `fitInto` by setting `max-height`
   * and/or `max-width`.
   */
  constrain: function() {
    if (this.horizontalAlign || this.verticalAlign) {
      return;
    }
    this._discoverInfo();

    var info = this._fitInfo;
    // position at (0px, 0px) if not already positioned, so we can measure the natural size.
    if (!info.positionedBy.vertically) {
      this.style.position = 'fixed';
      this.style.top = '0px';
    }
    if (!info.positionedBy.horizontally) {
      this.style.position = 'fixed';
      this.style.left = '0px';
    }

    // need border-box for margin/padding
    this.sizingTarget.style.boxSizing = 'border-box';
    // constrain the width and height if not already set
    var rect = this.getBoundingClientRect();
    if (!info.sizedBy.height) {
      this.__sizeDimension(rect, info.positionedBy.vertically, 'top', 'bottom', 'Height');
    }
    if (!info.sizedBy.width) {
      this.__sizeDimension(rect, info.positionedBy.horizontally, 'left', 'right', 'Width');
    }
  },

  /**
   * @protected
   * @deprecated
   */
  _sizeDimension: function(rect, positionedBy, start, end, extent) {
    this.__sizeDimension(rect, positionedBy, start, end, extent);
  },

  /**
   * @private
   */
  __sizeDimension: function(rect, positionedBy, start, end, extent) {
    var info = this._fitInfo;
    var fitRect = this.__getNormalizedRect(this.fitInto);
    var max = extent === 'Width' ? fitRect.width : fitRect.height;
    var flip = (positionedBy === end);
    var offset = flip ? max - rect[end] : rect[start];
    var margin = info.margin[flip ? start : end];
    var offsetExtent = 'offset' + extent;
    var sizingOffset = this[offsetExtent] - this.sizingTarget[offsetExtent];
    this.sizingTarget.style['max' + extent] = (max - margin - offset - sizingOffset) + 'px';
  },

  /**
   * Centers horizontally and vertically if not already positioned. This also sets
   * `position:fixed`.
   */
  center: function() {
    if (this.horizontalAlign || this.verticalAlign) {
      return;
    }
    this._discoverInfo();

    var positionedBy = this._fitInfo.positionedBy;
    if (positionedBy.vertically && positionedBy.horizontally) {
      // Already positioned.
      return;
    }
    // Need position:fixed to center
    this.style.position = 'fixed';
    // Take into account the offset caused by parents that create stacking
    // contexts (e.g. with transform: translate3d). Translate to 0,0 and
    // measure the bounding rect.
    if (!positionedBy.vertically) {
      this.style.top = '0px';
    }
    if (!positionedBy.horizontally) {
      this.style.left = '0px';
    }
    // It will take in consideration margins and transforms
    var rect = this.getBoundingClientRect();
    var fitRect = this.__getNormalizedRect(this.fitInto);
    if (!positionedBy.vertically) {
      var top = fitRect.top - rect.top + (fitRect.height - rect.height) / 2;
      this.style.top = top + 'px';
    }
    if (!positionedBy.horizontally) {
      var left = fitRect.left - rect.left + (fitRect.width - rect.width) / 2;
      this.style.left = left + 'px';
    }
  },

  __getNormalizedRect: function(target) {
    if (target === document.documentElement || target === window) {
      return {
        top: 0,
        left: 0,
        width: window.innerWidth,
        height: window.innerHeight,
        right: window.innerWidth,
        bottom: window.innerHeight
      };
    }
    return target.getBoundingClientRect();
  },

  __getCroppedArea: function(position, size, fitRect) {
    var verticalCrop = Math.min(0, position.top) + Math.min(0, fitRect.bottom - (position.top + size.height));
    var horizontalCrop = Math.min(0, position.left) + Math.min(0, fitRect.right - (position.left + size.width));
    return Math.abs(verticalCrop) * size.width + Math.abs(horizontalCrop) * size.height;
  },


  __getPosition: function(hAlign, vAlign, size, positionRect, fitRect) {
    // All the possible configurations.
    // Ordered as top-left, top-right, bottom-left, bottom-right.
    var positions = [{
      verticalAlign: 'top',
      horizontalAlign: 'left',
      top: positionRect.top + this.verticalOffset,
      left: positionRect.left + this.horizontalOffset
    }, {
      verticalAlign: 'top',
      horizontalAlign: 'right',
      top: positionRect.top + this.verticalOffset,
      left: positionRect.right - size.width - this.horizontalOffset
    }, {
      verticalAlign: 'bottom',
      horizontalAlign: 'left',
      top: positionRect.bottom - size.height - this.verticalOffset,
      left: positionRect.left + this.horizontalOffset
    }, {
      verticalAlign: 'bottom',
      horizontalAlign: 'right',
      top: positionRect.bottom - size.height - this.verticalOffset,
      left: positionRect.right - size.width - this.horizontalOffset
    }];

    if (this.noOverlap) {
      // Duplicate.
      for (var i = 0, l = positions.length; i < l; i++) {
        var copy = {};
        for (var key in positions[i]) {
          copy[key] = positions[i][key];
        }
        positions.push(copy);
      }
      // Horizontal overlap only.
      positions[0].top = positions[1].top += positionRect.height;
      positions[2].top = positions[3].top -= positionRect.height;
      // Vertical overlap only.
      positions[4].left = positions[6].left += positionRect.width;
      positions[5].left = positions[7].left -= positionRect.width;
    }

    // Consider auto as null for coding convenience.
    vAlign = vAlign === 'auto' ? null : vAlign;
    hAlign = hAlign === 'auto' ? null : hAlign;

    var position;
    for (var i = 0; i < positions.length; i++) {
      var pos = positions[i];

      // If both vAlign and hAlign are defined, return exact match.
      // For dynamicAlign and noOverlap we'll have more than one candidate, so
      // we'll have to check the croppedArea to make the best choice.
      if (!this.dynamicAlign && !this.noOverlap &&
        pos.verticalAlign === vAlign && pos.horizontalAlign === hAlign) {
        position = pos;
        break;
      }

      // Align is ok if alignment preferences are respected. If no preferences,
      // it is considered ok.
      var alignOk = (!vAlign || pos.verticalAlign === vAlign) &&
        (!hAlign || pos.horizontalAlign === hAlign);

      // Filter out elements that don't match the alignment (if defined).
      // With dynamicAlign, we need to consider all the positions to find the
      // one that minimizes the cropped area.
      if (!this.dynamicAlign && !alignOk) {
        continue;
      }

      position = position || pos;
      pos.croppedArea = this.__getCroppedArea(pos, size, fitRect);
      var diff = pos.croppedArea - position.croppedArea;
      // Check which crops less. If it crops equally, check if align is ok.
      if (diff < 0 || (diff === 0 && alignOk)) {
        position = pos;
      }
      // If not cropped and respects the align requirements, keep it.
      // This allows to prefer positions overlapping horizontally over the
      // ones overlapping vertically.
      if (position.croppedArea === 0 && alignOk) {
        break;
      }
    }

    return position;
  }

};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronFitBehavior;



/***/ }),
/* 77 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_utils_settings_js__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




const IronResizableBehavior = {
  properties: {
    /**
     * The closest ancestor element that implements `IronResizableBehavior`.
     */
    _parentResizable: {
      type: Object,
      observer: '_parentResizableChanged'
    },

    /**
     * True if this element is currently notifying its descendant elements of
     * resize.
     */
    _notifyingDescendant: {
      type: Boolean,
      value: false
    }
  },

  listeners: {
    'iron-request-resize-notifications': '_onIronRequestResizeNotifications'
  },

  created: function() {
    // We don't really need property effects on these, and also we want them
    // to be created before the `_parentResizable` observer fires:
    this._interestedResizables = [];
    this._boundNotifyResize = this.notifyResize.bind(this);
  },

  attached: function() {
    this._requestResizeNotifications();
  },

  detached: function() {
    if (this._parentResizable) {
      this._parentResizable.stopResizeNotificationsFor(this);
    } else {
      window.removeEventListener('resize', this._boundNotifyResize);
    }

    this._parentResizable = null;
  },

  /**
   * Can be called to manually notify a resizable and its descendant
   * resizables of a resize change.
   */
  notifyResize: function() {
    if (!this.isAttached) {
      return;
    }

    this._interestedResizables.forEach(function(resizable) {
      if (this.resizerShouldNotify(resizable)) {
        this._notifyDescendant(resizable);
      }
    }, this);

    this._fireResize();
  },

  /**
   * Used to assign the closest resizable ancestor to this resizable
   * if the ancestor detects a request for notifications.
   */
  assignParentResizable: function(parentResizable) {
    this._parentResizable = parentResizable;
  },

  /**
   * Used to remove a resizable descendant from the list of descendants
   * that should be notified of a resize change.
   */
  stopResizeNotificationsFor: function(target) {
    var index = this._interestedResizables.indexOf(target);

    if (index > -1) {
      this._interestedResizables.splice(index, 1);
      this.unlisten(target, 'iron-resize', '_onDescendantIronResize');
    }
  },

  /**
   * This method can be overridden to filter nested elements that should or
   * should not be notified by the current element. Return true if an element
   * should be notified, or false if it should not be notified.
   *
   * @param {HTMLElement} element A candidate descendant element that
   * implements `IronResizableBehavior`.
   * @return {boolean} True if the `element` should be notified of resize.
   */
  resizerShouldNotify: function(element) { return true; },

  _onDescendantIronResize: function(event) {
    if (this._notifyingDescendant) {
      event.stopPropagation();
      return;
    }

    // NOTE(cdata): In ShadowDOM, event retargeting makes echoing of the
    // otherwise non-bubbling event "just work." We do it manually here for
    // the case where Polymer is not using shadow roots for whatever reason:
    if (!__WEBPACK_IMPORTED_MODULE_1__polymer_lib_utils_settings_js__["a" /* Settings */].useShadow) {
      this._fireResize();
    }
  },

  _fireResize: function() {
    this.fire('iron-resize', null, {
      node: this,
      bubbles: false
    });
  },

  _onIronRequestResizeNotifications: function(event) {
    var target = /** @type {!EventTarget} */ (Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).rootTarget);
    if (target === this) {
      return;
    }

    if (this._interestedResizables.indexOf(target) === -1) {
      this._interestedResizables.push(target);
      this.listen(target, 'iron-resize', '_onDescendantIronResize');
    }

    target.assignParentResizable(this);
    this._notifyDescendant(target);

    event.stopPropagation();
  },

  _parentResizableChanged: function(parentResizable) {
    if (parentResizable) {
      window.removeEventListener('resize', this._boundNotifyResize);
    }
  },

  _notifyDescendant: function(descendant) {
    // NOTE(cdata): In IE10, attached is fired on children first, so it's
    // important not to notify them if the parent is not attached yet (or
    // else they will get redundantly notified when the parent attaches).
    if (!this.isAttached) {
      return;
    }

    this._notifyingDescendant = true;
    descendant.notifyResize();
    this._notifyingDescendant = false;
  },
  
  _requestResizeNotifications: function() {
    if (!this.isAttached)
      return;
    
    // NOTE(valdrin) In CustomElements v1 with native HTMLImports, the order
    // of imports affects the order of `attached` callbacks (see webcomponents/custom-elements#15).
    // This might cause a child to notify parents too early (as the parent
    // still has to be upgraded), resulting in a parent not able to keep track
    // of the `_interestedResizables`. To solve this, we wait for the document
    // to be done loading before firing the event.
    if (document.readyState === 'loading') {
      var _requestResizeNotifications = this._requestResizeNotifications.bind(this);
      document.addEventListener('readystatechange', function readystatechanged() {
        document.removeEventListener('readystatechange', readystatechanged);
        _requestResizeNotifications();
      });
    } else {
      this.fire('iron-request-resize-notifications', null, {
        node: this,
        bubbles: true,
        cancelable: true
      });

      if (!this._parentResizable) {
        window.addEventListener('resize', this._boundNotifyResize);
        this.notifyResize();
      } 
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronResizableBehavior;



/***/ }),
/* 78 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_overlay_backdrop_js__ = __webpack_require__(79);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_utils_gestures_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);






const IronOverlayManagerClass = function() {
  /**
   * Used to keep track of the opened overlays.
   * @private {Array<Element>}
   */
  this._overlays = [];

  /**
   * iframes have a default z-index of 100,
   * so this default should be at least that.
   * @private {number}
   */
  this._minimumZ = 101;

  /**
   * Memoized backdrop element.
   * @private {Element|null}
   */
  this._backdropElement = null;

  // Enable document-wide tap recognizer.
  // NOTE: Use useCapture=true to avoid accidentally prevention of the closing
  // of an overlay via event.stopPropagation(). The only way to prevent
  // closing of an overlay should be through its APIs.
  // NOTE: enable tap on <html> to workaround Polymer/polymer#4459
  __WEBPACK_IMPORTED_MODULE_3__polymer_lib_utils_gestures_js__["add"](document.documentElement, 'tap', null);
  document.addEventListener('tap', this._onCaptureClick.bind(this), true);
  document.addEventListener('focus', this._onCaptureFocus.bind(this), true);
  document.addEventListener('keydown', this._onCaptureKeyDown.bind(this), true);
};
/* unused harmony export IronOverlayManagerClass */


IronOverlayManagerClass.prototype = {

  constructor: IronOverlayManagerClass,

  /**
   * The shared backdrop element.
   * @type {!Element} backdropElement
   */
  get backdropElement() {
    if (!this._backdropElement) {
      this._backdropElement = document.createElement('iron-overlay-backdrop');
    }
    return this._backdropElement;
  },

  /**
   * The deepest active element.
   * @type {!Element} activeElement the active element
   */
  get deepActiveElement() {
    // document.activeElement can be null
    // https://developer.mozilla.org/en-US/docs/Web/API/Document/activeElement
    // In case of null, default it to document.body.
    var active = document.activeElement || document.body;
    while (active.root && Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(active.root).activeElement) {
      active = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(active.root).activeElement;
    }
    return active;
  },

  /**
   * Brings the overlay at the specified index to the front.
   * @param {number} i
   * @private
   */
  _bringOverlayAtIndexToFront: function(i) {
    var overlay = this._overlays[i];
    if (!overlay) {
      return;
    }
    var lastI = this._overlays.length - 1;
    var currentOverlay = this._overlays[lastI];
    // Ensure always-on-top overlay stays on top.
    if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      lastI--;
    }
    // If already the top element, return.
    if (i >= lastI) {
      return;
    }
    // Update z-index to be on top.
    var minimumZ = Math.max(this.currentOverlayZ(), this._minimumZ);
    if (this._getZ(overlay) <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }

    // Shift other overlays behind the new on top.
    while (i < lastI) {
      this._overlays[i] = this._overlays[i + 1];
      i++;
    }
    this._overlays[lastI] = overlay;
  },

  /**
   * Adds the overlay and updates its z-index if it's opened, or removes it if it's closed.
   * Also updates the backdrop z-index.
   * @param {!Element} overlay
   */
  addOrRemoveOverlay: function(overlay) {
    if (overlay.opened) {
      this.addOverlay(overlay);
    } else {
      this.removeOverlay(overlay);
    }
  },

  /**
   * Tracks overlays for z-index and focus management.
   * Ensures the last added overlay with always-on-top remains on top.
   * @param {!Element} overlay
   */
  addOverlay: function(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i >= 0) {
      this._bringOverlayAtIndexToFront(i);
      this.trackBackdrop();
      return;
    }
    var insertionIndex = this._overlays.length;
    var currentOverlay = this._overlays[insertionIndex - 1];
    var minimumZ = Math.max(this._getZ(currentOverlay), this._minimumZ);
    var newZ = this._getZ(overlay);

    // Ensure always-on-top overlay stays on top.
    if (currentOverlay && this._shouldBeBehindOverlay(overlay, currentOverlay)) {
      // This bumps the z-index of +2.
      this._applyOverlayZ(currentOverlay, minimumZ);
      insertionIndex--;
      // Update minimumZ to match previous overlay's z-index.
      var previousOverlay = this._overlays[insertionIndex - 1];
      minimumZ = Math.max(this._getZ(previousOverlay), this._minimumZ);
    }

    // Update z-index and insert overlay.
    if (newZ <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }
    this._overlays.splice(insertionIndex, 0, overlay);

    this.trackBackdrop();
  },

  /**
   * @param {!Element} overlay
   */
  removeOverlay: function(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i === -1) {
      return;
    }
    this._overlays.splice(i, 1);

    this.trackBackdrop();
  },

  /**
   * Returns the current overlay.
   * @return {Element|undefined}
   */
  currentOverlay: function() {
    var i = this._overlays.length - 1;
    return this._overlays[i];
  },

  /**
   * Returns the current overlay z-index.
   * @return {number}
   */
  currentOverlayZ: function() {
    return this._getZ(this.currentOverlay());
  },

  /**
   * Ensures that the minimum z-index of new overlays is at least `minimumZ`.
   * This does not effect the z-index of any existing overlays.
   * @param {number} minimumZ
   */
  ensureMinimumZ: function(minimumZ) {
    this._minimumZ = Math.max(this._minimumZ, minimumZ);
  },

  focusOverlay: function() {
    var current = /** @type {?} */ (this.currentOverlay());
    if (current) {
      current._applyFocus();
    }
  },

  /**
   * Updates the backdrop z-index.
   */
  trackBackdrop: function() {
    var overlay = this._overlayWithBackdrop();
    // Avoid creating the backdrop if there is no overlay with backdrop.
    if (!overlay && !this._backdropElement) {
      return;
    }
    this.backdropElement.style.zIndex = this._getZ(overlay) - 1;
    this.backdropElement.opened = !!overlay;
    // Property observers are not fired until element is attached
    // in Polymer 2.x, so we ensure element is attached if needed.
    // https://github.com/Polymer/polymer/issues/4526
    this.backdropElement.prepare();
  },

  /**
   * @return {Array<Element>}
   */
  getBackdrops: function() {
    var backdrops = [];
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        backdrops.push(this._overlays[i]);
      }
    }
    return backdrops;
  },

  /**
   * Returns the z-index for the backdrop.
   * @return {number}
   */
  backdropZ: function() {
    return this._getZ(this._overlayWithBackdrop()) - 1;
  },

  /**
   * Returns the first opened overlay that has a backdrop.
   * @return {Element|undefined}
   * @private
   */
  _overlayWithBackdrop: function() {
    for (var i = 0; i < this._overlays.length; i++) {
      if (this._overlays[i].withBackdrop) {
        return this._overlays[i];
      }
    }
  },

  /**
   * Calculates the minimum z-index for the overlay.
   * @param {Element=} overlay
   * @private
   */
  _getZ: function(overlay) {
    var z = this._minimumZ;
    if (overlay) {
      var z1 = Number(overlay.style.zIndex || window.getComputedStyle(overlay).zIndex);
      // Check if is a number
      // Number.isNaN not supported in IE 10+
      if (z1 === z1) {
        z = z1;
      }
    }
    return z;
  },

  /**
   * @param {!Element} element
   * @param {number|string} z
   * @private
   */
  _setZ: function(element, z) {
    element.style.zIndex = z;
  },

  /**
   * @param {!Element} overlay
   * @param {number} aboveZ
   * @private
   */
  _applyOverlayZ: function(overlay, aboveZ) {
    this._setZ(overlay, aboveZ + 2);
  },

  /**
   * Returns the deepest overlay in the path.
   * @param {Array<Element>=} path
   * @return {Element|undefined}
   * @suppress {missingProperties}
   * @private
   */
  _overlayInPath: function(path) {
    path = path || [];
    for (var i = 0; i < path.length; i++) {
      if (path[i]._manager === this) {
        return path[i];
      }
    }
  },

  /**
   * Ensures the click event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureClick: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    // Check if clicked outside of top overlay.
    if (overlay && this._overlayInPath(Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).path) !== overlay) {
      overlay._onCaptureClick(event);
    }
  },

  /**
   * Ensures the focus event is delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureFocus: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    if (overlay) {
      overlay._onCaptureFocus(event);
    }
  },

  /**
   * Ensures TAB and ESC keyboard events are delegated to the right overlay.
   * @param {!Event} event
   * @private
   */
  _onCaptureKeyDown: function(event) {
    var overlay = /** @type {?} */ (this.currentOverlay());
    if (overlay) {
      if (__WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */].keyboardEventMatchesKeys(event, 'esc')) {
        overlay._onCaptureEsc(event);
      } else if (__WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */].keyboardEventMatchesKeys(event, 'tab')) {
        overlay._onCaptureTab(event);
      }
    }
  },

  /**
   * Returns if the overlay1 should be behind overlay2.
   * @param {!Element} overlay1
   * @param {!Element} overlay2
   * @return {boolean}
   * @suppress {missingProperties}
   * @private
   */
  _shouldBeBehindOverlay: function(overlay1, overlay2) {
    return !overlay1.alwaysOnTop && overlay2.alwaysOnTop;
  }
};

const IronOverlayManager = new IronOverlayManagerClass();
/* harmony export (immutable) */ __webpack_exports__["a"] = IronOverlayManager;



/***/ }),
/* 79 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);




Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--iron-overlay-backdrop-background-color, #000);
        opacity: 0;
        transition: opacity 0.2s;
        pointer-events: none;
        @apply --iron-overlay-backdrop;
      }

      :host(.opened) {
        opacity: var(--iron-overlay-backdrop-opacity, 0.6);
        pointer-events: auto;
        @apply --iron-overlay-backdrop-opened;
      }
    </style>

    <slot></slot>
`,

  is: 'iron-overlay-backdrop',

  properties: {

    /**
     * Returns true if the backdrop is opened.
     */
    opened: {
      reflectToAttribute: true,
      type: Boolean,
      value: false,
      observer: '_openedChanged'
    }

  },

  listeners: {
    'transitionend': '_onTransitionend'
  },

  created: function() {
    // Used to cancel previous requestAnimationFrame calls when opened changes.
    this.__openedRaf = null;
  },

  attached: function() {
    this.opened && this._openedChanged(this.opened);
  },

  /**
   * Appends the backdrop to document body if needed.
   */
  prepare: function() {
    if (this.opened && !this.parentNode) {
      Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(document.body).appendChild(this);
    }
  },

  /**
   * Shows the backdrop.
   */
  open: function() {
    this.opened = true;
  },

  /**
   * Hides the backdrop.
   */
  close: function() {
    this.opened = false;
  },

  /**
   * Removes the backdrop from document body if needed.
   */
  complete: function() {
    if (!this.opened && this.parentNode === document.body) {
      Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.parentNode).removeChild(this);
    }
  },

  _onTransitionend: function(event) {
    if (event && event.target === this) {
      this.complete();
    }
  },

  /**
   * @param {boolean} opened
   * @private
   */
  _openedChanged: function(opened) {
    if (opened) {
      // Auto-attach.
      this.prepare();
    } else {
      // Animation might be disabled via the mixin or opacity custom property.
      // If it is disabled in other ways, it's up to the user to call complete.
      var cs = window.getComputedStyle(this);
      if (cs.transitionDuration === '0s' || cs.opacity == 0) {
        this.complete();
      }
    }

    if (!this.isAttached) {
      return;
    }

    // Always cancel previous requestAnimationFrame.
    if (this.__openedRaf) {
      window.cancelAnimationFrame(this.__openedRaf);
      this.__openedRaf = null;
    }
    // Force relayout to ensure proper transitions.
    this.scrollTop = this.scrollTop;
    this.__openedRaf = window.requestAnimationFrame(function() {
      this.__openedRaf = null;
      this.toggleClass('opened', this.opened);
    }.bind(this));
  }
});


/***/ }),
/* 80 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);



var p = Element.prototype;
var matches = p.matches || p.matchesSelector || p.mozMatchesSelector ||
  p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

const IronFocusablesHelper = {

  /**
   * Returns a sorted array of tabbable nodes, including the root node.
   * It searches the tabbable nodes in the light and shadow dom of the chidren,
   * sorting the result by tabindex.
   * @param {!Node} node
   * @return {Array<HTMLElement>}
   */
  getTabbableNodes: function(node) {
    var result = [];
    // If there is at least one element with tabindex > 0, we need to sort
    // the final array by tabindex.
    var needsSortByTabIndex = this._collectTabbableNodes(node, result);
    if (needsSortByTabIndex) {
      return this._sortByTabIndex(result);
    }
    return result;
  },

  /**
   * Returns if a element is focusable.
   * @param {!HTMLElement} element
   * @return {boolean}
   */
  isFocusable: function(element) {
    // From http://stackoverflow.com/a/1600194/4228703:
    // There isn't a definite list, it's up to the browser. The only
    // standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,
    // according to which the only elements that have a focus() method are
    // HTMLInputElement,  HTMLSelectElement, HTMLTextAreaElement and
    // HTMLAnchorElement. This notably omits HTMLButtonElement and
    // HTMLAreaElement.
    // Referring to these tests with tabbables in different browsers
    // http://allyjs.io/data-tables/focusable.html

    // Elements that cannot be focused if they have [disabled] attribute.
    if (matches.call(element, 'input, select, textarea, button, object')) {
      return matches.call(element, ':not([disabled])');
    }
    // Elements that can be focused even if they have [disabled] attribute.
    return matches.call(element,
      'a[href], area[href], iframe, [tabindex], [contentEditable]');
  },

  /**
   * Returns if a element is tabbable. To be tabbable, a element must be
   * focusable, visible, and with a tabindex !== -1.
   * @param {!HTMLElement} element
   * @return {boolean}
   */
  isTabbable: function(element) {
    return this.isFocusable(element) &&
      matches.call(element, ':not([tabindex="-1"])') &&
      this._isVisible(element);
  },

  /**
   * Returns the normalized element tabindex. If not focusable, returns -1.
   * It checks for the attribute "tabindex" instead of the element property
   * `tabIndex` since browsers assign different values to it.
   * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
   * @param {!HTMLElement} element
   * @return {!number}
   * @private
   */
  _normalizedTabIndex: function(element) {
    if (this.isFocusable(element)) {
      var tabIndex = element.getAttribute('tabindex') || 0;
      return Number(tabIndex);
    }
    return -1;
  },

  /**
   * Searches for nodes that are tabbable and adds them to the `result` array.
   * Returns if the `result` array needs to be sorted by tabindex.
   * @param {!Node} node The starting point for the search; added to `result`
   * if tabbable.
   * @param {!Array<HTMLElement>} result
   * @return {boolean}
   * @private
   */
  _collectTabbableNodes: function(node, result) {
    // If not an element or not visible, no need to explore children.
    if (node.nodeType !== Node.ELEMENT_NODE || !this._isVisible(node)) {
      return false;
    }
    var element = /** @type {HTMLElement} */ (node);
    var tabIndex = this._normalizedTabIndex(element);
    var needsSort = tabIndex > 0;
    if (tabIndex >= 0) {
      result.push(element);
    }

    // In ShadowDOM v1, tab order is affected by the order of distrubution.
    // E.g. getTabbableNodes(#root) in ShadowDOM v1 should return [#A, #B];
    // in ShadowDOM v0 tab order is not affected by the distrubution order,
    // in fact getTabbableNodes(#root) returns [#B, #A].
    //  <div id="root">
    //   <!-- shadow -->
    //     <slot name="a">
    //     <slot name="b">
    //   <!-- /shadow -->
    //   <input id="A" slot="a">
    //   <input id="B" slot="b" tabindex="1">
    //  </div>
    // TODO(valdrin) support ShadowDOM v1 when upgrading to Polymer v2.0.
    var children;
    if (element.localName === 'content' || element.localName === 'slot') {
      children = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(element).getDistributedNodes();
    } else {
      // Use shadow root if possible, will check for distributed nodes.
      children = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(element.root || element).children;
    }
    for (var i = 0; i < children.length; i++) {
      // Ensure method is always invoked to collect tabbable children.
      needsSort = this._collectTabbableNodes(children[i], result) || needsSort;
    }
    return needsSort;
  },

  /**
   * Returns false if the element has `visibility: hidden` or `display: none`
   * @param {!HTMLElement} element
   * @return {boolean}
   * @private
   */
  _isVisible: function(element) {
    // Check inline style first to save a re-flow. If looks good, check also
    // computed style.
    var style = element.style;
    if (style.visibility !== 'hidden' && style.display !== 'none') {
      style = window.getComputedStyle(element);
      return (style.visibility !== 'hidden' && style.display !== 'none');
    }
    return false;
  },

  /**
   * Sorts an array of tabbable elements by tabindex. Returns a new array.
   * @param {!Array<HTMLElement>} tabbables
   * @return {Array<HTMLElement>}
   * @private
   */
  _sortByTabIndex: function(tabbables) {
    // Implement a merge sort as Array.prototype.sort does a non-stable sort
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort
    var len = tabbables.length;
    if (len < 2) {
      return tabbables;
    }
    var pivot = Math.ceil(len / 2);
    var left = this._sortByTabIndex(tabbables.slice(0, pivot));
    var right = this._sortByTabIndex(tabbables.slice(pivot));
    return this._mergeSortByTabIndex(left, right);
  },

  /**
   * Merge sort iterator, merges the two arrays into one, sorted by tab index.
   * @param {!Array<HTMLElement>} left
   * @param {!Array<HTMLElement>} right
   * @return {Array<HTMLElement>}
   * @private
   */
  _mergeSortByTabIndex: function(left, right) {
    var result = [];
    while ((left.length > 0) && (right.length > 0)) {
      if (this._hasLowerTabOrder(left[0], right[0])) {
        result.push(right.shift());
      } else {
        result.push(left.shift());
      }
    }

    return result.concat(left, right);
  },

  /**
   * Returns if element `a` has lower tab order compared to element `b`
   * (both elements are assumed to be focusable and tabbable).
   * Elements with tabindex = 0 have lower tab order compared to elements
   * with tabindex > 0.
   * If both have same tabindex, it returns false.
   * @param {!HTMLElement} a
   * @param {!HTMLElement} b
   * @return {boolean}
   * @private
   */
  _hasLowerTabOrder: function(a, b) {
    // Normalize tabIndexes
    // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
    var ati = Math.max(a.tabIndex, 0);
    var bti = Math.max(b.tabIndex, 0);
    return (ati === 0 || bti === 0) ? bti > ati : ati > bti;
  }
};
/* harmony export (immutable) */ __webpack_exports__["a"] = IronFocusablesHelper;



/***/ }),
/* 81 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__paper_styles_shadow_js__ = __webpack_require__(44);





const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-dialog-shared-styles">
  <template>
    <style>
      :host {
        display: block;
        margin: 24px 40px;

        background: var(--paper-dialog-background-color, var(--primary-background-color));
        color: var(--paper-dialog-color, var(--primary-text-color));

        @apply --paper-font-body1;
        @apply --shadow-elevation-16dp;
        @apply --paper-dialog;
      }

      :host > ::slotted(*) {
        margin-top: 20px;
        padding: 0 24px;
      }

      :host > ::slotted(.no-padding) {
        padding: 0;
      }

      /* In 1.x, this selector was \`:host > ::content h2\`. In 2.x <slot> allows
      to select direct children only, which increases the weight of this
      selector, so we have to move it before first-child/last-child selectors */
      :host > ::slotted(h2) {
        position: relative;
        margin: 0;

        @apply --paper-font-title;
        @apply --paper-dialog-title;
      }

      :host > ::slotted(*:first-child) {
        margin-top: 24px;
      }

      :host > ::slotted(*:last-child) {
        margin-bottom: 24px;
      }

      :host > ::slotted(.buttons) {
        position: relative;
        padding: 8px 8px 8px 24px;
        margin: 0;

        color: var(--paper-dialog-button-color, var(--primary-color));

        @apply --layout-horizontal;
        @apply --layout-end-justified;
      }
    </style>
  </template>
</dom-module>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 82 */
/***/ (function(module, exports) {

const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,700|Roboto:400,300,300italic,400italic,500,500italic,700,700italic" crossorigin="anonymous">
`;
document.head.appendChild($_documentContainer);


/***/ }),
/* 83 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_button_behavior_js__ = __webpack_require__(84);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_element_styles_paper_material_styles_js__ = __webpack_require__(86);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);





const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-button">
  <template strip-whitespace="">
    <style include="paper-material-styles">
      /* Need to specify the same specificity as the styles imported from paper-material. */
      :host {
        @apply --layout-inline;
        @apply --layout-center-center;
        position: relative;
        box-sizing: border-box;
        min-width: 5.14em;
        margin: 0 0.29em;
        background: transparent;
        -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
        -webkit-tap-highlight-color: transparent;
        font: inherit;
        text-transform: uppercase;
        outline-width: 0;
        border-radius: 3px;
        -moz-user-select: none;
        -ms-user-select: none;
        -webkit-user-select: none;
        user-select: none;
        cursor: pointer;
        z-index: 0;
        padding: 0.7em 0.57em;

        @apply --paper-font-common-base;
        @apply --paper-button;
      }

      :host([elevation="1"]) {
        @apply --paper-material-elevation-1;
      }

      :host([elevation="2"]) {
        @apply --paper-material-elevation-2;
      }

      :host([elevation="3"]) {
        @apply --paper-material-elevation-3;
      }

      :host([elevation="4"]) {
        @apply --paper-material-elevation-4;
      }

      :host([elevation="5"]) {
        @apply --paper-material-elevation-5;
      }

      :host([hidden]) {
        display: none !important;
      }

      :host([raised].keyboard-focus) {
        font-weight: bold;
        @apply --paper-button-raised-keyboard-focus;
      }

      :host(:not([raised]).keyboard-focus) {
        font-weight: bold;
        @apply --paper-button-flat-keyboard-focus;
      }

      :host([disabled]) {
        background: #eaeaea;
        color: #a8a8a8;
        cursor: auto;
        pointer-events: none;

        @apply --paper-button-disabled;
      }

      :host([animated]) {
        @apply --shadow-transition;
      }

      paper-ripple {
        color: var(--paper-button-ink-color);
      }
    </style>

    <slot></slot>
  </template>

  
</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-button',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_button_behavior_js__["a" /* PaperButtonBehavior */]
  ],

  properties: {
    /**
     * If true, the button should be styled with a shadow.
     */
    raised: {
      type: Boolean,
      reflectToAttribute: true,
      value: false,
      observer: '_calculateElevation'
    }
  },

  _calculateElevation: function() {
    if (!this.raised) {
      this._setElevation(0);
    } else {
      __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_button_behavior_js__["b" /* PaperButtonBehaviorImpl */]._calculateElevation.apply(this);
    }
  }

  /**
  Fired when the animation finishes.
  This is useful if you want to wait until
  the ripple animation finishes to perform some action.

  @event transitionend
  Event param: {{node: Object}} detail Contains the animated node.
  */
});


/***/ }),
/* 84 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__ = __webpack_require__(19);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__ = __webpack_require__(18);





const PaperButtonBehaviorImpl = {
  properties: {
    /**
     * The z-depth of this element, from 0-5. Setting to 0 will remove the
     * shadow, and each increasing number greater than 0 will be "deeper"
     * than the last.
     *
     * @attribute elevation
     * @type number
     * @default 1
     */
    elevation: {
      type: Number,
      reflectToAttribute: true,
      readOnly: true
    }
  },

  observers: [
    '_calculateElevation(focused, disabled, active, pressed, receivedFocusFromKeyboard)',
    '_computeKeyboardClass(receivedFocusFromKeyboard)'
  ],

  hostAttributes: {
    role: 'button',
    tabindex: '0',
    animated: true
  },

  _calculateElevation: function() {
    var e = 1;
    if (this.disabled) {
      e = 0;
    } else if (this.active || this.pressed) {
      e = 4;
    } else if (this.receivedFocusFromKeyboard) {
      e = 3;
    }
    this._setElevation(e);
  },

  _computeKeyboardClass: function(receivedFocusFromKeyboard) {
    this.toggleClass('keyboard-focus', receivedFocusFromKeyboard);
  },

  /**
   * In addition to `IronButtonState` behavior, when space key goes down,
   * create a ripple down effect.
   *
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyDownHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["b" /* IronButtonStateImpl */]._spaceKeyDownHandler.call(this, event);
    // Ensure that there is at most one ripple when the space key is held down.
    if (this.hasRipple() && this.getRipple().ripples.length < 1) {
      this._ripple.uiDownAction();
    }
  },

  /**
   * In addition to `IronButtonState` behavior, when space key goes up,
   * create a ripple up effect.
   *
   * @param {!KeyboardEvent} event .
   */
  _spaceKeyUpHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["b" /* IronButtonStateImpl */]._spaceKeyUpHandler.call(this, event);
    if (this.hasRipple()) {
      this._ripple.uiUpAction();
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["b"] = PaperButtonBehaviorImpl;


const PaperButtonBehavior = [
  __WEBPACK_IMPORTED_MODULE_1__iron_behaviors_iron_button_state_js__["a" /* IronButtonState */],
  __WEBPACK_IMPORTED_MODULE_3__iron_behaviors_iron_control_state_js__["a" /* IronControlState */],
  __WEBPACK_IMPORTED_MODULE_2__paper_ripple_behavior_js__["a" /* PaperRippleBehavior */],
  PaperButtonBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperButtonBehavior;



/***/ }),
/* 85 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);





var Utility = {
  distance: function(x1, y1, x2, y2) {
    var xDelta = (x1 - x2);
    var yDelta = (y1 - y2);

    return Math.sqrt(xDelta * xDelta + yDelta * yDelta);
  },

  now: window.performance && window.performance.now ?
      window.performance.now.bind(window.performance) : Date.now
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function ElementMetrics(element) {
  this.element = element;
  this.width = this.boundingRect.width;
  this.height = this.boundingRect.height;

  this.size = Math.max(this.width, this.height);
}

ElementMetrics.prototype = {
  get boundingRect () {
    return this.element.getBoundingClientRect();
  },

  furthestCornerDistanceFrom: function(x, y) {
    var topLeft = Utility.distance(x, y, 0, 0);
    var topRight = Utility.distance(x, y, this.width, 0);
    var bottomLeft = Utility.distance(x, y, 0, this.height);
    var bottomRight = Utility.distance(x, y, this.width, this.height);

    return Math.max(topLeft, topRight, bottomLeft, bottomRight);
  }
};

/**
 * @param {HTMLElement} element
 * @constructor
 */
function Ripple(element) {
  this.element = element;
  this.color = window.getComputedStyle(element).color;

  this.wave = document.createElement('div');
  this.waveContainer = document.createElement('div');
  this.wave.style.backgroundColor = this.color;
  this.wave.classList.add('wave');
  this.waveContainer.classList.add('wave-container');
  Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.waveContainer).appendChild(this.wave);

  this.resetInteractionState();
}

Ripple.MAX_RADIUS = 300;

Ripple.prototype = {
  get recenters() {
    return this.element.recenters;
  },

  get center() {
    return this.element.center;
  },

  get mouseDownElapsed() {
    var elapsed;

    if (!this.mouseDownStart) {
      return 0;
    }

    elapsed = Utility.now() - this.mouseDownStart;

    if (this.mouseUpStart) {
      elapsed -= this.mouseUpElapsed;
    }

    return elapsed;
  },

  get mouseUpElapsed() {
    return this.mouseUpStart ?
      Utility.now () - this.mouseUpStart : 0;
  },

  get mouseDownElapsedSeconds() {
    return this.mouseDownElapsed / 1000;
  },

  get mouseUpElapsedSeconds() {
    return this.mouseUpElapsed / 1000;
  },

  get mouseInteractionSeconds() {
    return this.mouseDownElapsedSeconds + this.mouseUpElapsedSeconds;
  },

  get initialOpacity() {
    return this.element.initialOpacity;
  },

  get opacityDecayVelocity() {
    return this.element.opacityDecayVelocity;
  },

  get radius() {
    var width2 = this.containerMetrics.width * this.containerMetrics.width;
    var height2 = this.containerMetrics.height * this.containerMetrics.height;
    var waveRadius = Math.min(
      Math.sqrt(width2 + height2),
      Ripple.MAX_RADIUS
    ) * 1.1 + 5;

    var duration = 1.1 - 0.2 * (waveRadius / Ripple.MAX_RADIUS);
    var timeNow = this.mouseInteractionSeconds / duration;
    var size = waveRadius * (1 - Math.pow(80, -timeNow));

    return Math.abs(size);
  },

  get opacity() {
    if (!this.mouseUpStart) {
      return this.initialOpacity;
    }

    return Math.max(
      0,
      this.initialOpacity - this.mouseUpElapsedSeconds * this.opacityDecayVelocity
    );
  },

  get outerOpacity() {
    // Linear increase in background opacity, capped at the opacity
    // of the wavefront (waveOpacity).
    var outerOpacity = this.mouseUpElapsedSeconds * 0.3;
    var waveOpacity = this.opacity;

    return Math.max(
      0,
      Math.min(outerOpacity, waveOpacity)
    );
  },

  get isOpacityFullyDecayed() {
    return this.opacity < 0.01 &&
      this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isRestingAtMaxRadius() {
    return this.opacity >= this.initialOpacity &&
      this.radius >= Math.min(this.maxRadius, Ripple.MAX_RADIUS);
  },

  get isAnimationComplete() {
    return this.mouseUpStart ?
      this.isOpacityFullyDecayed : this.isRestingAtMaxRadius;
  },

  get translationFraction() {
    return Math.min(
      1,
      this.radius / this.containerMetrics.size * 2 / Math.sqrt(2)
    );
  },

  get xNow() {
    if (this.xEnd) {
      return this.xStart + this.translationFraction * (this.xEnd - this.xStart);
    }

    return this.xStart;
  },

  get yNow() {
    if (this.yEnd) {
      return this.yStart + this.translationFraction * (this.yEnd - this.yStart);
    }

    return this.yStart;
  },

  get isMouseDown() {
    return this.mouseDownStart && !this.mouseUpStart;
  },

  resetInteractionState: function() {
    this.maxRadius = 0;
    this.mouseDownStart = 0;
    this.mouseUpStart = 0;

    this.xStart = 0;
    this.yStart = 0;
    this.xEnd = 0;
    this.yEnd = 0;
    this.slideDistance = 0;

    this.containerMetrics = new ElementMetrics(this.element);
  },

  draw: function() {
    var scale;
    var translateString;
    var dx;
    var dy;

    this.wave.style.opacity = this.opacity;

    scale = this.radius / (this.containerMetrics.size / 2);
    dx = this.xNow - (this.containerMetrics.width / 2);
    dy = this.yNow - (this.containerMetrics.height / 2);


    // 2d transform for safari because of border-radius and overflow:hidden clipping bug.
    // https://bugs.webkit.org/show_bug.cgi?id=98538
    this.waveContainer.style.webkitTransform = 'translate(' + dx + 'px, ' + dy + 'px)';
    this.waveContainer.style.transform = 'translate3d(' + dx + 'px, ' + dy + 'px, 0)';
    this.wave.style.webkitTransform = 'scale(' + scale + ',' + scale + ')';
    this.wave.style.transform = 'scale3d(' + scale + ',' + scale + ',1)';
  },

  /** @param {Event=} event */
  downAction: function(event) {
    var xCenter = this.containerMetrics.width / 2;
    var yCenter = this.containerMetrics.height / 2;

    this.resetInteractionState();
    this.mouseDownStart = Utility.now();

    if (this.center) {
      this.xStart = xCenter;
      this.yStart = yCenter;
      this.slideDistance = Utility.distance(
        this.xStart, this.yStart, this.xEnd, this.yEnd
      );
    } else {
      this.xStart = event ?
          event.detail.x - this.containerMetrics.boundingRect.left :
          this.containerMetrics.width / 2;
      this.yStart = event ?
          event.detail.y - this.containerMetrics.boundingRect.top :
          this.containerMetrics.height / 2;
    }

    if (this.recenters) {
      this.xEnd = xCenter;
      this.yEnd = yCenter;
      this.slideDistance = Utility.distance(
        this.xStart, this.yStart, this.xEnd, this.yEnd
      );
    }

    this.maxRadius = this.containerMetrics.furthestCornerDistanceFrom(
      this.xStart,
      this.yStart
    );

    this.waveContainer.style.top =
      (this.containerMetrics.height - this.containerMetrics.size) / 2 + 'px';
    this.waveContainer.style.left =
      (this.containerMetrics.width - this.containerMetrics.size) / 2 + 'px';

    this.waveContainer.style.width = this.containerMetrics.size + 'px';
    this.waveContainer.style.height = this.containerMetrics.size + 'px';
  },

  /** @param {Event=} event */
  upAction: function(event) {
    if (!this.isMouseDown) {
      return;
    }

    this.mouseUpStart = Utility.now();
  },

  remove: function() {
    Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.waveContainer.parentNode).removeChild(
      this.waveContainer
    );
  }
};

Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: block;
        position: absolute;
        border-radius: inherit;
        overflow: hidden;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;

        /* See PolymerElements/paper-behaviors/issues/34. On non-Chrome browsers,
         * creating a node (with a position:absolute) in the middle of an event
         * handler "interrupts" that event handler (which happens when the
         * ripple is created on demand) */
        pointer-events: none;
      }

      :host([animating]) {
        /* This resolves a rendering issue in Chrome (as of 40) where the
           ripple is not properly clipped by its parent (which may have
           rounded corners). See: http://jsbin.com/temexa/4

           Note: We only apply this style conditionally. Otherwise, the browser
           will create a new compositing layer for every ripple element on the
           page, and that would be bad. */
        -webkit-transform: translate(0, 0);
        transform: translate3d(0, 0, 0);
      }

      #background,
      #waves,
      .wave-container,
      .wave {
        pointer-events: none;
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      #background,
      .wave {
        opacity: 0;
      }

      #waves,
      .wave {
        overflow: hidden;
      }

      .wave-container,
      .wave {
        border-radius: 50%;
      }

      :host(.circle) #background,
      :host(.circle) #waves {
        border-radius: 50%;
      }

      :host(.circle) .wave-container {
        overflow: hidden;
      }
    </style>

    <div id="background"></div>
    <div id="waves"></div>
`,

  is: 'paper-ripple',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */]
  ],

  properties: {
    /**
     * The initial opacity set on the wave.
     *
     * @attribute initialOpacity
     * @type number
     * @default 0.25
     */
    initialOpacity: {
      type: Number,
      value: 0.25
    },

    /**
     * How fast (opacity per second) the wave fades out.
     *
     * @attribute opacityDecayVelocity
     * @type number
     * @default 0.8
     */
    opacityDecayVelocity: {
      type: Number,
      value: 0.8
    },

    /**
     * If true, ripples will exhibit a gravitational pull towards
     * the center of their container as they fade away.
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    recenters: {
      type: Boolean,
      value: false
    },

    /**
     * If true, ripples will center inside its container
     *
     * @attribute recenters
     * @type boolean
     * @default false
     */
    center: {
      type: Boolean,
      value: false
    },

    /**
     * A list of the visual ripples.
     *
     * @attribute ripples
     * @type Array
     * @default []
     */
    ripples: {
      type: Array,
      value: function() {
        return [];
      }
    },

    /**
     * True when there are visible ripples animating within the
     * element.
     */
    animating: {
      type: Boolean,
      readOnly: true,
      reflectToAttribute: true,
      value: false
    },

    /**
     * If true, the ripple will remain in the "down" state until `holdDown`
     * is set to false again.
     */
    holdDown: {
      type: Boolean,
      value: false,
      observer: '_holdDownChanged'
    },

    /**
     * If true, the ripple will not generate a ripple effect
     * via pointer interaction.
     * Calling ripple's imperative api like `simulatedRipple` will
     * still generate the ripple effect.
     */
    noink: {
      type: Boolean,
      value: false
    },

    _animating: {
      type: Boolean
    },

    _boundAnimate: {
      type: Function,
      value: function() {
        return this.animate.bind(this);
      }
    }
  },

  get target () {
    return this.keyEventTarget;
  },

  keyBindings: {
    'enter:keydown': '_onEnterKeydown',
    'space:keydown': '_onSpaceKeydown',
    'space:keyup': '_onSpaceKeyup'
  },

  attached: function() {
    // Set up a11yKeysBehavior to listen to key events on the target,
    // so that space and enter activate the ripple even if the target doesn't
    // handle key events. The key handlers deal with `noink` themselves.
    if (this.parentNode.nodeType == 11) { // DOCUMENT_FRAGMENT_NODE
      this.keyEventTarget = Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).getOwnerRoot().host;
    } else {
      this.keyEventTarget = this.parentNode;
    }
    var keyEventTarget = /** @type {!EventTarget} */ (this.keyEventTarget);
    this.listen(keyEventTarget, 'up', 'uiUpAction');
    this.listen(keyEventTarget, 'down', 'uiDownAction');
  },

  detached: function() {
    this.unlisten(this.keyEventTarget, 'up', 'uiUpAction');
    this.unlisten(this.keyEventTarget, 'down', 'uiDownAction');
    this.keyEventTarget = null;
  },

  get shouldKeepAnimating () {
    for (var index = 0; index < this.ripples.length; ++index) {
      if (!this.ripples[index].isAnimationComplete) {
        return true;
      }
    }

    return false;
  },

  simulatedRipple: function() {
    this.downAction(null);

    // Please see polymer/polymer#1305
    this.async(function() {
      this.upAction();
    }, 1);
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiDownAction: function(event) {
    if (!this.noink) {
      this.downAction(event);
    }
  },

  /**
   * Provokes a ripple down effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  downAction: function(event) {
    if (this.holdDown && this.ripples.length > 0) {
      return;
    }

    var ripple = this.addRipple();

    ripple.downAction(event);

    if (!this._animating) {
      this._animating = true;
      this.animate();
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * respecting the `noink` property.
   * @param {Event=} event
   */
  uiUpAction: function(event) {
    if (!this.noink) {
      this.upAction(event);
    }
  },

  /**
   * Provokes a ripple up effect via a UI event,
   * *not* respecting the `noink` property.
   * @param {Event=} event
   */
  upAction: function(event) {
    if (this.holdDown) {
      return;
    }

    this.ripples.forEach(function(ripple) {
      ripple.upAction(event);
    });

    this._animating = true;
    this.animate();
  },

  onAnimationComplete: function() {
    this._animating = false;
    this.$.background.style.backgroundColor = null;
    this.fire('transitionend');
  },

  addRipple: function() {
    var ripple = new Ripple(this);

    Object(__WEBPACK_IMPORTED_MODULE_2__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.$.waves).appendChild(ripple.waveContainer);
    this.$.background.style.backgroundColor = ripple.color;
    this.ripples.push(ripple);

    this._setAnimating(true);

    return ripple;
  },

  removeRipple: function(ripple) {
    var rippleIndex = this.ripples.indexOf(ripple);

    if (rippleIndex < 0) {
      return;
    }

    this.ripples.splice(rippleIndex, 1);

    ripple.remove();

    if (!this.ripples.length) {
      this._setAnimating(false);
    }
  },

  /**
   * This conflicts with Element#antimate().
   * https://developer.mozilla.org/en-US/docs/Web/API/Element/animate
   * @suppress {checkTypes}
   */
  animate: function() {
    if (!this._animating) {
      return;
    }
    var index;
    var ripple;

    for (index = 0; index < this.ripples.length; ++index) {
      ripple = this.ripples[index];

      ripple.draw();

      this.$.background.style.opacity = ripple.outerOpacity;

      if (ripple.isOpacityFullyDecayed && !ripple.isRestingAtMaxRadius) {
        this.removeRipple(ripple);
      }
    }

    if (!this.shouldKeepAnimating && this.ripples.length === 0) {
      this.onAnimationComplete();
    } else {
      window.requestAnimationFrame(this._boundAnimate);
    }
  },

  _onEnterKeydown: function() {
    this.uiDownAction();
    this.async(this.uiUpAction, 1);
  },

  _onSpaceKeydown: function() {
    this.uiDownAction();
  },

  _onSpaceKeyup: function() {
    this.uiUpAction();
  },

  // note: holdDown does not respect noink since it can be a focus based
  // effect.
  _holdDownChanged: function(newVal, oldVal) {
    if (oldVal === undefined) {
      return;
    }
    if (newVal) {
      this.downAction();
    } else {
      this.upAction();
    }
  }

  /**
  Fired when the animation finishes.
  This is useful if you want to wait until
  the ripple animation finishes to perform some action.

  @event transitionend
  @param {{node: Object}} detail Contains the animated node.
  */
});


/***/ }),
/* 86 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shadow_js__ = __webpack_require__(44);


const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-material-styles">
  <template>
    <style>
      :host, html {
        --paper-material: {
          display: block;
          position: relative;
        };
        --paper-material-elevation-1: {
          @apply --shadow-elevation-2dp;
        };
        --paper-material-elevation-2: {
          @apply --shadow-elevation-4dp;
        };
        --paper-material-elevation-3: {
          @apply --shadow-elevation-6dp;
        };
        --paper-material-elevation-4: {
          @apply --shadow-elevation-8dp;
        };
        --paper-material-elevation-5: {
          @apply --shadow-elevation-16dp;
        };
      }
      :host(.paper-material), .paper-material {
        @apply --paper-material;
      }
      :host(.paper-material[elevation="1"]), .paper-material[elevation="1"] {
        @apply --paper-material-elevation-1;
      }
      :host(.paper-material[elevation="2"]), .paper-material[elevation="2"] {
        @apply --paper-material-elevation-2;
      }
      :host(.paper-material[elevation="3"]), .paper-material[elevation="3"] {
        @apply --paper-material-elevation-3;
      }
      :host(.paper-material[elevation="4"]), .paper-material[elevation="4"] {
        @apply --paper-material-elevation-4;
      }
      :host(.paper-material[elevation="5"]), .paper-material[elevation="5"] {
        @apply --paper-material-elevation-5;
      }
    </style>
  </template>
</dom-module>`;

document.head.appendChild($_documentContainer);


/***/ }),
/* 87 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_form_element_behavior_iron_form_element_behavior_js__ = __webpack_require__(45);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_input_iron_input_js__ = __webpack_require__(88);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_input_behavior_js__ = __webpack_require__(91);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__paper_input_char_counter_js__ = __webpack_require__(92);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__paper_input_container_js__ = __webpack_require__(93);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__paper_input_error_js__ = __webpack_require__(94);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__polymer_lib_elements_dom_module_js__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__polymer_polymer_element_js__ = __webpack_require__(4);










const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-input">
  <template>
    <style>
      :host {
        display: block;
      }

      :host([focused]) {
        outline: none;
      }

      :host([hidden]) {
        display: none !important;
      }

      input {
        position: relative; /* to make a stacking context */
        outline: none;
        box-shadow: none;
        padding: 0;
        width: 100%;
        max-width: 100%;
        background: transparent;
        border: none;
        color: var(--paper-input-container-input-color, var(--primary-text-color));
        -webkit-appearance: none;
        text-align: inherit;
        vertical-align: bottom;

        /* Firefox sets a min-width on the input, which can cause layout issues */
        min-width: 0;

        @apply --paper-font-subhead;
        @apply --paper-input-container-input;
      }

      input::-webkit-outer-spin-button,
      input::-webkit-inner-spin-button {
        @apply --paper-input-container-input-webkit-spinner;
      }

      input::-webkit-clear-button {
        @apply --paper-input-container-input-webkit-clear;
      }

      input::-webkit-input-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      input:-moz-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      input::-moz-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      input::-ms-clear {
        @apply --paper-input-container-ms-clear;
      }

      input:-ms-input-placeholder {
        color: var(--paper-input-container-color, var(--secondary-text-color));
      }

      label {
        pointer-events: none;
      }
    </style>

    <paper-input-container id="container" no-label-float="[[noLabelFloat]]" always-float-label="[[_computeAlwaysFloatLabel(alwaysFloatLabel,placeholder)]]" auto-validate\$="[[autoValidate]]" disabled\$="[[disabled]]" invalid="[[invalid]]">

      <slot name="prefix" slot="prefix"></slot>

      <label hidden\$="[[!label]]" aria-hidden="true" for="input" slot="label">[[label]]</label>

      <span id="template-placeholder"></span>

      <slot name="suffix" slot="suffix"></slot>

      <template is="dom-if" if="[[errorMessage]]">
        <paper-input-error aria-live="assertive" slot="add-on">[[errorMessage]]</paper-input-error>
      </template>

      <template is="dom-if" if="[[charCounter]]">
        <paper-input-char-counter slot="add-on"></paper-input-char-counter>
      </template>

    </paper-input-container>
  </template>

  <!-- This is a fresh new hell to make this element hybrid. Basically, in 2.0
    we lost is=, so the example same template can't be used with iron-input 1.0 and 2.0.
    Expect some conditional code (especially in the tests).
   -->
  <template id="v0">
    <input is="iron-input" id="input" slot="input" aria-labelledby\$="[[_ariaLabelledBy]]" aria-describedby\$="[[_ariaDescribedBy]]" disabled\$="[[disabled]]" title\$="[[title]]" bind-value="{{value}}" invalid="{{invalid}}" prevent-invalid-input="[[preventInvalidInput]]" allowed-pattern="[[allowedPattern]]" validator="[[validator]]" type\$="[[type]]" pattern\$="[[pattern]]" required\$="[[required]]" autocomplete\$="[[autocomplete]]" autofocus\$="[[autofocus]]" inputmode\$="[[inputmode]]" minlength\$="[[minlength]]" maxlength\$="[[maxlength]]" min\$="[[min]]" max\$="[[max]]" step\$="[[step]]" name\$="[[name]]" placeholder\$="[[placeholder]]" readonly\$="[[readonly]]" list\$="[[list]]" size\$="[[size]]" autocapitalize\$="[[autocapitalize]]" autocorrect\$="[[autocorrect]]" on-change="_onChange" tabindex\$="[[tabIndex]]" autosave\$="[[autosave]]" results\$="[[results]]" accept\$="[[accept]]" multiple\$="[[multiple]]">
  </template>

  <template id="v1">
    <!-- Need to bind maxlength so that the paper-input-char-counter works correctly -->
    <iron-input bind-value="{{value}}" id="input" slot="input" maxlength\$="[[maxlength]]" allowed-pattern="[[allowedPattern]]" invalid="{{invalid}}" validator="[[validator]]">
      <input id="nativeInput" aria-labelledby\$="[[_ariaLabelledBy]]" aria-describedby\$="[[_ariaDescribedBy]]" disabled\$="[[disabled]]" title\$="[[title]]" type\$="[[type]]" pattern\$="[[pattern]]" required\$="[[required]]" autocomplete\$="[[autocomplete]]" autofocus\$="[[autofocus]]" inputmode\$="[[inputmode]]" minlength\$="[[minlength]]" maxlength\$="[[maxlength]]" min\$="[[min]]" max\$="[[max]]" step\$="[[step]]" name\$="[[name]]" placeholder\$="[[placeholder]]" readonly\$="[[readonly]]" list\$="[[list]]" size\$="[[size]]" autocapitalize\$="[[autocapitalize]]" autocorrect\$="[[autocorrect]]" on-change="_onChange" tabindex\$="[[tabIndex]]" autosave\$="[[autosave]]" results\$="[[results]]" accept\$="[[accept]]" multiple\$="[[multiple]]">
    </iron-input>
  </template>

</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_7__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-input',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_3__paper_input_behavior_js__["a" /* PaperInputBehavior */],
    __WEBPACK_IMPORTED_MODULE_1__iron_form_element_behavior_iron_form_element_behavior_js__["a" /* IronFormElementBehavior */]
  ],

  beforeRegister: function() {
    // We need to tell which kind of of template to stamp based on
    // what kind of `iron-input` we got, but because of polyfills and
    // custom elements differences between v0 and v1, the safest bet is
    // to check a particular method we know the iron-input#2.x can have.
    // If it doesn't have it, then it's an iron-input#1.x.
    var ironInput = document.createElement('iron-input');
    var version = typeof ironInput._initSlottedInput == 'function' ? 'v1' : 'v0';
    var template = __WEBPACK_IMPORTED_MODULE_8__polymer_lib_elements_dom_module_js__["a" /* DomModule */].import('paper-input', 'template');
    var inputTemplate = __WEBPACK_IMPORTED_MODULE_8__polymer_lib_elements_dom_module_js__["a" /* DomModule */].import('paper-input', 'template#' + version);
    var inputPlaceholder = template.content.querySelector('#template-placeholder');
    if (inputPlaceholder) {
      inputPlaceholder.parentNode.replaceChild(inputTemplate.content, inputPlaceholder);
    }
    // else it's already been processed, probably in superclass
  },

  /**
   * Returns a reference to the focusable element. Overridden from PaperInputBehavior
   * to correctly focus the native input.
   */
  get _focusableElement() {
    return __WEBPACK_IMPORTED_MODULE_9__polymer_polymer_element_js__["a" /* Element */] ? this.inputElement._inputElement : this.inputElement;
  },

  // Note: This event is only available in the 1.0 version of this element.
  // In 2.0, the functionality of `_onIronInputReady` is done in
  // PaperInputBehavior::attached.
  listeners: {
    'iron-input-ready': '_onIronInputReady'
  },

  _onIronInputReady: function() {
    if (this.inputElement &&
        this._typesThatHaveText.indexOf(this.$.nativeInput.type) !== -1) {
      this.alwaysFloatLabel = true;
    }

    // Only validate when attached if the input already has a value.
    if (!!this.inputElement.bindValue) {
      this.$.container._handleValueAndAutoValidate(this.inputElement);
    }
  },
});


/***/ }),
/* 88 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_announcer_iron_a11y_announcer_js__ = __webpack_require__(89);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_validatable_behavior_iron_validatable_behavior_js__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
      }
    </style>
    <slot id="content"></slot>
`,

  is: 'iron-input',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__iron_validatable_behavior_iron_validatable_behavior_js__["a" /* IronValidatableBehavior */]
  ],

  /**
   * Fired whenever `validate()` is called.
   *
   * @event iron-input-validate
   */

  properties: {

    /**
     * Use this property instead of `value` for two-way data binding, or to
     * set a default value for the input. **Do not** use the distributed
     * input's `value` property to set a default value.
     */
    bindValue: {
      type: String
    },

    /**
     * Computed property that echoes `bindValue` (mostly used for Polymer 1.0
     * backcompatibility, if you were one-way binding to the Polymer 1.0
     * `input is="iron-input"` value attribute).
     */
    value: {
      computed: '_computeValue(bindValue)'
    },

    /**
     * Regex-like list of characters allowed as input; all characters not in the list
     * will be rejected. The recommended format should be a list of allowed characters,
     * for example, `[a-zA-Z0-9.+-!;:]`.
     *
     * This pattern represents the allowed characters for the field; as the user inputs text,
     * each individual character will be checked against the pattern (rather than checking
     * the entire value as a whole). If a character is not a match, it will be rejected.
     *
     * Pasted input will have each character checked individually; if any character
     * doesn't match `allowedPattern`, the entire pasted string will be rejected.
     *
     * Note: if you were using `iron-input` in 1.0, you were also required to
     * set `prevent-invalid-input`. This is no longer needed as of Polymer 2.0,
     * and will be set automatically for you if an `allowedPattern` is provided.
     *
     */
    allowedPattern: {
      type: String
    },

    /**
     * Set to true to auto-validate the input value as you type.
     */
    autoValidate: {
      type: Boolean,
      value: false
    }
  },

  observers: [
    '_bindValueChanged(bindValue, _inputElement)'
  ],

  listeners: {
    'input': '_onInput',
    'keypress': '_onKeypress'
  },

  created: function() {
    __WEBPACK_IMPORTED_MODULE_1__iron_a11y_announcer_iron_a11y_announcer_js__["a" /* IronA11yAnnouncer */].requestAvailability();
    this._previousValidInput = '';
    this._patternAlreadyChecked = false;
  },

  attached: function() {
    // If the input is added at a later time, update the internal reference.
    this._observer = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).observeNodes(function(info) {
      this._initSlottedInput();
    }.bind(this));
  },

  detached: function() {
    if (this._observer) {
      Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).unobserveNodes(this._observer);
      this._observer = null;
    }
  },

  /**
   * Returns the distributed <input> element.
   */
  get inputElement () {
    return this._inputElement;
  },

  _initSlottedInput: function() {
    this._inputElement = this.getEffectiveChildren()[0];

    if (this.inputElement && this.inputElement.value) {
      this.bindValue = this.inputElement.value;
    }

    this.fire('iron-input-ready');
  },

  get _patternRegExp() {
    var pattern;
    if (this.allowedPattern) {
      pattern = new RegExp(this.allowedPattern);
    } else {
      switch (this.type) {
        case 'number':
          pattern = /[0-9.,e-]/;
          break;
      }
    }
    return pattern;
  },

  /**
   * @suppress {checkTypes}
   */
  _bindValueChanged: function(bindValue, inputElement) {
    // The observer could have run before attached() when we have actually initialized
    // this property.
    if (!inputElement) {
      return;
    }

    if (bindValue === undefined) {
      inputElement.value = null;
    } else if (bindValue !== inputElement.value){
      this.inputElement.value = bindValue;
    }

    if (this.autoValidate) {
      this.validate();
    }

    // manually notify because we don't want to notify until after setting value
    this.fire('bind-value-changed', {value: bindValue});
  },

  _onInput: function() {
    // Need to validate each of the characters pasted if they haven't
    // been validated inside `_onKeypress` already.
    if (this.allowedPattern && !this._patternAlreadyChecked) {
      var valid = this._checkPatternValidity();
      if (!valid) {
        this._announceInvalidCharacter('Invalid string of characters not entered.');
        this.inputElement.value = this._previousValidInput;
      }
    }
    this.bindValue = this._previousValidInput = this.inputElement.value;
    this._patternAlreadyChecked = false;
  },

  _isPrintable: function(event) {
    // What a control/printable character is varies wildly based on the browser.
    // - most control characters (arrows, backspace) do not send a `keypress` event
    //   in Chrome, but the *do* on Firefox
    // - in Firefox, when they do send a `keypress` event, control chars have
    //   a charCode = 0, keyCode = xx (for ex. 40 for down arrow)
    // - printable characters always send a keypress event.
    // - in Firefox, printable chars always have a keyCode = 0. In Chrome, the keyCode
    //   always matches the charCode.
    // None of this makes any sense.

    // For these keys, ASCII code == browser keycode.
    var anyNonPrintable =
      (event.keyCode == 8)   ||  // backspace
      (event.keyCode == 9)   ||  // tab
      (event.keyCode == 13)  ||  // enter
      (event.keyCode == 27);     // escape

    // For these keys, make sure it's a browser keycode and not an ASCII code.
    var mozNonPrintable =
      (event.keyCode == 19)  ||  // pause
      (event.keyCode == 20)  ||  // caps lock
      (event.keyCode == 45)  ||  // insert
      (event.keyCode == 46)  ||  // delete
      (event.keyCode == 144) ||  // num lock
      (event.keyCode == 145) ||  // scroll lock
      (event.keyCode > 32 && event.keyCode < 41)   || // page up/down, end, home, arrows
      (event.keyCode > 111 && event.keyCode < 124); // fn keys

    return !anyNonPrintable && !(event.charCode == 0 && mozNonPrintable);
  },

  _onKeypress: function(event) {
    if (!this.allowedPattern && this.type !== 'number') {
      return;
    }
    var regexp = this._patternRegExp;
    if (!regexp) {
      return;
    }

    // Handle special keys and backspace
    if (event.metaKey || event.ctrlKey || event.altKey) {
      return;
    }

    // Check the pattern either here or in `_onInput`, but not in both.
    this._patternAlreadyChecked = true;

    var thisChar = String.fromCharCode(event.charCode);
    if (this._isPrintable(event) && !regexp.test(thisChar)) {
      event.preventDefault();
      this._announceInvalidCharacter('Invalid character ' + thisChar + ' not entered.');
    }
  },

  _checkPatternValidity: function() {
    var regexp = this._patternRegExp;
    if (!regexp) {
      return true;
    }
    for (var i = 0; i < this.inputElement.value.length; i++) {
      if (!regexp.test(this.inputElement.value[i])) {
        return false;
      }
    }
    return true;
  },

  /**
   * Returns true if `value` is valid. The validator provided in `validator` will be used first,
   * then any constraints.
   * @return {boolean} True if the value is valid.
   */
  validate: function() {
    if (!this.inputElement) {
      this.invalid = false;
      return true;
    }

    // Use the nested input's native validity.
    var valid =  this.inputElement.checkValidity();

    // Only do extra checking if the browser thought this was valid.
    if (valid) {
      // Empty, required input is invalid
      if (this.required && this.bindValue === '') {
        valid = false;
      } else if (this.hasValidator()) {
        valid = __WEBPACK_IMPORTED_MODULE_2__iron_validatable_behavior_iron_validatable_behavior_js__["a" /* IronValidatableBehavior */].validate.call(this, this.bindValue);
      }
    }

    this.invalid = !valid;
    this.fire('iron-input-validate');
    return valid;
  },

  _announceInvalidCharacter: function(message) {
    this.fire('iron-announce', { text: message });
  },

  _computeValue: function(bindValue) {
    return bindValue;
  }
});


/***/ }),
/* 89 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);



const IronA11yAnnouncer = Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
        position: fixed;
        clip: rect(0px,0px,0px,0px);
      }
    </style>
    <div aria-live\$="[[mode]]">[[_text]]</div>
`,

  is: 'iron-a11y-announcer',

  properties: {

    /**
     * The value of mode is used to set the `aria-live` attribute
     * for the element that will be announced. Valid values are: `off`,
     * `polite` and `assertive`.
     */
    mode: {
      type: String,
      value: 'polite'
    },

    _text: {
      type: String,
      value: ''
    }
  },

  created: function() {
    if (!IronA11yAnnouncer.instance) {
      IronA11yAnnouncer.instance = this;
    }

    document.body.addEventListener('iron-announce', this._onIronAnnounce.bind(this));
  },

  /**
   * Cause a text string to be announced by screen readers.
   *
   * @param {string} text The text that should be announced.
   */
  announce: function(text) {
    this._text = '';
    this.async(function() {
      this._text = text;
    }, 100);
  },

  _onIronAnnounce: function(event) {
    if (event.detail && event.detail.text) {
      this.announce(event.detail.text);
    }
  }
});
/* harmony export (immutable) */ __webpack_exports__["a"] = IronA11yAnnouncer;


IronA11yAnnouncer.instance = null;

IronA11yAnnouncer.requestAvailability = function() {
  if (!IronA11yAnnouncer.instance) {
    IronA11yAnnouncer.instance = document.createElement('iron-a11y-announcer');
  }

  document.body.appendChild(IronA11yAnnouncer.instance);
};


/***/ }),
/* 90 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return IronMeta; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);



/**
 * @constructor
 * @param {{type: (string|null), key: (string|null), value: *}} options
 */
function IronMeta(options) {
  this.type = (options && options.type) || 'default';
  this.key = options && options.key;
  if ('value' in options) {
    this.value = options.value;
  }
}

IronMeta.types = {};

IronMeta.prototype = {
  get value() {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      return IronMeta.types[type] && IronMeta.types[type][key];
    }
  },

  set value(value) {
    var type = this.type;
    var key = this.key;

    if (type && key) {
      type = IronMeta.types[type] = IronMeta.types[type] || {};
      if (value == null) {
        delete type[key];
      } else {
        type[key] = value;
      }
    }
  },

  get list() {
    var type = this.type;

    if (type) {
      return Object.keys(IronMeta.types[this.type]).map(function(key) {
        return metaDatas[this.type][key];
      }, this);
    }
  },

  byKey: function(key) {
    this.key = key;
    return this.value;
  }
};



var metaDatas = IronMeta.types;

Object(__WEBPACK_IMPORTED_MODULE_1__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({

  is: 'iron-meta',

  properties: {

    /**
     * The type of meta-data.  All meta-data of the same type is stored
     * together.
     * @type {string}
     */
    type: {
      type: String,
      value: 'default',
    },

    /**
     * The key used to store `value` under the `type` namespace.
     * @type {?string}
     */
    key: {
      type: String,
    },

    /**
     * The meta-data to store or retrieve.
     * @type {*}
     */
    value: {
      type: String,
      notify: true,
    },

    /**
     * If true, `value` is set to the iron-meta instance itself.
     */
     self: {
      type: Boolean,
      observer: '_selfChanged'
    },

    __meta: {
      type: Boolean,
      computed: '__computeMeta(type, key, value)'
    }
  },

  hostAttributes: {
    hidden: true
  },

  __computeMeta: function(type, key, value) {
    var meta = new IronMeta({
      type: type,
      key: key
    });

    if (value !== undefined && value !== meta.value) {
      meta.value = value;
    } else if (this.value !== meta.value) {
      this.value = meta.value;
    }

    return meta;
  },

  get list() {
    return this.__meta && this.__meta.list;
  },

  _selfChanged: function(self) {
    if (self) {
      this.value = this;
    }
  },

  /**
   * Retrieves meta data value by key.
   *
   * @method byKey
   * @param {string} key The key of the meta-data to be returned.
   * @return {*}
   */
  byKey: function(key) {
    return new IronMeta({
      type: this.type,
      key: key
    }).value;
  }
});


/***/ }),
/* 91 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_control_state_js__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_polymer_element_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);





const PaperInputHelper = {};
/* unused harmony export PaperInputHelper */

PaperInputHelper.NextLabelID = 1;
PaperInputHelper.NextAddonID = 1;

const PaperInputBehaviorImpl = {

  properties: {
    /**
     * Fired when the input changes due to user interaction.
     *
     * @event change
     */

    /**
     * The label for this input. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * `<label>`'s content and `hidden` property, e.g.
     * `<label hidden$="[[!label]]">[[label]]</label>` in your `template`
     */
    label: {
      type: String
    },

    /**
     * The value for this input. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<iron-input>`'s `bindValue`
     * property, or the value property of your input that is `notify:true`.
     */
    value: {
      notify: true,
      type: String
    },

    /**
     * Set to true to disable this input. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * both the `<paper-input-container>`'s and the input's `disabled` property.
     */
    disabled: {
      type: Boolean,
      value: false
    },

    /**
     * Returns true if the value is invalid. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to both the
     * `<paper-input-container>`'s and the input's `invalid` property.
     *
     * If `autoValidate` is true, the `invalid` attribute is managed automatically,
     * which can clobber attempts to manage it manually.
     */
    invalid: {
      type: Boolean,
      value: false,
      notify: true
    },

    /**
     * Set this to specify the pattern allowed by `preventInvalidInput`. If
     * you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `allowedPattern`
     * property.
     */
    allowedPattern: {
      type: String
    },

    /**
     * The type of the input. The supported types are `text`, `number` and `password`.
     * If you're using PaperInputBehavior to implement your own paper-input-like element,
     * bind this to the `<input is="iron-input">`'s `type` property.
     */
    type: {
      type: String
    },

    /**
     * The datalist of the input (if any). This should match the id of an existing `<datalist>`.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `list` property.
     */
    list: {
      type: String
    },

    /**
     * A pattern to validate the `input` with. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<input is="iron-input">`'s `pattern` property.
     */
    pattern: {
      type: String
    },

    /**
     * Set to true to mark the input as required. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<input is="iron-input">`'s `required` property.
     */
    required: {
      type: Boolean,
      value: false
    },

    /**
     * The error message to display when the input is invalid. If you're using
     * PaperInputBehavior to implement your own paper-input-like element,
     * bind this to the `<paper-input-error>`'s content, if using.
     */
    errorMessage: {
      type: String
    },

    /**
     * Set to true to show a character counter.
     */
    charCounter: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to disable the floating label. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<paper-input-container>`'s `noLabelFloat` property.
     */
    noLabelFloat: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to always float the label. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<paper-input-container>`'s `alwaysFloatLabel` property.
     */
    alwaysFloatLabel: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to auto-validate the input value. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<paper-input-container>`'s `autoValidate` property.
     */
    autoValidate: {
      type: Boolean,
      value: false
    },

    /**
     * Name of the validator to use. If you're using PaperInputBehavior to
     * implement your own paper-input-like element, bind this to
     * the `<input is="iron-input">`'s `validator` property.
     */
    validator: {
      type: String
    },

    // HTMLInputElement attributes for binding if needed

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autocomplete` property.
     */
    autocomplete: {
      type: String,
      value: 'off'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autofocus` property.
     */
    autofocus: {
      type: Boolean,
      observer: '_autofocusChanged'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `inputmode` property.
     */
    inputmode: {
      type: String
    },

    /**
     * The minimum length of the input value.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `minlength` property.
     */
    minlength: {
      type: Number
    },

    /**
     * The maximum length of the input value.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `maxlength` property.
     */
    maxlength: {
      type: Number
    },

    /**
     * The minimum (numeric or date-time) input value.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `min` property.
     */
    min: {
      type: String
    },

    /**
     * The maximum (numeric or date-time) input value.
     * Can be a String (e.g. `"2000-01-01"`) or a Number (e.g. `2`).
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `max` property.
     */
    max: {
      type: String
    },

    /**
     * Limits the numeric or date-time increments.
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `step` property.
     */
    step: {
      type: String
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `name` property.
     */
    name: {
      type: String
    },

    /**
     * A placeholder string in addition to the label. If this is set, the label will always float.
     */
    placeholder: {
      type: String,
      // need to set a default so _computeAlwaysFloatLabel is run
      value: ''
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `readonly` property.
     */
    readonly: {
      type: Boolean,
      value: false
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `size` property.
     */
    size: {
      type: Number
    },

    // Nonstandard attributes for binding if needed

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autocapitalize` property.
     */
    autocapitalize: {
      type: String,
      value: 'none'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autocorrect` property.
     */
    autocorrect: {
      type: String,
      value: 'off'
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `autosave` property,
     * used with type=search.
     */
    autosave: {
      type: String
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `results` property,
     * used with type=search.
     */
    results: {
      type: Number
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the `<input is="iron-input">`'s `accept` property,
     * used with type=file.
     */
    accept: {
      type: String
    },

    /**
     * If you're using PaperInputBehavior to implement your own paper-input-like
     * element, bind this to the`<input is="iron-input">`'s `multiple` property,
     * used with type=file.
     */
    multiple: {
      type: Boolean
    },

    _ariaDescribedBy: {
      type: String,
      value: ''
    },

    _ariaLabelledBy: {
      type: String,
      value: ''
    }

  },

  listeners: {
    'addon-attached': '_onAddonAttached',
  },

  keyBindings: {
    'shift+tab:keydown': '_onShiftTabDown'
  },

  hostAttributes: {
    tabindex: 0
  },

  /**
   * Returns a reference to the input element.
   */
  get inputElement() {
    return this.$.input;
  },

  /**
   * Returns a reference to the focusable element.
   */
  get _focusableElement() {
    return this.inputElement;
  },

  created: function() {
    // These types have some default placeholder text; overlapping
    // the label on top of it looks terrible. Auto-float the label in this case.
    this._typesThatHaveText = ["date", "datetime", "datetime-local", "month",
        "time", "week", "file"];
  },

  attached: function() {
    this._updateAriaLabelledBy();

    // In the 2.0 version of the element, this is handled in `onIronInputReady`,
    // i.e. after the native input has finished distributing. In the 1.0 version,
    // the input is in the shadow tree, so it's already available.
    if (!__WEBPACK_IMPORTED_MODULE_3__polymer_polymer_element_js__["a" /* Element */] && this.inputElement &&
        this._typesThatHaveText.indexOf(this.inputElement.type) !== -1) {
      this.alwaysFloatLabel = true;
    }
  },

  _appendStringWithSpace: function(str, more) {
    if (str) {
      str = str + ' ' + more;
    } else {
      str = more;
    }
    return str;
  },

  _onAddonAttached: function(event) {
    var target = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(event).rootTarget;
    if (target.id) {
      this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, target.id);
    } else {
      var id = 'paper-input-add-on-' + PaperInputHelper.NextAddonID++;
      target.id = id;
      this._ariaDescribedBy = this._appendStringWithSpace(this._ariaDescribedBy, id);
    }
  },

  /**
   * Validates the input element and sets an error style if needed.
   *
   * @return {boolean}
   */
  validate: function() {
    return this.inputElement.validate();
  },

  /**
   * Forward focus to inputElement. Overriden from IronControlState.
   */
  _focusBlurHandler: function(event) {
    __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_control_state_js__["a" /* IronControlState */]._focusBlurHandler.call(this, event);

    // Forward the focus to the nested input.
    if (this.focused && !this._shiftTabPressed && this._focusableElement) {
      this._focusableElement.focus();
    }
  },

  /**
   * Handler that is called when a shift+tab keypress is detected by the menu.
   *
   * @param {CustomEvent} event A key combination event.
   */
  _onShiftTabDown: function(event) {
    var oldTabIndex = this.getAttribute('tabindex');
    this._shiftTabPressed = true;
    this.setAttribute('tabindex', '-1');
    this.async(function() {
      this.setAttribute('tabindex', oldTabIndex);
      this._shiftTabPressed = false;
    }, 1);
  },

  /**
   * If `autoValidate` is true, then validates the element.
   */
  _handleAutoValidate: function() {
    if (this.autoValidate)
      this.validate();
  },

  /**
   * Restores the cursor to its original position after updating the value.
   * @param {string} newValue The value that should be saved.
   */
  updateValueAndPreserveCaret: function(newValue) {
    // Not all elements might have selection, and even if they have the
    // right properties, accessing them might throw an exception (like for
    // <input type=number>)
    try {
      var start = this.inputElement.selectionStart;
      this.value = newValue;

      // The cursor automatically jumps to the end after re-setting the value,
      // so restore it to its original position.
      this.inputElement.selectionStart = start;
      this.inputElement.selectionEnd = start;
    } catch (e) {
      // Just set the value and give up on the caret.
      this.value = newValue;
    }
  },

  _computeAlwaysFloatLabel: function(alwaysFloatLabel, placeholder) {
    return placeholder || alwaysFloatLabel;
  },

  _updateAriaLabelledBy: function() {
    var label = Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this.root).querySelector('label');
    if (!label) {
      this._ariaLabelledBy = '';
      return;
    }
    var labelledBy;
    if (label.id) {
      labelledBy = label.id;
    } else {
      labelledBy = 'paper-input-label-' + PaperInputHelper.NextLabelID++;
      label.id = labelledBy;
    }
    this._ariaLabelledBy = labelledBy;
  },

  _onChange:function(event) {
    // In the Shadow DOM, the `change` event is not leaked into the
    // ancestor tree, so we must do this manually.
    // See https://w3c.github.io/webcomponents/spec/shadow/#events-that-are-not-leaked-into-ancestor-trees.
    if (this.shadowRoot) {
      this.fire(event.type, {sourceEvent: event}, {
        node: this,
        bubbles: event.bubbles,
        cancelable: event.cancelable
      });
    }
  },

  _autofocusChanged: function() {
    // Firefox doesn't respect the autofocus attribute if it's applied after
    // the page is loaded (Chrome/WebKit do respect it), preventing an
    // autofocus attribute specified in markup from taking effect when the
    // element is upgraded. As a workaround, if the autofocus property is set,
    // and the focus hasn't already been moved elsewhere, we take focus.
    if (this.autofocus && this._focusableElement) {

      // In IE 11, the default document.activeElement can be the page's
      // outermost html element, but there are also cases (under the
      // polyfill?) in which the activeElement is not a real HTMLElement, but
      // just a plain object. We identify the latter case as having no valid
      // activeElement.
      var activeElement = document.activeElement;
      var isActiveElementValid = activeElement instanceof HTMLElement;

      // Has some other element has already taken the focus?
      var isSomeElementActive = isActiveElementValid &&
          activeElement !== document.body &&
          activeElement !== document.documentElement; /* IE 11 */
      if (!isSomeElementActive) {
        // No specific element has taken the focus yet, so we can take it.
        this._focusableElement.focus();
      }
    }
  }
};
/* unused harmony export PaperInputBehaviorImpl */


const PaperInputBehavior = [
  __WEBPACK_IMPORTED_MODULE_2__iron_behaviors_iron_control_state_js__["a" /* IronControlState */],
  __WEBPACK_IMPORTED_MODULE_1__iron_a11y_keys_behavior_iron_a11y_keys_behavior_js__["a" /* IronA11yKeysBehavior */],
  PaperInputBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = PaperInputBehavior;



/***/ }),
/* 92 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_input_addon_behavior_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);




Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
        float: right;

        @apply --paper-font-caption;
        @apply --paper-input-char-counter;
      }

      :host([hidden]) {
        display: none !important;
      }

      :host-context([dir="rtl"]) {
        float: left;
      }
    </style>

    <span>[[_charCounterStr]]</span>
`,

  is: 'paper-input-char-counter',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_input_addon_behavior_js__["a" /* PaperInputAddonBehavior */]
  ],

  properties: {
    _charCounterStr: {
      type: String,
      value: '0'
    }
  },

  /**
   * This overrides the update function in PaperInputAddonBehavior.
   * @param {{
   *   inputElement: (Element|undefined),
   *   value: (string|undefined),
   *   invalid: boolean
   * }} state -
   *     inputElement: The input element.
   *     value: The input value.
   *     invalid: True if the input value is invalid.
   */
  update: function(state) {
    if (!state.inputElement) {
      return;
    }

    state.value = state.value || '';

    var counter = state.value.toString().length.toString();

    if (state.inputElement.hasAttribute('maxlength')) {
      counter += '/' + state.inputElement.getAttribute('maxlength');
    }

    this._charCounterStr = counter;
  }
});


/***/ }),
/* 93 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_lib_utils_case_map_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polymer_lib_legacy_polymer_dom_js__ = __webpack_require__(2);







Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: block;
        padding: 8px 0;

        --paper-input-container-shared-input-style: {
          position: relative; /* to make a stacking context */
          outline: none;
          box-shadow: none;
          padding: 0;
          width: 100%;
          max-width: 100%;
          background: transparent;
          border: none;
          color: var(--paper-input-container-input-color, var(--primary-text-color));
          -webkit-appearance: none;
          text-align: inherit;
          vertical-align: bottom;

          @apply --paper-font-subhead;
        };

        @apply --paper-input-container;
      }

      :host([inline]) {
        display: inline-block;
      }

      :host([disabled]) {
        pointer-events: none;
        opacity: 0.33;

        @apply --paper-input-container-disabled;
      }

      :host([hidden]) {
        display: none !important;
      }

      [hidden] {
        display: none !important;
      }

      .floated-label-placeholder {
        @apply --paper-font-caption;
      }

      .underline {
        height: 2px;
        position: relative;
      }

      .focused-line {
        @apply --layout-fit;
        border-bottom: 2px solid var(--paper-input-container-focus-color, var(--primary-color));

        -webkit-transform-origin: center center;
        transform-origin: center center;
        -webkit-transform: scale3d(0,1,1);
        transform: scale3d(0,1,1);

        @apply --paper-input-container-underline-focus;
      }

      .underline.is-highlighted .focused-line {
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply --paper-transition-easing;
      }

      .underline.is-invalid .focused-line {
        border-color: var(--paper-input-container-invalid-color, var(--error-color));
        -webkit-transform: none;
        transform: none;
        -webkit-transition: -webkit-transform 0.25s;
        transition: transform 0.25s;

        @apply --paper-transition-easing;
      }

      .unfocused-line {
        @apply --layout-fit;
        border-bottom: 1px solid var(--paper-input-container-color, var(--secondary-text-color));
        @apply --paper-input-container-underline;
      }

      :host([disabled]) .unfocused-line {
        border-bottom: 1px dashed;
        border-color: var(--paper-input-container-color, var(--secondary-text-color));
        @apply --paper-input-container-underline-disabled;
      }

      .input-wrapper {
        @apply --layout-horizontal;
        @apply --layout-center;
        position: relative;
      }

      .input-content {
        @apply --layout-flex-auto;
        @apply --layout-relative;
        max-width: 100%;
      }

      .input-content ::slotted(label),
      .input-content ::slotted(.paper-input-label) {
        position: absolute;
        top: 0;
        right: 0;
        left: 0;
        width: 100%;
        font: inherit;
        color: var(--paper-input-container-color, var(--secondary-text-color));
        -webkit-transition: -webkit-transform 0.25s, width 0.25s;
        transition: transform 0.25s, width 0.25s;
        -webkit-transform-origin: left top;
        transform-origin: left top;

        @apply --paper-font-common-nowrap;
        @apply --paper-font-subhead;
        @apply --paper-input-container-label;
        @apply --paper-transition-easing;
      }

      .input-content.label-is-floating ::slotted(label),
      .input-content.label-is-floating ::slotted(.paper-input-label) {
        -webkit-transform: translateY(-75%) scale(0.75);
        transform: translateY(-75%) scale(0.75);

        /* Since we scale to 75/100 of the size, we actually have 100/75 of the
        original space now available */
        width: 133%;

        @apply --paper-input-container-label-floating;
      }

      :host-context([dir="rtl"]) .input-content.label-is-floating ::slotted(label),
      :host-context([dir="rtl"]) .input-content.label-is-floating ::slotted(.paper-input-label) {
        /* TODO(noms): Figure out why leaving the width at 133% before the animation
         * actually makes
         * it wider on the right side, not left side, as you would expect in RTL */
        width: 100%;
        -webkit-transform-origin: right top;
        transform-origin: right top;
      }

      .input-content.label-is-highlighted ::slotted(label),
      .input-content.label-is-highlighted ::slotted(.paper-input-label) {
        color: var(--paper-input-container-focus-color, var(--primary-color));

        @apply --paper-input-container-label-focus;
      }

      .input-content.is-invalid ::slotted(label),
      .input-content.is-invalid ::slotted(.paper-input-label) {
        color: var(--paper-input-container-invalid-color, var(--error-color));
      }

      .input-content.label-is-hidden ::slotted(label),
      .input-content.label-is-hidden ::slotted(.paper-input-label) {
        visibility: hidden;
      }

      .input-content ::slotted(iron-input) {
        @apply --paper-input-container-shared-input-style;
      }
      
      .input-content ::slotted(input),
      .input-content ::slotted(textarea),
      .input-content ::slotted(iron-autogrow-textarea),
      .input-content ::slotted(.paper-input-input) {
        @apply --paper-input-container-shared-input-style;
        @apply --paper-input-container-input;
      }

      .input-content ::slotted(input)::-webkit-outer-spin-button,
      .input-content ::slotted(input)::-webkit-inner-spin-button {
        @apply --paper-input-container-input-webkit-spinner;
      }
      
      .input-content.focused ::slotted(input),
      .input-content.focused ::slotted(textarea),
      .input-content.focused ::slotted(iron-autogrow-textarea),
      .input-content.focused ::slotted(.paper-input-input) {
        @apply --paper-input-container-input-focus;
      }

      .input-content.is-invalid ::slotted(input),
      .input-content.is-invalid ::slotted(textarea),
      .input-content.is-invalid ::slotted(iron-autogrow-textarea),
      .input-content.is-invalid ::slotted(.paper-input-input) {
        @apply --paper-input-container-input-invalid;
      }
      
      .prefix ::slotted(*) {
        display: inline-block;
        @apply --paper-font-subhead;
        @apply --layout-flex-none;
        @apply --paper-input-prefix;
      }

      .suffix ::slotted(*) {
        display: inline-block;
        @apply --paper-font-subhead;
        @apply --layout-flex-none;

        @apply --paper-input-suffix;
      }

      /* Firefox sets a min-width on the input, which can cause layout issues */
      .input-content ::slotted(input) {
        min-width: 0;
      }

      .input-content ::slotted(textarea) {
        resize: none;
      }

      .add-on-content {
        position: relative;
      }

      .add-on-content.is-invalid ::slotted(*) {
        color: var(--paper-input-container-invalid-color, var(--error-color));
      }

      .add-on-content.is-highlighted ::slotted(*) {
        color: var(--paper-input-container-focus-color, var(--primary-color));
      }
    </style>

    <div class="floated-label-placeholder" aria-hidden="true" hidden="[[noLabelFloat]]">&nbsp;</div>

    <div class="input-wrapper">
      <span class="prefix"><slot name="prefix"></slot></span>

      <div class\$="[[_computeInputContentClass(noLabelFloat,alwaysFloatLabel,focused,invalid,_inputHasContent)]]" id="labelAndInputContainer">
        <slot name="label"></slot>
        <slot name="input"></slot>
      </div>

      <span class="suffix"><slot name="suffix"></slot></span>
    </div>

    <div class\$="[[_computeUnderlineClass(focused,invalid)]]">
      <div class="unfocused-line"></div>
      <div class="focused-line"></div>
    </div>

    <div class\$="[[_computeAddOnContentClass(focused,invalid)]]">
      <slot name="add-on"></slot>
    </div>
`,

  is: 'paper-input-container',

  properties: {
    /**
     * Set to true to disable the floating label. The label disappears when the input value is
     * not null.
     */
    noLabelFloat: {
      type: Boolean,
      value: false
    },

    /**
     * Set to true to always float the floating label.
     */
    alwaysFloatLabel: {
      type: Boolean,
      value: false
    },

    /**
     * The attribute to listen for value changes on.
     */
    attrForValue: {
      type: String,
      value: 'bind-value'
    },

    /**
     * Set to true to auto-validate the input value when it changes.
     */
    autoValidate: {
      type: Boolean,
      value: false
    },

    /**
     * True if the input is invalid. This property is set automatically when the input value
     * changes if auto-validating, or when the `iron-input-validate` event is heard from a child.
     */
    invalid: {
      observer: '_invalidChanged',
      type: Boolean,
      value: false
    },

    /**
     * True if the input has focus.
     */
    focused: {
      readOnly: true,
      type: Boolean,
      value: false,
      notify: true
    },

    _addons: {
      type: Array
      // do not set a default value here intentionally - it will be initialized lazily when a
      // distributed child is attached, which may occur before configuration for this element
      // in polyfill.
    },

    _inputHasContent: {
      type: Boolean,
      value: false
    },

    _inputSelector: {
      type: String,
      value: 'input,iron-input,textarea,.paper-input-input'
    },

    _boundOnFocus: {
      type: Function,
      value: function() {
        return this._onFocus.bind(this);
      }
    },

    _boundOnBlur: {
      type: Function,
      value: function() {
        return this._onBlur.bind(this);
      }
    },

    _boundOnInput: {
      type: Function,
      value: function() {
        return this._onInput.bind(this);
      }
    },

    _boundValueChanged: {
      type: Function,
      value: function() {
        return this._onValueChanged.bind(this);
      }
    }
  },

  listeners: {
    'addon-attached': '_onAddonAttached',
    'iron-input-validate': '_onIronInputValidate'
  },

  get _valueChangedEvent() {
    return this.attrForValue + '-changed';
  },

  get _propertyForValue() {
    return Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_utils_case_map_js__["dashToCamelCase"])(this.attrForValue);
  },

  get _inputElement() {
    return Object(__WEBPACK_IMPORTED_MODULE_6__polymer_lib_legacy_polymer_dom_js__["a" /* dom */])(this).querySelector(this._inputSelector);
  },

  get _inputElementValue() {
    return this._inputElement[this._propertyForValue] || this._inputElement.value;
  },

  ready: function() {
    if (!this._addons) {
      this._addons = [];
    }
    this.addEventListener('focus', this._boundOnFocus, true);
    this.addEventListener('blur', this._boundOnBlur, true);
  },

  attached: function() {
    if (this.attrForValue) {
      this._inputElement.addEventListener(this._valueChangedEvent, this._boundValueChanged);
    } else {
      this.addEventListener('input', this._onInput);
    }

    // Only validate when attached if the input already has a value.
    if (this._inputElementValue && this._inputElementValue != '') {
      this._handleValueAndAutoValidate(this._inputElement);
    } else {
      this._handleValue(this._inputElement);
    }
  },

  _onAddonAttached: function(event) {
    if (!this._addons) {
      this._addons = [];
    }
    var target = event.target;
    if (this._addons.indexOf(target) === -1) {
      this._addons.push(target);
      if (this.isAttached) {
        this._handleValue(this._inputElement);
      }
    }
  },

  _onFocus: function() {
    this._setFocused(true);
  },

  _onBlur: function() {
    this._setFocused(false);
    this._handleValueAndAutoValidate(this._inputElement);
  },

  _onInput: function(event) {
    this._handleValueAndAutoValidate(event.target);
  },

  _onValueChanged: function(event) {
    var input = event.target;

    // Problem: if the input is required but has no text entered, we should
    // only validate it on blur (so that an empty form doesn't come up red
    // immediately; however, in this handler, we don't know whether this is
    // the booting up value or a value in the future. I am assuming that the
    // case  we care about manifests itself when the value is undefined.
    // If this causes future problems, we need to do something like track whether
    // the iron-input-ready event has fired, and this handler came before that.

    if (input.value === undefined) {
      return;
    }

    this._handleValueAndAutoValidate(event.target);
  },

  _handleValue: function(inputElement) {
    var value = this._inputElementValue;

    // type="number" hack needed because this.value is empty until it's valid
    if (value || value === 0 || (inputElement.type === 'number' && !inputElement.checkValidity())) {
      this._inputHasContent = true;
    } else {
      this._inputHasContent = false;
    }

    this.updateAddons({
      inputElement: inputElement,
      value: value,
      invalid: this.invalid
    });
  },

  _handleValueAndAutoValidate: function(inputElement) {
    if (this.autoValidate && inputElement) {
      var valid;

      if (inputElement.validate) {
        valid = inputElement.validate(this._inputElementValue);
      } else {
        valid = inputElement.checkValidity();
      }
      this.invalid = !valid;
    }

    // Call this last to notify the add-ons.
    this._handleValue(inputElement);
  },

  _onIronInputValidate: function(event) {
    this.invalid = this._inputElement.invalid;
  },

  _invalidChanged: function() {
    if (this._addons) {
      this.updateAddons({invalid: this.invalid});
    }
  },

  /**
   * Call this to update the state of add-ons.
   * @param {Object} state Add-on state.
   */
  updateAddons: function(state) {
    for (var addon, index = 0; addon = this._addons[index]; index++) {
      addon.update(state);
    }
  },

  _computeInputContentClass: function(noLabelFloat, alwaysFloatLabel, focused, invalid, _inputHasContent) {
    var cls = 'input-content';
    if (!noLabelFloat) {
      var label = this.querySelector('label');

      if (alwaysFloatLabel || _inputHasContent) {
        cls += ' label-is-floating';
        // If the label is floating, ignore any offsets that may have been
        // applied from a prefix element.
        this.$.labelAndInputContainer.style.position = 'static';

        if (invalid) {
          cls += ' is-invalid';
        } else if (focused) {
          cls += " label-is-highlighted";
        }
      } else {
        // When the label is not floating, it should overlap the input element.
        if (label) {
          this.$.labelAndInputContainer.style.position = 'relative';
        }
        if (invalid) {
          cls += ' is-invalid';
        }
      }
    } else {
      if (_inputHasContent) {
        cls += ' label-is-hidden';
      }
      if (invalid) {
        cls += ' is-invalid';
      }
    }
    if (focused) {
      cls += ' focused';
    }
    return cls;
  },

  _computeUnderlineClass: function(focused, invalid) {
    var cls = 'underline';
    if (invalid) {
      cls += ' is-invalid';
    } else if (focused) {
      cls += ' is-highlighted'
    }
    return cls;
  },

  _computeAddOnContentClass: function(focused, invalid) {
    var cls = 'add-on-content';
    if (invalid) {
      cls += ' is-invalid';
    } else if (focused) {
      cls += ' is-highlighted'
    }
    return cls;
  }
});


/***/ }),
/* 94 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_typography_js__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_input_addon_behavior_js__ = __webpack_require__(47);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);





Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  _template: `
    <style>
      :host {
        display: inline-block;
        visibility: hidden;

        color: var(--paper-input-container-invalid-color, var(--error-color));

        @apply --paper-font-caption;
        @apply --paper-input-error;
        position: absolute;
        left:0;
        right:0;
      }

      :host([invalid]) {
        visibility: visible;
      };
    </style>

    <slot></slot>
`,

  is: 'paper-input-error',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_3__paper_input_addon_behavior_js__["a" /* PaperInputAddonBehavior */]
  ],

  properties: {
    /**
     * True if the error is showing.
     */
    invalid: {
      readOnly: true,
      reflectToAttribute: true,
      type: Boolean
    }
  },

  /**
   * This overrides the update function in PaperInputAddonBehavior.
   * @param {{
   *   inputElement: (Element|undefined),
   *   value: (string|undefined),
   *   invalid: boolean
   * }} state -
   *     inputElement: The input element.
   *     value: The input value.
   *     invalid: True if the input value is invalid.
   */
  update: function(state) {
    this._setInvalid(state.invalid);
  }
});


/***/ }),
/* 95 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_checked_element_behavior_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__polymer_lib_utils_render_status_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__paper_behaviors_paper_inky_focus_behavior_js__ = __webpack_require__(49);






const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-checkbox">
  <template strip-whitespace="">
    <style>
      :host {
        display: inline-block;
        white-space: nowrap;
        cursor: pointer;
        --calculated-paper-checkbox-size: var(--paper-checkbox-size, 18px);
        /* -1px is a sentinel for the default and is replaced in \`attached\`. */
        --calculated-paper-checkbox-ink-size: var(--paper-checkbox-ink-size, -1px);
        @apply --paper-font-common-base;
        line-height: 0;
        -webkit-tap-highlight-color: transparent;
      }

      :host([hidden]) {
        display: none !important;
      }

      :host(:focus) {
        outline: none;
      }

      .hidden {
        display: none;
      }

      #checkboxContainer {
        display: inline-block;
        position: relative;
        width: var(--calculated-paper-checkbox-size);
        height: var(--calculated-paper-checkbox-size);
        min-width: var(--calculated-paper-checkbox-size);
        margin: var(--paper-checkbox-margin, initial);
        vertical-align: var(--paper-checkbox-vertical-align, middle);
        background-color: var(--paper-checkbox-unchecked-background-color, transparent);
      }

      #ink {
        position: absolute;

        /* Center the ripple in the checkbox by negative offsetting it by
         * (inkWidth - rippleWidth) / 2 */
        top: calc(0px - (var(--calculated-paper-checkbox-ink-size) - var(--calculated-paper-checkbox-size)) / 2);
        left: calc(0px - (var(--calculated-paper-checkbox-ink-size) - var(--calculated-paper-checkbox-size)) / 2);
        width: var(--calculated-paper-checkbox-ink-size);
        height: var(--calculated-paper-checkbox-ink-size);
        color: var(--paper-checkbox-unchecked-ink-color, var(--primary-text-color));
        opacity: 0.6;
        pointer-events: none;
      }

      :host-context([dir="rtl"]) #ink {
        right: calc(0px - (var(--calculated-paper-checkbox-ink-size) - var(--calculated-paper-checkbox-size)) / 2);
        left: auto;
      }

      #ink[checked] {
        color: var(--paper-checkbox-checked-ink-color, var(--primary-color));
      }

      #checkbox {
        position: relative;
        box-sizing: border-box;
        height: 100%;
        border: solid 2px;
        border-color: var(--paper-checkbox-unchecked-color, var(--primary-text-color));
        border-radius: 2px;
        pointer-events: none;
        -webkit-transition: background-color 140ms, border-color 140ms;
        transition: background-color 140ms, border-color 140ms;
      }

      /* checkbox checked animations */
      #checkbox.checked #checkmark {
        -webkit-animation: checkmark-expand 140ms ease-out forwards;
        animation: checkmark-expand 140ms ease-out forwards;
      }

      @-webkit-keyframes checkmark-expand {
        0% {
          -webkit-transform: scale(0, 0) rotate(45deg);
        }
        100% {
          -webkit-transform: scale(1, 1) rotate(45deg);
        }
      }

      @keyframes checkmark-expand {
        0% {
          transform: scale(0, 0) rotate(45deg);
        }
        100% {
          transform: scale(1, 1) rotate(45deg);
        }
      }

      #checkbox.checked {
        background-color: var(--paper-checkbox-checked-color, var(--primary-color));
        border-color: var(--paper-checkbox-checked-color, var(--primary-color));
      }

      #checkmark {
        position: absolute;
        width: 36%;
        height: 70%;
        border-style: solid;
        border-top: none;
        border-left: none;
        border-right-width: calc(2/15 * var(--calculated-paper-checkbox-size));
        border-bottom-width: calc(2/15 * var(--calculated-paper-checkbox-size));
        border-color: var(--paper-checkbox-checkmark-color, white);
        -webkit-transform-origin: 97% 86%;
        transform-origin: 97% 86%;
        box-sizing: content-box; /* protect against page-level box-sizing */
      }

      :host-context([dir="rtl"]) #checkmark {
        -webkit-transform-origin: 50% 14%;
        transform-origin: 50% 14%;
      }

      /* label */
      #checkboxLabel {
        position: relative;
        display: inline-block;
        vertical-align: middle;
        padding-left: var(--paper-checkbox-label-spacing, 8px);
        white-space: normal;
        line-height: normal;
        color: var(--paper-checkbox-label-color, var(--primary-text-color));
        @apply --paper-checkbox-label;
      }

      :host([checked]) #checkboxLabel {
        color: var(--paper-checkbox-label-checked-color, var(--paper-checkbox-label-color, var(--primary-text-color)));
        @apply --paper-checkbox-label-checked;
      }

      :host-context([dir="rtl"]) #checkboxLabel {
        padding-right: var(--paper-checkbox-label-spacing, 8px);
        padding-left: 0;
      }

      #checkboxLabel[hidden] {
        display: none;
      }

      /* disabled state */

      :host([disabled]) #checkbox {
        opacity: 0.5;
        border-color: var(--paper-checkbox-unchecked-color, var(--primary-text-color));
      }

      :host([disabled][checked]) #checkbox {
        background-color: var(--paper-checkbox-unchecked-color, var(--primary-text-color));
        opacity: 0.5;
      }

      :host([disabled]) #checkboxLabel  {
        opacity: 0.65;
      }

      /* invalid state */
      #checkbox.invalid:not(.checked) {
        border-color: var(--paper-checkbox-error-color, var(--error-color));
      }
    </style>

    <div id="checkboxContainer">
      <div id="checkbox" class\$="[[_computeCheckboxClass(checked, invalid)]]">
        <div id="checkmark" class\$="[[_computeCheckmarkClass(checked)]]"></div>
      </div>
    </div>

    <div id="checkboxLabel"><slot></slot></div>
  </template>

  
</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_3__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-checkbox',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_2__paper_behaviors_paper_checked_element_behavior_js__["a" /* PaperCheckedElementBehavior */]
  ],

  hostAttributes: {
    role: 'checkbox',
    'aria-checked': false,
    tabindex: 0
  },

  properties: {
    /**
     * Fired when the checked state changes due to user interaction.
     *
     * @event change
     */

    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */
    ariaActiveAttribute: {
      type: String,
      value: 'aria-checked'
    }
  },

  attached: function() {
    // Wait until styles have resolved to check for the default sentinel.
    // See polymer#4009 for more details.
    Object(__WEBPACK_IMPORTED_MODULE_4__polymer_lib_utils_render_status_js__["a" /* afterNextRender */])(this, function() {
      var inkSize = this.getComputedStyleValue('--calculated-paper-checkbox-ink-size').trim();
      // If unset, compute and set the default `--paper-checkbox-ink-size`.
      if (inkSize === '-1px') {
        var checkboxSizeText = this.getComputedStyleValue('--calculated-paper-checkbox-size').trim();

        var units = checkboxSizeText.match(/[A-Za-z]+$/)[0] || 'px';
        var checkboxSize = parseFloat(checkboxSizeText, 10);
        var defaultInkSize = (8 / 3) * checkboxSize;

        if (units === 'px') {
          defaultInkSize = Math.floor(defaultInkSize);

          // The checkbox and ripple need to have the same parity so that their
          // centers align.
          if (defaultInkSize % 2 !== checkboxSize % 2) {
            defaultInkSize++;
          }
        }

        this.updateStyles({
          '--paper-checkbox-ink-size': defaultInkSize + units,
        });
      }
    });
  },

  _computeCheckboxClass: function(checked, invalid) {
    var className = '';
    if (checked) {
      className += 'checked ';
    }
    if (invalid) {
      className += 'invalid';
    }
    return className;
  },

  _computeCheckmarkClass: function(checked) {
    return checked ? '' : 'hidden';
  },

  // create ripple inside the checkboxContainer
  _createRipple: function() {
    this._rippleContainer = this.$.checkboxContainer;
    return __WEBPACK_IMPORTED_MODULE_5__paper_behaviors_paper_inky_focus_behavior_js__["b" /* PaperInkyFocusBehaviorImpl */]._createRipple.call(this);
  }

});


/***/ }),
/* 96 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_validatable_behavior_iron_validatable_behavior_js__ = __webpack_require__(46);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__iron_form_element_behavior_iron_form_element_behavior_js__ = __webpack_require__(45);




const IronCheckedElementBehaviorImpl = {

  properties: {
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */

    /**
     * Gets or sets the state, `true` is checked and `false` is unchecked.
     */
    checked: {
      type: Boolean,
      value: false,
      reflectToAttribute: true,
      notify: true,
      observer: '_checkedChanged'
    },

    /**
     * If true, the button toggles the active state with each tap or press
     * of the spacebar.
     */
    toggles: {
      type: Boolean,
      value: true,
      reflectToAttribute: true
    },

    /* Overriden from Polymer.IronFormElementBehavior */
    value: {
      type: String,
      value: 'on',
      observer: '_valueChanged'
    }
  },

  observers: [
    '_requiredChanged(required)'
  ],

  created: function() {
    // Used by `iron-form` to handle the case that an element with this behavior
    // doesn't have a role of 'checkbox' or 'radio', but should still only be
    // included when the form is serialized if `this.checked === true`.
    this._hasIronCheckedElementBehavior = true;
  },

  /**
   * Returns false if the element is required and not checked, and true otherwise.
   * @param {*=} _value Ignored.
   * @return {boolean} true if `required` is false or if `checked` is true.
   */
  _getValidity: function(_value) {
    return this.disabled || !this.required || this.checked;
  },

  /**
   * Update the aria-required label when `required` is changed.
   */
  _requiredChanged: function() {
    if (this.required) {
      this.setAttribute('aria-required', 'true');
    } else {
      this.removeAttribute('aria-required');
    }
  },

  /**
   * Fire `iron-changed` when the checked state changes.
   */
  _checkedChanged: function() {
    this.active = this.checked;
    this.fire('iron-change');
  },

  /**
   * Reset value to 'on' if it is set to `undefined`.
   */
  _valueChanged: function() {
    if (this.value === undefined || this.value === null) {
      this.value = 'on';
    }
  }
};
/* harmony export (immutable) */ __webpack_exports__["b"] = IronCheckedElementBehaviorImpl;


const IronCheckedElementBehavior = [
  __WEBPACK_IMPORTED_MODULE_2__iron_form_element_behavior_iron_form_element_behavior_js__["a" /* IronFormElementBehavior */],
  __WEBPACK_IMPORTED_MODULE_1__iron_validatable_behavior_iron_validatable_behavior_js__["a" /* IronValidatableBehavior */],
  IronCheckedElementBehaviorImpl
];
/* harmony export (immutable) */ __webpack_exports__["a"] = IronCheckedElementBehavior;



/***/ }),
/* 97 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__iron_flex_layout_iron_flex_layout_js__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__paper_styles_color_js__ = __webpack_require__(43);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__paper_styles_default_theme_js__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__paper_behaviors_paper_checked_element_behavior_js__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_fn_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__polymer_lib_utils_render_status_js__ = __webpack_require__(27);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__polymer_lib_utils_gestures_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__paper_behaviors_paper_ripple_behavior_js__ = __webpack_require__(19);









const $_documentContainer = document.createElement('div');
$_documentContainer.setAttribute('style', 'display: none;');

$_documentContainer.innerHTML = `<dom-module id="paper-toggle-button">
  <template strip-whitespace="">

    <style>
      :host {
        display: inline-block;
        @apply --layout-horizontal;
        @apply --layout-center;
        @apply --paper-font-common-base;
      }

      :host([disabled]) {
        pointer-events: none;
      }

      :host(:focus) {
        outline:none;
      }

      .toggle-bar {
        position: absolute;
        height: 100%;
        width: 100%;
        border-radius: 8px;
        pointer-events: none;
        opacity: 0.4;
        transition: background-color linear .08s;
        background-color: var(--paper-toggle-button-unchecked-bar-color, #000000);

        @apply --paper-toggle-button-unchecked-bar;
      }

      .toggle-button {
        position: absolute;
        top: -3px;
        left: 0;
        height: 20px;
        width: 20px;
        border-radius: 50%;
        box-shadow: 0 1px 5px 0 rgba(0, 0, 0, 0.6);
        transition: -webkit-transform linear .08s, background-color linear .08s;
        transition: transform linear .08s, background-color linear .08s;
        will-change: transform;
        background-color: var(--paper-toggle-button-unchecked-button-color, var(--paper-grey-50));

        @apply --paper-toggle-button-unchecked-button;
      }

      .toggle-button.dragging {
        -webkit-transition: none;
        transition: none;
      }

      :host([checked]:not([disabled])) .toggle-bar {
        opacity: 0.5;
        background-color: var(--paper-toggle-button-checked-bar-color, var(--primary-color));

        @apply --paper-toggle-button-checked-bar;
      }

      :host([disabled]) .toggle-bar {
        background-color: #000;
        opacity: 0.12;
      }

      :host([checked]) .toggle-button {
        -webkit-transform: translate(16px, 0);
        transform: translate(16px, 0);
      }

      :host([checked]:not([disabled])) .toggle-button {
        background-color: var(--paper-toggle-button-checked-button-color, var(--primary-color));

        @apply --paper-toggle-button-checked-button;
      }

      :host([disabled]) .toggle-button {
        background-color: #bdbdbd;
        opacity: 1;
      }

      .toggle-ink {
        position: absolute;
        top: -14px;
        left: -14px;
        right: auto;
        bottom: auto;
        width: 48px;
        height: 48px;
        opacity: 0.5;
        pointer-events: none;
        color: var(--paper-toggle-button-unchecked-ink-color, var(--primary-text-color));

        @apply --paper-toggle-button-unchecked-ink;
      }

      :host([checked]) .toggle-ink {
        color: var(--paper-toggle-button-checked-ink-color, var(--primary-color));

        @apply --paper-toggle-button-checked-ink;
      }

      .toggle-container {
        display: inline-block;
        position: relative;
        width: 36px;
        height: 14px;
        /* The toggle button has an absolute position of -3px; The extra 1px
        /* accounts for the toggle button shadow box. */
        margin: 4px 1px;
      }

      .toggle-label {
        position: relative;
        display: inline-block;
        vertical-align: middle;
        padding-left: var(--paper-toggle-button-label-spacing, 8px);
        pointer-events: none;
        color: var(--paper-toggle-button-label-color, var(--primary-text-color));
      }

      /* invalid state */
      :host([invalid]) .toggle-bar {
        background-color: var(--paper-toggle-button-invalid-bar-color, var(--error-color));
      }

      :host([invalid]) .toggle-button {
        background-color: var(--paper-toggle-button-invalid-button-color, var(--error-color));
      }

      :host([invalid]) .toggle-ink {
        color: var(--paper-toggle-button-invalid-ink-color, var(--error-color));
      }
    </style>

    <div class="toggle-container">
      <div id="toggleBar" class="toggle-bar"></div>
      <div id="toggleButton" class="toggle-button"></div>
    </div>

    <div class="toggle-label"><slot></slot></div>

  </template>

  
</dom-module>`;

document.head.appendChild($_documentContainer);
Object(__WEBPACK_IMPORTED_MODULE_5__polymer_lib_legacy_polymer_fn_js__["a" /* Polymer */])({
  is: 'paper-toggle-button',

  behaviors: [
    __WEBPACK_IMPORTED_MODULE_4__paper_behaviors_paper_checked_element_behavior_js__["a" /* PaperCheckedElementBehavior */]
  ],

  hostAttributes: {
    role: 'button',
    'aria-pressed': 'false',
    tabindex: 0
  },

  properties: {
    /**
     * Fired when the checked state changes due to user interaction.
     *
     * @event change
     */
    /**
     * Fired when the checked state changes.
     *
     * @event iron-change
     */
  },

  listeners: {
    track: '_ontrack'
  },

  attached: function() {
    Object(__WEBPACK_IMPORTED_MODULE_6__polymer_lib_utils_render_status_js__["a" /* afterNextRender */])(this, function() {
      Object(__WEBPACK_IMPORTED_MODULE_7__polymer_lib_utils_gestures_js__["setTouchAction"])(this, 'pan-y');
    });
  },

  _ontrack: function(event) {
    var track = event.detail;
    if (track.state === 'start') {
      this._trackStart(track);
    } else if (track.state === 'track') {
      this._trackMove(track);
    } else if (track.state === 'end') {
      this._trackEnd(track);
    }
  },

  _trackStart: function(track) {
    this._width = this.$.toggleBar.offsetWidth / 2;
    /*
     * keep an track-only check state to keep the dragging behavior smooth
     * while toggling activations
     */
    this._trackChecked = this.checked;
    this.$.toggleButton.classList.add('dragging');
  },

  _trackMove: function(track) {
    var dx = track.dx;
    this._x = Math.min(this._width,
        Math.max(0, this._trackChecked ? this._width + dx : dx));
    this.translate3d(this._x + 'px', 0, 0, this.$.toggleButton);
    this._userActivate(this._x > (this._width / 2));
  },

  _trackEnd: function(track) {
    this.$.toggleButton.classList.remove('dragging');
    this.transform('', this.$.toggleButton);
  },

  // customize the element's ripple
  _createRipple: function() {
    this._rippleContainer = this.$.toggleButton;
    var ripple = __WEBPACK_IMPORTED_MODULE_8__paper_behaviors_paper_ripple_behavior_js__["a" /* PaperRippleBehavior */]._createRipple();
    ripple.id = 'ink';
    ripple.setAttribute('recenters', '');
    ripple.classList.add('circle', 'toggle-ink');
    return ripple;
  }

});


/***/ }),
/* 98 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js__ = __webpack_require__(99);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__webcomponents_webcomponentsjs_webcomponents_lite_js__);


var getBreakpoint = function () {
  return window.getComputedStyle(window.document.querySelector('body'), ':before').getPropertyValue('content').replace(/"/g, '');
};

function breakpoint(breakpoint, callback) {
  if (typeof callback === "function") {
    if (getBreakpoint() === breakpoint) {
      callback();
    }

    $(window).resize(function () {
      if (getBreakpoint() === breakpoint) {
        callback();
      }
    });
  } else {
    return getBreakpoint() === breakpoint;
  }
}

function desktop(callback) {
  return breakpoint("desktop", callback);
}

function tablet(callback) {
  return breakpoint("tablet", callback);
}

function phone(callback) {
  return breakpoint("phone", callback);
}

/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function(){/*

 Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
'use strict';var p,q="undefined"!=typeof window&&window===this?this:"undefined"!=typeof global&&null!=global?global:this,ba="function"==typeof Object.defineProperties?Object.defineProperty:function(a,b,c){a!=Array.prototype&&a!=Object.prototype&&(a[b]=c.value)};function ca(){ca=function(){};q.Symbol||(q.Symbol=da)}var da=function(){var a=0;return function(b){return"jscomp_symbol_"+(b||"")+a++}}();
function ea(){ca();var a=q.Symbol.iterator;a||(a=q.Symbol.iterator=q.Symbol("iterator"));"function"!=typeof Array.prototype[a]&&ba(Array.prototype,a,{configurable:!0,writable:!0,value:function(){return fa(this)}});ea=function(){}}function fa(a){var b=0;return ha(function(){return b<a.length?{done:!1,value:a[b++]}:{done:!0}})}function ha(a){ea();a={next:a};a[q.Symbol.iterator]=function(){return this};return a}function ia(a){ea();var b=a[Symbol.iterator];return b?b.call(a):fa(a)}
function ja(a){for(var b,c=[];!(b=a.next()).done;)c.push(b.value);return c}
(function(){if(!function(){var a=document.createEvent("Event");a.initEvent("foo",!0,!0);a.preventDefault();return a.defaultPrevented}()){var a=Event.prototype.preventDefault;Event.prototype.preventDefault=function(){this.cancelable&&(a.call(this),Object.defineProperty(this,"defaultPrevented",{get:function(){return!0},configurable:!0}))}}var b=/Trident/.test(navigator.userAgent);if(!window.CustomEvent||b&&"function"!==typeof window.CustomEvent)window.CustomEvent=function(a,b){b=b||{};var c=document.createEvent("CustomEvent");
c.initCustomEvent(a,!!b.bubbles,!!b.cancelable,b.detail);return c},window.CustomEvent.prototype=window.Event.prototype;if(!window.Event||b&&"function"!==typeof window.Event){var c=window.Event;window.Event=function(a,b){b=b||{};var c=document.createEvent("Event");c.initEvent(a,!!b.bubbles,!!b.cancelable);return c};if(c)for(var d in c)window.Event[d]=c[d];window.Event.prototype=c.prototype}if(!window.MouseEvent||b&&"function"!==typeof window.MouseEvent){b=window.MouseEvent;window.MouseEvent=function(a,
b){b=b||{};var c=document.createEvent("MouseEvent");c.initMouseEvent(a,!!b.bubbles,!!b.cancelable,b.view||window,b.detail,b.screenX,b.screenY,b.clientX,b.clientY,b.ctrlKey,b.altKey,b.shiftKey,b.metaKey,b.button,b.relatedTarget);return c};if(b)for(d in b)window.MouseEvent[d]=b[d];window.MouseEvent.prototype=b.prototype}Array.from||(Array.from=function(a){return[].slice.call(a)});Object.assign||(Object.assign=function(a,b){for(var c=[].slice.call(arguments,1),d=0,e;d<c.length;d++)if(e=c[d])for(var f=
a,m=e,n=Object.getOwnPropertyNames(m),w=0;w<n.length;w++)e=n[w],f[e]=m[e];return a})})(window.WebComponents);(function(){function a(){}function b(a,b){switch(a.nodeType){case Node.DOCUMENT_NODE:return w.call(a,b);case Node.DOCUMENT_FRAGMENT_NODE:return I.call(a,b);default:return n.call(a,b)}}var c="undefined"===typeof HTMLTemplateElement,d=!(document.createDocumentFragment().cloneNode()instanceof DocumentFragment),e=!1;/Trident/.test(navigator.userAgent)&&function(){function a(a,b){if(a instanceof DocumentFragment)for(var d;d=a.firstChild;)c.call(this,d,b);else c.call(this,a,b);return a}e=!0;var b=Node.prototype.cloneNode;
Node.prototype.cloneNode=function(a){a=b.call(this,a);this instanceof DocumentFragment&&(a.__proto__=DocumentFragment.prototype);return a};DocumentFragment.prototype.querySelectorAll=HTMLElement.prototype.querySelectorAll;DocumentFragment.prototype.querySelector=HTMLElement.prototype.querySelector;Object.defineProperties(DocumentFragment.prototype,{nodeType:{get:function(){return Node.DOCUMENT_FRAGMENT_NODE},configurable:!0},localName:{get:function(){},configurable:!0},nodeName:{get:function(){return"#document-fragment"},
configurable:!0}});var c=Node.prototype.insertBefore;Node.prototype.insertBefore=a;var d=Node.prototype.appendChild;Node.prototype.appendChild=function(b){b instanceof DocumentFragment?a.call(this,b,null):d.call(this,b);return b};var f=Node.prototype.removeChild,h=Node.prototype.replaceChild;Node.prototype.replaceChild=function(b,c){b instanceof DocumentFragment?(a.call(this,b,c),f.call(this,c)):h.call(this,b,c);return c};Document.prototype.createDocumentFragment=function(){var a=this.createElement("df");
a.__proto__=DocumentFragment.prototype;return a};var g=Document.prototype.importNode;Document.prototype.importNode=function(a,b){b=g.call(this,a,b||!1);a instanceof DocumentFragment&&(b.__proto__=DocumentFragment.prototype);return b}}();var f=Node.prototype.cloneNode,h=Document.prototype.createElement,g=Document.prototype.importNode,k=Node.prototype.removeChild,l=Node.prototype.appendChild,m=Node.prototype.replaceChild,n=Element.prototype.querySelectorAll,w=Document.prototype.querySelectorAll,I=DocumentFragment.prototype.querySelectorAll,
Za=function(){if(!c){var a=document.createElement("template"),b=document.createElement("template");b.content.appendChild(document.createElement("div"));a.content.appendChild(b);a=a.cloneNode(!0);return 0===a.content.childNodes.length||0===a.content.firstChild.content.childNodes.length||d}}();if(c){var t=document.implementation.createHTMLDocument("template"),na=!0,aa=document.createElement("style");aa.textContent="template{display:none;}";var T=document.head;T.insertBefore(aa,T.firstElementChild);
a.prototype=Object.create(HTMLElement.prototype);var U=!document.createElement("div").hasOwnProperty("innerHTML");a.D=function(b){if(!b.content){b.content=t.createDocumentFragment();for(var c;c=b.firstChild;)l.call(b.content,c);if(U)b.__proto__=a.prototype;else if(b.cloneNode=function(b){return a.a(this,b)},na)try{nc(b),oc(b)}catch(Ng){na=!1}a.J(b.content)}};var nc=function(b){Object.defineProperty(b,"innerHTML",{get:function(){for(var a="",b=this.content.firstChild;b;b=b.nextSibling)a+=b.outerHTML||
b.data.replace(Ge,pc);return a},set:function(b){t.body.innerHTML=b;for(a.J(t);this.content.firstChild;)k.call(this.content,this.content.firstChild);for(;t.body.firstChild;)l.call(this.content,t.body.firstChild)},configurable:!0})},oc=function(a){Object.defineProperty(a,"outerHTML",{get:function(){return"<template>"+this.innerHTML+"</template>"},set:function(a){if(this.parentNode){t.body.innerHTML=a;for(a=this.ownerDocument.createDocumentFragment();t.body.firstChild;)l.call(a,t.body.firstChild);m.call(this.parentNode,
a,this)}else throw Error("Failed to set the 'outerHTML' property on 'Element': This element has no parent node.");},configurable:!0})};nc(a.prototype);oc(a.prototype);a.J=function(c){c=b(c,"template");for(var d=0,e=c.length,f;d<e&&(f=c[d]);d++)a.D(f)};document.addEventListener("DOMContentLoaded",function(){a.J(document)});Document.prototype.createElement=function(){var b=h.apply(this,arguments);"template"===b.localName&&a.D(b);return b};var Ge=/[&\u00A0<>]/g,pc=function(a){switch(a){case "&":return"&amp;";
case "<":return"&lt;";case ">":return"&gt;";case "\u00a0":return"&nbsp;"}}}if(c||Za){a.a=function(a,b){var c=f.call(a,!1);this.D&&this.D(c);b&&(l.call(c.content,f.call(a.content,!0)),$a(c.content,a.content));return c};var $a=function(c,d){if(d.querySelectorAll&&(d=b(d,"template"),0!==d.length)){c=b(c,"template");for(var e=0,f=c.length,h,g;e<f;e++)g=d[e],h=c[e],a&&a.D&&a.D(g),m.call(h.parentNode,He.call(g,!0),h)}},He=Node.prototype.cloneNode=function(b){if(!e&&d&&this instanceof DocumentFragment)if(b)var c=
Ie.call(this.ownerDocument,this,!0);else return this.ownerDocument.createDocumentFragment();else this.nodeType===Node.ELEMENT_NODE&&"template"===this.localName?c=a.a(this,b):c=f.call(this,b);b&&$a(c,this);return c},Ie=Document.prototype.importNode=function(b,c){c=c||!1;if("template"===b.localName)return a.a(b,c);var d=g.call(this,b,c);c&&$a(d,b);return d}}c&&(window.HTMLTemplateElement=a)})();var ka;Array.isArray?ka=Array.isArray:ka=function(a){return"[object Array]"===Object.prototype.toString.call(a)};var la=ka;var ma=0,oa,pa="undefined"!==typeof window?window:void 0,qa=pa||{},ra=qa.MutationObserver||qa.WebKitMutationObserver,sa="undefined"!==typeof Uint8ClampedArray&&"undefined"!==typeof importScripts&&"undefined"!==typeof MessageChannel;function ta(){return"undefined"!==typeof oa?function(){oa(ua)}:va()}function wa(){var a=0,b=new ra(ua),c=document.createTextNode("");b.observe(c,{characterData:!0});return function(){c.data=a=++a%2}}
function xa(){var a=new MessageChannel;a.port1.onmessage=ua;return function(){return a.port2.postMessage(0)}}function va(){var a=setTimeout;return function(){return a(ua,1)}}var ya=Array(1E3);function ua(){for(var a=0;a<ma;a+=2)(0,ya[a])(ya[a+1]),ya[a]=void 0,ya[a+1]=void 0;ma=0}var za,Aa;
if("undefined"===typeof self&&"undefined"!==typeof process&&"[object process]"==={}.toString.call(process))Aa=function(){return process.jb(ua)};else{var Ba;if(ra)Ba=wa();else{var Ca;if(sa)Ca=xa();else{var Da;if(void 0===pa&&"function"==="function")try{var Ea=__webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"vertx\""); e.code = 'MODULE_NOT_FOUND'; throw e; }()));oa=Ea.lb||Ea.kb;Da=ta()}catch(a){Da=va()}else Da=va();Ca=Da}Ba=Ca}Aa=Ba}za=Aa;function Fa(a,b){ya[ma]=a;ya[ma+1]=b;ma+=2;2===ma&&za()};function Ga(a,b){var c=this,d=new this.constructor(Ha);void 0===d[Ia]&&Ja(d);var e=c.g;if(e){var f=arguments[e-1];Fa(function(){return Ka(e,d,f,c.f)})}else La(c,d,a,b);return d};function Ma(a){if(a&&"object"===typeof a&&a.constructor===this)return a;var b=new this(Ha);Na(b,a);return b};var Ia=Math.random().toString(36).substring(16);function Ha(){}var Pa=new Oa;function Qa(a){try{return a.then}catch(b){return Pa.error=b,Pa}}function Ra(a,b,c,d){try{a.call(b,c,d)}catch(e){return e}}function Sa(a,b,c){Fa(function(a){var d=!1,f=Ra(c,b,function(c){d||(d=!0,b!==c?Na(a,c):r(a,c))},function(b){d||(d=!0,u(a,b))});!d&&f&&(d=!0,u(a,f))},a)}function Ta(a,b){1===b.g?r(a,b.f):2===b.g?u(a,b.f):La(b,void 0,function(b){return Na(a,b)},function(b){return u(a,b)})}
function Ua(a,b,c){b.constructor===a.constructor&&c===Ga&&b.constructor.resolve===Ma?Ta(a,b):c===Pa?(u(a,Pa.error),Pa.error=null):void 0===c?r(a,b):"function"===typeof c?Sa(a,b,c):r(a,b)}function Na(a,b){if(a===b)u(a,new TypeError("You cannot resolve a promise with itself"));else{var c=typeof b;null===b||"object"!==c&&"function"!==c?r(a,b):Ua(a,b,Qa(b))}}function Va(a){a.pa&&a.pa(a.f);Wa(a)}function r(a,b){void 0===a.g&&(a.f=b,a.g=1,0!==a.I.length&&Fa(Wa,a))}
function u(a,b){void 0===a.g&&(a.g=2,a.f=b,Fa(Va,a))}function La(a,b,c,d){var e=a.I,f=e.length;a.pa=null;e[f]=b;e[f+1]=c;e[f+2]=d;0===f&&a.g&&Fa(Wa,a)}function Wa(a){var b=a.I,c=a.g;if(0!==b.length){for(var d,e,f=a.f,h=0;h<b.length;h+=3)d=b[h],e=b[h+c],d?Ka(c,d,e,f):e(f);a.I.length=0}}function Oa(){this.error=null}var Xa=new Oa;
function Ka(a,b,c,d){var e="function"===typeof c;if(e){try{var f=c(d)}catch(l){Xa.error=l,f=Xa}if(f===Xa){var h=!0;var g=f.error;f.error=null}else var k=!0;if(b===f){u(b,new TypeError("A promises callback cannot return that same promise."));return}}else f=d,k=!0;void 0===b.g&&(e&&k?Na(b,f):h?u(b,g):1===a?r(b,f):2===a&&u(b,f))}function Ya(a,b){try{b(function(b){Na(a,b)},function(b){u(a,b)})}catch(c){u(a,c)}}var ab=0;function Ja(a){a[Ia]=ab++;a.g=void 0;a.f=void 0;a.I=[]};function bb(a,b){this.Ga=a;this.A=new a(Ha);this.A[Ia]||Ja(this.A);if(la(b))if(this.S=this.length=b.length,this.f=Array(this.length),0===this.length)r(this.A,this.f);else{this.length=this.length||0;for(a=0;void 0===this.g&&a<b.length;a++)cb(this,b[a],a);0===this.S&&r(this.A,this.f)}else u(this.A,Error("Array Methods must be provided an Array"))}
function cb(a,b,c){var d=a.Ga,e=d.resolve;e===Ma?(e=Qa(b),e===Ga&&void 0!==b.g?db(a,b.g,c,b.f):"function"!==typeof e?(a.S--,a.f[c]=b):d===v?(d=new d(Ha),Ua(d,b,e),eb(a,d,c)):eb(a,new d(function(a){return a(b)}),c)):eb(a,e(b),c)}function db(a,b,c,d){var e=a.A;void 0===e.g&&(a.S--,2===b?u(e,d):a.f[c]=d);0===a.S&&r(e,a.f)}function eb(a,b,c){La(b,void 0,function(b){return db(a,1,c,b)},function(b){return db(a,2,c,b)})};function fb(a){return(new bb(this,a)).A};function gb(a){var b=this;return la(a)?new b(function(c,d){for(var e=a.length,f=0;f<e;f++)b.resolve(a[f]).then(c,d)}):new b(function(a,b){return b(new TypeError("You must pass an array to race."))})};function hb(a){var b=new this(Ha);u(b,a);return b};function v(a){this[Ia]=ab++;this.f=this.g=void 0;this.I=[];if(Ha!==a){if("function"!==typeof a)throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");if(this instanceof v)Ya(this,a);else throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");}}v.prototype={constructor:v,then:Ga,a:function(a){return this.then(null,a)}};/*

Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.Promise||(window.Promise=v,v.prototype["catch"]=v.prototype.a,v.prototype.then=v.prototype.then,v.all=fb,v.race=gb,v.resolve=Ma,v.reject=hb);(function(a){function b(a,b){if("function"===typeof window.CustomEvent)return new CustomEvent(a,b);var c=document.createEvent("CustomEvent");c.initCustomEvent(a,!!b.bubbles,!!b.cancelable,b.detail);return c}function c(a){if(m)return a.ownerDocument!==document?a.ownerDocument:null;var b=a.__importDoc;if(!b&&a.parentNode){b=a.parentNode;if("function"===typeof b.closest)b=b.closest("link[rel=import]");else for(;!g(b)&&(b=b.parentNode););a.__importDoc=b}return b}function d(a){var b=document.querySelectorAll("link[rel=import]:not([import-dependency])"),
c=b.length;c?l(b,function(b){return h(b,function(){0===--c&&a()})}):a()}function e(a){function b(){"loading"!==document.readyState&&document.body&&(document.removeEventListener("readystatechange",b),a())}document.addEventListener("readystatechange",b);b()}function f(a){e(function(){return d(function(){return a&&a()})})}function h(a,b){if(a.__loaded)b&&b();else if("script"===a.localName&&!a.src||"style"===a.localName&&!a.firstChild)a.__loaded=!0,b&&b();else{var c=function(d){a.removeEventListener(d.type,
c);a.__loaded=!0;b&&b()};a.addEventListener("load",c);aa&&"style"===a.localName||a.addEventListener("error",c)}}function g(a){return a.nodeType===Node.ELEMENT_NODE&&"link"===a.localName&&"import"===a.rel}function k(){var a=this;this.a={};this.b=0;this.h=new MutationObserver(function(b){return a.Qa(b)});this.h.observe(document.head,{childList:!0,subtree:!0});this.c(document)}function l(a,b,c){var d=a?a.length:0,e=c?-1:1;for(c=c?d-1:0;c<d&&0<=c;c+=e)b(a[c],c)}var m="import"in document.createElement("link"),
n=null;!1==="currentScript"in document&&Object.defineProperty(document,"currentScript",{get:function(){return n||("complete"!==document.readyState?document.scripts[document.scripts.length-1]:null)},configurable:!0});var w=/(url\()([^)]*)(\))/g,I=/(@import[\s]+(?!url\())([^;]*)(;)/g,Za=/(<link[^>]*)(rel=['|"]?stylesheet['|"]?[^>]*>)/g,t={Ka:function(a,b){a.href&&a.setAttribute("href",t.Y(a.getAttribute("href"),b));a.src&&a.setAttribute("src",t.Y(a.getAttribute("src"),b));if("style"===a.localName){var c=
t.ua(a.textContent,b,w);a.textContent=t.ua(c,b,I)}},ua:function(a,b,c){return a.replace(c,function(a,c,d,e){a=d.replace(/["']/g,"");b&&(a=t.Y(a,b));return c+"'"+a+"'"+e})},Y:function(a,b){if(void 0===t.ca){t.ca=!1;try{var c=new URL("b","http://a");c.pathname="c%20d";t.ca="http://a/c%20d"===c.href}catch(pc){}}if(t.ca)return(new URL(a,b)).href;c=t.Da;c||(c=document.implementation.createHTMLDocument("temp"),t.Da=c,c.ma=c.createElement("base"),c.head.appendChild(c.ma),c.la=c.createElement("a"));c.ma.href=
b;c.la.href=a;return c.la.href||a}},na={async:!0,load:function(a,b,c){if(a)if(a.match(/^data:/)){a=a.split(",");var d=a[1];d=-1<a[0].indexOf(";base64")?atob(d):decodeURIComponent(d);b(d)}else{var e=new XMLHttpRequest;e.open("GET",a,na.async);e.onload=function(){var a=e.responseURL||e.getResponseHeader("Location");a&&0===a.indexOf("/")&&(a=(location.origin||location.protocol+"//"+location.host)+a);var d=e.response||e.responseText;304===e.status||0===e.status||200<=e.status&&300>e.status?b(d,a):c(d)};
e.send()}else c("error: href must be specified")}},aa=/Trident/.test(navigator.userAgent)||/Edge\/\d./i.test(navigator.userAgent);k.prototype.c=function(a){var b=this;a=a.querySelectorAll("link[rel=import]");l(a,function(a){return b.L(a)})};k.prototype.L=function(a){var b=this,c=a.href;if(void 0!==this.a[c]){var d=this.a[c];d&&d.__loaded&&(a.import=d,this.o(a))}else this.b++,this.a[c]="pending",na.load(c,function(a,d){a=b.Ra(a,d||c);b.a[c]=a;b.b--;b.c(a);b.sa()},function(){b.a[c]=null;b.b--;b.sa()})};
k.prototype.Ra=function(a,b){if(!a)return document.createDocumentFragment();aa&&(a=a.replace(Za,function(a,b,c){return-1===a.indexOf("type=")?b+" type=import-disable "+c:a}));var c=document.createElement("template");c.innerHTML=a;if(c.content)a=c.content;else for(a=document.createDocumentFragment();c.firstChild;)a.appendChild(c.firstChild);if(c=a.querySelector("base"))b=t.Y(c.getAttribute("href"),b),c.removeAttribute("href");c=a.querySelectorAll('link[rel=import], link[rel=stylesheet][href][type=import-disable],\n    style:not([type]), link[rel=stylesheet][href]:not([type]),\n    script:not([type]), script[type="application/javascript"],\n    script[type="text/javascript"]');
var d=0;l(c,function(a){h(a);t.Ka(a,b);a.setAttribute("import-dependency","");"script"===a.localName&&!a.src&&a.textContent&&(a.setAttribute("src","data:text/javascript;charset=utf-8,"+encodeURIComponent(a.textContent+("\n//# sourceURL="+b+(d?"-"+d:"")+".js\n"))),a.textContent="",d++)});return a};k.prototype.sa=function(){var a=this;if(!this.b){this.h.disconnect();this.flatten(document);var b=!1,c=!1,d=function(){c&&b&&(a.c(document),a.b||(a.h.observe(document.head,{childList:!0,subtree:!0}),a.Pa()))};
this.Wa(function(){c=!0;d()});this.Sa(function(){b=!0;d()})}};k.prototype.flatten=function(a){var b=this;a=a.querySelectorAll("link[rel=import]");l(a,function(a){var c=b.a[a.href];(a.import=c)&&c.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&(b.a[a.href]=a,a.readyState="loading",a.import=a,b.flatten(c),a.appendChild(c))})};k.prototype.Sa=function(a){function b(e){if(e<d){var f=c[e],g=document.createElement("script");f.removeAttribute("import-dependency");l(f.attributes,function(a){return g.setAttribute(a.name,
a.value)});n=g;f.parentNode.replaceChild(g,f);h(g,function(){n=null;b(e+1)})}else a()}var c=document.querySelectorAll("script[import-dependency]"),d=c.length;b(0)};k.prototype.Wa=function(a){var b=document.querySelectorAll("style[import-dependency],\n    link[rel=stylesheet][import-dependency]"),d=b.length;if(d){var e=aa&&!!document.querySelector("link[rel=stylesheet][href][type=import-disable]");l(b,function(b){h(b,function(){b.removeAttribute("import-dependency");0===--d&&a()});if(e&&b.parentNode!==
document.head){var f=document.createElement(b.localName);f.__appliedElement=b;f.setAttribute("type","import-placeholder");b.parentNode.insertBefore(f,b.nextSibling);for(f=c(b);f&&c(f);)f=c(f);f.parentNode!==document.head&&(f=null);document.head.insertBefore(b,f);b.removeAttribute("type")}})}else a()};k.prototype.Pa=function(){var a=this,b=document.querySelectorAll("link[rel=import]");l(b,function(b){return a.o(b)},!0)};k.prototype.o=function(a){a.__loaded||(a.__loaded=!0,a.import&&(a.import.readyState=
"complete"),a.dispatchEvent(b(a.import?"load":"error",{bubbles:!1,cancelable:!1,detail:void 0})))};k.prototype.Qa=function(a){var b=this;l(a,function(a){return l(a.addedNodes,function(a){a&&a.nodeType===Node.ELEMENT_NODE&&(g(a)?b.L(a):b.c(a))})})};if(m){var T=document.querySelectorAll("link[rel=import]");l(T,function(a){a.import&&"loading"===a.import.readyState||(a.__loaded=!0)});T=function(a){a=a.target;g(a)&&(a.__loaded=!0)};document.addEventListener("load",T,!0);document.addEventListener("error",
T,!0)}else{var U=Object.getOwnPropertyDescriptor(Node.prototype,"baseURI");Object.defineProperty((!U||U.configurable?Node:Element).prototype,"baseURI",{get:function(){var a=g(this)?this:c(this);return a?a.href:U&&U.get?U.get.call(this):(document.querySelector("base")||window.location).href},configurable:!0,enumerable:!0});e(function(){return new k})}f(function(){return document.dispatchEvent(b("HTMLImportsLoaded",{cancelable:!0,bubbles:!0,detail:void 0}))});a.useNative=m;a.whenReady=f;a.importForElement=
c})(window.HTMLImports=window.HTMLImports||{});/*

 Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 Code distributed by Google as part of the polymer project is also
 subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.WebComponents=window.WebComponents||{flags:{}};var ib=document.querySelector('script[src*="webcomponents-lite.js"]'),jb=/wc-(.+)/,x={};if(!x.noOpts){location.search.slice(1).split("&").forEach(function(a){a=a.split("=");var b;a[0]&&(b=a[0].match(jb))&&(x[b[1]]=a[1]||!0)});if(ib)for(var kb=0,lb;lb=ib.attributes[kb];kb++)"src"!==lb.name&&(x[lb.name]=lb.value||!0);if(x.log&&x.log.split){var mb=x.log.split(",");x.log={};mb.forEach(function(a){x.log[a]=!0})}else x.log={}}
window.WebComponents.flags=x;var nb=x.shadydom;nb&&(window.ShadyDOM=window.ShadyDOM||{},window.ShadyDOM.force=nb);var ob=x.register||x.ce;ob&&window.customElements&&(window.customElements.forcePolyfill=ob);/*

Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
var y=window.ShadyDOM||{};y.Ma=!(!Element.prototype.attachShadow||!Node.prototype.getRootNode);var pb=Object.getOwnPropertyDescriptor(Node.prototype,"firstChild");y.M=!!(pb&&pb.configurable&&pb.get);y.ta=y.force||!y.Ma;function qb(a){return a.__shady&&void 0!==a.__shady.firstChild}function z(a){return"ShadyRoot"===a.Aa}function rb(a){a=a.getRootNode();if(z(a))return a}var sb=Element.prototype,tb=sb.matches||sb.matchesSelector||sb.mozMatchesSelector||sb.msMatchesSelector||sb.oMatchesSelector||sb.webkitMatchesSelector;
function ub(a,b){if(a&&b)for(var c=Object.getOwnPropertyNames(b),d=0,e;d<c.length&&(e=c[d]);d++){var f=Object.getOwnPropertyDescriptor(b,e);f&&Object.defineProperty(a,e,f)}}function vb(a,b){for(var c=[],d=1;d<arguments.length;++d)c[d-1]=arguments[d];for(d=0;d<c.length;d++)ub(a,c[d]);return a}function wb(a,b){for(var c in b)a[c]=b[c]}var xb=document.createTextNode(""),yb=0,zb=[];(new MutationObserver(function(){for(;zb.length;)try{zb.shift()()}catch(a){throw xb.textContent=yb++,a;}})).observe(xb,{characterData:!0});
function Ab(a){zb.push(a);xb.textContent=yb++}var Bb=!!document.contains;function Cb(a,b){for(;b;){if(b==a)return!0;b=b.parentNode}return!1};var Db=[],Eb;function Fb(a){Eb||(Eb=!0,Ab(Gb));Db.push(a)}function Gb(){Eb=!1;for(var a=!!Db.length;Db.length;)Db.shift()();return a}Gb.list=Db;function Hb(){this.a=!1;this.addedNodes=[];this.removedNodes=[];this.V=new Set}function Ib(a){a.a||(a.a=!0,Ab(function(){Jb(a)}))}function Jb(a){if(a.a){a.a=!1;var b=a.takeRecords();b.length&&a.V.forEach(function(a){a(b)})}}Hb.prototype.takeRecords=function(){if(this.addedNodes.length||this.removedNodes.length){var a=[{addedNodes:this.addedNodes,removedNodes:this.removedNodes}];this.addedNodes=[];this.removedNodes=[];return a}return[]};
function Kb(a,b){a.__shady=a.__shady||{};a.__shady.N||(a.__shady.N=new Hb);a.__shady.N.V.add(b);var c=a.__shady.N;return{Ea:b,C:c,Ha:a,takeRecords:function(){return c.takeRecords()}}}function Lb(a){var b=a&&a.C;b&&(b.V.delete(a.Ea),b.V.size||(a.Ha.__shady.N=null))}
function Mb(a,b){var c=b.getRootNode();return a.map(function(a){var b=c===a.target.getRootNode();if(b&&a.addedNodes){if(b=Array.from(a.addedNodes).filter(function(a){return c===a.getRootNode()}),b.length)return a=Object.create(a),Object.defineProperty(a,"addedNodes",{value:b,configurable:!0}),a}else if(b)return a}).filter(function(a){return a})};var A={},Nb=Element.prototype.insertBefore,Ob=Element.prototype.removeChild,Pb=Element.prototype.setAttribute,Qb=Element.prototype.removeAttribute,Rb=Element.prototype.cloneNode,Sb=Document.prototype.importNode,Tb=Element.prototype.addEventListener,Ub=Element.prototype.removeEventListener,Vb=Window.prototype.addEventListener,Wb=Window.prototype.removeEventListener,Xb=Element.prototype.dispatchEvent,Yb=Element.prototype.querySelector,Zb=Element.prototype.querySelectorAll,$b=Node.prototype.contains||
HTMLElement.prototype.contains;A.appendChild=Element.prototype.appendChild;A.insertBefore=Nb;A.removeChild=Ob;A.setAttribute=Pb;A.removeAttribute=Qb;A.cloneNode=Rb;A.importNode=Sb;A.addEventListener=Tb;A.removeEventListener=Ub;A.ab=Vb;A.bb=Wb;A.dispatchEvent=Xb;A.querySelector=Yb;A.querySelectorAll=Zb;A.contains=$b;var ac=/[&\u00A0"]/g,bc=/[&\u00A0<>]/g;function cc(a){switch(a){case "&":return"&amp;";case "<":return"&lt;";case ">":return"&gt;";case '"':return"&quot;";case "\u00a0":return"&nbsp;"}}function dc(a){for(var b={},c=0;c<a.length;c++)b[a[c]]=!0;return b}var ec=dc("area base br col command embed hr img input keygen link meta param source track wbr".split(" ")),fc=dc("style script xmp iframe noembed noframes plaintext noscript".split(" "));
function gc(a,b){"template"===a.localName&&(a=a.content);for(var c="",d=b?b(a):a.childNodes,e=0,f=d.length,h;e<f&&(h=d[e]);e++){a:{var g=h;var k=a;var l=b;switch(g.nodeType){case Node.ELEMENT_NODE:for(var m=g.localName,n="<"+m,w=g.attributes,I=0;k=w[I];I++)n+=" "+k.name+'="'+k.value.replace(ac,cc)+'"';n+=">";g=ec[m]?n:n+gc(g,l)+"</"+m+">";break a;case Node.TEXT_NODE:g=g.data;g=k&&fc[k.localName]?g:g.replace(bc,cc);break a;case Node.COMMENT_NODE:g="\x3c!--"+g.data+"--\x3e";break a;default:throw window.console.error(g),
Error("not implemented");}}c+=g}return c};var B={},C=document.createTreeWalker(document,NodeFilter.SHOW_ALL,null,!1),D=document.createTreeWalker(document,NodeFilter.SHOW_ELEMENT,null,!1);function hc(a){var b=[];C.currentNode=a;for(a=C.firstChild();a;)b.push(a),a=C.nextSibling();return b}B.parentNode=function(a){C.currentNode=a;return C.parentNode()};B.firstChild=function(a){C.currentNode=a;return C.firstChild()};B.lastChild=function(a){C.currentNode=a;return C.lastChild()};B.previousSibling=function(a){C.currentNode=a;return C.previousSibling()};
B.nextSibling=function(a){C.currentNode=a;return C.nextSibling()};B.childNodes=hc;B.parentElement=function(a){D.currentNode=a;return D.parentNode()};B.firstElementChild=function(a){D.currentNode=a;return D.firstChild()};B.lastElementChild=function(a){D.currentNode=a;return D.lastChild()};B.previousElementSibling=function(a){D.currentNode=a;return D.previousSibling()};B.nextElementSibling=function(a){D.currentNode=a;return D.nextSibling()};
B.children=function(a){var b=[];D.currentNode=a;for(a=D.firstChild();a;)b.push(a),a=D.nextSibling();return b};B.innerHTML=function(a){return gc(a,function(a){return hc(a)})};B.textContent=function(a){switch(a.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:a=document.createTreeWalker(a,NodeFilter.SHOW_TEXT,null,!1);for(var b="",c;c=a.nextNode();)b+=c.nodeValue;return b;default:return a.nodeValue}};var ic=Object.getOwnPropertyDescriptor(Element.prototype,"innerHTML")||Object.getOwnPropertyDescriptor(HTMLElement.prototype,"innerHTML"),jc=document.implementation.createHTMLDocument("inert"),kc=Object.getOwnPropertyDescriptor(Document.prototype,"activeElement"),lc={parentElement:{get:function(){var a=this.__shady&&this.__shady.parentNode;a&&a.nodeType!==Node.ELEMENT_NODE&&(a=null);return void 0!==a?a:B.parentElement(this)},configurable:!0},parentNode:{get:function(){var a=this.__shady&&this.__shady.parentNode;
return void 0!==a?a:B.parentNode(this)},configurable:!0},nextSibling:{get:function(){var a=this.__shady&&this.__shady.nextSibling;return void 0!==a?a:B.nextSibling(this)},configurable:!0},previousSibling:{get:function(){var a=this.__shady&&this.__shady.previousSibling;return void 0!==a?a:B.previousSibling(this)},configurable:!0},className:{get:function(){return this.getAttribute("class")||""},set:function(a){this.setAttribute("class",a)},configurable:!0},nextElementSibling:{get:function(){if(this.__shady&&
void 0!==this.__shady.nextSibling){for(var a=this.nextSibling;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.nextSibling;return a}return B.nextElementSibling(this)},configurable:!0},previousElementSibling:{get:function(){if(this.__shady&&void 0!==this.__shady.previousSibling){for(var a=this.previousSibling;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.previousSibling;return a}return B.previousElementSibling(this)},configurable:!0}},mc={childNodes:{get:function(){if(qb(this)){if(!this.__shady.childNodes){this.__shady.childNodes=
[];for(var a=this.firstChild;a;a=a.nextSibling)this.__shady.childNodes.push(a)}var b=this.__shady.childNodes}else b=B.childNodes(this);b.item=function(a){return b[a]};return b},configurable:!0},childElementCount:{get:function(){return this.children.length},configurable:!0},firstChild:{get:function(){var a=this.__shady&&this.__shady.firstChild;return void 0!==a?a:B.firstChild(this)},configurable:!0},lastChild:{get:function(){var a=this.__shady&&this.__shady.lastChild;return void 0!==a?a:B.lastChild(this)},
configurable:!0},textContent:{get:function(){if(qb(this)){for(var a=[],b=0,c=this.childNodes,d;d=c[b];b++)d.nodeType!==Node.COMMENT_NODE&&a.push(d.textContent);return a.join("")}return B.textContent(this)},set:function(a){switch(this.nodeType){case Node.ELEMENT_NODE:case Node.DOCUMENT_FRAGMENT_NODE:for(;this.firstChild;)this.removeChild(this.firstChild);(0<a.length||this.nodeType===Node.ELEMENT_NODE)&&this.appendChild(document.createTextNode(a));break;default:this.nodeValue=a}},configurable:!0},firstElementChild:{get:function(){if(this.__shady&&
void 0!==this.__shady.firstChild){for(var a=this.firstChild;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.nextSibling;return a}return B.firstElementChild(this)},configurable:!0},lastElementChild:{get:function(){if(this.__shady&&void 0!==this.__shady.lastChild){for(var a=this.lastChild;a&&a.nodeType!==Node.ELEMENT_NODE;)a=a.previousSibling;return a}return B.lastElementChild(this)},configurable:!0},children:{get:function(){var a;qb(this)?a=Array.prototype.filter.call(this.childNodes,function(a){return a.nodeType===
Node.ELEMENT_NODE}):a=B.children(this);a.item=function(b){return a[b]};return a},configurable:!0},innerHTML:{get:function(){var a="template"===this.localName?this.content:this;return qb(this)?gc(a):B.innerHTML(a)},set:function(a){for(var b="template"===this.localName?this.content:this;b.firstChild;)b.removeChild(b.firstChild);var c=this.localName;c&&"template"!==c||(c="div");c=jc.createElement(c);for(ic&&ic.set?ic.set.call(c,a):c.innerHTML=a;c.firstChild;)b.appendChild(c.firstChild)},configurable:!0}},
qc={shadowRoot:{get:function(){return this.__shady&&this.__shady.Ua||null},configurable:!0}},rc={activeElement:{get:function(){var a=kc&&kc.get?kc.get.call(document):y.M?void 0:document.activeElement;if(a&&a.nodeType){var b=!!z(this);if(this===document||b&&this.host!==a&&A.contains.call(this.host,a)){for(b=rb(a);b&&b!==this;)a=b.host,b=rb(a);a=this===document?b?null:a:b===this?a:null}else a=null}else a=null;return a},set:function(){},configurable:!0}};
function E(a,b,c){for(var d in b){var e=Object.getOwnPropertyDescriptor(a,d);e&&e.configurable||!e&&c?Object.defineProperty(a,d,b[d]):c&&console.warn("Could not define",d,"on",a)}}function F(a){E(a,lc);E(a,mc);E(a,rc)}var sc=y.M?function(){}:function(a){a.__shady&&a.__shady.Ba||(a.__shady=a.__shady||{},a.__shady.Ba=!0,E(a,lc,!0))},tc=y.M?function(){}:function(a){a.__shady&&a.__shady.za||(a.__shady=a.__shady||{},a.__shady.za=!0,E(a,mc,!0),E(a,qc,!0))};function uc(a,b,c){sc(a);c=c||null;a.__shady=a.__shady||{};b.__shady=b.__shady||{};c&&(c.__shady=c.__shady||{});a.__shady.previousSibling=c?c.__shady.previousSibling:b.lastChild;var d=a.__shady.previousSibling;d&&d.__shady&&(d.__shady.nextSibling=a);(d=a.__shady.nextSibling=c)&&d.__shady&&(d.__shady.previousSibling=a);a.__shady.parentNode=b;c?c===b.__shady.firstChild&&(b.__shady.firstChild=a):(b.__shady.lastChild=a,b.__shady.firstChild||(b.__shady.firstChild=a));b.__shady.childNodes=null}
function vc(a){if(!a.__shady||void 0===a.__shady.firstChild){a.__shady=a.__shady||{};a.__shady.firstChild=B.firstChild(a);a.__shady.lastChild=B.lastChild(a);tc(a);for(var b=a.__shady.childNodes=B.childNodes(a),c=0,d;c<b.length&&(d=b[c]);c++)d.__shady=d.__shady||{},d.__shady.parentNode=a,d.__shady.nextSibling=b[c+1]||null,d.__shady.previousSibling=b[c-1]||null,sc(d)}};function wc(a,b,c){if(b===a)throw Error("Failed to execute 'appendChild' on 'Node': The new child element contains the parent.");if(c){var d=c.__shady&&c.__shady.parentNode;if(void 0!==d&&d!==a||void 0===d&&B.parentNode(c)!==a)throw Error("Failed to execute 'insertBefore' on 'Node': The node before which the new node is to be inserted is not a child of this node.");}if(c===b)return b;b.parentNode&&xc(b.parentNode,b);d=rb(a);var e;if(e=d)a:{if(!b.__noInsertionPoint){var f;"slot"===b.localName?f=[b]:
b.querySelectorAll&&(f=b.querySelectorAll("slot"));if(f&&f.length){e=f;break a}}e=void 0}(f=e)&&d.H.push.apply(d.H,[].concat(f instanceof Array?f:ja(ia(f))));d&&("slot"===a.localName||f)&&yc(d);if(qb(a)){d=c;tc(a);a.__shady=a.__shady||{};void 0!==a.__shady.firstChild&&(a.__shady.childNodes=null);if(b.nodeType===Node.DOCUMENT_FRAGMENT_NODE){f=b.childNodes;for(e=0;e<f.length;e++)uc(f[e],a,d);b.__shady=b.__shady||{};d=void 0!==b.__shady.firstChild?null:void 0;b.__shady.firstChild=b.__shady.lastChild=
d;b.__shady.childNodes=d}else uc(b,a,d);if(zc(a)){yc(a.__shady.root);var h=!0}else a.__shady.root&&(h=!0)}h||(h=z(a)?a.host:a,c?(c=Ac(c),A.insertBefore.call(h,b,c)):A.appendChild.call(h,b));Bc(a,b);return b}
function xc(a,b){if(b.parentNode!==a)throw Error("The node to be removed is not a child of this node: "+b);var c=rb(b);if(qb(a)){b.__shady=b.__shady||{};a.__shady=a.__shady||{};b===a.__shady.firstChild&&(a.__shady.firstChild=b.__shady.nextSibling);b===a.__shady.lastChild&&(a.__shady.lastChild=b.__shady.previousSibling);var d=b.__shady.previousSibling,e=b.__shady.nextSibling;d&&(d.__shady=d.__shady||{},d.__shady.nextSibling=e);e&&(e.__shady=e.__shady||{},e.__shady.previousSibling=d);b.__shady.parentNode=
b.__shady.previousSibling=b.__shady.nextSibling=void 0;void 0!==a.__shady.childNodes&&(a.__shady.childNodes=null);if(zc(a)){yc(a.__shady.root);var f=!0}}Cc(b);if(c){(d=a&&"slot"===a.localName)&&(f=!0);Dc(c);e=c.l;for(var h in e)for(var g=e[h],k=0;k<g.length;k++){var l=g[k];if(Cb(b,l)){g.splice(k,1);var m=c.s.indexOf(l);0<=m&&c.s.splice(m,1);k--;if(m=l.__shady.K)for(l=0;l<m.length;l++){var n=m[l],w=B.parentNode(n);w&&A.removeChild.call(w,n)}m=!0}}(m||d)&&yc(c)}f||(f=z(a)?a.host:a,(!a.__shady.root&&
"slot"!==b.localName||f===B.parentNode(b))&&A.removeChild.call(f,b));Bc(a,null,b);return b}function Cc(a){if(a.__shady&&void 0!==a.__shady.ka)for(var b=a.childNodes,c=0,d=b.length,e;c<d&&(e=b[c]);c++)Cc(e);a.__shady&&(a.__shady.ka=void 0)}function Ac(a){var b=a;a&&"slot"===a.localName&&(b=(b=a.__shady&&a.__shady.K)&&b.length?b[0]:Ac(a.nextSibling));return b}function zc(a){return(a=a&&a.__shady&&a.__shady.root)&&Ec(a)}
function Fc(a,b){if("slot"===b)a=a.parentNode,zc(a)&&yc(a.__shady.root);else if("slot"===a.localName&&"name"===b&&(b=rb(a))){var c=a.Ca,d=Gc(a);if(d!==c){c=b.l[c];var e=c.indexOf(a);0<=e&&c.splice(e,1);c=b.l[d]||(b.l[d]=[]);c.push(a);1<c.length&&(b.l[d]=Hc(c))}yc(b)}}function Bc(a,b,c){if(a=a.__shady&&a.__shady.N)b&&a.addedNodes.push(b),c&&a.removedNodes.push(c),Ib(a)}
function Ic(a){if(a&&a.nodeType){a.__shady=a.__shady||{};var b=a.__shady.ka;void 0===b&&(z(a)?b=a:b=(b=a.parentNode)?Ic(b):a,A.contains.call(document.documentElement,a)&&(a.__shady.ka=b));return b}}function Jc(a,b,c){var d=[];Kc(a.childNodes,b,c,d);return d}function Kc(a,b,c,d){for(var e=0,f=a.length,h;e<f&&(h=a[e]);e++){var g;if(g=h.nodeType===Node.ELEMENT_NODE){g=h;var k=b,l=c,m=d,n=k(g);n&&m.push(g);l&&l(n)?g=n:(Kc(g.childNodes,k,l,m),g=void 0)}if(g)break}}var Lc=null;
function Mc(a,b,c){Lc||(Lc=window.ShadyCSS&&window.ShadyCSS.ScopingShim);Lc&&"class"===b?Lc.setElementClass(a,c):(A.setAttribute.call(a,b,c),Fc(a,b))}function Nc(a,b){if(a.ownerDocument!==document)return A.importNode.call(document,a,b);var c=A.importNode.call(document,a,!1);if(b){a=a.childNodes;b=0;for(var d;b<a.length;b++)d=Nc(a[b],!0),c.appendChild(d)}return c};var Oc="__eventWrappers"+Date.now(),Pc={blur:!0,focus:!0,focusin:!0,focusout:!0,click:!0,dblclick:!0,mousedown:!0,mouseenter:!0,mouseleave:!0,mousemove:!0,mouseout:!0,mouseover:!0,mouseup:!0,wheel:!0,beforeinput:!0,input:!0,keydown:!0,keyup:!0,compositionstart:!0,compositionupdate:!0,compositionend:!0,touchstart:!0,touchend:!0,touchmove:!0,touchcancel:!0,pointerover:!0,pointerenter:!0,pointerdown:!0,pointermove:!0,pointerup:!0,pointercancel:!0,pointerout:!0,pointerleave:!0,gotpointercapture:!0,lostpointercapture:!0,
dragstart:!0,drag:!0,dragenter:!0,dragleave:!0,dragover:!0,drop:!0,dragend:!0,DOMActivate:!0,DOMFocusIn:!0,DOMFocusOut:!0,keypress:!0};function Qc(a,b){var c=[],d=a;for(a=a===window?window:a.getRootNode();d;)c.push(d),d=d.assignedSlot?d.assignedSlot:d.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&d.host&&(b||d!==a)?d.host:d.parentNode;c[c.length-1]===document&&c.push(window);return c}
function Rc(a,b){if(!z)return a;a=Qc(a,!0);for(var c=0,d,e,f,h;c<b.length;c++)if(d=b[c],f=d===window?window:d.getRootNode(),f!==e&&(h=a.indexOf(f),e=f),!z(f)||-1<h)return d}
var Sc={get composed(){!1!==this.isTrusted&&void 0===this.Z&&(this.Z=Pc[this.type]);return this.Z||!1},composedPath:function(){this.na||(this.na=Qc(this.__target,this.composed));return this.na},get target(){return Rc(this.currentTarget,this.composedPath())},get relatedTarget(){if(!this.aa)return null;this.oa||(this.oa=Qc(this.aa,!0));return Rc(this.currentTarget,this.oa)},stopPropagation:function(){Event.prototype.stopPropagation.call(this);this.$=!0},stopImmediatePropagation:function(){Event.prototype.stopImmediatePropagation.call(this);
this.$=this.ya=!0}};function Tc(a){function b(b,d){b=new a(b,d);b.Z=d&&!!d.composed;return b}wb(b,a);b.prototype=a.prototype;return b}var Uc={focus:!0,blur:!0};function Vc(a){return a.__target!==a.target||a.aa!==a.relatedTarget}function Wc(a,b,c){if(c=b.__handlers&&b.__handlers[a.type]&&b.__handlers[a.type][c])for(var d=0,e;(e=c[d])&&(!Vc(a)||a.target!==a.relatedTarget)&&(e.call(b,a),!a.ya);d++);}
function Xc(a){var b=a.composedPath();Object.defineProperty(a,"currentTarget",{get:function(){return d},configurable:!0});for(var c=b.length-1;0<=c;c--){var d=b[c];Wc(a,d,"capture");if(a.$)return}Object.defineProperty(a,"eventPhase",{get:function(){return Event.AT_TARGET}});var e;for(c=0;c<b.length;c++){d=b[c];var f=d.__shady&&d.__shady.root;if(0===c||f&&f===e)if(Wc(a,d,"bubble"),d!==window&&(e=d.getRootNode()),a.$)break}}
function Yc(a,b,c,d,e,f){for(var h=0;h<a.length;h++){var g=a[h],k=g.type,l=g.capture,m=g.once,n=g.passive;if(b===g.node&&c===k&&d===l&&e===m&&f===n)return h}return-1}
function Zc(a,b,c){if(b){if(c&&"object"===typeof c){var d=!!c.capture;var e=!!c.once;var f=!!c.passive}else d=!!c,f=e=!1;var h=c&&c.ba||this,g=b[Oc];if(g){if(-1<Yc(g,h,a,d,e,f))return}else b[Oc]=[];g=function(d){e&&this.removeEventListener(a,b,c);d.__target||$c(d);if(h!==this){var f=Object.getOwnPropertyDescriptor(d,"currentTarget");Object.defineProperty(d,"currentTarget",{get:function(){return h},configurable:!0})}if(d.composed||-1<d.composedPath().indexOf(h))if(Vc(d)&&d.target===d.relatedTarget)d.eventPhase===
Event.BUBBLING_PHASE&&d.stopImmediatePropagation();else if(d.eventPhase===Event.CAPTURING_PHASE||d.bubbles||d.target===h||h instanceof Window){var g="object"===typeof b&&b.handleEvent?b.handleEvent(d):b.call(h,d);h!==this&&(f?(Object.defineProperty(d,"currentTarget",f),f=null):delete d.currentTarget);return g}};b[Oc].push({node:this,type:a,capture:d,once:e,passive:f,cb:g});Uc[a]?(this.__handlers=this.__handlers||{},this.__handlers[a]=this.__handlers[a]||{capture:[],bubble:[]},this.__handlers[a][d?
"capture":"bubble"].push(g)):(this instanceof Window?A.ab:A.addEventListener).call(this,a,g,c)}}
function ad(a,b,c){if(b){if(c&&"object"===typeof c){var d=!!c.capture;var e=!!c.once;var f=!!c.passive}else d=!!c,f=e=!1;var h=c&&c.ba||this,g=void 0;var k=null;try{k=b[Oc]}catch(l){}k&&(e=Yc(k,h,a,d,e,f),-1<e&&(g=k.splice(e,1)[0].cb,k.length||(b[Oc]=void 0)));(this instanceof Window?A.bb:A.removeEventListener).call(this,a,g||b,c);g&&Uc[a]&&this.__handlers&&this.__handlers[a]&&(a=this.__handlers[a][d?"capture":"bubble"],g=a.indexOf(g),-1<g&&a.splice(g,1))}}
function bd(){for(var a in Uc)window.addEventListener(a,function(a){a.__target||($c(a),Xc(a))},!0)}function $c(a){a.__target=a.target;a.aa=a.relatedTarget;if(y.M){var b=Object.getPrototypeOf(a);if(!b.hasOwnProperty("__patchProto")){var c=Object.create(b);c.fb=b;ub(c,Sc);b.__patchProto=c}a.__proto__=b.__patchProto}else ub(a,Sc)}var cd=Tc(window.Event),dd=Tc(window.CustomEvent),ed=Tc(window.MouseEvent);function fd(a,b){return{index:a,O:[],U:b}}
function gd(a,b,c,d){var e=0,f=0,h=0,g=0,k=Math.min(b-e,d-f);if(0==e&&0==f)a:{for(h=0;h<k;h++)if(a[h]!==c[h])break a;h=k}if(b==a.length&&d==c.length){g=a.length;for(var l=c.length,m=0;m<k-h&&hd(a[--g],c[--l]);)m++;g=m}e+=h;f+=h;b-=g;d-=g;if(0==b-e&&0==d-f)return[];if(e==b){for(b=fd(e,0);f<d;)b.O.push(c[f++]);return[b]}if(f==d)return[fd(e,b-e)];k=e;h=f;d=d-h+1;g=b-k+1;b=Array(d);for(l=0;l<d;l++)b[l]=Array(g),b[l][0]=l;for(l=0;l<g;l++)b[0][l]=l;for(l=1;l<d;l++)for(m=1;m<g;m++)if(a[k+m-1]===c[h+l-1])b[l][m]=
b[l-1][m-1];else{var n=b[l-1][m]+1,w=b[l][m-1]+1;b[l][m]=n<w?n:w}k=b.length-1;h=b[0].length-1;d=b[k][h];for(a=[];0<k||0<h;)0==k?(a.push(2),h--):0==h?(a.push(3),k--):(g=b[k-1][h-1],l=b[k-1][h],m=b[k][h-1],n=l<m?l<g?l:g:m<g?m:g,n==g?(g==d?a.push(0):(a.push(1),d=g),k--,h--):n==l?(a.push(3),k--,d=l):(a.push(2),h--,d=m));a.reverse();b=void 0;k=[];for(h=0;h<a.length;h++)switch(a[h]){case 0:b&&(k.push(b),b=void 0);e++;f++;break;case 1:b||(b=fd(e,0));b.U++;e++;b.O.push(c[f]);f++;break;case 2:b||(b=fd(e,0));
b.U++;e++;break;case 3:b||(b=fd(e,0)),b.O.push(c[f]),f++}b&&k.push(b);return k}function hd(a,b){return a===b};var id={};function G(a,b,c){if(a!==id)throw new TypeError("Illegal constructor");a=document.createDocumentFragment();a.__proto__=G.prototype;a.Aa="ShadyRoot";vc(b);vc(a);a.host=b;a.a=c&&c.mode;b.__shady=b.__shady||{};b.__shady.root=a;b.__shady.Ua="closed"!==a.a?a:null;a.T=!1;a.s=[];a.l={};a.H=[];c=B.childNodes(b);for(var d=0,e=c.length;d<e;d++)A.removeChild.call(b,c[d]);return a}G.prototype=Object.create(DocumentFragment.prototype);function yc(a){a.T||(a.T=!0,Fb(function(){return jd(a)}))}
function jd(a){for(var b;a;){a.T&&(b=a);a:{var c=a;a=c.host.getRootNode();if(z(a))for(var d=c.host.childNodes,e=0;e<d.length;e++)if(c=d[e],"slot"==c.localName)break a;a=void 0}}b&&b._renderRoot()}
G.prototype._renderRoot=function(){this.T=!1;Dc(this);for(var a=0,b;a<this.s.length;a++){b=this.s[a];var c=b.__shady.assignedNodes;b.__shady.assignedNodes=[];b.__shady.K=[];if(b.__shady.qa=c)for(var d=0;d<c.length;d++){var e=c[d];e.__shady.ga=e.__shady.assignedSlot;e.__shady.assignedSlot===b&&(e.__shady.assignedSlot=null)}}for(b=this.host.firstChild;b;b=b.nextSibling)kd(this,b);for(a=0;a<this.s.length;a++){b=this.s[a];if(!b.__shady.assignedNodes.length)for(c=b.firstChild;c;c=c.nextSibling)kd(this,
c,b);c=b.parentNode;(c=c.__shady&&c.__shady.root)&&Ec(c)&&c._renderRoot();ld(this,b.__shady.K,b.__shady.assignedNodes);if(c=b.__shady.qa){for(d=0;d<c.length;d++)c[d].__shady.ga=null;b.__shady.qa=null;c.length>b.__shady.assignedNodes.length&&(b.__shady.ia=!0)}b.__shady.ia&&(b.__shady.ia=!1,md(this,b))}a=this.s;b=[];for(c=0;c<a.length;c++)d=a[c].parentNode,d.__shady&&d.__shady.root||!(0>b.indexOf(d))||b.push(d);for(a=0;a<b.length;a++){c=b[a];d=c===this?this.host:c;e=[];c=c.childNodes;for(var f=0;f<
c.length;f++){var h=c[f];if("slot"==h.localName){h=h.__shady.K;for(var g=0;g<h.length;g++)e.push(h[g])}else e.push(h)}c=void 0;f=B.childNodes(d);h=gd(e,e.length,f,f.length);for(var k=g=0;g<h.length&&(c=h[g]);g++){for(var l=0,m;l<c.O.length&&(m=c.O[l]);l++)B.parentNode(m)===d&&A.removeChild.call(d,m),f.splice(c.index+k,1);k-=c.U}for(k=0;k<h.length&&(c=h[k]);k++)for(g=f[c.index],l=c.index;l<c.index+c.U;l++)m=e[l],A.insertBefore.call(d,m,g),f.splice(l,0,m)}};
function kd(a,b,c){b.__shady=b.__shady||{};var d=b.__shady.ga;b.__shady.ga=null;c||(c=(a=a.l[b.slot||"__catchall"])&&a[0]);c?(c.__shady.assignedNodes.push(b),b.__shady.assignedSlot=c):b.__shady.assignedSlot=void 0;d!==b.__shady.assignedSlot&&b.__shady.assignedSlot&&(b.__shady.assignedSlot.__shady.ia=!0)}function ld(a,b,c){for(var d=0,e;d<c.length&&(e=c[d]);d++)if("slot"==e.localName){var f=e.__shady.assignedNodes;f&&f.length&&ld(a,b,f)}else b.push(c[d])}
function md(a,b){A.dispatchEvent.call(b,new Event("slotchange"));b.__shady.assignedSlot&&md(a,b.__shady.assignedSlot)}function Dc(a){if(a.H.length){for(var b=a.H,c,d=0;d<b.length;d++){var e=b[d];e.__shady=e.__shady||{};vc(e);vc(e.parentNode);var f=Gc(e);a.l[f]?(c=c||{},c[f]=!0,a.l[f].push(e)):a.l[f]=[e];a.s.push(e)}if(c)for(var h in c)a.l[h]=Hc(a.l[h]);a.H=[]}}function Gc(a){var b=a.name||a.getAttribute("name")||"__catchall";return a.Ca=b}
function Hc(a){return a.sort(function(a,c){a=nd(a);for(var b=nd(c),e=0;e<a.length;e++){c=a[e];var f=b[e];if(c!==f)return a=Array.from(c.parentNode.childNodes),a.indexOf(c)-a.indexOf(f)}})}function nd(a){var b=[];do b.unshift(a);while(a=a.parentNode);return b}function Ec(a){Dc(a);return!!a.s.length}G.prototype.addEventListener=function(a,b,c){"object"!==typeof c&&(c={capture:!!c});c.ba=this;this.host.addEventListener(a,b,c)};
G.prototype.removeEventListener=function(a,b,c){"object"!==typeof c&&(c={capture:!!c});c.ba=this;this.host.removeEventListener(a,b,c)};G.prototype.getElementById=function(a){return Jc(this,function(b){return b.id==a},function(a){return!!a})[0]||null};var od=G.prototype;E(od,mc,!0);E(od,rc,!0);function pd(a){var b=a.getRootNode();z(b)&&jd(b);return a.__shady&&a.__shady.assignedSlot||null}
var qd={addEventListener:Zc.bind(window),removeEventListener:ad.bind(window)},rd={addEventListener:Zc,removeEventListener:ad,appendChild:function(a){return wc(this,a)},insertBefore:function(a,b){return wc(this,a,b)},removeChild:function(a){return xc(this,a)},replaceChild:function(a,b){wc(this,a,b);xc(this,b);return a},cloneNode:function(a){if("template"==this.localName)var b=A.cloneNode.call(this,a);else if(b=A.cloneNode.call(this,!1),a){a=this.childNodes;for(var c=0,d;c<a.length;c++)d=a[c].cloneNode(!0),
b.appendChild(d)}return b},getRootNode:function(){return Ic(this)},contains:function(a){return Cb(this,a)},get isConnected(){var a=this.ownerDocument;if(Bb&&A.contains.call(a,this)||a.documentElement&&A.contains.call(a.documentElement,this))return!0;for(a=this;a&&!(a instanceof Document);)a=a.parentNode||(a instanceof G?a.host:void 0);return!!(a&&a instanceof Document)},dispatchEvent:function(a){Gb();return A.dispatchEvent.call(this,a)}},sd={get assignedSlot(){return pd(this)}},td={querySelector:function(a){return Jc(this,
function(b){return tb.call(b,a)},function(a){return!!a})[0]||null},querySelectorAll:function(a){return Jc(this,function(b){return tb.call(b,a)})}},ud={assignedNodes:function(a){if("slot"===this.localName){var b=this.getRootNode();z(b)&&jd(b);return this.__shady?(a&&a.flatten?this.__shady.K:this.__shady.assignedNodes)||[]:[]}}},vd=vb({setAttribute:function(a,b){Mc(this,a,b)},removeAttribute:function(a){A.removeAttribute.call(this,a);Fc(this,a)},attachShadow:function(a){if(!this)throw"Must provide a host.";
if(!a)throw"Not enough arguments.";return new G(id,this,a)},get slot(){return this.getAttribute("slot")},set slot(a){Mc(this,"slot",a)},get assignedSlot(){return pd(this)}},td,ud);Object.defineProperties(vd,qc);var wd=vb({importNode:function(a,b){return Nc(a,b)},getElementById:function(a){return Jc(this,function(b){return b.id==a},function(a){return!!a})[0]||null}},td);Object.defineProperties(wd,{_activeElement:rc.activeElement});
var xd=HTMLElement.prototype.blur,yd=vb({blur:function(){var a=this.__shady&&this.__shady.root;(a=a&&a.activeElement)?a.blur():xd.call(this)}});function H(a,b){for(var c=Object.getOwnPropertyNames(b),d=0;d<c.length;d++){var e=c[d],f=Object.getOwnPropertyDescriptor(b,e);f.value?a[e]=f.value:Object.defineProperty(a,e,f)}};if(y.ta){var ShadyDOM={inUse:y.ta,patch:function(a){return a},isShadyRoot:z,enqueue:Fb,flush:Gb,settings:y,filterMutations:Mb,observeChildren:Kb,unobserveChildren:Lb,nativeMethods:A,nativeTree:B};window.ShadyDOM=ShadyDOM;window.Event=cd;window.CustomEvent=dd;window.MouseEvent=ed;bd();var zd=window.customElements&&window.customElements.nativeHTMLElement||HTMLElement;H(window.Node.prototype,rd);H(window.Window.prototype,qd);H(window.Text.prototype,sd);H(window.DocumentFragment.prototype,td);H(window.Element.prototype,
vd);H(window.Document.prototype,wd);window.HTMLSlotElement&&H(window.HTMLSlotElement.prototype,ud);H(zd.prototype,yd);y.M&&(F(window.Node.prototype),F(window.Text.prototype),F(window.DocumentFragment.prototype),F(window.Element.prototype),F(zd.prototype),F(window.Document.prototype),window.HTMLSlotElement&&F(window.HTMLSlotElement.prototype));window.ShadowRoot=G};var Ad=new Set("annotation-xml color-profile font-face font-face-src font-face-uri font-face-format font-face-name missing-glyph".split(" "));function Bd(a){var b=Ad.has(a);a=/^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(a);return!b&&a}function J(a){var b=a.isConnected;if(void 0!==b)return b;for(;a&&!(a.__CE_isImportDocument||a instanceof Document);)a=a.parentNode||(window.ShadowRoot&&a instanceof ShadowRoot?a.host:void 0);return!(!a||!(a.__CE_isImportDocument||a instanceof Document))}
function Cd(a,b){for(;b&&b!==a&&!b.nextSibling;)b=b.parentNode;return b&&b!==a?b.nextSibling:null}
function K(a,b,c){c=void 0===c?new Set:c;for(var d=a;d;){if(d.nodeType===Node.ELEMENT_NODE){var e=d;b(e);var f=e.localName;if("link"===f&&"import"===e.getAttribute("rel")){d=e.import;if(d instanceof Node&&!c.has(d))for(c.add(d),d=d.firstChild;d;d=d.nextSibling)K(d,b,c);d=Cd(a,e);continue}else if("template"===f){d=Cd(a,e);continue}if(e=e.__CE_shadowRoot)for(e=e.firstChild;e;e=e.nextSibling)K(e,b,c)}d=d.firstChild?d.firstChild:Cd(a,d)}}function L(a,b,c){a[b]=c};function Dd(){this.a=new Map;this.o=new Map;this.h=[];this.c=!1}function Ed(a,b,c){a.a.set(b,c);a.o.set(c.constructor,c)}function Fd(a,b){a.c=!0;a.h.push(b)}function Gd(a,b){a.c&&K(b,function(b){return a.b(b)})}Dd.prototype.b=function(a){if(this.c&&!a.__CE_patched){a.__CE_patched=!0;for(var b=0;b<this.h.length;b++)this.h[b](a)}};function M(a,b){var c=[];K(b,function(a){return c.push(a)});for(b=0;b<c.length;b++){var d=c[b];1===d.__CE_state?a.connectedCallback(d):Hd(a,d)}}
function N(a,b){var c=[];K(b,function(a){return c.push(a)});for(b=0;b<c.length;b++){var d=c[b];1===d.__CE_state&&a.disconnectedCallback(d)}}
function O(a,b,c){c=void 0===c?{}:c;var d=c.$a||new Set,e=c.wa||function(b){return Hd(a,b)},f=[];K(b,function(b){if("link"===b.localName&&"import"===b.getAttribute("rel")){var c=b.import;c instanceof Node&&(c.__CE_isImportDocument=!0,c.__CE_hasRegistry=!0);c&&"complete"===c.readyState?c.__CE_documentLoadHandled=!0:b.addEventListener("load",function(){var c=b.import;if(!c.__CE_documentLoadHandled){c.__CE_documentLoadHandled=!0;var f=new Set(d);f.delete(c);O(a,c,{$a:f,wa:e})}})}else f.push(b)},d);if(a.c)for(b=
0;b<f.length;b++)a.b(f[b]);for(b=0;b<f.length;b++)e(f[b])}
function Hd(a,b){if(void 0===b.__CE_state){var c=b.ownerDocument;if(c.defaultView||c.__CE_isImportDocument&&c.__CE_hasRegistry)if(c=a.a.get(b.localName)){c.constructionStack.push(b);var d=c.constructor;try{try{if(new d!==b)throw Error("The custom element constructor did not produce the element being upgraded.");}finally{c.constructionStack.pop()}}catch(h){throw b.__CE_state=2,h;}b.__CE_state=1;b.__CE_definition=c;if(c.attributeChangedCallback)for(c=c.observedAttributes,d=0;d<c.length;d++){var e=c[d],
f=b.getAttribute(e);null!==f&&a.attributeChangedCallback(b,e,null,f,null)}J(b)&&a.connectedCallback(b)}}}Dd.prototype.connectedCallback=function(a){var b=a.__CE_definition;b.connectedCallback&&b.connectedCallback.call(a)};Dd.prototype.disconnectedCallback=function(a){var b=a.__CE_definition;b.disconnectedCallback&&b.disconnectedCallback.call(a)};
Dd.prototype.attributeChangedCallback=function(a,b,c,d,e){var f=a.__CE_definition;f.attributeChangedCallback&&-1<f.observedAttributes.indexOf(b)&&f.attributeChangedCallback.call(a,b,c,d,e)};function Id(a){var b=document;this.j=a;this.a=b;this.C=void 0;O(this.j,this.a);"loading"===this.a.readyState&&(this.C=new MutationObserver(this.b.bind(this)),this.C.observe(this.a,{childList:!0,subtree:!0}))}function Jd(a){a.C&&a.C.disconnect()}Id.prototype.b=function(a){var b=this.a.readyState;"interactive"!==b&&"complete"!==b||Jd(this);for(b=0;b<a.length;b++)for(var c=a[b].addedNodes,d=0;d<c.length;d++)O(this.j,c[d])};function Kd(){var a=this;this.b=this.a=void 0;this.c=new Promise(function(b){a.b=b;a.a&&b(a.a)})}Kd.prototype.resolve=function(a){if(this.a)throw Error("Already resolved.");this.a=a;this.b&&this.b(a)};function P(a){this.da=!1;this.j=a;this.ha=new Map;this.ea=function(a){return a()};this.R=!1;this.fa=[];this.Fa=new Id(a)}
P.prototype.define=function(a,b){var c=this;if(!(b instanceof Function))throw new TypeError("Custom element constructors must be functions.");if(!Bd(a))throw new SyntaxError("The element name '"+a+"' is not valid.");if(this.j.a.get(a))throw Error("A custom element with name '"+a+"' has already been defined.");if(this.da)throw Error("A custom element is already being defined.");this.da=!0;try{var d=function(a){var b=e[a];if(void 0!==b&&!(b instanceof Function))throw Error("The '"+a+"' callback must be a function.");
return b},e=b.prototype;if(!(e instanceof Object))throw new TypeError("The custom element constructor's prototype is not an object.");var f=d("connectedCallback");var h=d("disconnectedCallback");var g=d("adoptedCallback");var k=d("attributeChangedCallback");var l=b.observedAttributes||[]}catch(m){return}finally{this.da=!1}b={localName:a,constructor:b,connectedCallback:f,disconnectedCallback:h,adoptedCallback:g,attributeChangedCallback:k,observedAttributes:l,constructionStack:[]};Ed(this.j,a,b);this.fa.push(b);
this.R||(this.R=!0,this.ea(function(){return Ld(c)}))};function Ld(a){if(!1!==a.R){a.R=!1;for(var b=a.fa,c=[],d=new Map,e=0;e<b.length;e++)d.set(b[e].localName,[]);O(a.j,document,{wa:function(b){if(void 0===b.__CE_state){var e=b.localName,f=d.get(e);f?f.push(b):a.j.a.get(e)&&c.push(b)}}});for(e=0;e<c.length;e++)Hd(a.j,c[e]);for(;0<b.length;){var f=b.shift();e=f.localName;f=d.get(f.localName);for(var h=0;h<f.length;h++)Hd(a.j,f[h]);(e=a.ha.get(e))&&e.resolve(void 0)}}}
P.prototype.get=function(a){if(a=this.j.a.get(a))return a.constructor};P.prototype.whenDefined=function(a){if(!Bd(a))return Promise.reject(new SyntaxError("'"+a+"' is not a valid custom element name."));var b=this.ha.get(a);if(b)return b.c;b=new Kd;this.ha.set(a,b);this.j.a.get(a)&&!this.fa.some(function(b){return b.localName===a})&&b.resolve(void 0);return b.c};P.prototype.Ta=function(a){Jd(this.Fa);var b=this.ea;this.ea=function(c){return a(function(){return b(c)})}};
window.CustomElementRegistry=P;P.prototype.define=P.prototype.define;P.prototype.get=P.prototype.get;P.prototype.whenDefined=P.prototype.whenDefined;P.prototype.polyfillWrapFlushCallback=P.prototype.Ta;var Md=window.Document.prototype.createElement,Nd=window.Document.prototype.createElementNS,Od=window.Document.prototype.importNode,Pd=window.Document.prototype.prepend,Qd=window.Document.prototype.append,Rd=window.DocumentFragment.prototype.prepend,Sd=window.DocumentFragment.prototype.append,Td=window.Node.prototype.cloneNode,Ud=window.Node.prototype.appendChild,Vd=window.Node.prototype.insertBefore,Wd=window.Node.prototype.removeChild,Xd=window.Node.prototype.replaceChild,Yd=Object.getOwnPropertyDescriptor(window.Node.prototype,
"textContent"),Zd=window.Element.prototype.attachShadow,$d=Object.getOwnPropertyDescriptor(window.Element.prototype,"innerHTML"),ae=window.Element.prototype.getAttribute,be=window.Element.prototype.setAttribute,ce=window.Element.prototype.removeAttribute,de=window.Element.prototype.getAttributeNS,ee=window.Element.prototype.setAttributeNS,fe=window.Element.prototype.removeAttributeNS,ge=window.Element.prototype.insertAdjacentElement,he=window.Element.prototype.prepend,ie=window.Element.prototype.append,
je=window.Element.prototype.before,ke=window.Element.prototype.after,le=window.Element.prototype.replaceWith,me=window.Element.prototype.remove,ne=window.HTMLElement,oe=Object.getOwnPropertyDescriptor(window.HTMLElement.prototype,"innerHTML"),pe=window.HTMLElement.prototype.insertAdjacentElement;var qe=new function(){};function re(){var a=se;window.HTMLElement=function(){function b(){var b=this.constructor,d=a.o.get(b);if(!d)throw Error("The custom element being constructed was not registered with `customElements`.");var e=d.constructionStack;if(0===e.length)return e=Md.call(document,d.localName),Object.setPrototypeOf(e,b.prototype),e.__CE_state=1,e.__CE_definition=d,a.b(e),e;d=e.length-1;var f=e[d];if(f===qe)throw Error("The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.");
e[d]=qe;Object.setPrototypeOf(f,b.prototype);a.b(f);return f}b.prototype=ne.prototype;return b}()};function te(a,b,c){function d(b){return function(c){for(var d=[],e=0;e<arguments.length;++e)d[e-0]=arguments[e];e=[];for(var f=[],l=0;l<d.length;l++){var m=d[l];m instanceof Element&&J(m)&&f.push(m);if(m instanceof DocumentFragment)for(m=m.firstChild;m;m=m.nextSibling)e.push(m);else e.push(m)}b.apply(this,d);for(d=0;d<f.length;d++)N(a,f[d]);if(J(this))for(d=0;d<e.length;d++)f=e[d],f instanceof Element&&M(a,f)}}void 0!==c.X&&(b.prepend=d(c.X));void 0!==c.append&&(b.append=d(c.append))};function ue(){var a=se;L(Document.prototype,"createElement",function(b){if(this.__CE_hasRegistry){var c=a.a.get(b);if(c)return new c.constructor}b=Md.call(this,b);a.b(b);return b});L(Document.prototype,"importNode",function(b,c){b=Od.call(this,b,c);this.__CE_hasRegistry?O(a,b):Gd(a,b);return b});L(Document.prototype,"createElementNS",function(b,c){if(this.__CE_hasRegistry&&(null===b||"http://www.w3.org/1999/xhtml"===b)){var d=a.a.get(c);if(d)return new d.constructor}b=Nd.call(this,b,c);a.b(b);return b});
te(a,Document.prototype,{X:Pd,append:Qd})};function ve(){var a=se;function b(b,d){Object.defineProperty(b,"textContent",{enumerable:d.enumerable,configurable:!0,get:d.get,set:function(b){if(this.nodeType===Node.TEXT_NODE)d.set.call(this,b);else{var c=void 0;if(this.firstChild){var e=this.childNodes,g=e.length;if(0<g&&J(this)){c=Array(g);for(var k=0;k<g;k++)c[k]=e[k]}}d.set.call(this,b);if(c)for(b=0;b<c.length;b++)N(a,c[b])}}})}L(Node.prototype,"insertBefore",function(b,d){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);
b=Vd.call(this,b,d);if(J(this))for(d=0;d<c.length;d++)M(a,c[d]);return b}c=J(b);d=Vd.call(this,b,d);c&&N(a,b);J(this)&&M(a,b);return d});L(Node.prototype,"appendChild",function(b){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);b=Ud.call(this,b);if(J(this))for(var e=0;e<c.length;e++)M(a,c[e]);return b}c=J(b);e=Ud.call(this,b);c&&N(a,b);J(this)&&M(a,b);return e});L(Node.prototype,"cloneNode",function(b){b=Td.call(this,b);this.ownerDocument.__CE_hasRegistry?O(a,b):
Gd(a,b);return b});L(Node.prototype,"removeChild",function(b){var c=J(b),e=Wd.call(this,b);c&&N(a,b);return e});L(Node.prototype,"replaceChild",function(b,d){if(b instanceof DocumentFragment){var c=Array.prototype.slice.apply(b.childNodes);b=Xd.call(this,b,d);if(J(this))for(N(a,d),d=0;d<c.length;d++)M(a,c[d]);return b}c=J(b);var f=Xd.call(this,b,d),h=J(this);h&&N(a,d);c&&N(a,b);h&&M(a,b);return f});Yd&&Yd.get?b(Node.prototype,Yd):Fd(a,function(a){b(a,{enumerable:!0,configurable:!0,get:function(){for(var a=
[],b=0;b<this.childNodes.length;b++)a.push(this.childNodes[b].textContent);return a.join("")},set:function(a){for(;this.firstChild;)Wd.call(this,this.firstChild);Ud.call(this,document.createTextNode(a))}})})};function we(a){var b=Element.prototype;function c(b){return function(c){for(var d=[],e=0;e<arguments.length;++e)d[e-0]=arguments[e];e=[];for(var g=[],k=0;k<d.length;k++){var l=d[k];l instanceof Element&&J(l)&&g.push(l);if(l instanceof DocumentFragment)for(l=l.firstChild;l;l=l.nextSibling)e.push(l);else e.push(l)}b.apply(this,d);for(d=0;d<g.length;d++)N(a,g[d]);if(J(this))for(d=0;d<e.length;d++)g=e[d],g instanceof Element&&M(a,g)}}void 0!==je&&(b.before=c(je));void 0!==je&&(b.after=c(ke));void 0!==
le&&L(b,"replaceWith",function(b){for(var c=[],d=0;d<arguments.length;++d)c[d-0]=arguments[d];d=[];for(var h=[],g=0;g<c.length;g++){var k=c[g];k instanceof Element&&J(k)&&h.push(k);if(k instanceof DocumentFragment)for(k=k.firstChild;k;k=k.nextSibling)d.push(k);else d.push(k)}g=J(this);le.apply(this,c);for(c=0;c<h.length;c++)N(a,h[c]);if(g)for(N(a,this),c=0;c<d.length;c++)h=d[c],h instanceof Element&&M(a,h)});void 0!==me&&L(b,"remove",function(){var b=J(this);me.call(this);b&&N(a,this)})};function xe(){var a=se;function b(b,c){Object.defineProperty(b,"innerHTML",{enumerable:c.enumerable,configurable:!0,get:c.get,set:function(b){var d=this,e=void 0;J(this)&&(e=[],K(this,function(a){a!==d&&e.push(a)}));c.set.call(this,b);if(e)for(var f=0;f<e.length;f++){var l=e[f];1===l.__CE_state&&a.disconnectedCallback(l)}this.ownerDocument.__CE_hasRegistry?O(a,this):Gd(a,this);return b}})}function c(b,c){L(b,"insertAdjacentElement",function(b,d){var e=J(d);b=c.call(this,b,d);e&&N(a,d);J(b)&&M(a,d);
return b})}Zd&&L(Element.prototype,"attachShadow",function(a){return this.__CE_shadowRoot=a=Zd.call(this,a)});$d&&$d.get?b(Element.prototype,$d):oe&&oe.get?b(HTMLElement.prototype,oe):Fd(a,function(a){b(a,{enumerable:!0,configurable:!0,get:function(){return Td.call(this,!0).innerHTML},set:function(a){var b="template"===this.localName,c=b?this.content:this,d=Md.call(document,this.localName);for(d.innerHTML=a;0<c.childNodes.length;)Wd.call(c,c.childNodes[0]);for(a=b?d.content:d;0<a.childNodes.length;)Ud.call(c,
a.childNodes[0])}})});L(Element.prototype,"setAttribute",function(b,c){if(1!==this.__CE_state)return be.call(this,b,c);var d=ae.call(this,b);be.call(this,b,c);c=ae.call(this,b);a.attributeChangedCallback(this,b,d,c,null)});L(Element.prototype,"setAttributeNS",function(b,c,f){if(1!==this.__CE_state)return ee.call(this,b,c,f);var d=de.call(this,b,c);ee.call(this,b,c,f);f=de.call(this,b,c);a.attributeChangedCallback(this,c,d,f,b)});L(Element.prototype,"removeAttribute",function(b){if(1!==this.__CE_state)return ce.call(this,
b);var c=ae.call(this,b);ce.call(this,b);null!==c&&a.attributeChangedCallback(this,b,c,null,null)});L(Element.prototype,"removeAttributeNS",function(b,c){if(1!==this.__CE_state)return fe.call(this,b,c);var d=de.call(this,b,c);fe.call(this,b,c);var e=de.call(this,b,c);d!==e&&a.attributeChangedCallback(this,c,d,e,b)});pe?c(HTMLElement.prototype,pe):ge?c(Element.prototype,ge):console.warn("Custom Elements: `Element#insertAdjacentElement` was not patched.");te(a,Element.prototype,{X:he,append:ie});we(a)}
;var ye=window.customElements;if(!ye||ye.forcePolyfill||"function"!=typeof ye.define||"function"!=typeof ye.get){var se=new Dd;re();ue();te(se,DocumentFragment.prototype,{X:Rd,append:Sd});ve();xe();document.__CE_hasRegistry=!0;var customElements=new P(se);Object.defineProperty(window,"customElements",{configurable:!0,enumerable:!0,value:customElements})};function ze(){this.end=this.start=0;this.rules=this.parent=this.previous=null;this.cssText=this.parsedCssText="";this.atRule=!1;this.type=0;this.parsedSelector=this.selector=this.keyframesName=""}
function Ae(a){a=a.replace(Be,"").replace(Ce,"");var b=De,c=a,d=new ze;d.start=0;d.end=c.length;for(var e=d,f=0,h=c.length;f<h;f++)if("{"===c[f]){e.rules||(e.rules=[]);var g=e,k=g.rules[g.rules.length-1]||null;e=new ze;e.start=f+1;e.parent=g;e.previous=k;g.rules.push(e)}else"}"===c[f]&&(e.end=f+1,e=e.parent||d);return b(d,a)}
function De(a,b){var c=b.substring(a.start,a.end-1);a.parsedCssText=a.cssText=c.trim();a.parent&&(c=b.substring(a.previous?a.previous.end:a.parent.start,a.start-1),c=Ee(c),c=c.replace(Fe," "),c=c.substring(c.lastIndexOf(";")+1),c=a.parsedSelector=a.selector=c.trim(),a.atRule=0===c.indexOf("@"),a.atRule?0===c.indexOf("@media")?a.type=Je:c.match(Ke)&&(a.type=Le,a.keyframesName=a.selector.split(Fe).pop()):a.type=0===c.indexOf("--")?Me:Ne);if(c=a.rules)for(var d=0,e=c.length,f;d<e&&(f=c[d]);d++)De(f,
b);return a}function Ee(a){return a.replace(/\\([0-9a-f]{1,6})\s/gi,function(a,c){a=c;for(c=6-a.length;c--;)a="0"+a;return"\\"+a})}
function Oe(a,b,c){c=void 0===c?"":c;var d="";if(a.cssText||a.rules){var e=a.rules,f;if(f=e)f=e[0],f=!(f&&f.selector&&0===f.selector.indexOf("--"));if(f){f=0;for(var h=e.length,g;f<h&&(g=e[f]);f++)d=Oe(g,b,d)}else b?b=a.cssText:(b=a.cssText,b=b.replace(Pe,"").replace(Qe,""),b=b.replace(Re,"").replace(Se,"")),(d=b.trim())&&(d="  "+d+"\n")}d&&(a.selector&&(c+=a.selector+" {\n"),c+=d,a.selector&&(c+="}\n\n"));return c}
var Ne=1,Le=7,Je=4,Me=1E3,Be=/\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,Ce=/@import[^;]*;/gim,Pe=/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,Qe=/(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,Re=/@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,Se=/[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,Ke=/^@[^\s]*keyframes/,Fe=/\s+/g;var Q=!(window.ShadyDOM&&window.ShadyDOM.inUse),Te;function Ue(a){Te=a&&a.shimcssproperties?!1:Q||!(navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/)||!window.CSS||!CSS.supports||!CSS.supports("box-shadow","0 0 0 var(--foo)"))}window.ShadyCSS&&void 0!==window.ShadyCSS.nativeCss?Te=window.ShadyCSS.nativeCss:window.ShadyCSS?(Ue(window.ShadyCSS),window.ShadyCSS=void 0):Ue(window.WebComponents&&window.WebComponents.flags);var R=Te;var Ve=/(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi,We=/(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi,Xe=/(--[\w-]+)\s*([:,;)]|$)/gi,Ye=/(animation\s*:)|(animation-name\s*:)/,Ze=/@media\s(.*)/,$e=/\{[^}]*\}/g;var af=new Set;function bf(a,b){if(!a)return"";"string"===typeof a&&(a=Ae(a));b&&cf(a,b);return Oe(a,R)}function df(a){!a.__cssRules&&a.textContent&&(a.__cssRules=Ae(a.textContent));return a.__cssRules||null}function ef(a){return!!a.parent&&a.parent.type===Le}function cf(a,b,c,d){if(a){var e=!1,f=a.type;if(d&&f===Je){var h=a.selector.match(Ze);h&&(window.matchMedia(h[1]).matches||(e=!0))}f===Ne?b(a):c&&f===Le?c(a):f===Me&&(e=!0);if((a=a.rules)&&!e){e=0;f=a.length;for(var g;e<f&&(g=a[e]);e++)cf(g,b,c,d)}}}
function ff(a,b,c,d){var e=document.createElement("style");b&&e.setAttribute("scope",b);e.textContent=a;gf(e,c,d);return e}var S=null;function gf(a,b,c){b=b||document.head;b.insertBefore(a,c&&c.nextSibling||b.firstChild);S?a.compareDocumentPosition(S)===Node.DOCUMENT_POSITION_PRECEDING&&(S=a):S=a}
function hf(a,b){var c=a.indexOf("var(");if(-1===c)return b(a,"","","");a:{var d=0;var e=c+3;for(var f=a.length;e<f;e++)if("("===a[e])d++;else if(")"===a[e]&&0===--d)break a;e=-1}d=a.substring(c+4,e);c=a.substring(0,c);a=hf(a.substring(e+1),b);e=d.indexOf(",");return-1===e?b(c,d.trim(),"",a):b(c,d.substring(0,e).trim(),d.substring(e+1).trim(),a)}function jf(a,b){Q?a.setAttribute("class",b):window.ShadyDOM.nativeMethods.setAttribute.call(a,"class",b)}
function V(a){var b=a.localName,c="";b?-1<b.indexOf("-")||(c=b,b=a.getAttribute&&a.getAttribute("is")||""):(b=a.is,c=a.extends);return{is:b,P:c}};function kf(){}function lf(a,b,c){var d=W;a.__styleScoped?a.__styleScoped=null:mf(d,a,b||"",c)}function mf(a,b,c,d){b.nodeType===Node.ELEMENT_NODE&&nf(b,c,d);if(b="template"===b.localName?(b.content||b.gb).childNodes:b.children||b.childNodes)for(var e=0;e<b.length;e++)mf(a,b[e],c,d)}
function nf(a,b,c){if(b)if(a.classList)c?(a.classList.remove("style-scope"),a.classList.remove(b)):(a.classList.add("style-scope"),a.classList.add(b));else if(a.getAttribute){var d=a.getAttribute(of);c?d&&(b=d.replace("style-scope","").replace(b,""),jf(a,b)):jf(a,(d?d+" ":"")+"style-scope "+b)}}function pf(a,b,c){var d=W,e=a.__cssBuild;Q||"shady"===e?b=bf(b,c):(a=V(a),b=qf(d,b,a.is,a.P,c)+"\n\n");return b.trim()}
function qf(a,b,c,d,e){var f=rf(c,d);c=c?sf+c:"";return bf(b,function(b){b.c||(b.selector=b.m=tf(a,b,a.b,c,f),b.c=!0);e&&e(b,c,f)})}function rf(a,b){return b?"[is="+a+"]":a}function tf(a,b,c,d,e){var f=b.selector.split(uf);if(!ef(b)){b=0;for(var h=f.length,g;b<h&&(g=f[b]);b++)f[b]=c.call(a,g,d,e)}return f.join(uf)}function vf(a){return a.replace(wf,function(a,c,d){-1<d.indexOf("+")?d=d.replace(/\+/g,"___"):-1<d.indexOf("___")&&(d=d.replace(/___/g,"+"));return":"+c+"("+d+")"})}
kf.prototype.b=function(a,b,c){var d=!1;a=a.trim();var e=wf.test(a);e&&(a=a.replace(wf,function(a,b,c){return":"+b+"("+c.replace(/\s/g,"")+")"}),a=vf(a));a=a.replace(xf,yf+" $1");a=a.replace(zf,function(a,e,g){d||(a=Af(g,e,b,c),d=d||a.stop,e=a.Ja,g=a.value);return e+g});e&&(a=vf(a));return a};
function Af(a,b,c,d){var e=a.indexOf(Bf);0<=a.indexOf(yf)?a=Cf(a,d):0!==e&&(a=c?Df(a,c):a);c=!1;0<=e&&(b="",c=!0);if(c){var f=!0;c&&(a=a.replace(Ef,function(a,b){return" > "+b}))}a=a.replace(Ff,function(a,b,c){return'[dir="'+c+'"] '+b+", "+b+'[dir="'+c+'"]'});return{value:a,Ja:b,stop:f}}function Df(a,b){a=a.split(Gf);a[0]+=b;return a.join(Gf)}
function Cf(a,b){var c=a.match(Hf);return(c=c&&c[2].trim()||"")?c[0].match(If)?a.replace(Hf,function(a,c,f){return b+f}):c.split(If)[0]===b?c:Jf:a.replace(yf,b)}function Kf(a){a.selector===Lf&&(a.selector="html")}kf.prototype.c=function(a){return a.match(Bf)?this.b(a,Mf):Df(a.trim(),Mf)};q.Object.defineProperties(kf.prototype,{a:{configurable:!0,enumerable:!0,get:function(){return"style-scope"}}});
var wf=/:(nth[-\w]+)\(([^)]+)\)/,Mf=":not(.style-scope)",uf=",",zf=/(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=[])+)/g,If=/[[.:#*]/,yf=":host",Lf=":root",Bf="::slotted",xf=new RegExp("^("+Bf+")"),Hf=/(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,Ef=/(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/,Ff=/(.*):dir\((?:(ltr|rtl))\)/,sf=".",Gf=":",of="class",Jf="should_not_match",W=new kf;function Nf(a,b,c,d){this.w=a||null;this.b=b||null;this.ja=c||[];this.G=null;this.P=d||"";this.a=this.u=this.B=null}function X(a){return a?a.__styleInfo:null}function Of(a,b){return a.__styleInfo=b}Nf.prototype.c=function(){return this.w};Nf.prototype._getStyleRules=Nf.prototype.c;var Pf,Qf=window.Element.prototype;Pf=Qf.matches||Qf.matchesSelector||Qf.mozMatchesSelector||Qf.msMatchesSelector||Qf.oMatchesSelector||Qf.webkitMatchesSelector;var Rf=navigator.userAgent.match("Trident");function Sf(){}function Tf(a){var b={},c=[],d=0;cf(a,function(a){Uf(a);a.index=d++;a=a.i.cssText;for(var c;c=Xe.exec(a);){var e=c[1];":"!==c[2]&&(b[e]=!0)}},function(a){c.push(a)});a.b=c;a=[];for(var e in b)a.push(e);return a}
function Uf(a){if(!a.i){var b={},c={};Vf(a,c)&&(b.v=c,a.rules=null);b.cssText=a.parsedCssText.replace($e,"").replace(Ve,"");a.i=b}}function Vf(a,b){var c=a.i;if(c){if(c.v)return Object.assign(b,c.v),!0}else{c=a.parsedCssText;for(var d;a=Ve.exec(c);){d=(a[2]||a[3]).trim();if("inherit"!==d||"unset"!==d)b[a[1].trim()]=d;d=!0}return d}}
function Wf(a,b,c){b&&(b=0<=b.indexOf(";")?Xf(a,b,c):hf(b,function(b,e,f,h){if(!e)return b+h;(e=Wf(a,c[e],c))&&"initial"!==e?"apply-shim-inherit"===e&&(e="inherit"):e=Wf(a,c[f]||f,c)||f;return b+(e||"")+h}));return b&&b.trim()||""}
function Xf(a,b,c){b=b.split(";");for(var d=0,e,f;d<b.length;d++)if(e=b[d]){We.lastIndex=0;if(f=We.exec(e))e=Wf(a,c[f[1]],c);else if(f=e.indexOf(":"),-1!==f){var h=e.substring(f);h=h.trim();h=Wf(a,h,c)||h;e=e.substring(0,f)+h}b[d]=e&&e.lastIndexOf(";")===e.length-1?e.slice(0,-1):e||""}return b.join(";")}
function Yf(a,b){var c={},d=[];cf(a,function(a){a.i||Uf(a);var e=a.m||a.parsedSelector;b&&a.i.v&&e&&Pf.call(b,e)&&(Vf(a,c),a=a.index,e=parseInt(a/32,10),d[e]=(d[e]||0)|1<<a%32)},null,!0);return{v:c,key:d}}
function Zf(a,b,c,d){b.i||Uf(b);if(b.i.v){var e=V(a);a=e.is;e=e.P;e=a?rf(a,e):"html";var f=b.parsedSelector,h=":host > *"===f||"html"===f,g=0===f.indexOf(":host")&&!h;"shady"===c&&(h=f===e+" > *."+e||-1!==f.indexOf("html"),g=!h&&0===f.indexOf(e));"shadow"===c&&(h=":host > *"===f||"html"===f,g=g&&!h);if(h||g)c=e,g&&(Q&&!b.m&&(b.m=tf(W,b,W.b,a?sf+a:"",e)),c=b.m||e),d({Xa:c,Oa:g,ib:h})}}
function $f(a,b){var c={},d={},e=b&&b.__cssBuild;cf(b,function(b){Zf(a,b,e,function(e){Pf.call(a.hb||a,e.Xa)&&(e.Oa?Vf(b,c):Vf(b,d))})},null,!0);return{Va:d,Na:c}}
function ag(a,b,c,d){var e=V(b),f=rf(e.is,e.P),h=new RegExp("(?:^|[^.#[:])"+(b.extends?"\\"+f.slice(0,-1)+"\\]":f)+"($|[.:[\\s>+~])");e=X(b).w;var g=bg(e,d);return pf(b,e,function(b){var e="";b.i||Uf(b);b.i.cssText&&(e=Xf(a,b.i.cssText,c));b.cssText=e;if(!Q&&!ef(b)&&b.cssText){var k=e=b.cssText;null==b.ra&&(b.ra=Ye.test(e));if(b.ra)if(null==b.W){b.W=[];for(var n in g)k=g[n],k=k(e),e!==k&&(e=k,b.W.push(n))}else{for(n=0;n<b.W.length;++n)k=g[b.W[n]],e=k(e);k=e}b.cssText=k;b.m=b.m||b.selector;e="."+d;
n=b.m.split(",");k=0;for(var w=n.length,I;k<w&&(I=n[k]);k++)n[k]=I.match(h)?I.replace(f,e):e+" "+I;b.selector=n.join(",")}})}function bg(a,b){a=a.b;var c={};if(!Q&&a)for(var d=0,e=a[d];d<a.length;e=a[++d]){var f=e,h=b;f.h=new RegExp(f.keyframesName,"g");f.a=f.keyframesName+"-"+h;f.m=f.m||f.selector;f.selector=f.m.replace(f.keyframesName,f.a);c[e.keyframesName]=cg(e)}return c}function cg(a){return function(b){return b.replace(a.h,a.a)}}
function dg(a,b){var c=eg,d=df(a);a.textContent=bf(d,function(a){var d=a.cssText=a.parsedCssText;a.i&&a.i.cssText&&(d=d.replace(Pe,"").replace(Qe,""),a.cssText=Xf(c,d,b))})}q.Object.defineProperties(Sf.prototype,{a:{configurable:!0,enumerable:!0,get:function(){return"x-scope"}}});var eg=new Sf;var fg={},gg=window.customElements;if(gg&&!Q){var hg=gg.define;gg.define=function(a,b,c){var d=document.createComment(" Shady DOM styles for "+a+" "),e=document.head;e.insertBefore(d,(S?S.nextSibling:null)||e.firstChild);S=d;fg[a]=d;return hg.call(gg,a,b,c)}};function ig(){this.cache={}}ig.prototype.store=function(a,b,c,d){var e=this.cache[a]||[];e.push({v:b,styleElement:c,u:d});100<e.length&&e.shift();this.cache[a]=e};ig.prototype.fetch=function(a,b,c){if(a=this.cache[a])for(var d=a.length-1;0<=d;d--){var e=a[d],f;a:{for(f=0;f<c.length;f++){var h=c[f];if(e.v[h]!==b[h]){f=!1;break a}}f=!0}if(f)return e}};function jg(){}
function kg(a){for(var b=0;b<a.length;b++){var c=a[b];if(c.target!==document.documentElement&&c.target!==document.head)for(var d=0;d<c.addedNodes.length;d++){var e=c.addedNodes[d];if(e.nodeType===Node.ELEMENT_NODE){var f=e.getRootNode();var h=e;var g=[];h.classList?g=Array.from(h.classList):h instanceof window.SVGElement&&h.hasAttribute("class")&&(g=h.getAttribute("class").split(/\s+/));h=g;g=h.indexOf(W.a);if((h=-1<g?h[g+1]:"")&&f===e.ownerDocument)lf(e,h,!0);else if(f.nodeType===Node.DOCUMENT_FRAGMENT_NODE&&
(f=f.host))if(f=V(f).is,h===f)for(e=window.ShadyDOM.nativeMethods.querySelectorAll.call(e,":not(."+W.a+")"),f=0;f<e.length;f++)nf(e[f],h);else h&&lf(e,h,!0),lf(e,f)}}}}
if(!Q){var lg=new MutationObserver(kg),mg=function(a){lg.observe(a,{childList:!0,subtree:!0})};if(window.customElements&&!window.customElements.polyfillWrapFlushCallback)mg(document);else{var ng=function(){mg(document.body)};window.HTMLImports?window.HTMLImports.whenReady(ng):requestAnimationFrame(function(){if("loading"===document.readyState){var a=function(){ng();document.removeEventListener("readystatechange",a)};document.addEventListener("readystatechange",a)}else ng()})}jg=function(){kg(lg.takeRecords())}}
var og=jg;var pg={};var qg=Promise.resolve();function rg(a){if(a=pg[a])a._applyShimCurrentVersion=a._applyShimCurrentVersion||0,a._applyShimValidatingVersion=a._applyShimValidatingVersion||0,a._applyShimNextVersion=(a._applyShimNextVersion||0)+1}function sg(a){return a._applyShimCurrentVersion===a._applyShimNextVersion}function tg(a){a._applyShimValidatingVersion=a._applyShimNextVersion;a.b||(a.b=!0,qg.then(function(){a._applyShimCurrentVersion=a._applyShimNextVersion;a.b=!1}))};var ug=null,vg=window.HTMLImports&&window.HTMLImports.whenReady||null,wg;function xg(a){requestAnimationFrame(function(){vg?vg(a):(ug||(ug=new Promise(function(a){wg=a}),"complete"===document.readyState?wg():document.addEventListener("readystatechange",function(){"complete"===document.readyState&&wg()})),ug.then(function(){a&&a()}))})};var yg=new ig;function Y(){var a=this;this.L={};this.c=document.documentElement;var b=new ze;b.rules=[];this.h=Of(this.c,new Nf(b));this.o=!1;this.b=this.a=null;xg(function(){zg(a)})}p=Y.prototype;p.xa=function(){og()};p.La=function(a){return df(a)};p.Za=function(a){return bf(a)};
p.prepareTemplate=function(a,b,c){if(!a.h){a.h=!0;a.name=b;a.extends=c;pg[b]=a;var d=(d=a.content.querySelector("style"))?d.getAttribute("css-build")||"":"";var e=[];for(var f=a.content.querySelectorAll("style"),h=0;h<f.length;h++){var g=f[h];if(g.hasAttribute("shady-unscoped")){if(!Q){var k=g.textContent;af.has(k)||(af.add(k),k=g.cloneNode(!0),document.head.appendChild(k));g.parentNode.removeChild(g)}}else e.push(g.textContent),g.parentNode.removeChild(g)}e=e.join("").trim();c={is:b,extends:c,eb:d};
Q||lf(a.content,b);zg(this);f=We.test(e)||Ve.test(e);We.lastIndex=0;Ve.lastIndex=0;e=Ae(e);f&&R&&this.a&&this.a.transformRules(e,b);a._styleAst=e;a.o=d;d=[];R||(d=Tf(a._styleAst));if(!d.length||R)e=Q?a.content:null,b=fg[b],f=pf(c,a._styleAst),b=f.length?ff(f,c.is,e,b):void 0,a.a=b;a.c=d}};
function Ag(a){!a.b&&window.ShadyCSS&&window.ShadyCSS.CustomStyleInterface&&(a.b=window.ShadyCSS.CustomStyleInterface,a.b.transformCallback=function(b){a.va(b)},a.b.validateCallback=function(){requestAnimationFrame(function(){(a.b.enqueued||a.o)&&a.F()})})}function zg(a){!a.a&&window.ShadyCSS&&window.ShadyCSS.ApplyShim&&(a.a=window.ShadyCSS.ApplyShim,a.a.invalidCallback=rg);Ag(a)}
p.F=function(){zg(this);if(this.b){var a=this.b.processStyles();if(this.b.enqueued){if(R)for(var b=0;b<a.length;b++){var c=this.b.getStyleForCustomStyle(a[b]);if(c&&R&&this.a){var d=df(c);zg(this);this.a.transformRules(d);c.textContent=bf(d)}}else for(Bg(this,this.c,this.h),b=0;b<a.length;b++)(c=this.b.getStyleForCustomStyle(a[b]))&&dg(c,this.h.B);this.b.enqueued=!1;this.o&&!R&&this.styleDocument()}}};
p.styleElement=function(a,b){var c=V(a).is,d=X(a);if(!d){var e=V(a);d=e.is;e=e.P;var f=fg[d];d=pg[d];if(d){var h=d._styleAst;var g=d.c}d=Of(a,new Nf(h,f,g,e))}a!==this.c&&(this.o=!0);b&&(d.G=d.G||{},Object.assign(d.G,b));if(R){if(d.G){b=d.G;for(var k in b)null===k?a.style.removeProperty(k):a.style.setProperty(k,b[k])}if(((k=pg[c])||a===this.c)&&k&&k.a&&!sg(k)){if(sg(k)||k._applyShimValidatingVersion!==k._applyShimNextVersion)zg(this),this.a&&this.a.transformRules(k._styleAst,c),k.a.textContent=pf(a,
d.w),tg(k);Q&&(c=a.shadowRoot)&&(c.querySelector("style").textContent=pf(a,d.w));d.w=k._styleAst}}else if(Bg(this,a,d),d.ja&&d.ja.length){c=d;k=V(a).is;d=(b=yg.fetch(k,c.B,c.ja))?b.styleElement:null;h=c.u;(g=b&&b.u)||(g=this.L[k]=(this.L[k]||0)+1,g=k+"-"+g);c.u=g;g=c.u;e=eg;e=d?d.textContent||"":ag(e,a,c.B,g);f=X(a);var l=f.a;l&&!Q&&l!==d&&(l._useCount--,0>=l._useCount&&l.parentNode&&l.parentNode.removeChild(l));Q?f.a?(f.a.textContent=e,d=f.a):e&&(d=ff(e,g,a.shadowRoot,f.b)):d?d.parentNode||(Rf&&
-1<e.indexOf("@media")&&(d.textContent=e),gf(d,null,f.b)):e&&(d=ff(e,g,null,f.b));d&&(d._useCount=d._useCount||0,f.a!=d&&d._useCount++,f.a=d);g=d;Q||(d=c.u,f=e=a.getAttribute("class")||"",h&&(f=e.replace(new RegExp("\\s*x-scope\\s*"+h+"\\s*","g")," ")),f+=(f?" ":"")+"x-scope "+d,e!==f&&jf(a,f));b||yg.store(k,c.B,g,c.u)}};function Cg(a,b){return(b=b.getRootNode().host)?X(b)?b:Cg(a,b):a.c}
function Bg(a,b,c){a=Cg(a,b);var d=X(a);a=Object.create(d.B||null);var e=$f(b,c.w);b=Yf(d.w,b).v;Object.assign(a,e.Na,b,e.Va);b=c.G;for(var f in b)if((e=b[f])||0===e)a[f]=e;f=eg;b=Object.getOwnPropertyNames(a);for(e=0;e<b.length;e++)d=b[e],a[d]=Wf(f,a[d],a);c.B=a}p.styleDocument=function(a){this.styleSubtree(this.c,a)};
p.styleSubtree=function(a,b){var c=a.shadowRoot;(c||a===this.c)&&this.styleElement(a,b);if(b=c&&(c.children||c.childNodes))for(a=0;a<b.length;a++)this.styleSubtree(b[a]);else if(a=a.children||a.childNodes)for(b=0;b<a.length;b++)this.styleSubtree(a[b])};p.va=function(a){var b=this,c=df(a);cf(c,function(a){if(Q)Kf(a);else{var c=W;a.selector=a.parsedSelector;Kf(a);a.selector=a.m=tf(c,a,c.c,void 0,void 0)}R&&(zg(b),b.a&&b.a.transformRule(a))});R?a.textContent=bf(c):this.h.w.rules.push(c)};
p.getComputedStyleValue=function(a,b){var c;R||(c=(X(a)||X(Cg(this,a))).B[b]);return(c=c||window.getComputedStyle(a).getPropertyValue(b))?c.trim():""};p.Ya=function(a,b){var c=a.getRootNode();b=b?b.split(/\s/):[];c=c.host&&c.host.localName;if(!c){var d=a.getAttribute("class");if(d){d=d.split(/\s/);for(var e=0;e<d.length;e++)if(d[e]===W.a){c=d[e+1];break}}}c&&b.push(W.a,c);R||(c=X(a))&&c.u&&b.push(eg.a,c.u);jf(a,b.join(" "))};p.Ia=function(a){return X(a)};Y.prototype.flush=Y.prototype.xa;
Y.prototype.prepareTemplate=Y.prototype.prepareTemplate;Y.prototype.styleElement=Y.prototype.styleElement;Y.prototype.styleDocument=Y.prototype.styleDocument;Y.prototype.styleSubtree=Y.prototype.styleSubtree;Y.prototype.getComputedStyleValue=Y.prototype.getComputedStyleValue;Y.prototype.setElementClass=Y.prototype.Ya;Y.prototype._styleInfoForNode=Y.prototype.Ia;Y.prototype.transformCustomStyleForDocument=Y.prototype.va;Y.prototype.getStyleAst=Y.prototype.La;Y.prototype.styleAstToString=Y.prototype.Za;
Y.prototype.flushCustomStyles=Y.prototype.F;Object.defineProperties(Y.prototype,{nativeShadow:{get:function(){return Q}},nativeCss:{get:function(){return R}}});var Z=new Y,Dg,Eg;window.ShadyCSS&&(Dg=window.ShadyCSS.ApplyShim,Eg=window.ShadyCSS.CustomStyleInterface);window.ShadyCSS={ScopingShim:Z,prepareTemplate:function(a,b,c){Z.F();Z.prepareTemplate(a,b,c)},styleSubtree:function(a,b){Z.F();Z.styleSubtree(a,b)},styleElement:function(a){Z.F();Z.styleElement(a)},styleDocument:function(a){Z.F();Z.styleDocument(a)},getComputedStyleValue:function(a,b){return Z.getComputedStyleValue(a,b)},nativeCss:R,nativeShadow:Q};Dg&&(window.ShadyCSS.ApplyShim=Dg);
Eg&&(window.ShadyCSS.CustomStyleInterface=Eg);var Fg=window.customElements,Gg=window.HTMLImports,Hg=window.HTMLTemplateElement;window.WebComponents=window.WebComponents||{};if(Fg&&Fg.polyfillWrapFlushCallback){var Ig,Jg=function(){if(Ig){Hg.J&&Hg.J(window.document);var a=Ig;Ig=null;a();return!0}},Kg=Gg.whenReady;Fg.polyfillWrapFlushCallback(function(a){Ig=a;Kg(Jg)});Gg.whenReady=function(a){Kg(function(){Jg()?Gg.whenReady(a):a()})}}
Gg.whenReady(function(){requestAnimationFrame(function(){window.WebComponents.ready=!0;document.dispatchEvent(new CustomEvent("WebComponentsReady",{bubbles:!0}))})});var Lg=document.createElement("style");Lg.textContent="body {transition: opacity ease-in 0.2s; } \nbody[unresolved] {opacity: 0; display: block; overflow: hidden; position: relative; } \n";var Mg=document.querySelector("head");Mg.insertBefore(Lg,Mg.firstChild);}).call(this);

//# sourceMappingURL=webcomponents-lite.js.map

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(100), __webpack_require__(101)))

/***/ }),
/* 100 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 101 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 102 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tta_underlined_text_html__ = __webpack_require__(103);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__tta_underlined_text_html___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__tta_underlined_text_html__);


class TTAUnderlinedText extends __WEBPACK_IMPORTED_MODULE_0__polymer_polymer_polymer_element__["a" /* Element */] {
  static get is() {
    return "tta-underlined-text";
  }

  static get template() {
    return __WEBPACK_IMPORTED_MODULE_1__tta_underlined_text_html___default.a;
  }

  constructor() {
    super();
  }

  static get properties() {
    return {
      text: {
        type: String
      },
      hasHr: {
        type: Boolean
      }
    };
  }

}
/* harmony export (immutable) */ __webpack_exports__["default"] = TTAUnderlinedText;
 // Register custom element class with browser

customElements.define(TTAUnderlinedText.is, TTAUnderlinedText);

/***/ }),
/* 103 */
/***/ (function(module, exports) {

module.exports = "<style>\n  hr {\n      border: 0.5px solid;\n  }\n</style>\n\n<div>[[text]]</div>\n\n<!-- TODO how do we conditionally hide this based on hasHr? -->\n<hr>\n"

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgM2Q4ZTg0OWNkMzBmOWE1ZmI4ZGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYm9vdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci1mbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hc3luYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zZXR0aW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVzb2x2ZS11cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2dlc3R1cmVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9kZWJvdW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL211dGFibGUtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IvaXJvbi1hMTF5LWtleXMtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL3R5cG9ncmFwaHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tYmVoYXZpb3JzL2lyb24tY29udHJvbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvc3R5bGUtc2V0dGluZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jc3MtcGFyc2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jb21tb24tcmVnZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9jb21tb24tdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsdXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy90ZW1wbGF0aXplLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWJlaGF2aW9ycy9pcm9uLWJ1dHRvbi1zdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi90YWN0aWxlL2NsaWVudC9hamF4LmpzIiwid2VicGFjazovLy8uL3RhY3RpbGUvY2xpZW50L3RhY3RpbGUtYXV0aG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpdC1odG1sLmpzIiwid2VicGFjazovLy8uL3RhY3RpbGUvY2xpZW50L3N0cmluZ1V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvbGVnYWN5LWVsZW1lbnQtbWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS11dGlsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvdGVtcGxhdGUtbWFwLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvZG9jdW1lbnQtd2FpdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYXJyYXktc3BsaWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvY29sb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9zaGFkb3cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tZm9ybS1lbGVtZW50LWJlaGF2aW9yL2lyb24tZm9ybS1lbGVtZW50LWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWlucHV0L3BhcGVyLWlucHV0LWFkZG9uLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi90YWN0aWxlL2NsaWVudC90YWN0aWxlLW1vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vdGFjdGlsZS9jbGllbnQvYXV0aG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvcHJvcGVydHktYWNjZXNzb3JzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvdGVtcGxhdGUtc3RhbXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWRpYWxvZy9wYXBlci1kaWFsb2cuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2FwcGx5LXNoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvdW5zY29wZWQtc3R5bGUtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2FwcGx5LXNoaW0tdXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ltcG9ydC1ocmVmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy91bnJlc29sdmVkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbGF0dGVuZWQtbm9kZXMtb2JzZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9jbGFzcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLXJlcGVhdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLWlmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9hcnJheS1zZWxlY3Rvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvY3VzdG9tLXN0eWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9lbnRyeXBvaW50cy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvbXV0YWJsZS1kYXRhLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9uZW9uLWFuaW1hdGlvbi9uZW9uLWFuaW1hdGlvbi1ydW5uZXItYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL25lb24tYW5pbWF0aW9uL25lb24tYW5pbWF0YWJsZS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItZGlhbG9nLWJlaGF2aW9yL3BhcGVyLWRpYWxvZy1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lyb24tb3ZlcmxheS1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1maXQtYmVoYXZpb3IvaXJvbi1maXQtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW92ZXJsYXktYmVoYXZpb3IvaXJvbi1vdmVybGF5LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tb3ZlcmxheS1iZWhhdmlvci9pcm9uLW92ZXJsYXktYmFja2Ryb3AuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tb3ZlcmxheS1iZWhhdmlvci9pcm9uLWZvY3VzYWJsZXMtaGVscGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1kaWFsb2ctYmVoYXZpb3IvcGFwZXItZGlhbG9nLXNoYXJlZC1zdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2ZvbnQtcm9ib3RvL3JvYm90by5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYnV0dG9uL3BhcGVyLWJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItYmVoYXZpb3JzL3BhcGVyLWJ1dHRvbi1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItcmlwcGxlL3BhcGVyLXJpcHBsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL2VsZW1lbnQtc3R5bGVzL3BhcGVyLW1hdGVyaWFsLXN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24taW5wdXQvaXJvbi1pbnB1dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1hMTF5LWFubm91bmNlci9pcm9uLWExMXktYW5ub3VuY2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW1ldGEvaXJvbi1tZXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC1iZWhhdmlvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItaW5wdXQvcGFwZXItaW5wdXQtY2hhci1jb3VudGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC1jb250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWlucHV0L3BhcGVyLWlucHV0LWVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1jaGVja2JveC9wYXBlci1jaGVja2JveC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXRvZ2dsZS1idXR0b24vcGFwZXItdG9nZ2xlLWJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9nbG9iYWwvY2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy93ZWJjb21wb25lbnRzanMvd2ViY29tcG9uZW50cy1saXRlLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9lbGVtZW50cy90dGEtdW5kZXJsaW5lZC10ZXh0L3R0YS11bmRlcmxpbmVkLXRleHQuanMiLCJ3ZWJwYWNrOi8vLy4vZWxlbWVudHMvdHRhLXVuZGVybGluZWQtdGV4dC90dGEtdW5kZXJsaW5lZC10ZXh0Lmh0bWwiXSwibmFtZXMiOlsiYWpheCIsInVybCIsImRhdGEiLCJtZXRob2QiLCJoZWFkZXJzIiwic3VjY2Vzc0NhbGxiYWNrIiwiZXJyb3JDYWxsYmFjayIsImNvbmZpZyIsImJvZHkiLCJKU09OIiwic3RyaW5naWZ5IiwiZmV0Y2giLCJ0aGVuIiwicmVzcG9uc2UiLCJvayIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiRXJyb3IiLCJqc29uIiwiY2F0Y2giLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJtZXNzYWdlIiwiYWpheEdldCIsIkhlYWRlcnMiLCJ1bmRlZmluZWQiLCJhamF4UG9zdCIsImFwcGVuZCIsImFqYXhQdXQiLCJUYWN0aWxlQXV0aG9yIiwiaXMiLCJjb25zdHJ1Y3RvciIsInByb3BlcnRpZXMiLCJwYXRoIiwidHlwZSIsIlN0cmluZyIsIl9jcmVhdGVJbnB1dHMiLCJjb21wb25lbnQiLCJpbnB1dHMiLCJhdXRob3IiLCJhdHRycyIsImZvckVhY2giLCJpbnB1dCIsInB1c2giLCJuYW1lIiwidGl0bGUiLCJfY3JlYXRlTWVzc2FnZSIsImRlc2NyaXB0aW9uIiwiX2NyZWF0ZUJ1dHRvbnMiLCJleHRyYUJ1dHRvbnMiLCJidXR0b24iLCJ0ZW1wbGF0ZSIsImNvbXBUeXBlIiwib3BlbkRpYWxvZyIsImNhbGxiYWNrIiwic2hhZG93Iiwic2hhZG93Um9vdCIsImF0dGFjaFNoYWRvdyIsIm1vZGUiLCJidXR0b25zIiwicmVuZGVyIiwicGFwZXJEaWFsb2ciLCJxdWVyeVNlbGVjdG9yIiwib3BlbiIsImFkZEV2ZW50TGlzdGVuZXIiLCJlIiwidGFyZ2V0IiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJkYXRhc2V0IiwicGFyc2UiLCJpcm9uT3ZlcmxheUNsb3NlZEhhbmRsZXIiLCJkZXRhaWwiLCJjb25maXJtZWQiLCJuZXdWYWx1ZXMiLCJxdWVyeVNlbGVjdG9yQWxsIiwidmFsdWUiLCJhY3RpdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3VzdG9tRWxlbWVudHMiLCJkZWZpbmUiLCJjYW1lbENhc2VUb1RpdGxlIiwic3RyIiwicmVwbGFjZSIsInRvVXBwZXJDYXNlIiwiVGFjdGlsZU1vZGUiLCJjb25uZWN0ZWRDYWxsYmFjayIsInRvZ2dsZSIsInNldFRvRWRpdCIsImNoZWNrZWQiLCJzZXRUb1B1Ymxpc2giLCJzd2l0Y2hlZFRvRWRpdCIsInN3aXRjaGVkVG9QdWJsaXNoIiwid2F0Y2hGb3JDb21wb25lbnRDbGlja3MiLCJldmVudCIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiY2xvc2VzdCIsImF1dGhvckVsZW1lbnQiLCJnZXRBdHRyaWJ1dGUiLCJkb2N1bWVudCIsIndpbmRvdyIsImxvY2F0aW9uIiwicmVsb2FkIiwic2V0dXBFZGl0TW9kZSIsImFkZCIsInNlc3Npb25TdG9yYWdlIiwic2V0SXRlbSIsInNldHVwUHVibGlzaE1vZGUiLCJyZW1vdmUiLCJ0YWN0aWxlTW9kZVRvZ2dsZSIsImdldEl0ZW0iLCJnZXRCcmVha3BvaW50IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJicmVha3BvaW50IiwiJCIsInJlc2l6ZSIsImRlc2t0b3AiLCJ0YWJsZXQiLCJwaG9uZSIsIlRUQVVuZGVybGluZWRUZXh0IiwidGV4dCIsImhhc0hyIiwiQm9vbGVhbiJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVksY0FBYztBQUMxQixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsbUNBQW1DLHdCQUF3QjtBQUMzRCxZQUFZO0FBQ1o7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLGNBQWM7QUFDM0IsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsc0JBQXNCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7QUM5YkE7QUFDQTtBQUNBLHlEQUF5RDs7QUFFekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7Ozs7QUM5VkE7QUFDQTtBQUNBO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsS0FBSztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7OztBQ3pOTyxTQUFTQSxJQUFULENB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDLHNDQUFzQyxnQkFBZ0IsR0FBRyxXQUFXO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix1QkFBdUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsZUFBZTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEM7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsb0JBQW9CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLEVBQUU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7QUFDQTs7QUFFUTs7Ozs7Ozs7O0FDcFFSO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7Ozs7Ozs7O0FDdlVBO0FBQ0E7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7Ozs7Ozs7OztBQ3JFQTtBQUNrQjs7QUFFbEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsNkRBQTZELGFBQWE7QUFDMUU7QUFDQTs7QUFFQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7O0FDbEVBO0FBQ21CO0FBQ25COztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQSxpSEFBZ0Qsa0JBQWtCO0FBQ2xFLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjLFFBQVE7QUFDdEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7O0FDekZBO0FBQ2dCOztBQUVoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7O0FDeEJBO0FBQ3FFO0FBQ3BDO0FBQ0g7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7O0FDdENBO0FBQzBCO0FBQ0k7QUFDSDs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7OztBQ2pDQTtBQUNBO0FBQ0E7QUFFZSxNQUFNQyxXQUFOLFNBQTBCLGlGQUExQixDQUF5QztBQUN0RCxhQUFXdkQsRUFBWCxHQUFnQjtBQUNkLFdBQU8sY0FBUDtBQUNEOztBQUVELGFBQVdxQixRQUFYLEdBQXNCO0FBQ3BCLFdBQU8saURBQVA7QUFDRDs7QUFFRG1DLHNCQUFvQjtBQUNsQixVQUFNQSxpQkFBTjtBQUNBLFFBQUlDLFNBQVMsS0FBSy9CLFVBQUwsQ0FBZ0JNLGFBQWhCLENBQThCLHFCQUE5QixDQUFiO0FBQ0Q7O0FBRUQwQixjQUFZO0FBQ1YsUUFBSUQsU0FBUyxLQUFLL0IsVUFBTCxDQUFnQk0sYUFBaEIsQ0FBOEIscUJBQTlCLENBQWI7QUFDQXlCLFdBQU9FLE9BQVAsR0FBaUIsSUFBakI7QUFDRDs7QUFFREMsaUJBQWU7QUFDYixRQUFJSCxTQUFTLEtBQUsvQixVQUFMLENBQWdCTSxhQUFoQixDQUE4QixxQkFBOUIsQ0FBYjtBQUNBeUIsV0FBT0UsT0FBUCxHQUFpQixJQUFqQjtBQUNEOztBQUVERSxpQkFBZXJDLFFBQWYsRUFBeUI7QUFDdkIsUUFBSWlDLFNBQVMsS0FBSy9CLFVBQUwsQ0FBZ0JNLGFBQWhCLENBQThCLHFCQUE5QixDQUFiO0FBQ0F5QixXQUFPdkIsZ0JBQVAsQ0FBd0IsYUFBeEIsRUFBdUMsTUFBTTtBQUMzQyxVQUFJdUIsT0FBT0UsT0FBWCxFQUFvQjtBQUNsQm5DO0FBQ0Q7QUFDRixLQUpEO0FBS0Q7O0FBRURzQyxvQkFBa0J0QyxRQUFsQixFQUE0QjtBQUMxQixRQUFJaUMsU0FBUyxLQUFLL0IsVUFBTCxDQUFnQk0sYUFBaEIsQ0FBOEIscUJBQTlCLENBQWI7QUFDQXlCLFdBQU92QixnQkFBUCxDQUF3QixhQUF4QixFQUF1QyxNQUFNO0FBQzNDLFVBQUksQ0FBRXVCLE9BQU9FLE9BQWIsRUFBc0I7QUFDcEJuQztBQUNEO0FBQ0YsS0FKRDtBQUtEOztBQXhDcUQsQzs7Q0EyQ3hEOztBQUNBeUIsZUFBZUMsTUFBZixDQUFzQkssWUFBWXZELEVBQWxDLEVBQXNDdUQsV0FBdEMsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoREE7QUFDQTs7QUFFQSxTQUFTUSx1QkFBVCxDQUFpQ0MsS0FBakMsRUFBd0M7QUFDdEM7QUFDQUEsUUFBTUMsZUFBTjtBQUNBRCxRQUFNRSxjQUFOO0FBRUEsTUFBSTNELFlBQVl5RCxNQUFNNUIsTUFBTixDQUFhK0IsT0FBYixDQUFxQixVQUFyQixDQUFoQjs7QUFDQSxNQUFJNUQsU0FBSixFQUFlO0FBQ2IsUUFBSTZELGdCQUFnQjdELFVBQVV5QixhQUFWLENBQXdCLGdCQUF4QixDQUFwQjs7QUFDQSxRQUFJb0MsYUFBSixFQUFtQjtBQUNqQixVQUFJakUsT0FBT2lFLGNBQWNDLFlBQWQsQ0FBMkIsTUFBM0IsQ0FBWDs7QUFFQSxVQUFJRCxhQUFKLEVBQW1CO0FBQ2pCRSxpQkFBU3RCLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDZSx1QkFBdEM7QUFFQUssc0JBQWM3QyxVQUFkLENBQXlCLFlBQVc7QUFDbEMrQyxtQkFBU3BDLGdCQUFULENBQTBCLE9BQTFCLEVBQW1DNkIsdUJBQW5DLEVBRGtDLENBR2xDOztBQUNBUSxpQkFBT0MsUUFBUCxDQUFnQkMsTUFBaEI7QUFDRCxTQUxEO0FBTUQ7QUFDRjtBQUNGO0FBQ0Y7O0FBQUE7O0FBRUQsU0FBU0MsYUFBVCxHQUF5QjtBQUN2QkosV0FBU3BDLGdCQUFULENBQTBCLE9BQTFCLEVBQW1DNkIsdUJBQW5DO0FBQ0FPLFdBQVM5RixJQUFULENBQWM2RCxTQUFkLENBQXdCc0MsR0FBeEIsQ0FBNEIsTUFBNUI7QUFDQUosU0FBT0ssY0FBUCxDQUFzQkMsT0FBdEIsQ0FBOEIsY0FBOUIsRUFBOEMsTUFBOUM7QUFDRDs7QUFFRCxTQUFTQyxnQkFBVCxHQUE0QjtBQUMxQlIsV0FBU3RCLG1CQUFULENBQTZCLE9BQTdCLEVBQXNDZSx1QkFBdEM7QUFDQU8sV0FBUzlGLElBQVQsQ0FBYzZELFNBQWQsQ0FBd0IwQyxNQUF4QixDQUErQixNQUEvQjtBQUNBUixTQUFPSyxjQUFQLENBQXNCQyxPQUF0QixDQUE4QixjQUE5QixFQUE4QyxTQUE5QztBQUNEOztBQUVEUCxTQUFTcEMsZ0JBQVQsQ0FBMEIsa0JBQTFCLEVBQStDOEIsS0FBRCxJQUFXO0FBQ3ZELE1BQUlNLFNBQVM5RixJQUFULENBQWM2RCxTQUFkLENBQXdCQyxRQUF4QixDQUFpQyxNQUFqQyxDQUFKLEVBQThDO0FBQzVDLFFBQUkwQyxvQkFBb0JWLFNBQVN0QyxhQUFULENBQXVCLGNBQXZCLENBQXhCO0FBQ0FnRCxzQkFBa0JuQixjQUFsQixDQUFpQ2EsYUFBakM7QUFDQU0sc0JBQWtCbEIsaUJBQWxCLENBQW9DZ0IsZ0JBQXBDO0FBRUEsUUFBSWxELE9BQU8yQyxPQUFPSyxjQUFQLENBQXNCSyxPQUF0QixDQUE4QixjQUE5QixDQUFYOztBQUVBLFFBQUlyRCxTQUFTLE1BQWIsRUFBcUI7QUFDbkJvRCx3QkFBa0J0QixTQUFsQjtBQUNELEtBRkQsTUFFTztBQUNMb0I7QUFDRDtBQUNGO0FBQ0YsQ0FkRCxFOzs7Ozs7Ozs7Ozs7QUN4Q0E7QUFDd0I7QUFDeEI7QUFDb0I7O0FBRXBCOztBQUVBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBLE9BQU87QUFDUCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLEdBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsRUFBRTtBQUNqQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixnQkFBZ0IsRUFBRTtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLGdGQUFnRixNQUFNO0FBQ3RGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUywwQ0FBMEM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsa0JBQWtCO0FBQ3ZDO0FBQ0E7QUFDQSxXQUFXO0FBQ1gscUJBQXFCLGtCQUFrQjtBQUN2Qyx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxFQUFFO0FBQ2pCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsRUFBRTtBQUNqQixlQUFlLEVBQUU7QUFDakIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7QUN0a0JEO0FBQ3dCOztBQUV4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLEdBQUc7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsNEJBQTRCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLE9BQU87QUFDakMsMkJBQTJCLE9BQU87QUFDbEMsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0EsOEJBQThCLE9BQU87QUFDckM7QUFDQTtBQUNBLDRCQUE0QixPQUFPO0FBQ25DLDZCQUE2QixPQUFPO0FBQ3BDLDJCQUEyQixPQUFPO0FBQ2xDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFCQUFxQjtBQUNwQyxlQUFlLGNBQWM7QUFDN0I7QUFDQSxnQkFBZ0IsY0FBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsYUFBYTtBQUN6RTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsY0FBYztBQUM3QixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxLQUFLO0FBQ3BCLGVBQWUsY0FBYztBQUM3QixlQUFlLFVBQVU7QUFDekI7QUFDQTtBQUNBLHlEQUF5RCxNQUFNO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSwwRUFBMEUsVUFBVTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGVBQWUsYUFBYTtBQUM1QjtBQUNBLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGFBQWE7QUFDNUIsZUFBZSxTQUFTO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGNBQWM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBLG9DQUFvQyw0QkFBNEI7QUFDaEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDZCQUE2QjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlCQUFpQjtBQUN6Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsT0FBTztBQUN0QixlQUFlLEdBQUc7QUFDbEI7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEtBQUs7QUFDcEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7OztBQ25jRDtBQUNzQztBQUNSO0FBQzlCO0FBQ2tCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FDeENEO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDZ0M7QUFDaEM7QUFDQTtBQUNzRDtBQUN5QjtBQUN0Qzs7QUFFekMsWUFBWSxVQUFVO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQSxlQUFlLCtCQUErQjtBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkJBQTJCO0FBQ2hELHFDQUFxQyxZQUFZO0FBQ2pEO0FBQ0EsS0FBSztBQUNMO0FBQ0EscUJBQXFCLHFCQUFxQjtBQUMxQyxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUc7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixpQkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLGFBQWE7QUFDNUIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQzs7Ozs7Ozs7OztBQ2pNQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFMkY7QUFDM0Q7QUFDWjtBQUNxQjs7QUFFekMsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0EsV0FBVyxZQUFZLEtBQUssYUFBYSxvQkFBb0IsZUFBZTtBQUM1RTtBQUNBO0FBQ0EsZUFBZSxnQ0FBZ0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsZUFBZTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHFCQUFxQjtBQUNsQyxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxnQkFBZ0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBLGVBQWUsTUFBTTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0IsRUFBRSxZQUFZLEVBQUUsZUFBZTtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUIsU0FBUyxnQkFBZ0IsU0FBUyxJQUFJLG9CQUFvQjtBQUNuRztBQUNBLGtDQUFrQztBQUNsQztBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qjs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGNBQWM7QUFDZDtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQSwwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTztBQUN4QztBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixhQUFhLEVBQUUsY0FBYyxFQUFFLEVBQUUsSUFBSSxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFdBQVcsRUFBRSxPQUFPO0FBQ3RDO0FBQ0EsY0FBYyxPQUFPLEVBQUUsV0FBVyxLQUFLO0FBQ3ZDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBLEdBQUc7QUFDSCxjQUFjLGtCQUFrQjtBQUNoQztBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELG9FOzs7Ozs7OztBQzVkQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxXQUFXLGFBQWE7QUFDeEI7O0FBRUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsa0JBQWtCO0FBQzdCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7Ozs7OztBQ3ZDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ3lDOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxPQUFPO0FBQ25COztBQUVBLFlBQVksT0FBTztBQUNuQjs7QUFFQSxZQUFZLE9BQU87QUFDbkI7O0FBRUE7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsb0JBQW9CO0FBQy9CLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsT0FBTztBQUNsQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG9CQUFvQjtBQUMvQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvQkFBb0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEM7Ozs7Ozs7OztBQ3BKQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QixnQkFBZ0I7QUFDeEM7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7QUNyRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7Ozs7Ozs7Ozs7OztBQ1JBO0FBQzJCO0FBQ1A7O0FBRXBCO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw0QkFBNEI7QUFDekMsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnQkFBZ0IsMEJBQTBCLGNBQWM7QUFDaEYsS0FBSztBQUNMO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCLDBCQUEwQixjQUFjO0FBQ3BGLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLEtBQUs7QUFDbEIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUJBQWlCO0FBQ2hDO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLDREQUE0RCxnQkFBZ0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQsc0JBQXNCLDRDQUE0QztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQ0FBc0M7QUFDMUQseUJBQXlCLDRCQUE0QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIscUJBQXFCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixxQkFBcUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVROzs7Ozs7Ozs7OztBQzNPcUI7QUFDVDs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCLFdBQVcsdUNBQXVDO0FBQ2xELFlBQVksMEJBQTBCO0FBQ3RDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFlBQVk7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDRCQUE0QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsT0FBTztBQUNsQixXQUFXLE9BQU87QUFDbEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsYUFBYTtBQUN4QixXQUFXLDBCQUEwQjtBQUNyQyxZQUFZLDBCQUEwQjtBQUN0QyxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVROzs7Ozs7Ozs7O0FDbFE2RDs7QUFFckUsOEdBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxrQkFBa0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGNBQWMscUJBQXFCO0FBQ25DO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVE7Ozs7Ozs7Ozs7Ozs7O0FDdklSO0FBQzBCO0FBQ0k7QUFDRTs7QUFFaEM7QUFDQTtBQUNBLGFBQWE7QUFDYixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1DQUFtQyx5QkFBeUI7O0FBRTVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQkFBb0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9CQUFvQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsR0FBRztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBOztBQUVROzs7Ozs7Ozs7Ozs7Ozs7O0FDbEhVO0FBQ21EO0FBQ2pEO0FBQ2M7QUFDSjtBQUNEO0FBQ0E7O0FBRTdCLDhHQUFrRDs7QUFFbEQ7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxXQUFXO0FBQ3JELG9DQUFvQyxZQUFZO0FBQ2hELG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0QkFBNEI7QUFDNUMsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0EsbUJBQW1CLHFCQUFxQjs7QUFFeEMseUJBQXlCLGFBQWE7O0FBRXRDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJCQUEyQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixtQkFBbUIsT0FBTztBQUMxQixtQkFBbUIsRUFBRTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsK0JBQStCO0FBQzVEO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLE9BQU87QUFDMUIsbUJBQW1CLEVBQUU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQXNELEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdEQUF3RCxFQUFFO0FBQzVFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QyxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxlQUFlO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsMkJBQTJCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxZQUFZO0FBQ3pCLGNBQWMsRUFBRTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsY0FBYyxFQUFFO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QixjQUFjLHFCQUFxQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVROzs7Ozs7Ozs7Ozs7Ozs7QUM1cUJVO0FBQ0c7QUFDRDtBQUNjO0FBQ2Q7QUFDSzs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUM7QUFDakM7QUFDQSxtQkFBbUIsaUJBQWlCOztBQUVwQyx5QkFBeUIsYUFBYTs7QUFFdEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsV0FBVztBQUNYLGtDQUFrQyxnQkFBZ0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsT0FBTztBQUM1QixxQkFBcUIsRUFBRTtBQUN2QixvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw0QkFBNEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVROzs7Ozs7Ozs7Ozs7OztBQ2hRVTtBQUNNO0FBQ0c7QUFDSjs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZixrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHFCQUFxQixnQkFBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakIsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxDQUFDOztBQUVPOztBQUVSO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxXQUFXO0FBQ3ZFLG9DQUFvQyxZQUFZO0FBQ2hELG1DQUFtQyxXQUFXO0FBQzlDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXLGNBQWMsVUFBVTtBQUNqRjtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQsb0NBQW9DLFlBQVk7QUFDaEQsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEMsWUFBWSxnQ0FBZ0M7QUFDNUM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQSxtQkFBbUIseUJBQXlCO0FBQzVDO0FBQ0E7QUFDUTs7Ozs7Ozs7Ozs7QUN2WlI7QUFDeUI7O0FBRXpCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ1E7Ozs7Ozs7Ozs7QUN0RlI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDc0Q7QUFDYjs7QUFFekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQkFBb0I7QUFDbkMsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLEtBQUs7O0FBRUw7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsT0FBTztBQUN0QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDREOzs7Ozs7OztBQ2hFc0I7O0FBRXRCO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2YsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxFQUFFO0FBQ2YsYUFBYSxFQUFFO0FBQ2YsY0FBYyxRQUFRO0FBQ3RCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOzs7Ozs7Ozs7O0FDakVBO0FBQ2lDOztBQUVqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0EsbUJBQW1CLDBCQUEwQjtBQUM3QztBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0RBQWtELGVBQWU7QUFDakU7QUFDQTs7QUFFQTs7QUFFQSxtQkFBbUIsMEJBQTBCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELGVBQWU7QUFDckU7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7OztBQzdHQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLDRCQUE0QjtBQUM3RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBOzs7Ozs7Ozs7OztBQ2xJQTtBQUM4QjtBQUNoQjs7QUFFZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLE9BQU87QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7O0FDL0ZBO0FBQzBCO0FBQ007QUFDSDtBQUNFO0FBQ2pCOztBQUVkOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsaUVBQWlFLGlCQUFpQjtBQUNsRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQUE7QUFBQTs7QUFFQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7QUM3aUJBO0FBQ2M7O0FBRWQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUwsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7O0FBR0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixzQkFBc0I7QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQUE7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RDtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ05BO0FBQ0E7QUFDdUQ7QUFDdkQ7QUFDa0I7QUFDbEI7QUFDQSx5REFBeUQ7O0FBRXpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBLENBQUM7Ozs7Ozs7Ozs7OztBQ3BJRDtBQUMrQztBQUNqQjtBQUNIOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGVBQWU7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7OztBQ25GQTtBQUMrQjtBQUNqQjtBQUNJOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFlBQVk7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUgsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DQUFvQyxhQUFhO0FBQ2pEO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtB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O0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxDQUFDOzs7Ozs7Ozs7Ozs7O0FDN0tEO0FBQzRCO0FBQ007QUFDaEI7QUFDSjtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQ0FBcUMsaUJBQWlCO0FBQ3RELEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7O0FBRW5EO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvQ0FBb0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hELEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7OztBQ3hSRDtBQUMrQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFBQTtBQUFBOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7O0FDdEVBO0FBQytCOztBQUUvQjtBQUNBO0FBQ0EsWUFBWSxtREFBbUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVROztBQUVSOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUN0SkQ7QUFDK0I7QUFDSjtBQUNUO0FBQ0o7QUFDZDtBQUFBO0FBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLGFBQWEsWUFBWTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTs7Ozs7Ozs7Ozs7O0FDMWhCQTtBQUNBO0FBQ2tDO0FBQ2hCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7O0FDbEVEO0FBQ0E7QUFDQTtBQUNBO0FBQ2tCO0FBQ1E7QUFDWjtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEZBQThGOztBQUU5RjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EseUJBQXlCLHNCQUFzQjtBQUMvQztBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0EsOEJBQThCLDZCQUE2QjtBQUMzRDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7Ozs7Ozs7Ozs7O0FDeGpCRDtBQUNBO0FBQ0E7QUFDa0M7QUFDaEI7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7O0FDNUREO0FBQ0E7QUFDc0M7QUFDcEI7QUFDUTtBQUNXO0FBQ3JDO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOzs7Ozs7Ozs7OztBQ2xSRDtBQUNrQztBQUNBOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ3NDO0FBQ3BCO0FBQ1E7QUFDRDtBQUNLO0FBQzlCO0FBQ0EseURBQXlEOztBQUV6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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RDs7QUFFRHBCLGdCQUFjO0FBQ1o7QUFDRDs7QUFFRCxhQUFXQyxVQUFYLEdBQXdCO0FBQ3RCLFdBQU87QUFDTDBGLFlBQU07QUFDRnhGLGNBQU1DO0FBREosT0FERDtBQUlMd0YsYUFBTztBQUNIekYsY0FBTTBGO0FBREg7QUFKRixLQUFQO0FBUUQ7O0FBdEIyRCxDOztDQXlCOUQ7O0FBQ0E3QyxlQUFlQyxNQUFmLENBQXNCeUMsa0JBQWtCM0YsRUFBeEMsRUFBNEMyRixpQkFBNUMsRTs7Ozs7O0FDN0JBLGlDQUFpQyw0QkFBNEIsS0FBSyw2RyIsImZpbGUiOiIzZDhlODQ5Y2QzMGY5YTVmYjhkZC5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDUxKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAzZDhlODQ5Y2QzMGY5YTVmYjhkZCIsImltcG9ydCB7IExlZ2FjeUVsZW1lbnRNaXhpbiB9IGZyb20gJy4vbGliL2xlZ2FjeS9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyc7XG5pbXBvcnQgJy4vbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCAnLi9saWIvbGVnYWN5L3RlbXBsYXRpemVyLWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvZG9tLWJpbmQuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9kb20tcmVwZWF0LmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvZG9tLWlmLmpzJztcbmltcG9ydCAnLi9saWIvZWxlbWVudHMvYXJyYXktc2VsZWN0b3IuanMnO1xuaW1wb3J0ICcuL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuanMnO1xuaW1wb3J0ICcuL2xpYi9sZWdhY3kvbXV0YWJsZS1kYXRhLWJlaGF2aW9yLmpzJztcbmV4cG9ydCBjb25zdCBCYXNlID0gTGVnYWN5RWxlbWVudE1peGluKEhUTUxFbGVtZW50KS5wcm90b3R5cGU7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL3BvbHltZXIuanNcbi8vIG1vZHVsZSBpZCA9IDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwid2luZG93LkpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkgPSBmdW5jdGlvbihwcm9wLCBvYmopIHsgcmV0dXJuIHByb3A7IH1cblxuLyoqIEBuYW1lc3BhY2UgKi9cbmxldCBQb2x5bWVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYm9vdC5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0ICcuLi91dGlscy9zZXR0aW5ncy5qcyc7XG5pbXBvcnQgeyBGbGF0dGVuZWROb2Rlc09ic2VydmVyIH0gZnJvbSAnLi4vdXRpbHMvZmxhdHRlbmVkLW5vZGVzLW9ic2VydmVyLmpzJztcbmltcG9ydCB7IGZsdXNoIGFzIGZsdXNoJDAsIGVucXVldWVEZWJvdW5jZXIgfSBmcm9tICcuLi91dGlscy9mbHVzaC5qcyc7XG5cbmNvbnN0IHAgPSBFbGVtZW50LnByb3RvdHlwZTtcbi8qKlxuICogQGNvbnN0IHtmdW5jdGlvbih0aGlzOkVsZW1lbnQsIHN0cmluZyk6IGJvb2xlYW59XG4gKi9cbmNvbnN0IG5vcm1hbGl6ZWRNYXRjaGVzU2VsZWN0b3IgPSBwLm1hdGNoZXMgfHwgcC5tYXRjaGVzU2VsZWN0b3IgfHxcbiAgcC5tb3pNYXRjaGVzU2VsZWN0b3IgfHwgcC5tc01hdGNoZXNTZWxlY3RvciB8fFxuICBwLm9NYXRjaGVzU2VsZWN0b3IgfHwgcC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbi8qKlxuICogQ3Jvc3MtcGxhdGZvcm0gYGVsZW1lbnQubWF0Y2hlc2Agc2hpbS5cbiAqXG4gKiBAZnVuY3Rpb24gbWF0Y2hlc1NlbGVjdG9yXG4gKiBAbWVtYmVyb2YgUG9seW1lci5kb21cbiAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGUgTm9kZSB0byBjaGVjayBzZWxlY3RvciBhZ2FpbnN0XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gbWF0Y2hcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbm9kZSBtYXRjaGVkIHNlbGVjdG9yXG4gKi9cbmNvbnN0IG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKG5vZGUsIHNlbGVjdG9yKSB7XG4gIHJldHVybiBub3JtYWxpemVkTWF0Y2hlc1NlbGVjdG9yLmNhbGwobm9kZSwgc2VsZWN0b3IpO1xufTtcblxuLyoqXG4gKiBOb2RlIEFQSSB3cmFwcGVyIGNsYXNzIHJldHVybmVkIGZyb20gYFBvbHltZXIuZG9tLih0YXJnZXQpYCB3aGVuXG4gKiBgdGFyZ2V0YCBpcyBhIGBOb2RlYC5cbiAqL1xuY2xhc3MgRG9tQXBpIHtcblxuICAvKipcbiAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgZm9yIHdoaWNoIHRvIGNyZWF0ZSBhIFBvbHltZXIuZG9tIGhlbHBlciBvYmplY3QuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIHRoYXRcbiAgICogbGlzdGVucyBmb3Igbm9kZSBjaGFuZ2VzIG9uIHRoaXMgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIHdoZW4gZGlyZWN0IG9yIGRpc3RyaWJ1dGVkIGNoaWxkcmVuXG4gICAqICAgb2YgdGhpcyBlbGVtZW50IGNoYW5nZXNcbiAgICogQHJldHVybiB7UG9seW1lci5GbGF0dGVuZWROb2Rlc09ic2VydmVyfSBPYnNlcnZlciBpbnN0YW5jZVxuICAgKi9cbiAgb2JzZXJ2ZU5vZGVzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIG5ldyBGbGF0dGVuZWROb2Rlc09ic2VydmVyKHRoaXMubm9kZSwgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc2Nvbm5lY3RzIGFuIG9ic2VydmVyIHByZXZpb3VzbHkgY3JlYXRlZCB2aWEgYG9ic2VydmVOb2Rlc2BcbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyLkZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJ9IG9ic2VydmVySGFuZGxlIE9ic2VydmVyIGluc3RhbmNlXG4gICAqICAgdG8gZGlzY29ubmVjdC5cbiAgICovXG4gIHVub2JzZXJ2ZU5vZGVzKG9ic2VydmVySGFuZGxlKSB7XG4gICAgb2JzZXJ2ZXJIYW5kbGUuZGlzY29ubmVjdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVkIGFzIGEgYmFja3dhcmRzLWNvbXBhdGlibGUgQVBJIG9ubHkuICBUaGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqL1xuICBub3RpZnlPYnNlcnZlcigpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvdmlkZWQgbm9kZSBpcyBjb250YWluZWQgd2l0aCB0aGlzIGVsZW1lbnQnc1xuICAgKiBsaWdodC1ET00gY2hpbGRyZW4gb3Igc2hhZG93IHJvb3QsIGluY2x1ZGluZyBhbnkgbmVzdGVkIHNoYWRvdyByb290c1xuICAgKiBvZiBjaGlsZHJlbiB0aGVyZWluLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byB0ZXN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGNvbnRhaW5lZCB3aXRoaW5cbiAgICogICB0aGlzIGVsZW1lbnQncyBsaWdodCBvciBzaGFkb3cgRE9NLlxuICAgKi9cbiAgZGVlcENvbnRhaW5zKG5vZGUpIHtcbiAgICBpZiAodGhpcy5ub2RlLmNvbnRhaW5zKG5vZGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG4gPSBub2RlO1xuICAgIGxldCBkb2MgPSBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gd2FsayBmcm9tIG5vZGUgdG8gYHRoaXNgIG9yIGBkb2N1bWVudGBcbiAgICB3aGlsZSAobiAmJiBuICE9PSBkb2MgJiYgbiAhPT0gdGhpcy5ub2RlKSB7XG4gICAgICAvLyB1c2UgbG9naWNhbCBwYXJlbnRub2RlLCBvciBuYXRpdmUgU2hhZG93Um9vdCBob3N0XG4gICAgICBuID0gbi5wYXJlbnROb2RlIHx8IG4uaG9zdDtcbiAgICB9XG4gICAgcmV0dXJuIG4gPT09IHRoaXMubm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByb290IG5vZGUgb2YgdGhpcyBub2RlLiAgRXF1aXZhbGVudCB0byBgZ2V0Um9vZE5vZGUoKWAuXG4gICAqXG4gICAqIEByZXR1cm4ge05vZGV9IFRvcCBtb3N0IGVsZW1lbnQgaW4gdGhlIGRvbSB0cmVlIGluIHdoaWNoIHRoZSBub2RlXG4gICAqIGV4aXN0cy4gSWYgdGhlIG5vZGUgaXMgY29ubmVjdGVkIHRvIGEgZG9jdW1lbnQgdGhpcyBpcyBlaXRoZXIgYVxuICAgKiBzaGFkb3dSb290IG9yIHRoZSBkb2N1bWVudDsgb3RoZXJ3aXNlLCBpdCBtYXkgYmUgdGhlIG5vZGVcbiAgICogaXRzZWxmIG9yIGEgbm9kZSBvciBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIGl0LlxuICAgKi9cbiAgZ2V0T3duZXJSb290KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3Igc2xvdCBlbGVtZW50cywgcmV0dXJucyB0aGUgbm9kZXMgYXNzaWduZWQgdG8gdGhlIHNsb3Q7IG90aGVyd2lzZVxuICAgKiBhbiBlbXB0eSBhcnJheS4gSXQgaXMgZXF1aXZhbGVudCB0byBgPHNsb3Q+LmFkZGlnbmVkTm9kZXMoe2ZsYXR0ZW46dHJ1ZX0pYC5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IEFycmF5IG9mIGFzc2lnbmVkIG5vZGVzXG4gICAqL1xuICBnZXREaXN0cmlidXRlZE5vZGVzKCkge1xuICAgIHJldHVybiAodGhpcy5ub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSA/XG4gICAgICB0aGlzLm5vZGUuYXNzaWduZWROb2Rlcyh7ZmxhdHRlbjogdHJ1ZX0pIDpcbiAgICAgIFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgb2YgYWxsIHNsb3RzIHRoaXMgZWxlbWVudCB3YXMgZGlzdHJpYnV0ZWQgdG8uXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PEhUTUxTbG90RWxlbWVudD59IERlc2NyaXB0aW9uXG4gICAqL1xuICBnZXREZXN0aW5hdGlvbkluc2VydGlvblBvaW50cygpIHtcbiAgICBsZXQgaXAkID0gW107XG4gICAgbGV0IG4gPSB0aGlzLm5vZGUuYXNzaWduZWRTbG90O1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpcCQucHVzaChuKTtcbiAgICAgIG4gPSBuLmFzc2lnbmVkU2xvdDtcbiAgICB9XG4gICAgcmV0dXJuIGlwJDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxscyBgaW1wb3J0Tm9kZWAgb24gdGhlIGBvd25lckRvY3VtZW50YCBmb3IgdGhpcyBub2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBpbXBvcnRcbiAgICogQHBhcmFtIHtib29sZWFufSBkZWVwIFRydWUgaWYgdGhlIG5vZGUgc2hvdWxkIGJlIGNsb25lZCBkZWVwbHkgZHVyaW5nXG4gICAqICAgaW1wb3J0XG4gICAqIEByZXR1cm4ge05vZGV9IENsb25lIG9mIGdpdmVuIG5vZGUgaW1wb3J0ZWQgdG8gdGhpcyBvd25lciBkb2N1bWVudFxuICAgKi9cbiAgaW1wb3J0Tm9kZShub2RlLCBkZWVwKSB7XG4gICAgbGV0IGRvYyA9IHRoaXMubm9kZSBpbnN0YW5jZW9mIERvY3VtZW50ID8gdGhpcy5ub2RlIDpcbiAgICAgIHRoaXMubm9kZS5vd25lckRvY3VtZW50O1xuICAgIHJldHVybiBkb2MuaW1wb3J0Tm9kZShub2RlLCBkZWVwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gUmV0dXJucyBhIGZsYXR0ZW5lZCBsaXN0IG9mIGFsbCBjaGlsZCBub2RlcyBhbmQgbm9kZXMgYXNzaWduZWRcbiAgICogdG8gY2hpbGQgc2xvdHMuXG4gICAqL1xuICBnZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCkge1xuICAgIHJldHVybiBGbGF0dGVuZWROb2Rlc09ic2VydmVyLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMubm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGZpbHRlcmVkIGxpc3Qgb2YgZmxhdHRlbmVkIGNoaWxkIGVsZW1lbnRzIGZvciB0aGlzIGVsZW1lbnQgYmFzZWRcbiAgICogb24gdGhlIGdpdmVuIHNlbGVjdG9yLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gZmlsdGVyIG5vZGVzIGFnYWluc3RcbiAgICogQHJldHVybiB7QXJyYXk8SFRNTEVsZW1lbnQ+fSBMaXN0IG9mIGZsYXR0ZW5lZCBjaGlsZCBlbGVtZW50c1xuICAgKi9cbiAgcXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgbGV0IGMkID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgbGV0IGxpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpPTAsIGw9YyQubGVuZ3RoLCBjOyAoaTxsKSAmJiAoYz1jJFtpXSk7IGkrKykge1xuICAgICAgaWYgKChjLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkgJiZcbiAgICAgICAgICBtYXRjaGVzU2VsZWN0b3IoYywgc2VsZWN0b3IpKSB7XG4gICAgICAgIGxpc3QucHVzaChjKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cblxuICAvKipcbiAgICogRm9yIHNoYWRvdyByb290cywgcmV0dXJucyB0aGUgY3VycmVudGx5IGZvY3VzZWQgZWxlbWVudCB3aXRoaW4gdGhpc1xuICAgKiBzaGFkb3cgcm9vdC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZXx1bmRlZmluZWR9IEN1cnJlbnRseSBmb2N1c2VkIGVsZW1lbnRcbiAgICovXG4gIGdldCBhY3RpdmVFbGVtZW50KCkge1xuICAgIGxldCBub2RlID0gdGhpcy5ub2RlO1xuICAgIHJldHVybiBub2RlLl9hY3RpdmVFbGVtZW50ICE9PSB1bmRlZmluZWQgPyBub2RlLl9hY3RpdmVFbGVtZW50IDogbm9kZS5hY3RpdmVFbGVtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRNZXRob2RzKHByb3RvLCBtZXRob2RzKSB7XG4gIGZvciAobGV0IGk9MDsgaSA8IG1ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbWV0aG9kID0gbWV0aG9kc1tpXTtcbiAgICBwcm90b1ttZXRob2RdID0gLyoqIEB0aGlzIHtEb21BcGl9ICovIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9kZVttZXRob2RdLmFwcGx5KHRoaXMubm9kZSwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZvcndhcmRSZWFkT25seVByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICB9LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yd2FyZFByb3BlcnRpZXMocHJvdG8sIHByb3BlcnRpZXMpIHtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgIGxldCBuYW1lID0gcHJvcGVydGllc1tpXTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIG5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV07XG4gICAgICB9LFxuICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAvKiogQHR5cGUge0RvbUFwaX0gKi8gKHRoaXMpLm5vZGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mb3J3YXJkTWV0aG9kcyhEb21BcGkucHJvdG90eXBlLCBbXG4gICdjbG9uZU5vZGUnLCAnYXBwZW5kQ2hpbGQnLCAnaW5zZXJ0QmVmb3JlJywgJ3JlbW92ZUNoaWxkJyxcbiAgJ3JlcGxhY2VDaGlsZCcsICdzZXRBdHRyaWJ1dGUnLCAncmVtb3ZlQXR0cmlidXRlJyxcbiAgJ3F1ZXJ5U2VsZWN0b3InLCAncXVlcnlTZWxlY3RvckFsbCdcbl0pO1xuXG5mb3J3YXJkUmVhZE9ubHlQcm9wZXJ0aWVzKERvbUFwaS5wcm90b3R5cGUsIFtcbiAgJ3BhcmVudE5vZGUnLCAnZmlyc3RDaGlsZCcsICdsYXN0Q2hpbGQnLFxuICAnbmV4dFNpYmxpbmcnLCAncHJldmlvdXNTaWJsaW5nJywgJ2ZpcnN0RWxlbWVudENoaWxkJyxcbiAgJ2xhc3RFbGVtZW50Q2hpbGQnLCAnbmV4dEVsZW1lbnRTaWJsaW5nJywgJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnLFxuICAnY2hpbGROb2RlcycsICdjaGlsZHJlbicsICdjbGFzc0xpc3QnXG5dKTtcblxuZm9yd2FyZFByb3BlcnRpZXMoRG9tQXBpLnByb3RvdHlwZSwgW1xuICAndGV4dENvbnRlbnQnLCAnaW5uZXJIVE1MJ1xuXSk7XG5cblxuLyoqXG4gKiBFdmVudCBBUEkgd3JhcHBlciBjbGFzcyByZXR1cm5lZCBmcm9tIGBQb2x5bWVyLmRvbS4odGFyZ2V0KWAgd2hlblxuICogYHRhcmdldGAgaXMgYW4gYEV2ZW50YC5cbiAqL1xuY2xhc3MgRXZlbnRBcGkge1xuICBjb25zdHJ1Y3RvcihldmVudCkge1xuICAgIHRoaXMuZXZlbnQgPSBldmVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmaXJzdCBub2RlIG9uIHRoZSBgY29tcG9zZWRQYXRoYCBvZiB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtOb2RlfSBUaGUgbm9kZSB0aGlzIGV2ZW50IHdhcyBkaXNwYXRjaGVkIHRvXG4gICAqL1xuICBnZXQgcm9vdFRhcmdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5ldmVudC5jb21wb3NlZFBhdGgoKVswXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsb2NhbCAocmUtdGFyZ2V0ZWQpIHRhcmdldCBmb3IgdGhpcyBldmVudC5cbiAgICpcbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIGxvY2FsIChyZS10YXJnZXRlZCkgdGFyZ2V0IGZvciB0aGlzIGV2ZW50LlxuICAgKi9cbiAgZ2V0IGxvY2FsVGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50LnRhcmdldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgY29tcG9zZWRQYXRoYCBmb3IgdGhpcyBldmVudC5cbiAgICovXG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLmV2ZW50LmNvbXBvc2VkUGF0aCgpO1xuICB9XG59XG5cbmV4cG9ydCB7IERvbUFwaSB9O1xuXG5leHBvcnQgY29uc3QgZG9tID0gZnVuY3Rpb24ob2JqKSB7XG4gIG9iaiA9IG9iaiB8fCBkb2N1bWVudDtcbiAgaWYgKCFvYmouX19kb21BcGkpIHtcbiAgICBsZXQgaGVscGVyO1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBFdmVudCkge1xuICAgICAgaGVscGVyID0gbmV3IEV2ZW50QXBpKG9iaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlbHBlciA9IG5ldyBEb21BcGkob2JqKTtcbiAgICB9XG4gICAgb2JqLl9fZG9tQXBpID0gaGVscGVyO1xuICB9XG4gIHJldHVybiBvYmouX19kb21BcGk7XG59O1xuXG5leHBvcnQgeyBtYXRjaGVzU2VsZWN0b3IgfTtcbmV4cG9ydCB7IGZsdXNoJDAgYXMgZmx1c2ggfTtcbmV4cG9ydCB7IGVucXVldWVEZWJvdW5jZXIgYXMgYWRkRGVib3VuY2VyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ2xhc3MgfSBmcm9tICcuL2NsYXNzLmpzJztcblxuZXhwb3J0IGNvbnN0IFBvbHltZXIgPSBmdW5jdGlvbihpbmZvKSB7XG4gIC8vIGlmIGlucHV0IGlzIGEgYGNsYXNzYCAoYWthIGEgZnVuY3Rpb24gd2l0aCBhIHByb3RvdHlwZSksIHVzZSB0aGUgcHJvdG90eXBlXG4gIC8vIHJlbWVtYmVyIHRoYXQgdGhlIGBjb25zdHJ1Y3RvcmAgd2lsbCBuZXZlciBiZSBjYWxsZWRcbiAgbGV0IGtsYXNzO1xuICBpZiAodHlwZW9mIGluZm8gPT09ICdmdW5jdGlvbicpIHtcbiAgICBrbGFzcyA9IGluZm87XG4gIH0gZWxzZSB7XG4gICAga2xhc3MgPSBDbGFzcyhpbmZvKTtcbiAgfVxuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoa2xhc3MuaXMsIC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyhrbGFzcykpO1xuICByZXR1cm4ga2xhc3M7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgRWxlbWVudE1peGluIH0gZnJvbSAnLi9saWIvbWl4aW5zL2VsZW1lbnQtbWl4aW4uanMnO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgdGhhdCBwcm92aWRlcyB0aGUgY29yZSBBUEkgZm9yIFBvbHltZXIncyBtZXRhLXByb2dyYW1taW5nXG4gKiBmZWF0dXJlcyBpbmNsdWRpbmcgdGVtcGxhdGUgc3RhbXBpbmcsIGRhdGEtYmluZGluZywgYXR0cmlidXRlIGRlc2VyaWFsaXphdGlvbixcbiAqIGFuZCBwcm9wZXJ0eSBjaGFuZ2Ugb2JzZXJ2YXRpb24uXG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBwb2x5bWVyXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9FbGVtZW50TWl4aW59XG4gKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLkVsZW1lbnRNaXhpblxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgYmFzZSBjbGFzcyB0aGF0IHByb3ZpZGVzIHRoZSBjb3JlIEFQSSBmb3IgUG9seW1lcidzXG4gKiAgIGtleSBtZXRhLXByb2dyYW1taW5nIGZlYXR1cmVzIGluY2x1ZGluZyB0ZW1wbGF0ZSBzdGFtcGluZywgZGF0YS1iaW5kaW5nLFxuICogICBhdHRyaWJ1dGUgZGVzZXJpYWxpemF0aW9uLCBhbmQgcHJvcGVydHkgY2hhbmdlIG9ic2VydmF0aW9uXG4gKi9cbmNvbnN0IEVsZW1lbnQgPSBFbGVtZW50TWl4aW4oSFRNTEVsZW1lbnQpO1xuZXhwb3J0IHsgRWxlbWVudCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG4vLyB1bmlxdWUgZ2xvYmFsIGlkIGZvciBkZWR1cGluZyBtaXhpbnMuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBNaXhpbkZ1bmN0aW9uKCl7fVxuLyoqIEB0eXBlIHsoV2Vha01hcCB8IHVuZGVmaW5lZCl9ICovXG5NaXhpbkZ1bmN0aW9uLnByb3RvdHlwZS5fX21peGluQXBwbGljYXRpb25zO1xuLyoqIEB0eXBlIHsoT2JqZWN0IHwgdW5kZWZpbmVkKX0gKi9cbk1peGluRnVuY3Rpb24ucHJvdG90eXBlLl9fbWl4aW5TZXQ7XG5cbmV4cG9ydCBjb25zdCBkZWR1cGluZ01peGluID0gZnVuY3Rpb24obWl4aW4pIHtcbiAgbGV0IG1peGluQXBwbGljYXRpb25zID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnM7XG4gIGlmICghbWl4aW5BcHBsaWNhdGlvbnMpIHtcbiAgICBtaXhpbkFwcGxpY2F0aW9ucyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8obWl4aW4pLl9fbWl4aW5BcHBsaWNhdGlvbnMgPSBtaXhpbkFwcGxpY2F0aW9ucztcbiAgfVxuICAvLyBtYWludGFpbiBhIHVuaXF1ZSBpZCBmb3IgZWFjaCBtaXhpblxuICBsZXQgbWl4aW5EZWR1cGVJZCA9IGRlZHVwZUlkKys7XG4gIGZ1bmN0aW9uIGRlZHVwaW5nTWl4aW4oYmFzZSkge1xuICAgIGxldCBiYXNlU2V0ID0gLyoqIEB0eXBlIHshTWl4aW5GdW5jdGlvbn0gKi8oYmFzZSkuX19taXhpblNldDtcbiAgICBpZiAoYmFzZVNldCAmJiBiYXNlU2V0W21peGluRGVkdXBlSWRdKSB7XG4gICAgICByZXR1cm4gYmFzZTtcbiAgICB9XG4gICAgbGV0IG1hcCA9IG1peGluQXBwbGljYXRpb25zO1xuICAgIGxldCBleHRlbmRlZCA9IG1hcC5nZXQoYmFzZSk7XG4gICAgaWYgKCFleHRlbmRlZCkge1xuICAgICAgZXh0ZW5kZWQgPSAvKiogQHR5cGUgeyFGdW5jdGlvbn0gKi8obWl4aW4pKGJhc2UpO1xuICAgICAgbWFwLnNldChiYXNlLCBleHRlbmRlZCk7XG4gICAgfVxuICAgIC8vIGNvcHkgaW5oZXJpdGVkIG1peGluIHNldCBmcm9tIHRoZSBleHRlbmRlZCBjbGFzcywgb3IgdGhlIGJhc2UgY2xhc3NcbiAgICAvLyBOT1RFOiB3ZSBhdm9pZCB1c2Ugb2YgU2V0IGhlcmUgYmVjYXVzZSBzb21lIGJyb3dzZXIgKElFMTEpXG4gICAgLy8gY2Fubm90IGV4dGVuZCBhIGJhc2UgU2V0IHZpYSB0aGUgY29uc3RydWN0b3IuXG4gICAgbGV0IG1peGluU2V0ID0gT2JqZWN0LmNyZWF0ZSgvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCB8fCBiYXNlU2V0IHx8IG51bGwpO1xuICAgIG1peGluU2V0W21peGluRGVkdXBlSWRdID0gdHJ1ZTtcbiAgICAvKiogQHR5cGUgeyFNaXhpbkZ1bmN0aW9ufSAqLyhleHRlbmRlZCkuX19taXhpblNldCA9IG1peGluU2V0O1xuICAgIHJldHVybiBleHRlbmRlZDtcbiAgfVxuXG4gIHJldHVybiBkZWR1cGluZ01peGluO1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL21peGluLmpzXG4vLyBtb2R1bGUgaWQgPSA1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcblxuLyoqIEB0eXBlZGVmIHt7cnVuOiBmdW5jdGlvbihmdW5jdGlvbigpLCBudW1iZXI9KTpudW1iZXIsIGNhbmNlbDogZnVuY3Rpb24obnVtYmVyKX19ICovXG5sZXQgQXN5bmNJbnRlcmZhY2U7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLy8gTWljcm90YXNrIGltcGxlbWVudGVkIHVzaW5nIE11dGF0aW9uIE9ic2VydmVyXG5sZXQgbWljcm90YXNrQ3VyckhhbmRsZSA9IDA7XG5sZXQgbWljcm90YXNrTGFzdEhhbmRsZSA9IDA7XG5sZXQgbWljcm90YXNrQ2FsbGJhY2tzID0gW107XG5sZXQgbWljcm90YXNrTm9kZUNvbnRlbnQgPSAwO1xubGV0IG1pY3JvdGFza05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG5uZXcgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIobWljcm90YXNrRmx1c2gpLm9ic2VydmUobWljcm90YXNrTm9kZSwge2NoYXJhY3RlckRhdGE6IHRydWV9KTtcblxuZnVuY3Rpb24gbWljcm90YXNrRmx1c2goKSB7XG4gIGNvbnN0IGxlbiA9IG1pY3JvdGFza0NhbGxiYWNrcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBsZXQgY2IgPSBtaWNyb3Rhc2tDYWxsYmFja3NbaV07XG4gICAgaWYgKGNiKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjYigpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsgdGhyb3cgZTsgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIG1pY3JvdGFza0NhbGxiYWNrcy5zcGxpY2UoMCwgbGVuKTtcbiAgbWljcm90YXNrTGFzdEhhbmRsZSArPSBsZW47XG59XG5cbmV4cG9ydCBjb25zdCB0aW1lT3V0ID0ge1xuICAvKipcbiAgICogUmV0dXJucyBhIHN1Yi1tb2R1bGUgd2l0aCB0aGUgYXN5bmMgaW50ZXJmYWNlIHByb3ZpZGluZyB0aGUgcHJvdmlkZWRcbiAgICogZGVsYXkuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGF5IFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyBjYWxsYmFja3MgaW4gbXNcbiAgICogQHJldHVybiB7QXN5bmNJbnRlcmZhY2V9IEFuIGFzeW5jIHRpbWVvdXQgaW50ZXJmYWNlXG4gICAqL1xuICBhZnRlcihkZWxheSkge1xuICAgIHJldHVybiAge1xuICAgICAgcnVuKGZuKSB7IHJldHVybiBzZXRUaW1lb3V0KGZuLCBkZWxheSk7IH0sXG4gICAgICBjYW5jZWw6IHdpbmRvdy5jbGVhclRpbWVvdXQuYmluZCh3aW5kb3cpXG4gICAgfTtcbiAgfSxcbiAgLyoqXG4gICAqIEVucXVldWVzIGEgZnVuY3Rpb24gY2FsbGVkIGluIHRoZSBuZXh0IHRhc2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLnRpbWVPdXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW46IHdpbmRvdy5zZXRUaW1lb3V0LmJpbmQod2luZG93KSxcbiAgLyoqXG4gICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IGVucXVldWVkIGB0aW1lT3V0YCBjYWxsYmFjay5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMudGltZU91dFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKi9cbiAgY2FuY2VsOiB3aW5kb3cuY2xlYXJUaW1lb3V0LmJpbmQod2luZG93KVxufTtcblxuZXhwb3J0IGNvbnN0IGFuaW1hdGlvbkZyYW1lID0ge1xuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5hbmltYXRpb25GcmFtZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBDYWxsYmFjayB0byBydW5cbiAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdXNlZCBmb3IgY2FuY2VsaW5nIHRhc2tcbiAgICovXG4gIHJ1bjogd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdyksXG4gIC8qKlxuICAgKiBDYW5jZWxzIGEgcHJldmlvdXNseSBlbnF1ZXVlZCBgYW5pbWF0aW9uRnJhbWVgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy50aW1lT3V0XG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqL1xuICBjYW5jZWw6IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZS5iaW5kKHdpbmRvdylcbn07XG5cbmV4cG9ydCBjb25zdCBpZGxlUGVyaW9kID0ge1xuICAvKipcbiAgICogRW5xdWV1ZXMgYSBmdW5jdGlvbiBjYWxsZWQgYXQgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgIHRpbWluZy5cbiAgICpcbiAgICogQG1lbWJlcm9mIFBvbHltZXIuQXN5bmMuaWRsZVBlcmlvZFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKElkbGVEZWFkbGluZSl9IGZuIENhbGxiYWNrIHRvIHJ1blxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEhhbmRsZSB1c2VkIGZvciBjYW5jZWxpbmcgdGFza1xuICAgKi9cbiAgcnVuKGZuKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrID9cbiAgICAgIHdpbmRvdy5yZXF1ZXN0SWRsZUNhbGxiYWNrKGZuKSA6XG4gICAgICB3aW5kb3cuc2V0VGltZW91dChmbiwgMTYpO1xuICB9LFxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYGlkbGVQZXJpb2RgIGNhbGxiYWNrLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5pZGxlUGVyaW9kXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoYW5kbGUgSGFuZGxlIHJldHVybmVkIGZyb20gYHJ1bmAgb2YgY2FsbGJhY2sgdG8gY2FuY2VsXG4gICAqL1xuICBjYW5jZWwoaGFuZGxlKSB7XG4gICAgd2luZG93LmNhbmNlbElkbGVDYWxsYmFjayA/XG4gICAgICB3aW5kb3cuY2FuY2VsSWRsZUNhbGxiYWNrKGhhbmRsZSkgOlxuICAgICAgd2luZG93LmNsZWFyVGltZW91dChoYW5kbGUpO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgbWljcm9UYXNrID0ge1xuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIGZ1bmN0aW9uIGNhbGxlZCBhdCBtaWNyb3Rhc2sgdGltaW5nLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgUG9seW1lci5Bc3luYy5taWNyb1Rhc2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuXG4gICAqIEByZXR1cm4ge251bWJlcn0gSGFuZGxlIHVzZWQgZm9yIGNhbmNlbGluZyB0YXNrXG4gICAqL1xuICBydW4oY2FsbGJhY2spIHtcbiAgICBtaWNyb3Rhc2tOb2RlLnRleHRDb250ZW50ID0gbWljcm90YXNrTm9kZUNvbnRlbnQrKztcbiAgICBtaWNyb3Rhc2tDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIG1pY3JvdGFza0N1cnJIYW5kbGUrKztcbiAgfSxcblxuICAvKipcbiAgICogQ2FuY2VscyBhIHByZXZpb3VzbHkgZW5xdWV1ZWQgYG1pY3JvVGFza2AgY2FsbGJhY2suXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLkFzeW5jLm1pY3JvVGFza1xuICAgKiBAcGFyYW0ge251bWJlcn0gaGFuZGxlIEhhbmRsZSByZXR1cm5lZCBmcm9tIGBydW5gIG9mIGNhbGxiYWNrIHRvIGNhbmNlbFxuICAgKi9cbiAgY2FuY2VsKGhhbmRsZSkge1xuICAgIGNvbnN0IGlkeCA9IGhhbmRsZSAtIG1pY3JvdGFza0xhc3RIYW5kbGU7XG4gICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICBpZiAoIW1pY3JvdGFza0NhbGxiYWNrc1tpZHhdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhc3luYyBoYW5kbGU6ICcgKyBoYW5kbGUpO1xuICAgICAgfVxuICAgICAgbWljcm90YXNrQ2FsbGJhY2tzW2lkeF0gPSBudWxsO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvYXN5bmMuanNcbi8vIG1vZHVsZSBpZCA9IDZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5jb25zdCBjYXNlTWFwID0ge307XG5jb25zdCBEQVNIX1RPX0NBTUVMID0gLy1bYS16XS9nO1xuY29uc3QgQ0FNRUxfVE9fREFTSCA9IC8oW0EtWl0pL2c7XG5cbmV4cG9ydCBmdW5jdGlvbiBkYXNoVG9DYW1lbENhc2UoZGFzaCkge1xuICByZXR1cm4gY2FzZU1hcFtkYXNoXSB8fCAoXG4gICAgY2FzZU1hcFtkYXNoXSA9IGRhc2guaW5kZXhPZignLScpIDwgMCA/IGRhc2ggOiBkYXNoLnJlcGxhY2UoREFTSF9UT19DQU1FTCxcbiAgICAgIChtKSA9PiBtWzFdLnRvVXBwZXJDYXNlKClcbiAgICApXG4gICk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYW1lbFRvRGFzaENhc2UoY2FtZWwpIHtcbiAgcmV0dXJuIGNhc2VNYXBbY2FtZWxdIHx8IChcbiAgICBjYXNlTWFwW2NhbWVsXSA9IGNhbWVsLnJlcGxhY2UoQ0FNRUxfVE9fREFTSCwgJy0kMScpLnRvTG93ZXJDYXNlKClcbiAgKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2Nhc2UtbWFwLmpzXG4vLyBtb2R1bGUgaWQgPSA3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi9jb2xvci5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGN1c3RvbS1zdHlsZT5cbiAgPHN0eWxlIGlzPVwiY3VzdG9tLXN0eWxlXCI+XG4gICAgaHRtbCB7XG4gICAgICAvKlxuICAgICAgICogWW91IGNhbiB1c2UgdGhlc2UgZ2VuZXJpYyB2YXJpYWJsZXMgaW4geW91ciBlbGVtZW50cyBmb3IgZWFzeSB0aGVtaW5nLlxuICAgICAgICogRm9yIGV4YW1wbGUsIGlmIGFsbCB5b3VyIGVsZW1lbnRzIHVzZSBcXGAtLXByaW1hcnktdGV4dC1jb2xvclxcYCBhcyBpdHMgbWFpblxuICAgICAgICogY29sb3IsIHRoZW4gc3dpdGNoaW5nIGZyb20gYSBsaWdodCB0byBhIGRhcmsgdGhlbWUgaXMganVzdCBhIG1hdHRlciBvZlxuICAgICAgICogY2hhbmdpbmcgdGhlIHZhbHVlIG9mIFxcYC0tcHJpbWFyeS10ZXh0LWNvbG9yXFxgIGluIHlvdXIgYXBwbGljYXRpb24uXG4gICAgICAgKi9cbiAgICAgIC0tcHJpbWFyeS10ZXh0LWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS10ZXh0LWNvbG9yKTtcbiAgICAgIC0tcHJpbWFyeS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1saWdodC10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yKTtcbiAgICAgIC0tc2Vjb25kYXJ5LXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLXNlY29uZGFyeS1jb2xvcik7XG4gICAgICAtLWRpc2FibGVkLXRleHQtY29sb3I6IHZhcigtLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yKTtcbiAgICAgIC0tZGl2aWRlci1jb2xvcjogdmFyKC0tbGlnaHQtdGhlbWUtZGl2aWRlci1jb2xvcik7XG4gICAgICAtLWVycm9yLWNvbG9yOiB2YXIoLS1wYXBlci1kZWVwLW9yYW5nZS1hNzAwKTtcblxuICAgICAgLypcbiAgICAgICAqIFByaW1hcnkgYW5kIGFjY2VudCBjb2xvcnMuIEFsc28gc2VlIGNvbG9yLmh0bWwgZm9yIG1vcmUgY29sb3JzLlxuICAgICAgICovXG4gICAgICAtLXByaW1hcnktY29sb3I6IHZhcigtLXBhcGVyLWluZGlnby01MDApO1xuICAgICAgLS1saWdodC1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wYXBlci1pbmRpZ28tMTAwKTtcbiAgICAgIC0tZGFyay1wcmltYXJ5LWNvbG9yOiB2YXIoLS1wYXBlci1pbmRpZ28tNzAwKTtcblxuICAgICAgLS1hY2NlbnQtY29sb3I6IHZhcigtLXBhcGVyLXBpbmstYTIwMCk7XG4gICAgICAtLWxpZ2h0LWFjY2VudC1jb2xvcjogdmFyKC0tcGFwZXItcGluay1hMTAwKTtcbiAgICAgIC0tZGFyay1hY2NlbnQtY29sb3I6IHZhcigtLXBhcGVyLXBpbmstYTQwMCk7XG5cblxuICAgICAgLypcbiAgICAgICAqIE1hdGVyaWFsIERlc2lnbiBMaWdodCBiYWNrZ3JvdW5kIHRoZW1lXG4gICAgICAgKi9cbiAgICAgIC0tbGlnaHQtdGhlbWUtYmFja2dyb3VuZC1jb2xvcjogI2ZmZmZmZjtcbiAgICAgIC0tbGlnaHQtdGhlbWUtYmFzZS1jb2xvcjogIzAwMDAwMDtcbiAgICAgIC0tbGlnaHQtdGhlbWUtdGV4dC1jb2xvcjogdmFyKC0tcGFwZXItZ3JleS05MDApO1xuICAgICAgLS1saWdodC10aGVtZS1zZWNvbmRhcnktY29sb3I6ICM3MzczNzM7ICAvKiBmb3Igc2Vjb25kYXJ5IHRleHQgYW5kIGljb25zICovXG4gICAgICAtLWxpZ2h0LXRoZW1lLWRpc2FibGVkLWNvbG9yOiAjOWI5YjliOyAgLyogZGlzYWJsZWQvaGludCB0ZXh0ICovXG4gICAgICAtLWxpZ2h0LXRoZW1lLWRpdmlkZXItY29sb3I6ICNkYmRiZGI7XG5cbiAgICAgIC8qXG4gICAgICAgKiBNYXRlcmlhbCBEZXNpZ24gRGFyayBiYWNrZ3JvdW5kIHRoZW1lXG4gICAgICAgKi9cbiAgICAgIC0tZGFyay10aGVtZS1iYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci1ncmV5LTkwMCk7XG4gICAgICAtLWRhcmstdGhlbWUtYmFzZS1jb2xvcjogI2ZmZmZmZjtcbiAgICAgIC0tZGFyay10aGVtZS10ZXh0LWNvbG9yOiAjZmZmZmZmO1xuICAgICAgLS1kYXJrLXRoZW1lLXNlY29uZGFyeS1jb2xvcjogI2JjYmNiYzsgIC8qIGZvciBzZWNvbmRhcnkgdGV4dCBhbmQgaWNvbnMgKi9cbiAgICAgIC0tZGFyay10aGVtZS1kaXNhYmxlZC1jb2xvcjogIzY0NjQ2NDsgIC8qIGRpc2FibGVkL2hpbnQgdGV4dCAqL1xuICAgICAgLS1kYXJrLXRoZW1lLWRpdmlkZXItY29sb3I6ICMzYzNjM2M7XG5cbiAgICAgIC8qXG4gICAgICAgKiBEZXByZWNhdGVkIHZhbHVlcyBiZWNhdXNlIG9mIHRoZWlyIGNvbmZ1c2luZyBuYW1lcy5cbiAgICAgICAqL1xuICAgICAgLS10ZXh0LXByaW1hcnktY29sb3I6IHZhcigtLWRhcmstdGhlbWUtdGV4dC1jb2xvcik7XG4gICAgICAtLWRlZmF1bHQtcHJpbWFyeS1jb2xvcjogdmFyKC0tcHJpbWFyeS1jb2xvcik7XG4gICAgfVxuICA8L3N0eWxlPlxuPC9jdXN0b20tc3R5bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzXG4vLyBtb2R1bGUgaWQgPSA4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IHBhdGhGcm9tVXJsIH0gZnJvbSAnLi9yZXNvbHZlLXVybC5qcyc7XG5cbi8qKlxuICogTGVnYWN5IHNldHRpbmdzLlxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqL1xuY29uc3Qgc2V0dGluZ3MgPSB1bmRlZmluZWQgfHwge307XG5leHBvcnQgY29uc3QgdXNlU2hhZG93ID0gISh3aW5kb3cuU2hhZHlET00pO1xuZXhwb3J0IGNvbnN0IHVzZU5hdGl2ZUNTU1Byb3BlcnRpZXMgPSBCb29sZWFuKCF3aW5kb3cuU2hhZHlDU1MgfHwgd2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcyk7XG5leHBvcnQgY29uc3QgdXNlTmF0aXZlQ3VzdG9tRWxlbWVudHMgPSAhKHdpbmRvdy5jdXN0b21FbGVtZW50cy5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKTtcbmV4cG9ydCB7IHNldHRpbmdzIGFzIFNldHRpbmdzIH07XG5cbi8qKlxuICogR2xvYmFsbHkgc2V0dGFibGUgcHJvcGVydHkgdGhhdCBpcyBhdXRvbWF0aWNhbGx5IGFzc2lnbmVkIHRvXG4gKiBgUG9seW1lci5FbGVtZW50TWl4aW5gIGluc3RhbmNlcywgdXNlZnVsIGZvciBiaW5kaW5nIGluIHRlbXBsYXRlcyB0b1xuICogbWFrZSBVUkwncyByZWxhdGl2ZSB0byBhbiBhcHBsaWNhdGlvbidzIHJvb3QuICBEZWZhdWx0cyB0byB0aGUgbWFpblxuICogZG9jdW1lbnQgVVJMLCBidXQgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdXNlcnMuICBJdCBtYXkgYmUgdXNlZnVsIHRvIHNldFxuICogYFBvbHltZXIucm9vdFBhdGhgIHRvIHByb3ZpZGUgYSBzdGFibGUgYXBwbGljYXRpb24gbW91bnQgcGF0aCB3aGVuXG4gKiB1c2luZyBjbGllbnQgc2lkZSByb3V0aW5nLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmxldCByb290UGF0aCA9IHVuZGVmaW5lZCB8fFxuICBwYXRoRnJvbVVybChkb2N1bWVudC5iYXNlVVJJIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuZXhwb3J0IHsgcm9vdFBhdGggfTtcblxuZXhwb3J0IGNvbnN0IHNldFJvb3RQYXRoID0gZnVuY3Rpb24ocGF0aCkge1xuICByb290UGF0aCA9IHBhdGg7XG59O1xuXG4vKipcbiAqIEEgZ2xvYmFsIGNhbGxiYWNrIHVzZWQgdG8gc2FuaXRpemUgYW55IHZhbHVlIGJlZm9yZSBpbnNlcnRpbmcgaXQgaW50byB0aGUgRE9NLiBUaGUgY2FsbGJhY2sgc2lnbmF0dXJlIGlzOlxuICpcbiAqICAgICBQb2x5bWVyID0ge1xuICogICAgICAgc2FuaXRpemVET01WYWx1ZTogZnVuY3Rpb24odmFsdWUsIG5hbWUsIHR5cGUsIG5vZGUpIHsgLi4uIH1cbiAqICAgICB9XG4gKlxuICogV2hlcmU6XG4gKlxuICogYHZhbHVlYCBpcyB0aGUgdmFsdWUgdG8gc2FuaXRpemUuXG4gKiBgbmFtZWAgaXMgdGhlIG5hbWUgb2YgYW4gYXR0cmlidXRlIG9yIHByb3BlcnR5IChmb3IgZXhhbXBsZSwgaHJlZikuXG4gKiBgdHlwZWAgaW5kaWNhdGVzIHdoZXJlIHRoZSB2YWx1ZSBpcyBiZWluZyBpbnNlcnRlZDogb25lIG9mIHByb3BlcnR5LCBhdHRyaWJ1dGUsIG9yIHRleHQuXG4gKiBgbm9kZWAgaXMgdGhlIG5vZGUgd2hlcmUgdGhlIHZhbHVlIGlzIGJlaW5nIGluc2VydGVkLlxuICpcbiAqIEB0eXBlIHsoZnVuY3Rpb24oKixzdHJpbmcsc3RyaW5nLE5vZGUpOiopfHVuZGVmaW5lZH1cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKi9cbmxldCBzYW5pdGl6ZURPTVZhbHVlID0gdW5kZWZpbmVkO1xuXG5leHBvcnQgeyBzYW5pdGl6ZURPTVZhbHVlIH07XG5cbmV4cG9ydCBjb25zdCBzZXRTYW5pdGl6ZURPTVZhbHVlID0gZnVuY3Rpb24obmV3U2FuaXRpemVET01WYWx1ZSkge1xuICBzYW5pdGl6ZURPTVZhbHVlID0gbmV3U2FuaXRpemVET01WYWx1ZTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zZXR0aW5ncy5qc1xuLy8gbW9kdWxlIGlkID0gOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBDU1NfVVJMX1JYID0gLyh1cmxcXCgpKFteKV0qKShcXCkpL2c7XG5sZXQgQUJTX1VSTCA9IC8oXlxcLyl8KF4jKXwoXltcXHctXFxkXSo6KS87XG5sZXQgd29ya2luZ1VSTDtcbmxldCByZXNvbHZlRG9jO1xuLyoqXG4gKiBSZXNvbHZlcyB0aGUgZ2l2ZW4gVVJMIGFnYWluc3QgdGhlIHByb3ZpZGVkIGBiYXNlVXJpJy5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byByZXNvbHZlXG4gKiBAcGFyYW0gez9zdHJpbmc9fSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHJlc29sdmVkIFVSTFxuICovXG5mdW5jdGlvbiByZXNvbHZlVXJsKHVybCwgYmFzZVVSSSkge1xuICBpZiAodXJsICYmIEFCU19VUkwudGVzdCh1cmwpKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuICAvLyBMYXp5IGZlYXR1cmUgZGV0ZWN0aW9uLlxuICBpZiAod29ya2luZ1VSTCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgd29ya2luZ1VSTCA9IGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1ID0gbmV3IFVSTCgnYicsICdodHRwOi8vYScpO1xuICAgICAgdS5wYXRobmFtZSA9ICdjJTIwZCc7XG4gICAgICB3b3JraW5nVVJMID0gKHUuaHJlZiA9PT0gJ2h0dHA6Ly9hL2MlMjBkJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gc2lsZW50bHkgZmFpbFxuICAgIH1cbiAgfVxuICBpZiAoIWJhc2VVUkkpIHtcbiAgICBiYXNlVVJJID0gZG9jdW1lbnQuYmFzZVVSSSB8fCB3aW5kb3cubG9jYXRpb24uaHJlZjtcbiAgfVxuICBpZiAod29ya2luZ1VSTCkge1xuICAgIHJldHVybiAobmV3IFVSTCh1cmwsIGJhc2VVUkkpKS5ocmVmO1xuICB9XG4gIC8vIEZhbGxiYWNrIHRvIGNyZWF0aW5nIGFuIGFuY2hvciBpbnRvIGEgZGlzY29ubmVjdGVkIGRvY3VtZW50LlxuICBpZiAoIXJlc29sdmVEb2MpIHtcbiAgICByZXNvbHZlRG9jID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCd0ZW1wJyk7XG4gICAgcmVzb2x2ZURvYy5iYXNlID0gcmVzb2x2ZURvYy5jcmVhdGVFbGVtZW50KCdiYXNlJyk7XG4gICAgcmVzb2x2ZURvYy5oZWFkLmFwcGVuZENoaWxkKHJlc29sdmVEb2MuYmFzZSk7XG4gICAgcmVzb2x2ZURvYy5hbmNob3IgPSByZXNvbHZlRG9jLmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICByZXNvbHZlRG9jLmJvZHkuYXBwZW5kQ2hpbGQocmVzb2x2ZURvYy5hbmNob3IpO1xuICB9XG4gIHJlc29sdmVEb2MuYmFzZS5ocmVmID0gYmFzZVVSSTtcbiAgcmVzb2x2ZURvYy5hbmNob3IuaHJlZiA9IHVybDtcbiAgcmV0dXJuIHJlc29sdmVEb2MuYW5jaG9yLmhyZWYgfHwgdXJsO1xuXG59XG5cbi8qKlxuICogUmVzb2x2ZXMgYW55IHJlbGF0aXZlIFVSTCdzIGluIHRoZSBnaXZlbiBDU1MgdGV4dCBhZ2FpbnN0IHRoZSBwcm92aWRlZFxuICogYG93bmVyRG9jdW1lbnRgJ3MgYGJhc2VVUklgLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyLlJlc29sdmVVcmxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0IENTUyB0ZXh0IHRvIHByb2Nlc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJIEJhc2UgVVJJIHRvIHJlc29sdmUgdGhlIFVSTCBhZ2FpbnN0XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFByb2Nlc3NlZCBDU1MgdGV4dCB3aXRoIHJlc29sdmVkIFVSTCdzXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDc3MoY3NzVGV4dCwgYmFzZVVSSSkge1xuICByZXR1cm4gY3NzVGV4dC5yZXBsYWNlKENTU19VUkxfUlgsIGZ1bmN0aW9uKG0sIHByZSwgdXJsLCBwb3N0KSB7XG4gICAgcmV0dXJuIHByZSArICdcXCcnICtcbiAgICAgIHJlc29sdmVVcmwodXJsLnJlcGxhY2UoL1tcIiddL2csICcnKSwgYmFzZVVSSSkgK1xuICAgICAgJ1xcJycgKyBwb3N0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgcGF0aCBmcm9tIGEgZ2l2ZW4gYHVybGAuIFRoZSBwYXRoIGluY2x1ZGVzIHRoZSB0cmFpbGluZ1xuICogYC9gIGZyb20gdGhlIHVybC5cbiAqXG4gKiBAbWVtYmVyb2YgUG9seW1lci5SZXNvbHZlVXJsXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIElucHV0IFVSTCB0byB0cmFuc2Zvcm1cbiAqIEByZXR1cm4ge3N0cmluZ30gcmVzb2x2ZWQgcGF0aFxuICovXG5mdW5jdGlvbiBwYXRoRnJvbVVybCh1cmwpIHtcbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcoMCwgdXJsLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbn1cblxuZXhwb3J0IHsgcmVzb2x2ZUNzcyB9O1xuZXhwb3J0IHsgcmVzb2x2ZVVybCB9O1xuZXhwb3J0IHsgcGF0aEZyb21VcmwgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3Jlc29sdmUtdXJsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BhdGgocGF0aCkge1xuICByZXR1cm4gcGF0aC5pbmRleE9mKCcuJykgPj0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJvb3QocGF0aCkge1xuICBsZXQgZG90SW5kZXggPSBwYXRoLmluZGV4T2YoJy4nKTtcbiAgaWYgKGRvdEluZGV4ID09PSAtMSkge1xuICAgIHJldHVybiBwYXRoO1xuICB9XG4gIHJldHVybiBwYXRoLnNsaWNlKDAsIGRvdEluZGV4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzQW5jZXN0b3IoYmFzZSwgcGF0aCkge1xuICAvLyAgICAgYmFzZS5zdGFydHNXaXRoKHBhdGggKyAnLicpO1xuICByZXR1cm4gYmFzZS5pbmRleE9mKHBhdGggKyAnLicpID09PSAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpIHtcbiAgLy8gICAgIHBhdGguc3RhcnRzV2l0aChiYXNlICsgJy4nKTtcbiAgcmV0dXJuIHBhdGguaW5kZXhPZihiYXNlICsgJy4nKSA9PT0gMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zbGF0ZShiYXNlLCBuZXdCYXNlLCBwYXRoKSB7XG4gIHJldHVybiBuZXdCYXNlICsgcGF0aC5zbGljZShiYXNlLmxlbmd0aCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXRjaGVzKGJhc2UsIHBhdGgpIHtcbiAgcmV0dXJuIChiYXNlID09PSBwYXRoKSB8fFxuICAgICAgICAgaXNBbmNlc3RvcihiYXNlLCBwYXRoKSB8fFxuICAgICAgICAgaXNEZXNjZW5kYW50KGJhc2UsIHBhdGgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplKHBhdGgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICBsZXQgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGk8cGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGFyZ3MgPSBwYXRoW2ldLnRvU3RyaW5nKCkuc3BsaXQoJy4nKTtcbiAgICAgIGZvciAobGV0IGo9MDsgajxhcmdzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHBhcnRzLnB1c2goYXJnc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhdGg7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0KHBhdGgpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0aCkpIHtcbiAgICByZXR1cm4gbm9ybWFsaXplKHBhdGgpLnNwbGl0KCcuJyk7XG4gIH1cbiAgcmV0dXJuIHBhdGgudG9TdHJpbmcoKS5zcGxpdCgnLicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHJvb3QsIHBhdGgsIGluZm8pIHtcbiAgbGV0IHByb3AgPSByb290O1xuICBsZXQgcGFydHMgPSBzcGxpdChwYXRoKTtcbiAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0xXSBhbmQgZGVyZWZlcmVuY2VcbiAgZm9yIChsZXQgaT0wOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKCFwcm9wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCBwYXJ0ID0gcGFydHNbaV07XG4gICAgcHJvcCA9IHByb3BbcGFydF07XG4gIH1cbiAgaWYgKGluZm8pIHtcbiAgICBpbmZvLnBhdGggPSBwYXJ0cy5qb2luKCcuJyk7XG4gIH1cbiAgcmV0dXJuIHByb3A7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXQocm9vdCwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IHByb3AgPSByb290O1xuICBsZXQgcGFydHMgPSBzcGxpdChwYXRoKTtcbiAgbGV0IGxhc3QgPSBwYXJ0c1twYXJ0cy5sZW5ndGgtMV07XG4gIGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG4gICAgLy8gTG9vcCBvdmVyIHBhdGggcGFydHNbMC4ubi0yXSBhbmQgZGVyZWZlcmVuY2VcbiAgICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoLTE7IGkrKykge1xuICAgICAgbGV0IHBhcnQgPSBwYXJ0c1tpXTtcbiAgICAgIHByb3AgPSBwcm9wW3BhcnRdO1xuICAgICAgaWYgKCFwcm9wKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gU2V0IHZhbHVlIHRvIG9iamVjdCBhdCBlbmQgb2YgcGF0aFxuICAgIHByb3BbbGFzdF0gPSB2YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBTaW1wbGUgcHJvcGVydHkgc2V0XG4gICAgcHJvcFtwYXRoXSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG59XG5cbmV4cG9ydCBjb25zdCBpc0RlZXAgPSBpc1BhdGg7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9wYXRoLmpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5pbXBvcnQgeyB0aW1lT3V0IH0gZnJvbSAnLi9hc3luYy5qcyc7XG5pbXBvcnQgeyBEZWJvdW5jZXIgfSBmcm9tICcuL2RlYm91bmNlLmpzJztcblxuLy8gZGV0ZWN0IG5hdGl2ZSB0b3VjaCBhY3Rpb24gc3VwcG9ydFxubGV0IEhBU19OQVRJVkVfVEEgPSB0eXBlb2YgZG9jdW1lbnQuaGVhZC5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ3N0cmluZyc7XG5sZXQgR0VTVFVSRV9LRVkgPSAnX19wb2x5bWVyR2VzdHVyZXMnO1xubGV0IEhBTkRMRURfT0JKID0gJ19fcG9seW1lckdlc3R1cmVzSGFuZGxlZCc7XG5sZXQgVE9VQ0hfQUNUSU9OID0gJ19fcG9seW1lckdlc3R1cmVzVG91Y2hBY3Rpb24nO1xuLy8gcmFkaXVzIGZvciB0YXAgYW5kIHRyYWNrXG5sZXQgVEFQX0RJU1RBTkNFID0gMjU7XG5sZXQgVFJBQ0tfRElTVEFOQ0UgPSA1O1xuLy8gbnVtYmVyIG9mIGxhc3QgTiB0cmFjayBwb3NpdGlvbnMgdG8ga2VlcFxubGV0IFRSQUNLX0xFTkdUSCA9IDI7XG5cbi8vIERpc2FibGluZyBcIm1vdXNlXCIgaGFuZGxlcnMgZm9yIDI1MDBtcyBpcyBlbm91Z2hcbmxldCBNT1VTRV9USU1FT1VUID0gMjUwMDtcbmxldCBNT1VTRV9FVkVOVFMgPSBbJ21vdXNlZG93bicsICdtb3VzZW1vdmUnLCAnbW91c2V1cCcsICdjbGljayddO1xuLy8gYW4gYXJyYXkgb2YgYml0bWFzayB2YWx1ZXMgZm9yIG1hcHBpbmcgTW91c2VFdmVudC53aGljaCB0byBNb3VzZUV2ZW50LmJ1dHRvbnNcbmxldCBNT1VTRV9XSElDSF9UT19CVVRUT05TID0gWzAsIDEsIDQsIDJdO1xubGV0IE1PVVNFX0hBU19CVVRUT05TID0gKGZ1bmN0aW9uKCkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgTW91c2VFdmVudCgndGVzdCcsIHtidXR0b25zOiAxfSkuYnV0dG9ucyA9PT0gMTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSkoKTtcblxuLyogZXNsaW50IG5vLWVtcHR5OiBbXCJlcnJvclwiLCB7IFwiYWxsb3dFbXB0eUNhdGNoXCI6IHRydWUgfV0gKi9cbi8vIGNoZWNrIGZvciBwYXNzaXZlIGV2ZW50IGxpc3RlbmVyc1xubGV0IFNVUFBPUlRTX1BBU1NJVkUgPSBmYWxzZTtcbihmdW5jdGlvbigpIHtcbiAgdHJ5IHtcbiAgICBsZXQgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7Z2V0OiBmdW5jdGlvbigpIHtTVVBQT1JUU19QQVNTSVZFID0gdHJ1ZTt9fSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCBvcHRzKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndGVzdCcsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoKGUpIHt9XG59KSgpO1xuXG4vLyBDaGVjayBmb3IgdG91Y2gtb25seSBkZXZpY2VzXG5sZXQgSVNfVE9VQ0hfT05MWSA9IG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL2lQKD86W29hXWR8aG9uZSl8QW5kcm9pZC8pO1xuXG5sZXQgR2VzdHVyZVJlY29nbml6ZXIgPSBmdW5jdGlvbigpe307IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKCl7fTtcbi8qKiBAdHlwZSB7ZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWR9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUubW91c2Vkb3duO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLm1vdXNlbW92ZTtcbi8qKiBAdHlwZSB7KGZ1bmN0aW9uKE1vdXNlRXZlbnQpIHwgdW5kZWZpbmVkKX0gKi9cbkdlc3R1cmVSZWNvZ25pemVyLnByb3RvdHlwZS5tb3VzZXVwO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoc3RhcnQ7XG4vKiogQHR5cGUgeyhmdW5jdGlvbihUb3VjaEV2ZW50KSB8IHVuZGVmaW5lZCl9ICovXG5HZXN0dXJlUmVjb2duaXplci5wcm90b3R5cGUudG91Y2htb3ZlO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oVG91Y2hFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLnRvdWNoZW5kO1xuLyoqIEB0eXBlIHsoZnVuY3Rpb24oTW91c2VFdmVudCkgfCB1bmRlZmluZWQpfSAqL1xuR2VzdHVyZVJlY29nbml6ZXIucHJvdG90eXBlLmNsaWNrO1xuXG4vLyB0b3VjaCB3aWxsIG1ha2Ugc3ludGhldGljIG1vdXNlIGV2ZW50c1xuLy8gYHByZXZlbnREZWZhdWx0YCBvbiB0b3VjaGVuZCB3aWxsIGNhbmNlbCB0aGVtLFxuLy8gYnV0IHRoaXMgYnJlYWtzIGA8aW5wdXQ+YCBmb2N1cyBhbmQgbGluayBjbGlja3Ncbi8vIGRpc2FibGUgbW91c2UgaGFuZGxlcnMgZm9yIE1PVVNFX1RJTUVPVVQgbXMgYWZ0ZXJcbi8vIGEgdG91Y2hlbmQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbmxldCBtb3VzZUNhbmNlbGxlciA9IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgLy8gQ2hlY2sgZm9yIHNvdXJjZUNhcGFiaWxpdGllcywgdXNlZCB0byBkaXN0aW5ndWlzaCBzeW50aGV0aWMgZXZlbnRzXG4gIC8vIGlmIG1vdXNlRXZlbnQgZGlkIG5vdCBjb21lIGZyb20gYSBkZXZpY2UgdGhhdCBmaXJlcyB0b3VjaCBldmVudHMsXG4gIC8vIGl0IHdhcyBtYWRlIGJ5IGEgcmVhbCBtb3VzZSBhbmQgc2hvdWxkIGJlIGNvdW50ZWRcbiAgLy8gaHR0cDovL3dpY2cuZ2l0aHViLmlvL0lucHV0RGV2aWNlQ2FwYWJpbGl0aWVzLyNkb20taW5wdXRkZXZpY2VjYXBhYmlsaXRpZXMtZmlyZXN0b3VjaGV2ZW50c1xuICBsZXQgc2MgPSBtb3VzZUV2ZW50LnNvdXJjZUNhcGFiaWxpdGllcztcbiAgaWYgKHNjICYmICFzYy5maXJlc1RvdWNoRXZlbnRzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHNraXAgc3ludGhldGljIG1vdXNlIGV2ZW50c1xuICBtb3VzZUV2ZW50W0hBTkRMRURfT0JKXSA9IHtza2lwOiB0cnVlfTtcbiAgLy8gZGlzYWJsZSBcImdob3N0IGNsaWNrc1wiXG4gIGlmIChtb3VzZUV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICBsZXQgcGF0aCA9IG1vdXNlRXZlbnQuY29tcG9zZWRQYXRoICYmIG1vdXNlRXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgaWYgKHBhdGgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAocGF0aFtpXSA9PT0gUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBtb3VzZUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgbW91c2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXR1cCBUcnVlIHRvIGFkZCwgZmFsc2UgdG8gcmVtb3ZlLlxuICovXG5mdW5jdGlvbiBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIoc2V0dXApIHtcbiAgbGV0IGV2ZW50cyA9IElTX1RPVUNIX09OTFkgPyBbJ2NsaWNrJ10gOiBNT1VTRV9FVkVOVFM7XG4gIGZvciAobGV0IGkgPSAwLCBlbjsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGVuID0gZXZlbnRzW2ldO1xuICAgIGlmIChzZXR1cCkge1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihlbiwgbW91c2VDYW5jZWxsZXIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGVuLCBtb3VzZUNhbmNlbGxlciwgdHJ1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlnbm9yZU1vdXNlKGUpIHtcbiAgaWYgKCFQT0lOVEVSU1RBVEUubW91c2UubW91c2VJZ25vcmVKb2IpIHtcbiAgICBzZXR1cFRlYXJkb3duTW91c2VDYW5jZWxsZXIodHJ1ZSk7XG4gIH1cbiAgbGV0IHVuc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgc2V0dXBUZWFyZG93bk1vdXNlQ2FuY2VsbGVyKCk7XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IG51bGw7XG4gICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iID0gbnVsbDtcbiAgfTtcbiAgUE9JTlRFUlNUQVRFLm1vdXNlLnRhcmdldCA9IGUuY29tcG9zZWRQYXRoKClbMF07XG4gIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYiA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgUE9JTlRFUlNUQVRFLm1vdXNlLm1vdXNlSWdub3JlSm9iXG4gICAgICAsIHRpbWVPdXQuYWZ0ZXIoTU9VU0VfVElNRU9VVClcbiAgICAgICwgdW5zZXQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXYgZXZlbnQgdG8gdGVzdCBmb3IgbGVmdCBtb3VzZSBidXR0b24gZG93blxuICogQHJldHVybiB7Ym9vbGVhbn0gaGFzIGxlZnQgbW91c2UgYnV0dG9uIGRvd25cbiAqL1xuZnVuY3Rpb24gaGFzTGVmdE1vdXNlQnV0dG9uKGV2KSB7XG4gIGxldCB0eXBlID0gZXYudHlwZTtcbiAgLy8gZXhpdCBlYXJseSBpZiB0aGUgZXZlbnQgaXMgbm90IGEgbW91c2UgZXZlbnRcbiAgaWYgKE1PVVNFX0VWRU5UUy5pbmRleE9mKHR5cGUpID09PSAtMSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBldi5idXR0b24gaXMgbm90IHJlbGlhYmxlIGZvciBtb3VzZW1vdmUgKDAgaXMgb3ZlcmxvYWRlZCBhcyBib3RoIGxlZnQgYnV0dG9uIGFuZCBubyBidXR0b25zKVxuICAvLyBpbnN0ZWFkIHdlIHVzZSBldi5idXR0b25zIChiaXRtYXNrIG9mIGJ1dHRvbnMpIG9yIGZhbGwgYmFjayB0byBldi53aGljaCAoZGVwcmVjYXRlZCwgMCBmb3Igbm8gYnV0dG9ucywgMSBmb3IgbGVmdCBidXR0b24pXG4gIGlmICh0eXBlID09PSAnbW91c2Vtb3ZlJykge1xuICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICBsZXQgYnV0dG9ucyA9IGV2LmJ1dHRvbnMgPT09IHVuZGVmaW5lZCA/IDEgOiBldi5idXR0b25zO1xuICAgIGlmICgoZXYgaW5zdGFuY2VvZiB3aW5kb3cuTW91c2VFdmVudCkgJiYgIU1PVVNFX0hBU19CVVRUT05TKSB7XG4gICAgICBidXR0b25zID0gTU9VU0VfV0hJQ0hfVE9fQlVUVE9OU1tldi53aGljaF0gfHwgMDtcbiAgICB9XG4gICAgLy8gYnV0dG9ucyBpcyBhIGJpdG1hc2ssIGNoZWNrIHRoYXQgdGhlIGxlZnQgYnV0dG9uIGJpdCBpcyBzZXQgKDEpXG4gICAgcmV0dXJuIEJvb2xlYW4oYnV0dG9ucyAmIDEpO1xuICB9IGVsc2Uge1xuICAgIC8vIGFsbG93IHVuZGVmaW5lZCBmb3IgdGVzdGluZyBldmVudHNcbiAgICBsZXQgYnV0dG9uID0gZXYuYnV0dG9uID09PSB1bmRlZmluZWQgPyAwIDogZXYuYnV0dG9uO1xuICAgIC8vIGV2LmJ1dHRvbiBpcyAwIGluIG1vdXNlZG93bi9tb3VzZXVwL2NsaWNrIGZvciBsZWZ0IGJ1dHRvbiBhY3RpdmF0aW9uXG4gICAgcmV0dXJuIGJ1dHRvbiA9PT0gMDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N5bnRoZXRpY0NsaWNrKGV2KSB7XG4gIGlmIChldi50eXBlID09PSAnY2xpY2snKSB7XG4gICAgLy8gZXYuZGV0YWlsIGlzIDAgZm9yIEhUTUxFbGVtZW50LmNsaWNrIGluIG1vc3QgYnJvd3NlcnNcbiAgICBpZiAoZXYuZGV0YWlsID09PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaW4gdGhlIHdvcnN0IGNhc2UsIGNoZWNrIHRoYXQgdGhlIHgveSBwb3NpdGlvbiBvZiB0aGUgY2xpY2sgaXMgd2l0aGluXG4gICAgLy8gdGhlIGJvdW5kaW5nIGJveCBvZiB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudFxuICAgIC8vIFRoYW5rcyBJRSAxMCA+OihcbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoZXYpO1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgdGFyZ2V0IG9mIHRoZSBldmVudCBpcyBhbiBlbGVtZW50IHNvIHdlIGNhbiB1c2UgZ2V0Qm91bmRpbmdDbGllbnRSZWN0LFxuICAgIC8vIGlmIG5vdCwganVzdCBhc3N1bWUgaXQgaXMgYSBzeW50aGV0aWMgY2xpY2tcbiAgICBpZiAoIXQubm9kZVR5cGUgfHwgLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgYmNyID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyh0KS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAvLyB1c2UgcGFnZSB4L3kgdG8gYWNjb3VudCBmb3Igc2Nyb2xsaW5nXG4gICAgbGV0IHggPSBldi5wYWdlWCwgeSA9IGV2LnBhZ2VZO1xuICAgIC8vIGV2IGlzIGEgc3ludGhldGljIGNsaWNrIGlmIHRoZSBwb3NpdGlvbiBpcyBvdXRzaWRlIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIHRhcmdldFxuICAgIHJldHVybiAhKCh4ID49IGJjci5sZWZ0ICYmIHggPD0gYmNyLnJpZ2h0KSAmJiAoeSA+PSBiY3IudG9wICYmIHkgPD0gYmNyLmJvdHRvbSkpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubGV0IFBPSU5URVJTVEFURSA9IHtcbiAgbW91c2U6IHtcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgbW91c2VJZ25vcmVKb2I6IG51bGxcbiAgfSxcbiAgdG91Y2g6IHtcbiAgICB4OiAwLFxuICAgIHk6IDAsXG4gICAgaWQ6IC0xLFxuICAgIHNjcm9sbERlY2lkZWQ6IGZhbHNlXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpcnN0VG91Y2hBY3Rpb24oZXYpIHtcbiAgbGV0IHRhID0gJ2F1dG8nO1xuICBsZXQgcGF0aCA9IGV2LmNvbXBvc2VkUGF0aCAmJiBldi5jb21wb3NlZFBhdGgoKTtcbiAgaWYgKHBhdGgpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbjsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIG4gPSBwYXRoW2ldO1xuICAgICAgaWYgKG5bVE9VQ0hfQUNUSU9OXSkge1xuICAgICAgICB0YSA9IG5bVE9VQ0hfQUNUSU9OXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YTtcbn1cblxuZnVuY3Rpb24gdHJhY2tEb2N1bWVudChzdGF0ZU9iaiwgbW92ZWZuLCB1cGZuKSB7XG4gIHN0YXRlT2JqLm1vdmVmbiA9IG1vdmVmbjtcbiAgc3RhdGVPYmoudXBmbiA9IHVwZm47XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdmVmbik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB1cGZuKTtcbn1cblxuZnVuY3Rpb24gdW50cmFja0RvY3VtZW50KHN0YXRlT2JqKSB7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHN0YXRlT2JqLm1vdmVmbik7XG4gIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBzdGF0ZU9iai51cGZuKTtcbiAgc3RhdGVPYmoubW92ZWZuID0gbnVsbDtcbiAgc3RhdGVPYmoudXBmbiA9IG51bGw7XG59XG5cbi8vIHVzZSBhIGRvY3VtZW50LXdpZGUgdG91Y2hlbmQgbGlzdGVuZXIgdG8gc3RhcnQgdGhlIGdob3N0LWNsaWNrIHByZXZlbnRpb24gbWVjaGFuaXNtXG4vLyBVc2UgcGFzc2l2ZSBldmVudCBsaXN0ZW5lcnMsIGlmIHN1cHBvcnRlZCwgdG8gbm90IGFmZmVjdCBzY3JvbGxpbmcgcGVyZm9ybWFuY2VcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgaWdub3JlTW91c2UsIFNVUFBPUlRTX1BBU1NJVkUgPyB7cGFzc2l2ZTogdHJ1ZX0gOiBmYWxzZSk7XG5cbmV4cG9ydCBjb25zdCBnZXN0dXJlcyA9IHt9O1xuZXhwb3J0IGNvbnN0IHJlY29nbml6ZXJzID0gW107XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWVwVGFyZ2V0RmluZCh4LCB5KSB7XG4gIGxldCBub2RlID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgbGV0IG5leHQgPSBub2RlO1xuICAvLyB0aGlzIGNvZGUgcGF0aCBpcyBvbmx5IHRha2VuIHdoZW4gbmF0aXZlIFNoYWRvd0RPTSBpcyB1c2VkXG4gIC8vIGlmIHRoZXJlIGlzIGEgc2hhZG93cm9vdCwgaXQgbWF5IGhhdmUgYSBub2RlIGF0IHgveVxuICAvLyBpZiB0aGVyZSBpcyBub3QgYSBzaGFkb3dyb290LCBleGl0IHRoZSBsb29wXG4gIHdoaWxlIChuZXh0ICYmIG5leHQuc2hhZG93Um9vdCAmJiAhd2luZG93LlNoYWR5RE9NKSB7XG4gICAgLy8gaWYgdGhlcmUgaXMgYSBub2RlIGF0IHgveSBpbiB0aGUgc2hhZG93cm9vdCwgbG9vayBkZWVwZXJcbiAgICBsZXQgb2xkTmV4dCA9IG5leHQ7XG4gICAgbmV4dCA9IG5leHQuc2hhZG93Um9vdC5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIC8vIG9uIFNhZmFyaSwgZWxlbWVudEZyb21Qb2ludCBtYXkgcmV0dXJuIHRoZSBzaGFkb3dSb290IGhvc3RcbiAgICBpZiAob2xkTmV4dCA9PT0gbmV4dCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChuZXh0KSB7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmluZE9yaWdpbmFsVGFyZ2V0KGV2KSB7XG4gIC8vIHNoYWRvd2RvbVxuICBpZiAoZXYuY29tcG9zZWRQYXRoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7RXZlbnRUYXJnZXR9ICovKGV2LmNvbXBvc2VkUGF0aCgpWzBdKTtcbiAgfVxuICAvLyBzaGFkeWRvbVxuICByZXR1cm4gZXYudGFyZ2V0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gX2hhbmRsZU5hdGl2ZShldikge1xuICBsZXQgaGFuZGxlZDtcbiAgbGV0IHR5cGUgPSBldi50eXBlO1xuICBsZXQgbm9kZSA9IGV2LmN1cnJlbnRUYXJnZXQ7XG4gIGxldCBnb2JqID0gbm9kZVtHRVNUVVJFX0tFWV07XG4gIGlmICghZ29iaikge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgZ3MgPSBnb2JqW3R5cGVdO1xuICBpZiAoIWdzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghZXZbSEFORExFRF9PQkpdKSB7XG4gICAgZXZbSEFORExFRF9PQkpdID0ge307XG4gICAgaWYgKHR5cGUuc2xpY2UoMCwgNSkgPT09ICd0b3VjaCcpIHtcbiAgICAgIGV2ID0gLyoqIEB0eXBlIHtUb3VjaEV2ZW50fSAqLyhldik7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1hc3NpZ25cbiAgICAgIGxldCB0ID0gZXYuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgIC8vIG9ubHkgaGFuZGxlIHRoZSBmaXJzdCBmaW5nZXJcbiAgICAgICAgaWYgKGV2LnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgUE9JTlRFUlNUQVRFLnRvdWNoLmlkID0gdC5pZGVudGlmaWVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoUE9JTlRFUlNUQVRFLnRvdWNoLmlkICE9PSB0LmlkZW50aWZpZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFIQVNfTkFUSVZFX1RBKSB7XG4gICAgICAgIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcgfHwgdHlwZSA9PT0gJ3RvdWNobW92ZScpIHtcbiAgICAgICAgICBfaGFuZGxlVG91Y2hBY3Rpb24oZXYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZWQgPSBldltIQU5ETEVEX09CSl07XG4gIC8vIHVzZWQgdG8gaWdub3JlIHN5bnRoZXRpYyBtb3VzZSBldmVudHNcbiAgaWYgKGhhbmRsZWQuc2tpcCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyByZXNldCByZWNvZ25pemVyIHN0YXRlXG4gIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgaWYgKGdzW3IubmFtZV0gJiYgIWhhbmRsZWRbci5uYW1lXSkge1xuICAgICAgaWYgKHIuZmxvdyAmJiByLmZsb3cuc3RhcnQuaW5kZXhPZihldi50eXBlKSA+IC0xICYmIHIucmVzZXQpIHtcbiAgICAgICAgci5yZXNldCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvLyBlbmZvcmNlIGdlc3R1cmUgcmVjb2duaXplciBvcmRlclxuICBmb3IgKGxldCBpID0gMCwgcjsgaSA8IHJlY29nbml6ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgciA9IHJlY29nbml6ZXJzW2ldO1xuICAgIGlmIChnc1tyLm5hbWVdICYmICFoYW5kbGVkW3IubmFtZV0pIHtcbiAgICAgIGhhbmRsZWRbci5uYW1lXSA9IHRydWU7XG4gICAgICByW3R5cGVdKGV2KTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9oYW5kbGVUb3VjaEFjdGlvbihldikge1xuICBsZXQgdCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdO1xuICBsZXQgdHlwZSA9IGV2LnR5cGU7XG4gIGlmICh0eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2gueCA9IHQuY2xpZW50WDtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2gueSA9IHQuY2xpZW50WTtcbiAgICBQT0lOVEVSU1RBVEUudG91Y2guc2Nyb2xsRGVjaWRlZCA9IGZhbHNlO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgaWYgKFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFBPSU5URVJTVEFURS50b3VjaC5zY3JvbGxEZWNpZGVkID0gdHJ1ZTtcbiAgICBsZXQgdGEgPSBmaXJzdFRvdWNoQWN0aW9uKGV2KTtcbiAgICBsZXQgcHJldmVudCA9IGZhbHNlO1xuICAgIGxldCBkeCA9IE1hdGguYWJzKFBPSU5URVJTVEFURS50b3VjaC54IC0gdC5jbGllbnRYKTtcbiAgICBsZXQgZHkgPSBNYXRoLmFicyhQT0lOVEVSU1RBVEUudG91Y2gueSAtIHQuY2xpZW50WSk7XG4gICAgaWYgKCFldi5jYW5jZWxhYmxlKSB7XG4gICAgICAvLyBzY3JvbGxpbmcgaXMgaGFwcGVuaW5nXG4gICAgfSBlbHNlIGlmICh0YSA9PT0gJ25vbmUnKSB7XG4gICAgICBwcmV2ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXgnKSB7XG4gICAgICBwcmV2ZW50ID0gZHkgPiBkeDtcbiAgICB9IGVsc2UgaWYgKHRhID09PSAncGFuLXknKSB7XG4gICAgICBwcmV2ZW50ID0gZHggPiBkeTtcbiAgICB9XG4gICAgaWYgKHByZXZlbnQpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZlbnQoJ3RyYWNrJyk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRMaXN0ZW5lcihub2RlLCBldlR5cGUsIGhhbmRsZXIpIHtcbiAgaWYgKGdlc3R1cmVzW2V2VHlwZV0pIHtcbiAgICBfYWRkKG5vZGUsIGV2VHlwZSwgaGFuZGxlcik7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGlmIChnZXN0dXJlc1tldlR5cGVdKSB7XG4gICAgX3JlbW92ZShub2RlLCBldlR5cGUsIGhhbmRsZXIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9hZGQobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGxldCByZWNvZ25pemVyID0gZ2VzdHVyZXNbZXZUeXBlXTtcbiAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICBpZiAoIWdvYmopIHtcbiAgICBub2RlW0dFU1RVUkVfS0VZXSA9IGdvYmogPSB7fTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgZGVwLCBnZDsgaSA8IGRlcHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXAgPSBkZXBzW2ldO1xuICAgIC8vIGRvbid0IGFkZCBtb3VzZSBoYW5kbGVycyBvbiBpT1MgYmVjYXVzZSB0aGV5IGNhdXNlIGdyYXkgc2VsZWN0aW9uIG92ZXJsYXlzXG4gICAgaWYgKElTX1RPVUNIX09OTFkgJiYgTU9VU0VfRVZFTlRTLmluZGV4T2YoZGVwKSA+IC0xICYmIGRlcCAhPT0gJ2NsaWNrJykge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGdkID0gZ29ialtkZXBdO1xuICAgIGlmICghZ2QpIHtcbiAgICAgIGdvYmpbZGVwXSA9IGdkID0ge19jb3VudDogMH07XG4gICAgfVxuICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihkZXAsIF9oYW5kbGVOYXRpdmUpO1xuICAgIH1cbiAgICBnZFtuYW1lXSA9IChnZFtuYW1lXSB8fCAwKSArIDE7XG4gICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAwKSArIDE7XG4gIH1cbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2VHlwZSwgaGFuZGxlcik7XG4gIGlmIChyZWNvZ25pemVyLnRvdWNoQWN0aW9uKSB7XG4gICAgc2V0VG91Y2hBY3Rpb24obm9kZSwgcmVjb2duaXplci50b3VjaEFjdGlvbik7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9yZW1vdmUobm9kZSwgZXZUeXBlLCBoYW5kbGVyKSB7XG4gIGxldCByZWNvZ25pemVyID0gZ2VzdHVyZXNbZXZUeXBlXTtcbiAgbGV0IGRlcHMgPSByZWNvZ25pemVyLmRlcHM7XG4gIGxldCBuYW1lID0gcmVjb2duaXplci5uYW1lO1xuICBsZXQgZ29iaiA9IG5vZGVbR0VTVFVSRV9LRVldO1xuICBpZiAoZ29iaikge1xuICAgIGZvciAobGV0IGkgPSAwLCBkZXAsIGdkOyBpIDwgZGVwcy5sZW5ndGg7IGkrKykge1xuICAgICAgZGVwID0gZGVwc1tpXTtcbiAgICAgIGdkID0gZ29ialtkZXBdO1xuICAgICAgaWYgKGdkICYmIGdkW25hbWVdKSB7XG4gICAgICAgIGdkW25hbWVdID0gKGdkW25hbWVdIHx8IDEpIC0gMTtcbiAgICAgICAgZ2QuX2NvdW50ID0gKGdkLl9jb3VudCB8fCAxKSAtIDE7XG4gICAgICAgIGlmIChnZC5fY291bnQgPT09IDApIHtcbiAgICAgICAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZGVwLCBfaGFuZGxlTmF0aXZlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZUeXBlLCBoYW5kbGVyKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdGVyKHJlY29nKSB7XG4gIHJlY29nbml6ZXJzLnB1c2gocmVjb2cpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHJlY29nLmVtaXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgZ2VzdHVyZXNbcmVjb2cuZW1pdHNbaV1dID0gcmVjb2c7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9maW5kUmVjb2duaXplckJ5RXZlbnQoZXZOYW1lKSB7XG4gIGZvciAobGV0IGkgPSAwLCByOyBpIDwgcmVjb2duaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICByID0gcmVjb2duaXplcnNbaV07XG4gICAgZm9yIChsZXQgaiA9IDAsIG47IGogPCByLmVtaXRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBuID0gci5lbWl0c1tqXTtcbiAgICAgIGlmIChuID09PSBldk5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0VG91Y2hBY3Rpb24obm9kZSwgdmFsdWUpIHtcbiAgaWYgKEhBU19OQVRJVkVfVEEpIHtcbiAgICBub2RlLnN0eWxlLnRvdWNoQWN0aW9uID0gdmFsdWU7XG4gIH1cbiAgbm9kZVtUT1VDSF9BQ1RJT05dID0gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZmlyZSh0YXJnZXQsIHR5cGUsIGRldGFpbCkge1xuICBsZXQgZXYgPSBuZXcgRXZlbnQodHlwZSwgeyBidWJibGVzOiB0cnVlLCBjYW5jZWxhYmxlOiB0cnVlLCBjb21wb3NlZDogdHJ1ZSB9KTtcbiAgZXYuZGV0YWlsID0gZGV0YWlsO1xuICB0YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XG4gIC8vIGZvcndhcmQgYHByZXZlbnREZWZhdWx0YCBpbiBhIGNsZWFuIHdheVxuICBpZiAoZXYuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIGxldCBwcmV2ZW50ZXIgPSBkZXRhaWwucHJldmVudGVyIHx8IGRldGFpbC5zb3VyY2VFdmVudDtcbiAgICBpZiAocHJldmVudGVyICYmIHByZXZlbnRlci5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgcHJldmVudGVyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50KGV2TmFtZSkge1xuICBsZXQgcmVjb2duaXplciA9IF9maW5kUmVjb2duaXplckJ5RXZlbnQoZXZOYW1lKTtcbiAgaWYgKHJlY29nbml6ZXIuaW5mbykge1xuICAgIHJlY29nbml6ZXIuaW5mby5wcmV2ZW50ID0gdHJ1ZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRNb3VzZUNhbmNlbGxlcigpIHtcbiAgaWYgKFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYikge1xuICAgIFBPSU5URVJTVEFURS5tb3VzZS5tb3VzZUlnbm9yZUpvYi5mbHVzaCgpO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG5cbnJlZ2lzdGVyKHtcbiAgbmFtZTogJ2Rvd251cCcsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnXSxcbiAgZmxvdzoge1xuICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgZW5kOiBbJ21vdXNldXAnLCAndG91Y2hlbmQnXVxuICB9LFxuICBlbWl0czogWydkb3duJywgJ3VwJ10sXG5cbiAgaW5mbzoge1xuICAgIG1vdmVmbjogbnVsbCxcbiAgICB1cGZuOiBudWxsXG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn0gKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHVudHJhY2tEb2N1bWVudCh0aGlzLmluZm8pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgIGlmICghaGFzTGVmdE1vdXNlQnV0dG9uKGUpKSB7XG4gICAgICAgIHNlbGYuX2ZpcmUoJ3VwJywgdCwgZSk7XG4gICAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZm4gPSBmdW5jdGlvbiB1cGZuKGUpIHtcbiAgICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgICAgc2VsZi5fZmlyZSgndXAnLCB0LCBlKTtcbiAgICAgIH1cbiAgICAgIHVudHJhY2tEb2N1bWVudChzZWxmLmluZm8pO1xuICAgIH07XG4gICAgdHJhY2tEb2N1bWVudCh0aGlzLmluZm8sIG1vdmVmbiwgdXBmbik7XG4gICAgdGhpcy5fZmlyZSgnZG93bicsIHQsIGUpO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLl9maXJlKCdkb3duJywgX2ZpbmRPcmlnaW5hbFRhcmdldChlKSwgZS5jaGFuZ2VkVG91Y2hlc1swXSwgZSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICB0aGlzLl9maXJlKCd1cCcsIF9maW5kT3JpZ2luYWxUYXJnZXQoZSksIGUuY2hhbmdlZFRvdWNoZXNbMF0sIGUpO1xuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtFdmVudFRhcmdldH0gdGFyZ2V0XG4gICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZXZlbnRlclxuICAgKi9cbiAgX2ZpcmU6IGZ1bmN0aW9uKHR5cGUsIHRhcmdldCwgZXZlbnQsIHByZXZlbnRlcikge1xuICAgIF9maXJlKHRhcmdldCwgdHlwZSwge1xuICAgICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICAgIHk6IGV2ZW50LmNsaWVudFksXG4gICAgICBzb3VyY2VFdmVudDogZXZlbnQsXG4gICAgICBwcmV2ZW50ZXI6IHByZXZlbnRlcixcbiAgICAgIHByZXZlbnQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgcmV0dXJuIHByZXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5yZWdpc3Rlcih7XG4gIG5hbWU6ICd0cmFjaycsXG4gIHRvdWNoQWN0aW9uOiAnbm9uZScsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ3RvdWNoc3RhcnQnLCAndG91Y2htb3ZlJywgJ3RvdWNoZW5kJ10sXG4gIGZsb3c6IHtcbiAgICBzdGFydDogWydtb3VzZWRvd24nLCAndG91Y2hzdGFydCddLFxuICAgIGVuZDogWydtb3VzZXVwJywgJ3RvdWNoZW5kJ11cbiAgfSxcbiAgZW1pdHM6IFsndHJhY2snXSxcblxuICBpbmZvOiB7XG4gICAgeDogMCxcbiAgICB5OiAwLFxuICAgIHN0YXRlOiAnc3RhcnQnLFxuICAgIHN0YXJ0ZWQ6IGZhbHNlLFxuICAgIG1vdmVzOiBbXSxcbiAgICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICAgIGFkZE1vdmU6IGZ1bmN0aW9uKG1vdmUpIHtcbiAgICAgIGlmICh0aGlzLm1vdmVzLmxlbmd0aCA+IFRSQUNLX0xFTkdUSCkge1xuICAgICAgICB0aGlzLm1vdmVzLnNoaWZ0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLm1vdmVzLnB1c2gobW92ZSk7XG4gICAgfSxcbiAgICBtb3ZlZm46IG51bGwsXG4gICAgdXBmbjogbnVsbCxcbiAgICBwcmV2ZW50OiBmYWxzZVxuICB9LFxuXG4gIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluZm8uc3RhdGUgPSAnc3RhcnQnO1xuICAgIHRoaXMuaW5mby5zdGFydGVkID0gZmFsc2U7XG4gICAgdGhpcy5pbmZvLm1vdmVzID0gW107XG4gICAgdGhpcy5pbmZvLnggPSAwO1xuICAgIHRoaXMuaW5mby55ID0gMDtcbiAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICAgIHVudHJhY2tEb2N1bWVudCh0aGlzLmluZm8pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBoYXNNb3ZlZEVub3VnaDogZnVuY3Rpb24oeCwgeSkge1xuICAgIGlmICh0aGlzLmluZm8ucHJldmVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgZHggPSBNYXRoLmFicyh0aGlzLmluZm8ueCAtIHgpO1xuICAgIGxldCBkeSA9IE1hdGguYWJzKHRoaXMuaW5mby55IC0geSk7XG4gICAgcmV0dXJuIChkeCA+PSBUUkFDS19ESVNUQU5DRSB8fCBkeSA+PSBUUkFDS19ESVNUQU5DRSk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKCFoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBzZWxmID0gdGhpcztcbiAgICBsZXQgbW92ZWZuID0gZnVuY3Rpb24gbW92ZWZuKGUpIHtcbiAgICAgIGxldCB4ID0gZS5jbGllbnRYLCB5ID0gZS5jbGllbnRZO1xuICAgICAgaWYgKHNlbGYuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgICAgLy8gZmlyc3QgbW92ZSBpcyAnc3RhcnQnLCBzdWJzZXF1ZW50IG1vdmVzIGFyZSAnbW92ZScsIG1vdXNldXAgaXMgJ2VuZCdcbiAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gc2VsZi5pbmZvLnN0YXJ0ZWQgPyAoZS50eXBlID09PSAnbW91c2V1cCcgPyAnZW5kJyA6ICd0cmFjaycpIDogJ3N0YXJ0JztcbiAgICAgICAgaWYgKHNlbGYuaW5mby5zdGF0ZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgIC8vIGlmIGFuZCBvbmx5IGlmIHRyYWNraW5nLCBhbHdheXMgcHJldmVudCB0YXBcbiAgICAgICAgICBwcmV2ZW50KCd0YXAnKTtcbiAgICAgICAgfVxuICAgICAgICBzZWxmLmluZm8uYWRkTW92ZSh7eDogeCwgeTogeX0pO1xuICAgICAgICBpZiAoIWhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgICAgIC8vIGFsd2F5cyBfZmlyZSBcImVuZFwiXG4gICAgICAgICAgc2VsZi5pbmZvLnN0YXRlID0gJ2VuZCc7XG4gICAgICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5fZmlyZSh0LCBlKTtcbiAgICAgICAgc2VsZi5pbmZvLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH07XG4gICAgbGV0IHVwZm4gPSBmdW5jdGlvbiB1cGZuKGUpIHtcbiAgICAgIGlmIChzZWxmLmluZm8uc3RhcnRlZCkge1xuICAgICAgICBtb3ZlZm4oZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHJlbW92ZSB0aGUgdGVtcG9yYXJ5IGxpc3RlbmVyc1xuICAgICAgdW50cmFja0RvY3VtZW50KHNlbGYuaW5mbyk7XG4gICAgfTtcbiAgICAvLyBhZGQgdGVtcG9yYXJ5IGRvY3VtZW50IGxpc3RlbmVycyBhcyBtb3VzZSByZXRhcmdldHNcbiAgICB0cmFja0RvY3VtZW50KHRoaXMuaW5mbywgbW92ZWZuLCB1cGZuKTtcbiAgICB0aGlzLmluZm8ueCA9IGUuY2xpZW50WDtcbiAgICB0aGlzLmluZm8ueSA9IGUuY2xpZW50WTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaHN0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgbGV0IGN0ID0gZS5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICB0aGlzLmluZm8ueCA9IGN0LmNsaWVudFg7XG4gICAgdGhpcy5pbmZvLnkgPSBjdC5jbGllbnRZO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNobW92ZTogZnVuY3Rpb24oZSkge1xuICAgIGxldCB0ID0gX2ZpbmRPcmlnaW5hbFRhcmdldChlKTtcbiAgICBsZXQgY3QgPSBlLmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgIGxldCB4ID0gY3QuY2xpZW50WCwgeSA9IGN0LmNsaWVudFk7XG4gICAgaWYgKHRoaXMuaGFzTW92ZWRFbm91Z2goeCwgeSkpIHtcbiAgICAgIGlmICh0aGlzLmluZm8uc3RhdGUgPT09ICdzdGFydCcpIHtcbiAgICAgICAgLy8gaWYgYW5kIG9ubHkgaWYgdHJhY2tpbmcsIGFsd2F5cyBwcmV2ZW50IHRhcFxuICAgICAgICBwcmV2ZW50KCd0YXAnKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5mby5hZGRNb3ZlKHt4OiB4LCB5OiB5fSk7XG4gICAgICB0aGlzLl9maXJlKHQsIGN0KTtcbiAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICd0cmFjayc7XG4gICAgICB0aGlzLmluZm8uc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge1RvdWNoRXZlbnR9IGVcbiAgICovXG4gIHRvdWNoZW5kOiBmdW5jdGlvbihlKSB7XG4gICAgbGV0IHQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0KGUpO1xuICAgIGxldCBjdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF07XG4gICAgLy8gb25seSB0cmFja2VuZCBpZiB0cmFjayB3YXMgc3RhcnRlZCBhbmQgbm90IGFib3J0ZWRcbiAgICBpZiAodGhpcy5pbmZvLnN0YXJ0ZWQpIHtcbiAgICAgIC8vIHJlc2V0IHN0YXJ0ZWQgc3RhdGUgb24gdXBcbiAgICAgIHRoaXMuaW5mby5zdGF0ZSA9ICdlbmQnO1xuICAgICAgdGhpcy5pbmZvLmFkZE1vdmUoe3g6IGN0LmNsaWVudFgsIHk6IGN0LmNsaWVudFl9KTtcbiAgICAgIHRoaXMuX2ZpcmUodCwgY3QsIGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfVxuICAgKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSB0YXJnZXRcbiAgICogQHBhcmFtIHtUb3VjaH0gdG91Y2hcbiAgICovXG4gIF9maXJlOiBmdW5jdGlvbih0YXJnZXQsIHRvdWNoKSB7XG4gICAgbGV0IHNlY29uZGxhc3QgPSB0aGlzLmluZm8ubW92ZXNbdGhpcy5pbmZvLm1vdmVzLmxlbmd0aCAtIDJdO1xuICAgIGxldCBsYXN0bW92ZSA9IHRoaXMuaW5mby5tb3Zlc1t0aGlzLmluZm8ubW92ZXMubGVuZ3RoIC0gMV07XG4gICAgbGV0IGR4ID0gbGFzdG1vdmUueCAtIHRoaXMuaW5mby54O1xuICAgIGxldCBkeSA9IGxhc3Rtb3ZlLnkgLSB0aGlzLmluZm8ueTtcbiAgICBsZXQgZGR4LCBkZHkgPSAwO1xuICAgIGlmIChzZWNvbmRsYXN0KSB7XG4gICAgICBkZHggPSBsYXN0bW92ZS54IC0gc2Vjb25kbGFzdC54O1xuICAgICAgZGR5ID0gbGFzdG1vdmUueSAtIHNlY29uZGxhc3QueTtcbiAgICB9XG4gICAgX2ZpcmUodGFyZ2V0LCAndHJhY2snLCB7XG4gICAgICBzdGF0ZTogdGhpcy5pbmZvLnN0YXRlLFxuICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgIHk6IHRvdWNoLmNsaWVudFksXG4gICAgICBkeDogZHgsXG4gICAgICBkeTogZHksXG4gICAgICBkZHg6IGRkeCxcbiAgICAgIGRkeTogZGR5LFxuICAgICAgc291cmNlRXZlbnQ6IHRvdWNoLFxuICAgICAgaG92ZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZGVlcFRhcmdldEZpbmQodG91Y2guY2xpZW50WCwgdG91Y2guY2xpZW50WSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbnJlZ2lzdGVyKHtcbiAgbmFtZTogJ3RhcCcsXG4gIGRlcHM6IFsnbW91c2Vkb3duJywgJ2NsaWNrJywgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnXSxcbiAgZmxvdzoge1xuICAgIHN0YXJ0OiBbJ21vdXNlZG93bicsICd0b3VjaHN0YXJ0J10sXG4gICAgZW5kOiBbJ2NsaWNrJywgJ3RvdWNoZW5kJ11cbiAgfSxcbiAgZW1pdHM6IFsndGFwJ10sXG4gIGluZm86IHtcbiAgICB4OiBOYU4sXG4gICAgeTogTmFOLFxuICAgIHByZXZlbnQ6IGZhbHNlXG4gIH0sXG4gIC8qKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9ICovXG4gIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmluZm8ueCA9IE5hTjtcbiAgICB0aGlzLmluZm8ueSA9IE5hTjtcbiAgICB0aGlzLmluZm8ucHJldmVudCA9IGZhbHNlO1xuICB9LFxuICAvKiogQHRoaXMge0dlc3R1cmVSZWNvZ25pemVyfSAqL1xuICBzYXZlOiBmdW5jdGlvbihlKSB7XG4gICAgdGhpcy5pbmZvLnggPSBlLmNsaWVudFg7XG4gICAgdGhpcy5pbmZvLnkgPSBlLmNsaWVudFk7XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuICAgKi9cbiAgbW91c2Vkb3duOiBmdW5jdGlvbihlKSB7XG4gICAgaWYgKGhhc0xlZnRNb3VzZUJ1dHRvbihlKSkge1xuICAgICAgdGhpcy5zYXZlKGUpO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBlXG4gICAqL1xuICBjbGljazogZnVuY3Rpb24oZSkge1xuICAgIGlmIChoYXNMZWZ0TW91c2VCdXR0b24oZSkpIHtcbiAgICAgIHRoaXMuZm9yd2FyZChlKTtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBAdGhpcyB7R2VzdHVyZVJlY29nbml6ZXJ9XG4gICAqIEBwYXJhbSB7VG91Y2hFdmVudH0gZVxuICAgKi9cbiAgdG91Y2hzdGFydDogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuc2F2ZShlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtUb3VjaEV2ZW50fSBlXG4gICAqL1xuICB0b3VjaGVuZDogZnVuY3Rpb24oZSkge1xuICAgIHRoaXMuZm9yd2FyZChlLmNoYW5nZWRUb3VjaGVzWzBdLCBlKTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtHZXN0dXJlUmVjb2duaXplcn1cbiAgICogQHBhcmFtIHtFdmVudCB8IFRvdWNofSBlXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBwcmV2ZW50ZXJcbiAgICovXG4gIGZvcndhcmQ6IGZ1bmN0aW9uKGUsIHByZXZlbnRlcikge1xuICAgIGxldCBkeCA9IE1hdGguYWJzKGUuY2xpZW50WCAtIHRoaXMuaW5mby54KTtcbiAgICBsZXQgZHkgPSBNYXRoLmFicyhlLmNsaWVudFkgLSB0aGlzLmluZm8ueSk7XG4gICAgLy8gZmluZCBvcmlnaW5hbCB0YXJnZXQgZnJvbSBgcHJldmVudGVyYCBmb3IgVG91Y2hFdmVudHMsIG9yIGBlYCBmb3IgTW91c2VFdmVudHNcbiAgICBsZXQgdCA9IF9maW5kT3JpZ2luYWxUYXJnZXQoKHByZXZlbnRlciB8fCBlKSk7XG4gICAgLy8gZHgsZHkgY2FuIGJlIE5hTiBpZiBgY2xpY2tgIGhhcyBiZWVuIHNpbXVsYXRlZCBhbmQgdGhlcmUgd2FzIG5vIGBkb3duYCBmb3IgYHN0YXJ0YFxuICAgIGlmIChpc05hTihkeCkgfHwgaXNOYU4oZHkpIHx8IChkeCA8PSBUQVBfRElTVEFOQ0UgJiYgZHkgPD0gVEFQX0RJU1RBTkNFKSB8fCBpc1N5bnRoZXRpY0NsaWNrKGUpKSB7XG4gICAgICAvLyBwcmV2ZW50IHRhcHMgZnJvbSBiZWluZyBnZW5lcmF0ZWQgaWYgYW4gZXZlbnQgaGFzIGNhbmNlbGVkIHRoZW1cbiAgICAgIGlmICghdGhpcy5pbmZvLnByZXZlbnQpIHtcbiAgICAgICAgX2ZpcmUodCwgJ3RhcCcsIHtcbiAgICAgICAgICB4OiBlLmNsaWVudFgsXG4gICAgICAgICAgeTogZS5jbGllbnRZLFxuICAgICAgICAgIHNvdXJjZUV2ZW50OiBlLFxuICAgICAgICAgIHByZXZlbnRlcjogcHJldmVudGVyXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBjb25zdCBmaW5kT3JpZ2luYWxUYXJnZXQgPSBfZmluZE9yaWdpbmFsVGFyZ2V0O1xuZXhwb3J0IGNvbnN0IGFkZCA9IGFkZExpc3RlbmVyO1xuZXhwb3J0IGNvbnN0IHJlbW92ZSA9IHJlbW92ZUxpc3RlbmVyO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCAnLi9taXhpbi5qcyc7XG5pbXBvcnQgJy4vYXN5bmMuanMnO1xuXG4vKiogQHR5cGVkZWYge3tydW46IGZ1bmN0aW9uKGZ1bmN0aW9uKCksIG51bWJlcj0pOm51bWJlciwgY2FuY2VsOiBmdW5jdGlvbihudW1iZXIpfX0gKi9cbmxldCBBc3luY01vZHVsZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKipcbiAqIEBzdW1tYXJ5IENvbGxhcHNlIG11bHRpcGxlIGNhbGxiYWNrcyBpbnRvIG9uZSBpbnZvY2F0aW9uIGFmdGVyIGEgdGltZXIuXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICovXG5jbGFzcyBEZWJvdW5jZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9hc3luY01vZHVsZSA9IG51bGw7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBudWxsO1xuICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgc2NoZWR1bGVyOyB0aGF0IGlzLCBhIG1vZHVsZSB3aXRoIHRoZSBBc3luYyBpbnRlcmZhY2UsXG4gICAqIGEgY2FsbGJhY2sgYW5kIG9wdGlvbmFsIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gdGhlIHJ1biBmdW5jdGlvblxuICAgKiBmcm9tIHRoZSBhc3luYyBtb2R1bGUuXG4gICAqXG4gICAqIEBwYXJhbSB7IUFzeW5jTW9kdWxlfSBhc3luY01vZHVsZSBPYmplY3Qgd2l0aCBBc3luYyBpbnRlcmZhY2UuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKX0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gcnVuLlxuICAgKi9cbiAgc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2FzeW5jTW9kdWxlID0gYXN5bmNNb2R1bGU7XG4gICAgdGhpcy5fY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLl90aW1lciA9IHRoaXMuX2FzeW5jTW9kdWxlLnJ1bigoKSA9PiB7XG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgICB0aGlzLl9jYWxsYmFjaygpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLlxuICAgKi9cbiAgY2FuY2VsKCkge1xuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHtcbiAgICAgIHRoaXMuX2FzeW5jTW9kdWxlLmNhbmNlbCh0aGlzLl90aW1lcik7XG4gICAgICB0aGlzLl90aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBGbHVzaGVzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG8gaXRzZWxmLlxuICAgKi9cbiAgZmx1c2goKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgIHRoaXMuX2NhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGRlYm91bmNlciBpcyBhY3RpdmUuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYWN0aXZlLlxuICAgKi9cbiAgaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RpbWVyICE9IG51bGw7XG4gIH1cbi8qKlxuICogQ3JlYXRlcyBhIGRlYm91bmNlciBpZiBubyBkZWJvdW5jZXIgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gKiBvciBpdCBjYW5jZWxzIGFuIGFjdGl2ZSBkZWJvdW5jZXIgb3RoZXJ3aXNlLiBUaGUgZm9sbG93aW5nXG4gKiBleGFtcGxlIHNob3dzIGhvdyBhIGRlYm91bmNlciBjYW4gYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdpdGhpbiBhXG4gKiBtaWNyb3Rhc2sgYW5kIFwiZGVib3VuY2VkXCIgc3VjaCB0aGF0IHRoZSBwcm92aWRlZCBjYWxsYmFjayBmdW5jdGlvbiBpc1xuICogY2FsbGVkIG9uY2UuIEFkZCB0aGlzIG1ldGhvZCB0byBhIGN1c3RvbSBlbGVtZW50OlxuICpcbiAqIF9kZWJvdW5jZVdvcmsoKSB7XG4gKiAgIHRoaXMuX2RlYm91bmNlSm9iID0gUG9seW1lci5EZWJvdW5jZXIuZGVib3VuY2UodGhpcy5fZGVib3VuY2VKb2IsXG4gKiAgICAgICBQb2x5bWVyLkFzeW5jLm1pY3JvVGFzaywgKCkgPT4ge1xuICogICAgIHRoaXMuX2RvV29yaygpO1xuICogICB9KTtcbiAqIH1cbiAqXG4gKiBJZiB0aGUgYF9kZWJvdW5jZVdvcmtgIG1ldGhvZCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aGluIHRoZSBzYW1lXG4gKiBtaWNyb3Rhc2ssIHRoZSBgX2RvV29ya2AgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIGF0IHRoZSBuZXh0XG4gKiBtaWNyb3Rhc2sgY2hlY2twb2ludC5cbiAqXG4gKiBOb3RlOiBJbiB0ZXN0aW5nIGl0IGlzIG9mdGVuIGNvbnZlbmllbnQgdG8gYXZvaWQgYXN5bmNocm9ueS4gVG8gYWNjb21wbGlzaFxuICogdGhpcyB3aXRoIGEgZGVib3VuY2VyLCB5b3UgY2FuIHVzZSBgUG9seW1lci5lbnF1ZXVlRGVib3VuY2VyYCBhbmRcbiAqIGBQb2x5bWVyLmZsdXNoYC4gRm9yIGV4YW1wbGUsIGV4dGVuZCB0aGUgYWJvdmUgZXhhbXBsZSBieSBhZGRpbmdcbiAqIGBQb2x5bWVyLmVucXVldWVEZWJvdW5jZXIodGhpcy5fZGVib3VuY2VKb2IpYCBhdCB0aGUgZW5kIG9mIHRoZVxuICogYF9kZWJvdW5jZVdvcmtgIG1ldGhvZC4gVGhlbiBpbiBhIHRlc3QsIGNhbGwgYFBvbHltZXIuZmx1c2hgIHRvIGVuc3VyZVxuICogdGhlIGRlYm91bmNlciBoYXMgY29tcGxldGVkLlxuICpcbiAqIEBwYXJhbSB7RGVib3VuY2VyP30gZGVib3VuY2VyIERlYm91bmNlciBvYmplY3QuXG4gKiBAcGFyYW0geyFBc3luY01vZHVsZX0gYXN5bmNNb2R1bGUgT2JqZWN0IHdpdGggQXN5bmMgaW50ZXJmYWNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIENhbGxiYWNrIHRvIHJ1bi5cbiAqIEByZXR1cm4geyFEZWJvdW5jZXJ9IFJldHVybnMgYSBkZWJvdW5jZXIgb2JqZWN0LlxuICovXG4gIHN0YXRpYyBkZWJvdW5jZShkZWJvdW5jZXIsIGFzeW5jTW9kdWxlLCBjYWxsYmFjaykge1xuICAgIGlmIChkZWJvdW5jZXIgaW5zdGFuY2VvZiBEZWJvdW5jZXIpIHtcbiAgICAgIGRlYm91bmNlci5jYW5jZWwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVib3VuY2VyID0gbmV3IERlYm91bmNlcigpO1xuICAgIH1cbiAgICBkZWJvdW5jZXIuc2V0Q29uZmlnKGFzeW5jTW9kdWxlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIGRlYm91bmNlcjtcbiAgfVxufVxuXG5leHBvcnQgeyBEZWJvdW5jZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2RlYm91bmNlLmpzXG4vLyBtb2R1bGUgaWQgPSAxM1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuXG4vLyBDb21tb24gaW1wbGVtZW50YXRpb24gZm9yIG1peGluICYgYmVoYXZpb3JcbmZ1bmN0aW9uIG11dGFibGVQcm9wZXJ0eUNoYW5nZShpbnN0LCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgbXV0YWJsZURhdGEpIHtcbiAgbGV0IGlzT2JqZWN0O1xuICBpZiAobXV0YWJsZURhdGEpIHtcbiAgICBpc09iamVjdCA9ICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKTtcbiAgICAvLyBQdWxsIGBvbGRgIGZvciBPYmplY3RzIGZyb20gdGVtcCBjYWNoZSwgYnV0IHRyZWF0IGBudWxsYCBhcyBhIHByaW1pdGl2ZVxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgb2xkID0gaW5zdC5fX2RhdGFUZW1wW3Byb3BlcnR5XTtcbiAgICB9XG4gIH1cbiAgLy8gU3RyaWN0IGVxdWFsaXR5IGNoZWNrLCBidXQgcmV0dXJuIGZhbHNlIGZvciBOYU49PT1OYU5cbiAgbGV0IHNob3VsZENoYW5nZSA9IChvbGQgIT09IHZhbHVlICYmIChvbGQgPT09IG9sZCB8fCB2YWx1ZSA9PT0gdmFsdWUpKTtcbiAgLy8gT2JqZWN0cyBhcmUgc3RvcmVkIGluIHRlbXBvcmFyeSBjYWNoZSAoY2xlYXJlZCBhdCBlbmQgb2ZcbiAgLy8gdHVybiksIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nXG4gIGlmIChpc09iamVjdCAmJiBzaG91bGRDaGFuZ2UpIHtcbiAgICBpbnN0Ll9fZGF0YVRlbXBbcHJvcGVydHldID0gdmFsdWU7XG4gIH1cbiAgcmV0dXJuIHNob3VsZENoYW5nZTtcbn1cblxuZXhwb3J0IGNvbnN0IE11dGFibGVEYXRhID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gICAqL1xuICBjbGFzcyBNdXRhYmxlRGF0YSBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHByb3ZpZGUgb3B0aW9uIGZvciBza2lwcGluZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcHVsbHMgdGhlIHZhbHVlIHRvIGRpcnR5IGNoZWNrIGFnYWluc3QgZnJvbSB0aGUgYF9fZGF0YVRlbXBgXG4gICAgICogY2FjaGUgKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICAgKiBjYWNoZSBpcyBjbGVhcmVkIGF0IHRoZSBlbmQgb2YgYSB0dXJuLCB0aGlzIGltcGxlbWVudGF0aW9uIGFsbG93c1xuICAgICAqIHNpZGUtZWZmZWN0cyBvZiBkZWVwIG9iamVjdCBjaGFuZ2VzIHRvIGJlIHByb2Nlc3NlZCBieSByZS1zZXR0aW5nIHRoZVxuICAgICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICAgKiBjeWNsZXMgZHVlIHRvIDItd2F5IG5vdGlmaWNhdGlvbikuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgTmV3IHByb3BlcnR5IHZhbHVlXG4gICAgICogQHBhcmFtIHsqfSBvbGQgUHJldmlvdXMgcHJvcGVydHkgdmFsdWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICAgIHJldHVybiBtdXRhYmxlUHJvcGVydHlDaGFuZ2UodGhpcywgcHJvcGVydHksIHZhbHVlLCBvbGQsIHRydWUpO1xuICAgIH1cblxuICB9XG4gIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgTXV0YWJsZURhdGEucHJvdG90eXBlLm11dGFibGVEYXRhID0gZmFsc2U7XG5cbiAgcmV0dXJuIE11dGFibGVEYXRhO1xuXG59KTtcblxuZXhwb3J0IGNvbnN0IE9wdGlvbmFsTXV0YWJsZURhdGEgPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAcG9seW1lclxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICAgKi9cbiAgY2xhc3MgT3B0aW9uYWxNdXRhYmxlRGF0YSBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluc3RhbmNlLWxldmVsIGZsYWcgZm9yIGNvbmZpZ3VyaW5nIHRoZSBkaXJ0eS1jaGVja2luZyBzdHJhdGVneVxuICAgICAgICAgKiBmb3IgdGhpcyBlbGVtZW50LiAgV2hlbiB0cnVlLCBPYmplY3RzIGFuZCBBcnJheXMgd2lsbCBza2lwIGRpcnR5XG4gICAgICAgICAqIGNoZWNraW5nLCBvdGhlcndpc2Ugc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIG11dGFibGVEYXRhOiBCb29sZWFuXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNgIHRvIHByb3ZpZGUgb3B0aW9uIGZvciBza2lwcGluZ1xuICAgICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgICAqXG4gICAgICogV2hlbiBgdGhpcy5tdXRhYmxlRGF0YWAgaXMgdHJ1ZSBvbiB0aGlzIGluc3RhbmNlLCB0aGlzIG1ldGhvZFxuICAgICAqIHB1bGxzIHRoZSB2YWx1ZSB0byBkaXJ0eSBjaGVjayBhZ2FpbnN0IGZyb20gdGhlIGBfX2RhdGFUZW1wYCBjYWNoZVxuICAgICAqIChyYXRoZXIgdGhhbiB0aGUgbm9ybWFsIGBfX2RhdGFgIGNhY2hlKSBmb3IgT2JqZWN0cy4gIFNpbmNlIHRoZSB0ZW1wXG4gICAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICAgKiBzaWRlLWVmZmVjdHMgb2YgZGVlcCBvYmplY3QgY2hhbmdlcyB0byBiZSBwcm9jZXNzZWQgYnkgcmUtc2V0dGluZyB0aGVcbiAgICAgKiBzYW1lIG9iamVjdCAodXNpbmcgdGhlIHRlbXAgY2FjaGUgYXMgYW4gaW4tdHVybiBiYWNrc3RvcCB0byBwcmV2ZW50XG4gICAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0aGlzLm11dGFibGVEYXRhKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gT3B0aW9uYWxNdXRhYmxlRGF0YTtcblxufSk7XG5cbi8vIEV4cG9ydCBmb3IgdXNlIGJ5IGxlZ2FjeSBiZWhhdmlvclxuTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZSA9IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9tdXRhYmxlLWRhdGEuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcblxuLyoqXG4gKiBDaHJvbWUgdXNlcyBhbiBvbGRlciB2ZXJzaW9uIG9mIERPTSBMZXZlbCAzIEtleWJvYXJkIEV2ZW50c1xuICpcbiAqIE1vc3Qga2V5cyBhcmUgbGFiZWxlZCBhcyB0ZXh0LCBidXQgc29tZSBhcmUgVW5pY29kZSBjb2RlcG9pbnRzLlxuICogVmFsdWVzIHRha2VuIGZyb206IGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDcvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDcxMjIxL2tleXNldC5odG1sI0tleVNldC1TZXRcbiAqL1xudmFyIEtFWV9JREVOVElGSUVSID0ge1xuICAnVSswMDA4JzogJ2JhY2tzcGFjZScsXG4gICdVKzAwMDknOiAndGFiJyxcbiAgJ1UrMDAxQic6ICdlc2MnLFxuICAnVSswMDIwJzogJ3NwYWNlJyxcbiAgJ1UrMDA3Ric6ICdkZWwnXG59O1xuXG4vKipcbiAqIFNwZWNpYWwgdGFibGUgZm9yIEtleWJvYXJkRXZlbnQua2V5Q29kZS5cbiAqIEtleWJvYXJkRXZlbnQua2V5SWRlbnRpZmllciBpcyBiZXR0ZXIsIGFuZCBLZXlCb2FyZEV2ZW50LmtleSBpcyBldmVuIGJldHRlclxuICogdGhhbiB0aGF0LlxuICpcbiAqIFZhbHVlcyBmcm9tOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudC5rZXlDb2RlI1ZhbHVlX29mX2tleUNvZGVcbiAqL1xudmFyIEtFWV9DT0RFID0ge1xuICA4OiAnYmFja3NwYWNlJyxcbiAgOTogJ3RhYicsXG4gIDEzOiAnZW50ZXInLFxuICAyNzogJ2VzYycsXG4gIDMzOiAncGFnZXVwJyxcbiAgMzQ6ICdwYWdlZG93bicsXG4gIDM1OiAnZW5kJyxcbiAgMzY6ICdob21lJyxcbiAgMzI6ICdzcGFjZScsXG4gIDM3OiAnbGVmdCcsXG4gIDM4OiAndXAnLFxuICAzOTogJ3JpZ2h0JyxcbiAgNDA6ICdkb3duJyxcbiAgNDY6ICdkZWwnLFxuICAxMDY6ICcqJ1xufTtcblxuLyoqXG4gKiBNT0RJRklFUl9LRVlTIG1hcHMgdGhlIHNob3J0IG5hbWUgZm9yIG1vZGlmaWVyIGtleXMgdXNlZCBpbiBhIGtleVxuICogY29tYm8gc3RyaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lIHRoYXQgcmVmZXJlbmNlcyB0aG9zZSBzYW1lIGtleXNcbiAqIGluIGEgS2V5Ym9hcmRFdmVudCBpbnN0YW5jZS5cbiAqL1xudmFyIE1PRElGSUVSX0tFWVMgPSB7XG4gICdzaGlmdCc6ICdzaGlmdEtleScsXG4gICdjdHJsJzogJ2N0cmxLZXknLFxuICAnYWx0JzogJ2FsdEtleScsXG4gICdtZXRhJzogJ21ldGFLZXknXG59O1xuXG4vKipcbiAqIEtleWJvYXJkRXZlbnQua2V5IGlzIG1vc3RseSByZXByZXNlbnRlZCBieSBwcmludGFibGUgY2hhcmFjdGVyIG1hZGUgYnlcbiAqIHRoZSBrZXlib2FyZCwgd2l0aCB1bnByaW50YWJsZSBrZXlzIGxhYmVsZWQgbmljZWx5LlxuICpcbiAqIEhvd2V2ZXIsIG9uIE9TIFgsIEFsdCtjaGFyIGNhbiBtYWtlIGEgVW5pY29kZSBjaGFyYWN0ZXIgdGhhdCBmb2xsb3dzIGFuXG4gKiBBcHBsZS1zcGVjaWZpYyBtYXBwaW5nLiBJbiB0aGlzIGNhc2UsIHdlIGZhbGwgYmFjayB0byAua2V5Q29kZS5cbiAqL1xudmFyIEtFWV9DSEFSID0gL1thLXowLTkqXS87XG5cbi8qKlxuICogTWF0Y2hlcyBhIGtleUlkZW50aWZpZXIgc3RyaW5nLlxuICovXG52YXIgSURFTlRfQ0hBUiA9IC9VXFwrLztcblxuLyoqXG4gKiBNYXRjaGVzIGFycm93IGtleXMgaW4gR2Vja28gMjcuMCtcbiAqL1xudmFyIEFSUk9XX0tFWSA9IC9eYXJyb3cvO1xuXG4vKipcbiAqIE1hdGNoZXMgc3BhY2Uga2V5cyBldmVyeXdoZXJlIChub3RhYmx5IGluY2x1ZGluZyBJRTEwJ3MgZXhjZXB0aW9uYWwgbmFtZVxuICogYHNwYWNlYmFyYCkuXG4gKi9cbnZhciBTUEFDRV9LRVkgPSAvXnNwYWNlKGJhcik/LztcblxuLyoqXG4gKiBNYXRjaGVzIEVTQyBrZXkuXG4gKlxuICogVmFsdWUgZnJvbTogaHR0cDovL3czYy5naXRodWIuaW8vdWlldmVudHMta2V5LyNrZXktRXNjYXBlXG4gKi9cbnZhciBFU0NfS0VZID0gL15lc2NhcGUkLztcblxuLyoqXG4gKiBUcmFuc2Zvcm1zIHRoZSBrZXkuXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBLZXlCb2FyZEV2ZW50LmtleVxuICogQHBhcmFtIHtCb29sZWFufSBbbm9TcGVjaWFsQ2hhcnNdIExpbWl0cyB0aGUgdHJhbnNmb3JtYXRpb24gdG9cbiAqIGFscGhhLW51bWVyaWMgY2hhcmFjdGVycy5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtS2V5KGtleSwgbm9TcGVjaWFsQ2hhcnMpIHtcbiAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gIGlmIChrZXkpIHtcbiAgICB2YXIgbEtleSA9IGtleS50b0xvd2VyQ2FzZSgpO1xuICAgIGlmIChsS2V5ID09PSAnICcgfHwgU1BBQ0VfS0VZLnRlc3QobEtleSkpIHtcbiAgICAgIHZhbGlkS2V5ID0gJ3NwYWNlJztcbiAgICB9IGVsc2UgaWYgKEVTQ19LRVkudGVzdChsS2V5KSkge1xuICAgICAgdmFsaWRLZXkgPSAnZXNjJztcbiAgICB9IGVsc2UgaWYgKGxLZXkubGVuZ3RoID09IDEpIHtcbiAgICAgIGlmICghbm9TcGVjaWFsQ2hhcnMgfHwgS0VZX0NIQVIudGVzdChsS2V5KSkge1xuICAgICAgICB2YWxpZEtleSA9IGxLZXk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBUlJPV19LRVkudGVzdChsS2V5KSkge1xuICAgICAgdmFsaWRLZXkgPSBsS2V5LnJlcGxhY2UoJ2Fycm93JywgJycpO1xuICAgIH0gZWxzZSBpZiAobEtleSA9PSAnbXVsdGlwbHknKSB7XG4gICAgICAvLyBudW1wYWQgJyonIGNhbiBtYXAgdG8gTXVsdGlwbHkgb24gSUUvV2luZG93c1xuICAgICAgdmFsaWRLZXkgPSAnKic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkS2V5ID0gbEtleTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbGlkS2V5O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1LZXlJZGVudGlmaWVyKGtleUlkZW50KSB7XG4gIHZhciB2YWxpZEtleSA9ICcnO1xuICBpZiAoa2V5SWRlbnQpIHtcbiAgICBpZiAoa2V5SWRlbnQgaW4gS0VZX0lERU5USUZJRVIpIHtcbiAgICAgIHZhbGlkS2V5ID0gS0VZX0lERU5USUZJRVJba2V5SWRlbnRdO1xuICAgIH0gZWxzZSBpZiAoSURFTlRfQ0hBUi50ZXN0KGtleUlkZW50KSkge1xuICAgICAga2V5SWRlbnQgPSBwYXJzZUludChrZXlJZGVudC5yZXBsYWNlKCdVKycsICcweCcpLCAxNik7XG4gICAgICB2YWxpZEtleSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoa2V5SWRlbnQpLnRvTG93ZXJDYXNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkS2V5ID0ga2V5SWRlbnQudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbGlkS2V5O1xufVxuXG5mdW5jdGlvbiB0cmFuc2Zvcm1LZXlDb2RlKGtleUNvZGUpIHtcbiAgdmFyIHZhbGlkS2V5ID0gJyc7XG4gIGlmIChOdW1iZXIoa2V5Q29kZSkpIHtcbiAgICBpZiAoa2V5Q29kZSA+PSA2NSAmJiBrZXlDb2RlIDw9IDkwKSB7XG4gICAgICAvLyBhc2NpaSBhLXpcbiAgICAgIC8vIGxvd2VyY2FzZSBpcyAzMiBvZmZzZXQgZnJvbSB1cHBlcmNhc2VcbiAgICAgIHZhbGlkS2V5ID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMiArIGtleUNvZGUpO1xuICAgIH0gZWxzZSBpZiAoa2V5Q29kZSA+PSAxMTIgJiYga2V5Q29kZSA8PSAxMjMpIHtcbiAgICAgIC8vIGZ1bmN0aW9uIGtleXMgZjEtZjEyXG4gICAgICB2YWxpZEtleSA9ICdmJyArIChrZXlDb2RlIC0gMTEyICsgMSk7XG4gICAgfSBlbHNlIGlmIChrZXlDb2RlID49IDQ4ICYmIGtleUNvZGUgPD0gNTcpIHtcbiAgICAgIC8vIHRvcCAwLTkga2V5c1xuICAgICAgdmFsaWRLZXkgPSBTdHJpbmcoa2V5Q29kZSAtIDQ4KTtcbiAgICB9IGVsc2UgaWYgKGtleUNvZGUgPj0gOTYgJiYga2V5Q29kZSA8PSAxMDUpIHtcbiAgICAgIC8vIG51bSBwYWQgMC05XG4gICAgICB2YWxpZEtleSA9IFN0cmluZyhrZXlDb2RlIC0gOTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWxpZEtleSA9IEtFWV9DT0RFW2tleUNvZGVdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdmFsaWRLZXk7XG59XG5cbi8qKlxuICAqIENhbGN1bGF0ZXMgdGhlIG5vcm1hbGl6ZWQga2V5IGZvciBhIEtleWJvYXJkRXZlbnQuXG4gICogQHBhcmFtIHtLZXlib2FyZEV2ZW50fSBrZXlFdmVudFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW25vU3BlY2lhbENoYXJzXSBTZXQgdG8gdHJ1ZSB0byBsaW1pdCBrZXlFdmVudC5rZXlcbiAgKiB0cmFuc2Zvcm1hdGlvbiB0byBhbHBoYS1udW1lcmljIGNoYXJzLiBUaGlzIGlzIHVzZWZ1bCB3aXRoIGtleVxuICAqIGNvbWJpbmF0aW9ucyBsaWtlIHNoaWZ0ICsgMiwgd2hpY2ggb24gRkYgZm9yIE1hY09TIHByb2R1Y2VzXG4gICoga2V5RXZlbnQua2V5ID0gQFxuICAqIFRvIGdldCAyIHJldHVybmVkLCBzZXQgbm9TcGVjaWFsQ2hhcnMgPSB0cnVlXG4gICogVG8gZ2V0IEAgcmV0dXJuZWQsIHNldCBub1NwZWNpYWxDaGFycyA9IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZWRLZXlGb3JFdmVudChrZXlFdmVudCwgbm9TcGVjaWFsQ2hhcnMpIHtcbiAgLy8gRmFsbCBiYWNrIGZyb20gLmtleSwgdG8gLmRldGFpbC5rZXkgZm9yIGFydGlmaWNhbCBrZXlib2FyZCBldmVudHMsXG4gIC8vIGFuZCB0aGVuIHRvIGRlcHJlY2F0ZWQgLmtleUlkZW50aWZpZXIgYW5kIC5rZXlDb2RlLlxuICBpZiAoa2V5RXZlbnQua2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybUtleShrZXlFdmVudC5rZXksIG5vU3BlY2lhbENoYXJzKTtcbiAgfVxuICBpZiAoa2V5RXZlbnQuZGV0YWlsICYmIGtleUV2ZW50LmRldGFpbC5rZXkpIHtcbiAgICByZXR1cm4gdHJhbnNmb3JtS2V5KGtleUV2ZW50LmRldGFpbC5rZXksIG5vU3BlY2lhbENoYXJzKTtcbiAgfVxuICByZXR1cm4gdHJhbnNmb3JtS2V5SWRlbnRpZmllcihrZXlFdmVudC5rZXlJZGVudGlmaWVyKSB8fFxuICAgIHRyYW5zZm9ybUtleUNvZGUoa2V5RXZlbnQua2V5Q29kZSkgfHwgJyc7XG59XG5cbmZ1bmN0aW9uIGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvLCBldmVudCkge1xuICAvLyBGb3IgY29tYm9zIHdpdGggbW9kaWZpZXJzIHdlIHN1cHBvcnQgb25seSBhbHBoYS1udW1lcmljIGtleXNcbiAgdmFyIGtleUV2ZW50ID0gbm9ybWFsaXplZEtleUZvckV2ZW50KGV2ZW50LCBrZXlDb21iby5oYXNNb2RpZmllcnMpO1xuICByZXR1cm4ga2V5RXZlbnQgPT09IGtleUNvbWJvLmtleSAmJlxuICAgICgha2V5Q29tYm8uaGFzTW9kaWZpZXJzIHx8IChcbiAgICAgICEhZXZlbnQuc2hpZnRLZXkgPT09ICEha2V5Q29tYm8uc2hpZnRLZXkgJiZcbiAgICAgICEhZXZlbnQuY3RybEtleSA9PT0gISFrZXlDb21iby5jdHJsS2V5ICYmXG4gICAgICAhIWV2ZW50LmFsdEtleSA9PT0gISFrZXlDb21iby5hbHRLZXkgJiZcbiAgICAgICEhZXZlbnQubWV0YUtleSA9PT0gISFrZXlDb21iby5tZXRhS2V5KVxuICAgICk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlS2V5Q29tYm9TdHJpbmcoa2V5Q29tYm9TdHJpbmcpIHtcbiAgaWYgKGtleUNvbWJvU3RyaW5nLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB7XG4gICAgICBjb21ibzoga2V5Q29tYm9TdHJpbmcsXG4gICAgICBrZXk6IGtleUNvbWJvU3RyaW5nLFxuICAgICAgZXZlbnQ6ICdrZXlkb3duJ1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGtleUNvbWJvU3RyaW5nLnNwbGl0KCcrJykucmVkdWNlKGZ1bmN0aW9uKHBhcnNlZEtleUNvbWJvLCBrZXlDb21ib1BhcnQpIHtcbiAgICB2YXIgZXZlbnRQYXJ0cyA9IGtleUNvbWJvUGFydC5zcGxpdCgnOicpO1xuICAgIHZhciBrZXlOYW1lID0gZXZlbnRQYXJ0c1swXTtcbiAgICB2YXIgZXZlbnQgPSBldmVudFBhcnRzWzFdO1xuXG4gICAgaWYgKGtleU5hbWUgaW4gTU9ESUZJRVJfS0VZUykge1xuICAgICAgcGFyc2VkS2V5Q29tYm9bTU9ESUZJRVJfS0VZU1trZXlOYW1lXV0gPSB0cnVlO1xuICAgICAgcGFyc2VkS2V5Q29tYm8uaGFzTW9kaWZpZXJzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkS2V5Q29tYm8ua2V5ID0ga2V5TmFtZTtcbiAgICAgIHBhcnNlZEtleUNvbWJvLmV2ZW50ID0gZXZlbnQgfHwgJ2tleWRvd24nO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJzZWRLZXlDb21ibztcbiAgfSwge1xuICAgIGNvbWJvOiBrZXlDb21ib1N0cmluZy5zcGxpdCgnOicpLnNoaWZ0KClcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRXZlbnRTdHJpbmcoZXZlbnRTdHJpbmcpIHtcbiAgcmV0dXJuIGV2ZW50U3RyaW5nLnRyaW0oKS5zcGxpdCgnICcpLm1hcChmdW5jdGlvbihrZXlDb21ib1N0cmluZykge1xuICAgIHJldHVybiBwYXJzZUtleUNvbWJvU3RyaW5nKGtleUNvbWJvU3RyaW5nKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBJcm9uQTExeUtleXNCZWhhdmlvciA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBFdmVudFRhcmdldCB0aGF0IHdpbGwgYmUgZmlyaW5nIHJlbGV2YW50IEtleWJvYXJkRXZlbnRzLiBTZXQgaXQgdG9cbiAgICAgKiBgbnVsbGAgdG8gZGlzYWJsZSB0aGUgbGlzdGVuZXJzLlxuICAgICAqIEB0eXBlIHs/RXZlbnRUYXJnZXR9XG4gICAgICovXG4gICAga2V5RXZlbnRUYXJnZXQ6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoaXMgcHJvcGVydHkgd2lsbCBjYXVzZSB0aGUgaW1wbGVtZW50aW5nIGVsZW1lbnQgdG9cbiAgICAgKiBhdXRvbWF0aWNhbGx5IHN0b3AgcHJvcGFnYXRpb24gb24gYW55IGhhbmRsZWQgS2V5Ym9hcmRFdmVudHMuXG4gICAgICovXG4gICAgc3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBfYm91bmRLZXlIYW5kbGVyczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gV2UgdXNlIHRoaXMgZHVlIHRvIGEgbGltaXRhdGlvbiBpbiBJRTEwIHdoZXJlIGluc3RhbmNlcyB3aWxsIGhhdmVcbiAgICAvLyBvd24gcHJvcGVydGllcyBvZiBldmVyeXRoaW5nIG9uIHRoZSBcInByb3RvdHlwZVwiLlxuICAgIF9pbXBlcmF0aXZlS2V5QmluZGluZ3M6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBvYnNlcnZlcnM6IFtcbiAgICAnX3Jlc2V0S2V5RXZlbnRMaXN0ZW5lcnMoa2V5RXZlbnRUYXJnZXQsIF9ib3VuZEtleUhhbmRsZXJzKSdcbiAgXSxcblxuXG4gIC8qKlxuICAgKiBUbyBiZSB1c2VkIHRvIGV4cHJlc3Mgd2hhdCBjb21iaW5hdGlvbiBvZiBrZXlzICB3aWxsIHRyaWdnZXIgdGhlIHJlbGF0aXZlXG4gICAqIGNhbGxiYWNrLiBlLmcuIGBrZXlCaW5kaW5nczogeyAnZXNjJzogJ19vbkVzY1ByZXNzZWQnfWBcbiAgICogQHR5cGUgeyFPYmplY3R9XG4gICAqL1xuICBrZXlCaW5kaW5nczoge30sXG5cbiAgcmVnaXN0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzKCk7XG4gIH0sXG5cbiAgZGV0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2FuIGJlIHVzZWQgdG8gaW1wZXJhdGl2ZWx5IGFkZCBhIGtleSBiaW5kaW5nIHRvIHRoZSBpbXBsZW1lbnRpbmdcbiAgICogZWxlbWVudC4gVGhpcyBpcyB0aGUgaW1wZXJhdGl2ZSBlcXVpdmFsZW50IG9mIGRlY2xhcmluZyBhIGtleWJpbmRpbmdcbiAgICogaW4gdGhlIGBrZXlCaW5kaW5nc2AgcHJvdG90eXBlIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRTdHJpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJOYW1lXG4gICAqL1xuICBhZGRPd25LZXlCaW5kaW5nOiBmdW5jdGlvbihldmVudFN0cmluZywgaGFuZGxlck5hbWUpIHtcbiAgICB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddID0gaGFuZGxlck5hbWU7XG4gICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgdGhpcy5fcmVzZXRLZXlFdmVudExpc3RlbmVycygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIGNhbGxlZCwgd2lsbCByZW1vdmUgYWxsIGltcGVyYXRpdmVseS1hZGRlZCBrZXkgYmluZGluZ3MuXG4gICAqL1xuICByZW1vdmVPd25LZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzID0ge307XG4gICAgdGhpcy5fcHJlcEtleUJpbmRpbmdzKCk7XG4gICAgdGhpcy5fcmVzZXRLZXlFdmVudExpc3RlbmVycygpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBrZXlib2FyZCBldmVudCBtYXRjaGVzIGBldmVudFN0cmluZ2AuXG4gICAqXG4gICAqIEBwYXJhbSB7S2V5Ym9hcmRFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50U3RyaW5nXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBrZXlib2FyZEV2ZW50TWF0Y2hlc0tleXM6IGZ1bmN0aW9uKGV2ZW50LCBldmVudFN0cmluZykge1xuICAgIHZhciBrZXlDb21ib3MgPSBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUNvbWJvcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvc1tpXSwgZXZlbnQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgX2NvbGxlY3RLZXlCaW5kaW5nczogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGtleUJpbmRpbmdzID0gdGhpcy5iZWhhdmlvcnMubWFwKGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgICByZXR1cm4gYmVoYXZpb3Iua2V5QmluZGluZ3M7XG4gICAgfSk7XG5cbiAgICBpZiAoa2V5QmluZGluZ3MuaW5kZXhPZih0aGlzLmtleUJpbmRpbmdzKSA9PT0gLTEpIHtcbiAgICAgIGtleUJpbmRpbmdzLnB1c2godGhpcy5rZXlCaW5kaW5ncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGtleUJpbmRpbmdzO1xuICB9LFxuXG4gIF9wcmVwS2V5QmluZGluZ3M6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2tleUJpbmRpbmdzID0ge307XG5cbiAgICB0aGlzLl9jb2xsZWN0S2V5QmluZGluZ3MoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUJpbmRpbmdzKSB7XG4gICAgICBmb3IgKHZhciBldmVudFN0cmluZyBpbiBrZXlCaW5kaW5ncykge1xuICAgICAgICB0aGlzLl9hZGRLZXlCaW5kaW5nKGV2ZW50U3RyaW5nLCBrZXlCaW5kaW5nc1tldmVudFN0cmluZ10pO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgZm9yICh2YXIgZXZlbnRTdHJpbmcgaW4gdGhpcy5faW1wZXJhdGl2ZUtleUJpbmRpbmdzKSB7XG4gICAgICB0aGlzLl9hZGRLZXlCaW5kaW5nKGV2ZW50U3RyaW5nLCB0aGlzLl9pbXBlcmF0aXZlS2V5QmluZGluZ3NbZXZlbnRTdHJpbmddKTtcbiAgICB9XG5cbiAgICAvLyBHaXZlIHByZWNlZGVuY2UgdG8gY29tYm9zIHdpdGggbW9kaWZpZXJzIHRvIGJlIGNoZWNrZWQgZmlyc3QuXG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHRoaXMuX2tleUJpbmRpbmdzKSB7XG4gICAgICB0aGlzLl9rZXlCaW5kaW5nc1tldmVudE5hbWVdLnNvcnQoZnVuY3Rpb24gKGtiMSwga2IyKSB7XG4gICAgICAgIHZhciBiMSA9IGtiMVswXS5oYXNNb2RpZmllcnM7XG4gICAgICAgIHZhciBiMiA9IGtiMlswXS5oYXNNb2RpZmllcnM7XG4gICAgICAgIHJldHVybiAoYjEgPT09IGIyKSA/IDAgOiBiMSA/IC0xIDogMTtcbiAgICAgIH0pXG4gICAgfVxuICB9LFxuXG4gIF9hZGRLZXlCaW5kaW5nOiBmdW5jdGlvbihldmVudFN0cmluZywgaGFuZGxlck5hbWUpIHtcbiAgICBwYXJzZUV2ZW50U3RyaW5nKGV2ZW50U3RyaW5nKS5mb3JFYWNoKGZ1bmN0aW9uKGtleUNvbWJvKSB7XG4gICAgICB0aGlzLl9rZXlCaW5kaW5nc1trZXlDb21iby5ldmVudF0gPVxuICAgICAgICB0aGlzLl9rZXlCaW5kaW5nc1trZXlDb21iby5ldmVudF0gfHwgW107XG5cbiAgICAgIHRoaXMuX2tleUJpbmRpbmdzW2tleUNvbWJvLmV2ZW50XS5wdXNoKFtcbiAgICAgICAga2V5Q29tYm8sXG4gICAgICAgIGhhbmRsZXJOYW1lXG4gICAgICBdKTtcbiAgICB9LCB0aGlzKTtcbiAgfSxcblxuICBfcmVzZXRLZXlFdmVudExpc3RlbmVyczogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdW5saXN0ZW5LZXlFdmVudExpc3RlbmVycygpO1xuXG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5fbGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH0sXG5cbiAgX2xpc3RlbktleUV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMua2V5RXZlbnRUYXJnZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgT2JqZWN0LmtleXModGhpcy5fa2V5QmluZGluZ3MpLmZvckVhY2goZnVuY3Rpb24oZXZlbnROYW1lKSB7XG4gICAgICB2YXIga2V5QmluZGluZ3MgPSB0aGlzLl9rZXlCaW5kaW5nc1tldmVudE5hbWVdO1xuICAgICAgdmFyIGJvdW5kS2V5SGFuZGxlciA9IHRoaXMuX29uS2V5QmluZGluZ0V2ZW50LmJpbmQodGhpcywga2V5QmluZGluZ3MpO1xuXG4gICAgICB0aGlzLl9ib3VuZEtleUhhbmRsZXJzLnB1c2goW3RoaXMua2V5RXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgYm91bmRLZXlIYW5kbGVyXSk7XG5cbiAgICAgIHRoaXMua2V5RXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcik7XG4gICAgfSwgdGhpcyk7XG4gIH0sXG5cbiAgX3VubGlzdGVuS2V5RXZlbnRMaXN0ZW5lcnM6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBrZXlIYW5kbGVyVHVwbGU7XG4gICAgdmFyIGtleUV2ZW50VGFyZ2V0O1xuICAgIHZhciBldmVudE5hbWU7XG4gICAgdmFyIGJvdW5kS2V5SGFuZGxlcjtcblxuICAgIHdoaWxlICh0aGlzLl9ib3VuZEtleUhhbmRsZXJzLmxlbmd0aCkge1xuICAgICAgLy8gTXkga2luZ2RvbSBmb3IgYmxvY2stc2NvcGUgYmluZGluZyBhbmQgZGVzdHJ1Y3R1cmluZyBhc3NpZ25tZW50Li5cbiAgICAgIGtleUhhbmRsZXJUdXBsZSA9IHRoaXMuX2JvdW5kS2V5SGFuZGxlcnMucG9wKCk7XG4gICAgICBrZXlFdmVudFRhcmdldCA9IGtleUhhbmRsZXJUdXBsZVswXTtcbiAgICAgIGV2ZW50TmFtZSA9IGtleUhhbmRsZXJUdXBsZVsxXTtcbiAgICAgIGJvdW5kS2V5SGFuZGxlciA9IGtleUhhbmRsZXJUdXBsZVsyXTtcblxuICAgICAga2V5RXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGJvdW5kS2V5SGFuZGxlcik7XG4gICAgfVxuICB9LFxuXG4gIF9vbktleUJpbmRpbmdFdmVudDogZnVuY3Rpb24oa2V5QmluZGluZ3MsIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuc3RvcEtleWJvYXJkRXZlbnRQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuXG4gICAgLy8gaWYgZXZlbnQgaGFzIGJlZW4gYWxyZWFkeSBwcmV2ZW50ZWQsIGRvbid0IGRvIGFueXRoaW5nXG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleUJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5Q29tYm8gPSBrZXlCaW5kaW5nc1tpXVswXTtcbiAgICAgIHZhciBoYW5kbGVyTmFtZSA9IGtleUJpbmRpbmdzW2ldWzFdO1xuICAgICAgaWYgKGtleUNvbWJvTWF0Y2hlc0V2ZW50KGtleUNvbWJvLCBldmVudCkpIHtcbiAgICAgICAgdGhpcy5fdHJpZ2dlcktleUhhbmRsZXIoa2V5Q29tYm8sIGhhbmRsZXJOYW1lLCBldmVudCk7XG4gICAgICAgIC8vIGV4aXQgdGhlIGxvb3AgaWYgZXZlbnREZWZhdWx0IHdhcyBwcmV2ZW50ZWRcbiAgICAgICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX3RyaWdnZXJLZXlIYW5kbGVyOiBmdW5jdGlvbihrZXlDb21ibywgaGFuZGxlck5hbWUsIGtleWJvYXJkRXZlbnQpIHtcbiAgICB2YXIgZGV0YWlsID0gT2JqZWN0LmNyZWF0ZShrZXlDb21ibyk7XG4gICAgZGV0YWlsLmtleWJvYXJkRXZlbnQgPSBrZXlib2FyZEV2ZW50O1xuICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudChrZXlDb21iby5ldmVudCwge1xuICAgICAgZGV0YWlsOiBkZXRhaWwsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpc1toYW5kbGVyTmFtZV0uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIGtleWJvYXJkRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci9pcm9uLWExMXkta2V5cy1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gMTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxjdXN0b20tc3R5bGU+XG4gIDxzdHlsZSBpcz1cImN1c3RvbS1zdHlsZVwiPlxuICAgIGh0bWwge1xuXG4gICAgICAtLWxheW91dDoge1xuICAgICAgICBkaXNwbGF5OiAtbXMtZmxleGJveDtcbiAgICAgICAgZGlzcGxheTogLXdlYmtpdC1mbGV4O1xuICAgICAgICBkaXNwbGF5OiBmbGV4O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtaW5saW5lOiB7XG4gICAgICAgIGRpc3BsYXk6IC1tcy1pbmxpbmUtZmxleGJveDtcbiAgICAgICAgZGlzcGxheTogLXdlYmtpdC1pbmxpbmUtZmxleDtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWZsZXg7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1ob3Jpem9udGFsOiB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dDtcblxuICAgICAgICAtbXMtZmxleC1kaXJlY3Rpb246IHJvdztcbiAgICAgICAgLXdlYmtpdC1mbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgICBmbGV4LWRpcmVjdGlvbjogcm93O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtaG9yaXpvbnRhbC1yZXZlcnNlOiB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dDtcblxuICAgICAgICAtbXMtZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xuICAgICAgICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiByb3ctcmV2ZXJzZTtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IHJvdy1yZXZlcnNlO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtdmVydGljYWw6IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0O1xuXG4gICAgICAgIC1tcy1mbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgICAgICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC12ZXJ0aWNhbC1yZXZlcnNlOiB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dDtcblxuICAgICAgICAtbXMtZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xuICAgICAgICAtd2Via2l0LWZsZXgtZGlyZWN0aW9uOiBjb2x1bW4tcmV2ZXJzZTtcbiAgICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbi1yZXZlcnNlO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtd3JhcDoge1xuICAgICAgICAtbXMtZmxleC13cmFwOiB3cmFwO1xuICAgICAgICAtd2Via2l0LWZsZXgtd3JhcDogd3JhcDtcbiAgICAgICAgZmxleC13cmFwOiB3cmFwO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtd3JhcC1yZXZlcnNlOiB7XG4gICAgICAgIC1tcy1mbGV4LXdyYXA6IHdyYXAtcmV2ZXJzZTtcbiAgICAgICAgLXdlYmtpdC1mbGV4LXdyYXA6IHdyYXAtcmV2ZXJzZTtcbiAgICAgICAgZmxleC13cmFwOiB3cmFwLXJldmVyc2U7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LWF1dG86IHtcbiAgICAgICAgLW1zLWZsZXg6IDEgMSBhdXRvO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDEgMSBhdXRvO1xuICAgICAgICBmbGV4OiAxIDEgYXV0bztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtbm9uZToge1xuICAgICAgICAtbXMtZmxleDogbm9uZTtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiBub25lO1xuICAgICAgICBmbGV4OiBub25lO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleDoge1xuICAgICAgICAtbXMtZmxleDogMSAxIDAuMDAwMDAwMDAxcHg7XG4gICAgICAgIC13ZWJraXQtZmxleDogMTtcbiAgICAgICAgZmxleDogMTtcbiAgICAgICAgLXdlYmtpdC1mbGV4LWJhc2lzOiAwLjAwMDAwMDAwMXB4O1xuICAgICAgICBmbGV4LWJhc2lzOiAwLjAwMDAwMDAwMXB4O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC0yOiB7XG4gICAgICAgIC1tcy1mbGV4OiAyO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDI7XG4gICAgICAgIGZsZXg6IDI7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTM6IHtcbiAgICAgICAgLW1zLWZsZXg6IDM7XG4gICAgICAgIC13ZWJraXQtZmxleDogMztcbiAgICAgICAgZmxleDogMztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtNDoge1xuICAgICAgICAtbXMtZmxleDogNDtcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA0O1xuICAgICAgICBmbGV4OiA0O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC01OiB7XG4gICAgICAgIC1tcy1mbGV4OiA1O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDU7XG4gICAgICAgIGZsZXg6IDU7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTY6IHtcbiAgICAgICAgLW1zLWZsZXg6IDY7XG4gICAgICAgIC13ZWJraXQtZmxleDogNjtcbiAgICAgICAgZmxleDogNjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtNzoge1xuICAgICAgICAtbXMtZmxleDogNztcbiAgICAgICAgLXdlYmtpdC1mbGV4OiA3O1xuICAgICAgICBmbGV4OiA3O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZmxleC04OiB7XG4gICAgICAgIC1tcy1mbGV4OiA4O1xuICAgICAgICAtd2Via2l0LWZsZXg6IDg7XG4gICAgICAgIGZsZXg6IDg7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1mbGV4LTk6IHtcbiAgICAgICAgLW1zLWZsZXg6IDk7XG4gICAgICAgIC13ZWJraXQtZmxleDogOTtcbiAgICAgICAgZmxleDogOTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtMTA6IHtcbiAgICAgICAgLW1zLWZsZXg6IDEwO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDEwO1xuICAgICAgICBmbGV4OiAxMDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtMTE6IHtcbiAgICAgICAgLW1zLWZsZXg6IDExO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDExO1xuICAgICAgICBmbGV4OiAxMTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZsZXgtMTI6IHtcbiAgICAgICAgLW1zLWZsZXg6IDEyO1xuICAgICAgICAtd2Via2l0LWZsZXg6IDEyO1xuICAgICAgICBmbGV4OiAxMjtcbiAgICAgIH07XG5cbiAgICAgIC8qIGFsaWdubWVudCBpbiBjcm9zcyBheGlzICovXG5cbiAgICAgIC0tbGF5b3V0LXN0YXJ0OiB7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBzdGFydDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1pdGVtczogZmxleC1zdGFydDtcbiAgICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1jZW50ZXI6IHtcbiAgICAgICAgLW1zLWZsZXgtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZW5kOiB7XG4gICAgICAgIC1tcy1mbGV4LWFsaWduOiBlbmQ7XG4gICAgICAgIC13ZWJraXQtYWxpZ24taXRlbXM6IGZsZXgtZW5kO1xuICAgICAgICBhbGlnbi1pdGVtczogZmxleC1lbmQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1iYXNlbGluZToge1xuICAgICAgICAtbXMtZmxleC1hbGlnbjogYmFzZWxpbmU7XG4gICAgICAgIC13ZWJraXQtYWxpZ24taXRlbXM6IGJhc2VsaW5lO1xuICAgICAgICBhbGlnbi1pdGVtczogYmFzZWxpbmU7XG4gICAgICB9O1xuXG4gICAgICAvKiBhbGlnbm1lbnQgaW4gbWFpbiBheGlzICovXG5cbiAgICAgIC0tbGF5b3V0LXN0YXJ0LWp1c3RpZmllZDoge1xuICAgICAgICAtbXMtZmxleC1wYWNrOiBzdGFydDtcbiAgICAgICAgLXdlYmtpdC1qdXN0aWZ5LWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1zdGFydDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWNlbnRlci1qdXN0aWZpZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogY2VudGVyO1xuICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogY2VudGVyO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWVuZC1qdXN0aWZpZWQ6IHtcbiAgICAgICAgLW1zLWZsZXgtcGFjazogZW5kO1xuICAgICAgICAtd2Via2l0LWp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogZmxleC1lbmQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1hcm91bmQtanVzdGlmaWVkOiB7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGRpc3RyaWJ1dGU7XG4gICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICAgIGp1c3RpZnktY29udGVudDogc3BhY2UtYXJvdW5kO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtanVzdGlmaWVkOiB7XG4gICAgICAgIC1tcy1mbGV4LXBhY2s6IGp1c3RpZnk7XG4gICAgICAgIC13ZWJraXQtanVzdGlmeS1jb250ZW50OiBzcGFjZS1iZXR3ZWVuO1xuICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1jZW50ZXItY2VudGVyOiB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1jZW50ZXI7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1jZW50ZXItanVzdGlmaWVkO1xuICAgICAgfTtcblxuICAgICAgLyogc2VsZiBhbGlnbm1lbnQgKi9cblxuICAgICAgLS1sYXlvdXQtc2VsZi1zdGFydDoge1xuICAgICAgICAtbXMtYWxpZ24tc2VsZjogZmxleC1zdGFydDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuICAgICAgICBhbGlnbi1zZWxmOiBmbGV4LXN0YXJ0O1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtc2VsZi1jZW50ZXI6IHtcbiAgICAgICAgLW1zLWFsaWduLXNlbGY6IGNlbnRlcjtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBjZW50ZXI7XG4gICAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXNlbGYtZW5kOiB7XG4gICAgICAgIC1tcy1hbGlnbi1zZWxmOiBmbGV4LWVuZDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1zZWxmOiBmbGV4LWVuZDtcbiAgICAgICAgYWxpZ24tc2VsZjogZmxleC1lbmQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1zZWxmLXN0cmV0Y2g6IHtcbiAgICAgICAgLW1zLWFsaWduLXNlbGY6IHN0cmV0Y2g7XG4gICAgICAgIC13ZWJraXQtYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgICAgYWxpZ24tc2VsZjogc3RyZXRjaDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXNlbGYtYmFzZWxpbmU6IHtcbiAgICAgICAgLW1zLWFsaWduLXNlbGY6IGJhc2VsaW5lO1xuICAgICAgICAtd2Via2l0LWFsaWduLXNlbGY6IGJhc2VsaW5lO1xuICAgICAgICBhbGlnbi1zZWxmOiBiYXNlbGluZTtcbiAgICAgIH07XG5cbiAgICAgIC8qIG11bHRpLWxpbmUgYWxpZ25tZW50IGluIG1haW4gYXhpcyAqL1xuXG4gICAgICAtLWxheW91dC1zdGFydC1hbGlnbmVkOiB7XG4gICAgICAgIC1tcy1mbGV4LWxpbmUtcGFjazogc3RhcnQ7ICAvKiBJRTEwICovXG4gICAgICAgIC1tcy1hbGlnbi1jb250ZW50OiBmbGV4LXN0YXJ0O1xuICAgICAgICAtd2Via2l0LWFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IGZsZXgtc3RhcnQ7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1lbmQtYWxpZ25lZDoge1xuICAgICAgICAtbXMtZmxleC1saW5lLXBhY2s6IGVuZDsgIC8qIElFMTAgKi9cbiAgICAgICAgLW1zLWFsaWduLWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgICAgICAtd2Via2l0LWFsaWduLWNvbnRlbnQ6IGZsZXgtZW5kO1xuICAgICAgICBhbGlnbi1jb250ZW50OiBmbGV4LWVuZDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWNlbnRlci1hbGlnbmVkOiB7XG4gICAgICAgIC1tcy1mbGV4LWxpbmUtcGFjazogY2VudGVyOyAgLyogSUUxMCAqL1xuICAgICAgICAtbXMtYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgICAgICAtd2Via2l0LWFsaWduLWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgYWxpZ24tY29udGVudDogY2VudGVyO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtYmV0d2Vlbi1hbGlnbmVkOiB7XG4gICAgICAgIC1tcy1mbGV4LWxpbmUtcGFjazoganVzdGlmeTsgIC8qIElFMTAgKi9cbiAgICAgICAgLW1zLWFsaWduLWNvbnRlbnQ6IHNwYWNlLWJldHdlZW47XG4gICAgICAgIC13ZWJraXQtYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgICAgYWxpZ24tY29udGVudDogc3BhY2UtYmV0d2VlbjtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWFyb3VuZC1hbGlnbmVkOiB7XG4gICAgICAgIC1tcy1mbGV4LWxpbmUtcGFjazogZGlzdHJpYnV0ZTsgIC8qIElFMTAgKi9cbiAgICAgICAgLW1zLWFsaWduLWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgICAgLXdlYmtpdC1hbGlnbi1jb250ZW50OiBzcGFjZS1hcm91bmQ7XG4gICAgICAgIGFsaWduLWNvbnRlbnQ6IHNwYWNlLWFyb3VuZDtcbiAgICAgIH07XG5cbiAgICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gICAgICAgICAgICAgICAgT3RoZXIgTGF5b3V0XG4gICAgICAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG4gICAgICAtLWxheW91dC1ibG9jazoge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWludmlzaWJsZToge1xuICAgICAgICB2aXNpYmlsaXR5OiBoaWRkZW4gIWltcG9ydGFudDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXJlbGF0aXZlOiB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZpdDoge1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LXNjcm9sbDoge1xuICAgICAgICAtd2Via2l0LW92ZXJmbG93LXNjcm9sbGluZzogdG91Y2g7XG4gICAgICAgIG92ZXJmbG93OiBhdXRvO1xuICAgICAgfTtcblxuICAgICAgLS1sYXlvdXQtZnVsbGJsZWVkOiB7XG4gICAgICAgIG1hcmdpbjogMDtcbiAgICAgICAgaGVpZ2h0OiAxMDB2aDtcbiAgICAgIH07XG5cbiAgICAgIC8qIGZpeGVkIHBvc2l0aW9uICovXG5cbiAgICAgIC0tbGF5b3V0LWZpeGVkLXRvcDoge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1maXhlZC1yaWdodDoge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHRvcDogMDtcbiAgICAgICAgcmlnaHQ6IDA7XG4gICAgICAgIGJvdHRvbTogMDtcbiAgICAgIH07XG5cbiAgICAgIC0tbGF5b3V0LWZpeGVkLWJvdHRvbToge1xuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICB9O1xuXG4gICAgICAtLWxheW91dC1maXhlZC1sZWZ0OiB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBib3R0b206IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICB9O1xuXG4gICAgfVxuICA8L3N0eWxlPlxuPC9jdXN0b20tc3R5bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qc1xuLy8gbW9kdWxlIGlkID0gMTZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9mb250LXJvYm90by9yb2JvdG8uanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxjdXN0b20tc3R5bGU+XG4gIDxzdHlsZSBpcz1cImN1c3RvbS1zdHlsZVwiPlxuICAgIGh0bWwge1xuXG4gICAgICAvKiBTaGFyZWQgU3R5bGVzICovXG4gICAgICAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U6IHtcbiAgICAgICAgZm9udC1mYW1pbHk6ICdSb2JvdG8nLCAnTm90bycsIHNhbnMtc2VyaWY7XG4gICAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWNvbW1vbi1jb2RlOiB7XG4gICAgICAgIGZvbnQtZmFtaWx5OiAnUm9ib3RvIE1vbm8nLCAnQ29uc29sYXMnLCAnTWVubG8nLCBtb25vc3BhY2U7XG4gICAgICAgIC13ZWJraXQtZm9udC1zbW9vdGhpbmc6IGFudGlhbGlhc2VkO1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWNvbW1vbi1leHBlbnNpdmUta2VybmluZzoge1xuICAgICAgICB0ZXh0LXJlbmRlcmluZzogb3B0aW1pemVMZWdpYmlsaXR5O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWNvbW1vbi1ub3dyYXA6IHtcbiAgICAgICAgd2hpdGUtc3BhY2U6IG5vd3JhcDtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgICAgdGV4dC1vdmVyZmxvdzogZWxsaXBzaXM7XG4gICAgICB9O1xuXG4gICAgICAvKiBNYXRlcmlhbCBGb250IFN0eWxlcyAqL1xuXG4gICAgICAtLXBhcGVyLWZvbnQtZGlzcGxheTQ6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tbm93cmFwO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMTEycHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiAzMDA7XG4gICAgICAgIGxldHRlci1zcGFjaW5nOiAtLjA0NGVtO1xuICAgICAgICBsaW5lLWhlaWdodDogMTIwcHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtZGlzcGxheTM6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tbm93cmFwO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogNTZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICAgICAgbGV0dGVyLXNwYWNpbmc6IC0uMDI2ZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiA2MHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWRpc3BsYXkyOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG5cbiAgICAgICAgZm9udC1zaXplOiA0NXB4O1xuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICBsZXR0ZXItc3BhY2luZzogLS4wMThlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDQ4cHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtZGlzcGxheTE6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcblxuICAgICAgICBmb250LXNpemU6IDM0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgICAgIGxldHRlci1zcGFjaW5nOiAtLjAxZW07XG4gICAgICAgIGxpbmUtaGVpZ2h0OiA0MHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWhlYWRsaW5lOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG5cbiAgICAgICAgZm9udC1zaXplOiAyNHB4O1xuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICBsZXR0ZXItc3BhY2luZzogLS4wMTJlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDMycHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtdGl0bGU6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tbm93cmFwO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMjBweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDI4cHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtc3ViaGVhZDoge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuXG4gICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgZm9udC13ZWlnaHQ6IDQwMDtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDI0cHg7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtYm9keTI6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tYmFzZTtcblxuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyNHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWJvZHkxOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG5cbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBmb250LXdlaWdodDogNDAwO1xuICAgICAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgICAgIH07XG5cbiAgICAgIC0tcGFwZXItZm9udC1jYXB0aW9uOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLW5vd3JhcDtcblxuICAgICAgICBmb250LXNpemU6IDEycHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA0MDA7XG4gICAgICAgIGxldHRlci1zcGFjaW5nOiAwLjAxMWVtO1xuICAgICAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgICAgIH07XG5cbiAgICAgIC0tcGFwZXItZm9udC1tZW51OiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLW5vd3JhcDtcblxuICAgICAgICBmb250LXNpemU6IDEzcHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA1MDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyNHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWJ1dHRvbjoge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1ub3dyYXA7XG5cbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICBsZXR0ZXItc3BhY2luZzogMC4wMThlbTtcbiAgICAgICAgbGluZS1oZWlnaHQ6IDI0cHg7XG4gICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgICB9O1xuXG4gICAgICAtLXBhcGVyLWZvbnQtY29kZTI6IHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1jb21tb24tY29kZTtcblxuICAgICAgICBmb250LXNpemU6IDE0cHg7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiA3MDA7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiAyMHB4O1xuICAgICAgfTtcblxuICAgICAgLS1wYXBlci1mb250LWNvZGUxOiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWNvZGU7XG5cbiAgICAgICAgZm9udC1zaXplOiAxNHB4O1xuICAgICAgICBmb250LXdlaWdodDogNTAwO1xuICAgICAgICBsaW5lLWhlaWdodDogMjBweDtcbiAgICAgIH07XG5cbiAgICB9XG5cbiAgPC9zdHlsZT5cbjwvY3VzdG9tLXN0eWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvdHlwb2dyYXBoeS5qc1xuLy8gbW9kdWxlIGlkID0gMTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uQ29udHJvbFN0YXRlID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBlbGVtZW50IGN1cnJlbnRseSBoYXMgZm9jdXMuXG4gICAgICovXG4gICAgZm9jdXNlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSB1c2VyIGNhbm5vdCBpbnRlcmFjdCB3aXRoIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICBkaXNhYmxlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIG9ic2VydmVyOiAnX2Rpc2FibGVkQ2hhbmdlZCcsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgX29sZFRhYkluZGV4OiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuXG4gICAgX2JvdW5kRm9jdXNCbHVySGFuZGxlcjoge1xuICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mb2N1c0JsdXJIYW5kbGVyLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9faGFuZGxlRXZlbnRSZXRhcmdldGluZzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnNoYWRvd1Jvb3QgJiYgIUVsZW1lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfY2hhbmdlZENvbnRyb2xTdGF0ZShmb2N1c2VkLCBkaXNhYmxlZCknXG4gIF0sXG5cbiAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9ib3VuZEZvY3VzQmx1ckhhbmRsZXIsIHRydWUpO1xuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2JvdW5kRm9jdXNCbHVySGFuZGxlciwgdHJ1ZSk7XG4gIH0sXG5cbiAgX2ZvY3VzQmx1ckhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gSW4gUG9seW1lciAyLjAsIHRoZSBsaWJyYXJ5IHRha2VzIGNhcmUgb2YgcmV0YXJnZXRpbmcgZXZlbnRzLlxuICAgIGlmIChFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXRGb2N1c2VkKGV2ZW50LnR5cGUgPT09ICdmb2N1cycpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE5PVEUoY2RhdGEpOiAgaWYgd2UgYXJlIGluIFNoYWRvd0RPTSBsYW5kLCBgZXZlbnQudGFyZ2V0YCB3aWxsXG4gICAgLy8gZXZlbnR1YWxseSBiZWNvbWUgYHRoaXNgIGR1ZSB0byByZXRhcmdldGluZzsgaWYgd2UgYXJlIG5vdCBpblxuICAgIC8vIFNoYWRvd0RPTSBsYW5kLCBgZXZlbnQudGFyZ2V0YCB3aWxsIGV2ZW50dWFsbHkgYmVjb21lIGB0aGlzYCBkdWVcbiAgICAvLyB0byB0aGUgc2Vjb25kIGNvbmRpdGlvbmFsIHdoaWNoIGZpcmVzIGEgc3ludGhldGljIGV2ZW50ICh0aGF0IGlzIGFsc29cbiAgICAvLyBoYW5kbGVkKS4gSW4gZWl0aGVyIGNhc2UsIHdlIGNhbiBkaXNyZWdhcmQgYGV2ZW50LnBhdGhgLlxuICAgIGlmIChldmVudC50YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuX3NldEZvY3VzZWQoZXZlbnQudHlwZSA9PT0gJ2ZvY3VzJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9faGFuZGxlRXZlbnRSZXRhcmdldGluZykge1xuICAgICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8oZG9tKGV2ZW50KS5sb2NhbFRhcmdldCk7XG4gICAgICBpZiAoIXRoaXMuaXNMaWdodERlc2NlbmRhbnQodGFyZ2V0KSkge1xuICAgICAgICB0aGlzLmZpcmUoZXZlbnQudHlwZSwge3NvdXJjZUV2ZW50OiBldmVudH0sIHtcbiAgICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICAgIGJ1YmJsZXM6IGV2ZW50LmJ1YmJsZXMsXG4gICAgICAgICAgY2FuY2VsYWJsZTogZXZlbnQuY2FuY2VsYWJsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgX2Rpc2FibGVkQ2hhbmdlZDogZnVuY3Rpb24oZGlzYWJsZWQsIG9sZCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdhcmlhLWRpc2FibGVkJywgZGlzYWJsZWQgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgICB0aGlzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBkaXNhYmxlZCA/ICdub25lJyA6ICcnO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgdGhpcy5fb2xkVGFiSW5kZXggPSB0aGlzLnRhYkluZGV4O1xuICAgICAgdGhpcy5fc2V0Rm9jdXNlZChmYWxzZSk7XG4gICAgICB0aGlzLnRhYkluZGV4ID0gLTE7XG4gICAgICB0aGlzLmJsdXIoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29sZFRhYkluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMudGFiSW5kZXggPSB0aGlzLl9vbGRUYWJJbmRleDtcbiAgICB9XG4gIH0sXG5cbiAgX2NoYW5nZWRDb250cm9sU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgIC8vIF9jb250cm9sU3RhdGVDaGFuZ2VkIGlzIGFic3RyYWN0LCBmb2xsb3ctb24gYmVoYXZpb3JzIG1heSBpbXBsZW1lbnQgaXRcbiAgICBpZiAodGhpcy5fY29udHJvbFN0YXRlQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fY29udHJvbFN0YXRlQ2hhbmdlZCgpO1xuICAgIH1cbiAgfVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmpzXG4vLyBtb2R1bGUgaWQgPSAxOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXJpcHBsZS9wYXBlci1yaXBwbGUuanMnO1xuaW1wb3J0IHsgSXJvbkJ1dHRvblN0YXRlSW1wbCB9IGZyb20gJy4uL2lyb24tYmVoYXZpb3JzL2lyb24tYnV0dG9uLXN0YXRlLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBQYXBlclJpcHBsZUJlaGF2aW9yID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGVsZW1lbnQgd2lsbCBub3QgcHJvZHVjZSBhIHJpcHBsZSBlZmZlY3Qgd2hlbiBpbnRlcmFjdGVkXG4gICAgICogd2l0aCB2aWEgdGhlIHBvaW50ZXIuXG4gICAgICovXG4gICAgbm9pbms6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBvYnNlcnZlcjogJ19ub2lua0NoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtFbGVtZW50fHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBfcmlwcGxlQ29udGFpbmVyOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIGEgYDxwYXBlci1yaXBwbGU+YCBlbGVtZW50IGlzIGF2YWlsYWJsZSB3aGVuIHRoZSBlbGVtZW50IGlzXG4gICAqIGZvY3VzZWQuXG4gICAqL1xuICBfYnV0dG9uU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5mb2N1c2VkKSB7XG4gICAgICB0aGlzLmVuc3VyZVJpcHBsZSgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogSW4gYWRkaXRpb24gdG8gdGhlIGZ1bmN0aW9uYWxpdHkgcHJvdmlkZWQgaW4gYElyb25CdXR0b25TdGF0ZWAsIGVuc3VyZXNcbiAgICogYSByaXBwbGUgZWZmZWN0IGlzIGNyZWF0ZWQgd2hlbiB0aGUgZWxlbWVudCBpcyBpbiBhIGBwcmVzc2VkYCBzdGF0ZS5cbiAgICovXG4gIF9kb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBJcm9uQnV0dG9uU3RhdGVJbXBsLl9kb3duSGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICBpZiAodGhpcy5wcmVzc2VkKSB7XG4gICAgICB0aGlzLmVuc3VyZVJpcHBsZShldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoaXMgZWxlbWVudCBjb250YWlucyBhIHJpcHBsZSBlZmZlY3QuIEZvciBzdGFydHVwIGVmZmljaWVuY3lcbiAgICogdGhlIHJpcHBsZSBlZmZlY3QgaXMgZHluYW1pY2FsbHkgb24gZGVtYW5kIHdoZW4gbmVlZGVkLlxuICAgKiBAcGFyYW0geyFFdmVudD19IG9wdFRyaWdnZXJpbmdFdmVudCAob3B0aW9uYWwpIGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZVxuICAgKiByaXBwbGUuXG4gICAqL1xuICBlbnN1cmVSaXBwbGU6IGZ1bmN0aW9uKG9wdFRyaWdnZXJpbmdFdmVudCkge1xuICAgIGlmICghdGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgdGhpcy5fcmlwcGxlID0gdGhpcy5fY3JlYXRlUmlwcGxlKCk7XG4gICAgICB0aGlzLl9yaXBwbGUubm9pbmsgPSB0aGlzLm5vaW5rO1xuICAgICAgdmFyIHJpcHBsZUNvbnRhaW5lciA9IHRoaXMuX3JpcHBsZUNvbnRhaW5lciB8fCB0aGlzLnJvb3Q7XG4gICAgICBpZiAocmlwcGxlQ29udGFpbmVyKSB7XG4gICAgICAgIGRvbShyaXBwbGVDb250YWluZXIpLmFwcGVuZENoaWxkKHRoaXMuX3JpcHBsZSk7XG4gICAgICB9XG4gICAgICBpZiAob3B0VHJpZ2dlcmluZ0V2ZW50KSB7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBldmVudCBoYXBwZW5lZCBpbnNpZGUgb2YgdGhlIHJpcHBsZSBjb250YWluZXJcbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGhvc3QgaW5zdGVhZCBvZiB0aGUgcm9vdCBiZWNhdXNlIGRpc3RyaWJ1dGVkIHRleHRcbiAgICAgICAgLy8gbm9kZXMgYXJlIG5vdCB2YWxpZCBldmVudCB0YXJnZXRzXG4gICAgICAgIHZhciBkb21Db250YWluZXIgPSBkb20odGhpcy5fcmlwcGxlQ29udGFpbmVyIHx8IHRoaXMpO1xuICAgICAgICB2YXIgdGFyZ2V0ID0gZG9tKG9wdFRyaWdnZXJpbmdFdmVudCkucm9vdFRhcmdldDtcbiAgICAgICAgaWYgKGRvbUNvbnRhaW5lci5kZWVwQ29udGFpbnMoIC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KSkpIHtcbiAgICAgICAgICB0aGlzLl9yaXBwbGUudWlEb3duQWN0aW9uKG9wdFRyaWdnZXJpbmdFdmVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGA8cGFwZXItcmlwcGxlPmAgZWxlbWVudCB1c2VkIGJ5IHRoaXMgZWxlbWVudCB0byBjcmVhdGVcbiAgICogcmlwcGxlIGVmZmVjdHMuIFRoZSBlbGVtZW50J3MgcmlwcGxlIGlzIGNyZWF0ZWQgb24gZGVtYW5kLCB3aGVuXG4gICAqIG5lY2Vzc2FyeSwgYW5kIGNhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCBmb3JjZSB0aGVcbiAgICogcmlwcGxlIHRvIGJlIGNyZWF0ZWQuXG4gICAqL1xuICBnZXRSaXBwbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZW5zdXJlUmlwcGxlKCk7XG4gICAgcmV0dXJuIHRoaXMuX3JpcHBsZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgZWxlbWVudCBjdXJyZW50bHkgY29udGFpbnMgYSByaXBwbGUgZWZmZWN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9yaXBwbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGUgdGhlIGVsZW1lbnQncyByaXBwbGUgZWZmZWN0IHZpYSBjcmVhdGluZyBhIGA8cGFwZXItcmlwcGxlPmAuXG4gICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGN1c3RvbWl6ZSB0aGUgcmlwcGxlIGVsZW1lbnQuXG4gICAqIEByZXR1cm4geyFQYXBlclJpcHBsZUVsZW1lbnR9IFJldHVybnMgYSBgPHBhcGVyLXJpcHBsZT5gIGVsZW1lbnQuXG4gICAqL1xuICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHshUGFwZXJSaXBwbGVFbGVtZW50fSAqLyAoXG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3BhcGVyLXJpcHBsZScpKTtcbiAgfSxcblxuICBfbm9pbmtDaGFuZ2VkOiBmdW5jdGlvbihub2luaykge1xuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICB0aGlzLl9yaXBwbGUubm9pbmsgPSBub2luaztcbiAgICB9XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItcmlwcGxlLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgcm9vdFBhdGggYXMgcm9vdFBhdGgkMCB9IGZyb20gJy4uL3V0aWxzL3NldHRpbmdzLmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwJDAgZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgY2FtZWxUb0Rhc2hDYXNlIH0gZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgY3NzRnJvbU1vZHVsZUltcG9ydHMsIGNzc0Zyb21UZW1wbGF0ZSB9IGZyb20gJy4uL3V0aWxzL3N0eWxlLWdhdGhlci5qcyc7XG5pbXBvcnQgeyByZXNvbHZlVXJsIGFzIHJlc29sdmVVcmwkMCB9IGZyb20gJy4uL3V0aWxzL3Jlc29sdmUtdXJsLmpzJztcbmltcG9ydCB7IERvbU1vZHVsZSB9IGZyb20gJy4uL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlFZmZlY3RzIH0gZnJvbSAnLi9wcm9wZXJ0eS1lZmZlY3RzLmpzJztcblxuZXhwb3J0IGNvbnN0IEVsZW1lbnRNaXhpbiA9IGRlZHVwaW5nTWl4aW4oYmFzZSA9PiB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfVxuICAgKi9cbiAgY29uc3QgcG9seW1lckVsZW1lbnRCYXNlID0gUHJvcGVydHlFZmZlY3RzKGJhc2UpO1xuXG4gIGxldCBjYXNlTWFwID0gY2FzZU1hcCQwO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBgcHJvcGVydGllc2Agb2JqZWN0IHNwZWNpZmljYWxseSBvbiBga2xhc3NgLiBVc2UgZm9yOlxuICAgKiAoMSkgc3VwZXIgY2hhaW4gbWl4ZXMgdG9ndGhlciB0byBtYWtlIGBwcm9wZXJ0aWVzRm9yQ2xhc3NgIHdoaWNoIGlzXG4gICAqIHRoZW4gdXNlZCB0byBtYWtlIGBvYnNlcnZlZEF0dHJpYnV0ZXNgLlxuICAgKiAoMikgcHJvcGVydGllcyBlZmZlY3RzIGFuZCBvYnNlcnZlcnMgYXJlIGNyZWF0ZWQgZnJvbSBpdCBhdCBgZmluYWxpemVgIHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7T2JqZWN0fSBPYmplY3QgY29udGFpbmluZyBvd24gcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKSB7XG4gICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fb3duUHJvcGVydGllcycsIGtsYXNzKSkpIHtcbiAgICAgIGtsYXNzLl9fb3duUHJvcGVydGllcyA9XG4gICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ3Byb3BlcnRpZXMnLCBrbGFzcykpID9cbiAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm9wZXJ0aWVzIDoge307XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX293blByb3BlcnRpZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYG9ic2VydmVyc2AgYXJyYXkgc3BlY2lmaWNhbGx5IG9uIGBrbGFzc2AuIFVzZSBmb3JcbiAgICogc2V0dGluZyB1cCBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7QXJyYXl9IEFycmF5IGNvbnRhaW5pbmcgb3duIG9ic2VydmVycyBmb3IgdGhpcyBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gb3duT2JzZXJ2ZXJzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vd25PYnNlcnZlcnMnLCBrbGFzcykpKSB7XG4gICAgICBrbGFzcy5fX293bk9ic2VydmVycyA9XG4gICAgICAgIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ29ic2VydmVycycsIGtsYXNzKSkgP1xuICAgICAgICAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLm9ic2VydmVycyA6IFtdO1xuICAgIH1cbiAgICByZXR1cm4ga2xhc3MuX19vd25PYnNlcnZlcnM7XG4gIH1cblxuICAvKipcbiAgICogTWl4ZXMgYHByb3BzYCBpbnRvIGBmbGF0dGVuZWRQcm9wc2AgYnV0IHVwZ3JhZGVzIHNob3J0aGFuZCB0eXBlXG4gICAqIHN5bnRheCB0byB7IHR5cGU6IFR5cGV9LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZmxhdHRlbmVkUHJvcHMgQmFnIHRvIGNvbGxlY3QgZmxhdHRlbmVkIHByb3BlcnRpZXMgaW50b1xuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgdG8gYWRkIHRvIGBmbGF0dGVuZWRQcm9wc2BcbiAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgaW5wdXQgYGZsYXR0ZW5lZFByb3BzYCBiYWdcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZsYXR0ZW5Qcm9wZXJ0aWVzKGZsYXR0ZW5lZFByb3BzLCBwcm9wcykge1xuICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgIGxldCBvID0gcHJvcHNbcF07XG4gICAgICBpZiAodHlwZW9mIG8gPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvID0geyB0eXBlOiBvIH07XG4gICAgICB9XG4gICAgICBmbGF0dGVuZWRQcm9wc1twXSA9IG87XG4gICAgfVxuICAgIHJldHVybiBmbGF0dGVuZWRQcm9wcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgZmxhdHRlbmVkIGxpc3Qgb2YgcHJvcGVydGllcyBtaXhlZCB0b2dldGhlciBmcm9tIHRoZSBjaGFpbiBvZiBhbGxcbiAgICogY29uc3RydWN0b3IncyBgY29uZmlnLnByb3BlcnRpZXNgLiBUaGlzIGxpc3QgaXMgdXNlZCB0byBjcmVhdGVcbiAgICogKDEpIG9ic2VydmVkQXR0cmlidXRlcyxcbiAgICogKDIpIGNsYXNzIHByb3BlcnR5IGRlZmF1bHQgdmFsdWVzXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtQb2x5bWVyRWxlbWVudFByb3BlcnRpZXN9IEZsYXR0ZW5lZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGNsYXNzXG4gICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgYSBwcm9wZXJ0eSBmb3Igc29tZSByZWFzb24/XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBmdW5jdGlvbiBwcm9wZXJ0aWVzRm9yQ2xhc3Moa2xhc3MpIHtcbiAgICBpZiAoIWtsYXNzLmhhc093blByb3BlcnR5KFxuICAgICAgSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19jbGFzc1Byb3BlcnRpZXMnLCBrbGFzcykpKSB7XG4gICAgICBrbGFzcy5fX2NsYXNzUHJvcGVydGllcyA9XG4gICAgICBmbGF0dGVuUHJvcGVydGllcyh7fSwgb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKSk7XG4gICAgICBsZXQgc3VwZXJDdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGtsYXNzLnByb3RvdHlwZSkuY29uc3RydWN0b3I7XG4gICAgICBpZiAoc3VwZXJDdG9yLnByb3RvdHlwZSBpbnN0YW5jZW9mIFBvbHltZXJFbGVtZW50KSB7XG4gICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0aWVzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXNGb3JDbGFzcygvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyhzdXBlckN0b3IpKSksXG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2xhc3MuX19jbGFzc1Byb3BlcnRpZXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxpc3Qgb2YgcHJvcGVydGllcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgKiBUaGlzIGxpc3QgaXMgY3JlYXRlZCBhcyBhbiBvcHRpbWl6YXRpb24gc2luY2UgaXQgaXMgYSBzdWJzZXQgb2ZcbiAgICogdGhlIGxpc3QgcmV0dXJuZWQgZnJvbSBgcHJvcGVydGllc0ZvckNsYXNzYC5cbiAgICogVGhpcyBsaXN0IGlzIHVzZWQgaW4gYF9pbml0aWFsaXplUHJvcGVydGllc2AgdG8gc2V0IHByb3BlcnR5IGRlZmF1bHRzLlxuICAgKlxuICAgKiBAcGFyYW0ge1BvbHltZXJFbGVtZW50Q29uc3RydWN0b3J9IGtsYXNzIEVsZW1lbnQgY2xhc3NcbiAgICogQHJldHVybiB7UG9seW1lckVsZW1lbnRQcm9wZXJ0aWVzfSBGbGF0dGVuZWQgcHJvcGVydGllcyBmb3IgdGhpcyBjbGFzc1xuICAgKiAgIHRoYXQgaGF2ZSBkZWZhdWx0IHZhbHVlc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gcHJvcGVydHlEZWZhdWx0c0ZvckNsYXNzKGtsYXNzKSB7XG4gICAgaWYgKCFrbGFzcy5oYXNPd25Qcm9wZXJ0eShcbiAgICAgIEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fY2xhc3NQcm9wZXJ0eURlZmF1bHRzJywga2xhc3MpKSkge1xuICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgPSBudWxsO1xuICAgICAgbGV0IHByb3BzID0gcHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKTtcbiAgICAgIGZvciAobGV0IHAgaW4gcHJvcHMpIHtcbiAgICAgICAgbGV0IGluZm8gPSBwcm9wc1twXTtcbiAgICAgICAgaWYgKCd2YWx1ZScgaW4gaW5mbykge1xuICAgICAgICAgIGtsYXNzLl9fY2xhc3NQcm9wZXJ0eURlZmF1bHRzID0ga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHMgfHwge307XG4gICAgICAgICAga2xhc3MuX19jbGFzc1Byb3BlcnR5RGVmYXVsdHNbcF0gPSBpbmZvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrbGFzcy5fX2NsYXNzUHJvcGVydHlEZWZhdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYSBga2xhc3NgIGhhcyBmaW5hbGl6ZWQuIENhbGxlZCBpbiBgRWxlbWVudENsYXNzLmZpbmFsaXplKClgXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFsbCBtZXRhcHJvZ3JhbW1pbmcgZm9yIHRoaXMgY2xhc3MgaGFzIGJlZW5cbiAgICogICBjb21wbGV0ZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGhhc0NsYXNzRmluYWxpemVkKGtsYXNzKSB7XG4gICAgcmV0dXJuIGtsYXNzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZmluYWxpemVkJywga2xhc3MpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgYnkgYEVsZW1lbnRDbGFzcy5maW5hbGl6ZSgpYC4gRW5zdXJlcyB0aGlzIGBrbGFzc2AgYW5kXG4gICAqICphbGwgc3VwZXJjbGFzc2VzKiBhcmUgZmluYWxpemVkIGJ5IHRyYXZlcnNpbmcgdGhlIHByb3RvdHlwZSBjaGFpblxuICAgKiBhbmQgY2FsbGluZyBga2xhc3MuZmluYWxpemUoKWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVDbGFzc0FuZFN1cGVyKGtsYXNzKSB7XG4gICAgbGV0IHByb3RvID0gLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKGtsYXNzKS5wcm90b3R5cGU7XG4gICAgbGV0IHN1cGVyQ3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihwcm90bykuY29uc3RydWN0b3I7XG4gICAgaWYgKHN1cGVyQ3Rvci5wcm90b3R5cGUgaW5zdGFuY2VvZiBQb2x5bWVyRWxlbWVudCkge1xuICAgICAgc3VwZXJDdG9yLmZpbmFsaXplKCk7XG4gICAgfVxuICAgIGZpbmFsaXplQ2xhc3Moa2xhc3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYSBga2xhc3NgIGJhc2VkIG9uIGEgc3RhaWMgYGtsYXNzLmNvbmZpZ2Agb2JqZWN0IGFuZFxuICAgKiBhIGB0ZW1wbGF0ZWAuIFRoaXMgaW5jbHVkZXMgY3JlYXRpbmcgYWNjZXNzb3JzIGFuZCBlZmZlY3RzXG4gICAqIGZvciBwcm9wZXJ0aWVzIGluIGBjb25maWdgIGFuZCB0aGUgYHRlbXBsYXRlYCBhcyB3ZWxsIGFzIHByZXBhcmluZyB0aGVcbiAgICogYHRlbXBsYXRlYCBmb3Igc3RhbXBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnRDb25zdHJ1Y3Rvcn0ga2xhc3MgRWxlbWVudCBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVDbGFzcyhrbGFzcykge1xuICAgIGtsYXNzLl9fZmluYWxpemVkID0gdHJ1ZTtcbiAgICBsZXQgcHJvdG8gPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnByb3RvdHlwZTtcbiAgICBpZiAoa2xhc3MuaGFzT3duUHJvcGVydHkoXG4gICAgICBKU0NvbXBpbGVyX3JlbmFtZVByb3BlcnR5KCdpcycsIGtsYXNzKSkgJiYga2xhc3MuaXMpIHtcbiAgICAgIHJlZ2lzdGVyKHByb3RvKTtcbiAgICB9XG4gICAgbGV0IHByb3BzID0gb3duUHJvcGVydGllc0ZvckNsYXNzKGtsYXNzKTtcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZpbmFsaXplUHJvcGVydGllcyhwcm90bywgcHJvcHMpO1xuICAgIH1cbiAgICBsZXQgb2JzZXJ2ZXJzID0gb3duT2JzZXJ2ZXJzRm9yQ2xhc3Moa2xhc3MpO1xuICAgIGlmIChvYnNlcnZlcnMpIHtcbiAgICAgIGZpbmFsaXplT2JzZXJ2ZXJzKHByb3RvLCBvYnNlcnZlcnMsIHByb3BzKTtcbiAgICB9XG4gICAgLy8gbm90ZTogY3JlYXRlIFwid29ya2luZ1wiIHRlbXBsYXRlIHRoYXQgaXMgZmluYWxpemVkIGF0IGluc3RhbmNlIHRpbWVcbiAgICBsZXQgdGVtcGxhdGUgPSAvKiogQHR5cGUgUG9seW1lckVsZW1lbnRDb25zdHJ1Y3RvciAqLyAoa2xhc3MpLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGV0IHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0LmlubmVySFRNTCA9IHRlbXBsYXRlO1xuICAgICAgICB0ZW1wbGF0ZSA9IHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlLmNsb25lTm9kZSh0cnVlKTtcbiAgICAgIH1cbiAgICAgIHByb3RvLl90ZW1wbGF0ZSA9IHRlbXBsYXRlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGEgYHByb3RvYCBiYXNlZCBvbiBhIGBwcm9wZXJ0aWVzYCBvYmplY3QuXG4gICAqIExldmVyYWdlcyBgUHJvcGVydHlFZmZlY3RzYCB0byBjcmVhdGUgcHJvcGVydHkgYWNjZXNzb3JzIGFuZCBlZmZlY3RzXG4gICAqIHN1cHBvcnRpbmcsIG9ic2VydmVycywgcmVmbGVjdGluZyB0byBhdHRyaWJ1dGVzLCBjaGFuZ2Ugbm90aWZpY2F0aW9uLFxuICAgKiBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgcmVhZCBvbmx5IHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7UG9seW1lckVsZW1lbnR9IHByb3RvIEVsZW1lbnQgY2xhc3MgcHJvdG90eXBlIHRvIGFkZCBhY2Nlc3NvcnNcbiAgICogICAgYW5kIGVmZmVjdHMgdG9cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgRmxhdHRlbmVkIGJhZyBvZiBwcm9wZXJ0eSBkZXNjcmlwdG9ycyBmb3JcbiAgICogICAgdGhpcyBjbGFzc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVQcm9wZXJ0aWVzKHByb3RvLCBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChsZXQgcCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBjcmVhdGVQcm9wZXJ0eUZyb21Db25maWcocHJvdG8sIHAsIHByb3BlcnRpZXNbcF0sIHByb3BlcnRpZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb25maWd1cmVzIGEgYHByb3RvYCBiYXNlZCBvbiBhIGBvYnNlcnZlcnNgIGFycmF5LlxuICAgKiBMZXZlcmFnZXMgYFByb3BlcnR5RWZmZWN0c2AgdG8gY3JlYXRlIG9ic2VydmVycy5cbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYnNlcnZlcnMgRmxhdHRlbmVkIGFycmF5IG9mIG9ic2VydmVyIGRlc2NyaXB0b3JzIGZvclxuICAgKiAgIHRoaXMgY2xhc3NcbiAgICogQHBhcmFtIHtPYmplY3R9IGR5bmFtaWNGbnMgT2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgYW55IHByb3BlcnRpZXNcbiAgICogICB0aGF0IGFyZSBmdW5jdGlvbnMgYW5kIHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3Qgd2hlbiB0aGUgZnVuY3Rpb25cbiAgICogICByZWZlcmVuY2UgaXMgY2hhbmdlZFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gZmluYWxpemVPYnNlcnZlcnMocHJvdG8sIG9ic2VydmVycywgZHluYW1pY0Zucykge1xuICAgIGZvciAobGV0IGk9MDsgaSA8IG9ic2VydmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgcHJvdG8uX2NyZWF0ZU1ldGhvZE9ic2VydmVyKG9ic2VydmVyc1tpXSwgZHluYW1pY0Zucyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgZWZmZWN0cyBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogTm90ZSwgb25jZSBhIHByb3BlcnR5IGhhcyBiZWVuIHNldCB0b1xuICAgKiBgcmVhZE9ubHlgLCBgY29tcHV0ZWRgLCBgcmVmbGVjdFRvQXR0cmlidXRlYCwgb3IgYG5vdGlmeWBcbiAgICogdGhlc2UgdmFsdWVzIG1heSBub3QgYmUgY2hhbmdlZC4gRm9yIGV4YW1wbGUsIGEgc3ViY2xhc3MgY2Fubm90XG4gICAqIGFsdGVyIHRoZXNlIHNldHRpbmdzLiBIb3dldmVyLCBhZGRpdGlvbmFsIGBvYnNlcnZlcnNgIG1heSBiZSBhZGRlZFxuICAgKiBieSBzdWJjbGFzc2VzLlxuICAgKlxuICAgKiBUaGUgaW5mbyBvYmplY3Qgc2hvdWxkIG1heSBjb250YWluIHByb3BlcnR5IG1ldGFkYXRhIGFzIGZvbGxvd3M6XG4gICAqXG4gICAqICogYHR5cGVgOiB7ZnVuY3Rpb259IHR5cGUgdG8gd2hpY2ggYW4gYXR0cmlidXRlIG1hdGNoaW5nIHRoZSBwcm9wZXJ0eVxuICAgKiBpcyBkZXNlcmlhbGl6ZWQuIE5vdGUgdGhlIHByb3BlcnR5IGlzIGNhbWVsLWNhc2VkIGZyb20gYSBkYXNoLWNhc2VkXG4gICAqIGF0dHJpYnV0ZS4gRm9yIGV4YW1wbGUsICdmb28tYmFyJyBhdHRyaWJ1dGUgaXMgZGVyc2lhbGl6ZWQgdG8gYVxuICAgKiBwcm9wZXJ0eSBuYW1lZCAnZm9vQmFyJy5cbiAgICpcbiAgICogKiBgcmVhZE9ubHlgOiB7Ym9vbGVhbn0gY3JlYXRlcyBhIHJlYWRPbmx5IHByb3BlcnR5IGFuZFxuICAgKiBtYWtlcyBhIHByaXZhdGUgc2V0dGVyIGZvciB0aGUgcHJpdmF0ZSBvZiB0aGUgZm9ybSAnX3NldEZvbycgZm9yIGFcbiAgICogcHJvcGVydHkgJ2ZvbycsXG4gICAqXG4gICAqICogYGNvbXB1dGVkYDoge3N0cmluZ30gY3JlYXRlcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBBIGNvbXB1dGVkIHByb3BlcnR5XG4gICAqIGFsc28gYXV0b21hdGljYWxseSBpcyBzZXQgdG8gYHJlYWRPbmx5OiB0cnVlYC4gVGhlIHZhbHVlIGlzIGNhbGN1bGF0ZWRcbiAgICogYnkgcnVubmluZyBhIG1ldGhvZCBhbmQgYXJndW1lbnRzIHBhcnNlZCBmcm9tIHRoZSBnaXZlbiBzdHJpbmcuIEZvclxuICAgKiBleGFtcGxlICdjb21wdXRlKGZvbyknIHdpbGwgY29tcHV0ZSBhIGdpdmVuIHByb3BlcnR5IHdoZW4gdGhlXG4gICAqICdmb28nIHByb3BlcnR5IGNoYW5nZXMgYnkgZXhlY3V0aW5nIHRoZSAnY29tcHV0ZScgbWV0aG9kLiBUaGlzIG1ldGhvZFxuICAgKiBtdXN0IHJldHVybiB0aGUgY29tcHV0ZWQgdmFsdWUuXG4gICAqXG4gICAqICogYHJlZmxlY3RUb0F0dHJpdXRlYDoge2Jvb2xlYW59IElmIHRydWUsIHRoZSBwcm9wZXJ0eSB2YWx1ZSBpcyByZWZsZWN0ZWRcbiAgICogdG8gYW4gYXR0cmlidXRlIG9mIHRoZSBzYW1lIG5hbWUuIE5vdGUsIHRoZSBhdHRyaWJ1dGUgaXMgZGFzaC1jYXNlZFxuICAgKiBzbyBhIHByb3BlcnR5IG5hbWVkICdmb29CYXInIGlzIHJlZmxlY3RlZCBhcyAnZm9vLWJhcicuXG4gICAqXG4gICAqICogYG5vdGlmeWA6IHtib29sZWFufSBzZW5kcyBhIG5vbi1idWJibGluZyBub3RpZmljYXRpb24gZXZlbnQgd2hlblxuICAgKiB0aGUgcHJvcGVydHkgY2hhbmdlcy4gRm9yIGV4YW1wbGUsIGEgcHJvcGVydHkgbmFtZWQgJ2Zvbycgc2VuZHMgYW5cbiAgICogZXZlbnQgbmFtZWQgJ2Zvby1jaGFuZ2VkJyB3aXRoIGBldmVudC5kZXRhaWxgIHNldCB0byB0aGUgdmFsdWUgb2ZcbiAgICogdGhlIHByb3BlcnR5LlxuICAgKlxuICAgKiAqIG9ic2VydmVyOiB7c3RyaW5nfSBuYW1lIG9mIGEgbWV0aG9kIHRoYXQgcnVucyB3aGVuIHRoZSBwcm9wZXJ0eVxuICAgKiBjaGFuZ2VzLiBUaGUgYXJndW1lbnRzIG9mIHRoZSBtZXRob2QgYXJlICh2YWx1ZSwgcHJldmlvdXNWYWx1ZSkuXG4gICAqXG4gICAqIE5vdGU6IFVzZXJzIG1heSB3YW50IGNvbnRyb2wgb3ZlciBtb2RpZnlpbmcgcHJvcGVydHlcbiAgICogZWZmZWN0cyB2aWEgc3ViY2xhc3NpbmcuIEZvciBleGFtcGxlLCBhIHVzZXIgbWlnaHQgd2FudCB0byBtYWtlIGFcbiAgICogcmVmbGVjdFRvQXR0cmlidXRlIHByb3BlcnR5IG5vdCBkbyBzbyBpbiBhIHN1YmNsYXNzLiBXZSd2ZSBjaG9zZW4gdG9cbiAgICogZGlzYWJsZSB0aGlzIGJlY2F1c2UgaXQgbGVhZHMgdG8gYWRkaXRpb25hbCBjb21wbGljYXRpb24uXG4gICAqIEZvciBleGFtcGxlLCBhIHJlYWRPbmx5IGVmZmVjdCBnZW5lcmF0ZXMgYSBzcGVjaWFsIHNldHRlci4gSWYgYSBzdWJjbGFzc1xuICAgKiBkaXNhYmxlcyB0aGUgZWZmZWN0LCB0aGUgc2V0dGVyIHdvdWxkIGZhaWwgdW5leHBlY3RlZGx5LlxuICAgKiBCYXNlZCBvbiBmZWVkYmFjaywgd2UgbWF5IHdhbnQgdG8gdHJ5IHRvIG1ha2UgZWZmZWN0cyBtb3JlIG1hbGxlYWJsZVxuICAgKiBhbmQvb3IgcHJvdmlkZSBhbiBhZHZhbmNlZCBhcGkgZm9yIG1hbmlwdWxhdGluZyB0aGVtLlxuICAgKiBBbHNvIGNvbnNpZGVyIGFkZGluZyB3YXJuaW5ncyB3aGVuIGFuIGVmZmVjdCBjYW5ub3QgYmUgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgdGhlIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyBJbmZvIG9iamVjdCBmcm9tIHdoaWNoIHRvIGNyZWF0ZSBwcm9wZXJ0eSBlZmZlY3RzLlxuICAgKiBTdXBwb3J0ZWQga2V5czpcbiAgICogQHBhcmFtIHtPYmplY3R9IGFsbFByb3BzIEZsYXR0ZW5lZCBtYXAgb2YgYWxsIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGlzXG4gICAqICAgZWxlbWVudCAoaW5jbHVkaW5nIGluaGVyaXRlZCBwcm9wZXJ0aWVzKVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlUHJvcGVydHlGcm9tQ29uZmlnKHByb3RvLCBuYW1lLCBpbmZvLCBhbGxQcm9wcykge1xuICAgIC8vIGNvbXB1dGVkIGZvcmNlcyByZWFkT25seS4uLlxuICAgIGlmIChpbmZvLmNvbXB1dGVkKSB7XG4gICAgICBpbmZvLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gTm90ZSwgc2luY2UgYWxsIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIHJlYWRPbmx5LCB0aGlzIHByZXZlbnRzXG4gICAgLy8gYWRkaW5nIGFkZGl0aW9uYWwgY29tcHV0ZWQgcHJvcGVydHkgZWZmZWN0cyAod2hpY2ggbGVhZHMgdG8gYSBjb25mdXNpbmdcbiAgICAvLyBzZXR1cCB3aGVyZSBtdWx0aXBsZSB0cmlnZ2VycyBmb3Igc2V0dGluZyBhIHByb3BlcnR5KVxuICAgIC8vIFdoaWxlIHdlIGRvIGhhdmUgYGhhc0NvbXB1dGVkRWZmZWN0YCB0aGlzIGlzIHNldCBvbiB0aGUgcHJvcGVydHknc1xuICAgIC8vIGRlcGVuZGVuY2llcyByYXRoZXIgdGhhbiBpdHNlbGYuXG4gICAgaWYgKGluZm8uY29tcHV0ZWQgICYmICFwcm90by5faGFzUmVhZE9ubHlFZmZlY3QobmFtZSkpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVDb21wdXRlZFByb3BlcnR5KG5hbWUsIGluZm8uY29tcHV0ZWQsIGFsbFByb3BzKTtcbiAgICB9XG4gICAgaWYgKGluZm8ucmVhZE9ubHkgJiYgIXByb3RvLl9oYXNSZWFkT25seUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkobmFtZSwgIWluZm8uY29tcHV0ZWQpO1xuICAgIH1cbiAgICBpZiAoaW5mby5yZWZsZWN0VG9BdHRyaWJ1dGUgJiYgIXByb3RvLl9oYXNSZWZsZWN0RWZmZWN0KG5hbWUpKSB7XG4gICAgICBwcm90by5fY3JlYXRlUmVmbGVjdGVkUHJvcGVydHkobmFtZSk7XG4gICAgfVxuICAgIGlmIChpbmZvLm5vdGlmeSAmJiAhcHJvdG8uX2hhc05vdGlmeUVmZmVjdChuYW1lKSkge1xuICAgICAgcHJvdG8uX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICAvLyBhbHdheXMgYWRkIG9ic2VydmVyXG4gICAgaWYgKGluZm8ub2JzZXJ2ZXIpIHtcbiAgICAgIHByb3RvLl9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKG5hbWUsIGluZm8ub2JzZXJ2ZXIsIGFsbFByb3BzW2luZm8ub2JzZXJ2ZXJdKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29uZmlndXJlcyBhbiBlbGVtZW50IGBwcm90b2AgdG8gZnVuY3Rpb24gd2l0aCBhIGdpdmVuIGB0ZW1wbGF0ZWAuXG4gICAqIFRoZSBlbGVtZW50IG5hbWUgYGlzYCBhbmQgZXh0ZW5kcyBgZXh0YCBtdXN0IGJlIHNwZWNpZmllZCBmb3IgU2hhZHlDU1NcbiAgICogc3R5bGUgc2NvcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtQb2x5bWVyRWxlbWVudH0gcHJvdG8gRWxlbWVudCBjbGFzcyBwcm90b3R5cGUgdG8gYWRkIGFjY2Vzc29yc1xuICAgKiAgIGFuZCBlZmZlY3RzIHRvXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHByb2Nlc3MgYW5kIGJpbmRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkkgVVJMIGFnYWluc3Qgd2hpY2ggdG8gcmVzb2x2ZSB1cmxzIGluXG4gICAqICAgc3R5bGUgZWxlbWVudCBjc3NUZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpcyBUYWcgbmFtZSAob3IgdHlwZSBleHRlbnNpb24gbmFtZSkgZm9yIHRoaXMgZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZz19IGV4dCBGb3IgdHlwZSBleHRlbnNpb25zLCB0aGUgdGFnIG5hbWUgdGhhdCB3YXMgZXh0ZW5kZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGZ1bmN0aW9uIGZpbmFsaXplVGVtcGxhdGUocHJvdG8sIHRlbXBsYXRlLCBiYXNlVVJJLCBpcywgZXh0KSB7XG4gICAgLy8gc3VwcG9ydCBgaW5jbHVkZT1cIm1vZHVsZS1uYW1lXCJgXG4gICAgbGV0IGNzc1RleHQgPVxuICAgICAgY3NzRnJvbU1vZHVsZUltcG9ydHMoaXMpICtcbiAgICAgIGNzc0Zyb21UZW1wbGF0ZSh0ZW1wbGF0ZSwgYmFzZVVSSSk7XG4gICAgaWYgKGNzc1RleHQpIHtcbiAgICAgIGxldCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9IGNzc1RleHQ7XG4gICAgICB0ZW1wbGF0ZS5jb250ZW50Lmluc2VydEJlZm9yZShzdHlsZSwgdGVtcGxhdGUuY29udGVudC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgICAgd2luZG93LlNoYWR5Q1NTLnByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgaXMsIGV4dCk7XG4gICAgfVxuICAgIHByb3RvLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgKi9cbiAgY2xhc3MgUG9seW1lckVsZW1lbnQgZXh0ZW5kcyBwb2x5bWVyRWxlbWVudEJhc2Uge1xuXG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzIFYxIEFQSS4gIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnNcbiAgICAgKiBhIGxpc3Qgb2YgZGFzaC1jYXNlZCBhdHRyaWJ1dGVzIGJhc2VkIG9uIGEgZmxhdHRlbmluZyBvZiBhbGwgcHJvcGVydGllc1xuICAgICAqIGRlY2xhcmVkIGluIGBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKWAgZm9yIHRoaXMgZWxlbWVudCBhbmQgYW55XG4gICAgICogc3VwZXJjbGFzc2VzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9IE9ic2VydmVkIGF0dHJpYnV0ZSBsaXN0XG4gICAgICovXG4gICAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX19vYnNlcnZlZEF0dHJpYnV0ZXMnLCB0aGlzKSkpIHtcbiAgICAgICAgbGV0IGxpc3QgPSBbXTtcbiAgICAgICAgbGV0IHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcyk7XG4gICAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIGxpc3QucHVzaChjYW1lbFRvRGFzaENhc2UocHJvcCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXMgPSBsaXN0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiB0aGUgZmlyc3QgZWxlbWVudCBpbnN0YW5jZSBpcyBjcmVhdGVkIHRvXG4gICAgICogZW5zdXJlIHRoYXQgY2xhc3MgZmluYWxpemF0aW9uIHdvcmsgaGFzIGJlZW4gY29tcGxldGVkLlxuICAgICAqIE1heSBiZSBjYWxsZWQgYnkgdXNlcnMgdG8gZWFnZXJseSBwZXJmb3JtIGNsYXNzIGZpbmFsaXphdGlvbiB3b3JrXG4gICAgICogcHJpb3IgdG8gdGhlIGNyZWF0aW9uIG9mIHRoZSBmaXJzdCBlbGVtZW50IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQ2xhc3MgZmluYWxpemF0aW9uIHdvcmsgZ2VuZXJhbGx5IGluY2x1ZGVzIG1ldGEtcHJvZ3JhbW1pbmcgc3VjaCBhc1xuICAgICAqIGNyZWF0aW5nIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgYW55IHByb3BlcnR5IGVmZmVjdCBtZXRhZGF0YSBuZWVkZWQgZm9yXG4gICAgICogdGhlIGZlYXR1cmVzIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3RhdGljIGZpbmFsaXplKCkge1xuICAgICAgaWYgKCFoYXNDbGFzc0ZpbmFsaXplZCh0aGlzKSkge1xuICAgICAgICBmaW5hbGl6ZUNsYXNzQW5kU3VwZXIodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdGVtcGxhdGUgdGhhdCB3aWxsIGJlIHN0YW1wZWQgaW50byB0aGlzIGVsZW1lbnQncyBzaGFkb3cgcm9vdC5cbiAgICAgKlxuICAgICAqIElmIGEgYHN0YXRpYyBnZXQgaXMoKWAgZ2V0dGVyIGlzIGRlZmluZWQsIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uXG4gICAgICogd2lsbCByZXR1cm4gdGhlIGZpcnN0IGA8dGVtcGxhdGU+YCBpbiBhIGBkb20tbW9kdWxlYCB3aG9zZSBgaWRgXG4gICAgICogbWF0Y2hlcyB0aGlzIGVsZW1lbnQncyBgaXNgLlxuICAgICAqXG4gICAgICogVXNlcnMgbWF5IG92ZXJyaWRlIHRoaXMgZ2V0dGVyIHRvIHJldHVybiBhbiBhcmJpdHJhcnkgdGVtcGxhdGVcbiAgICAgKiAoaW4gd2hpY2ggY2FzZSB0aGUgYGlzYCBnZXR0ZXIgaXMgdW5uZWNlc3NhcnkpLiBUaGUgdGVtcGxhdGUgcmV0dXJuZWRcbiAgICAgKiBtYXkgYmUgZWl0aGVyIGFuIGBIVE1MVGVtcGxhdGVFbGVtZW50YCBvciBhIHN0cmluZyB0aGF0IHdpbGwgYmVcbiAgICAgKiBhdXRvbWF0aWNhbGx5IHBhcnNlZCBpbnRvIGEgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgd2hlbiBzdWJjbGFzc2luZywgaWYgdGhlIHN1cGVyIGNsYXNzIG92ZXJyb2RlIHRoZSBkZWZhdWx0XG4gICAgICogaW1wbGVtZW50YXRpb24gYW5kIHRoZSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIHByb3ZpZGUgYW4gYWx0ZXJuYXRlXG4gICAgICogdGVtcGxhdGUgdmlhIGEgYGRvbS1tb2R1bGVgLCBpdCBzaG91bGQgb3ZlcnJpZGUgdGhpcyBnZXR0ZXIgYW5kXG4gICAgICogcmV0dXJuIGBQb2x5bWVyLkRvbU1vZHVsZS5pbXBvcnQodGhpcy5pcywgJ3RlbXBsYXRlJylgLlxuICAgICAqXG4gICAgICogSWYgYSBzdWJjbGFzcyB3b3VsZCBsaWtlIHRvIG1vZGlmeSB0aGUgc3VwZXIgY2xhc3MgdGVtcGxhdGUsIGl0IHNob3VsZFxuICAgICAqIGNsb25lIGl0IHJhdGhlciB0aGFuIG1vZGlmeSBpdCBpbiBwbGFjZS4gIElmIHRoZSBnZXR0ZXIgZG9lcyBleHBlbnNpdmVcbiAgICAgKiB3b3JrIHN1Y2ggYXMgY2xvbmluZy9tb2RpZnlpbmcgYSB0ZW1wbGF0ZSwgaXQgc2hvdWxkIG1lbW9pemUgdGhlXG4gICAgICogdGVtcGxhdGUgZm9yIG1heGltdW0gcGVyZm9ybWFuY2U6XG4gICAgICpcbiAgICAgKiAgIGxldCBtZW1vaXplZFRlbXBsYXRlO1xuICAgICAqICAgY2xhc3MgTXlTdWJDbGFzcyBleHRlbmRzIE15U3VwZXJDbGFzcyB7XG4gICAgICogICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICogICAgICAgaWYgKCFtZW1vaXplZFRlbXBsYXRlKSB7XG4gICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlID0gc3VwZXIudGVtcGxhdGUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgICAgICAgbGV0IHN1YkNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgKiAgICAgICAgIHN1YkNvbnRlbnQudGV4dENvbnRlbnQgPSAnVGhpcyBjYW1lIGZyb20gTXlTdWJDbGFzcyc7XG4gICAgICogICAgICAgICBtZW1vaXplZFRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kQ2hpbGQoc3ViQ29udGVudCk7XG4gICAgICogICAgICAgfVxuICAgICAqICAgICAgIHJldHVybiBtZW1vaXplZFRlbXBsYXRlO1xuICAgICAqICAgICB9XG4gICAgICogICB9XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MVGVtcGxhdGVFbGVtZW50fHN0cmluZ30gVGVtcGxhdGUgdG8gYmUgc3RhbXBlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkoSlNDb21waWxlcl9yZW5hbWVQcm9wZXJ0eSgnX3RlbXBsYXRlJywgdGhpcykpKSB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlID0gRG9tTW9kdWxlICYmIERvbU1vZHVsZS5pbXBvcnQoXG4gICAgICAgICAgLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IqLyAodGhpcykuaXMsICd0ZW1wbGF0ZScpIHx8XG4gICAgICAgICAgLy8gbm90ZTogaW1wbGVtZW50ZWQgc28gYSBzdWJjbGFzcyBjYW4gcmV0cmlldmUgdGhlIHN1cGVyXG4gICAgICAgICAgLy8gdGVtcGxhdGU7IGNhbGwgdGhlIHN1cGVyIGltcGwgdGhpcyB3YXkgc28gdGhhdCBgdGhpc2AgcG9pbnRzXG4gICAgICAgICAgLy8gdG8gdGhlIHN1cGVyY2xhc3MuXG4gICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yKi8gKHRoaXMpLnByb3RvdHlwZSkuY29uc3RydWN0b3IudGVtcGxhdGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGF0aCBtYXRjaGluZyB0aGUgdXJsIGZyb20gd2hpY2ggdGhlIGVsZW1lbnQgd2FzIGltcG9ydGVkLlxuICAgICAqIFRoaXMgcGF0aCBpcyB1c2VkIHRvIHJlc29sdmUgdXJsJ3MgaW4gdGVtcGxhdGUgc3R5bGUgY3NzVGV4dC5cbiAgICAgKiBUaGUgYGltcG9ydFBhdGhgIHByb3BlcnR5IGlzIGFsc28gc2V0IG9uIGVsZW1lbnQgaW5zdGFuY2VzIGFuZCBjYW4gYmVcbiAgICAgKiB1c2VkIHRvIGNyZWF0ZSBiaW5kaW5ncyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IHBhdGguXG4gICAgICogRGVmYXVsdHMgdG8gdGhlIHBhdGggbWF0Y2hpbmcgdGhlIHVybCBjb250YWluaW5nIGEgYGRvbS1tb2R1bGVgIGVsZW1lbnRcbiAgICAgKiBtYXRjaGluZyB0aGlzIGVsZW1lbnQncyBzdGF0aWMgYGlzYCBwcm9wZXJ0eS5cbiAgICAgKiBOb3RlLCB0aGlzIHBhdGggc2hvdWxkIGNvbnRhaW4gYSB0cmFpbGluZyBgL2AuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBpbXBvcnQgcGF0aCBmb3IgdGhpcyBlbGVtZW50IGNsYXNzXG4gICAgICovXG4gICAgc3RhdGljIGdldCBpbXBvcnRQYXRoKCkge1xuICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19pbXBvcnRQYXRoJywgdGhpcykpKSB7XG4gICAgICAgICAgY29uc3QgbW9kdWxlID0gRG9tTW9kdWxlICYmIERvbU1vZHVsZS5pbXBvcnQoLyoqIEB0eXBlIFBvbHltZXJFbGVtZW50Q29uc3RydWN0b3IgKi8gKHRoaXMpLmlzKTtcbiAgICAgICAgICB0aGlzLl9pbXBvcnRQYXRoID0gbW9kdWxlID8gbW9kdWxlLmFzc2V0cGF0aCA6ICcnIHx8XG4gICAgICAgICAgT2JqZWN0LmdldFByb3RvdHlwZU9mKC8qKiBAdHlwZSBQb2x5bWVyRWxlbWVudENvbnN0cnVjdG9yKi8gKHRoaXMpLnByb3RvdHlwZSkuY29uc3RydWN0b3IuaW1wb3J0UGF0aDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9pbXBvcnRQYXRoO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi9cbiAgICAgIHRoaXMuX3RlbXBsYXRlO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLl9pbXBvcnRQYXRoO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLnJvb3RQYXRoO1xuICAgICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgICB0aGlzLmltcG9ydFBhdGg7XG4gICAgICAvKiogQHR5cGUge1N0YW1wZWRUZW1wbGF0ZSB8IEhUTUxFbGVtZW50IHwgU2hhZG93Um9vdH0gKi9cbiAgICAgIHRoaXMucm9vdDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdDxzdHJpbmcsICFOb2RlPn0gKi9cbiAgICAgIHRoaXMuJDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIHRvIGVuc3VyZSBjbGFzc1xuICAgICAqIG1ldGFwcm9ncmFtbWluZyByZWxhdGVkIHRvIHByb3BlcnR5IGFjY2Vzc29ycyBhbmQgZWZmZWN0cyBoYXNcbiAgICAgKiBjb21wbGV0ZWQgKGNhbGxzIGBmaW5hbGl6ZWApLlxuICAgICAqXG4gICAgICogSXQgYWxzbyBpbml0aWFsaXplcyBhbnkgcHJvcGVydHkgZGVmYXVsdHMgcHJvdmlkZWQgdmlhIGB2YWx1ZWAgaW5cbiAgICAgKiBgcHJvcGVydGllc2AgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpbnN0YW5jZUNvdW50Kys7XG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLmZpbmFsaXplKCk7XG4gICAgICBjb25zdCBpbXBvcnRQYXRoID0gdGhpcy5jb25zdHJ1Y3Rvci5pbXBvcnRQYXRoO1xuICAgICAgLy8gbm90ZTogZmluYWxpemUgdGVtcGxhdGUgd2hlbiB3ZSBoYXZlIGFjY2VzcyB0byBgbG9jYWxOYW1lYCB0b1xuICAgICAgLy8gYXZvaWQgZGVwZW5kZW5jZSBvbiBgaXNgIGZvciBwb2x5ZmlsbGluZyBzdHlsaW5nLlxuICAgICAgaWYgKHRoaXMuX3RlbXBsYXRlICYmICF0aGlzLl90ZW1wbGF0ZS5fX3BvbHltZXJGaW5hbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGUuX19wb2x5bWVyRmluYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgYmFzZVVSSSA9XG4gICAgICAgICAgaW1wb3J0UGF0aCA/IHJlc29sdmVVcmwkMChpbXBvcnRQYXRoKSA6ICcnO1xuICAgICAgICBmaW5hbGl6ZVRlbXBsYXRlKC8qKiBAdHlwZSB7IVBvbHltZXJFbGVtZW50fSAqLyh0aGlzLl9fcHJvdG9fXyksIHRoaXMuX3RlbXBsYXRlLCBiYXNlVVJJLFxuICAgICAgICAgIC8qKkB0eXBlIHshSFRNTEVsZW1lbnR9Ki8odGhpcykubG9jYWxOYW1lKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgICAgLy8gc2V0IHBhdGggZGVmYXVsdHNcbiAgICAgIHRoaXMucm9vdFBhdGggPSByb290UGF0aCQwO1xuICAgICAgdGhpcy5pbXBvcnRQYXRoID0gaW1wb3J0UGF0aDtcbiAgICAgIC8vIGFwcGx5IHByb3BlcnR5IGRlZmF1bHRzLi4uXG4gICAgICBsZXQgcCQgPSBwcm9wZXJ0eURlZmF1bHRzRm9yQ2xhc3ModGhpcy5jb25zdHJ1Y3Rvcik7XG4gICAgICBpZiAoIXAkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IHAgaW4gcCQpIHtcbiAgICAgICAgbGV0IGluZm8gPSBwJFtwXTtcbiAgICAgICAgLy8gRG9uJ3Qgc2V0IGRlZmF1bHQgdmFsdWUgaWYgdGhlcmUgaXMgYWxyZWFkeSBhbiBvd24gcHJvcGVydHksIHdoaWNoXG4gICAgICAgIC8vIGhhcHBlbnMgd2hlbiBhIGBwcm9wZXJ0aWVzYCBwcm9wZXJ0eSB3aXRoIGRlZmF1bHQgYnV0IG5vIGVmZmVjdHMgaGFkXG4gICAgICAgIC8vIGEgcHJvcGVydHkgc2V0IChlLmcuIGJvdW5kKSBieSBpdHMgaG9zdCBiZWZvcmUgdXBncmFkZVxuICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkocCkpIHtcbiAgICAgICAgICBsZXQgdmFsdWUgPSB0eXBlb2YgaW5mby52YWx1ZSA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgIGluZm8udmFsdWUuY2FsbCh0aGlzKSA6XG4gICAgICAgICAgICBpbmZvLnZhbHVlO1xuICAgICAgICAgIC8vIFNldCB2aWEgYF9zZXRQcm9wZXJ0eWAgaWYgdGhlcmUgaXMgYW4gYWNjZXNzb3IsIHRvIGVuYWJsZVxuICAgICAgICAgIC8vIGluaXRpYWxpemluZyByZWFkT25seSBwcm9wZXJ0eSBkZWZhdWx0c1xuICAgICAgICAgIGlmICh0aGlzLl9oYXNBY2Nlc3NvcihwKSkge1xuICAgICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHAsIHZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1twXSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGNvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGVuYWJsZXMgdGhlIHByb3BlcnR5IGVmZmVjdHMgc3lzdGVtIGFuZFxuICAgICAqIGZsdXNoZXMgYW55IHBlbmRpbmcgcHJvcGVydGllcywgYW5kIHVwZGF0ZXMgc2hpbW1lZCBDU1MgcHJvcGVydGllc1xuICAgICAqIHdoZW4gdXNpbmcgdGhlIFNoYWR5Q1NTIHNjb3BpbmcvY3VzdG9tIHByb3BlcnRpZXMgcG9seWZpbGwuXG4gICAgICpcbiAgICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICAgKi9cbiAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MgJiYgdGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlRWxlbWVudCgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcykpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZW5hYmxlUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGEgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgc3RhbmRhcmQgQ3VzdG9tIEVsZW1lbnRzXG4gICAgICogYGRpc2Nvbm5lY3RlZENhbGxiYWNrYC5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBTdGFtcHMgdGhlIGVsZW1lbnQgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIGlmICh0aGlzLl90ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRoaXMuX3RlbXBsYXRlKTtcbiAgICAgICAgdGhpcy4kID0gdGhpcy5yb290LiQ7XG4gICAgICB9XG4gICAgICBzdXBlci5yZWFkeSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgYFByb3BlcnR5RWZmZWN0c2AncyBgX3JlYWR5Q2xpZW50c2AgY2FsbC4gQXR0YWNoZXNcbiAgICAgKiBlbGVtZW50IGRvbSBieSBjYWxsaW5nIGBfYXR0YWNoRG9tYCB3aXRoIHRoZSBkb20gc3RhbXBlZCBmcm9tIHRoZVxuICAgICAqIGVsZW1lbnQncyB0ZW1wbGF0ZSB2aWEgYF9zdGFtcFRlbXBsYXRlYC4gTm90ZSB0aGF0IHRoaXMgYWxsb3dzXG4gICAgICogY2xpZW50IGRvbSB0byBiZSBhdHRhY2hlZCB0byB0aGUgZWxlbWVudCBwcmlvciB0byBhbnkgb2JzZXJ2ZXJzXG4gICAgICogcnVubmluZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9yZWFkeUNsaWVudHMoKSB7XG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5fYXR0YWNoRG9tKC8qKiBAdHlwZSB7U3RhbXBlZFRlbXBsYXRlfSAqLyh0aGlzLnJvb3QpKTtcbiAgICAgIH1cbiAgICAgIC8vIFRoZSBzdXBlci5fcmVhZHlDbGllbnRzIGhlcmUgc2V0cyB0aGUgY2xpZW50cyBpbml0aWFsaXplZCBmbGFnLlxuICAgICAgLy8gV2UgbXVzdCB3YWl0IHRvIGRvIHRoaXMgdW50aWwgYWZ0ZXIgY2xpZW50IGRvbSBpcyBjcmVhdGVkL2F0dGFjaGVkXG4gICAgICAvLyBzbyB0aGF0IHRoaXMgZmxhZyBjYW4gYmUgY2hlY2tlZCB0byBwcmV2ZW50IG5vdGlmaWNhdGlvbnMgZmlyZWRcbiAgICAgIC8vIGR1cmluZyB0aGlzIHByb2Nlc3MgZnJvbSBiZWluZyBoYW5kbGVkIGJlZm9yZSBjbGllbnRzIGFyZSByZWFkeS5cbiAgICAgIHN1cGVyLl9yZWFkeUNsaWVudHMoKTtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGFuIGVsZW1lbnQncyBzdGFtcGVkIGRvbSB0byBpdHNlbGYuIEJ5IGRlZmF1bHQsXG4gICAgICogdGhpcyBtZXRob2QgY3JlYXRlcyBhIGBzaGFkb3dSb290YCBhbmQgYWRkcyB0aGUgZG9tIHRvIGl0LlxuICAgICAqIEhvd2V2ZXIsIHRoaXMgbWV0aG9kIG1heSBiZSBvdmVycmlkZGVuIHRvIGFsbG93IGFuIGVsZW1lbnRcbiAgICAgKiB0byBwdXQgaXRzIGRvbSBpbiBhbm90aGVyIGxvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9XG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUmV0dXJufVxuICAgICAqIEBwYXJhbSB7U3RhbXBlZFRlbXBsYXRlfSBkb20gdG8gYXR0YWNoIHRvIHRoZSBlbGVtZW50LlxuICAgICAqIEByZXR1cm4ge1NoYWRvd1Jvb3R9IG5vZGUgdG8gd2hpY2ggdGhlIGRvbSBoYXMgYmVlbiBhdHRhY2hlZC5cbiAgICAgKi9cbiAgICBfYXR0YWNoRG9tKGRvbSkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoU2hhZG93KSB7XG4gICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoZG9tKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zaGFkb3dSb290O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkb3dET00gbm90IGF2YWlsYWJsZS4gJyArXG4gICAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogbW92ZSB0byBjb21waWxlLXRpbWUgY29uZGl0aW9uYWwgd2hlbiBzdXBwb3J0ZWRcbiAgICAgICAgJ1BvbHltZXIuRWxlbWVudCBjYW4gY3JlYXRlIGRvbSBhcyBjaGlsZHJlbiBpbnN0ZWFkIG9mIGluICcgK1xuICAgICAgICAnU2hhZG93RE9NIGJ5IHNldHRpbmcgYHRoaXMucm9vdCA9IHRoaXM7XFxgIGJlZm9yZSBcXGByZWFkeVxcYC4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIHN0YW5kYXJkIEN1c3RvbSBFbGVtZW50c1xuICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCwgYXR0cmlidXRlcyBkZWNsYXJlZCBpbiBgcHJvcGVydGllc2AgbWV0YWRhdGEgYXJlXG4gICAgICogZGVzZXJpYWxpemVkIHVzaW5nIHRoZWlyIGB0eXBlYCBpbmZvcm1hdGlvbiB0byBwcm9wZXJ0aWVzIG9mIHRoZVxuICAgICAqIHNhbWUgbmFtZS4gIFwiRGFzaC1jYXNlZFwiIGF0dHJpYnV0ZXMgYXJlIGRlc2VyaWFsemVkIHRvIFwiY2FtZWxDYXNlXCJcbiAgICAgKiBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGQgT2xkIHZhbHVlIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIEN1cnJlbnQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBpZiAob2xkICE9PSB2YWx1ZSkge1xuICAgICAgICBsZXQgcHJvcGVydHkgPSBjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgbGV0IHR5cGUgPSBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcy5jb25zdHJ1Y3RvcilbcHJvcGVydHldLnR5cGU7XG4gICAgICAgIGlmICghdGhpcy5faGFzUmVhZE9ubHlFZmZlY3QocHJvcGVydHkpKSB7XG4gICAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSwgdHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHVzaW5nIHRoZSBTaGFkeUNTUyBzY29waW5nIGFuZCBjdXN0b20gcHJvcGVydHkgc2hpbSwgY2F1c2VzIGFsbFxuICAgICAqIHNoaW1tZWQgc3R5bGVzIGluIHRoaXMgZWxlbWVudCAoYW5kIGl0cyBzdWJ0cmVlKSB0byBiZSB1cGRhdGVkXG4gICAgICogYmFzZWQgb24gY3VycmVudCBjdXN0b20gcHJvcGVydHkgdmFsdWVzLlxuICAgICAqXG4gICAgICogVGhlIG9wdGlvbmFsIHBhcmFtZXRlciBvdmVycmlkZXMgaW5saW5lIGN1c3RvbSBwcm9wZXJ0eSBzdHlsZXMgd2l0aCBhblxuICAgICAqIG9iamVjdCBvZiBwcm9wZXJ0aWVzIHdoZXJlIHRoZSBrZXlzIGFyZSBDU1MgcHJvcGVydGllcywgYW5kIHRoZSB2YWx1ZXNcbiAgICAgKiBhcmUgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6IGB0aGlzLnVwZGF0ZVN0eWxlcyh7Jy0tY29sb3InOiAnYmx1ZSd9KWBcbiAgICAgKlxuICAgICAqIFRoZXNlIHByb3BlcnRpZXMgYXJlIHJldGFpbmVkIHVubGVzcyBhIHZhbHVlIG9mIGBudWxsYCBpcyBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgQmFnIG9mIGN1c3RvbSBwcm9wZXJ0eSBrZXkvdmFsdWVzIHRvXG4gICAgICogICBhcHBseSB0byB0aGlzIGVsZW1lbnQuXG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICovXG4gICAgdXBkYXRlU3R5bGVzKHByb3BlcnRpZXMpIHtcbiAgICAgIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgICAgICAgd2luZG93LlNoYWR5Q1NTLnN0eWxlU3VidHJlZSgvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8odGhpcyksIHByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJld3JpdGVzIGEgZ2l2ZW4gVVJMIHJlbGF0aXZlIHRvIGEgYmFzZSBVUkwuIFRoZSBiYXNlIFVSTCBkZWZhdWx0cyB0b1xuICAgICAqIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiBvZiB0aGUgZG9jdW1lbnQgY29udGFpbmluZyB0aGUgYGRvbS1tb2R1bGVgIGZvclxuICAgICAqIHRoaXMgZWxlbWVudC4gVGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gdGhlIHNhbWUgVVJMIGJlZm9yZSBhbmQgYWZ0ZXJcbiAgICAgKiBidW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVVJMIHRvIHJlc29sdmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBiYXNlIE9wdGlvbmFsIGJhc2UgVVJMIHRvIHJlc29sdmUgYWdhaW5zdCwgZGVmYXVsdHNcbiAgICAgKiB0byB0aGUgZWxlbWVudCdzIGBpbXBvcnRQYXRoYFxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV3cml0dGVuIFVSTCByZWxhdGl2ZSB0byBiYXNlXG4gICAgICovXG4gICAgcmVzb2x2ZVVybCh1cmwsIGJhc2UpIHtcbiAgICAgIGlmICghYmFzZSAmJiB0aGlzLmltcG9ydFBhdGgpIHtcbiAgICAgICAgYmFzZSA9IHJlc29sdmVVcmwkMCh0aGlzLmltcG9ydFBhdGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc29sdmVVcmwkMCh1cmwsIGJhc2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcnNgIHRvIGFkZCBtYXAgb2YgZHluYW1pYyBmdW5jdGlvbnMgb25cbiAgICAgKiB0ZW1wbGF0ZSBpbmZvLCBmb3IgY29uc3VtcHRpb24gYnkgYFByb3BlcnR5RWZmZWN0c2AgdGVtcGxhdGUgYmluZGluZ1xuICAgICAqIGNvZGUuIFRoaXMgbWFwIGRldGVybWluZXMgd2hpY2ggbWV0aG9kIHRlbXBsYXRlcyBzaG91bGQgaGF2ZSBhY2Nlc3NvcnNcbiAgICAgKiBjcmVhdGVkIGZvciB0aGVtLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc30gSW50ZXJmYWNlcyBpbiBjbG9zdXJlIGRvIG5vdCBpbmhlcml0IHN0YXRpY3MsIGJ1dCBjbGFzc2VzIGRvXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgdGVtcGxhdGVJbmZvLmR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucyB8fCBwcm9wZXJ0aWVzRm9yQ2xhc3ModGhpcyk7XG4gICAgICByZXR1cm4gc3VwZXIuX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKTtcbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBQb2x5bWVyRWxlbWVudDtcbn0pO1xuXG5leHBvcnQgbGV0IGluc3RhbmNlQ291bnQgPSAwO1xuZXhwb3J0IGNvbnN0IHJlZ2lzdHJhdGlvbnMgPSBbXTtcblxuZXhwb3J0IGZ1bmN0aW9uIF9yZWdMb2cocHJvdG90eXBlKSB7XG4gIGNvbnNvbGUubG9nKCdbJyArIHByb3RvdHlwZS5pcyArICddOiByZWdpc3RlcmVkJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdpc3Rlcihwcm90b3R5cGUpIHtcbiAgcmVnaXN0cmF0aW9ucy5wdXNoKHByb3RvdHlwZSk7XG4gIHVuZGVmaW5lZCAmJiBfcmVnTG9nKHByb3RvdHlwZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkdW1wUmVnaXN0cmF0aW9ucygpIHtcbiAgcmVnaXN0cmF0aW9ucy5mb3JFYWNoKF9yZWdMb2cpO1xufVxuXG5leHBvcnQgY29uc3QgdXBkYXRlU3R5bGVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgaWYgKHdpbmRvdy5TaGFkeUNTUykge1xuICAgIHdpbmRvdy5TaGFkeUNTUy5zdHlsZURvY3VtZW50KHByb3BzKTtcbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9lbGVtZW50LW1peGluLmpzXG4vLyBtb2R1bGUgaWQgPSAyMFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVVybCwgcGF0aEZyb21VcmwgfSBmcm9tICcuLi91dGlscy9yZXNvbHZlLXVybC5qcyc7XG5cbmxldCBtb2R1bGVzID0ge307XG5sZXQgbGNNb2R1bGVzID0ge307XG5mdW5jdGlvbiBmaW5kTW9kdWxlKGlkKSB7XG4gIHJldHVybiBtb2R1bGVzW2lkXSB8fCBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV07XG59XG5cbmZ1bmN0aW9uIHN0eWxlT3V0c2lkZVRlbXBsYXRlQ2hlY2soaW5zdCkge1xuICBpZiAoaW5zdC5xdWVyeVNlbGVjdG9yKCdzdHlsZScpKSB7XG4gICAgY29uc29sZS53YXJuKCdkb20tbW9kdWxlICVzIGhhcyBzdHlsZSBvdXRzaWRlIHRlbXBsYXRlJywgaW5zdC5pZCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgYGRvbS1tb2R1bGVgIGVsZW1lbnQgcmVnaXN0ZXJzIHRoZSBkb20gaXQgY29udGFpbnMgdG8gdGhlIG5hbWUgZ2l2ZW5cbiAqIGJ5IHRoZSBtb2R1bGUncyBpZCBhdHRyaWJ1dGUuIEl0IHByb3ZpZGVzIGEgdW5pZmllZCBkYXRhYmFzZSBvZiBkb21cbiAqIGFjY2Vzc2libGUgdmlhIGl0cyBzdGF0aWMgYGltcG9ydGAgQVBJLlxuICpcbiAqIEEga2V5IHVzZSBjYXNlIG9mIGBkb20tbW9kdWxlYCBpcyBmb3IgcHJvdmlkaW5nIGN1c3RvbSBlbGVtZW50IGA8dGVtcGxhdGU+YHNcbiAqIHZpYSBIVE1MIGltcG9ydHMgdGhhdCBhcmUgcGFyc2VkIGJ5IHRoZSBuYXRpdmUgSFRNTCBwYXJzZXIsIHRoYXQgY2FuIGJlXG4gKiByZWxvY2F0ZWQgZHVyaW5nIGEgYnVuZGxpbmcgcGFzcyBhbmQgc3RpbGwgbG9va2VkIHVwIGJ5IGBpZGAuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgPGRvbS1tb2R1bGUgaWQ9XCJmb29cIj5cbiAqICAgICAgIDxpbWcgc3JjPVwic3R1ZmYucG5nXCI+XG4gKiAgICAgPC9kb20tbW9kdWxlPlxuICpcbiAqIFRoZW4gaW4gY29kZSBpbiBzb21lIG90aGVyIGxvY2F0aW9uIHRoYXQgY2Fubm90IGFjY2VzcyB0aGUgZG9tLW1vZHVsZSBhYm92ZVxuICpcbiAqICAgICBsZXQgaW1nID0gY3VzdG9tRWxlbWVudHMuZ2V0KCdkb20tbW9kdWxlJykuaW1wb3J0KCdmb28nLCAnaW1nJyk7XG4gKlxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBleHRlbmRzIEhUTUxFbGVtZW50XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBwcm92aWRlcyBhIHJlZ2lzdHJ5IG9mIHJlbG9jYXRhYmxlIERPTSBjb250ZW50XG4gKiAgIGJ5IGBpZGAgdGhhdCBpcyBhZ25vc3RpYyB0byBidW5kbGluZy5cbiAqIEB1bnJlc3RyaWN0ZWRcbiAqL1xuY2xhc3MgRG9tTW9kdWxlIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkgeyByZXR1cm4gWydpZCddOyB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgZWxlbWVudCBzcGVjaWZpZWQgYnkgdGhlIGNzcyBgc2VsZWN0b3JgIGluIHRoZSBtb2R1bGVcbiAgICogcmVnaXN0ZXJlZCBieSBgaWRgLiBGb3IgZXhhbXBsZSwgdGhpcy5pbXBvcnQoJ2ZvbycsICdpbWcnKTtcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBpZCBvZiB0aGUgZG9tLW1vZHVsZSBpbiB3aGljaCB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gc2VsZWN0b3IgVGhlIGNzcyBzZWxlY3RvciBieSB3aGljaCB0byBmaW5kIHRoZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fSBSZXR1cm5zIHRoZSBlbGVtZW50IHdoaWNoIG1hdGNoZXMgYHNlbGVjdG9yYCBpbiB0aGVcbiAgICogbW9kdWxlIHJlZ2lzdGVyZWQgYXQgdGhlIHNwZWNpZmllZCBgaWRgLlxuICAgKi9cbiAgc3RhdGljIGltcG9ydChpZCwgc2VsZWN0b3IpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGxldCBtID0gZmluZE1vZHVsZShpZCk7XG4gICAgICBpZiAobSAmJiBzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gbS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXIoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIGFic29sdXRlIFVSTCBvZiB0aGUgb3JpZ2luYWwgbG9jYXRpb24gb2YgdGhpcyBgZG9tLW1vZHVsZWAuXG4gICAqXG4gICAqIFRoaXMgdmFsdWUgd2lsbCBkaWZmZXIgZnJvbSB0aGlzIGVsZW1lbnQncyBgb3duZXJEb2N1bWVudGAgaW4gdGhlXG4gICAqIGZvbGxvd2luZyB3YXlzOlxuICAgKiAtIFRha2VzIGludG8gYWNjb3VudCBhbnkgYGFzc2V0cGF0aGAgYXR0cmlidXRlIGFkZGVkIGR1cmluZyBidW5kbGluZ1xuICAgKiAgIHRvIGluZGljYXRlIHRoZSBvcmlnaW5hbCBsb2NhdGlvbiByZWxhdGl2ZSB0byB0aGUgYnVuZGxlZCBsb2NhdGlvblxuICAgKiAtIFVzZXMgdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsJ3MgYGltcG9ydEZvckVsZW1lbnRgIEFQSSB0byBlbnN1cmVcbiAgICogICB0aGUgcGF0aCBpcyByZWxhdGl2ZSB0byB0aGUgaW1wb3J0IGRvY3VtZW50J3MgbG9jYXRpb24gc2luY2VcbiAgICogICBgb3duZXJEb2N1bWVudGAgaXMgbm90IGN1cnJlbnRseSBwb2x5ZmlsbGVkXG4gICAqL1xuICBnZXQgYXNzZXRwYXRoKCkge1xuICAgIC8vIERvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGFzc2V0cGF0aC5cbiAgICBpZiAoIXRoaXMuX19hc3NldHBhdGgpIHtcbiAgICAgIC8vIG5vdGU6IGFzc2V0cGF0aCBzZXQgdmlhIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIHJlbGF0aXZlIHRvIHRoaXNcbiAgICAgIC8vIGVsZW1lbnQncyBsb2NhdGlvbjsgYWNjb21vZGF0ZSBwb2x5ZmlsbGVkIEhUTUxJbXBvcnRzXG4gICAgICBjb25zdCBvd25lciA9IHdpbmRvdy5IVE1MSW1wb3J0cyAmJiBIVE1MSW1wb3J0cy5pbXBvcnRGb3JFbGVtZW50ID9cbiAgICAgICAgSFRNTEltcG9ydHMuaW1wb3J0Rm9yRWxlbWVudCh0aGlzKSB8fCBkb2N1bWVudCA6IHRoaXMub3duZXJEb2N1bWVudDtcbiAgICAgIGNvbnN0IHVybCA9IHJlc29sdmVVcmwoXG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdhc3NldHBhdGgnKSB8fCAnJywgb3duZXIuYmFzZVVSSSk7XG4gICAgICB0aGlzLl9fYXNzZXRwYXRoID0gcGF0aEZyb21VcmwodXJsKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19hc3NldHBhdGg7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIHRoZSBkb20tbW9kdWxlIGF0IGEgZ2l2ZW4gaWQuIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIGNhbGxlZFxuICAgKiB3aGVuIGEgZG9tLW1vZHVsZSBpcyBpbXBlcmF0aXZlbHkgY3JlYXRlZC4gRm9yXG4gICAqIGV4YW1wbGUsIGBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkb20tbW9kdWxlJykucmVnaXN0ZXIoJ2ZvbycpYC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBpZCBUaGUgaWQgYXQgd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIGRvbS1tb2R1bGUuXG4gICAqL1xuICByZWdpc3RlcihpZCkge1xuICAgIGlkID0gaWQgfHwgdGhpcy5pZDtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgIC8vIHN0b3JlIGlkIHNlcGFyYXRlIGZyb20gbG93ZXJjYXNlZCBpZCBzbyB0aGF0XG4gICAgICAvLyBpbiBhbGwgY2FzZXMgbWl4ZWRDYXNlIGlkIHdpbGwgc3RvcmVkIGRpc3RpbmN0bHlcbiAgICAgIC8vIGFuZCBsb3dlcmNhc2UgdmVyc2lvbiBpcyBhIGZhbGxiYWNrXG4gICAgICBtb2R1bGVzW2lkXSA9IHRoaXM7XG4gICAgICBsY01vZHVsZXNbaWQudG9Mb3dlckNhc2UoKV0gPSB0aGlzO1xuICAgICAgc3R5bGVPdXRzaWRlVGVtcGxhdGVDaGVjayh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuRG9tTW9kdWxlLnByb3RvdHlwZVsnbW9kdWxlcyddID0gbW9kdWxlcztcblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCdkb20tbW9kdWxlJywgRG9tTW9kdWxlKTtcblxuZXhwb3J0IHsgRG9tTW9kdWxlIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20tbW9kdWxlLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3V0aWxzL2Jvb3QuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IHJvb3QgYXMgcm9vdCQwLCBpc0FuY2VzdG9yLCBpc0Rlc2NlbmRhbnQsIGdldCBhcyBnZXQkMCwgdHJhbnNsYXRlLCBpc1BhdGggYXMgaXNQYXRoJDAsIHNldCBhcyBzZXQkMCwgbm9ybWFsaXplIH0gZnJvbSAnLi4vdXRpbHMvcGF0aC5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwIGZyb20gJy4uL3V0aWxzL2Nhc2UtbWFwLmpzJztcbmltcG9ydCB7IGNhbWVsVG9EYXNoQ2FzZSBhcyBjYW1lbFRvRGFzaENhc2UkMCwgZGFzaFRvQ2FtZWxDYXNlIH0gZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlBY2Nlc3NvcnMgfSBmcm9tICcuL3Byb3BlcnR5LWFjY2Vzc29ycy5qcyc7XG5pbXBvcnQgeyBUZW1wbGF0ZVN0YW1wIH0gZnJvbSAnLi90ZW1wbGF0ZS1zdGFtcC5qcyc7XG5pbXBvcnQgeyBzYW5pdGl6ZURPTVZhbHVlIH0gZnJvbSAnLi4vdXRpbHMvc2V0dGluZ3MuanMnO1xuXG4vKiogQGNvbnN0IHtPYmplY3R9ICovXG5jb25zdCBDYXNlTWFwID0gY2FzZU1hcDtcblxuLy8gTW9ub3RvbmljYWxseSBpbmNyZWFzaW5nIHVuaXF1ZSBJRCB1c2VkIGZvciBkZS1kdXBpbmcgZWZmZWN0cyB0cmlnZ2VyZWRcbi8vIGZyb20gbXVsdGlwbGUgcHJvcGVydGllcyBpbiB0aGUgc2FtZSB0dXJuXG5sZXQgZGVkdXBlSWQgPSAwO1xuXG4vKipcbiAqIFByb3BlcnR5IGVmZmVjdCB0eXBlczsgZWZmZWN0cyBhcmUgc3RvcmVkIG9uIHRoZSBwcm90b3R5cGUgdXNpbmcgdGhlc2Uga2V5c1xuICogQGVudW0ge3N0cmluZ31cbiAqL1xuY29uc3QgVFlQRVMgPSB7XG4gIENPTVBVVEU6ICdfX2NvbXB1dGVFZmZlY3RzJyxcbiAgUkVGTEVDVDogJ19fcmVmbGVjdEVmZmVjdHMnLFxuICBOT1RJRlk6ICdfX25vdGlmeUVmZmVjdHMnLFxuICBQUk9QQUdBVEU6ICdfX3Byb3BhZ2F0ZUVmZmVjdHMnLFxuICBPQlNFUlZFOiAnX19vYnNlcnZlRWZmZWN0cycsXG4gIFJFQURfT05MWTogJ19fcmVhZE9ubHknXG59O1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiBuYW1lOiAoc3RyaW5nIHwgdW5kZWZpbmVkKSxcbiAqIHN0cnVjdHVyZWQ6IChib29sZWFuIHwgdW5kZWZpbmVkKSxcbiAqIHdpbGRjYXJkOiAoYm9vbGVhbiB8IHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBEYXRhVHJpZ2dlcjsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqIGluZm86ID8sXG4gKiB0cmlnZ2VyOiAoIURhdGFUcmlnZ2VyIHwgdW5kZWZpbmVkKSxcbiAqIGZuOiAoIUZ1bmN0aW9uIHwgdW5kZWZpbmVkKVxuICogfX1cbiAqL1xubGV0IERhdGFFZmZlY3Q7IC8vZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5sZXQgUHJvcGVydHlFZmZlY3RzVHlwZTsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qKlxuICogRW5zdXJlcyB0aGF0IHRoZSBtb2RlbCBoYXMgYW4gb3duLXByb3BlcnR5IG1hcCBvZiBlZmZlY3RzIGZvciB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFRoZSBtb2RlbCBtYXkgYmUgYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuXG4gKlxuICogUHJvcGVydHkgZWZmZWN0cyBhcmUgc3RvcmVkIGFzIGFycmF5cyBvZiBlZmZlY3RzIGJ5IHByb3BlcnR5IGluIGEgbWFwLFxuICogYnkgbmFtZWQgdHlwZSBvbiB0aGUgbW9kZWwuIGUuZy5cbiAqXG4gKiAgIF9fY29tcHV0ZUVmZmVjdHM6IHtcbiAqICAgICBmb286IFsgLi4uIF0sXG4gKiAgICAgYmFyOiBbIC4uLiBdXG4gKiAgIH1cbiAqXG4gKiBJZiB0aGUgbW9kZWwgZG9lcyBub3QgeWV0IGhhdmUgYW4gZWZmZWN0IG1hcCBmb3IgdGhlIHR5cGUsIG9uZSBpcyBjcmVhdGVkXG4gKiBhbmQgcmV0dXJuZWQuICBJZiBpdCBkb2VzLCBidXQgaXQgaXMgbm90IGFuIG93biBwcm9wZXJ0eSAoaS5lLiB0aGVcbiAqIHByb3RvdHlwZSBoYWQgZWZmZWN0cyksIHRoZSB0aGUgbWFwIGlzIGRlZXBseSBjbG9uZWQgYW5kIHRoZSBjb3B5IGlzXG4gKiBzZXQgb24gdGhlIG1vZGVsIGFuZCByZXR1cm5lZCwgcmVhZHkgZm9yIG5ldyBlZmZlY3RzIHRvIGJlIGFkZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2RlbCBQcm90b3R5cGUgb3IgaW5zdGFuY2VcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIFByb3BlcnR5IGVmZmVjdCB0eXBlXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBvd24tcHJvcGVydHkgbWFwIG9mIGVmZmVjdHMgZm9yIHRoZSBnaXZlbiB0eXBlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnN1cmVPd25FZmZlY3RNYXAobW9kZWwsIHR5cGUpIHtcbiAgbGV0IGVmZmVjdHMgPSBtb2RlbFt0eXBlXTtcbiAgaWYgKCFlZmZlY3RzKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0ge307XG4gIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KHR5cGUpKSB7XG4gICAgZWZmZWN0cyA9IG1vZGVsW3R5cGVdID0gT2JqZWN0LmNyZWF0ZShtb2RlbFt0eXBlXSk7XG4gICAgZm9yIChsZXQgcCBpbiBlZmZlY3RzKSB7XG4gICAgICBsZXQgcHJvdG9GeCA9IGVmZmVjdHNbcF07XG4gICAgICBsZXQgaW5zdEZ4ID0gZWZmZWN0c1twXSA9IEFycmF5KHByb3RvRngubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxwcm90b0Z4Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGluc3RGeFtpXSA9IHByb3RvRnhbaV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBlZmZlY3RzO1xufVxuXG4vLyAtLSBlZmZlY3RzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBSdW5zIGFsbCBlZmZlY3RzIG9mIGEgZ2l2ZW4gdHlwZSBmb3IgdGhlIGdpdmVuIHNldCBvZiBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBvbiBhbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSB3aXRoIGVmZmVjdHMgdG8gcnVuXG4gKiBAcGFyYW0ge09iamVjdH0gZWZmZWN0cyBPYmplY3QgbWFwIG9mIHByb3BlcnR5LXRvLUFycmF5IG9mIGVmZmVjdHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdD19IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHtib29sZWFuPX0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwYXJhbSB7Kj19IGV4dHJhQXJncyBBZGRpdGlvbmFsIG1ldGFkYXRhIHRvIHBhc3MgdG8gZWZmZWN0IGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGFuIGVmZmVjdCByYW4gZm9yIHRoaXMgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkVmZmVjdHMoaW5zdCwgZWZmZWN0cywgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSB7XG4gIGlmIChlZmZlY3RzKSB7XG4gICAgbGV0IHJhbiA9IGZhbHNlO1xuICAgIGxldCBpZCA9IGRlZHVwZUlkKys7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgaWYgKHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBlZmZlY3RzLCBpZCwgcHJvcCwgcHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocywgZXh0cmFBcmdzKSkge1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmFuO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSdW5zIGEgbGlzdCBvZiBlZmZlY3RzIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdpdGggZWZmZWN0cyB0byBydW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBlZmZlY3RzIE9iamVjdCBtYXAgb2YgcHJvcGVydHktdG8tQXJyYXkgb2YgZWZmZWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGRlZHVwZUlkIENvdW50ZXIgdXNlZCBmb3IgZGUtZHVwaW5nIGVmZmVjdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIE5hbWUgb2YgY2hhbmdlZCBwcm9wZXJ0eVxuICogQHBhcmFtIHsqfSBwcm9wcyBDaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Kn0gb2xkUHJvcHMgT2xkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0geyo9fSBleHRyYUFyZ3MgQWRkaXRpb25hbCBtZXRhZGF0YSB0byBwYXNzIHRvIGVmZmVjdCBmdW5jdGlvblxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBhbiBlZmZlY3QgcmFuIGZvciB0aGlzIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5FZmZlY3RzRm9yUHJvcGVydHkoaW5zdCwgZWZmZWN0cywgZGVkdXBlSWQsIHByb3AsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMsIGV4dHJhQXJncykge1xuICBsZXQgcmFuID0gZmFsc2U7XG4gIGxldCByb290UHJvcGVydHkgPSBoYXNQYXRocyA/IHJvb3QkMChwcm9wKSA6IHByb3A7XG4gIGxldCBmeHMgPSBlZmZlY3RzW3Jvb3RQcm9wZXJ0eV07XG4gIGlmIChmeHMpIHtcbiAgICBmb3IgKGxldCBpPTAsIGw9ZnhzLmxlbmd0aCwgZng7IChpPGwpICYmIChmeD1meHNbaV0pOyBpKyspIHtcbiAgICAgIGlmICgoIWZ4LmluZm8gfHwgZnguaW5mby5sYXN0UnVuICE9PSBkZWR1cGVJZCkgJiZcbiAgICAgICAgICAoIWhhc1BhdGhzIHx8IHBhdGhNYXRjaGVzVHJpZ2dlcihwcm9wLCBmeC50cmlnZ2VyKSkpIHtcbiAgICAgICAgaWYgKGZ4LmluZm8pIHtcbiAgICAgICAgICBmeC5pbmZvLmxhc3RSdW4gPSBkZWR1cGVJZDtcbiAgICAgICAgfVxuICAgICAgICBmeC5mbihpbnN0LCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGZ4LmluZm8sIGhhc1BhdGhzLCBleHRyYUFyZ3MpO1xuICAgICAgICByYW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmFuO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHByb3BlcnR5L3BhdGggdGhhdCBoYXMgY2hhbmdlZCBtYXRjaGVzIHRoZSB0cmlnZ2VyXG4gKiBjcml0ZXJpYSBmb3IgYW4gZWZmZWN0LiAgQSB0cmlnZ2VyIGlzIGEgZGVzY3JpcHRvciB3aXRoIHRoZSBmb2xsb3dpbmdcbiAqIHN0cnVjdHVyZSwgd2hpY2ggbWF0Y2hlcyB0aGUgZGVzY3JpcHRvcnMgcmV0dXJuZWQgZnJvbSBgcGFyc2VBcmdgLlxuICogZS5nLiBmb3IgYGZvby5iYXIuKmA6XG4gKiBgYGBcbiAqIHRyaWdnZXI6IHtcbiAqICAgbmFtZTogJ2EuYicsXG4gKiAgIHN0cnVjdHVyZWQ6IHRydWUsXG4gKiAgIHdpbGRjYXJkOiB0cnVlXG4gKiB9XG4gKiBgYGBcbiAqIElmIG5vIHRyaWdnZXIgaXMgZ2l2ZW4sIHRoZSBwYXRoIGlzIGRlZW1lZCB0byBtYXRjaC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBQYXRoIG9yIHByb3BlcnR5IHRoYXQgY2hhbmdlZFxuICogQHBhcmFtIHtEYXRhVHJpZ2dlcn0gdHJpZ2dlciBEZXNjcmlwdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwYXRoIG1hdGNoZWQgdGhlIHRyaWdnZXJcbiAqL1xuZnVuY3Rpb24gcGF0aE1hdGNoZXNUcmlnZ2VyKHBhdGgsIHRyaWdnZXIpIHtcbiAgaWYgKHRyaWdnZXIpIHtcbiAgICBsZXQgdHJpZ2dlclBhdGggPSB0cmlnZ2VyLm5hbWU7XG4gICAgcmV0dXJuICh0cmlnZ2VyUGF0aCA9PSBwYXRoKSB8fFxuICAgICAgKHRyaWdnZXIuc3RydWN0dXJlZCAmJiBpc0FuY2VzdG9yKHRyaWdnZXJQYXRoLCBwYXRoKSkgfHxcbiAgICAgICh0cmlnZ2VyLndpbGRjYXJkICYmIGlzRGVzY2VuZGFudCh0cmlnZ2VyUGF0aCwgcGF0aCkpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJvYnNlcnZlclwiIGVmZmVjdC5cbiAqXG4gKiBDYWxscyB0aGUgbWV0aG9kIHdpdGggYGluZm8ubWV0aG9kTmFtZWAgb24gdGhlIGluc3RhbmNlLCBwYXNzaW5nIHRoZVxuICogbmV3IGFuZCBvbGQgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIHByb3BlcnR5XG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIGN1cnJlbnQgcHJvcGVydHkgY2hhbmdlc1xuICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHs/fSBpbmZvIEVmZmVjdCBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuT2JzZXJ2ZXJFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbykge1xuICBsZXQgZm4gPSBpbnN0W2luZm8ubWV0aG9kTmFtZV07XG4gIGxldCBjaGFuZ2VkUHJvcCA9IGluZm8ucHJvcGVydHk7XG4gIGlmIChmbikge1xuICAgIGZuLmNhbGwoaW5zdCwgaW5zdC5fX2RhdGFbY2hhbmdlZFByb3BdLCBvbGRQcm9wc1tjaGFuZ2VkUHJvcF0pO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2Fybignb2JzZXJ2ZXIgbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgfVxufVxuXG4vKipcbiAqIFJ1bnMgXCJub3RpZnlcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogd2lsbCBkaXNwYXRjaCBwYXRoIG5vdGlmaWNhdGlvbiBldmVudHMgaW4gdGhlIGNhc2UgdGhhdCB0aGUgcHJvcGVydHlcbiAqIGNoYW5nZWQgd2FzIGEgcGF0aCBhbmQgdGhlIHJvb3QgcHJvcGVydHkgZm9yIHRoYXQgcGF0aCBkaWRuJ3QgaGF2ZSBhXG4gKiBcIm5vdGlmeVwiIGVmZmVjdC4gIFRoaXMgaXMgdG8gbWFpbnRhaW4gMS4wIGJlaGF2aW9yIHRoYXQgZGlkIG5vdCByZXF1aXJlXG4gKiBgbm90aWZ5OiB0cnVlYCB0byBlbnN1cmUgb2JqZWN0IHN1Yi1wcm9wZXJ0eSBub3RpZmljYXRpb25zIHdlcmVcbiAqIHNlbnQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2Ugd2l0aCBlZmZlY3RzIHRvIHJ1blxuICogQHBhcmFtIHtPYmplY3R9IG5vdGlmeVByb3BzIEJhZyBvZiBwcm9wZXJ0aWVzIHRvIG5vdGlmeVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk5vdGlmeUVmZmVjdHMoaW5zdCwgbm90aWZ5UHJvcHMsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpIHtcbiAgLy8gTm90aWZ5XG4gIGxldCBmeHMgPSBpbnN0W1RZUEVTLk5PVElGWV07XG4gIGxldCBub3RpZmllZDtcbiAgbGV0IGlkID0gZGVkdXBlSWQrKztcbiAgLy8gVHJ5IG5vcm1hbCBub3RpZnkgZWZmZWN0czsgaWYgbm9uZSwgZmFsbCBiYWNrIHRvIHRyeSBwYXRoIG5vdGlmaWNhdGlvblxuICBmb3IgKGxldCBwcm9wIGluIG5vdGlmeVByb3BzKSB7XG4gICAgaWYgKG5vdGlmeVByb3BzW3Byb3BdKSB7XG4gICAgICBpZiAoZnhzICYmIHJ1bkVmZmVjdHNGb3JQcm9wZXJ0eShpbnN0LCBmeHMsIGlkLCBwcm9wLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgICBub3RpZmllZCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGhhc1BhdGhzICYmIG5vdGlmeVBhdGgoaW5zdCwgcHJvcCwgcHJvcHMpKSB7XG4gICAgICAgIG5vdGlmaWVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gRmx1c2ggaG9zdCBpZiB3ZSBhY3R1YWxseSBub3RpZmllZCBhbmQgaG9zdCB3YXMgYmF0Y2hpbmdcbiAgLy8gQW5kIHRoZSBob3N0IGhhcyBhbHJlYWR5IGluaXRpYWxpemVkIGNsaWVudHM7IHRoaXMgcHJldmVudHNcbiAgLy8gYW4gaXNzdWUgd2l0aCBhIGhvc3Qgb2JzZXJ2aW5nIGRhdGEgY2hhbmdlcyBiZWZvcmUgY2xpZW50cyBhcmUgcmVhZHkuXG4gIGxldCBob3N0O1xuICBpZiAobm90aWZpZWQgJiYgKGhvc3QgPSBpbnN0Ll9fZGF0YUhvc3QpICYmIGhvc3QuX2ludmFsaWRhdGVQcm9wZXJ0aWVzKSB7XG4gICAgaG9zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoZXMge3Byb3BlcnR5fS1jaGFuZ2VkIGV2ZW50cyB3aXRoIHBhdGggaW5mb3JtYXRpb24gaW4gdGhlIGRldGFpbFxuICogb2JqZWN0IHRvIGluZGljYXRlIGEgc3ViLXBhdGggb2YgdGhlIHByb3BlcnR5IHdhcyBjaGFuZ2VkLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGVsZW1lbnQgZnJvbSB3aGljaCB0byBmaXJlIHRoZSBldmVudFxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGggVGhlIHBhdGggdGhhdCB3YXMgY2hhbmdlZFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0aCB3YXMgbm90aWZpZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVBhdGgoaW5zdCwgcGF0aCwgcHJvcHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IHJvb3QkMChwYXRoKTtcbiAgaWYgKHJvb3RQcm9wZXJ0eSAhPT0gcGF0aCkge1xuICAgIGxldCBldmVudE5hbWUgPSBjYW1lbFRvRGFzaENhc2UkMChyb290UHJvcGVydHkpICsgJy1jaGFuZ2VkJztcbiAgICBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgcHJvcHNbcGF0aF0sIHBhdGgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIHtwcm9wZXJ0eX0tY2hhbmdlZCBldmVudHMgdG8gaW5kaWNhdGUgYSBwcm9wZXJ0eSAob3IgcGF0aClcbiAqIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgZWxlbWVudCBmcm9tIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIFRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBzZW5kICgne3Byb3BlcnR5fS1jaGFuZ2VkJylcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBjaGFuZ2VkIHByb3BlcnR5XG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bGwgfCB1bmRlZmluZWR9IHBhdGggSWYgYSBzdWItcGF0aCBvZiB0aGlzIHByb3BlcnR5IGNoYW5nZWQsIHRoZSBwYXRoXG4gKiAgIHRoYXQgY2hhbmdlZCAob3B0aW9uYWwpLlxuICogQHByaXZhdGVcbiAqIEBzdXBwcmVzcyB7aW52YWxpZENhc3RzfVxuICovXG5mdW5jdGlvbiBkaXNwYXRjaE5vdGlmeUV2ZW50KGluc3QsIGV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpIHtcbiAgbGV0IGRldGFpbCA9IHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgcXVldWVQcm9wZXJ0eTogdHJ1ZVxuICB9O1xuICBpZiAocGF0aCkge1xuICAgIGRldGFpbC5wYXRoID0gcGF0aDtcbiAgfVxuICAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oaW5zdCkuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7IGRldGFpbCB9KSk7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJub3RpZnlcIiBlZmZlY3QuXG4gKlxuICogRGlzcGF0Y2hlcyBhIG5vbi1idWJibGluZyBldmVudCBuYW1lZCBgaW5mby5ldmVudE5hbWVgIG9uIHRoZSBpbnN0YW5jZVxuICogd2l0aCBhIGRldGFpbCBvYmplY3QgY29udGFpbmluZyB0aGUgbmV3IGB2YWx1ZWAuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Ob3RpZnlFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbywgaGFzUGF0aHMpIHtcbiAgbGV0IHJvb3RQcm9wZXJ0eSA9IGhhc1BhdGhzID8gcm9vdCQwKHByb3BlcnR5KSA6IHByb3BlcnR5O1xuICBsZXQgcGF0aCA9IHJvb3RQcm9wZXJ0eSAhPSBwcm9wZXJ0eSA/IHByb3BlcnR5IDogbnVsbDtcbiAgbGV0IHZhbHVlID0gcGF0aCA/IGdldCQwKGluc3QsIHBhdGgpIDogaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAocGF0aCAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdmFsdWUgPSBwcm9wc1twcm9wZXJ0eV07ICAvLyBzcGVjaWZpY2FsbHkgZm9yIC5zcGxpY2VzXG4gIH1cbiAgZGlzcGF0Y2hOb3RpZnlFdmVudChpbnN0LCBpbmZvLmV2ZW50TmFtZSwgdmFsdWUsIHBhdGgpO1xufVxuXG4vKipcbiAqIEhhbmRsZXIgZnVuY3Rpb24gZm9yIDItd2F5IG5vdGlmaWNhdGlvbiBldmVudHMuIFJlY2VpdmVzIGNvbnRleHRcbiAqIGluZm9ybWF0aW9uIGNhcHR1cmVkIGluIHRoZSBgYWRkTm90aWZ5TGlzdGVuZXJgIGNsb3N1cmUgZnJvbSB0aGVcbiAqIGBfX25vdGlmeUxpc3RlbmVyc2AgbWV0YWRhdGEuXG4gKlxuICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIG5vdGlmaWVkIHByb3BlcnR5IHRvIHRoZSBob3N0IHByb3BlcnR5IG9yIHBhdGguICBJZlxuICogdGhlIGV2ZW50IGNvbnRhaW5lZCBwYXRoIGluZm9ybWF0aW9uLCB0cmFuc2xhdGUgdGhhdCBwYXRoIHRvIHRoZSBob3N0XG4gKiBzY29wZSdzIG5hbWUgZm9yIHRoYXQgcGF0aCBmaXJzdC5cbiAqXG4gKiBAcGFyYW0ge0N1c3RvbUV2ZW50fSBldmVudCBOb3RpZmljYXRpb24gZXZlbnQgKGUuZy4gJzxwcm9wZXJ0eT4tY2hhbmdlZCcpXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSBoYW5kbGluZyB0aGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge3N0cmluZ30gZnJvbVByb3AgQ2hpbGQgZWxlbWVudCBwcm9wZXJ0eSB0aGF0IHdhcyBib3VuZFxuICogQHBhcmFtIHtzdHJpbmd9IHRvUGF0aCBIb3N0IHByb3BlcnR5L3BhdGggdGhhdCB3YXMgYm91bmRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbmVnYXRlIFdoZXRoZXIgdGhlIGJpbmRpbmcgd2FzIG5lZ2F0ZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5vdGlmaWNhdGlvbihldmVudCwgaW5zdCwgZnJvbVByb3AsIHRvUGF0aCwgbmVnYXRlKSB7XG4gIGxldCB2YWx1ZTtcbiAgbGV0IGRldGFpbCA9IC8qKiBAdHlwZSB7T2JqZWN0fSAqLyhldmVudC5kZXRhaWwpO1xuICBsZXQgZnJvbVBhdGggPSBkZXRhaWwgJiYgZGV0YWlsLnBhdGg7XG4gIGlmIChmcm9tUGF0aCkge1xuICAgIHRvUGF0aCA9IHRyYW5zbGF0ZShmcm9tUHJvcCwgdG9QYXRoLCBmcm9tUGF0aCk7XG4gICAgdmFsdWUgPSBkZXRhaWwgJiYgZGV0YWlsLnZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gZXZlbnQudGFyZ2V0W2Zyb21Qcm9wXTtcbiAgfVxuICB2YWx1ZSA9IG5lZ2F0ZSA/ICF2YWx1ZSA6IHZhbHVlO1xuICBpZiAoIWluc3RbVFlQRVMuUkVBRF9PTkxZXSB8fCAhaW5zdFtUWVBFUy5SRUFEX09OTFldW3RvUGF0aF0pIHtcbiAgICBpZiAoaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHRvUGF0aCwgdmFsdWUsIHRydWUsIEJvb2xlYW4oZnJvbVBhdGgpKVxuICAgICAgJiYgKCFkZXRhaWwgfHwgIWRldGFpbC5xdWV1ZVByb3BlcnR5KSkge1xuICAgICAgaW5zdC5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcInJlZmxlY3RcIiBlZmZlY3QuXG4gKlxuICogU2V0cyB0aGUgYXR0cmlidXRlIG5hbWVkIGBpbmZvLmF0dHJOYW1lYCB0byB0aGUgZ2l2ZW4gcHJvcGVydHkgdmFsdWUuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5SZWZsZWN0RWZmZWN0KGluc3QsIHByb3BlcnR5LCBwcm9wcywgb2xkUHJvcHMsIGluZm8pIHtcbiAgbGV0IHZhbHVlID0gaW5zdC5fX2RhdGFbcHJvcGVydHldO1xuICBpZiAoc2FuaXRpemVET01WYWx1ZSkge1xuICAgIHZhbHVlID0gc2FuaXRpemVET01WYWx1ZSh2YWx1ZSwgaW5mby5hdHRyTmFtZSwgJ2F0dHJpYnV0ZScsIC8qKiBAdHlwZSB7Tm9kZX0gKi8oaW5zdCkpO1xuICB9XG4gIGluc3QuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGluZm8uYXR0ck5hbWUsIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBSdW5zIFwiY29tcHV0ZWRcIiBlZmZlY3RzIGZvciBhIHNldCBvZiBjaGFuZ2VkIHByb3BlcnRpZXMuXG4gKlxuICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIHRoZSBnZW5lcmljIGBydW5FZmZlY3RzYCBtZXRob2QgaW4gdGhhdCBpdFxuICogY29udGludWVzIHRvIHJ1biBjb21wdXRlZCBlZmZlY3RzIGJhc2VkIG9uIHRoZSBvdXRwdXQgb2YgZWFjaCBwYXNzIHVudGlsXG4gKiB0aGVyZSBhcmUgbm8gbW9yZSBuZXdseSBjb21wdXRlZCBwcm9wZXJ0aWVzLiAgVGhpcyBlbnN1cmVzIHRoYXQgYWxsXG4gKiBwcm9wZXJ0aWVzIHRoYXQgd2lsbCBiZSBjb21wdXRlZCBieSB0aGUgaW5pdGlhbCBzZXQgb2YgY2hhbmdlcyBhcmVcbiAqIGNvbXB1dGVkIGJlZm9yZSBvdGhlciBlZmZlY3RzIChiaW5kaW5nIHByb3BhZ2F0aW9uLCBvYnNlcnZlcnMsIGFuZCBub3RpZnkpXG4gKiBydW4uXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIGNoYW5nZWQgcHJvcGVydGllc1xuICogQHBhcmFtIHshT2JqZWN0fSBvbGRQcm9wcyBCYWcgb2YgcHJldmlvdXMgdmFsdWVzIGZvciBjaGFuZ2VkIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bkNvbXB1dGVkRWZmZWN0cyhpbnN0LCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICBsZXQgY29tcHV0ZUVmZmVjdHMgPSBpbnN0W1RZUEVTLkNPTVBVVEVdO1xuICBpZiAoY29tcHV0ZUVmZmVjdHMpIHtcbiAgICBsZXQgaW5wdXRQcm9wcyA9IGNoYW5nZWRQcm9wcztcbiAgICB3aGlsZSAocnVuRWZmZWN0cyhpbnN0LCBjb21wdXRlRWZmZWN0cywgaW5wdXRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSkge1xuICAgICAgT2JqZWN0LmFzc2lnbihvbGRQcm9wcywgaW5zdC5fX2RhdGFPbGQpO1xuICAgICAgT2JqZWN0LmFzc2lnbihjaGFuZ2VkUHJvcHMsIGluc3QuX19kYXRhUGVuZGluZyk7XG4gICAgICBpbnB1dFByb3BzID0gaW5zdC5fX2RhdGFQZW5kaW5nO1xuICAgICAgaW5zdC5fX2RhdGFQZW5kaW5nID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBcImNvbXB1dGVkIHByb3BlcnR5XCIgZWZmZWN0IGJ5IHJ1bm5pbmcgdGhlIG1ldGhvZCB3aXRoIHRoZVxuICogdmFsdWVzIG9mIHRoZSBhcmd1bWVudHMgc3BlY2lmaWVkIGluIHRoZSBgaW5mb2Agb2JqZWN0IGFuZCBzZXR0aW5nIHRoZVxuICogcmV0dXJuIHZhbHVlIHRvIHRoZSBjb21wdXRlZCBwcm9wZXJ0eSBzcGVjaWZpZWQuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBydW5Db21wdXRlZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIGxldCByZXN1bHQgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcHJvcGVydHksIHByb3BzLCBvbGRQcm9wcywgaW5mbyk7XG4gIGxldCBjb21wdXRlZFByb3AgPSBpbmZvLm1ldGhvZEluZm87XG4gIGlmIChpbnN0Ll9fZGF0YUhhc0FjY2Vzc29yICYmIGluc3QuX19kYXRhSGFzQWNjZXNzb3JbY29tcHV0ZWRQcm9wXSkge1xuICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eShjb21wdXRlZFByb3AsIHJlc3VsdCwgdHJ1ZSk7XG4gIH0gZWxzZSB7XG4gICAgaW5zdFtjb21wdXRlZFByb3BdID0gcmVzdWx0O1xuICB9XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgcGF0aCBjaGFuZ2VzIGJhc2VkIG9uIHBhdGggbGlua3Mgc2V0IHVwIHVzaW5nIHRoZSBgbGlua1BhdGhzYFxuICogQVBJLlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHdob3NlIHByb3BzIGFyZSBjaGFuZ2luZ1xuICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8KHN0cmluZ3xudW1iZXIpPn0gcGF0aCBQYXRoIHRoYXQgaGFzIGNoYW5nZWRcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgb2YgY2hhbmdlZCBwYXRoXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb21wdXRlTGlua2VkUGF0aHMoaW5zdCwgcGF0aCwgdmFsdWUpIHtcbiAgbGV0IGxpbmtzID0gaW5zdC5fX2RhdGFMaW5rZWRQYXRocztcbiAgaWYgKGxpbmtzKSB7XG4gICAgbGV0IGxpbms7XG4gICAgZm9yIChsZXQgYSBpbiBsaW5rcykge1xuICAgICAgbGV0IGIgPSBsaW5rc1thXTtcbiAgICAgIGlmIChpc0Rlc2NlbmRhbnQoYSwgcGF0aCkpIHtcbiAgICAgICAgbGluayA9IHRyYW5zbGF0ZShhLCBiLCBwYXRoKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKGxpbmssIHZhbHVlLCB0cnVlLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZXNjZW5kYW50KGIsIHBhdGgpKSB7XG4gICAgICAgIGxpbmsgPSB0cmFuc2xhdGUoYiwgYSwgcGF0aCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChsaW5rLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIC0tIGJpbmRpbmdzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuLyoqXG4gKiBBZGRzIGJpbmRpbmcgbWV0YWRhdGEgdG8gdGhlIGN1cnJlbnQgYG5vZGVJbmZvYCwgYW5kIGJpbmRpbmcgZWZmZWN0c1xuICogZm9yIGFsbCBwYXJ0IGRlcGVuZGVuY2llcyB0byBgdGVtcGxhdGVJbmZvYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb25zdHJ1Y3RvciBDbGFzcyB0aGF0IGBfcGFyc2VUZW1wbGF0ZWAgaXMgY3VycmVudGx5XG4gKiAgIHJ1bm5pbmcgb25cbiAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUgbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IGtpbmQgQmluZGluZyBraW5kLCBlaXRoZXIgJ3Byb3BlcnR5JywgJ2F0dHJpYnV0ZScsIG9yICd0ZXh0J1xuICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldCBUYXJnZXQgcHJvcGVydHkgbmFtZVxuICogQHBhcmFtIHshQXJyYXk8IUJpbmRpbmdQYXJ0Pn0gcGFydHMgQXJyYXkgb2YgYmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZz19IGxpdGVyYWwgTGl0ZXJhbCB0ZXh0IHN1cnJvdW5kaW5nIGJpbmRpbmcgcGFydHMgKHNwZWNpZmllZFxuICogICBvbmx5IGZvciAncHJvcGVydHknIGJpbmRpbmdzLCBzaW5jZSB0aGVzZSBtdXN0IGJlIGluaXRpYWxpemVkIGFzIHBhcnRcbiAqICAgb2YgYm9vdC11cClcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZEJpbmRpbmcoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIHRhcmdldCwgcGFydHMsIGxpdGVyYWwpIHtcbiAgLy8gQ3JlYXRlIGJpbmRpbmcgbWV0YWRhdGEgYW5kIGFkZCB0byBub2RlSW5mb1xuICBub2RlSW5mby5iaW5kaW5ncyA9IG5vZGVJbmZvLmJpbmRpbmdzIHx8IFtdO1xuICBsZXQgLyoqIEJpbmRpbmcgKi8gYmluZGluZyA9IHsga2luZCwgdGFyZ2V0LCBwYXJ0cywgbGl0ZXJhbCwgaXNDb21wb3VuZDogKHBhcnRzLmxlbmd0aCAhPT0gMSkgfTtcbiAgbm9kZUluZm8uYmluZGluZ3MucHVzaChiaW5kaW5nKTtcbiAgLy8gQWRkIGxpc3RlbmVyIGluZm8gdG8gYmluZGluZyBtZXRhZGF0YVxuICBpZiAoc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykpIHtcbiAgICBsZXQge2V2ZW50LCBuZWdhdGV9ID0gYmluZGluZy5wYXJ0c1swXTtcbiAgICBiaW5kaW5nLmxpc3RlbmVyRXZlbnQgPSBldmVudCB8fCAoQ2FzZU1hcC5jYW1lbFRvRGFzaENhc2UodGFyZ2V0KSArICctY2hhbmdlZCcpO1xuICAgIGJpbmRpbmcubGlzdGVuZXJOZWdhdGUgPSBuZWdhdGU7XG4gIH1cbiAgLy8gQWRkIFwicHJvcGFnYXRlXCIgcHJvcGVydHkgZWZmZWN0cyB0byB0ZW1wbGF0ZUluZm9cbiAgbGV0IGluZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5sZW5ndGg7XG4gIGZvciAobGV0IGk9MDsgaTxiaW5kaW5nLnBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzW2ldO1xuICAgIHBhcnQuY29tcG91bmRJbmRleCA9IGk7XG4gICAgYWRkRWZmZWN0Rm9yQmluZGluZ1BhcnQoY29uc3RydWN0b3IsIHRlbXBsYXRlSW5mbywgYmluZGluZywgcGFydCwgaW5kZXgpO1xuICB9XG59XG5cbi8qKlxuICogQWRkcyBwcm9wZXJ0eSBlZmZlY3RzIHRvIHRoZSBnaXZlbiBgdGVtcGxhdGVJbmZvYCBmb3IgdGhlIGdpdmVuIGJpbmRpbmdcbiAqIHBhcnQuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29uc3RydWN0b3IgQ2xhc3MgdGhhdCBgX3BhcnNlVGVtcGxhdGVgIGlzIGN1cnJlbnRseVxuICogICBydW5uaW5nIG9uXG4gKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gKiBAcGFyYW0geyFCaW5kaW5nfSBiaW5kaW5nIEJpbmRpbmcgbWV0YWRhdGFcbiAqIEBwYXJhbSB7IUJpbmRpbmdQYXJ0fSBwYXJ0IEJpbmRpbmcgcGFydCBtZXRhZGF0YVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGludG8gYG5vZGVJbmZvTGlzdGAgZm9yIHRoaXMgbm9kZVxuICovXG5mdW5jdGlvbiBhZGRFZmZlY3RGb3JCaW5kaW5nUGFydChjb25zdHJ1Y3RvciwgdGVtcGxhdGVJbmZvLCBiaW5kaW5nLCBwYXJ0LCBpbmRleCkge1xuICBpZiAoIXBhcnQubGl0ZXJhbCkge1xuICAgIGlmIChiaW5kaW5nLmtpbmQgPT09ICdhdHRyaWJ1dGUnICYmIGJpbmRpbmcudGFyZ2V0WzBdID09PSAnLScpIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHNldCBhdHRyaWJ1dGUgJyArIGJpbmRpbmcudGFyZ2V0ICtcbiAgICAgICAgJyBiZWNhdXNlIFwiLVwiIGlzIG5vdCBhIHZhbGlkIGF0dHJpYnV0ZSBzdGFydGluZyBjaGFyYWN0ZXInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRlcGVuZGVuY2llcyA9IHBhcnQuZGVwZW5kZW5jaWVzO1xuICAgICAgbGV0IGluZm8gPSB7IGluZGV4LCBiaW5kaW5nLCBwYXJ0LCBldmFsdWF0b3I6IGNvbnN0cnVjdG9yIH07XG4gICAgICBmb3IgKGxldCBqPTA7IGo8ZGVwZW5kZW5jaWVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGxldCB0cmlnZ2VyID0gZGVwZW5kZW5jaWVzW2pdO1xuICAgICAgICBpZiAodHlwZW9mIHRyaWdnZXIgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0cmlnZ2VyID0gcGFyc2VBcmcodHJpZ2dlcik7XG4gICAgICAgICAgdHJpZ2dlci53aWxkY2FyZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IuX2FkZFRlbXBsYXRlUHJvcGVydHlFZmZlY3QodGVtcGxhdGVJbmZvLCB0cmlnZ2VyLnJvb3RQcm9wZXJ0eSwge1xuICAgICAgICAgIGZuOiBydW5CaW5kaW5nRWZmZWN0LFxuICAgICAgICAgIGluZm8sIHRyaWdnZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyB0aGUgXCJiaW5kaW5nXCIgKHByb3BlcnR5L3BhdGggYmluZGluZykgZWZmZWN0LlxuICpcbiAqIE5vdGUgdGhhdCBiaW5kaW5nIHN5bnRheCBpcyBvdmVycmlkYWJsZSB2aWEgYF9wYXJzZUJpbmRpbmdzYCBhbmRcbiAqIGBfZXZhbHVhdGVCaW5kaW5nYC4gIFRoaXMgbWV0aG9kIHdpbGwgY2FsbCBgX2V2YWx1YXRlQmluZGluZ2AgZm9yIGFueVxuICogbm9uLWxpdGVyYWwgcGFydHMgcmV0dXJuZWQgZnJvbSBgX3BhcnNlQmluZGluZ3NgLiAgSG93ZXZlcixcbiAqIHRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIF9wYXRoXyBiaW5kaW5ncyB2aWEgY3VzdG9tIGJpbmRpbmcgcGFydHMsXG4gKiBhcyB0aGlzIGlzIHNwZWNpZmljIHRvIFBvbHltZXIncyBwYXRoIGJpbmRpbmcgc3ludGF4LlxuICpcbiAqIEBwYXJhbSB7IVByb3BlcnR5RWZmZWN0c1R5cGV9IGluc3QgVGhlIGluc3RhbmNlIHRoZSBlZmZlY3Qgd2lsbCBiZSBydW4gb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhhc1BhdGhzIFRydWUgd2l0aCBgcHJvcHNgIGNvbnRhaW5zIG9uZSBvciBtb3JlIHBhdGhzXG4gKiBAcGFyYW0ge0FycmF5fSBub2RlTGlzdCBMaXN0IG9mIG5vZGVzIGFzc29jaWF0ZWQgd2l0aCBgbm9kZUluZm9MaXN0YCB0ZW1wbGF0ZVxuICogICBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcnVuQmluZGluZ0VmZmVjdChpbnN0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGluZm8sIGhhc1BhdGhzLCBub2RlTGlzdCkge1xuICBsZXQgbm9kZSA9IG5vZGVMaXN0W2luZm8uaW5kZXhdO1xuICBsZXQgYmluZGluZyA9IGluZm8uYmluZGluZztcbiAgbGV0IHBhcnQgPSBpbmZvLnBhcnQ7XG4gIC8vIFN1YnBhdGggbm90aWZpY2F0aW9uOiB0cmFuc2Zvcm0gcGF0aCBhbmQgc2V0IHRvIGNsaWVudFxuICAvLyBlLmcuOiBmb289XCJ7e29iai5zdWJ9fVwiLCBwYXRoOiAnb2JqLnN1Yi5wcm9wJywgc2V0ICdmb28ucHJvcCc9b2JqLnN1Yi5wcm9wXG4gIGlmIChoYXNQYXRocyAmJiBwYXJ0LnNvdXJjZSAmJiAocGF0aC5sZW5ndGggPiBwYXJ0LnNvdXJjZS5sZW5ndGgpICYmXG4gICAgICAoYmluZGluZy5raW5kID09ICdwcm9wZXJ0eScpICYmICFiaW5kaW5nLmlzQ29tcG91bmQgJiZcbiAgICAgIG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3NvcltiaW5kaW5nLnRhcmdldF0pIHtcbiAgICBsZXQgdmFsdWUgPSBwcm9wc1twYXRoXTtcbiAgICBwYXRoID0gdHJhbnNsYXRlKHBhcnQuc291cmNlLCBiaW5kaW5nLnRhcmdldCwgcGF0aCk7XG4gICAgaWYgKG5vZGUuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwYXRoLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICBpbnN0Ll9lbnF1ZXVlQ2xpZW50KG5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgdmFsdWUgPSBpbmZvLmV2YWx1YXRvci5fZXZhbHVhdGVCaW5kaW5nKGluc3QsIHBhcnQsIHBhdGgsIHByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgIC8vIFByb3BhZ2F0ZSB2YWx1ZSB0byBjaGlsZFxuICAgIGFwcGx5QmluZGluZ1ZhbHVlKGluc3QsIG5vZGUsIGJpbmRpbmcsIHBhcnQsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhbiBcImJpbmRpbmdcIiAoYmluZGluZykgZWZmZWN0IHRvIGEgbm9kZSxcbiAqIGVpdGhlciBhcyBhIHByb3BlcnR5IG9yIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IFRoZSBpbnN0YW5jZSBvd25pbmcgdGhlIGJpbmRpbmcgZWZmZWN0XG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgVGFyZ2V0IG5vZGUgZm9yIGJpbmRpbmdcbiAqIEBwYXJhbSB7IUJpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHBhcmFtIHshQmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYXBwbHlCaW5kaW5nVmFsdWUoaW5zdCwgbm9kZSwgYmluZGluZywgcGFydCwgdmFsdWUpIHtcbiAgdmFsdWUgPSBjb21wdXRlQmluZGluZ1ZhbHVlKG5vZGUsIHZhbHVlLCBiaW5kaW5nLCBwYXJ0KTtcbiAgaWYgKHNhbml0aXplRE9NVmFsdWUpIHtcbiAgICB2YWx1ZSA9IHNhbml0aXplRE9NVmFsdWUodmFsdWUsIGJpbmRpbmcudGFyZ2V0LCBiaW5kaW5nLmtpbmQsIG5vZGUpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAvLyBBdHRyaWJ1dGUgYmluZGluZ1xuICAgIGluc3QuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8obm9kZSksIHZhbHVlLCBiaW5kaW5nLnRhcmdldCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gUHJvcGVydHkgYmluZGluZ1xuICAgIGxldCBwcm9wID0gYmluZGluZy50YXJnZXQ7XG4gICAgaWYgKG5vZGUuX19kYXRhSGFzQWNjZXNzb3IgJiYgbm9kZS5fX2RhdGFIYXNBY2Nlc3Nvcltwcm9wXSkge1xuICAgICAgaWYgKCFub2RlW1RZUEVTLlJFQURfT05MWV0gfHwgIW5vZGVbVFlQRVMuUkVBRF9PTkxZXVtwcm9wXSkge1xuICAgICAgICBpZiAobm9kZS5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3AsIHZhbHVlKSkge1xuICAgICAgICAgIGluc3QuX2VucXVldWVDbGllbnQobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgIHtcbiAgICAgIGluc3QuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm1zIGFuIFwiYmluZGluZ1wiIGVmZmVjdCB2YWx1ZSBiYXNlZCBvbiBjb21wb3VuZCAmIG5lZ2F0aW9uXG4gKiBlZmZlY3QgbWV0YWRhdGEsIGFzIHdlbGwgYXMgaGFuZGxpbmcgZm9yIHNwZWNpYWwtY2FzZSBwcm9wZXJ0aWVzXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhlIHZhbHVlIHdpbGwgYmUgc2V0IHRvXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcGFyYW0geyFCaW5kaW5nUGFydH0gcGFydCBCaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAqIEByZXR1cm4geyp9IFRyYW5zZm9ybWVkIHZhbHVlIHRvIHNldFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZUJpbmRpbmdWYWx1ZShub2RlLCB2YWx1ZSwgYmluZGluZywgcGFydCkge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZVtiaW5kaW5nLnRhcmdldF07XG4gICAgc3RvcmFnZVtwYXJ0LmNvbXBvdW5kSW5kZXhdID0gdmFsdWU7XG4gICAgdmFsdWUgPSBzdG9yYWdlLmpvaW4oJycpO1xuICB9XG4gIGlmIChiaW5kaW5nLmtpbmQgIT09ICdhdHRyaWJ1dGUnKSB7XG4gICAgLy8gU29tZSBicm93c2VycyBzZXJpYWxpemUgYHVuZGVmaW5lZGAgdG8gYFwidW5kZWZpbmVkXCJgXG4gICAgaWYgKGJpbmRpbmcudGFyZ2V0ID09PSAndGV4dENvbnRlbnQnIHx8XG4gICAgICAgIChub2RlLmxvY2FsTmFtZSA9PSAnaW5wdXQnICYmIGJpbmRpbmcudGFyZ2V0ID09ICd2YWx1ZScpKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlID09IHVuZGVmaW5lZCA/ICcnIDogdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBiaW5kaW5nJ3MgbWV0YWRhdGEgbWVldHMgYWxsIHRoZSByZXF1aXJlbWVudHMgdG8gYWxsb3dcbiAqIDItd2F5IGJpbmRpbmcsIGFuZCB0aGVyZWZvcmUgYSBgPHByb3BlcnR5Pi1jaGFuZ2VkYCBldmVudCBsaXN0ZW5lciBzaG91bGQgYmVcbiAqIGFkZGVkOlxuICogLSB1c2VkIGN1cmx5IGJyYWNlc1xuICogLSBpcyBhIHByb3BlcnR5IChub3QgYXR0cmlidXRlKSBiaW5kaW5nXG4gKiAtIGlzIG5vdCBhIHRleHRDb250ZW50IGJpbmRpbmdcbiAqIC0gaXMgbm90IGNvbXBvdW5kXG4gKlxuICogQHBhcmFtIHshQmluZGluZ30gYmluZGluZyBCaW5kaW5nIG1ldGFkYXRhXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIDItd2F5IGxpc3RlbmVyIHNob3VsZCBiZSBhZGRlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2hvdWxkQWRkTGlzdGVuZXIoYmluZGluZykge1xuICByZXR1cm4gQm9vbGVhbihiaW5kaW5nLnRhcmdldCkgJiZcbiAgICAgICAgIGJpbmRpbmcua2luZCAhPSAnYXR0cmlidXRlJyAmJlxuICAgICAgICAgYmluZGluZy5raW5kICE9ICd0ZXh0JyAmJlxuICAgICAgICAgIWJpbmRpbmcuaXNDb21wb3VuZCAmJlxuICAgICAgICAgYmluZGluZy5wYXJ0c1swXS5tb2RlID09PSAneyc7XG59XG5cbi8qKlxuICogU2V0dXAgY29tcG91bmQgYmluZGluZyBzdG9yYWdlIHN0cnVjdHVyZXMsIG5vdGlmeSBsaXN0ZW5lcnMsIGFuZCBkYXRhSG9zdFxuICogcmVmZXJlbmNlcyBvbnRvIHRoZSBib3VuZCBub2RlTGlzdC5cbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRoYXQgYmFzIGJlZW4gcHJldmlvdXNseSBib3VuZFxuICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBCaW5kaW5ncyhpbnN0LCB0ZW1wbGF0ZUluZm8pIHtcbiAgLy8gU2V0dXAgY29tcG91bmQgc3RvcmFnZSwgZGF0YUhvc3QsIGFuZCBub3RpZnkgbGlzdGVuZXJzXG4gIGxldCB7bm9kZUxpc3QsIG5vZGVJbmZvTGlzdH0gPSB0ZW1wbGF0ZUluZm87XG4gIGlmIChub2RlSW5mb0xpc3QubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUluZm9MaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaW5mbyA9IG5vZGVJbmZvTGlzdFtpXTtcbiAgICAgIGxldCBub2RlID0gbm9kZUxpc3RbaV07XG4gICAgICBsZXQgYmluZGluZ3MgPSBpbmZvLmJpbmRpbmdzO1xuICAgICAgaWYgKGJpbmRpbmdzKSB7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaTxiaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGxldCBiaW5kaW5nID0gYmluZGluZ3NbaV07XG4gICAgICAgICAgc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZyk7XG4gICAgICAgICAgYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuX19kYXRhSG9zdCA9IGluc3Q7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgYF9fZGF0YUNvbXBvdW5kU3RvcmFnZWAgbG9jYWwgc3RvcmFnZSBvbiBhIGJvdW5kIG5vZGUgd2l0aFxuICogaW5pdGlhbCBsaXRlcmFsIGRhdGEgZm9yIGNvbXBvdW5kIGJpbmRpbmdzLCBhbmQgc2V0cyB0aGUgam9pbmVkXG4gKiBsaXRlcmFsIHBhcnRzIHRvIHRoZSBib3VuZCBwcm9wZXJ0eS5cbiAqXG4gKiBXaGVuIGNoYW5nZXMgdG8gY29tcG91bmQgcGFydHMgb2NjdXIsIHRoZXkgYXJlIGZpcnN0IHNldCBpbnRvIHRoZSBjb21wb3VuZFxuICogc3RvcmFnZSBhcnJheSBmb3IgdGhhdCBwcm9wZXJ0eSwgYW5kIHRoZW4gdGhlIGFycmF5IGlzIGpvaW5lZCB0byByZXN1bHQgaW5cbiAqIHRoZSBmaW5hbCB2YWx1ZSBzZXQgdG8gdGhlIHByb3BlcnR5L2F0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgQm91bmQgbm9kZSB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBDb21wb3VuZFN0b3JhZ2Uobm9kZSwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5pc0NvbXBvdW5kKSB7XG4gICAgLy8gQ3JlYXRlIGNvbXBvdW5kIHN0b3JhZ2UgbWFwXG4gICAgbGV0IHN0b3JhZ2UgPSBub2RlLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fFxuICAgICAgKG5vZGUuX19kYXRhQ29tcG91bmRTdG9yYWdlID0ge30pO1xuICAgIGxldCBwYXJ0cyA9IGJpbmRpbmcucGFydHM7XG4gICAgLy8gQ29weSBsaXRlcmFscyBmcm9tIHBhcnRzIGludG8gc3RvcmFnZSBmb3IgdGhpcyBiaW5kaW5nXG4gICAgbGV0IGxpdGVyYWxzID0gbmV3IEFycmF5KHBhcnRzLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaj0wOyBqPHBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICBsaXRlcmFsc1tqXSA9IHBhcnRzW2pdLmxpdGVyYWw7XG4gICAgfVxuICAgIGxldCB0YXJnZXQgPSBiaW5kaW5nLnRhcmdldDtcbiAgICBzdG9yYWdlW3RhcmdldF0gPSBsaXRlcmFscztcbiAgICAvLyBDb25maWd1cmUgcHJvcGVydGllcyB3aXRoIHRoZWlyIGxpdGVyYWwgcGFydHNcbiAgICBpZiAoYmluZGluZy5saXRlcmFsICYmIGJpbmRpbmcua2luZCA9PSAncHJvcGVydHknKSB7XG4gICAgICBub2RlW3RhcmdldF0gPSBiaW5kaW5nLmxpdGVyYWw7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkcyBhIDItd2F5IGJpbmRpbmcgbm90aWZpY2F0aW9uIGV2ZW50IGxpc3RlbmVyIHRvIHRoZSBub2RlIHNwZWNpZmllZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBub2RlIENoaWxkIGVsZW1lbnQgdG8gYWRkIGxpc3RlbmVyIHRvXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEhvc3QgZWxlbWVudCBpbnN0YW5jZSB0byBoYW5kbGUgbm90aWZpY2F0aW9uIGV2ZW50XG4gKiBAcGFyYW0ge0JpbmRpbmd9IGJpbmRpbmcgQmluZGluZyBtZXRhZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTm90aWZ5TGlzdGVuZXIobm9kZSwgaW5zdCwgYmluZGluZykge1xuICBpZiAoYmluZGluZy5saXN0ZW5lckV2ZW50KSB7XG4gICAgbGV0IHBhcnQgPSBiaW5kaW5nLnBhcnRzWzBdO1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihiaW5kaW5nLmxpc3RlbmVyRXZlbnQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGhhbmRsZU5vdGlmaWNhdGlvbihlLCBpbnN0LCBiaW5kaW5nLnRhcmdldCwgcGFydC5zb3VyY2UsIHBhcnQubmVnYXRlKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyAtLSBmb3IgbWV0aG9kLWJhc2VkIGVmZmVjdHMgKGNvbXBsZXhPYnNlcnZlciAmIGNvbXB1dGVkKSAtLS0tLS0tLS0tLS0tLVxuXG4vKipcbiAqIEFkZHMgcHJvcGVydHkgZWZmZWN0cyBmb3IgZWFjaCBhcmd1bWVudCBpbiB0aGUgbWV0aG9kIHNpZ25hdHVyZSAoYW5kXG4gKiBvcHRpb25hbGx5LCBmb3IgdGhlIG1ldGhvZCBuYW1lIGlmIGBkeW5hbWljYCBpcyB0cnVlKSB0aGF0IGNhbGxzIHRoZVxuICogcHJvdmlkZWQgZWZmZWN0IGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudCB8IE9iamVjdH0gbW9kZWwgUHJvdG90eXBlIG9yIGluc3RhbmNlXG4gKiBAcGFyYW0geyFNZXRob2RTaWduYXR1cmV9IHNpZyBNZXRob2Qgc2lnbmF0dXJlIG1ldGFkYXRhXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBUeXBlIG9mIHByb3BlcnR5IGVmZmVjdCB0byBhZGRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGVmZmVjdEZuIEZ1bmN0aW9uIHRvIHJ1biB3aGVuIGFyZ3VtZW50cyBjaGFuZ2VcbiAqIEBwYXJhbSB7Kj19IG1ldGhvZEluZm8gRWZmZWN0LXNwZWNpZmljIGluZm9ybWF0aW9uIHRvIGJlIGluY2x1ZGVkIGluXG4gKiAgIG1ldGhvZCBlZmZlY3QgbWV0YWRhdGFcbiAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmcgd2hldGhlclxuICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LiBOb3RlLFxuICogICBkZWZhdWx0cyB0byB0cnVlIGlmIHRoZSBzaWduYXR1cmUgaXMgc3RhdGljIChzaWcuc3RhdGljIGlzIHRydWUpLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWV0aG9kRWZmZWN0KG1vZGVsLCBzaWcsIHR5cGUsIGVmZmVjdEZuLCBtZXRob2RJbmZvLCBkeW5hbWljRm4pIHtcbiAgZHluYW1pY0ZuID0gc2lnLnN0YXRpYyB8fCAoZHluYW1pY0ZuICYmXG4gICAgKHR5cGVvZiBkeW5hbWljRm4gIT09ICdvYmplY3QnIHx8IGR5bmFtaWNGbltzaWcubWV0aG9kTmFtZV0pKTtcbiAgbGV0IGluZm8gPSB7XG4gICAgbWV0aG9kTmFtZTogc2lnLm1ldGhvZE5hbWUsXG4gICAgYXJnczogc2lnLmFyZ3MsXG4gICAgbWV0aG9kSW5mbyxcbiAgICBkeW5hbWljRm5cbiAgfTtcbiAgZm9yIChsZXQgaT0wLCBhcmc7IChpPHNpZy5hcmdzLmxlbmd0aCkgJiYgKGFyZz1zaWcuYXJnc1tpXSk7IGkrKykge1xuICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChhcmcucm9vdFByb3BlcnR5LCB0eXBlLCB7XG4gICAgICAgIGZuOiBlZmZlY3RGbiwgaW5mbzogaW5mbywgdHJpZ2dlcjogYXJnXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGR5bmFtaWNGbikge1xuICAgIG1vZGVsLl9hZGRQcm9wZXJ0eUVmZmVjdChzaWcubWV0aG9kTmFtZSwgdHlwZSwge1xuICAgICAgZm46IGVmZmVjdEZuLCBpbmZvOiBpbmZvXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxscyBhIG1ldGhvZCB3aXRoIGFyZ3VtZW50cyBtYXJzaGFsZWQgZnJvbSBwcm9wZXJ0aWVzIG9uIHRoZSBpbnN0YW5jZVxuICogYmFzZWQgb24gdGhlIG1ldGhvZCBzaWduYXR1cmUgY29udGFpbmVkIGluIHRoZSBlZmZlY3QgbWV0YWRhdGEuXG4gKlxuICogTXVsdGktcHJvcGVydHkgb2JzZXJ2ZXJzLCBjb21wdXRlZCBwcm9wZXJ0aWVzLCBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICogZnVuY3Rpb25zIGNhbGwgdGhpcyBmdW5jdGlvbiB0byBpbnZva2UgdGhlIG1ldGhvZCwgdGhlbiB1c2UgdGhlIHJldHVyblxuICogdmFsdWUgYWNjb3JkaW5nbHkuXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBUaGUgaW5zdGFuY2UgdGhlIGVmZmVjdCB3aWxsIGJlIHJ1biBvblxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gKiBAcGFyYW0ge09iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gez99IGluZm8gRWZmZWN0IG1ldGFkYXRhXG4gKiBAcmV0dXJuIHsqfSBSZXR1cm5zIHRoZSByZXR1cm4gdmFsdWUgZnJvbSB0aGUgbWV0aG9kIGludm9jYXRpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJ1bk1ldGhvZEVmZmVjdChpbnN0LCBwcm9wZXJ0eSwgcHJvcHMsIG9sZFByb3BzLCBpbmZvKSB7XG4gIC8vIEluc3RhbmNlcyBjYW4gb3B0aW9uYWxseSBoYXZlIGEgX21ldGhvZEhvc3Qgd2hpY2ggYWxsb3dzIHJlZGlyZWN0aW5nIHdoZXJlXG4gIC8vIHRvIGZpbmQgbWV0aG9kcy4gQ3VycmVudGx5IHVzZWQgYnkgYHRlbXBsYXRpemVgLlxuICBsZXQgY29udGV4dCA9IGluc3QuX21ldGhvZEhvc3QgfHwgaW5zdDtcbiAgbGV0IGZuID0gY29udGV4dFtpbmZvLm1ldGhvZE5hbWVdO1xuICBpZiAoZm4pIHtcbiAgICBsZXQgYXJncyA9IG1hcnNoYWxBcmdzKGluc3QuX19kYXRhLCBpbmZvLmFyZ3MsIHByb3BlcnR5LCBwcm9wcyk7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2UgaWYgKCFpbmZvLmR5bmFtaWNGbikge1xuICAgIGNvbnNvbGUud2FybignbWV0aG9kIGAnICsgaW5mby5tZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgfVxufVxuXG5jb25zdCBlbXB0eUFycmF5ID0gW107XG5cbi8vIFJlZ3VsYXIgZXhwcmVzc2lvbnMgdXNlZCBmb3IgYmluZGluZ1xuY29uc3QgSURFTlQgID0gJyg/OicgKyAnW2EtekEtWl8kXVtcXFxcdy46JFxcXFwtKl0qJyArICcpJztcbmNvbnN0IE5VTUJFUiA9ICcoPzonICsgJ1stK10/WzAtOV0qXFxcXC4/WzAtOV0rKD86W2VFXVstK10/WzAtOV0rKT8nICsgJyknO1xuY29uc3QgU1FVT1RFX1NUUklORyA9ICcoPzonICsgJ1xcJyg/OlteXFwnXFxcXFxcXFxdfFxcXFxcXFxcLikqXFwnJyArICcpJztcbmNvbnN0IERRVU9URV9TVFJJTkcgPSAnKD86JyArICdcIig/OlteXCJcXFxcXFxcXF18XFxcXFxcXFwuKSpcIicgKyAnKSc7XG5jb25zdCBTVFJJTkcgPSAnKD86JyArIFNRVU9URV9TVFJJTkcgKyAnfCcgKyBEUVVPVEVfU1RSSU5HICsgJyknO1xuY29uc3QgQVJHVU1FTlQgPSAnKD86KCcgKyBJREVOVCArICd8JyArIE5VTUJFUiArICd8JyArICBTVFJJTkcgKyAnKVxcXFxzKicgKyAnKSc7XG5jb25zdCBBUkdVTUVOVFMgPSAnKD86JyArIEFSR1VNRU5UICsgJyg/OixcXFxccyonICsgQVJHVU1FTlQgKyAnKSonICsgJyknO1xuY29uc3QgQVJHVU1FTlRfTElTVCA9ICcoPzonICsgJ1xcXFwoXFxcXHMqJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnKD86JyArIEFSR1VNRU5UUyArICc/JyArICcpJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1xcXFwpXFxcXHMqJyArICcpJztcbmNvbnN0IEJJTkRJTkcgPSAnKCcgKyBJREVOVCArICdcXFxccyonICsgQVJHVU1FTlRfTElTVCArICc/JyArICcpJzsgLy8gR3JvdXAgM1xuY29uc3QgT1BFTl9CUkFDS0VUID0gJyhcXFxcW1xcXFxbfHt7KScgKyAnXFxcXHMqJztcbmNvbnN0IENMT1NFX0JSQUNLRVQgPSAnKD86XV18fX0pJztcbmNvbnN0IE5FR0FURSA9ICcoPzooISlcXFxccyopPyc7IC8vIEdyb3VwIDJcbmNvbnN0IEVYUFJFU1NJT04gPSBPUEVOX0JSQUNLRVQgKyBORUdBVEUgKyBCSU5ESU5HICsgQ0xPU0VfQlJBQ0tFVDtcbmNvbnN0IGJpbmRpbmdSZWdleCA9IG5ldyBSZWdFeHAoRVhQUkVTU0lPTiwgXCJnXCIpO1xuXG4vKipcbiAqIENyZWF0ZSBhIHN0cmluZyBmcm9tIGJpbmRpbmcgcGFydHMgb2YgYWxsIHRoZSBsaXRlcmFsIHBhcnRzXG4gKlxuICogQHBhcmFtIHshQXJyYXk8QmluZGluZ1BhcnQ+fSBwYXJ0cyBBbGwgcGFydHMgdG8gc3RyaW5naWZ5XG4gKiBAcmV0dXJuIHtzdHJpbmd9IFN0cmluZyBtYWRlIGZyb20gdGhlIGxpdGVyYWwgcGFydHNcbiAqL1xuZnVuY3Rpb24gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cykge1xuICBsZXQgcyA9ICcnO1xuICBmb3IgKGxldCBpPTA7IGk8cGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgbGl0ZXJhbCA9IHBhcnRzW2ldLmxpdGVyYWw7XG4gICAgcyArPSBsaXRlcmFsIHx8ICcnO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG4vKipcbiAqIFBhcnNlcyBhbiBleHByZXNzaW9uIHN0cmluZyBmb3IgYSBtZXRob2Qgc2lnbmF0dXJlLCBhbmQgcmV0dXJucyBhIG1ldGFkYXRhXG4gKiBkZXNjcmliaW5nIHRoZSBtZXRob2QgaW4gdGVybXMgb2YgYG1ldGhvZE5hbWVgLCBgc3RhdGljYCAod2hldGhlciBhbGwgdGhlXG4gKiBhcmd1bWVudHMgYXJlIGxpdGVyYWxzKSwgYW5kIGFuIGFycmF5IG9mIGBhcmdzYFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIFRoZSBleHByZXNzaW9uIHRvIHBhcnNlXG4gKiBAcmV0dXJuIHs/TWV0aG9kU2lnbmF0dXJlfSBUaGUgbWV0aG9kIG1ldGFkYXRhIG9iamVjdCBpZiBhIG1ldGhvZCBleHByZXNzaW9uIHdhc1xuICogICBmb3VuZCwgb3RoZXJ3aXNlIGB1bmRlZmluZWRgXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZU1ldGhvZChleHByZXNzaW9uKSB7XG4gIC8vIHRyaWVzIHRvIG1hdGNoIHZhbGlkIGphdmFzY3JpcHQgcHJvcGVydHkgbmFtZXNcbiAgbGV0IG0gPSBleHByZXNzaW9uLm1hdGNoKC8oW15cXHNdKz8pXFwoKFtcXHNcXFNdKilcXCkvKTtcbiAgaWYgKG0pIHtcbiAgICBsZXQgbWV0aG9kTmFtZSA9IG1bMV07XG4gICAgbGV0IHNpZyA9IHsgbWV0aG9kTmFtZSwgc3RhdGljOiB0cnVlLCBhcmdzOiBlbXB0eUFycmF5IH07XG4gICAgaWYgKG1bMl0udHJpbSgpKSB7XG4gICAgICAvLyByZXBsYWNlIGVzY2FwZWQgY29tbWFzIHdpdGggY29tbWEgZW50aXR5LCBzcGxpdCBvbiB1bi1lc2NhcGVkIGNvbW1hc1xuICAgICAgbGV0IGFyZ3MgPSBtWzJdLnJlcGxhY2UoL1xcXFwsL2csICcmY29tbWE7Jykuc3BsaXQoJywnKTtcbiAgICAgIHJldHVybiBwYXJzZUFyZ3MoYXJncywgc2lnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHNpZztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUGFyc2VzIGFuIGFycmF5IG9mIGFyZ3VtZW50cyBhbmQgc2V0cyB0aGUgYGFyZ3NgIHByb3BlcnR5IG9mIHRoZSBzdXBwbGllZFxuICogc2lnbmF0dXJlIG1ldGFkYXRhIG9iamVjdC4gU2V0cyB0aGUgYHN0YXRpY2AgcHJvcGVydHkgdG8gZmFsc2UgaWYgYW55XG4gKiBhcmd1bWVudCBpcyBhIG5vbi1saXRlcmFsLlxuICpcbiAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IGFyZ0xpc3QgQXJyYXkgb2YgYXJndW1lbnQgbmFtZXNcbiAqIEBwYXJhbSB7IU1ldGhvZFNpZ25hdHVyZX0gc2lnIE1ldGhvZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcmV0dXJuIHshTWV0aG9kU2lnbmF0dXJlfSBUaGUgdXBkYXRlZCBzaWduYXR1cmUgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZ3MoYXJnTGlzdCwgc2lnKSB7XG4gIHNpZy5hcmdzID0gYXJnTGlzdC5tYXAoZnVuY3Rpb24ocmF3QXJnKSB7XG4gICAgbGV0IGFyZyA9IHBhcnNlQXJnKHJhd0FyZyk7XG4gICAgaWYgKCFhcmcubGl0ZXJhbCkge1xuICAgICAgc2lnLnN0YXRpYyA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9LCB0aGlzKTtcbiAgcmV0dXJuIHNpZztcbn1cblxuLyoqXG4gKiBQYXJzZXMgYW4gaW5kaXZpZHVhbCBhcmd1bWVudCwgYW5kIHJldHVybnMgYW4gYXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gKiB3aXRoIHRoZSBmb2xsb3dpbmcgZmllbGRzOlxuICpcbiAqICAge1xuICogICAgIHZhbHVlOiAncHJvcCcsICAgICAgICAvLyBwcm9wZXJ0eS9wYXRoIG9yIGxpdGVyYWwgdmFsdWVcbiAqICAgICBsaXRlcmFsOiBmYWxzZSwgICAgICAgLy8gd2hldGhlciBhcmd1bWVudCBpcyBhIGxpdGVyYWxcbiAqICAgICBzdHJ1Y3R1cmVkOiBmYWxzZSwgICAgLy8gd2hldGhlciB0aGUgcHJvcGVydHkgaXMgYSBwYXRoXG4gKiAgICAgcm9vdFByb3BlcnR5OiAncHJvcCcsIC8vIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoXG4gKiAgICAgd2lsZGNhcmQ6IGZhbHNlICAgICAgIC8vIHdoZXRoZXIgdGhlIGFyZ3VtZW50IHdhcyBhIHdpbGRjYXJkICcuKicgcGF0aFxuICogICB9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJhd0FyZyBUaGUgc3RyaW5nIHZhbHVlIG9mIHRoZSBhcmd1bWVudFxuICogQHJldHVybiB7IU1ldGhvZEFyZ30gQXJndW1lbnQgbWV0YWRhdGEgb2JqZWN0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZyhyYXdBcmcpIHtcbiAgLy8gY2xlYW4gdXAgd2hpdGVzcGFjZVxuICBsZXQgYXJnID0gcmF3QXJnLnRyaW0oKVxuICAgIC8vIHJlcGxhY2UgY29tbWEgZW50aXR5IHdpdGggY29tbWFcbiAgICAucmVwbGFjZSgvJmNvbW1hOy9nLCAnLCcpXG4gICAgLy8gcmVwYWlyIGV4dHJhIGVzY2FwZSBzZXF1ZW5jZXM7IG5vdGUgb25seSBjb21tYXMgc3RyaWN0bHkgbmVlZFxuICAgIC8vIGVzY2FwaW5nLCBidXQgd2UgYWxsb3cgYW55IG90aGVyIGNoYXIgdG8gYmUgZXNjYXBlZCBzaW5jZSBpdHNcbiAgICAvLyBsaWtlbHkgdXNlcnMgd2lsbCBkbyB0aGlzXG4gICAgLnJlcGxhY2UoL1xcXFwoLikvZywgJ1xcJDEnKVxuICAgIDtcbiAgLy8gYmFzaWMgYXJndW1lbnQgZGVzY3JpcHRvclxuICBsZXQgYSA9IHtcbiAgICBuYW1lOiBhcmcsXG4gICAgdmFsdWU6ICcnLFxuICAgIGxpdGVyYWw6IGZhbHNlXG4gIH07XG4gIC8vIGRldGVjdCBsaXRlcmFsIHZhbHVlIChtdXN0IGJlIFN0cmluZyBvciBOdW1iZXIpXG4gIGxldCBmYyA9IGFyZ1swXTtcbiAgaWYgKGZjID09PSAnLScpIHtcbiAgICBmYyA9IGFyZ1sxXTtcbiAgfVxuICBpZiAoZmMgPj0gJzAnICYmIGZjIDw9ICc5Jykge1xuICAgIGZjID0gJyMnO1xuICB9XG4gIHN3aXRjaChmYykge1xuICAgIGNhc2UgXCInXCI6XG4gICAgY2FzZSAnXCInOlxuICAgICAgYS52YWx1ZSA9IGFyZy5zbGljZSgxLCAtMSk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnIyc6XG4gICAgICBhLnZhbHVlID0gTnVtYmVyKGFyZyk7XG4gICAgICBhLmxpdGVyYWwgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgLy8gaWYgbm90IGxpdGVyYWwsIGxvb2sgZm9yIHN0cnVjdHVyZWQgcGF0aFxuICBpZiAoIWEubGl0ZXJhbCkge1xuICAgIGEucm9vdFByb3BlcnR5ID0gcm9vdCQwKGFyZyk7XG4gICAgLy8gZGV0ZWN0IHN0cnVjdHVyZWQgcGF0aCAoaGFzIGRvdHMpXG4gICAgYS5zdHJ1Y3R1cmVkID0gaXNQYXRoJDAoYXJnKTtcbiAgICBpZiAoYS5zdHJ1Y3R1cmVkKSB7XG4gICAgICBhLndpbGRjYXJkID0gKGFyZy5zbGljZSgtMikgPT0gJy4qJyk7XG4gICAgICBpZiAoYS53aWxkY2FyZCkge1xuICAgICAgICBhLm5hbWUgPSBhcmcuc2xpY2UoMCwgLTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBHYXRoZXIgdGhlIGFyZ3VtZW50IHZhbHVlcyBmb3IgYSBtZXRob2Qgc3BlY2lmaWVkIGluIHRoZSBwcm92aWRlZCBhcnJheVxuICogb2YgYXJndW1lbnQgbWV0YWRhdGEuXG4gKlxuICogVGhlIGBwYXRoYCBhbmQgYHZhbHVlYCBhcmd1bWVudHMgYXJlIHVzZWQgdG8gZmlsbCBpbiB3aWxkY2FyZCBkZXNjcmlwdG9yXG4gKiB3aGVuIHRoZSBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIGFzIGEgcmVzdWx0IG9mIGEgcGF0aCBub3RpZmljYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgSW5zdGFuY2UgZGF0YSBzdG9yYWdlIG9iamVjdCB0byByZWFkIHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHshQXJyYXk8IU1ldGhvZEFyZz59IGFyZ3MgQXJyYXkgb2YgYXJndW1lbnQgbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFByb3BlcnR5L3BhdGggbmFtZSB0aGF0IHRyaWdnZXJlZCB0aGUgbWV0aG9kIGVmZmVjdFxuICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBjdXJyZW50IHByb3BlcnR5IGNoYW5nZXNcbiAqIEByZXR1cm4ge0FycmF5PCo+fSBBcnJheSBvZiBhcmd1bWVudCB2YWx1ZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG1hcnNoYWxBcmdzKGRhdGEsIGFyZ3MsIHBhdGgsIHByb3BzKSB7XG4gIGxldCB2YWx1ZXMgPSBbXTtcbiAgZm9yIChsZXQgaT0wLCBsPWFyZ3MubGVuZ3RoOyBpPGw7IGkrKykge1xuICAgIGxldCBhcmcgPSBhcmdzW2ldO1xuICAgIGxldCBuYW1lID0gYXJnLm5hbWU7XG4gICAgbGV0IHY7XG4gICAgaWYgKGFyZy5saXRlcmFsKSB7XG4gICAgICB2ID0gYXJnLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnLnN0cnVjdHVyZWQpIHtcbiAgICAgICAgdiA9IGdldCQwKGRhdGEsIG5hbWUpO1xuICAgICAgICAvLyB3aGVuIGRhdGEgaXMgbm90IHN0b3JlZCBlLmcuIGBzcGxpY2VzYFxuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdiA9IHByb3BzW25hbWVdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ID0gZGF0YVtuYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFyZy53aWxkY2FyZCkge1xuICAgICAgLy8gT25seSBzZW5kIHRoZSBhY3R1YWwgcGF0aCBjaGFuZ2VkIGluZm8gaWYgdGhlIGNoYW5nZSB0aGF0XG4gICAgICAvLyBjYXVzZWQgdGhlIG9ic2VydmVyIHRvIHJ1biBtYXRjaGVkIHRoZSB3aWxkY2FyZFxuICAgICAgbGV0IGJhc2VDaGFuZ2VkID0gKG5hbWUuaW5kZXhPZihwYXRoICsgJy4nKSA9PT0gMCk7XG4gICAgICBsZXQgbWF0Y2hlcyA9IChwYXRoLmluZGV4T2YobmFtZSkgPT09IDAgJiYgIWJhc2VDaGFuZ2VkKTtcbiAgICAgIHZhbHVlc1tpXSA9IHtcbiAgICAgICAgcGF0aDogbWF0Y2hlcyA/IHBhdGggOiBuYW1lLFxuICAgICAgICB2YWx1ZTogbWF0Y2hlcyA/IHByb3BzW3BhdGhdIDogdixcbiAgICAgICAgYmFzZTogdlxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWVzW2ldID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHZhbHVlcztcbn1cblxuLy8gZGF0YSBhcGlcblxuLyoqXG4gKiBTZW5kcyBhcnJheSBzcGxpY2Ugbm90aWZpY2F0aW9ucyAoYC5zcGxpY2VzYCBhbmQgYC5sZW5ndGhgKVxuICpcbiAqIE5vdGU6IHRoaXMgaW1wbGVtZW50YXRpb24gb25seSBhY2NlcHRzIG5vcm1hbGl6ZWQgcGF0aHNcbiAqXG4gKiBAcGFyYW0geyFQcm9wZXJ0eUVmZmVjdHNUeXBlfSBpbnN0IEluc3RhbmNlIHRvIHNlbmQgbm90aWZpY2F0aW9ucyB0b1xuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRoZSBtdXRhdGlvbnMgb2NjdXJyZWQgb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIHRoZSBhcnJheSB0aGF0IHdhcyBtdXRhdGVkXG4gKiBAcGFyYW0ge0FycmF5fSBzcGxpY2VzIEFycmF5IG9mIHNwbGljZSByZWNvcmRzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBub3RpZnlTcGxpY2VzKGluc3QsIGFycmF5LCBwYXRoLCBzcGxpY2VzKSB7XG4gIGxldCBzcGxpY2VzUGF0aCA9IHBhdGggKyAnLnNwbGljZXMnO1xuICBpbnN0Lm5vdGlmeVBhdGgoc3BsaWNlc1BhdGgsIHsgaW5kZXhTcGxpY2VzOiBzcGxpY2VzIH0pO1xuICBpbnN0Lm5vdGlmeVBhdGgocGF0aCArICcubGVuZ3RoJywgYXJyYXkubGVuZ3RoKTtcbiAgLy8gTnVsbCBoZXJlIHRvIGFsbG93IHBvdGVudGlhbGx5IGxhcmdlIHNwbGljZSByZWNvcmRzIHRvIGJlIEdDJ2VkLlxuICBpbnN0Ll9fZGF0YVtzcGxpY2VzUGF0aF0gPSB7aW5kZXhTcGxpY2VzOiBudWxsfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3BsaWNlIHJlY29yZCBhbmQgc2VuZHMgYW4gYXJyYXkgc3BsaWNlIG5vdGlmaWNhdGlvbiBmb3JcbiAqIHRoZSBkZXNjcmliZWQgbXV0YXRpb25cbiAqXG4gKiBOb3RlOiB0aGlzIGltcGxlbWVudGF0aW9uIG9ubHkgYWNjZXB0cyBub3JtYWxpemVkIHBhdGhzXG4gKlxuICogQHBhcmFtIHshUHJvcGVydHlFZmZlY3RzVHlwZX0gaW5zdCBJbnN0YW5jZSB0byBzZW5kIG5vdGlmaWNhdGlvbnMgdG9cbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0aGUgbXV0YXRpb25zIG9jY3VycmVkIG9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byB0aGUgYXJyYXkgdGhhdCB3YXMgbXV0YXRlZFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRoZSBhcnJheSBtdXRhdGlvbiBvY2N1cnJlZFxuICogQHBhcmFtIHtudW1iZXJ9IGFkZGVkQ291bnQgTnVtYmVyIG9mIGFkZGVkIGl0ZW1zXG4gKiBAcGFyYW0ge0FycmF5fSByZW1vdmVkIEFycmF5IG9mIHJlbW92ZWQgaXRlbXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vdGlmeVNwbGljZShpbnN0LCBhcnJheSwgcGF0aCwgaW5kZXgsIGFkZGVkQ291bnQsIHJlbW92ZWQpIHtcbiAgbm90aWZ5U3BsaWNlcyhpbnN0LCBhcnJheSwgcGF0aCwgW3tcbiAgICBpbmRleDogaW5kZXgsXG4gICAgYWRkZWRDb3VudDogYWRkZWRDb3VudCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIG9iamVjdDogYXJyYXksXG4gICAgdHlwZTogJ3NwbGljZSdcbiAgfV0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gdXBwZXItY2FzZWQgdmVyc2lvbiBvZiB0aGUgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIFN0cmluZyB0byB1cHBlcmNhc2VcbiAqIEByZXR1cm4ge3N0cmluZ30gVXBwZXJjYXNlZCBzdHJpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHVwcGVyKG5hbWUpIHtcbiAgcmV0dXJuIG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xufVxuXG5leHBvcnQgY29uc3QgUHJvcGVydHlFZmZlY3RzID0gZGVkdXBpbmdNaXhpbihzdXBlckNsYXNzID0+IHtcblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBleHRlbmRzIHtzdXBlckNsYXNzfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUFjY2Vzc29yc31cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfVGVtcGxhdGVTdGFtcH1cbiAgICogQHVucmVzdHJpY3RlZFxuICAgKi9cbiAgY29uc3QgcHJvcGVydHlFZmZlY3RzQmFzZSA9IFRlbXBsYXRlU3RhbXAoUHJvcGVydHlBY2Nlc3NvcnMoc3VwZXJDbGFzcykpO1xuXG4gIC8qKlxuICAgKiBAcG9seW1lclxuICAgKiBAbWl4aW5DbGFzc1xuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gICAqIEBleHRlbmRzIHtwcm9wZXJ0eUVmZmVjdHNCYXNlfVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUVmZmVjdHMgZXh0ZW5kcyBwcm9wZXJ0eUVmZmVjdHNCYXNlIHtcblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c1JlYWR5O1xuICAgICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHM7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZTtcbiAgICAgIC8qKiBAdHlwZSB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG4gICAgICB0aGlzLl9fZGF0YUhvc3Q7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVRlbXA7XG4gICAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgICB0aGlzLl9fZGF0YUNsaWVudHNJbml0aWFsaXplZDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX2RhdGFPbGQ7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19jb21wdXRlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlZmxlY3RFZmZlY3RzO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fbm90aWZ5RWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3Byb3BhZ2F0ZUVmZmVjdHM7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19vYnNlcnZlRWZmZWN0cztcbiAgICAgIC8qKiBAdHlwZSB7T2JqZWN0fSAqL1xuICAgICAgdGhpcy5fX3JlYWRPbmx5O1xuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXI7XG4gICAgICAvKiogQHR5cGUgeyFUZW1wbGF0ZUluZm99ICovXG4gICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgIH1cblxuICAgIGdldCBQUk9QRVJUWV9FRkZFQ1RfVFlQRVMoKSB7XG4gICAgICByZXR1cm4gVFlQRVM7XG4gICAgfVxuXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgICBob3N0U3RhY2sucmVnaXN0ZXJIb3N0KHRoaXMpO1xuICAgICAgdGhpcy5fX2RhdGFDbGllbnRzUmVhZHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFUb05vdGlmeSA9IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0gbnVsbDtcbiAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSBmYWxzZTtcbiAgICAgIC8vIE1heSBiZSBzZXQgb24gaW5zdGFuY2UgcHJpb3IgdG8gdXBncmFkZVxuICAgICAgdGhpcy5fX2RhdGFDb21wb3VuZFN0b3JhZ2UgPSB0aGlzLl9fZGF0YUNvbXBvdW5kU3RvcmFnZSB8fCBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFIb3N0ID0gdGhpcy5fX2RhdGFIb3N0IHx8IG51bGw7XG4gICAgICB0aGlzLl9fZGF0YVRlbXAgPSB7fTtcbiAgICAgIHRoaXMuX19kYXRhQ2xpZW50c0luaXRpYWxpemVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBwcm92aWRlIGFcbiAgICAgKiBtb3JlIGVmZmljaWVudCBpbXBsZW1lbnRhdGlvbiBvZiBpbml0aWFsaXppbmcgcHJvcGVydGllcyBmcm9tXG4gICAgICogdGhlIHByb3RvdHlwZSBvbiB0aGUgaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgUHJvcGVydGllcyB0byBpbml0aWFsaXplIG9uIHRoZSBwcm90b3R5cGVcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgdGhpcy5fX2RhdGEgPSBPYmplY3QuY3JlYXRlKHByb3BzKTtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IE9iamVjdC5jcmVhdGUocHJvcHMpO1xuICAgICAgdGhpcy5fX2RhdGFPbGQgPSB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgIGltcGxlbWVudGF0aW9uIHRvIGF2b2lkIHNldHRpbmdcbiAgICAgKiBgX3NldFByb3BlcnR5YCdzIGBzaG91bGROb3RpZnk6IHRydWVgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIFByb3BlcnRpZXMgdG8gaW5pdGlhbGl6ZSBvbiB0aGUgaW5zdGFuY2VcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgbGV0IHJlYWRPbmx5ID0gdGhpc1tUWVBFUy5SRUFEX09OTFldO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoIXJlYWRPbmx5IHx8ICFyZWFkT25seVtwcm9wXSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhUGVuZGluZyA9IHRoaXMuX19kYXRhUGVuZGluZyB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHRoaXMuX19kYXRhT2xkIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhW3Byb3BdID0gdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BdID0gcHJvcHNbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQcm90b3R5cGUgc2V0dXAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGFkZFByb3BlcnR5RWZmZWN0YCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgZWZmZWN0XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgRWZmZWN0IHR5cGUsIGZyb20gdGhpcy5QUk9QRVJUWV9FRkZFQ1RfVFlQRVNcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KSB7XG4gICAgICB0aGlzLl9jcmVhdGVQcm9wZXJ0eUFjY2Vzc29yKHByb3BlcnR5LCB0eXBlID09IFRZUEVTLlJFQURfT05MWSk7XG4gICAgICAvLyBlZmZlY3RzIGFyZSBhY2N1bXVsYXRlZCBpbnRvIGFycmF5cyBwZXIgcHJvcGVydHkgYmFzZWQgb24gdHlwZVxuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgaWYgKCFlZmZlY3RzKSB7XG4gICAgICAgIGVmZmVjdHMgPSB0aGlzW3R5cGVdW3Byb3BlcnR5XSA9IFtdO1xuICAgICAgfVxuICAgICAgZWZmZWN0cy5wdXNoKGVmZmVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgZ2l2ZW4gcHJvcGVydHkgZWZmZWN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IHRoZSBlZmZlY3Qgd2FzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBlZmZlY3QgRWZmZWN0IG1ldGFkYXRhIG9iamVjdCB0byByZW1vdmVcbiAgICAgKi9cbiAgICBfcmVtb3ZlUHJvcGVydHlFZmZlY3QocHJvcGVydHksIHR5cGUsIGVmZmVjdCkge1xuICAgICAgbGV0IGVmZmVjdHMgPSBlbnN1cmVPd25FZmZlY3RNYXAodGhpcywgdHlwZSlbcHJvcGVydHldO1xuICAgICAgbGV0IGlkeCA9IGVmZmVjdHMuaW5kZXhPZihlZmZlY3QpO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIGVmZmVjdHMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBwcm9wZXJ0eSBlZmZlY3RcbiAgICAgKiBvZiBhIGNlcnRhaW4gdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlIEVmZmVjdCB0eXBlLCBmcm9tIHRoaXMuUFJPUEVSVFlfRUZGRUNUX1RZUEVTXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSkge1xuICAgICAgbGV0IGVmZmVjdHMgPSB0aGlzW3R5cGVdO1xuICAgICAgcmV0dXJuIEJvb2xlYW4oZWZmZWN0cyAmJiBlZmZlY3RzW3Byb3BlcnR5XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBjdXJyZW50IHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYSBcInJlYWQgb25seVwiXG4gICAgICogYWNjZXNzb3IgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhbiBlZmZlY3Qgb2YgdGhpcyB0eXBlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9oYXNSZWFkT25seUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUFEX09OTFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJub3RpZnlcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc05vdGlmeUVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5OT1RJRlkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGEgXCJyZWZsZWN0IHRvIGF0dHJpYnV0ZVwiXG4gICAgICogcHJvcGVydHkgZWZmZWN0IGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHByb3RvdHlwZS9pbnN0YW5jZSBoYXMgYW4gZWZmZWN0IG9mIHRoaXMgdHlwZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaGFzUmVmbGVjdEVmZmVjdChwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2hhc1Byb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5SRUZMRUNUKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIGN1cnJlbnQgcHJvdG90eXBlL2luc3RhbmNlIGhhcyBhIFwiY29tcHV0ZWRcIlxuICAgICAqIHByb3BlcnR5IGVmZmVjdCBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBwcm90b3R5cGUvaW5zdGFuY2UgaGFzIGFuIGVmZmVjdCBvZiB0aGlzIHR5cGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2hhc0NvbXB1dGVkRWZmZWN0KHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5faGFzUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLkNPTVBVVEUpO1xuICAgIH1cblxuICAgIC8vIFJ1bnRpbWUgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHBlbmRpbmcgcHJvcGVydHkgb3IgcGF0aC4gIElmIHRoZSByb290IHByb3BlcnR5IG9mIHRoZSBwYXRoIGluXG4gICAgICogcXVlc3Rpb24gaGFkIG5vIGFjY2Vzc29yLCB0aGUgcGF0aCBpcyBzZXQsIG90aGVyd2lzZSBpdCBpcyBlbnF1ZXVlZFxuICAgICAqIHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzb2xhdGVzIHJlbGF0aXZlbHkgZXhwZW5zaXZlIGZ1bmN0aW9uYWxpdHkgbmVjZXNzYXJ5XG4gICAgICogZm9yIHRoZSBwdWJsaWMgQVBJIChgc2V0YCwgYHNldFByb3BlcnRpZXNgLCBgbm90aWZ5UGF0aGAsIGFuZCBwcm9wZXJ0eVxuICAgICAqIGNoYW5nZSBsaXN0ZW5lcnMgdmlhIHt7Li4ufX0gYmluZGluZ3MpLCBzdWNoIHRoYXQgaXQgaXMgb25seSBkb25lXG4gICAgICogd2hlbiBwYXRocyBlbnRlciB0aGUgc3lzdGVtLCBhbmQgbm90IGF0IGV2ZXJ5IHByb3BhZ2F0aW9uIHN0ZXAuICBJdFxuICAgICAqIGFsc28gc2V0cyBhIGBfX2RhdGFIYXNQYXRoc2AgZmxhZyBvbiB0aGUgaW5zdGFuY2Ugd2hpY2ggaXMgdXNlZCB0b1xuICAgICAqIGZhc3QtcGF0aCBzbG93ZXIgcGF0aC1tYXRjaGluZyBjb2RlIGluIHRoZSBwcm9wZXJ0eSBlZmZlY3RzIGhvc3QgcGF0aHMuXG4gICAgICpcbiAgICAgKiBgcGF0aGAgY2FuIGJlIGEgcGF0aCBzdHJpbmcgb3IgYXJyYXkgb2YgcGF0aCBwYXJ0cyBhcyBhY2NlcHRlZCBieSB0aGVcbiAgICAgKiBwdWJsaWMgQVBJLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8bnVtYmVyfHN0cmluZz59IHBhdGggUGF0aCB0byBzZXRcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZE5vdGlmeSBTZXQgdG8gdHJ1ZSBpZiB0aGlzIGNoYW5nZSBzaG91bGRcbiAgICAgKiAgY2F1c2UgYSBwcm9wZXJ0eSBub3RpZmljYXRpb24gZXZlbnQgZGlzcGF0Y2hcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBpc1BhdGhOb3RpZmljYXRpb24gSWYgdGhlIHBhdGggYmVpbmcgc2V0IGlzIGEgcGF0aFxuICAgICAqICAgbm90aWZpY2F0aW9uIG9mIGFuIGFscmVhZHkgY2hhbmdlZCB2YWx1ZSwgYXMgb3Bwb3NlZCB0byBhIHJlcXVlc3RcbiAgICAgKiAgIHRvIHNldCBhbmQgbm90aWZ5IHRoZSBjaGFuZ2UuICBJbiB0aGUgbGF0dGVyIGBmYWxzZWAgY2FzZSwgYSBkaXJ0eVxuICAgICAqICAgY2hlY2sgaXMgcGVyZm9ybWVkIGFuZCB0aGVuIHRoZSB2YWx1ZSBpcyBzZXQgdG8gdGhlIHBhdGggYmVmb3JlXG4gICAgICogICBlbnF1ZXVpbmcgdGhlIHBlbmRpbmcgcHJvcGVydHkgY2hhbmdlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkvcGF0aCB3YXMgZW5xdWV1ZWQgaW5cbiAgICAgKiAgIHRoZSBwZW5kaW5nIGNoYW5nZXMgYmFnLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHZhbHVlLCBzaG91bGROb3RpZnksIGlzUGF0aE5vdGlmaWNhdGlvbikge1xuICAgICAgaWYgKGlzUGF0aE5vdGlmaWNhdGlvbiB8fFxuICAgICAgICAgIHJvb3QkMChBcnJheS5pc0FycmF5KHBhdGgpID8gcGF0aFswXSA6IHBhdGgpICE9PSBwYXRoKSB7XG4gICAgICAgIC8vIERpcnR5IGNoZWNrIGNoYW5nZXMgYmVpbmcgc2V0IHRvIGEgcGF0aCBhZ2FpbnN0IHRoZSBhY3R1YWwgb2JqZWN0LFxuICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3IgcGF0aHMgaW50byB0aGUgc3lzdGVtOyBmcm9tIGhlcmVcbiAgICAgICAgLy8gdGhlIG9ubHkgZGlydHkgY2hlY2tzIGFyZSBhZ2FpbnN0IHRoZSBgX19kYXRhVGVtcGAgY2FjaGUgdG8gcHJldmVudFxuICAgICAgICAvLyBkdXBsaWNhdGUgd29yayBpbiB0aGUgc2FtZSB0dXJuIG9ubHkuIE5vdGUsIGlmIHRoaXMgd2FzIGEgbm90aWZpY2F0aW9uXG4gICAgICAgIC8vIG9mIGEgY2hhbmdlIGFscmVhZHkgc2V0IHRvIGEgcGF0aCAoaXNQYXRoTm90aWZpY2F0aW9uOiB0cnVlKSxcbiAgICAgICAgLy8gd2UgYWx3YXlzIGxldCB0aGUgY2hhbmdlIHRocm91Z2ggYW5kIHNraXAgdGhlIGBzZXRgIHNpbmNlIGl0IHdhc1xuICAgICAgICAvLyBhbHJlYWR5IGRpcnR5IGNoZWNrZWQgYXQgdGhlIHBvaW50IG9mIGVudHJ5IGFuZCB0aGUgdW5kZXJseWluZ1xuICAgICAgICAvLyBvYmplY3QgaGFzIGFscmVhZHkgYmVlbiB1cGRhdGVkXG4gICAgICAgIGlmICghaXNQYXRoTm90aWZpY2F0aW9uKSB7XG4gICAgICAgICAgbGV0IG9sZCA9IGdldCQwKHRoaXMsIHBhdGgpO1xuICAgICAgICAgIHBhdGggPSAvKiogQHR5cGUge3N0cmluZ30gKi8gKHNldCQwKHRoaXMsIHBhdGgsIHZhbHVlKSk7XG4gICAgICAgICAgLy8gVXNlIHByb3BlcnR5LWFjY2Vzc29yJ3Mgc2ltcGxlciBkaXJ0eSBjaGVja1xuICAgICAgICAgIGlmICghcGF0aCB8fCAhc3VwZXIuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHBhdGgsIHZhbHVlLCBvbGQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19kYXRhSGFzUGF0aHMgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KC8qKkB0eXBle3N0cmluZ30qLyhwYXRoKSwgdmFsdWUsIHNob3VsZE5vdGlmeSkpIHtcbiAgICAgICAgICBjb21wdXRlTGlua2VkUGF0aHModGhpcywgcGF0aCwgdmFsdWUpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFIYXNBY2Nlc3NvciAmJiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yW3BhdGhdKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eSgvKipAdHlwZXtzdHJpbmd9Ki8ocGF0aCksIHZhbHVlLCBzaG91bGROb3RpZnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXNbcGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFwcGxpZXMgYSB2YWx1ZSB0byBhIG5vbi1Qb2x5bWVyIGVsZW1lbnQvbm9kZSdzIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhlIGltcGxlbWVudGF0aW9uIG1ha2VzIGEgYmVzdC1lZmZvcnQgYXQgYmluZGluZyBpbnRlcm9wOlxuICAgICAqIFNvbWUgbmF0aXZlIGVsZW1lbnQgcHJvcGVydGllcyBoYXZlIHNpZGUtZWZmZWN0cyB3aGVuXG4gICAgICogcmUtc2V0dGluZyB0aGUgc2FtZSB2YWx1ZSAoZS5nLiBzZXR0aW5nIGA8aW5wdXQ+LnZhbHVlYCByZXNldHMgdGhlXG4gICAgICogY3Vyc29yIHBvc2l0aW9uKSwgc28gd2UgZG8gYSBkaXJ0eS1jaGVjayBiZWZvcmUgc2V0dGluZyB0aGUgdmFsdWUuXG4gICAgICogSG93ZXZlciwgZm9yIGJldHRlciBpbnRlcm9wIHdpdGggbm9uLVBvbHltZXIgY3VzdG9tIGVsZW1lbnRzIHRoYXRcbiAgICAgKiBhY2NlcHQgb2JqZWN0cywgd2UgZXhwbGljaXRseSByZS1zZXQgb2JqZWN0IGNoYW5nZXMgY29taW5nIGZyb20gdGhlXG4gICAgICogUG9seW1lciB3b3JsZCAod2hpY2ggbWF5IGluY2x1ZGUgZGVlcCBvYmplY3QgY2hhbmdlcyB3aXRob3V0IHRoZVxuICAgICAqIHRvcCByZWZlcmVuY2UgY2hhbmdpbmcpLCBlcnJpbmcgb24gdGhlIHNpZGUgb2YgcHJvdmlkaW5nIG1vcmVcbiAgICAgKiBpbmZvcm1hdGlvbi5cbiAgICAgKlxuICAgICAqIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBwcm92aWRlIGFsdGVybmF0ZSBhcHByb2FjaGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIFRoZSBub2RlIHRvIHNldCBhIHByb3BlcnR5IG9uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgVGhlIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0VW5tYW5hZ2VkUHJvcGVydHlUb05vZGUobm9kZSwgcHJvcCwgdmFsdWUpIHtcbiAgICAgIC8vIEl0IGlzIGEganVkZ21lbnQgY2FsbCB0aGF0IHJlc2V0dGluZyBwcmltaXRpdmVzIGlzXG4gICAgICAvLyBcImJhZFwiIGFuZCByZXNldHRpbmdzIG9iamVjdHMgaXMgYWxzbyBcImdvb2RcIjsgYWx0ZXJuYXRpdmVseSB3ZSBjb3VsZFxuICAgICAgLy8gaW1wbGVtZW50IGEgd2hpdGVsaXN0IG9mIHRhZyAmIHByb3BlcnR5IHZhbHVlcyB0aGF0IHNob3VsZCBuZXZlclxuICAgICAgLy8gYmUgcmVzZXQgKGUuZy4gPGlucHV0Pi52YWx1ZSAmJiA8c2VsZWN0Pi52YWx1ZSlcbiAgICAgIGlmICh2YWx1ZSAhPT0gbm9kZVtwcm9wXSB8fCB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyB0aGUgYFByb3BlcnR5QWNjZXNzb3JzYCBpbXBsZW1lbnRhdGlvbiB0byBpbnRyb2R1Y2Ugc3BlY2lhbFxuICAgICAqIGRpcnR5IGNoZWNrIGxvZ2ljIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydHkgJiB2YWx1ZSBiZWluZyBzZXQ6XG4gICAgICpcbiAgICAgKiAxLiBBbnkgdmFsdWUgc2V0IHRvIGEgcGF0aCAoZS5nLiAnb2JqLnByb3AnOiA0MiBvciAnb2JqLnByb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgLCBkaXJ0eSBjaGVja2VkIGFnYWluc3QgYF9fZGF0YVRlbXBgXG4gICAgICogMi4gT2JqZWN0IHNldCB0byBzaW1wbGUgcHJvcGVydHkgKGUuZy4gJ3Byb3AnOiB7Li4ufSlcbiAgICAgKiAgICBTdG9yZWQgaW4gYF9fZGF0YVRlbXBgIGFuZCBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0XG4gICAgICogICAgYF9fZGF0YVRlbXBgIGJ5IGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYF9zaG91bGRQcm9wZXJ0eUNoYW5nZWBcbiAgICAgKiAzLiBQcmltaXRpdmUgdmFsdWUgc2V0IHRvIHNpbXBsZSBwcm9wZXJ0eSAoZS5nLiAncHJvcCc6IDQyKVxuICAgICAqICAgIFN0b3JlZCBpbiBgX19kYXRhYCwgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGBfX2RhdGFgXG4gICAgICpcbiAgICAgKiBUaGUgZGlydHktY2hlY2sgaXMgaW1wb3J0YW50IHRvIHByZXZlbnQgY3ljbGVzIGR1ZSB0byB0d28td2F5XG4gICAgICogbm90aWZpY2F0aW9uLCBidXQgcGF0aHMgYW5kIG9iamVjdHMgYXJlIG9ubHkgZGlydHkgY2hlY2tlZCBhZ2FpbnN0IGFueVxuICAgICAqIHByZXZpb3VzIHZhbHVlIHNldCBkdXJpbmcgdGhpcyB0dXJuIHZpYSBhIFwidGVtcG9yYXJ5IGNhY2hlXCIgdGhhdCBpc1xuICAgICAqIGNsZWFyZWQgd2hlbiB0aGUgbGFzdCBgX3Byb3BlcnRpZXNDaGFnZWRgIGV4aXRzLiBUaGlzIGlzIHNvOlxuICAgICAqIGEuIGFueSBjYWNoZWQgYXJyYXkgcGF0aHMgKGUuZy4gJ2FycmF5LjMucHJvcCcpIG1heSBiZSBpbnZhbGlkYXRlZFxuICAgICAqICAgIGR1ZSB0byBhcnJheSBtdXRhdGlvbnMgbGlrZSBzaGlmdC91bnNoaWZ0L3NwbGljZTsgdGhpcyBpcyBmaW5lXG4gICAgICogICAgc2luY2UgcGF0aCBjaGFuZ2VzIGFyZSBkaXJ0eS1jaGVja2VkIGF0IHVzZXIgZW50cnkgcG9pbnRzIGxpa2UgYHNldGBcbiAgICAgKiBiLiBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBvbmx5IGxhc3RzIG9uZSB0dXJuIHRvIGFsbG93IHRoZSB1c2VyXG4gICAgICogICAgdG8gbXV0YXRlIHRoZSBvYmplY3QgaW4tcGxhY2UgYW5kIHJlLXNldCBpdCB3aXRoIHRoZSBzYW1lIGlkZW50aXR5XG4gICAgICogICAgYW5kIGhhdmUgYWxsIHN1Yi1wcm9wZXJ0aWVzIHJlLXByb3BhZ2F0ZWQgaW4gYSBzdWJzZXF1ZW50IHR1cm4uXG4gICAgICpcbiAgICAgKiBUaGUgdGVtcCBjYWNoZSBpcyBub3QgbmVjZXNzYXJpbHkgc3VmZmljaWVudCB0byBwcmV2ZW50IGludmFsaWQgYXJyYXlcbiAgICAgKiBwYXRocywgc2luY2UgYSBzcGxpY2UgY2FuIGhhcHBlbiBkdXJpbmcgdGhlIHNhbWUgdHVybiAod2l0aCBwYXRob2xvZ2ljYWxcbiAgICAgKiB1c2VyIGNvZGUpOyB3ZSBjb3VsZCBpbnRyb2R1Y2UgYSBcImZpeHVwXCIgZm9yIHRlbXBvcmFyaWx5IGNhY2hlZCBhcnJheVxuICAgICAqIHBhdGhzIGlmIG5lZWRlZDogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXIvcG9seW1lci9pc3N1ZXMvNDIyN1xuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgdGhlIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXRcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGROb3RpZnkgVHJ1ZSBpZiBwcm9wZXJ0eSBzaG91bGQgZmlyZSBub3RpZmljYXRpb25cbiAgICAgKiAgIGV2ZW50IChhcHBsaWVzIG9ubHkgZm9yIGBub3RpZnk6IHRydWVgIHByb3BlcnRpZXMpXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIHRoZSBwcm9wZXJ0eSBjaGFuZ2VkXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX3NldFBlbmRpbmdQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUsIHNob3VsZE5vdGlmeSkge1xuICAgICAgbGV0IGlzUGF0aCA9IHRoaXMuX19kYXRhSGFzUGF0aHMgJiYgaXNQYXRoJDAocHJvcGVydHkpO1xuICAgICAgbGV0IHByZXZQcm9wcyA9IGlzUGF0aCA/IHRoaXMuX19kYXRhVGVtcCA6IHRoaXMuX19kYXRhO1xuICAgICAgaWYgKHRoaXMuX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgcHJldlByb3BzW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgIGlmICghKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXRocyBhcmUgc3RvcmVkIGluIHRlbXBvcmFyeSBjYWNoZSAoY2xlYXJlZCBhdCBlbmQgb2YgdHVybiksXG4gICAgICAgIC8vIHdoaWNoIGlzIHVzZWQgZm9yIGRpcnR5LWNoZWNraW5nLCBhbGwgb3RoZXJzIHN0b3JlZCBpbiBfX2RhdGFcbiAgICAgICAgaWYgKGlzUGF0aCkge1xuICAgICAgICAgIHRoaXMuX19kYXRhVGVtcFtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgY2hhbmdlcyBnbyBpbnRvIHBlbmRpbmcgcHJvcGVydHkgYmFnLCBwYXNzZWQgdG8gX3Byb3BlcnRpZXNDaGFuZ2VkXG4gICAgICAgIHRoaXMuX19kYXRhUGVuZGluZ1twcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgLy8gVHJhY2sgcHJvcGVydGllcyB0aGF0IHNob3VsZCBub3RpZnkgc2VwYXJhdGVseVxuICAgICAgICBpZiAoaXNQYXRoIHx8ICh0aGlzW1RZUEVTLk5PVElGWV0gJiYgdGhpc1tUWVBFUy5OT1RJRlldW3Byb3BlcnR5XSkpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gdGhpcy5fX2RhdGFUb05vdGlmeSB8fCB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5W3Byb3BlcnR5XSA9IHNob3VsZE5vdGlmeTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYmFzZSBpbXBsZW1lbnRhdGlvbiB0byBlbnN1cmUgYWxsIGFjY2Vzc29ycyBzZXQgYHNob3VsZE5vdGlmeWBcbiAgICAgKiB0byB0cnVlLCBmb3IgcGVyLXByb3BlcnR5IG5vdGlmaWNhdGlvbiB0cmFja2luZy5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcGVydHksIHZhbHVlLCB0cnVlKSkge1xuICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBgUHJvcGVydHlBY2Nlc3NvcmAncyBkZWZhdWx0IGFzeW5jIHF1ZXVpbmcgb2ZcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYDogaWYgYF9fZGF0YVJlYWR5YCBpcyBmYWxzZSAoaGFzIG5vdCB5ZXQgYmVlblxuICAgICAqIG1hbnVhbGx5IGZsdXNoZWQpLCB0aGUgZnVuY3Rpb24gbm8tb3BzOyBvdGhlcndpc2UgZmx1c2hlc1xuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIHN5bmNocm9ub3VzbHkuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBfaW52YWxpZGF0ZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnF1ZXVlcyB0aGUgZ2l2ZW4gY2xpZW50IG9uIGEgbGlzdCBvZiBwZW5kaW5nIGNsaWVudHMsIHdob3NlXG4gICAgICogcGVuZGluZyBwcm9wZXJ0eSBjaGFuZ2VzIGNhbiBsYXRlciBiZSBmbHVzaGVkIHZpYSBhIGNhbGwgdG9cbiAgICAgKiBgX2ZsdXNoQ2xpZW50c2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gY2xpZW50IFByb3BlcnR5RWZmZWN0cyBjbGllbnQgdG8gZW5xdWV1ZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZW5xdWV1ZUNsaWVudChjbGllbnQpIHtcbiAgICAgIHRoaXMuX19kYXRhUGVuZGluZ0NsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzIHx8IFtdO1xuICAgICAgaWYgKGNsaWVudCAhPT0gdGhpcykge1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzLnB1c2goY2xpZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGbHVzaGVzIGFueSBjbGllbnRzIHByZXZpb3VzbHkgZW5xdWV1ZWQgdmlhIGBfZW5xdWV1ZUNsaWVudGAsIGNhdXNpbmdcbiAgICAgKiB0aGVpciBgX2ZsdXNoUHJvcGVydGllc2AgbWV0aG9kIHRvIHJ1bi5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZmx1c2hDbGllbnRzKCkge1xuICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICB0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlYWR5Q2xpZW50cygpO1xuICAgICAgICAvLyBPdmVycmlkZSBwb2ludCB3aGVyZSBhY2Nlc3NvcnMgYXJlIHR1cm5lZCBvbjsgaW1wb3J0YW50bHksXG4gICAgICAgIC8vIHRoaXMgaXMgYWZ0ZXIgY2xpZW50cyBoYXZlIGZ1bGx5IHJlYWRpZWQsIHByb3ZpZGluZyBhIGd1YXJhbnRlZVxuICAgICAgICAvLyB0aGF0IGFueSBwcm9wZXJ0eSBlZmZlY3RzIG9jY3VyIG9ubHkgYWZ0ZXIgYWxsIGNsaWVudHMgYXJlIHJlYWR5LlxuICAgICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19lbmFibGVPckZsdXNoQ2xpZW50cygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE5PVEU6IFdlIGVuc3VyZSBjbGllbnRzIGVpdGhlciBlbmFibGUgb3IgZmx1c2ggYXMgYXBwcm9wcmlhdGUuIFRoaXNcbiAgICAvLyBoYW5kbGVzIHR3byBjb3JuZXIgY2FzZXM6XG4gICAgLy8gKDEpIGNsaWVudHMgZmx1c2ggcHJvcGVybHkgd2hlbiBjb25uZWN0ZWQvZW5hYmxlZCBiZWZvcmUgdGhlIGhvc3RcbiAgICAvLyBlbmFibGVzOyBlLmcuXG4gICAgLy8gICAoYSkgVGVtcGxhdGl6ZSBzdGFtcHMgd2l0aCBubyBwcm9wZXJ0aWVzIGFuZCBkb2VzIG5vdCBmbHVzaCBhbmRcbiAgICAvLyAgIChiKSB0aGUgaW5zdGFuY2UgaXMgaW5zZXJ0ZWQgaW50byBkb20gYW5kXG4gICAgLy8gICAoYykgdGhlbiB0aGUgaW5zdGFuY2UgZmx1c2hlcy5cbiAgICAvLyAoMikgY2xpZW50cyBlbmFibGUgcHJvcGVybHkgd2hlbiBub3QgY29ubmVjdGVkL2VuYWJsZWQgd2hlbiB0aGUgaG9zdFxuICAgIC8vIGZsdXNoZXM7IGUuZy5cbiAgICAvLyAgIChhKSBhIHRlbXBsYXRlIGlzIHJ1bnRpbWUgc3RhbXBlZCBhbmQgbm90IHlldCBjb25uZWN0ZWQvZW5hYmxlZFxuICAgIC8vICAgKGIpIGEgaG9zdCBzZXRzIGEgcHJvcGVydHksIGNhdXNpbmcgc3RhbXBlZCBkb20gdG8gZmx1c2hcbiAgICAvLyAgIChjKSB0aGUgc3RhbXBlZCBkb20gZW5hYmxlcy5cbiAgICBfX2VuYWJsZU9yRmx1c2hDbGllbnRzKCkge1xuICAgICAgbGV0IGNsaWVudHMgPSB0aGlzLl9fZGF0YVBlbmRpbmdDbGllbnRzO1xuICAgICAgaWYgKGNsaWVudHMpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nQ2xpZW50cyA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgY2xpZW50ID0gY2xpZW50c1tpXTtcbiAgICAgICAgICBpZiAoIWNsaWVudC5fX2RhdGFFbmFibGVkKSB7XG4gICAgICAgICAgICBjbGllbnQuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsaWVudC5fX2RhdGFQZW5kaW5nKSB7XG4gICAgICAgICAgICBjbGllbnQuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm0gYW55IGluaXRpYWwgc2V0dXAgb24gY2xpZW50IGRvbS4gQ2FsbGVkIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgKiBgX2ZsdXNoUHJvcGVydGllc2AgY2FsbCBvbiBjbGllbnQgZG9tIGFuZCBiZWZvcmUgYW55IGVsZW1lbnRcbiAgICAgKiBvYnNlcnZlcnMgYXJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVhZHlDbGllbnRzKCkge1xuICAgICAgdGhpcy5fX2VuYWJsZU9yRmx1c2hDbGllbnRzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIGJhZyBvZiBwcm9wZXJ0eSBjaGFuZ2VzIHRvIHRoaXMgaW5zdGFuY2UsIGFuZFxuICAgICAqIHN5bmNocm9ub3VzbHkgcHJvY2Vzc2VzIGFsbCBlZmZlY3RzIG9mIHRoZSBwcm9wZXJ0aWVzIGFzIGEgYmF0Y2guXG4gICAgICpcbiAgICAgKiBQcm9wZXJ0eSBuYW1lcyBtdXN0IGJlIHNpbXBsZSBwcm9wZXJ0aWVzLCBub3QgcGF0aHMuICBCYXRjaGVkXG4gICAgICogcGF0aCBwcm9wYWdhdGlvbiBpcyBub3Qgc3VwcG9ydGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIEJhZyBvZiBvbmUgb3IgbW9yZSBrZXktdmFsdWUgcGFpcnMgd2hvc2Uga2V5IGlzXG4gICAgICogICBhIHByb3BlcnR5IGFuZCB2YWx1ZSBpcyB0aGUgbmV3IHZhbHVlIHRvIHNldCBmb3IgdGhhdCBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzZXRSZWFkT25seSBXaGVuIHRydWUsIGFueSBwcml2YXRlIHZhbHVlcyBzZXQgaW5cbiAgICAgKiAgIGBwcm9wc2Agd2lsbCBiZSBzZXQuIEJ5IGRlZmF1bHQsIGBzZXRQcm9wZXJ0aWVzYCB3aWxsIG5vdCBzZXRcbiAgICAgKiAgIGByZWFkT25seTogdHJ1ZWAgcm9vdCBwcm9wZXJ0aWVzLlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXRQcm9wZXJ0aWVzKHByb3BzLCBzZXRSZWFkT25seSkge1xuICAgICAgZm9yIChsZXQgcGF0aCBpbiBwcm9wcykge1xuICAgICAgICBpZiAoc2V0UmVhZE9ubHkgfHwgIXRoaXNbVFlQRVMuUkVBRF9PTkxZXSB8fCAhdGhpc1tUWVBFUy5SRUFEX09OTFldW3BhdGhdKSB7XG4gICAgICAgICAgLy9UT0RPKGtzY2hhYWYpOiBleHBsaWNpdGx5IGRpc2FsbG93IHBhdGhzIGluIHNldFByb3BlcnR5P1xuICAgICAgICAgIC8vIHdpbGRjYXJkIG9ic2VydmVycyBjdXJyZW50bHkgb25seSBwYXNzIHRoZSBmaXJzdCBjaGFuZ2VkIHBhdGhcbiAgICAgICAgICAvLyBpbiB0aGUgYGluZm9gIG9iamVjdCwgYW5kIHlvdSBjb3VsZCBkbyBzb21lIG9kZCB0aGluZ3MgYmF0Y2hpbmdcbiAgICAgICAgICAvLyBwYXRocywgZS5nLiB7J2Zvby5iYXInOiB7Li4ufSwgJ2Zvbyc6IG51bGx9XG4gICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHBhdGgsIHByb3BzW3BhdGhdLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgYFByb3BlcnR5QWNjZXNzb3JzYCBzbyB0aGF0IHByb3BlcnR5IGFjY2Vzc29yXG4gICAgICogc2lkZSBlZmZlY3RzIGFyZSBub3QgZW5hYmxlZCB1bnRpbCBhZnRlciBjbGllbnQgZG9tIGlzIGZ1bGx5IHJlYWR5LlxuICAgICAqIEFsc28gY2FsbHMgYF9mbHVzaENsaWVudHNgIGNhbGxiYWNrIHRvIGVuc3VyZSBjbGllbnQgZG9tIGlzIGVuYWJsZWRcbiAgICAgKiB0aGF0IHdhcyBub3QgZW5hYmxlZCBhcyBhIHJlc3VsdCBvZiBmbHVzaGluZyBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdGhhdCBgc3VwZXIucmVhZHkoKWAgaXMgbm90IGNhbGxlZCBoZXJlIGFzIGl0XG4gICAgICAvLyBpbW1lZGlhdGVseSB0dXJucyBvbiBhY2Nlc3NvcnMuIEluc3RlYWQsIHdlIHdhaXQgdW50aWwgYHJlYWR5Q2xpZW50c2BcbiAgICAgIC8vIHRvIGVuYWJsZSBhY2Nlc3NvcnMgdG8gcHJvdmlkZSBhIGd1YXJhbnRlZSB0aGF0IGNsaWVudHMgYXJlIHJlYWR5XG4gICAgICAvLyBiZWZvcmUgcHJvY2Vzc2luZyBhbnkgYWNjZXNzb3JzIHNpZGUgZWZmZWN0cy5cbiAgICAgIHRoaXMuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgLy8gSWYgbm8gZGF0YSB3YXMgcGVuZGluZywgYF9mbHVzaFByb3BlcnRpZXNgIHdpbGwgbm90IGBmbHVzaENsaWVudHNgXG4gICAgICAvLyBzbyBlbnN1cmUgdGhpcyBpcyBkb25lLlxuICAgICAgaWYgKCF0aGlzLl9fZGF0YUNsaWVudHNSZWFkeSkge1xuICAgICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIH1cbiAgICAgIC8vIEJlZm9yZSByZWFkeSwgY2xpZW50IG5vdGlmaWNhdGlvbnMgZG8gbm90IHRyaWdnZXIgX2ZsdXNoUHJvcGVydGllcy5cbiAgICAgIC8vIFRoZXJlZm9yZSBhIGZsdXNoIGlzIG5lY2Vzc2FyeSBoZXJlIGlmIGRhdGEgaGFzIGJlZW4gc2V0LlxuICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZykge1xuICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbXBsZW1lbnRzIGBQcm9wZXJ0eUFjY2Vzc29yc2AncyBwcm9wZXJ0aWVzIGNoYW5nZWQgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBSdW5zIGVhY2ggY2xhc3Mgb2YgZWZmZWN0cyBmb3IgdGhlIGJhdGNoIG9mIGNoYW5nZWQgcHJvcGVydGllcyBpblxuICAgICAqIGEgc3BlY2lmaWMgb3JkZXIgKGNvbXB1dGUsIHByb3BhZ2F0ZSwgcmVmbGVjdCwgb2JzZXJ2ZSwgbm90aWZ5KS5cbiAgICAgKlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIF9wcm9wZXJ0aWVzQ2hhbmdlZChjdXJyZW50UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMpIHtcbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIC8vIGxldCBjID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY2hhbmdlZFByb3BzIHx8IHt9KTtcbiAgICAgIC8vIHdpbmRvdy5kZWJ1ZyAmJiBjb25zb2xlLmdyb3VwKHRoaXMubG9jYWxOYW1lICsgJyMnICsgdGhpcy5pZCArICc6ICcgKyBjKTtcbiAgICAgIC8vIGlmICh3aW5kb3cuZGVidWcpIHsgZGVidWdnZXI7IH1cbiAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgIGxldCBoYXNQYXRocyA9IHRoaXMuX19kYXRhSGFzUGF0aHM7XG4gICAgICB0aGlzLl9fZGF0YUhhc1BhdGhzID0gZmFsc2U7XG4gICAgICAvLyBDb21wdXRlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkNvbXB1dGVkRWZmZWN0cyh0aGlzLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBDbGVhciBub3RpZnkgcHJvcGVydGllcyBwcmlvciB0byBwb3NzaWJsZSByZWVudHJ5IChwcm9wYWdhdGUsIG9ic2VydmUpLFxuICAgICAgLy8gYnV0IGFmdGVyIGNvbXB1dGluZyBlZmZlY3RzIGhhdmUgYSBjaGFuY2UgdG8gYWRkIHRvIHRoZW1cbiAgICAgIGxldCBub3RpZnlQcm9wcyA9IHRoaXMuX19kYXRhVG9Ob3RpZnk7XG4gICAgICB0aGlzLl9fZGF0YVRvTm90aWZ5ID0gbnVsbDtcbiAgICAgIC8vIFByb3BhZ2F0ZSBwcm9wZXJ0aWVzIHRvIGNsaWVudHNcbiAgICAgIHRoaXMuX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBGbHVzaCBjbGllbnRzXG4gICAgICB0aGlzLl9mbHVzaENsaWVudHMoKTtcbiAgICAgIC8vIFJlZmxlY3QgcHJvcGVydGllc1xuICAgICAgcnVuRWZmZWN0cyh0aGlzLCB0aGlzW1RZUEVTLlJFRkxFQ1RdLCBjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocyk7XG4gICAgICAvLyBPYnNlcnZlIHByb3BlcnRpZXNcbiAgICAgIHJ1bkVmZmVjdHModGhpcywgdGhpc1tUWVBFUy5PQlNFUlZFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgLy8gTm90aWZ5IHByb3BlcnRpZXMgdG8gaG9zdFxuICAgICAgaWYgKG5vdGlmeVByb3BzKSB7XG4gICAgICAgIHJ1bk5vdGlmeUVmZmVjdHModGhpcywgbm90aWZ5UHJvcHMsIGNoYW5nZWRQcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKTtcbiAgICAgIH1cbiAgICAgIC8vIENsZWFyIHRlbXBvcmFyeSBjYWNoZSBhdCBlbmQgb2YgdHVyblxuICAgICAgaWYgKHRoaXMuX19kYXRhQ291bnRlciA9PSAxKSB7XG4gICAgICAgIHRoaXMuX19kYXRhVGVtcCA9IHt9O1xuICAgICAgfVxuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgLy8gd2luZG93LmRlYnVnICYmIGNvbnNvbGUuZ3JvdXBFbmQodGhpcy5sb2NhbE5hbWUgKyAnIycgKyB0aGlzLmlkICsgJzogJyArIGMpO1xuICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwcm9wYWdhdGUgYW55IHByb3BlcnR5IGNoYW5nZXMgdG8gc3RhbXBlZCB0ZW1wbGF0ZSBub2Rlc1xuICAgICAqIG1hbmFnZWQgYnkgdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGNoYW5nZWRQcm9wcyBCYWcgb2YgY2hhbmdlZCBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Byb3BhZ2F0ZVByb3BlcnR5Q2hhbmdlcyhjaGFuZ2VkUHJvcHMsIG9sZFByb3BzLCBoYXNQYXRocykge1xuICAgICAgaWYgKHRoaXNbVFlQRVMuUFJPUEFHQVRFXSkge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRoaXNbVFlQRVMuUFJPUEFHQVRFXSwgY2hhbmdlZFByb3BzLCBvbGRQcm9wcywgaGFzUGF0aHMpO1xuICAgICAgfVxuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuX190ZW1wbGF0ZUluZm87XG4gICAgICB3aGlsZSAodGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHJ1bkVmZmVjdHModGhpcywgdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcyxcbiAgICAgICAgICBoYXNQYXRocywgdGVtcGxhdGVJbmZvLm5vZGVMaXN0KTtcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvLm5leHRUZW1wbGF0ZUluZm87XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWxpYXNlcyBvbmUgZGF0YSBwYXRoIGFzIGFub3RoZXIsIHN1Y2ggdGhhdCBwYXRoIG5vdGlmaWNhdGlvbnMgZnJvbSBvbmVcbiAgICAgKiBhcmUgcm91dGVkIHRvIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSB0byBUYXJnZXQgcGF0aCB0byBsaW5rLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBmcm9tIFNvdXJjZSBwYXRoIHRvIGxpbmsuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGxpbmtQYXRocyh0bywgZnJvbSkge1xuICAgICAgdG8gPSBub3JtYWxpemUodG8pO1xuICAgICAgZnJvbSA9IG5vcm1hbGl6ZShmcm9tKTtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzIHx8IHt9O1xuICAgICAgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1t0b10gPSBmcm9tO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBkYXRhIHBhdGggYWxpYXMgcHJldmlvdXNseSBlc3RhYmxpc2hlZCB3aXRoIGBfbGlua1BhdGhzYC5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoZSBwYXRoIHRvIHVubGluayBzaG91bGQgYmUgdGhlIHRhcmdldCAoYHRvYCkgdXNlZCB3aGVuXG4gICAgICogbGlua2luZyB0aGUgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBUYXJnZXQgcGF0aCB0byB1bmxpbmsuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVubGlua1BhdGhzKHBhdGgpIHtcbiAgICAgIHBhdGggPSBub3JtYWxpemUocGF0aCk7XG4gICAgICBpZiAodGhpcy5fX2RhdGFMaW5rZWRQYXRocykge1xuICAgICAgICBkZWxldGUgdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1twYXRoXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOb3RpZnkgdGhhdCBhbiBhcnJheSBoYXMgY2hhbmdlZC5cbiAgICAgKlxuICAgICAqIEV4YW1wbGU6XG4gICAgICpcbiAgICAgKiAgICAgdGhpcy5pdGVtcyA9IFsge25hbWU6ICdKaW0nfSwge25hbWU6ICdUb2RkJ30sIHtuYW1lOiAnQmlsbCd9IF07XG4gICAgICogICAgIC4uLlxuICAgICAqICAgICB0aGlzLml0ZW1zLnNwbGljZSgxLCAxLCB7bmFtZTogJ1NhbSd9KTtcbiAgICAgKiAgICAgdGhpcy5pdGVtcy5wdXNoKHtuYW1lOiAnQm9iJ30pO1xuICAgICAqICAgICB0aGlzLm5vdGlmeVNwbGljZXMoJ2l0ZW1zJywgW1xuICAgICAqICAgICAgIHsgaW5kZXg6IDEsIHJlbW92ZWQ6IFt7bmFtZTogJ1RvZGQnfV0sIGFkZGVkQ291bnQ6IDEsIG9iZWN0OiB0aGlzLml0ZW1zLCB0eXBlOiAnc3BsaWNlJyB9LFxuICAgICAqICAgICAgIHsgaW5kZXg6IDMsIHJlbW92ZWQ6IFtdLCBhZGRlZENvdW50OiAxLCBvYmplY3Q6IHRoaXMuaXRlbXMsIHR5cGU6ICdzcGxpY2UnfVxuICAgICAqICAgICBdKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc3BsaWNlcyBBcnJheSBvZiBzcGxpY2UgcmVjb3JkcyBpbmRpY2F0aW5nIG9yZGVyZWRcbiAgICAgKiAgIGNoYW5nZXMgdGhhdCBvY2N1cnJlZCB0byB0aGUgYXJyYXkuIEVhY2ggcmVjb3JkIHNob3VsZCBoYXZlIHRoZVxuICAgICAqICAgZm9sbG93aW5nIGZpZWxkczpcbiAgICAgKiAgICAqIGluZGV4OiBpbmRleCBhdCB3aGljaCB0aGUgY2hhbmdlIG9jY3VycmVkXG4gICAgICogICAgKiByZW1vdmVkOiBhcnJheSBvZiBpdGVtcyB0aGF0IHdlcmUgcmVtb3ZlZCBmcm9tIHRoaXMgaW5kZXhcbiAgICAgKiAgICAqIGFkZGVkQ291bnQ6IG51bWJlciBvZiBuZXcgaXRlbXMgYWRkZWQgYXQgdGhpcyBpbmRleFxuICAgICAqICAgICogb2JqZWN0OiBhIHJlZmVyZW5jZSB0byB0aGUgYXJyYXkgaW4gcXVlc3Rpb25cbiAgICAgKiAgICAqIHR5cGU6IHRoZSBzdHJpbmcgbGl0ZXJhbCAnc3BsaWNlJ1xuICAgICAqXG4gICAgICogICBOb3RlIHRoYXQgc3BsaWNlIHJlY29yZHMgX211c3RfIGJlIG5vcm1hbGl6ZWQgc3VjaCB0aGF0IHRoZXkgYXJlXG4gICAgICogICByZXBvcnRlZCBpbiBpbmRleCBvcmRlciAocmF3IHJlc3VsdHMgZnJvbSBgT2JqZWN0Lm9ic2VydmVgIGFyZSBub3RcbiAgICAgKiAgIG9yZGVyZWQgYW5kIG11c3QgYmUgbm9ybWFsaXplZC9tZXJnZWQgYmVmb3JlIG5vdGlmeWluZykuXG4gICAgICogQHB1YmxpY1xuICAgICovXG4gICAgbm90aWZ5U3BsaWNlcyhwYXRoLCBzcGxpY2VzKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBub3RpZnlTcGxpY2VzKHRoaXMsIGFycmF5LCBpbmZvLnBhdGgsIHNwbGljZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgcmVhZGluZyBhIHZhbHVlIGZyb20gYSBwYXRoLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgYW55IHBhcnQgaW4gdGhlIHBhdGggaXMgdW5kZWZpbmVkLCB0aGlzIG1ldGhvZCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW4gZGVyZWZlcmVuY2luZyB1bmRlZmluZWRcbiAgICAgKiBwYXRocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byByZWFkLiAgVGhlIHBhdGggbWF5IGJlIHNwZWNpZmllZCBhcyBhIHN0cmluZyAoZS5nLiBgZm9vLmJhci5iYXpgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgdXNlcnMuMTIubmFtZWAgb3IgYFsndXNlcnMnLCAxMiwgJ25hbWUnXWApLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSBhdCB0aGUgcGF0aCwgb3IgYHVuZGVmaW5lZGAgaWYgYW55IHBhcnQgb2YgdGhlIHBhdGhcbiAgICAgKiAgIGlzIHVuZGVmaW5lZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0KHBhdGgsIHJvb3QpIHtcbiAgICAgIHJldHVybiBnZXQkMChyb290IHx8IHRoaXMsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3Igc2V0dGluZyBhIHZhbHVlIHRvIGEgcGF0aCBhbmQgbm90aWZ5aW5nIGFueVxuICAgICAqIGVsZW1lbnRzIGJvdW5kIHRvIHRoZSBzYW1lIHBhdGguXG4gICAgICpcbiAgICAgKiBOb3RlLCBpZiBhbnkgcGFydCBpbiB0aGUgcGF0aCBleGNlcHQgZm9yIHRoZSBsYXN0IGlzIHVuZGVmaW5lZCxcbiAgICAgKiB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcgKHRoaXMgbWV0aG9kIGRvZXMgbm90IHRocm93IHdoZW5cbiAgICAgKiBkZXJlZmVyZW5jaW5nIHVuZGVmaW5lZCBwYXRocykuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyhzdHJpbmd8IUFycmF5PChzdHJpbmd8bnVtYmVyKT4pfSBwYXRoIFBhdGggdG8gdGhlIHZhbHVlXG4gICAgICogICB0byB3cml0ZS4gIFRoZSBwYXRoIG1heSBiZSBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKGUuZy4gYCdmb28uYmFyLmJheidgKVxuICAgICAqICAgb3IgYW4gYXJyYXkgb2YgcGF0aCBwYXJ0cyAoZS5nLiBgWydmb28uYmFyJywgJ2JheiddYCkuICBOb3RlIHRoYXRcbiAgICAgKiAgIGJyYWNrZXRlZCBleHByZXNzaW9ucyBhcmUgbm90IHN1cHBvcnRlZDsgc3RyaW5nLWJhc2VkIHBhdGggcGFydHNcbiAgICAgKiAgICptdXN0KiBiZSBzZXBhcmF0ZWQgYnkgZG90cy4gIE5vdGUgdGhhdCB3aGVuIGRlcmVmZXJlbmNpbmcgYXJyYXlcbiAgICAgKiAgIGluZGljZXMsIHRoZSBpbmRleCBtYXkgYmUgdXNlZCBhcyBhIGRvdHRlZCBwYXJ0IGRpcmVjdGx5XG4gICAgICogICAoZS5nLiBgJ3VzZXJzLjEyLm5hbWUnYCBvciBgWyd1c2VycycsIDEyLCAnbmFtZSddYCkuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcm9vdCBSb290IG9iamVjdCBmcm9tIHdoaWNoIHRoZSBwYXRoIGlzIGV2YWx1YXRlZC5cbiAgICAgKiAgIFdoZW4gc3BlY2lmaWVkLCBubyBub3RpZmljYXRpb24gd2lsbCBvY2N1ci5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBzZXQocGF0aCwgdmFsdWUsIHJvb3QpIHtcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIHNldCQwKHJvb3QsIHBhdGgsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghdGhpc1tUWVBFUy5SRUFEX09OTFldIHx8ICF0aGlzW1RZUEVTLlJFQURfT05MWV1bLyoqIEB0eXBlIHtzdHJpbmd9ICovKHBhdGgpXSkge1xuICAgICAgICAgIGlmICh0aGlzLl9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgocGF0aCwgdmFsdWUsIHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLl9pbnZhbGlkYXRlUHJvcGVydGllcygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZHMgaXRlbXMgb250byB0aGUgZW5kIG9mIHRoZSBhcnJheSBhdCB0aGUgcGF0aCBzcGVjaWZpZWQuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnB1c2hgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgbm90aWZpZXMgb3RoZXIgcGF0aHMgdG8gdGhlIHNhbWUgYXJyYXkgdGhhdCBhXG4gICAgICogc3BsaWNlIG9jY3VycmVkIHRvIHRoZSBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PHN0cmluZ3xudW1iZXI+fSBwYXRoIFBhdGggdG8gYXJyYXkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBwdXNoIG9udG8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwdXNoKHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBsZW4gPSBhcnJheS5sZW5ndGg7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucHVzaCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBsZW4sIGl0ZW1zLmxlbmd0aCwgW10pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgZW5kIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcG9wKHBhdGgpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGg6ICcnfTtcbiAgICAgIGxldCBhcnJheSA9IC8qKiBAdHlwZSB7QXJyYXl9ICovKGdldCQwKHRoaXMsIHBhdGgsIGluZm8pKTtcbiAgICAgIGxldCBoYWRMZW5ndGggPSBCb29sZWFuKGFycmF5Lmxlbmd0aCk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkucG9wKCk7XG4gICAgICBpZiAoaGFkTGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBhcnJheS5sZW5ndGgsIDAsIFtyZXRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3RhcnRpbmcgZnJvbSB0aGUgc3RhcnQgaW5kZXggc3BlY2lmaWVkLCByZW1vdmVzIDAgb3IgbW9yZSBpdGVtc1xuICAgICAqIGZyb20gdGhlIGFycmF5IGFuZCBpbnNlcnRzIDAgb3IgbW9yZSBuZXcgaXRlbXMgaW4gdGhlaXIgcGxhY2UuXG4gICAgICpcbiAgICAgKiBUaGUgYXJndW1lbnRzIGFmdGVyIGBwYXRoYCBhbmQgcmV0dXJuIHZhbHVlIG1hdGNoIHRoYXQgb2ZcbiAgICAgKiBgQXJyYXkucHJvdG90eXBlLnNwbGljZWAuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBub3RpZmllcyBvdGhlciBwYXRocyB0byB0aGUgc2FtZSBhcnJheSB0aGF0IGFcbiAgICAgKiBzcGxpY2Ugb2NjdXJyZWQgdG8gdGhlIGFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmcgfCAhQXJyYXk8c3RyaW5nfG51bWJlcj59IHBhdGggUGF0aCB0byBhcnJheS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgSW5kZXggZnJvbSB3aGljaCB0byBzdGFydCByZW1vdmluZy9pbnNlcnRpbmcuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGV0ZUNvdW50IE51bWJlciBvZiBpdGVtcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHsuLi4qfSBpdGVtcyBJdGVtcyB0byBpbnNlcnQgaW50byBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gQXJyYXkgb2YgcmVtb3ZlZCBpdGVtcy5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3BsaWNlKHBhdGgsIHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpIHtcbiAgICAgIGxldCBpbmZvID0ge3BhdGggOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICAvLyBOb3JtYWxpemUgZmFuY3kgbmF0aXZlIHNwbGljZSBoYW5kbGluZyBvZiBjcmF6eSBzdGFydCB2YWx1ZXNcbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSBhcnJheS5sZW5ndGggLSBNYXRoLmZsb29yKC1zdGFydCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGFydCA9IE1hdGguZmxvb3Ioc3RhcnQpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdGFydCkge1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9XG4gICAgICBsZXQgcmV0ID0gYXJyYXkuc3BsaWNlKHN0YXJ0LCBkZWxldGVDb3VudCwgLi4uaXRlbXMpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCB8fCByZXQubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCBzdGFydCwgaXRlbXMubGVuZ3RoLCByZXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSB0aGUgYmVnaW5uaW5nIG9mIGFycmF5IGF0IHRoZSBwYXRoIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIFRoZSBhcmd1bWVudHMgYWZ0ZXIgYHBhdGhgIGFuZCByZXR1cm4gdmFsdWUgbWF0Y2ggdGhhdCBvZlxuICAgICAqIGBBcnJheS5wcm90b3R5cGUucG9wYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEByZXR1cm4geyp9IEl0ZW0gdGhhdCB3YXMgcmVtb3ZlZC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2hpZnQocGF0aCkge1xuICAgICAgbGV0IGluZm8gPSB7cGF0aDogJyd9O1xuICAgICAgbGV0IGFycmF5ID0gLyoqIEB0eXBlIHtBcnJheX0gKi8oZ2V0JDAodGhpcywgcGF0aCwgaW5mbykpO1xuICAgICAgbGV0IGhhZExlbmd0aCA9IEJvb2xlYW4oYXJyYXkubGVuZ3RoKTtcbiAgICAgIGxldCByZXQgPSBhcnJheS5zaGlmdCgpO1xuICAgICAgaWYgKGhhZExlbmd0aCkge1xuICAgICAgICBub3RpZnlTcGxpY2UodGhpcywgYXJyYXksIGluZm8ucGF0aCwgMCwgMCwgW3JldF0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGl0ZW1zIG9udG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgYXJyYXkgYXQgdGhlIHBhdGggc3BlY2lmaWVkLlxuICAgICAqXG4gICAgICogVGhlIGFyZ3VtZW50cyBhZnRlciBgcGF0aGAgYW5kIHJldHVybiB2YWx1ZSBtYXRjaCB0aGF0IG9mXG4gICAgICogYEFycmF5LnByb3RvdHlwZS5wdXNoYC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG5vdGlmaWVzIG90aGVyIHBhdGhzIHRvIHRoZSBzYW1lIGFycmF5IHRoYXQgYVxuICAgICAqIHNwbGljZSBvY2N1cnJlZCB0byB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZyB8ICFBcnJheTxzdHJpbmd8bnVtYmVyPn0gcGF0aCBQYXRoIHRvIGFycmF5LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gaXRlbXMgSXRlbXMgdG8gaW5zZXJ0IGluZm8gYXJyYXlcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IE5ldyBsZW5ndGggb2YgdGhlIGFycmF5LlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB1bnNoaWZ0KHBhdGgsIC4uLml0ZW1zKSB7XG4gICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICBsZXQgYXJyYXkgPSAvKiogQHR5cGUge0FycmF5fSAqLyhnZXQkMCh0aGlzLCBwYXRoLCBpbmZvKSk7XG4gICAgICBsZXQgcmV0ID0gYXJyYXkudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgICBpZiAoaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIG5vdGlmeVNwbGljZSh0aGlzLCBhcnJheSwgaW5mby5wYXRoLCAwLCBpdGVtcy5sZW5ndGgsIFtdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTm90aWZ5IHRoYXQgYSBwYXRoIGhhcyBjaGFuZ2VkLlxuICAgICAqXG4gICAgICogRXhhbXBsZTpcbiAgICAgKlxuICAgICAqICAgICB0aGlzLml0ZW0udXNlci5uYW1lID0gJ0JvYic7XG4gICAgICogICAgIHRoaXMubm90aWZ5UGF0aCgnaXRlbS51c2VyLm5hbWUnKTtcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIFBhdGggdGhhdCBzaG91bGQgYmUgbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHsqPX0gdmFsdWUgVmFsdWUgYXQgdGhlIHBhdGggKG9wdGlvbmFsKS5cbiAgICAgKiBAcHVibGljXG4gICAgKi9cbiAgICBub3RpZnlQYXRoKHBhdGgsIHZhbHVlKSB7XG4gICAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICAgIGxldCBwcm9wUGF0aDtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgLy8gR2V0IHZhbHVlIGlmIG5vdCBzdXBwbGllZFxuICAgICAgICBsZXQgaW5mbyA9IHtwYXRoOiAnJ307XG4gICAgICAgIHZhbHVlID0gZ2V0JDAodGhpcywgcGF0aCwgaW5mbyk7XG4gICAgICAgIHByb3BQYXRoID0gaW5mby5wYXRoO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHBhdGgpKSB7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBwYXRoIGlmIG5lZWRlZFxuICAgICAgICBwcm9wUGF0aCA9IG5vcm1hbGl6ZShwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BQYXRoID0gLyoqIEB0eXBle3N0cmluZ30gKi8ocGF0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKHByb3BQYXRoLCB2YWx1ZSwgdHJ1ZSwgdHJ1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUmVhZE9ubHlQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBwcm90ZWN0ZWRTZXR0ZXIgQ3JlYXRlcyBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyXG4gICAgICogICB3aGVuIGB0cnVlYC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlYWRPbmx5UHJvcGVydHkocHJvcGVydHksIHByb3RlY3RlZFNldHRlcikge1xuICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFQURfT05MWSk7XG4gICAgICBpZiAocHJvdGVjdGVkU2V0dGVyKSB7XG4gICAgICAgIHRoaXNbJ19zZXQnICsgdXBwZXIocHJvcGVydHkpXSA9IC8qKiBAdGhpcyB7UHJvcGVydHlFZmZlY3RzfSAqL2Z1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlUHJvcGVydHlPYnNlcnZlcmAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG9ic2VydmVyIG1ldGhvZCB0byBjYWxsXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZHluYW1pY0ZuIFdoZXRoZXIgdGhlIG1ldGhvZCBuYW1lIHNob3VsZCBiZSBpbmNsdWRlZCBhc1xuICAgICAqICAgYSBkZXBlbmRlbmN5IHRvIHRoZSBlZmZlY3QuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jcmVhdGVQcm9wZXJ0eU9ic2VydmVyKHByb3BlcnR5LCBtZXRob2ROYW1lLCBkeW5hbWljRm4pIHtcbiAgICAgIGxldCBpbmZvID0geyBwcm9wZXJ0eSwgbWV0aG9kTmFtZSwgZHluYW1pY0ZuOiBCb29sZWFuKGR5bmFtaWNGbikgfTtcbiAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCBUWVBFUy5PQlNFUlZFLCB7XG4gICAgICAgIGZuOiBydW5PYnNlcnZlckVmZmVjdCwgaW5mbywgdHJpZ2dlcjoge25hbWU6IHByb3BlcnR5fVxuICAgICAgfSk7XG4gICAgICBpZiAoZHluYW1pY0ZuKSB7XG4gICAgICAgIHRoaXMuX2FkZFByb3BlcnR5RWZmZWN0KG1ldGhvZE5hbWUsIFRZUEVTLk9CU0VSVkUsIHtcbiAgICAgICAgICBmbjogcnVuT2JzZXJ2ZXJFZmZlY3QsIGluZm8sIHRyaWdnZXI6IHtuYW1lOiBtZXRob2ROYW1lfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgY3JlYXRlTWV0aG9kT2JzZXJ2ZXJgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlTWV0aG9kT2JzZXJ2ZXIoZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgb2JzZXJ2ZXIgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuT0JTRVJWRSwgcnVuTWV0aG9kRWZmZWN0LCBudWxsLCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZU5vdGlmeWluZ1Byb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICB0aGlzLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgVFlQRVMuTk9USUZZLCB7XG4gICAgICAgIGZuOiBydW5Ob3RpZnlFZmZlY3QsXG4gICAgICAgIGluZm86IHtcbiAgICAgICAgICBldmVudE5hbWU6IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KSArICctY2hhbmdlZCcsXG4gICAgICAgICAgcHJvcGVydHk6IHByb3BlcnR5XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gc3RhdGljIGBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eWAgQVBJIGJ1dCBjYW4gYmUgY2FsbGVkIG9uXG4gICAgICogYW4gaW5zdGFuY2UgdG8gYWRkIGVmZmVjdHMgYXQgcnVudGltZS4gIFNlZSB0aGF0IG1ldGhvZCBmb3JcbiAgICAgKiBmdWxsIEFQSSBkb2NzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KSB7XG4gICAgICBsZXQgYXR0ciA9IENhc2VNYXAuY2FtZWxUb0Rhc2hDYXNlKHByb3BlcnR5KTtcbiAgICAgIGlmIChhdHRyWzBdID09PSAnLScpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQcm9wZXJ0eSAnICsgcHJvcGVydHkgKyAnIGNhbm5vdCBiZSByZWZsZWN0ZWQgdG8gYXR0cmlidXRlICcgK1xuICAgICAgICAgIGF0dHIgKyAnIGJlY2F1c2UgXCItXCIgaXMgbm90IGEgdmFsaWQgc3RhcnRpbmcgYXR0cmlidXRlIG5hbWUuIFVzZSBhIGxvd2VyY2FzZSBmaXJzdCBsZXR0ZXIgZm9yIHRoZSBwcm9wZXJ0eSB0aGlzZWFkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fYWRkUHJvcGVydHlFZmZlY3QocHJvcGVydHksIFRZUEVTLlJFRkxFQ1QsIHtcbiAgICAgICAgICBmbjogcnVuUmVmbGVjdEVmZmVjdCxcbiAgICAgICAgICBpbmZvOiB7XG4gICAgICAgICAgICBhdHRyTmFtZTogYXR0clxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBzdGF0aWMgYGNyZWF0ZUNvbXB1dGVkUHJvcGVydHlgIEFQSSBidXQgY2FuIGJlIGNhbGxlZCBvblxuICAgICAqIGFuIGluc3RhbmNlIHRvIGFkZCBlZmZlY3RzIGF0IHJ1bnRpbWUuICBTZWUgdGhhdCBtZXRob2QgZm9yXG4gICAgICogZnVsbCBBUEkgZG9jcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZ1xuICAgICAqICAgd2hldGhlciBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICBsZXQgc2lnID0gcGFyc2VNZXRob2QoZXhwcmVzc2lvbik7XG4gICAgICBpZiAoIXNpZykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYWxmb3JtZWQgY29tcHV0ZWQgZXhwcmVzc2lvbiAnXCIgKyBleHByZXNzaW9uICsgXCInXCIpO1xuICAgICAgfVxuICAgICAgY3JlYXRlTWV0aG9kRWZmZWN0KHRoaXMsIHNpZywgVFlQRVMuQ09NUFVURSwgcnVuQ29tcHV0ZWRFZmZlY3QsIHByb3BlcnR5LCBkeW5hbWljRm4pO1xuICAgIH1cblxuICAgIC8vIC0tIHN0YXRpYyBjbGFzcyBtZXRob2RzIC0tLS0tLS0tLS0tLVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyBhbiBhY2Nlc3NvciBleGlzdHMgZm9yIHRoZSBzcGVjaWZpZWQgcHJvcGVydHksIGFuZCBhZGRzXG4gICAgICogdG8gYSBsaXN0IG9mIFwicHJvcGVydHkgZWZmZWN0c1wiIHRoYXQgd2lsbCBydW4gd2hlbiB0aGUgYWNjZXNzb3IgZm9yXG4gICAgICogdGhlIHNwZWNpZmllZCBwcm9wZXJ0eSBpcyBzZXQuICBFZmZlY3RzIGFyZSBncm91cGVkIGJ5IFwidHlwZVwiLCB3aGljaFxuICAgICAqIHJvdWdobHkgY29ycmVzcG9uZHMgdG8gYSBwaGFzZSBpbiBlZmZlY3QgcHJvY2Vzc2luZy4gIFRoZSBlZmZlY3RcbiAgICAgKiBtZXRhZGF0YSBzaG91bGQgYmUgaW4gdGhlIGZvbGxvd2luZyBmb3JtOlxuICAgICAqXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBmbjogZWZmZWN0RnVuY3Rpb24sIC8vIFJlZmVyZW5jZSB0byBmdW5jdGlvbiB0byBjYWxsIHRvIHBlcmZvcm0gZWZmZWN0XG4gICAgICogICAgICAgaW5mbzogeyAuLi4gfSAgICAgICAvLyBFZmZlY3QgbWV0YWRhdGEgcGFzc2VkIHRvIGZ1bmN0aW9uXG4gICAgICogICAgICAgdHJpZ2dlcjogeyAgICAgICAgICAvLyBPcHRpb25hbCB0cmlnZ2VyaW5nIG1ldGFkYXRhOyBpZiBub3QgcHJvdmlkZWRcbiAgICAgKiAgICAgICAgIG5hbWU6IHN0cmluZyAgICAgIC8vIHRoZSBwcm9wZXJ0eSBpcyB0cmVhdGVkIGFzIGEgd2lsZGNhcmRcbiAgICAgKiAgICAgICAgIHN0cnVjdHVyZWQ6IGJvb2xlYW5cbiAgICAgKiAgICAgICAgIHdpbGRjYXJkOiBib29sZWFuXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBFZmZlY3RzIGFyZSBjYWxsZWQgZnJvbSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBpbiB0aGUgZm9sbG93aW5nIG9yZGVyIGJ5XG4gICAgICogdHlwZTpcbiAgICAgKlxuICAgICAqIDEuIENPTVBVVEVcbiAgICAgKiAyLiBQUk9QQUdBVEVcbiAgICAgKiAzLiBSRUZMRUNUXG4gICAgICogNC4gT0JTRVJWRVxuICAgICAqIDUuIE5PVElGWVxuICAgICAqXG4gICAgICogRWZmZWN0IGZ1bmN0aW9ucyBhcmUgY2FsbGVkIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gICAgICpcbiAgICAgKiAgICAgZWZmZWN0RnVuY3Rpb24oaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBpbmZvLCBoYXNQYXRocylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBFZmZlY3QgdHlwZSwgZnJvbSB0aGlzLlBST1BFUlRZX0VGRkVDVF9UWVBFU1xuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gZWZmZWN0IEVmZmVjdCBtZXRhZGF0YSBvYmplY3RcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGFkZFByb3BlcnR5RWZmZWN0KHByb3BlcnR5LCB0eXBlLCBlZmZlY3QpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdChwcm9wZXJ0eSwgdHlwZSwgZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2luZ2xlLXByb3BlcnR5IG9ic2VydmVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2Ygb2JzZXJ2ZXIgbWV0aG9kIHRvIGNhbGxcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkeW5hbWljRm4gV2hldGhlciB0aGUgbWV0aG9kIG5hbWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFzXG4gICAgICogICBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVByb3BlcnR5T2JzZXJ2ZXIocHJvcGVydHksIG1ldGhvZE5hbWUsIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG11bHRpLXByb3BlcnR5IFwibWV0aG9kIG9ic2VydmVyXCIgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gICAgICogZXhwcmVzc2lvbiwgd2hpY2ggc2hvdWxkIGJlIGEgc3RyaW5nIGluIHRoZSBmb3JtIG9mIGEgbm9ybWFsIEphdmFzY3JpcHRcbiAgICAgKiBmdW5jdGlvbiBzaWduYXR1cmU6IGAnbWV0aG9kTmFtZShhcmcxLCBbLi4uLCBhcmduXSknYC4gIEVhY2ggYXJndW1lbnRcbiAgICAgKiBzaG91bGQgY29ycmVzcG9uZCB0byBhIHByb3BlcnR5IG9yIHBhdGggaW4gdGhlIGNvbnRleHQgb2YgdGhpc1xuICAgICAqIHByb3RvdHlwZSAob3IgaW5zdGFuY2UpLCBvciBtYXkgYmUgYSBsaXRlcmFsIHN0cmluZyBvciBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXhwcmVzc2lvbiBNZXRob2QgZXhwcmVzc2lvblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbnxPYmplY3Q9fSBkeW5hbWljRm4gQm9vbGVhbiBvciBvYmplY3QgbWFwIGluZGljYXRpbmdcbiAgICAgKiAgIHdoZXRoZXIgbWV0aG9kIG5hbWVzIHNob3VsZCBiZSBpbmNsdWRlZCBhcyBhIGRlcGVuZGVuY3kgdG8gdGhlIGVmZmVjdC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbikge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZU1ldGhvZE9ic2VydmVyKGV4cHJlc3Npb24sIGR5bmFtaWNGbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2F1c2VzIHRoZSBzZXR0ZXIgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eSB0byBkaXNwYXRjaCBgPHByb3BlcnR5Pi1jaGFuZ2VkYFxuICAgICAqIGV2ZW50cyB0byBub3RpZnkgb2YgY2hhbmdlcyB0byB0aGUgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlTm90aWZ5aW5nUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHJlYWQtb25seSBhY2Nlc3NvciBmb3IgdGhlIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVG8gc2V0IHRoZSBwcm9wZXJ0eSwgdXNlIHRoZSBwcm90ZWN0ZWQgYF9zZXRQcm9wZXJ0eWAgQVBJLlxuICAgICAqIFRvIGNyZWF0ZSBhIGN1c3RvbSBwcm90ZWN0ZWQgc2V0dGVyIChlLmcuIGBfc2V0TXlQcm9wKClgIGZvclxuICAgICAqIHByb3BlcnR5IGBteVByb3BgKSwgcGFzcyBgdHJ1ZWAgZm9yIGBwcm90ZWN0ZWRTZXR0ZXJgLlxuICAgICAqXG4gICAgICogTm90ZSwgaWYgdGhlIHByb3BlcnR5IHdpbGwgaGF2ZSBvdGhlciBwcm9wZXJ0eSBlZmZlY3RzLCB0aGlzIG1ldGhvZFxuICAgICAqIHNob3VsZCBiZSBjYWxsZWQgZmlyc3QsIGJlZm9yZSBhZGRpbmcgb3RoZXIgZWZmZWN0cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gcHJvdGVjdGVkU2V0dGVyIENyZWF0ZXMgYSBjdXN0b20gcHJvdGVjdGVkIHNldHRlclxuICAgICAqICAgd2hlbiBgdHJ1ZWAuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpIHtcbiAgICAgIHRoaXMucHJvdG90eXBlLl9jcmVhdGVSZWFkT25seVByb3BlcnR5KHByb3BlcnR5LCBwcm90ZWN0ZWRTZXR0ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhdXNlcyB0aGUgc2V0dGVyIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkgdG8gcmVmbGVjdCB0aGUgcHJvcGVydHkgdmFsdWVcbiAgICAgKiB0byBhIChkYXNoLWNhc2VkKSBhdHRyaWJ1dGUgb2YgdGhlIHNhbWUgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVSZWZsZWN0ZWRQcm9wZXJ0eShwcm9wZXJ0eSkge1xuICAgICAgdGhpcy5wcm90b3R5cGUuX2NyZWF0ZVJlZmxlY3RlZFByb3BlcnR5KHByb3BlcnR5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY29tcHV0ZWQgcHJvcGVydHkgd2hvc2UgdmFsdWUgaXMgc2V0IHRvIHRoZSByZXN1bHQgb2YgdGhlXG4gICAgICogbWV0aG9kIGRlc2NyaWJlZCBieSB0aGUgZ2l2ZW4gYGV4cHJlc3Npb25gIGVhY2ggdGltZSBvbmUgb3IgbW9yZVxuICAgICAqIGFyZ3VtZW50cyB0byB0aGUgbWV0aG9kIGNoYW5nZXMuICBUaGUgZXhwcmVzc2lvbiBzaG91bGQgYmUgYSBzdHJpbmdcbiAgICAgKiBpbiB0aGUgZm9ybSBvZiBhIG5vcm1hbCBKYXZhc2NyaXB0IGZ1bmN0aW9uIHNpZ25hdHVyZTpcbiAgICAgKiBgJ21ldGhvZE5hbWUoYXJnMSwgWy4uLiwgYXJnbl0pJ2BcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBOYW1lIG9mIGNvbXB1dGVkIHByb3BlcnR5IHRvIHNldFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIE1ldGhvZCBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHtib29sZWFufE9iamVjdD19IGR5bmFtaWNGbiBCb29sZWFuIG9yIG9iamVjdCBtYXAgaW5kaWNhdGluZyB3aGV0aGVyXG4gICAgICogICBtZXRob2QgbmFtZXMgc2hvdWxkIGJlIGluY2x1ZGVkIGFzIGEgZGVwZW5kZW5jeSB0byB0aGUgZWZmZWN0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKSB7XG4gICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlQ29tcHV0ZWRQcm9wZXJ0eShwcm9wZXJ0eSwgZXhwcmVzc2lvbiwgZHluYW1pY0ZuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIHRvIGVuc3VyZSBiaW5kaW5nIGVmZmVjdHMgYXJlIGNyZWF0ZWRcbiAgICAgKiBmb3IgdGhlbSwgYW5kIHRoZW4gZW5zdXJlcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIGNyZWF0ZWQgZm9yIGFueVxuICAgICAqIGRlcGVuZGVudCBwcm9wZXJ0aWVzIGluIHRoZSB0ZW1wbGF0ZS4gIEJpbmRpbmcgZWZmZWN0cyBmb3IgYm91bmRcbiAgICAgKiB0ZW1wbGF0ZXMgYXJlIHN0b3JlZCBpbiBhIGxpbmtlZCBsaXN0IG9uIHRoZSBpbnN0YW5jZSBzbyB0aGF0XG4gICAgICogdGVtcGxhdGVzIGNhbiBiZSBlZmZpY2llbnRseSBzdGFtcGVkIGFuZCB1bnN0YW1wZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIGNvbnRhaW5pbmcgYmluZGluZ1xuICAgICAqICAgYmluZGluZ3NcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRlbXBsYXRlIG1ldGFkYXRhIG9iamVjdFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgYmluZFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm90b3R5cGUuX2JpbmRUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gLS0gYmluZGluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIHN0YXRpYyBgYmluZFRlbXBsYXRlYCBBUEkgYnV0IGNhbiBiZSBjYWxsZWQgb25cbiAgICAgKiBhbiBpbnN0YW5jZSB0byBhZGQgZWZmZWN0cyBhdCBydW50aW1lLiAgU2VlIHRoYXQgbWV0aG9kIGZvclxuICAgICAqIGZ1bGwgQVBJIGRvY3MuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBtYXkgYmUgY2FsbGVkIG9uIHRoZSBwcm90b3R5cGUgKGZvciBwcm90b3R5cGljYWwgdGVtcGxhdGVcbiAgICAgKiBiaW5kaW5nLCB0byBhdm9pZCBjcmVhdGluZyBhY2Nlc3NvcnMgZXZlcnkgaW5zdGFuY2UpIG9uY2UgcGVyIHByb3RvdHlwZSxcbiAgICAgKiBhbmQgd2lsbCBiZSBjYWxsZWQgd2l0aCBgcnVudGltZUJpbmRpbmc6IHRydWVgIGJ5IGBfc3RhbXBUZW1wbGF0ZWAgdG9cbiAgICAgKiBjcmVhdGUgYW5kIGxpbmsgYW4gaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlIG1ldGFkYXRhIGFzc29jaWF0ZWQgd2l0aCBhXG4gICAgICogcGFydGljdWxhciBzdGFtcGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgY29udGFpbmluZyBiaW5kaW5nXG4gICAgICogICBiaW5kaW5nc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGluc3RhbmNlQmluZGluZyBXaGVuIGZhbHNlIChkZWZhdWx0KSwgcGVyZm9ybXNcbiAgICAgKiAgIFwicHJvdG90eXBpY2FsXCIgYmluZGluZyBvZiB0aGUgdGVtcGxhdGUgYW5kIG92ZXJ3cml0ZXMgYW55IHByZXZpb3VzbHlcbiAgICAgKiAgIGJvdW5kIHRlbXBsYXRlIGZvciB0aGUgY2xhc3MuIFdoZW4gdHJ1ZSAoYXMgcGFzc2VkIGZyb21cbiAgICAgKiAgIGBfc3RhbXBUZW1wbGF0ZWApLCB0aGUgdGVtcGxhdGUgaW5mbyBpcyBpbnN0YW5jZWQgYW5kIGxpbmtlZCBpbnRvXG4gICAgICogICB0aGUgbGlzdCBvZiBib3VuZCB0ZW1wbGF0ZXMuXG4gICAgICogQHJldHVybiB7IVRlbXBsYXRlSW5mb30gVGVtcGxhdGUgbWV0YWRhdGEgb2JqZWN0OyBmb3IgYHJ1bnRpbWVCaW5kaW5nYCxcbiAgICAgKiAgIHRoaXMgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIHByb3RvdHlwaWNhbCB0ZW1wbGF0ZSBpbmZvXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIGluc3RhbmNlQmluZGluZykge1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IHdhc1ByZUJvdW5kID0gdGhpcy5fX3RlbXBsYXRlSW5mbyA9PSB0ZW1wbGF0ZUluZm87XG4gICAgICAvLyBPcHRpbWl6YXRpb246IHNpbmNlIHRoaXMgaXMgY2FsbGVkIHR3aWNlIGZvciBwcm90by1ib3VuZCB0ZW1wbGF0ZXMsXG4gICAgICAvLyBkb24ndCBhdHRlbXB0IHRvIHJlY3JlYXRlIGFjY2Vzc29ycyBpZiB0aGlzIHRlbXBsYXRlIHdhcyBwcmUtYm91bmRcbiAgICAgIGlmICghd2FzUHJlQm91bmQpIHtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0ZW1wbGF0ZUluZm8ucHJvcGVydHlFZmZlY3RzKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlQmluZGluZykge1xuICAgICAgICAvLyBGb3IgaW5zdGFuY2UtdGltZSBiaW5kaW5nLCBjcmVhdGUgaW5zdGFuY2Ugb2YgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgICAgLy8gYW5kIGxpbmsgaW50byBsaXN0IG9mIHRlbXBsYXRlcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyhPYmplY3QuY3JlYXRlKHRlbXBsYXRlSW5mbykpO1xuICAgICAgICB0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQgPSB3YXNQcmVCb3VuZDtcbiAgICAgICAgaWYgKCF3YXNQcmVCb3VuZCAmJiB0aGlzLl9fdGVtcGxhdGVJbmZvKSB7XG4gICAgICAgICAgbGV0IGxhc3QgPSB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCB8fCB0aGlzLl9fdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID0gbGFzdC5uZXh0VGVtcGxhdGVJbmZvID0gdGVtcGxhdGVJbmZvO1xuICAgICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IGxhc3Q7XG4gICAgICAgICAgcmV0dXJuIHRlbXBsYXRlSW5mbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX190ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIHByb3BlcnR5IGVmZmVjdCB0byB0aGUgZ2l2ZW4gdGVtcGxhdGUgbWV0YWRhdGEsIHdoaWNoIGlzIHJ1blxuICAgICAqIGF0IHRoZSBcInByb3BhZ2F0ZVwiIHN0YWdlIG9mIGBfcHJvcGVydGllc0NoYW5nZWRgIHdoZW4gdGhlIHRlbXBsYXRlXG4gICAgICogaGFzIGJlZW4gYm91bmQgdG8gdGhlIGVsZW1lbnQgdmlhIGBfYmluZFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgZWZmZWN0YCBvYmplY3Qgc2hvdWxkIG1hdGNoIHRoZSBmb3JtYXQgaW4gYF9hZGRQcm9wZXJ0eUVmZmVjdGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIHRvIGFkZCBlZmZlY3QgdG9cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0aGF0IHNob3VsZCB0cmlnZ2VyIHRoZSBlZmZlY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdD19IGVmZmVjdCBFZmZlY3QgbWV0YWRhdGEgb2JqZWN0XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHN0YXRpYyBfYWRkVGVtcGxhdGVQcm9wZXJ0eUVmZmVjdCh0ZW1wbGF0ZUluZm8sIHByb3AsIGVmZmVjdCkge1xuICAgICAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzIHx8IHt9O1xuICAgICAgaG9zdFByb3BzW3Byb3BdID0gdHJ1ZTtcbiAgICAgIGxldCBlZmZlY3RzID0gdGVtcGxhdGVJbmZvLnByb3BlcnR5RWZmZWN0cyA9IHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMgfHwge307XG4gICAgICBsZXQgcHJvcEVmZmVjdHMgPSBlZmZlY3RzW3Byb3BdID0gZWZmZWN0c1twcm9wXSB8fCBbXTtcbiAgICAgIHByb3BFZmZlY3RzLnB1c2goZWZmZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTdGFtcHMgdGhlIHByb3ZpZGVkIHRlbXBsYXRlIGFuZCBwZXJmb3JtcyBpbnN0YW5jZS10aW1lIHNldHVwIGZvclxuICAgICAqIFBvbHltZXIgdGVtcGxhdGUgZmVhdHVyZXMsIGluY2x1ZGluZyBkYXRhIGJpbmRpbmdzLCBkZWNsYXJhdGl2ZSBldmVudFxuICAgICAqIGxpc3RlbmVycywgYW5kIHRoZSBgdGhpcy4kYCBtYXAgb2YgYGlkYCdzIHRvIG5vZGVzLiAgQSBkb2N1bWVudCBmcmFnbWVudFxuICAgICAqIGlzIHJldHVybmVkIGNvbnRhaW5pbmcgdGhlIHN0YW1wZWQgRE9NLCByZWFkeSBmb3IgaW5zZXJ0aW9uIGludG8gdGhlXG4gICAgICogRE9NLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCBtb3JlIHRoYW4gb25jZTsgaG93ZXZlciBub3RlIHRoYXQgZHVlIHRvXG4gICAgICogYHNoYWR5Y3NzYCBwb2x5ZmlsbCBsaW1pdGF0aW9ucywgb25seSBzdHlsZXMgZnJvbSB0ZW1wbGF0ZXMgcHJlcGFyZWRcbiAgICAgKiB1c2luZyBgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlYCB3aWxsIGJlIGNvcnJlY3RseSBwb2x5ZmlsbGVkIChzY29wZWRcbiAgICAgKiB0byB0aGUgc2hhZG93IHJvb3QgYW5kIHN1cHBvcnQgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzKSwgYW5kIG5vdGUgdGhhdFxuICAgICAqIGBTaGFkeUNTUy5wcmVwYXJlVGVtcGxhdGVgIG1heSBvbmx5IGJlIGNhbGxlZCBvbmNlIHBlciBlbGVtZW50LiBBcyBzdWNoLFxuICAgICAqIGFueSBzdHlsZXMgcmVxdWlyZWQgYnkgaW4gcnVudGltZS1zdGFtcGVkIHRlbXBsYXRlcyBtdXN0IGJlIGluY2x1ZGVkXG4gICAgICogaW4gdGhlIG1haW4gZWxlbWVudCB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIFRlbXBsYXRlIHRvIHN0YW1wXG4gICAgICogQHJldHVybiB7IVN0YW1wZWRUZW1wbGF0ZX0gQ2xvbmVkIHRlbXBsYXRlIGNvbnRlbnRcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgICAgIC8vIEVuc3VyZXMgdGhhdCBjcmVhdGVkIGRvbSBpcyBgX2VucXVldWVDbGllbnRgJ2QgdG8gdGhpcyBlbGVtZW50IHNvXG4gICAgICAvLyB0aGF0IGl0IGNhbiBiZSBmbHVzaGVkIG9uIG5leHQgY2FsbCB0byBgX2ZsdXNoUHJvcGVydGllc2BcbiAgICAgIGhvc3RTdGFjay5iZWdpbkhvc3RpbmcodGhpcyk7XG4gICAgICBsZXQgZG9tID0gc3VwZXIuX3N0YW1wVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgaG9zdFN0YWNrLmVuZEhvc3RpbmcodGhpcyk7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHshVGVtcGxhdGVJbmZvfSAqLyh0aGlzLl9iaW5kVGVtcGxhdGUodGVtcGxhdGUsIHRydWUpKTtcbiAgICAgIC8vIEFkZCB0ZW1wbGF0ZS1pbnN0YW5jZS1zcGVjaWZpYyBkYXRhIHRvIGluc3RhbmNlZCB0ZW1wbGF0ZUluZm9cbiAgICAgIHRlbXBsYXRlSW5mby5ub2RlTGlzdCA9IGRvbS5ub2RlTGlzdDtcbiAgICAgIC8vIENhcHR1cmUgY2hpbGQgbm9kZXMgdG8gYWxsb3cgdW5zdGFtcGluZyBvZiBub24tcHJvdG90eXBpY2FsIHRlbXBsYXRlc1xuICAgICAgaWYgKCF0ZW1wbGF0ZUluZm8ud2FzUHJlQm91bmQpIHtcbiAgICAgICAgbGV0IG5vZGVzID0gdGVtcGxhdGVJbmZvLmNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbj1kb20uZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZG9tLnRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mbztcbiAgICAgIC8vIFNldHVwIGNvbXBvdW5kIHN0b3JhZ2UsIDItd2F5IGxpc3RlbmVycywgYW5kIGRhdGFIb3N0IGZvciBiaW5kaW5nc1xuICAgICAgc2V0dXBCaW5kaW5ncyh0aGlzLCB0ZW1wbGF0ZUluZm8pO1xuICAgICAgLy8gRmx1c2ggcHJvcGVydGllcyBpbnRvIHRlbXBsYXRlIG5vZGVzIGlmIGFscmVhZHkgYm9vdGVkXG4gICAgICBpZiAodGhpcy5fX2RhdGFSZWFkeSkge1xuICAgICAgICBydW5FZmZlY3RzKHRoaXMsIHRlbXBsYXRlSW5mby5wcm9wZXJ0eUVmZmVjdHMsIHRoaXMuX19kYXRhLCBudWxsLFxuICAgICAgICAgIGZhbHNlLCB0ZW1wbGF0ZUluZm8ubm9kZUxpc3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRvbTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuZCB1bmJpbmRzIHRoZSBub2RlcyBwcmV2aW91c2x5IGNvbnRhaW5lZCBpbiB0aGUgcHJvdmlkZWRcbiAgICAgKiBEb2N1bWVudEZyYWdtZW50IHJldHVybmVkIGZyb20gYF9zdGFtcFRlbXBsYXRlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IVN0YW1wZWRUZW1wbGF0ZX0gZG9tIERvY3VtZW50RnJhZ21lbnQgcHJldmlvdXNseSByZXR1cm5lZFxuICAgICAqICAgZnJvbSBgX3N0YW1wVGVtcGxhdGVgIGFzc29jaWF0ZWQgd2l0aCB0aGUgbm9kZXMgdG8gYmUgcmVtb3ZlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVtb3ZlQm91bmREb20oZG9tKSB7XG4gICAgICAvLyBVbmxpbmsgdGVtcGxhdGUgaW5mb1xuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IGRvbS50ZW1wbGF0ZUluZm87XG4gICAgICBpZiAodGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvKSB7XG4gICAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID1cbiAgICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mbykge1xuICAgICAgICB0ZW1wbGF0ZUluZm8ubmV4dFRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9XG4gICAgICAgICAgdGVtcGxhdGVJbmZvLnByZXZpb3VzVGVtcGxhdGVJbmZvO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX190ZW1wbGF0ZUluZm9MYXN0ID09IHRlbXBsYXRlSW5mbykge1xuICAgICAgICB0aGlzLl9fdGVtcGxhdGVJbmZvTGFzdCA9IHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbztcbiAgICAgIH1cbiAgICAgIHRlbXBsYXRlSW5mby5wcmV2aW91c1RlbXBsYXRlSW5mbyA9IHRlbXBsYXRlSW5mby5uZXh0VGVtcGxhdGVJbmZvID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBzdGFtcGVkIG5vZGVzXG4gICAgICBsZXQgbm9kZXMgPSB0ZW1wbGF0ZUluZm8uY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGk9MDsgaTxub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIGRlZmF1bHQgYFRlbXBsYXRlU3RhbXBgIGltcGxlbWVudGF0aW9uIHRvIGFkZCBzdXBwb3J0IGZvclxuICAgICAqIHBhcnNpbmcgYmluZGluZ3MgZnJvbSBgVGV4dE5vZGVgJ3MnIGB0ZXh0Q29udGVudGAuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbykge1xuICAgICAgbGV0IG5vdGVkID0gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3Mobm9kZS50ZXh0Q29udGVudCwgdGVtcGxhdGVJbmZvKTtcbiAgICAgICAgaWYgKHBhcnRzKSB7XG4gICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgdGV4dENvbnRlbnQgd2l0aCBhbnkgbGl0ZXJhbCBwYXJ0c1xuICAgICAgICAgIC8vIE5PVEU6IGRlZmF1bHQgdG8gYSBzcGFjZSBoZXJlIHNvIHRoZSB0ZXh0Tm9kZSByZW1haW5zOyBzb21lIGJyb3dzZXJzXG4gICAgICAgICAgLy8gKElFKSBldmFjaXBhdGUgYW4gZW1wdHkgdGV4dE5vZGUgZm9sbG93aW5nIGNsb25lTm9kZS9pbXBvcnROb2RlLlxuICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgPSBsaXRlcmFsRnJvbVBhcnRzKHBhcnRzKSB8fCAnICc7XG4gICAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAndGV4dCcsICd0ZXh0Q29udGVudCcsIHBhcnRzKTtcbiAgICAgICAgICBub3RlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogcGFyc2luZyBiaW5kaW5ncyBmcm9tIGF0dHJpYnV0ZXMuICBBIGBiaW5kaW5nc2BcbiAgICAgKiBhcnJheSBpcyBhZGRlZCB0byBgbm9kZUluZm9gIGFuZCBwb3B1bGF0ZWQgd2l0aCBiaW5kaW5nIG1ldGFkYXRhXG4gICAgICogd2l0aCBpbmZvcm1hdGlvbiBjYXB0dXJpbmcgdGhlIGJpbmRpbmcgdGFyZ2V0LCBhbmQgYSBgcGFydHNgIGFycmF5XG4gICAgICogd2l0aCBvbmUgb3IgbW9yZSBtZXRhZGF0YSBvYmplY3RzIGNhcHR1cmluZyB0aGUgc291cmNlKHMpIG9mIHRoZVxuICAgICAqIGJpbmRpbmcuXG4gICAgICpcbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7VGVtcGxhdGVJbmZvfSB0ZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiBAcGFyYW0ge05vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlIG5vZGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIHZpc2l0ZWQgbm9kZSBhZGRlZCBub2RlLXNwZWNpZmljXG4gICAgICogICBtZXRhZGF0YSB0byBgbm9kZUluZm9gXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IEludGVyZmFjZXMgaW4gY2xvc3VyZSBkbyBub3QgaW5oZXJpdCBzdGF0aWNzLCBidXQgY2xhc3NlcyBkb1xuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgIGxldCBwYXJ0cyA9IHRoaXMuX3BhcnNlQmluZGluZ3ModmFsdWUsIHRlbXBsYXRlSW5mbyk7XG4gICAgICBpZiAocGFydHMpIHtcbiAgICAgICAgLy8gQXR0cmlidXRlIG9yIHByb3BlcnR5XG4gICAgICAgIGxldCBvcmlnTmFtZSA9IG5hbWU7XG4gICAgICAgIGxldCBraW5kID0gJ3Byb3BlcnR5JztcbiAgICAgICAgaWYgKG5hbWVbbmFtZS5sZW5ndGgtMV0gPT0gJyQnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLTEpO1xuICAgICAgICAgIGtpbmQgPSAnYXR0cmlidXRlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBJbml0aWFsaXplIGF0dHJpYnV0ZSBiaW5kaW5ncyB3aXRoIGFueSBsaXRlcmFsIHBhcnRzXG4gICAgICAgIGxldCBsaXRlcmFsID0gbGl0ZXJhbEZyb21QYXJ0cyhwYXJ0cyk7XG4gICAgICAgIGlmIChsaXRlcmFsICYmIGtpbmQgPT0gJ2F0dHJpYnV0ZScpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCBsaXRlcmFsKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbGVhciBhdHRyaWJ1dGUgYmVmb3JlIHJlbW92aW5nLCBzaW5jZSBJRSB3b24ndCBhbGxvdyByZW1vdmluZ1xuICAgICAgICAvLyBgdmFsdWVgIGF0dHJpYnV0ZSBpZiBpdCBwcmV2aW91c2x5IGhhZCBhIHZhbHVlIChjYW4ndFxuICAgICAgICAvLyB1bmNvbmRpdGlvbmFsbHkgc2V0ICcnIGJlZm9yZSByZW1vdmluZyBzaW5jZSBhdHRyaWJ1dGVzIHdpdGggYCRgXG4gICAgICAgIC8vIGNhbid0IGJlIHNldCB1c2luZyBzZXRBdHRyaWJ1dGUpXG4gICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PT0gJ2lucHV0JyAmJiBvcmlnTmFtZSA9PT0gJ3ZhbHVlJykge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG9yaWdOYW1lLCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIGFubm90YXRpb25cbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUob3JpZ05hbWUpO1xuICAgICAgICAvLyBDYXNlIGhhY2tlcnk6IGF0dHJpYnV0ZXMgYXJlIGxvd2VyLWNhc2UsIGJ1dCBiaW5kIHRhcmdldHNcbiAgICAgICAgLy8gKHByb3BlcnRpZXMpIGFyZSBjYXNlIHNlbnNpdGl2ZS4gR2FtYml0IGlzIHRvIG1hcCBkYXNoLWNhc2UgdG9cbiAgICAgICAgLy8gY2FtZWwtY2FzZTogYGZvby1iYXJgIGJlY29tZXMgYGZvb0JhcmAuXG4gICAgICAgIC8vIEF0dHJpYnV0ZSBiaW5kaW5ncyBhcmUgZXhjZXB0ZWQuXG4gICAgICAgIGlmIChraW5kID09PSAncHJvcGVydHknKSB7XG4gICAgICAgICAgbmFtZSA9IGRhc2hUb0NhbWVsQ2FzZShuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRCaW5kaW5nKHRoaXMsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIGtpbmQsIG5hbWUsIHBhcnRzLCBsaXRlcmFsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VwZXIuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8sIG5hbWUsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgZGVmYXVsdCBgVGVtcGxhdGVTdGFtcGAgaW1wbGVtZW50YXRpb24gdG8gYWRkIHN1cHBvcnQgZm9yXG4gICAgICogYmluZGluZyB0aGUgcHJvcGVydGllcyB0aGF0IGEgbmVzdGVkIHRlbXBsYXRlIGRlcGVuZHMgb24gdG8gdGhlIHRlbXBsYXRlXG4gICAgICogYXMgYF9ob3N0Xzxwcm9wZXJ0eT5gLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtOb2RlSW5mb30gbm9kZUluZm8gTm9kZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZSBub2RlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBJbnRlcmZhY2VzIGluIGNsb3N1cmUgZG8gbm90IGluaGVyaXQgc3RhdGljcywgYnV0IGNsYXNzZXMgZG9cbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBsZXQgbm90ZWQgPSBzdXBlci5fcGFyc2VUZW1wbGF0ZU5lc3RlZFRlbXBsYXRlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pO1xuICAgICAgLy8gTWVyZ2UgaG9zdCBwcm9wcyBpbnRvIG91dGVyIHRlbXBsYXRlIGFuZCBhZGQgYmluZGluZ3NcbiAgICAgIGxldCBob3N0UHJvcHMgPSBub2RlSW5mby50ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgbGV0IG1vZGUgPSAneyc7XG4gICAgICBmb3IgKGxldCBzb3VyY2UgaW4gaG9zdFByb3BzKSB7XG4gICAgICAgIGxldCBwYXJ0cyA9IFt7IG1vZGUsIHNvdXJjZSwgZGVwZW5kZW5jaWVzOiBbc291cmNlXSB9XTtcbiAgICAgICAgYWRkQmluZGluZyh0aGlzLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvLCAncHJvcGVydHknLCAnX2hvc3RfJyArIHNvdXJjZSwgcGFydHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdGVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB0byBwYXJzZSB0ZXh0IGluIGEgdGVtcGxhdGUgKGVpdGhlciBhdHRyaWJ1dGUgdmFsdWVzIG9yXG4gICAgICogdGV4dENvbnRlbnQpIGludG8gYmluZGluZyBtZXRhZGF0YS5cbiAgICAgKlxuICAgICAqIEFueSBvdmVycmlkZXMgb2YgdGhpcyBtZXRob2Qgc2hvdWxkIHJldHVybiBhbiBhcnJheSBvZiBiaW5kaW5nIHBhcnRcbiAgICAgKiBtZXRhZGF0YSAgcmVwcmVzZW50aW5nIG9uZSBvciBtb3JlIGJpbmRpbmdzIGZvdW5kIGluIHRoZSBwcm92aWRlZCB0ZXh0XG4gICAgICogYW5kIGFueSBcImxpdGVyYWxcIiB0ZXh0IGluIGJldHdlZW4uICBBbnkgbm9uLWxpdGVyYWwgcGFydHMgd2lsbCBiZSBwYXNzZWRcbiAgICAgKiB0byBgX2V2YWx1YXRlQmluZGluZ2Agd2hlbiBhbnkgZGVwZW5kZW5jaWVzIGNoYW5nZS4gIFRoZSBvbmx5IHJlcXVpcmVkXG4gICAgICogZmllbGRzIG9mIGVhY2ggXCJwYXJ0XCIgaW4gdGhlIHJldHVybmVkIGFycmF5IGFyZSBhcyBmb2xsb3dzOlxuICAgICAqXG4gICAgICogLSBgZGVwZW5kZW5jaWVzYCAtIEFycmF5IGNvbnRhaW5pbmcgdHJpZ2dlciBtZXRhZGF0YSBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgdGhhdCBzaG91bGQgdHJpZ2dlciB0aGUgYmluZGluZyB0byB1cGRhdGVcbiAgICAgKiAtIGBsaXRlcmFsYCAtIFN0cmluZyBjb250YWluaW5nIHRleHQgaWYgdGhlIHBhcnQgcmVwcmVzZW50cyBhIGxpdGVyYWw7XG4gICAgICogICBpbiB0aGlzIGNhc2Ugbm8gYGRlcGVuZGVuY2llc2AgYXJlIG5lZWRlZFxuICAgICAqXG4gICAgICogQWRkaXRpb25hbCBtZXRhZGF0YSBmb3IgdXNlIGJ5IGBfZXZhbHVhdGVCaW5kaW5nYCBtYXkgYmUgcHJvdmlkZWQgaW5cbiAgICAgKiBlYWNoIHBhcnQgb2JqZWN0IGFzIG5lZWRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhhbmRsZXMgdGhlIGZvbGxvd2luZyB0eXBlcyBvZiBiaW5kaW5nc1xuICAgICAqIChvbmUgb3IgbW9yZSBtYXkgYmUgaW50ZXJtaXhlZCB3aXRoIGxpdGVyYWwgc3RyaW5ncyk6XG4gICAgICogLSBQcm9wZXJ0eSBiaW5kaW5nOiBgW1twcm9wXV1gXG4gICAgICogLSBQYXRoIGJpbmRpbmc6IGBbW29iamVjdC5wcm9wXV1gXG4gICAgICogLSBOZWdhdGVkIHByb3BlcnR5IG9yIHBhdGggYmluZGluZ3M6IGBbWyFwcm9wXV1gIG9yIGBbWyFvYmplY3QucHJvcF1dYFxuICAgICAqIC0gVHdvLXdheSBwcm9wZXJ0eSBvciBwYXRoIGJpbmRpbmdzIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBge3twcm9wfX1gLCBge3tvYmplY3QucHJvcH19YCwgYHt7IXByb3B9fWAgb3IgYHt7IW9iamVjdC5wcm9wfX1gXG4gICAgICogLSBJbmxpbmUgY29tcHV0ZWQgbWV0aG9kIChzdXBwb3J0cyBuZWdhdGlvbik6XG4gICAgICogICBgW1tjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWAsIGBbWyFjb21wdXRlKGEsICdsaXRlcmFsJywgYildXWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRleHQgdG8gcGFyc2UgZnJvbSBhdHRyaWJ1dGUgb3IgdGV4dENvbnRlbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdGVtcGxhdGVJbmZvIEN1cnJlbnQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiBAcmV0dXJuIHtBcnJheTwhQmluZGluZ1BhcnQ+fSBBcnJheSBvZiBiaW5kaW5nIHBhcnQgbWV0YWRhdGFcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZUJpbmRpbmdzKHRleHQsIHRlbXBsYXRlSW5mbykge1xuICAgICAgbGV0IHBhcnRzID0gW107XG4gICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgIGxldCBtO1xuICAgICAgLy8gRXhhbXBsZTogXCJsaXRlcmFsMXt7cHJvcH19bGl0ZXJhbDJbWyFjb21wdXRlKGZvbyxiYXIpXV1maW5hbFwiXG4gICAgICAvLyBSZWdleCBtYXRjaGVzOlxuICAgICAgLy8gICAgICAgIEl0ZXJhdGlvbiAxOiAgSXRlcmF0aW9uIDI6XG4gICAgICAvLyBtWzFdOiAne3snICAgICAgICAgICdbWydcbiAgICAgIC8vIG1bMl06ICcnICAgICAgICAgICAgJyEnXG4gICAgICAvLyBtWzNdOiAncHJvcCcgICAgICAgICdjb21wdXRlKGZvbyxiYXIpJ1xuICAgICAgd2hpbGUgKChtID0gYmluZGluZ1JlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgIC8vIEFkZCBsaXRlcmFsIHBhcnRcbiAgICAgICAgaWYgKG0uaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtsaXRlcmFsOiB0ZXh0LnNsaWNlKGxhc3RJbmRleCwgbS5pbmRleCl9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgYmluZGluZyBwYXJ0XG4gICAgICAgIGxldCBtb2RlID0gbVsxXVswXTtcbiAgICAgICAgbGV0IG5lZ2F0ZSA9IEJvb2xlYW4obVsyXSk7XG4gICAgICAgIGxldCBzb3VyY2UgPSBtWzNdLnRyaW0oKTtcbiAgICAgICAgbGV0IGN1c3RvbUV2ZW50ID0gZmFsc2UsIG5vdGlmeUV2ZW50ID0gJycsIGNvbG9uID0gLTE7XG4gICAgICAgIGlmIChtb2RlID09ICd7JyAmJiAoY29sb24gPSBzb3VyY2UuaW5kZXhPZignOjonKSkgPiAwKSB7XG4gICAgICAgICAgbm90aWZ5RXZlbnQgPSBzb3VyY2Uuc3Vic3RyaW5nKGNvbG9uICsgMik7XG4gICAgICAgICAgc291cmNlID0gc291cmNlLnN1YnN0cmluZygwLCBjb2xvbik7XG4gICAgICAgICAgY3VzdG9tRXZlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaWduYXR1cmUgPSBwYXJzZU1ldGhvZChzb3VyY2UpO1xuICAgICAgICBsZXQgZGVwZW5kZW5jaWVzID0gW107XG4gICAgICAgIGlmIChzaWduYXR1cmUpIHtcbiAgICAgICAgICAvLyBJbmxpbmUgY29tcHV0ZWQgZnVuY3Rpb25cbiAgICAgICAgICBsZXQge2FyZ3MsIG1ldGhvZE5hbWV9ID0gc2lnbmF0dXJlO1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmICghYXJnLmxpdGVyYWwpIHtcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzLnB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGR5bmFtaWNGbnMgPSB0ZW1wbGF0ZUluZm8uZHluYW1pY0ZucztcbiAgICAgICAgICBpZiAoZHluYW1pY0ZucyAmJiBkeW5hbWljRm5zW21ldGhvZE5hbWVdIHx8IHNpZ25hdHVyZS5zdGF0aWMpIHtcbiAgICAgICAgICAgIGRlcGVuZGVuY2llcy5wdXNoKG1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgc2lnbmF0dXJlLmR5bmFtaWNGbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFByb3BlcnR5IG9yIHBhdGhcbiAgICAgICAgICBkZXBlbmRlbmNpZXMucHVzaChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgIHNvdXJjZSwgbW9kZSwgbmVnYXRlLCBjdXN0b21FdmVudCwgc2lnbmF0dXJlLCBkZXBlbmRlbmNpZXMsXG4gICAgICAgICAgZXZlbnQ6IG5vdGlmeUV2ZW50XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0SW5kZXggPSBiaW5kaW5nUmVnZXgubGFzdEluZGV4O1xuICAgICAgfVxuICAgICAgLy8gQWRkIGEgZmluYWwgbGl0ZXJhbCBwYXJ0XG4gICAgICBpZiAobGFzdEluZGV4ICYmIGxhc3RJbmRleCA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgIGxldCBsaXRlcmFsID0gdGV4dC5zdWJzdHJpbmcobGFzdEluZGV4KTtcbiAgICAgICAgaWYgKGxpdGVyYWwpIHtcbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIGxpdGVyYWw6IGxpdGVyYWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gcGFydHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdG8gZXZhbHVhdGUgYSBwcmV2aW91c2x5IHBhcnNlZCBiaW5kaW5nIHBhcnQgYmFzZWQgb24gYSBzZXQgb2ZcbiAgICAgKiBvbmUgb3IgbW9yZSBjaGFuZ2VkIGRlcGVuZGVuY2llcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7dGhpc30gaW5zdCBFbGVtZW50IHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgc2NvcGUgZm9yXG4gICAgICogICBiaW5kaW5nIGRlcGVuZGVuY2llc1xuICAgICAqIEBwYXJhbSB7QmluZGluZ1BhcnR9IHBhcnQgQmluZGluZyBwYXJ0IG1ldGFkYXRhXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHBhdGggUHJvcGVydHkvcGF0aCB0aGF0IHRyaWdnZXJlZCB0aGlzIGVmZmVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgY3VycmVudCBwcm9wZXJ0eSBjaGFuZ2VzXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFByb3BzIEJhZyBvZiBwcmV2aW91cyB2YWx1ZXMgZm9yIGNoYW5nZWQgcHJvcGVydGllc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaGFzUGF0aHMgVHJ1ZSB3aXRoIGBwcm9wc2AgY29udGFpbnMgb25lIG9yIG1vcmUgcGF0aHNcbiAgICAgKiBAcmV0dXJuIHsqfSBWYWx1ZSB0aGUgYmluZGluZyBwYXJ0IGV2YWx1YXRlZCB0b1xuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzdGF0aWMgX2V2YWx1YXRlQmluZGluZyhpbnN0LCBwYXJ0LCBwYXRoLCBwcm9wcywgb2xkUHJvcHMsIGhhc1BhdGhzKSB7XG4gICAgICBsZXQgdmFsdWU7XG4gICAgICBpZiAocGFydC5zaWduYXR1cmUpIHtcbiAgICAgICAgdmFsdWUgPSBydW5NZXRob2RFZmZlY3QoaW5zdCwgcGF0aCwgcHJvcHMsIG9sZFByb3BzLCBwYXJ0LnNpZ25hdHVyZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhdGggIT0gcGFydC5zb3VyY2UpIHtcbiAgICAgICAgdmFsdWUgPSBnZXQkMChpbnN0LCBwYXJ0LnNvdXJjZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaGFzUGF0aHMgJiYgaXNQYXRoJDAocGF0aCkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGdldCQwKGluc3QsIHBhdGgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gaW5zdC5fX2RhdGFbcGF0aF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJ0Lm5lZ2F0ZSkge1xuICAgICAgICB2YWx1ZSA9ICF2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIG1ha2UgYSB0eXBpbmcgZm9yIGNsb3N1cmUgOlBcbiAgUHJvcGVydHlFZmZlY3RzVHlwZSA9IFByb3BlcnR5RWZmZWN0cztcblxuICByZXR1cm4gUHJvcGVydHlFZmZlY3RzO1xufSk7XG5cbi8qKlxuICogSGVscGVyIGFwaSBmb3IgZW5xdWVpbmcgY2xpZW50IGRvbSBjcmVhdGVkIGJ5IGEgaG9zdCBlbGVtZW50LlxuICpcbiAqIEJ5IGRlZmF1bHQgZWxlbWVudHMgYXJlIGZsdXNoZWQgdmlhIGBfZmx1c2hQcm9wZXJ0aWVzYCB3aGVuXG4gKiBgY29ubmVjdGVkQ2FsbGJhY2tgIGlzIGNhbGxlZC4gRWxlbWVudHMgYXR0YWNoIHRoZWlyIGNsaWVudCBkb20gdG9cbiAqIHRoZW1zZWx2ZXMgYXQgYHJlYWR5YCB0aW1lIHdoaWNoIHJlc3VsdHMgZnJvbSB0aGlzIGZpcnN0IGZsdXNoLlxuICogVGhpcyBwcm92aWRlcyBhbiBvcmRlcmluZyBndWFyYW50ZWUgdGhhdCB0aGUgY2xpZW50IGRvbSBhbiBlbGVtZW50XG4gKiBjcmVhdGVzIGlzIGZsdXNoZWQgYmVmb3JlIHRoZSBlbGVtZW50IGl0c2VsZiAoaS5lLiBjbGllbnQgYHJlYWR5YFxuICogZmlyZXMgYmVmb3JlIGhvc3QgYHJlYWR5YCkuXG4gKlxuICogSG93ZXZlciwgaWYgYF9mbHVzaFByb3BlcnRpZXNgIGlzIGNhbGxlZCAqYmVmb3JlKiBhbiBlbGVtZW50IGlzIGNvbm5lY3RlZCxcbiAqIGFzIGZvciBleGFtcGxlIGBUZW1wbGF0aXplYCBkb2VzLCB0aGlzIG9yZGVyaW5nIGd1YXJhbnRlZSBjYW5ub3QgYmVcbiAqIHNhdGlzZmllZCBiZWNhdXNlIG5vIGVsZW1lbnRzIGFyZSBjb25uZWN0ZWQuIChOb3RlOiBCb3VuZCBlbGVtZW50cyB0aGF0XG4gKiByZWNlaXZlIGRhdGEgZG8gYmVjb21lIGVucXVldWVkIGNsaWVudHMgYW5kIGFyZSBwcm9wZXJseSBvcmRlcmVkIGJ1dFxuICogdW5ib3VuZCBlbGVtZW50cyBhcmUgbm90LilcbiAqXG4gKiBUbyBtYWludGFpbiB0aGUgZGVzaXJlZCBcImNsaWVudCBiZWZvcmUgaG9zdFwiIG9yZGVyaW5nIGd1YXJhbnRlZSBmb3IgdGhpc1xuICogY2FzZSB3ZSByZWx5IG9uIHRoZSBcImhvc3Qgc3RhY2suIENsaWVudCBub2RlcyByZWdpc3RlcnMgdGhlbXNlbHZlcyB3aXRoXG4gKiB0aGUgY3JlYXRpbmcgaG9zdCBlbGVtZW50IHdoZW4gY3JlYXRlZC4gVGhpcyBlbnN1cmVzIHRoYXQgYWxsIGNsaWVudCBkb21cbiAqIGlzIHJlYWRpZWQgaW4gdGhlIHByb3BlciBvcmRlciwgbWFpbnRhaW5pbmcgdGhlIGRlc2lyZWQgZ3VhcmFudGVlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmxldCBob3N0U3RhY2sgPSB7XG5cbiAgc3RhY2s6IFtdLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYWRkIHRvIGhvc3RTdGFja1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgcmVnaXN0ZXJIb3N0KGluc3QpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgIGxldCBob3N0ID0gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aC0xXTtcbiAgICAgIGhvc3QuX2VucXVldWVDbGllbnQoaW5zdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyp9IGluc3QgSW5zdGFuY2UgdG8gYmVnaW4gaG9zdGluZ1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgYmVnaW5Ib3N0aW5nKGluc3QpIHtcbiAgICB0aGlzLnN0YWNrLnB1c2goaW5zdCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Kn0gaW5zdCBJbnN0YW5jZSB0byBlbmQgaG9zdGluZ1xuICAgKiBAdGhpcyB7aG9zdFN0YWNrfVxuICAgKi9cbiAgZW5kSG9zdGluZyhpbnN0KSB7XG4gICAgbGV0IHN0YWNrTGVuID0gdGhpcy5zdGFjay5sZW5ndGg7XG4gICAgaWYgKHN0YWNrTGVuICYmIHRoaXMuc3RhY2tbc3RhY2tMZW4tMV0gPT0gaW5zdCkge1xuICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICB9XG4gIH1cblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzXG4vLyBtb2R1bGUgaWQgPSAyMlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydCBsZXQgbmF0aXZlU2hhZG93ID0gISh3aW5kb3dbJ1NoYWR5RE9NJ10gJiYgd2luZG93WydTaGFkeURPTSddWydpblVzZSddKTtcbmV4cG9ydCBsZXQgbmF0aXZlQ3NzVmFyaWFibGVzO1xuXG4vKipcbiAqIEBwYXJhbSB7KFNoYWR5Q1NTT3B0aW9ucyB8IFNoYWR5Q1NTSW50ZXJmYWNlKT19IHNldHRpbmdzXG4gKi9cbmZ1bmN0aW9uIGNhbGNDc3NWYXJpYWJsZXMoc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzWydzaGltY3NzcHJvcGVydGllcyddKSB7XG4gICAgbmF0aXZlQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gY2hyb21lIDQ5IGhhcyBzZW1pLXdvcmtpbmcgY3NzIHZhcnMsIGNoZWNrIGlmIGJveC1zaGFkb3cgd29ya3NcbiAgICAvLyBzYWZhcmkgOS4xIGhhcyBhIHJlY2FsYyBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xNTU3ODJcbiAgICAvLyBIb3dldmVyLCBzaGltIGNzcyBjdXN0b20gcHJvcGVydGllcyBhcmUgb25seSBzdXBwb3J0ZWQgd2l0aCBTaGFkeURPTSBlbmFibGVkLFxuICAgIC8vIHNvIGZhbGwgYmFjayBvbiBuYXRpdmUgaWYgd2UgZG8gbm90IGRldGVjdCBTaGFkeURPTVxuICAgIC8vIEVkZ2UgMTU6IGN1c3RvbSBwcm9wZXJ0aWVzIHVzZWQgaW4gOjpiZWZvcmUgYW5kIDo6YWZ0ZXIgd2lsbCBhbHNvIGJlIHVzZWQgaW4gdGhlIHBhcmVudCBlbGVtZW50XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTI0MTQyNTcvXG4gICAgbmF0aXZlQ3NzVmFyaWFibGVzID0gbmF0aXZlU2hhZG93IHx8IEJvb2xlYW4oIW5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvNjAxfEVkZ2VcXC8xNS8pICYmXG4gICAgICB3aW5kb3cuQ1NTICYmIENTUy5zdXBwb3J0cyAmJiBDU1Muc3VwcG9ydHMoJ2JveC1zaGFkb3cnLCAnMCAwIDAgdmFyKC0tZm9vKScpKTtcbiAgfVxufVxuXG5pZiAod2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5uYXRpdmVDc3MgIT09IHVuZGVmaW5lZCkge1xuICBuYXRpdmVDc3NWYXJpYWJsZXMgPSB3aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzO1xufSBlbHNlIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgY2FsY0Nzc1ZhcmlhYmxlcyh3aW5kb3cuU2hhZHlDU1MpO1xuICAvLyByZXNldCB3aW5kb3cgdmFyaWFibGUgdG8gbGV0IFNoYWR5Q1NTIEFQSSB0YWtlIGl0cyBwbGFjZVxuICB3aW5kb3cuU2hhZHlDU1MgPSB1bmRlZmluZWQ7XG59IGVsc2Uge1xuICBjYWxjQ3NzVmFyaWFibGVzKHdpbmRvd1snV2ViQ29tcG9uZW50cyddICYmIHdpbmRvd1snV2ViQ29tcG9uZW50cyddWydmbGFncyddKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvc3R5bGUtc2V0dGluZ3MuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qXG5FeHRyZW1lbHkgc2ltcGxlIGNzcyBwYXJzZXIuIEludGVuZGVkIHRvIGJlIG5vdCBtb3JlIHRoYW4gd2hhdCB3ZSBuZWVkXG5hbmQgZGVmaW5pdGVseSBub3QgbmVjZXNzYXJpbHkgY29ycmVjdCA9KS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEB1bnJlc3RyaWN0ZWQgKi9cbmNsYXNzIFN0eWxlTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ3N0YXJ0J10gPSAwO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ2VuZCddID0gMDtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzWydwcmV2aW91cyddID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzWydwYXJlbnQnXSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTdHlsZU5vZGU+fSAqL1xuICAgIHRoaXNbJ3J1bGVzJ10gPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3BhcnNlZENzc1RleHQnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ2Nzc1RleHQnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzWydhdFJ1bGUnXSA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ3R5cGUnXSA9IDA7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1sna2V5ZnJhbWVzTmFtZSddID0gJyc7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1snc2VsZWN0b3InXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3BhcnNlZFNlbGVjdG9yJ10gPSAnJztcbiAgfVxufVxuXG5leHBvcnQge1N0eWxlTm9kZX1cblxuLy8gZ2l2ZW4gYSBzdHJpbmcgb2YgY3NzLCByZXR1cm4gYSBzaW1wbGUgcnVsZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gIHRleHQgPSBjbGVhbih0ZXh0KTtcbiAgcmV0dXJuIHBhcnNlQ3NzKGxleCh0ZXh0KSwgdGV4dCk7XG59XG5cbi8vIHJlbW92ZSBzdHVmZiB3ZSBkb24ndCBjYXJlIGFib3V0IHRoYXQgbWF5IGhpbmRlciBwYXJzaW5nXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuKGNzc1RleHQpIHtcbiAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShSWC5jb21tZW50cywgJycpLnJlcGxhY2UoUlgucG9ydCwgJycpO1xufVxuXG4vLyBzdXBlciBzaW1wbGUgey4uLn0gbGV4ZXIgdGhhdCByZXR1cm5zIGEgbm9kZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmZ1bmN0aW9uIGxleCh0ZXh0KSB7XG4gIGxldCByb290ID0gbmV3IFN0eWxlTm9kZSgpO1xuICByb290WydzdGFydCddID0gMDtcbiAgcm9vdFsnZW5kJ10gPSB0ZXh0Lmxlbmd0aFxuICBsZXQgbiA9IHJvb3Q7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gdGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAodGV4dFtpXSA9PT0gT1BFTl9CUkFDRSkge1xuICAgICAgaWYgKCFuWydydWxlcyddKSB7XG4gICAgICAgIG5bJ3J1bGVzJ10gPSBbXTtcbiAgICAgIH1cbiAgICAgIGxldCBwID0gbjtcbiAgICAgIGxldCBwcmV2aW91cyA9IHBbJ3J1bGVzJ11bcFsncnVsZXMnXS5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgbiA9IG5ldyBTdHlsZU5vZGUoKTtcbiAgICAgIG5bJ3N0YXJ0J10gPSBpICsgMTtcbiAgICAgIG5bJ3BhcmVudCddID0gcDtcbiAgICAgIG5bJ3ByZXZpb3VzJ10gPSBwcmV2aW91cztcbiAgICAgIHBbJ3J1bGVzJ10ucHVzaChuKTtcbiAgICB9IGVsc2UgaWYgKHRleHRbaV0gPT09IENMT1NFX0JSQUNFKSB7XG4gICAgICBuWydlbmQnXSA9IGkgKyAxO1xuICAgICAgbiA9IG5bJ3BhcmVudCddIHx8IHJvb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290O1xufVxuXG4vLyBhZGQgc2VsZWN0b3JzL2Nzc1RleHQgdG8gbm9kZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7U3R5bGVOb2RlfVxuICovXG5mdW5jdGlvbiBwYXJzZUNzcyhub2RlLCB0ZXh0KSB7XG4gIGxldCB0ID0gdGV4dC5zdWJzdHJpbmcobm9kZVsnc3RhcnQnXSwgbm9kZVsnZW5kJ10gLSAxKTtcbiAgbm9kZVsncGFyc2VkQ3NzVGV4dCddID0gbm9kZVsnY3NzVGV4dCddID0gdC50cmltKCk7XG4gIGlmIChub2RlWydwYXJlbnQnXSkge1xuICAgIGxldCBzcyA9IG5vZGVbJ3ByZXZpb3VzJ10gPyBub2RlWydwcmV2aW91cyddWydlbmQnXSA6IG5vZGVbJ3BhcmVudCddWydzdGFydCddO1xuICAgIHQgPSB0ZXh0LnN1YnN0cmluZyhzcywgbm9kZVsnc3RhcnQnXSAtIDEpO1xuICAgIHQgPSBfZXhwYW5kVW5pY29kZUVzY2FwZXModCk7XG4gICAgdCA9IHQucmVwbGFjZShSWC5tdWx0aXBsZVNwYWNlcywgJyAnKTtcbiAgICAvLyBUT0RPKHNvcnZlbGwpOiBhZCBob2M7IG1ha2Ugc2VsZWN0b3IgaW5jbHVkZSBvbmx5IGFmdGVyIGxhc3QgO1xuICAgIC8vIGhlbHBzIHdpdGggbWl4aW4gc3ludGF4XG4gICAgdCA9IHQuc3Vic3RyaW5nKHQubGFzdEluZGV4T2YoJzsnKSArIDEpO1xuICAgIGxldCBzID0gbm9kZVsncGFyc2VkU2VsZWN0b3InXSA9IG5vZGVbJ3NlbGVjdG9yJ10gPSB0LnRyaW0oKTtcbiAgICBub2RlWydhdFJ1bGUnXSA9IChzLmluZGV4T2YoQVRfU1RBUlQpID09PSAwKTtcbiAgICAvLyBub3RlLCBzdXBwb3J0IGEgc3Vic2V0IG9mIHJ1bGUgdHlwZXMuLi5cbiAgICBpZiAobm9kZVsnYXRSdWxlJ10pIHtcbiAgICAgIGlmIChzLmluZGV4T2YoTUVESUFfU1RBUlQpID09PSAwKSB7XG4gICAgICAgIG5vZGVbJ3R5cGUnXSA9IHR5cGVzLk1FRElBX1JVTEU7XG4gICAgICB9IGVsc2UgaWYgKHMubWF0Y2goUlgua2V5ZnJhbWVzUnVsZSkpIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuS0VZRlJBTUVTX1JVTEU7XG4gICAgICAgIG5vZGVbJ2tleWZyYW1lc05hbWUnXSA9XG4gICAgICAgICAgbm9kZVsnc2VsZWN0b3InXS5zcGxpdChSWC5tdWx0aXBsZVNwYWNlcykucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMCkge1xuICAgICAgICBub2RlWyd0eXBlJ10gPSB0eXBlcy5NSVhJTl9SVUxFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuU1RZTEVfUlVMRTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHIkID0gbm9kZVsncnVsZXMnXTtcbiAgaWYgKHIkKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSByJC5sZW5ndGgsIHI7XG4gICAgICAoaSA8IGwpICYmIChyID0gciRbaV0pOyBpKyspIHtcbiAgICAgIHBhcnNlQ3NzKHIsIHRleHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBjb252ZXJzaW9uIG9mIHNvcnQgdW5pY29kZSBlc2NhcGVzIHdpdGggc3BhY2VzIGxpa2UgYFxcMzMgYCAoYW5kIGxvbmdlcikgaW50b1xuICogZXhwYW5kZWQgZm9ybSB0aGF0IGRvZXNuJ3QgcmVxdWlyZSB0cmFpbGluZyBzcGFjZSBgXFwwMDAwMzNgXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBfZXhwYW5kVW5pY29kZUVzY2FwZXMocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKFswLTlhLWZdezEsNn0pXFxzL2dpLCBmdW5jdGlvbigpIHtcbiAgICBsZXQgY29kZSA9IGFyZ3VtZW50c1sxXSxcbiAgICAgIHJlcGVhdCA9IDYgLSBjb2RlLmxlbmd0aDtcbiAgICB3aGlsZSAocmVwZWF0LS0pIHtcbiAgICAgIGNvZGUgPSAnMCcgKyBjb2RlO1xuICAgIH1cbiAgICByZXR1cm4gJ1xcXFwnICsgY29kZTtcbiAgfSk7XG59XG5cbi8qKlxuICogc3RyaW5naWZ5IHBhcnNlZCBjc3MuXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFuPX0gcHJlc2VydmVQcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge3N0cmluZz19IHRleHRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlLCBwcmVzZXJ2ZVByb3BlcnRpZXMsIHRleHQgPSAnJykge1xuICAvLyBjYWxjIHJ1bGUgY3NzVGV4dFxuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBpZiAobm9kZVsnY3NzVGV4dCddIHx8IG5vZGVbJ3J1bGVzJ10pIHtcbiAgICBsZXQgciQgPSBub2RlWydydWxlcyddO1xuICAgIGlmIChyJCAmJiAhX2hhc01peGluUnVsZXMociQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHIkLmxlbmd0aCwgcjtcbiAgICAgICAgKGkgPCBsKSAmJiAociA9IHIkW2ldKTsgaSsrKSB7XG4gICAgICAgIGNzc1RleHQgPSBzdHJpbmdpZnkociwgcHJlc2VydmVQcm9wZXJ0aWVzLCBjc3NUZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3NzVGV4dCA9IHByZXNlcnZlUHJvcGVydGllcyA/IG5vZGVbJ2Nzc1RleHQnXSA6XG4gICAgICAgIHJlbW92ZUN1c3RvbVByb3BzKG5vZGVbJ2Nzc1RleHQnXSk7XG4gICAgICBjc3NUZXh0ID0gY3NzVGV4dC50cmltKCk7XG4gICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICBjc3NUZXh0ID0gJyAgJyArIGNzc1RleHQgKyAnXFxuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZW1pdCBydWxlIGlmIHRoZXJlIGlzIGNzc1RleHRcbiAgaWYgKGNzc1RleHQpIHtcbiAgICBpZiAobm9kZVsnc2VsZWN0b3InXSkge1xuICAgICAgdGV4dCArPSBub2RlWydzZWxlY3RvciddICsgJyAnICsgT1BFTl9CUkFDRSArICdcXG4nO1xuICAgIH1cbiAgICB0ZXh0ICs9IGNzc1RleHQ7XG4gICAgaWYgKG5vZGVbJ3NlbGVjdG9yJ10pIHtcbiAgICAgIHRleHQgKz0gQ0xPU0VfQlJBQ0UgKyAnXFxuXFxuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxTdHlsZU5vZGU+fSBydWxlc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gX2hhc01peGluUnVsZXMocnVsZXMpIHtcbiAgbGV0IHIgPSBydWxlc1swXTtcbiAgcmV0dXJuIEJvb2xlYW4ocikgJiYgQm9vbGVhbihyWydzZWxlY3RvciddKSAmJiByWydzZWxlY3RvciddLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZW1vdmVDdXN0b21Qcm9wcyhjc3NUZXh0KSB7XG4gIGNzc1RleHQgPSByZW1vdmVDdXN0b21Qcm9wQXNzaWdubWVudChjc3NUZXh0KTtcbiAgcmV0dXJuIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQoY3NzVGV4dCkge1xuICByZXR1cm4gY3NzVGV4dFxuICAgIC5yZXBsYWNlKFJYLmN1c3RvbVByb3AsICcnKVxuICAgIC5yZXBsYWNlKFJYLm1peGluUHJvcCwgJycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KSB7XG4gIHJldHVybiBjc3NUZXh0XG4gICAgLnJlcGxhY2UoUlgubWl4aW5BcHBseSwgJycpXG4gICAgLnJlcGxhY2UoUlgudmFyQXBwbHksICcnKTtcbn1cblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5leHBvcnQgY29uc3QgdHlwZXMgPSB7XG4gIFNUWUxFX1JVTEU6IDEsXG4gIEtFWUZSQU1FU19SVUxFOiA3LFxuICBNRURJQV9SVUxFOiA0LFxuICBNSVhJTl9SVUxFOiAxMDAwXG59XG5cbmNvbnN0IE9QRU5fQlJBQ0UgPSAneyc7XG5jb25zdCBDTE9TRV9CUkFDRSA9ICd9JztcblxuLy8gaGVscGVyIHJlZ2V4cCdzXG5jb25zdCBSWCA9IHtcbiAgY29tbWVudHM6IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9naW0sXG4gIHBvcnQ6IC9AaW1wb3J0W147XSo7L2dpbSxcbiAgY3VzdG9tUHJvcDogLyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj8oPzpbO1xcbl18JCkvZ2ltLFxuICBtaXhpblByb3A6IC8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/e1tefV0qP30oPzpbO1xcbl18JCk/L2dpbSxcbiAgbWl4aW5BcHBseTogL0BhcHBseVxccypcXCg/W14pO10qXFwpP1xccyooPzpbO1xcbl18JCk/L2dpbSxcbiAgdmFyQXBwbHk6IC9bXjs6XSo/OlteO10qP3ZhclxcKFteO10qXFwpKD86WztcXG5dfCQpPy9naW0sXG4gIGtleWZyYW1lc1J1bGU6IC9eQFteXFxzXSprZXlmcmFtZXMvLFxuICBtdWx0aXBsZVNwYWNlczogL1xccysvZ1xufVxuXG5jb25zdCBWQVJfU1RBUlQgPSAnLS0nO1xuY29uc3QgTUVESUFfU1RBUlQgPSAnQG1lZGlhJztcbmNvbnN0IEFUX1NUQVJUID0gJ0AnO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2Nzcy1wYXJzZS5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuZXhwb3J0IGNvbnN0IFZBUl9BU1NJR04gPSAvKD86XnxbO1xcc3tdXFxzKikoLS1bXFx3LV0qPylcXHMqOlxccyooPzooKD86Jyg/OlxcXFwnfC4pKj8nfFwiKD86XFxcXFwifC4pKj9cInxcXChbXildKj9cXCl8W159O3tdKSspfFxceyhbXn1dKilcXH0oPzooPz1bO1xcc31dKXwkKSkvZ2k7XG5leHBvcnQgY29uc3QgTUlYSU5fTUFUQ0ggPSAvKD86XnxcXFcrKUBhcHBseVxccypcXCg/KFteKTtcXG5dKilcXCk/L2dpO1xuZXhwb3J0IGNvbnN0IFZBUl9DT05TVU1FRCA9IC8oLS1bXFx3LV0rKVxccyooWzosOyldfCQpL2dpO1xuZXhwb3J0IGNvbnN0IEFOSU1BVElPTl9NQVRDSCA9IC8oYW5pbWF0aW9uXFxzKjopfChhbmltYXRpb24tbmFtZVxccyo6KS87XG5leHBvcnQgY29uc3QgTUVESUFfTUFUQ0ggPSAvQG1lZGlhXFxzKC4qKS87XG5leHBvcnQgY29uc3QgSVNfVkFSID0gL14tLS87XG5leHBvcnQgY29uc3QgQlJBQ0tFVEVEID0gL1xce1tefV0qXFx9L2c7XG5leHBvcnQgY29uc3QgSE9TVF9QUkVGSVggPSAnKD86XnxbXi4jWzpdKSc7XG5leHBvcnQgY29uc3QgSE9TVF9TVUZGSVggPSAnKCR8Wy46W1xcXFxzPit+XSknO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2NvbW1vbi1yZWdleC5qc1xuLy8gbW9kdWxlIGlkID0gMjVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgeyBNSVhJTl9NQVRDSCwgVkFSX0FTU0lHTiB9IGZyb20gJy4vY29tbW9uLXJlZ2V4LmpzJztcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTmF0aXZlUHJvcGVydGllcyhlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gIC8vIHJlbW92ZSBwcmV2aW91cyBwcm9wZXJ0aWVzXG4gIGZvciAobGV0IHAgaW4gcHJvcGVydGllcykge1xuICAgIC8vIE5PVEU6IGZvciBiYyB3aXRoIHNoaW0sIGRvbid0IGFwcGx5IG51bGwgdmFsdWVzLlxuICAgIGlmIChwID09PSBudWxsKSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnJlbW92ZVByb3BlcnR5KHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHAsIHByb3BlcnRpZXNbcF0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgLyoqXG4gICAqIEBjb25zdCB7c3RyaW5nfVxuICAgKi9cbiAgY29uc3QgdmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgaWYgKCF2YWx1ZSkge1xuICAgIHJldHVybiAnJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdmFsdWUudHJpbSgpO1xuICB9XG59XG5cbi8qKlxuICogcmV0dXJuIHRydWUgaWYgYGNzc1RleHRgIGNvbnRhaW5zIGEgbWl4aW4gZGVmaW5pdGlvbiBvciBjb25zdW1wdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXRlY3RNaXhpbihjc3NUZXh0KSB7XG4gIGNvbnN0IGhhcyA9IE1JWElOX01BVENILnRlc3QoY3NzVGV4dCkgfHwgVkFSX0FTU0lHTi50ZXN0KGNzc1RleHQpO1xuICAvLyByZXNldCBzdGF0ZSBvZiB0aGUgcmVnZXhlc1xuICBNSVhJTl9NQVRDSC5sYXN0SW5kZXggPSAwO1xuICBWQVJfQVNTSUdOLmxhc3RJbmRleCA9IDA7XG4gIHJldHVybiBoYXM7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAyNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmxldCBzY2hlZHVsZWQgPSBmYWxzZTtcbmxldCBiZWZvcmVSZW5kZXJRdWV1ZSA9IFtdO1xubGV0IGFmdGVyUmVuZGVyUXVldWUgPSBbXTtcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG4gIHNjaGVkdWxlZCA9IHRydWU7XG4gIC8vIGJlZm9yZSBuZXh0IHJlbmRlclxuICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgc2NoZWR1bGVkID0gZmFsc2U7XG4gICAgZmx1c2hRdWV1ZShiZWZvcmVSZW5kZXJRdWV1ZSk7XG4gICAgLy8gYWZ0ZXIgdGhlIHJlbmRlclxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBydW5RdWV1ZShhZnRlclJlbmRlclF1ZXVlKTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoUXVldWUocXVldWUpIHtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcnVuUXVldWUocXVldWUpIHtcbiAgZm9yIChsZXQgaT0wLCBsPXF1ZXVlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGNhbGxNZXRob2QocXVldWUuc2hpZnQoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbE1ldGhvZChpbmZvKSB7XG4gIGNvbnN0IGNvbnRleHQgPSBpbmZvWzBdO1xuICBjb25zdCBjYWxsYmFjayA9IGluZm9bMV07XG4gIGNvbnN0IGFyZ3MgPSBpbmZvWzJdO1xuICB0cnkge1xuICAgIGNhbGxiYWNrLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICB9IGNhdGNoKGUpIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gIHdoaWxlIChiZWZvcmVSZW5kZXJRdWV1ZS5sZW5ndGggfHwgYWZ0ZXJSZW5kZXJRdWV1ZS5sZW5ndGgpIHtcbiAgICBmbHVzaFF1ZXVlKGJlZm9yZVJlbmRlclF1ZXVlKTtcbiAgICBmbHVzaFF1ZXVlKGFmdGVyUmVuZGVyUXVldWUpO1xuICB9XG4gIHNjaGVkdWxlZCA9IGZhbHNlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYmVmb3JlTmV4dFJlbmRlcihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICBpZiAoIXNjaGVkdWxlZCkge1xuICAgIHNjaGVkdWxlKCk7XG4gIH1cbiAgYmVmb3JlUmVuZGVyUXVldWUucHVzaChbY29udGV4dCwgY2FsbGJhY2ssIGFyZ3NdKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFmdGVyTmV4dFJlbmRlcihjb250ZXh0LCBjYWxsYmFjaywgYXJncykge1xuICBpZiAoIXNjaGVkdWxlZCkge1xuICAgIHNjaGVkdWxlKCk7XG4gIH1cbiAgYWZ0ZXJSZW5kZXJRdWV1ZS5wdXNoKFtjb250ZXh0LCBjYWxsYmFjaywgYXJnc10pO1xufVxuXG5leHBvcnQgeyBmbHVzaCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvcmVuZGVyLXN0YXR1cy5qc1xuLy8gbW9kdWxlIGlkID0gMjdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuXG5sZXQgZGVib3VuY2VyUXVldWUgPSBbXTtcblxuZXhwb3J0IGNvbnN0IGVucXVldWVEZWJvdW5jZXIgPSBmdW5jdGlvbihkZWJvdW5jZXIpIHtcbiAgZGVib3VuY2VyUXVldWUucHVzaChkZWJvdW5jZXIpO1xufTtcblxuZnVuY3Rpb24gZmx1c2hEZWJvdW5jZXJzKCkge1xuICBjb25zdCBkaWRGbHVzaCA9IEJvb2xlYW4oZGVib3VuY2VyUXVldWUubGVuZ3RoKTtcbiAgd2hpbGUgKGRlYm91bmNlclF1ZXVlLmxlbmd0aCkge1xuICAgIHRyeSB7XG4gICAgICBkZWJvdW5jZXJRdWV1ZS5zaGlmdCgpLmZsdXNoKCk7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGlkRmx1c2g7XG59XG5cbmV4cG9ydCBjb25zdCBmbHVzaCA9IGZ1bmN0aW9uKCkge1xuICBsZXQgc2hhZHlET00sIGRlYm91bmNlcnM7XG4gIGRvIHtcbiAgICBzaGFkeURPTSA9IHdpbmRvdy5TaGFkeURPTSAmJiBTaGFkeURPTS5mbHVzaCgpO1xuICAgIGlmICh3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltKSB7XG4gICAgICB3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0uZmx1c2goKTtcbiAgICB9XG4gICAgZGVib3VuY2VycyA9IGZsdXNoRGVib3VuY2VycygpO1xuICB9IHdoaWxlIChzaGFkeURPTSB8fCBkZWJvdW5jZXJzKTtcbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9mbHVzaC5qc1xuLy8gbW9kdWxlIGlkID0gMjhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuL2Jvb3QuanMnO1xuaW1wb3J0IHsgUHJvcGVydHlFZmZlY3RzIH0gZnJvbSAnLi4vbWl4aW5zL3Byb3BlcnR5LWVmZmVjdHMuanMnO1xuaW1wb3J0IHsgTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcblxuLy8gQmFzZSBjbGFzcyBmb3IgSFRNTFRlbXBsYXRlRWxlbWVudCBleHRlbnNpb24gdGhhdCBoYXMgcHJvcGVydHkgZWZmZWN0c1xuLy8gbWFjaGluZXJ5IGZvciBwcm9wYWdhdGluZyBob3N0IHByb3BlcnRpZXMgdG8gY2hpbGRyZW4uIFRoaXMgaXMgYW4gRVM1XG4vLyBjbGFzcyBvbmx5IGJlY2F1c2UgQmFiZWwgKGluY29ycmVjdGx5KSByZXF1aXJlcyBzdXBlcigpIGluIHRoZSBjbGFzc1xuLy8gY29uc3RydWN0b3IgZXZlbiB0aG91Z2ggbm8gYHRoaXNgIGlzIHVzZWQgYW5kIGl0IHJldHVybnMgYW4gaW5zdGFuY2UuXG5sZXQgbmV3SW5zdGFuY2UgPSBudWxsO1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIHtIVE1MVGVtcGxhdGVFbGVtZW50fVxuICovXG5mdW5jdGlvbiBIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uKCkgeyByZXR1cm4gbmV3SW5zdGFuY2U7IH1cbkhUTUxUZW1wbGF0ZUVsZW1lbnRFeHRlbnNpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShIVE1MVGVtcGxhdGVFbGVtZW50LnByb3RvdHlwZSwge1xuICBjb25zdHJ1Y3Rvcjoge1xuICAgIHZhbHVlOiBIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9uLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH1cbn0pO1xuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c31cbiAqIEBleHRlbmRzIHtIVE1MVGVtcGxhdGVFbGVtZW50RXh0ZW5zaW9ufVxuICovXG5jb25zdCBEYXRhVGVtcGxhdGUgPSBQcm9wZXJ0eUVmZmVjdHMoSFRNTFRlbXBsYXRlRWxlbWVudEV4dGVuc2lvbik7XG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfTXV0YWJsZURhdGF9XG4gKiBAZXh0ZW5kcyB7RGF0YVRlbXBsYXRlfVxuICovXG5jb25zdCBNdXRhYmxlRGF0YVRlbXBsYXRlID0gTXV0YWJsZURhdGEoRGF0YVRlbXBsYXRlKTtcblxuLy8gQXBwbGllcyBhIERhdGFUZW1wbGF0ZSBzdWJjbGFzcyB0byBhIDx0ZW1wbGF0ZT4gaW5zdGFuY2VcbmZ1bmN0aW9uIHVwZ3JhZGVUZW1wbGF0ZSh0ZW1wbGF0ZSwgY29uc3RydWN0b3IpIHtcbiAgbmV3SW5zdGFuY2UgPSB0ZW1wbGF0ZTtcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRlbXBsYXRlLCBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICBuZXcgY29uc3RydWN0b3IoKTtcbiAgbmV3SW5zdGFuY2UgPSBudWxsO1xufVxuXG4vLyBCYXNlIGNsYXNzIGZvciBUZW1wbGF0ZUluc3RhbmNlJ3Ncbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gKi9cbmNvbnN0IGJhc2UgPSBQcm9wZXJ0eUVmZmVjdHMoY2xhc3Mge30pO1xuXG4vKipcbiAqIEBwb2x5bWVyXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQGFwcGxpZXNNaXhpbiBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c1xuICogQHVucmVzdHJpY3RlZFxuICovXG5jbGFzcyBUZW1wbGF0ZUluc3RhbmNlQmFzZSBleHRlbmRzIGJhc2Uge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29uZmlndXJlUHJvcGVydGllcyhwcm9wcyk7XG4gICAgdGhpcy5yb290ID0gdGhpcy5fc3RhbXBUZW1wbGF0ZSh0aGlzLl9fZGF0YUhvc3QpO1xuICAgIC8vIFNhdmUgbGlzdCBvZiBzdGFtcGVkIGNoaWxkcmVuXG4gICAgbGV0IGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIGZvciAobGV0IG4gPSB0aGlzLnJvb3QuZmlyc3RDaGlsZDsgbjsgbj1uLm5leHRTaWJsaW5nKSB7XG4gICAgICBjaGlsZHJlbi5wdXNoKG4pO1xuICAgICAgbi5fX3RlbXBsYXRpemVJbnN0YW5jZSA9IHRoaXM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fdGVtcGxhdGl6ZU93bmVyLl9faGlkZVRlbXBsYXRlQ2hpbGRyZW5fXykge1xuICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbih0cnVlKTtcbiAgICB9XG4gICAgLy8gRmx1c2ggcHJvcHMgb25seSB3aGVuIHByb3BzIGFyZSBwYXNzZWQgaWYgaW5zdGFuY2UgcHJvcHMgZXhpc3RcbiAgICAvLyBvciB3aGVuIHRoZXJlIGlzbid0IGluc3RhbmNlIHByb3BzLlxuICAgIGxldCBvcHRpb25zID0gdGhpcy5fX3RlbXBsYXRpemVPcHRpb25zO1xuICAgIGlmICgocHJvcHMgJiYgb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB8fCAhb3B0aW9ucy5pbnN0YW5jZVByb3BzKSB7XG4gICAgICB0aGlzLl9lbmFibGVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBDb25maWd1cmUgdGhlIGdpdmVuIGBwcm9wc2AgYnkgY2FsbGluZyBgX3NldFBlbmRpbmdQcm9wZXJ0eWAuIEFsc29cbiAgICogc2V0cyBhbnkgcHJvcGVydGllcyBzdG9yZWQgaW4gYF9faG9zdFByb3BzYC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BzIE9iamVjdCBvZiBwcm9wZXJ0eSBuYW1lLXZhbHVlIHBhaXJzIHRvIHNldC5cbiAgICovXG4gIF9jb25maWd1cmVQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSB0aGlzLl9fdGVtcGxhdGl6ZU9wdGlvbnM7XG4gICAgaWYgKHByb3BzKSB7XG4gICAgICBmb3IgKGxldCBpcHJvcCBpbiBvcHRpb25zLmluc3RhbmNlUHJvcHMpIHtcbiAgICAgICAgaWYgKGlwcm9wIGluIHByb3BzKSB7XG4gICAgICAgICAgdGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KGlwcm9wLCBwcm9wc1tpcHJvcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobGV0IGhwcm9wIGluIHRoaXMuX19ob3N0UHJvcHMpIHtcbiAgICAgIHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eShocHJvcCwgdGhpcy5fX2RhdGFIb3N0WydfaG9zdF8nICsgaHByb3BdKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZvcndhcmRzIGEgaG9zdCBwcm9wZXJ0eSB0byB0aGlzIGluc3RhbmNlLiAgVGhpcyBtZXRob2Qgc2hvdWxkIGJlXG4gICAqIGNhbGxlZCBvbiBpbnN0YW5jZXMgZnJvbSB0aGUgYG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wYCBjYWxsYmFja1xuICAgKiB0byBwcm9wYWdhdGUgY2hhbmdlcyBvZiBob3N0IHByb3BlcnRpZXMgdG8gZWFjaCBpbnN0YW5jZS5cbiAgICpcbiAgICogTm90ZSB0aGlzIG1ldGhvZCBlbnF1ZXVlcyB0aGUgY2hhbmdlLCB3aGljaCBhcmUgZmx1c2hlZCBhcyBhIGJhdGNoLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBvciBwYXRoIG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSBvZiB0aGUgcHJvcGVydHkgdG8gZm9yd2FyZFxuICAgKi9cbiAgZm9yd2FyZEhvc3RQcm9wKHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3NldFBlbmRpbmdQcm9wZXJ0eU9yUGF0aChwcm9wLCB2YWx1ZSwgZmFsc2UsIHRydWUpKSB7XG4gICAgICB0aGlzLl9fZGF0YUhvc3QuX2VucXVldWVDbGllbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIF9hZGRFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgIGlmICh0aGlzLl9tZXRob2RIb3N0ICYmIHRoaXMuX190ZW1wbGF0aXplT3B0aW9ucy5wYXJlbnRNb2RlbCkge1xuICAgICAgLy8gSWYgdGhpcyBpbnN0YW5jZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIHBhcmVudCBtb2RlbCwgZGVjb3JhdGVcbiAgICAgIC8vIGV2ZW50cyB0aGlzIHRlbXBsYXRlIGluc3RhbmNlIGFzIGBtb2RlbGBcbiAgICAgIHRoaXMuX21ldGhvZEhvc3QuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCAoZSkgPT4ge1xuICAgICAgICBlLm1vZGVsID0gdGhpcztcbiAgICAgICAgaGFuZGxlcihlKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPdGhlcndpc2UgZGVsZWdhdGUgdG8gdGhlIHRlbXBsYXRlJ3MgaG9zdCAod2hpY2ggY291bGQgYmUpXG4gICAgICAvLyBhbm90aGVyIHRlbXBsYXRlIGluc3RhbmNlXG4gICAgICBsZXQgdGVtcGxhdGVIb3N0ID0gdGhpcy5fX2RhdGFIb3N0Ll9fZGF0YUhvc3Q7XG4gICAgICBpZiAodGVtcGxhdGVIb3N0KSB7XG4gICAgICAgIHRlbXBsYXRlSG9zdC5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogU2hvd3Mgb3IgaGlkZXMgdGhlIHRlbXBsYXRlIGluc3RhbmNlIHRvcCBsZXZlbCBjaGlsZCBlbGVtZW50cy4gRm9yXG4gICAqIHRleHQgbm9kZXMsIGB0ZXh0Q29udGVudGAgaXMgcmVtb3ZlZCB3aGlsZSBcImhpZGRlblwiIGFuZCByZXBsYWNlZCB3aGVuXG4gICAqIFwic2hvd24uXCJcbiAgICogQHBhcmFtIHtib29sZWFufSBoaWRlIFNldCB0byB0cnVlIHRvIGhpZGUgdGhlIGNoaWxkcmVuO1xuICAgKiBzZXQgdG8gZmFsc2UgdG8gc2hvdyB0aGVtLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2hvd0hpZGVDaGlsZHJlbihoaWRlKSB7XG4gICAgbGV0IGMgPSB0aGlzLmNoaWxkcmVuO1xuICAgIGZvciAobGV0IGk9MDsgaTxjLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbiA9IGNbaV07XG4gICAgICAvLyBJZ25vcmUgbm9uLWNoYW5nZXNcbiAgICAgIGlmIChCb29sZWFuKGhpZGUpICE9IEJvb2xlYW4obi5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18pKSB7XG4gICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgIGlmIChoaWRlKSB7XG4gICAgICAgICAgICBuLl9fcG9seW1lclRleHRDb250ZW50X18gPSBuLnRleHRDb250ZW50O1xuICAgICAgICAgICAgbi50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuLnRleHRDb250ZW50ID0gbi5fX3BvbHltZXJUZXh0Q29udGVudF9fO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChuLnN0eWxlKSB7XG4gICAgICAgICAgaWYgKGhpZGUpIHtcbiAgICAgICAgICAgIG4uX19wb2x5bWVyRGlzcGxheV9fID0gbi5zdHlsZS5kaXNwbGF5O1xuICAgICAgICAgICAgbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuLnN0eWxlLmRpc3BsYXkgPSBuLl9fcG9seW1lckRpc3BsYXlfXztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG4uX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fID0gaGlkZTtcbiAgICAgIGlmIChuLl9zaG93SGlkZUNoaWxkcmVuKSB7XG4gICAgICAgIG4uX3Nob3dIaWRlQ2hpbGRyZW4oaGlkZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBPdmVycmlkZXMgZGVmYXVsdCBwcm9wZXJ0eS1lZmZlY3RzIGltcGxlbWVudGF0aW9uIHRvIGludGVyY2VwdFxuICAgKiB0ZXh0Q29udGVudCBiaW5kaW5ncyB3aGlsZSBjaGlsZHJlbiBhcmUgXCJoaWRkZW5cIiBhbmQgY2FjaGUgaW5cbiAgICogcHJpdmF0ZSBzdG9yYWdlIGZvciBsYXRlciByZXRyaWV2YWwuXG4gICAqXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKSB7XG4gICAgaWYgKG5vZGUuX19oaWRlVGVtcGxhdGVDaGlsZHJlbl9fICYmXG4gICAgICAgIG5vZGUubm9kZVR5cGUgPT0gTm9kZS5URVhUX05PREUgJiYgcHJvcCA9PSAndGV4dENvbnRlbnQnKSB7XG4gICAgICBub2RlLl9fcG9seW1lclRleHRDb250ZW50X18gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuX3NldFVubWFuYWdlZFByb3BlcnR5VG9Ob2RlKG5vZGUsIHByb3AsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEZpbmQgdGhlIHBhcmVudCBtb2RlbCBvZiB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLiAgVGhlIHBhcmVudCBtb2RlbFxuICAgKiBpcyBlaXRoZXIgYW5vdGhlciB0ZW1wbGF0aXplIGluc3RhbmNlIHRoYXQgaGFkIG9wdGlvbiBgcGFyZW50TW9kZWw6IHRydWVgLFxuICAgKiBvciBlbHNlIHRoZSBob3N0IGVsZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge1BvbHltZXJfUHJvcGVydHlFZmZlY3RzfSBUaGUgcGFyZW50IG1vZGVsIG9mIHRoaXMgaW5zdGFuY2VcbiAgICovXG4gIGdldCBwYXJlbnRNb2RlbCgpIHtcbiAgICBsZXQgbW9kZWwgPSB0aGlzLl9fcGFyZW50TW9kZWw7XG4gICAgaWYgKCFtb2RlbCkge1xuICAgICAgbGV0IG9wdGlvbnM7XG4gICAgICBtb2RlbCA9IHRoaXM7XG4gICAgICBkbyB7XG4gICAgICAgIC8vIEEgdGVtcGxhdGUgaW5zdGFuY2UncyBgX19kYXRhSG9zdGAgaXMgYSA8dGVtcGxhdGU+XG4gICAgICAgIC8vIGBtb2RlbC5fX2RhdGFIb3N0Ll9fZGF0YUhvc3RgIGlzIHRoZSB0ZW1wbGF0ZSdzIGhvc3RcbiAgICAgICAgbW9kZWwgPSBtb2RlbC5fX2RhdGFIb3N0Ll9fZGF0YUhvc3Q7XG4gICAgICB9IHdoaWxlICgob3B0aW9ucyA9IG1vZGVsLl9fdGVtcGxhdGl6ZU9wdGlvbnMpICYmICFvcHRpb25zLnBhcmVudE1vZGVsKTtcbiAgICAgIHRoaXMuX19wYXJlbnRNb2RlbCA9IG1vZGVsO1xuICAgIH1cbiAgICByZXR1cm4gbW9kZWw7XG4gIH1cbn1cblxuLyoqIEB0eXBlIHshRGF0YVRlbXBsYXRlfSAqL1xuVGVtcGxhdGVJbnN0YW5jZUJhc2UucHJvdG90eXBlLl9fZGF0YUhvc3Q7XG4vKiogQHR5cGUgeyFUZW1wbGF0aXplT3B0aW9uc30gKi9cblRlbXBsYXRlSW5zdGFuY2VCYXNlLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPcHRpb25zO1xuLyoqIEB0eXBlIHshUG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX21ldGhvZEhvc3Q7XG4vKiogQHR5cGUgeyFPYmplY3R9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX190ZW1wbGF0aXplT3duZXI7XG4vKiogQHR5cGUgeyFPYmplY3R9ICovXG5UZW1wbGF0ZUluc3RhbmNlQmFzZS5wcm90b3R5cGUuX19ob3N0UHJvcHM7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9NdXRhYmxlRGF0YX1cbiAqL1xuY29uc3QgTXV0YWJsZVRlbXBsYXRlSW5zdGFuY2VCYXNlID0gTXV0YWJsZURhdGEoVGVtcGxhdGVJbnN0YW5jZUJhc2UpO1xuXG5mdW5jdGlvbiBmaW5kTWV0aG9kSG9zdCh0ZW1wbGF0ZSkge1xuICAvLyBUZWNobmljYWxseSB0aGlzIHNob3VsZCBiZSB0aGUgb3duZXIgb2YgdGhlIG91dGVybW9zdCB0ZW1wbGF0ZS5cbiAgLy8gSW4gc2hhZG93IGRvbSwgdGhpcyBpcyBhbHdheXMgZ2V0Um9vdE5vZGUoKS5ob3N0LCBidXQgd2UgY2FuXG4gIC8vIGFwcHJveGltYXRlIHRoaXMgdmlhIGNvb3BlcmF0aW9uIHdpdGggb3VyIGRhdGFIb3N0IGFsd2F5cyBzZXR0aW5nXG4gIC8vIGBfbWV0aG9kSG9zdGAgYXMgbG9uZyBhcyB0aGVyZSB3ZXJlIGJpbmRpbmdzIChvciBpZCdzKSBvbiB0aGlzXG4gIC8vIGluc3RhbmNlIGNhdXNpbmcgaXQgdG8gZ2V0IGEgZGF0YUhvc3QuXG4gIGxldCB0ZW1wbGF0ZUhvc3QgPSB0ZW1wbGF0ZS5fX2RhdGFIb3N0O1xuICByZXR1cm4gdGVtcGxhdGVIb3N0ICYmIHRlbXBsYXRlSG9zdC5fbWV0aG9kSG9zdCB8fCB0ZW1wbGF0ZUhvc3Q7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIHZhbGlkLWpzZG9jICovXG4vKipcbiAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9IGNsYXNzLnByb3RvdHlwZSBpcyBub3QgZGVmaW5lZCBmb3Igc29tZSByZWFzb25cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVGVtcGxhdGl6ZXJDbGFzcyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKSB7XG4gIC8vIEFub255bW91cyBjbGFzcyBjcmVhdGVkIGJ5IHRoZSB0ZW1wbGF0aXplXG4gIGxldCBiYXNlID0gb3B0aW9ucy5tdXRhYmxlRGF0YSA/XG4gICAgTXV0YWJsZVRlbXBsYXRlSW5zdGFuY2VCYXNlIDogVGVtcGxhdGVJbnN0YW5jZUJhc2U7XG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge2Jhc2V9XG4gICAqL1xuICBsZXQga2xhc3MgPSBjbGFzcyBleHRlbmRzIGJhc2UgeyB9O1xuICBrbGFzcy5wcm90b3R5cGUuX190ZW1wbGF0aXplT3B0aW9ucyA9IG9wdGlvbnM7XG4gIGtsYXNzLnByb3RvdHlwZS5fYmluZFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgYWRkTm90aWZ5RWZmZWN0cyhrbGFzcywgdGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucyk7XG4gIHJldHVybiBrbGFzcztcbn1cblxuLyoqXG4gKiBAc3VwcHJlc3Mge21pc3NpbmdQcm9wZXJ0aWVzfSBjbGFzcy5wcm90b3R5cGUgaXMgbm90IGRlZmluZWQgZm9yIHNvbWUgcmVhc29uXG4gKi9cbmZ1bmN0aW9uIGFkZFByb3BhZ2F0ZUVmZmVjdHModGVtcGxhdGUsIHRlbXBsYXRlSW5mbywgb3B0aW9ucykge1xuICBsZXQgdXNlckZvcndhcmRIb3N0UHJvcCA9IG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wO1xuICBpZiAodXNlckZvcndhcmRIb3N0UHJvcCkge1xuICAgIC8vIFByb3ZpZGUgZGF0YSBBUEkgYW5kIHByb3BlcnR5IGVmZmVjdHMgb24gbWVtb2l6ZWQgdGVtcGxhdGUgY2xhc3NcbiAgICBsZXQga2xhc3MgPSB0ZW1wbGF0ZUluZm8udGVtcGxhdGl6ZVRlbXBsYXRlQ2xhc3M7XG4gICAgaWYgKCFrbGFzcykge1xuICAgICAgbGV0IGJhc2UgPSBvcHRpb25zLm11dGFibGVEYXRhID8gTXV0YWJsZURhdGFUZW1wbGF0ZSA6IERhdGFUZW1wbGF0ZTtcbiAgICAgIGtsYXNzID0gdGVtcGxhdGVJbmZvLnRlbXBsYXRpemVUZW1wbGF0ZUNsYXNzID1cbiAgICAgICAgY2xhc3MgVGVtcGxhdGl6ZWRUZW1wbGF0ZSBleHRlbmRzIGJhc2Uge307XG4gICAgICAvLyBBZGQgdGVtcGxhdGUgLSA+aW5zdGFuY2VzIGVmZmVjdHNcbiAgICAgIC8vIGFuZCBob3N0IDwtIHRlbXBsYXRlIGVmZmVjdHNcbiAgICAgIGxldCBob3N0UHJvcHMgPSB0ZW1wbGF0ZUluZm8uaG9zdFByb3BzO1xuICAgICAgZm9yIChsZXQgcHJvcCBpbiBob3N0UHJvcHMpIHtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9hZGRQcm9wZXJ0eUVmZmVjdCgnX2hvc3RfJyArIHByb3AsXG4gICAgICAgICAga2xhc3MucHJvdG90eXBlLlBST1BFUlRZX0VGRkVDVF9UWVBFUy5QUk9QQUdBVEUsXG4gICAgICAgICAge2ZuOiBjcmVhdGVGb3J3YXJkSG9zdFByb3BFZmZlY3QocHJvcCwgdXNlckZvcndhcmRIb3N0UHJvcCl9KTtcbiAgICAgICAga2xhc3MucHJvdG90eXBlLl9jcmVhdGVOb3RpZnlpbmdQcm9wZXJ0eSgnX2hvc3RfJyArIHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgICB1cGdyYWRlVGVtcGxhdGUodGVtcGxhdGUsIGtsYXNzKTtcbiAgICAvLyBNaXggYW55IHByZS1ib3VuZCBkYXRhIGludG8gX19kYXRhOyBubyBuZWVkIHRvIGZsdXNoIHRoaXMgdG9cbiAgICAvLyBpbnN0YW5jZXMgc2luY2UgdGhleSBwdWxsIGZyb20gdGhlIHRlbXBsYXRlIGF0IGluc3RhbmNlLXRpbWVcbiAgICBpZiAodGVtcGxhdGUuX19kYXRhUHJvdG8pIHtcbiAgICAgIC8vIE5vdGUsIGdlbmVyYWxseSBgX19kYXRhUHJvdG9gIGNvdWxkIGJlIGNoYWluZWQsIGJ1dCBpdCdzIGd1YXJhbnRlZWRcbiAgICAgIC8vIHRvIG5vdCBiZSBzaW5jZSB0aGlzIGlzIGEgdmFuaWxsYSB0ZW1wbGF0ZSB3ZSBqdXN0IGFkZGVkIGVmZmVjdHMgdG9cbiAgICAgIE9iamVjdC5hc3NpZ24odGVtcGxhdGUuX19kYXRhLCB0ZW1wbGF0ZS5fX2RhdGFQcm90byk7XG4gICAgfVxuICAgIC8vIENsZWFyIGFueSBwZW5kaW5nIGRhdGEgZm9yIHBlcmZvcm1hbmNlXG4gICAgdGVtcGxhdGUuX19kYXRhVGVtcCA9IHt9O1xuICAgIHRlbXBsYXRlLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgIHRlbXBsYXRlLl9fZGF0YU9sZCA9IG51bGw7XG4gICAgdGVtcGxhdGUuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgfVxufVxuLyogZXNsaW50LWVuYWJsZSB2YWxpZC1qc2RvYyAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGb3J3YXJkSG9zdFByb3BFZmZlY3QoaG9zdFByb3AsIHVzZXJGb3J3YXJkSG9zdFByb3ApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGZvcndhcmRIb3N0UHJvcCh0ZW1wbGF0ZSwgcHJvcCwgcHJvcHMpIHtcbiAgICB1c2VyRm9yd2FyZEhvc3RQcm9wLmNhbGwodGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIsXG4gICAgICBwcm9wLnN1YnN0cmluZygnX2hvc3RfJy5sZW5ndGgpLCBwcm9wc1twcm9wXSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFkZE5vdGlmeUVmZmVjdHMoa2xhc3MsIHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpIHtcbiAgbGV0IGhvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHMgfHwge307XG4gIGZvciAobGV0IGlwcm9wIGluIG9wdGlvbnMuaW5zdGFuY2VQcm9wcykge1xuICAgIGRlbGV0ZSBob3N0UHJvcHNbaXByb3BdO1xuICAgIGxldCB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wID0gb3B0aW9ucy5ub3RpZnlJbnN0YW5jZVByb3A7XG4gICAgaWYgKHVzZXJOb3RpZnlJbnN0YW5jZVByb3ApIHtcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoaXByb3AsXG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuTk9USUZZLFxuICAgICAgICB7Zm46IGNyZWF0ZU5vdGlmeUluc3RhbmNlUHJvcEVmZmVjdChpcHJvcCwgdXNlck5vdGlmeUluc3RhbmNlUHJvcCl9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdGlvbnMuZm9yd2FyZEhvc3RQcm9wICYmIHRlbXBsYXRlLl9fZGF0YUhvc3QpIHtcbiAgICBmb3IgKGxldCBocHJvcCBpbiBob3N0UHJvcHMpIHtcbiAgICAgIGtsYXNzLnByb3RvdHlwZS5fYWRkUHJvcGVydHlFZmZlY3QoaHByb3AsXG4gICAgICAgIGtsYXNzLnByb3RvdHlwZS5QUk9QRVJUWV9FRkZFQ1RfVFlQRVMuTk9USUZZLFxuICAgICAgICB7Zm46IGNyZWF0ZU5vdGlmeUhvc3RQcm9wRWZmZWN0KCl9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTm90aWZ5SW5zdGFuY2VQcm9wRWZmZWN0KGluc3RQcm9wLCB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub3RpZnlJbnN0YW5jZVByb3AoaW5zdCwgcHJvcCwgcHJvcHMpIHtcbiAgICB1c2VyTm90aWZ5SW5zdGFuY2VQcm9wLmNhbGwoaW5zdC5fX3RlbXBsYXRpemVPd25lcixcbiAgICAgIGluc3QsIHByb3AsIHByb3BzW3Byb3BdKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm90aWZ5SG9zdFByb3BFZmZlY3QoKSB7XG4gIHJldHVybiBmdW5jdGlvbiBub3RpZnlIb3N0UHJvcChpbnN0LCBwcm9wLCBwcm9wcykge1xuICAgIGluc3QuX19kYXRhSG9zdC5fc2V0UGVuZGluZ1Byb3BlcnR5T3JQYXRoKCdfaG9zdF8nICsgcHJvcCwgcHJvcHNbcHJvcF0sIHRydWUsIHRydWUpO1xuICB9O1xufVxuXG4vKipcbiAqIE1vZHVsZSBmb3IgcHJlcGFyaW5nIGFuZCBzdGFtcGluZyBpbnN0YW5jZXMgb2YgdGVtcGxhdGVzIHRoYXQgdXRpbGl6ZVxuICogUG9seW1lcidzIGRhdGEtYmluZGluZyBhbmQgZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXIgZmVhdHVyZXMuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgLy8gR2V0IGEgdGVtcGxhdGUgZnJvbSBzb21ld2hlcmUsIGUuZy4gbGlnaHQgRE9NXG4gKiAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICogICAgIC8vIFByZXBhcmUgdGhlIHRlbXBsYXRlXG4gKiAgICAgbGV0IFRlbXBsYXRlQ2xhc3MgPSBQb2x5bWVyLlRlbXBsYXRpemUudGVtcGxhdGl6ZSh0ZW1wbGF0ZSk7XG4gKiAgICAgLy8gSW5zdGFuY2UgdGhlIHRlbXBsYXRlIHdpdGggYW4gaW5pdGlhbCBkYXRhIG1vZGVsXG4gKiAgICAgbGV0IGluc3RhbmNlID0gbmV3IFRlbXBsYXRlQ2xhc3Moe215UHJvcDogJ2luaXRpYWwnfSk7XG4gKiAgICAgLy8gSW5zZXJ0IHRoZSBpbnN0YW5jZSdzIERPTSBzb21ld2hlcmUsIGUuZy4gZWxlbWVudCdzIHNoYWRvdyBET01cbiAqICAgICB0aGlzLnNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQoaW5zdGFuY2Uucm9vdCk7XG4gKiAgICAgLy8gQ2hhbmdpbmcgYSBwcm9wZXJ0eSBvbiB0aGUgaW5zdGFuY2Ugd2lsbCBwcm9wYWdhdGUgdG8gYmluZGluZ3NcbiAqICAgICAvLyBpbiB0aGUgdGVtcGxhdGVcbiAqICAgICBpbnN0YW5jZS5teVByb3AgPSAnbmV3IHZhbHVlJztcbiAqXG4gKiBUaGUgYG9wdGlvbnNgIGRpY3Rpb25hcnkgcGFzc2VkIHRvIGB0ZW1wbGF0aXplYCBhbGxvd3MgZm9yIGN1c3RvbWl6aW5nXG4gKiBmZWF0dXJlcyBvZiB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIGNsYXNzLCBpbmNsdWRpbmcgaG93IG91dGVyLXNjb3BlIGhvc3RcbiAqIHByb3BlcnRpZXMgc2hvdWxkIGJlIGZvcndhcmRlZCBpbnRvIHRlbXBsYXRlIGluc3RhbmNlcywgaG93IGFueSBpbnN0YW5jZVxuICogcHJvcGVydGllcyBhZGRlZCBpbnRvIHRoZSB0ZW1wbGF0ZSdzIHNjb3BlIHNob3VsZCBiZSBub3RpZmllZCBvdXQgdG9cbiAqIHRoZSBob3N0LCBhbmQgd2hldGhlciB0aGUgaW5zdGFuY2Ugc2hvdWxkIGJlIGRlY29yYXRlZCBhcyBhIFwicGFyZW50IG1vZGVsXCJcbiAqIG9mIGFueSBldmVudCBoYW5kbGVycy5cbiAqXG4gKiAgICAgLy8gQ3VzdG9temUgcHJvcGVydHkgZm9yd2FyZGluZyBhbmQgZXZlbnQgbW9kZWwgZGVjb3JhdGlvblxuICogICAgIGxldCBUZW1wbGF0ZUNsYXNzID0gUG9seW1lci5UZW1wbGF0aXplLnRlbXBsYXRpemUodGVtcGxhdGUsIHRoaXMsIHtcbiAqICAgICAgIHBhcmVudE1vZGVsOiB0cnVlLFxuICogICAgICAgaW5zdGFuY2VQcm9wczogey4uLn0sXG4gKiAgICAgICBmb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKSB7Li4ufSxcbiAqICAgICAgIG5vdGlmeUluc3RhbmNlUHJvcChpbnN0YW5jZSwgcHJvcGVydHksIHZhbHVlKSB7Li4ufSxcbiAqICAgICB9KTtcbiAqXG4gKlxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IE1vZHVsZSBmb3IgcHJlcGFyaW5nIGFuZCBzdGFtcGluZyBpbnN0YW5jZXMgb2YgdGVtcGxhdGVzXG4gKiAgIHV0aWxpemluZyBQb2x5bWVyIHRlbXBsYXRpbmcgZmVhdHVyZXMuXG4gKi9cblxuY29uc3QgVGVtcGxhdGl6ZSA9IHtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhbm9ueW1vdXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBjbGFzcyBib3VuZCB0byB0aGVcbiAgICogYDx0ZW1wbGF0ZT5gIHByb3ZpZGVkLiAgSW5zdGFuY2luZyB0aGUgY2xhc3Mgd2lsbCByZXN1bHQgaW4gdGhlXG4gICAqIHRlbXBsYXRlIGJlaW5nIHN0YW1wZWQgaW50byBkb2N1bWVudCBmcmFnbWVudCBzdG9yZWQgYXMgdGhlIGluc3RhbmNlJ3NcbiAgICogYHJvb3RgIHByb3BlcnR5LCBhZnRlciB3aGljaCBpdCBjYW4gYmUgYXBwZW5kZWQgdG8gdGhlIERPTS5cbiAgICpcbiAgICogVGVtcGxhdGVzIG1heSB1dGlsaXplIGFsbCBQb2x5bWVyIGRhdGEtYmluZGluZyBmZWF0dXJlcyBhcyB3ZWxsIGFzXG4gICAqIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycy4gIEV2ZW50IGxpc3RlbmVycyBhbmQgaW5saW5lIGNvbXB1dGluZ1xuICAgKiBmdW5jdGlvbnMgaW4gdGhlIHRlbXBsYXRlIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSBob3N0IG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogVGhlIGNvbnN0cnVjdG9yIHJldHVybmVkIHRha2VzIGEgc2luZ2xlIGFyZ3VtZW50IGRpY3Rpb25hcnkgb2YgaW5pdGlhbFxuICAgKiBwcm9wZXJ0eSB2YWx1ZXMgdG8gcHJvcGFnYXRlIGludG8gdGVtcGxhdGUgYmluZGluZ3MuICBBZGRpdGlvbmFsbHlcbiAgICogaG9zdCBwcm9wZXJ0aWVzIGNhbiBiZSBmb3J3YXJkZWQgaW4sIGFuZCBpbnN0YW5jZSBwcm9wZXJ0aWVzIGNhbiBiZVxuICAgKiBub3RpZmllZCBvdXQgYnkgcHJvdmlkaW5nIG9wdGlvbmFsIGNhbGxiYWNrcyBpbiB0aGUgYG9wdGlvbnNgIGRpY3Rpb25hcnkuXG4gICAqXG4gICAqIFZhbGlkIGNvbmZpZ3VyYXRpb24gaW4gYG9wdGlvbnNgIGFyZSBhcyBmb2xsb3dzOlxuICAgKlxuICAgKiAtIGBmb3J3YXJkSG9zdFByb3AocHJvcGVydHksIHZhbHVlKWA6IENhbGxlZCB3aGVuIGEgcHJvcGVydHkgcmVmZXJlbmNlZFxuICAgKiAgIGluIHRoZSB0ZW1wbGF0ZSBjaGFuZ2VkIG9uIHRoZSB0ZW1wbGF0ZSdzIGhvc3QuIEFzIHRoaXMgbGlicmFyeSBkb2VzXG4gICAqICAgbm90IHJldGFpbiByZWZlcmVuY2VzIHRvIHRlbXBsYXRlcyBpbnN0YW5jZWQgYnkgdGhlIHVzZXIsIGl0IGlzIHRoZVxuICAgKiAgIHRlbXBsYXRpemUgb3duZXIncyByZXNwb25zaWJpbGl0eSB0byBmb3J3YXJkIGhvc3QgcHJvcGVydHkgY2hhbmdlcyBpbnRvXG4gICAqICAgdXNlci1zdGFtcGVkIGluc3RhbmNlcy4gIFRoZSBgaW5zdGFuY2UuZm9yd2FyZEhvc3RQcm9wKHByb3BlcnR5LCB2YWx1ZSlgXG4gICAqICAgIG1ldGhvZCBvbiB0aGUgZ2VuZXJhdGVkIGNsYXNzIHNob3VsZCBiZSBjYWxsZWQgdG8gZm9yd2FyZCBob3N0XG4gICAqICAgcHJvcGVydGllcyBpbnRvIHRoZSB0ZW1wbGF0ZSB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IHByb3BlcnR5LWNoYW5nZWRcbiAgICogICBub3RpZmljYXRpb25zLiBBbnkgcHJvcGVydGllcyByZWZlcmVuY2VkIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IGFyZSBub3RcbiAgICogICBkZWZpbmVkIGluIGBpbnN0YW5jZVByb3BzYCB3aWxsIGJlIG5vdGlmaWVkIHVwIHRvIHRoZSB0ZW1wbGF0ZSdzIGhvc3RcbiAgICogICBhdXRvbWF0aWNhbGx5LlxuICAgKiAtIGBpbnN0YW5jZVByb3BzYDogRGljdGlvbmFyeSBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IHdpbGwgYmUgYWRkZWRcbiAgICogICB0byB0aGUgaW5zdGFuY2UgYnkgdGhlIHRlbXBsYXRpemUgb3duZXIuICBUaGVzZSBwcm9wZXJ0aWVzIHNoYWRvdyBhbnlcbiAgICogICBob3N0IHByb3BlcnRpZXMsIGFuZCBjaGFuZ2VzIHdpdGhpbiB0aGUgdGVtcGxhdGUgdG8gdGhlc2UgcHJvcGVydGllc1xuICAgKiAgIHdpbGwgcmVzdWx0IGluIGBub3RpZnlJbnN0YW5jZVByb3BgIGJlaW5nIGNhbGxlZC5cbiAgICogLSBgbXV0YWJsZURhdGFgOiBXaGVuIGB0cnVlYCwgdGhlIGdlbmVyYXRlZCBjbGFzcyB3aWxsIHNraXAgc3RyaWN0XG4gICAqICAgZGlydHktY2hlY2tpbmcgZm9yIG9iamVjdHMgYW5kIGFycmF5cyAoYWx3YXlzIGNvbnNpZGVyIHRoZW0gdG8gYmVcbiAgICogICBcImRpcnR5XCIpLlxuICAgKiAtIGBub3RpZnlJbnN0YW5jZVByb3AoaW5zdGFuY2UsIHByb3BlcnR5LCB2YWx1ZSlgOiBDYWxsZWQgd2hlblxuICAgKiAgIGFuIGluc3RhbmNlIHByb3BlcnR5IGNoYW5nZXMuICBVc2VycyBtYXkgY2hvb3NlIHRvIGNhbGwgYG5vdGlmeVBhdGhgXG4gICAqICAgb24gZS5nLiB0aGUgb3duZXIgdG8gbm90aWZ5IHRoZSBjaGFuZ2UuXG4gICAqIC0gYHBhcmVudE1vZGVsYDogV2hlbiBgdHJ1ZWAsIGV2ZW50cyBoYW5kbGVkIGJ5IGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVyc1xuICAgKiAgIChgb24tZXZlbnQ9XCJoYW5kbGVyXCJgKSB3aWxsIGJlIGRlY29yYXRlZCB3aXRoIGEgYG1vZGVsYCBwcm9wZXJ0eSBwb2ludGluZ1xuICAgKiAgIHRvIHRoZSB0ZW1wbGF0ZSBpbnN0YW5jZSB0aGF0IHN0YW1wZWQgaXQuICBJdCB3aWxsIGFsc28gYmUgcmV0dXJuZWRcbiAgICogICBmcm9tIGBpbnN0YW5jZS5wYXJlbnRNb2RlbGAgaW4gY2FzZXMgd2hlcmUgdGVtcGxhdGUgaW5zdGFuY2UgbmVzdGluZ1xuICAgKiAgIGNhdXNlcyBhbiBpbm5lciBtb2RlbCB0byBzaGFkb3cgYW4gb3V0ZXIgbW9kZWwuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY2xhc3MgcmV0dXJuZWQgZnJvbSBgdGVtcGxhdGl6ZWAgaXMgZ2VuZXJhdGVkIG9ubHkgb25jZVxuICAgKiBmb3IgYSBnaXZlbiBgPHRlbXBsYXRlPmAgdXNpbmcgYG9wdGlvbnNgIGZyb20gdGhlIGZpcnN0IGNhbGwgZm9yIHRoYXRcbiAgICogdGVtcGxhdGUsIGFuZCB0aGUgY2FjaGVkIGNsYXNzIGlzIHJldHVybmVkIGZvciBhbGwgc3Vic2VxdWVudCBjYWxscyB0b1xuICAgKiBgdGVtcGxhdGl6ZWAgZm9yIHRoYXQgdGVtcGxhdGUuICBBcyBzdWNoLCBgb3B0aW9uc2AgY2FsbGJhY2tzIHNob3VsZCBub3RcbiAgICogY2xvc2Ugb3ZlciBvd25lci1zcGVjaWZpYyBwcm9wZXJ0aWVzIHNpbmNlIG9ubHkgdGhlIGZpcnN0IGBvcHRpb25zYCBpc1xuICAgKiB1c2VkOyByYXRoZXIsIGNhbGxiYWNrcyBhcmUgY2FsbGVkIGJvdW5kIHRvIHRoZSBgb3duZXJgLCBhbmQgc28gY29udGV4dFxuICAgKiBuZWVkZWQgZnJvbSB0aGUgY2FsbGJhY2tzIChzdWNoIGFzIHJlZmVyZW5jZXMgdG8gYGluc3RhbmNlc2Agc3RhbXBlZClcbiAgICogc2hvdWxkIGJlIHN0b3JlZCBvbiB0aGUgYG93bmVyYCBzdWNoIHRoYXQgdGhleSBjYW4gYmUgcmV0cmlldmVkIHZpYSBgdGhpc2AuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLlRlbXBsYXRpemVcbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gdGVtcGxhdGl6ZVxuICAgKiBAcGFyYW0geyFQb2x5bWVyX1Byb3BlcnR5RWZmZWN0c30gb3duZXIgT3duZXIgb2YgdGhlIHRlbXBsYXRlIGluc3RhbmNlcztcbiAgICogICBhbnkgb3B0aW9uYWwgY2FsbGJhY2tzIHdpbGwgYmUgYm91bmQgdG8gdGhpcyBvd25lci5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIE9wdGlvbnMgZGljdGlvbmFyeSAoc2VlIHN1bW1hcnkgZm9yIGRldGFpbHMpXG4gICAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpUZW1wbGF0ZUluc3RhbmNlQmFzZSl9IEdlbmVyYXRlZCBjbGFzcyBib3VuZCB0byB0aGUgdGVtcGxhdGVcbiAgICogICBwcm92aWRlZFxuICAgKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0c31cbiAgICovXG4gIHRlbXBsYXRpemUodGVtcGxhdGUsIG93bmVyLCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IC8qKiBAdHlwZSB7IVRlbXBsYXRpemVPcHRpb25zfSAqLyhvcHRpb25zIHx8IHt9KTtcbiAgICBpZiAodGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQSA8dGVtcGxhdGU+IGNhbiBvbmx5IGJlIHRlbXBsYXRpemVkIG9uY2UnKTtcbiAgICB9XG4gICAgdGVtcGxhdGUuX190ZW1wbGF0aXplT3duZXIgPSBvd25lcjtcbiAgICBsZXQgdGVtcGxhdGVJbmZvID0gb3duZXIuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgIC8vIEdldCBtZW1vaXplZCBiYXNlIGNsYXNzIGZvciB0aGUgcHJvdG90eXBpY2FsIHRlbXBsYXRlLCB3aGljaFxuICAgIC8vIGluY2x1ZGVzIHByb3BlcnR5IGVmZmVjdHMgZm9yIGJpbmRpbmcgdGVtcGxhdGUgJiBmb3J3YXJkaW5nXG4gICAgbGV0IGJhc2VDbGFzcyA9IHRlbXBsYXRlSW5mby50ZW1wbGF0aXplSW5zdGFuY2VDbGFzcztcbiAgICBpZiAoIWJhc2VDbGFzcykge1xuICAgICAgYmFzZUNsYXNzID0gY3JlYXRlVGVtcGxhdGl6ZXJDbGFzcyh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCBvcHRpb25zKTtcbiAgICAgIHRlbXBsYXRlSW5mby50ZW1wbGF0aXplSW5zdGFuY2VDbGFzcyA9IGJhc2VDbGFzcztcbiAgICB9XG4gICAgLy8gSG9zdCBwcm9wZXJ0eSBmb3J3YXJkaW5nIG11c3QgYmUgaW5zdGFsbGVkIG9udG8gdGVtcGxhdGUgaW5zdGFuY2VcbiAgICBhZGRQcm9wYWdhdGVFZmZlY3RzKHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG9wdGlvbnMpO1xuICAgIC8vIFN1YmNsYXNzIGJhc2UgY2xhc3MgYW5kIGFkZCByZWZlcmVuY2UgZm9yIHRoaXMgc3BlY2lmaWMgdGVtcGxhdGVcbiAgICBsZXQga2xhc3MgPSBjbGFzcyBUZW1wbGF0ZUluc3RhbmNlIGV4dGVuZHMgYmFzZUNsYXNzIHt9O1xuICAgIGtsYXNzLnByb3RvdHlwZS5fbWV0aG9kSG9zdCA9IGZpbmRNZXRob2RIb3N0KHRlbXBsYXRlKTtcbiAgICBrbGFzcy5wcm90b3R5cGUuX19kYXRhSG9zdCA9IHRlbXBsYXRlO1xuICAgIGtsYXNzLnByb3RvdHlwZS5fX3RlbXBsYXRpemVPd25lciA9IG93bmVyO1xuICAgIGtsYXNzLnByb3RvdHlwZS5fX2hvc3RQcm9wcyA9IHRlbXBsYXRlSW5mby5ob3N0UHJvcHM7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7ZnVuY3Rpb24obmV3OlRlbXBsYXRlSW5zdGFuY2VCYXNlKX0gKi8oa2xhc3MpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2hcbiAgICogc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXNcbiAgICogY29udGFpbmVkIGluLiBBIHRlbXBsYXRlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mXG4gICAqIGBUZW1wbGF0ZUluc3RhbmNlQmFzZWAsIGFuZCBzaG91bGQgYmUgdXNlZCB0byBtYW5pcHVsYXRlIGRhdGFcbiAgICogYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqICAgbGV0IG1vZGVsID0gbW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICogICBpZiAobW9kZWwuaW5kZXggPCAxMCkge1xuICAgKiAgICAgbW9kZWwuc2V0KCdpdGVtLmNoZWNrZWQnLCB0cnVlKTtcbiAgICogICB9XG4gICAqXG4gICAqIEBtZW1iZXJvZiBQb2x5bWVyLlRlbXBsYXRpemVcbiAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUaGUgbW9kZWwgd2lsbCBiZSByZXR1cm5lZCBmb3JcbiAgICogICBlbGVtZW50cyBzdGFtcGVkIGZyb20gdGhpcyB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSBmb3Igd2hpY2ggdG8gcmV0dXJuIGEgdGVtcGxhdGUgbW9kZWwuXG4gICAqIEByZXR1cm4ge1RlbXBsYXRlSW5zdGFuY2VCYXNlfSBUZW1wbGF0ZSBpbnN0YW5jZSByZXByZXNlbnRpbmcgdGhlXG4gICAqICAgYmluZGluZyBzY29wZSBmb3IgdGhlIGVsZW1lbnRcbiAgICovXG4gIG1vZGVsRm9yRWxlbWVudCh0ZW1wbGF0ZSwgbm9kZSkge1xuICAgIGxldCBtb2RlbDtcbiAgICB3aGlsZSAobm9kZSkge1xuICAgICAgLy8gQW4gZWxlbWVudCB3aXRoIGEgX190ZW1wbGF0aXplSW5zdGFuY2UgbWFya3MgdGhlIHRvcCBib3VuZGFyeVxuICAgICAgLy8gb2YgYSBzY29wZTsgd2FsayB1cCB1bnRpbCB3ZSBmaW5kIG9uZSwgYW5kIHRoZW4gZW5zdXJlIHRoYXRcbiAgICAgIC8vIGl0cyBfX2RhdGFIb3N0IG1hdGNoZXMgYHRoaXNgLCBtZWFuaW5nIHRoaXMgZG9tLXJlcGVhdCBzdGFtcGVkIGl0XG4gICAgICBpZiAoKG1vZGVsID0gbm9kZS5fX3RlbXBsYXRpemVJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gRm91bmQgYW4gZWxlbWVudCBzdGFtcGVkIGJ5IGFub3RoZXIgdGVtcGxhdGU7IGtlZXAgd2Fsa2luZyB1cFxuICAgICAgICAvLyBmcm9tIGl0cyBfX2RhdGFIb3N0XG4gICAgICAgIGlmIChtb2RlbC5fX2RhdGFIb3N0ICE9IHRlbXBsYXRlKSB7XG4gICAgICAgICAgbm9kZSA9IG1vZGVsLl9fZGF0YUhvc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTdGlsbCBpbiBhIHRlbXBsYXRlIHNjb3BlLCBrZWVwIGdvaW5nIHVwIHVudGlsXG4gICAgICAgIC8vIGEgX190ZW1wbGF0aXplSW5zdGFuY2UgaXMgZm91bmRcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbmV4cG9ydCB7IFRlbXBsYXRpemUgfTtcbmV4cG9ydCB7IFRlbXBsYXRlSW5zdGFuY2VCYXNlIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy90ZW1wbGF0aXplLmpzXG4vLyBtb2R1bGUgaWQgPSAyOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQTExeUtleXNCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi9pcm9uLWNvbnRyb2wtc3RhdGUuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25CdXR0b25TdGF0ZUltcGwgPSB7XG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIHVzZXIgaXMgY3VycmVudGx5IGhvbGRpbmcgZG93biB0aGUgYnV0dG9uLlxuICAgICAqL1xuICAgIHByZXNzZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICByZWFkT25seTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIG9ic2VydmVyOiAnX3ByZXNzZWRDaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCB0aGUgYnV0dG9uIHRvZ2dsZXMgdGhlIGFjdGl2ZSBzdGF0ZSB3aXRoIGVhY2ggdGFwIG9yIHByZXNzXG4gICAgICogb2YgdGhlIHNwYWNlYmFyLlxuICAgICAqL1xuICAgIHRvZ2dsZXM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJ1dHRvbiBpcyBhIHRvZ2dsZSBhbmQgaXMgY3VycmVudGx5IGluIHRoZSBhY3RpdmUgc3RhdGUuXG4gICAgICovXG4gICAgYWN0aXZlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IGJlaW5nIHByZXNzZWQgYnkgYSBcInBvaW50ZXIsXCIgd2hpY2hcbiAgICAgKiBpcyBsb29zZWx5IGRlZmluZWQgYXMgbW91c2Ugb3IgdG91Y2ggaW5wdXQgKGJ1dCBzcGVjaWZpY2FsbHkgZXhjbHVkaW5nXG4gICAgICoga2V5Ym9hcmQgaW5wdXQpLlxuICAgICAqL1xuICAgIHBvaW50ZXJEb3duOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgaW5wdXQgZGV2aWNlIHRoYXQgY2F1c2VkIHRoZSBlbGVtZW50IHRvIHJlY2VpdmUgZm9jdXNcbiAgICAgKiB3YXMgYSBrZXlib2FyZC5cbiAgICAgKi9cbiAgICByZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIGFyaWEgYXR0cmlidXRlIHRvIGJlIHNldCBpZiB0aGUgYnV0dG9uIGlzIGEgdG9nZ2xlIGFuZCBpbiB0aGVcbiAgICAgKiBhY3RpdmUgc3RhdGUuXG4gICAgICovXG4gICAgYXJpYUFjdGl2ZUF0dHJpYnV0ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdhcmlhLXByZXNzZWQnLFxuICAgICAgb2JzZXJ2ZXI6ICdfYXJpYUFjdGl2ZUF0dHJpYnV0ZUNoYW5nZWQnXG4gICAgfVxuICB9LFxuXG4gIGxpc3RlbmVyczoge1xuICAgIGRvd246ICdfZG93bkhhbmRsZXInLFxuICAgIHVwOiAnX3VwSGFuZGxlcicsXG4gICAgdGFwOiAnX3RhcEhhbmRsZXInXG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19mb2N1c0NoYW5nZWQoZm9jdXNlZCknLFxuICAgICdfYWN0aXZlQ2hhbmdlZChhY3RpdmUsIGFyaWFBY3RpdmVBdHRyaWJ1dGUpJ1xuICBdLFxuXG4gIGtleUJpbmRpbmdzOiB7XG4gICAgJ2VudGVyOmtleWRvd24nOiAnX2FzeW5jQ2xpY2snLFxuICAgICdzcGFjZTprZXlkb3duJzogJ19zcGFjZUtleURvd25IYW5kbGVyJyxcbiAgICAnc3BhY2U6a2V5dXAnOiAnX3NwYWNlS2V5VXBIYW5kbGVyJyxcbiAgfSxcblxuICBfbW91c2VFdmVudFJlOiAvXm1vdXNlLyxcblxuICBfdGFwSGFuZGxlcjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMudG9nZ2xlcykge1xuICAgICAvLyBhIHRhcCBpcyBuZWVkZWQgdG8gdG9nZ2xlIHRoZSBhY3RpdmUgc3RhdGVcbiAgICAgIHRoaXMuX3VzZXJBY3RpdmF0ZSghdGhpcy5hY3RpdmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfSxcblxuICBfZm9jdXNDaGFuZ2VkOiBmdW5jdGlvbihmb2N1c2VkKSB7XG4gICAgdGhpcy5fZGV0ZWN0S2V5Ym9hcmRGb2N1cyhmb2N1c2VkKTtcblxuICAgIGlmICghZm9jdXNlZCkge1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIF9kZXRlY3RLZXlib2FyZEZvY3VzOiBmdW5jdGlvbihmb2N1c2VkKSB7XG4gICAgdGhpcy5fc2V0UmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCghdGhpcy5wb2ludGVyRG93biAmJiBmb2N1c2VkKTtcbiAgfSxcblxuICAvLyB0byBlbXVsYXRlIG5hdGl2ZSBjaGVja2JveCwgKGRlLSlhY3RpdmF0aW9ucyBmcm9tIGEgdXNlciBpbnRlcmFjdGlvbiBmaXJlXG4gIC8vICdjaGFuZ2UnIGV2ZW50c1xuICBfdXNlckFjdGl2YXRlOiBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICBpZiAodGhpcy5hY3RpdmUgIT09IGFjdGl2ZSkge1xuICAgICAgdGhpcy5hY3RpdmUgPSBhY3RpdmU7XG4gICAgICB0aGlzLmZpcmUoJ2NoYW5nZScpO1xuICAgIH1cbiAgfSxcblxuICBfZG93bkhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5fc2V0UG9pbnRlckRvd24odHJ1ZSk7XG4gICAgdGhpcy5fc2V0UHJlc3NlZCh0cnVlKTtcbiAgICB0aGlzLl9zZXRSZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKGZhbHNlKTtcbiAgfSxcblxuICBfdXBIYW5kbGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZXRQb2ludGVyRG93bihmYWxzZSk7XG4gICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUtleWJvYXJkRXZlbnR9IGV2ZW50IC5cbiAgICovXG4gIF9zcGFjZUtleURvd25IYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBrZXlib2FyZEV2ZW50ID0gZXZlbnQuZGV0YWlsLmtleWJvYXJkRXZlbnQ7XG4gICAgdmFyIHRhcmdldCA9IGRvbShrZXlib2FyZEV2ZW50KS5sb2NhbFRhcmdldDtcblxuICAgIC8vIElnbm9yZSB0aGUgZXZlbnQgaWYgdGhpcyBpcyBjb21pbmcgZnJvbSBhIGZvY3VzZWQgbGlnaHQgY2hpbGQsIHNpbmNlIHRoYXRcbiAgICAvLyBlbGVtZW50IHdpbGwgZGVhbCB3aXRoIGl0LlxuICAgIGlmICh0aGlzLmlzTGlnaHREZXNjZW5kYW50KC8qKiBAdHlwZSB7Tm9kZX0gKi8odGFyZ2V0KSkpXG4gICAgICByZXR1cm47XG5cbiAgICBrZXlib2FyZEV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAga2V5Ym9hcmRFdmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICB0aGlzLl9zZXRQcmVzc2VkKHRydWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldmVudCAuXG4gICAqL1xuICBfc3BhY2VLZXlVcEhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGtleWJvYXJkRXZlbnQgPSBldmVudC5kZXRhaWwua2V5Ym9hcmRFdmVudDtcbiAgICB2YXIgdGFyZ2V0ID0gZG9tKGtleWJvYXJkRXZlbnQpLmxvY2FsVGFyZ2V0O1xuXG4gICAgLy8gSWdub3JlIHRoZSBldmVudCBpZiB0aGlzIGlzIGNvbWluZyBmcm9tIGEgZm9jdXNlZCBsaWdodCBjaGlsZCwgc2luY2UgdGhhdFxuICAgIC8vIGVsZW1lbnQgd2lsbCBkZWFsIHdpdGggaXQuXG4gICAgaWYgKHRoaXMuaXNMaWdodERlc2NlbmRhbnQoLyoqIEB0eXBlIHtOb2RlfSAqLyh0YXJnZXQpKSlcbiAgICAgIHJldHVybjtcblxuICAgIGlmICh0aGlzLnByZXNzZWQpIHtcbiAgICAgIHRoaXMuX2FzeW5jQ2xpY2soKTtcbiAgICB9XG4gICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gIH0sXG5cbiAgLy8gdHJpZ2dlciBjbGljayBhc3luY2hyb25vdXNseSwgdGhlIGFzeW5jaHJvbnkgaXMgdXNlZnVsIHRvIGFsbG93IG9uZVxuICAvLyBldmVudCBoYW5kbGVyIHRvIHVud2luZCBiZWZvcmUgdHJpZ2dlcmluZyBhbm90aGVyIGV2ZW50XG4gIF9hc3luY0NsaWNrOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGljaygpO1xuICAgIH0sIDEpO1xuICB9LFxuXG4gIC8vIGFueSBvZiB0aGVzZSBjaGFuZ2VzIGFyZSBjb25zaWRlcmVkIGEgY2hhbmdlIHRvIGJ1dHRvbiBzdGF0ZVxuXG4gIF9wcmVzc2VkQ2hhbmdlZDogZnVuY3Rpb24ocHJlc3NlZCkge1xuICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICB9LFxuXG4gIF9hcmlhQWN0aXZlQXR0cmlidXRlQ2hhbmdlZDogZnVuY3Rpb24odmFsdWUsIG9sZFZhbHVlKSB7XG4gICAgaWYgKG9sZFZhbHVlICYmIG9sZFZhbHVlICE9IHZhbHVlICYmIHRoaXMuaGFzQXR0cmlidXRlKG9sZFZhbHVlKSkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUob2xkVmFsdWUpO1xuICAgIH1cbiAgfSxcblxuICBfYWN0aXZlQ2hhbmdlZDogZnVuY3Rpb24oYWN0aXZlLCBhcmlhQWN0aXZlQXR0cmlidXRlKSB7XG4gICAgaWYgKHRoaXMudG9nZ2xlcykge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUodGhpcy5hcmlhQWN0aXZlQXR0cmlidXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZlID8gJ3RydWUnIDogJ2ZhbHNlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKHRoaXMuYXJpYUFjdGl2ZUF0dHJpYnV0ZSk7XG4gICAgfVxuICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICB9LFxuXG4gIF9jb250cm9sU3RhdGVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5kaXNhYmxlZCkge1xuICAgICAgdGhpcy5fc2V0UHJlc3NlZChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2NoYW5nZWRCdXR0b25TdGF0ZSgpO1xuICAgIH1cbiAgfSxcblxuICAvLyBwcm92aWRlIGhvb2sgZm9yIGZvbGxvdy1vbiBiZWhhdmlvcnMgdG8gcmVhY3QgdG8gYnV0dG9uLXN0YXRlXG5cbiAgX2NoYW5nZWRCdXR0b25TdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX2J1dHRvblN0YXRlQ2hhbmdlZCkge1xuICAgICAgdGhpcy5fYnV0dG9uU3RhdGVDaGFuZ2VkKCk7IC8vIGFic3RyYWN0XG4gICAgfVxuICB9XG5cbn07XG5cbmV4cG9ydCBjb25zdCBJcm9uQnV0dG9uU3RhdGUgPSBbXG4gIElyb25BMTF5S2V5c0JlaGF2aW9yLFxuICBJcm9uQnV0dG9uU3RhdGVJbXBsXG5dO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1iZWhhdmlvcnMvaXJvbi1idXR0b24tc3RhdGUuanNcbi8vIG1vZHVsZSBpZCA9IDMwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBmdW5jdGlvbiBhamF4KHVybCwgZGF0YSwgbWV0aG9kLCBoZWFkZXJzLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgdmFyIGNvbmZpZyA9IHttZXRob2Q6IG1ldGhvZCwgaGVhZGVyczogaGVhZGVyc307XG4gIGlmICh0eXBlb2YgZGF0YSAhPSBcInVuZGVmaW5lZFwiKSB7XG4gICAgY29uZmlnLmJvZHkgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgfVxuICBmZXRjaCh1cmwsIGNvbmZpZylcbiAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXNwb25zZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignRmFpbGVkIHRvIHBvc3QgZGF0YScpKTtcbiAgICB9XG4gIH0pXG4gIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSkgLy8gcGFyc2UgcmVzcG9uc2UgYXMgSlNPTlxuICAudGhlbihkYXRhID0+IHtcbiAgICBpZiAodHlwZW9mIHN1Y2Nlc3NDYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICBzdWNjZXNzQ2FsbGJhY2soZGF0YSk7XG4gICAgfVxuICB9KVxuICAuY2F0Y2goZnVuY3Rpb24oZXJyb3IpIHtcbiAgICBjb25zb2xlLmxvZyhgRXJyb3I6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgICBpZiAodHlwZW9mIGVycm9yQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgZXJyb3JDYWxsYmFjayhlcnJvcik7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFqYXhHZXQodXJsLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBhamF4KHVybCwgdW5kZWZpbmVkLCBcIkdFVFwiLCBoZWFkZXJzLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWpheFBvc3QodXJsLCBkYXRhLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBoZWFkZXJzLmFwcGVuZChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gIGFqYXgodXJsLCBkYXRhLCBcIlBPU1RcIiwgaGVhZGVycywgc3VjY2Vzc0NhbGxiYWNrLCBlcnJvckNhbGxiYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFqYXhQdXQodXJsLCBkYXRhLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spIHtcbiAgdmFyIGhlYWRlcnMgPSBuZXcgSGVhZGVycygpO1xuICBoZWFkZXJzLmFwcGVuZChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gIGFqYXgodXJsLCBkYXRhLCBcIlBVVFwiLCBoZWFkZXJzLCBzdWNjZXNzQ2FsbGJhY2ssIGVycm9yQ2FsbGJhY2spO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdGFjdGlsZS9jbGllbnQvYWpheC5qcyIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudCc7XG5pbXBvcnQgeyBhamF4R2V0LCBhamF4UG9zdCwgYWpheFB1dCB9IGZyb20gXCIuL2FqYXguanNcIjtcbmltcG9ydCB7aHRtbCwgcmVuZGVyfSBmcm9tICdsaXQtaHRtbCc7XG5pbXBvcnQgeyBjYW1lbENhc2VUb1RpdGxlIH0gZnJvbSAnLi9zdHJpbmdVdGlscy5qcyc7XG5pbXBvcnQgXCJAcG9seW1lci9wYXBlci1kaWFsb2cvcGFwZXItZGlhbG9nXCI7XG5pbXBvcnQgXCJAcG9seW1lci9wYXBlci1idXR0b24vcGFwZXItYnV0dG9uXCI7XG5pbXBvcnQgXCJAcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dFwiO1xuaW1wb3J0IFwiQHBvbHltZXIvcGFwZXItY2hlY2tib3gvcGFwZXItY2hlY2tib3hcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFjdGlsZUF1dGhvciBleHRlbmRzIFBvbHltZXJFbGVtZW50IHtcbiAgc3RhdGljIGdldCBpcygpIHtcbiAgICByZXR1cm4gXCJ0YWN0aWxlLWF1dGhvclwiO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgcHJvcGVydGllcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGF0aDoge1xuICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgX2NyZWF0ZUlucHV0cyhjb21wb25lbnQpIHtcbiAgICB2YXIgaW5wdXRzID0gWyBdO1xuICAgIGNvbXBvbmVudC5hdXRob3IuYXR0cnMuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgIGlmIChpbnB1dC50eXBlID09PSBcIlN0cmluZ1wiKSB7XG4gICAgICAgIGlucHV0cy5wdXNoKFxuICAgICAgICAgIGh0bWxgPHBhcGVyLWlucHV0XG4gICAgICAgICAgICAgICAgbmFtZT0ke2lucHV0Lm5hbWV9XG4gICAgICAgICAgICAgICAgbGFiZWw9JHtpbnB1dC50aXRsZX1cbiAgICAgICAgICAgICAgICB2YWx1ZT0ke2NvbXBvbmVudFtpbnB1dC5uYW1lXX0+PC9wYXBlci1pbnB1dD5gKTtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQudHlwZSA9PT0gXCJCb29sZWFuXCIpIHtcbiAgICAgICAgaWYgKGNvbXBvbmVudFtpbnB1dC5uYW1lXSkge1xuICAgICAgICAgIGlucHV0cy5wdXNoKGh0bWxgPHBhcGVyLWNoZWNrYm94IG5hbWU9JHtpbnB1dC5uYW1lfSBjaGVja2VkPiR7aW5wdXQudGl0bGV9PC9wYXBlci1jaGVja2JveD5gKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnB1dHMucHVzaChodG1sYDxwYXBlci1jaGVja2JveCBuYW1lPSR7aW5wdXQubmFtZX0+JHtpbnB1dC50aXRsZX08L3BhcGVyLWNoZWNrYm94PmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGlucHV0cztcbiAgfVxuXG4gIF9jcmVhdGVNZXNzYWdlKGNvbXBvbmVudCkge1xuICAgIHJldHVybiBodG1sYFxuICAgICAgPGgyPiR7Y29tcG9uZW50LmF1dGhvci50aXRsZX08L2gyPlxuICAgICAgPHA+JHtjb21wb25lbnQuYXV0aG9yLmRlc2NyaXB0aW9ufTwvcD5gO1xuICB9XG5cbiAgX2NyZWF0ZUJ1dHRvbnMoY29tcG9uZW50KSB7XG4gICAgdmFyIGV4dHJhQnV0dG9ucyA9IFsgXTtcbiAgICBjb21wb25lbnQuYXV0aG9yLmF0dHJzLmZvckVhY2goKGlucHV0KSA9PiB7XG4gICAgICBpZiAoaW5wdXQudHlwZSA9PT0gXCJBZGRcIikge1xuICAgICAgICB2YXIgYnV0dG9uID0gaHRtbGA8cGFwZXItYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJ0YWN0aWxlLWFkZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS1wYXRoPSR7aW5wdXQucGF0aH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLXRlbXBsYXRlPSR7SlNPTi5zdHJpbmdpZnkoaW5wdXQudGVtcGxhdGUpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEtY29tcC10eXBlPSR7aW5wdXQuY29tcFR5cGV9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICR7aW5wdXQudGl0bGV9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIDwvcGFwZXItYnV0dG9uPmA7XG5cbiAgICAgICAgZXh0cmFCdXR0b25zLnB1c2goYnV0dG9uKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBodG1sYFxuICAgICAgPGRpdiBjbGFzcz1cImJ1dHRvbnNcIj5cbiAgICAgICAgJHtleHRyYUJ1dHRvbnN9XG4gICAgICAgIDxwYXBlci1idXR0b24gZGlhbG9nLWRpc21pc3M+RGVjbGluZTwvcGFwZXItYnV0dG9uPlxuICAgICAgICA8cGFwZXItYnV0dG9uIGRpYWxvZy1jb25maXJtIGF1dG9mb2N1cz5BY2NlcHQ8L3BhcGVyLWJ1dHRvbj5cbiAgICAgIDwvZGl2PmA7XG4gIH1cblxuICBvcGVuRGlhbG9nKGNhbGxiYWNrKSB7XG4gICAgYWpheEdldCh0aGlzLnBhdGgrXCIuanNvblwiLCAoY29tcG9uZW50KSA9PiB7XG4gICAgICB2YXIgc2hhZG93ID0gdGhpcy5zaGFkb3dSb290O1xuICAgICAgaWYgKCEgdGhpcy5zaGFkb3dSb290KSB7XG4gICAgICAgIHNoYWRvdyA9IHRoaXMuYXR0YWNoU2hhZG93KHttb2RlOiBcIm9wZW5cIn0pO1xuICAgICAgfVxuXG4gICAgICB2YXIgaW5wdXRzID0gdGhpcy5fY3JlYXRlSW5wdXRzKGNvbXBvbmVudCk7XG4gICAgICB2YXIgbWVzc2FnZSA9IHRoaXMuX2NyZWF0ZU1lc3NhZ2UoY29tcG9uZW50KTtcbiAgICAgIHZhciBidXR0b25zID0gdGhpcy5fY3JlYXRlQnV0dG9ucyhjb21wb25lbnQpO1xuXG4gICAgICByZW5kZXIoaHRtbGBcbiAgICAgICAgPHBhcGVyLWRpYWxvZyBtb2RhbCBzdHlsZT1cIm1pbi13aWR0aDogNjAwcHg7XCI+XG4gICAgICAgICAgJHttZXNzYWdlfVxuICAgICAgICAgICR7aW5wdXRzfVxuICAgICAgICAgICR7YnV0dG9uc31cbiAgICAgICAgPC9wYXBlci1kaWFsb2c+YCwgc2hhZG93KTtcblxuICAgICAgdmFyIHBhcGVyRGlhbG9nID0gc2hhZG93LnF1ZXJ5U2VsZWN0b3IoXCJwYXBlci1kaWFsb2dcIilcbiAgICAgIHBhcGVyRGlhbG9nLm9wZW4oKTtcblxuICAgICAgcGFwZXJEaWFsb2cucXVlcnlTZWxlY3RvcihcInBhcGVyLWJ1dHRvblwiKS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKGUpID0+IHtcbiAgICAgICAgaWYgKGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhcInRhY3RpbGUtYWRkXCIpKSB7XG4gICAgICAgICAgdmFyIHBhdGggPSB0aGlzLnBhdGgrXCIvXCIrZS50YXJnZXQuZGF0YXNldC5wYXRoO1xuICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IEpTT04ucGFyc2UoZS50YXJnZXQuZGF0YXNldC50ZW1wbGF0ZSk7XG4gICAgICAgICAgYWpheFB1dChwYXRoLCB0ZW1wbGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgdmFyIGlyb25PdmVybGF5Q2xvc2VkSGFuZGxlciA9IChlKSA9PiB7XG4gICAgICAgIC8vIFRPRE8gSW5zcGVjdCB0aGUgaW5wdXQgZWxlbWVudHMgZm9yIHRoZSB2YWx1ZXMgdG8gc2VuZCBvdmVyIGEgUE9TVFxuICAgICAgICAvLyBBUEkgZm9yIHVwZGF0aW5nIGNvbnRlbnQuanNvblxuICAgICAgICBpZiAoZS5kZXRhaWwuY29uZmlybWVkKSB7XG4gICAgICAgICAgdmFyIG5ld1ZhbHVlcyA9IHt9O1xuICAgICAgICAgIHNoYWRvdy5xdWVyeVNlbGVjdG9yQWxsKFwicGFwZXItaW5wdXRcIikuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQudmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWVzW2lucHV0Lm5hbWVdID0gaW5wdXQudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdWYWx1ZXNbaW5wdXQubmFtZV0gPSBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNoYWRvdy5xdWVyeVNlbGVjdG9yQWxsKFwicGFwZXItY2hlY2tib3hcIikuZm9yRWFjaCgoaW5wdXQpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5wdXQudmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coaW5wdXQuYWN0aXZlKTtcbiAgICAgICAgICAgICAgbmV3VmFsdWVzW2lucHV0Lm5hbWVdID0gaW5wdXQuYWN0aXZlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWVzW2lucHV0Lm5hbWVdID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYWpheFBvc3QodGhpcy5wYXRoLCBuZXdWYWx1ZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFwZXJEaWFsb2cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlyb24tb3ZlcmxheS1jbG9zZWRcIiwgaXJvbk92ZXJsYXlDbG9zZWRIYW5kbGVyKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cblxuICAgICAgcGFwZXJEaWFsb2cuYWRkRXZlbnRMaXN0ZW5lcihcImlyb24tb3ZlcmxheS1jbG9zZWRcIiwgaXJvbk92ZXJsYXlDbG9zZWRIYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBSZWdpc3RlciBjdXN0b20gZWxlbWVudCBjbGFzcyB3aXRoIGJyb3dzZXJcbmN1c3RvbUVsZW1lbnRzLmRlZmluZShUYWN0aWxlQXV0aG9yLmlzLCBUYWN0aWxlQXV0aG9yKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3RhY3RpbGUvY2xpZW50L3RhY3RpbGUtYXV0aG9yLmpzIiwiaW1wb3J0IHsgcmVzb2x2ZUNzcyB9IGZyb20gJy4vcmVzb2x2ZS11cmwuanMnO1xuXG5jb25zdCBNT0RVTEVfU1RZTEVfTElOS19TRUxFQ1RPUiA9ICdsaW5rW3JlbD1pbXBvcnRdW3R5cGV+PWNzc10nO1xuY29uc3QgSU5DTFVERV9BVFRSID0gJ2luY2x1ZGUnO1xuXG5mdW5jdGlvbiBpbXBvcnRNb2R1bGUobW9kdWxlSWQpIHtcbiAgY29uc3QgLyoqIFBvbHltZXIuRG9tTW9kdWxlICovIFBvbHltZXJEb21Nb2R1bGUgPSBjdXN0b21FbGVtZW50cy5nZXQoJ2RvbS1tb2R1bGUnKTtcbiAgaWYgKCFQb2x5bWVyRG9tTW9kdWxlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIFBvbHltZXJEb21Nb2R1bGUuaW1wb3J0KG1vZHVsZUlkKTtcbn1cblxuLyoqIEB0eXBlZGVmIHt7YXNzZXRwYXRoOiBzdHJpbmd9fSAqL1xubGV0IHRlbXBsYXRlV2l0aEFzc2V0UGF0aDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbU1vZHVsZXMobW9kdWxlSWRzKSB7XG4gIGxldCBtb2R1bGVzID0gbW9kdWxlSWRzLnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBmb3IgKGxldCBpPTA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY3NzVGV4dCArPSBjc3NGcm9tTW9kdWxlKG1vZHVsZXNbaV0pO1xuICB9XG4gIHJldHVybiBjc3NUZXh0O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3NzRnJvbU1vZHVsZShtb2R1bGVJZCkge1xuICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gIGlmIChtICYmIG0uX2Nzc1RleHQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIG1vZHVsZSBpbXBvcnRzOiA8bGluayByZWw9XCJpbXBvcnRcIiB0eXBlPVwiY3NzXCI+XG4gICAgbGV0IGNzc1RleHQgPSBfY3NzRnJvbU1vZHVsZUltcG9ydHMobSk7XG4gICAgLy8gaW5jbHVkZSBjc3MgZnJvbSB0aGUgZmlyc3QgdGVtcGxhdGUgaW4gdGhlIG1vZHVsZVxuICAgIGxldCB0ID0gbS5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgIGlmICh0KSB7XG4gICAgICBjc3NUZXh0ICs9IGNzc0Zyb21UZW1wbGF0ZSh0LCAvKiogQHR5cGUge3RlbXBsYXRlV2l0aEFzc2V0UGF0aH0gKi8obSkuYXNzZXRwYXRoKTtcbiAgICB9XG4gICAgbS5fY3NzVGV4dCA9IGNzc1RleHQgfHwgbnVsbDtcbiAgfVxuICBpZiAoIW0pIHtcbiAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmaW5kIHN0eWxlIGRhdGEgaW4gbW9kdWxlIG5hbWVkJywgbW9kdWxlSWQpO1xuICB9XG4gIHJldHVybiBtICYmIG0uX2Nzc1RleHQgfHwgJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tVGVtcGxhdGUodGVtcGxhdGUsIGJhc2VVUkkpIHtcbiAgbGV0IGNzc1RleHQgPSAnJztcbiAgLy8gaWYgZWxlbWVudCBpcyBhIHRlbXBsYXRlLCBnZXQgY29udGVudCBmcm9tIGl0cyAuY29udGVudFxuICBsZXQgZSQgPSB0ZW1wbGF0ZS5jb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJyk7XG4gIGZvciAobGV0IGk9MDsgaSA8IGUkLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGUgPSBlJFtpXTtcbiAgICAvLyBzdXBwb3J0IHN0eWxlIHNoYXJpbmcgYnkgYWxsb3dpbmcgc3R5bGVzIHRvIFwiaW5jbHVkZVwiXG4gICAgLy8gb3RoZXIgZG9tLW1vZHVsZXMgdGhhdCBjb250YWluIHN0eWxpbmdcbiAgICBsZXQgaW5jbHVkZSA9IGUuZ2V0QXR0cmlidXRlKElOQ0xVREVfQVRUUik7XG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIGNzc1RleHQgKz0gY3NzRnJvbU1vZHVsZXMoaW5jbHVkZSk7XG4gICAgfVxuICAgIGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKTtcbiAgICBjc3NUZXh0ICs9IGJhc2VVUkkgP1xuICAgICAgcmVzb2x2ZUNzcyhlLnRleHRDb250ZW50LCBiYXNlVVJJKSA6IGUudGV4dENvbnRlbnQ7XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjc3NGcm9tTW9kdWxlSW1wb3J0cyhtb2R1bGVJZCkge1xuICBsZXQgbSA9IGltcG9ydE1vZHVsZShtb2R1bGVJZCk7XG4gIHJldHVybiBtID8gX2Nzc0Zyb21Nb2R1bGVJbXBvcnRzKG0pIDogJyc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfY3NzRnJvbU1vZHVsZUltcG9ydHMobW9kdWxlKSB7XG4gIGxldCBjc3NUZXh0ID0gJyc7XG4gIGxldCBwJCA9IG1vZHVsZS5xdWVyeVNlbGVjdG9yQWxsKE1PRFVMRV9TVFlMRV9MSU5LX1NFTEVDVE9SKTtcbiAgZm9yIChsZXQgaT0wOyBpIDwgcCQubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgcCA9IHAkW2ldO1xuICAgIGlmIChwLmltcG9ydCkge1xuICAgICAgbGV0IGltcG9ydERvYyA9IHAuaW1wb3J0O1xuICAgICAgLy8gTk9URTogcG9seWZpbGwgYWZmb3JkYW5jZS5cbiAgICAgIC8vIHVuZGVyIHRoZSBIVE1MSW1wb3J0cyBwb2x5ZmlsbCwgdGhlcmUgd2lsbCBiZSBubyAnYm9keScsXG4gICAgICAvLyBidXQgdGhlIGltcG9ydCBwc2V1ZG8tZG9jIGNhbiBiZSB1c2VkIGRpcmVjdGx5LlxuICAgICAgbGV0IGNvbnRhaW5lciA9IGltcG9ydERvYy5ib2R5ID8gaW1wb3J0RG9jLmJvZHkgOiBpbXBvcnREb2M7XG4gICAgICBjc3NUZXh0ICs9XG4gICAgICAgIHJlc29sdmVDc3MoY29udGFpbmVyLnRleHRDb250ZW50LFxuICAgICAgICAgIGltcG9ydERvYy5iYXNlVVJJKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNzc1RleHQ7XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9zdHlsZS1nYXRoZXIuanNcbi8vIG1vZHVsZSBpZCA9IDMzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXRcbiAqIGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdFxuICogaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cbi8qKlxuICogVHlwZVNjcmlwdCBoYXMgYSBwcm9ibGVtIHdpdGggcHJlY29tcGlsaW5nIHRlbXBsYXRlcyBsaXRlcmFsc1xuICogaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy8xNzk1NlxuICpcbiAqIFRPRE8oanVzdGluZmFnbmFuaSk6IFJ1biB0ZXN0cyBjb21waWxlZCB0byBFUzUgd2l0aCBib3RoIEJhYmVsIGFuZFxuICogVHlwZVNjcmlwdCB0byB2ZXJpZnkgY29ycmVjdG5lc3MuXG4gKi9cbmNvbnN0IGVudkNhY2hlc1RlbXBsYXRlcyA9ICgodCkgPT4gdCgpID09PSB0KCkpKCgpID0+ICgocykgPT4gcykgYGApO1xuLy8gVGhlIGZpcnN0IGFyZ3VtZW50IHRvIEpTIHRlbXBsYXRlIHRhZ3MgcmV0YWluIGlkZW50aXR5IGFjcm9zcyBtdWx0aXBsZVxuLy8gY2FsbHMgdG8gYSB0YWcgZm9yIHRoZSBzYW1lIGxpdGVyYWwsIHNvIHdlIGNhbiBjYWNoZSB3b3JrIGRvbmUgcGVyIGxpdGVyYWxcbi8vIGluIGEgTWFwLlxuY29uc3QgdGVtcGxhdGVzID0gbmV3IE1hcCgpO1xuY29uc3Qgc3ZnVGVtcGxhdGVzID0gbmV3IE1hcCgpO1xuLyoqXG4gKiBJbnRlcnByZXRzIGEgdGVtcGxhdGUgbGl0ZXJhbCBhcyBhbiBIVE1MIHRlbXBsYXRlIHRoYXQgY2FuIGVmZmljaWVudGx5XG4gKiByZW5kZXIgdG8gYW5kIHVwZGF0ZSBhIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGNvbnN0IGh0bWwgPSAoc3RyaW5ncywgLi4udmFsdWVzKSA9PiBsaXRUYWcoc3RyaW5ncywgdmFsdWVzLCB0ZW1wbGF0ZXMsIGZhbHNlKTtcbi8qKlxuICogSW50ZXJwcmV0cyBhIHRlbXBsYXRlIGxpdGVyYWwgYXMgYW4gU1ZHIHRlbXBsYXRlIHRoYXQgY2FuIGVmZmljaWVudGx5XG4gKiByZW5kZXIgdG8gYW5kIHVwZGF0ZSBhIGNvbnRhaW5lci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN2ZyA9IChzdHJpbmdzLCAuLi52YWx1ZXMpID0+IGxpdFRhZyhzdHJpbmdzLCB2YWx1ZXMsIHN2Z1RlbXBsYXRlcywgdHJ1ZSk7XG5mdW5jdGlvbiBsaXRUYWcoc3RyaW5ncywgdmFsdWVzLCB0ZW1wbGF0ZXMsIGlzU3ZnKSB7XG4gICAgY29uc3Qga2V5ID0gZW52Q2FjaGVzVGVtcGxhdGVzID9cbiAgICAgICAgc3RyaW5ncyA6XG4gICAgICAgIHN0cmluZ3Muam9pbigne3stLXVuaXF1ZW5lc3Mtd29ya2Fyb3VuZC0tfX0nKTtcbiAgICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZXMuZ2V0KGtleSk7XG4gICAgaWYgKHRlbXBsYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGVtcGxhdGUgPSBuZXcgVGVtcGxhdGUoc3RyaW5ncywgaXNTdmcpO1xuICAgICAgICB0ZW1wbGF0ZXMuc2V0KGtleSwgdGVtcGxhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRlbXBsYXRlUmVzdWx0KHRlbXBsYXRlLCB2YWx1ZXMpO1xufVxuLyoqXG4gKiBUaGUgcmV0dXJuIHR5cGUgb2YgYGh0bWxgLCB3aGljaCBob2xkcyBhIFRlbXBsYXRlIGFuZCB0aGUgdmFsdWVzIGZyb21cbiAqIGludGVycG9sYXRlZCBleHByZXNzaW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZSwgdmFsdWVzKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgfVxufVxuLyoqXG4gKiBSZW5kZXJzIGEgdGVtcGxhdGUgdG8gYSBjb250YWluZXIuXG4gKlxuICogVG8gdXBkYXRlIGEgY29udGFpbmVyIHdpdGggbmV3IHZhbHVlcywgcmVldmFsdWF0ZSB0aGUgdGVtcGxhdGUgbGl0ZXJhbCBhbmRcbiAqIGNhbGwgYHJlbmRlcmAgd2l0aCB0aGUgbmV3IHJlc3VsdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlbmRlcihyZXN1bHQsIGNvbnRhaW5lciwgcGFydENhbGxiYWNrID0gZGVmYXVsdFBhcnRDYWxsYmFjaykge1xuICAgIGxldCBpbnN0YW5jZSA9IGNvbnRhaW5lci5fX3RlbXBsYXRlSW5zdGFuY2U7XG4gICAgLy8gUmVwZWF0IHJlbmRlciwganVzdCBjYWxsIHVwZGF0ZSgpXG4gICAgaWYgKGluc3RhbmNlICE9PSB1bmRlZmluZWQgJiYgaW5zdGFuY2UudGVtcGxhdGUgPT09IHJlc3VsdC50ZW1wbGF0ZSAmJlxuICAgICAgICBpbnN0YW5jZS5fcGFydENhbGxiYWNrID09PSBwYXJ0Q2FsbGJhY2spIHtcbiAgICAgICAgaW5zdGFuY2UudXBkYXRlKHJlc3VsdC52YWx1ZXMpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIEZpcnN0IHJlbmRlciwgY3JlYXRlIGEgbmV3IFRlbXBsYXRlSW5zdGFuY2UgYW5kIGFwcGVuZCBpdFxuICAgIGluc3RhbmNlID0gbmV3IFRlbXBsYXRlSW5zdGFuY2UocmVzdWx0LnRlbXBsYXRlLCBwYXJ0Q2FsbGJhY2spO1xuICAgIGNvbnRhaW5lci5fX3RlbXBsYXRlSW5zdGFuY2UgPSBpbnN0YW5jZTtcbiAgICBjb25zdCBmcmFnbWVudCA9IGluc3RhbmNlLl9jbG9uZSgpO1xuICAgIGluc3RhbmNlLnVwZGF0ZShyZXN1bHQudmFsdWVzKTtcbiAgICBsZXQgY2hpbGQ7XG4gICAgd2hpbGUgKChjaGlsZCA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpKSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgfVxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG59XG4vKipcbiAqIEFuIGV4cHJlc3Npb24gbWFya2VyIHdpdGggZW1iZWRkZWQgdW5pcXVlIGtleSB0byBhdm9pZFxuICogaHR0cHM6Ly9naXRodWIuY29tL1BvbHltZXJMYWJzL2xpdC1odG1sL2lzc3Vlcy82MlxuICovXG5jb25zdCBhdHRyaWJ1dGVNYXJrZXIgPSBge3tsaXQtJHtNYXRoLnJhbmRvbSgpfX19YDtcbi8qKlxuICogUmVnZXggdG8gc2NhbiB0aGUgc3RyaW5nIHByZWNlZGluZyBhbiBleHByZXNzaW9uIHRvIHNlZSBpZiB3ZSdyZSBpbiBhIHRleHRcbiAqIGNvbnRleHQsIGFuZCBub3QgYW4gYXR0cmlidXRlIGNvbnRleHQuXG4gKlxuICogVGhpcyB3b3JrcyBieSBzZWVpbmcgaWYgd2UgaGF2ZSBhIGA+YCBub3QgZm9sbG93ZWQgYnkgYSBgPGAuIElmIHRoZXJlIGlzIGFcbiAqIGA8YCBjbG9zZXIgdG8gdGhlIGVuZCBvZiB0aGUgc3RyaW5ncywgdGhlbiB3ZSdyZSBpbnNpZGUgYSB0YWcuXG4gKi9cbmNvbnN0IHRleHRSZWdleCA9IC8+W148XSokLztcbmNvbnN0IGhhc1RhZ3NSZWdleCA9IC9bXjxdKi87XG5jb25zdCB0ZXh0TWFya2VyQ29udGVudCA9ICdfLWxpdC1odG1sLV8nO1xuY29uc3QgdGV4dE1hcmtlciA9IGA8IS0tJHt0ZXh0TWFya2VyQ29udGVudH0tLT5gO1xuY29uc3QgYXR0ck9yVGV4dFJlZ2V4ID0gbmV3IFJlZ0V4cChgJHthdHRyaWJ1dGVNYXJrZXJ9fCR7dGV4dE1hcmtlcn1gKTtcbi8qKlxuICogQSBwbGFjZWhvbGRlciBmb3IgYSBkeW5hbWljIGV4cHJlc3Npb24gaW4gYW4gSFRNTCB0ZW1wbGF0ZS5cbiAqXG4gKiBUaGVyZSBhcmUgdHdvIGJ1aWx0LWluIHBhcnQgdHlwZXM6IEF0dHJpYnV0ZVBhcnQgYW5kIE5vZGVQYXJ0LiBOb2RlUGFydHNcbiAqIGFsd2F5cyByZXByZXNlbnQgYSBzaW5nbGUgZHluYW1pYyBleHByZXNzaW9uLCB3aGlsZSBBdHRyaWJ1dGVQYXJ0cyBtYXlcbiAqIHJlcHJlc2VudCBhcyBtYW55IGV4cHJlc3Npb25zIGFyZSBjb250YWluZWQgaW4gdGhlIGF0dHJpYnV0ZS5cbiAqXG4gKiBBIFRlbXBsYXRlJ3MgcGFydHMgYXJlIG11dGFibGUsIHNvIHBhcnRzIGNhbiBiZSByZXBsYWNlZCBvciBtb2RpZmllZFxuICogKHBvc3NpYmx5IHRvIGltcGxlbWVudCBkaWZmZXJlbnQgdGVtcGxhdGUgc2VtYW50aWNzKS4gVGhlIGNvbnRyYWN0IGlzIHRoYXRcbiAqIHBhcnRzIGNhbiBvbmx5IGJlIHJlcGxhY2VkLCBub3QgcmVtb3ZlZCwgYWRkZWQgb3IgcmVvcmRlcmVkLCBhbmQgcGFydHMgbXVzdFxuICogYWx3YXlzIGNvbnN1bWUgdGhlIGNvcnJlY3QgbnVtYmVyIG9mIHZhbHVlcyBpbiB0aGVpciBgdXBkYXRlKClgIG1ldGhvZC5cbiAqXG4gKiBUT0RPKGp1c3RpbmZhZ25hbmkpOiBUaGF0IHJlcXVpcmVtZW50IGlzIGEgbGl0dGxlIGZyYWdpbGUuIEFcbiAqIFRlbXBsYXRlSW5zdGFuY2UgY291bGQgaW5zdGVhZCBiZSBtb3JlIGNhcmVmdWwgYWJvdXQgd2hpY2ggdmFsdWVzIGl0IGdpdmVzXG4gKiB0byBQYXJ0LnVwZGF0ZSgpLlxuICovXG5leHBvcnQgY2xhc3MgVGVtcGxhdGVQYXJ0IHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBpbmRleCwgbmFtZSwgcmF3TmFtZSwgc3RyaW5ncykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMucmF3TmFtZSA9IHJhd05hbWU7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRlbXBsYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihzdHJpbmdzLCBzdmcgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnBhcnRzID0gW107XG4gICAgICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuICAgICAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fZ2V0SHRtbChzdHJpbmdzLCBzdmcpO1xuICAgICAgICAvLyBFZGdlIG5lZWRzIGFsbCA0IHBhcmFtZXRlcnMgcHJlc2VudDsgSUUxMSBuZWVkcyAzcmQgcGFyYW1ldGVyIHRvIGJlIG51bGxcbiAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcih0aGlzLmVsZW1lbnQuY29udGVudCwgMTMzIC8qIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfFxuICAgICAgICAgICAgICAgTm9kZUZpbHRlci5TSE9XX1RFWFQgKi8sIG51bGwsIGZhbHNlKTtcbiAgICAgICAgbGV0IGluZGV4ID0gLTE7XG4gICAgICAgIGxldCBwYXJ0SW5kZXggPSAwO1xuICAgICAgICBjb25zdCBub2Rlc1RvUmVtb3ZlID0gW107XG4gICAgICAgIC8vIFRoZSBhY3R1YWwgcHJldmlvdXMgbm9kZSwgYWNjb3VudGluZyBmb3IgcmVtb3ZhbHM6IGlmIGEgbm9kZSBpcyByZW1vdmVkXG4gICAgICAgIC8vIGl0IHdpbGwgbmV2ZXIgYmUgdGhlIHByZXZpb3VzTm9kZS5cbiAgICAgICAgbGV0IHByZXZpb3VzTm9kZTtcbiAgICAgICAgLy8gVXNlZCB0byBzZXQgcHJldmlvdXNOb2RlIGF0IHRoZSB0b3Agb2YgdGhlIGxvb3AuXG4gICAgICAgIGxldCBjdXJyZW50Tm9kZTtcbiAgICAgICAgd2hpbGUgKHdhbGtlci5uZXh0Tm9kZSgpKSB7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgcHJldmlvdXNOb2RlID0gY3VycmVudE5vZGU7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gY3VycmVudE5vZGUgPSB3YWxrZXIuY3VycmVudE5vZGU7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gMSAvKiBOb2RlLkVMRU1FTlRfTk9ERSAqLykge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGF0dHJpYnV0ZXMuaXRlbShpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXR0cmlidXRlU3RyaW5ncyA9IGF0dHJpYnV0ZS52YWx1ZS5zcGxpdChhdHRyT3JUZXh0UmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlU3RyaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRlbXBsYXRlIGxpdGVyYWwgc2VjdGlvbiBsZWFkaW5nIHVwIHRvIHRoZSBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXhwcmVzc2lvbiBpbiB0aGlzIGF0dHJpYnV0ZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZVN0cmluZyA9IHN0cmluZ3NbcGFydEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyaW0gdGhlIHRyYWlsaW5nIGxpdGVyYWwgdmFsdWUgaWYgdGhpcyBpcyBhbiBpbnRlcnBvbGF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdOYW1lU3RyaW5nID0gYXR0cmlidXRlU3RyaW5nLnN1YnN0cmluZygwLCBhdHRyaWJ1dGVTdHJpbmcubGVuZ3RoIC0gYXR0cmlidXRlU3RyaW5nc1swXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd05hbWUgPSByYXdOYW1lU3RyaW5nLm1hdGNoKC8oKD86XFx3fFsuXFwtXyRdKSspPVtcIiddPyQvKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucGFydHMucHVzaChuZXcgVGVtcGxhdGVQYXJ0KCdhdHRyaWJ1dGUnLCBpbmRleCwgYXR0cmlidXRlLm5hbWUsIHJhd05hbWUsIGF0dHJpYnV0ZVN0cmluZ3MpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCArPSBhdHRyaWJ1dGVTdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpLS07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSAzIC8qIE5vZGUuVEVYVF9OT0RFICovKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVZhbHVlID0gbm9kZS5ub2RlVmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5ncyA9IG5vZGVWYWx1ZS5zcGxpdChhdHRyaWJ1dGVNYXJrZXIpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5wYXJlbnROb2RlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0SW5kZXggPSBzdHJpbmdzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGhhdmUgYSBwYXJ0IGZvciBlYWNoIG1hdGNoIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgIHBhcnRJbmRleCArPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGtlZXAgdGhpcyBjdXJyZW50IG5vZGUsIGJ1dCByZXNldCBpdHMgY29udGVudCB0byB0aGUgbGFzdFxuICAgICAgICAgICAgICAgICAgICAvLyBsaXRlcmFsIHBhcnQuIFdlIGluc2VydCBuZXcgbGl0ZXJhbCBub2RlcyBiZWZvcmUgdGhpcyBzbyB0aGF0IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyB0cmVlIHdhbGtlciBrZWVwcyBpdHMgcG9zaXRpb24gY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gc3RyaW5nc1tsYXN0SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAvLyBHZW5lcmF0ZSBhIG5ldyB0ZXh0IG5vZGUgZm9yIGVhY2ggbGl0ZXJhbCBzZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXNlIG5vZGVzIGFyZSBhbHNvIHVzZWQgYXMgdGhlIG1hcmtlcnMgZm9yIG5vZGUgcGFydHNcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXN0SW5kZXg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShzdHJpbmdzW2ldKSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnRzLnB1c2gobmV3IFRlbXBsYXRlUGFydCgnbm9kZScsIGluZGV4KyspKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU3RyaXAgd2hpdGVzcGFjZS1vbmx5IG5vZGVzLCBvbmx5IGJldHdlZW4gZWxlbWVudHMsIG9yIGF0IHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBiZWdpbm5pbmcgb3IgZW5kIG9mIGVsZW1lbnRzLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmV2aW91c1NpYmxpbmcgPSBub2RlLnByZXZpb3VzU2libGluZztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFNpYmxpbmcgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICBpZiAoKHByZXZpb3VzU2libGluZyA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nLm5vZGVUeXBlID09PSAxIC8qIE5vZGUuRUxFTUVOVF9OT0RFICovKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKG5leHRTaWJsaW5nID09PSBudWxsIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFNpYmxpbmcubm9kZVR5cGUgPT09IDEgLyogTm9kZS5FTEVNRU5UX05PREUgKi8pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlVmFsdWUudHJpbSgpID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vZGUgPSBwcmV2aW91c05vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBOb2RlLkNPTU1FTlRfTk9ERSAqLyAmJlxuICAgICAgICAgICAgICAgIG5vZGUubm9kZVZhbHVlID09PSB0ZXh0TWFya2VyQ29udGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgcHJldmlvdXMgbm9kZSBhZGQgYSBtYXJrZXIgbm9kZS5cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXNTaWJsaW5nIGlzIHJlbW92ZWQsIGJlY2F1c2UgaXQncyBhbm90aGVyIHBhcnRcbiAgICAgICAgICAgICAgICAvLyBwbGFjaG9sZGVyLCBvciBlbXB0eSB0ZXh0LCBhZGQgYSBtYXJrZXIgbm9kZS5cbiAgICAgICAgICAgICAgICBpZiAobm9kZS5wcmV2aW91c1NpYmxpbmcgPT09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wcmV2aW91c1NpYmxpbmcgIT09IHByZXZpb3VzTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKG5ldyBUZXh0KCksIG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXgtLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJ0cy5wdXNoKG5ldyBUZW1wbGF0ZVBhcnQoJ25vZGUnLCBpbmRleCsrKSk7XG4gICAgICAgICAgICAgICAgbm9kZXNUb1JlbW92ZS5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBuZXh0IG5vZGUgYWRkIGEgbWFya2VyIG5vZGUuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayBpZiB0aGUgbmV4dCBub2RlIGlzIGdvaW5nIHRvIGJlIHJlbW92ZWQsXG4gICAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IG5vZGUgd2lsbCBpbmR1Y2UgYSBtYXJrZXIgaWYgc28uXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUubmV4dFNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50Lmluc2VydEJlZm9yZShuZXcgVGV4dCgpLCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnROb2RlID0gcHJldmlvdXNOb2RlO1xuICAgICAgICAgICAgICAgIHBhcnRJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0ZXh0IGJpbmRpbmcgbm9kZXMgYWZ0ZXIgdGhlIHdhbGsgdG8gbm90IGRpc3R1cmIgdGhlIFRyZWVXYWxrZXJcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIG5vZGVzVG9SZW1vdmUpIHtcbiAgICAgICAgICAgIG4ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyaW5nIG9mIEhUTUwgdXNlZCB0byBjcmVhdGUgYSA8dGVtcGxhdGU+IGVsZW1lbnQuXG4gICAgICovXG4gICAgX2dldEh0bWwoc3RyaW5ncywgc3ZnKSB7XG4gICAgICAgIGNvbnN0IGwgPSBzdHJpbmdzLmxlbmd0aDtcbiAgICAgICAgY29uc3QgYSA9IFtdO1xuICAgICAgICBsZXQgaXNUZXh0QmluZGluZyA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGwgLSAxOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBzdHJpbmdzW2ldO1xuICAgICAgICAgICAgYS5wdXNoKHMpO1xuICAgICAgICAgICAgLy8gV2UncmUgaW4gYSB0ZXh0IHBvc2l0aW9uIGlmIHRoZSBwcmV2aW91cyBzdHJpbmcgbWF0Y2hlcyB0aGVcbiAgICAgICAgICAgIC8vIHRleHRSZWdleC4gSWYgaXQgZG9lc24ndCBhbmQgdGhlIHByZXZpb3VzIHN0cmluZyBoYXMgbm8gdGFncywgdGhlblxuICAgICAgICAgICAgLy8gd2UgdXNlIHRoZSBwcmV2aW91cyB0ZXh0IHBvc2l0aW9uIHN0YXRlLlxuICAgICAgICAgICAgaXNUZXh0QmluZGluZyA9IHMubWF0Y2godGV4dFJlZ2V4KSAhPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChzLm1hdGNoKGhhc1RhZ3NSZWdleCkgIT09IG51bGwgJiYgaXNUZXh0QmluZGluZyk7XG4gICAgICAgICAgICBhLnB1c2goaXNUZXh0QmluZGluZyA/IHRleHRNYXJrZXIgOiBhdHRyaWJ1dGVNYXJrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGEucHVzaChzdHJpbmdzW2wgLSAxXSk7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBhLmpvaW4oJycpO1xuICAgICAgICByZXR1cm4gc3ZnID8gYDxzdmc+JHtodG1sfTwvc3ZnPmAgOiBodG1sO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBnZXRWYWx1ZSA9IChwYXJ0LCB2YWx1ZSkgPT4ge1xuICAgIC8vIGBudWxsYCBhcyB0aGUgdmFsdWUgb2YgYSBUZXh0IG5vZGUgd2lsbCByZW5kZXIgdGhlIHN0cmluZyAnbnVsbCdcbiAgICAvLyBzbyB3ZSBjb252ZXJ0IGl0IHRvIHVuZGVmaW5lZFxuICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLl9fbGl0RGlyZWN0aXZlID09PSB0cnVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUocGFydCk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBkaXJlY3RpdmUgPSAoZikgPT4ge1xuICAgIGYuX19saXREaXJlY3RpdmUgPSB0cnVlO1xuICAgIHJldHVybiBmO1xufTtcbmV4cG9ydCBjbGFzcyBBdHRyaWJ1dGVQYXJ0IHtcbiAgICBjb25zdHJ1Y3RvcihpbnN0YW5jZSwgZWxlbWVudCwgbmFtZSwgc3RyaW5ncykge1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gaW5zdGFuY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IHN0cmluZ3M7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHN0cmluZ3MubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWVzLCBzdGFydEluZGV4KSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ3MgPSB0aGlzLnN0cmluZ3M7XG4gICAgICAgIGxldCB0ZXh0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGV4dCArPSBzdHJpbmdzW2ldO1xuICAgICAgICAgICAgaWYgKGkgPCBzdHJpbmdzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gZ2V0VmFsdWUodGhpcywgdmFsdWVzW3N0YXJ0SW5kZXggKyBpXSk7XG4gICAgICAgICAgICAgICAgaWYgKHYgJiZcbiAgICAgICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkodikgfHwgdHlwZW9mIHYgIT09ICdzdHJpbmcnICYmIHZbU3ltYm9sLml0ZXJhdG9yXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCB0IG9mIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHdlIG5lZWQgdG8gcmVjdXJzaXZlbHkgY2FsbCBnZXRWYWx1ZSBpbnRvIGl0ZXJhYmxlcy4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCArPSB0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ICs9IHY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUodGhpcy5uYW1lLCB0ZXh0KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTm9kZVBhcnQge1xuICAgIGNvbnN0cnVjdG9yKGluc3RhbmNlLCBzdGFydE5vZGUsIGVuZE5vZGUpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICB0aGlzLnN0YXJ0Tm9kZSA9IHN0YXJ0Tm9kZTtcbiAgICAgICAgdGhpcy5lbmROb2RlID0gZW5kTm9kZTtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgc2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSBnZXRWYWx1ZSh0aGlzLCB2YWx1ZSk7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgISh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBwcmltaXRpdmUgdmFsdWVzXG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgZGlkbid0IGNoYW5nZSwgZG8gbm90aGluZ1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLl9wcmV2aW91c1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2V0VGV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBUZW1wbGF0ZVJlc3VsdCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0VGVtcGxhdGVSZXN1bHQodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0pIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEl0ZXJhYmxlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldE5vZGUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlLnRoZW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fc2V0UHJvbWlzZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjaywgd2lsbCByZW5kZXIgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAgICAgICAgdGhpcy5fc2V0VGV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2luc2VydChub2RlKSB7XG4gICAgICAgIHRoaXMuZW5kTm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShub2RlLCB0aGlzLmVuZE5vZGUpO1xuICAgIH1cbiAgICBfc2V0Tm9kZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuX2luc2VydCh2YWx1ZSk7XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgX3NldFRleHQodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuc3RhcnROb2RlLm5leHRTaWJsaW5nO1xuICAgICAgICBpZiAobm9kZSA9PT0gdGhpcy5lbmROb2RlLnByZXZpb3VzU2libGluZyAmJlxuICAgICAgICAgICAgbm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIG9ubHkgaGF2ZSBhIHNpbmdsZSB0ZXh0IG5vZGUgYmV0d2VlbiB0aGUgbWFya2Vycywgd2UgY2FuIGp1c3RcbiAgICAgICAgICAgIC8vIHNldCBpdHMgdmFsdWUsIHJhdGhlciB0aGFuIHJlcGxhY2luZyBpdC5cbiAgICAgICAgICAgIC8vIFRPRE8oanVzdGluZmFnbmFuaSk6IENhbiB3ZSBqdXN0IGNoZWNrIGlmIF9wcmV2aW91c1ZhbHVlIGlzXG4gICAgICAgICAgICAvLyBwcmltaXRpdmU/XG4gICAgICAgICAgICBub2RlLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zZXROb2RlKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbHVlID09PSB1bmRlZmluZWQgPyAnJyA6IHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICBfc2V0VGVtcGxhdGVSZXN1bHQodmFsdWUpIHtcbiAgICAgICAgbGV0IGluc3RhbmNlO1xuICAgICAgICBpZiAodGhpcy5fcHJldmlvdXNWYWx1ZSAmJlxuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZS50ZW1wbGF0ZSA9PT0gdmFsdWUudGVtcGxhdGUpIHtcbiAgICAgICAgICAgIGluc3RhbmNlID0gdGhpcy5fcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluc3RhbmNlID1cbiAgICAgICAgICAgICAgICBuZXcgVGVtcGxhdGVJbnN0YW5jZSh2YWx1ZS50ZW1wbGF0ZSwgdGhpcy5pbnN0YW5jZS5fcGFydENhbGxiYWNrKTtcbiAgICAgICAgICAgIHRoaXMuX3NldE5vZGUoaW5zdGFuY2UuX2Nsb25lKCkpO1xuICAgICAgICAgICAgdGhpcy5fcHJldmlvdXNWYWx1ZSA9IGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGluc3RhbmNlLnVwZGF0ZSh2YWx1ZS52YWx1ZXMpO1xuICAgIH1cbiAgICBfc2V0SXRlcmFibGUodmFsdWUpIHtcbiAgICAgICAgLy8gRm9yIGFuIEl0ZXJhYmxlLCB3ZSBjcmVhdGUgYSBuZXcgSW5zdGFuY2VQYXJ0IHBlciBpdGVtLCB0aGVuIHNldCBpdHNcbiAgICAgICAgLy8gdmFsdWUgdG8gdGhlIGl0ZW0uIFRoaXMgaXMgYSBsaXR0bGUgYml0IG9mIG92ZXJoZWFkIGZvciBldmVyeSBpdGVtIGluXG4gICAgICAgIC8vIGFuIEl0ZXJhYmxlLCBidXQgaXQgbGV0cyB1cyByZWN1cnNlIGVhc2lseSBhbmQgZWZmaWNpZW50bHkgdXBkYXRlIEFycmF5c1xuICAgICAgICAvLyBvZiBUZW1wbGF0ZVJlc3VsdHMgdGhhdCB3aWxsIGJlIGNvbW1vbmx5IHJldHVybmVkIGZyb20gZXhwcmVzc2lvbnMgbGlrZTpcbiAgICAgICAgLy8gYXJyYXkubWFwKChpKSA9PiBodG1sYCR7aX1gKSwgYnkgcmV1c2luZyBleGlzdGluZyBUZW1wbGF0ZUluc3RhbmNlcy5cbiAgICAgICAgLy8gSWYgX3ByZXZpb3VzVmFsdWUgaXMgYW4gYXJyYXksIHRoZW4gdGhlIHByZXZpb3VzIHJlbmRlciB3YXMgb2YgYW5cbiAgICAgICAgLy8gaXRlcmFibGUgYW5kIF9wcmV2aW91c1ZhbHVlIHdpbGwgY29udGFpbiB0aGUgTm9kZVBhcnRzIGZyb20gdGhlIHByZXZpb3VzXG4gICAgICAgIC8vIHJlbmRlci4gSWYgX3ByZXZpb3VzVmFsdWUgaXMgbm90IGFuIGFycmF5LCBjbGVhciB0aGlzIHBhcnQgYW5kIG1ha2UgYSBuZXdcbiAgICAgICAgLy8gYXJyYXkgZm9yIE5vZGVQYXJ0cy5cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuX3ByZXZpb3VzVmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGV0cyB1cyBrZWVwIHRyYWNrIG9mIGhvdyBtYW55IGl0ZW1zIHdlIHN0YW1wZWQgc28gd2UgY2FuIGNsZWFyIGxlZnRvdmVyXG4gICAgICAgIC8vIGl0ZW1zIGZyb20gYSBwcmV2aW91cyByZW5kZXJcbiAgICAgICAgY29uc3QgaXRlbVBhcnRzID0gdGhpcy5fcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgbGV0IHBhcnRJbmRleCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIHJldXNlIGFuIGV4aXN0aW5nIHBhcnRcbiAgICAgICAgICAgIGxldCBpdGVtUGFydCA9IGl0ZW1QYXJ0c1twYXJ0SW5kZXhdO1xuICAgICAgICAgICAgLy8gSWYgbm8gZXhpc3RpbmcgcGFydCwgY3JlYXRlIGEgbmV3IG9uZVxuICAgICAgICAgICAgaWYgKGl0ZW1QYXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBjcmVhdGluZyB0aGUgZmlyc3QgaXRlbSBwYXJ0LCBpdCdzIHN0YXJ0Tm9kZSBzaG91bGQgYmUgdGhlXG4gICAgICAgICAgICAgICAgLy8gY29udGFpbmVyJ3Mgc3RhcnROb2RlXG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1TdGFydCA9IHRoaXMuc3RhcnROb2RlO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBjcmVhdGluZyB0aGUgZmlyc3QgcGFydCwgY3JlYXRlIGEgbmV3IHNlcGFyYXRvciBtYXJrZXJcbiAgICAgICAgICAgICAgICAvLyBub2RlLCBhbmQgZml4IHVwIHRoZSBwcmV2aW91cyBwYXJ0J3MgZW5kTm9kZSB0byBwb2ludCB0byBpdFxuICAgICAgICAgICAgICAgIGlmIChwYXJ0SW5kZXggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzUGFydCA9IGl0ZW1QYXJ0c1twYXJ0SW5kZXggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVN0YXJ0ID0gcHJldmlvdXNQYXJ0LmVuZE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2luc2VydChpdGVtU3RhcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtUGFydCA9IG5ldyBOb2RlUGFydCh0aGlzLmluc3RhbmNlLCBpdGVtU3RhcnQsIHRoaXMuZW5kTm9kZSk7XG4gICAgICAgICAgICAgICAgaXRlbVBhcnRzLnB1c2goaXRlbVBhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbVBhcnQuc2V0VmFsdWUoaXRlbSk7XG4gICAgICAgICAgICBwYXJ0SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnRJbmRleCA8IGl0ZW1QYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxhc3RQYXJ0ID0gaXRlbVBhcnRzW3BhcnRJbmRleCAtIDFdO1xuICAgICAgICAgICAgLy8gVHJ1bmNhdGUgdGhlIHBhcnRzIGFycmF5IHNvIF9wcmV2aW91c1ZhbHVlIHJlZmxlY3RzIHRoZSBjdXJyZW50IHN0YXRlXG4gICAgICAgICAgICBpdGVtUGFydHMubGVuZ3RoID0gcGFydEluZGV4O1xuICAgICAgICAgICAgdGhpcy5jbGVhcihsYXN0UGFydC5lbmROb2RlLnByZXZpb3VzU2libGluZyk7XG4gICAgICAgICAgICBsYXN0UGFydC5lbmROb2RlID0gdGhpcy5lbmROb2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9zZXRQcm9taXNlKHZhbHVlKSB7XG4gICAgICAgIHZhbHVlLnRoZW4oKHYpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcmV2aW91c1ZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUodik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9wcmV2aW91c1ZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIGNsZWFyKHN0YXJ0Tm9kZSA9IHRoaXMuc3RhcnROb2RlKSB7XG4gICAgICAgIGxldCBub2RlO1xuICAgICAgICB3aGlsZSAoKG5vZGUgPSBzdGFydE5vZGUubmV4dFNpYmxpbmcpICE9PSB0aGlzLmVuZE5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFydENhbGxiYWNrID0gKGluc3RhbmNlLCB0ZW1wbGF0ZVBhcnQsIG5vZGUpID0+IHtcbiAgICBpZiAodGVtcGxhdGVQYXJ0LnR5cGUgPT09ICdhdHRyaWJ1dGUnKSB7XG4gICAgICAgIHJldHVybiBuZXcgQXR0cmlidXRlUGFydChpbnN0YW5jZSwgbm9kZSwgdGVtcGxhdGVQYXJ0Lm5hbWUsIHRlbXBsYXRlUGFydC5zdHJpbmdzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodGVtcGxhdGVQYXJ0LnR5cGUgPT09ICdub2RlJykge1xuICAgICAgICByZXR1cm4gbmV3IE5vZGVQYXJ0KGluc3RhbmNlLCBub2RlLCBub2RlLm5leHRTaWJsaW5nKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcnQgdHlwZSAke3RlbXBsYXRlUGFydC50eXBlfWApO1xufTtcbi8qKlxuICogQW4gaW5zdGFuY2Ugb2YgYSBgVGVtcGxhdGVgIHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIHRoZSBET00gYW5kIHVwZGF0ZWRcbiAqIHdpdGggbmV3IHZhbHVlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlSW5zdGFuY2Uge1xuICAgIGNvbnN0cnVjdG9yKHRlbXBsYXRlLCBwYXJ0Q2FsbGJhY2sgPSBkZWZhdWx0UGFydENhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3BhcnRzID0gW107XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICAgICAgdGhpcy5fcGFydENhbGxiYWNrID0gcGFydENhbGxiYWNrO1xuICAgIH1cbiAgICB1cGRhdGUodmFsdWVzKSB7XG4gICAgICAgIGxldCB2YWx1ZUluZGV4ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIHRoaXMuX3BhcnRzKSB7XG4gICAgICAgICAgICBpZiAocGFydC5zaXplID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYXJ0LnNldFZhbHVlKHZhbHVlc1t2YWx1ZUluZGV4XSk7XG4gICAgICAgICAgICAgICAgdmFsdWVJbmRleCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFydC5zZXRWYWx1ZSh2YWx1ZXMsIHZhbHVlSW5kZXgpO1xuICAgICAgICAgICAgICAgIHZhbHVlSW5kZXggKz0gcGFydC5zaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jbG9uZSgpIHtcbiAgICAgICAgY29uc3QgZnJhZ21lbnQgPSBkb2N1bWVudC5pbXBvcnROb2RlKHRoaXMudGVtcGxhdGUuZWxlbWVudC5jb250ZW50LCB0cnVlKTtcbiAgICAgICAgaWYgKHRoaXMudGVtcGxhdGUucGFydHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgLy8gRWRnZSBuZWVkcyBhbGwgNCBwYXJhbWV0ZXJzIHByZXNlbnQ7IElFMTEgbmVlZHMgM3JkIHBhcmFtZXRlciB0byBiZVxuICAgICAgICAgICAgLy8gbnVsbFxuICAgICAgICAgICAgY29uc3Qgd2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihmcmFnbWVudCwgMTMzIC8qIE5vZGVGaWx0ZXIuU0hPV19FTEVNRU5UIHwgTm9kZUZpbHRlci5TSE9XX0NPTU1FTlQgfCBOb2RlRmlsdGVyLlNIT1dfVEVYVCAqLywgbnVsbCwgZmFsc2UpO1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLnRlbXBsYXRlLnBhcnRzO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgICAgIGxldCBwYXJ0SW5kZXggPSAwO1xuICAgICAgICAgICAgbGV0IHRlbXBsYXRlUGFydCA9IHBhcnRzWzBdO1xuICAgICAgICAgICAgbGV0IG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgIHdoaWxlIChub2RlICE9IG51bGwgJiYgcGFydEluZGV4IDwgcGFydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0ZW1wbGF0ZVBhcnQuaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFydHMucHVzaCh0aGlzLl9wYXJ0Q2FsbGJhY2sodGhpcywgdGVtcGxhdGVQYXJ0LCBub2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlUGFydCA9IHBhcnRzWysrcGFydEluZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUgPSB3YWxrZXIubmV4dE5vZGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMudGVtcGxhdGUuc3ZnKSB7XG4gICAgICAgICAgICBjb25zdCBzdmdFbGVtZW50ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgICAgIGZyYWdtZW50LnJlbW92ZUNoaWxkKHN2Z0VsZW1lbnQpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBzdmdFbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQobm9kZXMuaXRlbShpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyYWdtZW50O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpdC1odG1sLmpzLm1hcFxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL2xpdC1odG1sL2xpdC1odG1sLmpzXG4vLyBtb2R1bGUgaWQgPSAzNFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZnVuY3Rpb24gY2FtZWxDYXNlVG9UaXRsZShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oW0EtWl0pL2csICcgJDEnKS5yZXBsYWNlKC9eLi8sIGZ1bmN0aW9uKHN0cil7IHJldHVybiBzdHIudG9VcHBlckNhc2UoKTsgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3RhY3RpbGUvY2xpZW50L3N0cmluZ1V0aWxzLmpzIiwiaW1wb3J0ICcuLi8uLi8uLi8uLi9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9lbnRyeXBvaW50cy9hcHBseS1zaGltLmpzJztcbmltcG9ydCB7IEVsZW1lbnRNaXhpbiB9IGZyb20gJy4uL21peGlucy9lbGVtZW50LW1peGluLmpzJztcbmltcG9ydCB7IEdlc3R1cmVFdmVudExpc3RlbmVycyB9IGZyb20gJy4uL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5qcyc7XG5pbXBvcnQgeyBkZWR1cGluZ01peGluIH0gZnJvbSAnLi4vdXRpbHMvbWl4aW4uanMnO1xuaW1wb3J0IHsgaW1wb3J0SHJlZiBhcyBpbXBvcnRIcmVmJDAgfSBmcm9tICcuLi91dGlscy9pbXBvcnQtaHJlZi5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL3JlbmRlci1zdGF0dXMuanMnO1xuaW1wb3J0ICcuLi91dGlscy91bnJlc29sdmVkLmpzJztcbmltcG9ydCB7IGRvbSBhcyBkb20kMCwgbWF0Y2hlc1NlbGVjdG9yIH0gZnJvbSAnLi9wb2x5bWVyLmRvbS5qcyc7XG5pbXBvcnQgeyBzZXRUb3VjaEFjdGlvbiB9IGZyb20gJy4uL3V0aWxzL2dlc3R1cmVzLmpzJztcbmltcG9ydCB7IERlYm91bmNlciB9IGZyb20gJy4uL3V0aWxzL2RlYm91bmNlLmpzJztcbmltcG9ydCB7IHRpbWVPdXQsIG1pY3JvVGFzayB9IGZyb20gJy4uL3V0aWxzL2FzeW5jLmpzJztcbmltcG9ydCB7IGdldCBhcyBnZXQkMCB9IGZyb20gJy4uL3V0aWxzL3BhdGguanMnO1xuXG5sZXQgc3R5bGVJbnRlcmZhY2UgPSB3aW5kb3cuU2hhZHlDU1M7XG5cbmV4cG9ydCBjb25zdCBMZWdhY3lFbGVtZW50TWl4aW4gPSBkZWR1cGluZ01peGluKChiYXNlKSA9PiB7XG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAZXh0ZW5kcyB7YmFzZX1cbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfRWxlbWVudE1peGlufVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9HZXN0dXJlRXZlbnRMaXN0ZW5lcnN9XG4gICAqL1xuICBjb25zdCBsZWdhY3lFbGVtZW50QmFzZSA9IEdlc3R1cmVFdmVudExpc3RlbmVycyhFbGVtZW50TWl4aW4oYmFzZSkpO1xuXG4gIC8qKlxuICAgKiBNYXAgb2Ygc2ltcGxlIG5hbWVzIHRvIHRvdWNoIGFjdGlvbiBuYW1lc1xuICAgKiBAZGljdFxuICAgKi9cbiAgY29uc3QgRElSRUNUSU9OX01BUCA9IHtcbiAgICAneCc6ICdwYW4teCcsXG4gICAgJ3knOiAncGFuLXknLFxuICAgICdub25lJzogJ25vbmUnLFxuICAgICdhbGwnOiAnYXV0bydcbiAgfTtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGV4dGVuZHMge2xlZ2FjeUVsZW1lbnRCYXNlfVxuICAgKiBAaW1wbGVtZW50cyB7UG9seW1lcl9MZWdhY3lFbGVtZW50TWl4aW59XG4gICAqIEB1bnJlc3RyaWN0ZWRcbiAgICovXG4gIGNsYXNzIExlZ2FjeUVsZW1lbnQgZXh0ZW5kcyBsZWdhY3lFbGVtZW50QmFzZSB7XG5cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLnJvb3QgPSB0aGlzO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5pc0F0dGFjaGVkO1xuICAgICAgLyoqIEB0eXBlIHtXZWFrTWFwPCFFbGVtZW50LCAhT2JqZWN0PHN0cmluZywgIUZ1bmN0aW9uPj59ICovXG4gICAgICB0aGlzLl9fYm91bmRMaXN0ZW5lcnM7XG4gICAgICAvKiogQHR5cGUge09iamVjdDxzdHJpbmcsIEZ1bmN0aW9uPn0gKi9cbiAgICAgIHRoaXMuX2RlYm91bmNlcnM7XG4gICAgICB0aGlzLmNyZWF0ZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyB0aGUgYGNvbnN0cnVjdG9yYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBjcmVhdGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIGltcGxlbWVudGF0aW9uIG9mIGBjb25uZWN0ZWRDYWxsYmFja2BcbiAgICAgKiB3aGljaCBhZGRzIFBvbHltZXIgbGVnYWN5IEFQSSdzIGBhdHRhY2hlZGAgbWV0aG9kLlxuICAgICAqIEBvdmVycmlkZVxuICAgICAqL1xuICAgIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIHRoaXMuaXNBdHRhY2hlZCA9IHRydWU7XG4gICAgICB0aGlzLmF0dGFjaGVkKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTGVnYWN5IGNhbGxiYWNrIGNhbGxlZCBkdXJpbmcgYGNvbm5lY3RlZENhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgKi9cbiAgICBhdHRhY2hlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBQcm92aWRlcyBhbiBpbXBsZW1lbnRhdGlvbiBvZiBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgXG4gICAgICogd2hpY2ggYWRkcyBQb2x5bWVyIGxlZ2FjeSBBUEkncyBgZGV0YWNoZWRgIG1ldGhvZC5cbiAgICAgKiBAb3ZlcnJpZGVcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgICB0aGlzLmlzQXR0YWNoZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuZGV0YWNoZWQoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMZWdhY3kgY2FsbGJhY2sgY2FsbGVkIGR1cmluZyBgZGlzY29ubmVjdGVkQ2FsbGJhY2tgLCBmb3Igb3ZlcnJpZGluZ1xuICAgICAqIGJ5IHRoZSB1c2VyLlxuICAgICAqL1xuICAgIGRldGFjaGVkKCkge31cblxuICAgIC8qKlxuICAgICAqIFByb3ZpZGVzIGFuIG92ZXJyaWRlIGltcGxlbWVudGF0aW9uIG9mIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgXG4gICAgICogd2hpY2ggYWRkcyB0aGUgUG9seW1lciBsZWdhY3kgQVBJJ3MgYGF0dHJpYnV0ZUNoYW5nZWRgIG1ldGhvZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUsIG9sZCwgdmFsdWUpIHtcbiAgICAgIGlmIChvbGQgIT09IHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIExlZ2FjeSBjYWxsYmFjayBjYWxsZWQgZHVyaW5nIGBhdHRyaWJ1dGVDaGFuZ2VkQ2hhbGxiYWNrYCwgZm9yIG92ZXJyaWRpbmdcbiAgICAgKiBieSB0aGUgdXNlci5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBOYW1lIG9mIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG9sZCBPbGQgdmFsdWUgb2YgYXR0cmlidXRlLlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQ3VycmVudCB2YWx1ZSBvZiBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKSB7fSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBpbXBsZW1lbnRhdGlvbiB0b1xuICAgICAqIGFkZCBzdXBwb3J0IGZvciBjbGFzcyBpbml0aWFsaXphdGlvbiB2aWEgdGhlIGBfcmVnaXN0ZXJlZGAgY2FsbGJhY2suXG4gICAgICogVGhpcyBpcyBjYWxsZWQgb25seSB3aGVuIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiB0aGUgZWxlbWVudCBpcyBjcmVhdGVkLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgbGV0IHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpO1xuICAgICAgaWYgKCFwcm90by5oYXNPd25Qcm9wZXJ0eSgnX19oYXNSZWdpc3RlckZpbmlzaGVkJykpIHtcbiAgICAgICAgcHJvdG8uX19oYXNSZWdpc3RlckZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZCgpO1xuICAgICAgfVxuICAgICAgc3VwZXIuX2luaXRpYWxpemVQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhbiBlbGVtZW50IGlzIGluaXRpYWxpemluZy5cbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBjbGFzcyByZWdpc3RyYXRpb24gdGltZVxuICAgICAqIHdvcmsuIFRoZSBpbXBsZW1lbnRhdGlvbiBzaG91bGQgZW5zdXJlIHRoZSB3b3JrIGlzIHBlcmZvcm1lZFxuICAgICAqIG9ubHkgb25jZSBmb3IgdGhlIGNsYXNzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcmVnaXN0ZXJlZCgpIHt9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgdGhlIGRlZmF1bHQgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCBpbXBsZW1lbnRhdGlvbiB0b1xuICAgICAqIGFkZCBzdXBwb3J0IGZvciBpbnN0YWxsaW5nIGBob3N0QXR0cmlidXRlc2AgYW5kIGBsaXN0ZW5lcnNgLlxuICAgICAqXG4gICAgICogQG92ZXJyaWRlXG4gICAgICovXG4gICAgcmVhZHkoKSB7XG4gICAgICB0aGlzLl9lbnN1cmVBdHRyaWJ1dGVzKCk7XG4gICAgICB0aGlzLl9hcHBseUxpc3RlbmVycygpO1xuICAgICAgc3VwZXIucmVhZHkoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIGFuIGVsZW1lbnQgaGFzIHJlcXVpcmVkIGF0dHJpYnV0ZXMuIENhbGxlZCB3aGVuIHRoZSBlbGVtZW50XG4gICAgICogaXMgYmVpbmcgcmVhZGllZCB2aWEgYHJlYWR5YC4gVXNlcnMgc2hvdWxkIG92ZXJyaWRlIHRvIHNldCB0aGVcbiAgICAgKiBlbGVtZW50J3MgcmVxdWlyZWQgYXR0cmlidXRlcy4gVGhlIGltcGxlbWVudGF0aW9uIHNob3VsZCBiZSBzdXJlXG4gICAgICogdG8gY2hlY2sgYW5kIG5vdCBvdmVycmlkZSBleGlzdGluZyBhdHRyaWJ1dGVzIGFkZGVkIGJ5XG4gICAgICogdGhlIHVzZXIgb2YgdGhlIGVsZW1lbnQuIFR5cGljYWxseSwgc2V0dGluZyBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsZWZ0XG4gICAgICogdG8gdGhlIGVsZW1lbnQgdXNlciBhbmQgbm90IGRvbmUgaGVyZTsgcmVhc29uYWJsZSBleGNlcHRpb25zIGluY2x1ZGVcbiAgICAgKiBzZXR0aW5nIGFyaWEgcm9sZXMgYW5kIGZvY3VzYWJpbGl0eS5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2Vuc3VyZUF0dHJpYnV0ZXMoKSB7fVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBlbGVtZW50IGV2ZW50IGxpc3RlbmVycy4gQ2FsbGVkIHdoZW4gdGhlIGVsZW1lbnRcbiAgICAgKiBpcyBiZWluZyByZWFkaWVkIHZpYSBgcmVhZHlgLiBVc2VycyBzaG91bGQgb3ZlcnJpZGUgdG9cbiAgICAgKiBhZGQgYW55IHJlcXVpcmVkIGVsZW1lbnQgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEluIHBlcmZvcm1hbmNlIGNyaXRpY2FsIGVsZW1lbnRzLCB0aGUgd29yayBkb25lIGhlcmUgc2hvdWxkIGJlIGtlcHRcbiAgICAgKiB0byBhIG1pbmltdW0gc2luY2UgaXQgaXMgZG9uZSBiZWZvcmUgdGhlIGVsZW1lbnQgaXMgcmVuZGVyZWQuIEluXG4gICAgICogdGhlc2UgZWxlbWVudHMsIGNvbnNpZGVyIGFkZGluZyBsaXN0ZW5lcnMgYXN5Y2hyb25vdXNseSBzbyBhcyBub3QgdG9cbiAgICAgKiBibG9jayByZW5kZXIuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9hcHBseUxpc3RlbmVycygpIHt9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUgdG8gYSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLiBUbyBjdXN0b21pemVcbiAgICAgKiBob3cgcHJvcGVydGllcyBhcmUgc2VyaWFsaXplZCB0byBhdHRyaWJ1dGVzIGZvciBhdHRyaWJ1dGUgYmluZGluZ3MgYW5kXG4gICAgICogYHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZWAgcHJvcGVydGllcyBhcyB3ZWxsIGFzIHRoaXMgbWV0aG9kLCBvdmVycmlkZVxuICAgICAqIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgcHJvdmlkZWQgYnkgYFBvbHltZXIuUHJvcGVydHlBY2Nlc3NvcnNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBkZXNlcmlhbGl6ZVxuICAgICAqIEByZXR1cm4ge3N0cmluZyB8IHVuZGVmaW5lZH0gU2VyaWFsaXplZCB2YWx1ZVxuICAgICAqL1xuICAgIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3NlcmlhbGl6ZVZhbHVlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLiAgVG8gY3VzdG9taXplXG4gICAgICogaG93IGF0dHJpYnV0ZXMgYXJlIGRlc2VyaWFsaXplZCB0byBwcm9wZXJ0aWVzIGZvciBpblxuICAgICAqIGBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2tgLCBvdmVycmlkZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZFxuICAgICAqIHByb3ZpZGVkIGJ5IGBQb2x5bWVyLlByb3BlcnR5QWNjZXNzb3JzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBTdHJpbmcgdG8gZGVzZXJpYWxpemVcbiAgICAgKiBAcGFyYW0geyp9IHR5cGUgVHlwZSB0byBkZXNlcmlhbGl6ZSB0aGUgc3RyaW5nIHRvXG4gICAgICogQHJldHVybiB7Kn0gUmV0dXJucyB0aGUgZGVzZXJpYWxpemVkIHZhbHVlIGluIHRoZSBgdHlwZWAgZ2l2ZW4uXG4gICAgICovXG4gICAgZGVzZXJpYWxpemUodmFsdWUsIHR5cGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZXNlcmlhbGl6ZVZhbHVlKHZhbHVlLCB0eXBlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIGEgcHJvcGVydHkgdG8gaXRzIGFzc29jaWF0ZWQgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICogTm90ZSB0aGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBiYWNrd2FyZC1jb21wYXRpYmxlIGxlZ2FjeSBBUElcbiAgICAgKiBvbmx5LiAgSXQgaXMgbm90IGRpcmVjdGx5IGNhbGxlZCBieSBhbnkgUG9seW1lciBmZWF0dXJlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICovXG4gICAgcmVmbGVjdFByb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgYSB0eXBlZCB2YWx1ZSB0byBhbiBIVE1MIGF0dHJpYnV0ZSBvbiBhIG5vZGUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGJhY2t3YXJkLWNvbXBhdGlibGUgbGVnYWN5IEFQSVxuICAgICAqIG9ubHkuICBJdCBpcyBub3QgZGlyZWN0bHkgY2FsbGVkIGJ5IGFueSBQb2x5bWVyIGZlYXR1cmVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBBdHRyaWJ1dGUgbmFtZSB0byBzZXJpYWxpemUgdG8uXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gc2V0IGF0dHJpYnV0ZSB0by5cbiAgICAgKi9cbiAgICBzZXJpYWxpemVWYWx1ZVRvQXR0cmlidXRlKHZhbHVlLCBhdHRyaWJ1dGUsIG5vZGUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlVG9Ob2RlQXR0cmlidXRlKC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5vZGUgfHwgdGhpcyksIHZhbHVlLCBhdHRyaWJ1dGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gcHJvcGVydGllcyAoaW5jbHVkaW5nIGFjY2Vzc29yIGRlc2NyaXB0b3JzKSBmcm9tIGEgc291cmNlXG4gICAgICogb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGFyZ2V0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGFwaSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gcHJvdG90eXBlIG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAgICovXG4gICAgZXh0ZW5kKHByb3RvdHlwZSwgYXBpKSB7XG4gICAgICBpZiAoIShwcm90b3R5cGUgJiYgYXBpKSkge1xuICAgICAgICByZXR1cm4gcHJvdG90eXBlIHx8IGFwaTtcbiAgICAgIH1cbiAgICAgIGxldCBuJCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGFwaSk7XG4gICAgICBmb3IgKGxldCBpPTAsIG47IChpPG4kLmxlbmd0aCkgJiYgKG49biRbaV0pOyBpKyspIHtcbiAgICAgICAgbGV0IHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcGksIG4pO1xuICAgICAgICBpZiAocGQpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG90eXBlLCBuLCBwZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm90b3R5cGU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIHByb3BzIGZyb20gYSBzb3VyY2Ugb2JqZWN0IHRvIGEgdGFyZ2V0IG9iamVjdC5cbiAgICAgKlxuICAgICAqIE5vdGUsIHRoaXMgbWV0aG9kIHVzZXMgYSBzaW1wbGUgYGZvci4uLmluYCBzdHJhdGVneSBmb3IgZW51bWVyYXRpbmdcbiAgICAgKiBwcm9wZXJ0aWVzLiAgVG8gZW5zdXJlIG9ubHkgYG93blByb3BlcnRpZXNgIGFyZSBjb3BpZWQgZnJvbSBzb3VyY2VcbiAgICAgKiB0byB0YXJnZXQgYW5kIHRoYXQgYWNjZXNzb3IgaW1wbGVtZW50YXRpb25zIGFyZSBjb3BpZWQsIHVzZSBgZXh0ZW5kYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgVGFyZ2V0IG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgdG8uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBTb3VyY2Ugb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gVGFyZ2V0IG9iamVjdCB0aGF0IHdhcyBwYXNzZWQgYXMgZmlyc3QgYXJndW1lbnQuXG4gICAgICovXG4gICAgbWl4aW4odGFyZ2V0LCBzb3VyY2UpIHtcbiAgICAgIGZvciAobGV0IGkgaW4gc291cmNlKSB7XG4gICAgICAgIHRhcmdldFtpXSA9IHNvdXJjZVtpXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcHJvdG90eXBlIG9mIGFuIG9iamVjdC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhpcyBtZXRob2QgaXMgcHJvdmlkZWQgYXMgYmFja3dhcmQtY29tcGF0aWJsZSBsZWdhY3kgQVBJXG4gICAgICogb25seS4gIEl0IGlzIG5vdCBkaXJlY3RseSBjYWxsZWQgYnkgYW55IFBvbHltZXIgZmVhdHVyZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IG9uIHdoaWNoIHRvIHNldCB0aGUgcHJvdG90eXBlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIHByb3RvdHlwZSB0aGF0IHdpbGwgYmUgc2V0IG9uIHRoZSBnaXZlblxuICAgICAqIGBvYmplY3RgLlxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyB0aGUgZ2l2ZW4gYG9iamVjdGAgd2l0aCBpdHMgcHJvdG90eXBlIHNldFxuICAgICAqIHRvIHRoZSBnaXZlbiBgcHJvdG90eXBlYCBvYmplY3QuXG4gICAgICovXG4gICAgY2hhaW5PYmplY3Qob2JqZWN0LCBwcm90b3R5cGUpIHtcbiAgICAgIGlmIChvYmplY3QgJiYgcHJvdG90eXBlICYmIG9iamVjdCAhPT0gcHJvdG90eXBlKSB7XG4gICAgICAgIG9iamVjdC5fX3Byb3RvX18gPSBwcm90b3R5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qICoqKiogQmVnaW4gVGVtcGxhdGUgKioqKiAqL1xuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgYGltcG9ydE5vZGVgIG9uIHRoZSBgY29udGVudGAgb2YgdGhlIGB0ZW1wbGF0ZWAgc3BlY2lmaWVkIGFuZFxuICAgICAqIHJldHVybnMgYSBkb2N1bWVudCBmcmFnbWVudCBjb250YWluaW5nIHRoZSBpbXBvcnRlZCBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBIVE1MIHRlbXBsYXRlIGVsZW1lbnQgdG8gaW5zdGFuY2UuXG4gICAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH0gRG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyB0aGUgaW1wb3J0ZWRcbiAgICAgKiAgIHRlbXBsYXRlIGNvbnRlbnQuXG4gICAgKi9cbiAgICBpbnN0YW5jZVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICBsZXQgY29udGVudCA9IHRoaXMuY29uc3RydWN0b3IuX2NvbnRlbnRGb3JUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gICAgICBsZXQgZG9tID0gLyoqIEB0eXBlIHtEb2N1bWVudEZyYWdtZW50fSAqL1xuICAgICAgICAoZG9jdW1lbnQuaW1wb3J0Tm9kZShjb250ZW50LCB0cnVlKSk7XG4gICAgICByZXR1cm4gZG9tO1xuICAgIH1cblxuICAgIC8qICoqKiogQmVnaW4gRXZlbnRzICoqKiogKi9cblxuXG5cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaGVzIGEgY3VzdG9tIGV2ZW50IHdpdGggYW4gb3B0aW9uYWwgZGV0YWlsIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgTmFtZSBvZiBldmVudCB0eXBlLlxuICAgICAqIEBwYXJhbSB7Kj19IGRldGFpbCBEZXRhaWwgdmFsdWUgY29udGFpbmluZyBldmVudC1zcGVjaWZpY1xuICAgICAqICAgcGF5bG9hZC5cbiAgICAgKiBAcGFyYW0ge3sgYnViYmxlczogKGJvb2xlYW58dW5kZWZpbmVkKSwgY2FuY2VsYWJsZTogKGJvb2xlYW58dW5kZWZpbmVkKSwgY29tcG9zZWQ6IChib29sZWFufHVuZGVmaW5lZCkgfT19XG4gICAgICogIG9wdGlvbnMgT2JqZWN0IHNwZWNpZnlpbmcgb3B0aW9ucy4gIFRoZXNlIG1heSBpbmNsdWRlOlxuICAgICAqICBgYnViYmxlc2AgKGJvb2xlYW4sIGRlZmF1bHRzIHRvIGB0cnVlYCksXG4gICAgICogIGBjYW5jZWxhYmxlYCAoYm9vbGVhbiwgZGVmYXVsdHMgdG8gZmFsc2UpLCBhbmRcbiAgICAgKiAgYG5vZGVgIG9uIHdoaWNoIHRvIGZpcmUgdGhlIGV2ZW50IChIVE1MRWxlbWVudCwgZGVmYXVsdHMgdG8gYHRoaXNgKS5cbiAgICAgKiBAcmV0dXJuIHtFdmVudH0gVGhlIG5ldyBldmVudCB0aGF0IHdhcyBmaXJlZC5cbiAgICAgKi9cbiAgICBmaXJlKHR5cGUsIGRldGFpbCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBkZXRhaWwgPSAoZGV0YWlsID09PSBudWxsIHx8IGRldGFpbCA9PT0gdW5kZWZpbmVkKSA/IHt9IDogZGV0YWlsO1xuICAgICAgbGV0IGV2ZW50ID0gbmV3IEV2ZW50KHR5cGUsIHtcbiAgICAgICAgYnViYmxlczogb3B0aW9ucy5idWJibGVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogb3B0aW9ucy5idWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlOiBCb29sZWFuKG9wdGlvbnMuY2FuY2VsYWJsZSksXG4gICAgICAgIGNvbXBvc2VkOiBvcHRpb25zLmNvbXBvc2VkID09PSB1bmRlZmluZWQgPyB0cnVlOiBvcHRpb25zLmNvbXBvc2VkXG4gICAgICB9KTtcbiAgICAgIGV2ZW50LmRldGFpbCA9IGRldGFpbDtcbiAgICAgIGxldCBub2RlID0gb3B0aW9ucy5ub2RlIHx8IHRoaXM7XG4gICAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgb24gYSBnaXZlbiBlbGVtZW50LFxuICAgICAqIGxhdGUgYm91bmQgdG8gYSBuYW1lZCBtZXRob2Qgb24gdGhpcyBlbGVtZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlIEVsZW1lbnQgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudCB0byBsaXN0ZW4gZm9yLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE5hbWUgb2YgaGFuZGxlciBtZXRob2Qgb24gYHRoaXNgIHRvIGNhbGwuXG4gICAgICovXG4gICAgbGlzdGVuKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgbGV0IGhibCA9IHRoaXMuX19ib3VuZExpc3RlbmVycyB8fFxuICAgICAgICAodGhpcy5fX2JvdW5kTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKSk7XG4gICAgICBsZXQgYmwgPSBoYmwuZ2V0KG5vZGUpO1xuICAgICAgaWYgKCFibCkge1xuICAgICAgICBibCA9IHt9O1xuICAgICAgICBoYmwuc2V0KG5vZGUsIGJsKTtcbiAgICAgIH1cbiAgICAgIGxldCBrZXkgPSBldmVudE5hbWUgKyBtZXRob2ROYW1lO1xuICAgICAgaWYgKCFibFtrZXldKSB7XG4gICAgICAgIGJsW2tleV0gPSB0aGlzLl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKFxuICAgICAgICAgIG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgbWV0aG9kIHRvIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciBmcm9tIGEgZ2l2ZW4gZWxlbWVudCxcbiAgICAgKiBsYXRlIGJvdW5kIHRvIGEgbmFtZWQgbWV0aG9kIG9uIHRoaXMgZWxlbWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBFbGVtZW50IHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWUgTmFtZSBvZiBldmVudCB0byBzdG9wIGxpc3RlbmluZyB0by5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIGhhbmRsZXIgbWV0aG9kIG9uIGB0aGlzYCB0byBub3QgY2FsbFxuICAgICBhbnltb3JlLlxuICAgICAqL1xuICAgIHVubGlzdGVuKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSkge1xuICAgICAgbm9kZSA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgbGV0IGJsID0gdGhpcy5fX2JvdW5kTGlzdGVuZXJzICYmIHRoaXMuX19ib3VuZExpc3RlbmVycy5nZXQobm9kZSk7XG4gICAgICBsZXQga2V5ID0gZXZlbnROYW1lICsgbWV0aG9kTmFtZTtcbiAgICAgIGxldCBoYW5kbGVyID0gYmwgJiYgYmxba2V5XTtcbiAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2ZW50TGlzdGVuZXJGcm9tTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICBibFtrZXldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZSBzY3JvbGxpbmcgYmVoYXZpb3IgdG8gYWxsIGRpcmVjdGlvbiwgb25lIGRpcmVjdGlvbiwgb3Igbm9uZS5cbiAgICAgKlxuICAgICAqIFZhbGlkIHNjcm9sbCBkaXJlY3Rpb25zOlxuICAgICAqICAgLSAnYWxsJzogc2Nyb2xsIGluIGFueSBkaXJlY3Rpb25cbiAgICAgKiAgIC0gJ3gnOiBzY3JvbGwgb25seSBpbiB0aGUgJ3gnIGRpcmVjdGlvblxuICAgICAqICAgLSAneSc6IHNjcm9sbCBvbmx5IGluIHRoZSAneScgZGlyZWN0aW9uXG4gICAgICogICAtICdub25lJzogZGlzYWJsZSBzY3JvbGxpbmcgZm9yIHRoaXMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBkaXJlY3Rpb24gRGlyZWN0aW9uIHRvIGFsbG93IHNjcm9sbGluZ1xuICAgICAqIERlZmF1bHRzIHRvIGBhbGxgLlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSBzY3JvbGwgZGlyZWN0aW9uIHNldHRpbmcuXG4gICAgICogRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAqL1xuICAgIHNldFNjcm9sbERpcmVjdGlvbihkaXJlY3Rpb24sIG5vZGUpIHtcbiAgICAgIHNldFRvdWNoQWN0aW9uKCAobm9kZSB8fCB0aGlzKSwgRElSRUNUSU9OX01BUFtkaXJlY3Rpb25dIHx8ICdhdXRvJyk7XG4gICAgfVxuICAgIC8qICoqKiogRW5kIEV2ZW50cyAqKioqICovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdG8gcnVuIGBxdWVyeVNlbGVjdG9yYCBvbiB0aGlzIGxvY2FsIERPTSBzY29wZS5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgYFBvbHltZXIuZG9tKHRoaXMucm9vdCkucXVlcnlTZWxlY3RvcihzbGN0cilgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNsY3RyIFNlbGVjdG9yIHRvIHJ1biBvbiB0aGlzIGxvY2FsIERPTSBzY29wZVxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IEVsZW1lbnQgZm91bmQgYnkgdGhlIHNlbGVjdG9yLCBvciBudWxsIGlmIG5vdCBmb3VuZC5cbiAgICAgKi9cbiAgICAkJChzbGN0cikge1xuICAgICAgcmV0dXJuIHRoaXMucm9vdC5xdWVyeVNlbGVjdG9yKHNsY3RyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVsZW1lbnQgd2hvc2UgbG9jYWwgZG9tIHdpdGhpbiB3aGljaCB0aGlzIGVsZW1lbnRcbiAgICAgKiBpcyBjb250YWluZWQuIFRoaXMgaXMgYSBzaG9ydGhhbmQgZm9yXG4gICAgICogYHRoaXMuZ2V0Um9vdE5vZGUoKS5ob3N0YC5cbiAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBnZXQgZG9tSG9zdCgpIHtcbiAgICAgIGxldCByb290ID0gdGhpcy5nZXRSb290Tm9kZSgpO1xuICAgICAgcmV0dXJuIChyb290IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkgPyAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovIChyb290KS5ob3N0IDogcm9vdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGb3JjZSB0aGlzIGVsZW1lbnQgdG8gZGlzdHJpYnV0ZSBpdHMgY2hpbGRyZW4gdG8gaXRzIGxvY2FsIGRvbS5cbiAgICAgKiBUaGlzIHNob3VsZCBub3QgYmUgbmVjZXNzYXJ5IGFzIG9mIFBvbHltZXIgMi4wLjIgYW5kIGlzIHByb3ZpZGVkIG9ubHlcbiAgICAgKiBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICovXG4gICAgZGlzdHJpYnV0ZUNvbnRlbnQoKSB7XG4gICAgICBpZiAod2luZG93LlNoYWR5RE9NICYmIHRoaXMuc2hhZG93Um9vdCkge1xuICAgICAgICBTaGFkeURPTS5mbHVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIHRoZSBlZmZlY3RpdmUgY2hpbGROb2Rlcy4gVGhlIGVmZmVjdGl2ZVxuICAgICAqIGNoaWxkTm9kZXMgbGlzdCBpcyB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCdzIGNoaWxkTm9kZXMgZXhjZXB0IHRoYXRcbiAgICAgKiBhbnkgYDxjb250ZW50PmAgZWxlbWVudHMgYXJlIHJlcGxhY2VkIHdpdGggdGhlIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWRcbiAgICAgKiB0byB0aGUgYDxjb250ZW50PmAsIHRoZSByZXN1bHQgb2YgaXRzIGBnZXREaXN0cmlidXRlZE5vZGVzYCBtZXRob2QuXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmY3RpdmUgY2hpbGQgbm9kZXMuXG4gICAgICovXG4gICAgZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovIChkb20kMCh0aGlzKSkuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpXG4gICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIG5vZGVzIGRpc3RyaWJ1dGVkIHdpdGhpbiB0aGlzIGVsZW1lbnQgdGhhdCBtYXRjaFxuICAgICAqIGBzZWxlY3RvcmAuIFRoZXNlIGNhbiBiZSBkb20gY2hpbGRyZW4gb3IgZWxlbWVudHMgZGlzdHJpYnV0ZWQgdG9cbiAgICAgKiBjaGlsZHJlbiB0aGF0IGFyZSBpbnNlcnRpb24gcG9pbnRzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvciBTZWxlY3RvciB0byBydW4uXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgZWxlbWVudHMgdGhhdCBtYXRjaCBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBxdWVyeURpc3RyaWJ1dGVkRWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIC8qKiBAdHlwZSB7UG9seW1lci5Eb21BcGl9ICovIChkb20kMCh0aGlzKSkucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlbGVtZW50cyB0aGF0IGFyZSB0aGUgZWZmZWN0aXZlIGNoaWxkcmVuLiBUaGUgZWZmZWN0aXZlXG4gICAgICogY2hpbGRyZW4gbGlzdCBpcyB0aGUgc2FtZSBhcyB0aGUgZWxlbWVudCdzIGNoaWxkcmVuIGV4Y2VwdCB0aGF0XG4gICAgICogYW55IGA8Y29udGVudD5gIGVsZW1lbnRzIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBsaXN0IG9mIGVsZW1lbnRzXG4gICAgICogZGlzdHJpYnV0ZWQgdG8gdGhlIGA8Y29udGVudD5gLlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXk8Tm9kZT59IExpc3Qgb2YgZWZmY3RpdmUgY2hpbGRyZW4uXG4gICAgICovXG4gICAgZ2V0RWZmZWN0aXZlQ2hpbGRyZW4oKSB7XG4gICAgICBsZXQgbGlzdCA9IHRoaXMuZ2V0RWZmZWN0aXZlQ2hpbGROb2RlcygpO1xuICAgICAgcmV0dXJuIGxpc3QuZmlsdGVyKGZ1bmN0aW9uKC8qKiBAdHlwZSB7Tm9kZX0gKi8gbikge1xuICAgICAgICByZXR1cm4gKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJpbmcgb2YgdGV4dCBjb250ZW50IHRoYXQgaXMgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXG4gICAgICogdGV4dCBjb250ZW50J3Mgb2YgdGhlIGVsZW1lbnQncyBlZmZlY3RpdmUgY2hpbGROb2RlcyAodGhlIGVsZW1lbnRzXG4gICAgICogcmV0dXJuZWQgYnkgPGEgaHJlZj1cIiNnZXRFZmZlY3RpdmVDaGlsZE5vZGVzPmdldEVmZmVjdGl2ZUNoaWxkTm9kZXM8L2E+LlxuICAgICAqXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBMaXN0IG9mIGVmZmN0aXZlIGNoaWxkcmVuLlxuICAgICAqL1xuICAgIGdldEVmZmVjdGl2ZVRleHRDb250ZW50KCkge1xuICAgICAgbGV0IGNuID0gdGhpcy5nZXRFZmZlY3RpdmVDaGlsZE5vZGVzKCk7XG4gICAgICBsZXQgdGMgPSBbXTtcbiAgICAgIGZvciAobGV0IGk9MCwgYzsgKGMgPSBjbltpXSk7IGkrKykge1xuICAgICAgICBpZiAoYy5ub2RlVHlwZSAhPT0gTm9kZS5DT01NRU5UX05PREUpIHtcbiAgICAgICAgICB0Yy5wdXNoKGMudGV4dENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGMuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZmlyc3QgZWZmZWN0aXZlIGNoaWxkTm9kZSB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXRcbiAgICAgKiBtYXRjaCBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkIG5vZGVzIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkXG4gICAgICogdG8gY2hpbGRyZW4gdGhhdCBhcmUgaW5zZXJ0aW9uIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAqIEByZXR1cm4ge09iamVjdDxOb2RlPn0gRmlyc3QgZWZmZWN0aXZlIGNoaWxkIG5vZGUgdGhhdCBtYXRjaGVzIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIHF1ZXJ5RWZmZWN0aXZlQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgIGxldCBlJCA9IHRoaXMucXVlcnlEaXN0cmlidXRlZEVsZW1lbnRzKHNlbGVjdG9yKTtcbiAgICAgIHJldHVybiBlJCAmJiBlJFswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBlZmZlY3RpdmUgY2hpbGROb2RlcyB3aXRoaW4gdGhpcyBlbGVtZW50IHRoYXRcbiAgICAgKiBtYXRjaCBgc2VsZWN0b3JgLiBUaGVzZSBjYW4gYmUgZG9tIGNoaWxkIG5vZGVzIG9yIGVsZW1lbnRzIGRpc3RyaWJ1dGVkXG4gICAgICogdG8gY2hpbGRyZW4gdGhhdCBhcmUgaW5zZXJ0aW9uIHBvaW50cy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3IgU2VsZWN0b3IgdG8gcnVuLlxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGVmZmVjdGl2ZSBjaGlsZCBub2RlcyB0aGF0IG1hdGNoIHNlbGVjdG9yLlxuICAgICAqL1xuICAgIHF1ZXJ5QWxsRWZmZWN0aXZlQ2hpbGRyZW4oc2VsZWN0b3IpIHtcbiAgICAgIHJldHVybiB0aGlzLnF1ZXJ5RGlzdHJpYnV0ZWRFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIGxpc3Qgb2Ygbm9kZXMgZGlzdHJpYnV0ZWQgdG8gdGhpcyBlbGVtZW50J3MgYDxzbG90PmAuXG4gICAgICpcbiAgICAgKiBJZiB0aGlzIGVsZW1lbnQgY29udGFpbnMgbW9yZSB0aGFuIG9uZSBgPHNsb3Q+YCBpbiBpdHMgbG9jYWwgRE9NLFxuICAgICAqIGFuIG9wdGlvbmFsIHNlbGVjdG9yIG1heSBiZSBwYXNzZWQgdG8gY2hvb3NlIHRoZSBkZXNpcmVkIGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZz19IHNsY3RyIENTUyBzZWxlY3RvciB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgKiAgIGA8c2xvdD5gLiAgRGVmYXVsdHMgdG8gYGNvbnRlbnRgLlxuICAgICAqIEByZXR1cm4ge0FycmF5PE5vZGU+fSBMaXN0IG9mIGRpc3RyaWJ1dGVkIG5vZGVzIGZvciB0aGUgYDxzbG90PmAuXG4gICAgICovXG4gICAgZ2V0Q29udGVudENoaWxkTm9kZXMoc2xjdHIpIHtcbiAgICAgIGxldCBjb250ZW50ID0gdGhpcy5yb290LnF1ZXJ5U2VsZWN0b3Ioc2xjdHIgfHwgJ3Nsb3QnKTtcbiAgICAgIHJldHVybiBjb250ZW50ID8gLyoqIEB0eXBlIHtQb2x5bWVyLkRvbUFwaX0gKi8oZG9tJDAoY29udGVudCkpLmdldERpc3RyaWJ1dGVkTm9kZXMoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGVsZW1lbnQgY2hpbGRyZW4gZGlzdHJpYnV0ZWQgdG8gdGhpcyBlbGVtZW50J3NcbiAgICAgKiBgPHNsb3Q+YC5cbiAgICAgKlxuICAgICAqIElmIHRoaXMgZWxlbWVudCBjb250YWlucyBtb3JlIHRoYW4gb25lIGA8c2xvdD5gIGluIGl0c1xuICAgICAqIGxvY2FsIERPTSwgYW4gb3B0aW9uYWwgc2VsZWN0b3IgbWF5IGJlIHBhc3NlZCB0byBjaG9vc2UgdGhlIGRlc2lyZWRcbiAgICAgKiBjb250ZW50LiAgVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBnZXRDb250ZW50Q2hpbGROb2Rlc2AgaW4gdGhhdCBvbmx5XG4gICAgICogZWxlbWVudHMgYXJlIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBzbGN0ciBDU1Mgc2VsZWN0b3IgdG8gY2hvb3NlIHRoZSBkZXNpcmVkXG4gICAgICogICBgPGNvbnRlbnQ+YC4gIERlZmF1bHRzIHRvIGBjb250ZW50YC5cbiAgICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59IExpc3Qgb2YgZGlzdHJpYnV0ZWQgbm9kZXMgZm9yIHRoZVxuICAgICAqICAgYDxzbG90PmAuXG4gICAgICogQHN1cHByZXNzIHtpbnZhbGlkQ2FzdHN9XG4gICAgICovXG4gICAgZ2V0Q29udGVudENoaWxkcmVuKHNsY3RyKSB7XG4gICAgICByZXR1cm4gLyoqIEB0eXBlIHtBcnJheTxIVE1MRWxlbWVudD59ICovKHRoaXMuZ2V0Q29udGVudENoaWxkTm9kZXMoc2xjdHIpLmZpbHRlcihmdW5jdGlvbihuKSB7XG4gICAgICAgIHJldHVybiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpO1xuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIGFuIGVsZW1lbnQgaXMgaW4gdGhpcyBlbGVtZW50J3MgbGlnaHQgRE9NIHRyZWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9Ob2RlfSBub2RlIFRoZSBlbGVtZW50IHRvIGJlIGNoZWNrZWQuXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBub2RlIGlzIGluIHRoaXMgZWxlbWVudCdzIGxpZ2h0IERPTSB0cmVlLlxuICAgICAqL1xuICAgIGlzTGlnaHREZXNjZW5kYW50KG5vZGUpIHtcbiAgICAgIHJldHVybiB0aGlzICE9PSBub2RlICYmIHRoaXMuY29udGFpbnMobm9kZSkgJiZcbiAgICAgICAgICB0aGlzLmdldFJvb3ROb2RlKCkgPT09IG5vZGUuZ2V0Um9vdE5vZGUoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhbiBlbGVtZW50IGlzIGluIHRoaXMgZWxlbWVudCdzIGxvY2FsIERPTSB0cmVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBUaGUgZWxlbWVudCB0byBiZSBjaGVja2VkLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgbm9kZSBpcyBpbiB0aGlzIGVsZW1lbnQncyBsb2NhbCBET00gdHJlZS5cbiAgICAgKi9cbiAgICBpc0xvY2FsRGVzY2VuZGFudChub2RlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yb290ID09PSBub2RlLmdldFJvb3ROb2RlKCk7XG4gICAgfVxuXG4gICAgLy8gTk9URTogc2hvdWxkIG5vdyBiZSBoYW5kbGVkIGJ5IFNoYWR5Q3NzIGxpYnJhcnkuXG4gICAgc2NvcGVTdWJ0cmVlKGNvbnRhaW5lciwgc2hvdWxkT2JzZXJ2ZSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgc3R5bGUgdmFsdWUgZm9yIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgVGhlIGNzcyBwcm9wZXJ0eSBuYW1lLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gUmV0dXJucyB0aGUgY29tcHV0ZWQgY3NzIHByb3BlcnR5IHZhbHVlIGZvciB0aGUgZ2l2ZW5cbiAgICAgKiBgcHJvcGVydHlgLlxuICAgICAqL1xuICAgIGdldENvbXB1dGVkU3R5bGVWYWx1ZShwcm9wZXJ0eSkge1xuICAgICAgcmV0dXJuIHN0eWxlSW50ZXJmYWNlLmdldENvbXB1dGVkU3R5bGVWYWx1ZSh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgfVxuXG4gICAgLy8gZGVib3VuY2VcblxuICAgIC8qKlxuICAgICAqIENhbGwgYGRlYm91bmNlYCB0byBjb2xsYXBzZSBtdWx0aXBsZSByZXF1ZXN0cyBmb3IgYSBuYW1lZCB0YXNrIGludG9cbiAgICAgKiBvbmUgaW52b2NhdGlvbiB3aGljaCBpcyBtYWRlIGFmdGVyIHRoZSB3YWl0IHRpbWUgaGFzIGVsYXBzZWQgd2l0aFxuICAgICAqIG5vIG5ldyByZXF1ZXN0LiAgSWYgbm8gd2FpdCB0aW1lIGlzIGdpdmVuLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAgICAgKiBhdCBtaWNyb3Rhc2sgdGltaW5nIChndWFyYW50ZWVkIGJlZm9yZSBwYWludCkuXG4gICAgICpcbiAgICAgKiAgICAgZGVib3VuY2VkQ2xpY2tBY3Rpb24oZSkge1xuICAgICAqICAgICAgIC8vIHdpbGwgbm90IGNhbGwgYHByb2Nlc3NDbGlja2AgbW9yZSB0aGFuIG9uY2UgcGVyIDEwMG1zXG4gICAgICogICAgICAgdGhpcy5kZWJvdW5jZSgnY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgdGhpcy5wcm9jZXNzQ2xpY2soKTtcbiAgICAgKiAgICAgICB9IDEwMCk7XG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFN0cmluZyB0byBpbmRlbnRpZnkgdGhlIGRlYm91bmNlIGpvYi5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCl9IGNhbGxiYWNrIEZ1bmN0aW9uIHRoYXQgaXMgY2FsbGVkICh3aXRoIGB0aGlzYFxuICAgICAqICAgY29udGV4dCkgd2hlbiB0aGUgd2FpdCB0aW1lIGVsYXBzZXMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgT3B0aW9uYWwgd2FpdCB0aW1lIGluIG1pbGxpc2Vjb25kcyAobXMpIGFmdGVyIHRoZVxuICAgICAqICAgbGFzdCBzaWduYWwgdGhhdCBtdXN0IGVsYXBzZSBiZWZvcmUgaW52b2tpbmcgYGNhbGxiYWNrYFxuICAgICAqIEByZXR1cm4ge09iamVjdH0gUmV0dXJucyBhIGRlYm91bmNlciBvYmplY3Qgb24gd2hpY2ggZXhpc3RzIHRoZVxuICAgICAqIGZvbGxvd2luZyBtZXRob2RzOiBgaXNBY3RpdmUoKWAgcmV0dXJucyB0cnVlIGlmIHRoZSBkZWJvdW5jZXIgaXNcbiAgICAgKiBhY3RpdmU7IGBjYW5jZWwoKWAgY2FuY2VscyB0aGUgZGVib3VuY2VyIGlmIGl0IGlzIGFjdGl2ZTtcbiAgICAgKiBgZmx1c2goKWAgaW1tZWRpYXRlbHkgaW52b2tlcyB0aGUgZGVib3VuY2VkIGNhbGxiYWNrIGlmIHRoZSBkZWJvdW5jZXJcbiAgICAgKiBpcyBhY3RpdmUuXG4gICAgICovXG4gICAgZGVib3VuY2Uoam9iTmFtZSwgY2FsbGJhY2ssIHdhaXQpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV0gPSBEZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgICB0aGlzLl9kZWJvdW5jZXJzW2pvYk5hbWVdXG4gICAgICAgICAgLCB3YWl0ID4gMCA/IHRpbWVPdXQuYWZ0ZXIod2FpdCkgOiBtaWNyb1Rhc2tcbiAgICAgICAgICAsIGNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciBhIG5hbWVkIGRlYm91bmNlciBpcyBhY3RpdmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gam9iTmFtZSBUaGUgbmFtZSBvZiB0aGUgZGVib3VuY2VyIHN0YXJ0ZWQgd2l0aCBgZGVib3VuY2VgXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZGVib3VuY2VyIGlzIGFjdGl2ZSAoaGFzIG5vdCB5ZXQgZmlyZWQpLlxuICAgICAqL1xuICAgIGlzRGVib3VuY2VyQWN0aXZlKGpvYk5hbWUpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICByZXR1cm4gISEoZGVib3VuY2VyICYmIGRlYm91bmNlci5pc0FjdGl2ZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbW1lZGlhdGVseSBjYWxscyB0aGUgZGVib3VuY2VyIGBjYWxsYmFja2AgYW5kIGluYWN0aXZhdGVzIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGpvYk5hbWUgVGhlIG5hbWUgb2YgdGhlIGRlYm91bmNlciBzdGFydGVkIHdpdGggYGRlYm91bmNlYFxuICAgICAqL1xuICAgIGZsdXNoRGVib3VuY2VyKGpvYk5hbWUpIHtcbiAgICAgIHRoaXMuX2RlYm91bmNlcnMgPSB0aGlzLl9kZWJvdW5jZXJzIHx8IHt9O1xuICAgICAgbGV0IGRlYm91bmNlciA9IHRoaXMuX2RlYm91bmNlcnNbam9iTmFtZV07XG4gICAgICBpZiAoZGVib3VuY2VyKSB7XG4gICAgICAgIGRlYm91bmNlci5mbHVzaCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gYWN0aXZlIGRlYm91bmNlci4gIFRoZSBgY2FsbGJhY2tgIHdpbGwgbm90IGJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBqb2JOYW1lIFRoZSBuYW1lIG9mIHRoZSBkZWJvdW5jZXIgc3RhcnRlZCB3aXRoIGBkZWJvdW5jZWBcbiAgICAgKi9cbiAgICBjYW5jZWxEZWJvdW5jZXIoam9iTmFtZSkge1xuICAgICAgdGhpcy5fZGVib3VuY2VycyA9IHRoaXMuX2RlYm91bmNlcnMgfHwge307XG4gICAgICBsZXQgZGVib3VuY2VyID0gdGhpcy5fZGVib3VuY2Vyc1tqb2JOYW1lXTtcbiAgICAgIGlmIChkZWJvdW5jZXIpIHtcbiAgICAgICAgZGVib3VuY2VyLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiBhc3luY3Jvbm91c2x5LlxuICAgICAqXG4gICAgICogQnkgZGVmYXVsdCAoaWYgbm8gd2FpdFRpbWUgaXMgc3BlY2lmaWVkKSwgYXN5bmMgY2FsbGJhY2tzIGFyZSBydW4gYXRcbiAgICAgKiBtaWNyb3Rhc2sgdGltaW5nLCB3aGljaCB3aWxsIG9jY3VyIGJlZm9yZSBwYWludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBydW4sIGJvdW5kIHRvIGB0aGlzYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcj19IHdhaXRUaW1lIFRpbWUgdG8gd2FpdCBiZWZvcmUgY2FsbGluZyB0aGVcbiAgICAgKiAgIGBjYWxsYmFja2AuICBJZiB1bnNwZWNpZmllZCBvciAwLCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBydW4gYXQgbWljcm90YXNrXG4gICAgICogICB0aW1pbmcgKGJlZm9yZSBwYWludCkuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBIYW5kbGUgdGhhdCBtYXkgYmUgdXNlZCB0byBjYW5jZWwgdGhlIGFzeW5jIGpvYi5cbiAgICAgKi9cbiAgICBhc3luYyhjYWxsYmFjaywgd2FpdFRpbWUpIHtcbiAgICAgIHJldHVybiB3YWl0VGltZSA+IDAgPyB0aW1lT3V0LnJ1bihjYWxsYmFjay5iaW5kKHRoaXMpLCB3YWl0VGltZSkgOlxuICAgICAgICAgIH5taWNyb1Rhc2sucnVuKGNhbGxiYWNrLmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbmNlbHMgYW4gYXN5bmMgb3BlcmF0aW9uIHN0YXJ0ZWQgd2l0aCBgYXN5bmNgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhhbmRsZSBIYW5kbGUgcmV0dXJuZWQgZnJvbSBvcmlnaW5hbCBgYXN5bmNgIGNhbGwgdG9cbiAgICAgKiAgIGNhbmNlbC5cbiAgICAgKi9cbiAgICBjYW5jZWxBc3luYyhoYW5kbGUpIHtcbiAgICAgIGhhbmRsZSA8IDAgPyBtaWNyb1Rhc2suY2FuY2VsKH5oYW5kbGUpIDpcbiAgICAgICAgICB0aW1lT3V0LmNhbmNlbChoYW5kbGUpO1xuICAgIH1cblxuICAgIC8vIG90aGVyXG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgZm9yIGNyZWF0aW5nIGFuIGVsZW1lbnQgYW5kIGNvbmZpZ3VyaW5nIGl0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBIVE1MIGVsZW1lbnQgdGFnIHRvIGNyZWF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgT2JqZWN0IG9mIHByb3BlcnRpZXMgdG8gY29uZmlndXJlIG9uIHRoZVxuICAgICAqICAgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IE5ld2x5IGNyZWF0ZWQgYW5kIGNvbmZpZ3VyZWQgZWxlbWVudC5cbiAgICAgKi9cbiAgICBjcmVhdGUodGFnLCBwcm9wcykge1xuICAgICAgbGV0IGVsdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgICAgIGlmIChwcm9wcykge1xuICAgICAgICBpZiAoZWx0LnNldFByb3BlcnRpZXMpIHtcbiAgICAgICAgICBlbHQuc2V0UHJvcGVydGllcyhwcm9wcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZm9yIChsZXQgbiBpbiBwcm9wcykge1xuICAgICAgICAgICAgZWx0W25dID0gcHJvcHNbbl07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIG1ldGhvZCBmb3IgaW1wb3J0aW5nIGFuIEhUTUwgZG9jdW1lbnQgaW1wZXJhdGl2ZWx5LlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgY3JlYXRlcyBhIG5ldyBgPGxpbmsgcmVsPVwiaW1wb3J0XCI+YCBlbGVtZW50IHdpdGhcbiAgICAgKiB0aGUgcHJvdmlkZWQgVVJMIGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBkb2N1bWVudCB0byBzdGFydCBsb2FkaW5nLlxuICAgICAqIEluIHRoZSBgb25sb2FkYCBjYWxsYmFjaywgdGhlIGBpbXBvcnRgIHByb3BlcnR5IG9mIHRoZSBgbGlua2BcbiAgICAgKiBlbGVtZW50IHdpbGwgY29udGFpbiB0aGUgaW1wb3J0ZWQgZG9jdW1lbnQgY29udGVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaHJlZiBVUkwgdG8gZG9jdW1lbnQgdG8gbG9hZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvbmxvYWQgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0IHN1Y2Nlc3NmdWxseVxuICAgICAqICAgbG9hZGVkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9uZXJyb3IgQ2FsbGJhY2sgdG8gbm90aWZ5IHdoZW4gYW4gaW1wb3J0XG4gICAgICogICB1bnN1Y2Nlc3NmdWxseSBsb2FkZWQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBvcHRBc3luYyBUcnVlIGlmIHRoZSBpbXBvcnQgc2hvdWxkIGJlIGxvYWRlZCBgYXN5bmNgLlxuICAgICAqICAgRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAgICAgKiBAcmV0dXJuIHtIVE1MTGlua0VsZW1lbnR9IFRoZSBsaW5rIGVsZW1lbnQgZm9yIHRoZSBVUkwgdG8gYmUgbG9hZGVkLlxuICAgICAqL1xuICAgIGltcG9ydEhyZWYoaHJlZiwgb25sb2FkLCBvbmVycm9yLCBvcHRBc3luYykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBsZXQgbG9hZEZuID0gb25sb2FkID8gb25sb2FkLmJpbmQodGhpcykgOiBudWxsO1xuICAgICAgbGV0IGVycm9yRm4gPSBvbmVycm9yID8gb25lcnJvci5iaW5kKHRoaXMpIDogbnVsbDtcbiAgICAgIHJldHVybiBpbXBvcnRIcmVmJDAoaHJlZiwgbG9hZEZuLCBlcnJvckZuLCBvcHRBc3luYyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUG9seWZpbGwgZm9yIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMsIHdoaWNoIGlzIHNvbWV0aW1lcyBzdGlsbFxuICAgICAqIHByZWZpeGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yIFNlbGVjdG9yIHRvIHRlc3QuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIHRlc3QgdGhlIHNlbGVjdG9yIGFnYWluc3QuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgZWxlbWVudCBtYXRjaGVzIHRoZSBzZWxlY3Rvci5cbiAgICAgKi9cbiAgICBlbGVtZW50TWF0Y2hlcyhzZWxlY3Rvciwgbm9kZSkge1xuICAgICAgcmV0dXJuIG1hdGNoZXNTZWxlY3RvciggKG5vZGUgfHwgdGhpcyksIHNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGFuIEhUTUwgYXR0cmlidXRlIG9uIG9yIG9mZi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEhUTUwgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBib29sIEJvb2xlYW4gdG8gZm9yY2UgdGhlIGF0dHJpYnV0ZSBvbiBvciBvZmYuXG4gICAgICogICAgV2hlbiB1bnNwZWNpZmllZCwgdGhlIHN0YXRlIG9mIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZXZlcnNlZC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIE5vZGUgdG8gdGFyZ2V0LiAgRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAqL1xuICAgIHRvZ2dsZUF0dHJpYnV0ZShuYW1lLCBib29sLCBub2RlKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgYm9vbCA9ICFub2RlLmhhc0F0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmIChib29sKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKG5hbWUsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuXG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBhIENTUyBjbGFzcyBvbiBvciBvZmYuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBDU1MgY2xhc3MgbmFtZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGJvb2wgQm9vbGVhbiB0byBmb3JjZSB0aGUgY2xhc3Mgb24gb3Igb2ZmLlxuICAgICAqICAgIFdoZW4gdW5zcGVjaWZpZWQsIHRoZSBzdGF0ZSBvZiB0aGUgY2xhc3Mgd2lsbCBiZSByZXZlcnNlZC5cbiAgICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBub2RlIE5vZGUgdG8gdGFyZ2V0LiAgRGVmYXVsdHMgdG8gYHRoaXNgLlxuICAgICAqL1xuICAgIHRvZ2dsZUNsYXNzKG5hbWUsIGJvb2wsIG5vZGUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuICAgICAgICBib29sID0gIW5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xuICAgICAgfVxuICAgICAgaWYgKGJvb2wpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzLXBsYXRmb3JtIGhlbHBlciBmb3Igc2V0dGluZyBhbiBlbGVtZW50J3MgQ1NTIGB0cmFuc2Zvcm1gIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZm9ybVRleHQgVHJhbnNmb3JtIHNldHRpbmcuXG4gICAgICogQHBhcmFtIHtFbGVtZW50PX0gbm9kZSBFbGVtZW50IHRvIGFwcGx5IHRoZSB0cmFuc2Zvcm0gdG8uXG4gICAgICogRGVmYXVsdHMgdG8gYHRoaXNgXG4gICAgICovXG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybVRleHQsIG5vZGUpIHtcbiAgICAgIG5vZGUgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChub2RlIHx8IHRoaXMpO1xuICAgICAgbm9kZS5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZXh0O1xuICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZXh0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyb3NzLXBsYXRmb3JtIGhlbHBlciBmb3Igc2V0dGluZyBhbiBlbGVtZW50J3MgQ1NTIGB0cmFuc2xhdGUzZGBcbiAgICAgKiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IFggb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IFkgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB6IFogb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7RWxlbWVudD19IG5vZGUgRWxlbWVudCB0byBhcHBseSB0aGUgdHJhbnNmb3JtIHRvLlxuICAgICAqIERlZmF1bHRzIHRvIGB0aGlzYC5cbiAgICAgKi9cbiAgICB0cmFuc2xhdGUzZCh4LCB5LCB6LCBub2RlKSB7XG4gICAgICBub2RlID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobm9kZSB8fCB0aGlzKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCd0cmFuc2xhdGUzZCgnICsgeCArICcsJyArIHkgKyAnLCcgKyB6ICsgJyknLCBub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFuIGl0ZW0gZnJvbSBhbiBhcnJheSwgaWYgaXQgZXhpc3RzLlxuICAgICAqXG4gICAgICogSWYgdGhlIGFycmF5IGlzIHNwZWNpZmllZCBieSBwYXRoLCBhIGNoYW5nZSBub3RpZmljYXRpb24gaXNcbiAgICAgKiBnZW5lcmF0ZWQsIHNvIHRoYXQgb2JzZXJ2ZXJzLCBkYXRhIGJpbmRpbmdzIGFuZCBjb21wdXRlZFxuICAgICAqIHByb3BlcnRpZXMgd2F0Y2hpbmcgdGhhdCBwYXRoIGNhbiB1cGRhdGUuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgYXJyYXkgaXMgcGFzc2VkIGRpcmVjdGx5LCAqKm5vIGNoYW5nZVxuICAgICAqIG5vdGlmaWNhdGlvbiBpcyBnZW5lcmF0ZWQqKi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nIHwgIUFycmF5PG51bWJlcnxzdHJpbmc+fSBhcnJheU9yUGF0aCBQYXRoIHRvIGFycmF5IGZyb20gd2hpY2ggdG8gcmVtb3ZlIHRoZSBpdGVtXG4gICAgICogICAob3IgdGhlIGFycmF5IGl0c2VsZikuXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSBjb250YWluaW5nIGl0ZW0gcmVtb3ZlZC5cbiAgICAgKi9cbiAgICBhcnJheURlbGV0ZShhcnJheU9yUGF0aCwgaXRlbSkge1xuICAgICAgbGV0IGluZGV4O1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlPclBhdGgpKSB7XG4gICAgICAgIGluZGV4ID0gYXJyYXlPclBhdGguaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICByZXR1cm4gYXJyYXlPclBhdGguc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IGFyciA9IGdldCQwKHRoaXMsIGFycmF5T3JQYXRoKTtcbiAgICAgICAgaW5kZXggPSBhcnIuaW5kZXhPZihpdGVtKTtcbiAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5zcGxpY2UoYXJyYXlPclBhdGgsIGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gbG9nZ2luZ1xuXG4gICAgLyoqXG4gICAgICogRmFjYWRlcyBgY29uc29sZS5sb2dgL2B3YXJuYC9gZXJyb3JgIGFzIG92ZXJyaWRlIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGxldmVsIE9uZSBvZiAnbG9nJywgJ3dhcm4nLCAnZXJyb3InXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICovXG4gICAgX2xvZ2dlcihsZXZlbCwgYXJncykge1xuICAgICAgLy8gYWNjZXB0IFsnZm9vJywgJ2JhciddIGFuZCBbWydmb28nLCAnYmFyJ11dXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzKSAmJiBhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBhcmdzID0gYXJnc1swXTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaChsZXZlbCkge1xuICAgICAgICBjYXNlICdsb2cnOlxuICAgICAgICBjYXNlICd3YXJuJzpcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgIGNvbnNvbGVbbGV2ZWxdKC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZhY2FkZXMgYGNvbnNvbGUubG9nYCBhcyBhbiBvdmVycmlkZSBwb2ludC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcnJheSBvZiBzdHJpbmdzIG9yIG9iamVjdHMgdG8gbG9nXG4gICAgICovXG4gICAgX2xvZyguLi5hcmdzKSB7XG4gICAgICB0aGlzLl9sb2dnZXIoJ2xvZycsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZhY2FkZXMgYGNvbnNvbGUud2FybmAgYXMgYW4gb3ZlcnJpZGUgcG9pbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAqL1xuICAgIF93YXJuKC4uLmFyZ3MpIHtcbiAgICAgIHRoaXMuX2xvZ2dlcignd2FybicsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZhY2FkZXMgYGNvbnNvbGUuZXJyb3JgIGFzIGFuIG92ZXJyaWRlIHBvaW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFycmF5IG9mIHN0cmluZ3Mgb3Igb2JqZWN0cyB0byBsb2dcbiAgICAgKi9cbiAgICBfZXJyb3IoLi4uYXJncykge1xuICAgICAgdGhpcy5fbG9nZ2VyKCdlcnJvcicsIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZvcm1hdHMgYSBtZXNzYWdlIHVzaW5nIHRoZSBlbGVtZW50IHR5cGUgYW4gYSBtZXRob2QgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2ROYW1lIE1ldGhvZCBuYW1lIHRvIGFzc29jaWF0ZSB3aXRoIG1lc3NhZ2VcbiAgICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJyYXkgb2Ygc3RyaW5ncyBvciBvYmplY3RzIHRvIGxvZ1xuICAgICAqIEByZXR1cm4ge0FycmF5fSBBcnJheSB3aXRoIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24gZm9yIGBjb25zb2xlYFxuICAgICAqICAgbG9nZ2luZy5cbiAgICAgKi9cbiAgICBfbG9nZihtZXRob2ROYW1lLCAuLi5hcmdzKSB7XG4gICAgICByZXR1cm4gWydbJXM6OiVzXScsIHRoaXMuaXMsIG1ldGhvZE5hbWUsIC4uLmFyZ3NdO1xuICAgIH1cblxuICB9XG5cbiAgTGVnYWN5RWxlbWVudC5wcm90b3R5cGUuaXMgPSAnJztcblxuICByZXR1cm4gTGVnYWN5RWxlbWVudDtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvbGVnYWN5LWVsZW1lbnQtbWl4aW4uanNcbi8vIG1vZHVsZSBpZCA9IDM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtuYXRpdmVTaGFkb3csIG5hdGl2ZUNzc1ZhcmlhYmxlc30gZnJvbSAnLi9zdHlsZS1zZXR0aW5ncy5qcyc7XG5pbXBvcnQge3BhcnNlLCBzdHJpbmdpZnksIHR5cGVzLCBTdHlsZU5vZGV9IGZyb20gJy4vY3NzLXBhcnNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHtNRURJQV9NQVRDSH0gZnJvbSAnLi9jb21tb24tcmVnZXguanMnO1xuaW1wb3J0IHtwcm9jZXNzVW5zY29wZWRTdHlsZSwgaXNVbnNjb3BlZFN0eWxlfSBmcm9tICcuL3Vuc2NvcGVkLXN0eWxlLWhhbmRsZXIuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfFN0eWxlTm9kZX0gcnVsZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oU3R5bGVOb2RlKT19IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Nzc1RleHQgKHJ1bGVzLCBjYWxsYmFjaykge1xuICBpZiAoIXJ1bGVzKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmICh0eXBlb2YgcnVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcnVsZXMgPSBwYXJzZShydWxlcyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgZm9yRWFjaFJ1bGUocnVsZXMsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gc3RyaW5naWZ5KHJ1bGVzLCBuYXRpdmVDc3NWYXJpYWJsZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVzRm9yU3R5bGUoc3R5bGUpIHtcbiAgaWYgKCFzdHlsZVsnX19jc3NSdWxlcyddICYmIHN0eWxlLnRleHRDb250ZW50KSB7XG4gICAgc3R5bGVbJ19fY3NzUnVsZXMnXSA9IHBhcnNlKHN0eWxlLnRleHRDb250ZW50KTtcbiAgfVxuICByZXR1cm4gc3R5bGVbJ19fY3NzUnVsZXMnXSB8fCBudWxsO1xufVxuXG4vLyBUZXN0cyBpZiBhIHJ1bGUgaXMgYSBrZXlmcmFtZXMgc2VsZWN0b3IsIHdoaWNoIGxvb2tzIGFsbW9zdCBleGFjdGx5XG4vLyBsaWtlIGEgbm9ybWFsIHNlbGVjdG9yIGJ1dCBpcyBub3QgKGl0IGhhcyBub3RoaW5nIHRvIGRvIHdpdGggc2NvcGluZ1xuLy8gZm9yIGV4YW1wbGUpLlxuLyoqXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gcnVsZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzS2V5ZnJhbWVzU2VsZWN0b3IocnVsZSkge1xuICByZXR1cm4gQm9vbGVhbihydWxlWydwYXJlbnQnXSkgJiZcbiAgcnVsZVsncGFyZW50J11bJ3R5cGUnXSA9PT0gdHlwZXMuS0VZRlJBTUVTX1JVTEU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHlsZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBzdHlsZVJ1bGVDYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbj19IGtleWZyYW1lc1J1bGVDYWxsYmFja1xuICogQHBhcmFtIHtib29sZWFuPX0gb25seUFjdGl2ZVJ1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoUnVsZShub2RlLCBzdHlsZVJ1bGVDYWxsYmFjaywga2V5ZnJhbWVzUnVsZUNhbGxiYWNrLCBvbmx5QWN0aXZlUnVsZXMpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBza2lwUnVsZXMgPSBmYWxzZTtcbiAgbGV0IHR5cGUgPSBub2RlWyd0eXBlJ107XG4gIGlmIChvbmx5QWN0aXZlUnVsZXMpIHtcbiAgICBpZiAodHlwZSA9PT0gdHlwZXMuTUVESUFfUlVMRSkge1xuICAgICAgbGV0IG1hdGNoTWVkaWEgPSBub2RlWydzZWxlY3RvciddLm1hdGNoKE1FRElBX01BVENIKTtcbiAgICAgIGlmIChtYXRjaE1lZGlhKSB7XG4gICAgICAgIC8vIGlmIHJ1bGUgaXMgYSBub24gbWF0Y2hpbmcgQG1lZGlhIHJ1bGUsIHNraXAgc3VicnVsZXNcbiAgICAgICAgaWYgKCF3aW5kb3cubWF0Y2hNZWRpYShtYXRjaE1lZGlhWzFdKS5tYXRjaGVzKSB7XG4gICAgICAgICAgc2tpcFJ1bGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodHlwZSA9PT0gdHlwZXMuU1RZTEVfUlVMRSkge1xuICAgIHN0eWxlUnVsZUNhbGxiYWNrKG5vZGUpO1xuICB9IGVsc2UgaWYgKGtleWZyYW1lc1J1bGVDYWxsYmFjayAmJlxuICAgIHR5cGUgPT09IHR5cGVzLktFWUZSQU1FU19SVUxFKSB7XG4gICAga2V5ZnJhbWVzUnVsZUNhbGxiYWNrKG5vZGUpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IHR5cGVzLk1JWElOX1JVTEUpIHtcbiAgICBza2lwUnVsZXMgPSB0cnVlO1xuICB9XG4gIGxldCByJCA9IG5vZGVbJ3J1bGVzJ107XG4gIGlmIChyJCAmJiAhc2tpcFJ1bGVzKSB7XG4gICAgZm9yIChsZXQgaT0wLCBsPXIkLmxlbmd0aCwgcjsgKGk8bCkgJiYgKHI9ciRbaV0pOyBpKyspIHtcbiAgICAgIGZvckVhY2hSdWxlKHIsIHN0eWxlUnVsZUNhbGxiYWNrLCBrZXlmcmFtZXNSdWxlQ2FsbGJhY2ssIG9ubHlBY3RpdmVSdWxlcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIGFkZCBhIHN0cmluZyBvZiBjc3NUZXh0IHRvIHRoZSBkb2N1bWVudC5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb25pa2VyXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBjb250ZXh0Tm9kZVxuICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5Q3NzKGNzc1RleHQsIG1vbmlrZXIsIHRhcmdldCwgY29udGV4dE5vZGUpIHtcbiAgbGV0IHN0eWxlID0gY3JlYXRlU2NvcGVTdHlsZShjc3NUZXh0LCBtb25pa2VyKTtcbiAgYXBwbHlTdHlsZShzdHlsZSwgdGFyZ2V0LCBjb250ZXh0Tm9kZSk7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IG1vbmlrZXJcbiAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY29wZVN0eWxlKGNzc1RleHQsIG1vbmlrZXIpIHtcbiAgbGV0IHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqLyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpKTtcbiAgaWYgKG1vbmlrZXIpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3Njb3BlJywgbW9uaWtlcik7XG4gIH1cbiAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3NUZXh0O1xuICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogVHJhY2sgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IGFkZGVkIHN0eWxlIGZvciBwbGFjaW5nIHBsYWNlaG9sZGVyc1xuICogQHR5cGUge05vZGV9XG4gKi9cbmxldCBsYXN0SGVhZEFwcGx5Tm9kZSA9IG51bGw7XG5cbi8vIGluc2VydCBhIGNvbW1lbnQgbm9kZSBhcyBhIHN0eWxpbmcgcG9zaXRpb24gcGxhY2Vob2xkZXIuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb25pa2VyXG4gKiBAcmV0dXJuIHshQ29tbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3R5bGVQbGFjZUhvbGRlcihtb25pa2VyKSB7XG4gIGxldCBwbGFjZUhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJyBTaGFkeSBET00gc3R5bGVzIGZvciAnICtcbiAgICBtb25pa2VyICsgJyAnKTtcbiAgbGV0IGFmdGVyID0gbGFzdEhlYWRBcHBseU5vZGUgP1xuICAgIGxhc3RIZWFkQXBwbHlOb2RlWyduZXh0U2libGluZyddIDogbnVsbDtcbiAgbGV0IHNjb3BlID0gZG9jdW1lbnQuaGVhZDtcbiAgc2NvcGUuaW5zZXJ0QmVmb3JlKHBsYWNlSG9sZGVyLCBhZnRlciB8fCBzY29wZS5maXJzdENoaWxkKTtcbiAgbGFzdEhlYWRBcHBseU5vZGUgPSBwbGFjZUhvbGRlcjtcbiAgcmV0dXJuIHBsYWNlSG9sZGVyO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEBwYXJhbSB7P05vZGV9IHRhcmdldFxuICogQHBhcmFtIHs/Tm9kZX0gY29udGV4dE5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3R5bGUoc3R5bGUsIHRhcmdldCwgY29udGV4dE5vZGUpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IGRvY3VtZW50LmhlYWQ7XG4gIGxldCBhZnRlciA9IChjb250ZXh0Tm9kZSAmJiBjb250ZXh0Tm9kZS5uZXh0U2libGluZykgfHxcbiAgICB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgdGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgYWZ0ZXIpO1xuICBpZiAoIWxhc3RIZWFkQXBwbHlOb2RlKSB7XG4gICAgbGFzdEhlYWRBcHBseU5vZGUgPSBzdHlsZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvbmx5IHVwZGF0ZSBsYXN0SGVhZEFwcGx5Tm9kZSBpZiB0aGUgbmV3IHN0eWxlIGlzIGluc2VydGVkIGFmdGVyIHRoZSBvbGQgbGFzdEhlYWRBcHBseU5vZGVcbiAgICBsZXQgcG9zaXRpb24gPSBzdHlsZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihsYXN0SGVhZEFwcGx5Tm9kZSk7XG4gICAgaWYgKHBvc2l0aW9uID09PSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykge1xuICAgICAgbGFzdEhlYWRBcHBseU5vZGUgPSBzdHlsZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVpbGRUeXBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUYXJnZXRlZEJ1aWxkKGJ1aWxkVHlwZSkge1xuICByZXR1cm4gbmF0aXZlU2hhZG93ID8gYnVpbGRUeXBlID09PSAnc2hhZG93JyA6IGJ1aWxkVHlwZSA9PT0gJ3NoYWR5Jztcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4gez9zdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDc3NCdWlsZFR5cGUoZWxlbWVudCkge1xuICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Nzcy1idWlsZCcpO1xufVxuXG4vKipcbiAqIFdhbGsgZnJvbSB0ZXh0W3N0YXJ0XSBtYXRjaGluZyBwYXJlbnMgYW5kXG4gKiByZXR1cm5zIHBvc2l0aW9uIG9mIHRoZSBvdXRlciBlbmQgcGFyZW5cbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZmluZE1hdGNoaW5nUGFyZW4odGV4dCwgc3RhcnQpIHtcbiAgbGV0IGxldmVsID0gMDtcbiAgZm9yIChsZXQgaT1zdGFydCwgbD10ZXh0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh0ZXh0W2ldID09PSAnKCcpIHtcbiAgICAgIGxldmVsKys7XG4gICAgfSBlbHNlIGlmICh0ZXh0W2ldID09PSAnKScpIHtcbiAgICAgIGlmICgtLWxldmVsID09PSAwKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gLTE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtmdW5jdGlvbihzdHJpbmcsIHN0cmluZywgc3RyaW5nLCBzdHJpbmcpfSBjYWxsYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2soc3RyLCBjYWxsYmFjaykge1xuICAvLyBmaW5kICd2YXIoJ1xuICBsZXQgc3RhcnQgPSBzdHIuaW5kZXhPZigndmFyKCcpO1xuICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgLy8gbm8gdmFyPywgZXZlcnl0aGluZyBpcyBwcmVmaXhcbiAgICByZXR1cm4gY2FsbGJhY2soc3RyLCAnJywgJycsICcnKTtcbiAgfVxuICAvLyR7cHJlZml4fXZhcigke2lubmVyfSkke3N1ZmZpeH1cbiAgbGV0IGVuZCA9IGZpbmRNYXRjaGluZ1BhcmVuKHN0ciwgc3RhcnQgKyAzKTtcbiAgbGV0IGlubmVyID0gc3RyLnN1YnN0cmluZyhzdGFydCArIDQsIGVuZCk7XG4gIGxldCBwcmVmaXggPSBzdHIuc3Vic3RyaW5nKDAsIHN0YXJ0KTtcbiAgLy8gc3VmZml4IG1heSBoYXZlIG90aGVyIHZhcmlhYmxlc1xuICBsZXQgc3VmZml4ID0gcHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2soc3RyLnN1YnN0cmluZyhlbmQgKyAxKSwgY2FsbGJhY2spO1xuICBsZXQgY29tbWEgPSBpbm5lci5pbmRleE9mKCcsJyk7XG4gIC8vIHZhbHVlIGFuZCBmYWxsYmFjayBhcmdzIHNob3VsZCBiZSB0cmltbWVkIHRvIG1hdGNoIGluIHByb3BlcnR5IGxvb2t1cFxuICBpZiAoY29tbWEgPT09IC0xKSB7XG4gICAgLy8gdmFyaWFibGUsIG5vIGZhbGxiYWNrXG4gICAgcmV0dXJuIGNhbGxiYWNrKHByZWZpeCwgaW5uZXIudHJpbSgpLCAnJywgc3VmZml4KTtcbiAgfVxuICAvLyB2YXIoJHt2YWx1ZX0sJHtmYWxsYmFja30pXG4gIGxldCB2YWx1ZSA9IGlubmVyLnN1YnN0cmluZygwLCBjb21tYSkudHJpbSgpO1xuICBsZXQgZmFsbGJhY2sgPSBpbm5lci5zdWJzdHJpbmcoY29tbWEgKyAxKS50cmltKCk7XG4gIHJldHVybiBjYWxsYmFjayhwcmVmaXgsIHZhbHVlLCBmYWxsYmFjaywgc3VmZml4KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RWxlbWVudENsYXNzUmF3KGVsZW1lbnQsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgc2V0QXR0cmlidXRlIHByb3ZpZGVkIGJ5IFNoYWR5RE9NIHdoZW4gc2V0QXR0cmlidXRlIGlzIHBhdGNoZWRcbiAgaWYgKG5hdGl2ZVNoYWRvdykge1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICB3aW5kb3dbJ1NoYWR5RE9NJ11bJ25hdGl2ZU1ldGhvZHMnXVsnc2V0QXR0cmlidXRlJ10uY2FsbChlbGVtZW50LCAnY2xhc3MnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnQgfCB7aXM6IHN0cmluZywgZXh0ZW5kczogc3RyaW5nfX0gZWxlbWVudFxuICogQHJldHVybiB7e2lzOiBzdHJpbmcsIHR5cGVFeHRlbnNpb246IHN0cmluZ319XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJc0V4dGVuZHMoZWxlbWVudCkge1xuICBsZXQgbG9jYWxOYW1lID0gZWxlbWVudFsnbG9jYWxOYW1lJ107XG4gIGxldCBpcyA9ICcnLCB0eXBlRXh0ZW5zaW9uID0gJyc7XG4gIC8qXG4gIE5PVEU6IHRlY2huaWNhbGx5LCB0aGlzIGNhbiBiZSB3cm9uZyBmb3IgY2VydGFpbiBzdmcgZWxlbWVudHNcbiAgd2l0aCBgLWAgaW4gdGhlIG5hbWUgbGlrZSBgPGZvbnQtZmFjZT5gXG4gICovXG4gIGlmIChsb2NhbE5hbWUpIHtcbiAgICBpZiAobG9jYWxOYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICBpcyA9IGxvY2FsTmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZUV4dGVuc2lvbiA9IGxvY2FsTmFtZTtcbiAgICAgIGlzID0gKGVsZW1lbnQuZ2V0QXR0cmlidXRlICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpcycpKSB8fCAnJztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaXMgPSAvKiogQHR5cGUgez99ICovKGVsZW1lbnQpLmlzO1xuICAgIHR5cGVFeHRlbnNpb24gPSAvKiogQHR5cGUgez99ICovKGVsZW1lbnQpLmV4dGVuZHM7XG4gIH1cbiAgcmV0dXJuIHtpcywgdHlwZUV4dGVuc2lvbn07XG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fERvY3VtZW50RnJhZ21lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdhdGhlclN0eWxlVGV4dChlbGVtZW50KSB7XG4gIC8qKiBAdHlwZSB7IUFycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IHN0eWxlVGV4dFBhcnRzID0gW107XG4gIGNvbnN0IHN0eWxlcyA9IC8qKiBAdHlwZSB7IU5vZGVMaXN0PCFIVE1MU3R5bGVFbGVtZW50Pn0gKi8oZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdzdHlsZScpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzdHlsZSA9IHN0eWxlc1tpXTtcbiAgICBpZiAoaXNVbnNjb3BlZFN0eWxlKHN0eWxlKSkge1xuICAgICAgaWYgKCFuYXRpdmVTaGFkb3cpIHtcbiAgICAgICAgcHJvY2Vzc1Vuc2NvcGVkU3R5bGUoc3R5bGUpO1xuICAgICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVUZXh0UGFydHMucHVzaChzdHlsZS50ZXh0Q29udGVudCk7XG4gICAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0eWxlVGV4dFBhcnRzLmpvaW4oJycpLnRyaW0oKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvc3R5bGUtdXRpbC5qc1xuLy8gbW9kdWxlIGlkID0gMzdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBjb25zdCB7IU9iamVjdDxzdHJpbmcsICFIVE1MVGVtcGxhdGVFbGVtZW50Pn1cbiAqL1xuY29uc3QgdGVtcGxhdGVNYXAgPSB7fTtcbmV4cG9ydCBkZWZhdWx0IHRlbXBsYXRlTWFwO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3RlbXBsYXRlLW1hcC5qc1xuLy8gbW9kdWxlIGlkID0gMzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge1Byb21pc2U8dm9pZD59ICovXG5sZXQgcmVhZHlQcm9taXNlID0gbnVsbDtcblxuLyoqIEB0eXBlIHs/ZnVuY3Rpb24oP2Z1bmN0aW9uKCkpfSAqL1xubGV0IHdoZW5SZWFkeSA9IHdpbmRvd1snSFRNTEltcG9ydHMnXSAmJiB3aW5kb3dbJ0hUTUxJbXBvcnRzJ11bJ3doZW5SZWFkeSddIHx8IG51bGw7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oKX0gKi9cbmxldCByZXNvbHZlRm47XG5cbi8qKlxuICogQHBhcmFtIHs/ZnVuY3Rpb24oKX0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZG9jdW1lbnRXYWl0KGNhbGxiYWNrKSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICBpZiAod2hlblJlYWR5KSB7XG4gICAgICB3aGVuUmVhZHkoY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmVhZHlQcm9taXNlKSB7XG4gICAgICAgIHJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7cmVzb2x2ZUZuID0gcmVzb2x2ZX0pO1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIHJlc29sdmVGbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICByZXNvbHZlRm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24oKXsgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTsgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9kb2N1bWVudC13YWl0LmpzXG4vLyBtb2R1bGUgaWQgPSAzOVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCBkb2N1bWVudFdhaXQgZnJvbSAnLi9kb2N1bWVudC13YWl0LmpzJztcblxuLyoqXG4gKiBAdHlwZWRlZiB7SFRNTFN0eWxlRWxlbWVudCB8IHtnZXRTdHlsZTogZnVuY3Rpb24oKTpIVE1MU3R5bGVFbGVtZW50fX1cbiAqL1xuZXhwb3J0IGxldCBDdXN0b21TdHlsZVByb3ZpZGVyO1xuXG5jb25zdCBTRUVOX01BUktFUiA9ICdfX3NlZW5CeVNoYWR5Q1NTJztcbmNvbnN0IENBQ0hFRF9TVFlMRSA9ICdfX3NoYWR5Q1NTQ2FjaGVkU3R5bGUnO1xuXG4vKiogQHR5cGUgez9mdW5jdGlvbighSFRNTFN0eWxlRWxlbWVudCl9ICovXG5sZXQgdHJhbnNmb3JtRm4gPSBudWxsO1xuXG4vKiogQHR5cGUgez9mdW5jdGlvbigpfSAqL1xubGV0IHZhbGlkYXRlRm4gPSBudWxsO1xuXG4vKipcblRoaXMgaW50ZXJmYWNlIGlzIHByb3ZpZGVkIHRvIGFkZCBkb2N1bWVudC1sZXZlbCA8c3R5bGU+IGVsZW1lbnRzIHRvIFNoYWR5Q1NTIGZvciBwcm9jZXNzaW5nLlxuVGhlc2Ugc3R5bGVzIG11c3QgYmUgcHJvY2Vzc2VkIGJ5IFNoYWR5Q1NTIHRvIHNpbXVsYXRlIFNoYWRvd1Jvb3QgdXBwZXItYm91bmQgZW5jYXBzdWxhdGlvbiBmcm9tIG91dHNpZGUgc3R5bGVzXG5JbiBhZGRpdGlvbiwgdGhlc2Ugc3R5bGVzIG1heSBhbHNvIG5lZWQgdG8gYmUgcHJvY2Vzc2VkIGZvciBAYXBwbHkgcnVsZXMgYW5kIENTUyBDdXN0b20gUHJvcGVydGllc1xuXG5UbyBhZGQgZG9jdW1lbnQtbGV2ZWwgc3R5bGVzIHRvIFNoYWR5Q1NTLCBvbmUgY2FuIGNhbGwgYFNoYWR5Q1NTLmFkZERvY3VtZW50U3R5bGUoc3R5bGVFbGVtZW50KWAgb3IgYFNoYWR5Q1NTLmFkZERvY3VtZW50U3R5bGUoe2dldFN0eWxlOiAoKSA9PiBzdHlsZUVsZW1lbnR9KWBcblxuSW4gYWRkaXRpb24sIGlmIHRoZSBwcm9jZXNzIHVzZWQgdG8gZGlzY292ZXIgZG9jdW1lbnQtbGV2ZWwgc3R5bGVzIGNhbiBiZSBzeW5jaHJvbm91c2x5IGZsdXNoZWQsIG9uZSBzaG91bGQgc2V0IGBTaGFkeUNTUy5kb2N1bWVudFN0eWxlRmx1c2hgLlxuVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuIGNhbGN1bGF0aW5nIHN0eWxlcy5cblxuQW4gZXhhbXBsZSB1c2FnZSBvZiB0aGUgZG9jdW1lbnQtbGV2ZWwgc3R5bGluZyBhcGkgY2FuIGJlIGZvdW5kIGluIGBleGFtcGxlcy9kb2N1bWVudC1zdHlsZS1saWIuanNgXG5cbkB1bnJlc3RyaWN0ZWRcbiovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21TdHlsZUludGVyZmFjZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7IUFycmF5PCFDdXN0b21TdHlsZVByb3ZpZGVyPn0gKi9cbiAgICB0aGlzWydjdXN0b21TdHlsZXMnXSA9IFtdO1xuICAgIHRoaXNbJ2VucXVldWVkJ10gPSBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogUXVldWUgYSB2YWxpZGF0aW9uIGZvciBuZXcgY3VzdG9tIHN0eWxlcyB0byBiYXRjaCBzdHlsZSByZWNhbGN1bGF0aW9uc1xuICAgKi9cbiAgZW5xdWV1ZURvY3VtZW50VmFsaWRhdGlvbigpIHtcbiAgICBpZiAodGhpc1snZW5xdWV1ZWQnXSB8fCAhdmFsaWRhdGVGbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzWydlbnF1ZXVlZCddID0gdHJ1ZTtcbiAgICBkb2N1bWVudFdhaXQodmFsaWRhdGVGbik7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gICAqL1xuICBhZGRDdXN0b21TdHlsZShzdHlsZSkge1xuICAgIGlmICghc3R5bGVbU0VFTl9NQVJLRVJdKSB7XG4gICAgICBzdHlsZVtTRUVOX01BUktFUl0gPSB0cnVlO1xuICAgICAgdGhpc1snY3VzdG9tU3R5bGVzJ10ucHVzaChzdHlsZSk7XG4gICAgICB0aGlzLmVucXVldWVEb2N1bWVudFZhbGlkYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUN1c3RvbVN0eWxlUHJvdmlkZXJ9IGN1c3RvbVN0eWxlXG4gICAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9XG4gICAqL1xuICBnZXRTdHlsZUZvckN1c3RvbVN0eWxlKGN1c3RvbVN0eWxlKSB7XG4gICAgaWYgKGN1c3RvbVN0eWxlW0NBQ0hFRF9TVFlMRV0pIHtcbiAgICAgIHJldHVybiBjdXN0b21TdHlsZVtDQUNIRURfU1RZTEVdO1xuICAgIH1cbiAgICBsZXQgc3R5bGU7XG4gICAgaWYgKGN1c3RvbVN0eWxlWydnZXRTdHlsZSddKSB7XG4gICAgICBzdHlsZSA9IGN1c3RvbVN0eWxlWydnZXRTdHlsZSddKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlID0gY3VzdG9tU3R5bGU7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybiB7IUFycmF5PCFDdXN0b21TdHlsZVByb3ZpZGVyPn1cbiAgICovXG4gIHByb2Nlc3NTdHlsZXMoKSB7XG4gICAgY29uc3QgY3MgPSB0aGlzWydjdXN0b21TdHlsZXMnXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXN0b21TdHlsZSA9IGNzW2ldO1xuICAgICAgaWYgKGN1c3RvbVN0eWxlW0NBQ0hFRF9TVFlMRV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHlsZSA9IHRoaXMuZ2V0U3R5bGVGb3JDdXN0b21TdHlsZShjdXN0b21TdHlsZSk7XG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgLy8gSFRNTEltcG9ydHMgcG9seWZpbGwgbWF5IGhhdmUgY2xvbmVkIHRoZSBzdHlsZSBpbnRvIHRoZSBtYWluIGRvY3VtZW50LFxuICAgICAgICAvLyB3aGljaCBpcyByZWZlcmVuY2VkIHdpdGggX19hcHBsaWVkRWxlbWVudC5cbiAgICAgICAgY29uc3Qgc3R5bGVUb1RyYW5zZm9ybSA9IC8qKiBAdHlwZSB7IUhUTUxTdHlsZUVsZW1lbnR9ICovKHN0eWxlWydfX2FwcGxpZWRFbGVtZW50J10gfHwgc3R5bGUpO1xuICAgICAgICBpZiAodHJhbnNmb3JtRm4pIHtcbiAgICAgICAgICB0cmFuc2Zvcm1GbihzdHlsZVRvVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXN0b21TdHlsZVtDQUNIRURfU1RZTEVdID0gc3R5bGVUb1RyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNzO1xuICB9XG59XG5cbkN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZVsnYWRkQ3VzdG9tU3R5bGUnXSA9IEN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZS5hZGRDdXN0b21TdHlsZTtcbkN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZVsnZ2V0U3R5bGVGb3JDdXN0b21TdHlsZSddID0gQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlLmdldFN0eWxlRm9yQ3VzdG9tU3R5bGU7XG5DdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGVbJ3Byb2Nlc3NTdHlsZXMnXSA9IEN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZS5wcm9jZXNzU3R5bGVzO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhDdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGUsIHtcbiAgJ3RyYW5zZm9ybUNhbGxiYWNrJzoge1xuICAgIC8qKiBAcmV0dXJuIHs/ZnVuY3Rpb24oIUhUTUxTdHlsZUVsZW1lbnQpfSAqL1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1GbjtcbiAgICB9LFxuICAgIC8qKiBAcGFyYW0gez9mdW5jdGlvbighSFRNTFN0eWxlRWxlbWVudCl9IGZuICovXG4gICAgc2V0KGZuKSB7XG4gICAgICB0cmFuc2Zvcm1GbiA9IGZuO1xuICAgIH1cbiAgfSxcbiAgJ3ZhbGlkYXRlQ2FsbGJhY2snOiB7XG4gICAgLyoqIEByZXR1cm4gez9mdW5jdGlvbigpfSAqL1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB2YWxpZGF0ZUZuO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHs/ZnVuY3Rpb24oKX0gZm5cbiAgICAgKiBAdGhpcyB7Q3VzdG9tU3R5bGVJbnRlcmZhY2V9XG4gICAgICovXG4gICAgc2V0KGZuKSB7XG4gICAgICBsZXQgbmVlZHNFbnF1ZXVlID0gZmFsc2U7XG4gICAgICBpZiAoIXZhbGlkYXRlRm4pIHtcbiAgICAgICAgbmVlZHNFbnF1ZXVlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHZhbGlkYXRlRm4gPSBmbjtcbiAgICAgIGlmIChuZWVkc0VucXVldWUpIHtcbiAgICAgICAgdGhpcy5lbnF1ZXVlRG9jdW1lbnRWYWxpZGF0aW9uKCk7XG4gICAgICB9XG4gICAgfSxcbiAgfVxufSlcblxuLyoqIEB0eXBlZGVmIHt7XG4gKiBjdXN0b21TdHlsZXM6ICFBcnJheTwhQ3VzdG9tU3R5bGVQcm92aWRlcj4sXG4gKiBhZGRDdXN0b21TdHlsZTogZnVuY3Rpb24oIUN1c3RvbVN0eWxlUHJvdmlkZXIpLFxuICogZ2V0U3R5bGVGb3JDdXN0b21TdHlsZTogZnVuY3Rpb24oIUN1c3RvbVN0eWxlUHJvdmlkZXIpOiBIVE1MU3R5bGVFbGVtZW50LFxuICogZmluZFN0eWxlczogZnVuY3Rpb24oKSxcbiAqIHRyYW5zZm9ybUNhbGxiYWNrOiA/ZnVuY3Rpb24oIUhUTUxTdHlsZUVsZW1lbnQpLFxuICogdmFsaWRhdGVDYWxsYmFjazogP2Z1bmN0aW9uKClcbiAqIH19XG4gKi9cbmV4cG9ydCBsZXQgQ3VzdG9tU3R5bGVJbnRlcmZhY2VJbnRlcmZhY2U7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gNDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgKiBhcyBnZXN0dXJlcyQwIGZyb20gJy4uL3V0aWxzL2dlc3R1cmVzLmpzJztcblxuLyoqXG4gKiBAY29uc3Qge1BvbHltZXIuR2VzdHVyZXN9XG4gKi9cbmNvbnN0IGdlc3R1cmVzID0gZ2VzdHVyZXMkMDtcblxuZXhwb3J0IGNvbnN0IEdlc3R1cmVFdmVudExpc3RlbmVycyA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0dlc3R1cmVFdmVudExpc3RlbmVyc31cbiAgICovXG4gIGNsYXNzIEdlc3R1cmVFdmVudExpc3RlbmVycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKSB7XG4gICAgICBpZiAoIWdlc3R1cmVzLmFkZExpc3RlbmVyKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikpIHtcbiAgICAgICAgc3VwZXIuX2FkZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgaWYgKCFnZXN0dXJlcy5yZW1vdmVMaXN0ZW5lcihub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpKSB7XG4gICAgICAgIHN1cGVyLl9yZW1vdmVFdmVudExpc3RlbmVyRnJvbU5vZGUobm9kZSwgZXZlbnROYW1lLCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfVxuXG4gIHJldHVybiBHZXN0dXJlRXZlbnRMaXN0ZW5lcnM7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL2dlc3R1cmUtZXZlbnQtbGlzdGVuZXJzLmpzXG4vLyBtb2R1bGUgaWQgPSA0MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbmZ1bmN0aW9uIG5ld1NwbGljZShpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudCkge1xuICByZXR1cm4ge1xuICAgIGluZGV4OiBpbmRleCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnRcbiAgfTtcbn1cblxuY29uc3QgRURJVF9MRUFWRSA9IDA7XG5jb25zdCBFRElUX1VQREFURSA9IDE7XG5jb25zdCBFRElUX0FERCA9IDI7XG5jb25zdCBFRElUX0RFTEVURSA9IDM7XG5cbi8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgKmJhc2VkKiBvbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIExldmVuc2h0ZWluXG4vLyBcImVkaXRcIiBkaXN0YW5jZS4gVGhlIG9uZSBjaGFuZ2UgaXMgdGhhdCBcInVwZGF0ZXNcIiBhcmUgdHJlYXRlZCBhcyB0d29cbi8vIGVkaXRzIC0gbm90IG9uZS4gV2l0aCBBcnJheSBzcGxpY2VzLCBhbiB1cGRhdGUgaXMgcmVhbGx5IGEgZGVsZXRlXG4vLyBmb2xsb3dlZCBieSBhbiBhZGQuIEJ5IHJldGFpbmluZyB0aGlzLCB3ZSBvcHRpbWl6ZSBmb3IgXCJrZWVwaW5nXCIgdGhlXG4vLyBtYXhpbXVtIGFycmF5IGl0ZW1zIGluIHRoZSBvcmlnaW5hbCBhcnJheS4gRm9yIGV4YW1wbGU6XG4vL1xuLy8gICAneHh4eDEyMycgLT4gJzEyM3l5eXknXG4vL1xuLy8gV2l0aCAxLWVkaXQgdXBkYXRlcywgdGhlIHNob3J0ZXN0IHBhdGggd291bGQgYmUganVzdCB0byB1cGRhdGUgYWxsIHNldmVuXG4vLyBjaGFyYWN0ZXJzLiBXaXRoIDItZWRpdCB1cGRhdGVzLCB3ZSBkZWxldGUgNCwgbGVhdmUgMywgYW5kIGFkZCA0LiBUaGlzXG4vLyBsZWF2ZXMgdGhlIHN1YnN0cmluZyAnMTIzJyBpbnRhY3QuXG5mdW5jdGlvbiBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gIC8vIFwiRGVsZXRpb25cIiBjb2x1bW5zXG4gIGxldCByb3dDb3VudCA9IG9sZEVuZCAtIG9sZFN0YXJ0ICsgMTtcbiAgbGV0IGNvbHVtbkNvdW50ID0gY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCArIDE7XG4gIGxldCBkaXN0YW5jZXMgPSBuZXcgQXJyYXkocm93Q291bnQpO1xuXG4gIC8vIFwiQWRkaXRpb25cIiByb3dzLiBJbml0aWFsaXplIG51bGwgY29sdW1uLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBkaXN0YW5jZXNbaV0gPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpO1xuICAgIGRpc3RhbmNlc1tpXVswXSA9IGk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIG51bGwgcm93XG4gIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uQ291bnQ7IGorKylcbiAgICBkaXN0YW5jZXNbMF1bal0gPSBqO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDwgY29sdW1uQ291bnQ7IGorKykge1xuICAgICAgaWYgKGVxdWFscyhjdXJyZW50W2N1cnJlbnRTdGFydCArIGogLSAxXSwgb2xkW29sZFN0YXJ0ICsgaSAtIDFdKSlcbiAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IG5vcnRoID0gZGlzdGFuY2VzW2kgLSAxXVtqXSArIDE7XG4gICAgICAgIGxldCB3ZXN0ID0gZGlzdGFuY2VzW2ldW2ogLSAxXSArIDE7XG4gICAgICAgIGRpc3RhbmNlc1tpXVtqXSA9IG5vcnRoIDwgd2VzdCA/IG5vcnRoIDogd2VzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzdGFuY2VzO1xufVxuXG4vLyBUaGlzIHN0YXJ0cyBhdCB0aGUgZmluYWwgd2VpZ2h0LCBhbmQgd2Fsa3MgXCJiYWNrd2FyZFwiIGJ5IGZpbmRpbmdcbi8vIHRoZSBtaW5pbXVtIHByZXZpb3VzIHdlaWdodCByZWN1cnNpdmVseSB1bnRpbCB0aGUgb3JpZ2luIG9mIHRoZSB3ZWlnaHRcbi8vIG1hdHJpeC5cbmZ1bmN0aW9uIHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhkaXN0YW5jZXMpIHtcbiAgbGV0IGkgPSBkaXN0YW5jZXMubGVuZ3RoIC0gMTtcbiAgbGV0IGogPSBkaXN0YW5jZXNbMF0ubGVuZ3RoIC0gMTtcbiAgbGV0IGN1cnJlbnQgPSBkaXN0YW5jZXNbaV1bal07XG4gIGxldCBlZGl0cyA9IFtdO1xuICB3aGlsZSAoaSA+IDAgfHwgaiA+IDApIHtcbiAgICBpZiAoaSA9PSAwKSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgIGotLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaiA9PSAwKSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgIGktLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgbm9ydGhXZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgbGV0IHdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2pdO1xuICAgIGxldCBub3J0aCA9IGRpc3RhbmNlc1tpXVtqIC0gMV07XG5cbiAgICBsZXQgbWluO1xuICAgIGlmICh3ZXN0IDwgbm9ydGgpXG4gICAgICBtaW4gPSB3ZXN0IDwgbm9ydGhXZXN0ID8gd2VzdCA6IG5vcnRoV2VzdDtcbiAgICBlbHNlXG4gICAgICBtaW4gPSBub3J0aCA8IG5vcnRoV2VzdCA/IG5vcnRoIDogbm9ydGhXZXN0O1xuXG4gICAgaWYgKG1pbiA9PSBub3J0aFdlc3QpIHtcbiAgICAgIGlmIChub3J0aFdlc3QgPT0gY3VycmVudCkge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfTEVBVkUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX1VQREFURSk7XG4gICAgICAgIGN1cnJlbnQgPSBub3J0aFdlc3Q7XG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBqLS07XG4gICAgfSBlbHNlIGlmIChtaW4gPT0gd2VzdCkge1xuICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICBpLS07XG4gICAgICBjdXJyZW50ID0gd2VzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG4gICAgICBqLS07XG4gICAgICBjdXJyZW50ID0gbm9ydGg7XG4gICAgfVxuICB9XG5cbiAgZWRpdHMucmV2ZXJzZSgpO1xuICByZXR1cm4gZWRpdHM7XG59XG5cbi8qKlxuICogU3BsaWNlIFByb2plY3Rpb24gZnVuY3Rpb25zOlxuICpcbiAqIEEgc3BsaWNlIG1hcCBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIGhvdyBhIHByZXZpb3VzIGFycmF5IG9mIGl0ZW1zXG4gKiB3YXMgdHJhbnNmb3JtZWQgaW50byBhIG5ldyBhcnJheSBvZiBpdGVtcy4gQ29uY2VwdHVhbGx5IGl0IGlzIGEgbGlzdCBvZlxuICogdHVwbGVzIG9mXG4gKlxuICogICA8aW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQ+XG4gKlxuICogd2hpY2ggYXJlIGtlcHQgaW4gYXNjZW5kaW5nIGluZGV4IG9yZGVyIG9mLiBUaGUgdHVwbGUgcmVwcmVzZW50cyB0aGF0IGF0XG4gKiB0aGUgfGluZGV4fCwgfHJlbW92ZWR8IHNlcXVlbmNlIG9mIGl0ZW1zIHdlcmUgcmVtb3ZlZCwgYW5kIGNvdW50aW5nIGZvcndhcmRcbiAqIGZyb20gfGluZGV4fCwgfGFkZGVkQ291bnR8IGl0ZW1zIHdlcmUgYWRkZWQuXG4gKi9cblxuLyoqXG4gKiBMYWNraW5nIGluZGl2aWR1YWwgc3BsaWNlIG11dGF0aW9uIGluZm9ybWF0aW9uLCB0aGUgbWluaW1hbCBzZXQgb2ZcbiAqIHNwbGljZXMgY2FuIGJlIHN5bnRoZXNpemVkIGdpdmVuIHRoZSBwcmV2aW91cyBzdGF0ZSBhbmQgZmluYWwgc3RhdGUgb2YgYW5cbiAqIGFycmF5LiBUaGUgYmFzaWMgYXBwcm9hY2ggaXMgdG8gY2FsY3VsYXRlIHRoZSBlZGl0IGRpc3RhbmNlIG1hdHJpeCBhbmRcbiAqIGNob29zZSB0aGUgc2hvcnRlc3QgcGF0aCB0aHJvdWdoIGl0LlxuICpcbiAqIENvbXBsZXhpdHk6IE8obCAqIHApXG4gKiAgIGw6IFRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgYXJyYXlcbiAqICAgcDogVGhlIGxlbmd0aCBvZiB0aGUgb2xkIGFycmF5XG4gKlxuICogQHBhcmFtIHtBcnJheX0gY3VycmVudCBUaGUgY3VycmVudCBcImNoYW5nZWRcIiBhcnJheSBmb3Igd2hpY2ggdG9cbiAqIGNhbGN1bGF0ZSBzcGxpY2VzLlxuICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRTdGFydCBTdGFydGluZyBpbmRleCBpbiB0aGUgYGN1cnJlbnRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50RW5kIEVuZGluZyBpbmRleCBpbiB0aGUgYGN1cnJlbnRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEBwYXJhbSB7QXJyYXl9IG9sZCBUaGUgb3JpZ2luYWwgXCJ1bmNoYW5nZWRcIiBhcnJheSB0byBjb21wYXJlIGBjdXJyZW50YFxuICogYWdhaW5zdCB0byBkZXRlcm1pbmUgc3BsaWNlcy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvbGRTdGFydCBTdGFydGluZyBpbmRleCBpbiB0aGUgYG9sZGAgYXJyYXkgZm9yXG4gKiB3aGljaCBzcGxpY2VzIGFyZSBjYWxjdWxhdGVkLlxuICogQHBhcmFtIHtudW1iZXJ9IG9sZEVuZCBFbmRpbmcgaW5kZXggaW4gdGhlIGBvbGRgIGFycmF5IGZvclxuICogd2hpY2ggc3BsaWNlcyBhcmUgY2FsY3VsYXRlZC5cbiAqIEByZXR1cm4ge0FycmF5fSBSZXR1cm5zIGFuIGFycmF5IG9mIHNwbGljZSByZWNvcmQgb2JqZWN0cy4gRWFjaCBvZiB0aGVzZVxuICogY29udGFpbnM6IGBpbmRleGAgdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBzcGxpY2Ugb2NjdXJyZWQ7IGByZW1vdmVkYFxuICogdGhlIGFycmF5IG9mIHJlbW92ZWQgaXRlbXMgZnJvbSB0aGlzIGxvY2F0aW9uOyBgYWRkZWRDb3VudGAgdGhlIG51bWJlclxuICogb2YgaXRlbXMgYWRkZWQgYXQgdGhpcyBsb2NhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY2FsY1NwbGljZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkge1xuICBsZXQgcHJlZml4Q291bnQgPSAwO1xuICBsZXQgc3VmZml4Q291bnQgPSAwO1xuICBsZXQgc3BsaWNlO1xuXG4gIGxldCBtaW5MZW5ndGggPSBNYXRoLm1pbihjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0LCBvbGRFbmQgLSBvbGRTdGFydCk7XG4gIGlmIChjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRTdGFydCA9PSAwKVxuICAgIHByZWZpeENvdW50ID0gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgbWluTGVuZ3RoKTtcblxuICBpZiAoY3VycmVudEVuZCA9PSBjdXJyZW50Lmxlbmd0aCAmJiBvbGRFbmQgPT0gb2xkLmxlbmd0aClcbiAgICBzdWZmaXhDb3VudCA9IHNoYXJlZFN1ZmZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCAtIHByZWZpeENvdW50KTtcblxuICBjdXJyZW50U3RhcnQgKz0gcHJlZml4Q291bnQ7XG4gIG9sZFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICBjdXJyZW50RW5kIC09IHN1ZmZpeENvdW50O1xuICBvbGRFbmQgLT0gc3VmZml4Q291bnQ7XG5cbiAgaWYgKGN1cnJlbnRFbmQgLSBjdXJyZW50U3RhcnQgPT0gMCAmJiBvbGRFbmQgLSBvbGRTdGFydCA9PSAwKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAoY3VycmVudFN0YXJ0ID09IGN1cnJlbnRFbmQpIHtcbiAgICBzcGxpY2UgPSBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgMCk7XG4gICAgd2hpbGUgKG9sZFN0YXJ0IDwgb2xkRW5kKVxuICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkU3RhcnQrK10pO1xuXG4gICAgcmV0dXJuIFsgc3BsaWNlIF07XG4gIH0gZWxzZSBpZiAob2xkU3RhcnQgPT0gb2xkRW5kKVxuICAgIHJldHVybiBbIG5ld1NwbGljZShjdXJyZW50U3RhcnQsIFtdLCBjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0KSBdO1xuXG4gIGxldCBvcHMgPSBzcGxpY2VPcGVyYXRpb25zRnJvbUVkaXREaXN0YW5jZXMoXG4gICAgICBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZCwgb2xkU3RhcnQsIG9sZEVuZCkpO1xuXG4gIHNwbGljZSA9IHVuZGVmaW5lZDtcbiAgbGV0IHNwbGljZXMgPSBbXTtcbiAgbGV0IGluZGV4ID0gY3VycmVudFN0YXJ0O1xuICBsZXQgb2xkSW5kZXggPSBvbGRTdGFydDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBvcHMubGVuZ3RoOyBpKyspIHtcbiAgICBzd2l0Y2gob3BzW2ldKSB7XG4gICAgICBjYXNlIEVESVRfTEVBVkU6XG4gICAgICAgIGlmIChzcGxpY2UpIHtcbiAgICAgICAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgICAgICAgICBzcGxpY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRURJVF9VUERBVEU6XG4gICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgIHNwbGljZS5hZGRlZENvdW50Kys7XG4gICAgICAgIGluZGV4Kys7XG5cbiAgICAgICAgc3BsaWNlLnJlbW92ZWQucHVzaChvbGRbb2xkSW5kZXhdKTtcbiAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVESVRfQUREOlxuICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRURJVF9ERUxFVEU6XG4gICAgICAgIGlmICghc3BsaWNlKVxuICAgICAgICAgIHNwbGljZSA9IG5ld1NwbGljZShpbmRleCwgW10sIDApO1xuXG4gICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzcGxpY2UpIHtcbiAgICBzcGxpY2VzLnB1c2goc3BsaWNlKTtcbiAgfVxuICByZXR1cm4gc3BsaWNlcztcbn1cblxuZnVuY3Rpb24gc2hhcmVkUHJlZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VhcmNoTGVuZ3RoOyBpKyspXG4gICAgaWYgKCFlcXVhbHMoY3VycmVudFtpXSwgb2xkW2ldKSlcbiAgICAgIHJldHVybiBpO1xuICByZXR1cm4gc2VhcmNoTGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBzZWFyY2hMZW5ndGgpIHtcbiAgbGV0IGluZGV4MSA9IGN1cnJlbnQubGVuZ3RoO1xuICBsZXQgaW5kZXgyID0gb2xkLmxlbmd0aDtcbiAgbGV0IGNvdW50ID0gMDtcbiAgd2hpbGUgKGNvdW50IDwgc2VhcmNoTGVuZ3RoICYmIGVxdWFscyhjdXJyZW50Wy0taW5kZXgxXSwgb2xkWy0taW5kZXgyXSkpXG4gICAgY291bnQrKztcblxuICByZXR1cm4gY291bnQ7XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVNwbGljZXMoY3VycmVudCwgcHJldmlvdXMpIHtcbiAgcmV0dXJuIGNhbGNTcGxpY2VzKGN1cnJlbnQsIDAsIGN1cnJlbnQubGVuZ3RoLCBwcmV2aW91cywgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcHJldmlvdXMubGVuZ3RoKTtcbn1cblxuZnVuY3Rpb24gZXF1YWxzKGN1cnJlbnRWYWx1ZSwgcHJldmlvdXNWYWx1ZSkge1xuICByZXR1cm4gY3VycmVudFZhbHVlID09PSBwcmV2aW91c1ZhbHVlO1xufVxuXG5leHBvcnQgeyBjYWxjdWxhdGVTcGxpY2VzIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi91dGlscy9hcnJheS1zcGxpY2UuanNcbi8vIG1vZHVsZSBpZCA9IDQyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8Y3VzdG9tLXN0eWxlPlxuICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICBodG1sIHtcblxuICAgICAgLyogTWF0ZXJpYWwgRGVzaWduIGNvbG9yIHBhbGV0dGUgZm9yIEdvb2dsZSBwcm9kdWN0cyAqL1xuXG4gICAgICAtLWdvb2dsZS1yZWQtMTAwOiAjZjRjN2MzO1xuICAgICAgLS1nb29nbGUtcmVkLTMwMDogI2U2N2M3MztcbiAgICAgIC0tZ29vZ2xlLXJlZC01MDA6ICNkYjQ0Mzc7XG4gICAgICAtLWdvb2dsZS1yZWQtNzAwOiAjYzUzOTI5O1xuXG4gICAgICAtLWdvb2dsZS1ibHVlLTEwMDogI2M2ZGFmYztcbiAgICAgIC0tZ29vZ2xlLWJsdWUtMzAwOiAjN2JhYWY3O1xuICAgICAgLS1nb29nbGUtYmx1ZS01MDA6ICM0Mjg1ZjQ7XG4gICAgICAtLWdvb2dsZS1ibHVlLTcwMDogIzMzNjdkNjtcblxuICAgICAgLS1nb29nbGUtZ3JlZW4tMTAwOiAjYjdlMWNkO1xuICAgICAgLS1nb29nbGUtZ3JlZW4tMzAwOiAjNTdiYjhhO1xuICAgICAgLS1nb29nbGUtZ3JlZW4tNTAwOiAjMGY5ZDU4O1xuICAgICAgLS1nb29nbGUtZ3JlZW4tNzAwOiAjMGI4MDQzO1xuXG4gICAgICAtLWdvb2dsZS15ZWxsb3ctMTAwOiAjZmNlOGIyO1xuICAgICAgLS1nb29nbGUteWVsbG93LTMwMDogI2Y3Y2I0ZDtcbiAgICAgIC0tZ29vZ2xlLXllbGxvdy01MDA6ICNmNGI0MDA7XG4gICAgICAtLWdvb2dsZS15ZWxsb3ctNzAwOiAjZjA5MzAwO1xuXG4gICAgICAtLWdvb2dsZS1ncmV5LTEwMDogI2Y1ZjVmNTtcbiAgICAgIC0tZ29vZ2xlLWdyZXktMzAwOiAjZTBlMGUwO1xuICAgICAgLS1nb29nbGUtZ3JleS01MDA6ICM5ZTllOWU7XG4gICAgICAtLWdvb2dsZS1ncmV5LTcwMDogIzYxNjE2MTtcblxuICAgICAgLyogTWF0ZXJpYWwgRGVzaWduIGNvbG9yIHBhbGV0dGUgZnJvbSBvbmxpbmUgc3BlYyBkb2N1bWVudCAqL1xuXG4gICAgICAtLXBhcGVyLXJlZC01MDogI2ZmZWJlZTtcbiAgICAgIC0tcGFwZXItcmVkLTEwMDogI2ZmY2RkMjtcbiAgICAgIC0tcGFwZXItcmVkLTIwMDogI2VmOWE5YTtcbiAgICAgIC0tcGFwZXItcmVkLTMwMDogI2U1NzM3MztcbiAgICAgIC0tcGFwZXItcmVkLTQwMDogI2VmNTM1MDtcbiAgICAgIC0tcGFwZXItcmVkLTUwMDogI2Y0NDMzNjtcbiAgICAgIC0tcGFwZXItcmVkLTYwMDogI2U1MzkzNTtcbiAgICAgIC0tcGFwZXItcmVkLTcwMDogI2QzMmYyZjtcbiAgICAgIC0tcGFwZXItcmVkLTgwMDogI2M2MjgyODtcbiAgICAgIC0tcGFwZXItcmVkLTkwMDogI2I3MWMxYztcbiAgICAgIC0tcGFwZXItcmVkLWExMDA6ICNmZjhhODA7XG4gICAgICAtLXBhcGVyLXJlZC1hMjAwOiAjZmY1MjUyO1xuICAgICAgLS1wYXBlci1yZWQtYTQwMDogI2ZmMTc0NDtcbiAgICAgIC0tcGFwZXItcmVkLWE3MDA6ICNkNTAwMDA7XG5cbiAgICAgIC0tcGFwZXItcGluay01MDogI2ZjZTRlYztcbiAgICAgIC0tcGFwZXItcGluay0xMDA6ICNmOGJiZDA7XG4gICAgICAtLXBhcGVyLXBpbmstMjAwOiAjZjQ4ZmIxO1xuICAgICAgLS1wYXBlci1waW5rLTMwMDogI2YwNjI5MjtcbiAgICAgIC0tcGFwZXItcGluay00MDA6ICNlYzQwN2E7XG4gICAgICAtLXBhcGVyLXBpbmstNTAwOiAjZTkxZTYzO1xuICAgICAgLS1wYXBlci1waW5rLTYwMDogI2Q4MWI2MDtcbiAgICAgIC0tcGFwZXItcGluay03MDA6ICNjMjE4NWI7XG4gICAgICAtLXBhcGVyLXBpbmstODAwOiAjYWQxNDU3O1xuICAgICAgLS1wYXBlci1waW5rLTkwMDogIzg4MGU0ZjtcbiAgICAgIC0tcGFwZXItcGluay1hMTAwOiAjZmY4MGFiO1xuICAgICAgLS1wYXBlci1waW5rLWEyMDA6ICNmZjQwODE7XG4gICAgICAtLXBhcGVyLXBpbmstYTQwMDogI2Y1MDA1NztcbiAgICAgIC0tcGFwZXItcGluay1hNzAwOiAjYzUxMTYyO1xuXG4gICAgICAtLXBhcGVyLXB1cnBsZS01MDogI2YzZTVmNTtcbiAgICAgIC0tcGFwZXItcHVycGxlLTEwMDogI2UxYmVlNztcbiAgICAgIC0tcGFwZXItcHVycGxlLTIwMDogI2NlOTNkODtcbiAgICAgIC0tcGFwZXItcHVycGxlLTMwMDogI2JhNjhjODtcbiAgICAgIC0tcGFwZXItcHVycGxlLTQwMDogI2FiNDdiYztcbiAgICAgIC0tcGFwZXItcHVycGxlLTUwMDogIzljMjdiMDtcbiAgICAgIC0tcGFwZXItcHVycGxlLTYwMDogIzhlMjRhYTtcbiAgICAgIC0tcGFwZXItcHVycGxlLTcwMDogIzdiMWZhMjtcbiAgICAgIC0tcGFwZXItcHVycGxlLTgwMDogIzZhMWI5YTtcbiAgICAgIC0tcGFwZXItcHVycGxlLTkwMDogIzRhMTQ4YztcbiAgICAgIC0tcGFwZXItcHVycGxlLWExMDA6ICNlYTgwZmM7XG4gICAgICAtLXBhcGVyLXB1cnBsZS1hMjAwOiAjZTA0MGZiO1xuICAgICAgLS1wYXBlci1wdXJwbGUtYTQwMDogI2Q1MDBmOTtcbiAgICAgIC0tcGFwZXItcHVycGxlLWE3MDA6ICNhYTAwZmY7XG5cbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNTA6ICNlZGU3ZjY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTEwMDogI2QxYzRlOTtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtMjAwOiAjYjM5ZGRiO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS0zMDA6ICM5NTc1Y2Q7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTQwMDogIzdlNTdjMjtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtNTAwOiAjNjczYWI3O1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS02MDA6ICM1ZTM1YjE7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLTcwMDogIzUxMmRhODtcbiAgICAgIC0tcGFwZXItZGVlcC1wdXJwbGUtODAwOiAjNDUyN2EwO1xuICAgICAgLS1wYXBlci1kZWVwLXB1cnBsZS05MDA6ICMzMTFiOTI7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWExMDA6ICNiMzg4ZmY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWEyMDA6ICM3YzRkZmY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWE0MDA6ICM2NTFmZmY7XG4gICAgICAtLXBhcGVyLWRlZXAtcHVycGxlLWE3MDA6ICM2MjAwZWE7XG5cbiAgICAgIC0tcGFwZXItaW5kaWdvLTUwOiAjZThlYWY2O1xuICAgICAgLS1wYXBlci1pbmRpZ28tMTAwOiAjYzVjYWU5O1xuICAgICAgLS1wYXBlci1pbmRpZ28tMjAwOiAjOWZhOGRhO1xuICAgICAgLS1wYXBlci1pbmRpZ28tMzAwOiAjNzk4NmNiO1xuICAgICAgLS1wYXBlci1pbmRpZ28tNDAwOiAjNWM2YmMwO1xuICAgICAgLS1wYXBlci1pbmRpZ28tNTAwOiAjM2Y1MWI1O1xuICAgICAgLS1wYXBlci1pbmRpZ28tNjAwOiAjMzk0OWFiO1xuICAgICAgLS1wYXBlci1pbmRpZ28tNzAwOiAjMzAzZjlmO1xuICAgICAgLS1wYXBlci1pbmRpZ28tODAwOiAjMjgzNTkzO1xuICAgICAgLS1wYXBlci1pbmRpZ28tOTAwOiAjMWEyMzdlO1xuICAgICAgLS1wYXBlci1pbmRpZ28tYTEwMDogIzhjOWVmZjtcbiAgICAgIC0tcGFwZXItaW5kaWdvLWEyMDA6ICM1MzZkZmU7XG4gICAgICAtLXBhcGVyLWluZGlnby1hNDAwOiAjM2Q1YWZlO1xuICAgICAgLS1wYXBlci1pbmRpZ28tYTcwMDogIzMwNGZmZTtcblxuICAgICAgLS1wYXBlci1ibHVlLTUwOiAjZTNmMmZkO1xuICAgICAgLS1wYXBlci1ibHVlLTEwMDogI2JiZGVmYjtcbiAgICAgIC0tcGFwZXItYmx1ZS0yMDA6ICM5MGNhZjk7XG4gICAgICAtLXBhcGVyLWJsdWUtMzAwOiAjNjRiNWY2O1xuICAgICAgLS1wYXBlci1ibHVlLTQwMDogIzQyYTVmNTtcbiAgICAgIC0tcGFwZXItYmx1ZS01MDA6ICMyMTk2ZjM7XG4gICAgICAtLXBhcGVyLWJsdWUtNjAwOiAjMWU4OGU1O1xuICAgICAgLS1wYXBlci1ibHVlLTcwMDogIzE5NzZkMjtcbiAgICAgIC0tcGFwZXItYmx1ZS04MDA6ICMxNTY1YzA7XG4gICAgICAtLXBhcGVyLWJsdWUtOTAwOiAjMGQ0N2ExO1xuICAgICAgLS1wYXBlci1ibHVlLWExMDA6ICM4MmIxZmY7XG4gICAgICAtLXBhcGVyLWJsdWUtYTIwMDogIzQ0OGFmZjtcbiAgICAgIC0tcGFwZXItYmx1ZS1hNDAwOiAjMjk3OWZmO1xuICAgICAgLS1wYXBlci1ibHVlLWE3MDA6ICMyOTYyZmY7XG5cbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS01MDogI2UxZjVmZTtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS0xMDA6ICNiM2U1ZmM7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtMjAwOiAjODFkNGZhO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTMwMDogIzRmYzNmNztcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS00MDA6ICMyOWI2ZjY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtNTAwOiAjMDNhOWY0O1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTYwMDogIzAzOWJlNTtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS03MDA6ICMwMjg4ZDE7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtODAwOiAjMDI3N2JkO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLTkwMDogIzAxNTc5YjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS1hMTAwOiAjODBkOGZmO1xuICAgICAgLS1wYXBlci1saWdodC1ibHVlLWEyMDA6ICM0MGM0ZmY7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWJsdWUtYTQwMDogIzAwYjBmZjtcbiAgICAgIC0tcGFwZXItbGlnaHQtYmx1ZS1hNzAwOiAjMDA5MWVhO1xuXG4gICAgICAtLXBhcGVyLWN5YW4tNTA6ICNlMGY3ZmE7XG4gICAgICAtLXBhcGVyLWN5YW4tMTAwOiAjYjJlYmYyO1xuICAgICAgLS1wYXBlci1jeWFuLTIwMDogIzgwZGVlYTtcbiAgICAgIC0tcGFwZXItY3lhbi0zMDA6ICM0ZGQwZTE7XG4gICAgICAtLXBhcGVyLWN5YW4tNDAwOiAjMjZjNmRhO1xuICAgICAgLS1wYXBlci1jeWFuLTUwMDogIzAwYmNkNDtcbiAgICAgIC0tcGFwZXItY3lhbi02MDA6ICMwMGFjYzE7XG4gICAgICAtLXBhcGVyLWN5YW4tNzAwOiAjMDA5N2E3O1xuICAgICAgLS1wYXBlci1jeWFuLTgwMDogIzAwODM4ZjtcbiAgICAgIC0tcGFwZXItY3lhbi05MDA6ICMwMDYwNjQ7XG4gICAgICAtLXBhcGVyLWN5YW4tYTEwMDogIzg0ZmZmZjtcbiAgICAgIC0tcGFwZXItY3lhbi1hMjAwOiAjMThmZmZmO1xuICAgICAgLS1wYXBlci1jeWFuLWE0MDA6ICMwMGU1ZmY7XG4gICAgICAtLXBhcGVyLWN5YW4tYTcwMDogIzAwYjhkNDtcblxuICAgICAgLS1wYXBlci10ZWFsLTUwOiAjZTBmMmYxO1xuICAgICAgLS1wYXBlci10ZWFsLTEwMDogI2IyZGZkYjtcbiAgICAgIC0tcGFwZXItdGVhbC0yMDA6ICM4MGNiYzQ7XG4gICAgICAtLXBhcGVyLXRlYWwtMzAwOiAjNGRiNmFjO1xuICAgICAgLS1wYXBlci10ZWFsLTQwMDogIzI2YTY5YTtcbiAgICAgIC0tcGFwZXItdGVhbC01MDA6ICMwMDk2ODg7XG4gICAgICAtLXBhcGVyLXRlYWwtNjAwOiAjMDA4OTdiO1xuICAgICAgLS1wYXBlci10ZWFsLTcwMDogIzAwNzk2YjtcbiAgICAgIC0tcGFwZXItdGVhbC04MDA6ICMwMDY5NWM7XG4gICAgICAtLXBhcGVyLXRlYWwtOTAwOiAjMDA0ZDQwO1xuICAgICAgLS1wYXBlci10ZWFsLWExMDA6ICNhN2ZmZWI7XG4gICAgICAtLXBhcGVyLXRlYWwtYTIwMDogIzY0ZmZkYTtcbiAgICAgIC0tcGFwZXItdGVhbC1hNDAwOiAjMWRlOWI2O1xuICAgICAgLS1wYXBlci10ZWFsLWE3MDA6ICMwMGJmYTU7XG5cbiAgICAgIC0tcGFwZXItZ3JlZW4tNTA6ICNlOGY1ZTk7XG4gICAgICAtLXBhcGVyLWdyZWVuLTEwMDogI2M4ZTZjOTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tMjAwOiAjYTVkNmE3O1xuICAgICAgLS1wYXBlci1ncmVlbi0zMDA6ICM4MWM3ODQ7XG4gICAgICAtLXBhcGVyLWdyZWVuLTQwMDogIzY2YmI2YTtcbiAgICAgIC0tcGFwZXItZ3JlZW4tNTAwOiAjNGNhZjUwO1xuICAgICAgLS1wYXBlci1ncmVlbi02MDA6ICM0M2EwNDc7XG4gICAgICAtLXBhcGVyLWdyZWVuLTcwMDogIzM4OGUzYztcbiAgICAgIC0tcGFwZXItZ3JlZW4tODAwOiAjMmU3ZDMyO1xuICAgICAgLS1wYXBlci1ncmVlbi05MDA6ICMxYjVlMjA7XG4gICAgICAtLXBhcGVyLWdyZWVuLWExMDA6ICNiOWY2Y2E7XG4gICAgICAtLXBhcGVyLWdyZWVuLWEyMDA6ICM2OWYwYWU7XG4gICAgICAtLXBhcGVyLWdyZWVuLWE0MDA6ICMwMGU2NzY7XG4gICAgICAtLXBhcGVyLWdyZWVuLWE3MDA6ICMwMGM4NTM7XG5cbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNTA6ICNmMWY4ZTk7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTEwMDogI2RjZWRjODtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tMjAwOiAjYzVlMWE1O1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi0zMDA6ICNhZWQ1ODE7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTQwMDogIzljY2M2NTtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tNTAwOiAjOGJjMzRhO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi02MDA6ICM3Y2IzNDI7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLTcwMDogIzY4OWYzODtcbiAgICAgIC0tcGFwZXItbGlnaHQtZ3JlZW4tODAwOiAjNTU4YjJmO1xuICAgICAgLS1wYXBlci1saWdodC1ncmVlbi05MDA6ICMzMzY5MWU7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWExMDA6ICNjY2ZmOTA7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWEyMDA6ICNiMmZmNTk7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWE0MDA6ICM3NmZmMDM7XG4gICAgICAtLXBhcGVyLWxpZ2h0LWdyZWVuLWE3MDA6ICM2NGRkMTc7XG5cbiAgICAgIC0tcGFwZXItbGltZS01MDogI2Y5ZmJlNztcbiAgICAgIC0tcGFwZXItbGltZS0xMDA6ICNmMGY0YzM7XG4gICAgICAtLXBhcGVyLWxpbWUtMjAwOiAjZTZlZTljO1xuICAgICAgLS1wYXBlci1saW1lLTMwMDogI2RjZTc3NTtcbiAgICAgIC0tcGFwZXItbGltZS00MDA6ICNkNGUxNTc7XG4gICAgICAtLXBhcGVyLWxpbWUtNTAwOiAjY2RkYzM5O1xuICAgICAgLS1wYXBlci1saW1lLTYwMDogI2MwY2EzMztcbiAgICAgIC0tcGFwZXItbGltZS03MDA6ICNhZmI0MmI7XG4gICAgICAtLXBhcGVyLWxpbWUtODAwOiAjOWU5ZDI0O1xuICAgICAgLS1wYXBlci1saW1lLTkwMDogIzgyNzcxNztcbiAgICAgIC0tcGFwZXItbGltZS1hMTAwOiAjZjRmZjgxO1xuICAgICAgLS1wYXBlci1saW1lLWEyMDA6ICNlZWZmNDE7XG4gICAgICAtLXBhcGVyLWxpbWUtYTQwMDogI2M2ZmYwMDtcbiAgICAgIC0tcGFwZXItbGltZS1hNzAwOiAjYWVlYTAwO1xuXG4gICAgICAtLXBhcGVyLXllbGxvdy01MDogI2ZmZmRlNztcbiAgICAgIC0tcGFwZXIteWVsbG93LTEwMDogI2ZmZjljNDtcbiAgICAgIC0tcGFwZXIteWVsbG93LTIwMDogI2ZmZjU5ZDtcbiAgICAgIC0tcGFwZXIteWVsbG93LTMwMDogI2ZmZjE3NjtcbiAgICAgIC0tcGFwZXIteWVsbG93LTQwMDogI2ZmZWU1ODtcbiAgICAgIC0tcGFwZXIteWVsbG93LTUwMDogI2ZmZWIzYjtcbiAgICAgIC0tcGFwZXIteWVsbG93LTYwMDogI2ZkZDgzNTtcbiAgICAgIC0tcGFwZXIteWVsbG93LTcwMDogI2ZiYzAyZDtcbiAgICAgIC0tcGFwZXIteWVsbG93LTgwMDogI2Y5YTgyNTtcbiAgICAgIC0tcGFwZXIteWVsbG93LTkwMDogI2Y1N2YxNztcbiAgICAgIC0tcGFwZXIteWVsbG93LWExMDA6ICNmZmZmOGQ7XG4gICAgICAtLXBhcGVyLXllbGxvdy1hMjAwOiAjZmZmZjAwO1xuICAgICAgLS1wYXBlci15ZWxsb3ctYTQwMDogI2ZmZWEwMDtcbiAgICAgIC0tcGFwZXIteWVsbG93LWE3MDA6ICNmZmQ2MDA7XG5cbiAgICAgIC0tcGFwZXItYW1iZXItNTA6ICNmZmY4ZTE7XG4gICAgICAtLXBhcGVyLWFtYmVyLTEwMDogI2ZmZWNiMztcbiAgICAgIC0tcGFwZXItYW1iZXItMjAwOiAjZmZlMDgyO1xuICAgICAgLS1wYXBlci1hbWJlci0zMDA6ICNmZmQ1NGY7XG4gICAgICAtLXBhcGVyLWFtYmVyLTQwMDogI2ZmY2EyODtcbiAgICAgIC0tcGFwZXItYW1iZXItNTAwOiAjZmZjMTA3O1xuICAgICAgLS1wYXBlci1hbWJlci02MDA6ICNmZmIzMDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLTcwMDogI2ZmYTAwMDtcbiAgICAgIC0tcGFwZXItYW1iZXItODAwOiAjZmY4ZjAwO1xuICAgICAgLS1wYXBlci1hbWJlci05MDA6ICNmZjZmMDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLWExMDA6ICNmZmU1N2Y7XG4gICAgICAtLXBhcGVyLWFtYmVyLWEyMDA6ICNmZmQ3NDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLWE0MDA6ICNmZmM0MDA7XG4gICAgICAtLXBhcGVyLWFtYmVyLWE3MDA6ICNmZmFiMDA7XG5cbiAgICAgIC0tcGFwZXItb3JhbmdlLTUwOiAjZmZmM2UwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtMTAwOiAjZmZlMGIyO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtMjAwOiAjZmZjYzgwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtMzAwOiAjZmZiNzRkO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNDAwOiAjZmZhNzI2O1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNTAwOiAjZmY5ODAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNjAwOiAjZmI4YzAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtNzAwOiAjZjU3YzAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtODAwOiAjZWY2YzAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtOTAwOiAjZTY1MTAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtYTEwMDogI2ZmZDE4MDtcbiAgICAgIC0tcGFwZXItb3JhbmdlLWEyMDA6ICNmZmFiNDA7XG4gICAgICAtLXBhcGVyLW9yYW5nZS1hNDAwOiAjZmY5MTAwO1xuICAgICAgLS1wYXBlci1vcmFuZ2UtYTcwMDogI2ZmNjUwMDtcblxuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS01MDogI2ZiZTllNztcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtMTAwOiAjZmZjY2JjO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS0yMDA6ICNmZmFiOTE7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTMwMDogI2ZmOGE2NTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtNDAwOiAjZmY3MDQzO1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS01MDA6ICNmZjU3MjI7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTYwMDogI2Y0NTExZTtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtNzAwOiAjZTY0YTE5O1xuICAgICAgLS1wYXBlci1kZWVwLW9yYW5nZS04MDA6ICNkODQzMTU7XG4gICAgICAtLXBhcGVyLWRlZXAtb3JhbmdlLTkwMDogI2JmMzYwYztcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTEwMDogI2ZmOWU4MDtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTIwMDogI2ZmNmU0MDtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTQwMDogI2ZmM2QwMDtcbiAgICAgIC0tcGFwZXItZGVlcC1vcmFuZ2UtYTcwMDogI2RkMmMwMDtcblxuICAgICAgLS1wYXBlci1icm93bi01MDogI2VmZWJlOTtcbiAgICAgIC0tcGFwZXItYnJvd24tMTAwOiAjZDdjY2M4O1xuICAgICAgLS1wYXBlci1icm93bi0yMDA6ICNiY2FhYTQ7XG4gICAgICAtLXBhcGVyLWJyb3duLTMwMDogI2ExODg3ZjtcbiAgICAgIC0tcGFwZXItYnJvd24tNDAwOiAjOGQ2ZTYzO1xuICAgICAgLS1wYXBlci1icm93bi01MDA6ICM3OTU1NDg7XG4gICAgICAtLXBhcGVyLWJyb3duLTYwMDogIzZkNGM0MTtcbiAgICAgIC0tcGFwZXItYnJvd24tNzAwOiAjNWQ0MDM3O1xuICAgICAgLS1wYXBlci1icm93bi04MDA6ICM0ZTM0MmU7XG4gICAgICAtLXBhcGVyLWJyb3duLTkwMDogIzNlMjcyMztcblxuICAgICAgLS1wYXBlci1ncmV5LTUwOiAjZmFmYWZhO1xuICAgICAgLS1wYXBlci1ncmV5LTEwMDogI2Y1ZjVmNTtcbiAgICAgIC0tcGFwZXItZ3JleS0yMDA6ICNlZWVlZWU7XG4gICAgICAtLXBhcGVyLWdyZXktMzAwOiAjZTBlMGUwO1xuICAgICAgLS1wYXBlci1ncmV5LTQwMDogI2JkYmRiZDtcbiAgICAgIC0tcGFwZXItZ3JleS01MDA6ICM5ZTllOWU7XG4gICAgICAtLXBhcGVyLWdyZXktNjAwOiAjNzU3NTc1O1xuICAgICAgLS1wYXBlci1ncmV5LTcwMDogIzYxNjE2MTtcbiAgICAgIC0tcGFwZXItZ3JleS04MDA6ICM0MjQyNDI7XG4gICAgICAtLXBhcGVyLWdyZXktOTAwOiAjMjEyMTIxO1xuXG4gICAgICAtLXBhcGVyLWJsdWUtZ3JleS01MDogI2VjZWZmMTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTEwMDogI2NmZDhkYztcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTIwMDogI2IwYmVjNTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTMwMDogIzkwYTRhZTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTQwMDogIzc4OTA5YztcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTUwMDogIzYwN2Q4YjtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTYwMDogIzU0NmU3YTtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTcwMDogIzQ1NWE2NDtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTgwMDogIzM3NDc0ZjtcbiAgICAgIC0tcGFwZXItYmx1ZS1ncmV5LTkwMDogIzI2MzIzODtcblxuICAgICAgLyogb3BhY2l0eSBmb3IgZGFyayB0ZXh0IG9uIGEgbGlnaHQgYmFja2dyb3VuZCAqL1xuICAgICAgLS1kYXJrLWRpdmlkZXItb3BhY2l0eTogMC4xMjtcbiAgICAgIC0tZGFyay1kaXNhYmxlZC1vcGFjaXR5OiAwLjM4OyAvKiBvciBoaW50IHRleHQgb3IgaWNvbiAqL1xuICAgICAgLS1kYXJrLXNlY29uZGFyeS1vcGFjaXR5OiAwLjU0O1xuICAgICAgLS1kYXJrLXByaW1hcnktb3BhY2l0eTogMC44NztcblxuICAgICAgLyogb3BhY2l0eSBmb3IgbGlnaHQgdGV4dCBvbiBhIGRhcmsgYmFja2dyb3VuZCAqL1xuICAgICAgLS1saWdodC1kaXZpZGVyLW9wYWNpdHk6IDAuMTI7XG4gICAgICAtLWxpZ2h0LWRpc2FibGVkLW9wYWNpdHk6IDAuMzsgLyogb3IgaGludCB0ZXh0IG9yIGljb24gKi9cbiAgICAgIC0tbGlnaHQtc2Vjb25kYXJ5LW9wYWNpdHk6IDAuNztcbiAgICAgIC0tbGlnaHQtcHJpbWFyeS1vcGFjaXR5OiAxLjA7XG5cbiAgICB9XG5cbiAgPC9zdHlsZT5cbjwvY3VzdG9tLXN0eWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvY29sb3IuanNcbi8vIG1vZHVsZSBpZCA9IDQzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8Y3VzdG9tLXN0eWxlPlxuICA8c3R5bGUgaXM9XCJjdXN0b20tc3R5bGVcIj5cbiAgICBodG1sIHtcblxuICAgICAgLS1zaGFkb3ctdHJhbnNpdGlvbjoge1xuICAgICAgICB0cmFuc2l0aW9uOiBib3gtc2hhZG93IDAuMjhzIGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSk7XG4gICAgICB9O1xuXG4gICAgICAtLXNoYWRvdy1ub25lOiB7XG4gICAgICAgIGJveC1zaGFkb3c6IG5vbmU7XG4gICAgICB9O1xuXG4gICAgICAvKiBmcm9tIGh0dHA6Ly9jb2RlcGVuLmlvL3NoeW5kbWFuL3Blbi9jNTM5NGRkZjJlOGIyYTVjOTE4NTkwNGI1NzQyMWNkYiAqL1xuXG4gICAgICAtLXNoYWRvdy1lbGV2YXRpb24tMmRwOiB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDJweCAwIHJnYmEoMCwgMCwgMCwgMC4xNCksXG4gICAgICAgICAgICAgICAgICAgIDAgMXB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksXG4gICAgICAgICAgICAgICAgICAgIDAgM3B4IDFweCAtMnB4IHJnYmEoMCwgMCwgMCwgMC4yKTtcbiAgICAgIH07XG5cbiAgICAgIC0tc2hhZG93LWVsZXZhdGlvbi0zZHA6IHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAzcHggNHB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgMCAxcHggOHB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCAzcHggM3B4IC0ycHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgfTtcblxuICAgICAgLS1zaGFkb3ctZWxldmF0aW9uLTRkcDoge1xuICAgICAgICBib3gtc2hhZG93OiAwIDRweCA1cHggMCByZ2JhKDAsIDAsIDAsIDAuMTQpLFxuICAgICAgICAgICAgICAgICAgICAwIDFweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCAycHggNHB4IC0xcHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgfTtcblxuICAgICAgLS1zaGFkb3ctZWxldmF0aW9uLTZkcDoge1xuICAgICAgICBib3gtc2hhZG93OiAwIDZweCAxMHB4IDAgcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgMCAxcHggMThweCAwIHJnYmEoMCwgMCwgMCwgMC4xMiksXG4gICAgICAgICAgICAgICAgICAgIDAgM3B4IDVweCAtMXB4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAgIH07XG5cbiAgICAgIC0tc2hhZG93LWVsZXZhdGlvbi04ZHA6IHtcbiAgICAgICAgYm94LXNoYWRvdzogMCA4cHggMTBweCAxcHggcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgMCAzcHggMTRweCAycHggcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCA1cHggNXB4IC0zcHggcmdiYSgwLCAwLCAwLCAwLjQpO1xuICAgICAgfTtcblxuICAgICAgLS1zaGFkb3ctZWxldmF0aW9uLTEyZHA6IHtcbiAgICAgICAgYm94LXNoYWRvdzogMCAxMnB4IDE2cHggMXB4IHJnYmEoMCwgMCwgMCwgMC4xNCksXG4gICAgICAgICAgICAgICAgICAgIDAgNHB4IDIycHggM3B4IHJnYmEoMCwgMCwgMCwgMC4xMiksXG4gICAgICAgICAgICAgICAgICAgIDAgNnB4IDdweCAtNHB4IHJnYmEoMCwgMCwgMCwgMC40KTtcbiAgICAgIH07XG5cbiAgICAgIC0tc2hhZG93LWVsZXZhdGlvbi0xNmRwOiB7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMTZweCAyNHB4IDJweCByZ2JhKDAsIDAsIDAsIDAuMTQpLFxuICAgICAgICAgICAgICAgICAgICAwICA2cHggMzBweCA1cHggcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCAgOHB4IDEwcHggLTVweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICB9O1xuXG4gICAgICAtLXNoYWRvdy1lbGV2YXRpb24tMjRkcDoge1xuICAgICAgICBib3gtc2hhZG93OiAwIDI0cHggMzhweCAzcHggcmdiYSgwLCAwLCAwLCAwLjE0KSxcbiAgICAgICAgICAgICAgICAgICAgMCA5cHggNDZweCA4cHggcmdiYSgwLCAwLCAwLCAwLjEyKSxcbiAgICAgICAgICAgICAgICAgICAgMCAxMXB4IDE1cHggLTdweCByZ2JhKDAsIDAsIDAsIDAuNCk7XG4gICAgICB9O1xuICAgIH1cbiAgPC9zdHlsZT5cbjwvY3VzdG9tLXN0eWxlPmA7XG5cbmRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoJF9kb2N1bWVudENvbnRhaW5lcik7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1zdHlsZXMvc2hhZG93LmpzXG4vLyBtb2R1bGUgaWQgPSA0NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBFbGVtZW50IH0gZnJvbSAnLi4vcG9seW1lci9wb2x5bWVyLWVsZW1lbnQuanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IgPSB7XG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWRkZWQgdG8gYW4gYGlyb24tZm9ybWAuXG4gICAgICpcbiAgICAgKiBAZXZlbnQgaXJvbi1mb3JtLWVsZW1lbnQtcmVnaXN0ZXJcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGVsZW1lbnQgaXMgcmVtb3ZlZCBmcm9tIGFuIGBpcm9uLWZvcm1gLlxuICAgICAqXG4gICAgICogQGV2ZW50IGlyb24tZm9ybS1lbGVtZW50LXVucmVnaXN0ZXJcbiAgICAgKi9cbiAgICAgXG4gICAgLyoqXG4gICAgICogVGhlIG5hbWUgb2YgdGhpcyBlbGVtZW50LlxuICAgICAqL1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoaXMgZWxlbWVudC5cbiAgICAgKi9cbiAgICB2YWx1ZToge1xuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIG1hcmsgdGhlIGlucHV0IGFzIHJlcXVpcmVkLiBJZiB1c2VkIGluIGEgZm9ybSwgYVxuICAgICAqIGN1c3RvbSBlbGVtZW50IHRoYXQgdXNlcyB0aGlzIGJlaGF2aW9yIHNob3VsZCBhbHNvIHVzZVxuICAgICAqIFBvbHltZXIuSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IgYW5kIGRlZmluZSBhIGN1c3RvbSB2YWxpZGF0aW9uIG1ldGhvZC5cbiAgICAgKiBPdGhlcndpc2UsIGEgYHJlcXVpcmVkYCBlbGVtZW50IHdpbGwgYWx3YXlzIGJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gICAgICogSXQncyBhbHNvIHN0cm9uZ2x5IHJlY29tbWVuZGVkIHRvIHByb3ZpZGUgYSB2aXN1YWwgc3R5bGUgZm9yIHRoZSBlbGVtZW50XG4gICAgICogd2hlbiBpdHMgdmFsdWUgaXMgaW52YWxpZC5cbiAgICAgKi9cbiAgICByZXF1aXJlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZm9ybSB0aGF0IHRoZSBlbGVtZW50IGlzIHJlZ2lzdGVyZWQgdG8uXG4gICAgICovXG4gICAgX3BhcmVudEZvcm06IHtcbiAgICAgIHR5cGU6IE9iamVjdFxuICAgIH1cbiAgfSxcblxuICBhdHRhY2hlZDogRWxlbWVudCA/IG51bGwgOiBmdW5jdGlvbigpIHtcbiAgICAvLyBOb3RlOiB0aGUgaXJvbi1mb3JtIHRoYXQgdGhpcyBlbGVtZW50IGJlbG9uZ3MgdG8gd2lsbCBzZXQgdGhpc1xuICAgIC8vIGVsZW1lbnQncyBfcGFyZW50Rm9ybSBwcm9wZXJ0eSB3aGVuIGhhbmRsaW5nIHRoaXMgZXZlbnQuXG4gICAgdGhpcy5maXJlKCdpcm9uLWZvcm0tZWxlbWVudC1yZWdpc3RlcicpO1xuICB9LFxuXG4gIGRldGFjaGVkOiBFbGVtZW50ID8gbnVsbCA6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9wYXJlbnRGb3JtKSB7XG4gICAgICB0aGlzLl9wYXJlbnRGb3JtLmZpcmUoJ2lyb24tZm9ybS1lbGVtZW50LXVucmVnaXN0ZXInLCB7dGFyZ2V0OiB0aGlzfSk7XG4gICAgfVxuICB9XG5cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNDVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbk1ldGEgfSBmcm9tICcuLi9pcm9uLW1ldGEvaXJvbi1tZXRhLmpzJztcbmV4cG9ydCBsZXQgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhID0gbnVsbDtcblxuZXhwb3J0IGNvbnN0IElyb25WYWxpZGF0YWJsZUJlaGF2aW9yID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvKipcbiAgICAgKiBOYW1lIG9mIHRoZSB2YWxpZGF0b3IgdG8gdXNlLlxuICAgICAqL1xuICAgIHZhbGlkYXRvcjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGxhc3QgY2FsbCB0byBgdmFsaWRhdGVgIGlzIGludmFsaWQuXG4gICAgICovXG4gICAgaW52YWxpZDoge1xuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG9ic2VydmVyOiAnX2ludmFsaWRDaGFuZ2VkJ1xuICAgIH0sXG4gIH0sXG5cbiAgcmVnaXN0ZXJlZDogZnVuY3Rpb24oKSB7XG4gICAgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3JNZXRhID0gbmV3IElyb25NZXRhKHt0eXBlOiAndmFsaWRhdG9yJ30pO1xuICB9LFxuXG4gIF9pbnZhbGlkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuaW52YWxpZCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtaW52YWxpZCcsICd0cnVlJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWludmFsaWQnKTtcbiAgICB9XG4gIH0sXG5cbiAgLyogUmVjb21wdXRlIHRoaXMgZXZlcnkgdGltZSBpdCdzIG5lZWRlZCwgYmVjYXVzZSB3ZSBkb24ndCBrbm93IGlmIHRoZVxuICAgKiB1bmRlcmx5aW5nIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSBoYXMgY2hhbmdlZC4gKi9cbiAgZ2V0IF92YWxpZGF0b3IoKSB7XG4gICAgcmV0dXJuIElyb25WYWxpZGF0YWJsZUJlaGF2aW9yTWV0YSAmJlxuICAgICAgICBJcm9uVmFsaWRhdGFibGVCZWhhdmlvck1ldGEuYnlLZXkodGhpcy52YWxpZGF0b3IpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWxpZGF0b3IgYHZhbGlkYXRvcmAgZXhpc3RzLlxuICAgKi9cbiAgaGFzVmFsaWRhdG9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWRhdG9yICE9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYHZhbHVlYCBpcyB2YWxpZCwgYW5kIHVwZGF0ZXMgYGludmFsaWRgLiBJZiB5b3Ugd2FudFxuICAgKiB5b3VyIGVsZW1lbnQgdG8gaGF2ZSBjdXN0b20gdmFsaWRhdGlvbiBsb2dpYywgZG8gbm90IG92ZXJyaWRlIHRoaXMgbWV0aG9kO1xuICAgKiBvdmVycmlkZSBgX2dldFZhbGlkaXR5KHZhbHVlKWAgaW5zdGVhZC5cblxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgRGVwcmVjYXRlZDogVGhlIHZhbHVlIHRvIGJlIHZhbGlkYXRlZC4gQnkgZGVmYXVsdCxcbiAgICogaXQgaXMgcGFzc2VkIHRvIHRoZSB2YWxpZGF0b3IncyBgdmFsaWRhdGUoKWAgZnVuY3Rpb24sIGlmIGEgdmFsaWRhdG9yIGlzIHNldC5cbiAgICogSWYgdGhpcyBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkLCB0aGVuIHRoZSBlbGVtZW50J3MgYHZhbHVlYCBwcm9wZXJ0eVxuICAgKiBpcyB1c2VkLCBpZiBpdCBleGlzdHMuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYHZhbHVlYCBpcyB2YWxpZC5cbiAgICovXG4gIHZhbGlkYXRlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIC8vIElmIHRoaXMgaXMgYW4gZWxlbWVudCB0aGF0IGFsc28gaGFzIGEgdmFsdWUgcHJvcGVydHksIGFuZCB0aGVyZSB3YXNcbiAgICAvLyBubyBleHBsaWNpdCB2YWx1ZSBhcmd1bWVudCBwYXNzZWQsIHVzZSB0aGUgZWxlbWVudCdzIHByb3BlcnR5IGluc3RlYWQuXG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgdGhpcy52YWx1ZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgdGhpcy5pbnZhbGlkID0gIXRoaXMuX2dldFZhbGlkaXR5KHRoaXMudmFsdWUpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuaW52YWxpZCA9ICF0aGlzLl9nZXRWYWxpZGl0eSh2YWx1ZSk7XG4gICAgcmV0dXJuICF0aGlzLmludmFsaWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZiBgdmFsdWVgIGlzIHZhbGlkLiAgQnkgZGVmYXVsdCwgaXQgaXMgcGFzc2VkXG4gICAqIHRvIHRoZSB2YWxpZGF0b3IncyBgdmFsaWRhdGUoKWAgZnVuY3Rpb24sIGlmIGEgdmFsaWRhdG9yIGlzIHNldC4gWW91XG4gICAqIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB5b3Ugd2FudCB0byBpbXBsZW1lbnQgY3VzdG9tIHZhbGlkaXR5XG4gICAqIGxvZ2ljIGZvciB5b3VyIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSBUaGUgdmFsdWUgdG8gYmUgdmFsaWRhdGVkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQuXG4gICAqL1xuXG4gIF9nZXRWYWxpZGl0eTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXNWYWxpZGF0b3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvci52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBmbHVzaCB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBQYXBlcklucHV0QWRkb25CZWhhdmlvciA9IHtcbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5ZG9tL2lzc3Vlcy85NlxuICAgIGZsdXNoKCk7XG4gICAgdGhpcy5maXJlKCdhZGRvbi1hdHRhY2hlZCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgZnVuY3Rpb24gY2FsbGVkIGJ5IGA8cGFwZXItaW5wdXQtY29udGFpbmVyPmAgd2hlbiB0aGUgaW5wdXQgdmFsdWUgb3IgdmFsaWRpdHkgY2hhbmdlcy5cbiAgICogQHBhcmFtIHt7XG4gICAqICAgaW5wdXRFbGVtZW50OiAoRWxlbWVudHx1bmRlZmluZWQpLFxuICAgKiAgIHZhbHVlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICAqICAgaW52YWxpZDogYm9vbGVhblxuICAgKiB9fSBzdGF0ZSAtXG4gICAqICAgICBpbnB1dEVsZW1lbnQ6IFRoZSBpbnB1dCBlbGVtZW50LlxuICAgKiAgICAgdmFsdWU6IFRoZSBpbnB1dCB2YWx1ZS5cbiAgICogICAgIGludmFsaWQ6IFRydWUgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGludmFsaWQuXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gIH1cblxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWlucHV0L3BhcGVyLWlucHV0LWFkZG9uLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA0N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGwsIElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IvaXJvbi1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvciB9IGZyb20gJy4vcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBQYXBlclJpcHBsZUJlaGF2aW9yIH0gZnJvbSAnLi9wYXBlci1yaXBwbGUtYmVoYXZpb3IuanMnO1xuXG5leHBvcnQgY29uc3QgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbCA9IHtcbiAgLyoqXG4gICAqIFN5bmNocm9uaXplcyB0aGUgZWxlbWVudCdzIGNoZWNrZWQgc3RhdGUgd2l0aCBpdHMgcmlwcGxlIGVmZmVjdC5cbiAgICovXG4gIF9jaGVja2VkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgSXJvbkNoZWNrZWRFbGVtZW50QmVoYXZpb3JJbXBsLl9jaGVja2VkQ2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICBpZiAodGhpcy5jaGVja2VkKSB7XG4gICAgICAgIHRoaXMuX3JpcHBsZS5zZXRBdHRyaWJ1dGUoJ2NoZWNrZWQnLCAnJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yaXBwbGUucmVtb3ZlQXR0cmlidXRlKCdjaGVja2VkJyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTeW5jaHJvbml6ZXMgdGhlIGVsZW1lbnQncyBgYWN0aXZlYCBhbmQgYGNoZWNrZWRgIHN0YXRlLlxuICAgKi9cbiAgX2J1dHRvblN0YXRlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgUGFwZXJSaXBwbGVCZWhhdmlvci5fYnV0dG9uU3RhdGVDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgaWYgKHRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5jaGVja2VkID0gdGhpcy5hY3RpdmU7XG4gICAgfVxuICB9XG59O1xuXG5leHBvcnQgY29uc3QgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9yID0gW1xuICBQYXBlcklua3lGb2N1c0JlaGF2aW9yLFxuICBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvcixcbiAgUGFwZXJDaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbFxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDQ4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25CdXR0b25TdGF0ZSB9IGZyb20gJy4uL2lyb24tYmVoYXZpb3JzL2lyb24tYnV0dG9uLXN0YXRlLmpzJztcbmltcG9ydCB7IFBhcGVyUmlwcGxlQmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBJcm9uQ29udHJvbFN0YXRlIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmpzJztcblxuZXhwb3J0IGNvbnN0IFBhcGVySW5reUZvY3VzQmVoYXZpb3JJbXBsID0ge1xuICBvYnNlcnZlcnM6IFtcbiAgICAnX2ZvY3VzZWRDaGFuZ2VkKHJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpJ1xuICBdLFxuXG4gIF9mb2N1c2VkQ2hhbmdlZDogZnVuY3Rpb24ocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCkge1xuICAgIGlmIChyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSB7XG4gICAgICB0aGlzLmVuc3VyZVJpcHBsZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5oYXNSaXBwbGUoKSkge1xuICAgICAgdGhpcy5fcmlwcGxlLmhvbGREb3duID0gcmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJpcHBsZSA9IFBhcGVyUmlwcGxlQmVoYXZpb3IuX2NyZWF0ZVJpcHBsZSgpO1xuICAgIHJpcHBsZS5pZCA9ICdpbmsnO1xuICAgIHJpcHBsZS5zZXRBdHRyaWJ1dGUoJ2NlbnRlcicsICcnKTtcbiAgICByaXBwbGUuY2xhc3NMaXN0LmFkZCgnY2lyY2xlJyk7XG4gICAgcmV0dXJuIHJpcHBsZTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IFBhcGVySW5reUZvY3VzQmVoYXZpb3IgPSBbXG4gIElyb25CdXR0b25TdGF0ZSxcbiAgSXJvbkNvbnRyb2xTdGF0ZSxcbiAgUGFwZXJSaXBwbGVCZWhhdmlvcixcbiAgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGxcbl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgRWxlbWVudCBhcyBQb2x5bWVyRWxlbWVudCB9IGZyb20gJ0Bwb2x5bWVyL3BvbHltZXIvcG9seW1lci1lbGVtZW50JztcbmltcG9ydCBcIkBwb2x5bWVyL3BhcGVyLXRvZ2dsZS1idXR0b24vcGFwZXItdG9nZ2xlLWJ1dHRvblwiO1xuaW1wb3J0IHtodG1sLCByZW5kZXJ9IGZyb20gJ2xpdC1odG1sJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVGFjdGlsZU1vZGUgZXh0ZW5kcyBQb2x5bWVyRWxlbWVudCB7XG4gIHN0YXRpYyBnZXQgaXMoKSB7XG4gICAgcmV0dXJuIFwidGFjdGlsZS1tb2RlXCI7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHRlbXBsYXRlKCkge1xuICAgIHJldHVybiBcIjxwYXBlci10b2dnbGUtYnV0dG9uPkVkaXQ8L3BhcGVyLXRvZ2dsZS1idXR0b24+XCI7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIHZhciB0b2dnbGUgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInBhcGVyLXRvZ2dsZS1idXR0b25cIik7XG4gIH1cblxuICBzZXRUb0VkaXQoKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwicGFwZXItdG9nZ2xlLWJ1dHRvblwiKTtcbiAgICB0b2dnbGUuY2hlY2tlZCA9IHRydWU7XG4gIH1cblxuICBzZXRUb1B1Ymxpc2goKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwicGFwZXItdG9nZ2xlLWJ1dHRvblwiKTtcbiAgICB0b2dnbGUuY2hlY2tlZCA9IHRydWU7XG4gIH1cblxuICBzd2l0Y2hlZFRvRWRpdChjYWxsYmFjaykge1xuICAgIHZhciB0b2dnbGUgPSB0aGlzLnNoYWRvd1Jvb3QucXVlcnlTZWxlY3RvcihcInBhcGVyLXRvZ2dsZS1idXR0b25cIik7XG4gICAgdG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoXCJpcm9uLWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICBpZiAodG9nZ2xlLmNoZWNrZWQpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN3aXRjaGVkVG9QdWJsaXNoKGNhbGxiYWNrKSB7XG4gICAgdmFyIHRvZ2dsZSA9IHRoaXMuc2hhZG93Um9vdC5xdWVyeVNlbGVjdG9yKFwicGFwZXItdG9nZ2xlLWJ1dHRvblwiKTtcbiAgICB0b2dnbGUuYWRkRXZlbnRMaXN0ZW5lcihcImlyb24tY2hhbmdlXCIsICgpID0+IHtcbiAgICAgIGlmICghIHRvZ2dsZS5jaGVja2VkKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gUmVnaXN0ZXIgY3VzdG9tIGVsZW1lbnQgY2xhc3Mgd2l0aCBicm93c2VyXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoVGFjdGlsZU1vZGUuaXMsIFRhY3RpbGVNb2RlKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3RhY3RpbGUvY2xpZW50L3RhY3RpbGUtbW9kZS5qcyIsImltcG9ydCBcIi4vdGFjdGlsZS1hdXRob3IuanNcIjtcbmltcG9ydCBcIi4vdGFjdGlsZS1tb2RlLmpzXCI7XG5cbmZ1bmN0aW9uIHdhdGNoRm9yQ29tcG9uZW50Q2xpY2tzKGV2ZW50KSB7XG4gIC8vIFRoaXMgc3RvcHMgdXNlciBmcm9tIGludGVyYWN0aW5nIHdpdGggcGFnZSBpbiBhdXRob3IgbW9kZVxuICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICB2YXIgY29tcG9uZW50ID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoXCIudGFjdGlsZVwiKTtcbiAgaWYgKGNvbXBvbmVudCkge1xuICAgIHZhciBhdXRob3JFbGVtZW50ID0gY29tcG9uZW50LnF1ZXJ5U2VsZWN0b3IoXCJ0YWN0aWxlLWF1dGhvclwiKTtcbiAgICBpZiAoYXV0aG9yRWxlbWVudCkge1xuICAgICAgdmFyIHBhdGggPSBhdXRob3JFbGVtZW50LmdldEF0dHJpYnV0ZShcInBhdGhcIik7XG5cbiAgICAgIGlmIChhdXRob3JFbGVtZW50KSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB3YXRjaEZvckNvbXBvbmVudENsaWNrcyk7XG5cbiAgICAgICAgYXV0aG9yRWxlbWVudC5vcGVuRGlhbG9nKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB3YXRjaEZvckNvbXBvbmVudENsaWNrcyk7XG5cbiAgICAgICAgICAvLyBUT0RPIGp1c3QgcmVsb2FkIHRoZSBjb21wb25lbnQsIG5vdCB0aGUgZW50aXJlIHBhZ2UuXG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldHVwRWRpdE1vZGUoKSB7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB3YXRjaEZvckNvbXBvbmVudENsaWNrcyk7XG4gIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZChcImVkaXRcIik7XG4gIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKFwidGFjdGlsZS1tb2RlXCIsIFwiZWRpdFwiKTtcbn1cblxuZnVuY3Rpb24gc2V0dXBQdWJsaXNoTW9kZSgpIHtcbiAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHdhdGNoRm9yQ29tcG9uZW50Q2xpY2tzKTtcbiAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKFwiZWRpdFwiKTtcbiAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0oXCJ0YWN0aWxlLW1vZGVcIiwgXCJwdWJsaXNoXCIpO1xufVxuXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoZXZlbnQpID0+IHtcbiAgaWYgKGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmNvbnRhaW5zKCdlZGl0JykpIHtcbiAgICB2YXIgdGFjdGlsZU1vZGVUb2dnbGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwidGFjdGlsZS1tb2RlXCIpO1xuICAgIHRhY3RpbGVNb2RlVG9nZ2xlLnN3aXRjaGVkVG9FZGl0KHNldHVwRWRpdE1vZGUpO1xuICAgIHRhY3RpbGVNb2RlVG9nZ2xlLnN3aXRjaGVkVG9QdWJsaXNoKHNldHVwUHVibGlzaE1vZGUpO1xuXG4gICAgdmFyIG1vZGUgPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbShcInRhY3RpbGUtbW9kZVwiKTtcblxuICAgIGlmIChtb2RlID09PSBcImVkaXRcIikge1xuICAgICAgdGFjdGlsZU1vZGVUb2dnbGUuc2V0VG9FZGl0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldHVwUHVibGlzaE1vZGUoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vdGFjdGlsZS9jbGllbnQvYXV0aG9yLmpzIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5pbXBvcnQgKiBhcyBjYXNlTWFwJDAgZnJvbSAnLi4vdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgbWljcm9UYXNrIH0gZnJvbSAnLi4vdXRpbHMvYXN5bmMuanMnO1xuXG5sZXQgY2FzZU1hcCA9IGNhc2VNYXAkMDtcblxubGV0IG1pY3JvdGFzayA9IG1pY3JvVGFzaztcblxuLy8gU2F2ZSBtYXAgb2YgbmF0aXZlIHByb3BlcnRpZXM7IHRoaXMgZm9ybXMgYSBibGFja2xpc3Qgb3IgcHJvcGVydGllc1xuLy8gdGhhdCB3b24ndCBoYXZlIHRoZWlyIHZhbHVlcyBcInNhdmVkXCIgYnkgYHNhdmVBY2Nlc3NvclZhbHVlYCwgc2luY2Vcbi8vIHJlYWRpbmcgZnJvbSBhbiBIVE1MRWxlbWVudCBhY2Nlc3NvciBmcm9tIHRoZSBjb250ZXh0IG9mIGEgcHJvdG90eXBlIHRocm93c1xuY29uc3QgbmF0aXZlUHJvcGVydGllcyA9IHt9O1xubGV0IHByb3RvID0gSFRNTEVsZW1lbnQucHJvdG90eXBlO1xud2hpbGUgKHByb3RvKSB7XG4gIGxldCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHByb3RvKTtcbiAgZm9yIChsZXQgaT0wOyBpPHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgbmF0aXZlUHJvcGVydGllc1twcm9wc1tpXV0gPSB0cnVlO1xuICB9XG4gIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHByb3RvKTtcbn1cblxuLyoqXG4gKiBVc2VkIHRvIHNhdmUgdGhlIHZhbHVlIG9mIGEgcHJvcGVydHkgdGhhdCB3aWxsIGJlIG92ZXJyaWRkZW4gd2l0aFxuICogYW4gYWNjZXNzb3IuIElmIHRoZSBgbW9kZWxgIGlzIGEgcHJvdG90eXBlLCB0aGUgdmFsdWVzIHdpbGwgYmUgc2F2ZWRcbiAqIGluIGBfX2RhdGFQcm90b2AsIGFuZCBpdCdzIHVwIHRvIHRoZSB1c2VyIChvciBkb3duc3RyZWFtIG1peGluKSB0b1xuICogZGVjaWRlIGhvdy93aGVuIHRvIHNldCB0aGVzZSB2YWx1ZXMgYmFjayBpbnRvIHRoZSBhY2Nlc3NvcnMuXG4gKiBJZiBgbW9kZWxgIGlzIGFscmVhZHkgYW4gaW5zdGFuY2UgKGl0IGhhcyBhIGBfX2RhdGFgIHByb3BlcnR5KSwgdGhlblxuICogdGhlIHZhbHVlIHdpbGwgYmUgc2V0IGFzIGEgcGVuZGluZyBwcm9wZXJ0eSwgbWVhbmluZyB0aGUgdXNlciBzaG91bGRcbiAqIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgIHRvIHRha2UgZWZmZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG1vZGVsIFByb3RvdHlwZSBvciBpbnN0YW5jZVxuICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IE5hbWUgb2YgcHJvcGVydHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmVBY2Nlc3NvclZhbHVlKG1vZGVsLCBwcm9wZXJ0eSkge1xuICAvLyBEb24ndCByZWFkL3N0b3JlIHZhbHVlIGZvciBhbnkgbmF0aXZlIHByb3BlcnRpZXMgc2luY2UgdGhleSBjb3VsZCB0aHJvd1xuICBpZiAoIW5hdGl2ZVByb3BlcnRpZXNbcHJvcGVydHldKSB7XG4gICAgbGV0IHZhbHVlID0gbW9kZWxbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAobW9kZWwuX19kYXRhKSB7XG4gICAgICAgIC8vIEFkZGluZyBhY2Nlc3NvciB0byBpbnN0YW5jZTsgdXBkYXRlIHRoZSBwcm9wZXJ0eVxuICAgICAgICAvLyBJdCBpcyB0aGUgdXNlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGNhbGwgX2ZsdXNoUHJvcGVydGllc1xuICAgICAgICBtb2RlbC5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBZGRpbmcgYWNjZXNzb3IgdG8gcHJvdG87IHNhdmUgcHJvdG8ncyB2YWx1ZSBmb3IgaW5zdGFuY2UtdGltZSB1c2VcbiAgICAgICAgaWYgKCFtb2RlbC5fX2RhdGFQcm90bykge1xuICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0ge307XG4gICAgICAgIH0gZWxzZSBpZiAoIW1vZGVsLmhhc093blByb3BlcnR5KEpTQ29tcGlsZXJfcmVuYW1lUHJvcGVydHkoJ19fZGF0YVByb3RvJywgbW9kZWwpKSkge1xuICAgICAgICAgIG1vZGVsLl9fZGF0YVByb3RvID0gT2JqZWN0LmNyZWF0ZShtb2RlbC5fX2RhdGFQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgbW9kZWwuX19kYXRhUHJvdG9bcHJvcGVydHldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBQcm9wZXJ0eUFjY2Vzc29ycyA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1Byb3BlcnR5QWNjZXNzb3JzfVxuICAgKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBQcm9wZXJ0eUFjY2Vzc29ycyBleHRlbmRzIHN1cGVyQ2xhc3Mge1xuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGVzIHByb3BlcnR5IGFjY2Vzc29ycyBmb3IgYWxsIGF0dHJpYnV0ZXMgaW4gdGhlIHN0YW5kYXJkXG4gICAgICogc3RhdGljIGBvYnNlcnZlZEF0dHJpYnV0ZXNgIGFycmF5LlxuICAgICAqXG4gICAgICogQXR0cmlidXRlIG5hbWVzIGFyZSBtYXBwZWQgdG8gcHJvcGVydHkgbmFtZXMgdXNpbmcgdGhlIGBkYXNoLWNhc2VgIHRvXG4gICAgICogYGNhbWVsQ2FzZWAgY29udmVudGlvblxuICAgICAqXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZVByb3BlcnRpZXNGb3JBdHRyaWJ1dGVzKCkge1xuICAgICAgbGV0IGEkID0gdGhpcy5vYnNlcnZlZEF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBhJC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnByb3RvdHlwZS5fY3JlYXRlUHJvcGVydHlBY2Nlc3NvcihjYXNlTWFwLmRhc2hUb0NhbWVsQ2FzZShhJFtpXSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19zZXJpYWxpemluZztcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgICAgdGhpcy5fX2RhdGFDb3VudGVyO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFFbmFibGVkO1xuICAgICAgLyoqIEB0eXBlIHtib29sZWFufSAqL1xuICAgICAgdGhpcy5fX2RhdGFSZWFkeTtcbiAgICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICAgIHRoaXMuX19kYXRhSW52YWxpZDtcbiAgICAgIC8qKiBAdHlwZSB7IU9iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmc7XG4gICAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICAgIHRoaXMuX19kYXRhT2xkO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YVByb3RvO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yO1xuICAgICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXG4gICAgICB0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHM7XG4gICAgICB0aGlzLl9pbml0aWFsaXplUHJvcGVydGllcygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEltcGxlbWVudHMgbmF0aXZlIEN1c3RvbSBFbGVtZW50cyBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCB0b1xuICAgICAqIHNldCBhbiBhdHRyaWJ1dGUgdmFsdWUgdG8gYSBwcm9wZXJ0eSB2aWEgYF9hdHRyaWJ1dGVUb1Byb3BlcnR5YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIE5hbWUgb2YgYXR0cmlidXRlIHRoYXQgY2hhbmdlZFxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gb2xkIE9sZCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIE5ldyBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKi9cbiAgICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgb2xkLCB2YWx1ZSkge1xuICAgICAgaWYgKG9sZCAhPT0gdmFsdWUpIHtcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlVG9Qcm9wZXJ0eShuYW1lLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIHByb3BlcnR5IGFjY2Vzc29ycy5cbiAgICAgKlxuICAgICAqIFByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlIHBvaW50IGZvciBwZXJmb3JtaW5nIGFueSBzZXR1cCB3b3JrIHByaW9yXG4gICAgICogdG8gaW5pdGlhbGl6aW5nIHRoZSBwcm9wZXJ0eSBhY2Nlc3NvciBzeXN0ZW0uXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2luaXRpYWxpemVQcm9wZXJ0aWVzKCkge1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YUNvdW50ZXIgPSAwO1xuICAgICAgdGhpcy5fX2RhdGFFbmFibGVkID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YVJlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLl9fZGF0YUludmFsaWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX19kYXRhID0ge307XG4gICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgdGhpcy5fX2RhdGFPbGQgPSBudWxsO1xuICAgICAgaWYgKHRoaXMuX19kYXRhUHJvdG8pIHtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyh0aGlzLl9fZGF0YVByb3RvKTtcbiAgICAgICAgdGhpcy5fX2RhdGFQcm90byA9IG51bGw7XG4gICAgICB9XG4gICAgICAvLyBDYXB0dXJlIGluc3RhbmNlIHByb3BlcnRpZXM7IHRoZXNlIHdpbGwgYmUgc2V0IGludG8gYWNjZXNzb3JzXG4gICAgICAvLyBkdXJpbmcgZmlyc3QgZmx1c2guIERvbid0IHNldCB0aGVtIGhlcmUsIHNpbmNlIHdlIHdhbnRcbiAgICAgIC8vIHRoZXNlIHRvIG92ZXJ3cml0ZSBkZWZhdWx0cy9jb25zdHJ1Y3RvciBhc3NpZ25tZW50c1xuICAgICAgZm9yIChsZXQgcCBpbiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yKSB7XG4gICAgICAgIGlmICh0aGlzLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICAgICAgdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzID0gdGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzIHx8IHt9O1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wc1twXSA9IHRoaXNbcF07XG4gICAgICAgICAgZGVsZXRlIHRoaXNbcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYXQgaW5zdGFuY2UgdGltZSB3aXRoIGJhZyBvZiBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqIGJ5IGFjY2Vzc29ycyBvbiB0aGUgcHJvdG90eXBlIHdoZW4gYWNjZXNzb3JzIHdlcmUgY3JlYXRlZC5cbiAgICAgKlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHNldHMgdGhlc2UgcHJvcGVydGllcyBiYWNrIGludG8gdGhlXG4gICAgICogc2V0dGVyIGF0IGluc3RhbmNlIHRpbWUuICBUaGlzIG1ldGhvZCBpcyBwcm92aWRlZCBhcyBhbiBvdmVycmlkZVxuICAgICAqIHBvaW50IGZvciBjdXN0b21pemluZyBvciBwcm92aWRpbmcgbW9yZSBlZmZpY2llbnQgaW5pdGlhbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgQmFnIG9mIHByb3BlcnR5IHZhbHVlcyB0aGF0IHdlcmUgb3ZlcndyaXR0ZW5cbiAgICAgKiAgIHdoZW4gY3JlYXRpbmcgcHJvcGVydHkgYWNjZXNzb3JzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaW5pdGlhbGl6ZVByb3RvUHJvcGVydGllcyhwcm9wcykge1xuICAgICAgZm9yIChsZXQgcCBpbiBwcm9wcykge1xuICAgICAgICB0aGlzLl9zZXRQcm9wZXJ0eShwLCBwcm9wc1twXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGF0IHJlYWR5IHRpbWUgd2l0aCBiYWcgb2YgaW5zdGFuY2UgcHJvcGVydGllcyB0aGF0IG92ZXJ3cm90ZVxuICAgICAqIGFjY2Vzc29ycyB3aGVuIHRoZSBlbGVtZW50IHVwZ3JhZGVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gc2V0cyB0aGVzZSBwcm9wZXJ0aWVzIGJhY2sgaW50byB0aGVcbiAgICAgKiBzZXR0ZXIgYXQgcmVhZHkgdGltZS4gIFRoaXMgbWV0aG9kIGlzIHByb3ZpZGVkIGFzIGFuIG92ZXJyaWRlXG4gICAgICogcG9pbnQgZm9yIGN1c3RvbWl6aW5nIG9yIHByb3ZpZGluZyBtb3JlIGVmZmljaWVudCBpbml0aWFsaXphdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wcyBCYWcgb2YgcHJvcGVydHkgdmFsdWVzIHRoYXQgd2VyZSBvdmVyd3JpdHRlblxuICAgICAqICAgd2hlbiBjcmVhdGluZyBwcm9wZXJ0eSBhY2Nlc3NvcnMuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbml0aWFsaXplSW5zdGFuY2VQcm9wZXJ0aWVzKHByb3BzKSB7XG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHByb3BzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmVzIHRoZSBlbGVtZW50IGhhcyB0aGUgZ2l2ZW4gYXR0cmlidXRlLiBJZiBpdCBkb2VzIG5vdCxcbiAgICAgKiBhc3NpZ25zIHRoZSBnaXZlbiB2YWx1ZSB0byB0aGUgYXR0cmlidXRlLlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIE5hbWUgb2YgYXR0cmlidXRlIHRvIGVuc3VyZSBpcyBzZXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgX2Vuc3VyZUF0dHJpYnV0ZShhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsIGF0dHJpYnV0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVzZXJpYWxpemVzIGFuIGF0dHJpYnV0ZSB0byBpdHMgYXNzb2NpYXRlZCBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX2Rlc2VyaWFsaXplVmFsdWVgIG1ldGhvZCB0byBjb252ZXJ0IHRoZSBzdHJpbmcgdG9cbiAgICAgKiBhIHR5cGVkIHZhbHVlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBOYW1lIG9mIGF0dHJpYnV0ZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICogQHBhcmFtIHsqPX0gdHlwZSB0eXBlIHRvIGRlc2VyaWFsaXplIHRvLlxuICAgICAqL1xuICAgIF9hdHRyaWJ1dGVUb1Byb3BlcnR5KGF0dHJpYnV0ZSwgdmFsdWUsIHR5cGUpIHtcbiAgICAgIC8vIERvbid0IGRlc2VyaWFsaXplIGJhY2sgdG8gcHJvcGVydHkgaWYgY3VycmVudGx5IHJlZmxlY3RpbmdcbiAgICAgIGlmICghdGhpcy5fX3NlcmlhbGl6aW5nKSB7XG4gICAgICAgIGxldCBwcm9wZXJ0eSA9IGNhc2VNYXAuZGFzaFRvQ2FtZWxDYXNlKGF0dHJpYnV0ZSk7XG4gICAgICAgIHRoaXNbcHJvcGVydHldID0gdGhpcy5fZGVzZXJpYWxpemVWYWx1ZSh2YWx1ZSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplcyBhIHByb3BlcnR5IHRvIGl0cyBhc3NvY2lhdGVkIGF0dHJpYnV0ZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSBQcm9wZXJ0eSBuYW1lIHRvIHJlZmxlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gcmVmbGVjdC5cbiAgICAgKiBAcGFyYW0geyo9fSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byByZWZlY3QuXG4gICAgICovXG4gICAgX3Byb3BlcnR5VG9BdHRyaWJ1dGUocHJvcGVydHksIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX19zZXJpYWxpemluZyA9IHRydWU7XG4gICAgICB2YWx1ZSA9IChhcmd1bWVudHMubGVuZ3RoIDwgMykgPyB0aGlzW3Byb3BlcnR5XSA6IHZhbHVlO1xuICAgICAgdGhpcy5fdmFsdWVUb05vZGVBdHRyaWJ1dGUodGhpcywgdmFsdWUsXG4gICAgICAgIGF0dHJpYnV0ZSB8fCBjYXNlTWFwLmNhbWVsVG9EYXNoQ2FzZShwcm9wZXJ0eSkpO1xuICAgICAgdGhpcy5fX3NlcmlhbGl6aW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIHR5cGVkIHZhbHVlIHRvIGFuIEhUTUwgYXR0cmlidXRlIG9uIGEgbm9kZS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGNhbGxzIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgdG8gY29udmVydCB0aGUgdHlwZWRcbiAgICAgKiB2YWx1ZSB0byBhIHN0cmluZy4gIElmIHRoZSBgX3NlcmlhbGl6ZVZhbHVlYCBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiB0aGUgYXR0cmlidXRlIHdpbGwgYmUgcmVtb3ZlZCAodGhpcyBpcyB0aGUgZGVmYXVsdCBmb3IgYm9vbGVhblxuICAgICAqIHR5cGUgYGZhbHNlYCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgRWxlbWVudCB0byBzZXQgYXR0cmlidXRlIHRvLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgQXR0cmlidXRlIG5hbWUgdG8gc2VyaWFsaXplIHRvLlxuICAgICAqL1xuICAgIF92YWx1ZVRvTm9kZUF0dHJpYnV0ZShub2RlLCB2YWx1ZSwgYXR0cmlidXRlKSB7XG4gICAgICBsZXQgc3RyID0gdGhpcy5fc2VyaWFsaXplVmFsdWUodmFsdWUpO1xuICAgICAgaWYgKHN0ciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIHN0cik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSB0eXBlZCBKYXZhU2NyaXB0IHZhbHVlIHRvIGEgc3RyaW5nLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFBvbHltZXIgd2hlbiBzZXR0aW5nIEpTIHByb3BlcnR5IHZhbHVlcyB0b1xuICAgICAqIEhUTUwgYXR0cmlidXRlcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgc2VyaWFsaXphdGlvbiBmb3IgY3VzdG9tIHR5cGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBQcm9wZXJ0eSB2YWx1ZSB0byBzZXJpYWxpemUuXG4gICAgICogQHJldHVybiB7c3RyaW5nIHwgdW5kZWZpbmVkfSBTdHJpbmcgc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBwcm9wZXJ0eSB2YWx1ZS5cbiAgICAgKi9cbiAgICBfc2VyaWFsaXplVmFsdWUodmFsdWUpIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLWZhbGx0aHJvdWdoICovXG4gICAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgICByZXR1cm4gdmFsdWUgPyAnJyA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsID8gdmFsdWUudG9TdHJpbmcoKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyB0byBhIHR5cGVkIEphdmFTY3JpcHQgdmFsdWUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYnkgUG9seW1lciB3aGVuIHJlYWRpbmcgSFRNTCBhdHRyaWJ1dGUgdmFsdWVzIHRvXG4gICAgICogSlMgcHJvcGVydGllcy4gIFVzZXJzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCBvbiBQb2x5bWVyIGVsZW1lbnRcbiAgICAgKiBwcm90b3R5cGVzIHRvIHByb3ZpZGUgZGVzZXJpYWxpemF0aW9uIGZvciBjdXN0b20gYHR5cGVgcy4gIE5vdGUsXG4gICAgICogdGhlIGB0eXBlYCBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGB0eXBlYCBmaWVsZCBwcm92aWRlZCBpbiB0aGVcbiAgICAgKiBgcHJvcGVydGllc2AgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGEgZ2l2ZW4gcHJvcGVydHksIGFuZCBpc1xuICAgICAqIGJ5IGNvbnZlbnRpb24gdGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgdHlwZSB0byBkZXNlcmlhbGl6ZS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoZSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgaXMgdXNlZCBhcyBhIHNlbnRpbmVsIHZhbHVlIHRvXG4gICAgICogaW5kaWNhdGUgdGhlIGF0dHJpYnV0ZSBzaG91bGQgYmUgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlIHRvIGRlc2VyaWFsaXplLlxuICAgICAqIEBwYXJhbSB7Kj19IHR5cGUgVHlwZSB0byBkZXNlcmlhbGl6ZSB0aGUgc3RyaW5nIHRvLlxuICAgICAqIEByZXR1cm4geyp9IFR5cGVkIHZhbHVlIGRlc2VyaWFsaXplZCBmcm9tIHRoZSBwcm92aWRlZCBzdHJpbmcuXG4gICAgICovXG4gICAgX2Rlc2VyaWFsaXplVmFsdWUodmFsdWUsIHR5cGUpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUgeyp9XG4gICAgICAgKi9cbiAgICAgIGxldCBvdXRWYWx1ZTtcbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICBvdXRWYWx1ZSA9IE51bWJlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgIG91dFZhbHVlID0gKHZhbHVlICE9PSBudWxsKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3V0VmFsdWUgPSBKU09OLnBhcnNlKC8qKiBAdHlwZSBzdHJpbmcgKi8odmFsdWUpKTtcbiAgICAgICAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgICAgIC8vIGFsbG93IG5vbi1KU09OIGxpdGVyYWxzIGxpa2UgU3RyaW5ncyBhbmQgTnVtYmVyc1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvdXRWYWx1ZSA9IEpTT04ucGFyc2UoLyoqIEB0eXBlIHN0cmluZyAqLyh2YWx1ZSkpO1xuICAgICAgICAgIH0gY2F0Y2goeCkge1xuICAgICAgICAgICAgb3V0VmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBQb2x5bWVyOjpBdHRyaWJ1dGVzOiBjb3VsZG4ndCBkZWNvZGUgQXJyYXkgYXMgSlNPTjogJHt2YWx1ZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBEYXRlOlxuICAgICAgICAgIG91dFZhbHVlID0gbmV3IERhdGUodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIG91dFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRWYWx1ZTtcbiAgICB9XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1mYWxsdGhyb3VnaCAqL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldHRlci9nZXR0ZXIgcGFpciBmb3IgdGhlIG5hbWVkIHByb3BlcnR5IHdpdGggaXRzIG93blxuICAgICAqIGxvY2FsIHN0b3JhZ2UuICBUaGUgZ2V0dGVyIHJldHVybnMgdGhlIHZhbHVlIGluIHRoZSBsb2NhbCBzdG9yYWdlLFxuICAgICAqIGFuZCB0aGUgc2V0dGVyIGNhbGxzIGBfc2V0UHJvcGVydHlgLCB3aGljaCB1cGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlXG4gICAgICogZm9yIHRoZSBwcm9wZXJ0eSBhbmQgZW5xdWV1ZXMgYSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgb24gYSBwcm90b3R5cGUgb3IgYW4gaW5zdGFuY2UuICBDYWxsaW5nXG4gICAgICogdGhpcyBtZXRob2QgbWF5IG92ZXJ3cml0ZSBhIHByb3BlcnR5IHZhbHVlIHRoYXQgYWxyZWFkeSBleGlzdHMgb25cbiAgICAgKiB0aGUgcHJvdG90eXBlL2luc3RhbmNlIGJ5IGNyZWF0aW5nIHRoZSBhY2Nlc3Nvci4gIFdoZW4gY2FsbGluZyBvblxuICAgICAqIGEgcHJvdG90eXBlLCBhbnkgb3ZlcndyaXR0ZW4gdmFsdWVzIGFyZSBzYXZlZCBpbiBgX19kYXRhUHJvdG9gLFxuICAgICAqIGFuZCBpdCBpcyB1cCB0byB0aGUgc3ViY2xhc3NlciB0byBkZWNpZGUgaG93L3doZW4gdG8gc2V0IHRob3NlXG4gICAgICogcHJvcGVydGllcyBiYWNrIGludG8gdGhlIGFjY2Vzc29yLiAgV2hlbiBjYWxsaW5nIG9uIGFuIGluc3RhbmNlLFxuICAgICAqIHRoZSBvdmVyd3JpdHRlbiB2YWx1ZSBpcyBzZXQgdmlhIGBfc2V0UGVuZGluZ1Byb3BlcnR5YCwgYW5kIHRoZVxuICAgICAqIHVzZXIgc2hvdWxkIGNhbGwgYF9pbnZhbGlkYXRlUHJvcGVydGllc2Agb3IgYF9mbHVzaFByb3BlcnRpZXNgXG4gICAgICogZm9yIHRoZSB2YWx1ZXMgdG8gdGFrZSBlZmZlY3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW49fSByZWFkT25seSBXaGVuIHRydWUsIG5vIHNldHRlciBpcyBjcmVhdGVkOyB0aGVcbiAgICAgKiAgIHByb3RlY3RlZCBgX3NldFByb3BlcnR5YCBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gc2V0IHRoZSBwcm9wZXJ0eVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfY3JlYXRlUHJvcGVydHlBY2Nlc3Nvcihwcm9wZXJ0eSwgcmVhZE9ubHkpIHtcbiAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eSgnX19kYXRhSGFzQWNjZXNzb3InKSkge1xuICAgICAgICB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fX2RhdGFIYXNBY2Nlc3Nvcik7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldKSB7XG4gICAgICAgIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgc2F2ZUFjY2Vzc29yVmFsdWUodGhpcywgcHJvcGVydHkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcGVydHksIHtcbiAgICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSB2YWxpZC1qc2RvYyAqL1xuICAgICAgICAgIC8qKiBAdGhpcyB7UHJvcGVydHlBY2Nlc3NvcnN9ICovXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZGF0YVtwcm9wZXJ0eV07XG4gICAgICAgICAgfSxcbiAgICAgICAgICAvKiogQHRoaXMge1Byb3BlcnR5QWNjZXNzb3JzfSAqL1xuICAgICAgICAgIHNldDogcmVhZE9ubHkgPyBmdW5jdGlvbigpIHt9IDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgbGlicmFyeSBjcmVhdGVkIGFuIGFjY2Vzc29yIGZvciB0aGUgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYW4gYWNjZXNzb3Igd2FzIGNyZWF0ZWRcbiAgICAgKi9cbiAgICBfaGFzQWNjZXNzb3IocHJvcGVydHkpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YUhhc0FjY2Vzc29yICYmIHRoaXMuX19kYXRhSGFzQWNjZXNzb3JbcHJvcGVydHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIGxvY2FsIHN0b3JhZ2UgZm9yIGEgcHJvcGVydHkgKHZpYSBgX3NldFBlbmRpbmdQcm9wZXJ0eWApXG4gICAgICogYW5kIGVucXVldWVzIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UHJvcGVydHkocHJvcGVydHksIHZhbHVlKSB7XG4gICAgICBpZiAodGhpcy5fc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5faW52YWxpZGF0ZVByb3BlcnRpZXMoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBsb2NhbCBzdG9yYWdlIGZvciBhIHByb3BlcnR5LCByZWNvcmRzIHRoZSBwcmV2aW91cyB2YWx1ZSxcbiAgICAgKiBhbmQgYWRkcyBpdCB0byB0aGUgc2V0IG9mIFwicGVuZGluZyBjaGFuZ2VzXCIgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICAgKiBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjay4gIFRoaXMgbWV0aG9kIGRvZXMgbm90IGVucXVldWUgdGhlXG4gICAgICogYF9wcm9wZXJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgTmFtZSBvZiB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIHNldFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgcHJvcGVydHkgY2hhbmdlZFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0UGVuZGluZ1Byb3BlcnR5KHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgbGV0IG9sZCA9IHRoaXMuX19kYXRhW3Byb3BlcnR5XTtcbiAgICAgIGxldCBjaGFuZ2VkID0gdGhpcy5fc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpO1xuICAgICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVBlbmRpbmcpIHtcbiAgICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSB7fTtcbiAgICAgICAgICB0aGlzLl9fZGF0YU9sZCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSBvbGQgaXMgY2FwdHVyZWQgZnJvbSB0aGUgbGFzdCB0dXJuXG4gICAgICAgIGlmICh0aGlzLl9fZGF0YU9sZCAmJiAhKHByb3BlcnR5IGluIHRoaXMuX19kYXRhT2xkKSkge1xuICAgICAgICAgIHRoaXMuX19kYXRhT2xkW3Byb3BlcnR5XSA9IG9sZDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fZGF0YVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fX2RhdGFQZW5kaW5nW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkgaGFzIGEgcGVuZGluZyBjaGFuZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSBuYW1lXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBwcm9wZXJ0eSBoYXMgYSBwZW5kaW5nIGNoYW5nZVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfaXNQcm9wZXJ0eVBlbmRpbmcocHJvcCkge1xuICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5fX2RhdGFQZW5kaW5nICYmIChwcm9wIGluIHRoaXMuX19kYXRhUGVuZGluZykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1hcmtzIHRoZSBwcm9wZXJ0aWVzIGFzIGludmFsaWQsIGFuZCBlbnF1ZXVlcyBhbiBhc3luY1xuICAgICAqIGBfcHJvcGVydGllc0NoYW5nZWRgIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9pbnZhbGlkYXRlUHJvcGVydGllcygpIHtcbiAgICAgIGlmICghdGhpcy5fX2RhdGFJbnZhbGlkICYmIHRoaXMuX19kYXRhUmVhZHkpIHtcbiAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gdHJ1ZTtcbiAgICAgICAgbWljcm90YXNrLnJ1bigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX19kYXRhSW52YWxpZCkge1xuICAgICAgICAgICAgdGhpcy5fX2RhdGFJbnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgdG8gZW5hYmxlIHByb3BlcnR5IGFjY2Vzc29yIHByb2Nlc3NpbmcuIEJlZm9yZSB0aGlzIG1ldGhvZCBpc1xuICAgICAqIGNhbGxlZCBhY2Nlc3NvciB2YWx1ZXMgd2lsbCBiZSBzZXQgYnV0IHNpZGUgZWZmZWN0cyBhcmVcbiAgICAgKiBxdWV1ZWQuIFdoZW4gY2FsbGVkLCBhbnkgcGVuZGluZyBzaWRlIGVmZmVjdHMgb2NjdXIgaW1tZWRpYXRlbHkuXG4gICAgICogRm9yIGVsZW1lbnRzLCBnZW5lcmFsbHkgYGNvbm5lY3RlZENhbGxiYWNrYCBpcyBhIG5vcm1hbCBzcG90IHRvIGRvIHNvLlxuICAgICAqIEl0IGlzIHNhZmUgdG8gY2FsbCB0aGlzIG1ldGhvZCBtdWx0aXBsZSB0aW1lcyBhcyBpdCBvbmx5IHR1cm5zIG9uXG4gICAgICogcHJvcGVydHkgYWNjZXNzb3JzIG9uY2UuXG4gICAgICovXG4gICAgX2VuYWJsZVByb3BlcnRpZXMoKSB7XG4gICAgICBpZiAoIXRoaXMuX19kYXRhRW5hYmxlZCkge1xuICAgICAgICB0aGlzLl9fZGF0YUVuYWJsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fX2RhdGFJbnN0YW5jZVByb3BzKSB7XG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZUluc3RhbmNlUHJvcGVydGllcyh0aGlzLl9fZGF0YUluc3RhbmNlUHJvcHMpO1xuICAgICAgICAgIHRoaXMuX19kYXRhSW5zdGFuY2VQcm9wcyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWFkeSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGxzIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFjayB3aXRoIHRoZSBjdXJyZW50IHNldCBvZlxuICAgICAqIHBlbmRpbmcgY2hhbmdlcyAoYW5kIG9sZCB2YWx1ZXMgcmVjb3JkZWQgd2hlbiBwZW5kaW5nIGNoYW5nZXMgd2VyZVxuICAgICAqIHNldCksIGFuZCByZXNldHMgdGhlIHBlbmRpbmcgc2V0IG9mIGNoYW5nZXMuIEdlbmVyYWxseSwgdGhpcyBtZXRob2RcbiAgICAgKiBzaG91bGQgbm90IGJlIGNhbGxlZCBpbiB1c2VyIGNvZGUuXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZmx1c2hQcm9wZXJ0aWVzKCkge1xuICAgICAgaWYgKHRoaXMuX19kYXRhUGVuZGluZyAmJiB0aGlzLl9fZGF0YU9sZCkge1xuICAgICAgICBsZXQgY2hhbmdlZFByb3BzID0gdGhpcy5fX2RhdGFQZW5kaW5nO1xuICAgICAgICB0aGlzLl9fZGF0YVBlbmRpbmcgPSBudWxsO1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXIrKztcbiAgICAgICAgdGhpcy5fcHJvcGVydGllc0NoYW5nZWQodGhpcy5fX2RhdGEsIGNoYW5nZWRQcm9wcywgdGhpcy5fX2RhdGFPbGQpO1xuICAgICAgICB0aGlzLl9fZGF0YUNvdW50ZXItLTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBMaWZlY3ljbGUgY2FsbGJhY2sgY2FsbGVkIHRoZSBmaXJzdCB0aW1lIHByb3BlcnRpZXMgYXJlIGJlaW5nIGZsdXNoZWQuXG4gICAgICogUHJpb3IgdG8gYHJlYWR5YCwgYWxsIHByb3BlcnR5IHNldHMgdGhyb3VnaCBhY2Nlc3NvcnMgYXJlIHF1ZXVlZCBhbmRcbiAgICAgKiB0aGVpciBlZmZlY3RzIGFyZSBmbHVzaGVkIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMuXG4gICAgICpcbiAgICAgKiBVc2VycyBtYXkgb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiB0byBpbXBsZW1lbnQgYmVoYXZpb3IgdGhhdCBpc1xuICAgICAqIGRlcGVuZGVudCBvbiB0aGUgZWxlbWVudCBoYXZpbmcgaXRzIHByb3BlcnRpZXMgaW5pdGlhbGl6ZWQsIGUuZy5cbiAgICAgKiBmcm9tIGRlZmF1bHRzIChpbml0aWFsaXplZCBmcm9tIGBjb25zdHJ1Y3RvcmAsIGBfaW5pdGlhbGl6ZVByb3BlcnRpZXNgKSxcbiAgICAgKiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYCwgb3IgdmFsdWVzIHByb3BhZ2F0ZWQgZnJvbSBob3N0IGUuZy4gdmlhXG4gICAgICogYmluZGluZ3MuICBgc3VwZXIucmVhZHkoKWAgbXVzdCBiZSBjYWxsZWQgdG8gZW5zdXJlIHRoZSBkYXRhIHN5c3RlbVxuICAgICAqIGJlY29tZXMgZW5hYmxlZC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICByZWFkeSgpIHtcbiAgICAgIHRoaXMuX19kYXRhUmVhZHkgPSB0cnVlO1xuICAgICAgLy8gUnVuIG5vcm1hbCBmbHVzaFxuICAgICAgdGhpcy5fZmx1c2hQcm9wZXJ0aWVzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gYW55IHByb3BlcnRpZXMgd2l0aCBhY2Nlc3NvcnMgY3JlYXRlZCB2aWFcbiAgICAgKiBgX2NyZWF0ZVByb3BlcnR5QWNjZXNzb3JgIGhhdmUgYmVlbiBzZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IGN1cnJlbnRQcm9wcyBCYWcgb2YgYWxsIGN1cnJlbnQgYWNjZXNzb3IgdmFsdWVzXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBjaGFuZ2VkUHJvcHMgQmFnIG9mIHByb3BlcnRpZXMgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdFxuICAgICAqICAgY2FsbCB0byBgX3Byb3BlcnRpZXNDaGFuZ2VkYFxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gb2xkUHJvcHMgQmFnIG9mIHByZXZpb3VzIHZhbHVlcyBmb3IgZWFjaCBwcm9wZXJ0eVxuICAgICAqICAgaW4gYGNoYW5nZWRQcm9wc2BcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Byb3BlcnRpZXNDaGFuZ2VkKGN1cnJlbnRQcm9wcywgY2hhbmdlZFByb3BzLCBvbGRQcm9wcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIGNhbGxlZCB0byBkZXRlcm1pbmUgd2hldGhlciBhIHByb3BlcnR5IHZhbHVlIHNob3VsZCBiZVxuICAgICAqIGNvbnNpZGVyZWQgYXMgYSBjaGFuZ2UgYW5kIGNhdXNlIHRoZSBgX3Byb3BlcnRpZXNDaGFuZ2VkYCBjYWxsYmFja1xuICAgICAqIHRvIGJlIGVucXVldWVkLlxuICAgICAqXG4gICAgICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIHByaW1pdGl2ZSB0eXBlcyBpZiBhXG4gICAgICogc3RyaWN0IGVxdWFsaXR5IGNoZWNrIGZhaWxzLCBhbmQgcmV0dXJucyBgdHJ1ZWAgZm9yIGFsbCBPYmplY3QvQXJyYXlzLlxuICAgICAqIFRoZSBtZXRob2QgYWx3YXlzIHJldHVybnMgZmFsc2UgZm9yIGBOYU5gLlxuICAgICAqXG4gICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZS5nLiBwcm92aWRlIHN0cmljdGVyIGNoZWNraW5nIGZvclxuICAgICAqIE9iamVjdHMvQXJyYXlzIHdoZW4gdXNpbmcgaW1tdXRhYmxlIHBhdHRlcm5zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5IFByb3BlcnR5IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2xkIFByZXZpb3VzIHByb3BlcnR5IHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIGNvbnNpZGVyZWQgYSBjaGFuZ2VcbiAgICAgKiAgIGFuZCBlbnF1ZXVlIGEgYF9wcm9lcHJ0aWVzQ2hhbmdlZGAgY2FsbGJhY2tcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICAvLyBTdHJpY3QgZXF1YWxpdHkgY2hlY2tcbiAgICAgICAgKG9sZCAhPT0gdmFsdWUgJiZcbiAgICAgICAgIC8vIFRoaXMgZW5zdXJlcyAob2xkPT1OYU4sIHZhbHVlPT1OYU4pIGFsd2F5cyByZXR1cm5zIGZhbHNlXG4gICAgICAgICAob2xkID09PSBvbGQgfHwgdmFsdWUgPT09IHZhbHVlKSlcbiAgICAgICk7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gUHJvcGVydHlBY2Nlc3NvcnM7XG5cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvbWl4aW5zL3Byb3BlcnR5LWFjY2Vzc29ycy5qc1xuLy8gbW9kdWxlIGlkID0gNTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IGRlZHVwaW5nTWl4aW4gfSBmcm9tICcuLi91dGlscy9taXhpbi5qcyc7XG5cbi8vIDEueCBiYWNrd2FyZHMtY29tcGF0aWJsZSBhdXRvLXdyYXBwZXIgZm9yIHRlbXBsYXRlIHR5cGUgZXh0ZW5zaW9uc1xuLy8gVGhpcyBpcyBhIGNsZWFyIGxheWVyaW5nIHZpb2xhdGlvbiBhbmQgZ2l2ZXMgZmF2b3JlZC1uYXRpb24gc3RhdHVzIHRvXG4vLyBkb20taWYgYW5kIGRvbS1yZXBlYXQgdGVtcGxhdGVzLiAgVGhpcyBpcyBhIGNvbmNlaXQgd2UncmUgY2hvb3NpbmcgdG8ga2VlcFxuLy8gYS4pIHRvIGVhc2UgMS54IGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGR1ZSB0byBsb3NzIG9mIGBpc2AsIGFuZFxuLy8gYi4pIHRvIG1haW50YWluIGlmL3JlcGVhdCBjYXBhYmlsaXR5IGluIHBhcnNlci1jb25zdHJhaW5lZCBlbGVtZW50c1xuLy8gICAgIChlLmcuIHRhYmxlLCBzZWxlY3QpIGluIGxpZXUgb2YgbmF0aXZlIENFIHR5cGUgZXh0ZW5zaW9ucyB3aXRob3V0XG4vLyAgICAgbWFzc2l2ZSBuZXcgaW52ZW50aW9uIGluIHRoaXMgc3BhY2UgKGUuZy4gZGlyZWN0aXZlIHN5c3RlbSlcbmNvbnN0IHRlbXBsYXRlRXh0ZW5zaW9ucyA9IHtcbiAgJ2RvbS1pZic6IHRydWUsXG4gICdkb20tcmVwZWF0JzogdHJ1ZVxufTtcbmZ1bmN0aW9uIHdyYXBUZW1wbGF0ZUV4dGVuc2lvbihub2RlKSB7XG4gIGxldCBpcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdpcycpO1xuICBpZiAoaXMgJiYgdGVtcGxhdGVFeHRlbnNpb25zW2lzXSkge1xuICAgIGxldCB0ID0gbm9kZTtcbiAgICB0LnJlbW92ZUF0dHJpYnV0ZSgnaXMnKTtcbiAgICBub2RlID0gdC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoaXMpO1xuICAgIHQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgdCk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0KTtcbiAgICB3aGlsZSh0LmF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZSh0LmF0dHJpYnV0ZXNbMF0ubmFtZSwgdC5hdHRyaWJ1dGVzWzBdLnZhbHVlKTtcbiAgICAgIHQucmVtb3ZlQXR0cmlidXRlKHQuYXR0cmlidXRlc1swXS5uYW1lKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRUZW1wbGF0ZU5vZGUocm9vdCwgbm9kZUluZm8pIHtcbiAgLy8gcmVjdXJzaXZlbHkgYXNjZW5kIHRyZWUgdW50aWwgd2UgaGl0IHJvb3RcbiAgbGV0IHBhcmVudCA9IG5vZGVJbmZvLnBhcmVudEluZm8gJiYgZmluZFRlbXBsYXRlTm9kZShyb290LCBub2RlSW5mby5wYXJlbnRJbmZvKTtcbiAgLy8gdW53aW5kIHRoZSBzdGFjaywgcmV0dXJuaW5nIHRoZSBpbmRleGVkIG5vZGUgYXQgZWFjaCBsZXZlbFxuICBpZiAocGFyZW50KSB7XG4gICAgLy8gbm90ZTogbWFyZ2luYWxseSBmYXN0ZXIgdGhhbiBpbmRleGluZyB2aWEgY2hpbGROb2Rlc1xuICAgIC8vIChodHRwOi8vanNwZXJmLmNvbS9jaGlsZG5vZGVzLWxvb2t1cClcbiAgICBmb3IgKGxldCBuPXBhcmVudC5maXJzdENoaWxkLCBpPTA7IG47IG49bi5uZXh0U2libGluZykge1xuICAgICAgaWYgKG5vZGVJbmZvLnBhcmVudEluZGV4ID09PSBpKyspIHtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByb290O1xuICB9XG59XG5cbi8vIGNvbnN0cnVjdCBgJGAgbWFwIChmcm9tIGlkIGFubm90YXRpb25zKVxuZnVuY3Rpb24gYXBwbHlJZFRvTWFwKGluc3QsIG1hcCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgaWYgKG5vZGVJbmZvLmlkKSB7XG4gICAgbWFwW25vZGVJbmZvLmlkXSA9IG5vZGU7XG4gIH1cbn1cblxuLy8gaW5zdGFsbCBldmVudCBsaXN0ZW5lcnMgKGZyb20gZXZlbnQgYW5ub3RhdGlvbnMpXG5mdW5jdGlvbiBhcHBseUV2ZW50TGlzdGVuZXIoaW5zdCwgbm9kZSwgbm9kZUluZm8pIHtcbiAgaWYgKG5vZGVJbmZvLmV2ZW50cyAmJiBub2RlSW5mby5ldmVudHMubGVuZ3RoKSB7XG4gICAgZm9yIChsZXQgaj0wLCBlJD1ub2RlSW5mby5ldmVudHMsIGU7IChqPGUkLmxlbmd0aCkgJiYgKGU9ZSRbal0pOyBqKyspIHtcbiAgICAgIGluc3QuX2FkZE1ldGhvZEV2ZW50TGlzdGVuZXJUb05vZGUobm9kZSwgZS5uYW1lLCBlLnZhbHVlLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLy8gcHVzaCBjb25maWd1cmF0aW9uIHJlZmVyZW5jZXMgYXQgY29uZmlndXJlIHRpbWVcbmZ1bmN0aW9uIGFwcGx5VGVtcGxhdGVDb250ZW50KGluc3QsIG5vZGUsIG5vZGVJbmZvKSB7XG4gIGlmIChub2RlSW5mby50ZW1wbGF0ZUluZm8pIHtcbiAgICBub2RlLl90ZW1wbGF0ZUluZm8gPSBub2RlSW5mby50ZW1wbGF0ZUluZm87XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZUV2ZW50SGFuZGxlcihjb250ZXh0LCBldmVudE5hbWUsIG1ldGhvZE5hbWUpIHtcbiAgLy8gSW5zdGFuY2VzIGNhbiBvcHRpb25hbGx5IGhhdmUgYSBfbWV0aG9kSG9zdCB3aGljaCBhbGxvd3MgcmVkaXJlY3Rpbmcgd2hlcmVcbiAgLy8gdG8gZmluZCBtZXRob2RzLiBDdXJyZW50bHkgdXNlZCBieSBgdGVtcGxhdGl6ZWAuXG4gIGNvbnRleHQgPSBjb250ZXh0Ll9tZXRob2RIb3N0IHx8IGNvbnRleHQ7XG4gIGxldCBoYW5kbGVyID0gZnVuY3Rpb24oZSkge1xuICAgIGlmIChjb250ZXh0W21ldGhvZE5hbWVdKSB7XG4gICAgICBjb250ZXh0W21ldGhvZE5hbWVdKGUsIGUuZGV0YWlsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdsaXN0ZW5lciBtZXRob2QgYCcgKyBtZXRob2ROYW1lICsgJ2Agbm90IGRlZmluZWQnKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBoYW5kbGVyO1xufVxuXG5leHBvcnQgY29uc3QgVGVtcGxhdGVTdGFtcCA9IGRlZHVwaW5nTWl4aW4oc3VwZXJDbGFzcyA9PiB7XG5cbiAgLyoqXG4gICAqIEBwb2x5bWVyXG4gICAqIEBtaXhpbkNsYXNzXG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX1RlbXBsYXRlU3RhbXB9XG4gICAqL1xuICBjbGFzcyBUZW1wbGF0ZVN0YW1wIGV4dGVuZHMgc3VwZXJDbGFzcyB7XG5cbiAgICAvKipcbiAgICAgKiBTY2FucyBhIHRlbXBsYXRlIHRvIHByb2R1Y2UgdGVtcGxhdGUgbWV0YWRhdGEuXG4gICAgICpcbiAgICAgKiBUZW1wbGF0ZS1zcGVjaWZpYyBtZXRhZGF0YSBhcmUgc3RvcmVkIGluIHRoZSBvYmplY3QgcmV0dXJuZWQsIGFuZCBub2RlLVxuICAgICAqIHNwZWNpZmljIG1ldGFkYXRhIGFyZSBzdG9yZWQgaW4gb2JqZWN0cyBpbiBpdHMgZmxhdHRlbmVkIGBub2RlSW5mb0xpc3RgXG4gICAgICogYXJyYXkuICBPbmx5IG5vZGVzIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IHdlcmUgcGFyc2VkIGFzIG5vZGVzIG9mXG4gICAgICogaW50ZXJlc3QgY29udGFpbiBhbiBvYmplY3QgaW4gYG5vZGVJbmZvTGlzdGAuICBFYWNoIGBub2RlSW5mb2Agb2JqZWN0XG4gICAgICogY29udGFpbnMgYW4gYGluZGV4YCAoYGNoaWxkTm9kZXNgIGluZGV4IGluIHBhcmVudCkgYW5kIG9wdGlvbmFsbHlcbiAgICAgKiBgcGFyZW50YCwgd2hpY2ggcG9pbnRzIHRvIG5vZGUgaW5mbyBvZiBpdHMgcGFyZW50IChpbmNsdWRpbmcgaXRzIGluZGV4KS5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBtZXRhZGF0YSBvYmplY3QgcmV0dXJuZWQgZnJvbSB0aGlzIG1ldGhvZCBoYXMgdGhlIGZvbGxvd2luZ1xuICAgICAqIHN0cnVjdHVyZSAobWFueSBmaWVsZHMgb3B0aW9uYWwpOlxuICAgICAqXG4gICAgICogYGBganNcbiAgICAgKiAgIHtcbiAgICAgKiAgICAgLy8gRmxhdHRlbmVkIGxpc3Qgb2Ygbm9kZSBtZXRhZGF0YSAoZm9yIG5vZGVzIHRoYXQgZ2VuZXJhdGVkIG1ldGFkYXRhKVxuICAgICAqICAgICBub2RlSW5mb0xpc3Q6IFtcbiAgICAgKiAgICAgICB7XG4gICAgICogICAgICAgICAvLyBgaWRgIGF0dHJpYnV0ZSBmb3IgYW55IG5vZGVzIHdpdGggaWQncyBmb3IgZ2VuZXJhdGluZyBgJGAgbWFwXG4gICAgICogICAgICAgICBpZDoge3N0cmluZ30sXG4gICAgICogICAgICAgICAvLyBgb24tZXZlbnQ9XCJoYW5kbGVyXCJgIG1ldGFkYXRhXG4gICAgICogICAgICAgICBldmVudHM6IFtcbiAgICAgKiAgICAgICAgICAge1xuICAgICAqICAgICAgICAgICAgIG5hbWU6IHtzdHJpbmd9LCAgIC8vIGV2ZW50IG5hbWVcbiAgICAgKiAgICAgICAgICAgICB2YWx1ZToge3N0cmluZ30sICAvLyBoYW5kbGVyIG1ldGhvZCBuYW1lXG4gICAgICogICAgICAgICAgIH0sIC4uLlxuICAgICAqICAgICAgICAgXSxcbiAgICAgKiAgICAgICAgIC8vIE5vdGVzIHdoZW4gdGhlIHRlbXBsYXRlIGNvbnRhaW5lZCBhIGA8c2xvdD5gIGZvciBzaGFkeSBET01cbiAgICAgKiAgICAgICAgIC8vIG9wdGltaXphdGlvbiBwdXJwb3Nlc1xuICAgICAqICAgICAgICAgaGFzSW5zZXJ0aW9uUG9pbnQ6IHtib29sZWFufSxcbiAgICAgKiAgICAgICAgIC8vIEZvciBuZXN0ZWQgYDx0ZW1wbGF0ZT5gYCBub2RlcywgbmVzdGVkIHRlbXBsYXRlIG1ldGFkYXRhXG4gICAgICogICAgICAgICB0ZW1wbGF0ZUluZm86IHtvYmplY3R9LCAvLyBuZXN0ZWQgdGVtcGxhdGUgbWV0YWRhdGFcbiAgICAgKiAgICAgICAgIC8vIE1ldGFkYXRhIHRvIGFsbG93IGVmZmljaWVudCByZXRyaWV2YWwgb2YgaW5zdGFuY2VkIG5vZGVcbiAgICAgKiAgICAgICAgIC8vIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZXRhZGF0YVxuICAgICAqICAgICAgICAgcGFyZW50SW5mbzoge251bWJlcn0sICAgLy8gcmVmZXJlbmNlIHRvIHBhcmVudCBub2RlSW5mbz5cbiAgICAgKiAgICAgICAgIHBhcmVudEluZGV4OiB7bnVtYmVyfSwgIC8vIGluZGV4IGluIHBhcmVudCdzIGBjaGlsZE5vZGVzYCBjb2xsZWN0aW9uXG4gICAgICogICAgICAgICBpbmZvSW5kZXg6IHtudW1iZXJ9LCAgICAvLyBpbmRleCBvZiB0aGlzIGBub2RlSW5mb2AgaW4gYHRlbXBsYXRlSW5mby5ub2RlSW5mb0xpc3RgXG4gICAgICogICAgICAgfSxcbiAgICAgKiAgICAgICAuLi5cbiAgICAgKiAgICAgXSxcbiAgICAgKiAgICAgLy8gV2hlbiB0cnVlLCB0aGUgdGVtcGxhdGUgaGFkIHRoZSBgc3RyaXAtd2hpdGVzcGFjZWAgYXR0cmlidXRlXG4gICAgICogICAgIC8vIG9yIHdhcyBuZXN0ZWQgaW4gYSB0ZW1wbGF0ZSB3aXRoIHRoYXQgc2V0dGluZ1xuICAgICAqICAgICBzdHJpcFdoaXRlc3BhY2U6IHtib29sZWFufSxcbiAgICAgKiAgICAgLy8gRm9yIG5lc3RlZCB0ZW1wbGF0ZXMsIG5lc3RlZCB0ZW1wbGF0ZSBjb250ZW50IGlzIG1vdmVkIGludG9cbiAgICAgKiAgICAgLy8gYSBkb2N1bWVudCBmcmFnbWVudCBzdG9yZWQgaGVyZTsgdGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gdG9cbiAgICAgKiAgICAgLy8gYXZvaWQgdGhlIGNvc3Qgb2YgbmVzdGVkIHRlbXBsYXRlIGNsb25pbmdcbiAgICAgKiAgICAgY29udGVudDoge0RvY3VtZW50RnJhZ21lbnR9XG4gICAgICogICB9XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBraWNrcyBvZmYgYSByZWN1cnNpdmUgdHJlZXdhbGsgYXMgZm9sbG93czpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqICAgIF9wYXJzZVRlbXBsYXRlIDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAgICogICAgICBfcGFyc2VUZW1wbGF0ZUNvbnRlbnQgICAgICAgICAgICAgIHxcbiAgICAgKiAgICAgICAgX3BhcnNlVGVtcGxhdGVOb2RlICA8LS0tLS0tLS0tLS0tfC0tK1xuICAgICAqICAgICAgICAgIF9wYXJzZVRlbXBsYXRlTmVzdGVkVGVtcGxhdGUgLS0rICB8XG4gICAgICogICAgICAgICAgX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzIC0tLS0tLS0tLStcbiAgICAgKiAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzXG4gICAgICogICAgICAgICAgICBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgb3ZlcnJpZGRlbiB0byBhZGQgY3VzdG9tIG1ldGFkYXRhIGFib3V0IHRlbXBsYXRlc1xuICAgICAqIHRvIGVpdGhlciBgdGVtcGxhdGVJbmZvYCBvciBgbm9kZUluZm9gLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIG1heSBiZSBkZXN0cnVjdGl2ZSB0byB0aGUgdGVtcGxhdGUsIGluIHRoYXRcbiAgICAgKiBlLmcuIGV2ZW50IGFubm90YXRpb25zIG1heSBiZSByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIHRoZVxuICAgICAqIHRlbXBsYXRlIG1ldGFkYXRhLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mbz19IG91dGVyVGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZyb20gdGhlIG91dGVyXG4gICAgICogICB0ZW1wbGF0ZSwgZm9yIHBhcnNpbmcgbmVzdGVkIHRlbXBsYXRlc1xuICAgICAqIEByZXR1cm4geyFUZW1wbGF0ZUluZm99IFBhcnNlZCB0ZW1wbGF0ZSBtZXRhZGF0YVxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgb3V0ZXJUZW1wbGF0ZUluZm8pIHtcbiAgICAgIC8vIHNpbmNlIGEgdGVtcGxhdGUgbWF5IGJlIHJlLXVzZWQsIG1lbW8taXplIG1ldGFkYXRhXG4gICAgICBpZiAoIXRlbXBsYXRlLl90ZW1wbGF0ZUluZm8pIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRlbXBsYXRlLl90ZW1wbGF0ZUluZm8gPSB7fTtcbiAgICAgICAgdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdCA9IFtdO1xuICAgICAgICB0ZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlID1cbiAgICAgICAgICAob3V0ZXJUZW1wbGF0ZUluZm8gJiYgb3V0ZXJUZW1wbGF0ZUluZm8uc3RyaXBXaGl0ZVNwYWNlKSB8fFxuICAgICAgICAgIHRlbXBsYXRlLmhhc0F0dHJpYnV0ZSgnc3RyaXAtd2hpdGVzcGFjZScpO1xuICAgICAgICB0aGlzLl9wYXJzZVRlbXBsYXRlQ29udGVudCh0ZW1wbGF0ZSwgdGVtcGxhdGVJbmZvLCB7cGFyZW50OiBudWxsfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVtcGxhdGUuX3RlbXBsYXRlSW5mbztcbiAgICB9XG5cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVDb250ZW50KHRlbXBsYXRlLCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGUodGVtcGxhdGUuY29udGVudCwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIG5vZGUgYW5kIGFkZHMgdGVtcGxhdGUgYW5kIG5vZGUgbWV0YWRhdGEgYmFzZWQgb25cbiAgICAgKiB0aGUgY3VycmVudCBub2RlLCBhbmQgaXRzIGBjaGlsZE5vZGVzYCBhbmQgYGF0dHJpYnV0ZXNgLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgbWF5IGJlIG92ZXJyaWRkZW4gdG8gYWRkIGN1c3RvbSBub2RlIG9yIHRlbXBsYXRlIHNwZWNpZmljXG4gICAgICogbWV0YWRhdGEgYmFzZWQgb24gdGhpcyBub2RlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcGFyc2VcbiAgICAgKiBAcGFyYW0geyFUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOb2RlKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGxldCBub3RlZDtcbiAgICAgIGxldCBlbGVtZW50ID0gLyoqIEB0eXBlIEVsZW1lbnQgKi8obm9kZSk7XG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT0gJ3RlbXBsYXRlJyAmJiAhZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3ByZXNlcnZlLWNvbnRlbnQnKSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdzbG90Jykge1xuICAgICAgICAvLyBGb3IgU2hhZHlEb20gb3B0aW1pemF0aW9uLCBpbmRpY2F0aW5nIHRoZXJlIGlzIGFuIGluc2VydGlvbiBwb2ludFxuICAgICAgICB0ZW1wbGF0ZUluZm8uaGFzSW5zZXJ0aW9uUG9pbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVDaGlsZE5vZGVzKGVsZW1lbnQsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHx8IG5vdGVkO1xuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlcyAmJiBlbGVtZW50Lmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgICAgICBub3RlZCA9IHRoaXMuX3BhcnNlVGVtcGxhdGVOb2RlQXR0cmlidXRlcyhlbGVtZW50LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgY2hpbGQgbm9kZXMgZm9yIHRoZSBnaXZlbiByb290IG5vZGUuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBhbHNvIHdyYXBzIHdoaXRlbGlzdGVkIGxlZ2FjeSB0ZW1wbGF0ZSBleHRlbnNpb25zXG4gICAgICogKGBpcz1cImRvbS1pZlwiYCBhbmQgYGlzPVwiZG9tLXJlcGVhdFwiYCkgd2l0aCB0aGVpciBlcXVpdmFsZW50IGVsZW1lbnRcbiAgICAgKiB3cmFwcGVycywgY29sbGFwc2VzIHRleHQgbm9kZXMsIGFuZCBzdHJpcHMgd2hpdGVzcGFjZSBmcm9tIHRoZSB0ZW1wbGF0ZVxuICAgICAqIGlmIHRoZSBgdGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVzcGFjZWAgc2V0dGluZyB3YXMgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IHJvb3QgUm9vdCBub2RlIHdob3NlIGBjaGlsZE5vZGVzYCB3aWxsIGJlIHBhcnNlZFxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICovXG4gICAgc3RhdGljIF9wYXJzZVRlbXBsYXRlQ2hpbGROb2Rlcyhyb290LCB0ZW1wbGF0ZUluZm8sIG5vZGVJbmZvKSB7XG4gICAgICBmb3IgKGxldCBub2RlPXJvb3QuZmlyc3RDaGlsZCwgcGFyZW50SW5kZXg9MCwgbmV4dDsgbm9kZTsgbm9kZT1uZXh0KSB7XG4gICAgICAgIC8vIFdyYXAgdGVtcGxhdGVzXG4gICAgICAgIGlmIChub2RlLmxvY2FsTmFtZSA9PSAndGVtcGxhdGUnKSB7XG4gICAgICAgICAgbm9kZSA9IHdyYXBUZW1wbGF0ZUV4dGVuc2lvbihub2RlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb2xsYXBzZSBhZGphY2VudCB0ZXh0Tm9kZXM6IGZpeGVzIGFuIElFIGlzc3VlIHRoYXQgY2FuIGNhdXNlXG4gICAgICAgIC8vIHRleHQgbm9kZXMgdG8gYmUgaW5leHBsaWNhYmx5IHNwbGl0ID0oXG4gICAgICAgIC8vIG5vdGUgdGhhdCByb290Lm5vcm1hbGl6ZSgpIHNob3VsZCB3b3JrIGJ1dCBkb2VzIG5vdCBzbyB3ZSBkbyB0aGlzXG4gICAgICAgIC8vIG1hbnVhbGx5LlxuICAgICAgICBuZXh0ID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgbGV0IC8qKiBOb2RlICovIG4gPSBuZXh0O1xuICAgICAgICAgIHdoaWxlIChuICYmIChuLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkpIHtcbiAgICAgICAgICAgIG5vZGUudGV4dENvbnRlbnQgKz0gbi50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIG5leHQgPSBuLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgcm9vdC5yZW1vdmVDaGlsZChuKTtcbiAgICAgICAgICAgIG4gPSBuZXh0O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBvcHRpb25hbGx5IHN0cmlwIHdoaXRlc3BhY2VcbiAgICAgICAgICBpZiAodGVtcGxhdGVJbmZvLnN0cmlwV2hpdGVTcGFjZSAmJiAhbm9kZS50ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgIHJvb3QucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNoaWxkSW5mbyA9IHsgcGFyZW50SW5kZXgsIHBhcmVudEluZm86IG5vZGVJbmZvIH07XG4gICAgICAgIGlmICh0aGlzLl9wYXJzZVRlbXBsYXRlTm9kZShub2RlLCB0ZW1wbGF0ZUluZm8sIGNoaWxkSW5mbykpIHtcbiAgICAgICAgICBjaGlsZEluZm8uaW5mb0luZGV4ID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdC5wdXNoKC8qKiBAdHlwZSB7IU5vZGVJbmZvfSAqLyhjaGlsZEluZm8pKSAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5jcmVtZW50IGlmIG5vdCByZW1vdmVkXG4gICAgICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICBwYXJlbnRJbmRleCsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGFyc2VzIHRlbXBsYXRlIGNvbnRlbnQgZm9yIHRoZSBnaXZlbiBuZXN0ZWQgYDx0ZW1wbGF0ZT5gLlxuICAgICAqXG4gICAgICogTmVzdGVkIHRlbXBsYXRlIGluZm8gaXMgc3RvcmVkIGFzIGB0ZW1wbGF0ZUluZm9gIGluIHRoZSBjdXJyZW50IG5vZGUnc1xuICAgICAqIGBub2RlSW5mb2AuIGB0ZW1wbGF0ZS5jb250ZW50YCBpcyByZW1vdmVkIGFuZCBzdG9yZWQgaW4gYHRlbXBsYXRlSW5mb2AuXG4gICAgICogSXQgd2lsbCB0aGVuIGJlIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgaG9zdCB0byBzZXQgaXQgYmFjayB0byB0aGVcbiAgICAgKiB0ZW1wbGF0ZSBhbmQgZm9yIHVzZXJzIHN0YW1waW5nIG5lc3RlZCB0ZW1wbGF0ZXMgdG8gdXNlIHRoZVxuICAgICAqIGBfY29udGVudEZvclRlbXBsYXRlYCBtZXRob2QgdG8gcmV0cmlldmUgdGhlIGNvbnRlbnQgZm9yIHRoaXMgdGVtcGxhdGVcbiAgICAgKiAoYW4gb3B0aW1pemF0aW9uIHRvIGF2b2lkIHRoZSBjb3N0IG9mIGNsb25pbmcgbmVzdGVkIHRlbXBsYXRlIGNvbnRlbnQpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSBub2RlIE5vZGUgdG8gcGFyc2UgKGEgPHRlbXBsYXRlPilcbiAgICAgKiBAcGFyYW0ge1RlbXBsYXRlSW5mb30gb3V0ZXJUZW1wbGF0ZUluZm8gVGVtcGxhdGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGVcbiAgICAgKiAgIHRoYXQgaW5jbHVkZXMgdGhlIHRlbXBsYXRlIGBub2RlYFxuICAgICAqIEBwYXJhbSB7IU5vZGVJbmZvfSBub2RlSW5mbyBOb2RlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlLlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgdmlzaXRlZCBub2RlIGFkZGVkIG5vZGUtc3BlY2lmaWNcbiAgICAgKiAgIG1ldGFkYXRhIHRvIGBub2RlSW5mb2BcbiAgICAgKi9cbiAgICBzdGF0aWMgX3BhcnNlVGVtcGxhdGVOZXN0ZWRUZW1wbGF0ZShub2RlLCBvdXRlclRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIGxldCB0ZW1wbGF0ZUluZm8gPSB0aGlzLl9wYXJzZVRlbXBsYXRlKG5vZGUsIG91dGVyVGVtcGxhdGVJbmZvKTtcbiAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgPVxuICAgICAgICBub2RlLmNvbnRlbnQub3duZXJEb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgICBjb250ZW50LmFwcGVuZENoaWxkKG5vZGUuY29udGVudCk7XG4gICAgICBub2RlSW5mby50ZW1wbGF0ZUluZm8gPSB0ZW1wbGF0ZUluZm87XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgdGVtcGxhdGUgbm9kZSBhdHRyaWJ1dGVzIGFuZCBhZGRzIG5vZGUgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqIGZvciBub2RlcyBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZSBOb2RlIHRvIHBhcnNlXG4gICAgICogQHBhcmFtIHtUZW1wbGF0ZUluZm99IHRlbXBsYXRlSW5mbyBUZW1wbGF0ZSBtZXRhZGF0YSBmb3IgY3VycmVudCB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7Tm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGVzKG5vZGUsIHRlbXBsYXRlSW5mbywgbm9kZUluZm8pIHtcbiAgICAgIC8vIE1ha2UgY29weSBvZiBvcmlnaW5hbCBhdHRyaWJ1dGUgbGlzdCwgc2luY2UgdGhlIG9yZGVyIG1heSBjaGFuZ2VcbiAgICAgIC8vIGFzIGF0dHJpYnV0ZXMgYXJlIGFkZGVkIGFuZCByZW1vdmVkXG4gICAgICBsZXQgbm90ZWQgPSBmYWxzZTtcbiAgICAgIGxldCBhdHRycyA9IEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKTtcbiAgICAgIGZvciAobGV0IGk9YXR0cnMubGVuZ3RoLTEsIGE7IChhPWF0dHJzW2ldKTsgaS0tKSB7XG4gICAgICAgIG5vdGVkID0gdGhpcy5fcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgYS5uYW1lLCBhLnZhbHVlKSB8fCBub3RlZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3RlZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZXMgYSBzaW5nbGUgdGVtcGxhdGUgbm9kZSBhdHRyaWJ1dGUgYW5kIGFkZHMgbm9kZSBtZXRhZGF0YSB0b1xuICAgICAqIGBub2RlSW5mb2AgZm9yIGF0dHJpYnV0ZXMgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGltcGxlbWVudGF0aW9uIGFkZHMgbWV0YWRhdGEgZm9yIGBvbi1ldmVudD1cImhhbmRsZXJcImAgYXR0cmlidXRlc1xuICAgICAqIGFuZCBgaWRgIGF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGUgTm9kZSB0byBwYXJzZVxuICAgICAqIEBwYXJhbSB7IVRlbXBsYXRlSW5mb30gdGVtcGxhdGVJbmZvIFRlbXBsYXRlIG1ldGFkYXRhIGZvciBjdXJyZW50IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHshTm9kZUluZm99IG5vZGVJbmZvIE5vZGUgbWV0YWRhdGEgZm9yIGN1cnJlbnQgdGVtcGxhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHRoZSB2aXNpdGVkIG5vZGUgYWRkZWQgbm9kZS1zcGVjaWZpY1xuICAgICAqICAgbWV0YWRhdGEgdG8gYG5vZGVJbmZvYFxuICAgICAqL1xuICAgIHN0YXRpYyBfcGFyc2VUZW1wbGF0ZU5vZGVBdHRyaWJ1dGUobm9kZSwgdGVtcGxhdGVJbmZvLCBub2RlSW5mbywgbmFtZSwgdmFsdWUpIHtcbiAgICAgIC8vIGV2ZW50cyAob24tKilcbiAgICAgIGlmIChuYW1lLnNsaWNlKDAsIDMpID09PSAnb24tJykge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgbm9kZUluZm8uZXZlbnRzID0gbm9kZUluZm8uZXZlbnRzIHx8IFtdO1xuICAgICAgICBub2RlSW5mby5ldmVudHMucHVzaCh7XG4gICAgICAgICAgbmFtZTogbmFtZS5zbGljZSgzKSxcbiAgICAgICAgICB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICAvLyBzdGF0aWMgaWRcbiAgICAgIGVsc2UgaWYgKG5hbWUgPT09ICdpZCcpIHtcbiAgICAgICAgbm9kZUluZm8uaWQgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYGNvbnRlbnRgIGRvY3VtZW50IGZyYWdtZW50IGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogRm9yIG5lc3RlZCB0ZW1wbGF0ZXMsIFBvbHltZXIgcGVyZm9ybXMgYW4gb3B0aW1pemF0aW9uIHRvIGNhY2hlIG5lc3RlZFxuICAgICAqIHRlbXBsYXRlIGNvbnRlbnQgdG8gYXZvaWQgdGhlIGNvc3Qgb2YgY2xvbmluZyBkZWVwbHkgbmVzdGVkIHRlbXBsYXRlcy5cbiAgICAgKiBUaGlzIG1ldGhvZCByZXRyaWV2ZXMgdGhlIGNhY2hlZCBjb250ZW50IGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byByZXRyaWV2ZSBgY29udGVudGAgZm9yXG4gICAgICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH0gQ29udGVudCBmcmFnbWVudFxuICAgICAqL1xuICAgIHN0YXRpYyBfY29udGVudEZvclRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICBsZXQgdGVtcGxhdGVJbmZvID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50V2l0aEluZm99ICovICh0ZW1wbGF0ZSkuX3RlbXBsYXRlSW5mbztcbiAgICAgIHJldHVybiAodGVtcGxhdGVJbmZvICYmIHRlbXBsYXRlSW5mby5jb250ZW50KSB8fCB0ZW1wbGF0ZS5jb250ZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsb25lcyB0aGUgcHJvdmlkZWQgdGVtcGxhdGUgY29udGVudCBhbmQgcmV0dXJucyBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICogY29udGFpbmluZyB0aGUgY2xvbmVkIGRvbS5cbiAgICAgKlxuICAgICAqIFRoZSB0ZW1wbGF0ZSBpcyBwYXJzZWQgKG9uY2UgYW5kIG1lbW9pemVkKSB1c2luZyB0aGlzIGxpYnJhcnknc1xuICAgICAqIHRlbXBsYXRlIHBhcnNpbmcgZmVhdHVyZXMsIGFuZCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIHZhbHVlLWFkZGVkXG4gICAgICogZmVhdHVyZXM6XG4gICAgICogKiBBZGRzIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBmb3IgYG9uLWV2ZW50PVwiaGFuZGxlclwiYCBhdHRyaWJ1dGVzXG4gICAgICogKiBHZW5lcmF0ZXMgYW4gXCJpZCBtYXBcIiBmb3IgYWxsIG5vZGVzIHdpdGggaWQncyB1bmRlciBgJGAgb24gcmV0dXJuZWRcbiAgICAgKiAgIGRvY3VtZW50IGZyYWdtZW50XG4gICAgICogKiBQYXNzZXMgdGVtcGxhdGUgaW5mbyBpbmNsdWRpbmcgYGNvbnRlbnRgIGJhY2sgdG8gdGVtcGxhdGVzIGFzXG4gICAgICogICBgX3RlbXBsYXRlSW5mb2AgKGEgcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uIHRvIGF2b2lkIGRlZXAgdGVtcGxhdGVcbiAgICAgKiAgIGNsb25pbmcpXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhlIG1lbW9pemVkIHRlbXBsYXRlIHBhcnNpbmcgcHJvY2VzcyBpcyBkZXN0cnVjdGl2ZSB0byB0aGVcbiAgICAgKiB0ZW1wbGF0ZTogYXR0cmlidXRlcyBmb3IgYmluZGluZ3MgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycyBhcmVcbiAgICAgKiByZW1vdmVkIGFmdGVyIGJlaW5nIG5vdGVkIGluIG5vdGVzLCBhbmQgYW55IG5lc3RlZCBgPHRlbXBsYXRlPi5jb250ZW50YFxuICAgICAqIGlzIHJlbW92ZWQgYW5kIHN0b3JlZCBpbiBub3RlcyBhcyB3ZWxsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGUgVGVtcGxhdGUgdG8gc3RhbXBcbiAgICAgKiBAcmV0dXJuIHshU3RhbXBlZFRlbXBsYXRlfSBDbG9uZWQgdGVtcGxhdGUgY29udGVudFxuICAgICAqL1xuICAgIF9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAvLyBQb2x5ZmlsbCBzdXBwb3J0OiBib290c3RyYXAgdGhlIHRlbXBsYXRlIGlmIGl0IGhhcyBub3QgYWxyZWFkeSBiZWVuXG4gICAgICBpZiAodGVtcGxhdGUgJiYgIXRlbXBsYXRlLmNvbnRlbnQgJiZcbiAgICAgICAgICB3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudCAmJiBIVE1MVGVtcGxhdGVFbGVtZW50LmRlY29yYXRlKSB7XG4gICAgICAgIEhUTUxUZW1wbGF0ZUVsZW1lbnQuZGVjb3JhdGUodGVtcGxhdGUpO1xuICAgICAgfVxuICAgICAgbGV0IHRlbXBsYXRlSW5mbyA9IHRoaXMuY29uc3RydWN0b3IuX3BhcnNlVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgbGV0IG5vZGVJbmZvID0gdGVtcGxhdGVJbmZvLm5vZGVJbmZvTGlzdDtcbiAgICAgIGxldCBjb250ZW50ID0gdGVtcGxhdGVJbmZvLmNvbnRlbnQgfHwgdGVtcGxhdGUuY29udGVudDtcbiAgICAgIGxldCBkb20gPSAvKiogQHR5cGUgRG9jdW1lbnRGcmFnbWVudCAqLyAoZG9jdW1lbnQuaW1wb3J0Tm9kZShjb250ZW50LCB0cnVlKSk7XG4gICAgICAvLyBOT1RFOiBTaGFkeURvbSBvcHRpbWl6YXRpb24gaW5kaWNhdGluZyB0aGVyZSBpcyBhbiBpbnNlcnRpb24gcG9pbnRcbiAgICAgIGRvbS5fX25vSW5zZXJ0aW9uUG9pbnQgPSAhdGVtcGxhdGVJbmZvLmhhc0luc2VydGlvblBvaW50O1xuICAgICAgbGV0IG5vZGVzID0gZG9tLm5vZGVMaXN0ID0gbmV3IEFycmF5KG5vZGVJbmZvLmxlbmd0aCk7XG4gICAgICBkb20uJCA9IHt9O1xuICAgICAgZm9yIChsZXQgaT0wLCBsPW5vZGVJbmZvLmxlbmd0aCwgaW5mbzsgKGk8bCkgJiYgKGluZm89bm9kZUluZm9baV0pOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBub2Rlc1tpXSA9IGZpbmRUZW1wbGF0ZU5vZGUoZG9tLCBpbmZvKTtcbiAgICAgICAgYXBwbHlJZFRvTWFwKHRoaXMsIGRvbS4kLCBub2RlLCBpbmZvKTtcbiAgICAgICAgYXBwbHlUZW1wbGF0ZUNvbnRlbnQodGhpcywgbm9kZSwgaW5mbyk7XG4gICAgICAgIGFwcGx5RXZlbnRMaXN0ZW5lcih0aGlzLCBub2RlLCBpbmZvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiogQHR5cGUgeyFTdGFtcGVkVGVtcGxhdGV9ICovKGRvbSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbiBldmVudCBsaXN0ZW5lciBieSBtZXRob2QgbmFtZSBmb3IgdGhlIGV2ZW50IHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZ2VuZXJhdGVzIGEgaGFuZGxlciBmdW5jdGlvbiB0aGF0IGxvb2tzIHVwIHRoZSBtZXRob2RcbiAgICAgKiBuYW1lIGF0IGhhbmRsaW5nIHRpbWUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBhZGQgbGlzdGVuZXIgb25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lIE5hbWUgb2YgZXZlbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBOYW1lIG9mIG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Kj19IGNvbnRleHQgQ29udGV4dCB0aGUgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIG9uIChkZWZhdWx0c1xuICAgICAqICAgdG8gYG5vZGVgKVxuICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBHZW5lcmF0ZWQgaGFuZGxlciBmdW5jdGlvblxuICAgICAqL1xuICAgIF9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgbWV0aG9kTmFtZSwgY29udGV4dCkge1xuICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbm9kZTtcbiAgICAgIGxldCBoYW5kbGVyID0gY3JlYXRlTm9kZUV2ZW50SGFuZGxlcihjb250ZXh0LCBldmVudE5hbWUsIG1ldGhvZE5hbWUpO1xuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGUgcG9pbnQgZm9yIGFkZGluZyBjdXN0b20gb3Igc2ltdWxhdGVkIGV2ZW50IGhhbmRsaW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gYWRkIGV2ZW50IGxpc3RlbmVyIHRvXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBMaXN0ZW5lciBmdW5jdGlvbiB0byBhZGRcbiAgICAgKi9cbiAgICBfYWRkRXZlbnRMaXN0ZW5lclRvTm9kZShub2RlLCBldmVudE5hbWUsIGhhbmRsZXIpIHtcbiAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlIHBvaW50IGZvciBhZGRpbmcgY3VzdG9tIG9yIHNpbXVsYXRlZCBldmVudCBoYW5kbGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHJlbW92ZSBldmVudCBsaXN0ZW5lciBmcm9tXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSBOYW1lIG9mIGV2ZW50XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBMaXN0ZW5lciBmdW5jdGlvbiB0byByZW1vdmVcbiAgICAgKi9cbiAgICBfcmVtb3ZlRXZlbnRMaXN0ZW5lckZyb21Ob2RlKG5vZGUsIGV2ZW50TmFtZSwgaGFuZGxlcikge1xuICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgaGFuZGxlcik7XG4gICAgfVxuXG4gIH1cblxuICByZXR1cm4gVGVtcGxhdGVTdGFtcDtcblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9taXhpbnMvdGVtcGxhdGUtc3RhbXAuanNcbi8vIG1vZHVsZSBpZCA9IDU0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IE5lb25BbmltYXRpb25SdW5uZXJCZWhhdmlvciB9IGZyb20gJy4uL25lb24tYW5pbWF0aW9uL25lb24tYW5pbWF0aW9uLXJ1bm5lci1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBQYXBlckRpYWxvZ0JlaGF2aW9yIH0gZnJvbSAnLi4vcGFwZXItZGlhbG9nLWJlaGF2aW9yL3BhcGVyLWRpYWxvZy1iZWhhdmlvci5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLWRpYWxvZy1iZWhhdmlvci9wYXBlci1kaWFsb2ctc2hhcmVkLXN0eWxlcy5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlIGluY2x1ZGU9XCJwYXBlci1kaWFsb2ctc2hhcmVkLXN0eWxlc1wiPjwvc3R5bGU+XG4gICAgPHNsb3Q+PC9zbG90PlxuYCxcblxuICBpczogJ3BhcGVyLWRpYWxvZycsXG5cbiAgYmVoYXZpb3JzOiBbXG4gICAgUGFwZXJEaWFsb2dCZWhhdmlvcixcbiAgICBOZW9uQW5pbWF0aW9uUnVubmVyQmVoYXZpb3JcbiAgXSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICAnbmVvbi1hbmltYXRpb24tZmluaXNoJzogJ19vbk5lb25BbmltYXRpb25GaW5pc2gnXG4gIH0sXG5cbiAgX3JlbmRlck9wZW5lZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICB0aGlzLnBsYXlBbmltYXRpb24oJ2VudHJ5Jyk7XG4gIH0sXG5cbiAgX3JlbmRlckNsb3NlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jYW5jZWxBbmltYXRpb24oKTtcbiAgICB0aGlzLnBsYXlBbmltYXRpb24oJ2V4aXQnKTtcbiAgfSxcblxuICBfb25OZW9uQW5pbWF0aW9uRmluaXNoOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgIHRoaXMuX2ZpbmlzaFJlbmRlck9wZW5lZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9maW5pc2hSZW5kZXJDbG9zZWQoKTtcbiAgICB9XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItZGlhbG9nL3BhcGVyLWRpYWxvZy5qc1xuLy8gbW9kdWxlIGlkID0gNTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQgQXBwbHlTaGltIGZyb20gJy4uL3NyYy9hcHBseS1zaGltLmpzJztcbmltcG9ydCB0ZW1wbGF0ZU1hcCBmcm9tICcuLi9zcmMvdGVtcGxhdGUtbWFwLmpzJztcbmltcG9ydCB7Z2V0SXNFeHRlbmRzLCB0b0Nzc1RleHR9IGZyb20gJy4uL3NyYy9zdHlsZS11dGlsLmpzJztcbmltcG9ydCAqIGFzIEFwcGx5U2hpbVV0aWxzIGZyb20gJy4uL3NyYy9hcHBseS1zaGltLXV0aWxzLmpzJztcbmltcG9ydCBkb2N1bWVudFdhaXQgZnJvbSAnLi4vc3JjL2RvY3VtZW50LXdhaXQuanMnO1xuaW1wb3J0IHtnZXRDb21wdXRlZFN0eWxlVmFsdWUsIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXN9IGZyb20gJy4uL3NyYy9jb21tb24tdXRpbHMuanMnO1xuaW1wb3J0IHtDdXN0b21TdHlsZUludGVyZmFjZUludGVyZmFjZX0gZnJvbSAnLi4vc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5pbXBvcnQge25hdGl2ZUNzc1ZhcmlhYmxlcywgbmF0aXZlU2hhZG93fSBmcm9tICcuLi9zcmMvc3R5bGUtc2V0dGluZ3MuanMnO1xuXG4vKiogQGNvbnN0IHtBcHBseVNoaW19ICovXG5jb25zdCBhcHBseVNoaW0gPSBuZXcgQXBwbHlTaGltKCk7XG5cbmNsYXNzIEFwcGx5U2hpbUludGVyZmFjZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7P0N1c3RvbVN0eWxlSW50ZXJmYWNlSW50ZXJmYWNlfSAqL1xuICAgIHRoaXMuY3VzdG9tU3R5bGVJbnRlcmZhY2UgPSBudWxsO1xuICAgIGRvY3VtZW50V2FpdCgoKSA9PiB7XG4gICAgICB0aGlzLmVuc3VyZSgpO1xuICAgIH0pO1xuICAgIGFwcGx5U2hpbVsnaW52YWxpZENhbGxiYWNrJ10gPSBBcHBseVNoaW1VdGlscy5pbnZhbGlkYXRlO1xuICB9XG4gIGVuc3VyZSgpIHtcbiAgICBpZiAodGhpcy5jdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlID0gd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuICAgIGlmICh0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlKSB7XG4gICAgICB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWyd0cmFuc2Zvcm1DYWxsYmFjayddID0gKHN0eWxlKSA9PiB7XG4gICAgICAgIGFwcGx5U2hpbS50cmFuc2Zvcm1DdXN0b21TdHlsZShzdHlsZSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsndmFsaWRhdGVDYWxsYmFjayddID0gKCkgPT4ge1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWydlbnF1ZXVlZCddKSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgKi9cbiAgcHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSkge1xuICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdID0gdGVtcGxhdGU7XG4gICAgbGV0IGFzdCA9IGFwcGx5U2hpbS50cmFuc2Zvcm1UZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUpO1xuICAgIC8vIHNhdmUgb3JpZ2luYWwgc3R5bGUgYXN0IHRvIHVzZSBmb3IgcmV2YWxpZGF0aW5nIGluc3RhbmNlc1xuICAgIHRlbXBsYXRlWydfc3R5bGVBc3QnXSA9IGFzdDtcbiAgfVxuICBmbHVzaEN1c3RvbVN0eWxlcygpIHtcbiAgICB0aGlzLmVuc3VyZSgpO1xuICAgIGlmICghdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc3R5bGVzID0gdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsncHJvY2Vzc1N0eWxlcyddKCk7XG4gICAgaWYgKCF0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWydlbnF1ZXVlZCddKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrICkge1xuICAgICAgbGV0IGNzID0gc3R5bGVzW2ldO1xuICAgICAgbGV0IHN0eWxlID0gdGhpcy5jdXN0b21TdHlsZUludGVyZmFjZVsnZ2V0U3R5bGVGb3JDdXN0b21TdHlsZSddKGNzKTtcbiAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICBhcHBseVNoaW0udHJhbnNmb3JtQ3VzdG9tU3R5bGUoc3R5bGUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmN1c3RvbVN0eWxlSW50ZXJmYWNlWydlbnF1ZXVlZCddID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAqL1xuICBzdHlsZVN1YnRyZWUoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgIHRoaXMuZW5zdXJlKCk7XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnNoYWRvd1Jvb3QpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgbGV0IHNoYWRvd0NoaWxkcmVuID0gZWxlbWVudC5zaGFkb3dSb290LmNoaWxkcmVuIHx8IGVsZW1lbnQuc2hhZG93Um9vdC5jaGlsZE5vZGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaGFkb3dDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnN0eWxlU3VidHJlZSgvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhzaGFkb3dDaGlsZHJlbltpXSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgY2hpbGRyZW4gPSBlbGVtZW50LmNoaWxkcmVuIHx8IGVsZW1lbnQuY2hpbGROb2RlcztcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5zdHlsZVN1YnRyZWUoLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8oY2hpbGRyZW5baV0pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICovXG4gIHN0eWxlRWxlbWVudChlbGVtZW50KSB7XG4gICAgdGhpcy5lbnN1cmUoKTtcbiAgICBsZXQge2lzfSA9IGdldElzRXh0ZW5kcyhlbGVtZW50KTtcbiAgICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtpc107XG4gICAgaWYgKHRlbXBsYXRlICYmICFBcHBseVNoaW1VdGlscy50ZW1wbGF0ZUlzVmFsaWQodGVtcGxhdGUpKSB7XG4gICAgICAvLyBvbmx5IHJldmFsaWRhdGUgdGVtcGxhdGUgb25jZVxuICAgICAgaWYgKCFBcHBseVNoaW1VdGlscy50ZW1wbGF0ZUlzVmFsaWRhdGluZyh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgdGhpcy5wcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGlzKTtcbiAgICAgICAgQXBwbHlTaGltVXRpbHMuc3RhcnRWYWxpZGF0aW5nVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgfVxuICAgICAgLy8gdXBkYXRlIHRoaXMgZWxlbWVudCBpbnN0YW5jZVxuICAgICAgbGV0IHJvb3QgPSBlbGVtZW50LnNoYWRvd1Jvb3Q7XG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICBsZXQgc3R5bGUgPSAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovKHJvb3QucXVlcnlTZWxlY3Rvcignc3R5bGUnKSk7XG4gICAgICAgIGlmIChzdHlsZSkge1xuICAgICAgICAgIC8vIHJldXNlIHRoZSB0ZW1wbGF0ZSdzIHN0eWxlIGFzdCwgaXQgaGFzIGFsbCB0aGUgb3JpZ2luYWwgY3NzIHRleHRcbiAgICAgICAgICBzdHlsZVsnX19jc3NSdWxlcyddID0gdGVtcGxhdGVbJ19zdHlsZUFzdCddO1xuICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdG9Dc3NUZXh0KHRlbXBsYXRlWydfc3R5bGVBc3QnXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAqL1xuICBzdHlsZURvY3VtZW50KHByb3BlcnRpZXMpIHtcbiAgICB0aGlzLmVuc3VyZSgpO1xuICAgIHRoaXMuc3R5bGVTdWJ0cmVlKGRvY3VtZW50LmJvZHksIHByb3BlcnRpZXMpO1xuICB9XG59XG5cbmlmICghd2luZG93LlNoYWR5Q1NTIHx8ICF3aW5kb3cuU2hhZHlDU1MuU2NvcGluZ1NoaW0pIHtcbiAgY29uc3QgYXBwbHlTaGltSW50ZXJmYWNlID0gbmV3IEFwcGx5U2hpbUludGVyZmFjZSgpO1xuICBsZXQgQ3VzdG9tU3R5bGVJbnRlcmZhY2UgPSB3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuXG4gIHdpbmRvdy5TaGFkeUNTUyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nPX0gZWxlbWVudEV4dGVuZHNcbiAgICAgKi9cbiAgICBwcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lLCBlbGVtZW50RXh0ZW5kcykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2UuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5wcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lKVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgICAqL1xuICAgIHN0eWxlU3VidHJlZShlbGVtZW50LCBwcm9wZXJ0aWVzKSB7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2UuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5zdHlsZVN1YnRyZWUoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAgICovXG4gICAgc3R5bGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgICAgYXBwbHlTaGltSW50ZXJmYWNlLnN0eWxlRWxlbWVudChlbGVtZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc3R5bGVEb2N1bWVudChwcm9wZXJ0aWVzKSB7XG4gICAgICBhcHBseVNoaW1JbnRlcmZhY2UuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgIGFwcGx5U2hpbUludGVyZmFjZS5zdHlsZURvY3VtZW50KHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgICB9LFxuICAgIG5hdGl2ZUNzczogbmF0aXZlQ3NzVmFyaWFibGVzLFxuICAgIG5hdGl2ZVNoYWRvdzogbmF0aXZlU2hhZG93XG4gIH07XG5cbiAgaWYgKEN1c3RvbVN0eWxlSW50ZXJmYWNlKSB7XG4gICAgd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlID0gQ3VzdG9tU3R5bGVJbnRlcmZhY2U7XG4gIH1cbn1cblxud2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbSA9IGFwcGx5U2hpbTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9lbnRyeXBvaW50cy9hcHBseS1zaGltLmpzXG4vLyBtb2R1bGUgaWQgPSA1NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuLypcbiAqIFRoZSBhcHBseSBzaGltIHNpbXVsYXRlcyB0aGUgYmVoYXZpb3Igb2YgYEBhcHBseWAgcHJvcG9zZWQgYXRcbiAqIGh0dHBzOi8vdGFiYXRraW5zLmdpdGh1Yi5pby9zcGVjcy9jc3MtYXBwbHktcnVsZS8uXG4gKiBUaGUgYXBwcm9hY2ggaXMgdG8gY29udmVydCBhIHByb3BlcnR5IGxpa2UgdGhpczpcbiAqXG4gKiAgICAtLWZvbzoge2NvbG9yOiByZWQ7IGJhY2tncm91bmQ6IGJsdWU7fVxuICpcbiAqIHRvIHRoaXM6XG4gKlxuICogICAgLS1mb29fLV9jb2xvcjogcmVkO1xuICogICAgLS1mb29fLV9iYWNrZ3JvdW5kOiBibHVlO1xuICpcbiAqIFRoZW4gd2hlcmUgYEBhcHBseSAtLWZvb2AgaXMgdXNlZCwgdGhhdCBpcyBjb252ZXJ0ZWQgdG86XG4gKlxuICogICAgY29sb3I6IHZhcigtLWZvb18tX2NvbG9yKTtcbiAqICAgIGJhY2tncm91bmQ6IHZhcigtLWZvb18tX2JhY2tncm91bmQpO1xuICpcbiAqIFRoaXMgYXBwcm9hY2ggZ2VuZXJhbGx5IHdvcmtzIGJ1dCB0aGVyZSBhcmUgc29tZSBpc3N1ZXMgYW5kIGxpbWl0YXRpb25zLlxuICogQ29uc2lkZXIsIGZvciBleGFtcGxlLCB0aGF0IHNvbWV3aGVyZSAqYmV0d2Vlbiogd2hlcmUgYC0tZm9vYCBpcyBzZXQgYW5kIHVzZWQsXG4gKiBhbm90aGVyIGVsZW1lbnQgc2V0cyBpdCB0bzpcbiAqXG4gKiAgICAtLWZvbzogeyBib3JkZXI6IDJweCBzb2xpZCByZWQ7IH1cbiAqXG4gKiBXZSBtdXN0IG5vdyBlbnN1cmUgdGhhdCB0aGUgY29sb3IgYW5kIGJhY2tncm91bmQgZnJvbSB0aGUgcHJldmlvdXMgc2V0dGluZ1xuICogZG8gbm90IGFwcGx5LiBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSBjaGFuZ2luZyB0aGUgcHJvcGVydHkgc2V0IHRvIHRoaXM6XG4gKlxuICogICAgLS1mb29fLV9ib3JkZXI6IDJweCBzb2xpZCByZWQ7XG4gKiAgICAtLWZvb18tX2NvbG9yOiBpbml0aWFsO1xuICogICAgLS1mb29fLV9iYWNrZ3JvdW5kOiBpbml0aWFsO1xuICpcbiAqIFRoaXMgd29ya3MgYnV0IGludHJvZHVjZXMgb25lIG5ldyBpc3N1ZS5cbiAqIENvbnNpZGVyIHRoaXMgc2V0dXAgYXQgdGhlIHBvaW50IHdoZXJlIHRoZSBgQGFwcGx5YCBpcyB1c2VkOlxuICpcbiAqICAgIGJhY2tncm91bmQ6IG9yYW5nZTtcbiAqICAgIGBAYXBwbHlgIC0tZm9vO1xuICpcbiAqIEluIHRoaXMgY2FzZSB0aGUgYmFja2dyb3VuZCB3aWxsIGJlIHVuc2V0IChpbml0aWFsKSByYXRoZXIgdGhhbiB0aGUgZGVzaXJlZFxuICogYG9yYW5nZWAuIFdlIGFkZHJlc3MgdGhpcyBieSBhbHRlcmluZyB0aGUgcHJvcGVydHkgc2V0IHRvIHVzZSBhIGZhbGxiYWNrXG4gKiB2YWx1ZSBsaWtlIHRoaXM6XG4gKlxuICogICAgY29sb3I6IHZhcigtLWZvb18tX2NvbG9yKTtcbiAqICAgIGJhY2tncm91bmQ6IHZhcigtLWZvb18tX2JhY2tncm91bmQsIG9yYW5nZSk7XG4gKiAgICBib3JkZXI6IHZhcigtLWZvb18tX2JvcmRlcik7XG4gKlxuICogTm90ZSB0aGF0IHRoZSBkZWZhdWx0IGlzIHJldGFpbmVkIGluIHRoZSBwcm9wZXJ0eSBzZXQgYW5kIHRoZSBgYmFja2dyb3VuZGAgaXNcbiAqIHRoZSBkZXNpcmVkIGBvcmFuZ2VgLiBUaGlzIGxlYWRzIHVzIHRvIGEgbGltaXRhdGlvbi5cbiAqXG4gKiBMaW1pdGF0aW9uIDE6XG5cbiAqIE9ubHkgcHJvcGVydGllcyBpbiB0aGUgcnVsZSB3aGVyZSB0aGUgYEBhcHBseWBcbiAqIGlzIHVzZWQgYXJlIGNvbnNpZGVyZWQgYXMgZGVmYXVsdCB2YWx1ZXMuXG4gKiBJZiBhbm90aGVyIHJ1bGUgbWF0Y2hlcyB0aGUgZWxlbWVudCBhbmQgc2V0cyBgYmFja2dyb3VuZGAgd2l0aFxuICogbGVzcyBzcGVjaWZpY2l0eSB0aGFuIHRoZSBydWxlIGluIHdoaWNoIGBAYXBwbHlgIGFwcGVhcnMsXG4gKiB0aGUgYGJhY2tncm91bmRgIHdpbGwgbm90IGJlIHNldC5cbiAqXG4gKiBMaW1pdGF0aW9uIDI6XG4gKlxuICogV2hlbiB1c2luZyBQb2x5bWVyJ3MgYHVwZGF0ZVN0eWxlc2AgYXBpLCBuZXcgcHJvcGVydGllcyBtYXkgbm90IGJlIHNldCBmb3JcbiAqIGBAYXBwbHlgIHByb3BlcnRpZXMuXG5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtmb3JFYWNoUnVsZSwgcHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2ssIHJ1bGVzRm9yU3R5bGUsIHRvQ3NzVGV4dCwgZ2F0aGVyU3R5bGVUZXh0fSBmcm9tICcuL3N0eWxlLXV0aWwuanMnO1xuaW1wb3J0IHtNSVhJTl9NQVRDSCwgVkFSX0FTU0lHTn0gZnJvbSAnLi9jb21tb24tcmVnZXguanMnO1xuaW1wb3J0IHtkZXRlY3RNaXhpbn0gZnJvbSAnLi9jb21tb24tdXRpbHMuanMnO1xuaW1wb3J0IHtTdHlsZU5vZGV9IGZyb20gJy4vY3NzLXBhcnNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG5jb25zdCBBUFBMWV9OQU1FX0NMRUFOID0gLztcXHMqL207XG5jb25zdCBJTklUSUFMX0lOSEVSSVQgPSAvXlxccyooaW5pdGlhbCl8KGluaGVyaXQpXFxzKiQvO1xuXG4vLyBzZXBhcmF0b3IgdXNlZCBiZXR3ZWVuIG1peGluLW5hbWUgYW5kIG1peGluLXByb3BlcnR5LW5hbWUgd2hlbiBwcm9kdWNpbmcgcHJvcGVydGllc1xuLy8gTk9URTogcGxhaW4gJy0nIG1heSBjYXVzZSBjb2xsaXNpb25zIGluIHVzZXIgc3R5bGVzXG5jb25zdCBNSVhJTl9WQVJfU0VQID0gJ18tXyc7XG5cbi8qKlxuICogQHR5cGVkZWYgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICovXG5sZXQgUHJvcGVydHlFbnRyeTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKipcbiAqIEB0eXBlZGVmIHshT2JqZWN0PHN0cmluZywgYm9vbGVhbj59XG4gKi9cbmxldCBEZXBlbmRhbnRzRW50cnk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqIEB0eXBlZGVmIHt7XG4gKiAgICBwcm9wZXJ0aWVzOiBQcm9wZXJ0eUVudHJ5LFxuICogICAgZGVwZW5kYW50czogRGVwZW5kYW50c0VudHJ5XG4gKiB9fVxuICovXG5sZXQgTWl4aW5NYXBFbnRyeTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vLyBtYXAgb2YgbWl4aW4gdG8gcHJvcGVydHkgbmFtZXNcbi8vIC0tZm9vOiB7Ym9yZGVyOiAycHh9IC0+IHtwcm9wZXJ0aWVzOiB7KC0tZm9vLCBbJ2JvcmRlciddKX0sIGRlcGVuZGFudHM6IHsnZWxlbWVudC1uYW1lJzogcHJvdG99fVxuY2xhc3MgTWl4aW5NYXAge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAhTWl4aW5NYXBFbnRyeT59ICovXG4gICAgdGhpcy5fbWFwID0ge307XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7IVByb3BlcnR5RW50cnl9IHByb3BzXG4gICAqL1xuICBzZXQobmFtZSwgcHJvcHMpIHtcbiAgICBuYW1lID0gbmFtZS50cmltKCk7XG4gICAgdGhpcy5fbWFwW25hbWVdID0ge1xuICAgICAgcHJvcGVydGllczogcHJvcHMsXG4gICAgICBkZXBlbmRhbnRzOiB7fVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybiB7TWl4aW5NYXBFbnRyeX1cbiAgICovXG4gIGdldChuYW1lKSB7XG4gICAgbmFtZSA9IG5hbWUudHJpbSgpO1xuICAgIHJldHVybiB0aGlzLl9tYXBbbmFtZV0gfHwgbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciB3aGVuIGFuIGVsZW1lbnQgaXMgbWFya2VkIGludmFsaWRcbiAqIEB0eXBlIHs/ZnVuY3Rpb24oc3RyaW5nKX1cbiAqL1xubGV0IGludmFsaWRDYWxsYmFjayA9IG51bGw7XG5cbi8qKiBAdW5yZXN0cmljdGVkICovXG5jbGFzcyBBcHBseVNoaW0ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7SFRNTE1ldGFFbGVtZW50fSAqL1xuICAgIHRoaXMuX21lYXN1cmVFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9tYXAgPSBuZXcgTWl4aW5NYXAoKTtcbiAgfVxuICAvKipcbiAgICogcmV0dXJuIHRydWUgaWYgYGNzc1RleHRgIGNvbnRhaW5zIGEgbWl4aW4gZGVmaW5pdGlvbiBvciBjb25zdW1wdGlvblxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZGV0ZWN0TWl4aW4oY3NzVGV4dCkge1xuICAgIHJldHVybiBkZXRlY3RNaXhpbihjc3NUZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHYXRoZXIgc3R5bGVzIGludG8gb25lIHN0eWxlIGZvciBlYXNpZXIgcHJvY2Vzc2luZ1xuICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgKiBAcmV0dXJuIHtIVE1MU3R5bGVFbGVtZW50fVxuICAgKi9cbiAgZ2F0aGVyU3R5bGVzKHRlbXBsYXRlKSB7XG4gICAgY29uc3Qgc3R5bGVUZXh0ID0gZ2F0aGVyU3R5bGVUZXh0KHRlbXBsYXRlLmNvbnRlbnQpO1xuICAgIGlmIChzdHlsZVRleHQpIHtcbiAgICAgIGNvbnN0IHN0eWxlID0gLyoqIEB0eXBlIHshSFRNTFN0eWxlRWxlbWVudH0gKi8oZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKSk7XG4gICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlVGV4dDtcbiAgICAgIHRlbXBsYXRlLmNvbnRlbnQuaW5zZXJ0QmVmb3JlKHN0eWxlLCB0ZW1wbGF0ZS5jb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgcmV0dXJuIHN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAgICovXG4gIHRyYW5zZm9ybVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSkge1xuICAgIGlmICh0ZW1wbGF0ZS5fZ2F0aGVyZWRTdHlsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0ZW1wbGF0ZS5fZ2F0aGVyZWRTdHlsZSA9IHRoaXMuZ2F0aGVyU3R5bGVzKHRlbXBsYXRlKTtcbiAgICB9XG4gICAgLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqL1xuICAgIGNvbnN0IHN0eWxlID0gdGVtcGxhdGUuX2dhdGhlcmVkU3R5bGU7XG4gICAgcmV0dXJuIHN0eWxlID8gdGhpcy50cmFuc2Zvcm1TdHlsZShzdHlsZSwgZWxlbWVudE5hbWUpIDogbnVsbDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAgICovXG4gIHRyYW5zZm9ybVN0eWxlKHN0eWxlLCBlbGVtZW50TmFtZSA9ICcnKSB7XG4gICAgbGV0IGFzdCA9IHJ1bGVzRm9yU3R5bGUoc3R5bGUpO1xuICAgIHRoaXMudHJhbnNmb3JtUnVsZXMoYXN0LCBlbGVtZW50TmFtZSk7XG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSB0b0Nzc1RleHQoYXN0KTtcbiAgICByZXR1cm4gYXN0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICAgKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gICAqL1xuICB0cmFuc2Zvcm1DdXN0b21TdHlsZShzdHlsZSkge1xuICAgIGxldCBhc3QgPSBydWxlc0ZvclN0eWxlKHN0eWxlKTtcbiAgICBmb3JFYWNoUnVsZShhc3QsIChydWxlKSA9PiB7XG4gICAgICBpZiAocnVsZVsnc2VsZWN0b3InXSA9PT0gJzpyb290Jykge1xuICAgICAgICBydWxlWydzZWxlY3RvciddID0gJ2h0bWwnO1xuICAgICAgfVxuICAgICAgdGhpcy50cmFuc2Zvcm1SdWxlKHJ1bGUpO1xuICAgIH0pXG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSB0b0Nzc1RleHQoYXN0KTtcbiAgICByZXR1cm4gYXN0O1xuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0eWxlTm9kZX0gcnVsZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAqL1xuICB0cmFuc2Zvcm1SdWxlcyhydWxlcywgZWxlbWVudE5hbWUpIHtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IGVsZW1lbnROYW1lO1xuICAgIGZvckVhY2hSdWxlKHJ1bGVzLCAocikgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm1SdWxlKHIpO1xuICAgIH0pO1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshU3R5bGVOb2RlfSBydWxlXG4gICAqL1xuICB0cmFuc2Zvcm1SdWxlKHJ1bGUpIHtcbiAgICBydWxlWydjc3NUZXh0J10gPSB0aGlzLnRyYW5zZm9ybUNzc1RleHQocnVsZVsncGFyc2VkQ3NzVGV4dCddKTtcbiAgICAvLyA6cm9vdCB3YXMgb25seSB1c2VkIGZvciB2YXJpYWJsZSBhc3NpZ25tZW50IGluIHByb3BlcnR5IHNoaW0sXG4gICAgLy8gYnV0IGdlbmVyYXRlcyBpbnZhbGlkIHNlbGVjdG9ycyB3aXRoIHJlYWwgcHJvcGVydGllcy5cbiAgICAvLyByZXBsYWNlIHdpdGggYDpob3N0ID4gKmAsIHdoaWNoIHNlcnZlcyB0aGUgc2FtZSBlZmZlY3RcbiAgICBpZiAocnVsZVsnc2VsZWN0b3InXSA9PT0gJzpyb290Jykge1xuICAgICAgcnVsZVsnc2VsZWN0b3InXSA9ICc6aG9zdCA+IConO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdHJhbnNmb3JtQ3NzVGV4dChjc3NUZXh0KSB7XG4gICAgLy8gcHJvZHVjZSB2YXJpYWJsZXNcbiAgICBjc3NUZXh0ID0gY3NzVGV4dC5yZXBsYWNlKFZBUl9BU1NJR04sIChtYXRjaFRleHQsIHByb3BlcnR5TmFtZSwgdmFsdWVQcm9wZXJ0eSwgdmFsdWVNaXhpbikgPT5cbiAgICAgIHRoaXMuX3Byb2R1Y2VDc3NQcm9wZXJ0aWVzKG1hdGNoVGV4dCwgcHJvcGVydHlOYW1lLCB2YWx1ZVByb3BlcnR5LCB2YWx1ZU1peGluKSk7XG4gICAgLy8gY29uc3VtZSBtaXhpbnNcbiAgICByZXR1cm4gdGhpcy5fY29uc3VtZUNzc1Byb3BlcnRpZXMoY3NzVGV4dCk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfZ2V0SW5pdGlhbFZhbHVlRm9yUHJvcGVydHkocHJvcGVydHkpIHtcbiAgICBpZiAoIXRoaXMuX21lYXN1cmVFbGVtZW50KSB7XG4gICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudCA9IC8qKiBAdHlwZSB7SFRNTE1ldGFFbGVtZW50fSAqLyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtZXRhJykpO1xuICAgICAgdGhpcy5fbWVhc3VyZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcHBseS1zaGltLW1lYXN1cmUnLCAnJyk7XG4gICAgICB0aGlzLl9tZWFzdXJlRWxlbWVudC5zdHlsZS5hbGwgPSAnaW5pdGlhbCc7XG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRoaXMuX21lYXN1cmVFbGVtZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuX21lYXN1cmVFbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHByb3BlcnR5KTtcbiAgfVxuICAvKipcbiAgICogcmVwbGFjZSBtaXhpbiBjb25zdW1wdGlvbiB3aXRoIHZhcmlhYmxlIGNvbnN1bXB0aW9uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9jb25zdW1lQ3NzUHJvcGVydGllcyh0ZXh0KSB7XG4gICAgLyoqIEB0eXBlIHtBcnJheX0gKi9cbiAgICBsZXQgbSA9IG51bGw7XG4gICAgLy8gbG9vcCBvdmVyIHRleHQgdW50aWwgYWxsIG1peGlucyB3aXRoIGRlZmludGlvbnMgaGF2ZSBiZWVuIGFwcGxpZWRcbiAgICB3aGlsZSgobSA9IE1JWElOX01BVENILmV4ZWModGV4dCkpKSB7XG4gICAgICBsZXQgbWF0Y2hUZXh0ID0gbVswXTtcbiAgICAgIGxldCBtaXhpbk5hbWUgPSBtWzFdO1xuICAgICAgbGV0IGlkeCA9IG0uaW5kZXg7XG4gICAgICAvLyBjb2xsZWN0IHByb3BlcnRpZXMgYmVmb3JlIGFwcGx5IHRvIGJlIFwiZGVmYXVsdHNcIiBpZiBtaXhpbiBtaWdodCBvdmVycmlkZSB0aGVtXG4gICAgICAvLyBtYXRjaCBpbmNsdWRlcyBhIFwicHJlZml4XCIsIHNvIGZpbmQgdGhlIHN0YXJ0IGFuZCBlbmQgcG9zaXRpb25zIG9mIEBhcHBseVxuICAgICAgbGV0IGFwcGx5UG9zID0gaWR4ICsgbWF0Y2hUZXh0LmluZGV4T2YoJ0BhcHBseScpO1xuICAgICAgbGV0IGFmdGVyQXBwbHlQb3MgPSBpZHggKyBtYXRjaFRleHQubGVuZ3RoO1xuICAgICAgLy8gZmluZCBwcm9wcyBkZWZpbmVkIGJlZm9yZSB0aGlzIEBhcHBseVxuICAgICAgbGV0IHRleHRCZWZvcmVBcHBseSA9IHRleHQuc2xpY2UoMCwgYXBwbHlQb3MpO1xuICAgICAgbGV0IHRleHRBZnRlckFwcGx5ID0gdGV4dC5zbGljZShhZnRlckFwcGx5UG9zKTtcbiAgICAgIGxldCBkZWZhdWx0cyA9IHRoaXMuX2Nzc1RleHRUb01hcCh0ZXh0QmVmb3JlQXBwbHkpO1xuICAgICAgbGV0IHJlcGxhY2VtZW50ID0gdGhpcy5fYXRBcHBseVRvQ3NzUHJvcGVydGllcyhtaXhpbk5hbWUsIGRlZmF1bHRzKTtcbiAgICAgIC8vIHVzZSByZWdleCBtYXRjaCBwb3NpdGlvbiB0byByZXBsYWNlIG1peGluLCBrZWVwIGxpbmVhciBwcm9jZXNzaW5nIHRpbWVcbiAgICAgIHRleHQgPSBgJHt0ZXh0QmVmb3JlQXBwbHl9JHtyZXBsYWNlbWVudH0ke3RleHRBZnRlckFwcGx5fWA7XG4gICAgICAvLyBtb3ZlIHJlZ2V4IHNlYXJjaCB0byBfYWZ0ZXJfIHJlcGxhY2VtZW50XG4gICAgICBNSVhJTl9NQVRDSC5sYXN0SW5kZXggPSBpZHggKyByZXBsYWNlbWVudC5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiB0ZXh0O1xuICB9XG4gIC8qKlxuICAgKiBwcm9kdWNlIHZhcmlhYmxlIGNvbnN1bXB0aW9uIGF0IHRoZSBzaXRlIG9mIG1peGluIGNvbnN1bXB0aW9uXG4gICAqIGBAYXBwbHlgIC0tZm9vOyAtPiBmb3IgYWxsIHByb3BzICgke3Byb3BuYW1lfTogdmFyKC0tZm9vXy1fJHtwcm9wbmFtZX0sICR7ZmFsbGJhY2tbcHJvcG5hbWVdfX0pKVxuICAgKiBFeGFtcGxlOlxuICAgKiAgYm9yZGVyOiB2YXIoLS1mb29fLV9ib3JkZXIpOyBwYWRkaW5nOiB2YXIoLS1mb29fLV9wYWRkaW5nLCAycHgpXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtaXhpbk5hbWVcbiAgICogQHBhcmFtIHtPYmplY3R9IGZhbGxiYWNrc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfYXRBcHBseVRvQ3NzUHJvcGVydGllcyhtaXhpbk5hbWUsIGZhbGxiYWNrcykge1xuICAgIG1peGluTmFtZSA9IG1peGluTmFtZS5yZXBsYWNlKEFQUExZX05BTUVfQ0xFQU4sICcnKTtcbiAgICBsZXQgdmFycyA9IFtdO1xuICAgIGxldCBtaXhpbkVudHJ5ID0gdGhpcy5fbWFwLmdldChtaXhpbk5hbWUpO1xuICAgIC8vIGlmIHdlIGRlcGVuZCBvbiBhIG1peGluIGJlZm9yZSBpdCBpcyBjcmVhdGVkXG4gICAgLy8gbWFrZSBhIHNlbnRpbmVsIGVudHJ5IGluIHRoZSBtYXAgdG8gYWRkIHRoaXMgZWxlbWVudCBhcyBhIGRlcGVuZGVuY3kgZm9yIHdoZW4gaXQgaXMgZGVmaW5lZC5cbiAgICBpZiAoIW1peGluRW50cnkpIHtcbiAgICAgIHRoaXMuX21hcC5zZXQobWl4aW5OYW1lLCB7fSk7XG4gICAgICBtaXhpbkVudHJ5ID0gdGhpcy5fbWFwLmdldChtaXhpbk5hbWUpO1xuICAgIH1cbiAgICBpZiAobWl4aW5FbnRyeSkge1xuICAgICAgaWYgKHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgIG1peGluRW50cnkuZGVwZW5kYW50c1t0aGlzLl9jdXJyZW50RWxlbWVudF0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgbGV0IHAsIHBhcnRzLCBmO1xuICAgICAgZm9yIChwIGluIG1peGluRW50cnkucHJvcGVydGllcykge1xuICAgICAgICBmID0gZmFsbGJhY2tzICYmIGZhbGxiYWNrc1twXTtcbiAgICAgICAgcGFydHMgPSBbcCwgJzogdmFyKCcsIG1peGluTmFtZSwgTUlYSU5fVkFSX1NFUCwgcF07XG4gICAgICAgIGlmIChmKSB7XG4gICAgICAgICAgcGFydHMucHVzaCgnLCcsIGYpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzLnB1c2goJyknKTtcbiAgICAgICAgdmFycy5wdXNoKHBhcnRzLmpvaW4oJycpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhcnMuam9pbignOyAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9yZXBsYWNlSW5pdGlhbE9ySW5oZXJpdChwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBsZXQgbWF0Y2ggPSBJTklUSUFMX0lOSEVSSVQuZXhlYyh2YWx1ZSk7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBpZiAobWF0Y2hbMV0pIHtcbiAgICAgICAgLy8gaW5pdGlhbFxuICAgICAgICAvLyByZXBsYWNlIGBpbml0aWFsYCB3aXRoIHRoZSBjb25jcmV0ZSBpbml0aWFsIHZhbHVlIGZvciB0aGlzIHByb3BlcnR5XG4gICAgICAgIHZhbHVlID0gdGhpcy5fZ2V0SW5pdGlhbFZhbHVlRm9yUHJvcGVydHkocHJvcGVydHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaW5oZXJpdFxuICAgICAgICAvLyB3aXRoIHRoaXMgcHVycG9zZnVsbHkgaWxsZWdhbCB2YWx1ZSwgdGhlIHZhcmlhYmxlIHdpbGwgYmUgaW52YWxpZCBhdFxuICAgICAgICAvLyBjb21wdXRlIHRpbWUgKGh0dHBzOi8vd3d3LnczLm9yZy9UUi9jc3MtdmFyaWFibGVzLyNpbnZhbGlkLWF0LWNvbXB1dGVkLXZhbHVlLXRpbWUpXG4gICAgICAgIC8vIGFuZCBmb3IgaW5oZXJpdGluZyB2YWx1ZXMsIHdpbGwgYmVoYXZlIHNpbWlsYXJseVxuICAgICAgICAvLyB3ZSBjYW5ub3Qgc3VwcG9ydCB0aGUgc2FtZSBiZWhhdmlvciBmb3Igbm9uIGluaGVyaXRpbmcgdmFsdWVzIGxpa2UgJ2JvcmRlcidcbiAgICAgICAgdmFsdWUgPSAnYXBwbHktc2hpbS1pbmhlcml0JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFwicGFyc2VcIiBhIG1peGluIGRlZmluaXRpb24gaW50byBhIG1hcCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXNcbiAgICogY3NzVGV4dFRvTWFwKCdib3JkZXI6IDJweCBzb2xpZCBibGFjaycpIC0+ICgnYm9yZGVyJywgJzJweCBzb2xpZCBibGFjaycpXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqIEByZXR1cm4geyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fVxuICAgKi9cbiAgX2Nzc1RleHRUb01hcCh0ZXh0KSB7XG4gICAgbGV0IHByb3BzID0gdGV4dC5zcGxpdCgnOycpO1xuICAgIGxldCBwcm9wZXJ0eSwgdmFsdWU7XG4gICAgbGV0IG91dCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwLCBwLCBzcDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBwID0gcHJvcHNbaV07XG4gICAgICBpZiAocCkge1xuICAgICAgICBzcCA9IHAuc3BsaXQoJzonKTtcbiAgICAgICAgLy8gaWdub3JlIGxpbmVzIHRoYXQgYXJlbid0IGRlZmluaXRpb25zIGxpa2UgQG1lZGlhXG4gICAgICAgIGlmIChzcC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcHJvcGVydHkgPSBzcFswXS50cmltKCk7XG4gICAgICAgICAgLy8gc29tZSBwcm9wZXJ0aWVzIG1heSBoYXZlICc6JyBpbiB0aGUgdmFsdWUsIGxpa2UgZGF0YSB1cmxzXG4gICAgICAgICAgdmFsdWUgPSB0aGlzLl9yZXBsYWNlSW5pdGlhbE9ySW5oZXJpdChwcm9wZXJ0eSwgc3Auc2xpY2UoMSkuam9pbignOicpKTtcbiAgICAgICAgICBvdXRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge01peGluTWFwRW50cnl9IG1peGluRW50cnlcbiAgICovXG4gIF9pbnZhbGlkYXRlTWl4aW5FbnRyeShtaXhpbkVudHJ5KSB7XG4gICAgaWYgKCFpbnZhbGlkQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChsZXQgZWxlbWVudE5hbWUgaW4gbWl4aW5FbnRyeS5kZXBlbmRhbnRzKSB7XG4gICAgICBpZiAoZWxlbWVudE5hbWUgIT09IHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICAgIGludmFsaWRDYWxsYmFjayhlbGVtZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtYXRjaFRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IHZhbHVlUHJvcGVydHlcbiAgICogQHBhcmFtIHs/c3RyaW5nfSB2YWx1ZU1peGluXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIF9wcm9kdWNlQ3NzUHJvcGVydGllcyhtYXRjaFRleHQsIHByb3BlcnR5TmFtZSwgdmFsdWVQcm9wZXJ0eSwgdmFsdWVNaXhpbikge1xuICAgIC8vIGhhbmRsZSBjYXNlIHdoZXJlIHByb3BlcnR5IHZhbHVlIGlzIGEgbWl4aW5cbiAgICBpZiAodmFsdWVQcm9wZXJ0eSkge1xuICAgICAgLy8gZm9ybTogLS1taXhpbjI6IHZhcigtLW1peGluMSksIHdoZXJlIC0tbWl4aW4xIGlzIGluIHRoZSBtYXBcbiAgICAgIHByb2Nlc3NWYXJpYWJsZUFuZEZhbGxiYWNrKHZhbHVlUHJvcGVydHksIChwcmVmaXgsIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0aGlzLl9tYXAuZ2V0KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlTWl4aW4gPSBgQGFwcGx5ICR7dmFsdWV9O2BcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghdmFsdWVNaXhpbikge1xuICAgICAgcmV0dXJuIG1hdGNoVGV4dDtcbiAgICB9XG4gICAgbGV0IG1peGluQXNQcm9wZXJ0aWVzID0gdGhpcy5fY29uc3VtZUNzc1Byb3BlcnRpZXModmFsdWVNaXhpbik7XG4gICAgbGV0IHByZWZpeCA9IG1hdGNoVGV4dC5zbGljZSgwLCBtYXRjaFRleHQuaW5kZXhPZignLS0nKSk7XG4gICAgbGV0IG1peGluVmFsdWVzID0gdGhpcy5fY3NzVGV4dFRvTWFwKG1peGluQXNQcm9wZXJ0aWVzKTtcbiAgICBsZXQgY29tYmluZWRQcm9wcyA9IG1peGluVmFsdWVzO1xuICAgIGxldCBtaXhpbkVudHJ5ID0gdGhpcy5fbWFwLmdldChwcm9wZXJ0eU5hbWUpO1xuICAgIGxldCBvbGRQcm9wcyA9IG1peGluRW50cnkgJiYgbWl4aW5FbnRyeS5wcm9wZXJ0aWVzO1xuICAgIGlmIChvbGRQcm9wcykge1xuICAgICAgLy8gTk9URTogc2luY2Ugd2UgdXNlIG1peGluLCB0aGUgbWFwIG9mIHByb3BlcnRpZXMgaXMgdXBkYXRlZCBoZXJlXG4gICAgICAvLyBhbmQgdGhpcyBpcyB3aGF0IHdlIHdhbnQuXG4gICAgICBjb21iaW5lZFByb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG9sZFByb3BzKSwgbWl4aW5WYWx1ZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9tYXAuc2V0KHByb3BlcnR5TmFtZSwgY29tYmluZWRQcm9wcyk7XG4gICAgfVxuICAgIGxldCBvdXQgPSBbXTtcbiAgICBsZXQgcCwgdjtcbiAgICAvLyBzZXQgdmFyaWFibGVzIGRlZmluZWQgYnkgY3VycmVudCBtaXhpblxuICAgIGxldCBuZWVkVG9JbnZhbGlkYXRlID0gZmFsc2U7XG4gICAgZm9yIChwIGluIGNvbWJpbmVkUHJvcHMpIHtcbiAgICAgIHYgPSBtaXhpblZhbHVlc1twXTtcbiAgICAgIC8vIGlmIHByb3BlcnR5IG5vdCBkZWZpbmVkIGJ5IGN1cnJlbnQgbWl4aW4sIHNldCBpbml0aWFsXG4gICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHYgPSAnaW5pdGlhbCc7XG4gICAgICB9XG4gICAgICBpZiAob2xkUHJvcHMgJiYgIShwIGluIG9sZFByb3BzKSkge1xuICAgICAgICBuZWVkVG9JbnZhbGlkYXRlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG91dC5wdXNoKGAke3Byb3BlcnR5TmFtZX0ke01JWElOX1ZBUl9TRVB9JHtwfTogJHt2fWApO1xuICAgIH1cbiAgICBpZiAobmVlZFRvSW52YWxpZGF0ZSkge1xuICAgICAgdGhpcy5faW52YWxpZGF0ZU1peGluRW50cnkobWl4aW5FbnRyeSk7XG4gICAgfVxuICAgIGlmIChtaXhpbkVudHJ5KSB7XG4gICAgICBtaXhpbkVudHJ5LnByb3BlcnRpZXMgPSBjb21iaW5lZFByb3BzO1xuICAgIH1cbiAgICAvLyBiZWNhdXNlIHRoZSBtaXhpbk1hcCBpcyBnbG9iYWwsIHRoZSBtaXhpbiBtaWdodCBjb25mbGljdCB3aXRoXG4gICAgLy8gYSBkaWZmZXJlbnQgc2NvcGUncyBzaW1wbGUgdmFyaWFibGUgZGVmaW5pdGlvbjpcbiAgICAvLyBFeGFtcGxlOlxuICAgIC8vIHNvbWUgc3R5bGUgc29tZXdoZXJlOlxuICAgIC8vIC0tbWl4aW4xOnsgLi4uIH1cbiAgICAvLyAtLW1peGluMjogdmFyKC0tbWl4aW4xKTtcbiAgICAvLyBzb21lIG90aGVyIGVsZW1lbnQ6XG4gICAgLy8gLS1taXhpbjE6IDEwcHggc29saWQgcmVkO1xuICAgIC8vIC0tZm9vOiB2YXIoLS1taXhpbjEpO1xuICAgIC8vIEluIHRoaXMgY2FzZSwgd2UgbGVhdmUgdGhlIG9yaWdpbmFsIHZhcmlhYmxlIGRlZmluaXRpb24gaW4gcGxhY2UuXG4gICAgaWYgKHZhbHVlUHJvcGVydHkpIHtcbiAgICAgIHByZWZpeCA9IGAke21hdGNoVGV4dH07JHtwcmVmaXh9YDtcbiAgICB9XG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke291dC5qb2luKCc7ICcpfTtgO1xuICB9XG59XG5cbi8qIGV4cG9ydHMgKi9cbkFwcGx5U2hpbS5wcm90b3R5cGVbJ2RldGVjdE1peGluJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLmRldGVjdE1peGluO1xuQXBwbHlTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtU3R5bGUnXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUudHJhbnNmb3JtU3R5bGU7XG5BcHBseVNoaW0ucHJvdG90eXBlWyd0cmFuc2Zvcm1DdXN0b21TdHlsZSddID0gQXBwbHlTaGltLnByb3RvdHlwZS50cmFuc2Zvcm1DdXN0b21TdHlsZTtcbkFwcGx5U2hpbS5wcm90b3R5cGVbJ3RyYW5zZm9ybVJ1bGVzJ10gPSBBcHBseVNoaW0ucHJvdG90eXBlLnRyYW5zZm9ybVJ1bGVzO1xuQXBwbHlTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtUnVsZSddID0gQXBwbHlTaGltLnByb3RvdHlwZS50cmFuc2Zvcm1SdWxlO1xuQXBwbHlTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtVGVtcGxhdGUnXSA9IEFwcGx5U2hpbS5wcm90b3R5cGUudHJhbnNmb3JtVGVtcGxhdGU7XG5BcHBseVNoaW0ucHJvdG90eXBlWydfc2VwYXJhdG9yJ10gPSBNSVhJTl9WQVJfU0VQO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFwcGx5U2hpbS5wcm90b3R5cGUsICdpbnZhbGlkQ2FsbGJhY2snLCB7XG4gIC8qKiBAcmV0dXJuIHs/ZnVuY3Rpb24oc3RyaW5nKX0gKi9cbiAgZ2V0KCkge1xuICAgIHJldHVybiBpbnZhbGlkQ2FsbGJhY2s7XG4gIH0sXG4gIC8qKiBAcGFyYW0gez9mdW5jdGlvbihzdHJpbmcpfSBjYiAqL1xuICBzZXQoY2IpIHtcbiAgICBpbnZhbGlkQ2FsbGJhY2sgPSBjYjtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IEFwcGx5U2hpbTtcblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvYXBwbHktc2hpbS5qc1xuLy8gbW9kdWxlIGlkID0gNTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUgeyFTZXQ8c3RyaW5nPn0gKi9cbmNvbnN0IHN0eWxlVGV4dFNldCA9IG5ldyBTZXQoKTtcblxuZXhwb3J0IGNvbnN0IHNjb3BpbmdBdHRyaWJ1dGUgPSAnc2hhZHktdW5zY29wZWQnO1xuXG4vKipcbiAqIEFkZCBhIHNwZWNpZmljYWxseS1tYXJrZWQgc3R5bGUgdG8gdGhlIGRvY3VtZW50IGRpcmVjdGx5LCBhbmQgb25seSBvbmUgY29weSBvZiB0aGF0IHN0eWxlLlxuICpcbiAqIEBwYXJhbSB7IUhUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzVW5zY29wZWRTdHlsZShzdHlsZSkge1xuICBjb25zdCB0ZXh0ID0gc3R5bGUudGV4dENvbnRlbnQ7XG4gIGlmICghc3R5bGVUZXh0U2V0Lmhhcyh0ZXh0KSkge1xuICAgIHN0eWxlVGV4dFNldC5hZGQodGV4dCk7XG4gICAgY29uc3QgbmV3U3R5bGUgPSBzdHlsZS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChuZXdTdHlsZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHN0eWxlIGlzIHN1cHBvc2VkIHRvIGJlIHVuc2NvcGVkXG4gKiBAcGFyYW0geyFIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgc3R5bGUgaGFzIHRoZSB1bnNjb3BpbmcgYXR0cmlidXRlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Vuc2NvcGVkU3R5bGUoc3R5bGUpIHtcbiAgcmV0dXJuIHN0eWxlLmhhc0F0dHJpYnV0ZShzY29waW5nQXR0cmlidXRlKTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvdW5zY29wZWQtc3R5bGUtaGFuZGxlci5qc1xuLy8gbW9kdWxlIGlkID0gNThcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHRlbXBsYXRlTWFwIGZyb20gJy4vdGVtcGxhdGUtbWFwLmpzJztcbmltcG9ydCB7U3R5bGVOb2RlfSBmcm9tICcuL2Nzcy1wYXJzZS5qcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLypcbiAqIFV0aWxpdGllcyBmb3IgaGFuZGxpbmcgaW52YWxpZGF0aW5nIGFwcGx5LXNoaW0gbWl4aW5zIGZvciBhIGdpdmVuIHRlbXBsYXRlLlxuICpcbiAqIFRoZSBpbnZhbGlkYXRpb24gc3RyYXRlZ3kgaW52b2x2ZXMga2VlcGluZyB0cmFjayBvZiB0aGUgXCJjdXJyZW50XCIgdmVyc2lvbiBvZiBhIHRlbXBsYXRlJ3MgbWl4aW5zLCBhbmQgdXBkYXRpbmcgdGhhdCBjb3VudCB3aGVuIGEgbWl4aW4gaXMgaW52YWxpZGF0ZWQuXG4gKiBUaGUgdGVtcGxhdGVcbiAqL1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBDVVJSRU5UX1ZFUlNJT04gPSAnX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uJztcblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgTkVYVF9WRVJTSU9OID0gJ19hcHBseVNoaW1OZXh0VmVyc2lvbic7XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IFZBTElEQVRJTkdfVkVSU0lPTiA9ICdfYXBwbHlTaGltVmFsaWRhdGluZ1ZlcnNpb24nO1xuXG4vKipcbiAqIEBjb25zdCB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSgpO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZShlbGVtZW50TmFtZSl7XG4gIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgaWYgKHRlbXBsYXRlKSB7XG4gICAgaW52YWxpZGF0ZVRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB0byBtYXJrIGEgdGVtcGxhdGUgaW52YWxpZFxuICogYW5kIHNpZ25hbCB0aGF0IHRoZSBzdHlsZSBpbnNpZGUgbXVzdCBiZSByZWdlbmVyYXRlZC5cbiAqXG4gKiBVc2UgYHN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlYCB0byBiZWdpbiBhbiBhc3luY2hyb25vdXMgdmFsaWRhdGlvbiBjeWNsZS5cbiAqIER1cmluZyB0aGF0IGN5Y2xlLCBjYWxsIGB0ZW1wbGF0ZUlzVmFsaWRhdGluZ2AgdG8gc2VlIGlmIHRoZSB0ZW1wbGF0ZSBtdXN0XG4gKiBiZSByZXZhbGlkYXRlZFxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW52YWxpZGF0ZVRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gIC8vIGRlZmF1bHQgdGhlIGN1cnJlbnQgdmVyc2lvbiB0byAwXG4gIHRlbXBsYXRlW0NVUlJFTlRfVkVSU0lPTl0gPSB0ZW1wbGF0ZVtDVVJSRU5UX1ZFUlNJT05dIHx8IDA7XG4gIC8vIGVuc3VyZSB0aGUgXCJ2YWxpZGF0aW5nIGZvclwiIGZsYWcgZXhpc3RzXG4gIHRlbXBsYXRlW1ZBTElEQVRJTkdfVkVSU0lPTl0gPSB0ZW1wbGF0ZVtWQUxJREFUSU5HX1ZFUlNJT05dIHx8IDA7XG4gIC8vIGluY3JlbWVudCB0aGUgbmV4dCB2ZXJzaW9uXG4gIHRlbXBsYXRlW05FWFRfVkVSU0lPTl0gPSAodGVtcGxhdGVbTkVYVF9WRVJTSU9OXSB8fCAwKSArIDE7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZChlbGVtZW50TmFtZSkge1xuICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gIGlmICh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZUlzVmFsaWQodGVtcGxhdGUpO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUlzVmFsaWQodGVtcGxhdGUpIHtcbiAgcmV0dXJuIHRlbXBsYXRlW0NVUlJFTlRfVkVSU0lPTl0gPT09IHRlbXBsYXRlW05FWFRfVkVSU0lPTl07XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZGF0aW5nKGVsZW1lbnROYW1lKSB7XG4gIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgaWYgKHRlbXBsYXRlKSB7XG4gICAgcmV0dXJuIHRlbXBsYXRlSXNWYWxpZGF0aW5nKHRlbXBsYXRlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB0ZW1wbGF0ZSBpcyBjdXJyZW50bHkgaW52YWxpZCBhbmQgYHN0YXJ0VmFsaWRhdGluZ2AgaGFzIGJlZW4gY2FsbGVkIHNpbmNlIHRoZSBsYXN0IGludmFsaWRhdGlvbi5cbiAqIElmIGZhbHNlLCB0aGUgdGVtcGxhdGUgbXVzdCBiZSB2YWxpZGF0ZWQuXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVJc1ZhbGlkYXRpbmcodGVtcGxhdGUpIHtcbiAgcmV0dXJuICF0ZW1wbGF0ZUlzVmFsaWQodGVtcGxhdGUpICYmIHRlbXBsYXRlW1ZBTElEQVRJTkdfVkVSU0lPTl0gPT09IHRlbXBsYXRlW05FWFRfVkVSU0lPTl07XG59XG5cbi8qKlxuICogdGhlIHRlbXBsYXRlIGlzIG1hcmtlZCBhcyBgdmFsaWRhdGluZ2AgZm9yIG9uZSBtaWNyb3Rhc2sgc28gdGhhdCBhbGwgaW5zdGFuY2VzXG4gKiBmb3VuZCBpbiB0aGUgdHJlZSBjcmF3bCBvZiBgYXBwbHlTdHlsZWAgd2lsbCB1cGRhdGUgdGhlbXNlbHZlcyxcbiAqIGJ1dCB0aGUgdGVtcGxhdGUgd2lsbCBvbmx5IGJlIHVwZGF0ZWQgb25jZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFydFZhbGlkYXRpbmcoZWxlbWVudE5hbWUpIHtcbiAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICBzdGFydFZhbGlkYXRpbmdUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG59XG5cbi8qKlxuICogQmVnaW4gYW4gYXN5bmNocm9ub3VzIGludmFsaWRhdGlvbiBjeWNsZS5cbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBldmVyeSB2YWxpZGF0aW9uIG9mIGEgdGVtcGxhdGVcbiAqXG4gKiBBZnRlciBvbmUgbWljcm90YXNrLCB0aGUgdGVtcGxhdGUgd2lsbCBiZSBtYXJrZWQgYXMgdmFsaWQgdW50aWwgdGhlIG5leHQgY2FsbCB0byBgaW52YWxpZGF0ZVRlbXBsYXRlYFxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRWYWxpZGF0aW5nVGVtcGxhdGUodGVtcGxhdGUpIHtcbiAgLy8gcmVtZW1iZXIgdGhhdCB0aGUgY3VycmVudCBcIm5leHQgdmVyc2lvblwiIGlzIHRoZSByZWFzb24gZm9yIHRoaXMgdmFsaWRhdGlvbiBjeWNsZVxuICB0ZW1wbGF0ZVtWQUxJREFUSU5HX1ZFUlNJT05dID0gdGVtcGxhdGVbTkVYVF9WRVJTSU9OXTtcbiAgLy8gaG93ZXZlciwgdGhlcmUgb25seSBuZWVkcyB0byBiZSBvbmUgYXN5bmMgdGFzayB0byBjbGVhciB0aGUgY291bnRlcnNcbiAgaWYgKCF0ZW1wbGF0ZS5fdmFsaWRhdGluZykge1xuICAgIHRlbXBsYXRlLl92YWxpZGF0aW5nID0gdHJ1ZTtcbiAgICBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAvLyBzeW5jIHRoZSBjdXJyZW50IHZlcnNpb24gdG8gbGV0IGZ1dHVyZSBpbnZhbGlkYXRpb25zIGNhdXNlIGEgcmVmcmVzaCBjeWNsZVxuICAgICAgdGVtcGxhdGVbQ1VSUkVOVF9WRVJTSU9OXSA9IHRlbXBsYXRlW05FWFRfVkVSU0lPTl07XG4gICAgICB0ZW1wbGF0ZS5fdmFsaWRhdGluZyA9IGZhbHNlO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRzQXJlSW52YWxpZCgpIHtcbiAgZm9yIChsZXQgZWxlbWVudE5hbWUgaW4gdGVtcGxhdGVNYXApIHtcbiAgICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gICAgaWYgKCF0ZW1wbGF0ZUlzVmFsaWQodGVtcGxhdGUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLXV0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSA1OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4vYm9vdC5qcyc7XG5cbi8vIHJ1biBhIGNhbGxiYWNrIHdoZW4gSFRNTEltcG9ydHMgYXJlIHJlYWR5IG9yIGltbWVkaWF0ZWx5IGlmXG4vLyB0aGlzIGFwaSBpcyBub3QgYXZhaWxhYmxlLlxuZnVuY3Rpb24gd2hlbkltcG9ydHNSZWFkeShjYikge1xuICBpZiAod2luZG93LkhUTUxJbXBvcnRzKSB7XG4gICAgSFRNTEltcG9ydHMud2hlblJlYWR5KGNiKTtcbiAgfSBlbHNlIHtcbiAgICBjYigpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBpbXBvcnRIcmVmID0gZnVuY3Rpb24oaHJlZiwgb25sb2FkLCBvbmVycm9yLCBvcHRBc3luYykge1xuICBsZXQgbGluayA9IC8qKiBAdHlwZSB7SFRNTExpbmtFbGVtZW50fSAqL1xuICAgIChkb2N1bWVudC5oZWFkLnF1ZXJ5U2VsZWN0b3IoJ2xpbmtbaHJlZj1cIicgKyBocmVmICsgJ1wiXVtpbXBvcnQtaHJlZl0nKSk7XG4gIGlmICghbGluaykge1xuICAgIGxpbmsgPSAvKiogQHR5cGUge0hUTUxMaW5rRWxlbWVudH0gKi8gKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpbmsnKSk7XG4gICAgbGluay5yZWwgPSAnaW1wb3J0JztcbiAgICBsaW5rLmhyZWYgPSBocmVmO1xuICAgIGxpbmsuc2V0QXR0cmlidXRlKCdpbXBvcnQtaHJlZicsICcnKTtcbiAgfVxuICAvLyBhbHdheXMgZW5zdXJlIGxpbmsgaGFzIGBhc3luY2AgYXR0cmlidXRlIGlmIHVzZXIgc3BlY2lmaWVkIG9uZSxcbiAgLy8gZXZlbiBpZiBpdCB3YXMgcHJldmlvdXNseSBub3QgYXN5bmMuIFRoaXMgaXMgY29uc2lkZXJlZCBsZXNzIGNvbmZ1c2luZy5cbiAgaWYgKG9wdEFzeW5jKSB7XG4gICAgbGluay5zZXRBdHRyaWJ1dGUoJ2FzeW5jJywgJycpO1xuICB9XG4gIC8vIE5PVEU6IHRoZSBsaW5rIG1heSBub3cgYmUgaW4gMyBzdGF0ZXM6ICgxKSBwZW5kaW5nIGluc2VydGlvbixcbiAgLy8gKDIpIGluZmxpZ2h0LCAoMykgYWxyZWFkeSBsYW9kZWQuIEluIGVhY2ggY2FzZSwgd2UgbmVlZCB0byBhZGRcbiAgLy8gZXZlbnQgbGlzdGVuZXJzIHRvIHByb2Nlc3MgY2FsbGJhY2tzLlxuICBsZXQgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIGxpbmsucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lcik7XG4gICAgbGluay5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGVycm9yTGlzdGVuZXIpO1xuICB9O1xuICBsZXQgbG9hZExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgLy8gSW4gY2FzZSBvZiBhIHN1Y2Nlc3NmdWwgbG9hZCwgY2FjaGUgdGhlIGxvYWQgZXZlbnQgb24gdGhlIGxpbmsgc29cbiAgICAvLyB0aGF0IGl0IGNhbiBiZSB1c2VkIHRvIHNob3J0LWNpcmN1aXQgdGhpcyBtZXRob2QgaW4gdGhlIGZ1dHVyZSB3aGVuXG4gICAgLy8gaXQgaXMgY2FsbGVkIHdpdGggdGhlIHNhbWUgaHJlZiBwYXJhbS5cbiAgICBsaW5rLl9fZHluYW1pY0ltcG9ydExvYWRlZCA9IHRydWU7XG4gICAgaWYgKG9ubG9hZCkge1xuICAgICAgd2hlbkltcG9ydHNSZWFkeSgoKSA9PiB7XG4gICAgICAgIG9ubG9hZChldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGxldCBlcnJvckxpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgLy8gSW4gY2FzZSBvZiBhbiBlcnJvciwgcmVtb3ZlIHRoZSBsaW5rIGZyb20gdGhlIGRvY3VtZW50IHNvIHRoYXQgaXRcbiAgICAvLyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgY3JlYXRlZCBhZ2FpbiB0aGUgbmV4dCB0aW1lIGBpbXBvcnRIcmVmYCBpc1xuICAgIC8vIGNhbGxlZC5cbiAgICBpZiAobGluay5wYXJlbnROb2RlKSB7XG4gICAgICBsaW5rLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobGluayk7XG4gICAgfVxuICAgIGlmIChvbmVycm9yKSB7XG4gICAgICB3aGVuSW1wb3J0c1JlYWR5KCgpID0+IHtcbiAgICAgICAgb25lcnJvcihldmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGxvYWRMaXN0ZW5lcik7XG4gIGxpbmsuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgaWYgKGxpbmsucGFyZW50Tm9kZSA9PSBudWxsKSB7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChsaW5rKTtcbiAgLy8gaWYgdGhlIGxpbmsgYWxyZWFkeSBsb2FkZWQsIGRpc3BhdGNoIGEgZmFrZSBsb2FkIGV2ZW50XG4gIC8vIHNvIHRoYXQgbGlzdGVuZXJzIGFyZSBjYWxsZWQgYW5kIGdldCBhIHByb3BlciBldmVudCBhcmd1bWVudC5cbiAgfSBlbHNlIGlmIChsaW5rLl9fZHluYW1pY0ltcG9ydExvYWRlZCkge1xuICAgIGxpbmsuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2xvYWQnKSk7XG4gIH1cbiAgcmV0dXJuIGxpbms7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvdXRpbHMvaW1wb3J0LWhyZWYuanNcbi8vIG1vZHVsZSBpZCA9IDYwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImZ1bmN0aW9uIHJlc29sdmUoKSB7XG4gIGRvY3VtZW50LmJvZHkucmVtb3ZlQXR0cmlidXRlKCd1bnJlc29sdmVkJyk7XG59XG5cbmlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgcmVzb2x2ZSgpO1xufSBlbHNlIHtcbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCByZXNvbHZlKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL3VucmVzb2x2ZWQuanNcbi8vIG1vZHVsZSBpZCA9IDYxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi9ib290LmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNwbGljZXMgfSBmcm9tICcuL2FycmF5LXNwbGljZS5qcyc7XG5pbXBvcnQgeyBtaWNyb1Rhc2sgfSBmcm9tICcuL2FzeW5jLmpzJztcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYG5vZGVgIGlzIGEgc2xvdCBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlIE5vZGUgdG8gdGVzdC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gYG5vZGVgIGlzIGEgc2xvdFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNTbG90KG5vZGUpIHtcbiAgcmV0dXJuIChub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKTtcbn1cblxuLyoqXG4gKiBDbGFzcyB0aGF0IGxpc3RlbnMgZm9yIGNoYW5nZXMgKGFkZGl0aW9ucyBvciByZW1vdmFscykgdG9cbiAqIFwiZmxhdHRlbmVkIG5vZGVzXCIgb24gYSBnaXZlbiBgbm9kZWAuIFRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBjb25zaXN0c1xuICogb2YgYSBub2RlJ3MgY2hpbGRyZW4gYW5kLCBmb3IgYW55IGNoaWxkcmVuIHRoYXQgYXJlIGA8c2xvdD5gIGVsZW1lbnRzLFxuICogdGhlIGV4cGFuZGVkIGZsYXR0ZW5lZCBsaXN0IG9mIGBhc3NpZ25lZE5vZGVzYC5cbiAqIEZvciBleGFtcGxlLCBpZiB0aGUgb2JzZXJ2ZWQgbm9kZSBoYXMgY2hpbGRyZW4gYDxhPjwvYT48c2xvdD48L3Nsb3Q+PGI+PC9iPmBcbiAqIGFuZCB0aGUgYDxzbG90PmAgaGFzIG9uZSBgPGRpdj5gIGFzc2lnbmVkIHRvIGl0LCB0aGVuIHRoZSBmbGF0dGVuZWRcbiAqIG5vZGVzIGxpc3QgaXMgYDxhPjwvYT48ZGl2PjwvZGl2PjxiPjwvYj5gLiBJZiB0aGUgYDxzbG90PmAgaGFzIG90aGVyXG4gKiBgPHNsb3Q+YCBlbGVtZW50cyBhc3NpZ25lZCB0byBpdCwgdGhlc2UgYXJlIGZsYXR0ZW5lZCBhcyB3ZWxsLlxuICpcbiAqIFRoZSBwcm92aWRlZCBgY2FsbGJhY2tgIGlzIGNhbGxlZCB3aGVuZXZlciBhbnkgY2hhbmdlIHRvIHRoaXMgbGlzdFxuICogb2YgZmxhdHRlbmVkIG5vZGVzIG9jY3Vycywgd2hlcmUgYW4gYWRkaXRpb24gb3IgcmVtb3ZhbCBvZiBhIG5vZGUgaXNcbiAqIGNvbnNpZGVyZWQgYSBjaGFuZ2UuIFRoZSBgY2FsbGJhY2tgIGlzIGNhbGxlZCB3aXRoIG9uZSBhcmd1bWVudCwgYW4gb2JqZWN0XG4gKiBjb250YWluaW5nIGFuIGFycmF5IG9mIGFueSBgYWRkZWROb2Rlc2AgYW5kIGByZW1vdmVkTm9kZXNgLlxuICpcbiAqIE5vdGU6IHRoZSBjYWxsYmFjayBpcyBjYWxsZWQgYXN5bmNocm9ub3VzIHRvIGFueSBjaGFuZ2VzXG4gKiBhdCBhIG1pY3JvdGFzayBjaGVja3BvaW50LiBUaGlzIGlzIGJlY2F1c2Ugb2JzZXJ2YXRpb24gaXMgcGVyZm9ybWVkIHVzaW5nXG4gKiBgTXV0YXRpb25PYnNlcnZlcmAgYW5kIHRoZSBgPHNsb3Q+YCBlbGVtZW50J3MgYHNsb3RjaGFuZ2VgIGV2ZW50IHdoaWNoXG4gKiBhcmUgYXN5bmNocm9ub3VzLlxuICpcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VtbWFyeSBDbGFzcyB0aGF0IGxpc3RlbnMgZm9yIGNoYW5nZXMgKGFkZGl0aW9ucyBvciByZW1vdmFscykgdG9cbiAqIFwiZmxhdHRlbmVkIG5vZGVzXCIgb24gYSBnaXZlbiBgbm9kZWAuXG4gKi9cbmNsYXNzIEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIge1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBub2RlcyBmb3IgdGhlIGdpdmVuIGBub2RlYC5cbiAgICogVGhpcyBsaXN0IGNvbnNpc3RzIG9mIGEgbm9kZSdzIGNoaWxkcmVuIGFuZCwgZm9yIGFueSBjaGlsZHJlblxuICAgKiB0aGF0IGFyZSBgPHNsb3Q+YCBlbGVtZW50cywgdGhlIGV4cGFuZGVkIGZsYXR0ZW5lZCBsaXN0IG9mIGBhc3NpZ25lZE5vZGVzYC5cbiAgICogRm9yIGV4YW1wbGUsIGlmIHRoZSBvYnNlcnZlZCBub2RlIGhhcyBjaGlsZHJlbiBgPGE+PC9hPjxzbG90Pjwvc2xvdD48Yj48L2I+YFxuICAgKiBhbmQgdGhlIGA8c2xvdD5gIGhhcyBvbmUgYDxkaXY+YCBhc3NpZ25lZCB0byBpdCwgdGhlbiB0aGUgZmxhdHRlbmVkXG4gICAqIG5vZGVzIGxpc3QgaXMgYDxhPjwvYT48ZGl2PjwvZGl2PjxiPjwvYj5gLiBJZiB0aGUgYDxzbG90PmAgaGFzIG90aGVyXG4gICAqIGA8c2xvdD5gIGVsZW1lbnRzIGFzc2lnbmVkIHRvIGl0LCB0aGVzZSBhcmUgZmxhdHRlbmVkIGFzIHdlbGwuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8SFRNTFNsb3RFbGVtZW50fSBub2RlIFRoZSBub2RlIGZvciB3aGljaCB0byByZXR1cm4gdGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzLlxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIGxpc3Qgb2YgZmxhdHRlbmVkIG5vZGVzIGZvciB0aGUgZ2l2ZW4gYG5vZGVgLlxuICAqL1xuICBzdGF0aWMgZ2V0RmxhdHRlbmVkTm9kZXMobm9kZSkge1xuICAgIGlmIChpc1Nsb3Qobm9kZSkpIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxTbG90RWxlbWVudH0gKi8gKG5vZGUpLmFzc2lnbmVkTm9kZXMoe2ZsYXR0ZW46IHRydWV9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5tYXAobm9kZSA9PiB7XG4gICAgICAgIGlmIChpc1Nsb3Qobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtIVE1MU2xvdEVsZW1lbnR9ICovIChub2RlKS5hc3NpZ25lZE5vZGVzKHtmbGF0dGVuOiB0cnVlfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICAgICAgfVxuICAgICAgfSkucmVkdWNlKChhLCBiKSA9PiBhLmNvbmNhdChiKSwgW10pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge05vZGV9IHRhcmdldCBOb2RlIG9uIHdoaWNoIHRvIGxpc3RlbiBmb3IgY2hhbmdlcy5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgRnVuY3Rpb24gY2FsbGVkIHdoZW4gdGhlcmUgYXJlIGFkZGl0aW9uc1xuICAgKiBvciByZW1vdmFscyBmcm9tIHRoZSB0YXJnZXQncyBsaXN0IG9mIGZsYXR0ZW5lZCBub2Rlcy5cbiAgKi9cbiAgY29uc3RydWN0b3IodGFyZ2V0LCBjYWxsYmFjaykge1xuICAgIC8qKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcn0gKi9cbiAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICB0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzID0gW107XG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NjaGVkdWxlZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oKX0gKi9cbiAgICB0aGlzLl9ib3VuZFNjaGVkdWxlID0gKCkgPT4ge1xuICAgICAgdGhpcy5fc2NoZWR1bGUoKTtcbiAgICB9O1xuICAgIHRoaXMuY29ubmVjdCgpO1xuICAgIHRoaXMuX3NjaGVkdWxlKCk7XG4gIH1cblxuICAvKipcbiAgICogQWN0aXZhdGVzIGFuIG9ic2VydmVyLiBUaGlzIG1ldGhvZCBpcyBhdXRvbWF0aWNhbGx5IGNhbGxlZCB3aGVuXG4gICAqIGEgYEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXJgIGlzIGNyZWF0ZWQuIEl0IHNob3VsZCBvbmx5IGJlIGNhbGxlZCB0b1xuICAgKiByZS1hY3RpdmF0ZSBhbiBvYnNlcnZlciB0aGF0IGhhcyBiZWVuIGRlYWN0aXZhdGVkIHZpYSB0aGUgYGRpc2Nvbm5lY3RgIG1ldGhvZC5cbiAgICovXG4gIGNvbm5lY3QoKSB7XG4gICAgaWYgKGlzU2xvdCh0aGlzLl90YXJnZXQpKSB7XG4gICAgICB0aGlzLl9saXN0ZW5TbG90cyhbdGhpcy5fdGFyZ2V0XSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xpc3RlblNsb3RzKHRoaXMuX3RhcmdldC5jaGlsZHJlbik7XG4gICAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICAgIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlciA9XG4gICAgICAgICAgU2hhZHlET00ub2JzZXJ2ZUNoaWxkcmVuKHRoaXMuX3RhcmdldCwgKG11dGF0aW9ucykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlciA9XG4gICAgICAgICAgbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKG11dGF0aW9ucykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyLm9ic2VydmUodGhpcy5fdGFyZ2V0LCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogRGVhY3RpdmF0ZXMgdGhlIGZsYXR0ZW5lZCBub2RlcyBvYnNlcnZlci4gQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZFxuICAgKiB0aGUgb2JzZXJ2ZXIgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIHdoZW4gY2hhbmdlcyB0byBmbGF0dGVuZWQgbm9kZXNcbiAgICogb2NjdXIuIFRoZSBgY29ubmVjdGAgbWV0aG9kIG1heSBiZSBzdWJzZXF1ZW50bHkgY2FsbGVkIHRvIHJlYWN0aXZhdGVcbiAgICogdGhlIG9ic2VydmVyLlxuICAgKi9cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAoaXNTbG90KHRoaXMuX3RhcmdldCkpIHtcbiAgICAgIHRoaXMuX3VubGlzdGVuU2xvdHMoW3RoaXMuX3RhcmdldF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl91bmxpc3RlblNsb3RzKHRoaXMuX3RhcmdldC5jaGlsZHJlbik7XG4gICAgICBpZiAod2luZG93LlNoYWR5RE9NICYmIHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgICBTaGFkeURPTS51bm9ic2VydmVDaGlsZHJlbih0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIpO1xuICAgICAgICB0aGlzLl9zaGFkeUNoaWxkcmVuT2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuX25hdGl2ZUNoaWxkcmVuT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB0aGlzLl9uYXRpdmVDaGlsZHJlbk9ic2VydmVyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG4gIH1cblxuICBfc2NoZWR1bGUoKSB7XG4gICAgaWYgKCF0aGlzLl9zY2hlZHVsZWQpIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBtaWNyb1Rhc2sucnVuKCgpID0+IHRoaXMuZmx1c2goKSk7XG4gICAgfVxuICB9XG5cbiAgX3Byb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnMobXV0YXRpb25zKTtcbiAgICB0aGlzLmZsdXNoKCk7XG4gIH1cblxuICBfcHJvY2Vzc1Nsb3RNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgaWYgKG11dGF0aW9ucykge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBtdXRhdGlvbiA9IG11dGF0aW9uc1tpXTtcbiAgICAgICAgaWYgKG11dGF0aW9uLmFkZGVkTm9kZXMpIHtcbiAgICAgICAgICB0aGlzLl9saXN0ZW5TbG90cyhtdXRhdGlvbi5hZGRlZE5vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXV0YXRpb24ucmVtb3ZlZE5vZGVzKSB7XG4gICAgICAgICAgdGhpcy5fdW5saXN0ZW5TbG90cyhtdXRhdGlvbi5yZW1vdmVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoZXMgdGhlIG9ic2VydmVyIGNhdXNpbmcgYW55IHBlbmRpbmcgY2hhbmdlcyB0byBiZSBpbW1lZGlhdGVseVxuICAgKiBkZWxpdmVyZWQgdGhlIG9ic2VydmVyIGNhbGxiYWNrLiBCeSBkZWZhdWx0IHRoZXNlIGNoYW5nZXMgYXJlIGRlbGl2ZXJlZFxuICAgKiBhc3luY2hyb25vdXNseSBhdCB0aGUgbmV4dCBtaWNyb3Rhc2sgY2hlY2twb2ludC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gUmV0dXJucyB0cnVlIGlmIGFueSBwZW5kaW5nIGNoYW5nZXMgY2F1c2VkIHRoZSBvYnNlcnZlclxuICAgKiBjYWxsYmFjayB0byBydW4uXG4gICAqL1xuICBmbHVzaCgpIHtcbiAgICBpZiAoIXRoaXMuX2Nvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAod2luZG93LlNoYWR5RE9NKSB7XG4gICAgICBTaGFkeURPTS5mbHVzaCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnModGhpcy5fbmF0aXZlQ2hpbGRyZW5PYnNlcnZlci50YWtlUmVjb3JkcygpKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NoYWR5Q2hpbGRyZW5PYnNlcnZlcikge1xuICAgICAgdGhpcy5fcHJvY2Vzc1Nsb3RNdXRhdGlvbnModGhpcy5fc2hhZHlDaGlsZHJlbk9ic2VydmVyLnRha2VSZWNvcmRzKCkpO1xuICAgIH1cbiAgICB0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBsZXQgaW5mbyA9IHtcbiAgICAgIHRhcmdldDogdGhpcy5fdGFyZ2V0LFxuICAgICAgYWRkZWROb2RlczogW10sXG4gICAgICByZW1vdmVkTm9kZXM6IFtdXG4gICAgfTtcbiAgICBsZXQgbmV3Tm9kZXMgPSB0aGlzLmNvbnN0cnVjdG9yLmdldEZsYXR0ZW5lZE5vZGVzKHRoaXMuX3RhcmdldCk7XG4gICAgbGV0IHNwbGljZXMgPSBjYWxjdWxhdGVTcGxpY2VzKG5ld05vZGVzLFxuICAgICAgdGhpcy5fZWZmZWN0aXZlTm9kZXMpO1xuICAgIC8vIHByb2Nlc3MgcmVtb3ZhbHNcbiAgICBmb3IgKGxldCBpPTAsIHM7IChpPHNwbGljZXMubGVuZ3RoKSAmJiAocz1zcGxpY2VzW2ldKTsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqPTAsIG47IChqIDwgcy5yZW1vdmVkLmxlbmd0aCkgJiYgKG49cy5yZW1vdmVkW2pdKTsgaisrKSB7XG4gICAgICAgIGluZm8ucmVtb3ZlZE5vZGVzLnB1c2gobik7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHByb2Nlc3MgYWRkc1xuICAgIGZvciAobGV0IGk9MCwgczsgKGk8c3BsaWNlcy5sZW5ndGgpICYmIChzPXNwbGljZXNbaV0pOyBpKyspIHtcbiAgICAgIGZvciAobGV0IGo9cy5pbmRleDsgaiA8IHMuaW5kZXggKyBzLmFkZGVkQ291bnQ7IGorKykge1xuICAgICAgICBpbmZvLmFkZGVkTm9kZXMucHVzaChuZXdOb2Rlc1tqXSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVwZGF0ZSBjYWNoZVxuICAgIHRoaXMuX2VmZmVjdGl2ZU5vZGVzID0gbmV3Tm9kZXM7XG4gICAgbGV0IGRpZEZsdXNoID0gZmFsc2U7XG4gICAgaWYgKGluZm8uYWRkZWROb2Rlcy5sZW5ndGggfHwgaW5mby5yZW1vdmVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBkaWRGbHVzaCA9IHRydWU7XG4gICAgICB0aGlzLmNhbGxiYWNrLmNhbGwodGhpcy5fdGFyZ2V0LCBpbmZvKTtcbiAgICB9XG4gICAgcmV0dXJuIGRpZEZsdXNoO1xuICB9XG5cbiAgX2xpc3RlblNsb3RzKG5vZGVMaXN0KSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuID0gbm9kZUxpc3RbaV07XG4gICAgICBpZiAoaXNTbG90KG4pKSB7XG4gICAgICAgIG4uYWRkRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMuX2JvdW5kU2NoZWR1bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF91bmxpc3RlblNsb3RzKG5vZGVMaXN0KSB7XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgbm9kZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBuID0gbm9kZUxpc3RbaV07XG4gICAgICBpZiAoaXNTbG90KG4pKSB7XG4gICAgICAgIG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2xvdGNoYW5nZScsIHRoaXMuX2JvdW5kU2NoZWR1bGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbmV4cG9ydCB7IEZsYXR0ZW5lZE5vZGVzT2JzZXJ2ZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL3V0aWxzL2ZsYXR0ZW5lZC1ub2Rlcy1vYnNlcnZlci5qc1xuLy8gbW9kdWxlIGlkID0gNjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgTGVnYWN5RWxlbWVudE1peGluIH0gZnJvbSAnLi9sZWdhY3ktZWxlbWVudC1taXhpbi5qcyc7XG5pbXBvcnQgeyBEb21Nb2R1bGUgfSBmcm9tICcuLi9lbGVtZW50cy9kb20tbW9kdWxlLmpzJztcblxubGV0IG1ldGFQcm9wcyA9IHtcbiAgYXR0YWNoZWQ6IHRydWUsXG4gIGRldGFjaGVkOiB0cnVlLFxuICByZWFkeTogdHJ1ZSxcbiAgY3JlYXRlZDogdHJ1ZSxcbiAgYmVmb3JlUmVnaXN0ZXI6IHRydWUsXG4gIHJlZ2lzdGVyZWQ6IHRydWUsXG4gIGF0dHJpYnV0ZUNoYW5nZWQ6IHRydWUsXG4gIC8vIG1ldGEgb2JqZWN0c1xuICBiZWhhdmlvcnM6IHRydWVcbn07XG5cbi8qKlxuICogQXBwbGllcyBhIFwibGVnYWN5XCIgYmVoYXZpb3Igb3IgYXJyYXkgb2YgYmVoYXZpb3JzIHRvIHRoZSBwcm92aWRlZCBjbGFzcy5cbiAqXG4gKiBOb3RlOiB0aGlzIG1ldGhvZCB3aWxsIGF1dG9tYXRpY2FsbHkgYWxzbyBhcHBseSB0aGUgYFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluYFxuICogdG8gZW5zdXJlIHRoYXQgYW55IGxlZ2FjeSBiZWhhdmlvcnMgY2FuIHJlbHkgb24gbGVnYWN5IFBvbHltZXIgQVBJIG9uXG4gKiB0aGUgdW5kZXJseWluZyBlbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7IShPYmplY3R8QXJyYXkpfSBiZWhhdmlvcnMgQmVoYXZpb3Igb2JqZWN0IG9yIGFycmF5IG9mIGJlaGF2aW9ycy5cbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fGZ1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IGtsYXNzIEVsZW1lbnQgY2xhc3MuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBSZXR1cm5zIGEgbmV3IEVsZW1lbnQgY2xhc3MgZXh0ZW5kZWQgYnkgdGhlXG4gKiBwYXNzZWQgaW4gYGJlaGF2aW9yc2AgYW5kIGFsc28gYnkgYFBvbHltZXIuTGVnYWN5RWxlbWVudE1peGluYC5cbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAc3VwcHJlc3Mge2ludmFsaWRDYXN0cywgY2hlY2tUeXBlc31cbiAqL1xuZnVuY3Rpb24gbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcykge1xuICBpZiAoIWJlaGF2aW9ycykge1xuICAgIHJldHVybiAvKiogQHR5cGUge0hUTUxFbGVtZW50fSAqLyhrbGFzcyk7XG4gIH1cbiAgLy8gTk9URTogZW5zdXJlIHRoZSBiYWhldmlvciBpcyBleHRlbmRpbmcgYSBjbGFzcyB3aXRoXG4gIC8vIGxlZ2FjeSBlbGVtZW50IGFwaS4gVGhpcyBpcyBuZWNlc3Nhcnkgc2luY2UgYmVoYXZpb3JzIGV4cGVjdCB0byBiZSBhYmxlXG4gIC8vIHRvIGFjY2VzcyAxLnggbGVnYWN5IGFwaS5cbiAga2xhc3MgPSBMZWdhY3lFbGVtZW50TWl4aW4oa2xhc3MpO1xuICBpZiAoIUFycmF5LmlzQXJyYXkoYmVoYXZpb3JzKSkge1xuICAgIGJlaGF2aW9ycyA9IFtiZWhhdmlvcnNdO1xuICB9XG4gIGxldCBzdXBlckJlaGF2aW9ycyA9IGtsYXNzLnByb3RvdHlwZS5iZWhhdmlvcnM7XG4gIC8vIGdldCBmbGF0dGVuZWQsIGRlZHVwZWQgbGlzdCBvZiBiZWhhdmlvcnMgKm5vdCogYWxyZWFkeSBvbiBzdXBlciBjbGFzc1xuICBiZWhhdmlvcnMgPSBmbGF0dGVuQmVoYXZpb3JzKGJlaGF2aW9ycywgbnVsbCwgc3VwZXJCZWhhdmlvcnMpO1xuICAvLyBtaXhpbiBuZXcgYmVoYXZpb3JzXG4gIGtsYXNzID0gX21peGluQmVoYXZpb3JzKGJlaGF2aW9ycywga2xhc3MpO1xuICBpZiAoc3VwZXJCZWhhdmlvcnMpIHtcbiAgICBiZWhhdmlvcnMgPSBzdXBlckJlaGF2aW9ycy5jb25jYXQoYmVoYXZpb3JzKTtcbiAgfVxuICAvLyBTZXQgYmVoYXZpb3JzIG9uIHByb3RvdHlwZSBmb3IgQkMuLi5cbiAga2xhc3MucHJvdG90eXBlLmJlaGF2aW9ycyA9IGJlaGF2aW9ycztcbiAgcmV0dXJuIGtsYXNzO1xufVxuXG4vLyBOT1RFOlxuLy8gMS54XG4vLyBCZWhhdmlvcnMgd2VyZSBtaXhlZCBpbiAqaW4gcmV2ZXJzZSBvcmRlciogYW5kIGRlLWR1cGVkIG9uIHRoZSBmbHkuXG4vLyBUaGUgcnVsZSB3YXMgdGhhdCBiZWhhdmlvciBwcm9wZXJ0aWVzIHdlcmUgY29waWVkIG9udG8gdGhlIGVsZW1lbnRcbi8vIHByb3RvdHlwZSBpZiBhbmQgb25seSBpZiB0aGUgcHJvcGVydHkgZGlkIG5vdCBhbHJlYWR5IGV4aXN0LlxuLy8gR2l2ZW46IFBvbHltZXJ7IGJlaGF2aW9yczogW0EsIEIsIEMsIEEsIEJdfSwgcHJvcGVydHkgY29weSBvcmRlciB3YXM6XG4vLyAoMSksIEIsICgyKSwgQSwgKDMpIEMuIFRoaXMgbWVhbnMgcHJvdG90eXBlIHByb3BlcnRpZXMgd2luIG92ZXJcbi8vIEIgcHJvcGVydGllcyB3aW4gb3ZlciBBIHdpbiBvdmVyIEMuIFRoaXMgbWlycm9ycyB3aGF0IHdvdWxkIGhhcHBlblxuLy8gd2l0aCBpbmhlcml0YW5jZSBpZiBlbGVtZW50IGV4dGVuZGVkIEIgZXh0ZW5kZWQgQSBleHRlbmRlZCBDLlxuLy9cbi8vIEFnYWluIGdpdmVuLCBQb2x5bWVyeyBiZWhhdmlvcnM6IFtBLCBCLCBDLCBBLCBCXX0sIHRoZSByZXN1bHRpbmdcbi8vIGBiZWhhdmlvcnNgIGFycmF5IHdhcyBbQywgQSwgQl0uXG4vLyBCZWhhdmlvciBsaWZlY3ljbGUgbWV0aG9kcyB3ZXJlIGNhbGxlZCBpbiBiZWhhdmlvciBhcnJheSBvcmRlclxuLy8gZm9sbG93ZWQgYnkgdGhlIGVsZW1lbnQsIGUuZy4gKDEpIEMuY3JlYXRlZCwgKDIpIEEuY3JlYXRlZCxcbi8vICgzKSBCLmNyZWF0ZWQsICg0KSBlbGVtZW50LmNyZWF0ZWQuIFRoZXJlIHdhcyBubyBzdXBwb3J0IGZvclxuLy8gc3VwZXIsIGFuZCBcInN1cGVyLWJlaGF2aW9yXCIgbWV0aG9kcyB3ZXJlIGNhbGxhYmxlIG9ubHkgYnkgbmFtZSkuXG4vL1xuLy8gMi54XG4vLyBCZWhhdmlvcnMgYXJlIG1hZGUgaW50byBwcm9wZXIgbWl4aW5zIHdoaWNoIGxpdmUgaW4gdGhlXG4vLyBlbGVtZW50J3MgcHJvdG90eXBlIGNoYWluLiBCZWhhdmlvcnMgYXJlIHBsYWNlZCBpbiB0aGUgZWxlbWVudCBwcm90b3R5cGVcbi8vIGVsZGVzdCB0byB5b3VuZ2VzdCBhbmQgZGUtZHVwZWQgeW91bmdlc3QgdG8gb2xkZXN0OlxuLy8gU28sIGZpcnN0IFtBLCBCLCBDLCBBLCBCXSBiZWNvbWVzIFtDLCBBLCBCXSB0aGVuLFxuLy8gdGhlIGVsZW1lbnQgcHJvdG90eXBlIGJlY29tZXMgKG9sZGVzdCkgKDEpIFBvbHltZXIuRWxlbWVudCwgKDIpIGNsYXNzKEMpLFxuLy8gKDMpIGNsYXNzKEEpLCAoNCkgY2xhc3MoQiksICg1KSBjbGFzcyhQb2x5bWVyKHsuLi59KSkuXG4vLyBSZXN1bHQ6XG4vLyBUaGlzIG1lYW5zIGVsZW1lbnQgcHJvcGVydGllcyB3aW4gb3ZlciBCIHByb3BlcnRpZXMgd2luIG92ZXIgQSB3aW5cbi8vIG92ZXIgQy4gKHNhbWUgYXMgMS54KVxuLy8gSWYgbGlmZWN5Y2xlIGlzIGNhbGxlZCAoc3VwZXIgdGhlbiBtZSksIG9yZGVyIGlzXG4vLyAoMSkgQy5jcmVhdGVkLCAoMikgQS5jcmVhdGVkLCAoMykgQi5jcmVhdGVkLCAoNCkgZWxlbWVudC5jcmVhdGVkXG4vLyAoYWdhaW4gc2FtZSBhcyAxLngpXG5mdW5jdGlvbiBfbWl4aW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBrbGFzcykge1xuICBmb3IgKGxldCBpPTA7IGk8YmVoYXZpb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGIgPSBiZWhhdmlvcnNbaV07XG4gICAgaWYgKGIpIHtcbiAgICAgIGtsYXNzID0gQXJyYXkuaXNBcnJheShiKSA/IF9taXhpbkJlaGF2aW9ycyhiLCBrbGFzcykgOlxuICAgICAgICBHZW5lcmF0ZUNsYXNzRnJvbUluZm8oYiwga2xhc3MpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ga2xhc3M7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gYmVoYXZpb3JzIExpc3Qgb2YgYmVoYXZpb3JzIHRvIGZsYXR0ZW4uXG4gKiBAcGFyYW0ge0FycmF5PX0gbGlzdCBUYXJnZXQgbGlzdCB0byBmbGF0dGVuIGJlaGF2aW9ycyBpbnRvLlxuICogQHBhcmFtIHtBcnJheT19IGV4Y2x1ZGUgTGlzdCBvZiBiZWhhdmlvcnMgdG8gZXhjbHVkZSBmcm9tIHRoZSBsaXN0LlxuICogQHJldHVybiB7IUFycmF5fSBSZXR1cm5zIHRoZSBsaXN0IG9mIGZsYXR0ZW5lZCBiZWhhdmlvcnMuXG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5CZWhhdmlvcnMoYmVoYXZpb3JzLCBsaXN0LCBleGNsdWRlKSB7XG4gIGxpc3QgPSBsaXN0IHx8IFtdO1xuICBmb3IgKGxldCBpPWJlaGF2aW9ycy5sZW5ndGgtMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBsZXQgYiA9IGJlaGF2aW9yc1tpXTtcbiAgICBpZiAoYikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgZmxhdHRlbkJlaGF2aW9ycyhiLCBsaXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRlZHVwXG4gICAgICAgIGlmIChsaXN0LmluZGV4T2YoYikgPCAwICYmICghZXhjbHVkZSB8fCBleGNsdWRlLmluZGV4T2YoYikgPCAwKSkge1xuICAgICAgICAgIGxpc3QudW5zaGlmdChiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ2JlaGF2aW9yIGlzIG51bGwsIGNoZWNrIGZvciBtaXNzaW5nIG9yIDQwNCBpbXBvcnQnKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogQHBhcmFtIHshUG9seW1lckluaXR9IGluZm8gUG9seW1lciBpbmZvIG9iamVjdFxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBCYXNlIGJhc2UgY2xhc3MgdG8gZXh0ZW5kIHdpdGggaW5mbyBvYmplY3RcbiAqIEByZXR1cm4ge2Z1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9IEdlbmVyYXRlZCBjbGFzc1xuICogQHN1cHByZXNzIHtjaGVja1R5cGVzfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGluZm8sIEJhc2UpIHtcblxuICBjbGFzcyBQb2x5bWVyR2VuZXJhdGVkIGV4dGVuZHMgQmFzZSB7XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICByZXR1cm4gaW5mby5wcm9wZXJ0aWVzO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgcmV0dXJuIGluZm8ub2JzZXJ2ZXJzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlIGZvciB0aGlzIGNsYXNzXG4gICAgICovXG4gICAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHtcbiAgICAgIC8vIGdldCB0ZW1wbGF0ZSBmaXJzdCBmcm9tIGFueSBpbXBlcmF0aXZlIHNldCBpbiBgaW5mby5fdGVtcGxhdGVgXG4gICAgICByZXR1cm4gaW5mby5fdGVtcGxhdGUgfHxcbiAgICAgICAgLy8gbmV4dCBsb29rIGluIGRvbS1tb2R1bGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgZWxlbWVudCdzIGlzLlxuICAgICAgICBEb21Nb2R1bGUgJiYgRG9tTW9kdWxlLmltcG9ydCh0aGlzLmlzLCAndGVtcGxhdGUnKSB8fFxuICAgICAgICAvLyBuZXh0IGxvb2sgZm9yIHN1cGVyY2xhc3MgdGVtcGxhdGUgKG5vdGU6IHVzZSBzdXBlcmNsYXNzIHN5bWJvbFxuICAgICAgICAvLyB0byBlbnN1cmUgY29ycmVjdCBgdGhpcy5pc2ApXG4gICAgICAgIEJhc2UudGVtcGxhdGUgfHxcbiAgICAgICAgLy8gZmluYWxseSBmYWxsIGJhY2sgdG8gYF90ZW1wbGF0ZWAgaW4gZWxlbWVudCdzIHByb3RveXBlLlxuICAgICAgICB0aGlzLnByb3RvdHlwZS5fdGVtcGxhdGUgfHxcbiAgICAgICAgbnVsbDtcbiAgICB9XG5cbiAgICBjcmVhdGVkKCkge1xuICAgICAgc3VwZXIuY3JlYXRlZCgpO1xuICAgICAgaWYgKGluZm8uY3JlYXRlZCkge1xuICAgICAgICBpbmZvLmNyZWF0ZWQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBfcmVnaXN0ZXJlZCgpIHtcbiAgICAgIHN1cGVyLl9yZWdpc3RlcmVkKCk7XG4gICAgICAvKiBOT1RFOiBgYmVmb3JlUmVnaXN0ZXJgIGlzIGNhbGxlZCBoZXJlIGZvciBiYywgYnV0IHRoZSBiZWhhdmlvclxuICAgICAgIGlzIGRpZmZlcmVudCB0aGFuIGluIDEueC4gSW4gMS4wLCB0aGUgbWV0aG9kIHdhcyBjYWxsZWQgKmFmdGVyKlxuICAgICAgIG1peGluZyBwcm90b3R5cGVzIHRvZ2V0aGVyIGJ1dCAqYmVmb3JlKiBwcm9jZXNzaW5nIG9mIG1ldGEtb2JqZWN0cy5cbiAgICAgICBIb3dldmVyLCBkeW5hbWljIGVmZmVjdHMgY2FuIHN0aWxsIGJlIHNldCBoZXJlIGFuZCBjYW4gYmUgZG9uZSBlaXRoZXJcbiAgICAgICBpbiBgYmVmb3JlUmVnaXN0ZXJgIG9yIGByZWdpc3RlcmVkYC4gSXQgaXMgbm8gbG9uZ2VyIHBvc3NpYmxlIHRvIHNldFxuICAgICAgIGBpc2AgaW4gYGJlZm9yZVJlZ2lzdGVyYCBhcyB5b3UgY291bGQgaW4gMS54LlxuICAgICAgKi9cbiAgICAgIGlmIChpbmZvLmJlZm9yZVJlZ2lzdGVyKSB7XG4gICAgICAgIGluZm8uYmVmb3JlUmVnaXN0ZXIuY2FsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgfVxuICAgICAgaWYgKGluZm8ucmVnaXN0ZXJlZCkge1xuICAgICAgICBpbmZvLnJlZ2lzdGVyZWQuY2FsbChPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIF9hcHBseUxpc3RlbmVycygpIHtcbiAgICAgIHN1cGVyLl9hcHBseUxpc3RlbmVycygpO1xuICAgICAgaWYgKGluZm8ubGlzdGVuZXJzKSB7XG4gICAgICAgIGZvciAobGV0IGwgaW4gaW5mby5saXN0ZW5lcnMpIHtcbiAgICAgICAgICB0aGlzLl9hZGRNZXRob2RFdmVudExpc3RlbmVyVG9Ob2RlKHRoaXMsIGwsIGluZm8ubGlzdGVuZXJzW2xdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG5vdGU6IGV4Y2VwdGlvbiB0byBcInN1cGVyIHRoZW4gbWVcIiBydWxlO1xuICAgIC8vIGRvIHdvcmsgYmVmb3JlIGNhbGxpbmcgc3VwZXIgc28gdGhhdCBzdXBlciBhdHRyaWJ1dGVzXG4gICAgLy8gb25seSBhcHBseSBpZiBub3QgYWxyZWFkeSBzZXQuXG4gICAgX2Vuc3VyZUF0dHJpYnV0ZXMoKSB7XG4gICAgICBpZiAoaW5mby5ob3N0QXR0cmlidXRlcykge1xuICAgICAgICBmb3IgKGxldCBhIGluIGluZm8uaG9zdEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICB0aGlzLl9lbnN1cmVBdHRyaWJ1dGUoYSwgaW5mby5ob3N0QXR0cmlidXRlc1thXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN1cGVyLl9lbnN1cmVBdHRyaWJ1dGVzKCk7XG4gICAgfVxuXG4gICAgcmVhZHkoKSB7XG4gICAgICBzdXBlci5yZWFkeSgpO1xuICAgICAgaWYgKGluZm8ucmVhZHkpIHtcbiAgICAgICAgaW5mby5yZWFkeS5jYWxsKHRoaXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGF0dGFjaGVkKCkge1xuICAgICAgc3VwZXIuYXR0YWNoZWQoKTtcbiAgICAgIGlmIChpbmZvLmF0dGFjaGVkKSB7XG4gICAgICAgIGluZm8uYXR0YWNoZWQuY2FsbCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZXRhY2hlZCgpIHtcbiAgICAgIHN1cGVyLmRldGFjaGVkKCk7XG4gICAgICBpZiAoaW5mby5kZXRhY2hlZCkge1xuICAgICAgICBpbmZvLmRldGFjaGVkLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgYXR0cmlidXRlQ2hhbmdlZChuYW1lLCBvbGQsIHZhbHVlKSB7XG4gICAgICBzdXBlci5hdHRyaWJ1dGVDaGFuZ2VkKG5hbWUsIG9sZCwgdmFsdWUpO1xuICAgICAgaWYgKGluZm8uYXR0cmlidXRlQ2hhbmdlZCkge1xuICAgICAgICBpbmZvLmF0dHJpYnV0ZUNoYW5nZWQuY2FsbCh0aGlzLCBuYW1lLCBvbGQsIHZhbHVlKTtcbiAgICAgIH1cbiAgIH1cbiAgfVxuXG4gIFBvbHltZXJHZW5lcmF0ZWQuZ2VuZXJhdGVkRnJvbSA9IGluZm87XG5cbiAgZm9yIChsZXQgcCBpbiBpbmZvKSB7XG4gICAgLy8gTk9URTogY2Fubm90IGNvcHkgYG1ldGFQcm9wc2AgbWV0aG9kcyBvbnRvIHByb3RvdHlwZSBhdCBsZWFzdCBiZWNhdXNlXG4gICAgLy8gYHN1cGVyLnJlYWR5YCBtdXN0IGJlIGNhbGxlZCBhbmQgaXMgbm90IGluY2x1ZGVkIGluIHRoZSB1c2VyIGZuLlxuICAgIGlmICghKHAgaW4gbWV0YVByb3BzKSkge1xuICAgICAgbGV0IHBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmZvLCBwKTtcbiAgICAgIGlmIChwZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUG9seW1lckdlbmVyYXRlZC5wcm90b3R5cGUsIHAsIHBkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gUG9seW1lckdlbmVyYXRlZDtcbn1cblxuZXhwb3J0IGNvbnN0IENsYXNzID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoIWluZm8pIHtcbiAgICBjb25zb2xlLndhcm4oJ1BvbHltZXIuQ2xhc3MgcmVxdWlyZXMgYGluZm9gIGFyZ3VtZW50Jyk7XG4gIH1cbiAgbGV0IGtsYXNzID0gR2VuZXJhdGVDbGFzc0Zyb21JbmZvKGluZm8sIGluZm8uYmVoYXZpb3JzID9cbiAgICAvLyBub3RlOiBtaXhpbkJlaGF2aW9ycyBlbnN1cmVzIGBMZWdhY3lFbGVtZW50TWl4aW5gLlxuICAgIG1peGluQmVoYXZpb3JzKGluZm8uYmVoYXZpb3JzLCBIVE1MRWxlbWVudCkgOlxuICAgIExlZ2FjeUVsZW1lbnRNaXhpbihIVE1MRWxlbWVudCkpO1xuICAvLyBkZWNvcmF0ZSBrbGFzcyB3aXRoIHJlZ2lzdHJhdGlvbiBpbmZvXG4gIGtsYXNzLmlzID0gaW5mby5pcztcbiAgcmV0dXJuIGtsYXNzO1xufTtcblxuZXhwb3J0IHsgbWl4aW5CZWhhdmlvcnMgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS9jbGFzcy5qc1xuLy8gbW9kdWxlIGlkID0gNjNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgVGVtcGxhdGVJbnN0YW5jZUJhc2UgYXMgVGVtcGxhdGVJbnN0YW5jZUJhc2UkMCwgVGVtcGxhdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3RlbXBsYXRpemUuanMnO1xuXG5sZXQgVGVtcGxhdGVJbnN0YW5jZUJhc2UgPSBUZW1wbGF0ZUluc3RhbmNlQmFzZSQwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgX3RlbXBsYXRpemVyVGVtcGxhdGU6IEhUTUxUZW1wbGF0ZUVsZW1lbnQsXG4gKiAgIF9wYXJlbnRNb2RlbDogYm9vbGVhbixcbiAqICAgX2luc3RhbmNlUHJvcHM6IE9iamVjdCxcbiAqICAgX2ZvcndhcmRIb3N0UHJvcFYyOiBGdW5jdGlvbixcbiAqICAgX25vdGlmeUluc3RhbmNlUHJvcFYyOiBGdW5jdGlvbixcbiAqICAgY3RvcjogVGVtcGxhdGVJbnN0YW5jZUJhc2VcbiAqIH19XG4gKi9cbmxldCBUZW1wbGF0aXplclVzZXI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBUaGUgYFBvbHltZXIuVGVtcGxhdGl6ZXJgIGJlaGF2aW9yIGFkZHMgbWV0aG9kcyB0byBnZW5lcmF0ZSBpbnN0YW5jZXMgb2ZcbiAqIHRlbXBsYXRlcyB0aGF0IGFyZSBlYWNoIG1hbmFnZWQgYnkgYW4gYW5vbnltb3VzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2BcbiAqIGluc3RhbmNlIHdoZXJlIGRhdGEtYmluZGluZ3MgaW4gdGhlIHN0YW1wZWQgdGVtcGxhdGUgY29udGVudCBhcmUgYm91bmQgdG9cbiAqIGFjY2Vzc29ycyBvbiBpdHNlbGYuXG4gKlxuICogVGhpcyBiZWhhdmlvciBpcyBwcm92aWRlZCBpbiBQb2x5bWVyIDIueCBhcyBhIGh5YnJpZC1lbGVtZW50IGNvbnZlbmllbmNlXG4gKiBvbmx5LiAgRm9yIG5vbi1oeWJyaWQgdXNhZ2UsIHRoZSBgUG9seW1lci5UZW1wbGF0aXplYCBsaWJyYXJ5XG4gKiBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIC8vIEdldCBhIHRlbXBsYXRlIGZyb20gc29tZXdoZXJlLCBlLmcuIGxpZ2h0IERPTVxuICogICAgIGxldCB0ZW1wbGF0ZSA9IHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKTtcbiAqICAgICAvLyBQcmVwYXJlIHRoZSB0ZW1wbGF0ZVxuICogICAgIHRoaXMudGVtcGxhdGl6ZSh0ZW1wbGF0ZSk7XG4gKiAgICAgLy8gSW5zdGFuY2UgdGhlIHRlbXBsYXRlIHdpdGggYW4gaW5pdGlhbCBkYXRhIG1vZGVsXG4gKiAgICAgbGV0IGluc3RhbmNlID0gdGhpcy5zdGFtcCh7bXlQcm9wOiAnaW5pdGlhbCd9KTtcbiAqICAgICAvLyBJbnNlcnQgdGhlIGluc3RhbmNlJ3MgRE9NIHNvbWV3aGVyZSwgZS5nLiBsaWdodCBET01cbiAqICAgICBQb2x5bWVyLmRvbSh0aGlzKS5hcHBlbmRDaGlsZChpbnN0YW5jZS5yb290KTtcbiAqICAgICAvLyBDaGFuZ2luZyBhIHByb3BlcnR5IG9uIHRoZSBpbnN0YW5jZSB3aWxsIHByb3BhZ2F0ZSB0byBiaW5kaW5nc1xuICogICAgIC8vIGluIHRoZSB0ZW1wbGF0ZVxuICogICAgIGluc3RhbmNlLm15UHJvcCA9ICduZXcgdmFsdWUnO1xuICpcbiAqIFVzZXJzIG9mIGBUZW1wbGF0aXplcmAgbWF5IG5lZWQgdG8gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgYWJzdHJhY3RcbiAqIEFQSSdzIHRvIGRldGVybWluZSBob3cgcHJvcGVydGllcyBhbmQgcGF0aHMgZnJvbSB0aGUgaG9zdCBzaG91bGQgYmVcbiAqIGZvcndhcmRlZCBpbnRvIHRvIGluc3RhbmNlczpcbiAqXG4gKiAgICAgX2ZvcndhcmRIb3N0UHJvcFYyOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSlcbiAqXG4gKiBMaWtld2lzZSwgdXNlcnMgbWF5IGltcGxlbWVudCB0aGVzZSBhZGRpdGlvbmFsIGFic3RyYWN0IEFQSSdzIHRvIGRldGVybWluZVxuICogaG93IGluc3RhbmNlLXNwZWNpZmljIHByb3BlcnRpZXMgdGhhdCBjaGFuZ2Ugb24gdGhlIGluc3RhbmNlIHNob3VsZCBiZVxuICogZm9yd2FyZGVkIG91dCB0byB0aGUgaG9zdCwgaWYgbmVjZXNzYXJ5LlxuICpcbiAqICAgICBfbm90aWZ5SW5zdGFuY2VQcm9wVjI6IGZ1bmN0aW9uKGluc3QsIHByb3AsIHZhbHVlKVxuICpcbiAqIEluIG9yZGVyIHRvIGRldGVybWluZSB3aGljaCBwcm9wZXJ0aWVzIGFyZSBpbnN0YW5jZS1zcGVjaWZpYyBhbmQgcmVxdWlyZVxuICogY3VzdG9tIG5vdGlmaWNhdGlvbiB2aWEgYF9ub3RpZnlJbnN0YW5jZVByb3BgLCBkZWZpbmUgYW4gYF9pbnN0YW5jZVByb3BzYFxuICogb2JqZWN0IGNvbnRhaW5pbmcga2V5cyBmb3IgZWFjaCBpbnN0YW5jZSBwcm9wLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgX2luc3RhbmNlUHJvcHM6IHtcbiAqICAgICAgIGl0ZW06IHRydWUsXG4gKiAgICAgICBpbmRleDogdHJ1ZVxuICogICAgIH1cbiAqXG4gKiBBbnkgcHJvcGVydGllcyB1c2VkIGluIHRoZSB0ZW1wbGF0ZSB0aGF0IGFyZSBub3QgZGVmaW5lZCBpbiBfaW5zdGFuY2VQcm9wXG4gKiB3aWxsIGJlIGZvcndhcmRlZCBvdXQgdG8gdGhlIFRlbXBsYXRpemUgYG93bmVyYCBhdXRvbWF0aWNhbGx5LlxuICpcbiAqIFVzZXJzIG1heSBhbHNvIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIGFic3RyYWN0IGZ1bmN0aW9uIHRvIHNob3cgb3JcbiAqIGhpZGUgYW55IERPTSBnZW5lcmF0ZWQgdXNpbmcgYHN0YW1wYDpcbiAqXG4gKiAgICAgX3Nob3dIaWRlQ2hpbGRyZW46IGZ1bmN0aW9uKHNob3VsZEhpZGUpXG4gKlxuICogTm90ZSB0aGF0IHNvbWUgY2FsbGJhY2tzIGFyZSBzdWZmaXhlZCB3aXRoIGBWMmAgaW4gdGhlIFBvbHltZXIgMi54IGJlaGF2aW9yXG4gKiBhcyB0aGUgaW1wbGVtZW50YXRpb25zIHdpbGwgbmVlZCB0byBkaWZmZXIgZnJvbSB0aGUgY2FsbGJhY2tzIHJlcXVpcmVkXG4gKiBieSB0aGUgMS54IFRlbXBsYXRpemVyIEFQSSBkdWUgdG8gY2hhbmdlcyBpbiB0aGUgYFRlbXBsYXRlSW5zdGFuY2VgIEFQSVxuICogYmV0d2VlbiB2ZXJzaW9ucyAxLnggYW5kIDIueC5cbiAqXG4gKiBAcG9seW1lckJlaGF2aW9yXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICovXG5sZXQgVGVtcGxhdGl6ZXIgPSB7XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhbiBhbm9ueW1vdXMgYFRlbXBsYXRlSW5zdGFuY2VgIGNsYXNzIChzdG9yZWQgYXMgYHRoaXMuY3RvcmApXG4gICAqIGZvciB0aGUgcHJvdmlkZWQgdGVtcGxhdGUuICBUaGlzIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkIG9uY2UgcGVyXG4gICAqIHRlbXBsYXRlIHRvIHByZXBhcmUgYW4gZWxlbWVudCBmb3Igc3RhbXBpbmcgdGhlIHRlbXBsYXRlLCBmb2xsb3dlZFxuICAgKiBieSBgc3RhbXBgIHRvIGNyZWF0ZSBuZXcgaW5zdGFuY2VzIG9mIHRoZSB0ZW1wbGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZSBUZW1wbGF0ZSB0byBwcmVwYXJlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IG11dGFibGVEYXRhIFdoZW4gYHRydWVgLCB0aGUgZ2VuZXJhdGVkIGNsYXNzIHdpbGwgc2tpcFxuICAgKiAgIHN0cmljdCBkaXJ0eS1jaGVja2luZyBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIChhbHdheXMgY29uc2lkZXIgdGhlbSB0b1xuICAgKiAgIGJlIFwiZGlydHlcIikuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgKi9cbiAgdGVtcGxhdGl6ZSh0ZW1wbGF0ZSwgbXV0YWJsZURhdGEpIHtcbiAgICB0aGlzLl90ZW1wbGF0aXplclRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgdGhpcy5jdG9yID0gVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICBtdXRhYmxlRGF0YTogQm9vbGVhbihtdXRhYmxlRGF0YSksXG4gICAgICBwYXJlbnRNb2RlbDogdGhpcy5fcGFyZW50TW9kZWwsXG4gICAgICBpbnN0YW5jZVByb3BzOiB0aGlzLl9pbnN0YW5jZVByb3BzLFxuICAgICAgZm9yd2FyZEhvc3RQcm9wOiB0aGlzLl9mb3J3YXJkSG9zdFByb3BWMixcbiAgICAgIG5vdGlmeUluc3RhbmNlUHJvcDogdGhpcy5fbm90aWZ5SW5zdGFuY2VQcm9wVjJcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiB0aGUgdGVtcGxhdGUgcHJlcGFyZWQgYnkgYHRlbXBsYXRpemVgLiAgVGhlIG9iamVjdFxuICAgKiByZXR1cm5lZCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgYW5vbnltb3VzIGNsYXNzIGdlbmVyYXRlZCBieSBgdGVtcGxhdGl6ZWBcbiAgICogd2hvc2UgYHJvb3RgIHByb3BlcnR5IGlzIGEgZG9jdW1lbnQgZnJhZ21lbnQgY29udGFpbmluZyBuZXdseSBjbG9uZWRcbiAgICogdGVtcGxhdGUgY29udGVudCwgYW5kIHdoaWNoIGhhcyBwcm9wZXJ0eSBhY2Nlc3NvcnMgY29ycmVzcG9uZGluZyB0b1xuICAgKiBwcm9wZXJ0aWVzIHJlZmVyZW5jZWQgaW4gdGVtcGxhdGUgYmluZGluZ3MuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gbW9kZWwgT2JqZWN0IGNvbnRhaW5pbmcgaW5pdGlhbCBwcm9wZXJ0eSB2YWx1ZXMgdG9cbiAgICogICBwb3B1bGF0ZSBpbnRvIHRoZSB0ZW1wbGF0ZSBiaW5kaW5ncy5cbiAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IFJldHVybnMgdGhlIGNyZWF0ZWQgaW5zdGFuY2Ugb2ZcbiAgICogdGhlIHRlbXBsYXRlIHByZXBhcmVkIGJ5IGB0ZW1wbGF0aXplYC5cbiAgICogQHRoaXMge1RlbXBsYXRpemVyVXNlcn1cbiAgICovXG4gIHN0YW1wKG1vZGVsKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmN0b3IobW9kZWwpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgKGBUZW1wbGF0ZUluc3RhbmNlYCkgYXNzb2NpYXRlZCB3aXRoXG4gICAqIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2ggc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGVcbiAgICogaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXMgY29udGFpbmVkIGluLiAgQSB0ZW1wbGF0ZSBtb2RlbCBzaG91bGQgYmUgdXNlZFxuICAgKiB0byBtYW5pcHVsYXRlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoaXMgdGVtcGxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiBhIHRlbXBsYXRlIG1vZGVsLlxuICAgKiBAcmV0dXJuIHtUZW1wbGF0ZUluc3RhbmNlQmFzZX0gTW9kZWwgcmVwcmVzZW50aW5nIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICAgKiAgIHRoZSBlbGVtZW50LlxuICAgKiBAdGhpcyB7VGVtcGxhdGl6ZXJVc2VyfVxuICAgKi9cbiAgbW9kZWxGb3JFbGVtZW50KGVsKSB7XG4gICAgcmV0dXJuIFRlbXBsYXRpemUubW9kZWxGb3JFbGVtZW50KHRoaXMuX3RlbXBsYXRpemVyVGVtcGxhdGUsIGVsKTtcbiAgfVxufTtcblxuZXhwb3J0IHsgVGVtcGxhdGl6ZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2xlZ2FjeS90ZW1wbGF0aXplci1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi91dGlscy9ib290LmpzJztcbmltcG9ydCB7IFByb3BlcnR5RWZmZWN0cyB9IGZyb20gJy4uL21peGlucy9wcm9wZXJ0eS1lZmZlY3RzLmpzJztcbmltcG9ydCB7IE9wdGlvbmFsTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcbmltcG9ydCB7IEdlc3R1cmVFdmVudExpc3RlbmVycyB9IGZyb20gJy4uL21peGlucy9nZXN0dXJlLWV2ZW50LWxpc3RlbmVycy5qcyc7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAZXh0ZW5kcyB7SFRNTEVsZW1lbnR9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9Qcm9wZXJ0eUVmZmVjdHN9XG4gKiBAaW1wbGVtZW50cyB7UG9seW1lcl9PcHRpb25hbE11dGFibGVEYXRhfVxuICogQGltcGxlbWVudHMge1BvbHltZXJfR2VzdHVyZUV2ZW50TGlzdGVuZXJzfVxuICovXG5jb25zdCBkb21CaW5kQmFzZSA9XG4gIEdlc3R1cmVFdmVudExpc3RlbmVycyhcbiAgICBPcHRpb25hbE11dGFibGVEYXRhKFxuICAgICAgUHJvcGVydHlFZmZlY3RzKEhUTUxFbGVtZW50KSkpO1xuXG4vKipcbiAqIEN1c3RvbSBlbGVtZW50IHRvIGFsbG93IHVzaW5nIFBvbHltZXIncyB0ZW1wbGF0ZSBmZWF0dXJlcyAoZGF0YSBiaW5kaW5nLFxuICogZGVjbGFyYXRpdmUgZXZlbnQgbGlzdGVuZXJzLCBldGMuKSBpbiB0aGUgbWFpbiBkb2N1bWVudCB3aXRob3V0IGRlZmluaW5nXG4gKiBhIG5ldyBjdXN0b20gZWxlbWVudC5cbiAqXG4gKiBgPHRlbXBsYXRlPmAgdGFncyB1dGlsaXppbmcgYmluZGluZ3MgbWF5IGJlIHdyYXBwZWQgd2l0aCB0aGUgYDxkb20tYmluZD5gXG4gKiBlbGVtZW50LCB3aGljaCB3aWxsIGltbWVkaWF0ZWx5IHN0YW1wIHRoZSB3cmFwcGVkIHRlbXBsYXRlIGludG8gdGhlIG1haW5cbiAqIGRvY3VtZW50IGFuZCBiaW5kIGVsZW1lbnRzIHRvIHRoZSBgZG9tLWJpbmRgIGVsZW1lbnQgaXRzZWxmIGFzIHRoZVxuICogYmluZGluZyBzY29wZS5cbiAqXG4gKiBAcG9seW1lclxuICogQGN1c3RvbUVsZW1lbnRcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5Qcm9wZXJ0eUVmZmVjdHNcbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhXG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuR2VzdHVyZUV2ZW50TGlzdGVuZXJzXG4gKiBAZXh0ZW5kcyB7ZG9tQmluZEJhc2V9XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdG8gYWxsb3cgdXNpbmcgUG9seW1lcidzIHRlbXBsYXRlIGZlYXR1cmVzIChkYXRhXG4gKiAgIGJpbmRpbmcsIGRlY2xhcmF0aXZlIGV2ZW50IGxpc3RlbmVycywgZXRjLikgaW4gdGhlIG1haW4gZG9jdW1lbnQuXG4gKi9cbmNsYXNzIERvbUJpbmQgZXh0ZW5kcyBkb21CaW5kQmFzZSB7XG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7IHJldHVybiBbJ211dGFibGUtZGF0YSddOyB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnJvb3QgPSBudWxsO1xuICAgIHRoaXMuJCA9IG51bGw7XG4gICAgdGhpcy5fX2NoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIC8vIGFzc3VtZXMgb25seSBvbmUgb2JzZXJ2ZWQgYXR0cmlidXRlXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLm11dGFibGVEYXRhID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMucmVuZGVyKCk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLl9fcmVtb3ZlQ2hpbGRyZW4oKTtcbiAgfVxuXG4gIF9faW5zZXJ0Q2hpbGRyZW4oKSB7XG4gICAgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0aGlzLnJvb3QsIHRoaXMpO1xuICB9XG5cbiAgX19yZW1vdmVDaGlsZHJlbigpIHtcbiAgICBpZiAodGhpcy5fX2NoaWxkcmVuKSB7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMucm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9fY2hpbGRyZW5baV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjZXMgdGhlIGVsZW1lbnQgdG8gcmVuZGVyIGl0cyBjb250ZW50LiBUaGlzIGlzIHR5cGljYWxseSBvbmx5XG4gICAqIG5lY2Vzc2FyeSB0byBjYWxsIGlmIEhUTUxJbXBvcnRzIHdpdGggdGhlIGFzeW5jIGF0dHJpYnV0ZSBhcmUgdXNlZC5cbiAgICovXG4gIHJlbmRlcigpIHtcbiAgICBsZXQgdGVtcGxhdGU7XG4gICAgaWYgKCF0aGlzLl9fY2hpbGRyZW4pIHtcbiAgICAgIHRlbXBsYXRlID0gLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyh0ZW1wbGF0ZSB8fCB0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3RlbXBsYXRlJykpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgdGVtcGxhdGUgPSAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSk7XG4gICAgICAgICAgaWYgKHRlbXBsYXRlKSB7XG4gICAgICAgICAgICBvYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1iaW5kIHJlcXVpcmVzIGEgPHRlbXBsYXRlPiBjaGlsZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIG9ic2VydmVyLm9ic2VydmUodGhpcywge2NoaWxkTGlzdDogdHJ1ZX0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJvb3QgPSB0aGlzLl9zdGFtcFRlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIHRoaXMuJCA9IHRoaXMucm9vdC4kO1xuICAgICAgdGhpcy5fX2NoaWxkcmVuID0gW107XG4gICAgICBmb3IgKGxldCBuPXRoaXMucm9vdC5maXJzdENoaWxkOyBuOyBuPW4ubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgdGhpcy5fX2NoaWxkcmVuW3RoaXMuX19jaGlsZHJlbi5sZW5ndGhdID0gbjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VuYWJsZVByb3BlcnRpZXMoKTtcbiAgICB9XG4gICAgdGhpcy5fX2luc2VydENoaWxkcmVuKCk7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnZG9tLWNoYW5nZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjb21wb3NlZDogdHJ1ZVxuICAgIH0pKTtcbiAgfVxuXG59XG5cbmN1c3RvbUVsZW1lbnRzLmRlZmluZSgnZG9tLWJpbmQnLCBEb21CaW5kKTtcblxuZXhwb3J0IHsgRG9tQmluZCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcG9seW1lci9saWIvZWxlbWVudHMvZG9tLWJpbmQuanNcbi8vIG1vZHVsZSBpZCA9IDY1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi8uLi9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGVJbnN0YW5jZUJhc2UgYXMgVGVtcGxhdGVJbnN0YW5jZUJhc2UkMCwgVGVtcGxhdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3RlbXBsYXRpemUuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VyIH0gZnJvbSAnLi4vdXRpbHMvZGVib3VuY2UuanMnO1xuaW1wb3J0IHsgZW5xdWV1ZURlYm91bmNlciwgZmx1c2ggfSBmcm9tICcuLi91dGlscy9mbHVzaC5qcyc7XG5pbXBvcnQgeyBPcHRpb25hbE11dGFibGVEYXRhIH0gZnJvbSAnLi4vbWl4aW5zL211dGFibGUtZGF0YS5qcyc7XG5pbXBvcnQgeyBtYXRjaGVzLCB0cmFuc2xhdGUgfSBmcm9tICcuLi91dGlscy9wYXRoLmpzJztcbmltcG9ydCB7IHRpbWVPdXQsIG1pY3JvVGFzayB9IGZyb20gJy4uL3V0aWxzL2FzeW5jLmpzJztcblxubGV0IFRlbXBsYXRlSW5zdGFuY2VCYXNlID0gVGVtcGxhdGVJbnN0YW5jZUJhc2UkMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGltcGxlbWVudHMge1BvbHltZXJfT3B0aW9uYWxNdXRhYmxlRGF0YX1cbiAqIEBleHRlbmRzIHtQb2x5bWVyLkVsZW1lbnR9XG4gKi9cbmNvbnN0IGRvbVJlcGVhdEJhc2UgPSBPcHRpb25hbE11dGFibGVEYXRhKEVsZW1lbnQpO1xuXG4vKipcbiAqIFRoZSBgPGRvbS1yZXBlYXQ+YCBlbGVtZW50IHdpbGwgYXV0b21hdGljYWxseSBzdGFtcCBhbmQgYmluZHMgb25lIGluc3RhbmNlXG4gKiBvZiB0ZW1wbGF0ZSBjb250ZW50IHRvIGVhY2ggb2JqZWN0IGluIGEgdXNlci1wcm92aWRlZCBhcnJheS5cbiAqIGBkb20tcmVwZWF0YCBhY2NlcHRzIGFuIGBpdGVtc2AgcHJvcGVydHksIGFuZCBvbmUgaW5zdGFuY2Ugb2YgdGhlIHRlbXBsYXRlXG4gKiBpcyBzdGFtcGVkIGZvciBlYWNoIGl0ZW0gaW50byB0aGUgRE9NIGF0IHRoZSBsb2NhdGlvbiBvZiB0aGUgYGRvbS1yZXBlYXRgXG4gKiBlbGVtZW50LiAgVGhlIGBpdGVtYCBwcm9wZXJ0eSB3aWxsIGJlIHNldCBvbiBlYWNoIGluc3RhbmNlJ3MgYmluZGluZ1xuICogc2NvcGUsIHRodXMgdGVtcGxhdGVzIHNob3VsZCBiaW5kIHRvIHN1Yi1wcm9wZXJ0aWVzIG9mIGBpdGVtYC5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqIGBgYGh0bWxcbiAqIDxkb20tbW9kdWxlIGlkPVwiZW1wbG95ZWUtbGlzdFwiPlxuICpcbiAqICAgPHRlbXBsYXRlPlxuICpcbiAqICAgICA8ZGl2PiBFbXBsb3llZSBsaXN0OiA8L2Rpdj5cbiAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCI+XG4gKiAgICAgICAgIDxkaXY+Rmlyc3QgbmFtZTogPHNwYW4+e3tpdGVtLmZpcnN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgICAgIDxkaXY+TGFzdCBuYW1lOiA8c3Bhbj57e2l0ZW0ubGFzdH19PC9zcGFuPjwvZGl2PlxuICogICAgIDwvdGVtcGxhdGU+XG4gKlxuICogICA8L3RlbXBsYXRlPlxuICpcbiAqICAgPHNjcmlwdD5cbiAqICAgICBQb2x5bWVyKHtcbiAqICAgICAgIGlzOiAnZW1wbG95ZWUtbGlzdCcsXG4gKiAgICAgICByZWFkeTogZnVuY3Rpb24oKSB7XG4gKiAgICAgICAgIHRoaXMuZW1wbG95ZWVzID0gW1xuICogICAgICAgICAgICAge2ZpcnN0OiAnQm9iJywgbGFzdDogJ1NtaXRoJ30sXG4gKiAgICAgICAgICAgICB7Zmlyc3Q6ICdTYWxseScsIGxhc3Q6ICdKb2huc29uJ30sXG4gKiAgICAgICAgICAgICAuLi5cbiAqICAgICAgICAgXTtcbiAqICAgICAgIH1cbiAqICAgICB9KTtcbiAqICAgPCAvc2NyaXB0PlxuICpcbiAqIDwvZG9tLW1vZHVsZT5cbiAqIGBgYFxuICpcbiAqIE5vdGlmaWNhdGlvbnMgZm9yIGNoYW5nZXMgdG8gaXRlbXMgc3ViLXByb3BlcnRpZXMgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGVtcGxhdGVcbiAqIGluc3RhbmNlcywgd2hpY2ggd2lsbCB1cGRhdGUgdmlhIHRoZSBub3JtYWwgc3RydWN0dXJlZCBkYXRhIG5vdGlmaWNhdGlvbiBzeXN0ZW0uXG4gKlxuICogTXV0YXRpb25zIHRvIHRoZSBgaXRlbXNgIGFycmF5IGl0c2VsZiBzaG91bGQgYmUgbWFkZSB1c2luZyB0aGUgQXJyYXlcbiAqIG11dGF0aW9uIEFQSSdzIG9uIGBQb2x5bWVyLkJhc2VgIChgcHVzaGAsIGBwb3BgLCBgc3BsaWNlYCwgYHNoaWZ0YCxcbiAqIGB1bnNoaWZ0YCksIGFuZCB0ZW1wbGF0ZSBpbnN0YW5jZXMgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCB0aGUgZGF0YSBpbiB0aGVcbiAqIGFycmF5LlxuICpcbiAqIEV2ZW50cyBjYXVnaHQgYnkgZXZlbnQgaGFuZGxlcnMgd2l0aGluIHRoZSBgZG9tLXJlcGVhdGAgdGVtcGxhdGUgd2lsbCBiZVxuICogZGVjb3JhdGVkIHdpdGggYSBgbW9kZWxgIHByb3BlcnR5LCB3aGljaCByZXByZXNlbnRzIHRoZSBiaW5kaW5nIHNjb3BlIGZvclxuICogZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZS4gIFRoZSBtb2RlbCBpcyBhbiBpbnN0YW5jZSBvZiBQb2x5bWVyLkJhc2UsIGFuZCBzaG91bGRcbiAqIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhIG9uIHRoZSBpbnN0YW5jZSwgZm9yIGV4YW1wbGVcbiAqIGBldmVudC5tb2RlbC5zZXQoJ2l0ZW0uY2hlY2tlZCcsIHRydWUpO2AuXG4gKlxuICogQWx0ZXJuYXRpdmVseSwgdGhlIG1vZGVsIGZvciBhIHRlbXBsYXRlIGluc3RhbmNlIGZvciBhbiBlbGVtZW50IHN0YW1wZWQgYnlcbiAqIGEgYGRvbS1yZXBlYXRgIGNhbiBiZSBvYnRhaW5lZCB1c2luZyB0aGUgYG1vZGVsRm9yRWxlbWVudGAgQVBJIG9uIHRoZVxuICogYGRvbS1yZXBlYXRgIHRoYXQgc3RhbXBlZCBpdCwgZm9yIGV4YW1wbGVcbiAqIGB0aGlzLiQuZG9tUmVwZWF0Lm1vZGVsRm9yRWxlbWVudChldmVudC50YXJnZXQpLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7YC5cbiAqIFRoaXMgbWF5IGJlIHVzZWZ1bCBmb3IgbWFuaXB1bGF0aW5nIGluc3RhbmNlIGRhdGEgb2YgZXZlbnQgdGFyZ2V0cyBvYnRhaW5lZFxuICogYnkgZXZlbnQgaGFuZGxlcnMgb24gcGFyZW50cyBvZiB0aGUgYGRvbS1yZXBlYXRgIChldmVudCBkZWxlZ2F0aW9uKS5cbiAqXG4gKiBBIHZpZXctc3BlY2lmaWMgZmlsdGVyL3NvcnQgbWF5IGJlIGFwcGxpZWQgdG8gZWFjaCBgZG9tLXJlcGVhdGAgYnkgc3VwcGx5aW5nIGFcbiAqIGBmaWx0ZXJgIGFuZC9vciBgc29ydGAgcHJvcGVydHkuICBUaGlzIG1heSBiZSBhIHN0cmluZyB0aGF0IG5hbWVzIGEgZnVuY3Rpb24gb25cbiAqIHRoZSBob3N0LCBvciBhIGZ1bmN0aW9uIG1heSBiZSBhc3NpZ25lZCB0byB0aGUgcHJvcGVydHkgZGlyZWN0bHkuICBUaGUgZnVuY3Rpb25zXG4gKiBzaG91bGQgaW1wbGVtZW50ZWQgZm9sbG93aW5nIHRoZSBzdGFuZGFyZCBgQXJyYXlgIGZpbHRlci9zb3J0IEFQSS5cbiAqXG4gKiBJbiBvcmRlciB0byByZS1ydW4gdGhlIGZpbHRlciBvciBzb3J0IGZ1bmN0aW9ucyBiYXNlZCBvbiBjaGFuZ2VzIHRvIHN1Yi1maWVsZHNcbiAqIG9mIGBpdGVtc2AsIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHkgbWF5IGJlIHNldCBhcyBhIHNwYWNlLXNlcGFyYXRlZCBsaXN0IG9mXG4gKiBgaXRlbWAgc3ViLWZpZWxkcyB0aGF0IHNob3VsZCBjYXVzZSBhIHJlLWZpbHRlci9zb3J0IHdoZW4gbW9kaWZpZWQuICBJZlxuICogdGhlIGZpbHRlciBvciBzb3J0IGZ1bmN0aW9uIGRlcGVuZHMgb24gcHJvcGVydGllcyBub3QgY29udGFpbmVkIGluIGBpdGVtc2AsXG4gKiB0aGUgdXNlciBzaG91bGQgb2JzZXJ2ZSBjaGFuZ2VzIHRvIHRob3NlIHByb3BlcnRpZXMgYW5kIGNhbGwgYHJlbmRlcmAgdG8gdXBkYXRlXG4gKiB0aGUgdmlldyBiYXNlZCBvbiB0aGUgZGVwZW5kZW5jeSBjaGFuZ2UuXG4gKlxuICogRm9yIGV4YW1wbGUsIGZvciBhbiBgZG9tLXJlcGVhdGAgd2l0aCBhIGZpbHRlciBvZiB0aGUgZm9sbG93aW5nOlxuICpcbiAqIGBgYGpzXG4gKiBpc0VuZ2luZWVyOiBmdW5jdGlvbihpdGVtKSB7XG4gKiAgICAgcmV0dXJuIGl0ZW0udHlwZSA9PSAnZW5naW5lZXInIHx8IGl0ZW0ubWFuYWdlci50eXBlID09ICdlbmdpbmVlcic7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBUaGVuIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHkgc2hvdWxkIGJlIGNvbmZpZ3VyZWQgYXMgZm9sbG93czpcbiAqXG4gKiBgYGBodG1sXG4gKiA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCJcbiAqICAgICAgICAgICBmaWx0ZXI9XCJpc0VuZ2luZWVyXCIgb2JzZXJ2ZT1cInR5cGUgbWFuYWdlci50eXBlXCI+XG4gKiBgYGBcbiAqXG4gKiBAY3VzdG9tRWxlbWVudFxuICogQHBvbHltZXJcbiAqIEBtZW1iZXJvZiBQb2x5bWVyXG4gKiBAZXh0ZW5kcyB7ZG9tUmVwZWF0QmFzZX1cbiAqIEBhcHBsaWVzTWl4aW4gUG9seW1lci5PcHRpb25hbE11dGFibGVEYXRhXG4gKiBAc3VtbWFyeSBDdXN0b20gZWxlbWVudCBmb3Igc3RhbXBpbmcgaW5zdGFuY2Ugb2YgYSB0ZW1wbGF0ZSBib3VuZCB0b1xuICogICBpdGVtcyBpbiBhbiBhcnJheS5cbiAqL1xuY2xhc3MgRG9tUmVwZWF0IGV4dGVuZHMgZG9tUmVwZWF0QmFzZSB7XG5cbiAgLy8gTm90IG5lZWRlZCB0byBmaW5kIHRlbXBsYXRlOyBjYW4gYmUgcmVtb3ZlZCBvbmNlIHRoZSBhbmFseXplclxuICAvLyBjYW4gZmluZCB0aGUgdGFnIG5hbWUgZnJvbSBjdXN0b21FbGVtZW50cy5kZWZpbmUgY2FsbFxuICBzdGF0aWMgZ2V0IGlzKCkgeyByZXR1cm4gJ2RvbS1yZXBlYXQnOyB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIG51bGw7IH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAvKipcbiAgICAgKiBGaXJlZCB3aGVuZXZlciBET00gaXMgYWRkZWQgb3IgcmVtb3ZlZCBieSB0aGlzIHRlbXBsYXRlIChieVxuICAgICAqIGRlZmF1bHQsIHJlbmRlcmluZyBvY2N1cnMgbGF6aWx5KS4gIFRvIGZvcmNlIGltbWVkaWF0ZSByZW5kZXJpbmcsIGNhbGxcbiAgICAgKiBgcmVuZGVyYC5cbiAgICAgKlxuICAgICAqIEBldmVudCBkb20tY2hhbmdlXG4gICAgICovXG4gICAgcmV0dXJuIHtcblxuICAgICAgLyoqXG4gICAgICAgKiBBbiBhcnJheSBjb250YWluaW5nIGl0ZW1zIGRldGVybWluaW5nIGhvdyBtYW55IGluc3RhbmNlcyBvZiB0aGUgdGVtcGxhdGVcbiAgICAgICAqIHRvIHN0YW1wIGFuZCB0aGF0IHRoYXQgZWFjaCB0ZW1wbGF0ZSBpbnN0YW5jZSBzaG91bGQgYmluZCB0by5cbiAgICAgICAqL1xuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogQXJyYXlcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSBmb3IgdGhlIGFycmF5XG4gICAgICAgKiBlbGVtZW50IGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgICAgICovXG4gICAgICBhczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaXRlbSdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogVGhlIG5hbWUgb2YgdGhlIHZhcmlhYmxlIHRvIGFkZCB0byB0aGUgYmluZGluZyBzY29wZSB3aXRoIHRoZSBpbmRleFxuICAgICAgICogb2YgdGhlIGluc3RhbmNlIGluIHRoZSBzb3J0ZWQgYW5kIGZpbHRlcmVkIGxpc3Qgb2YgcmVuZGVyZWQgaXRlbXMuXG4gICAgICAgKiBOb3RlLCBmb3IgdGhlIGluZGV4IGluIHRoZSBgdGhpcy5pdGVtc2AgYXJyYXksIHVzZSB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICAgKiBgaXRlbXNJbmRleEFzYCBwcm9wZXJ0eS5cbiAgICAgICAqL1xuICAgICAgaW5kZXhBczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaW5kZXgnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFRoZSBuYW1lIG9mIHRoZSB2YXJpYWJsZSB0byBhZGQgdG8gdGhlIGJpbmRpbmcgc2NvcGUgd2l0aCB0aGUgaW5kZXhcbiAgICAgICAqIG9mIHRoZSBpbnN0YW5jZSBpbiB0aGUgYHRoaXMuaXRlbXNgIGFycmF5LiBOb3RlLCBmb3IgdGhlIGluZGV4IG9mXG4gICAgICAgKiB0aGlzIGluc3RhbmNlIGluIHRoZSBzb3J0ZWQgYW5kIGZpbHRlcmVkIGxpc3Qgb2YgcmVuZGVyZWQgaXRlbXMsXG4gICAgICAgKiB1c2UgdGhlIHZhbHVlIG9mIHRoZSBgaW5kZXhBc2AgcHJvcGVydHkuXG4gICAgICAgKi9cbiAgICAgIGl0ZW1zSW5kZXhBczoge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHZhbHVlOiAnaXRlbXNJbmRleCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSBmdW5jdGlvbiB0aGF0IHNob3VsZCBkZXRlcm1pbmUgdGhlIHNvcnQgb3JkZXIgb2YgdGhlIGl0ZW1zLiAgVGhpc1xuICAgICAgICogcHJvcGVydHkgc2hvdWxkIGVpdGhlciBiZSBwcm92aWRlZCBhcyBhIHN0cmluZywgaW5kaWNhdGluZyBhIG1ldGhvZFxuICAgICAgICogbmFtZSBvbiB0aGUgZWxlbWVudCdzIGhvc3QsIG9yIGVsc2UgYmUgYW4gYWN0dWFsIGZ1bmN0aW9uLiAgVGhlXG4gICAgICAgKiBmdW5jdGlvbiBzaG91bGQgbWF0Y2ggdGhlIHNvcnQgZnVuY3Rpb24gcGFzc2VkIHRvIGBBcnJheS5zb3J0YC5cbiAgICAgICAqIFVzaW5nIGEgc29ydCBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1bmRlcmx5aW5nIGBpdGVtc2AgYXJyYXkuXG4gICAgICAgKi9cbiAgICAgIHNvcnQ6IHtcbiAgICAgICAgdHlwZTogRnVuY3Rpb24sXG4gICAgICAgIG9ic2VydmVyOiAnX19zb3J0Q2hhbmdlZCdcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGZpbHRlciBpdGVtcyBvdXQgb2YgdGhlIHZpZXcuICBUaGlzXG4gICAgICAgKiBwcm9wZXJ0eSBzaG91bGQgZWl0aGVyIGJlIHByb3ZpZGVkIGFzIGEgc3RyaW5nLCBpbmRpY2F0aW5nIGEgbWV0aG9kXG4gICAgICAgKiBuYW1lIG9uIHRoZSBlbGVtZW50J3MgaG9zdCwgb3IgZWxzZSBiZSBhbiBhY3R1YWwgZnVuY3Rpb24uICBUaGVcbiAgICAgICAqIGZ1bmN0aW9uIHNob3VsZCBtYXRjaCB0aGUgc29ydCBmdW5jdGlvbiBwYXNzZWQgdG8gYEFycmF5LmZpbHRlcmAuXG4gICAgICAgKiBVc2luZyBhIGZpbHRlciBmdW5jdGlvbiBoYXMgbm8gZWZmZWN0IG9uIHRoZSB1bmRlcmx5aW5nIGBpdGVtc2AgYXJyYXkuXG4gICAgICAgKi9cbiAgICAgIGZpbHRlcjoge1xuICAgICAgICB0eXBlOiBGdW5jdGlvbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2ZpbHRlckNoYW5nZWQnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gdXNpbmcgYSBgZmlsdGVyYCBvciBgc29ydGAgZnVuY3Rpb24sIHRoZSBgb2JzZXJ2ZWAgcHJvcGVydHlcbiAgICAgICAqIHNob3VsZCBiZSBzZXQgdG8gYSBzcGFjZS1zZXBhcmF0ZWQgbGlzdCBvZiB0aGUgbmFtZXMgb2YgaXRlbVxuICAgICAgICogc3ViLWZpZWxkcyB0aGF0IHNob3VsZCB0cmlnZ2VyIGEgcmUtc29ydCBvciByZS1maWx0ZXIgd2hlbiBjaGFuZ2VkLlxuICAgICAgICogVGhlc2Ugc2hvdWxkIGdlbmVyYWxseSBiZSBmaWVsZHMgb2YgYGl0ZW1gIHRoYXQgdGhlIHNvcnQgb3IgZmlsdGVyXG4gICAgICAgKiBmdW5jdGlvbiBkZXBlbmRzIG9uLlxuICAgICAgICovXG4gICAgICBvYnNlcnZlOiB7XG4gICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX29ic2VydmVDaGFuZ2VkJ1xuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHVzaW5nIGEgYGZpbHRlcmAgb3IgYHNvcnRgIGZ1bmN0aW9uLCB0aGUgYGRlbGF5YCBwcm9wZXJ0eVxuICAgICAgICogZGV0ZXJtaW5lcyBhIGRlYm91bmNlIHRpbWUgYWZ0ZXIgYSBjaGFuZ2UgdG8gb2JzZXJ2ZWQgaXRlbVxuICAgICAgICogcHJvcGVydGllcyB0aGF0IG11c3QgcGFzcyBiZWZvcmUgdGhlIGZpbHRlciBvciBzb3J0IGlzIHJlLXJ1bi5cbiAgICAgICAqIFRoaXMgaXMgdXNlZnVsIGluIHJhdGUtbGltaXRpbmcgc2h1ZmZpbmcgb2YgdGhlIHZpZXcgd2hlblxuICAgICAgICogaXRlbSBjaGFuZ2VzIG1heSBiZSBmcmVxdWVudC5cbiAgICAgICAqL1xuICAgICAgZGVsYXk6IE51bWJlcixcblxuICAgICAgLyoqXG4gICAgICAgKiBDb3VudCBvZiBjdXJyZW50bHkgcmVuZGVyZWQgaXRlbXMgYWZ0ZXIgYGZpbHRlcmAgKGlmIGFueSkgaGFzIGJlZW4gYXBwbGllZC5cbiAgICAgICAqIElmIFwiY2h1bmtpbmcgbW9kZVwiIGlzIGVuYWJsZWQsIGByZW5kZXJlZEl0ZW1Db3VudGAgaXMgdXBkYXRlZCBlYWNoIHRpbWUgYVxuICAgICAgICogc2V0IG9mIHRlbXBsYXRlIGluc3RhbmNlcyBpcyByZW5kZXJlZC5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICAgIHJlbmRlcmVkSXRlbUNvdW50OiB7XG4gICAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgICAgbm90aWZ5OiB0cnVlLFxuICAgICAgICByZWFkT25seTogdHJ1ZVxuICAgICAgfSxcblxuICAgICAgLyoqXG4gICAgICAgKiBEZWZpbmVzIGFuIGluaXRpYWwgY291bnQgb2YgdGVtcGxhdGUgaW5zdGFuY2VzIHRvIHJlbmRlciBhZnRlciBzZXR0aW5nXG4gICAgICAgKiB0aGUgYGl0ZW1zYCBhcnJheSwgYmVmb3JlIHRoZSBuZXh0IHBhaW50LCBhbmQgcHV0cyB0aGUgYGRvbS1yZXBlYXRgXG4gICAgICAgKiBpbnRvIFwiY2h1bmtpbmcgbW9kZVwiLiAgVGhlIHJlbWFpbmluZyBpdGVtcyB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJlbmRlcmVkXG4gICAgICAgKiBpbmNyZW1lbnRhbGx5IGF0IGVhY2ggYW5pbWF0aW9uIGZyYW1lIHRoZXJvZiB1bnRpbCBhbGwgaW5zdGFuY2VzIGhhdmVcbiAgICAgICAqIGJlZW4gcmVuZGVyZWQuXG4gICAgICAgKi9cbiAgICAgIGluaXRpYWxDb3VudDoge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIG9ic2VydmVyOiAnX19pbml0aWFsaXplQ2h1bmtpbmcnXG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFdoZW4gYGluaXRpYWxDb3VudGAgaXMgdXNlZCwgdGhpcyBwcm9wZXJ0eSBkZWZpbmVzIGEgZnJhbWUgcmF0ZSB0b1xuICAgICAgICogdGFyZ2V0IGJ5IHRocm90dGxpbmcgdGhlIG51bWJlciBvZiBpbnN0YW5jZXMgcmVuZGVyZWQgZWFjaCBmcmFtZSB0b1xuICAgICAgICogbm90IGV4Y2VlZCB0aGUgYnVkZ2V0IGZvciB0aGUgdGFyZ2V0IGZyYW1lIHJhdGUuICBTZXR0aW5nIHRoaXMgdG8gYVxuICAgICAgICogaGlnaGVyIG51bWJlciB3aWxsIGFsbG93IGxvd2VyIGxhdGVuY3kgYW5kIGhpZ2hlciB0aHJvdWdocHV0IGZvclxuICAgICAgICogdGhpbmdzIGxpa2UgZXZlbnQgaGFuZGxlcnMsIGJ1dCB3aWxsIHJlc3VsdCBpbiBhIGxvbmdlciB0aW1lIGZvciB0aGVcbiAgICAgICAqIHJlbWFpbmluZyBpdGVtcyB0byBjb21wbGV0ZSByZW5kZXJpbmcuXG4gICAgICAgKi9cbiAgICAgIHRhcmdldEZyYW1lcmF0ZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIHZhbHVlOiAyMFxuICAgICAgfSxcblxuICAgICAgX3RhcmdldEZyYW1lVGltZToge1xuICAgICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICAgIGNvbXB1dGVkOiAnX19jb21wdXRlRnJhbWVUaW1lKHRhcmdldEZyYW1lcmF0ZSknXG4gICAgICB9XG5cbiAgICB9O1xuXG4gIH1cblxuICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICByZXR1cm4gWyAnX19pdGVtc0NoYW5nZWQoaXRlbXMuKiknIF07XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX19pbnN0YW5jZXMgPSBbXTtcbiAgICB0aGlzLl9fbGltaXQgPSBJbmZpbml0eTtcbiAgICB0aGlzLl9fcG9vbCA9IFtdO1xuICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBudWxsO1xuICAgIHRoaXMuX19pdGVtc0lkeFRvSW5zdElkeCA9IHt9O1xuICAgIHRoaXMuX19jaHVua0NvdW50ID0gbnVsbDtcbiAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IG51bGw7XG4gICAgdGhpcy5fX3NvcnRGbiA9IG51bGw7XG4gICAgdGhpcy5fX2ZpbHRlckZuID0gbnVsbDtcbiAgICB0aGlzLl9fb2JzZXJ2ZVBhdGhzID0gbnVsbDtcbiAgICB0aGlzLl9fY3RvciA9IG51bGw7XG4gICAgdGhpcy5fX2lzRGV0YWNoZWQgPSB0cnVlO1xuICAgIHRoaXMudGVtcGxhdGUgPSBudWxsO1xuICB9XG5cbiAgZGlzY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICB0aGlzLl9faXNEZXRhY2hlZCA9IHRydWU7XG4gICAgZm9yIChsZXQgaT0wOyBpPHRoaXMuX19pbnN0YW5jZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX19kZXRhY2hJbnN0YW5jZShpKTtcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBzdXBlci5jb25uZWN0ZWRDYWxsYmFjaygpO1xuICAgIC8vIG9ubHkgcGVyZm9ybSBhdHRhY2htZW50IGlmIHRoZSBlbGVtZW50IHdhcyBwcmV2aW91c2x5IGRldGFjaGVkLlxuICAgIGlmICh0aGlzLl9faXNEZXRhY2hlZCkge1xuICAgICAgdGhpcy5fX2lzRGV0YWNoZWQgPSBmYWxzZTtcbiAgICAgIGxldCBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLl9fYXR0YWNoSW5zdGFuY2UoaSwgcGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfX2Vuc3VyZVRlbXBsYXRpemVkKCkge1xuICAgIC8vIFRlbXBsYXRpemluZyAoZ2VuZXJhdGluZyB0aGUgaW5zdGFuY2UgY29uc3RydWN0b3IpIG5lZWRzIHRvIHdhaXRcbiAgICAvLyB1bnRpbCByZWFkeSwgc2luY2Ugd29uJ3QgaGF2ZSBpdHMgdGVtcGxhdGUgY29udGVudCBoYW5kZWQgYmFjayB0b1xuICAgIC8vIGl0IHVudGlsIHRoZW5cbiAgICBpZiAoIXRoaXMuX19jdG9yKSB7XG4gICAgICBsZXQgdGVtcGxhdGUgPSB0aGlzLnRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAvLyAvLyBXYWl0IHVudGlsIGNoaWxkTGlzdCBjaGFuZ2VzIGFuZCB0ZW1wbGF0ZSBzaG91bGQgYmUgdGhlcmUgYnkgdGhlblxuICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMucXVlcnlTZWxlY3RvcigndGVtcGxhdGUnKSkge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RvbS1yZXBlYXQgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIFRlbXBsYXRlIGluc3RhbmNlIHByb3BzIHRoYXQgc2hvdWxkIGJlIGV4Y2x1ZGVkIGZyb20gZm9yd2FyZGluZ1xuICAgICAgbGV0IGluc3RhbmNlUHJvcHMgPSB7fTtcbiAgICAgIGluc3RhbmNlUHJvcHNbdGhpcy5hc10gPSB0cnVlO1xuICAgICAgaW5zdGFuY2VQcm9wc1t0aGlzLmluZGV4QXNdID0gdHJ1ZTtcbiAgICAgIGluc3RhbmNlUHJvcHNbdGhpcy5pdGVtc0luZGV4QXNdID0gdHJ1ZTtcbiAgICAgIHRoaXMuX19jdG9yID0gVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgIG11dGFibGVEYXRhOiB0aGlzLm11dGFibGVEYXRhLFxuICAgICAgICBwYXJlbnRNb2RlbDogdHJ1ZSxcbiAgICAgICAgaW5zdGFuY2VQcm9wczogaW5zdGFuY2VQcm9wcyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcCBQcm9wZXJ0eSB0byBzZXRcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZSBWYWx1ZSB0byBzZXQgcHJvcGVydHkgdG9cbiAgICAgICAgICovXG4gICAgICAgIGZvcndhcmRIb3N0UHJvcDogZnVuY3Rpb24ocHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICBsZXQgaSQgPSB0aGlzLl9faW5zdGFuY2VzO1xuICAgICAgICAgIGZvciAobGV0IGk9MCwgaW5zdDsgKGk8aSQubGVuZ3RoKSAmJiAoaW5zdD1pJFtpXSk7IGkrKykge1xuICAgICAgICAgICAgaW5zdC5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0aGlzIHt0aGlzfVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gaW5zdCBJbnN0YW5jZSB0byBub3RpZnlcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3AgUHJvcGVydHkgdG8gbm90aWZ5XG4gICAgICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVmFsdWUgdG8gbm90aWZ5XG4gICAgICAgICAqL1xuICAgICAgICBub3RpZnlJbnN0YW5jZVByb3A6IGZ1bmN0aW9uKGluc3QsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKG1hdGNoZXModGhpcy5hcywgcHJvcCkpIHtcbiAgICAgICAgICAgIGxldCBpZHggPSBpbnN0W3RoaXMuaXRlbXNJbmRleEFzXTtcbiAgICAgICAgICAgIGlmIChwcm9wID09IHRoaXMuYXMpIHtcbiAgICAgICAgICAgICAgdGhpcy5pdGVtc1tpZHhdID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcGF0aCA9IHRyYW5zbGF0ZSh0aGlzLmFzLCAnaXRlbXMuJyArIGlkeCwgcHJvcCk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVBhdGgocGF0aCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX19nZXRNZXRob2RIb3N0KCkge1xuICAgIC8vIFRlY2huaWNhbGx5IHRoaXMgc2hvdWxkIGJlIHRoZSBvd25lciBvZiB0aGUgb3V0ZXJtb3N0IHRlbXBsYXRlLlxuICAgIC8vIEluIHNoYWRvdyBkb20sIHRoaXMgaXMgYWx3YXlzIGdldFJvb3ROb2RlKCkuaG9zdCwgYnV0IHdlIGNhblxuICAgIC8vIGFwcHJveGltYXRlIHRoaXMgdmlhIGNvb3BlcmF0aW9uIHdpdGggb3VyIGRhdGFIb3N0IGFsd2F5cyBzZXR0aW5nXG4gICAgLy8gYF9tZXRob2RIb3N0YCBhcyBsb25nIGFzIHRoZXJlIHdlcmUgYmluZGluZ3MgKG9yIGlkJ3MpIG9uIHRoaXNcbiAgICAvLyBpbnN0YW5jZSBjYXVzaW5nIGl0IHRvIGdldCBhIGRhdGFIb3N0LlxuICAgIHJldHVybiB0aGlzLl9fZGF0YUhvc3QuX21ldGhvZEhvc3QgfHwgdGhpcy5fX2RhdGFIb3N0O1xuICB9XG5cbiAgX19zb3J0Q2hhbmdlZChzb3J0KSB7XG4gICAgbGV0IG1ldGhvZEhvc3QgPSB0aGlzLl9fZ2V0TWV0aG9kSG9zdCgpO1xuICAgIHRoaXMuX19zb3J0Rm4gPSBzb3J0ICYmICh0eXBlb2Ygc29ydCA9PSAnZnVuY3Rpb24nID8gc29ydCA6XG4gICAgICBmdW5jdGlvbigpIHsgcmV0dXJuIG1ldGhvZEhvc3Rbc29ydF0uYXBwbHkobWV0aG9kSG9zdCwgYXJndW1lbnRzKTsgfSk7XG4gICAgaWYgKHRoaXMuaXRlbXMpIHtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG4gIH1cblxuICBfX2ZpbHRlckNoYW5nZWQoZmlsdGVyKSB7XG4gICAgbGV0IG1ldGhvZEhvc3QgPSB0aGlzLl9fZ2V0TWV0aG9kSG9zdCgpO1xuICAgIHRoaXMuX19maWx0ZXJGbiA9IGZpbHRlciAmJiAodHlwZW9mIGZpbHRlciA9PSAnZnVuY3Rpb24nID8gZmlsdGVyIDpcbiAgICAgIGZ1bmN0aW9uKCkgeyByZXR1cm4gbWV0aG9kSG9zdFtmaWx0ZXJdLmFwcGx5KG1ldGhvZEhvc3QsIGFyZ3VtZW50cyk7IH0pO1xuICAgIGlmICh0aGlzLml0ZW1zKSB7XG4gICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgfVxuICB9XG5cbiAgX19jb21wdXRlRnJhbWVUaW1lKHJhdGUpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKDEwMDAvcmF0ZSk7XG4gIH1cblxuICBfX2luaXRpYWxpemVDaHVua2luZygpIHtcbiAgICBpZiAodGhpcy5pbml0aWFsQ291bnQpIHtcbiAgICAgIHRoaXMuX19saW1pdCA9IHRoaXMuaW5pdGlhbENvdW50O1xuICAgICAgdGhpcy5fX2NodW5rQ291bnQgPSB0aGlzLmluaXRpYWxDb3VudDtcbiAgICAgIHRoaXMuX19sYXN0Q2h1bmtUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgfVxuICB9XG5cbiAgX190cnlSZW5kZXJDaHVuaygpIHtcbiAgICAvLyBEZWJvdW5jZWQgc28gdGhhdCBtdWx0aXBsZSBjYWxscyB0aHJvdWdoIGBfcmVuZGVyYCBiZXR3ZWVuIGFuaW1hdGlvblxuICAgIC8vIGZyYW1lcyBvbmx5IHF1ZXVlIG9uZSBuZXcgckFGIChlLmcuIGFycmF5IG11dGF0aW9uICYgY2h1bmtlZCByZW5kZXIpXG4gICAgaWYgKHRoaXMuaXRlbXMgJiYgdGhpcy5fX2xpbWl0IDwgdGhpcy5pdGVtcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVxdWVzdFJlbmRlckNodW5rKTtcbiAgICB9XG4gIH1cblxuICBfX3JlcXVlc3RSZW5kZXJDaHVuaygpIHtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCk9PnRoaXMuX19yZW5kZXJDaHVuaygpKTtcbiAgfVxuXG4gIF9fcmVuZGVyQ2h1bmsoKSB7XG4gICAgLy8gU2ltcGxlIGF1dG8gY2h1bmtTaXplIHRocm90dGxpbmcgYWxnb3JpdGhtIGJhc2VkIG9uIGZlZWRiYWNrIGxvb3A6XG4gICAgLy8gbWVhc3VyZSBhY3R1YWwgdGltZSBiZXR3ZWVuIGZyYW1lcyBhbmQgc2NhbGUgY2h1bmsgY291bnQgYnkgcmF0aW9cbiAgICAvLyBvZiB0YXJnZXQvYWN0dWFsIGZyYW1lIHRpbWVcbiAgICBsZXQgY3VyckNodW5rVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGxldCByYXRpbyA9IHRoaXMuX3RhcmdldEZyYW1lVGltZSAvIChjdXJyQ2h1bmtUaW1lIC0gdGhpcy5fX2xhc3RDaHVua1RpbWUpO1xuICAgIHRoaXMuX19jaHVua0NvdW50ID0gTWF0aC5yb3VuZCh0aGlzLl9fY2h1bmtDb3VudCAqIHJhdGlvKSB8fCAxO1xuICAgIHRoaXMuX19saW1pdCArPSB0aGlzLl9fY2h1bmtDb3VudDtcbiAgICB0aGlzLl9fbGFzdENodW5rVGltZSA9IGN1cnJDaHVua1RpbWU7XG4gICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKHRoaXMuX19yZW5kZXIpO1xuICB9XG5cbiAgX19vYnNlcnZlQ2hhbmdlZCgpIHtcbiAgICB0aGlzLl9fb2JzZXJ2ZVBhdGhzID0gdGhpcy5vYnNlcnZlICYmXG4gICAgICB0aGlzLm9ic2VydmUucmVwbGFjZSgnLionLCAnLicpLnNwbGl0KCcgJyk7XG4gIH1cblxuICBfX2l0ZW1zQ2hhbmdlZChjaGFuZ2UpIHtcbiAgICBpZiAodGhpcy5pdGVtcyAmJiAhQXJyYXkuaXNBcnJheSh0aGlzLml0ZW1zKSkge1xuICAgICAgY29uc29sZS53YXJuKCdkb20tcmVwZWF0IGV4cGVjdGVkIGFycmF5IGZvciBgaXRlbXNgLCBmb3VuZCcsIHRoaXMuaXRlbXMpO1xuICAgIH1cbiAgICAvLyBJZiBwYXRoIHdhcyB0byBhbiBpdGVtIChlLmcuICdpdGVtcy4zJyBvciAnaXRlbXMuMy5mb28nKSwgZm9yd2FyZCB0aGVcbiAgICAvLyBwYXRoIHRvIHRoYXQgaW5zdGFuY2Ugc3luY2hyb25vdXNseSAocmV0dW5zIGZhbHNlIGZvciBub24taXRlbSBwYXRocylcbiAgICBpZiAoIXRoaXMuX19oYW5kbGVJdGVtUGF0aChjaGFuZ2UucGF0aCwgY2hhbmdlLnZhbHVlKSkge1xuICAgICAgLy8gT3RoZXJ3aXNlLCB0aGUgYXJyYXkgd2FzIHJlc2V0ICgnaXRlbXMnKSBvciBzcGxpY2VkICgnaXRlbXMuc3BsaWNlcycpLFxuICAgICAgLy8gc28gcXVldWUgYSBmdWxsIHJlZnJlc2hcbiAgICAgIHRoaXMuX19pbml0aWFsaXplQ2h1bmtpbmcoKTtcbiAgICAgIHRoaXMuX19kZWJvdW5jZVJlbmRlcih0aGlzLl9fcmVuZGVyKTtcbiAgICB9XG4gIH1cblxuICBfX2hhbmRsZU9ic2VydmVkUGF0aHMocGF0aCkge1xuICAgIGlmICh0aGlzLl9fb2JzZXJ2ZVBhdGhzKSB7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcocGF0aC5pbmRleE9mKCcuJykgKyAxKTtcbiAgICAgIGxldCBwYXRocyA9IHRoaXMuX19vYnNlcnZlUGF0aHM7XG4gICAgICBmb3IgKGxldCBpPTA7IGk8cGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBhdGguaW5kZXhPZihwYXRoc1tpXSkgPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlciwgdGhpcy5kZWxheSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbih0aGlzOkRvbVJlcGVhdCl9IGZuIEZ1bmN0aW9uIHRvIGRlYm91bmNlLlxuICAgKiBAcGFyYW0ge251bWJlcj19IGRlbGF5IERlbGF5IGluIG1zIHRvIGRlYm91bmNlIGJ5LlxuICAgKi9cbiAgX19kZWJvdW5jZVJlbmRlcihmbiwgZGVsYXkgPSAwKSB7XG4gICAgdGhpcy5fX3JlbmRlckRlYm91bmNlciA9IERlYm91bmNlci5kZWJvdW5jZShcbiAgICAgICAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyXG4gICAgICAgICwgZGVsYXkgPiAwID8gdGltZU91dC5hZnRlcihkZWxheSkgOiBtaWNyb1Rhc2tcbiAgICAgICAgLCBmbi5iaW5kKHRoaXMpKTtcbiAgICBlbnF1ZXVlRGVib3VuY2VyKHRoaXMuX19yZW5kZXJEZWJvdW5jZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIE5vcm1hbGx5IHJlbmRlcmluZyBpc1xuICAgKiBhc3luY2hyb25vdXMgdG8gYSBwcm92b2tpbmcgY2hhbmdlLiBUaGlzIGlzIGRvbmUgZm9yIGVmZmljaWVuY3kgc29cbiAgICogdGhhdCBtdWx0aXBsZSBjaGFuZ2VzIHRyaWdnZXIgb25seSBhIHNpbmdsZSByZW5kZXIuIFRoZSByZW5kZXIgbWV0aG9kXG4gICAqIHNob3VsZCBiZSBjYWxsZWQgaWYsIGZvciBleGFtcGxlLCB0ZW1wbGF0ZSByZW5kZXJpbmcgaXMgcmVxdWlyZWQgdG9cbiAgICogdmFsaWRhdGUgYXBwbGljYXRpb24gc3RhdGUuXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgLy8gUXVldWUgdGhpcyByZXBlYXRlciwgdGhlbiBmbHVzaCBhbGwgaW4gb3JkZXJcbiAgICB0aGlzLl9fZGVib3VuY2VSZW5kZXIodGhpcy5fX3JlbmRlcik7XG4gICAgZmx1c2goKTtcbiAgfVxuXG4gIF9fcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5fX2Vuc3VyZVRlbXBsYXRpemVkKCkpIHtcbiAgICAgIC8vIE5vIHRlbXBsYXRlIGZvdW5kIHlldFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9fYXBwbHlGdWxsUmVmcmVzaCgpO1xuICAgIC8vIFJlc2V0IHRoZSBwb29sXG4gICAgLy8gVE9ETyhrc2NoYWFmKTogUmV1c2UgcG9vbCBhY3Jvc3MgdHVybnMgYW5kIG5lc3RlZCB0ZW1wbGF0ZXNcbiAgICAvLyBOb3cgdGhhdCBvYmplY3RzL2FycmF5cyBhcmUgcmUtZXZhbHVhdGVkIHdoZW4gc2V0LCB3ZSBjYW4gc2FmZWx5XG4gICAgLy8gcmV1c2UgcG9vbGVkIGluc3RhbmNlcyBhY3Jvc3MgdHVybnMsIGhvd2V2ZXIgd2Ugc3RpbGwgbmVlZCB0byBkZWNpZGVcbiAgICAvLyBzZW1hbnRpY3MgcmVnYXJkaW5nIGhvdyBsb25nIHRvIGhvbGQsIGhvdyBtYW55IHRvIGhvbGQsIGV0Yy5cbiAgICB0aGlzLl9fcG9vbC5sZW5ndGggPSAwO1xuICAgIC8vIFNldCByZW5kZXJlZCBpdGVtIGNvdW50XG4gICAgdGhpcy5fc2V0UmVuZGVyZWRJdGVtQ291bnQodGhpcy5fX2luc3RhbmNlcy5sZW5ndGgpO1xuICAgIC8vIE5vdGlmeSB1c2Vyc1xuICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgY29tcG9zZWQ6IHRydWVcbiAgICB9KSk7XG4gICAgLy8gQ2hlY2sgdG8gc2VlIGlmIHdlIG5lZWQgdG8gcmVuZGVyIG1vcmUgaXRlbXNcbiAgICB0aGlzLl9fdHJ5UmVuZGVyQ2h1bmsoKTtcbiAgfVxuXG4gIF9fYXBwbHlGdWxsUmVmcmVzaCgpIHtcbiAgICBsZXQgaXRlbXMgPSB0aGlzLml0ZW1zIHx8IFtdO1xuICAgIGxldCBpc250SWR4VG9JdGVtc0lkeCA9IG5ldyBBcnJheShpdGVtcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGk9MDsgaTxpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgaXNudElkeFRvSXRlbXNJZHhbaV0gPSBpO1xuICAgIH1cbiAgICAvLyBBcHBseSB1c2VyIGZpbHRlclxuICAgIGlmICh0aGlzLl9fZmlsdGVyRm4pIHtcbiAgICAgIGlzbnRJZHhUb0l0ZW1zSWR4ID0gaXNudElkeFRvSXRlbXNJZHguZmlsdGVyKChpLCBpZHgsIGFycmF5KSA9PlxuICAgICAgICB0aGlzLl9fZmlsdGVyRm4oaXRlbXNbaV0sIGlkeCwgYXJyYXkpKTtcbiAgICB9XG4gICAgLy8gQXBwbHkgdXNlciBzb3J0XG4gICAgaWYgKHRoaXMuX19zb3J0Rm4pIHtcbiAgICAgIGlzbnRJZHhUb0l0ZW1zSWR4LnNvcnQoKGEsIGIpID0+IHRoaXMuX19zb3J0Rm4oaXRlbXNbYV0sIGl0ZW1zW2JdKSk7XG4gICAgfVxuICAgIC8vIGl0ZW1zLT5pbnN0IG1hcCBrZXB0IGZvciBpdGVtIHBhdGggZm9yd2FyZGluZ1xuICAgIGNvbnN0IGl0ZW1zSWR4VG9JbnN0SWR4ID0gdGhpcy5fX2l0ZW1zSWR4VG9JbnN0SWR4ID0ge307XG4gICAgbGV0IGluc3RJZHggPSAwO1xuICAgIC8vIEdlbmVyYXRlIGluc3RhbmNlcyBhbmQgYXNzaWduIGl0ZW1zXG4gICAgY29uc3QgbGltaXQgPSBNYXRoLm1pbihpc250SWR4VG9JdGVtc0lkeC5sZW5ndGgsIHRoaXMuX19saW1pdCk7XG4gICAgZm9yICg7IGluc3RJZHg8bGltaXQ7IGluc3RJZHgrKykge1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdO1xuICAgICAgbGV0IGl0ZW1JZHggPSBpc250SWR4VG9JdGVtc0lkeFtpbnN0SWR4XTtcbiAgICAgIGxldCBpdGVtID0gaXRlbXNbaXRlbUlkeF07XG4gICAgICBpdGVtc0lkeFRvSW5zdElkeFtpdGVtSWR4XSA9IGluc3RJZHg7XG4gICAgICBpZiAoaW5zdCAmJiBpbnN0SWR4IDwgdGhpcy5fX2xpbWl0KSB7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLmFzLCBpdGVtKTtcbiAgICAgICAgaW5zdC5fc2V0UGVuZGluZ1Byb3BlcnR5KHRoaXMuaW5kZXhBcywgaW5zdElkeCk7XG4gICAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLml0ZW1zSW5kZXhBcywgaXRlbUlkeCk7XG4gICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fX2luc2VydEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgYW55IGV4dHJhIGluc3RhbmNlcyBmcm9tIHByZXZpb3VzIHN0YXRlXG4gICAgZm9yIChsZXQgaT10aGlzLl9faW5zdGFuY2VzLmxlbmd0aC0xOyBpPj1pbnN0SWR4OyBpLS0pIHtcbiAgICAgIHRoaXMuX19kZXRhY2hBbmRSZW1vdmVJbnN0YW5jZShpKTtcbiAgICB9XG4gIH1cblxuICBfX2RldGFjaEluc3RhbmNlKGlkeCkge1xuICAgIGxldCBpbnN0ID0gdGhpcy5fX2luc3RhbmNlc1tpZHhdO1xuICAgIGZvciAobGV0IGk9MDsgaTxpbnN0LmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgZWwgPSBpbnN0LmNoaWxkcmVuW2ldO1xuICAgICAgaW5zdC5yb290LmFwcGVuZENoaWxkKGVsKTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cblxuICBfX2F0dGFjaEluc3RhbmNlKGlkeCwgcGFyZW50KSB7XG4gICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2lkeF07XG4gICAgcGFyZW50Lmluc2VydEJlZm9yZShpbnN0LnJvb3QsIHRoaXMpO1xuICB9XG5cbiAgX19kZXRhY2hBbmRSZW1vdmVJbnN0YW5jZShpZHgpIHtcbiAgICBsZXQgaW5zdCA9IHRoaXMuX19kZXRhY2hJbnN0YW5jZShpZHgpO1xuICAgIGlmIChpbnN0KSB7XG4gICAgICB0aGlzLl9fcG9vbC5wdXNoKGluc3QpO1xuICAgIH1cbiAgICB0aGlzLl9faW5zdGFuY2VzLnNwbGljZShpZHgsIDEpO1xuICB9XG5cbiAgX19zdGFtcEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpIHtcbiAgICBsZXQgbW9kZWwgPSB7fTtcbiAgICBtb2RlbFt0aGlzLmFzXSA9IGl0ZW07XG4gICAgbW9kZWxbdGhpcy5pbmRleEFzXSA9IGluc3RJZHg7XG4gICAgbW9kZWxbdGhpcy5pdGVtc0luZGV4QXNdID0gaXRlbUlkeDtcbiAgICByZXR1cm4gbmV3IHRoaXMuX19jdG9yKG1vZGVsKTtcbiAgfVxuXG4gIF9faW5zZXJ0SW5zdGFuY2UoaXRlbSwgaW5zdElkeCwgaXRlbUlkeCkge1xuICAgIGxldCBpbnN0ID0gdGhpcy5fX3Bvb2wucG9wKCk7XG4gICAgaWYgKGluc3QpIHtcbiAgICAgIC8vIFRPRE8oa3NjaGFhZik6IElmIHRoZSBwb29sIGlzIHNoYXJlZCBhY3Jvc3MgdHVybnMsIGhvc3RQcm9wc1xuICAgICAgLy8gbmVlZCB0byBiZSByZS1zZXQgdG8gcmV1c2VkIGluc3RhbmNlcyBpbiBhZGRpdGlvbiB0byBpdGVtXG4gICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5hcywgaXRlbSk7XG4gICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHkodGhpcy5pbmRleEFzLCBpbnN0SWR4KTtcbiAgICAgIGluc3QuX3NldFBlbmRpbmdQcm9wZXJ0eSh0aGlzLml0ZW1zSW5kZXhBcywgaXRlbUlkeCk7XG4gICAgICBpbnN0Ll9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5zdCA9IHRoaXMuX19zdGFtcEluc3RhbmNlKGl0ZW0sIGluc3RJZHgsIGl0ZW1JZHgpO1xuICAgIH1cbiAgICBsZXQgYmVmb3JlUm93ID0gdGhpcy5fX2luc3RhbmNlc1tpbnN0SWR4ICsgMV07XG4gICAgbGV0IGJlZm9yZU5vZGUgPSBiZWZvcmVSb3cgPyBiZWZvcmVSb3cuY2hpbGRyZW5bMF0gOiB0aGlzO1xuICAgIHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoaW5zdC5yb290LCBiZWZvcmVOb2RlKTtcbiAgICB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdID0gaW5zdDtcbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuXG4gIC8vIEltcGxlbWVudHMgZXh0ZW5zaW9uIHBvaW50IGZyb20gVGVtcGxhdGl6ZSBtaXhpblxuICBfc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pIHtcbiAgICBmb3IgKGxldCBpPTA7IGk8dGhpcy5fX2luc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fX2luc3RhbmNlc1tpXS5fc2hvd0hpZGVDaGlsZHJlbihoaWRkZW4pO1xuICAgIH1cbiAgfVxuXG4gIC8vIENhbGxlZCBhcyBhIHNpZGUgZWZmZWN0IG9mIGEgaG9zdCBpdGVtcy48a2V5Pi48cGF0aD4gcGF0aCBjaGFuZ2UsXG4gIC8vIHJlc3BvbnNpYmxlIGZvciBub3RpZnlpbmcgaXRlbS48cGF0aD4gY2hhbmdlcyB0byBpbnN0IGZvciBrZXlcbiAgX19oYW5kbGVJdGVtUGF0aChwYXRoLCB2YWx1ZSkge1xuICAgIGxldCBpdGVtc1BhdGggPSBwYXRoLnNsaWNlKDYpOyAvLyAnaXRlbXMuJy5sZW5ndGggPT0gNlxuICAgIGxldCBkb3QgPSBpdGVtc1BhdGguaW5kZXhPZignLicpO1xuICAgIGxldCBpdGVtc0lkeCA9IGRvdCA8IDAgPyBpdGVtc1BhdGggOiBpdGVtc1BhdGguc3Vic3RyaW5nKDAsIGRvdCk7XG4gICAgLy8gSWYgcGF0aCB3YXMgaW5kZXggaW50byBhcnJheS4uLlxuICAgIGlmIChpdGVtc0lkeCA9PSBwYXJzZUludChpdGVtc0lkeCwgMTApKSB7XG4gICAgICBsZXQgaXRlbVN1YlBhdGggPSBkb3QgPCAwID8gJycgOiBpdGVtc1BhdGguc3Vic3RyaW5nKGRvdCsxKTtcbiAgICAgIC8vIElmIHRoZSBwYXRoIGlzIG9ic2VydmVkLCBpdCB3aWxsIHRyaWdnZXIgYSBmdWxsIHJlZnJlc2hcbiAgICAgIHRoaXMuX19oYW5kbGVPYnNlcnZlZFBhdGhzKGl0ZW1TdWJQYXRoKTtcbiAgICAgIC8vIE5vdGUsIGV2ZW4gaWYgYSBydWxsIHJlZnJlc2ggaXMgdHJpZ2dlcmVkLCBhbHdheXMgZG8gdGhlIHBhdGhcbiAgICAgIC8vIG5vdGlmaWNhdGlvbiBiZWNhdXNlIHVubGVzcyBtdXRhYmxlRGF0YSBpcyB1c2VkIGZvciBkb20tcmVwZWF0XG4gICAgICAvLyBhbmQgYWxsIGVsZW1lbnRzIGluIHRoZSBpbnN0YW5jZSBzdWJ0cmVlLCBhIGZ1bGwgcmVmcmVzaCBtYXlcbiAgICAgIC8vIG5vdCB0cmlnZ2VyIHRoZSBwcm9wZXIgdXBkYXRlLlxuICAgICAgbGV0IGluc3RJZHggPSB0aGlzLl9faXRlbXNJZHhUb0luc3RJZHhbaXRlbXNJZHhdO1xuICAgICAgbGV0IGluc3QgPSB0aGlzLl9faW5zdGFuY2VzW2luc3RJZHhdO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgbGV0IGl0ZW1QYXRoID0gdGhpcy5hcyArIChpdGVtU3ViUGF0aCA/ICcuJyArIGl0ZW1TdWJQYXRoIDogJycpO1xuICAgICAgICAvLyBUaGlzIGlzIGVmZmVjdGl2ZWx5IGBub3RpZnlQYXRoYCwgYnV0IGF2b2lkcyBzb21lIG9mIHRoZSBvdmVyaGVhZFxuICAgICAgICAvLyBvZiB0aGUgcHVibGljIEFQSVxuICAgICAgICBpbnN0Ll9zZXRQZW5kaW5nUHJvcGVydHlPclBhdGgoaXRlbVBhdGgsIHZhbHVlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIGluc3QuX2ZsdXNoUHJvcGVydGllcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZW0gYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCBzdGFtcGVkIGJ5XG4gICAqIHRoaXMgYGRvbS1yZXBlYXRgLlxuICAgKlxuICAgKiBOb3RlLCB0byBtb2RpZnkgc3ViLXByb3BlcnRpZXMgb2YgdGhlIGl0ZW0sXG4gICAqIGBtb2RlbEZvckVsZW1lbnQoZWwpLnNldCgnaXRlbS48c3ViLXByb3A+JywgdmFsdWUpYFxuICAgKiBzaG91bGQgYmUgdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWwgRWxlbWVudCBmb3Igd2hpY2ggdG8gcmV0dXJuIHRoZSBpdGVtLlxuICAgKiBAcmV0dXJuIHsqfSBJdGVtIGFzc29jaWF0ZWQgd2l0aCB0aGUgZWxlbWVudC5cbiAgICovXG4gIGl0ZW1Gb3JFbGVtZW50KGVsKSB7XG4gICAgbGV0IGluc3RhbmNlID0gdGhpcy5tb2RlbEZvckVsZW1lbnQoZWwpO1xuICAgIHJldHVybiBpbnN0YW5jZSAmJiBpbnN0YW5jZVt0aGlzLmFzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpbnN0IGluZGV4IGZvciBhIGdpdmVuIGVsZW1lbnQgc3RhbXBlZCBieSB0aGlzIGBkb20tcmVwZWF0YC5cbiAgICogSWYgYHNvcnRgIGlzIHByb3ZpZGVkLCB0aGUgaW5kZXggd2lsbCByZWZsZWN0IHRoZSBzb3J0ZWQgb3JkZXIgKHJhdGhlclxuICAgKiB0aGFuIHRoZSBvcmlnaW5hbCBhcnJheSBvcmRlcikuXG4gICAqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsIEVsZW1lbnQgZm9yIHdoaWNoIHRvIHJldHVybiB0aGUgaW5kZXguXG4gICAqIEByZXR1cm4geyp9IFJvdyBpbmRleCBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnQgKG5vdGUgdGhpcyBtYXlcbiAgICogICBub3QgY29ycmVzcG9uZCB0byB0aGUgYXJyYXkgaW5kZXggaWYgYSB1c2VyIGBzb3J0YCBpcyBhcHBsaWVkKS5cbiAgICovXG4gIGluZGV4Rm9yRWxlbWVudChlbCkge1xuICAgIGxldCBpbnN0YW5jZSA9IHRoaXMubW9kZWxGb3JFbGVtZW50KGVsKTtcbiAgICByZXR1cm4gaW5zdGFuY2UgJiYgaW5zdGFuY2VbdGhpcy5pbmRleEFzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB0ZW1wbGF0ZSBcIm1vZGVsXCIgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4gZWxlbWVudCwgd2hpY2hcbiAgICogc2VydmVzIGFzIHRoZSBiaW5kaW5nIHNjb3BlIGZvciB0aGUgdGVtcGxhdGUgaW5zdGFuY2UgdGhlIGVsZW1lbnQgaXNcbiAgICogY29udGFpbmVkIGluLiBBIHRlbXBsYXRlIG1vZGVsIGlzIGFuIGluc3RhbmNlIG9mIGBQb2x5bWVyLkJhc2VgLCBhbmRcbiAgICogc2hvdWxkIGJlIHVzZWQgdG8gbWFuaXB1bGF0ZSBkYXRhIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHRlbXBsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiAgIGxldCBtb2RlbCA9IG1vZGVsRm9yRWxlbWVudChlbCk7XG4gICAqICAgaWYgKG1vZGVsLmluZGV4IDwgMTApIHtcbiAgICogICAgIG1vZGVsLnNldCgnaXRlbS5jaGVja2VkJywgdHJ1ZSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbCBFbGVtZW50IGZvciB3aGljaCB0byByZXR1cm4gYSB0ZW1wbGF0ZSBtb2RlbC5cbiAgICogQHJldHVybiB7VGVtcGxhdGVJbnN0YW5jZUJhc2V9IE1vZGVsIHJlcHJlc2VudGluZyB0aGUgYmluZGluZyBzY29wZSBmb3JcbiAgICogICB0aGUgZWxlbWVudC5cbiAgICovXG4gIG1vZGVsRm9yRWxlbWVudChlbCkge1xuICAgIHJldHVybiBUZW1wbGF0aXplLm1vZGVsRm9yRWxlbWVudCh0aGlzLnRlbXBsYXRlLCBlbCk7XG4gIH1cblxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoRG9tUmVwZWF0LmlzLCBEb21SZXBlYXQpO1xuXG5leHBvcnQgeyBEb21SZXBlYXQgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1yZXBlYXQuanNcbi8vIG1vZHVsZSBpZCA9IDY2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi8uLi9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgVGVtcGxhdGl6ZSB9IGZyb20gJy4uL3V0aWxzL3RlbXBsYXRpemUuanMnO1xuaW1wb3J0IHsgRGVib3VuY2VyIH0gZnJvbSAnLi4vdXRpbHMvZGVib3VuY2UuanMnO1xuaW1wb3J0IHsgZW5xdWV1ZURlYm91bmNlciwgZmx1c2ggfSBmcm9tICcuLi91dGlscy9mbHVzaC5qcyc7XG5pbXBvcnQgeyBtaWNyb1Rhc2sgfSBmcm9tICcuLi91dGlscy9hc3luYy5qcyc7XG5pbXBvcnQgeyByb290IGFzIHJvb3QkMCB9IGZyb20gJy4uL3V0aWxzL3BhdGguanMnO1xuXG4vKipcbiAqIFRoZSBgPGRvbS1pZj5gIGVsZW1lbnQgd2lsbCBzdGFtcCBhIGxpZ2h0LWRvbSBgPHRlbXBsYXRlPmAgY2hpbGQgd2hlblxuICogdGhlIGBpZmAgcHJvcGVydHkgYmVjb21lcyB0cnV0aHksIGFuZCB0aGUgdGVtcGxhdGUgY2FuIHVzZSBQb2x5bWVyXG4gKiBkYXRhLWJpbmRpbmcgYW5kIGRlY2xhcmF0aXZlIGV2ZW50IGZlYXR1cmVzIHdoZW4gdXNlZCBpbiB0aGUgY29udGV4dCBvZlxuICogYSBQb2x5bWVyIGVsZW1lbnQncyB0ZW1wbGF0ZS5cbiAqXG4gKiBXaGVuIGBpZmAgYmVjb21lcyBmYWxzZXksIHRoZSBzdGFtcGVkIGNvbnRlbnQgaXMgaGlkZGVuIGJ1dCBub3RcbiAqIHJlbW92ZWQgZnJvbSBkb20uIFdoZW4gYGlmYCBzdWJzZXF1ZW50bHkgYmVjb21lcyB0cnV0aHkgYWdhaW4sIHRoZSBjb250ZW50XG4gKiBpcyBzaW1wbHkgcmUtc2hvd24uIFRoaXMgYXBwcm9hY2ggaXMgdXNlZCBkdWUgdG8gaXRzIGZhdm9yYWJsZSBwZXJmb3JtYW5jZVxuICogY2hhcmFjdGVyaXN0aWNzOiB0aGUgZXhwZW5zZSBvZiBjcmVhdGluZyB0ZW1wbGF0ZSBjb250ZW50IGlzIHBhaWQgb25seVxuICogb25jZSBhbmQgbGF6aWx5LlxuICpcbiAqIFNldCB0aGUgYHJlc3RhbXBgIHByb3BlcnR5IHRvIHRydWUgdG8gZm9yY2UgdGhlIHN0YW1wZWQgY29udGVudCB0byBiZVxuICogY3JlYXRlZCAvIGRlc3Ryb3llZCB3aGVuIHRoZSBgaWZgIGNvbmRpdGlvbiBjaGFuZ2VzLlxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAcG9seW1lclxuICogQGV4dGVuZHMgUG9seW1lci5FbGVtZW50XG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBjb25kaXRpb25hbGx5IHN0YW1wcyBhbmQgaGlkZXMgb3IgcmVtb3Zlc1xuICogICB0ZW1wbGF0ZSBjb250ZW50IGJhc2VkIG9uIGEgYm9vbGVhbiBmbGFnLlxuICovXG5jbGFzcyBEb21JZiBleHRlbmRzIEVsZW1lbnQge1xuXG4gIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgLy8gY2FuIGZpbmQgdGhlIHRhZyBuYW1lIGZyb20gY3VzdG9tRWxlbWVudHMuZGVmaW5lIGNhbGxcbiAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdkb20taWYnOyB9XG5cbiAgc3RhdGljIGdldCB0ZW1wbGF0ZSgpIHsgcmV0dXJuIG51bGw7IH1cblxuICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICByZXR1cm4ge1xuXG4gICAgICAvKipcbiAgICAgICAqIEZpcmVkIHdoZW5ldmVyIERPTSBpcyBhZGRlZCBvciByZW1vdmVkL2hpZGRlbiBieSB0aGlzIHRlbXBsYXRlIChieVxuICAgICAgICogZGVmYXVsdCwgcmVuZGVyaW5nIG9jY3VycyBsYXppbHkpLiAgVG8gZm9yY2UgaW1tZWRpYXRlIHJlbmRlcmluZywgY2FsbFxuICAgICAgICogYHJlbmRlcmAuXG4gICAgICAgKlxuICAgICAgICogQGV2ZW50IGRvbS1jaGFuZ2VcbiAgICAgICAqL1xuXG4gICAgICAvKipcbiAgICAgICAqIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyB0ZW1wbGF0ZSBzaG91bGQgc3RhbXAuXG4gICAgICAgKi9cbiAgICAgIGlmOiB7XG4gICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgIG9ic2VydmVyOiAnX19kZWJvdW5jZVJlbmRlcidcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogV2hlbiB0cnVlLCBlbGVtZW50cyB3aWxsIGJlIHJlbW92ZWQgZnJvbSBET00gYW5kIGRpc2NhcmRlZCB3aGVuIGBpZmBcbiAgICAgICAqIGJlY29tZXMgZmFsc2UgYW5kIHJlLWNyZWF0ZWQgYW5kIGFkZGVkIGJhY2sgdG8gdGhlIERPTSB3aGVuIGBpZmBcbiAgICAgICAqIGJlY29tZXMgdHJ1ZS4gIEJ5IGRlZmF1bHQsIHN0YW1wZWQgZWxlbWVudHMgd2lsbCBiZSBoaWRkZW4gYnV0IGxlZnRcbiAgICAgICAqIGluIHRoZSBET00gd2hlbiBgaWZgIGJlY29tZXMgZmFsc2UsIHdoaWNoIGlzIGdlbmVyYWxseSByZXN1bHRzXG4gICAgICAgKiBpbiBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgICAgKi9cbiAgICAgIHJlc3RhbXA6IHtcbiAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgICAgb2JzZXJ2ZXI6ICdfX2RlYm91bmNlUmVuZGVyJ1xuICAgICAgfVxuXG4gICAgfTtcblxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9fcmVuZGVyRGVib3VuY2VyID0gbnVsbDtcbiAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICB0aGlzLl9faW5zdGFuY2UgPSBudWxsO1xuICAgIHRoaXMuX2xhc3RJZiA9IGZhbHNlO1xuICAgIHRoaXMuX19jdG9yID0gbnVsbDtcbiAgfVxuXG4gIF9fZGVib3VuY2VSZW5kZXIoKSB7XG4gICAgLy8gUmVuZGVyIGlzIGFzeW5jIGZvciAyIHJlYXNvbnM6XG4gICAgLy8gMS4gVG8gZWxpbWluYXRlIGRvbSBjcmVhdGlvbiB0cmFzaGluZyBpZiB1c2VyIGNvZGUgdGhyYXNoZXMgYGlmYCBpbiB0aGVcbiAgICAvLyAgICBzYW1lIHR1cm4uIFRoaXMgd2FzIG1vcmUgY29tbW9uIGluIDEueCB3aGVyZSBhIGNvbXBvdW5kIGNvbXB1dGVkXG4gICAgLy8gICAgcHJvcGVydHkgY291bGQgcmVzdWx0IGluIHRoZSByZXN1bHQgY2hhbmdpbmcgbXVsdGlwbGUgdGltZXMsIGJ1dCBpc1xuICAgIC8vICAgIG1pdGlnYXRlZCB0byBhIGxhcmdlIGV4dGVudCBieSBiYXRjaGVkIHByb3BlcnR5IHByb2Nlc3NpbmcgaW4gMi54LlxuICAgIC8vIDIuIFRvIGF2b2lkIGRvdWJsZSBvYmplY3QgcHJvcGFnYXRpb24gd2hlbiBhIGJhZyBpbmNsdWRpbmcgdmFsdWVzIGJvdW5kXG4gICAgLy8gICAgdG8gdGhlIGBpZmAgcHJvcGVydHkgYXMgd2VsbCBhcyBvbmUgb3IgbW9yZSBob3N0UHJvcHMgY291bGQgZW5xdWV1ZVxuICAgIC8vICAgIHRoZSA8ZG9tLWlmPiB0byBmbHVzaCBiZWZvcmUgdGhlIDx0ZW1wbGF0ZT4ncyBob3N0IHByb3BlcnR5XG4gICAgLy8gICAgZm9yd2FyZGluZy4gSW4gdGhhdCBzY2VuYXJpbyBjcmVhdGluZyBhbiBpbnN0YW5jZSB3b3VsZCByZXN1bHQgaW5cbiAgICAvLyAgICB0aGUgaG9zdCBwcm9wcyBiZWluZyBzZXQgb25jZSwgYW5kIHRoZW4gdGhlIGVucXVldWVkIGNoYW5nZXMgb24gdGhlXG4gICAgLy8gICAgdGVtcGxhdGUgd291bGQgc2V0IHByb3BlcnRpZXMgYSBzZWNvbmQgdGltZSwgcG90ZW50aWFsbHkgY2F1c2luZyBhblxuICAgIC8vICAgIG9iamVjdCB0byBiZSBzZXQgdG8gYW4gaW5zdGFuY2UgbW9yZSB0aGFuIG9uY2UuICBDcmVhdGluZyB0aGVcbiAgICAvLyAgICBpbnN0YW5jZSBhc3luYyBmcm9tIGZsdXNoaW5nIGRhdGEgZW5zdXJlcyB0aGlzIGRvZXNuJ3QgaGFwcGVuLiBJZlxuICAgIC8vICAgIHdlIHdhbnRlZCBhIHN5bmMgb3B0aW9uIGluIHRoZSBmdXR1cmUsIHNpbXBseSBoYXZpbmcgPGRvbS1pZj4gZmx1c2hcbiAgICAvLyAgICAob3IgY2xlYXIpIGl0cyB0ZW1wbGF0ZSdzIHBlbmRpbmcgaG9zdCBwcm9wZXJ0aWVzIGJlZm9yZSBjcmVhdGluZ1xuICAgIC8vICAgIHRoZSBpbnN0YW5jZSB3b3VsZCBhbHNvIGF2b2lkIHRoZSBwcm9ibGVtLlxuICAgIHRoaXMuX19yZW5kZXJEZWJvdW5jZXIgPSBEZWJvdW5jZXIuZGVib3VuY2UoXG4gICAgICAgICAgdGhpcy5fX3JlbmRlckRlYm91bmNlclxuICAgICAgICAsIG1pY3JvVGFza1xuICAgICAgICAsICgpID0+IHRoaXMuX19yZW5kZXIoKSk7XG4gICAgZW5xdWV1ZURlYm91bmNlcih0aGlzLl9fcmVuZGVyRGVib3VuY2VyKTtcbiAgfVxuXG4gIGRpc2Nvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmRpc2Nvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudE5vZGUgfHxcbiAgICAgICAgKHRoaXMucGFyZW50Tm9kZS5ub2RlVHlwZSA9PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgJiZcbiAgICAgICAgICF0aGlzLnBhcmVudE5vZGUuaG9zdCkpIHtcbiAgICAgIHRoaXMuX190ZWFyZG93bkluc3RhbmNlKCk7XG4gICAgfVxuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgc3VwZXIuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICBpZiAodGhpcy5pZikge1xuICAgICAgdGhpcy5fX2RlYm91bmNlUmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNlcyB0aGUgZWxlbWVudCB0byByZW5kZXIgaXRzIGNvbnRlbnQuIE5vcm1hbGx5IHJlbmRlcmluZyBpc1xuICAgKiBhc3luY2hyb25vdXMgdG8gYSBwcm92b2tpbmcgY2hhbmdlLiBUaGlzIGlzIGRvbmUgZm9yIGVmZmljaWVuY3kgc29cbiAgICogdGhhdCBtdWx0aXBsZSBjaGFuZ2VzIHRyaWdnZXIgb25seSBhIHNpbmdsZSByZW5kZXIuIFRoZSByZW5kZXIgbWV0aG9kXG4gICAqIHNob3VsZCBiZSBjYWxsZWQgaWYsIGZvciBleGFtcGxlLCB0ZW1wbGF0ZSByZW5kZXJpbmcgaXMgcmVxdWlyZWQgdG9cbiAgICogdmFsaWRhdGUgYXBwbGljYXRpb24gc3RhdGUuXG4gICAqL1xuICByZW5kZXIoKSB7XG4gICAgZmx1c2goKTtcbiAgfVxuXG4gIF9fcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmlmKSB7XG4gICAgICBpZiAoIXRoaXMuX19lbnN1cmVJbnN0YW5jZSgpKSB7XG4gICAgICAgIC8vIE5vIHRlbXBsYXRlIGZvdW5kIHlldFxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zaG93SGlkZUNoaWxkcmVuKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlc3RhbXApIHtcbiAgICAgIHRoaXMuX190ZWFyZG93bkluc3RhbmNlKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5yZXN0YW1wICYmIHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgdGhpcy5fc2hvd0hpZGVDaGlsZHJlbigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pZiAhPSB0aGlzLl9sYXN0SWYpIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2RvbS1jaGFuZ2UnLCB7XG4gICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgIGNvbXBvc2VkOiB0cnVlXG4gICAgICB9KSk7XG4gICAgICB0aGlzLl9sYXN0SWYgPSB0aGlzLmlmO1xuICAgIH1cbiAgfVxuXG4gIF9fZW5zdXJlSW5zdGFuY2UoKSB7XG4gICAgbGV0IHBhcmVudE5vZGUgPSB0aGlzLnBhcmVudE5vZGU7XG4gICAgLy8gR3VhcmQgYWdhaW5zdCBlbGVtZW50IGJlaW5nIGRldGFjaGVkIHdoaWxlIHJlbmRlciB3YXMgcXVldWVkXG4gICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgIGlmICghdGhpcy5fX2N0b3IpIHtcbiAgICAgICAgbGV0IHRlbXBsYXRlID0gdGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpO1xuICAgICAgICBpZiAoIXRlbXBsYXRlKSB7XG4gICAgICAgICAgLy8gV2FpdCB1bnRpbCBjaGlsZExpc3QgY2hhbmdlcyBhbmQgdGVtcGxhdGUgc2hvdWxkIGJlIHRoZXJlIGJ5IHRoZW5cbiAgICAgICAgICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5xdWVyeVNlbGVjdG9yKCd0ZW1wbGF0ZScpKSB7XG4gICAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgdGhpcy5fX3JlbmRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkb20taWYgcmVxdWlyZXMgYSA8dGVtcGxhdGU+IGNoaWxkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLCB7Y2hpbGRMaXN0OiB0cnVlfSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX19jdG9yID0gVGVtcGxhdGl6ZS50ZW1wbGF0aXplKHRlbXBsYXRlLCB0aGlzLCB7XG4gICAgICAgICAgLy8gZG9tLWlmIHRlbXBsYXRpemVyIGluc3RhbmNlcyByZXF1aXJlIGBtdXRhYmxlOiB0cnVlYCwgYXNcbiAgICAgICAgICAvLyBgX19zeW5jSG9zdFByb3BlcnRpZXNgIHJlbGllcyBvbiB0aGF0IGJlaGF2aW9yIHRvIHN5bmMgb2JqZWN0c1xuICAgICAgICAgIG11dGFibGVEYXRhOiB0cnVlLFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wIFByb3BlcnR5IHRvIGZvcndhcmRcbiAgICAgICAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIG9mIHByb3BlcnR5XG4gICAgICAgICAgICogQHRoaXMge3RoaXN9XG4gICAgICAgICAgICovXG4gICAgICAgICAgZm9yd2FyZEhvc3RQcm9wOiBmdW5jdGlvbihwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5pZikge1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnN0YW5jZS5mb3J3YXJkSG9zdFByb3AocHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gaW5zdGFuY2UgYnV0IGFyZSBzcXVlbGNoaW5nIGhvc3QgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAvLyBmb3J3YXJkaW5nIGR1ZSB0byBpZiBiZWluZyBmYWxzZSwgbm90ZSB0aGUgaW52YWxpZGF0ZWRcbiAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0aWVzIHNvIGBfX3N5bmNIb3N0UHJvcGVydGllc2AgY2FuIHN5bmMgdGhlbSB0aGUgbmV4dFxuICAgICAgICAgICAgICAgIC8vIHRpbWUgYGlmYCBiZWNvbWVzIHRydWVcbiAgICAgICAgICAgICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gdGhpcy5fX2ludmFsaWRQcm9wcyB8fCBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHNbcm9vdCQwKHByb3ApXSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLl9faW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlID0gbmV3IHRoaXMuX19jdG9yKCk7XG4gICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuX19pbnN0YW5jZS5yb290LCB0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19zeW5jSG9zdFByb3BlcnRpZXMoKTtcbiAgICAgICAgbGV0IGMkID0gdGhpcy5fX2luc3RhbmNlLmNoaWxkcmVuO1xuICAgICAgICBpZiAoYyQgJiYgYyQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gRGV0ZWN0IGNhc2Ugd2hlcmUgZG9tLWlmIHdhcyByZS1hdHRhY2hlZCBpbiBuZXcgcG9zaXRpb25cbiAgICAgICAgICBsZXQgbGFzdENoaWxkID0gdGhpcy5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgaWYgKGxhc3RDaGlsZCAhPT0gYyRbYyQubGVuZ3RoLTFdKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTAsIG47IChpPGMkLmxlbmd0aCkgJiYgKG49YyRbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobiwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgX19zeW5jSG9zdFByb3BlcnRpZXMoKSB7XG4gICAgbGV0IHByb3BzID0gdGhpcy5fX2ludmFsaWRQcm9wcztcbiAgICBpZiAocHJvcHMpIHtcbiAgICAgIGZvciAobGV0IHByb3AgaW4gcHJvcHMpIHtcbiAgICAgICAgdGhpcy5fX2luc3RhbmNlLl9zZXRQZW5kaW5nUHJvcGVydHkocHJvcCwgdGhpcy5fX2RhdGFIb3N0W3Byb3BdKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX19pbnZhbGlkUHJvcHMgPSBudWxsO1xuICAgICAgdGhpcy5fX2luc3RhbmNlLl9mbHVzaFByb3BlcnRpZXMoKTtcbiAgICB9XG4gIH1cblxuICBfX3RlYXJkb3duSW5zdGFuY2UoKSB7XG4gICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgbGV0IGMkID0gdGhpcy5fX2luc3RhbmNlLmNoaWxkcmVuO1xuICAgICAgaWYgKGMkICYmIGMkLmxlbmd0aCkge1xuICAgICAgICAvLyB1c2UgZmlyc3QgY2hpbGQgcGFyZW50LCBmb3IgY2FzZSB3aGVuIGRvbS1pZiBtYXkgaGF2ZSBiZWVuIGRldGFjaGVkXG4gICAgICAgIGxldCBwYXJlbnQgPSBjJFswXS5wYXJlbnROb2RlO1xuICAgICAgICBmb3IgKGxldCBpPTAsIG47IChpPGMkLmxlbmd0aCkgJiYgKG49YyRbaV0pOyBpKyspIHtcbiAgICAgICAgICBwYXJlbnQucmVtb3ZlQ2hpbGQobik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX19pbnN0YW5jZSA9IG51bGw7XG4gICAgICB0aGlzLl9faW52YWxpZFByb3BzID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBfc2hvd0hpZGVDaGlsZHJlbigpIHtcbiAgICBsZXQgaGlkZGVuID0gdGhpcy5fX2hpZGVUZW1wbGF0ZUNoaWxkcmVuX18gfHwgIXRoaXMuaWY7XG4gICAgaWYgKHRoaXMuX19pbnN0YW5jZSkge1xuICAgICAgdGhpcy5fX2luc3RhbmNlLl9zaG93SGlkZUNoaWxkcmVuKGhpZGRlbik7XG4gICAgfVxuICB9XG5cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKERvbUlmLmlzLCBEb21JZik7XG5cbmV4cG9ydCB7IERvbUlmIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9kb20taWYuanNcbi8vIG1vZHVsZSBpZCA9IDY3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgfSBmcm9tICcuLi8uLi9wb2x5bWVyLWVsZW1lbnQuanMnO1xuaW1wb3J0IHsgZGVkdXBpbmdNaXhpbiB9IGZyb20gJy4uL3V0aWxzL21peGluLmpzJztcbmltcG9ydCB7IGNhbGN1bGF0ZVNwbGljZXMgfSBmcm9tICcuLi91dGlscy9hcnJheS1zcGxpY2UuanMnO1xuaW1wb3J0IHsgRWxlbWVudE1peGluIH0gZnJvbSAnLi4vbWl4aW5zL2VsZW1lbnQtbWl4aW4uanMnO1xuXG4vKipcbiAqIEVsZW1lbnQgbWl4aW4gZm9yIHJlY29yZGluZyBkeW5hbWljIGFzc29jaWF0aW9ucyBiZXR3ZWVuIGl0ZW0gcGF0aHMgaW4gYVxuICogbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGEgYHNlbGVjdGVkYCBhcnJheSBzdWNoIHRoYXQgcGF0aCBjaGFuZ2VzIHRvIHRoZVxuICogbWFzdGVyIGFycmF5IChhdCB0aGUgaG9zdCkgZWxlbWVudCBvciBlbHNld2hlcmUgdmlhIGRhdGEtYmluZGluZykgYXJlXG4gKiBjb3JyZWN0bHkgcHJvcGFnYXRlZCB0byBpdGVtcyBpbiB0aGUgc2VsZWN0ZWQgYXJyYXkgYW5kIHZpY2UtdmVyc2EuXG4gKlxuICogVGhlIGBpdGVtc2AgcHJvcGVydHkgYWNjZXB0cyBhbiBhcnJheSBvZiB1c2VyIGRhdGEsIGFuZCB2aWEgdGhlXG4gKiBgc2VsZWN0KGl0ZW0pYCBhbmQgYGRlc2VsZWN0KGl0ZW0pYCBBUEksIHVwZGF0ZXMgdGhlIGBzZWxlY3RlZGAgcHJvcGVydHlcbiAqIHdoaWNoIG1heSBiZSBib3VuZCB0byBvdGhlciBwYXJ0cyBvZiB0aGUgYXBwbGljYXRpb24sIGFuZCBhbnkgY2hhbmdlcyB0b1xuICogc3ViLWZpZWxkcyBvZiBgc2VsZWN0ZWRgIGl0ZW0ocykgd2lsbCBiZSBrZXB0IGluIHN5bmMgd2l0aCBpdGVtcyBpbiB0aGVcbiAqIGBpdGVtc2AgYXJyYXkuICBXaGVuIGBtdWx0aWAgaXMgZmFsc2UsIGBzZWxlY3RlZGAgaXMgYSBwcm9wZXJ0eVxuICogcmVwcmVzZW50aW5nIHRoZSBsYXN0IHNlbGVjdGVkIGl0ZW0uICBXaGVuIGBtdWx0aWAgaXMgdHJ1ZSwgYHNlbGVjdGVkYFxuICogaXMgYW4gYXJyYXkgb2YgbXVsdGlwbHkgc2VsZWN0ZWQgaXRlbXMuXG4gKlxuICogQHBvbHltZXJcbiAqIEBtaXhpbkZ1bmN0aW9uXG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuRWxlbWVudE1peGluXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgRWxlbWVudCBtaXhpbiBmb3IgcmVjb3JkaW5nIGR5bmFtaWMgYXNzb2NpYXRpb25zIGJldHdlZW4gaXRlbSBwYXRocyBpbiBhXG4gKiBtYXN0ZXIgYGl0ZW1zYCBhcnJheSBhbmQgYSBgc2VsZWN0ZWRgIGFycmF5XG4gKi9cbmxldCBBcnJheVNlbGVjdG9yTWl4aW4gPSBkZWR1cGluZ01peGluKHN1cGVyQ2xhc3MgPT4ge1xuXG4gIC8qKlxuICAgKiBAY29uc3RydWN0b3JcbiAgICogQGV4dGVuZHMge3N1cGVyQ2xhc3N9XG4gICAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0VsZW1lbnRNaXhpbn1cbiAgICovXG4gIGxldCBlbGVtZW50QmFzZSA9IEVsZW1lbnRNaXhpbihzdXBlckNsYXNzKTtcblxuICAvKipcbiAgICogQHBvbHltZXJcbiAgICogQG1peGluQ2xhc3NcbiAgICogQGltcGxlbWVudHMge1BvbHltZXJfQXJyYXlTZWxlY3Rvck1peGlufVxuICAgKiBAdW5yZXN0cmljdGVkXG4gICAqL1xuICBjbGFzcyBBcnJheVNlbGVjdG9yTWl4aW4gZXh0ZW5kcyBlbGVtZW50QmFzZSB7XG5cbiAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG5cbiAgICAgIHJldHVybiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIGFycmF5IGNvbnRhaW5pbmcgaXRlbXMgZnJvbSB3aGljaCBzZWxlY3Rpb24gd2lsbCBiZSBtYWRlLlxuICAgICAgICAgKi9cbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICB0eXBlOiBBcnJheSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgdHJ1ZWAsIG11bHRpcGxlIGl0ZW1zIG1heSBiZSBzZWxlY3RlZCBhdCBvbmNlIChpbiB0aGlzIGNhc2UsXG4gICAgICAgICAqIGBzZWxlY3RlZGAgaXMgYW4gYXJyYXkgb2YgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW1zKS4gIFdoZW4gYGZhbHNlYCxcbiAgICAgICAgICogb25seSBvbmUgaXRlbSBtYXkgYmUgc2VsZWN0ZWQgYXQgYSB0aW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGk6IHtcbiAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgbXVsdGlgIGlzIHRydWUsIHRoaXMgaXMgYW4gYXJyYXkgdGhhdCBjb250YWlucyBhbnkgc2VsZWN0ZWQuXG4gICAgICAgICAqIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgdGhpcyBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIG9yIGBudWxsYFxuICAgICAgICAgKiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAdHlwZSB7PyhPYmplY3R8QXJyYXk8IU9iamVjdD4pfVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0ZWQ6IHtcbiAgICAgICAgICB0eXBlOiBPYmplY3QsXG4gICAgICAgICAgbm90aWZ5OiB0cnVlXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdoZW4gYG11bHRpYCBpcyBmYWxzZSwgdGhpcyBpcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGl0ZW0sIG9yIGBudWxsYFxuICAgICAgICAgKiBpZiBubyBpdGVtIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAdHlwZSB7P09iamVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHNlbGVjdGVkSXRlbToge1xuICAgICAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgICAgICBub3RpZnk6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogV2hlbiBgdHJ1ZWAsIGNhbGxpbmcgYHNlbGVjdGAgb24gYW4gaXRlbSB0aGF0IGlzIGFscmVhZHkgc2VsZWN0ZWRcbiAgICAgICAgICogd2lsbCBkZXNlbGVjdCB0aGUgaXRlbS5cbiAgICAgICAgICovXG4gICAgICAgIHRvZ2dsZToge1xuICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgICAgIH1cblxuICAgICAgfTtcbiAgICB9XG5cbiAgICBzdGF0aWMgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgIHJldHVybiBbJ19fdXBkYXRlU2VsZWN0aW9uKG11bHRpLCBpdGVtcy4qKSddO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX19sYXN0SXRlbXMgPSBudWxsO1xuICAgICAgdGhpcy5fX2xhc3RNdWx0aSA9IG51bGw7XG4gICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAgPSBudWxsO1xuICAgIH1cblxuICAgIF9fdXBkYXRlU2VsZWN0aW9uKG11bHRpLCBpdGVtc0luZm8pIHtcbiAgICAgIGxldCBwYXRoID0gaXRlbXNJbmZvLnBhdGg7XG4gICAgICBpZiAocGF0aCA9PSAnaXRlbXMnKSB7XG4gICAgICAgIC8vIENhc2UgMSAtIGl0ZW1zIGFycmF5IGNoYW5nZWQsIHNvIGRpZmYgYWdhaW5zdCBwcmV2aW91cyBhcnJheSBhbmRcbiAgICAgICAgLy8gZGVzZWxlY3QgYW55IHJlbW92ZWQgaXRlbXMgYW5kIGFkanVzdCBzZWxlY3RlZCBpbmRpY2VzXG4gICAgICAgIGxldCBuZXdJdGVtcyA9IGl0ZW1zSW5mby5iYXNlIHx8IFtdO1xuICAgICAgICBsZXQgbGFzdEl0ZW1zID0gdGhpcy5fX2xhc3RJdGVtcztcbiAgICAgICAgbGV0IGxhc3RNdWx0aSA9IHRoaXMuX19sYXN0TXVsdGk7XG4gICAgICAgIGlmIChtdWx0aSAhPT0gbGFzdE11bHRpKSB7XG4gICAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0SXRlbXMpIHtcbiAgICAgICAgICBsZXQgc3BsaWNlcyA9IGNhbGN1bGF0ZVNwbGljZXMobmV3SXRlbXMsIGxhc3RJdGVtcyk7XG4gICAgICAgICAgdGhpcy5fX2FwcGx5U3BsaWNlcyhzcGxpY2VzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fbGFzdEl0ZW1zID0gbmV3SXRlbXM7XG4gICAgICAgIHRoaXMuX19sYXN0TXVsdGkgPSBtdWx0aTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNJbmZvLnBhdGggPT0gJ2l0ZW1zLnNwbGljZXMnKSB7XG4gICAgICAgIC8vIENhc2UgMiAtIGdvdCBzcGVjaWZpYyBzcGxpY2UgaW5mb3JtYXRpb24gZGVzY3JpYmluZyB0aGUgYXJyYXkgbXV0YXRpb246XG4gICAgICAgIC8vIGRlc2VsZWN0IGFueSByZW1vdmVkIGl0ZW1zIGFuZCBhZGp1c3Qgc2VsZWN0ZWQgaW5kaWNlc1xuICAgICAgICB0aGlzLl9fYXBwbHlTcGxpY2VzKGl0ZW1zSW5mby52YWx1ZS5pbmRleFNwbGljZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQ2FzZSAzIC0gYW4gYXJyYXkgZWxlbWVudCB3YXMgY2hhbmdlZCwgc28gZGVzZWxlY3QgdGhlIHByZXZpb3VzXG4gICAgICAgIC8vIGl0ZW0gZm9yIHRoYXQgaW5kZXggaWYgaXQgd2FzIHByZXZpb3VzbHkgc2VsZWN0ZWRcbiAgICAgICAgbGV0IHBhcnQgPSBwYXRoLnNsaWNlKCdpdGVtcy4nLmxlbmd0aCk7XG4gICAgICAgIGxldCBpZHggPSBwYXJzZUludChwYXJ0LCAxMCk7XG4gICAgICAgIGlmICgocGFydC5pbmRleE9mKCcuJykgPCAwKSAmJiBwYXJ0ID09IGlkeCkge1xuICAgICAgICAgIHRoaXMuX19kZXNlbGVjdENoYW5nZWRJZHgoaWR4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIF9fYXBwbHlTcGxpY2VzKHNwbGljZXMpIHtcbiAgICAgIGxldCBzZWxlY3RlZCA9IHRoaXMuX19zZWxlY3RlZE1hcDtcbiAgICAgIC8vIEFkanVzdCBzZWxlY3RlZCBpbmRpY2VzIGFuZCBtYXJrIHJlbW92YWxzXG4gICAgICBmb3IgKGxldCBpPTA7IGk8c3BsaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgcyA9IHNwbGljZXNbaV07XG4gICAgICAgIHNlbGVjdGVkLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICAgIGlmIChpZHggPCBzLmluZGV4KSB7XG4gICAgICAgICAgICAvLyBubyBjaGFuZ2VcbiAgICAgICAgICB9IGVsc2UgaWYgKGlkeCA+PSBzLmluZGV4ICsgcy5yZW1vdmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gYWRqdXN0IGluZGV4XG4gICAgICAgICAgICBzZWxlY3RlZC5zZXQoaXRlbSwgaWR4ICsgcy5hZGRlZENvdW50IC0gcy5yZW1vdmVkLmxlbmd0aCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpbmRleFxuICAgICAgICAgICAgc2VsZWN0ZWQuc2V0KGl0ZW0sIC0xKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKGxldCBqPTA7IGo8cy5hZGRlZENvdW50OyBqKyspIHtcbiAgICAgICAgICBsZXQgaWR4ID0gcy5pbmRleCArIGo7XG4gICAgICAgICAgaWYgKHNlbGVjdGVkLmhhcyh0aGlzLml0ZW1zW2lkeF0pKSB7XG4gICAgICAgICAgICBzZWxlY3RlZC5zZXQodGhpcy5pdGVtc1tpZHhdLCBpZHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIGxpbmtlZCBwYXRoc1xuICAgICAgdGhpcy5fX3VwZGF0ZUxpbmtzKCk7XG4gICAgICAvLyBSZW1vdmUgc2VsZWN0ZWQgaXRlbXMgdGhhdCB3ZXJlIHJlbW92ZWQgZnJvbSB0aGUgaXRlbXMgYXJyYXlcbiAgICAgIGxldCBzaWR4ID0gMDtcbiAgICAgIHNlbGVjdGVkLmZvckVhY2goKGlkeCwgaXRlbSkgPT4ge1xuICAgICAgICBpZiAoaWR4IDwgMCkge1xuICAgICAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZSgnc2VsZWN0ZWQnLCBzaWR4LCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZCA9IHRoaXMuc2VsZWN0ZWRJdGVtID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZWN0ZWQuZGVsZXRlKGl0ZW0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNpZHgrKztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgX191cGRhdGVMaW5rcygpIHtcbiAgICAgIHRoaXMuX19kYXRhTGlua2VkUGF0aHMgPSB7fTtcbiAgICAgIGlmICh0aGlzLm11bHRpKSB7XG4gICAgICAgIGxldCBzaWR4ID0gMDtcbiAgICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwLmZvckVhY2goaWR4ID0+IHtcbiAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdpdGVtcy4nICsgaWR4LCAnc2VsZWN0ZWQuJyArIHNpZHgrKyk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgdGhpcy5saW5rUGF0aHMoJ3NlbGVjdGVkJywgJ2l0ZW1zLicgKyBpZHgpO1xuICAgICAgICAgIHRoaXMubGlua1BhdGhzKCdzZWxlY3RlZEl0ZW0nLCAnaXRlbXMuJyArIGlkeCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgc2VsZWN0aW9uIHN0YXRlLlxuICAgICAqXG4gICAgICovXG4gICAgY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAvLyBVbmJpbmQgcHJldmlvdXMgc2VsZWN0aW9uXG4gICAgICB0aGlzLl9fZGF0YUxpbmtlZFBhdGhzID0ge307XG4gICAgICAvLyBUaGUgc2VsZWN0ZWQgbWFwIHN0b3JlcyAzIHBpZWNlcyBvZiBpbmZvcm1hdGlvbjpcbiAgICAgIC8vIGtleTogaXRlbXMgYXJyYXkgb2JqZWN0XG4gICAgICAvLyB2YWx1ZTogaXRlbXMgYXJyYXkgaW5kZXhcbiAgICAgIC8vIG9yZGVyOiBzZWxlY3RlZCBhcnJheSBpbmRleFxuICAgICAgdGhpcy5fX3NlbGVjdGVkTWFwID0gbmV3IE1hcCgpO1xuICAgICAgLy8gSW5pdGlhbGl6ZSBzZWxlY3Rpb25cbiAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLm11bHRpID8gW10gOiBudWxsO1xuICAgICAgdGhpcy5zZWxlY3RlZEl0ZW0gPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaXRlbSBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IGl0ZW0gSXRlbSBmcm9tIGBpdGVtc2AgYXJyYXkgdG8gdGVzdFxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkKGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLl9fc2VsZWN0ZWRNYXAuaGFzKGl0ZW0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgd2hldGhlciB0aGUgaXRlbSBpcyBjdXJyZW50bHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byB0ZXN0XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0aGUgaXRlbSBpcyBzZWxlY3RlZFxuICAgICAqL1xuICAgIGlzSW5kZXhTZWxlY3RlZChpZHgpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzU2VsZWN0ZWQodGhpcy5pdGVtc1tpZHhdKTtcbiAgICB9XG5cbiAgICBfX2Rlc2VsZWN0Q2hhbmdlZElkeChpZHgpIHtcbiAgICAgIGxldCBzaWR4ID0gdGhpcy5fX3NlbGVjdGVkSW5kZXhGb3JJdGVtSW5kZXgoaWR4KTtcbiAgICAgIGlmIChzaWR4ID49IDApIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuZm9yRWFjaCgoaWR4LCBpdGVtKSA9PiB7XG4gICAgICAgICAgaWYgKHNpZHggPT0gaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2VsZWN0KGl0ZW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgX19zZWxlY3RlZEluZGV4Rm9ySXRlbUluZGV4KGlkeCkge1xuICAgICAgbGV0IHNlbGVjdGVkID0gdGhpcy5fX2RhdGFMaW5rZWRQYXRoc1snaXRlbXMuJyArIGlkeF07XG4gICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KHNlbGVjdGVkLnNsaWNlKCdzZWxlY3RlZC4nLmxlbmd0aCksIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGl0ZW0gaWYgaXQgaXMgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gaXRlbSBJdGVtIGZyb20gYGl0ZW1zYCBhcnJheSB0byBkZXNlbGVjdFxuICAgICAqL1xuICAgIGRlc2VsZWN0KGl0ZW0pIHtcbiAgICAgIGxldCBpZHggPSB0aGlzLl9fc2VsZWN0ZWRNYXAuZ2V0KGl0ZW0pO1xuICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgIHRoaXMuX19zZWxlY3RlZE1hcC5kZWxldGUoaXRlbSk7XG4gICAgICAgIGxldCBzaWR4O1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIHNpZHggPSB0aGlzLl9fc2VsZWN0ZWRJbmRleEZvckl0ZW1JbmRleChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIHRoaXMuc3BsaWNlKCdzZWxlY3RlZCcsIHNpZHgsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGVkSXRlbSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXNlbGVjdHMgdGhlIGdpdmVuIGluZGV4IGlmIGl0IGlzIGFscmVhZHkgc2VsZWN0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4IEluZGV4IGZyb20gYGl0ZW1zYCBhcnJheSB0byBkZXNlbGVjdFxuICAgICAqL1xuICAgIGRlc2VsZWN0SW5kZXgoaWR4KSB7XG4gICAgICB0aGlzLmRlc2VsZWN0KHRoaXMuaXRlbXNbaWR4XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gaXRlbS4gIFdoZW4gYHRvZ2dsZWAgaXMgdHJ1ZSwgdGhpcyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAgICAgKiBkZXNlbGVjdCB0aGUgaXRlbSBpZiBhbHJlYWR5IHNlbGVjdGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBpdGVtIEl0ZW0gZnJvbSBgaXRlbXNgIGFycmF5IHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNlbGVjdChpdGVtKSB7XG4gICAgICB0aGlzLnNlbGVjdEluZGV4KHRoaXMuaXRlbXMuaW5kZXhPZihpdGVtKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VsZWN0cyB0aGUgZ2l2ZW4gaW5kZXguICBXaGVuIGB0b2dnbGVgIGlzIHRydWUsIHRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5XG4gICAgICogZGVzZWxlY3QgdGhlIGl0ZW0gaWYgYWxyZWFkeSBzZWxlY3RlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpZHggSW5kZXggZnJvbSBgaXRlbXNgIGFycmF5IHRvIHNlbGVjdFxuICAgICAqL1xuICAgIHNlbGVjdEluZGV4KGlkeCkge1xuICAgICAgbGV0IGl0ZW0gPSB0aGlzLml0ZW1zW2lkeF07XG4gICAgICBpZiAoIXRoaXMuaXNTZWxlY3RlZChpdGVtKSkge1xuICAgICAgICBpZiAoIXRoaXMubXVsdGkpIHtcbiAgICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9fc2VsZWN0ZWRNYXAuc2V0KGl0ZW0sIGlkeCk7XG4gICAgICAgIHRoaXMuX191cGRhdGVMaW5rcygpO1xuICAgICAgICBpZiAodGhpcy5tdWx0aSkge1xuICAgICAgICAgIHRoaXMucHVzaCgnc2VsZWN0ZWQnLCBpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNlbGVjdGVkID0gdGhpcy5zZWxlY3RlZEl0ZW0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudG9nZ2xlKSB7XG4gICAgICAgIHRoaXMuZGVzZWxlY3RJbmRleChpZHgpO1xuICAgICAgfVxuICAgIH1cblxuICB9XG5cbiAgcmV0dXJuIEFycmF5U2VsZWN0b3JNaXhpbjtcblxufSk7XG5cbmV4cG9ydCB7IEFycmF5U2VsZWN0b3JNaXhpbiB9O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGV4dGVuZHMge1BvbHltZXIuRWxlbWVudH1cbiAqIEBpbXBsZW1lbnRzIHtQb2x5bWVyX0FycmF5U2VsZWN0b3JNaXhpbn1cbiAqL1xubGV0IGJhc2VBcnJheVNlbGVjdG9yID0gQXJyYXlTZWxlY3Rvck1peGluKEVsZW1lbnQpO1xuXG4vKipcbiAqIEVsZW1lbnQgaW1wbGVtZW50aW5nIHRoZSBgUG9seW1lci5BcnJheVNlbGVjdG9yYCBtaXhpbiwgd2hpY2ggcmVjb3Jkc1xuICogZHluYW1pYyBhc3NvY2lhdGlvbnMgYmV0d2VlbiBpdGVtIHBhdGhzIGluIGEgbWFzdGVyIGBpdGVtc2AgYXJyYXkgYW5kIGFcbiAqIGBzZWxlY3RlZGAgYXJyYXkgc3VjaCB0aGF0IHBhdGggY2hhbmdlcyB0byB0aGUgbWFzdGVyIGFycmF5IChhdCB0aGUgaG9zdClcbiAqIGVsZW1lbnQgb3IgZWxzZXdoZXJlIHZpYSBkYXRhLWJpbmRpbmcpIGFyZSBjb3JyZWN0bHkgcHJvcGFnYXRlZCB0byBpdGVtc1xuICogaW4gdGhlIHNlbGVjdGVkIGFycmF5IGFuZCB2aWNlLXZlcnNhLlxuICpcbiAqIFRoZSBgaXRlbXNgIHByb3BlcnR5IGFjY2VwdHMgYW4gYXJyYXkgb2YgdXNlciBkYXRhLCBhbmQgdmlhIHRoZVxuICogYHNlbGVjdChpdGVtKWAgYW5kIGBkZXNlbGVjdChpdGVtKWAgQVBJLCB1cGRhdGVzIHRoZSBgc2VsZWN0ZWRgIHByb3BlcnR5XG4gKiB3aGljaCBtYXkgYmUgYm91bmQgdG8gb3RoZXIgcGFydHMgb2YgdGhlIGFwcGxpY2F0aW9uLCBhbmQgYW55IGNoYW5nZXMgdG9cbiAqIHN1Yi1maWVsZHMgb2YgYHNlbGVjdGVkYCBpdGVtKHMpIHdpbGwgYmUga2VwdCBpbiBzeW5jIHdpdGggaXRlbXMgaW4gdGhlXG4gKiBgaXRlbXNgIGFycmF5LiAgV2hlbiBgbXVsdGlgIGlzIGZhbHNlLCBgc2VsZWN0ZWRgIGlzIGEgcHJvcGVydHlcbiAqIHJlcHJlc2VudGluZyB0aGUgbGFzdCBzZWxlY3RlZCBpdGVtLiAgV2hlbiBgbXVsdGlgIGlzIHRydWUsIGBzZWxlY3RlZGBcbiAqIGlzIGFuIGFycmF5IG9mIG11bHRpcGx5IHNlbGVjdGVkIGl0ZW1zLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBgaHRtbFxuICogPGRvbS1tb2R1bGUgaWQ9XCJlbXBsb3llZS1saXN0XCI+XG4gKlxuICogICA8dGVtcGxhdGU+XG4gKlxuICogICAgIDxkaXY+IEVtcGxveWVlIGxpc3Q6IDwvZGl2PlxuICogICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1yZXBlYXRcIiBpZD1cImVtcGxveWVlTGlzdFwiIGl0ZW1zPVwie3tlbXBsb3llZXN9fVwiPlxuICogICAgICAgICA8ZGl2PkZpcnN0IG5hbWU6IDxzcGFuPnt7aXRlbS5maXJzdH19PC9zcGFuPjwvZGl2PlxuICogICAgICAgICA8ZGl2Pkxhc3QgbmFtZTogPHNwYW4+e3tpdGVtLmxhc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICAgICAgPGJ1dHRvbiBvbi1jbGljaz1cInRvZ2dsZVNlbGVjdGlvblwiPlNlbGVjdDwvYnV0dG9uPlxuICogICAgIDwvdGVtcGxhdGU+XG4gKlxuICogICAgIDxhcnJheS1zZWxlY3RvciBpZD1cInNlbGVjdG9yXCIgaXRlbXM9XCJ7e2VtcGxveWVlc319XCIgc2VsZWN0ZWQ9XCJ7e3NlbGVjdGVkfX1cIiBtdWx0aSB0b2dnbGU+PC9hcnJheS1zZWxlY3Rvcj5cbiAqXG4gKiAgICAgPGRpdj4gU2VsZWN0ZWQgZW1wbG95ZWVzOiA8L2Rpdj5cbiAqICAgICA8dGVtcGxhdGUgaXM9XCJkb20tcmVwZWF0XCIgaXRlbXM9XCJ7e3NlbGVjdGVkfX1cIj5cbiAqICAgICAgICAgPGRpdj5GaXJzdCBuYW1lOiA8c3Bhbj57e2l0ZW0uZmlyc3R9fTwvc3Bhbj48L2Rpdj5cbiAqICAgICAgICAgPGRpdj5MYXN0IG5hbWU6IDxzcGFuPnt7aXRlbS5sYXN0fX08L3NwYW4+PC9kaXY+XG4gKiAgICAgPC90ZW1wbGF0ZT5cbiAqXG4gKiAgIDwvdGVtcGxhdGU+XG4gKlxuICogPC9kb20tbW9kdWxlPlxuICogYGBgXG4gKlxuICogYGBganNcbiAqIFBvbHltZXIoe1xuICogICBpczogJ2VtcGxveWVlLWxpc3QnLFxuICogICByZWFkeSgpIHtcbiAqICAgICB0aGlzLmVtcGxveWVlcyA9IFtcbiAqICAgICAgICAge2ZpcnN0OiAnQm9iJywgbGFzdDogJ1NtaXRoJ30sXG4gKiAgICAgICAgIHtmaXJzdDogJ1NhbGx5JywgbGFzdDogJ0pvaG5zb24nfSxcbiAqICAgICAgICAgLi4uXG4gKiAgICAgXTtcbiAqICAgfSxcbiAqICAgdG9nZ2xlU2VsZWN0aW9uKGUpIHtcbiAqICAgICBsZXQgaXRlbSA9IHRoaXMuJC5lbXBsb3llZUxpc3QuaXRlbUZvckVsZW1lbnQoZS50YXJnZXQpO1xuICogICAgIHRoaXMuJC5zZWxlY3Rvci5zZWxlY3QoaXRlbSk7XG4gKiAgIH1cbiAqIH0pO1xuICogYGBgXG4gKlxuICogQHBvbHltZXJcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAZXh0ZW5kcyB7YmFzZUFycmF5U2VsZWN0b3J9XG4gKiBAYXBwbGllc01peGluIFBvbHltZXIuQXJyYXlTZWxlY3Rvck1peGluXG4gKiBAbWVtYmVyb2YgUG9seW1lclxuICogQHN1bW1hcnkgQ3VzdG9tIGVsZW1lbnQgdGhhdCBsaW5rcyBwYXRocyBiZXR3ZWVuIGFuIGlucHV0IGBpdGVtc2AgYXJyYXkgYW5kXG4gKiAgIGFuIG91dHB1dCBgc2VsZWN0ZWRgIGl0ZW0gb3IgYXJyYXkgYmFzZWQgb24gY2FsbHMgdG8gaXRzIHNlbGVjdGlvbiBBUEkuXG4gKi9cbmNsYXNzIEFycmF5U2VsZWN0b3IgZXh0ZW5kcyBiYXNlQXJyYXlTZWxlY3RvciB7XG4gIC8vIE5vdCBuZWVkZWQgdG8gZmluZCB0ZW1wbGF0ZTsgY2FuIGJlIHJlbW92ZWQgb25jZSB0aGUgYW5hbHl6ZXJcbiAgLy8gY2FuIGZpbmQgdGhlIHRhZyBuYW1lIGZyb20gY3VzdG9tRWxlbWVudHMuZGVmaW5lIGNhbGxcbiAgc3RhdGljIGdldCBpcygpIHsgcmV0dXJuICdhcnJheS1zZWxlY3Rvcic7IH1cbn1cbmN1c3RvbUVsZW1lbnRzLmRlZmluZShBcnJheVNlbGVjdG9yLmlzLCBBcnJheVNlbGVjdG9yKTtcbmV4cG9ydCB7IEFycmF5U2VsZWN0b3IgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BvbHltZXIvbGliL2VsZW1lbnRzL2FycmF5LXNlbGVjdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSA2OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uLy4uLy4uLy4uL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMnO1xuaW1wb3J0IHsgY3NzRnJvbU1vZHVsZXMgfSBmcm9tICcuLi91dGlscy9zdHlsZS1nYXRoZXIuanMnO1xuXG5jb25zdCBhdHRyID0gJ2luY2x1ZGUnO1xuXG5jb25zdCBDdXN0b21TdHlsZUludGVyZmFjZSA9IHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZTtcblxuLyoqXG4gKiBDdXN0b20gZWxlbWVudCBmb3IgZGVmaW5pbmcgc3R5bGVzIGluIHRoZSBtYWluIGRvY3VtZW50IHRoYXQgY2FuIHRha2VcbiAqIGFkdmFudGFnZSBvZiBbc2hhZHkgRE9NXShodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9zaGFkeWNzcykgc2hpbXNcbiAqIGZvciBzdHlsZSBlbmNhcHN1bGF0aW9uLCBjdXN0b20gcHJvcGVydGllcywgYW5kIGN1c3RvbSBtaXhpbnMuXG4gKlxuICogLSBEb2N1bWVudCBzdHlsZXMgZGVmaW5lZCBpbiBhIGA8Y3VzdG9tLXN0eWxlPmAgYXJlIHNoaW1tZWQgdG8gZW5zdXJlIHRoZXlcbiAqICAgZG8gbm90IGxlYWsgaW50byBsb2NhbCBET00gd2hlbiBydW5uaW5nIG9uIGJyb3dzZXJzIHdpdGhvdXQgbmF0aXZlXG4gKiAgIFNoYWRvdyBET00uXG4gKiAtIEN1c3RvbSBwcm9wZXJ0aWVzIGNhbiBiZSBkZWZpbmVkIGluIGEgYDxjdXN0b20tc3R5bGU+YC4gVXNlIHRoZSBgaHRtbGAgc2VsZWN0b3JcbiAqICAgdG8gZGVmaW5lIGN1c3RvbSBwcm9wZXJ0aWVzIHRoYXQgYXBwbHkgdG8gYWxsIGN1c3RvbSBlbGVtZW50cy5cbiAqIC0gQ3VzdG9tIG1peGlucyBjYW4gYmUgZGVmaW5lZCBpbiBhIGA8Y3VzdG9tLXN0eWxlPmAsIGlmIHlvdSBpbXBvcnQgdGhlIG9wdGlvbmFsXG4gKiAgIFthcHBseSBzaGltXShodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9zaGFkeWNzcyNhYm91dC1hcHBseXNoaW0pXG4gKiAgIChgc2hhZHljc3MvYXBwbHktc2hpbS5odG1sYCkuXG4gKlxuICogVG8gdXNlOlxuICpcbiAqIC0gSW1wb3J0IGBjdXN0b20tc3R5bGUuaHRtbGAuXG4gKiAtIFBsYWNlIGEgYDxjdXN0b20tc3R5bGU+YCBlbGVtZW50IGluIHRoZSBtYWluIGRvY3VtZW50LCB3cmFwcGluZyBhbiBpbmxpbmUgYDxzdHlsZT5gIHRhZyB0aGF0XG4gKiAgIGNvbnRhaW5zIHRoZSBDU1MgcnVsZXMgeW91IHdhbnQgdG8gc2hpbS5cbiAqXG4gKiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBcbiAqIDwhLS0gaW1wb3J0IGFwcGx5IHNoaW0tLW9ubHkgcmVxdWlyZWQgaWYgdXNpbmcgbWl4aW5zIC0tPlxuICogPGxpbmsgcmVsPVwiaW1wb3J0IGhyZWY9XCJib3dlcl9jb21wb25lbnRzL3NoYWR5Y3NzL2FwcGx5LXNoaW0uaHRtbFwiPlxuICogPCEtLSBpbXBvcnQgY3VzdG9tLXN0eWxlIGVsZW1lbnQgLS0+XG4gKiA8bGluayByZWw9XCJpbXBvcnRcIiBocmVmPVwiYm93ZXJfY29tcG9uZW50cy9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuaHRtbFwiPlxuICogLi4uXG4gKiA8Y3VzdG9tLXN0eWxlPlxuICogICA8c3R5bGU+XG4gKiAgICAgaHRtbCB7XG4gKiAgICAgICAtLWN1c3RvbS1jb2xvcjogYmx1ZTtcbiAqICAgICAgIC0tY3VzdG9tLW1peGluOiB7XG4gKiAgICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICogICAgICAgICBjb2xvcjogcmVkO1xuICogICAgICAgfTtcbiAqICAgICB9XG4gKiAgIDwvc3R5bGU+XG4gKiA8L2N1c3RvbS1zdHlsZT5cbiAqIGBgYFxuICpcbiAqIEBjdXN0b21FbGVtZW50XG4gKiBAZXh0ZW5kcyBIVE1MRWxlbWVudFxuICogQG1lbWJlcm9mIFBvbHltZXJcbiAqIEBzdW1tYXJ5IEN1c3RvbSBlbGVtZW50IGZvciBkZWZpbmluZyBzdHlsZXMgaW4gdGhlIG1haW4gZG9jdW1lbnQgdGhhdCBjYW5cbiAqICAgdGFrZSBhZHZhbnRhZ2Ugb2YgUG9seW1lcidzIHN0eWxlIHNjb3BpbmcgYW5kIGN1c3RvbSBwcm9wZXJ0aWVzIHNoaW1zLlxuICovXG5jbGFzcyBDdXN0b21TdHlsZSBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLl9zdHlsZSA9IG51bGw7XG4gICAgQ3VzdG9tU3R5bGVJbnRlcmZhY2UuYWRkQ3VzdG9tU3R5bGUodGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpZ2h0LURPTSBgPHN0eWxlPmAgY2hpbGQgdGhpcyBlbGVtZW50IHdyYXBzLiAgVXBvbiBmaXJzdFxuICAgKiBjYWxsIGFueSBzdHlsZSBtb2R1bGVzIHJlZmVyZW5jZWQgdmlhIHRoZSBgaW5jbHVkZWAgYXR0cmlidXRlIHdpbGwgYmVcbiAgICogY29uY2F0ZW5hdGVkIHRvIHRoaXMgZWxlbWVudCdzIGA8c3R5bGU+YC5cbiAgICpcbiAgICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH0gVGhpcyBlbGVtZW50J3MgbGlnaHQtRE9NIGA8c3R5bGU+YFxuICAgKi9cbiAgZ2V0U3R5bGUoKSB7XG4gICAgaWYgKHRoaXMuX3N0eWxlKSB7XG4gICAgICByZXR1cm4gdGhpcy5fc3R5bGU7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqLyh0aGlzLnF1ZXJ5U2VsZWN0b3IoJ3N0eWxlJykpO1xuICAgIGlmICghc3R5bGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0aGlzLl9zdHlsZSA9IHN0eWxlO1xuICAgIGNvbnN0IGluY2x1ZGUgPSBzdHlsZS5nZXRBdHRyaWJ1dGUoYXR0cik7XG4gICAgaWYgKGluY2x1ZGUpIHtcbiAgICAgIHN0eWxlLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gY3NzRnJvbU1vZHVsZXMoaW5jbHVkZSkgKyBzdHlsZS50ZXh0Q29udGVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0eWxlO1xuICB9XG59XG5cbndpbmRvdy5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ2N1c3RvbS1zdHlsZScsIEN1c3RvbVN0eWxlKTtcbmV4cG9ydCB7IEN1c3RvbVN0eWxlIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9lbGVtZW50cy9jdXN0b20tc3R5bGUuanNcbi8vIG1vZHVsZSBpZCA9IDY5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IEN1c3RvbVN0eWxlSW50ZXJmYWNlIGZyb20gJy4uL3NyYy9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzJztcbmltcG9ydCB7Z2V0Q29tcHV0ZWRTdHlsZVZhbHVlLCB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzfSBmcm9tICcuLi9zcmMvY29tbW9uLXV0aWxzLmpzJztcbmltcG9ydCB7bmF0aXZlQ3NzVmFyaWFibGVzLCBuYXRpdmVTaGFkb3d9IGZyb20gJy4uL3NyYy9zdHlsZS1zZXR0aW5ncy5qcyc7XG5cbmNvbnN0IGN1c3RvbVN0eWxlSW50ZXJmYWNlID0gbmV3IEN1c3RvbVN0eWxlSW50ZXJmYWNlKCk7XG5cbmlmICghd2luZG93LlNoYWR5Q1NTKSB7XG4gIHdpbmRvdy5TaGFkeUNTUyA9IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmc9fSBlbGVtZW50RXh0ZW5kc1xuICAgICAqL1xuICAgIHByZXBhcmVUZW1wbGF0ZSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUsIGVsZW1lbnRFeHRlbmRzKSB7fSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc3R5bGVTdWJ0cmVlKGVsZW1lbnQsIHByb3BlcnRpZXMpIHtcbiAgICAgIGN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb2Nlc3NTdHlsZXMoKTtcbiAgICAgIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgICAqL1xuICAgIHN0eWxlRWxlbWVudChlbGVtZW50KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICAgIGN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb2Nlc3NTdHlsZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgc3R5bGVEb2N1bWVudChwcm9wZXJ0aWVzKSB7XG4gICAgICBjdXN0b21TdHlsZUludGVyZmFjZS5wcm9jZXNzU3R5bGVzKCk7XG4gICAgICB1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzKGRvY3VtZW50LmJvZHksIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgICB9LFxuICAgIG5hdGl2ZUNzczogbmF0aXZlQ3NzVmFyaWFibGVzLFxuICAgIG5hdGl2ZVNoYWRvdzogbmF0aXZlU2hhZG93XG4gIH1cbn1cblxud2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlID0gY3VzdG9tU3R5bGVJbnRlcmZhY2U7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3MvZW50cnlwb2ludHMvY3VzdG9tLXN0eWxlLWludGVyZmFjZS5qc1xuLy8gbW9kdWxlIGlkID0gNzBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgTXV0YWJsZURhdGEgfSBmcm9tICcuLi9taXhpbnMvbXV0YWJsZS1kYXRhLmpzJztcblxubGV0IG11dGFibGVQcm9wZXJ0eUNoYW5nZTtcbihcbiAgLyoqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9ICovXG4gIChmdW5jdGlvbigpIHtcbiAgbXV0YWJsZVByb3BlcnR5Q2hhbmdlID0gTXV0YWJsZURhdGEuX211dGFibGVQcm9wZXJ0eUNoYW5nZTtcbn0pKSgpO1xuXG5leHBvcnQgY29uc3QgTXV0YWJsZURhdGFCZWhhdmlvciA9IHtcblxuICAvKipcbiAgICogT3ZlcnJpZGVzIGBQb2x5bWVyLlByb3BlcnR5RWZmZWN0c2AgdG8gcHJvdmlkZSBvcHRpb24gZm9yIHNraXBwaW5nXG4gICAqIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZyBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBwdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGBcbiAgICogY2FjaGUgKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2hvdWxkUHJvcGVydHlDaGFuZ2UocHJvcGVydHksIHZhbHVlLCBvbGQpIHtcbiAgICByZXR1cm4gbXV0YWJsZVByb3BlcnR5Q2hhbmdlKHRoaXMsIHByb3BlcnR5LCB2YWx1ZSwgb2xkLCB0cnVlKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IE9wdGlvbmFsTXV0YWJsZURhdGFCZWhhdmlvciA9IHtcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogSW5zdGFuY2UtbGV2ZWwgZmxhZyBmb3IgY29uZmlndXJpbmcgdGhlIGRpcnR5LWNoZWNraW5nIHN0cmF0ZWd5XG4gICAgICogZm9yIHRoaXMgZWxlbWVudC4gIFdoZW4gdHJ1ZSwgT2JqZWN0cyBhbmQgQXJyYXlzIHdpbGwgc2tpcCBkaXJ0eVxuICAgICAqIGNoZWNraW5nLCBvdGhlcndpc2Ugc3RyaWN0IGVxdWFsaXR5IGNoZWNraW5nIHdpbGwgYmUgdXNlZC5cbiAgICAgKi9cbiAgICBtdXRhYmxlRGF0YTogQm9vbGVhblxuICB9LFxuXG4gIC8qKlxuICAgKiBPdmVycmlkZXMgYFBvbHltZXIuUHJvcGVydHlFZmZlY3RzYCB0byBza2lwIHN0cmljdCBlcXVhbGl0eSBjaGVja2luZ1xuICAgKiBmb3IgT2JqZWN0cyBhbmQgQXJyYXlzLlxuICAgKlxuICAgKiBQdWxscyB0aGUgdmFsdWUgdG8gZGlydHkgY2hlY2sgYWdhaW5zdCBmcm9tIHRoZSBgX19kYXRhVGVtcGAgY2FjaGVcbiAgICogKHJhdGhlciB0aGFuIHRoZSBub3JtYWwgYF9fZGF0YWAgY2FjaGUpIGZvciBPYmplY3RzLiAgU2luY2UgdGhlIHRlbXBcbiAgICogY2FjaGUgaXMgY2xlYXJlZCBhdCB0aGUgZW5kIG9mIGEgdHVybiwgdGhpcyBpbXBsZW1lbnRhdGlvbiBhbGxvd3NcbiAgICogc2lkZS1lZmZlY3RzIG9mIGRlZXAgb2JqZWN0IGNoYW5nZXMgdG8gYmUgcHJvY2Vzc2VkIGJ5IHJlLXNldHRpbmcgdGhlXG4gICAqIHNhbWUgb2JqZWN0ICh1c2luZyB0aGUgdGVtcCBjYWNoZSBhcyBhbiBpbi10dXJuIGJhY2tzdG9wIHRvIHByZXZlbnRcbiAgICogY3ljbGVzIGR1ZSB0byAyLXdheSBub3RpZmljYXRpb24pLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgUHJvcGVydHkgbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcGFyYW0geyp9IG9sZCBQcmV2aW91cyBwcm9wZXJ0eSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgY29uc2lkZXJlZCBhIGNoYW5nZVxuICAgKiBAdGhpcyB7dGhpc31cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3Nob3VsZFByb3BlcnR5Q2hhbmdlKHByb3BlcnR5LCB2YWx1ZSwgb2xkKSB7XG4gICAgcmV0dXJuIG11dGFibGVQcm9wZXJ0eUNoYW5nZSh0aGlzLCBwcm9wZXJ0eSwgdmFsdWUsIG9sZCwgdGhpcy5tdXRhYmxlRGF0YSk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wb2x5bWVyL2xpYi9sZWdhY3kvbXV0YWJsZS1kYXRhLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3MVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBOZW9uQW5pbWF0YWJsZUJlaGF2aW9yIH0gZnJvbSAnLi9uZW9uLWFuaW1hdGFibGUtYmVoYXZpb3IuanMnO1xuXG5leHBvcnQgY29uc3QgTmVvbkFuaW1hdGlvblJ1bm5lckJlaGF2aW9ySW1wbCA9IHtcblxuICBfY29uZmlndXJlQW5pbWF0aW9uczogZnVuY3Rpb24oY29uZmlncykge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgaWYgKGNvbmZpZ3MubGVuZ3RoID4gMCkge1xuICAgICAgZm9yICh2YXIgY29uZmlnLCBpbmRleCA9IDA7IGNvbmZpZyA9IGNvbmZpZ3NbaW5kZXhdOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBuZW9uQW5pbWF0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChjb25maWcubmFtZSk7XG4gICAgICAgIC8vIGlzIHRoaXMgZWxlbWVudCBhY3R1YWxseSBhIG5lb24gYW5pbWF0aW9uP1xuICAgICAgICBpZiAobmVvbkFuaW1hdGlvbi5pc05lb25BbmltYXRpb24pIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAvLyBjb25maWd1cmF0aW9uIG9yIHBsYXkgY291bGQgZmFpbCBpZiBwb2x5ZmlsbHMgYXJlbid0IGxvYWRlZFxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBuZW9uQW5pbWF0aW9uLmNvbmZpZ3VyZShjb25maWcpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhbiBFZmZlY3QgcmF0aGVyIHRoYW4gYW4gQW5pbWF0aW9uXG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdC5jYW5jZWwgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICByZXN1bHQgPSBkb2N1bWVudC50aW1lbGluZS5wbGF5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGRudCBwbGF5JywgJygnLCBjb25maWcubmFtZSwgJykuJywgZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgIG5lb25BbmltYXRpb246IG5lb25BbmltYXRpb24sXG4gICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICAgICAgICBhbmltYXRpb246IHJlc3VsdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4odGhpcy5pcyArICc6JywgY29uZmlnLm5hbWUsICdub3QgZm91bmQhJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH0sXG5cbiAgX3Nob3VsZENvbXBsZXRlOiBmdW5jdGlvbihhY3RpdmVFbnRyaWVzKSB7XG4gICAgdmFyIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFjdGl2ZUVudHJpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhY3RpdmVFbnRyaWVzW2ldLmFuaW1hdGlvbi5wbGF5U3RhdGUgIT0gJ2ZpbmlzaGVkJykge1xuICAgICAgICBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaGVkO1xuICB9LFxuXG4gIF9jb21wbGV0ZTogZnVuY3Rpb24oYWN0aXZlRW50cmllcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aXZlRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZlRW50cmllc1tpXS5uZW9uQW5pbWF0aW9uLmNvbXBsZXRlKGFjdGl2ZUVudHJpZXNbaV0uY29uZmlnKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY3RpdmVFbnRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY3RpdmVFbnRyaWVzW2ldLmFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFBsYXlzIGFuIGFuaW1hdGlvbiB3aXRoIGFuIG9wdGlvbmFsIGB0eXBlYC5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlXG4gICAqIEBwYXJhbSB7IU9iamVjdD19IGNvb2tpZVxuICAgKi9cbiAgcGxheUFuaW1hdGlvbjogZnVuY3Rpb24odHlwZSwgY29va2llKSB7XG4gICAgdmFyIGNvbmZpZ3MgPSB0aGlzLmdldEFuaW1hdGlvbkNvbmZpZyh0eXBlKTtcbiAgICBpZiAoIWNvbmZpZ3MpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fYWN0aXZlID0gdGhpcy5fYWN0aXZlIHx8IHt9O1xuICAgIGlmICh0aGlzLl9hY3RpdmVbdHlwZV0pIHtcbiAgICAgIHRoaXMuX2NvbXBsZXRlKHRoaXMuX2FjdGl2ZVt0eXBlXSk7XG4gICAgICBkZWxldGUgdGhpcy5fYWN0aXZlW3R5cGVdO1xuICAgIH1cblxuICAgIHZhciBhY3RpdmVFbnRyaWVzID0gdGhpcy5fY29uZmlndXJlQW5pbWF0aW9ucyhjb25maWdzKTtcblxuICAgIGlmIChhY3RpdmVFbnRyaWVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICB0aGlzLmZpcmUoJ25lb24tYW5pbWF0aW9uLWZpbmlzaCcsIGNvb2tpZSwge2J1YmJsZXM6IGZhbHNlfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fYWN0aXZlW3R5cGVdID0gYWN0aXZlRW50cmllcztcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWN0aXZlRW50cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgYWN0aXZlRW50cmllc1tpXS5hbmltYXRpb24ub25maW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZENvbXBsZXRlKGFjdGl2ZUVudHJpZXMpKSB7XG4gICAgICAgICAgdGhpcy5fY29tcGxldGUoYWN0aXZlRW50cmllcyk7XG4gICAgICAgICAgZGVsZXRlIHRoaXMuX2FjdGl2ZVt0eXBlXTtcbiAgICAgICAgICB0aGlzLmZpcmUoJ25lb24tYW5pbWF0aW9uLWZpbmlzaCcsIGNvb2tpZSwge2J1YmJsZXM6IGZhbHNlfSk7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbmNlbHMgdGhlIGN1cnJlbnRseSBydW5uaW5nIGFuaW1hdGlvbnMuXG4gICAqL1xuICBjYW5jZWxBbmltYXRpb246IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5fYW5pbWF0aW9ucykge1xuICAgICAgdGhpcy5fYW5pbWF0aW9uc1trXS5jYW5jZWwoKTtcbiAgICB9XG4gICAgdGhpcy5fYW5pbWF0aW9ucyA9IHt9O1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgTmVvbkFuaW1hdGlvblJ1bm5lckJlaGF2aW9yID0gW1xuICBOZW9uQW5pbWF0YWJsZUJlaGF2aW9yLFxuICBOZW9uQW5pbWF0aW9uUnVubmVyQmVoYXZpb3JJbXBsXG5dO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvbmVvbi1hbmltYXRpb24vbmVvbi1hbmltYXRpb24tcnVubmVyLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3MlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5cbmV4cG9ydCBjb25zdCBOZW9uQW5pbWF0YWJsZUJlaGF2aW9yID0ge1xuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIEFuaW1hdGlvbiBjb25maWd1cmF0aW9uLiBTZWUgUkVBRE1FIGZvciBtb3JlIGluZm8uXG4gICAgICovXG4gICAgYW5pbWF0aW9uQ29uZmlnOiB7XG4gICAgICB0eXBlOiBPYmplY3RcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgcHJvcGVydHkgZm9yIHNldHRpbmcgYW4gJ2VudHJ5JyBhbmltYXRpb24uIERvIG5vdCBzZXQgYGFuaW1hdGlvbkNvbmZpZy5lbnRyeWBcbiAgICAgKiBtYW51YWxseSBpZiB1c2luZyB0aGlzLiBUaGUgYW5pbWF0ZWQgbm9kZSBpcyBzZXQgdG8gYHRoaXNgIGlmIHVzaW5nIHRoaXMgcHJvcGVydHkuXG4gICAgICovXG4gICAgZW50cnlBbmltYXRpb246IHtcbiAgICAgIG9ic2VydmVyOiAnX2VudHJ5QW5pbWF0aW9uQ2hhbmdlZCcsXG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVuaWVuY2UgcHJvcGVydHkgZm9yIHNldHRpbmcgYW4gJ2V4aXQnIGFuaW1hdGlvbi4gRG8gbm90IHNldCBgYW5pbWF0aW9uQ29uZmlnLmV4aXRgXG4gICAgICogbWFudWFsbHkgaWYgdXNpbmcgdGhpcy4gVGhlIGFuaW1hdGVkIG5vZGUgaXMgc2V0IHRvIGB0aGlzYCBpZiB1c2luZyB0aGlzIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGV4aXRBbmltYXRpb246IHtcbiAgICAgIG9ic2VydmVyOiAnX2V4aXRBbmltYXRpb25DaGFuZ2VkJyxcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH1cblxuICB9LFxuXG4gIF9lbnRyeUFuaW1hdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uQ29uZmlnID0gdGhpcy5hbmltYXRpb25Db25maWcgfHwge307XG4gICAgdGhpcy5hbmltYXRpb25Db25maWdbJ2VudHJ5J10gPSBbe1xuICAgICAgbmFtZTogdGhpcy5lbnRyeUFuaW1hdGlvbixcbiAgICAgIG5vZGU6IHRoaXNcbiAgICB9XTtcbiAgfSxcblxuICBfZXhpdEFuaW1hdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYW5pbWF0aW9uQ29uZmlnID0gdGhpcy5hbmltYXRpb25Db25maWcgfHwge307XG4gICAgdGhpcy5hbmltYXRpb25Db25maWdbJ2V4aXQnXSA9IFt7XG4gICAgICBuYW1lOiB0aGlzLmV4aXRBbmltYXRpb24sXG4gICAgICBub2RlOiB0aGlzXG4gICAgfV07XG4gIH0sXG5cbiAgX2NvcHlQcm9wZXJ0aWVzOiBmdW5jdGlvbihjb25maWcxLCBjb25maWcyKSB7XG4gICAgLy8gc2hhbGxvd2x5IGNvcHkgcHJvcGVydGllcyBmcm9tIGNvbmZpZzIgdG8gY29uZmlnMVxuICAgIGZvciAodmFyIHByb3BlcnR5IGluIGNvbmZpZzIpIHtcbiAgICAgIGNvbmZpZzFbcHJvcGVydHldID0gY29uZmlnMltwcm9wZXJ0eV07XG4gICAgfVxuICB9LFxuXG4gIF9jbG9uZUNvbmZpZzogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgaXNDbG9uZTogdHJ1ZVxuICAgIH07XG4gICAgdGhpcy5fY29weVByb3BlcnRpZXMoY2xvbmUsIGNvbmZpZyk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9LFxuXG4gIF9nZXRBbmltYXRpb25Db25maWdSZWN1cnNpdmU6IGZ1bmN0aW9uKHR5cGUsIG1hcCwgYWxsQ29uZmlncykge1xuICAgIGlmICghdGhpcy5hbmltYXRpb25Db25maWcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZih0aGlzLmFuaW1hdGlvbkNvbmZpZy52YWx1ZSAmJiB0eXBlb2YgdGhpcy5hbmltYXRpb25Db25maWcudmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMuX3dhcm4odGhpcy5fbG9nZigncGxheUFuaW1hdGlvbicsIFwiUGxlYXNlIHB1dCAnYW5pbWF0aW9uQ29uZmlnJyBpbnNpZGUgb2YgeW91ciBjb21wb25lbnRzICdwcm9wZXJ0aWVzJyBvYmplY3QgaW5zdGVhZCBvZiBvdXRzaWRlIG9mIGl0LlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdHlwZSBpcyBvcHRpb25hbFxuICAgIHZhciB0aGlzQ29uZmlnO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICB0aGlzQ29uZmlnID0gdGhpcy5hbmltYXRpb25Db25maWdbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNDb25maWcgPSB0aGlzLmFuaW1hdGlvbkNvbmZpZztcbiAgICB9XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodGhpc0NvbmZpZykpIHtcbiAgICAgIHRoaXNDb25maWcgPSBbdGhpc0NvbmZpZ107XG4gICAgfVxuXG4gICAgLy8gaXRlcmF0ZSBhbmltYXRpb25zIGFuZCByZWN1cnNlIHRvIHByb2Nlc3MgY29uZmlndXJhdGlvbnMgZnJvbSBjaGlsZCBub2Rlc1xuICAgIGlmICh0aGlzQ29uZmlnKSB7XG4gICAgICBmb3IgKHZhciBjb25maWcsIGluZGV4ID0gMDsgY29uZmlnID0gdGhpc0NvbmZpZ1tpbmRleF07IGluZGV4KyspIHtcbiAgICAgICAgaWYgKGNvbmZpZy5hbmltYXRhYmxlKSB7XG4gICAgICAgICAgY29uZmlnLmFuaW1hdGFibGUuX2dldEFuaW1hdGlvbkNvbmZpZ1JlY3Vyc2l2ZShjb25maWcudHlwZSB8fCB0eXBlLCBtYXAsIGFsbENvbmZpZ3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb25maWcuaWQpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZWRDb25maWcgPSBtYXBbY29uZmlnLmlkXTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRDb25maWcpIHtcbiAgICAgICAgICAgICAgLy8gbWVyZ2UgY29uZmlndXJhdGlvbnMgd2l0aCB0aGUgc2FtZSBpZCwgbWFraW5nIGEgY2xvbmUgbGF6aWx5XG4gICAgICAgICAgICAgIGlmICghY2FjaGVkQ29uZmlnLmlzQ2xvbmUpIHtcbiAgICAgICAgICAgICAgICBtYXBbY29uZmlnLmlkXSA9IHRoaXMuX2Nsb25lQ29uZmlnKGNhY2hlZENvbmZpZyk7XG4gICAgICAgICAgICAgICAgY2FjaGVkQ29uZmlnID0gbWFwW2NvbmZpZy5pZF07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fY29weVByb3BlcnRpZXMoY2FjaGVkQ29uZmlnLCBjb25maWcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gcHV0IGFueSBjb25maWdzIHdpdGggYW4gaWQgaW50byBhIG1hcFxuICAgICAgICAgICAgICBtYXBbY29uZmlnLmlkXSA9IGNvbmZpZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYWxsQ29uZmlncy5wdXNoKGNvbmZpZyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBBbiBlbGVtZW50IGltcGxlbWVudGluZyBgUG9seW1lci5OZW9uQW5pbWF0aW9uUnVubmVyQmVoYXZpb3JgIGNhbGxzIHRoaXMgbWV0aG9kIHRvIGNvbmZpZ3VyZVxuICAgKiBhbiBhbmltYXRpb24gd2l0aCBhbiBvcHRpb25hbCB0eXBlLiBFbGVtZW50cyBpbXBsZW1lbnRpbmcgYFBvbHltZXIuTmVvbkFuaW1hdGFibGVCZWhhdmlvcmBcbiAgICogc2hvdWxkIGRlZmluZSB0aGUgcHJvcGVydHkgYGFuaW1hdGlvbkNvbmZpZ2AsIHdoaWNoIGlzIGVpdGhlciBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqIG9yIGEgbWFwIG9mIGFuaW1hdGlvbiB0eXBlIHRvIGFycmF5IG9mIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAgICovXG4gIGdldEFuaW1hdGlvbkNvbmZpZzogZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciBtYXAgPSB7fTtcbiAgICB2YXIgYWxsQ29uZmlncyA9IFtdO1xuICAgIHRoaXMuX2dldEFuaW1hdGlvbkNvbmZpZ1JlY3Vyc2l2ZSh0eXBlLCBtYXAsIGFsbENvbmZpZ3MpO1xuICAgIC8vIGFwcGVuZCB0aGUgY29uZmlndXJhdGlvbnMgc2F2ZWQgaW4gdGhlIG1hcCB0byB0aGUgYXJyYXlcbiAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSB7XG4gICAgICBhbGxDb25maWdzLnB1c2gobWFwW2tleV0pO1xuICAgIH1cbiAgICByZXR1cm4gYWxsQ29uZmlncztcbiAgfVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvbmVvbi1hbmltYXRpb24vbmVvbi1hbmltYXRhYmxlLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3M1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uT3ZlcmxheUJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1vdmVybGF5LWJlaGF2aW9yL2lyb24tb3ZlcmxheS1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5leHBvcnQgY29uc3QgUGFwZXJEaWFsb2dCZWhhdmlvckltcGwgPSB7XG5cbiAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICAncm9sZSc6ICdkaWFsb2cnLFxuICAgICd0YWJpbmRleCc6ICctMSdcbiAgfSxcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBJZiBgbW9kYWxgIGlzIHRydWUsIHRoaXMgaW1wbGllcyBgbm8tY2FuY2VsLW9uLW91dHNpZGUtY2xpY2tgLCBgbm8tY2FuY2VsLW9uLWVzYy1rZXlgIGFuZCBgd2l0aC1iYWNrZHJvcGAuXG4gICAgICovXG4gICAgbW9kYWw6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgX19yZWFkaWVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfVxuXG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19tb2RhbENoYW5nZWQobW9kYWwsIF9fcmVhZGllZCknXG4gIF0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgJ3RhcCc6ICdfb25EaWFsb2dDbGljaydcbiAgfSxcblxuICByZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgLy8gT25seSBub3cgdGhlc2UgcHJvcGVydGllcyBjYW4gYmUgcmVhZC5cbiAgICB0aGlzLl9fcHJldk5vQ2FuY2VsT25PdXRzaWRlQ2xpY2sgPSB0aGlzLm5vQ2FuY2VsT25PdXRzaWRlQ2xpY2s7XG4gICAgdGhpcy5fX3ByZXZOb0NhbmNlbE9uRXNjS2V5ID0gdGhpcy5ub0NhbmNlbE9uRXNjS2V5O1xuICAgIHRoaXMuX19wcmV2V2l0aEJhY2tkcm9wID0gdGhpcy53aXRoQmFja2Ryb3A7XG4gICAgdGhpcy5fX3JlYWRpZWQgPSB0cnVlO1xuICB9LFxuXG4gIF9tb2RhbENoYW5nZWQ6IGZ1bmN0aW9uKG1vZGFsLCByZWFkaWVkKSB7XG4gICAgLy8gbW9kYWwgaW1wbGllcyBub0NhbmNlbE9uT3V0c2lkZUNsaWNrLCBub0NhbmNlbE9uRXNjS2V5IGFuZCB3aXRoQmFja2Ryb3AuXG4gICAgLy8gV2UgbmVlZCB0byB3YWl0IGZvciB0aGUgZWxlbWVudCB0byBiZSByZWFkeSBiZWZvcmUgd2UgY2FuIHJlYWQgdGhlXG4gICAgLy8gcHJvcGVydGllcyB2YWx1ZXMuXG4gICAgaWYgKCFyZWFkaWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1vZGFsKSB7XG4gICAgICB0aGlzLl9fcHJldk5vQ2FuY2VsT25PdXRzaWRlQ2xpY2sgPSB0aGlzLm5vQ2FuY2VsT25PdXRzaWRlQ2xpY2s7XG4gICAgICB0aGlzLl9fcHJldk5vQ2FuY2VsT25Fc2NLZXkgPSB0aGlzLm5vQ2FuY2VsT25Fc2NLZXk7XG4gICAgICB0aGlzLl9fcHJldldpdGhCYWNrZHJvcCA9IHRoaXMud2l0aEJhY2tkcm9wO1xuICAgICAgdGhpcy5ub0NhbmNlbE9uT3V0c2lkZUNsaWNrID0gdHJ1ZTtcbiAgICAgIHRoaXMubm9DYW5jZWxPbkVzY0tleSA9IHRydWU7XG4gICAgICB0aGlzLndpdGhCYWNrZHJvcCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZSB2YWx1ZSB3YXMgY2hhbmdlZCB0byBmYWxzZSwgbGV0IGl0IGZhbHNlLlxuICAgICAgdGhpcy5ub0NhbmNlbE9uT3V0c2lkZUNsaWNrID0gdGhpcy5ub0NhbmNlbE9uT3V0c2lkZUNsaWNrICYmXG4gICAgICAgIHRoaXMuX19wcmV2Tm9DYW5jZWxPbk91dHNpZGVDbGljaztcbiAgICAgIHRoaXMubm9DYW5jZWxPbkVzY0tleSA9IHRoaXMubm9DYW5jZWxPbkVzY0tleSAmJlxuICAgICAgICB0aGlzLl9fcHJldk5vQ2FuY2VsT25Fc2NLZXk7XG4gICAgICB0aGlzLndpdGhCYWNrZHJvcCA9IHRoaXMud2l0aEJhY2tkcm9wICYmIHRoaXMuX19wcmV2V2l0aEJhY2tkcm9wO1xuICAgIH1cbiAgfSxcblxuICBfdXBkYXRlQ2xvc2luZ1JlYXNvbkNvbmZpcm1lZDogZnVuY3Rpb24oY29uZmlybWVkKSB7XG4gICAgdGhpcy5jbG9zaW5nUmVhc29uID0gdGhpcy5jbG9zaW5nUmVhc29uIHx8IHt9O1xuICAgIHRoaXMuY2xvc2luZ1JlYXNvbi5jb25maXJtZWQgPSBjb25maXJtZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdpbGwgZGlzbWlzcyB0aGUgZGlhbG9nIGlmIHVzZXIgY2xpY2tlZCBvbiBhbiBlbGVtZW50IHdpdGggZGlhbG9nLWRpc21pc3NcbiAgICogb3IgZGlhbG9nLWNvbmZpcm0gYXR0cmlidXRlLlxuICAgKi9cbiAgX29uRGlhbG9nQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgLy8gU2VhcmNoIGZvciB0aGUgZWxlbWVudCB3aXRoIGRpYWxvZy1jb25maXJtIG9yIGRpYWxvZy1kaXNtaXNzLFxuICAgIC8vIGZyb20gdGhlIHJvb3QgdGFyZ2V0IHVudGlsIHRoaXMgKGV4Y2x1ZGVkKS5cbiAgICB2YXIgcGF0aCA9IGRvbShldmVudCkucGF0aDtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBhdGguaW5kZXhPZih0aGlzKTsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIHRhcmdldCA9IHBhdGhbaV07XG4gICAgICBpZiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZSAmJiAodGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlhbG9nLWRpc21pc3MnKSB8fCB0YXJnZXQuaGFzQXR0cmlidXRlKCdkaWFsb2ctY29uZmlybScpKSkge1xuICAgICAgICB0aGlzLl91cGRhdGVDbG9zaW5nUmVhc29uQ29uZmlybWVkKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2RpYWxvZy1jb25maXJtJykpO1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuZXhwb3J0IGNvbnN0IFBhcGVyRGlhbG9nQmVoYXZpb3IgPSBbSXJvbk92ZXJsYXlCZWhhdmlvciwgUGFwZXJEaWFsb2dCZWhhdmlvckltcGxdO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItZGlhbG9nLWJlaGF2aW9yL3BhcGVyLWRpYWxvZy1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gNzRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkZpdEJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1maXQtYmVoYXZpb3IvaXJvbi1maXQtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgSXJvblJlc2l6YWJsZUJlaGF2aW9yIH0gZnJvbSAnLi4vaXJvbi1yZXNpemFibGUtYmVoYXZpb3IvaXJvbi1yZXNpemFibGUtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgSXJvbk92ZXJsYXlNYW5hZ2VyIH0gZnJvbSAnLi9pcm9uLW92ZXJsYXktbWFuYWdlci5qcyc7XG5pbXBvcnQgeyBJcm9uRm9jdXNhYmxlc0hlbHBlciB9IGZyb20gJy4vaXJvbi1mb2N1c2FibGVzLWhlbHBlci5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG5leHBvcnQgY29uc3QgSXJvbk92ZXJsYXlCZWhhdmlvckltcGwgPSB7XG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogVHJ1ZSBpZiB0aGUgb3ZlcmxheSBpcyBjdXJyZW50bHkgZGlzcGxheWVkLlxuICAgICAqL1xuICAgIG9wZW5lZDoge1xuICAgICAgb2JzZXJ2ZXI6ICdfb3BlbmVkQ2hhbmdlZCcsXG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIG92ZXJsYXkgd2FzIGNhbmNlbGVkIHdoZW4gaXQgd2FzIGxhc3QgY2xvc2VkLlxuICAgICAqL1xuICAgIGNhbmNlbGVkOiB7XG4gICAgICBvYnNlcnZlcjogJ19jYW5jZWxlZENoYW5nZWQnLFxuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGRpc3BsYXkgYSBiYWNrZHJvcCBiZWhpbmQgdGhlIG92ZXJsYXkuIEl0IHRyYXBzIHRoZSBmb2N1c1xuICAgICAqIHdpdGhpbiB0aGUgbGlnaHQgRE9NIG9mIHRoZSBvdmVybGF5LlxuICAgICAqL1xuICAgIHdpdGhCYWNrZHJvcDoge1xuICAgICAgb2JzZXJ2ZXI6ICdfd2l0aEJhY2tkcm9wQ2hhbmdlZCcsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGRpc2FibGUgYXV0by1mb2N1c2luZyB0aGUgb3ZlcmxheSBvciBjaGlsZCBub2RlcyB3aXRoXG4gICAgICogdGhlIGBhdXRvZm9jdXNgIGF0dHJpYnV0ZWAgd2hlbiB0aGUgb3ZlcmxheSBpcyBvcGVuZWQuXG4gICAgICovXG4gICAgbm9BdXRvRm9jdXM6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZGlzYWJsZSBjYW5jZWxpbmcgdGhlIG92ZXJsYXkgd2l0aCB0aGUgRVNDIGtleS5cbiAgICAgKi9cbiAgICBub0NhbmNlbE9uRXNjS2V5OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGRpc2FibGUgY2FuY2VsaW5nIHRoZSBvdmVybGF5IGJ5IGNsaWNraW5nIG91dHNpZGUgaXQuXG4gICAgICovXG4gICAgbm9DYW5jZWxPbk91dHNpZGVDbGljazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb250YWlucyB0aGUgcmVhc29uKHMpIHRoaXMgb3ZlcmxheSB3YXMgbGFzdCBjbG9zZWQgKHNlZSBgaXJvbi1vdmVybGF5LWNsb3NlZGApLlxuICAgICAqIGBJcm9uT3ZlcmxheUJlaGF2aW9yYCBwcm92aWRlcyB0aGUgYGNhbmNlbGVkYCByZWFzb247IGltcGxlbWVudGVycyBvZiB0aGVcbiAgICAgKiBiZWhhdmlvciBjYW4gcHJvdmlkZSBvdGhlciByZWFzb25zIGluIGFkZGl0aW9uIHRvIGBjYW5jZWxlZGAuXG4gICAgICovXG4gICAgY2xvc2luZ1JlYXNvbjoge1xuICAgICAgLy8gd2FzIGEgZ2V0dGVyIGJlZm9yZSwgYnV0IG5lZWRzIHRvIGJlIGEgcHJvcGVydHkgc28gb3RoZXJcbiAgICAgIC8vIGJlaGF2aW9ycyBjYW4gb3ZlcnJpZGUgdGhpcy5cbiAgICAgIHR5cGU6IE9iamVjdFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBlbmFibGUgcmVzdG9yaW5nIG9mIGZvY3VzIHdoZW4gb3ZlcmxheSBpcyBjbG9zZWQuXG4gICAgICovXG4gICAgcmVzdG9yZUZvY3VzT25DbG9zZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBrZWVwIG92ZXJsYXkgYWx3YXlzIG9uIHRvcC5cbiAgICAgKi9cbiAgICBhbHdheXNPblRvcDoge1xuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaG9ydGN1dCB0byBhY2Nlc3MgdG8gdGhlIG92ZXJsYXkgbWFuYWdlci5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtQb2x5bWVyLklyb25PdmVybGF5TWFuYWdlckNsYXNzfVxuICAgICAqL1xuICAgIF9tYW5hZ2VyOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB2YWx1ZTogSXJvbk92ZXJsYXlNYW5hZ2VyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBub2RlIGJlaW5nIGZvY3VzZWQuXG4gICAgICogQHR5cGUgez9Ob2RlfVxuICAgICAqL1xuICAgIF9mb2N1c2VkQ2hpbGQ6IHtcbiAgICAgIHR5cGU6IE9iamVjdFxuICAgIH1cblxuICB9LFxuXG4gIGxpc3RlbmVyczoge1xuICAgICdpcm9uLXJlc2l6ZSc6ICdfb25Jcm9uUmVzaXplJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgYmFja2Ryb3AgZWxlbWVudC5cbiAgICogQHR5cGUge0VsZW1lbnR9XG4gICAqL1xuICBnZXQgYmFja2Ryb3BFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9tYW5hZ2VyLmJhY2tkcm9wRWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbm9kZSB0byBnaXZlIGZvY3VzIHRvLlxuICAgKiBAdHlwZSB7Tm9kZX1cbiAgICovXG4gIGdldCBfZm9jdXNOb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c2VkQ2hpbGQgfHwgZG9tKHRoaXMpLnF1ZXJ5U2VsZWN0b3IoJ1thdXRvZm9jdXNdJykgfHwgdGhpcztcbiAgfSxcblxuICAvKipcbiAgICogQXJyYXkgb2Ygbm9kZXMgdGhhdCBjYW4gcmVjZWl2ZSBmb2N1cyAob3ZlcmxheSBpbmNsdWRlZCksIG9yZGVyZWQgYnkgYHRhYmluZGV4YC5cbiAgICogVGhpcyBpcyB1c2VkIHRvIHJldHJpZXZlIHdoaWNoIGlzIHRoZSBmaXJzdCBhbmQgbGFzdCBmb2N1c2FibGUgbm9kZXMgaW4gb3JkZXJcbiAgICogdG8gd3JhcCB0aGUgZm9jdXMgZm9yIG92ZXJsYXlzIGB3aXRoLWJhY2tkcm9wYC5cbiAgICpcbiAgICogSWYgeW91IGtub3cgd2hhdCBpcyB5b3VyIGNvbnRlbnQgKHNwZWNpZmljYWxseSB0aGUgZmlyc3QgYW5kIGxhc3QgZm9jdXNhYmxlIGNoaWxkcmVuKSxcbiAgICogeW91IGNhbiBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gb25seSBgW2ZpcnN0Rm9jdXNhYmxlLCBsYXN0Rm9jdXNhYmxlXTtgXG4gICAqIEB0eXBlIHtBcnJheTxOb2RlPn1cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgZ2V0IF9mb2N1c2FibGVOb2RlcygpIHtcbiAgICByZXR1cm4gSXJvbkZvY3VzYWJsZXNIZWxwZXIuZ2V0VGFiYmFibGVOb2Rlcyh0aGlzKTtcbiAgfSxcblxuICByZWFkeTogZnVuY3Rpb24oKSB7XG4gICAgLy8gVXNlZCB0byBza2lwIGNhbGxzIHRvIG5vdGlmeVJlc2l6ZSBhbmQgcmVmaXQgd2hpbGUgdGhlIG92ZXJsYXkgaXMgYW5pbWF0aW5nLlxuICAgIHRoaXMuX19pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIC8vIHdpdGgtYmFja2Ryb3AgbmVlZHMgdGFiaW5kZXggdG8gYmUgc2V0IGluIG9yZGVyIHRvIHRyYXAgdGhlIGZvY3VzLlxuICAgIC8vIElmIGl0IGlzIG5vdCBzZXQsIElyb25PdmVybGF5QmVoYXZpb3Igd2lsbCBzZXQgaXQsIGFuZCByZW1vdmUgaXQgaWYgd2l0aC1iYWNrZHJvcCA9IGZhbHNlLlxuICAgIHRoaXMuX19zaG91bGRSZW1vdmVUYWJJbmRleCA9IGZhbHNlO1xuICAgIC8vIFVzZWQgZm9yIHdyYXBwaW5nIHRoZSBmb2N1cyBvbiBUQUIgLyBTaGlmdCtUQUIuXG4gICAgdGhpcy5fX2ZpcnN0Rm9jdXNhYmxlTm9kZSA9IHRoaXMuX19sYXN0Rm9jdXNhYmxlTm9kZSA9IG51bGw7XG4gICAgLy8gVXNlZCBieSBfX29uTmV4dEFuaW1hdGlvbkZyYW1lIHRvIGNhbmNlbCBhbnkgcHJldmlvdXMgY2FsbGJhY2suXG4gICAgdGhpcy5fX3JhZiA9IG51bGw7XG4gICAgLy8gRm9jdXNlZCBub2RlIGJlZm9yZSBvdmVybGF5IGdldHMgb3BlbmVkLiBDYW4gYmUgcmVzdG9yZWQgb24gY2xvc2UuXG4gICAgdGhpcy5fX3Jlc3RvcmVGb2N1c05vZGUgPSBudWxsO1xuICAgIHRoaXMuX2Vuc3VyZVNldHVwKCk7XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIENhbGwgX29wZW5lZENoYW5nZWQgaGVyZSBzbyB0aGF0IHBvc2l0aW9uIGNhbiBiZSBjb21wdXRlZCBjb3JyZWN0bHkuXG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICB0aGlzLl9vcGVuZWRDaGFuZ2VkKHRoaXMub3BlbmVkKTtcbiAgICB9XG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBkb20odGhpcykub2JzZXJ2ZU5vZGVzKHRoaXMuX29uTm9kZXNDaGFuZ2UpO1xuICB9LFxuXG4gIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICBkb20odGhpcykudW5vYnNlcnZlTm9kZXModGhpcy5fb2JzZXJ2ZXIpO1xuICAgIHRoaXMuX29ic2VydmVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5fX3JhZikge1xuICAgICAgd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuX19yYWYpO1xuICAgICAgdGhpcy5fX3JhZiA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuX21hbmFnZXIucmVtb3ZlT3ZlcmxheSh0aGlzKTtcbiAgfSxcblxuICAvKipcbiAgICogVG9nZ2xlIHRoZSBvcGVuZWQgc3RhdGUgb2YgdGhlIG92ZXJsYXkuXG4gICAqL1xuICB0b2dnbGU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NldENhbmNlbGVkKGZhbHNlKTtcbiAgICB0aGlzLm9wZW5lZCA9ICF0aGlzLm9wZW5lZDtcbiAgfSxcblxuICAvKipcbiAgICogT3BlbiB0aGUgb3ZlcmxheS5cbiAgICovXG4gIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NldENhbmNlbGVkKGZhbHNlKTtcbiAgICB0aGlzLm9wZW5lZCA9IHRydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENsb3NlIHRoZSBvdmVybGF5LlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NldENhbmNlbGVkKGZhbHNlKTtcbiAgICB0aGlzLm9wZW5lZCA9IGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYW5jZWxzIHRoZSBvdmVybGF5LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgVGhlIG9yaWdpbmFsIGV2ZW50XG4gICAqL1xuICBjYW5jZWw6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGNhbmNlbEV2ZW50ID0gdGhpcy5maXJlKCdpcm9uLW92ZXJsYXktY2FuY2VsZWQnLCBldmVudCwge2NhbmNlbGFibGU6IHRydWV9KTtcbiAgICBpZiAoY2FuY2VsRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3NldENhbmNlbGVkKHRydWUpO1xuICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEludmFsaWRhdGVzIHRoZSBjYWNoZWQgdGFiYmFibGUgbm9kZXMuIFRvIGJlIGNhbGxlZCB3aGVuIGFueSBvZiB0aGUgZm9jdXNhYmxlXG4gICAqIGNvbnRlbnQgY2hhbmdlcyAoZS5nLiBhIGJ1dHRvbiBpcyBkaXNhYmxlZCkuXG4gICAqL1xuICBpbnZhbGlkYXRlVGFiYmFibGVzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9fZmlyc3RGb2N1c2FibGVOb2RlID0gdGhpcy5fX2xhc3RGb2N1c2FibGVOb2RlID0gbnVsbDtcbiAgfSxcblxuICBfZW5zdXJlU2V0dXA6IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9vdmVybGF5U2V0dXApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fb3ZlcmxheVNldHVwID0gdHJ1ZTtcbiAgICB0aGlzLnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiBgb3BlbmVkYCBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBvcGVuZWRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29wZW5lZENoYW5nZWQ6IGZ1bmN0aW9uKG9wZW5lZCkge1xuICAgIGlmIChvcGVuZWQpIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIH1cblxuICAgIC8vIERlZmVyIGFueSBhbmltYXRpb24tcmVsYXRlZCBjb2RlIG9uIGF0dGFjaGVkXG4gICAgLy8gKF9vcGVuZWRDaGFuZ2VkIGdldHMgY2FsbGVkIGFnYWluIG9uIGF0dGFjaGVkKS5cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX19pc0FuaW1hdGluZyA9IHRydWU7XG5cbiAgICAvLyBVc2UgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZvciBub24tYmxvY2tpbmcgcmVuZGVyaW5nLlxuICAgIHRoaXMuX19vbk5leHRBbmltYXRpb25GcmFtZSh0aGlzLl9fb3BlbmVkQ2hhbmdlZCk7XG4gIH0sXG5cbiAgX2NhbmNlbGVkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5jbG9zaW5nUmVhc29uID0gdGhpcy5jbG9zaW5nUmVhc29uIHx8IHt9O1xuICAgIHRoaXMuY2xvc2luZ1JlYXNvbi5jYW5jZWxlZCA9IHRoaXMuY2FuY2VsZWQ7XG4gIH0sXG5cbiAgX3dpdGhCYWNrZHJvcENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIElmIHRhYmluZGV4IGlzIGFscmVhZHkgc2V0LCBubyBuZWVkIHRvIG92ZXJyaWRlIGl0LlxuICAgIGlmICh0aGlzLndpdGhCYWNrZHJvcCAmJiAhdGhpcy5oYXNBdHRyaWJ1dGUoJ3RhYmluZGV4JykpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgdGhpcy5fX3Nob3VsZFJlbW92ZVRhYkluZGV4ID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX19zaG91bGRSZW1vdmVUYWJJbmRleCkge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgICB0aGlzLl9fc2hvdWxkUmVtb3ZlVGFiSW5kZXggPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3BlbmVkICYmIHRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgdGhpcy5fbWFuYWdlci50cmFja0JhY2tkcm9wKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiB0YXNrcyB3aGljaCBtdXN0IG9jY3VyIGJlZm9yZSBvcGVuaW5nOyBlLmcuIG1ha2luZyB0aGUgZWxlbWVudCB2aXNpYmxlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfcHJlcGFyZVJlbmRlck9wZW5lZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gU3RvcmUgZm9jdXNlZCBub2RlLlxuICAgIHRoaXMuX19yZXN0b3JlRm9jdXNOb2RlID0gdGhpcy5fbWFuYWdlci5kZWVwQWN0aXZlRWxlbWVudDtcblxuICAgIC8vIE5lZWRlZCB0byBjYWxjdWxhdGUgdGhlIHNpemUgb2YgdGhlIG92ZXJsYXkgc28gdGhhdCB0cmFuc2l0aW9ucyBvbiBpdHMgc2l6ZVxuICAgIC8vIHdpbGwgaGF2ZSB0aGUgY29ycmVjdCBzdGFydGluZyBwb2ludHMuXG4gICAgdGhpcy5fcHJlcGFyZVBvc2l0aW9uaW5nKCk7XG4gICAgdGhpcy5yZWZpdCgpO1xuICAgIHRoaXMuX2ZpbmlzaFBvc2l0aW9uaW5nKCk7XG5cbiAgICAvLyBTYWZhcmkgd2lsbCBhcHBseSB0aGUgZm9jdXMgdG8gdGhlIGF1dG9mb2N1cyBlbGVtZW50IHdoZW4gZGlzcGxheWVkXG4gICAgLy8gZm9yIHRoZSBmaXJzdCB0aW1lLCBzbyB3ZSBtYWtlIHN1cmUgdG8gcmV0dXJuIHRoZSBmb2N1cyB3aGVyZSBpdCB3YXMuXG4gICAgaWYgKHRoaXMubm9BdXRvRm9jdXMgJiYgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5fZm9jdXNOb2RlKSB7XG4gICAgICB0aGlzLl9mb2N1c05vZGUuYmx1cigpO1xuICAgICAgdGhpcy5fX3Jlc3RvcmVGb2N1c05vZGUuZm9jdXMoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRhc2tzIHdoaWNoIGNhdXNlIHRoZSBvdmVybGF5IHRvIGFjdHVhbGx5IG9wZW47IHR5cGljYWxseSBwbGF5IGFuIGFuaW1hdGlvbi5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlck9wZW5lZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fZmluaXNoUmVuZGVyT3BlbmVkKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRhc2tzIHdoaWNoIGNhdXNlIHRoZSBvdmVybGF5IHRvIGFjdHVhbGx5IGNsb3NlOyB0eXBpY2FsbHkgcGxheSBhbiBhbmltYXRpb24uXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9yZW5kZXJDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2ZpbmlzaFJlbmRlckNsb3NlZCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYXNrcyB0byBiZSBwZXJmb3JtZWQgYXQgdGhlIGVuZCBvZiBvcGVuIGFjdGlvbi4gV2lsbCBmaXJlIGBpcm9uLW92ZXJsYXktb3BlbmVkYC5cbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2ZpbmlzaFJlbmRlck9wZW5lZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5ub3RpZnlSZXNpemUoKTtcbiAgICB0aGlzLl9faXNBbmltYXRpbmcgPSBmYWxzZTtcblxuICAgIHRoaXMuZmlyZSgnaXJvbi1vdmVybGF5LW9wZW5lZCcpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUYXNrcyB0byBiZSBwZXJmb3JtZWQgYXQgdGhlIGVuZCBvZiBjbG9zZSBhY3Rpb24uIFdpbGwgZmlyZSBgaXJvbi1vdmVybGF5LWNsb3NlZGAuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9maW5pc2hSZW5kZXJDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIEhpZGUgdGhlIG92ZXJsYXkuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIC8vIFJlc2V0IHotaW5kZXggb25seSBhdCB0aGUgZW5kIG9mIHRoZSBhbmltYXRpb24uXG4gICAgdGhpcy5zdHlsZS56SW5kZXggPSAnJztcbiAgICB0aGlzLm5vdGlmeVJlc2l6ZSgpO1xuICAgIHRoaXMuX19pc0FuaW1hdGluZyA9IGZhbHNlO1xuICAgIHRoaXMuZmlyZSgnaXJvbi1vdmVybGF5LWNsb3NlZCcsIHRoaXMuY2xvc2luZ1JlYXNvbik7XG4gIH0sXG5cbiAgX3ByZXBhcmVQb3NpdGlvbmluZzogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uID0gdGhpcy5zdHlsZS53ZWJraXRUcmFuc2l0aW9uID0gJ25vbmUnO1xuICAgIHRoaXMuc3R5bGUudHJhbnNmb3JtID0gdGhpcy5zdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSAnbm9uZSc7XG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gIH0sXG5cbiAgX2ZpbmlzaFBvc2l0aW9uaW5nOiBmdW5jdGlvbigpIHtcbiAgICAvLyBGaXJzdCwgbWFrZSBpdCBpbnZpc2libGUgJiByZWFjdGl2YXRlIGFuaW1hdGlvbnMuXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIC8vIEZvcmNlIHJlZmxvdyBiZWZvcmUgcmUtZW5hYmxpbmcgYW5pbWF0aW9ucyBzbyB0aGF0IHRoZXkgZG9uJ3Qgc3RhcnQuXG4gICAgLy8gU2V0IHNjcm9sbFRvcCB0byBpdHNlbGYgc28gdGhhdCBDbG9zdXJlIENvbXBpbGVyIGRvZXNuJ3QgcmVtb3ZlIHRoaXMuXG4gICAgdGhpcy5zY3JvbGxUb3AgPSB0aGlzLnNjcm9sbFRvcDtcbiAgICB0aGlzLnN0eWxlLnRyYW5zaXRpb24gPSB0aGlzLnN0eWxlLndlYmtpdFRyYW5zaXRpb24gPSAnJztcbiAgICB0aGlzLnN0eWxlLnRyYW5zZm9ybSA9IHRoaXMuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJyc7XG4gICAgLy8gTm93IHRoYXQgYW5pbWF0aW9ucyBhcmUgZW5hYmxlZCwgbWFrZSBpdCB2aXNpYmxlIGFnYWluXG4gICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgLy8gRm9yY2UgcmVmbG93LCBzbyB0aGF0IGZvbGxvd2luZyBhbmltYXRpb25zIGFyZSBwcm9wZXJseSBzdGFydGVkLlxuICAgIC8vIFNldCBzY3JvbGxUb3AgdG8gaXRzZWxmIHNvIHRoYXQgQ2xvc3VyZSBDb21waWxlciBkb2Vzbid0IHJlbW92ZSB0aGlzLlxuICAgIHRoaXMuc2Nyb2xsVG9wID0gdGhpcy5zY3JvbGxUb3A7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGxpZXMgZm9jdXMgYWNjb3JkaW5nIHRvIHRoZSBvcGVuZWQgc3RhdGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9hcHBseUZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcGVuZWQpIHtcbiAgICAgIGlmICghdGhpcy5ub0F1dG9Gb2N1cykge1xuICAgICAgICB0aGlzLl9mb2N1c05vZGUuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLl9mb2N1c05vZGUuYmx1cigpO1xuICAgICAgdGhpcy5fZm9jdXNlZENoaWxkID0gbnVsbDtcbiAgICAgIC8vIFJlc3RvcmUgZm9jdXMuXG4gICAgICBpZiAodGhpcy5yZXN0b3JlRm9jdXNPbkNsb3NlICYmIHRoaXMuX19yZXN0b3JlRm9jdXNOb2RlKSB7XG4gICAgICAgIHRoaXMuX19yZXN0b3JlRm9jdXNOb2RlLmZvY3VzKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9fcmVzdG9yZUZvY3VzTm9kZSA9IG51bGw7XG4gICAgICAvLyBJZiBtYW55IG92ZXJsYXlzIGdldCBjbG9zZWQgYXQgdGhlIHNhbWUgdGltZSwgb25lIG9mIHRoZW0gd291bGQgc3RpbGxcbiAgICAgIC8vIGJlIHRoZSBjdXJyZW50T3ZlcmxheSBldmVuIGlmIGFscmVhZHkgY2xvc2VkLCBhbmQgd291bGQgY2FsbCBfYXBwbHlGb2N1c1xuICAgICAgLy8gaW5maW5pdGVseSwgc28gd2UgY2hlY2sgZm9yIHRoaXMgbm90IHRvIGJlIHRoZSBjdXJyZW50IG92ZXJsYXkuXG4gICAgICB2YXIgY3VycmVudE92ZXJsYXkgPSB0aGlzLl9tYW5hZ2VyLmN1cnJlbnRPdmVybGF5KCk7XG4gICAgICBpZiAoY3VycmVudE92ZXJsYXkgJiYgdGhpcyAhPT0gY3VycmVudE92ZXJsYXkpIHtcbiAgICAgICAgY3VycmVudE92ZXJsYXkuX2FwcGx5Rm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbmNlbHMgKGNsb3NlcykgdGhlIG92ZXJsYXkuIENhbGwgd2hlbiBjbGljayBoYXBwZW5zIG91dHNpZGUgdGhlIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb25DYXB0dXJlQ2xpY2s6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLm5vQ2FuY2VsT25PdXRzaWRlQ2xpY2spIHtcbiAgICAgIHRoaXMuY2FuY2VsKGV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEtlZXBzIHRyYWNrIG9mIHRoZSBmb2N1c2VkIGNoaWxkLiBJZiB3aXRoQmFja2Ryb3AsIHRyYXBzIGZvY3VzIHdpdGhpbiBvdmVybGF5LlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29uQ2FwdHVyZUZvY3VzOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMud2l0aEJhY2tkcm9wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBwYXRoID0gZG9tKGV2ZW50KS5wYXRoO1xuICAgIGlmIChwYXRoLmluZGV4T2YodGhpcykgPT09IC0xKSB7XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIHRoaXMuX2FwcGx5Rm9jdXMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fZm9jdXNlZENoaWxkID0gcGF0aFswXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgdGhlIEVTQyBrZXkgZXZlbnQgYW5kIGNhbmNlbHMgKGNsb3NlcykgdGhlIG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb25DYXB0dXJlRXNjOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5ub0NhbmNlbE9uRXNjS2V5KSB7XG4gICAgICB0aGlzLmNhbmNlbChldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIFRBQiBrZXkgZXZlbnRzIHRvIHRyYWNrIGZvY3VzIGNoYW5nZXMuXG4gICAqIFdpbGwgd3JhcCBmb2N1cyBmb3Igb3ZlcmxheXMgd2l0aEJhY2tkcm9wLlxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZlbnRcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX29uQ2FwdHVyZVRhYjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMud2l0aEJhY2tkcm9wKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX19lbnN1cmVGaXJzdExhc3RGb2N1c2FibGVzKCk7XG4gICAgLy8gVEFCIHdyYXBzIGZyb20gbGFzdCB0byBmaXJzdCBmb2N1c2FibGUuXG4gICAgLy8gU2hpZnQgKyBUQUIgd3JhcHMgZnJvbSBmaXJzdCB0byBsYXN0IGZvY3VzYWJsZS5cbiAgICB2YXIgc2hpZnQgPSBldmVudC5zaGlmdEtleTtcbiAgICB2YXIgbm9kZVRvQ2hlY2sgPSBzaGlmdCA/IHRoaXMuX19maXJzdEZvY3VzYWJsZU5vZGUgOiB0aGlzLl9fbGFzdEZvY3VzYWJsZU5vZGU7XG4gICAgdmFyIG5vZGVUb1NldCA9IHNoaWZ0ID8gdGhpcy5fX2xhc3RGb2N1c2FibGVOb2RlIDogdGhpcy5fX2ZpcnN0Rm9jdXNhYmxlTm9kZTtcbiAgICB2YXIgc2hvdWxkV3JhcCA9IGZhbHNlO1xuICAgIGlmIChub2RlVG9DaGVjayA9PT0gbm9kZVRvU2V0KSB7XG4gICAgICAvLyBJZiBub2RlVG9DaGVjayBpcyB0aGUgc2FtZSBhcyBub2RlVG9TZXQsIGl0IG1lYW5zIHdlIGhhdmUgYW4gb3ZlcmxheVxuICAgICAgLy8gd2l0aCAwIG9yIDEgZm9jdXNhYmxlczsgaW4gZWl0aGVyIGNhc2Ugd2Ugc3RpbGwgbmVlZCB0byB0cmFwIHRoZVxuICAgICAgLy8gZm9jdXMgd2l0aGluIHRoZSBvdmVybGF5LlxuICAgICAgc2hvdWxkV3JhcCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIGRvbT1zaGFkb3csIHRoZSBtYW5hZ2VyIHdpbGwgcmVjZWl2ZSBmb2N1cyBjaGFuZ2VzIG9uIHRoZSBtYWluXG4gICAgICAvLyByb290IGJ1dCBub3QgdGhlIG9uZXMgd2l0aGluIG90aGVyIHNoYWRvdyByb290cywgc28gd2UgY2FuJ3QgcmVseSBvblxuICAgICAgLy8gX2ZvY3VzZWRDaGlsZCwgYnV0IHdlIHNob3VsZCBjaGVjayB0aGUgZGVlcGVzdCBhY3RpdmUgZWxlbWVudC5cbiAgICAgIHZhciBmb2N1c2VkTm9kZSA9IHRoaXMuX21hbmFnZXIuZGVlcEFjdGl2ZUVsZW1lbnQ7XG4gICAgICAvLyBJZiB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgbm90IHRoZSBub2RlVG9DaGVjayBidXQgdGhlIG92ZXJsYXkgaXRzZWxmLFxuICAgICAgLy8gaXQgbWVhbnMgdGhlIGZvY3VzIGlzIGFib3V0IHRvIGdvIG91dHNpZGUgdGhlIG92ZXJsYXksIGhlbmNlIHdlXG4gICAgICAvLyBzaG91bGQgcHJldmVudCB0aGF0IChlLmcuIHVzZXIgb3BlbnMgdGhlIG92ZXJsYXkgYW5kIGhpdCBTaGlmdCtUQUIpLlxuICAgICAgc2hvdWxkV3JhcCA9IChmb2N1c2VkTm9kZSA9PT0gbm9kZVRvQ2hlY2sgfHwgZm9jdXNlZE5vZGUgPT09IHRoaXMpO1xuICAgIH1cblxuICAgIGlmIChzaG91bGRXcmFwKSB7XG4gICAgICAvLyBXaGVuIHRoZSBvdmVybGF5IGNvbnRhaW5zIHRoZSBsYXN0IGZvY3VzYWJsZSBlbGVtZW50IG9mIHRoZSBkb2N1bWVudFxuICAgICAgLy8gYW5kIGl0J3MgYWxyZWFkeSBmb2N1c2VkLCBwcmVzc2luZyBUQUIgd291bGQgbW92ZSB0aGUgZm9jdXMgb3V0c2lkZVxuICAgICAgLy8gdGhlIGRvY3VtZW50IChlLmcuIHRvIHRoZSBicm93c2VyIHNlYXJjaCBiYXIpLiBTaW1pbGFybHksIHdoZW4gdGhlXG4gICAgICAvLyBvdmVybGF5IGNvbnRhaW5zIHRoZSBmaXJzdCBmb2N1c2FibGUgZWxlbWVudCBvZiB0aGUgZG9jdW1lbnQgYW5kIGl0J3NcbiAgICAgIC8vIGFscmVhZHkgZm9jdXNlZCwgcHJlc3NpbmcgU2hpZnQrVEFCIHdvdWxkIG1vdmUgdGhlIGZvY3VzIG91dHNpZGUgdGhlXG4gICAgICAvLyBkb2N1bWVudCAoZS5nLiB0byB0aGUgYnJvd3NlciBzZWFyY2ggYmFyKS5cbiAgICAgIC8vIEluIGJvdGggY2FzZXMsIHdlIHdvdWxkIG5vdCByZWNlaXZlIGEgZm9jdXMgZXZlbnQsIGJ1dCBvbmx5IGEgYmx1ci5cbiAgICAgIC8vIEluIG9yZGVyIHRvIGFjaGlldmUgZm9jdXMgd3JhcHBpbmcsIHdlIHByZXZlbnQgdGhpcyBUQUIgZXZlbnQgYW5kXG4gICAgICAvLyBmb3JjZSB0aGUgZm9jdXMuIFRoaXMgd2lsbCBhbHNvIHByZXZlbnQgdGhlIGZvY3VzIHRvIHRlbXBvcmFyaWx5IG1vdmVcbiAgICAgIC8vIG91dHNpZGUgdGhlIG92ZXJsYXksIHdoaWNoIG1pZ2h0IGNhdXNlIHNjcm9sbGluZy5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl9mb2N1c2VkQ2hpbGQgPSBub2RlVG9TZXQ7XG4gICAgICB0aGlzLl9hcHBseUZvY3VzKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWZpdHMgaWYgdGhlIG92ZXJsYXkgaXMgb3BlbmVkIGFuZCBub3QgYW5pbWF0aW5nLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfb25Jcm9uUmVzaXplOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcGVuZWQgJiYgIXRoaXMuX19pc0FuaW1hdGluZykge1xuICAgICAgdGhpcy5fX29uTmV4dEFuaW1hdGlvbkZyYW1lKHRoaXMucmVmaXQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogV2lsbCBjYWxsIG5vdGlmeVJlc2l6ZSBpZiBvdmVybGF5IGlzIG9wZW5lZC5cbiAgICogQ2FuIGJlIG92ZXJyaWRkZW4gaW4gb3JkZXIgdG8gYXZvaWQgbXVsdGlwbGUgb2JzZXJ2ZXJzIG9uIHRoZSBzYW1lIG5vZGUuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9vbk5vZGVzQ2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5vcGVuZWQgJiYgIXRoaXMuX19pc0FuaW1hdGluZykge1xuICAgICAgLy8gSXQgbWlnaHQgaGF2ZSBhZGRlZCBmb2N1c2FibGUgbm9kZXMsIHNvIGludmFsaWRhdGUgY2FjaGVkIHZhbHVlcy5cbiAgICAgIHRoaXMuaW52YWxpZGF0ZVRhYmJhYmxlcygpO1xuICAgICAgdGhpcy5ub3RpZnlSZXNpemUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFdpbGwgc2V0IGZpcnN0IGFuZCBsYXN0IGZvY3VzYWJsZSBub2RlcyBpZiBhbnkgb2YgdGhlbSBpcyBub3Qgc2V0LlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX19lbnN1cmVGaXJzdExhc3RGb2N1c2FibGVzOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuX19maXJzdEZvY3VzYWJsZU5vZGUgfHwgIXRoaXMuX19sYXN0Rm9jdXNhYmxlTm9kZSkge1xuICAgICAgdmFyIGZvY3VzYWJsZU5vZGVzID0gdGhpcy5fZm9jdXNhYmxlTm9kZXM7XG4gICAgICB0aGlzLl9fZmlyc3RGb2N1c2FibGVOb2RlID0gZm9jdXNhYmxlTm9kZXNbMF07XG4gICAgICB0aGlzLl9fbGFzdEZvY3VzYWJsZU5vZGUgPSBmb2N1c2FibGVOb2Rlc1tmb2N1c2FibGVOb2Rlcy5sZW5ndGggLSAxXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRhc2tzIGV4ZWN1dGVkIHdoZW4gb3BlbmVkIGNoYW5nZXM6IHByZXBhcmUgZm9yIHRoZSBvcGVuaW5nLCBtb3ZlIHRoZVxuICAgKiBmb2N1cywgdXBkYXRlIHRoZSBtYW5hZ2VyLCByZW5kZXIgb3BlbmVkL2Nsb3NlZC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9fb3BlbmVkQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkKSB7XG4gICAgICAvLyBNYWtlIG92ZXJsYXkgdmlzaWJsZSwgdGhlbiBhZGQgaXQgdG8gdGhlIG1hbmFnZXIuXG4gICAgICB0aGlzLl9wcmVwYXJlUmVuZGVyT3BlbmVkKCk7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFkZE92ZXJsYXkodGhpcyk7XG4gICAgICAvLyBNb3ZlIHRoZSBmb2N1cyB0byB0aGUgY2hpbGQgbm9kZSB3aXRoIFthdXRvZm9jdXNdLlxuICAgICAgdGhpcy5fYXBwbHlGb2N1cygpO1xuXG4gICAgICB0aGlzLl9yZW5kZXJPcGVuZWQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlIG92ZXJsYXksIHRoZW4gcmVzdG9yZSB0aGUgZm9jdXMgYmVmb3JlIGFjdHVhbGx5IGNsb3NpbmcuXG4gICAgICB0aGlzLl9tYW5hZ2VyLnJlbW92ZU92ZXJsYXkodGhpcyk7XG4gICAgICB0aGlzLl9hcHBseUZvY3VzKCk7XG5cbiAgICAgIHRoaXMuX3JlbmRlckNsb3NlZCgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBjYWxsYmFjayBvbiB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUsIG92ZXJyaWRpbmcgYW55IHByZXZpb3VzXG4gICAqIGNhbGxiYWNrIGF3YWl0aW5nIGZvciB0aGUgbmV4dCBhbmltYXRpb24gZnJhbWUuIGUuZy5cbiAgICogYF9fb25OZXh0QW5pbWF0aW9uRnJhbWUoY2FsbGJhY2sxKSAmJiBfX29uTmV4dEFuaW1hdGlvbkZyYW1lKGNhbGxiYWNrMilgO1xuICAgKiBgY2FsbGJhY2sxYCB3aWxsIG5ldmVyIGJlIGludm9rZWQuXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjYWxsYmFjayBJdHMgYHRoaXNgIHBhcmFtZXRlciBpcyB0aGUgb3ZlcmxheSBpdHNlbGYuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfX29uTmV4dEFuaW1hdGlvbkZyYW1lOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLl9fcmFmKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fX3JhZik7XG4gICAgfVxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9fcmFmID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiBuZXh0QW5pbWF0aW9uRnJhbWUoKSB7XG4gICAgICBzZWxmLl9fcmFmID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrLmNhbGwoc2VsZik7XG4gICAgfSk7XG4gIH1cblxufTtcblxuZXhwb3J0IGNvbnN0IElyb25PdmVybGF5QmVoYXZpb3IgPSBbSXJvbkZpdEJlaGF2aW9yLCBJcm9uUmVzaXphYmxlQmVoYXZpb3IsIElyb25PdmVybGF5QmVoYXZpb3JJbXBsXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tb3ZlcmxheS1iZWhhdmlvci9pcm9uLW92ZXJsYXktYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDc1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uRml0QmVoYXZpb3IgPSB7XG5cbiAgcHJvcGVydGllczoge1xuXG4gICAgLyoqXG4gICAgICogVGhlIGVsZW1lbnQgdGhhdCB3aWxsIHJlY2VpdmUgYSBgbWF4LWhlaWdodGAvYHdpZHRoYC4gQnkgZGVmYXVsdCBpdCBpcyB0aGUgc2FtZSBhcyBgdGhpc2AsXG4gICAgICogYnV0IGl0IGNhbiBiZSBzZXQgdG8gYSBjaGlsZCBlbGVtZW50LiBUaGlzIGlzIHVzZWZ1bCwgZm9yIGV4YW1wbGUsIGZvciBpbXBsZW1lbnRpbmcgYVxuICAgICAqIHNjcm9sbGluZyByZWdpb24gaW5zaWRlIHRoZSBlbGVtZW50LlxuICAgICAqIEB0eXBlIHshRWxlbWVudH1cbiAgICAgKi9cbiAgICBzaXppbmdUYXJnZXQ6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlbGVtZW50IHRvIGZpdCBgdGhpc2AgaW50by5cbiAgICAgKi9cbiAgICBmaXRJbnRvOiB7XG4gICAgICB0eXBlOiBPYmplY3QsXG4gICAgICB2YWx1ZTogd2luZG93XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdpbGwgcG9zaXRpb24gdGhlIGVsZW1lbnQgYXJvdW5kIHRoZSBwb3NpdGlvblRhcmdldCB3aXRob3V0IG92ZXJsYXBwaW5nIGl0LlxuICAgICAqL1xuICAgIG5vT3ZlcmxhcDoge1xuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZWxlbWVudCB0aGF0IHNob3VsZCBiZSB1c2VkIHRvIHBvc2l0aW9uIHRoZSBlbGVtZW50LiBJZiBub3Qgc2V0LCBpdCB3aWxsXG4gICAgICogZGVmYXVsdCB0byB0aGUgcGFyZW50IG5vZGUuXG4gICAgICogQHR5cGUgeyFFbGVtZW50fVxuICAgICAqL1xuICAgIHBvc2l0aW9uVGFyZ2V0OiB7XG4gICAgICB0eXBlOiBFbGVtZW50XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmllbnRhdGlvbiBhZ2FpbnN0IHdoaWNoIHRvIGFsaWduIHRoZSBlbGVtZW50IGhvcml6b250YWxseVxuICAgICAqIHJlbGF0aXZlIHRvIHRoZSBgcG9zaXRpb25UYXJnZXRgLiBQb3NzaWJsZSB2YWx1ZXMgYXJlIFwibGVmdFwiLCBcInJpZ2h0XCIsIFwiYXV0b1wiLlxuICAgICAqL1xuICAgIGhvcml6b250YWxBbGlnbjoge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBvcmllbnRhdGlvbiBhZ2FpbnN0IHdoaWNoIHRvIGFsaWduIHRoZSBlbGVtZW50IHZlcnRpY2FsbHlcbiAgICAgKiByZWxhdGl2ZSB0byB0aGUgYHBvc2l0aW9uVGFyZ2V0YC4gUG9zc2libGUgdmFsdWVzIGFyZSBcInRvcFwiLCBcImJvdHRvbVwiLCBcImF1dG9cIi5cbiAgICAgKi9cbiAgICB2ZXJ0aWNhbEFsaWduOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgaXQgd2lsbCB1c2UgYGhvcml6b250YWxBbGlnbmAgYW5kIGB2ZXJ0aWNhbEFsaWduYCB2YWx1ZXMgYXMgcHJlZmVycmVkIGFsaWdubWVudFxuICAgICAqIGFuZCBpZiB0aGVyZSdzIG5vdCBlbm91Z2ggc3BhY2UsIGl0IHdpbGwgcGljayB0aGUgdmFsdWVzIHdoaWNoIG1pbmltaXplIHRoZSBjcm9wcGluZy5cbiAgICAgKi9cbiAgICBkeW5hbWljQWxpZ246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBwaXhlbCB2YWx1ZSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHBvc2l0aW9uIGNhbGN1bGF0ZWQgZm9yIHRoZVxuICAgICAqIGdpdmVuIGBob3Jpem9udGFsQWxpZ25gLCBpbiB0aGUgZGlyZWN0aW9uIG9mIGFsaWdubWVudC4gWW91IGNhbiB0aGlua1xuICAgICAqIG9mIGl0IGFzIGluY3JlYXNpbmcgb3IgZGVjcmVhc2luZyB0aGUgZGlzdGFuY2UgdG8gdGhlIHNpZGUgb2YgdGhlXG4gICAgICogc2NyZWVuIGdpdmVuIGJ5IGBob3Jpem9udGFsQWxpZ25gLlxuICAgICAqXG4gICAgICogSWYgYGhvcml6b250YWxBbGlnbmAgaXMgXCJsZWZ0XCIsIHRoaXMgb2Zmc2V0IHdpbGwgaW5jcmVhc2Ugb3IgZGVjcmVhc2VcbiAgICAgKiB0aGUgZGlzdGFuY2UgdG8gdGhlIGxlZnQgc2lkZSBvZiB0aGUgc2NyZWVuOiBhIG5lZ2F0aXZlIG9mZnNldCB3aWxsXG4gICAgICogbW92ZSB0aGUgZHJvcGRvd24gdG8gdGhlIGxlZnQ7IGEgcG9zaXRpdmUgb25lLCB0byB0aGUgcmlnaHQuXG4gICAgICpcbiAgICAgKiBDb252ZXJzZWx5IGlmIGBob3Jpem9udGFsQWxpZ25gIGlzIFwicmlnaHRcIiwgdGhpcyBvZmZzZXQgd2lsbCBpbmNyZWFzZVxuICAgICAqIG9yIGRlY3JlYXNlIHRoZSBkaXN0YW5jZSB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc2NyZWVuOiBhIG5lZ2F0aXZlXG4gICAgICogb2Zmc2V0IHdpbGwgbW92ZSB0aGUgZHJvcGRvd24gdG8gdGhlIHJpZ2h0OyBhIHBvc2l0aXZlIG9uZSwgdG8gdGhlIGxlZnQuXG4gICAgICovXG4gICAgaG9yaXpvbnRhbE9mZnNldDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBub3RpZnk6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBwaXhlbCB2YWx1ZSB0aGF0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIHBvc2l0aW9uIGNhbGN1bGF0ZWQgZm9yIHRoZVxuICAgICAqIGdpdmVuIGB2ZXJ0aWNhbEFsaWduYCwgaW4gdGhlIGRpcmVjdGlvbiBvZiBhbGlnbm1lbnQuIFlvdSBjYW4gdGhpbmtcbiAgICAgKiBvZiBpdCBhcyBpbmNyZWFzaW5nIG9yIGRlY3JlYXNpbmcgdGhlIGRpc3RhbmNlIHRvIHRoZSBzaWRlIG9mIHRoZVxuICAgICAqIHNjcmVlbiBnaXZlbiBieSBgdmVydGljYWxBbGlnbmAuXG4gICAgICpcbiAgICAgKiBJZiBgdmVydGljYWxBbGlnbmAgaXMgXCJ0b3BcIiwgdGhpcyBvZmZzZXQgd2lsbCBpbmNyZWFzZSBvciBkZWNyZWFzZVxuICAgICAqIHRoZSBkaXN0YW5jZSB0byB0aGUgdG9wIHNpZGUgb2YgdGhlIHNjcmVlbjogYSBuZWdhdGl2ZSBvZmZzZXQgd2lsbFxuICAgICAqIG1vdmUgdGhlIGRyb3Bkb3duIHVwd2FyZHM7IGEgcG9zaXRpdmUgb25lLCBkb3dud2FyZHMuXG4gICAgICpcbiAgICAgKiBDb252ZXJzZWx5IGlmIGB2ZXJ0aWNhbEFsaWduYCBpcyBcImJvdHRvbVwiLCB0aGlzIG9mZnNldCB3aWxsIGluY3JlYXNlXG4gICAgICogb3IgZGVjcmVhc2UgdGhlIGRpc3RhbmNlIHRvIHRoZSBib3R0b20gc2lkZSBvZiB0aGUgc2NyZWVuOiBhIG5lZ2F0aXZlXG4gICAgICogb2Zmc2V0IHdpbGwgbW92ZSB0aGUgZHJvcGRvd24gZG93bndhcmRzOyBhIHBvc2l0aXZlIG9uZSwgdXB3YXJkcy5cbiAgICAgKi9cbiAgICB2ZXJ0aWNhbE9mZnNldDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgdmFsdWU6IDAsXG4gICAgICBub3RpZnk6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gYXV0by1maXQgb24gYXR0YWNoLlxuICAgICAqL1xuICAgIGF1dG9GaXRPbkF0dGFjaDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKiogQHR5cGUgez9PYmplY3R9ICovXG4gICAgX2ZpdEluZm86IHtcbiAgICAgIHR5cGU6IE9iamVjdFxuICAgIH1cbiAgfSxcblxuICBnZXQgX2ZpdFdpZHRoKCkge1xuICAgIHZhciBmaXRXaWR0aDtcbiAgICBpZiAodGhpcy5maXRJbnRvID09PSB3aW5kb3cpIHtcbiAgICAgIGZpdFdpZHRoID0gdGhpcy5maXRJbnRvLmlubmVyV2lkdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpdFdpZHRoID0gdGhpcy5maXRJbnRvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gZml0V2lkdGg7XG4gIH0sXG5cbiAgZ2V0IF9maXRIZWlnaHQoKSB7XG4gICAgdmFyIGZpdEhlaWdodDtcbiAgICBpZiAodGhpcy5maXRJbnRvID09PSB3aW5kb3cpIHtcbiAgICAgIGZpdEhlaWdodCA9IHRoaXMuZml0SW50by5pbm5lckhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZml0SGVpZ2h0ID0gdGhpcy5maXRJbnRvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICB9XG4gICAgcmV0dXJuIGZpdEhlaWdodDtcbiAgfSxcblxuICBnZXQgX2ZpdExlZnQoKSB7XG4gICAgdmFyIGZpdExlZnQ7XG4gICAgaWYgKHRoaXMuZml0SW50byA9PT0gd2luZG93KSB7XG4gICAgICBmaXRMZWZ0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZml0TGVmdCA9IHRoaXMuZml0SW50by5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gZml0TGVmdDtcbiAgfSxcblxuICBnZXQgX2ZpdFRvcCgpIHtcbiAgICB2YXIgZml0VG9wO1xuICAgIGlmICh0aGlzLmZpdEludG8gPT09IHdpbmRvdykge1xuICAgICAgZml0VG9wID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZml0VG9wID0gdGhpcy5maXRJbnRvLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcDtcbiAgICB9XG4gICAgcmV0dXJuIGZpdFRvcDtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgdXNlZCB0byBwb3NpdGlvbiB0aGUgZWxlbWVudCxcbiAgICogaWYgbm8gcG9zaXRpb24gdGFyZ2V0IGlzIGNvbmZpZ3VyZWQuXG4gICAqL1xuICBnZXQgX2RlZmF1bHRQb3NpdGlvblRhcmdldCgpIHtcbiAgICB2YXIgcGFyZW50ID0gZG9tKHRoaXMpLnBhcmVudE5vZGU7XG5cbiAgICBpZiAocGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnQuaG9zdDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGUgaG9yaXpvbnRhbCBhbGlnbiB2YWx1ZSwgYWNjb3VudGluZyBmb3IgdGhlIFJUTC9MVFIgdGV4dCBkaXJlY3Rpb24uXG4gICAqL1xuICBnZXQgX2xvY2FsZUhvcml6b250YWxBbGlnbigpIHtcbiAgICBpZiAodGhpcy5faXNSVEwpIHtcbiAgICAgIC8vIEluIFJUTCwgXCJsZWZ0XCIgYmVjb21lcyBcInJpZ2h0XCIuXG4gICAgICBpZiAodGhpcy5ob3Jpem9udGFsQWxpZ24gPT09ICdyaWdodCcpIHtcbiAgICAgICAgcmV0dXJuICdsZWZ0JztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhvcml6b250YWxBbGlnbiA9PT0gJ2xlZnQnKSB7XG4gICAgICAgIHJldHVybiAncmlnaHQnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5ob3Jpem9udGFsQWxpZ247XG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE1lbW9pemUgdGhpcyB0byBhdm9pZCBleHBlbnNpdmUgY2FsY3VsYXRpb25zICYgcmVsYXlvdXRzLlxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBkbyBpdCBvbmx5IG9uY2VcbiAgICBpZiAodHlwZW9mIHRoaXMuX2lzUlRMID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy5faXNSVEwgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5kaXJlY3Rpb24gPT0gJ3J0bCc7XG4gICAgfVxuICAgIHRoaXMucG9zaXRpb25UYXJnZXQgPSB0aGlzLnBvc2l0aW9uVGFyZ2V0IHx8IHRoaXMuX2RlZmF1bHRQb3NpdGlvblRhcmdldDtcbiAgICBpZiAodGhpcy5hdXRvRml0T25BdHRhY2gpIHtcbiAgICAgIGlmICh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICB0aGlzLmZpdCgpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTk9URTogc2hhZHlkb20gYXBwbGllcyBkaXN0cmlidXRpb24gYXN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgd2ViY29tcG9uZW50cy9zaGFkeWRvbSMxMjBcbiAgICAgICAgLy8gRmx1c2ggdG8gZ2V0IGNvcnJlY3QgbGF5b3V0IGluZm8uXG4gICAgICAgIHdpbmRvdy5TaGFkeURPTSAmJiBTaGFkeURPTS5mbHVzaCgpO1xuICAgICAgICB0aGlzLmZpdCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX19kZWZlcnJlZEZpdCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX19kZWZlcnJlZEZpdCk7XG4gICAgICB0aGlzLl9fZGVmZXJyZWRGaXQgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUG9zaXRpb25zIGFuZCBmaXRzIHRoZSBlbGVtZW50IGludG8gdGhlIGBmaXRJbnRvYCBlbGVtZW50LlxuICAgKi9cbiAgZml0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnBvc2l0aW9uKCk7XG4gICAgdGhpcy5jb25zdHJhaW4oKTtcbiAgICB0aGlzLmNlbnRlcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZW1vaXplIGluZm9ybWF0aW9uIG5lZWRlZCB0byBwb3NpdGlvbiBhbmQgc2l6ZSB0aGUgdGFyZ2V0IGVsZW1lbnQuXG4gICAqIEBzdXBwcmVzcyB7ZGVwcmVjYXRlZH1cbiAgICovXG4gIF9kaXNjb3ZlckluZm86IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9maXRJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0YXJnZXQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICB2YXIgc2l6ZXIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLnNpemluZ1RhcmdldCk7XG5cbiAgICB0aGlzLl9maXRJbmZvID0ge1xuICAgICAgaW5saW5lU3R5bGU6IHtcbiAgICAgICAgdG9wOiB0aGlzLnN0eWxlLnRvcCB8fCAnJyxcbiAgICAgICAgbGVmdDogdGhpcy5zdHlsZS5sZWZ0IHx8ICcnLFxuICAgICAgICBwb3NpdGlvbjogdGhpcy5zdHlsZS5wb3NpdGlvbiB8fCAnJ1xuICAgICAgfSxcbiAgICAgIHNpemVySW5saW5lU3R5bGU6IHtcbiAgICAgICAgbWF4V2lkdGg6IHRoaXMuc2l6aW5nVGFyZ2V0LnN0eWxlLm1heFdpZHRoIHx8ICcnLFxuICAgICAgICBtYXhIZWlnaHQ6IHRoaXMuc2l6aW5nVGFyZ2V0LnN0eWxlLm1heEhlaWdodCB8fCAnJyxcbiAgICAgICAgYm94U2l6aW5nOiB0aGlzLnNpemluZ1RhcmdldC5zdHlsZS5ib3hTaXppbmcgfHwgJydcbiAgICAgIH0sXG4gICAgICBwb3NpdGlvbmVkQnk6IHtcbiAgICAgICAgdmVydGljYWxseTogdGFyZ2V0LnRvcCAhPT0gJ2F1dG8nID8gJ3RvcCcgOiAodGFyZ2V0LmJvdHRvbSAhPT0gJ2F1dG8nID9cbiAgICAgICAgICAnYm90dG9tJyA6IG51bGwpLFxuICAgICAgICBob3Jpem9udGFsbHk6IHRhcmdldC5sZWZ0ICE9PSAnYXV0bycgPyAnbGVmdCcgOiAodGFyZ2V0LnJpZ2h0ICE9PSAnYXV0bycgP1xuICAgICAgICAgICdyaWdodCcgOiBudWxsKVxuICAgICAgfSxcbiAgICAgIHNpemVkQnk6IHtcbiAgICAgICAgaGVpZ2h0OiBzaXplci5tYXhIZWlnaHQgIT09ICdub25lJyxcbiAgICAgICAgd2lkdGg6IHNpemVyLm1heFdpZHRoICE9PSAnbm9uZScsXG4gICAgICAgIG1pbldpZHRoOiBwYXJzZUludChzaXplci5taW5XaWR0aCwgMTApIHx8IDAsXG4gICAgICAgIG1pbkhlaWdodDogcGFyc2VJbnQoc2l6ZXIubWluSGVpZ2h0LCAxMCkgfHwgMFxuICAgICAgfSxcbiAgICAgIG1hcmdpbjoge1xuICAgICAgICB0b3A6IHBhcnNlSW50KHRhcmdldC5tYXJnaW5Ub3AsIDEwKSB8fCAwLFxuICAgICAgICByaWdodDogcGFyc2VJbnQodGFyZ2V0Lm1hcmdpblJpZ2h0LCAxMCkgfHwgMCxcbiAgICAgICAgYm90dG9tOiBwYXJzZUludCh0YXJnZXQubWFyZ2luQm90dG9tLCAxMCkgfHwgMCxcbiAgICAgICAgbGVmdDogcGFyc2VJbnQodGFyZ2V0Lm1hcmdpbkxlZnQsIDEwKSB8fCAwXG4gICAgICB9XG4gICAgfTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzZXRzIHRoZSB0YXJnZXQgZWxlbWVudCdzIHBvc2l0aW9uIGFuZCBzaXplIGNvbnN0cmFpbnRzLCBhbmQgY2xlYXJcbiAgICogdGhlIG1lbW9pemVkIGRhdGEuXG4gICAqL1xuICByZXNldEZpdDogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLl9maXRJbmZvIHx8IHt9O1xuICAgIGZvciAodmFyIHByb3BlcnR5IGluIGluZm8uc2l6ZXJJbmxpbmVTdHlsZSkge1xuICAgICAgdGhpcy5zaXppbmdUYXJnZXQuc3R5bGVbcHJvcGVydHldID0gaW5mby5zaXplcklubGluZVN0eWxlW3Byb3BlcnR5XTtcbiAgICB9XG4gICAgZm9yICh2YXIgcHJvcGVydHkgaW4gaW5mby5pbmxpbmVTdHlsZSkge1xuICAgICAgdGhpcy5zdHlsZVtwcm9wZXJ0eV0gPSBpbmZvLmlubGluZVN0eWxlW3Byb3BlcnR5XTtcbiAgICB9XG5cbiAgICB0aGlzLl9maXRJbmZvID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXF1aXZhbGVudCB0byBjYWxsaW5nIGByZXNldEZpdCgpYCBhbmQgYGZpdCgpYC4gVXNlZnVsIHRvIGNhbGwgdGhpcyBhZnRlclxuICAgKiB0aGUgZWxlbWVudCBvciB0aGUgYGZpdEludG9gIGVsZW1lbnQgaGFzIGJlZW4gcmVzaXplZCwgb3IgaWYgYW55IG9mIHRoZVxuICAgKiBwb3NpdGlvbmluZyBwcm9wZXJ0aWVzIChlLmcuIGBob3Jpem9udGFsQWxpZ24sIHZlcnRpY2FsQWxpZ25gKSBpcyB1cGRhdGVkLlxuICAgKiBJdCBwcmVzZXJ2ZXMgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgc2l6aW5nVGFyZ2V0LlxuICAgKi9cbiAgcmVmaXQ6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY3JvbGxMZWZ0ID0gdGhpcy5zaXppbmdUYXJnZXQuc2Nyb2xsTGVmdDtcbiAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5zaXppbmdUYXJnZXQuc2Nyb2xsVG9wO1xuICAgIHRoaXMucmVzZXRGaXQoKTtcbiAgICB0aGlzLmZpdCgpO1xuICAgIHRoaXMuc2l6aW5nVGFyZ2V0LnNjcm9sbExlZnQgPSBzY3JvbGxMZWZ0O1xuICAgIHRoaXMuc2l6aW5nVGFyZ2V0LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgfSxcblxuICAvKipcbiAgICogUG9zaXRpb25zIHRoZSBlbGVtZW50IGFjY29yZGluZyB0byBgaG9yaXpvbnRhbEFsaWduLCB2ZXJ0aWNhbEFsaWduYC5cbiAgICovXG4gIHBvc2l0aW9uOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaG9yaXpvbnRhbEFsaWduICYmICF0aGlzLnZlcnRpY2FsQWxpZ24pIHtcbiAgICAgIC8vIG5lZWRzIHRvIGJlIGNlbnRlcmVkLCBhbmQgaXQgaXMgZG9uZSBhZnRlciBjb25zdHJhaW4uXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2Rpc2NvdmVySW5mbygpO1xuXG4gICAgdGhpcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgLy8gTmVlZCBib3JkZXItYm94IGZvciBtYXJnaW4vcGFkZGluZy5cbiAgICB0aGlzLnNpemluZ1RhcmdldC5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG4gICAgLy8gU2V0IHRvIDAsIDAgaW4gb3JkZXIgdG8gZGlzY292ZXIgYW55IG9mZnNldCBjYXVzZWQgYnkgcGFyZW50IHN0YWNraW5nIGNvbnRleHRzLlxuICAgIHRoaXMuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIHRoaXMuc3R5bGUudG9wID0gJzBweCc7XG5cbiAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHBvc2l0aW9uUmVjdCA9IHRoaXMuX19nZXROb3JtYWxpemVkUmVjdCh0aGlzLnBvc2l0aW9uVGFyZ2V0KTtcbiAgICB2YXIgZml0UmVjdCA9IHRoaXMuX19nZXROb3JtYWxpemVkUmVjdCh0aGlzLmZpdEludG8pO1xuXG4gICAgdmFyIG1hcmdpbiA9IHRoaXMuX2ZpdEluZm8ubWFyZ2luO1xuXG4gICAgLy8gQ29uc2lkZXIgdGhlIG1hcmdpbiBhcyBwYXJ0IG9mIHRoZSBzaXplIGZvciBwb3NpdGlvbiBjYWxjdWxhdGlvbnMuXG4gICAgdmFyIHNpemUgPSB7XG4gICAgICB3aWR0aDogcmVjdC53aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0LFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCArIG1hcmdpbi50b3AgKyBtYXJnaW4uYm90dG9tXG4gICAgfTtcblxuICAgIHZhciBwb3NpdGlvbiA9IHRoaXMuX19nZXRQb3NpdGlvbih0aGlzLl9sb2NhbGVIb3Jpem9udGFsQWxpZ24sIHRoaXMudmVydGljYWxBbGlnbiwgc2l6ZSwgcG9zaXRpb25SZWN0LFxuICAgICAgZml0UmVjdCk7XG5cbiAgICB2YXIgbGVmdCA9IHBvc2l0aW9uLmxlZnQgKyBtYXJnaW4ubGVmdDtcbiAgICB2YXIgdG9wID0gcG9zaXRpb24udG9wICsgbWFyZ2luLnRvcDtcblxuICAgIC8vIFdlIGZpcnN0IGxpbWl0IHJpZ2h0L2JvdHRvbSB3aXRoaW4gZml0SW50byByZXNwZWN0aW5nIHRoZSBtYXJnaW4sXG4gICAgLy8gdGhlbiB1c2UgdGhvc2UgdmFsdWVzIHRvIGxpbWl0IHRvcC9sZWZ0LlxuICAgIHZhciByaWdodCA9IE1hdGgubWluKGZpdFJlY3QucmlnaHQgLSBtYXJnaW4ucmlnaHQsIGxlZnQgKyByZWN0LndpZHRoKTtcbiAgICB2YXIgYm90dG9tID0gTWF0aC5taW4oZml0UmVjdC5ib3R0b20gLSBtYXJnaW4uYm90dG9tLCB0b3AgKyByZWN0LmhlaWdodCk7XG5cbiAgICAvLyBLZWVwIGxlZnQvdG9wIHdpdGhpbiBmaXRJbnRvIHJlc3BlY3RpbmcgdGhlIG1hcmdpbi5cbiAgICBsZWZ0ID0gTWF0aC5tYXgoZml0UmVjdC5sZWZ0ICsgbWFyZ2luLmxlZnQsXG4gICAgICBNYXRoLm1pbihsZWZ0LCByaWdodCAtIHRoaXMuX2ZpdEluZm8uc2l6ZWRCeS5taW5XaWR0aCkpO1xuICAgIHRvcCA9IE1hdGgubWF4KGZpdFJlY3QudG9wICsgbWFyZ2luLnRvcCxcbiAgICAgIE1hdGgubWluKHRvcCwgYm90dG9tIC0gdGhpcy5fZml0SW5mby5zaXplZEJ5Lm1pbkhlaWdodCkpO1xuXG4gICAgLy8gVXNlIHJpZ2h0L2JvdHRvbSB0byBzZXQgbWF4V2lkdGgvbWF4SGVpZ2h0LCBhbmQgcmVzcGVjdCBtaW5XaWR0aC9taW5IZWlnaHQuXG4gICAgdGhpcy5zaXppbmdUYXJnZXQuc3R5bGUubWF4V2lkdGggPSBNYXRoLm1heChyaWdodCAtIGxlZnQsIHRoaXMuX2ZpdEluZm8uc2l6ZWRCeS5taW5XaWR0aCkgKyAncHgnO1xuICAgIHRoaXMuc2l6aW5nVGFyZ2V0LnN0eWxlLm1heEhlaWdodCA9IE1hdGgubWF4KGJvdHRvbSAtIHRvcCwgdGhpcy5fZml0SW5mby5zaXplZEJ5Lm1pbkhlaWdodCkgKyAncHgnO1xuXG4gICAgLy8gUmVtb3ZlIHRoZSBvZmZzZXQgY2F1c2VkIGJ5IGFueSBzdGFja2luZyBjb250ZXh0LlxuICAgIHRoaXMuc3R5bGUubGVmdCA9IChsZWZ0IC0gcmVjdC5sZWZ0KSArICdweCc7XG4gICAgdGhpcy5zdHlsZS50b3AgPSAodG9wIC0gcmVjdC50b3ApICsgJ3B4JztcbiAgfSxcblxuICAvKipcbiAgICogQ29uc3RyYWlucyB0aGUgc2l6ZSBvZiB0aGUgZWxlbWVudCB0byBgZml0SW50b2AgYnkgc2V0dGluZyBgbWF4LWhlaWdodGBcbiAgICogYW5kL29yIGBtYXgtd2lkdGhgLlxuICAgKi9cbiAgY29uc3RyYWluOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ob3Jpem9udGFsQWxpZ24gfHwgdGhpcy52ZXJ0aWNhbEFsaWduKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2Rpc2NvdmVySW5mbygpO1xuXG4gICAgdmFyIGluZm8gPSB0aGlzLl9maXRJbmZvO1xuICAgIC8vIHBvc2l0aW9uIGF0ICgwcHgsIDBweCkgaWYgbm90IGFscmVhZHkgcG9zaXRpb25lZCwgc28gd2UgY2FuIG1lYXN1cmUgdGhlIG5hdHVyYWwgc2l6ZS5cbiAgICBpZiAoIWluZm8ucG9zaXRpb25lZEJ5LnZlcnRpY2FsbHkpIHtcbiAgICAgIHRoaXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgdGhpcy5zdHlsZS50b3AgPSAnMHB4JztcbiAgICB9XG4gICAgaWYgKCFpbmZvLnBvc2l0aW9uZWRCeS5ob3Jpem9udGFsbHkpIHtcbiAgICAgIHRoaXMuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgdGhpcy5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgfVxuXG4gICAgLy8gbmVlZCBib3JkZXItYm94IGZvciBtYXJnaW4vcGFkZGluZ1xuICAgIHRoaXMuc2l6aW5nVGFyZ2V0LnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgICAvLyBjb25zdHJhaW4gdGhlIHdpZHRoIGFuZCBoZWlnaHQgaWYgbm90IGFscmVhZHkgc2V0XG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmICghaW5mby5zaXplZEJ5LmhlaWdodCkge1xuICAgICAgdGhpcy5fX3NpemVEaW1lbnNpb24ocmVjdCwgaW5mby5wb3NpdGlvbmVkQnkudmVydGljYWxseSwgJ3RvcCcsICdib3R0b20nLCAnSGVpZ2h0Jyk7XG4gICAgfVxuICAgIGlmICghaW5mby5zaXplZEJ5LndpZHRoKSB7XG4gICAgICB0aGlzLl9fc2l6ZURpbWVuc2lvbihyZWN0LCBpbmZvLnBvc2l0aW9uZWRCeS5ob3Jpem9udGFsbHksICdsZWZ0JywgJ3JpZ2h0JywgJ1dpZHRoJyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICBfc2l6ZURpbWVuc2lvbjogZnVuY3Rpb24ocmVjdCwgcG9zaXRpb25lZEJ5LCBzdGFydCwgZW5kLCBleHRlbnQpIHtcbiAgICB0aGlzLl9fc2l6ZURpbWVuc2lvbihyZWN0LCBwb3NpdGlvbmVkQnksIHN0YXJ0LCBlbmQsIGV4dGVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfX3NpemVEaW1lbnNpb246IGZ1bmN0aW9uKHJlY3QsIHBvc2l0aW9uZWRCeSwgc3RhcnQsIGVuZCwgZXh0ZW50KSB7XG4gICAgdmFyIGluZm8gPSB0aGlzLl9maXRJbmZvO1xuICAgIHZhciBmaXRSZWN0ID0gdGhpcy5fX2dldE5vcm1hbGl6ZWRSZWN0KHRoaXMuZml0SW50byk7XG4gICAgdmFyIG1heCA9IGV4dGVudCA9PT0gJ1dpZHRoJyA/IGZpdFJlY3Qud2lkdGggOiBmaXRSZWN0LmhlaWdodDtcbiAgICB2YXIgZmxpcCA9IChwb3NpdGlvbmVkQnkgPT09IGVuZCk7XG4gICAgdmFyIG9mZnNldCA9IGZsaXAgPyBtYXggLSByZWN0W2VuZF0gOiByZWN0W3N0YXJ0XTtcbiAgICB2YXIgbWFyZ2luID0gaW5mby5tYXJnaW5bZmxpcCA/IHN0YXJ0IDogZW5kXTtcbiAgICB2YXIgb2Zmc2V0RXh0ZW50ID0gJ29mZnNldCcgKyBleHRlbnQ7XG4gICAgdmFyIHNpemluZ09mZnNldCA9IHRoaXNbb2Zmc2V0RXh0ZW50XSAtIHRoaXMuc2l6aW5nVGFyZ2V0W29mZnNldEV4dGVudF07XG4gICAgdGhpcy5zaXppbmdUYXJnZXQuc3R5bGVbJ21heCcgKyBleHRlbnRdID0gKG1heCAtIG1hcmdpbiAtIG9mZnNldCAtIHNpemluZ09mZnNldCkgKyAncHgnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDZW50ZXJzIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseSBpZiBub3QgYWxyZWFkeSBwb3NpdGlvbmVkLiBUaGlzIGFsc28gc2V0c1xuICAgKiBgcG9zaXRpb246Zml4ZWRgLlxuICAgKi9cbiAgY2VudGVyOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5ob3Jpem9udGFsQWxpZ24gfHwgdGhpcy52ZXJ0aWNhbEFsaWduKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2Rpc2NvdmVySW5mbygpO1xuXG4gICAgdmFyIHBvc2l0aW9uZWRCeSA9IHRoaXMuX2ZpdEluZm8ucG9zaXRpb25lZEJ5O1xuICAgIGlmIChwb3NpdGlvbmVkQnkudmVydGljYWxseSAmJiBwb3NpdGlvbmVkQnkuaG9yaXpvbnRhbGx5KSB7XG4gICAgICAvLyBBbHJlYWR5IHBvc2l0aW9uZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE5lZWQgcG9zaXRpb246Zml4ZWQgdG8gY2VudGVyXG4gICAgdGhpcy5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgLy8gVGFrZSBpbnRvIGFjY291bnQgdGhlIG9mZnNldCBjYXVzZWQgYnkgcGFyZW50cyB0aGF0IGNyZWF0ZSBzdGFja2luZ1xuICAgIC8vIGNvbnRleHRzIChlLmcuIHdpdGggdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCkuIFRyYW5zbGF0ZSB0byAwLDAgYW5kXG4gICAgLy8gbWVhc3VyZSB0aGUgYm91bmRpbmcgcmVjdC5cbiAgICBpZiAoIXBvc2l0aW9uZWRCeS52ZXJ0aWNhbGx5KSB7XG4gICAgICB0aGlzLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIH1cbiAgICBpZiAoIXBvc2l0aW9uZWRCeS5ob3Jpem9udGFsbHkpIHtcbiAgICAgIHRoaXMuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIH1cbiAgICAvLyBJdCB3aWxsIHRha2UgaW4gY29uc2lkZXJhdGlvbiBtYXJnaW5zIGFuZCB0cmFuc2Zvcm1zXG4gICAgdmFyIHJlY3QgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBmaXRSZWN0ID0gdGhpcy5fX2dldE5vcm1hbGl6ZWRSZWN0KHRoaXMuZml0SW50byk7XG4gICAgaWYgKCFwb3NpdGlvbmVkQnkudmVydGljYWxseSkge1xuICAgICAgdmFyIHRvcCA9IGZpdFJlY3QudG9wIC0gcmVjdC50b3AgKyAoZml0UmVjdC5oZWlnaHQgLSByZWN0LmhlaWdodCkgLyAyO1xuICAgICAgdGhpcy5zdHlsZS50b3AgPSB0b3AgKyAncHgnO1xuICAgIH1cbiAgICBpZiAoIXBvc2l0aW9uZWRCeS5ob3Jpem9udGFsbHkpIHtcbiAgICAgIHZhciBsZWZ0ID0gZml0UmVjdC5sZWZ0IC0gcmVjdC5sZWZ0ICsgKGZpdFJlY3Qud2lkdGggLSByZWN0LndpZHRoKSAvIDI7XG4gICAgICB0aGlzLnN0eWxlLmxlZnQgPSBsZWZ0ICsgJ3B4JztcbiAgICB9XG4gIH0sXG5cbiAgX19nZXROb3JtYWxpemVkUmVjdDogZnVuY3Rpb24odGFyZ2V0KSB7XG4gICAgaWYgKHRhcmdldCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IHRhcmdldCA9PT0gd2luZG93KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgaGVpZ2h0OiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICAgIHJpZ2h0OiB3aW5kb3cuaW5uZXJXaWR0aCxcbiAgICAgICAgYm90dG9tOiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH0sXG5cbiAgX19nZXRDcm9wcGVkQXJlYTogZnVuY3Rpb24ocG9zaXRpb24sIHNpemUsIGZpdFJlY3QpIHtcbiAgICB2YXIgdmVydGljYWxDcm9wID0gTWF0aC5taW4oMCwgcG9zaXRpb24udG9wKSArIE1hdGgubWluKDAsIGZpdFJlY3QuYm90dG9tIC0gKHBvc2l0aW9uLnRvcCArIHNpemUuaGVpZ2h0KSk7XG4gICAgdmFyIGhvcml6b250YWxDcm9wID0gTWF0aC5taW4oMCwgcG9zaXRpb24ubGVmdCkgKyBNYXRoLm1pbigwLCBmaXRSZWN0LnJpZ2h0IC0gKHBvc2l0aW9uLmxlZnQgKyBzaXplLndpZHRoKSk7XG4gICAgcmV0dXJuIE1hdGguYWJzKHZlcnRpY2FsQ3JvcCkgKiBzaXplLndpZHRoICsgTWF0aC5hYnMoaG9yaXpvbnRhbENyb3ApICogc2l6ZS5oZWlnaHQ7XG4gIH0sXG5cblxuICBfX2dldFBvc2l0aW9uOiBmdW5jdGlvbihoQWxpZ24sIHZBbGlnbiwgc2l6ZSwgcG9zaXRpb25SZWN0LCBmaXRSZWN0KSB7XG4gICAgLy8gQWxsIHRoZSBwb3NzaWJsZSBjb25maWd1cmF0aW9ucy5cbiAgICAvLyBPcmRlcmVkIGFzIHRvcC1sZWZ0LCB0b3AtcmlnaHQsIGJvdHRvbS1sZWZ0LCBib3R0b20tcmlnaHQuXG4gICAgdmFyIHBvc2l0aW9ucyA9IFt7XG4gICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcbiAgICAgIGhvcml6b250YWxBbGlnbjogJ2xlZnQnLFxuICAgICAgdG9wOiBwb3NpdGlvblJlY3QudG9wICsgdGhpcy52ZXJ0aWNhbE9mZnNldCxcbiAgICAgIGxlZnQ6IHBvc2l0aW9uUmVjdC5sZWZ0ICsgdGhpcy5ob3Jpem9udGFsT2Zmc2V0XG4gICAgfSwge1xuICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXG4gICAgICBob3Jpem9udGFsQWxpZ246ICdyaWdodCcsXG4gICAgICB0b3A6IHBvc2l0aW9uUmVjdC50b3AgKyB0aGlzLnZlcnRpY2FsT2Zmc2V0LFxuICAgICAgbGVmdDogcG9zaXRpb25SZWN0LnJpZ2h0IC0gc2l6ZS53aWR0aCAtIHRoaXMuaG9yaXpvbnRhbE9mZnNldFxuICAgIH0sIHtcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdib3R0b20nLFxuICAgICAgaG9yaXpvbnRhbEFsaWduOiAnbGVmdCcsXG4gICAgICB0b3A6IHBvc2l0aW9uUmVjdC5ib3R0b20gLSBzaXplLmhlaWdodCAtIHRoaXMudmVydGljYWxPZmZzZXQsXG4gICAgICBsZWZ0OiBwb3NpdGlvblJlY3QubGVmdCArIHRoaXMuaG9yaXpvbnRhbE9mZnNldFxuICAgIH0sIHtcbiAgICAgIHZlcnRpY2FsQWxpZ246ICdib3R0b20nLFxuICAgICAgaG9yaXpvbnRhbEFsaWduOiAncmlnaHQnLFxuICAgICAgdG9wOiBwb3NpdGlvblJlY3QuYm90dG9tIC0gc2l6ZS5oZWlnaHQgLSB0aGlzLnZlcnRpY2FsT2Zmc2V0LFxuICAgICAgbGVmdDogcG9zaXRpb25SZWN0LnJpZ2h0IC0gc2l6ZS53aWR0aCAtIHRoaXMuaG9yaXpvbnRhbE9mZnNldFxuICAgIH1dO1xuXG4gICAgaWYgKHRoaXMubm9PdmVybGFwKSB7XG4gICAgICAvLyBEdXBsaWNhdGUuXG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNvcHkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHBvc2l0aW9uc1tpXSkge1xuICAgICAgICAgIGNvcHlba2V5XSA9IHBvc2l0aW9uc1tpXVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHBvc2l0aW9ucy5wdXNoKGNvcHkpO1xuICAgICAgfVxuICAgICAgLy8gSG9yaXpvbnRhbCBvdmVybGFwIG9ubHkuXG4gICAgICBwb3NpdGlvbnNbMF0udG9wID0gcG9zaXRpb25zWzFdLnRvcCArPSBwb3NpdGlvblJlY3QuaGVpZ2h0O1xuICAgICAgcG9zaXRpb25zWzJdLnRvcCA9IHBvc2l0aW9uc1szXS50b3AgLT0gcG9zaXRpb25SZWN0LmhlaWdodDtcbiAgICAgIC8vIFZlcnRpY2FsIG92ZXJsYXAgb25seS5cbiAgICAgIHBvc2l0aW9uc1s0XS5sZWZ0ID0gcG9zaXRpb25zWzZdLmxlZnQgKz0gcG9zaXRpb25SZWN0LndpZHRoO1xuICAgICAgcG9zaXRpb25zWzVdLmxlZnQgPSBwb3NpdGlvbnNbN10ubGVmdCAtPSBwb3NpdGlvblJlY3Qud2lkdGg7XG4gICAgfVxuXG4gICAgLy8gQ29uc2lkZXIgYXV0byBhcyBudWxsIGZvciBjb2RpbmcgY29udmVuaWVuY2UuXG4gICAgdkFsaWduID0gdkFsaWduID09PSAnYXV0bycgPyBudWxsIDogdkFsaWduO1xuICAgIGhBbGlnbiA9IGhBbGlnbiA9PT0gJ2F1dG8nID8gbnVsbCA6IGhBbGlnbjtcblxuICAgIHZhciBwb3NpdGlvbjtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvc2l0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBvcyA9IHBvc2l0aW9uc1tpXTtcblxuICAgICAgLy8gSWYgYm90aCB2QWxpZ24gYW5kIGhBbGlnbiBhcmUgZGVmaW5lZCwgcmV0dXJuIGV4YWN0IG1hdGNoLlxuICAgICAgLy8gRm9yIGR5bmFtaWNBbGlnbiBhbmQgbm9PdmVybGFwIHdlJ2xsIGhhdmUgbW9yZSB0aGFuIG9uZSBjYW5kaWRhdGUsIHNvXG4gICAgICAvLyB3ZSdsbCBoYXZlIHRvIGNoZWNrIHRoZSBjcm9wcGVkQXJlYSB0byBtYWtlIHRoZSBiZXN0IGNob2ljZS5cbiAgICAgIGlmICghdGhpcy5keW5hbWljQWxpZ24gJiYgIXRoaXMubm9PdmVybGFwICYmXG4gICAgICAgIHBvcy52ZXJ0aWNhbEFsaWduID09PSB2QWxpZ24gJiYgcG9zLmhvcml6b250YWxBbGlnbiA9PT0gaEFsaWduKSB7XG4gICAgICAgIHBvc2l0aW9uID0gcG9zO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gQWxpZ24gaXMgb2sgaWYgYWxpZ25tZW50IHByZWZlcmVuY2VzIGFyZSByZXNwZWN0ZWQuIElmIG5vIHByZWZlcmVuY2VzLFxuICAgICAgLy8gaXQgaXMgY29uc2lkZXJlZCBvay5cbiAgICAgIHZhciBhbGlnbk9rID0gKCF2QWxpZ24gfHwgcG9zLnZlcnRpY2FsQWxpZ24gPT09IHZBbGlnbikgJiZcbiAgICAgICAgKCFoQWxpZ24gfHwgcG9zLmhvcml6b250YWxBbGlnbiA9PT0gaEFsaWduKTtcblxuICAgICAgLy8gRmlsdGVyIG91dCBlbGVtZW50cyB0aGF0IGRvbid0IG1hdGNoIHRoZSBhbGlnbm1lbnQgKGlmIGRlZmluZWQpLlxuICAgICAgLy8gV2l0aCBkeW5hbWljQWxpZ24sIHdlIG5lZWQgdG8gY29uc2lkZXIgYWxsIHRoZSBwb3NpdGlvbnMgdG8gZmluZCB0aGVcbiAgICAgIC8vIG9uZSB0aGF0IG1pbmltaXplcyB0aGUgY3JvcHBlZCBhcmVhLlxuICAgICAgaWYgKCF0aGlzLmR5bmFtaWNBbGlnbiAmJiAhYWxpZ25Paykge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiB8fCBwb3M7XG4gICAgICBwb3MuY3JvcHBlZEFyZWEgPSB0aGlzLl9fZ2V0Q3JvcHBlZEFyZWEocG9zLCBzaXplLCBmaXRSZWN0KTtcbiAgICAgIHZhciBkaWZmID0gcG9zLmNyb3BwZWRBcmVhIC0gcG9zaXRpb24uY3JvcHBlZEFyZWE7XG4gICAgICAvLyBDaGVjayB3aGljaCBjcm9wcyBsZXNzLiBJZiBpdCBjcm9wcyBlcXVhbGx5LCBjaGVjayBpZiBhbGlnbiBpcyBvay5cbiAgICAgIGlmIChkaWZmIDwgMCB8fCAoZGlmZiA9PT0gMCAmJiBhbGlnbk9rKSkge1xuICAgICAgICBwb3NpdGlvbiA9IHBvcztcbiAgICAgIH1cbiAgICAgIC8vIElmIG5vdCBjcm9wcGVkIGFuZCByZXNwZWN0cyB0aGUgYWxpZ24gcmVxdWlyZW1lbnRzLCBrZWVwIGl0LlxuICAgICAgLy8gVGhpcyBhbGxvd3MgdG8gcHJlZmVyIHBvc2l0aW9ucyBvdmVybGFwcGluZyBob3Jpem9udGFsbHkgb3ZlciB0aGVcbiAgICAgIC8vIG9uZXMgb3ZlcmxhcHBpbmcgdmVydGljYWxseS5cbiAgICAgIGlmIChwb3NpdGlvbi5jcm9wcGVkQXJlYSA9PT0gMCAmJiBhbGlnbk9rKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwb3NpdGlvbjtcbiAgfVxuXG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1maXQtYmVoYXZpb3IvaXJvbi1maXQtYmVoYXZpb3IuanNcbi8vIG1vZHVsZSBpZCA9IDc2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IFNldHRpbmdzIH0gZnJvbSAnLi4vcG9seW1lci9saWIvdXRpbHMvc2V0dGluZ3MuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25SZXNpemFibGVCZWhhdmlvciA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBjbG9zZXN0IGFuY2VzdG9yIGVsZW1lbnQgdGhhdCBpbXBsZW1lbnRzIGBJcm9uUmVzaXphYmxlQmVoYXZpb3JgLlxuICAgICAqL1xuICAgIF9wYXJlbnRSZXNpemFibGU6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIG9ic2VydmVyOiAnX3BhcmVudFJlc2l6YWJsZUNoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhpcyBlbGVtZW50IGlzIGN1cnJlbnRseSBub3RpZnlpbmcgaXRzIGRlc2NlbmRhbnQgZWxlbWVudHMgb2ZcbiAgICAgKiByZXNpemUuXG4gICAgICovXG4gICAgX25vdGlmeWluZ0Rlc2NlbmRhbnQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgJ2lyb24tcmVxdWVzdC1yZXNpemUtbm90aWZpY2F0aW9ucyc6ICdfb25Jcm9uUmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMnXG4gIH0sXG5cbiAgY3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gV2UgZG9uJ3QgcmVhbGx5IG5lZWQgcHJvcGVydHkgZWZmZWN0cyBvbiB0aGVzZSwgYW5kIGFsc28gd2Ugd2FudCB0aGVtXG4gICAgLy8gdG8gYmUgY3JlYXRlZCBiZWZvcmUgdGhlIGBfcGFyZW50UmVzaXphYmxlYCBvYnNlcnZlciBmaXJlczpcbiAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcyA9IFtdO1xuICAgIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplID0gdGhpcy5ub3RpZnlSZXNpemUuYmluZCh0aGlzKTtcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMoKTtcbiAgfSxcblxuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX3BhcmVudFJlc2l6YWJsZSkge1xuICAgICAgdGhpcy5fcGFyZW50UmVzaXphYmxlLnN0b3BSZXNpemVOb3RpZmljYXRpb25zRm9yKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5fYm91bmROb3RpZnlSZXNpemUpO1xuICAgIH1cblxuICAgIHRoaXMuX3BhcmVudFJlc2l6YWJsZSA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbiBiZSBjYWxsZWQgdG8gbWFudWFsbHkgbm90aWZ5IGEgcmVzaXphYmxlIGFuZCBpdHMgZGVzY2VuZGFudFxuICAgKiByZXNpemFibGVzIG9mIGEgcmVzaXplIGNoYW5nZS5cbiAgICovXG4gIG5vdGlmeVJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHJlc2l6YWJsZSkge1xuICAgICAgaWYgKHRoaXMucmVzaXplclNob3VsZE5vdGlmeShyZXNpemFibGUpKSB7XG4gICAgICAgIHRoaXMuX25vdGlmeURlc2NlbmRhbnQocmVzaXphYmxlKTtcbiAgICAgIH1cbiAgICB9LCB0aGlzKTtcblxuICAgIHRoaXMuX2ZpcmVSZXNpemUoKTtcbiAgfSxcblxuICAvKipcbiAgICogVXNlZCB0byBhc3NpZ24gdGhlIGNsb3Nlc3QgcmVzaXphYmxlIGFuY2VzdG9yIHRvIHRoaXMgcmVzaXphYmxlXG4gICAqIGlmIHRoZSBhbmNlc3RvciBkZXRlY3RzIGEgcmVxdWVzdCBmb3Igbm90aWZpY2F0aW9ucy5cbiAgICovXG4gIGFzc2lnblBhcmVudFJlc2l6YWJsZTogZnVuY3Rpb24ocGFyZW50UmVzaXphYmxlKSB7XG4gICAgdGhpcy5fcGFyZW50UmVzaXphYmxlID0gcGFyZW50UmVzaXphYmxlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVc2VkIHRvIHJlbW92ZSBhIHJlc2l6YWJsZSBkZXNjZW5kYW50IGZyb20gdGhlIGxpc3Qgb2YgZGVzY2VuZGFudHNcbiAgICogdGhhdCBzaG91bGQgYmUgbm90aWZpZWQgb2YgYSByZXNpemUgY2hhbmdlLlxuICAgKi9cbiAgc3RvcFJlc2l6ZU5vdGlmaWNhdGlvbnNGb3I6IGZ1bmN0aW9uKHRhcmdldCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLmluZGV4T2YodGFyZ2V0KTtcblxuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICB0aGlzLl9pbnRlcmVzdGVkUmVzaXphYmxlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgdGhpcy51bmxpc3Rlbih0YXJnZXQsICdpcm9uLXJlc2l6ZScsICdfb25EZXNjZW5kYW50SXJvblJlc2l6ZScpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtZXRob2QgY2FuIGJlIG92ZXJyaWRkZW4gdG8gZmlsdGVyIG5lc3RlZCBlbGVtZW50cyB0aGF0IHNob3VsZCBvclxuICAgKiBzaG91bGQgbm90IGJlIG5vdGlmaWVkIGJ5IHRoZSBjdXJyZW50IGVsZW1lbnQuIFJldHVybiB0cnVlIGlmIGFuIGVsZW1lbnRcbiAgICogc2hvdWxkIGJlIG5vdGlmaWVkLCBvciBmYWxzZSBpZiBpdCBzaG91bGQgbm90IGJlIG5vdGlmaWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IEEgY2FuZGlkYXRlIGRlc2NlbmRhbnQgZWxlbWVudCB0aGF0XG4gICAqIGltcGxlbWVudHMgYElyb25SZXNpemFibGVCZWhhdmlvcmAuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGBlbGVtZW50YCBzaG91bGQgYmUgbm90aWZpZWQgb2YgcmVzaXplLlxuICAgKi9cbiAgcmVzaXplclNob3VsZE5vdGlmeTogZnVuY3Rpb24oZWxlbWVudCkgeyByZXR1cm4gdHJ1ZTsgfSxcblxuICBfb25EZXNjZW5kYW50SXJvblJlc2l6ZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy5fbm90aWZ5aW5nRGVzY2VuZGFudCkge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gTk9URShjZGF0YSk6IEluIFNoYWRvd0RPTSwgZXZlbnQgcmV0YXJnZXRpbmcgbWFrZXMgZWNob2luZyBvZiB0aGVcbiAgICAvLyBvdGhlcndpc2Ugbm9uLWJ1YmJsaW5nIGV2ZW50IFwianVzdCB3b3JrLlwiIFdlIGRvIGl0IG1hbnVhbGx5IGhlcmUgZm9yXG4gICAgLy8gdGhlIGNhc2Ugd2hlcmUgUG9seW1lciBpcyBub3QgdXNpbmcgc2hhZG93IHJvb3RzIGZvciB3aGF0ZXZlciByZWFzb246XG4gICAgaWYgKCFTZXR0aW5ncy51c2VTaGFkb3cpIHtcbiAgICAgIHRoaXMuX2ZpcmVSZXNpemUoKTtcbiAgICB9XG4gIH0sXG5cbiAgX2ZpcmVSZXNpemU6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuZmlyZSgnaXJvbi1yZXNpemUnLCBudWxsLCB7XG4gICAgICBub2RlOiB0aGlzLFxuICAgICAgYnViYmxlczogZmFsc2VcbiAgICB9KTtcbiAgfSxcblxuICBfb25Jcm9uUmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnM6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IC8qKiBAdHlwZSB7IUV2ZW50VGFyZ2V0fSAqLyAoZG9tKGV2ZW50KS5yb290VGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0ID09PSB0aGlzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLmluZGV4T2YodGFyZ2V0KSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX2ludGVyZXN0ZWRSZXNpemFibGVzLnB1c2godGFyZ2V0KTtcbiAgICAgIHRoaXMubGlzdGVuKHRhcmdldCwgJ2lyb24tcmVzaXplJywgJ19vbkRlc2NlbmRhbnRJcm9uUmVzaXplJyk7XG4gICAgfVxuXG4gICAgdGFyZ2V0LmFzc2lnblBhcmVudFJlc2l6YWJsZSh0aGlzKTtcbiAgICB0aGlzLl9ub3RpZnlEZXNjZW5kYW50KHRhcmdldCk7XG5cbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgfSxcblxuICBfcGFyZW50UmVzaXphYmxlQ2hhbmdlZDogZnVuY3Rpb24ocGFyZW50UmVzaXphYmxlKSB7XG4gICAgaWYgKHBhcmVudFJlc2l6YWJsZSkge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2JvdW5kTm90aWZ5UmVzaXplKTtcbiAgICB9XG4gIH0sXG5cbiAgX25vdGlmeURlc2NlbmRhbnQ6IGZ1bmN0aW9uKGRlc2NlbmRhbnQpIHtcbiAgICAvLyBOT1RFKGNkYXRhKTogSW4gSUUxMCwgYXR0YWNoZWQgaXMgZmlyZWQgb24gY2hpbGRyZW4gZmlyc3QsIHNvIGl0J3NcbiAgICAvLyBpbXBvcnRhbnQgbm90IHRvIG5vdGlmeSB0aGVtIGlmIHRoZSBwYXJlbnQgaXMgbm90IGF0dGFjaGVkIHlldCAob3JcbiAgICAvLyBlbHNlIHRoZXkgd2lsbCBnZXQgcmVkdW5kYW50bHkgbm90aWZpZWQgd2hlbiB0aGUgcGFyZW50IGF0dGFjaGVzKS5cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX25vdGlmeWluZ0Rlc2NlbmRhbnQgPSB0cnVlO1xuICAgIGRlc2NlbmRhbnQubm90aWZ5UmVzaXplKCk7XG4gICAgdGhpcy5fbm90aWZ5aW5nRGVzY2VuZGFudCA9IGZhbHNlO1xuICB9LFxuICBcbiAgX3JlcXVlc3RSZXNpemVOb3RpZmljYXRpb25zOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZClcbiAgICAgIHJldHVybjtcbiAgICBcbiAgICAvLyBOT1RFKHZhbGRyaW4pIEluIEN1c3RvbUVsZW1lbnRzIHYxIHdpdGggbmF0aXZlIEhUTUxJbXBvcnRzLCB0aGUgb3JkZXJcbiAgICAvLyBvZiBpbXBvcnRzIGFmZmVjdHMgdGhlIG9yZGVyIG9mIGBhdHRhY2hlZGAgY2FsbGJhY2tzIChzZWUgd2ViY29tcG9uZW50cy9jdXN0b20tZWxlbWVudHMjMTUpLlxuICAgIC8vIFRoaXMgbWlnaHQgY2F1c2UgYSBjaGlsZCB0byBub3RpZnkgcGFyZW50cyB0b28gZWFybHkgKGFzIHRoZSBwYXJlbnRcbiAgICAvLyBzdGlsbCBoYXMgdG8gYmUgdXBncmFkZWQpLCByZXN1bHRpbmcgaW4gYSBwYXJlbnQgbm90IGFibGUgdG8ga2VlcCB0cmFja1xuICAgIC8vIG9mIHRoZSBgX2ludGVyZXN0ZWRSZXNpemFibGVzYC4gVG8gc29sdmUgdGhpcywgd2Ugd2FpdCBmb3IgdGhlIGRvY3VtZW50XG4gICAgLy8gdG8gYmUgZG9uZSBsb2FkaW5nIGJlZm9yZSBmaXJpbmcgdGhlIGV2ZW50LlxuICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgIHZhciBfcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMgPSB0aGlzLl9yZXF1ZXN0UmVzaXplTm90aWZpY2F0aW9ucy5iaW5kKHRoaXMpO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigncmVhZHlzdGF0ZWNoYW5nZScsIGZ1bmN0aW9uIHJlYWR5c3RhdGVjaGFuZ2VkKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgcmVhZHlzdGF0ZWNoYW5nZWQpO1xuICAgICAgICBfcmVxdWVzdFJlc2l6ZU5vdGlmaWNhdGlvbnMoKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZpcmUoJ2lyb24tcmVxdWVzdC1yZXNpemUtbm90aWZpY2F0aW9ucycsIG51bGwsIHtcbiAgICAgICAgbm9kZTogdGhpcyxcbiAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghdGhpcy5fcGFyZW50UmVzaXphYmxlKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9ib3VuZE5vdGlmeVJlc2l6ZSk7XG4gICAgICAgIHRoaXMubm90aWZ5UmVzaXplKCk7XG4gICAgICB9IFxuICAgIH1cbiAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yL2lyb24tcmVzaXphYmxlLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA3N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQTExeUtleXNCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi9pcm9uLW92ZXJsYXktYmFja2Ryb3AuanMnO1xuaW1wb3J0ICogYXMgZ2VzdHVyZXMgZnJvbSAnLi4vcG9seW1lci9saWIvdXRpbHMvZ2VzdHVyZXMuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25PdmVybGF5TWFuYWdlckNsYXNzID0gZnVuY3Rpb24oKSB7XG4gIC8qKlxuICAgKiBVc2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIG9wZW5lZCBvdmVybGF5cy5cbiAgICogQHByaXZhdGUge0FycmF5PEVsZW1lbnQ+fVxuICAgKi9cbiAgdGhpcy5fb3ZlcmxheXMgPSBbXTtcblxuICAvKipcbiAgICogaWZyYW1lcyBoYXZlIGEgZGVmYXVsdCB6LWluZGV4IG9mIDEwMCxcbiAgICogc28gdGhpcyBkZWZhdWx0IHNob3VsZCBiZSBhdCBsZWFzdCB0aGF0LlxuICAgKiBAcHJpdmF0ZSB7bnVtYmVyfVxuICAgKi9cbiAgdGhpcy5fbWluaW11bVogPSAxMDE7XG5cbiAgLyoqXG4gICAqIE1lbW9pemVkIGJhY2tkcm9wIGVsZW1lbnQuXG4gICAqIEBwcml2YXRlIHtFbGVtZW50fG51bGx9XG4gICAqL1xuICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQgPSBudWxsO1xuXG4gIC8vIEVuYWJsZSBkb2N1bWVudC13aWRlIHRhcCByZWNvZ25pemVyLlxuICAvLyBOT1RFOiBVc2UgdXNlQ2FwdHVyZT10cnVlIHRvIGF2b2lkIGFjY2lkZW50YWxseSBwcmV2ZW50aW9uIG9mIHRoZSBjbG9zaW5nXG4gIC8vIG9mIGFuIG92ZXJsYXkgdmlhIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpLiBUaGUgb25seSB3YXkgdG8gcHJldmVudFxuICAvLyBjbG9zaW5nIG9mIGFuIG92ZXJsYXkgc2hvdWxkIGJlIHRocm91Z2ggaXRzIEFQSXMuXG4gIC8vIE5PVEU6IGVuYWJsZSB0YXAgb24gPGh0bWw+IHRvIHdvcmthcm91bmQgUG9seW1lci9wb2x5bWVyIzQ0NTlcbiAgZ2VzdHVyZXMuYWRkKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgJ3RhcCcsIG51bGwpO1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0YXAnLCB0aGlzLl9vbkNhcHR1cmVDbGljay5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9vbkNhcHR1cmVGb2N1cy5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuX29uQ2FwdHVyZUtleURvd24uYmluZCh0aGlzKSwgdHJ1ZSk7XG59O1xuXG5Jcm9uT3ZlcmxheU1hbmFnZXJDbGFzcy5wcm90b3R5cGUgPSB7XG5cbiAgY29uc3RydWN0b3I6IElyb25PdmVybGF5TWFuYWdlckNsYXNzLFxuXG4gIC8qKlxuICAgKiBUaGUgc2hhcmVkIGJhY2tkcm9wIGVsZW1lbnQuXG4gICAqIEB0eXBlIHshRWxlbWVudH0gYmFja2Ryb3BFbGVtZW50XG4gICAqL1xuICBnZXQgYmFja2Ryb3BFbGVtZW50KCkge1xuICAgIGlmICghdGhpcy5fYmFja2Ryb3BFbGVtZW50KSB7XG4gICAgICB0aGlzLl9iYWNrZHJvcEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpcm9uLW92ZXJsYXktYmFja2Ryb3AnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2JhY2tkcm9wRWxlbWVudDtcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGRlZXBlc3QgYWN0aXZlIGVsZW1lbnQuXG4gICAqIEB0eXBlIHshRWxlbWVudH0gYWN0aXZlRWxlbWVudCB0aGUgYWN0aXZlIGVsZW1lbnRcbiAgICovXG4gIGdldCBkZWVwQWN0aXZlRWxlbWVudCgpIHtcbiAgICAvLyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiBiZSBudWxsXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0RvY3VtZW50L2FjdGl2ZUVsZW1lbnRcbiAgICAvLyBJbiBjYXNlIG9mIG51bGwsIGRlZmF1bHQgaXQgdG8gZG9jdW1lbnQuYm9keS5cbiAgICB2YXIgYWN0aXZlID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCB8fCBkb2N1bWVudC5ib2R5O1xuICAgIHdoaWxlIChhY3RpdmUucm9vdCAmJiBkb20oYWN0aXZlLnJvb3QpLmFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIGFjdGl2ZSA9IGRvbShhY3RpdmUucm9vdCkuYWN0aXZlRWxlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZTtcbiAgfSxcblxuICAvKipcbiAgICogQnJpbmdzIHRoZSBvdmVybGF5IGF0IHRoZSBzcGVjaWZpZWQgaW5kZXggdG8gdGhlIGZyb250LlxuICAgKiBAcGFyYW0ge251bWJlcn0gaVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2JyaW5nT3ZlcmxheUF0SW5kZXhUb0Zyb250OiBmdW5jdGlvbihpKSB7XG4gICAgdmFyIG92ZXJsYXkgPSB0aGlzLl9vdmVybGF5c1tpXTtcbiAgICBpZiAoIW92ZXJsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxhc3RJID0gdGhpcy5fb3ZlcmxheXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgY3VycmVudE92ZXJsYXkgPSB0aGlzLl9vdmVybGF5c1tsYXN0SV07XG4gICAgLy8gRW5zdXJlIGFsd2F5cy1vbi10b3Agb3ZlcmxheSBzdGF5cyBvbiB0b3AuXG4gICAgaWYgKGN1cnJlbnRPdmVybGF5ICYmIHRoaXMuX3Nob3VsZEJlQmVoaW5kT3ZlcmxheShvdmVybGF5LCBjdXJyZW50T3ZlcmxheSkpIHtcbiAgICAgIGxhc3RJLS07XG4gICAgfVxuICAgIC8vIElmIGFscmVhZHkgdGhlIHRvcCBlbGVtZW50LCByZXR1cm4uXG4gICAgaWYgKGkgPj0gbGFzdEkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gVXBkYXRlIHotaW5kZXggdG8gYmUgb24gdG9wLlxuICAgIHZhciBtaW5pbXVtWiA9IE1hdGgubWF4KHRoaXMuY3VycmVudE92ZXJsYXlaKCksIHRoaXMuX21pbmltdW1aKTtcbiAgICBpZiAodGhpcy5fZ2V0WihvdmVybGF5KSA8PSBtaW5pbXVtWikge1xuICAgICAgdGhpcy5fYXBwbHlPdmVybGF5WihvdmVybGF5LCBtaW5pbXVtWik7XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgb3RoZXIgb3ZlcmxheXMgYmVoaW5kIHRoZSBuZXcgb24gdG9wLlxuICAgIHdoaWxlIChpIDwgbGFzdEkpIHtcbiAgICAgIHRoaXMuX292ZXJsYXlzW2ldID0gdGhpcy5fb3ZlcmxheXNbaSArIDFdO1xuICAgICAgaSsrO1xuICAgIH1cbiAgICB0aGlzLl9vdmVybGF5c1tsYXN0SV0gPSBvdmVybGF5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBvdmVybGF5IGFuZCB1cGRhdGVzIGl0cyB6LWluZGV4IGlmIGl0J3Mgb3BlbmVkLCBvciByZW1vdmVzIGl0IGlmIGl0J3MgY2xvc2VkLlxuICAgKiBBbHNvIHVwZGF0ZXMgdGhlIGJhY2tkcm9wIHotaW5kZXguXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG92ZXJsYXlcbiAgICovXG4gIGFkZE9yUmVtb3ZlT3ZlcmxheTogZnVuY3Rpb24ob3ZlcmxheSkge1xuICAgIGlmIChvdmVybGF5Lm9wZW5lZCkge1xuICAgICAgdGhpcy5hZGRPdmVybGF5KG92ZXJsYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZU92ZXJsYXkob3ZlcmxheSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFja3Mgb3ZlcmxheXMgZm9yIHotaW5kZXggYW5kIGZvY3VzIG1hbmFnZW1lbnQuXG4gICAqIEVuc3VyZXMgdGhlIGxhc3QgYWRkZWQgb3ZlcmxheSB3aXRoIGFsd2F5cy1vbi10b3AgcmVtYWlucyBvbiB0b3AuXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG92ZXJsYXlcbiAgICovXG4gIGFkZE92ZXJsYXk6IGZ1bmN0aW9uKG92ZXJsYXkpIHtcbiAgICB2YXIgaSA9IHRoaXMuX292ZXJsYXlzLmluZGV4T2Yob3ZlcmxheSk7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fYnJpbmdPdmVybGF5QXRJbmRleFRvRnJvbnQoaSk7XG4gICAgICB0aGlzLnRyYWNrQmFja2Ryb3AoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGluc2VydGlvbkluZGV4ID0gdGhpcy5fb3ZlcmxheXMubGVuZ3RoO1xuICAgIHZhciBjdXJyZW50T3ZlcmxheSA9IHRoaXMuX292ZXJsYXlzW2luc2VydGlvbkluZGV4IC0gMV07XG4gICAgdmFyIG1pbmltdW1aID0gTWF0aC5tYXgodGhpcy5fZ2V0WihjdXJyZW50T3ZlcmxheSksIHRoaXMuX21pbmltdW1aKTtcbiAgICB2YXIgbmV3WiA9IHRoaXMuX2dldFoob3ZlcmxheSk7XG5cbiAgICAvLyBFbnN1cmUgYWx3YXlzLW9uLXRvcCBvdmVybGF5IHN0YXlzIG9uIHRvcC5cbiAgICBpZiAoY3VycmVudE92ZXJsYXkgJiYgdGhpcy5fc2hvdWxkQmVCZWhpbmRPdmVybGF5KG92ZXJsYXksIGN1cnJlbnRPdmVybGF5KSkge1xuICAgICAgLy8gVGhpcyBidW1wcyB0aGUgei1pbmRleCBvZiArMi5cbiAgICAgIHRoaXMuX2FwcGx5T3ZlcmxheVooY3VycmVudE92ZXJsYXksIG1pbmltdW1aKTtcbiAgICAgIGluc2VydGlvbkluZGV4LS07XG4gICAgICAvLyBVcGRhdGUgbWluaW11bVogdG8gbWF0Y2ggcHJldmlvdXMgb3ZlcmxheSdzIHotaW5kZXguXG4gICAgICB2YXIgcHJldmlvdXNPdmVybGF5ID0gdGhpcy5fb3ZlcmxheXNbaW5zZXJ0aW9uSW5kZXggLSAxXTtcbiAgICAgIG1pbmltdW1aID0gTWF0aC5tYXgodGhpcy5fZ2V0WihwcmV2aW91c092ZXJsYXkpLCB0aGlzLl9taW5pbXVtWik7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHotaW5kZXggYW5kIGluc2VydCBvdmVybGF5LlxuICAgIGlmIChuZXdaIDw9IG1pbmltdW1aKSB7XG4gICAgICB0aGlzLl9hcHBseU92ZXJsYXlaKG92ZXJsYXksIG1pbmltdW1aKTtcbiAgICB9XG4gICAgdGhpcy5fb3ZlcmxheXMuc3BsaWNlKGluc2VydGlvbkluZGV4LCAwLCBvdmVybGF5KTtcblxuICAgIHRoaXMudHJhY2tCYWNrZHJvcCgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBvdmVybGF5XG4gICAqL1xuICByZW1vdmVPdmVybGF5OiBmdW5jdGlvbihvdmVybGF5KSB7XG4gICAgdmFyIGkgPSB0aGlzLl9vdmVybGF5cy5pbmRleE9mKG92ZXJsYXkpO1xuICAgIGlmIChpID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9vdmVybGF5cy5zcGxpY2UoaSwgMSk7XG5cbiAgICB0aGlzLnRyYWNrQmFja2Ryb3AoKTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBvdmVybGF5LlxuICAgKiBAcmV0dXJuIHtFbGVtZW50fHVuZGVmaW5lZH1cbiAgICovXG4gIGN1cnJlbnRPdmVybGF5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgaSA9IHRoaXMuX292ZXJsYXlzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIHRoaXMuX292ZXJsYXlzW2ldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IG92ZXJsYXkgei1pbmRleC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgY3VycmVudE92ZXJsYXlaOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Wih0aGlzLmN1cnJlbnRPdmVybGF5KCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoYXQgdGhlIG1pbmltdW0gei1pbmRleCBvZiBuZXcgb3ZlcmxheXMgaXMgYXQgbGVhc3QgYG1pbmltdW1aYC5cbiAgICogVGhpcyBkb2VzIG5vdCBlZmZlY3QgdGhlIHotaW5kZXggb2YgYW55IGV4aXN0aW5nIG92ZXJsYXlzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gbWluaW11bVpcbiAgICovXG4gIGVuc3VyZU1pbmltdW1aOiBmdW5jdGlvbihtaW5pbXVtWikge1xuICAgIHRoaXMuX21pbmltdW1aID0gTWF0aC5tYXgodGhpcy5fbWluaW11bVosIG1pbmltdW1aKTtcbiAgfSxcblxuICBmb2N1c092ZXJsYXk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjdXJyZW50ID0gLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5jdXJyZW50T3ZlcmxheSgpKTtcbiAgICBpZiAoY3VycmVudCkge1xuICAgICAgY3VycmVudC5fYXBwbHlGb2N1cygpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgYmFja2Ryb3Agei1pbmRleC5cbiAgICovXG4gIHRyYWNrQmFja2Ryb3A6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBvdmVybGF5ID0gdGhpcy5fb3ZlcmxheVdpdGhCYWNrZHJvcCgpO1xuICAgIC8vIEF2b2lkIGNyZWF0aW5nIHRoZSBiYWNrZHJvcCBpZiB0aGVyZSBpcyBubyBvdmVybGF5IHdpdGggYmFja2Ryb3AuXG4gICAgaWYgKCFvdmVybGF5ICYmICF0aGlzLl9iYWNrZHJvcEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5iYWNrZHJvcEVsZW1lbnQuc3R5bGUuekluZGV4ID0gdGhpcy5fZ2V0WihvdmVybGF5KSAtIDE7XG4gICAgdGhpcy5iYWNrZHJvcEVsZW1lbnQub3BlbmVkID0gISFvdmVybGF5O1xuICAgIC8vIFByb3BlcnR5IG9ic2VydmVycyBhcmUgbm90IGZpcmVkIHVudGlsIGVsZW1lbnQgaXMgYXR0YWNoZWRcbiAgICAvLyBpbiBQb2x5bWVyIDIueCwgc28gd2UgZW5zdXJlIGVsZW1lbnQgaXMgYXR0YWNoZWQgaWYgbmVlZGVkLlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9Qb2x5bWVyL3BvbHltZXIvaXNzdWVzLzQ1MjZcbiAgICB0aGlzLmJhY2tkcm9wRWxlbWVudC5wcmVwYXJlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PEVsZW1lbnQ+fVxuICAgKi9cbiAgZ2V0QmFja2Ryb3BzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgYmFja2Ryb3BzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9vdmVybGF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX292ZXJsYXlzW2ldLndpdGhCYWNrZHJvcCkge1xuICAgICAgICBiYWNrZHJvcHMucHVzaCh0aGlzLl9vdmVybGF5c1tpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBiYWNrZHJvcHM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHotaW5kZXggZm9yIHRoZSBiYWNrZHJvcC5cbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgYmFja2Ryb3BaOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0Wih0aGlzLl9vdmVybGF5V2l0aEJhY2tkcm9wKCkpIC0gMTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3Qgb3BlbmVkIG92ZXJsYXkgdGhhdCBoYXMgYSBiYWNrZHJvcC5cbiAgICogQHJldHVybiB7RWxlbWVudHx1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb3ZlcmxheVdpdGhCYWNrZHJvcDogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9vdmVybGF5cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRoaXMuX292ZXJsYXlzW2ldLndpdGhCYWNrZHJvcCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb3ZlcmxheXNbaV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBtaW5pbXVtIHotaW5kZXggZm9yIHRoZSBvdmVybGF5LlxuICAgKiBAcGFyYW0ge0VsZW1lbnQ9fSBvdmVybGF5XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0WjogZnVuY3Rpb24ob3ZlcmxheSkge1xuICAgIHZhciB6ID0gdGhpcy5fbWluaW11bVo7XG4gICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgIHZhciB6MSA9IE51bWJlcihvdmVybGF5LnN0eWxlLnpJbmRleCB8fCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShvdmVybGF5KS56SW5kZXgpO1xuICAgICAgLy8gQ2hlY2sgaWYgaXMgYSBudW1iZXJcbiAgICAgIC8vIE51bWJlci5pc05hTiBub3Qgc3VwcG9ydGVkIGluIElFIDEwK1xuICAgICAgaWYgKHoxID09PSB6MSkge1xuICAgICAgICB6ID0gejE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB6O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gelxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3NldFo6IGZ1bmN0aW9uKGVsZW1lbnQsIHopIHtcbiAgICBlbGVtZW50LnN0eWxlLnpJbmRleCA9IHo7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG92ZXJsYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IGFib3ZlWlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2FwcGx5T3ZlcmxheVo6IGZ1bmN0aW9uKG92ZXJsYXksIGFib3ZlWikge1xuICAgIHRoaXMuX3NldFoob3ZlcmxheSwgYWJvdmVaICsgMik7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZXBlc3Qgb3ZlcmxheSBpbiB0aGUgcGF0aC5cbiAgICogQHBhcmFtIHtBcnJheTxFbGVtZW50Pj19IHBhdGhcbiAgICogQHJldHVybiB7RWxlbWVudHx1bmRlZmluZWR9XG4gICAqIEBzdXBwcmVzcyB7bWlzc2luZ1Byb3BlcnRpZXN9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb3ZlcmxheUluUGF0aDogZnVuY3Rpb24ocGF0aCkge1xuICAgIHBhdGggPSBwYXRoIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0uX21hbmFnZXIgPT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHBhdGhbaV07XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSBjbGljayBldmVudCBpcyBkZWxlZ2F0ZWQgdG8gdGhlIHJpZ2h0IG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2FwdHVyZUNsaWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBvdmVybGF5ID0gLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5jdXJyZW50T3ZlcmxheSgpKTtcbiAgICAvLyBDaGVjayBpZiBjbGlja2VkIG91dHNpZGUgb2YgdG9wIG92ZXJsYXkuXG4gICAgaWYgKG92ZXJsYXkgJiYgdGhpcy5fb3ZlcmxheUluUGF0aChkb20oZXZlbnQpLnBhdGgpICE9PSBvdmVybGF5KSB7XG4gICAgICBvdmVybGF5Ll9vbkNhcHR1cmVDbGljayhldmVudCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBFbnN1cmVzIHRoZSBmb2N1cyBldmVudCBpcyBkZWxlZ2F0ZWQgdG8gdGhlIHJpZ2h0IG92ZXJsYXkuXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldmVudFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX29uQ2FwdHVyZUZvY3VzOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciBvdmVybGF5ID0gLyoqIEB0eXBlIHs/fSAqLyAodGhpcy5jdXJyZW50T3ZlcmxheSgpKTtcbiAgICBpZiAob3ZlcmxheSkge1xuICAgICAgb3ZlcmxheS5fb25DYXB0dXJlRm9jdXMoZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRW5zdXJlcyBUQUIgYW5kIEVTQyBrZXlib2FyZCBldmVudHMgYXJlIGRlbGVnYXRlZCB0byB0aGUgcmlnaHQgb3ZlcmxheS5cbiAgICogQHBhcmFtIHshRXZlbnR9IGV2ZW50XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb25DYXB0dXJlS2V5RG93bjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgb3ZlcmxheSA9IC8qKiBAdHlwZSB7P30gKi8gKHRoaXMuY3VycmVudE92ZXJsYXkoKSk7XG4gICAgaWYgKG92ZXJsYXkpIHtcbiAgICAgIGlmIChJcm9uQTExeUtleXNCZWhhdmlvci5rZXlib2FyZEV2ZW50TWF0Y2hlc0tleXMoZXZlbnQsICdlc2MnKSkge1xuICAgICAgICBvdmVybGF5Ll9vbkNhcHR1cmVFc2MoZXZlbnQpO1xuICAgICAgfSBlbHNlIGlmIChJcm9uQTExeUtleXNCZWhhdmlvci5rZXlib2FyZEV2ZW50TWF0Y2hlc0tleXMoZXZlbnQsICd0YWInKSkge1xuICAgICAgICBvdmVybGF5Ll9vbkNhcHR1cmVUYWIoZXZlbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBpZiB0aGUgb3ZlcmxheTEgc2hvdWxkIGJlIGJlaGluZCBvdmVybGF5Mi5cbiAgICogQHBhcmFtIHshRWxlbWVudH0gb3ZlcmxheTFcbiAgICogQHBhcmFtIHshRWxlbWVudH0gb3ZlcmxheTJcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICogQHN1cHByZXNzIHttaXNzaW5nUHJvcGVydGllc31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9zaG91bGRCZUJlaGluZE92ZXJsYXk6IGZ1bmN0aW9uKG92ZXJsYXkxLCBvdmVybGF5Mikge1xuICAgIHJldHVybiAhb3ZlcmxheTEuYWx3YXlzT25Ub3AgJiYgb3ZlcmxheTIuYWx3YXlzT25Ub3A7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBJcm9uT3ZlcmxheU1hbmFnZXIgPSBuZXcgSXJvbk92ZXJsYXlNYW5hZ2VyQ2xhc3MoKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tb3ZlcmxheS1iZWhhdmlvci9pcm9uLW92ZXJsYXktbWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gNzhcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5cblBvbHltZXIoe1xuICBfdGVtcGxhdGU6IGBcbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgaGVpZ2h0OiAxMDAlO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1pcm9uLW92ZXJsYXktYmFja2Ryb3AtYmFja2dyb3VuZC1jb2xvciwgIzAwMCk7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4ycztcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIEBhcHBseSAtLWlyb24tb3ZlcmxheS1iYWNrZHJvcDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoLm9wZW5lZCkge1xuICAgICAgICBvcGFjaXR5OiB2YXIoLS1pcm9uLW92ZXJsYXktYmFja2Ryb3Atb3BhY2l0eSwgMC42KTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IGF1dG87XG4gICAgICAgIEBhcHBseSAtLWlyb24tb3ZlcmxheS1iYWNrZHJvcC1vcGVuZWQ7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxzbG90Pjwvc2xvdD5cbmAsXG5cbiAgaXM6ICdpcm9uLW92ZXJsYXktYmFja2Ryb3AnLFxuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgYmFja2Ryb3AgaXMgb3BlbmVkLlxuICAgICAqL1xuICAgIG9wZW5lZDoge1xuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG9ic2VydmVyOiAnX29wZW5lZENoYW5nZWQnXG4gICAgfVxuXG4gIH0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgJ3RyYW5zaXRpb25lbmQnOiAnX29uVHJhbnNpdGlvbmVuZCdcbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBVc2VkIHRvIGNhbmNlbCBwcmV2aW91cyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgY2FsbHMgd2hlbiBvcGVuZWQgY2hhbmdlcy5cbiAgICB0aGlzLl9fb3BlbmVkUmFmID0gbnVsbDtcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5vcGVuZWQgJiYgdGhpcy5fb3BlbmVkQ2hhbmdlZCh0aGlzLm9wZW5lZCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGJhY2tkcm9wIHRvIGRvY3VtZW50IGJvZHkgaWYgbmVlZGVkLlxuICAgKi9cbiAgcHJlcGFyZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMub3BlbmVkICYmICF0aGlzLnBhcmVudE5vZGUpIHtcbiAgICAgIGRvbShkb2N1bWVudC5ib2R5KS5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNob3dzIHRoZSBiYWNrZHJvcC5cbiAgICovXG4gIG9wZW46IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3BlbmVkID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogSGlkZXMgdGhlIGJhY2tkcm9wLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgdGhlIGJhY2tkcm9wIGZyb20gZG9jdW1lbnQgYm9keSBpZiBuZWVkZWQuXG4gICAqL1xuICBjb21wbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLm9wZW5lZCAmJiB0aGlzLnBhcmVudE5vZGUgPT09IGRvY3VtZW50LmJvZHkpIHtcbiAgICAgIGRvbSh0aGlzLnBhcmVudE5vZGUpLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgIH1cbiAgfSxcblxuICBfb25UcmFuc2l0aW9uZW5kOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmIChldmVudCAmJiBldmVudC50YXJnZXQgPT09IHRoaXMpIHtcbiAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gb3BlbmVkXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfb3BlbmVkQ2hhbmdlZDogZnVuY3Rpb24ob3BlbmVkKSB7XG4gICAgaWYgKG9wZW5lZCkge1xuICAgICAgLy8gQXV0by1hdHRhY2guXG4gICAgICB0aGlzLnByZXBhcmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQW5pbWF0aW9uIG1pZ2h0IGJlIGRpc2FibGVkIHZpYSB0aGUgbWl4aW4gb3Igb3BhY2l0eSBjdXN0b20gcHJvcGVydHkuXG4gICAgICAvLyBJZiBpdCBpcyBkaXNhYmxlZCBpbiBvdGhlciB3YXlzLCBpdCdzIHVwIHRvIHRoZSB1c2VyIHRvIGNhbGwgY29tcGxldGUuXG4gICAgICB2YXIgY3MgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKTtcbiAgICAgIGlmIChjcy50cmFuc2l0aW9uRHVyYXRpb24gPT09ICcwcycgfHwgY3Mub3BhY2l0eSA9PSAwKSB7XG4gICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuaXNBdHRhY2hlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEFsd2F5cyBjYW5jZWwgcHJldmlvdXMgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxuICAgIGlmICh0aGlzLl9fb3BlbmVkUmFmKSB7XG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fX29wZW5lZFJhZik7XG4gICAgICB0aGlzLl9fb3BlbmVkUmFmID0gbnVsbDtcbiAgICB9XG4gICAgLy8gRm9yY2UgcmVsYXlvdXQgdG8gZW5zdXJlIHByb3BlciB0cmFuc2l0aW9ucy5cbiAgICB0aGlzLnNjcm9sbFRvcCA9IHRoaXMuc2Nyb2xsVG9wO1xuICAgIHRoaXMuX19vcGVuZWRSYWYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5fX29wZW5lZFJhZiA9IG51bGw7XG4gICAgICB0aGlzLnRvZ2dsZUNsYXNzKCdvcGVuZWQnLCB0aGlzLm9wZW5lZCk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW92ZXJsYXktYmVoYXZpb3IvaXJvbi1vdmVybGF5LWJhY2tkcm9wLmpzXG4vLyBtb2R1bGUgaWQgPSA3OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBkb20gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi9sZWdhY3kvcG9seW1lci5kb20uanMnO1xuXG52YXIgcCA9IEVsZW1lbnQucHJvdG90eXBlO1xudmFyIG1hdGNoZXMgPSBwLm1hdGNoZXMgfHwgcC5tYXRjaGVzU2VsZWN0b3IgfHwgcC5tb3pNYXRjaGVzU2VsZWN0b3IgfHxcbiAgcC5tc01hdGNoZXNTZWxlY3RvciB8fCBwLm9NYXRjaGVzU2VsZWN0b3IgfHwgcC53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG5cbmV4cG9ydCBjb25zdCBJcm9uRm9jdXNhYmxlc0hlbHBlciA9IHtcblxuICAvKipcbiAgICogUmV0dXJucyBhIHNvcnRlZCBhcnJheSBvZiB0YWJiYWJsZSBub2RlcywgaW5jbHVkaW5nIHRoZSByb290IG5vZGUuXG4gICAqIEl0IHNlYXJjaGVzIHRoZSB0YWJiYWJsZSBub2RlcyBpbiB0aGUgbGlnaHQgYW5kIHNoYWRvdyBkb20gb2YgdGhlIGNoaWRyZW4sXG4gICAqIHNvcnRpbmcgdGhlIHJlc3VsdCBieSB0YWJpbmRleC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59XG4gICAqL1xuICBnZXRUYWJiYWJsZU5vZGVzOiBmdW5jdGlvbihub2RlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIC8vIElmIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBlbGVtZW50IHdpdGggdGFiaW5kZXggPiAwLCB3ZSBuZWVkIHRvIHNvcnRcbiAgICAvLyB0aGUgZmluYWwgYXJyYXkgYnkgdGFiaW5kZXguXG4gICAgdmFyIG5lZWRzU29ydEJ5VGFiSW5kZXggPSB0aGlzLl9jb2xsZWN0VGFiYmFibGVOb2Rlcyhub2RlLCByZXN1bHQpO1xuICAgIGlmIChuZWVkc1NvcnRCeVRhYkluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5fc29ydEJ5VGFiSW5kZXgocmVzdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBpZiBhIGVsZW1lbnQgaXMgZm9jdXNhYmxlLlxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNGb2N1c2FibGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAvLyBGcm9tIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2MDAxOTQvNDIyODcwMzpcbiAgICAvLyBUaGVyZSBpc24ndCBhIGRlZmluaXRlIGxpc3QsIGl0J3MgdXAgdG8gdGhlIGJyb3dzZXIuIFRoZSBvbmx5XG4gICAgLy8gc3RhbmRhcmQgd2UgaGF2ZSBpcyBET00gTGV2ZWwgMiBIVE1MIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMi1IVE1ML2h0bWwuaHRtbCxcbiAgICAvLyBhY2NvcmRpbmcgdG8gd2hpY2ggdGhlIG9ubHkgZWxlbWVudHMgdGhhdCBoYXZlIGEgZm9jdXMoKSBtZXRob2QgYXJlXG4gICAgLy8gSFRNTElucHV0RWxlbWVudCwgIEhUTUxTZWxlY3RFbGVtZW50LCBIVE1MVGV4dEFyZWFFbGVtZW50IGFuZFxuICAgIC8vIEhUTUxBbmNob3JFbGVtZW50LiBUaGlzIG5vdGFibHkgb21pdHMgSFRNTEJ1dHRvbkVsZW1lbnQgYW5kXG4gICAgLy8gSFRNTEFyZWFFbGVtZW50LlxuICAgIC8vIFJlZmVycmluZyB0byB0aGVzZSB0ZXN0cyB3aXRoIHRhYmJhYmxlcyBpbiBkaWZmZXJlbnQgYnJvd3NlcnNcbiAgICAvLyBodHRwOi8vYWxseWpzLmlvL2RhdGEtdGFibGVzL2ZvY3VzYWJsZS5odG1sXG5cbiAgICAvLyBFbGVtZW50cyB0aGF0IGNhbm5vdCBiZSBmb2N1c2VkIGlmIHRoZXkgaGF2ZSBbZGlzYWJsZWRdIGF0dHJpYnV0ZS5cbiAgICBpZiAobWF0Y2hlcy5jYWxsKGVsZW1lbnQsICdpbnB1dCwgc2VsZWN0LCB0ZXh0YXJlYSwgYnV0dG9uLCBvYmplY3QnKSkge1xuICAgICAgcmV0dXJuIG1hdGNoZXMuY2FsbChlbGVtZW50LCAnOm5vdChbZGlzYWJsZWRdKScpO1xuICAgIH1cbiAgICAvLyBFbGVtZW50cyB0aGF0IGNhbiBiZSBmb2N1c2VkIGV2ZW4gaWYgdGhleSBoYXZlIFtkaXNhYmxlZF0gYXR0cmlidXRlLlxuICAgIHJldHVybiBtYXRjaGVzLmNhbGwoZWxlbWVudCxcbiAgICAgICdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpZnJhbWUsIFt0YWJpbmRleF0sIFtjb250ZW50RWRpdGFibGVdJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgaWYgYSBlbGVtZW50IGlzIHRhYmJhYmxlLiBUbyBiZSB0YWJiYWJsZSwgYSBlbGVtZW50IG11c3QgYmVcbiAgICogZm9jdXNhYmxlLCB2aXNpYmxlLCBhbmQgd2l0aCBhIHRhYmluZGV4ICE9PSAtMS5cbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzVGFiYmFibGU6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5pc0ZvY3VzYWJsZShlbGVtZW50KSAmJlxuICAgICAgbWF0Y2hlcy5jYWxsKGVsZW1lbnQsICc6bm90KFt0YWJpbmRleD1cIi0xXCJdKScpICYmXG4gICAgICB0aGlzLl9pc1Zpc2libGUoZWxlbWVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5vcm1hbGl6ZWQgZWxlbWVudCB0YWJpbmRleC4gSWYgbm90IGZvY3VzYWJsZSwgcmV0dXJucyAtMS5cbiAgICogSXQgY2hlY2tzIGZvciB0aGUgYXR0cmlidXRlIFwidGFiaW5kZXhcIiBpbnN0ZWFkIG9mIHRoZSBlbGVtZW50IHByb3BlcnR5XG4gICAqIGB0YWJJbmRleGAgc2luY2UgYnJvd3NlcnMgYXNzaWduIGRpZmZlcmVudCB2YWx1ZXMgdG8gaXQuXG4gICAqIGUuZy4gaW4gRmlyZWZveCBgPGRpdiBjb250ZW50ZWRpdGFibGU+YCBoYXMgYHRhYkluZGV4ID0gLTFgXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4geyFudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfbm9ybWFsaXplZFRhYkluZGV4OiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKHRoaXMuaXNGb2N1c2FibGUoZWxlbWVudCkpIHtcbiAgICAgIHZhciB0YWJJbmRleCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpIHx8IDA7XG4gICAgICByZXR1cm4gTnVtYmVyKHRhYkluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZWFyY2hlcyBmb3Igbm9kZXMgdGhhdCBhcmUgdGFiYmFibGUgYW5kIGFkZHMgdGhlbSB0byB0aGUgYHJlc3VsdGAgYXJyYXkuXG4gICAqIFJldHVybnMgaWYgdGhlIGByZXN1bHRgIGFycmF5IG5lZWRzIHRvIGJlIHNvcnRlZCBieSB0YWJpbmRleC5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZSBUaGUgc3RhcnRpbmcgcG9pbnQgZm9yIHRoZSBzZWFyY2g7IGFkZGVkIHRvIGByZXN1bHRgXG4gICAqIGlmIHRhYmJhYmxlLlxuICAgKiBAcGFyYW0geyFBcnJheTxIVE1MRWxlbWVudD59IHJlc3VsdFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbGxlY3RUYWJiYWJsZU5vZGVzOiBmdW5jdGlvbihub2RlLCByZXN1bHQpIHtcbiAgICAvLyBJZiBub3QgYW4gZWxlbWVudCBvciBub3QgdmlzaWJsZSwgbm8gbmVlZCB0byBleHBsb3JlIGNoaWxkcmVuLlxuICAgIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSB8fCAhdGhpcy5faXNWaXNpYmxlKG5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBlbGVtZW50ID0gLyoqIEB0eXBlIHtIVE1MRWxlbWVudH0gKi8gKG5vZGUpO1xuICAgIHZhciB0YWJJbmRleCA9IHRoaXMuX25vcm1hbGl6ZWRUYWJJbmRleChlbGVtZW50KTtcbiAgICB2YXIgbmVlZHNTb3J0ID0gdGFiSW5kZXggPiAwO1xuICAgIGlmICh0YWJJbmRleCA+PSAwKSB7XG4gICAgICByZXN1bHQucHVzaChlbGVtZW50KTtcbiAgICB9XG5cbiAgICAvLyBJbiBTaGFkb3dET00gdjEsIHRhYiBvcmRlciBpcyBhZmZlY3RlZCBieSB0aGUgb3JkZXIgb2YgZGlzdHJ1YnV0aW9uLlxuICAgIC8vIEUuZy4gZ2V0VGFiYmFibGVOb2Rlcygjcm9vdCkgaW4gU2hhZG93RE9NIHYxIHNob3VsZCByZXR1cm4gWyNBLCAjQl07XG4gICAgLy8gaW4gU2hhZG93RE9NIHYwIHRhYiBvcmRlciBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIGRpc3RydWJ1dGlvbiBvcmRlcixcbiAgICAvLyBpbiBmYWN0IGdldFRhYmJhYmxlTm9kZXMoI3Jvb3QpIHJldHVybnMgWyNCLCAjQV0uXG4gICAgLy8gIDxkaXYgaWQ9XCJyb290XCI+XG4gICAgLy8gICA8IS0tIHNoYWRvdyAtLT5cbiAgICAvLyAgICAgPHNsb3QgbmFtZT1cImFcIj5cbiAgICAvLyAgICAgPHNsb3QgbmFtZT1cImJcIj5cbiAgICAvLyAgIDwhLS0gL3NoYWRvdyAtLT5cbiAgICAvLyAgIDxpbnB1dCBpZD1cIkFcIiBzbG90PVwiYVwiPlxuICAgIC8vICAgPGlucHV0IGlkPVwiQlwiIHNsb3Q9XCJiXCIgdGFiaW5kZXg9XCIxXCI+XG4gICAgLy8gIDwvZGl2PlxuICAgIC8vIFRPRE8odmFsZHJpbikgc3VwcG9ydCBTaGFkb3dET00gdjEgd2hlbiB1cGdyYWRpbmcgdG8gUG9seW1lciB2Mi4wLlxuICAgIHZhciBjaGlsZHJlbjtcbiAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdjb250ZW50JyB8fCBlbGVtZW50LmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICBjaGlsZHJlbiA9IGRvbShlbGVtZW50KS5nZXREaXN0cmlidXRlZE5vZGVzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVzZSBzaGFkb3cgcm9vdCBpZiBwb3NzaWJsZSwgd2lsbCBjaGVjayBmb3IgZGlzdHJpYnV0ZWQgbm9kZXMuXG4gICAgICBjaGlsZHJlbiA9IGRvbShlbGVtZW50LnJvb3QgfHwgZWxlbWVudCkuY2hpbGRyZW47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIEVuc3VyZSBtZXRob2QgaXMgYWx3YXlzIGludm9rZWQgdG8gY29sbGVjdCB0YWJiYWJsZSBjaGlsZHJlbi5cbiAgICAgIG5lZWRzU29ydCA9IHRoaXMuX2NvbGxlY3RUYWJiYWJsZU5vZGVzKGNoaWxkcmVuW2ldLCByZXN1bHQpIHx8IG5lZWRzU29ydDtcbiAgICB9XG4gICAgcmV0dXJuIG5lZWRzU29ydDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgZWxlbWVudCBoYXMgYHZpc2liaWxpdHk6IGhpZGRlbmAgb3IgYGRpc3BsYXk6IG5vbmVgXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaXNWaXNpYmxlOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgLy8gQ2hlY2sgaW5saW5lIHN0eWxlIGZpcnN0IHRvIHNhdmUgYSByZS1mbG93LiBJZiBsb29rcyBnb29kLCBjaGVjayBhbHNvXG4gICAgLy8gY29tcHV0ZWQgc3R5bGUuXG4gICAgdmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBpZiAoc3R5bGUudmlzaWJpbGl0eSAhPT0gJ2hpZGRlbicgJiYgc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIChzdHlsZS52aXNpYmlsaXR5ICE9PSAnaGlkZGVuJyAmJiBzdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNvcnRzIGFuIGFycmF5IG9mIHRhYmJhYmxlIGVsZW1lbnRzIGJ5IHRhYmluZGV4LiBSZXR1cm5zIGEgbmV3IGFycmF5LlxuICAgKiBAcGFyYW0geyFBcnJheTxIVE1MRWxlbWVudD59IHRhYmJhYmxlc1xuICAgKiBAcmV0dXJuIHtBcnJheTxIVE1MRWxlbWVudD59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc29ydEJ5VGFiSW5kZXg6IGZ1bmN0aW9uKHRhYmJhYmxlcykge1xuICAgIC8vIEltcGxlbWVudCBhIG1lcmdlIHNvcnQgYXMgQXJyYXkucHJvdG90eXBlLnNvcnQgZG9lcyBhIG5vbi1zdGFibGUgc29ydFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L3NvcnRcbiAgICB2YXIgbGVuID0gdGFiYmFibGVzLmxlbmd0aDtcbiAgICBpZiAobGVuIDwgMikge1xuICAgICAgcmV0dXJuIHRhYmJhYmxlcztcbiAgICB9XG4gICAgdmFyIHBpdm90ID0gTWF0aC5jZWlsKGxlbiAvIDIpO1xuICAgIHZhciBsZWZ0ID0gdGhpcy5fc29ydEJ5VGFiSW5kZXgodGFiYmFibGVzLnNsaWNlKDAsIHBpdm90KSk7XG4gICAgdmFyIHJpZ2h0ID0gdGhpcy5fc29ydEJ5VGFiSW5kZXgodGFiYmFibGVzLnNsaWNlKHBpdm90KSk7XG4gICAgcmV0dXJuIHRoaXMuX21lcmdlU29ydEJ5VGFiSW5kZXgobGVmdCwgcmlnaHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZSBzb3J0IGl0ZXJhdG9yLCBtZXJnZXMgdGhlIHR3byBhcnJheXMgaW50byBvbmUsIHNvcnRlZCBieSB0YWIgaW5kZXguXG4gICAqIEBwYXJhbSB7IUFycmF5PEhUTUxFbGVtZW50Pn0gbGVmdFxuICAgKiBAcGFyYW0geyFBcnJheTxIVE1MRWxlbWVudD59IHJpZ2h0XG4gICAqIEByZXR1cm4ge0FycmF5PEhUTUxFbGVtZW50Pn1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tZXJnZVNvcnRCeVRhYkluZGV4OiBmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB3aGlsZSAoKGxlZnQubGVuZ3RoID4gMCkgJiYgKHJpZ2h0Lmxlbmd0aCA+IDApKSB7XG4gICAgICBpZiAodGhpcy5faGFzTG93ZXJUYWJPcmRlcihsZWZ0WzBdLCByaWdodFswXSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocmlnaHQuc2hpZnQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQucHVzaChsZWZ0LnNoaWZ0KCkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQuY29uY2F0KGxlZnQsIHJpZ2h0KTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBpZiBlbGVtZW50IGBhYCBoYXMgbG93ZXIgdGFiIG9yZGVyIGNvbXBhcmVkIHRvIGVsZW1lbnQgYGJgXG4gICAqIChib3RoIGVsZW1lbnRzIGFyZSBhc3N1bWVkIHRvIGJlIGZvY3VzYWJsZSBhbmQgdGFiYmFibGUpLlxuICAgKiBFbGVtZW50cyB3aXRoIHRhYmluZGV4ID0gMCBoYXZlIGxvd2VyIHRhYiBvcmRlciBjb21wYXJlZCB0byBlbGVtZW50c1xuICAgKiB3aXRoIHRhYmluZGV4ID4gMC5cbiAgICogSWYgYm90aCBoYXZlIHNhbWUgdGFiaW5kZXgsIGl0IHJldHVybnMgZmFsc2UuXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBhXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBiXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaGFzTG93ZXJUYWJPcmRlcjogZnVuY3Rpb24oYSwgYikge1xuICAgIC8vIE5vcm1hbGl6ZSB0YWJJbmRleGVzXG4gICAgLy8gZS5nLiBpbiBGaXJlZm94IGA8ZGl2IGNvbnRlbnRlZGl0YWJsZT5gIGhhcyBgdGFiSW5kZXggPSAtMWBcbiAgICB2YXIgYXRpID0gTWF0aC5tYXgoYS50YWJJbmRleCwgMCk7XG4gICAgdmFyIGJ0aSA9IE1hdGgubWF4KGIudGFiSW5kZXgsIDApO1xuICAgIHJldHVybiAoYXRpID09PSAwIHx8IGJ0aSA9PT0gMCkgPyBidGkgPiBhdGkgOiBhdGkgPiBidGk7XG4gIH1cbn07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW92ZXJsYXktYmVoYXZpb3IvaXJvbi1mb2N1c2FibGVzLWhlbHBlci5qc1xuLy8gbW9kdWxlIGlkID0gODBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvZGVmYXVsdC10aGVtZS5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy90eXBvZ3JhcGh5LmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL3NoYWRvdy5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci1kaWFsb2ctc2hhcmVkLXN0eWxlc1wiPlxuICA8dGVtcGxhdGU+XG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgbWFyZ2luOiAyNHB4IDQwcHg7XG5cbiAgICAgICAgYmFja2dyb3VuZDogdmFyKC0tcGFwZXItZGlhbG9nLWJhY2tncm91bmQtY29sb3IsIHZhcigtLXByaW1hcnktYmFja2dyb3VuZC1jb2xvcikpO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItZGlhbG9nLWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWJvZHkxO1xuICAgICAgICBAYXBwbHkgLS1zaGFkb3ctZWxldmF0aW9uLTE2ZHA7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWRpYWxvZztcbiAgICAgIH1cblxuICAgICAgOmhvc3QgPiA6OnNsb3R0ZWQoKikge1xuICAgICAgICBtYXJnaW4tdG9wOiAyMHB4O1xuICAgICAgICBwYWRkaW5nOiAwIDI0cHg7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gOjpzbG90dGVkKC5uby1wYWRkaW5nKSB7XG4gICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICB9XG5cbiAgICAgIC8qIEluIDEueCwgdGhpcyBzZWxlY3RvciB3YXMgXFxgOmhvc3QgPiA6OmNvbnRlbnQgaDJcXGAuIEluIDIueCA8c2xvdD4gYWxsb3dzXG4gICAgICB0byBzZWxlY3QgZGlyZWN0IGNoaWxkcmVuIG9ubHksIHdoaWNoIGluY3JlYXNlcyB0aGUgd2VpZ2h0IG9mIHRoaXNcbiAgICAgIHNlbGVjdG9yLCBzbyB3ZSBoYXZlIHRvIG1vdmUgaXQgYmVmb3JlIGZpcnN0LWNoaWxkL2xhc3QtY2hpbGQgc2VsZWN0b3JzICovXG4gICAgICA6aG9zdCA+IDo6c2xvdHRlZChoMikge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIG1hcmdpbjogMDtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LXRpdGxlO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1kaWFsb2ctdGl0bGU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gOjpzbG90dGVkKCo6Zmlyc3QtY2hpbGQpIHtcbiAgICAgICAgbWFyZ2luLXRvcDogMjRweDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QgPiA6OnNsb3R0ZWQoKjpsYXN0LWNoaWxkKSB7XG4gICAgICAgIG1hcmdpbi1ib3R0b206IDI0cHg7XG4gICAgICB9XG5cbiAgICAgIDpob3N0ID4gOjpzbG90dGVkKC5idXR0b25zKSB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgcGFkZGluZzogOHB4IDhweCA4cHggMjRweDtcbiAgICAgICAgbWFyZ2luOiAwO1xuXG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1kaWFsb2ctYnV0dG9uLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWhvcml6b250YWw7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1lbmQtanVzdGlmaWVkO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG4gIDwvdGVtcGxhdGU+XG48L2RvbS1tb2R1bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWRpYWxvZy1iZWhhdmlvci9wYXBlci1kaWFsb2ctc2hhcmVkLXN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gODFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYFxuPGxpbmsgcmVsPVwic3R5bGVzaGVldFwiIHR5cGU9XCJ0ZXh0L2Nzc1wiIGhyZWY9XCJodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2Nzcz9mYW1pbHk9Um9ib3RvK01vbm86NDAwLDcwMHxSb2JvdG86NDAwLDMwMCwzMDBpdGFsaWMsNDAwaXRhbGljLDUwMCw1MDBpdGFsaWMsNzAwLDcwMGl0YWxpY1wiIGNyb3Nzb3JpZ2luPVwiYW5vbnltb3VzXCI+XG5gO1xuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2ZvbnQtcm9ib3RvL3JvYm90by5qc1xuLy8gbW9kdWxlIGlkID0gODJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9pcm9uLWZsZXgtbGF5b3V0L2lyb24tZmxleC1sYXlvdXQuanMnO1xuaW1wb3J0IHsgUGFwZXJCdXR0b25CZWhhdmlvciwgUGFwZXJCdXR0b25CZWhhdmlvckltcGwgfSBmcm9tICcuLi9wYXBlci1iZWhhdmlvcnMvcGFwZXItYnV0dG9uLWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL2VsZW1lbnQtc3R5bGVzL3BhcGVyLW1hdGVyaWFsLXN0eWxlcy5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuY29uc3QgJF9kb2N1bWVudENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuJF9kb2N1bWVudENvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgJ2Rpc3BsYXk6IG5vbmU7Jyk7XG5cbiRfZG9jdW1lbnRDb250YWluZXIuaW5uZXJIVE1MID0gYDxkb20tbW9kdWxlIGlkPVwicGFwZXItYnV0dG9uXCI+XG4gIDx0ZW1wbGF0ZSBzdHJpcC13aGl0ZXNwYWNlPVwiXCI+XG4gICAgPHN0eWxlIGluY2x1ZGU9XCJwYXBlci1tYXRlcmlhbC1zdHlsZXNcIj5cbiAgICAgIC8qIE5lZWQgdG8gc3BlY2lmeSB0aGUgc2FtZSBzcGVjaWZpY2l0eSBhcyB0aGUgc3R5bGVzIGltcG9ydGVkIGZyb20gcGFwZXItbWF0ZXJpYWwuICovXG4gICAgICA6aG9zdCB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1pbmxpbmU7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1jZW50ZXItY2VudGVyO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICAgIGJveC1zaXppbmc6IGJvcmRlci1ib3g7XG4gICAgICAgIG1pbi13aWR0aDogNS4xNGVtO1xuICAgICAgICBtYXJnaW46IDAgMC4yOWVtO1xuICAgICAgICBiYWNrZ3JvdW5kOiB0cmFuc3BhcmVudDtcbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiByZ2JhKDAsIDAsIDAsIDApO1xuICAgICAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xuICAgICAgICBmb250OiBpbmhlcml0O1xuICAgICAgICB0ZXh0LXRyYW5zZm9ybTogdXBwZXJjYXNlO1xuICAgICAgICBvdXRsaW5lLXdpZHRoOiAwO1xuICAgICAgICBib3JkZXItcmFkaXVzOiAzcHg7XG4gICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgIGN1cnNvcjogcG9pbnRlcjtcbiAgICAgICAgei1pbmRleDogMDtcbiAgICAgICAgcGFkZGluZzogMC43ZW0gMC41N2VtO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2VsZXZhdGlvbj1cIjFcIl0pIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTE7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtlbGV2YXRpb249XCIyXCJdKSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi0yO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZWxldmF0aW9uPVwiM1wiXSkge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tMztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2VsZXZhdGlvbj1cIjRcIl0pIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtlbGV2YXRpb249XCI1XCJdKSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi01O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGlkZGVuXSkge1xuICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtyYWlzZWRdLmtleWJvYXJkLWZvY3VzKSB7XG4gICAgICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1idXR0b24tcmFpc2VkLWtleWJvYXJkLWZvY3VzO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCg6bm90KFtyYWlzZWRdKS5rZXlib2FyZC1mb2N1cykge1xuICAgICAgICBmb250LXdlaWdodDogYm9sZDtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItYnV0dG9uLWZsYXQta2V5Ym9hcmQtZm9jdXM7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIHtcbiAgICAgICAgYmFja2dyb3VuZDogI2VhZWFlYTtcbiAgICAgICAgY29sb3I6ICNhOGE4YTg7XG4gICAgICAgIGN1cnNvcjogYXV0bztcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItYnV0dG9uLWRpc2FibGVkO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbYW5pbWF0ZWRdKSB7XG4gICAgICAgIEBhcHBseSAtLXNoYWRvdy10cmFuc2l0aW9uO1xuICAgICAgfVxuXG4gICAgICBwYXBlci1yaXBwbGUge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItYnV0dG9uLWluay1jb2xvcik7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxzbG90Pjwvc2xvdD5cbiAgPC90ZW1wbGF0ZT5cblxuICBcbjwvZG9tLW1vZHVsZT5gO1xuXG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuUG9seW1lcih7XG4gIGlzOiAncGFwZXItYnV0dG9uJyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBQYXBlckJ1dHRvbkJlaGF2aW9yXG4gIF0sXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSBidXR0b24gc2hvdWxkIGJlIHN0eWxlZCB3aXRoIGEgc2hhZG93LlxuICAgICAqL1xuICAgIHJhaXNlZDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlZmxlY3RUb0F0dHJpYnV0ZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgIG9ic2VydmVyOiAnX2NhbGN1bGF0ZUVsZXZhdGlvbidcbiAgICB9XG4gIH0sXG5cbiAgX2NhbGN1bGF0ZUVsZXZhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnJhaXNlZCkge1xuICAgICAgdGhpcy5fc2V0RWxldmF0aW9uKDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBQYXBlckJ1dHRvbkJlaGF2aW9ySW1wbC5fY2FsY3VsYXRlRWxldmF0aW9uLmFwcGx5KHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICBGaXJlZCB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMuXG4gIFRoaXMgaXMgdXNlZnVsIGlmIHlvdSB3YW50IHRvIHdhaXQgdW50aWxcbiAgdGhlIHJpcHBsZSBhbmltYXRpb24gZmluaXNoZXMgdG8gcGVyZm9ybSBzb21lIGFjdGlvbi5cblxuICBAZXZlbnQgdHJhbnNpdGlvbmVuZFxuICBFdmVudCBwYXJhbToge3tub2RlOiBPYmplY3R9fSBkZXRhaWwgQ29udGFpbnMgdGhlIGFuaW1hdGVkIG5vZGUuXG4gICovXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWJ1dHRvbi9wYXBlci1idXR0b24uanNcbi8vIG1vZHVsZSBpZCA9IDgzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCB7IElyb25CdXR0b25TdGF0ZUltcGwsIElyb25CdXR0b25TdGF0ZSB9IGZyb20gJy4uL2lyb24tYmVoYXZpb3JzL2lyb24tYnV0dG9uLXN0YXRlLmpzJztcbmltcG9ydCB7IFBhcGVyUmlwcGxlQmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBJcm9uQ29udHJvbFN0YXRlIH0gZnJvbSAnLi4vaXJvbi1iZWhhdmlvcnMvaXJvbi1jb250cm9sLXN0YXRlLmpzJztcblxuZXhwb3J0IGNvbnN0IFBhcGVyQnV0dG9uQmVoYXZpb3JJbXBsID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogVGhlIHotZGVwdGggb2YgdGhpcyBlbGVtZW50LCBmcm9tIDAtNS4gU2V0dGluZyB0byAwIHdpbGwgcmVtb3ZlIHRoZVxuICAgICAqIHNoYWRvdywgYW5kIGVhY2ggaW5jcmVhc2luZyBudW1iZXIgZ3JlYXRlciB0aGFuIDAgd2lsbCBiZSBcImRlZXBlclwiXG4gICAgICogdGhhbiB0aGUgbGFzdC5cbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgZWxldmF0aW9uXG4gICAgICogQHR5cGUgbnVtYmVyXG4gICAgICogQGRlZmF1bHQgMVxuICAgICAqL1xuICAgIGVsZXZhdGlvbjoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgcmVhZE9ubHk6IHRydWVcbiAgICB9XG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19jYWxjdWxhdGVFbGV2YXRpb24oZm9jdXNlZCwgZGlzYWJsZWQsIGFjdGl2ZSwgcHJlc3NlZCwgcmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCknLFxuICAgICdfY29tcHV0ZUtleWJvYXJkQ2xhc3MocmVjZWl2ZWRGb2N1c0Zyb21LZXlib2FyZCknXG4gIF0sXG5cbiAgaG9zdEF0dHJpYnV0ZXM6IHtcbiAgICByb2xlOiAnYnV0dG9uJyxcbiAgICB0YWJpbmRleDogJzAnLFxuICAgIGFuaW1hdGVkOiB0cnVlXG4gIH0sXG5cbiAgX2NhbGN1bGF0ZUVsZXZhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIGUgPSAxO1xuICAgIGlmICh0aGlzLmRpc2FibGVkKSB7XG4gICAgICBlID0gMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuYWN0aXZlIHx8IHRoaXMucHJlc3NlZCkge1xuICAgICAgZSA9IDQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLnJlY2VpdmVkRm9jdXNGcm9tS2V5Ym9hcmQpIHtcbiAgICAgIGUgPSAzO1xuICAgIH1cbiAgICB0aGlzLl9zZXRFbGV2YXRpb24oZSk7XG4gIH0sXG5cbiAgX2NvbXB1dGVLZXlib2FyZENsYXNzOiBmdW5jdGlvbihyZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKSB7XG4gICAgdGhpcy50b2dnbGVDbGFzcygna2V5Ym9hcmQtZm9jdXMnLCByZWNlaXZlZEZvY3VzRnJvbUtleWJvYXJkKTtcbiAgfSxcblxuICAvKipcbiAgICogSW4gYWRkaXRpb24gdG8gYElyb25CdXR0b25TdGF0ZWAgYmVoYXZpb3IsIHdoZW4gc3BhY2Uga2V5IGdvZXMgZG93bixcbiAgICogY3JlYXRlIGEgcmlwcGxlIGRvd24gZWZmZWN0LlxuICAgKlxuICAgKiBAcGFyYW0geyFLZXlib2FyZEV2ZW50fSBldmVudCAuXG4gICAqL1xuICBfc3BhY2VLZXlEb3duSGFuZGxlcjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBJcm9uQnV0dG9uU3RhdGVJbXBsLl9zcGFjZUtleURvd25IYW5kbGVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGF0IG1vc3Qgb25lIHJpcHBsZSB3aGVuIHRoZSBzcGFjZSBrZXkgaXMgaGVsZCBkb3duLlxuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpICYmIHRoaXMuZ2V0UmlwcGxlKCkucmlwcGxlcy5sZW5ndGggPCAxKSB7XG4gICAgICB0aGlzLl9yaXBwbGUudWlEb3duQWN0aW9uKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbiBhZGRpdGlvbiB0byBgSXJvbkJ1dHRvblN0YXRlYCBiZWhhdmlvciwgd2hlbiBzcGFjZSBrZXkgZ29lcyB1cCxcbiAgICogY3JlYXRlIGEgcmlwcGxlIHVwIGVmZmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHshS2V5Ym9hcmRFdmVudH0gZXZlbnQgLlxuICAgKi9cbiAgX3NwYWNlS2V5VXBIYW5kbGVyOiBmdW5jdGlvbihldmVudCkge1xuICAgIElyb25CdXR0b25TdGF0ZUltcGwuX3NwYWNlS2V5VXBIYW5kbGVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIGlmICh0aGlzLmhhc1JpcHBsZSgpKSB7XG4gICAgICB0aGlzLl9yaXBwbGUudWlVcEFjdGlvbigpO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IFBhcGVyQnV0dG9uQmVoYXZpb3IgPSBbXG4gIElyb25CdXR0b25TdGF0ZSxcbiAgSXJvbkNvbnRyb2xTdGF0ZSxcbiAgUGFwZXJSaXBwbGVCZWhhdmlvcixcbiAgUGFwZXJCdXR0b25CZWhhdmlvckltcGxcbl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1iZWhhdmlvcnMvcGFwZXItYnV0dG9uLWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA4NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQTExeUtleXNCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuXG52YXIgVXRpbGl0eSA9IHtcbiAgZGlzdGFuY2U6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIHhEZWx0YSA9ICh4MSAtIHgyKTtcbiAgICB2YXIgeURlbHRhID0gKHkxIC0geTIpO1xuXG4gICAgcmV0dXJuIE1hdGguc3FydCh4RGVsdGEgKiB4RGVsdGEgKyB5RGVsdGEgKiB5RGVsdGEpO1xuICB9LFxuXG4gIG5vdzogd2luZG93LnBlcmZvcm1hbmNlICYmIHdpbmRvdy5wZXJmb3JtYW5jZS5ub3cgP1xuICAgICAgd2luZG93LnBlcmZvcm1hbmNlLm5vdy5iaW5kKHdpbmRvdy5wZXJmb3JtYW5jZSkgOiBEYXRlLm5vd1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRWxlbWVudE1ldHJpY3MoZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLndpZHRoID0gdGhpcy5ib3VuZGluZ1JlY3Qud2lkdGg7XG4gIHRoaXMuaGVpZ2h0ID0gdGhpcy5ib3VuZGluZ1JlY3QuaGVpZ2h0O1xuXG4gIHRoaXMuc2l6ZSA9IE1hdGgubWF4KHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn1cblxuRWxlbWVudE1ldHJpY3MucHJvdG90eXBlID0ge1xuICBnZXQgYm91bmRpbmdSZWN0ICgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9LFxuXG4gIGZ1cnRoZXN0Q29ybmVyRGlzdGFuY2VGcm9tOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgdmFyIHRvcExlZnQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIDAsIDApO1xuICAgIHZhciB0b3BSaWdodCA9IFV0aWxpdHkuZGlzdGFuY2UoeCwgeSwgdGhpcy53aWR0aCwgMCk7XG4gICAgdmFyIGJvdHRvbUxlZnQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIDAsIHRoaXMuaGVpZ2h0KTtcbiAgICB2YXIgYm90dG9tUmlnaHQgPSBVdGlsaXR5LmRpc3RhbmNlKHgsIHksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblxuICAgIHJldHVybiBNYXRoLm1heCh0b3BMZWZ0LCB0b3BSaWdodCwgYm90dG9tTGVmdCwgYm90dG9tUmlnaHQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSaXBwbGUoZWxlbWVudCkge1xuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB0aGlzLmNvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuY29sb3I7XG5cbiAgdGhpcy53YXZlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRoaXMud2F2ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICB0aGlzLndhdmUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgdGhpcy53YXZlLmNsYXNzTGlzdC5hZGQoJ3dhdmUnKTtcbiAgdGhpcy53YXZlQ29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ3dhdmUtY29udGFpbmVyJyk7XG4gIGRvbSh0aGlzLndhdmVDb250YWluZXIpLmFwcGVuZENoaWxkKHRoaXMud2F2ZSk7XG5cbiAgdGhpcy5yZXNldEludGVyYWN0aW9uU3RhdGUoKTtcbn1cblxuUmlwcGxlLk1BWF9SQURJVVMgPSAzMDA7XG5cblJpcHBsZS5wcm90b3R5cGUgPSB7XG4gIGdldCByZWNlbnRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5yZWNlbnRlcnM7XG4gIH0sXG5cbiAgZ2V0IGNlbnRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNlbnRlcjtcbiAgfSxcblxuICBnZXQgbW91c2VEb3duRWxhcHNlZCgpIHtcbiAgICB2YXIgZWxhcHNlZDtcblxuICAgIGlmICghdGhpcy5tb3VzZURvd25TdGFydCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgZWxhcHNlZCA9IFV0aWxpdHkubm93KCkgLSB0aGlzLm1vdXNlRG93blN0YXJ0O1xuXG4gICAgaWYgKHRoaXMubW91c2VVcFN0YXJ0KSB7XG4gICAgICBlbGFwc2VkIC09IHRoaXMubW91c2VVcEVsYXBzZWQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsYXBzZWQ7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlVXBFbGFwc2VkKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlVXBTdGFydCA/XG4gICAgICBVdGlsaXR5Lm5vdyAoKSAtIHRoaXMubW91c2VVcFN0YXJ0IDogMDtcbiAgfSxcblxuICBnZXQgbW91c2VEb3duRWxhcHNlZFNlY29uZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VEb3duRWxhcHNlZCAvIDEwMDA7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlVXBFbGFwc2VkU2Vjb25kcygpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZVVwRWxhcHNlZCAvIDEwMDA7XG4gIH0sXG5cbiAgZ2V0IG1vdXNlSW50ZXJhY3Rpb25TZWNvbmRzKCkge1xuICAgIHJldHVybiB0aGlzLm1vdXNlRG93bkVsYXBzZWRTZWNvbmRzICsgdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHM7XG4gIH0sXG5cbiAgZ2V0IGluaXRpYWxPcGFjaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaW5pdGlhbE9wYWNpdHk7XG4gIH0sXG5cbiAgZ2V0IG9wYWNpdHlEZWNheVZlbG9jaXR5KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQub3BhY2l0eURlY2F5VmVsb2NpdHk7XG4gIH0sXG5cbiAgZ2V0IHJhZGl1cygpIHtcbiAgICB2YXIgd2lkdGgyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoICogdGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoO1xuICAgIHZhciBoZWlnaHQyID0gdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAqIHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQ7XG4gICAgdmFyIHdhdmVSYWRpdXMgPSBNYXRoLm1pbihcbiAgICAgIE1hdGguc3FydCh3aWR0aDIgKyBoZWlnaHQyKSxcbiAgICAgIFJpcHBsZS5NQVhfUkFESVVTXG4gICAgKSAqIDEuMSArIDU7XG5cbiAgICB2YXIgZHVyYXRpb24gPSAxLjEgLSAwLjIgKiAod2F2ZVJhZGl1cyAvIFJpcHBsZS5NQVhfUkFESVVTKTtcbiAgICB2YXIgdGltZU5vdyA9IHRoaXMubW91c2VJbnRlcmFjdGlvblNlY29uZHMgLyBkdXJhdGlvbjtcbiAgICB2YXIgc2l6ZSA9IHdhdmVSYWRpdXMgKiAoMSAtIE1hdGgucG93KDgwLCAtdGltZU5vdykpO1xuXG4gICAgcmV0dXJuIE1hdGguYWJzKHNpemUpO1xuICB9LFxuXG4gIGdldCBvcGFjaXR5KCkge1xuICAgIGlmICghdGhpcy5tb3VzZVVwU3RhcnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmluaXRpYWxPcGFjaXR5O1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLm1heChcbiAgICAgIDAsXG4gICAgICB0aGlzLmluaXRpYWxPcGFjaXR5IC0gdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHMgKiB0aGlzLm9wYWNpdHlEZWNheVZlbG9jaXR5XG4gICAgKTtcbiAgfSxcblxuICBnZXQgb3V0ZXJPcGFjaXR5KCkge1xuICAgIC8vIExpbmVhciBpbmNyZWFzZSBpbiBiYWNrZ3JvdW5kIG9wYWNpdHksIGNhcHBlZCBhdCB0aGUgb3BhY2l0eVxuICAgIC8vIG9mIHRoZSB3YXZlZnJvbnQgKHdhdmVPcGFjaXR5KS5cbiAgICB2YXIgb3V0ZXJPcGFjaXR5ID0gdGhpcy5tb3VzZVVwRWxhcHNlZFNlY29uZHMgKiAwLjM7XG4gICAgdmFyIHdhdmVPcGFjaXR5ID0gdGhpcy5vcGFjaXR5O1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KFxuICAgICAgMCxcbiAgICAgIE1hdGgubWluKG91dGVyT3BhY2l0eSwgd2F2ZU9wYWNpdHkpXG4gICAgKTtcbiAgfSxcblxuICBnZXQgaXNPcGFjaXR5RnVsbHlEZWNheWVkKCkge1xuICAgIHJldHVybiB0aGlzLm9wYWNpdHkgPCAwLjAxICYmXG4gICAgICB0aGlzLnJhZGl1cyA+PSBNYXRoLm1pbih0aGlzLm1heFJhZGl1cywgUmlwcGxlLk1BWF9SQURJVVMpO1xuICB9LFxuXG4gIGdldCBpc1Jlc3RpbmdBdE1heFJhZGl1cygpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5ID49IHRoaXMuaW5pdGlhbE9wYWNpdHkgJiZcbiAgICAgIHRoaXMucmFkaXVzID49IE1hdGgubWluKHRoaXMubWF4UmFkaXVzLCBSaXBwbGUuTUFYX1JBRElVUyk7XG4gIH0sXG5cbiAgZ2V0IGlzQW5pbWF0aW9uQ29tcGxldGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubW91c2VVcFN0YXJ0ID9cbiAgICAgIHRoaXMuaXNPcGFjaXR5RnVsbHlEZWNheWVkIDogdGhpcy5pc1Jlc3RpbmdBdE1heFJhZGl1cztcbiAgfSxcblxuICBnZXQgdHJhbnNsYXRpb25GcmFjdGlvbigpIHtcbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICAxLFxuICAgICAgdGhpcy5yYWRpdXMgLyB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSAqIDIgLyBNYXRoLnNxcnQoMilcbiAgICApO1xuICB9LFxuXG4gIGdldCB4Tm93KCkge1xuICAgIGlmICh0aGlzLnhFbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnhTdGFydCArIHRoaXMudHJhbnNsYXRpb25GcmFjdGlvbiAqICh0aGlzLnhFbmQgLSB0aGlzLnhTdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMueFN0YXJ0O1xuICB9LFxuXG4gIGdldCB5Tm93KCkge1xuICAgIGlmICh0aGlzLnlFbmQpIHtcbiAgICAgIHJldHVybiB0aGlzLnlTdGFydCArIHRoaXMudHJhbnNsYXRpb25GcmFjdGlvbiAqICh0aGlzLnlFbmQgLSB0aGlzLnlTdGFydCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMueVN0YXJ0O1xuICB9LFxuXG4gIGdldCBpc01vdXNlRG93bigpIHtcbiAgICByZXR1cm4gdGhpcy5tb3VzZURvd25TdGFydCAmJiAhdGhpcy5tb3VzZVVwU3RhcnQ7XG4gIH0sXG5cbiAgcmVzZXRJbnRlcmFjdGlvblN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLm1heFJhZGl1cyA9IDA7XG4gICAgdGhpcy5tb3VzZURvd25TdGFydCA9IDA7XG4gICAgdGhpcy5tb3VzZVVwU3RhcnQgPSAwO1xuXG4gICAgdGhpcy54U3RhcnQgPSAwO1xuICAgIHRoaXMueVN0YXJ0ID0gMDtcbiAgICB0aGlzLnhFbmQgPSAwO1xuICAgIHRoaXMueUVuZCA9IDA7XG4gICAgdGhpcy5zbGlkZURpc3RhbmNlID0gMDtcblxuICAgIHRoaXMuY29udGFpbmVyTWV0cmljcyA9IG5ldyBFbGVtZW50TWV0cmljcyh0aGlzLmVsZW1lbnQpO1xuICB9LFxuXG4gIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzY2FsZTtcbiAgICB2YXIgdHJhbnNsYXRlU3RyaW5nO1xuICAgIHZhciBkeDtcbiAgICB2YXIgZHk7XG5cbiAgICB0aGlzLndhdmUuc3R5bGUub3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcblxuICAgIHNjYWxlID0gdGhpcy5yYWRpdXMgLyAodGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUgLyAyKTtcbiAgICBkeCA9IHRoaXMueE5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyKTtcbiAgICBkeSA9IHRoaXMueU5vdyAtICh0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMik7XG5cblxuICAgIC8vIDJkIHRyYW5zZm9ybSBmb3Igc2FmYXJpIGJlY2F1c2Ugb2YgYm9yZGVyLXJhZGl1cyBhbmQgb3ZlcmZsb3c6aGlkZGVuIGNsaXBwaW5nIGJ1Zy5cbiAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9OTg1MzhcbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZHggKyAncHgsICcgKyBkeSArICdweCknO1xuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoJyArIGR4ICsgJ3B4LCAnICsgZHkgKyAncHgsIDApJztcbiAgICB0aGlzLndhdmUuc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ3NjYWxlKCcgKyBzY2FsZSArICcsJyArIHNjYWxlICsgJyknO1xuICAgIHRoaXMud2F2ZS5zdHlsZS50cmFuc2Zvcm0gPSAnc2NhbGUzZCgnICsgc2NhbGUgKyAnLCcgKyBzY2FsZSArICcsMSknO1xuICB9LFxuXG4gIC8qKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnQgKi9cbiAgZG93bkFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICB2YXIgeENlbnRlciA9IHRoaXMuY29udGFpbmVyTWV0cmljcy53aWR0aCAvIDI7XG4gICAgdmFyIHlDZW50ZXIgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuaGVpZ2h0IC8gMjtcblxuICAgIHRoaXMucmVzZXRJbnRlcmFjdGlvblN0YXRlKCk7XG4gICAgdGhpcy5tb3VzZURvd25TdGFydCA9IFV0aWxpdHkubm93KCk7XG5cbiAgICBpZiAodGhpcy5jZW50ZXIpIHtcbiAgICAgIHRoaXMueFN0YXJ0ID0geENlbnRlcjtcbiAgICAgIHRoaXMueVN0YXJ0ID0geUNlbnRlcjtcbiAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IFV0aWxpdHkuZGlzdGFuY2UoXG4gICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMueFN0YXJ0ID0gZXZlbnQgP1xuICAgICAgICAgIGV2ZW50LmRldGFpbC54IC0gdGhpcy5jb250YWluZXJNZXRyaWNzLmJvdW5kaW5nUmVjdC5sZWZ0IDpcbiAgICAgICAgICB0aGlzLmNvbnRhaW5lck1ldHJpY3Mud2lkdGggLyAyO1xuICAgICAgdGhpcy55U3RhcnQgPSBldmVudCA/XG4gICAgICAgICAgZXZlbnQuZGV0YWlsLnkgLSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuYm91bmRpbmdSZWN0LnRvcCA6XG4gICAgICAgICAgdGhpcy5jb250YWluZXJNZXRyaWNzLmhlaWdodCAvIDI7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVjZW50ZXJzKSB7XG4gICAgICB0aGlzLnhFbmQgPSB4Q2VudGVyO1xuICAgICAgdGhpcy55RW5kID0geUNlbnRlcjtcbiAgICAgIHRoaXMuc2xpZGVEaXN0YW5jZSA9IFV0aWxpdHkuZGlzdGFuY2UoXG4gICAgICAgIHRoaXMueFN0YXJ0LCB0aGlzLnlTdGFydCwgdGhpcy54RW5kLCB0aGlzLnlFbmRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5tYXhSYWRpdXMgPSB0aGlzLmNvbnRhaW5lck1ldHJpY3MuZnVydGhlc3RDb3JuZXJEaXN0YW5jZUZyb20oXG4gICAgICB0aGlzLnhTdGFydCxcbiAgICAgIHRoaXMueVN0YXJ0XG4gICAgKTtcblxuICAgIHRoaXMud2F2ZUNvbnRhaW5lci5zdHlsZS50b3AgPVxuICAgICAgKHRoaXMuY29udGFpbmVyTWV0cmljcy5oZWlnaHQgLSB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSkgLyAyICsgJ3B4JztcbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUubGVmdCA9XG4gICAgICAodGhpcy5jb250YWluZXJNZXRyaWNzLndpZHRoIC0gdGhpcy5jb250YWluZXJNZXRyaWNzLnNpemUpIC8gMiArICdweCc7XG5cbiAgICB0aGlzLndhdmVDb250YWluZXIuc3R5bGUud2lkdGggPSB0aGlzLmNvbnRhaW5lck1ldHJpY3Muc2l6ZSArICdweCc7XG4gICAgdGhpcy53YXZlQ29udGFpbmVyLnN0eWxlLmhlaWdodCA9IHRoaXMuY29udGFpbmVyTWV0cmljcy5zaXplICsgJ3B4JztcbiAgfSxcblxuICAvKiogQHBhcmFtIHtFdmVudD19IGV2ZW50ICovXG4gIHVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5pc01vdXNlRG93bikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMubW91c2VVcFN0YXJ0ID0gVXRpbGl0eS5ub3coKTtcbiAgfSxcblxuICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgIGRvbSh0aGlzLndhdmVDb250YWluZXIucGFyZW50Tm9kZSkucmVtb3ZlQ2hpbGQoXG4gICAgICB0aGlzLndhdmVDb250YWluZXJcbiAgICApO1xuICB9XG59O1xuXG5Qb2x5bWVyKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiBpbmhlcml0O1xuICAgICAgICBvdmVyZmxvdzogaGlkZGVuO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHJpZ2h0OiAwO1xuICAgICAgICBib3R0b206IDA7XG5cbiAgICAgICAgLyogU2VlIFBvbHltZXJFbGVtZW50cy9wYXBlci1iZWhhdmlvcnMvaXNzdWVzLzM0LiBPbiBub24tQ2hyb21lIGJyb3dzZXJzLFxuICAgICAgICAgKiBjcmVhdGluZyBhIG5vZGUgKHdpdGggYSBwb3NpdGlvbjphYnNvbHV0ZSkgaW4gdGhlIG1pZGRsZSBvZiBhbiBldmVudFxuICAgICAgICAgKiBoYW5kbGVyIFwiaW50ZXJydXB0c1wiIHRoYXQgZXZlbnQgaGFuZGxlciAod2hpY2ggaGFwcGVucyB3aGVuIHRoZVxuICAgICAgICAgKiByaXBwbGUgaXMgY3JlYXRlZCBvbiBkZW1hbmQpICovXG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbYW5pbWF0aW5nXSkge1xuICAgICAgICAvKiBUaGlzIHJlc29sdmVzIGEgcmVuZGVyaW5nIGlzc3VlIGluIENocm9tZSAoYXMgb2YgNDApIHdoZXJlIHRoZVxuICAgICAgICAgICByaXBwbGUgaXMgbm90IHByb3Blcmx5IGNsaXBwZWQgYnkgaXRzIHBhcmVudCAod2hpY2ggbWF5IGhhdmVcbiAgICAgICAgICAgcm91bmRlZCBjb3JuZXJzKS4gU2VlOiBodHRwOi8vanNiaW4uY29tL3RlbWV4YS80XG5cbiAgICAgICAgICAgTm90ZTogV2Ugb25seSBhcHBseSB0aGlzIHN0eWxlIGNvbmRpdGlvbmFsbHkuIE90aGVyd2lzZSwgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgd2lsbCBjcmVhdGUgYSBuZXcgY29tcG9zaXRpbmcgbGF5ZXIgZm9yIGV2ZXJ5IHJpcHBsZSBlbGVtZW50IG9uIHRoZVxuICAgICAgICAgICBwYWdlLCBhbmQgdGhhdCB3b3VsZCBiZSBiYWQuICovXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUoMCwgMCk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgI3dhdmVzLFxuICAgICAgLndhdmUtY29udGFpbmVyLFxuICAgICAgLndhdmUge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICB0b3A6IDA7XG4gICAgICAgIGxlZnQ6IDA7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgICNiYWNrZ3JvdW5kLFxuICAgICAgLndhdmUge1xuICAgICAgICBvcGFjaXR5OiAwO1xuICAgICAgfVxuXG4gICAgICAjd2F2ZXMsXG4gICAgICAud2F2ZSB7XG4gICAgICAgIG92ZXJmbG93OiBoaWRkZW47XG4gICAgICB9XG5cbiAgICAgIC53YXZlLWNvbnRhaW5lcixcbiAgICAgIC53YXZlIHtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogNTAlO1xuICAgICAgfVxuXG4gICAgICA6aG9zdCguY2lyY2xlKSAjYmFja2dyb3VuZCxcbiAgICAgIDpob3N0KC5jaXJjbGUpICN3YXZlcyB7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDUwJTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoLmNpcmNsZSkgLndhdmUtY29udGFpbmVyIHtcbiAgICAgICAgb3ZlcmZsb3c6IGhpZGRlbjtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cImJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGlkPVwid2F2ZXNcIj48L2Rpdj5cbmAsXG5cbiAgaXM6ICdwYXBlci1yaXBwbGUnLFxuXG4gIGJlaGF2aW9yczogW1xuICAgIElyb25BMTF5S2V5c0JlaGF2aW9yXG4gIF0sXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFRoZSBpbml0aWFsIG9wYWNpdHkgc2V0IG9uIHRoZSB3YXZlLlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSBpbml0aWFsT3BhY2l0eVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuMjVcbiAgICAgKi9cbiAgICBpbml0aWFsT3BhY2l0eToge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgdmFsdWU6IDAuMjVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSG93IGZhc3QgKG9wYWNpdHkgcGVyIHNlY29uZCkgdGhlIHdhdmUgZmFkZXMgb3V0LlxuICAgICAqXG4gICAgICogQGF0dHJpYnV0ZSBvcGFjaXR5RGVjYXlWZWxvY2l0eVxuICAgICAqIEB0eXBlIG51bWJlclxuICAgICAqIEBkZWZhdWx0IDAuOFxuICAgICAqL1xuICAgIG9wYWNpdHlEZWNheVZlbG9jaXR5OiB7XG4gICAgICB0eXBlOiBOdW1iZXIsXG4gICAgICB2YWx1ZTogMC44XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBleGhpYml0IGEgZ3Jhdml0YXRpb25hbCBwdWxsIHRvd2FyZHNcbiAgICAgKiB0aGUgY2VudGVyIG9mIHRoZWlyIGNvbnRhaW5lciBhcyB0aGV5IGZhZGUgYXdheS5cbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgcmVjZW50ZXJzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgcmVjZW50ZXJzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHJpcHBsZXMgd2lsbCBjZW50ZXIgaW5zaWRlIGl0cyBjb250YWluZXJcbiAgICAgKlxuICAgICAqIEBhdHRyaWJ1dGUgcmVjZW50ZXJzXG4gICAgICogQHR5cGUgYm9vbGVhblxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICovXG4gICAgY2VudGVyOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgbGlzdCBvZiB0aGUgdmlzdWFsIHJpcHBsZXMuXG4gICAgICpcbiAgICAgKiBAYXR0cmlidXRlIHJpcHBsZXNcbiAgICAgKiBAdHlwZSBBcnJheVxuICAgICAqIEBkZWZhdWx0IFtdXG4gICAgICovXG4gICAgcmlwcGxlczoge1xuICAgICAgdHlwZTogQXJyYXksXG4gICAgICB2YWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVHJ1ZSB3aGVuIHRoZXJlIGFyZSB2aXNpYmxlIHJpcHBsZXMgYW5pbWF0aW5nIHdpdGhpbiB0aGVcbiAgICAgKiBlbGVtZW50LlxuICAgICAqL1xuICAgIGFuaW1hdGluZzoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgcmVmbGVjdFRvQXR0cmlidXRlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSByaXBwbGUgd2lsbCByZW1haW4gaW4gdGhlIFwiZG93blwiIHN0YXRlIHVudGlsIGBob2xkRG93bmBcbiAgICAgKiBpcyBzZXQgdG8gZmFsc2UgYWdhaW4uXG4gICAgICovXG4gICAgaG9sZERvd246IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBvYnNlcnZlcjogJ19ob2xkRG93bkNoYW5nZWQnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHRydWUsIHRoZSByaXBwbGUgd2lsbCBub3QgZ2VuZXJhdGUgYSByaXBwbGUgZWZmZWN0XG4gICAgICogdmlhIHBvaW50ZXIgaW50ZXJhY3Rpb24uXG4gICAgICogQ2FsbGluZyByaXBwbGUncyBpbXBlcmF0aXZlIGFwaSBsaWtlIGBzaW11bGF0ZWRSaXBwbGVgIHdpbGxcbiAgICAgKiBzdGlsbCBnZW5lcmF0ZSB0aGUgcmlwcGxlIGVmZmVjdC5cbiAgICAgKi9cbiAgICBub2luazoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICBfYW5pbWF0aW5nOiB7XG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfSxcblxuICAgIF9ib3VuZEFuaW1hdGU6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmltYXRlLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldCB0YXJnZXQgKCkge1xuICAgIHJldHVybiB0aGlzLmtleUV2ZW50VGFyZ2V0O1xuICB9LFxuXG4gIGtleUJpbmRpbmdzOiB7XG4gICAgJ2VudGVyOmtleWRvd24nOiAnX29uRW50ZXJLZXlkb3duJyxcbiAgICAnc3BhY2U6a2V5ZG93bic6ICdfb25TcGFjZUtleWRvd24nLFxuICAgICdzcGFjZTprZXl1cCc6ICdfb25TcGFjZUtleXVwJ1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAvLyBTZXQgdXAgYTExeUtleXNCZWhhdmlvciB0byBsaXN0ZW4gdG8ga2V5IGV2ZW50cyBvbiB0aGUgdGFyZ2V0LFxuICAgIC8vIHNvIHRoYXQgc3BhY2UgYW5kIGVudGVyIGFjdGl2YXRlIHRoZSByaXBwbGUgZXZlbiBpZiB0aGUgdGFyZ2V0IGRvZXNuJ3RcbiAgICAvLyBoYW5kbGUga2V5IGV2ZW50cy4gVGhlIGtleSBoYW5kbGVycyBkZWFsIHdpdGggYG5vaW5rYCB0aGVtc2VsdmVzLlxuICAgIGlmICh0aGlzLnBhcmVudE5vZGUubm9kZVR5cGUgPT0gMTEpIHsgLy8gRE9DVU1FTlRfRlJBR01FTlRfTk9ERVxuICAgICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IGRvbSh0aGlzKS5nZXRPd25lclJvb3QoKS5ob3N0O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmtleUV2ZW50VGFyZ2V0ID0gdGhpcy5wYXJlbnROb2RlO1xuICAgIH1cbiAgICB2YXIga2V5RXZlbnRUYXJnZXQgPSAvKiogQHR5cGUgeyFFdmVudFRhcmdldH0gKi8gKHRoaXMua2V5RXZlbnRUYXJnZXQpO1xuICAgIHRoaXMubGlzdGVuKGtleUV2ZW50VGFyZ2V0LCAndXAnLCAndWlVcEFjdGlvbicpO1xuICAgIHRoaXMubGlzdGVuKGtleUV2ZW50VGFyZ2V0LCAnZG93bicsICd1aURvd25BY3Rpb24nKTtcbiAgfSxcblxuICBkZXRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51bmxpc3Rlbih0aGlzLmtleUV2ZW50VGFyZ2V0LCAndXAnLCAndWlVcEFjdGlvbicpO1xuICAgIHRoaXMudW5saXN0ZW4odGhpcy5rZXlFdmVudFRhcmdldCwgJ2Rvd24nLCAndWlEb3duQWN0aW9uJyk7XG4gICAgdGhpcy5rZXlFdmVudFRhcmdldCA9IG51bGw7XG4gIH0sXG5cbiAgZ2V0IHNob3VsZEtlZXBBbmltYXRpbmcgKCkge1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCB0aGlzLnJpcHBsZXMubGVuZ3RoOyArK2luZGV4KSB7XG4gICAgICBpZiAoIXRoaXMucmlwcGxlc1tpbmRleF0uaXNBbmltYXRpb25Db21wbGV0ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgc2ltdWxhdGVkUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmRvd25BY3Rpb24obnVsbCk7XG5cbiAgICAvLyBQbGVhc2Ugc2VlIHBvbHltZXIvcG9seW1lciMxMzA1XG4gICAgdGhpcy5hc3luYyhmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICB9LCAxKTtcbiAgfSxcblxuICAvKipcbiAgICogUHJvdm9rZXMgYSByaXBwbGUgZG93biBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgKi9cbiAgdWlEb3duQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5ub2luaykge1xuICAgICAgdGhpcy5kb3duQWN0aW9uKGV2ZW50KTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFByb3Zva2VzIGEgcmlwcGxlIGRvd24gZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgKiAqbm90KiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICovXG4gIGRvd25BY3Rpb246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuaG9sZERvd24gJiYgdGhpcy5yaXBwbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmlwcGxlID0gdGhpcy5hZGRSaXBwbGUoKTtcblxuICAgIHJpcHBsZS5kb3duQWN0aW9uKGV2ZW50KTtcblxuICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICB0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5hbmltYXRlKCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBQcm92b2tlcyBhIHJpcHBsZSB1cCBlZmZlY3QgdmlhIGEgVUkgZXZlbnQsXG4gICAqIHJlc3BlY3RpbmcgdGhlIGBub2lua2AgcHJvcGVydHkuXG4gICAqIEBwYXJhbSB7RXZlbnQ9fSBldmVudFxuICAgKi9cbiAgdWlVcEFjdGlvbjogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMubm9pbmspIHtcbiAgICAgIHRoaXMudXBBY3Rpb24oZXZlbnQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUHJvdm9rZXMgYSByaXBwbGUgdXAgZWZmZWN0IHZpYSBhIFVJIGV2ZW50LFxuICAgKiAqbm90KiByZXNwZWN0aW5nIHRoZSBgbm9pbmtgIHByb3BlcnR5LlxuICAgKiBAcGFyYW0ge0V2ZW50PX0gZXZlbnRcbiAgICovXG4gIHVwQWN0aW9uOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICh0aGlzLmhvbGREb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5yaXBwbGVzLmZvckVhY2goZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgICByaXBwbGUudXBBY3Rpb24oZXZlbnQpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmFuaW1hdGUoKTtcbiAgfSxcblxuICBvbkFuaW1hdGlvbkNvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9hbmltYXRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLiQuYmFja2dyb3VuZC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBudWxsO1xuICAgIHRoaXMuZmlyZSgndHJhbnNpdGlvbmVuZCcpO1xuICB9LFxuXG4gIGFkZFJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJpcHBsZSA9IG5ldyBSaXBwbGUodGhpcyk7XG5cbiAgICBkb20odGhpcy4kLndhdmVzKS5hcHBlbmRDaGlsZChyaXBwbGUud2F2ZUNvbnRhaW5lcik7XG4gICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gcmlwcGxlLmNvbG9yO1xuICAgIHRoaXMucmlwcGxlcy5wdXNoKHJpcHBsZSk7XG5cbiAgICB0aGlzLl9zZXRBbmltYXRpbmcodHJ1ZSk7XG5cbiAgICByZXR1cm4gcmlwcGxlO1xuICB9LFxuXG4gIHJlbW92ZVJpcHBsZTogZnVuY3Rpb24ocmlwcGxlKSB7XG4gICAgdmFyIHJpcHBsZUluZGV4ID0gdGhpcy5yaXBwbGVzLmluZGV4T2YocmlwcGxlKTtcblxuICAgIGlmIChyaXBwbGVJbmRleCA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLnJpcHBsZXMuc3BsaWNlKHJpcHBsZUluZGV4LCAxKTtcblxuICAgIHJpcHBsZS5yZW1vdmUoKTtcblxuICAgIGlmICghdGhpcy5yaXBwbGVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fc2V0QW5pbWF0aW5nKGZhbHNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRoaXMgY29uZmxpY3RzIHdpdGggRWxlbWVudCNhbnRpbWF0ZSgpLlxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudC9hbmltYXRlXG4gICAqIEBzdXBwcmVzcyB7Y2hlY2tUeXBlc31cbiAgICovXG4gIGFuaW1hdGU6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpbmRleDtcbiAgICB2YXIgcmlwcGxlO1xuXG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5yaXBwbGVzLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgcmlwcGxlID0gdGhpcy5yaXBwbGVzW2luZGV4XTtcblxuICAgICAgcmlwcGxlLmRyYXcoKTtcblxuICAgICAgdGhpcy4kLmJhY2tncm91bmQuc3R5bGUub3BhY2l0eSA9IHJpcHBsZS5vdXRlck9wYWNpdHk7XG5cbiAgICAgIGlmIChyaXBwbGUuaXNPcGFjaXR5RnVsbHlEZWNheWVkICYmICFyaXBwbGUuaXNSZXN0aW5nQXRNYXhSYWRpdXMpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVSaXBwbGUocmlwcGxlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuc2hvdWxkS2VlcEFuaW1hdGluZyAmJiB0aGlzLnJpcHBsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLm9uQW5pbWF0aW9uQ29tcGxldGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLl9ib3VuZEFuaW1hdGUpO1xuICAgIH1cbiAgfSxcblxuICBfb25FbnRlcktleWRvd246IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMudWlEb3duQWN0aW9uKCk7XG4gICAgdGhpcy5hc3luYyh0aGlzLnVpVXBBY3Rpb24sIDEpO1xuICB9LFxuXG4gIF9vblNwYWNlS2V5ZG93bjogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy51aURvd25BY3Rpb24oKTtcbiAgfSxcblxuICBfb25TcGFjZUtleXVwOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnVpVXBBY3Rpb24oKTtcbiAgfSxcblxuICAvLyBub3RlOiBob2xkRG93biBkb2VzIG5vdCByZXNwZWN0IG5vaW5rIHNpbmNlIGl0IGNhbiBiZSBhIGZvY3VzIGJhc2VkXG4gIC8vIGVmZmVjdC5cbiAgX2hvbGREb3duQ2hhbmdlZDogZnVuY3Rpb24obmV3VmFsLCBvbGRWYWwpIHtcbiAgICBpZiAob2xkVmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG5ld1ZhbCkge1xuICAgICAgdGhpcy5kb3duQWN0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudXBBY3Rpb24oKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgRmlyZWQgd2hlbiB0aGUgYW5pbWF0aW9uIGZpbmlzaGVzLlxuICBUaGlzIGlzIHVzZWZ1bCBpZiB5b3Ugd2FudCB0byB3YWl0IHVudGlsXG4gIHRoZSByaXBwbGUgYW5pbWF0aW9uIGZpbmlzaGVzIHRvIHBlcmZvcm0gc29tZSBhY3Rpb24uXG5cbiAgQGV2ZW50IHRyYW5zaXRpb25lbmRcbiAgQHBhcmFtIHt7bm9kZTogT2JqZWN0fX0gZGV0YWlsIENvbnRhaW5zIHRoZSBhbmltYXRlZCBub2RlLlxuICAqL1xufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1yaXBwbGUvcGFwZXItcmlwcGxlLmpzXG4vLyBtb2R1bGUgaWQgPSA4NVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uLy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL3NoYWRvdy5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci1tYXRlcmlhbC1zdHlsZXNcIj5cbiAgPHRlbXBsYXRlPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0LCBodG1sIHtcbiAgICAgICAgLS1wYXBlci1tYXRlcmlhbDoge1xuICAgICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgfTtcbiAgICAgICAgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tMToge1xuICAgICAgICAgIEBhcHBseSAtLXNoYWRvdy1lbGV2YXRpb24tMmRwO1xuICAgICAgICB9O1xuICAgICAgICAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi0yOiB7XG4gICAgICAgICAgQGFwcGx5IC0tc2hhZG93LWVsZXZhdGlvbi00ZHA7XG4gICAgICAgIH07XG4gICAgICAgIC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTM6IHtcbiAgICAgICAgICBAYXBwbHkgLS1zaGFkb3ctZWxldmF0aW9uLTZkcDtcbiAgICAgICAgfTtcbiAgICAgICAgLS1wYXBlci1tYXRlcmlhbC1lbGV2YXRpb24tNDoge1xuICAgICAgICAgIEBhcHBseSAtLXNoYWRvdy1lbGV2YXRpb24tOGRwO1xuICAgICAgICB9O1xuICAgICAgICAtLXBhcGVyLW1hdGVyaWFsLWVsZXZhdGlvbi01OiB7XG4gICAgICAgICAgQGFwcGx5IC0tc2hhZG93LWVsZXZhdGlvbi0xNmRwO1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgOmhvc3QoLnBhcGVyLW1hdGVyaWFsKSwgLnBhcGVyLW1hdGVyaWFsIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWw7XG4gICAgICB9XG4gICAgICA6aG9zdCgucGFwZXItbWF0ZXJpYWxbZWxldmF0aW9uPVwiMVwiXSksIC5wYXBlci1tYXRlcmlhbFtlbGV2YXRpb249XCIxXCJdIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTE7XG4gICAgICB9XG4gICAgICA6aG9zdCgucGFwZXItbWF0ZXJpYWxbZWxldmF0aW9uPVwiMlwiXSksIC5wYXBlci1tYXRlcmlhbFtlbGV2YXRpb249XCIyXCJdIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTI7XG4gICAgICB9XG4gICAgICA6aG9zdCgucGFwZXItbWF0ZXJpYWxbZWxldmF0aW9uPVwiM1wiXSksIC5wYXBlci1tYXRlcmlhbFtlbGV2YXRpb249XCIzXCJdIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTM7XG4gICAgICB9XG4gICAgICA6aG9zdCgucGFwZXItbWF0ZXJpYWxbZWxldmF0aW9uPVwiNFwiXSksIC5wYXBlci1tYXRlcmlhbFtlbGV2YXRpb249XCI0XCJdIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTQ7XG4gICAgICB9XG4gICAgICA6aG9zdCgucGFwZXItbWF0ZXJpYWxbZWxldmF0aW9uPVwiNVwiXSksIC5wYXBlci1tYXRlcmlhbFtlbGV2YXRpb249XCI1XCJdIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItbWF0ZXJpYWwtZWxldmF0aW9uLTU7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cbiAgPC90ZW1wbGF0ZT5cbjwvZG9tLW1vZHVsZT5gO1xuXG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKCRfZG9jdW1lbnRDb250YWluZXIpO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvcGFwZXItc3R5bGVzL2VsZW1lbnQtc3R5bGVzL3BhcGVyLW1hdGVyaWFsLXN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gODZcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci5qcyc7XG5pbXBvcnQgJy4uL2lyb24taW5wdXQvaXJvbi1pbnB1dC5qcyc7XG5pbXBvcnQgeyBQYXBlcklucHV0QmVoYXZpb3IgfSBmcm9tICcuL3BhcGVyLWlucHV0LWJlaGF2aW9yLmpzJztcbmltcG9ydCAnLi9wYXBlci1pbnB1dC1jaGFyLWNvdW50ZXIuanMnO1xuaW1wb3J0ICcuL3BhcGVyLWlucHV0LWNvbnRhaW5lci5qcyc7XG5pbXBvcnQgJy4vcGFwZXItaW5wdXQtZXJyb3IuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCB7IERvbU1vZHVsZSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2VsZW1lbnRzL2RvbS1tb2R1bGUuanMnO1xuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmNvbnN0ICRfZG9jdW1lbnRDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiRfZG9jdW1lbnRDb250YWluZXIuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBub25lOycpO1xuXG4kX2RvY3VtZW50Q29udGFpbmVyLmlubmVySFRNTCA9IGA8ZG9tLW1vZHVsZSBpZD1cInBhcGVyLWlucHV0XCI+XG4gIDx0ZW1wbGF0ZT5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZm9jdXNlZF0pIHtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICBpbnB1dCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTsgLyogdG8gbWFrZSBhIHN0YWNraW5nIGNvbnRleHQgKi9cbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgYm94LXNoYWRvdzogbm9uZTtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIG1heC13aWR0aDogMTAwJTtcbiAgICAgICAgYmFja2dyb3VuZDogdHJhbnNwYXJlbnQ7XG4gICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1pbnB1dC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcbiAgICAgICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IGJvdHRvbTtcblxuICAgICAgICAvKiBGaXJlZm94IHNldHMgYSBtaW4td2lkdGggb24gdGhlIGlucHV0LCB3aGljaCBjYW4gY2F1c2UgbGF5b3V0IGlzc3VlcyAqL1xuICAgICAgICBtaW4td2lkdGg6IDA7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1zdWJoZWFkO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQ7XG4gICAgICB9XG5cbiAgICAgIGlucHV0Ojotd2Via2l0LW91dGVyLXNwaW4tYnV0dG9uLFxuICAgICAgaW5wdXQ6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQtd2Via2l0LXNwaW5uZXI7XG4gICAgICB9XG5cbiAgICAgIGlucHV0Ojotd2Via2l0LWNsZWFyLWJ1dHRvbiB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1pbnB1dC13ZWJraXQtY2xlYXI7XG4gICAgICB9XG5cbiAgICAgIGlucHV0Ojotd2Via2l0LWlucHV0LXBsYWNlaG9sZGVyIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1jb2xvciwgdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgaW5wdXQ6LW1vei1wbGFjZWhvbGRlciB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItY29sb3IsIHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIGlucHV0OjotbW96LXBsYWNlaG9sZGVyIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1jb2xvciwgdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgaW5wdXQ6Oi1tcy1jbGVhciB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1tcy1jbGVhcjtcbiAgICAgIH1cblxuICAgICAgaW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVyIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1jb2xvciwgdmFyKC0tc2Vjb25kYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgbGFiZWwge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogbm9uZTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPHBhcGVyLWlucHV0LWNvbnRhaW5lciBpZD1cImNvbnRhaW5lclwiIG5vLWxhYmVsLWZsb2F0PVwiW1tub0xhYmVsRmxvYXRdXVwiIGFsd2F5cy1mbG9hdC1sYWJlbD1cIltbX2NvbXB1dGVBbHdheXNGbG9hdExhYmVsKGFsd2F5c0Zsb2F0TGFiZWwscGxhY2Vob2xkZXIpXV1cIiBhdXRvLXZhbGlkYXRlXFwkPVwiW1thdXRvVmFsaWRhdGVdXVwiIGRpc2FibGVkXFwkPVwiW1tkaXNhYmxlZF1dXCIgaW52YWxpZD1cIltbaW52YWxpZF1dXCI+XG5cbiAgICAgIDxzbG90IG5hbWU9XCJwcmVmaXhcIiBzbG90PVwicHJlZml4XCI+PC9zbG90PlxuXG4gICAgICA8bGFiZWwgaGlkZGVuXFwkPVwiW1shbGFiZWxdXVwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiIGZvcj1cImlucHV0XCIgc2xvdD1cImxhYmVsXCI+W1tsYWJlbF1dPC9sYWJlbD5cblxuICAgICAgPHNwYW4gaWQ9XCJ0ZW1wbGF0ZS1wbGFjZWhvbGRlclwiPjwvc3Bhbj5cblxuICAgICAgPHNsb3QgbmFtZT1cInN1ZmZpeFwiIHNsb3Q9XCJzdWZmaXhcIj48L3Nsb3Q+XG5cbiAgICAgIDx0ZW1wbGF0ZSBpcz1cImRvbS1pZlwiIGlmPVwiW1tlcnJvck1lc3NhZ2VdXVwiPlxuICAgICAgICA8cGFwZXItaW5wdXQtZXJyb3IgYXJpYS1saXZlPVwiYXNzZXJ0aXZlXCIgc2xvdD1cImFkZC1vblwiPltbZXJyb3JNZXNzYWdlXV08L3BhcGVyLWlucHV0LWVycm9yPlxuICAgICAgPC90ZW1wbGF0ZT5cblxuICAgICAgPHRlbXBsYXRlIGlzPVwiZG9tLWlmXCIgaWY9XCJbW2NoYXJDb3VudGVyXV1cIj5cbiAgICAgICAgPHBhcGVyLWlucHV0LWNoYXItY291bnRlciBzbG90PVwiYWRkLW9uXCI+PC9wYXBlci1pbnB1dC1jaGFyLWNvdW50ZXI+XG4gICAgICA8L3RlbXBsYXRlPlxuXG4gICAgPC9wYXBlci1pbnB1dC1jb250YWluZXI+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPCEtLSBUaGlzIGlzIGEgZnJlc2ggbmV3IGhlbGwgdG8gbWFrZSB0aGlzIGVsZW1lbnQgaHlicmlkLiBCYXNpY2FsbHksIGluIDIuMFxuICAgIHdlIGxvc3QgaXM9LCBzbyB0aGUgZXhhbXBsZSBzYW1lIHRlbXBsYXRlIGNhbid0IGJlIHVzZWQgd2l0aCBpcm9uLWlucHV0IDEuMCBhbmQgMi4wLlxuICAgIEV4cGVjdCBzb21lIGNvbmRpdGlvbmFsIGNvZGUgKGVzcGVjaWFsbHkgaW4gdGhlIHRlc3RzKS5cbiAgIC0tPlxuICA8dGVtcGxhdGUgaWQ9XCJ2MFwiPlxuICAgIDxpbnB1dCBpcz1cImlyb24taW5wdXRcIiBpZD1cImlucHV0XCIgc2xvdD1cImlucHV0XCIgYXJpYS1sYWJlbGxlZGJ5XFwkPVwiW1tfYXJpYUxhYmVsbGVkQnldXVwiIGFyaWEtZGVzY3JpYmVkYnlcXCQ9XCJbW19hcmlhRGVzY3JpYmVkQnldXVwiIGRpc2FibGVkXFwkPVwiW1tkaXNhYmxlZF1dXCIgdGl0bGVcXCQ9XCJbW3RpdGxlXV1cIiBiaW5kLXZhbHVlPVwie3t2YWx1ZX19XCIgaW52YWxpZD1cInt7aW52YWxpZH19XCIgcHJldmVudC1pbnZhbGlkLWlucHV0PVwiW1twcmV2ZW50SW52YWxpZElucHV0XV1cIiBhbGxvd2VkLXBhdHRlcm49XCJbW2FsbG93ZWRQYXR0ZXJuXV1cIiB2YWxpZGF0b3I9XCJbW3ZhbGlkYXRvcl1dXCIgdHlwZVxcJD1cIltbdHlwZV1dXCIgcGF0dGVyblxcJD1cIltbcGF0dGVybl1dXCIgcmVxdWlyZWRcXCQ9XCJbW3JlcXVpcmVkXV1cIiBhdXRvY29tcGxldGVcXCQ9XCJbW2F1dG9jb21wbGV0ZV1dXCIgYXV0b2ZvY3VzXFwkPVwiW1thdXRvZm9jdXNdXVwiIGlucHV0bW9kZVxcJD1cIltbaW5wdXRtb2RlXV1cIiBtaW5sZW5ndGhcXCQ9XCJbW21pbmxlbmd0aF1dXCIgbWF4bGVuZ3RoXFwkPVwiW1ttYXhsZW5ndGhdXVwiIG1pblxcJD1cIltbbWluXV1cIiBtYXhcXCQ9XCJbW21heF1dXCIgc3RlcFxcJD1cIltbc3RlcF1dXCIgbmFtZVxcJD1cIltbbmFtZV1dXCIgcGxhY2Vob2xkZXJcXCQ9XCJbW3BsYWNlaG9sZGVyXV1cIiByZWFkb25seVxcJD1cIltbcmVhZG9ubHldXVwiIGxpc3RcXCQ9XCJbW2xpc3RdXVwiIHNpemVcXCQ9XCJbW3NpemVdXVwiIGF1dG9jYXBpdGFsaXplXFwkPVwiW1thdXRvY2FwaXRhbGl6ZV1dXCIgYXV0b2NvcnJlY3RcXCQ9XCJbW2F1dG9jb3JyZWN0XV1cIiBvbi1jaGFuZ2U9XCJfb25DaGFuZ2VcIiB0YWJpbmRleFxcJD1cIltbdGFiSW5kZXhdXVwiIGF1dG9zYXZlXFwkPVwiW1thdXRvc2F2ZV1dXCIgcmVzdWx0c1xcJD1cIltbcmVzdWx0c11dXCIgYWNjZXB0XFwkPVwiW1thY2NlcHRdXVwiIG11bHRpcGxlXFwkPVwiW1ttdWx0aXBsZV1dXCI+XG4gIDwvdGVtcGxhdGU+XG5cbiAgPHRlbXBsYXRlIGlkPVwidjFcIj5cbiAgICA8IS0tIE5lZWQgdG8gYmluZCBtYXhsZW5ndGggc28gdGhhdCB0aGUgcGFwZXItaW5wdXQtY2hhci1jb3VudGVyIHdvcmtzIGNvcnJlY3RseSAtLT5cbiAgICA8aXJvbi1pbnB1dCBiaW5kLXZhbHVlPVwie3t2YWx1ZX19XCIgaWQ9XCJpbnB1dFwiIHNsb3Q9XCJpbnB1dFwiIG1heGxlbmd0aFxcJD1cIltbbWF4bGVuZ3RoXV1cIiBhbGxvd2VkLXBhdHRlcm49XCJbW2FsbG93ZWRQYXR0ZXJuXV1cIiBpbnZhbGlkPVwie3tpbnZhbGlkfX1cIiB2YWxpZGF0b3I9XCJbW3ZhbGlkYXRvcl1dXCI+XG4gICAgICA8aW5wdXQgaWQ9XCJuYXRpdmVJbnB1dFwiIGFyaWEtbGFiZWxsZWRieVxcJD1cIltbX2FyaWFMYWJlbGxlZEJ5XV1cIiBhcmlhLWRlc2NyaWJlZGJ5XFwkPVwiW1tfYXJpYURlc2NyaWJlZEJ5XV1cIiBkaXNhYmxlZFxcJD1cIltbZGlzYWJsZWRdXVwiIHRpdGxlXFwkPVwiW1t0aXRsZV1dXCIgdHlwZVxcJD1cIltbdHlwZV1dXCIgcGF0dGVyblxcJD1cIltbcGF0dGVybl1dXCIgcmVxdWlyZWRcXCQ9XCJbW3JlcXVpcmVkXV1cIiBhdXRvY29tcGxldGVcXCQ9XCJbW2F1dG9jb21wbGV0ZV1dXCIgYXV0b2ZvY3VzXFwkPVwiW1thdXRvZm9jdXNdXVwiIGlucHV0bW9kZVxcJD1cIltbaW5wdXRtb2RlXV1cIiBtaW5sZW5ndGhcXCQ9XCJbW21pbmxlbmd0aF1dXCIgbWF4bGVuZ3RoXFwkPVwiW1ttYXhsZW5ndGhdXVwiIG1pblxcJD1cIltbbWluXV1cIiBtYXhcXCQ9XCJbW21heF1dXCIgc3RlcFxcJD1cIltbc3RlcF1dXCIgbmFtZVxcJD1cIltbbmFtZV1dXCIgcGxhY2Vob2xkZXJcXCQ9XCJbW3BsYWNlaG9sZGVyXV1cIiByZWFkb25seVxcJD1cIltbcmVhZG9ubHldXVwiIGxpc3RcXCQ9XCJbW2xpc3RdXVwiIHNpemVcXCQ9XCJbW3NpemVdXVwiIGF1dG9jYXBpdGFsaXplXFwkPVwiW1thdXRvY2FwaXRhbGl6ZV1dXCIgYXV0b2NvcnJlY3RcXCQ9XCJbW2F1dG9jb3JyZWN0XV1cIiBvbi1jaGFuZ2U9XCJfb25DaGFuZ2VcIiB0YWJpbmRleFxcJD1cIltbdGFiSW5kZXhdXVwiIGF1dG9zYXZlXFwkPVwiW1thdXRvc2F2ZV1dXCIgcmVzdWx0c1xcJD1cIltbcmVzdWx0c11dXCIgYWNjZXB0XFwkPVwiW1thY2NlcHRdXVwiIG11bHRpcGxlXFwkPVwiW1ttdWx0aXBsZV1dXCI+XG4gICAgPC9pcm9uLWlucHV0PlxuICA8L3RlbXBsYXRlPlxuXG48L2RvbS1tb2R1bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblBvbHltZXIoe1xuICBpczogJ3BhcGVyLWlucHV0JyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBQYXBlcklucHV0QmVoYXZpb3IsXG4gICAgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3JcbiAgXSxcblxuICBiZWZvcmVSZWdpc3RlcjogZnVuY3Rpb24oKSB7XG4gICAgLy8gV2UgbmVlZCB0byB0ZWxsIHdoaWNoIGtpbmQgb2Ygb2YgdGVtcGxhdGUgdG8gc3RhbXAgYmFzZWQgb25cbiAgICAvLyB3aGF0IGtpbmQgb2YgYGlyb24taW5wdXRgIHdlIGdvdCwgYnV0IGJlY2F1c2Ugb2YgcG9seWZpbGxzIGFuZFxuICAgIC8vIGN1c3RvbSBlbGVtZW50cyBkaWZmZXJlbmNlcyBiZXR3ZWVuIHYwIGFuZCB2MSwgdGhlIHNhZmVzdCBiZXQgaXNcbiAgICAvLyB0byBjaGVjayBhIHBhcnRpY3VsYXIgbWV0aG9kIHdlIGtub3cgdGhlIGlyb24taW5wdXQjMi54IGNhbiBoYXZlLlxuICAgIC8vIElmIGl0IGRvZXNuJ3QgaGF2ZSBpdCwgdGhlbiBpdCdzIGFuIGlyb24taW5wdXQjMS54LlxuICAgIHZhciBpcm9uSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpcm9uLWlucHV0Jyk7XG4gICAgdmFyIHZlcnNpb24gPSB0eXBlb2YgaXJvbklucHV0Ll9pbml0U2xvdHRlZElucHV0ID09ICdmdW5jdGlvbicgPyAndjEnIDogJ3YwJztcbiAgICB2YXIgdGVtcGxhdGUgPSBEb21Nb2R1bGUuaW1wb3J0KCdwYXBlci1pbnB1dCcsICd0ZW1wbGF0ZScpO1xuICAgIHZhciBpbnB1dFRlbXBsYXRlID0gRG9tTW9kdWxlLmltcG9ydCgncGFwZXItaW5wdXQnLCAndGVtcGxhdGUjJyArIHZlcnNpb24pO1xuICAgIHZhciBpbnB1dFBsYWNlaG9sZGVyID0gdGVtcGxhdGUuY29udGVudC5xdWVyeVNlbGVjdG9yKCcjdGVtcGxhdGUtcGxhY2Vob2xkZXInKTtcbiAgICBpZiAoaW5wdXRQbGFjZWhvbGRlcikge1xuICAgICAgaW5wdXRQbGFjZWhvbGRlci5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChpbnB1dFRlbXBsYXRlLmNvbnRlbnQsIGlucHV0UGxhY2Vob2xkZXIpO1xuICAgIH1cbiAgICAvLyBlbHNlIGl0J3MgYWxyZWFkeSBiZWVuIHByb2Nlc3NlZCwgcHJvYmFibHkgaW4gc3VwZXJjbGFzc1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBmb2N1c2FibGUgZWxlbWVudC4gT3ZlcnJpZGRlbiBmcm9tIFBhcGVySW5wdXRCZWhhdmlvclxuICAgKiB0byBjb3JyZWN0bHkgZm9jdXMgdGhlIG5hdGl2ZSBpbnB1dC5cbiAgICovXG4gIGdldCBfZm9jdXNhYmxlRWxlbWVudCgpIHtcbiAgICByZXR1cm4gRWxlbWVudCA/IHRoaXMuaW5wdXRFbGVtZW50Ll9pbnB1dEVsZW1lbnQgOiB0aGlzLmlucHV0RWxlbWVudDtcbiAgfSxcblxuICAvLyBOb3RlOiBUaGlzIGV2ZW50IGlzIG9ubHkgYXZhaWxhYmxlIGluIHRoZSAxLjAgdmVyc2lvbiBvZiB0aGlzIGVsZW1lbnQuXG4gIC8vIEluIDIuMCwgdGhlIGZ1bmN0aW9uYWxpdHkgb2YgYF9vbklyb25JbnB1dFJlYWR5YCBpcyBkb25lIGluXG4gIC8vIFBhcGVySW5wdXRCZWhhdmlvcjo6YXR0YWNoZWQuXG4gIGxpc3RlbmVyczoge1xuICAgICdpcm9uLWlucHV0LXJlYWR5JzogJ19vbklyb25JbnB1dFJlYWR5J1xuICB9LFxuXG4gIF9vbklyb25JbnB1dFJlYWR5OiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5pbnB1dEVsZW1lbnQgJiZcbiAgICAgICAgdGhpcy5fdHlwZXNUaGF0SGF2ZVRleHQuaW5kZXhPZih0aGlzLiQubmF0aXZlSW5wdXQudHlwZSkgIT09IC0xKSB7XG4gICAgICB0aGlzLmFsd2F5c0Zsb2F0TGFiZWwgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIE9ubHkgdmFsaWRhdGUgd2hlbiBhdHRhY2hlZCBpZiB0aGUgaW5wdXQgYWxyZWFkeSBoYXMgYSB2YWx1ZS5cbiAgICBpZiAoISF0aGlzLmlucHV0RWxlbWVudC5iaW5kVmFsdWUpIHtcbiAgICAgIHRoaXMuJC5jb250YWluZXIuX2hhbmRsZVZhbHVlQW5kQXV0b1ZhbGlkYXRlKHRoaXMuaW5wdXRFbGVtZW50KTtcbiAgICB9XG4gIH0sXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWlucHV0L3BhcGVyLWlucHV0LmpzXG4vLyBtb2R1bGUgaWQgPSA4N1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQTExeUFubm91bmNlciB9IGZyb20gJy4uL2lyb24tYTExeS1hbm5vdW5jZXIvaXJvbi1hMTF5LWFubm91bmNlci5qcyc7XG5pbXBvcnQgeyBJcm9uVmFsaWRhdGFibGVCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IvaXJvbi12YWxpZGF0YWJsZS1iZWhhdmlvci5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblBvbHltZXIoe1xuICBfdGVtcGxhdGU6IGBcbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICAgIDxzbG90IGlkPVwiY29udGVudFwiPjwvc2xvdD5cbmAsXG5cbiAgaXM6ICdpcm9uLWlucHV0JyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBJcm9uVmFsaWRhdGFibGVCZWhhdmlvclxuICBdLFxuXG4gIC8qKlxuICAgKiBGaXJlZCB3aGVuZXZlciBgdmFsaWRhdGUoKWAgaXMgY2FsbGVkLlxuICAgKlxuICAgKiBAZXZlbnQgaXJvbi1pbnB1dC12YWxpZGF0ZVxuICAgKi9cblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBwcm9wZXJ0eSBpbnN0ZWFkIG9mIGB2YWx1ZWAgZm9yIHR3by13YXkgZGF0YSBiaW5kaW5nLCBvciB0b1xuICAgICAqIHNldCBhIGRlZmF1bHQgdmFsdWUgZm9yIHRoZSBpbnB1dC4gKipEbyBub3QqKiB1c2UgdGhlIGRpc3RyaWJ1dGVkXG4gICAgICogaW5wdXQncyBgdmFsdWVgIHByb3BlcnR5IHRvIHNldCBhIGRlZmF1bHQgdmFsdWUuXG4gICAgICovXG4gICAgYmluZFZhbHVlOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZWQgcHJvcGVydHkgdGhhdCBlY2hvZXMgYGJpbmRWYWx1ZWAgKG1vc3RseSB1c2VkIGZvciBQb2x5bWVyIDEuMFxuICAgICAqIGJhY2tjb21wYXRpYmlsaXR5LCBpZiB5b3Ugd2VyZSBvbmUtd2F5IGJpbmRpbmcgdG8gdGhlIFBvbHltZXIgMS4wXG4gICAgICogYGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiYCB2YWx1ZSBhdHRyaWJ1dGUpLlxuICAgICAqL1xuICAgIHZhbHVlOiB7XG4gICAgICBjb21wdXRlZDogJ19jb21wdXRlVmFsdWUoYmluZFZhbHVlKSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVnZXgtbGlrZSBsaXN0IG9mIGNoYXJhY3RlcnMgYWxsb3dlZCBhcyBpbnB1dDsgYWxsIGNoYXJhY3RlcnMgbm90IGluIHRoZSBsaXN0XG4gICAgICogd2lsbCBiZSByZWplY3RlZC4gVGhlIHJlY29tbWVuZGVkIGZvcm1hdCBzaG91bGQgYmUgYSBsaXN0IG9mIGFsbG93ZWQgY2hhcmFjdGVycyxcbiAgICAgKiBmb3IgZXhhbXBsZSwgYFthLXpBLVowLTkuKy0hOzpdYC5cbiAgICAgKlxuICAgICAqIFRoaXMgcGF0dGVybiByZXByZXNlbnRzIHRoZSBhbGxvd2VkIGNoYXJhY3RlcnMgZm9yIHRoZSBmaWVsZDsgYXMgdGhlIHVzZXIgaW5wdXRzIHRleHQsXG4gICAgICogZWFjaCBpbmRpdmlkdWFsIGNoYXJhY3RlciB3aWxsIGJlIGNoZWNrZWQgYWdhaW5zdCB0aGUgcGF0dGVybiAocmF0aGVyIHRoYW4gY2hlY2tpbmdcbiAgICAgKiB0aGUgZW50aXJlIHZhbHVlIGFzIGEgd2hvbGUpLiBJZiBhIGNoYXJhY3RlciBpcyBub3QgYSBtYXRjaCwgaXQgd2lsbCBiZSByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIFBhc3RlZCBpbnB1dCB3aWxsIGhhdmUgZWFjaCBjaGFyYWN0ZXIgY2hlY2tlZCBpbmRpdmlkdWFsbHk7IGlmIGFueSBjaGFyYWN0ZXJcbiAgICAgKiBkb2Vzbid0IG1hdGNoIGBhbGxvd2VkUGF0dGVybmAsIHRoZSBlbnRpcmUgcGFzdGVkIHN0cmluZyB3aWxsIGJlIHJlamVjdGVkLlxuICAgICAqXG4gICAgICogTm90ZTogaWYgeW91IHdlcmUgdXNpbmcgYGlyb24taW5wdXRgIGluIDEuMCwgeW91IHdlcmUgYWxzbyByZXF1aXJlZCB0b1xuICAgICAqIHNldCBgcHJldmVudC1pbnZhbGlkLWlucHV0YC4gVGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIGFzIG9mIFBvbHltZXIgMi4wLFxuICAgICAqIGFuZCB3aWxsIGJlIHNldCBhdXRvbWF0aWNhbGx5IGZvciB5b3UgaWYgYW4gYGFsbG93ZWRQYXR0ZXJuYCBpcyBwcm92aWRlZC5cbiAgICAgKlxuICAgICAqL1xuICAgIGFsbG93ZWRQYXR0ZXJuOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gYXV0by12YWxpZGF0ZSB0aGUgaW5wdXQgdmFsdWUgYXMgeW91IHR5cGUuXG4gICAgICovXG4gICAgYXV0b1ZhbGlkYXRlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfVxuICB9LFxuXG4gIG9ic2VydmVyczogW1xuICAgICdfYmluZFZhbHVlQ2hhbmdlZChiaW5kVmFsdWUsIF9pbnB1dEVsZW1lbnQpJ1xuICBdLFxuXG4gIGxpc3RlbmVyczoge1xuICAgICdpbnB1dCc6ICdfb25JbnB1dCcsXG4gICAgJ2tleXByZXNzJzogJ19vbktleXByZXNzJ1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIElyb25BMTF5QW5ub3VuY2VyLnJlcXVlc3RBdmFpbGFiaWxpdHkoKTtcbiAgICB0aGlzLl9wcmV2aW91c1ZhbGlkSW5wdXQgPSAnJztcbiAgICB0aGlzLl9wYXR0ZXJuQWxyZWFkeUNoZWNrZWQgPSBmYWxzZTtcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gSWYgdGhlIGlucHV0IGlzIGFkZGVkIGF0IGEgbGF0ZXIgdGltZSwgdXBkYXRlIHRoZSBpbnRlcm5hbCByZWZlcmVuY2UuXG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSBkb20odGhpcykub2JzZXJ2ZU5vZGVzKGZ1bmN0aW9uKGluZm8pIHtcbiAgICAgIHRoaXMuX2luaXRTbG90dGVkSW5wdXQoKTtcbiAgICB9LmJpbmQodGhpcykpO1xuICB9LFxuXG4gIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcbiAgICAgIGRvbSh0aGlzKS51bm9ic2VydmVOb2Rlcyh0aGlzLl9vYnNlcnZlcik7XG4gICAgICB0aGlzLl9vYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkaXN0cmlidXRlZCA8aW5wdXQ+IGVsZW1lbnQuXG4gICAqL1xuICBnZXQgaW5wdXRFbGVtZW50ICgpIHtcbiAgICByZXR1cm4gdGhpcy5faW5wdXRFbGVtZW50O1xuICB9LFxuXG4gIF9pbml0U2xvdHRlZElucHV0OiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9pbnB1dEVsZW1lbnQgPSB0aGlzLmdldEVmZmVjdGl2ZUNoaWxkcmVuKClbMF07XG5cbiAgICBpZiAodGhpcy5pbnB1dEVsZW1lbnQgJiYgdGhpcy5pbnB1dEVsZW1lbnQudmFsdWUpIHtcbiAgICAgIHRoaXMuYmluZFZhbHVlID0gdGhpcy5pbnB1dEVsZW1lbnQudmFsdWU7XG4gICAgfVxuXG4gICAgdGhpcy5maXJlKCdpcm9uLWlucHV0LXJlYWR5Jyk7XG4gIH0sXG5cbiAgZ2V0IF9wYXR0ZXJuUmVnRXhwKCkge1xuICAgIHZhciBwYXR0ZXJuO1xuICAgIGlmICh0aGlzLmFsbG93ZWRQYXR0ZXJuKSB7XG4gICAgICBwYXR0ZXJuID0gbmV3IFJlZ0V4cCh0aGlzLmFsbG93ZWRQYXR0ZXJuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3dpdGNoICh0aGlzLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICBwYXR0ZXJuID0gL1swLTkuLGUtXS87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc3VwcHJlc3Mge2NoZWNrVHlwZXN9XG4gICAqL1xuICBfYmluZFZhbHVlQ2hhbmdlZDogZnVuY3Rpb24oYmluZFZhbHVlLCBpbnB1dEVsZW1lbnQpIHtcbiAgICAvLyBUaGUgb2JzZXJ2ZXIgY291bGQgaGF2ZSBydW4gYmVmb3JlIGF0dGFjaGVkKCkgd2hlbiB3ZSBoYXZlIGFjdHVhbGx5IGluaXRpYWxpemVkXG4gICAgLy8gdGhpcyBwcm9wZXJ0eS5cbiAgICBpZiAoIWlucHV0RWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChiaW5kVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgaW5wdXRFbGVtZW50LnZhbHVlID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGJpbmRWYWx1ZSAhPT0gaW5wdXRFbGVtZW50LnZhbHVlKXtcbiAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlID0gYmluZFZhbHVlO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmF1dG9WYWxpZGF0ZSkge1xuICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICAgIH1cblxuICAgIC8vIG1hbnVhbGx5IG5vdGlmeSBiZWNhdXNlIHdlIGRvbid0IHdhbnQgdG8gbm90aWZ5IHVudGlsIGFmdGVyIHNldHRpbmcgdmFsdWVcbiAgICB0aGlzLmZpcmUoJ2JpbmQtdmFsdWUtY2hhbmdlZCcsIHt2YWx1ZTogYmluZFZhbHVlfSk7XG4gIH0sXG5cbiAgX29uSW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIE5lZWQgdG8gdmFsaWRhdGUgZWFjaCBvZiB0aGUgY2hhcmFjdGVycyBwYXN0ZWQgaWYgdGhleSBoYXZlbid0XG4gICAgLy8gYmVlbiB2YWxpZGF0ZWQgaW5zaWRlIGBfb25LZXlwcmVzc2AgYWxyZWFkeS5cbiAgICBpZiAodGhpcy5hbGxvd2VkUGF0dGVybiAmJiAhdGhpcy5fcGF0dGVybkFscmVhZHlDaGVja2VkKSB7XG4gICAgICB2YXIgdmFsaWQgPSB0aGlzLl9jaGVja1BhdHRlcm5WYWxpZGl0eSgpO1xuICAgICAgaWYgKCF2YWxpZCkge1xuICAgICAgICB0aGlzLl9hbm5vdW5jZUludmFsaWRDaGFyYWN0ZXIoJ0ludmFsaWQgc3RyaW5nIG9mIGNoYXJhY3RlcnMgbm90IGVudGVyZWQuJyk7XG4gICAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlID0gdGhpcy5fcHJldmlvdXNWYWxpZElucHV0O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmJpbmRWYWx1ZSA9IHRoaXMuX3ByZXZpb3VzVmFsaWRJbnB1dCA9IHRoaXMuaW5wdXRFbGVtZW50LnZhbHVlO1xuICAgIHRoaXMuX3BhdHRlcm5BbHJlYWR5Q2hlY2tlZCA9IGZhbHNlO1xuICB9LFxuXG4gIF9pc1ByaW50YWJsZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBXaGF0IGEgY29udHJvbC9wcmludGFibGUgY2hhcmFjdGVyIGlzIHZhcmllcyB3aWxkbHkgYmFzZWQgb24gdGhlIGJyb3dzZXIuXG4gICAgLy8gLSBtb3N0IGNvbnRyb2wgY2hhcmFjdGVycyAoYXJyb3dzLCBiYWNrc3BhY2UpIGRvIG5vdCBzZW5kIGEgYGtleXByZXNzYCBldmVudFxuICAgIC8vICAgaW4gQ2hyb21lLCBidXQgdGhlICpkbyogb24gRmlyZWZveFxuICAgIC8vIC0gaW4gRmlyZWZveCwgd2hlbiB0aGV5IGRvIHNlbmQgYSBga2V5cHJlc3NgIGV2ZW50LCBjb250cm9sIGNoYXJzIGhhdmVcbiAgICAvLyAgIGEgY2hhckNvZGUgPSAwLCBrZXlDb2RlID0geHggKGZvciBleC4gNDAgZm9yIGRvd24gYXJyb3cpXG4gICAgLy8gLSBwcmludGFibGUgY2hhcmFjdGVycyBhbHdheXMgc2VuZCBhIGtleXByZXNzIGV2ZW50LlxuICAgIC8vIC0gaW4gRmlyZWZveCwgcHJpbnRhYmxlIGNoYXJzIGFsd2F5cyBoYXZlIGEga2V5Q29kZSA9IDAuIEluIENocm9tZSwgdGhlIGtleUNvZGVcbiAgICAvLyAgIGFsd2F5cyBtYXRjaGVzIHRoZSBjaGFyQ29kZS5cbiAgICAvLyBOb25lIG9mIHRoaXMgbWFrZXMgYW55IHNlbnNlLlxuXG4gICAgLy8gRm9yIHRoZXNlIGtleXMsIEFTQ0lJIGNvZGUgPT0gYnJvd3NlciBrZXljb2RlLlxuICAgIHZhciBhbnlOb25QcmludGFibGUgPVxuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gOCkgICB8fCAgLy8gYmFja3NwYWNlXG4gICAgICAoZXZlbnQua2V5Q29kZSA9PSA5KSAgIHx8ICAvLyB0YWJcbiAgICAgIChldmVudC5rZXlDb2RlID09IDEzKSAgfHwgIC8vIGVudGVyXG4gICAgICAoZXZlbnQua2V5Q29kZSA9PSAyNyk7ICAgICAvLyBlc2NhcGVcblxuICAgIC8vIEZvciB0aGVzZSBrZXlzLCBtYWtlIHN1cmUgaXQncyBhIGJyb3dzZXIga2V5Y29kZSBhbmQgbm90IGFuIEFTQ0lJIGNvZGUuXG4gICAgdmFyIG1vek5vblByaW50YWJsZSA9XG4gICAgICAoZXZlbnQua2V5Q29kZSA9PSAxOSkgIHx8ICAvLyBwYXVzZVxuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMjApICB8fCAgLy8gY2FwcyBsb2NrXG4gICAgICAoZXZlbnQua2V5Q29kZSA9PSA0NSkgIHx8ICAvLyBpbnNlcnRcbiAgICAgIChldmVudC5rZXlDb2RlID09IDQ2KSAgfHwgIC8vIGRlbGV0ZVxuICAgICAgKGV2ZW50LmtleUNvZGUgPT0gMTQ0KSB8fCAgLy8gbnVtIGxvY2tcbiAgICAgIChldmVudC5rZXlDb2RlID09IDE0NSkgfHwgIC8vIHNjcm9sbCBsb2NrXG4gICAgICAoZXZlbnQua2V5Q29kZSA+IDMyICYmIGV2ZW50LmtleUNvZGUgPCA0MSkgICB8fCAvLyBwYWdlIHVwL2Rvd24sIGVuZCwgaG9tZSwgYXJyb3dzXG4gICAgICAoZXZlbnQua2V5Q29kZSA+IDExMSAmJiBldmVudC5rZXlDb2RlIDwgMTI0KTsgLy8gZm4ga2V5c1xuXG4gICAgcmV0dXJuICFhbnlOb25QcmludGFibGUgJiYgIShldmVudC5jaGFyQ29kZSA9PSAwICYmIG1vek5vblByaW50YWJsZSk7XG4gIH0sXG5cbiAgX29uS2V5cHJlc3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgaWYgKCF0aGlzLmFsbG93ZWRQYXR0ZXJuICYmIHRoaXMudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlZ2V4cCA9IHRoaXMuX3BhdHRlcm5SZWdFeHA7XG4gICAgaWYgKCFyZWdleHApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgc3BlY2lhbCBrZXlzIGFuZCBiYWNrc3BhY2VcbiAgICBpZiAoZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5IHx8IGV2ZW50LmFsdEtleSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRoZSBwYXR0ZXJuIGVpdGhlciBoZXJlIG9yIGluIGBfb25JbnB1dGAsIGJ1dCBub3QgaW4gYm90aC5cbiAgICB0aGlzLl9wYXR0ZXJuQWxyZWFkeUNoZWNrZWQgPSB0cnVlO1xuXG4gICAgdmFyIHRoaXNDaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShldmVudC5jaGFyQ29kZSk7XG4gICAgaWYgKHRoaXMuX2lzUHJpbnRhYmxlKGV2ZW50KSAmJiAhcmVnZXhwLnRlc3QodGhpc0NoYXIpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgdGhpcy5fYW5ub3VuY2VJbnZhbGlkQ2hhcmFjdGVyKCdJbnZhbGlkIGNoYXJhY3RlciAnICsgdGhpc0NoYXIgKyAnIG5vdCBlbnRlcmVkLicpO1xuICAgIH1cbiAgfSxcblxuICBfY2hlY2tQYXR0ZXJuVmFsaWRpdHk6IGZ1bmN0aW9uKCkge1xuICAgIHZhciByZWdleHAgPSB0aGlzLl9wYXR0ZXJuUmVnRXhwO1xuICAgIGlmICghcmVnZXhwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmlucHV0RWxlbWVudC52YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFyZWdleHAudGVzdCh0aGlzLmlucHV0RWxlbWVudC52YWx1ZVtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIGB2YWx1ZWAgaXMgdmFsaWQuIFRoZSB2YWxpZGF0b3IgcHJvdmlkZWQgaW4gYHZhbGlkYXRvcmAgd2lsbCBiZSB1c2VkIGZpcnN0LFxuICAgKiB0aGVuIGFueSBjb25zdHJhaW50cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdmFsaWQuXG4gICAqL1xuICB2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLmlucHV0RWxlbWVudCkge1xuICAgICAgdGhpcy5pbnZhbGlkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBVc2UgdGhlIG5lc3RlZCBpbnB1dCdzIG5hdGl2ZSB2YWxpZGl0eS5cbiAgICB2YXIgdmFsaWQgPSAgdGhpcy5pbnB1dEVsZW1lbnQuY2hlY2tWYWxpZGl0eSgpO1xuXG4gICAgLy8gT25seSBkbyBleHRyYSBjaGVja2luZyBpZiB0aGUgYnJvd3NlciB0aG91Z2h0IHRoaXMgd2FzIHZhbGlkLlxuICAgIGlmICh2YWxpZCkge1xuICAgICAgLy8gRW1wdHksIHJlcXVpcmVkIGlucHV0IGlzIGludmFsaWRcbiAgICAgIGlmICh0aGlzLnJlcXVpcmVkICYmIHRoaXMuYmluZFZhbHVlID09PSAnJykge1xuICAgICAgICB2YWxpZCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmhhc1ZhbGlkYXRvcigpKSB7XG4gICAgICAgIHZhbGlkID0gSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IudmFsaWRhdGUuY2FsbCh0aGlzLCB0aGlzLmJpbmRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbnZhbGlkID0gIXZhbGlkO1xuICAgIHRoaXMuZmlyZSgnaXJvbi1pbnB1dC12YWxpZGF0ZScpO1xuICAgIHJldHVybiB2YWxpZDtcbiAgfSxcblxuICBfYW5ub3VuY2VJbnZhbGlkQ2hhcmFjdGVyOiBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgdGhpcy5maXJlKCdpcm9uLWFubm91bmNlJywgeyB0ZXh0OiBtZXNzYWdlIH0pO1xuICB9LFxuXG4gIF9jb21wdXRlVmFsdWU6IGZ1bmN0aW9uKGJpbmRWYWx1ZSkge1xuICAgIHJldHVybiBiaW5kVmFsdWU7XG4gIH1cbn0pO1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1pbnB1dC9pcm9uLWlucHV0LmpzXG4vLyBtb2R1bGUgaWQgPSA4OFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIGFzIFBvbHltZXIkMCB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcblxuZXhwb3J0IGNvbnN0IElyb25BMTF5QW5ub3VuY2VyID0gUG9seW1lciQwKHtcbiAgX3RlbXBsYXRlOiBgXG4gICAgPHN0eWxlPlxuICAgICAgOmhvc3Qge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgY2xpcDogcmVjdCgwcHgsMHB4LDBweCwwcHgpO1xuICAgICAgfVxuICAgIDwvc3R5bGU+XG4gICAgPGRpdiBhcmlhLWxpdmVcXCQ9XCJbW21vZGVdXVwiPltbX3RleHRdXTwvZGl2PlxuYCxcblxuICBpczogJ2lyb24tYTExeS1hbm5vdW5jZXInLFxuXG4gIHByb3BlcnRpZXM6IHtcblxuICAgIC8qKlxuICAgICAqIFRoZSB2YWx1ZSBvZiBtb2RlIGlzIHVzZWQgdG8gc2V0IHRoZSBgYXJpYS1saXZlYCBhdHRyaWJ1dGVcbiAgICAgKiBmb3IgdGhlIGVsZW1lbnQgdGhhdCB3aWxsIGJlIGFubm91bmNlZC4gVmFsaWQgdmFsdWVzIGFyZTogYG9mZmAsXG4gICAgICogYHBvbGl0ZWAgYW5kIGBhc3NlcnRpdmVgLlxuICAgICAqL1xuICAgIG1vZGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAncG9saXRlJ1xuICAgIH0sXG5cbiAgICBfdGV4dDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICcnXG4gICAgfVxuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghSXJvbkExMXlBbm5vdW5jZXIuaW5zdGFuY2UpIHtcbiAgICAgIElyb25BMTF5QW5ub3VuY2VyLmluc3RhbmNlID0gdGhpcztcbiAgICB9XG5cbiAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2lyb24tYW5ub3VuY2UnLCB0aGlzLl9vbklyb25Bbm5vdW5jZS5iaW5kKHRoaXMpKTtcbiAgfSxcblxuICAvKipcbiAgICogQ2F1c2UgYSB0ZXh0IHN0cmluZyB0byBiZSBhbm5vdW5jZWQgYnkgc2NyZWVuIHJlYWRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IFRoZSB0ZXh0IHRoYXQgc2hvdWxkIGJlIGFubm91bmNlZC5cbiAgICovXG4gIGFubm91bmNlOiBmdW5jdGlvbih0ZXh0KSB7XG4gICAgdGhpcy5fdGV4dCA9ICcnO1xuICAgIHRoaXMuYXN5bmMoZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLl90ZXh0ID0gdGV4dDtcbiAgICB9LCAxMDApO1xuICB9LFxuXG4gIF9vbklyb25Bbm5vdW5jZTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuZGV0YWlsICYmIGV2ZW50LmRldGFpbC50ZXh0KSB7XG4gICAgICB0aGlzLmFubm91bmNlKGV2ZW50LmRldGFpbC50ZXh0KTtcbiAgICB9XG4gIH1cbn0pO1xuXG5Jcm9uQTExeUFubm91bmNlci5pbnN0YW5jZSA9IG51bGw7XG5cbklyb25BMTF5QW5ub3VuY2VyLnJlcXVlc3RBdmFpbGFiaWxpdHkgPSBmdW5jdGlvbigpIHtcbiAgaWYgKCFJcm9uQTExeUFubm91bmNlci5pbnN0YW5jZSkge1xuICAgIElyb25BMTF5QW5ub3VuY2VyLmluc3RhbmNlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaXJvbi1hMTF5LWFubm91bmNlcicpO1xuICB9XG5cbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChJcm9uQTExeUFubm91bmNlci5pbnN0YW5jZSk7XG59O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHBvbHltZXIvaXJvbi1hMTF5LWFubm91bmNlci9pcm9uLWExMXktYW5ub3VuY2VyLmpzXG4vLyBtb2R1bGUgaWQgPSA4OVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIGFzIFBvbHltZXIkMCB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7e3R5cGU6IChzdHJpbmd8bnVsbCksIGtleTogKHN0cmluZ3xudWxsKSwgdmFsdWU6ICp9fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIElyb25NZXRhKG9wdGlvbnMpIHtcbiAgdGhpcy50eXBlID0gKG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlKSB8fCAnZGVmYXVsdCc7XG4gIHRoaXMua2V5ID0gb3B0aW9ucyAmJiBvcHRpb25zLmtleTtcbiAgaWYgKCd2YWx1ZScgaW4gb3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICB9XG59XG5cbklyb25NZXRhLnR5cGVzID0ge307XG5cbklyb25NZXRhLnByb3RvdHlwZSA9IHtcbiAgZ2V0IHZhbHVlKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgIHZhciBrZXkgPSB0aGlzLmtleTtcblxuICAgIGlmICh0eXBlICYmIGtleSkge1xuICAgICAgcmV0dXJuIElyb25NZXRhLnR5cGVzW3R5cGVdICYmIElyb25NZXRhLnR5cGVzW3R5cGVdW2tleV07XG4gICAgfVxuICB9LFxuXG4gIHNldCB2YWx1ZSh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuICAgIHZhciBrZXkgPSB0aGlzLmtleTtcblxuICAgIGlmICh0eXBlICYmIGtleSkge1xuICAgICAgdHlwZSA9IElyb25NZXRhLnR5cGVzW3R5cGVdID0gSXJvbk1ldGEudHlwZXNbdHlwZV0gfHwge307XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBkZWxldGUgdHlwZVtrZXldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZVtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGdldCBsaXN0KCkge1xuICAgIHZhciB0eXBlID0gdGhpcy50eXBlO1xuXG4gICAgaWYgKHR5cGUpIHtcbiAgICAgIHJldHVybiBPYmplY3Qua2V5cyhJcm9uTWV0YS50eXBlc1t0aGlzLnR5cGVdKS5tYXAoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBtZXRhRGF0YXNbdGhpcy50eXBlXVtrZXldO1xuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIGJ5S2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxufTtcblxuZXhwb3J0IHsgSXJvbk1ldGEgfTtcblxudmFyIG1ldGFEYXRhcyA9IElyb25NZXRhLnR5cGVzO1xuXG5Qb2x5bWVyJDAoe1xuXG4gIGlzOiAnaXJvbi1tZXRhJyxcblxuICBwcm9wZXJ0aWVzOiB7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBtZXRhLWRhdGEuICBBbGwgbWV0YS1kYXRhIG9mIHRoZSBzYW1lIHR5cGUgaXMgc3RvcmVkXG4gICAgICogdG9nZXRoZXIuXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ2RlZmF1bHQnLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUga2V5IHVzZWQgdG8gc3RvcmUgYHZhbHVlYCB1bmRlciB0aGUgYHR5cGVgIG5hbWVzcGFjZS5cbiAgICAgKiBAdHlwZSB7P3N0cmluZ31cbiAgICAgKi9cbiAgICBrZXk6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1ldGEtZGF0YSB0byBzdG9yZSBvciByZXRyaWV2ZS5cbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgbm90aWZ5OiB0cnVlLFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB0cnVlLCBgdmFsdWVgIGlzIHNldCB0byB0aGUgaXJvbi1tZXRhIGluc3RhbmNlIGl0c2VsZi5cbiAgICAgKi9cbiAgICAgc2VsZjoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIG9ic2VydmVyOiAnX3NlbGZDaGFuZ2VkJ1xuICAgIH0sXG5cbiAgICBfX21ldGE6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBjb21wdXRlZDogJ19fY29tcHV0ZU1ldGEodHlwZSwga2V5LCB2YWx1ZSknXG4gICAgfVxuICB9LFxuXG4gIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgaGlkZGVuOiB0cnVlXG4gIH0sXG5cbiAgX19jb21wdXRlTWV0YTogZnVuY3Rpb24odHlwZSwga2V5LCB2YWx1ZSkge1xuICAgIHZhciBtZXRhID0gbmV3IElyb25NZXRhKHtcbiAgICAgIHR5cGU6IHR5cGUsXG4gICAgICBrZXk6IGtleVxuICAgIH0pO1xuXG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG1ldGEudmFsdWUpIHtcbiAgICAgIG1ldGEudmFsdWUgPSB2YWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMudmFsdWUgIT09IG1ldGEudmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBtZXRhLnZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBtZXRhO1xuICB9LFxuXG4gIGdldCBsaXN0KCkge1xuICAgIHJldHVybiB0aGlzLl9fbWV0YSAmJiB0aGlzLl9fbWV0YS5saXN0O1xuICB9LFxuXG4gIF9zZWxmQ2hhbmdlZDogZnVuY3Rpb24oc2VsZikge1xuICAgIGlmIChzZWxmKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdGhpcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBtZXRhIGRhdGEgdmFsdWUgYnkga2V5LlxuICAgKlxuICAgKiBAbWV0aG9kIGJ5S2V5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0YS1kYXRhIHRvIGJlIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHsqfVxuICAgKi9cbiAgYnlLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgIHJldHVybiBuZXcgSXJvbk1ldGEoe1xuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAga2V5OiBrZXlcbiAgICB9KS52YWx1ZTtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9pcm9uLW1ldGEvaXJvbi1tZXRhLmpzXG4vLyBtb2R1bGUgaWQgPSA5MFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgeyBJcm9uQTExeUtleXNCZWhhdmlvciB9IGZyb20gJy4uL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yL2lyb24tYTExeS1rZXlzLWJlaGF2aW9yLmpzJztcbmltcG9ydCB7IElyb25Db250cm9sU3RhdGUgfSBmcm9tICcuLi9pcm9uLWJlaGF2aW9ycy9pcm9uLWNvbnRyb2wtc3RhdGUuanMnO1xuaW1wb3J0IHsgRWxlbWVudCB9IGZyb20gJy4uL3BvbHltZXIvcG9seW1lci1lbGVtZW50LmpzJztcbmltcG9ydCB7IGRvbSB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLmRvbS5qcyc7XG5leHBvcnQgY29uc3QgUGFwZXJJbnB1dEhlbHBlciA9IHt9O1xuUGFwZXJJbnB1dEhlbHBlci5OZXh0TGFiZWxJRCA9IDE7XG5QYXBlcklucHV0SGVscGVyLk5leHRBZGRvbklEID0gMTtcblxuZXhwb3J0IGNvbnN0IFBhcGVySW5wdXRCZWhhdmlvckltcGwgPSB7XG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGlucHV0IGNoYW5nZXMgZHVlIHRvIHVzZXIgaW50ZXJhY3Rpb24uXG4gICAgICpcbiAgICAgKiBAZXZlbnQgY2hhbmdlXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbGFiZWwgZm9yIHRoaXMgaW5wdXQuIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG9cbiAgICAgKiBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LCBiaW5kIHRoaXMgdG9cbiAgICAgKiBgPGxhYmVsPmAncyBjb250ZW50IGFuZCBgaGlkZGVuYCBwcm9wZXJ0eSwgZS5nLlxuICAgICAqIGA8bGFiZWwgaGlkZGVuJD1cIltbIWxhYmVsXV1cIj5bW2xhYmVsXV08L2xhYmVsPmAgaW4geW91ciBgdGVtcGxhdGVgXG4gICAgICovXG4gICAgbGFiZWw6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdmFsdWUgZm9yIHRoaXMgaW5wdXQuIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG9cbiAgICAgKiBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LCBiaW5kIHRoaXMgdG9cbiAgICAgKiB0aGUgYDxpcm9uLWlucHV0PmAncyBgYmluZFZhbHVlYFxuICAgICAqIHByb3BlcnR5LCBvciB0aGUgdmFsdWUgcHJvcGVydHkgb2YgeW91ciBpbnB1dCB0aGF0IGlzIGBub3RpZnk6dHJ1ZWAuXG4gICAgICovXG4gICAgdmFsdWU6IHtcbiAgICAgIG5vdGlmeTogdHJ1ZSxcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBkaXNhYmxlIHRoaXMgaW5wdXQuIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG9cbiAgICAgKiBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LCBiaW5kIHRoaXMgdG9cbiAgICAgKiBib3RoIHRoZSBgPHBhcGVyLWlucHV0LWNvbnRhaW5lcj5gJ3MgYW5kIHRoZSBpbnB1dCdzIGBkaXNhYmxlZGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgZGlzYWJsZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSB2YWx1ZSBpcyBpbnZhbGlkLiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvIGJvdGggdGhlXG4gICAgICogYDxwYXBlci1pbnB1dC1jb250YWluZXI+YCdzIGFuZCB0aGUgaW5wdXQncyBgaW52YWxpZGAgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBJZiBgYXV0b1ZhbGlkYXRlYCBpcyB0cnVlLCB0aGUgYGludmFsaWRgIGF0dHJpYnV0ZSBpcyBtYW5hZ2VkIGF1dG9tYXRpY2FsbHksXG4gICAgICogd2hpY2ggY2FuIGNsb2JiZXIgYXR0ZW1wdHMgdG8gbWFuYWdlIGl0IG1hbnVhbGx5LlxuICAgICAqL1xuICAgIGludmFsaWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICBub3RpZnk6IHRydWVcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRoaXMgdG8gc3BlY2lmeSB0aGUgcGF0dGVybiBhbGxvd2VkIGJ5IGBwcmV2ZW50SW52YWxpZElucHV0YC4gSWZcbiAgICAgKiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgYWxsb3dlZFBhdHRlcm5gXG4gICAgICogcHJvcGVydHkuXG4gICAgICovXG4gICAgYWxsb3dlZFBhdHRlcm46IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiB0aGUgaW5wdXQuIFRoZSBzdXBwb3J0ZWQgdHlwZXMgYXJlIGB0ZXh0YCwgYG51bWJlcmAgYW5kIGBwYXNzd29yZGAuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LFxuICAgICAqIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYHR5cGVgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgZGF0YWxpc3Qgb2YgdGhlIGlucHV0IChpZiBhbnkpLiBUaGlzIHNob3VsZCBtYXRjaCB0aGUgaWQgb2YgYW4gZXhpc3RpbmcgYDxkYXRhbGlzdD5gLlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBsaXN0YCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBsaXN0OiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQSBwYXR0ZXJuIHRvIHZhbGlkYXRlIHRoZSBgaW5wdXRgIHdpdGguIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG9cbiAgICAgKiBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LCBiaW5kIHRoaXMgdG9cbiAgICAgKiB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYHBhdHRlcm5gIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHBhdHRlcm46IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBtYXJrIHRoZSBpbnB1dCBhcyByZXF1aXJlZC4gSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0b1xuICAgICAqIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlIGVsZW1lbnQsIGJpbmQgdGhpcyB0b1xuICAgICAqIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgcmVxdWlyZWRgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHJlcXVpcmVkOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBlcnJvciBtZXNzYWdlIHRvIGRpc3BsYXkgd2hlbiB0aGUgaW5wdXQgaXMgaW52YWxpZC4gSWYgeW91J3JlIHVzaW5nXG4gICAgICogUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlIGVsZW1lbnQsXG4gICAgICogYmluZCB0aGlzIHRvIHRoZSBgPHBhcGVyLWlucHV0LWVycm9yPmAncyBjb250ZW50LCBpZiB1c2luZy5cbiAgICAgKi9cbiAgICBlcnJvck1lc3NhZ2U6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBzaG93IGEgY2hhcmFjdGVyIGNvdW50ZXIuXG4gICAgICovXG4gICAgY2hhckNvdW50ZXI6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGUgZmxvYXRpbmcgbGFiZWwuIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG9cbiAgICAgKiBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LCBiaW5kIHRoaXMgdG9cbiAgICAgKiB0aGUgYDxwYXBlci1pbnB1dC1jb250YWluZXI+YCdzIGBub0xhYmVsRmxvYXRgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIG5vTGFiZWxGbG9hdDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBhbHdheXMgZmxvYXQgdGhlIGxhYmVsLiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvXG4gICAgICogaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2UgZWxlbWVudCwgYmluZCB0aGlzIHRvXG4gICAgICogdGhlIGA8cGFwZXItaW5wdXQtY29udGFpbmVyPmAncyBgYWx3YXlzRmxvYXRMYWJlbGAgcHJvcGVydHkuXG4gICAgICovXG4gICAgYWx3YXlzRmxvYXRMYWJlbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byBhdXRvLXZhbGlkYXRlIHRoZSBpbnB1dCB2YWx1ZS4gSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0b1xuICAgICAqIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlIGVsZW1lbnQsIGJpbmQgdGhpcyB0b1xuICAgICAqIHRoZSBgPHBhcGVyLWlucHV0LWNvbnRhaW5lcj5gJ3MgYGF1dG9WYWxpZGF0ZWAgcHJvcGVydHkuXG4gICAgICovXG4gICAgYXV0b1ZhbGlkYXRlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE5hbWUgb2YgdGhlIHZhbGlkYXRvciB0byB1c2UuIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG9cbiAgICAgKiBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZSBlbGVtZW50LCBiaW5kIHRoaXMgdG9cbiAgICAgKiB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYHZhbGlkYXRvcmAgcHJvcGVydHkuXG4gICAgICovXG4gICAgdmFsaWRhdG9yOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLy8gSFRNTElucHV0RWxlbWVudCBhdHRyaWJ1dGVzIGZvciBiaW5kaW5nIGlmIG5lZWRlZFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYGF1dG9jb21wbGV0ZWAgcHJvcGVydHkuXG4gICAgICovXG4gICAgYXV0b2NvbXBsZXRlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ29mZidcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYGF1dG9mb2N1c2AgcHJvcGVydHkuXG4gICAgICovXG4gICAgYXV0b2ZvY3VzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgb2JzZXJ2ZXI6ICdfYXV0b2ZvY3VzQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYGlucHV0bW9kZWAgcHJvcGVydHkuXG4gICAgICovXG4gICAgaW5wdXRtb2RlOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1pbmltdW0gbGVuZ3RoIG9mIHRoZSBpbnB1dCB2YWx1ZS5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgbWlubGVuZ3RoYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBtaW5sZW5ndGg6IHtcbiAgICAgIHR5cGU6IE51bWJlclxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgbWF4aW11bSBsZW5ndGggb2YgdGhlIGlucHV0IHZhbHVlLlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBtYXhsZW5ndGhgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIG1heGxlbmd0aDoge1xuICAgICAgdHlwZTogTnVtYmVyXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIChudW1lcmljIG9yIGRhdGUtdGltZSkgaW5wdXQgdmFsdWUuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYG1pbmAgcHJvcGVydHkuXG4gICAgICovXG4gICAgbWluOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gKG51bWVyaWMgb3IgZGF0ZS10aW1lKSBpbnB1dCB2YWx1ZS5cbiAgICAgKiBDYW4gYmUgYSBTdHJpbmcgKGUuZy4gYFwiMjAwMC0wMS0wMVwiYCkgb3IgYSBOdW1iZXIgKGUuZy4gYDJgKS5cbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgbWF4YCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBtYXg6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaW1pdHMgdGhlIG51bWVyaWMgb3IgZGF0ZS10aW1lIGluY3JlbWVudHMuXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYHN0ZXBgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHN0ZXA6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgbmFtZWAgcHJvcGVydHkuXG4gICAgICovXG4gICAgbmFtZToge1xuICAgICAgdHlwZTogU3RyaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEEgcGxhY2Vob2xkZXIgc3RyaW5nIGluIGFkZGl0aW9uIHRvIHRoZSBsYWJlbC4gSWYgdGhpcyBpcyBzZXQsIHRoZSBsYWJlbCB3aWxsIGFsd2F5cyBmbG9hdC5cbiAgICAgKi9cbiAgICBwbGFjZWhvbGRlcjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgLy8gbmVlZCB0byBzZXQgYSBkZWZhdWx0IHNvIF9jb21wdXRlQWx3YXlzRmxvYXRMYWJlbCBpcyBydW5cbiAgICAgIHZhbHVlOiAnJ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZSBgPGlucHV0IGlzPVwiaXJvbi1pbnB1dFwiPmAncyBgcmVhZG9ubHlgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHJlYWRvbmx5OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBzaXplYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBzaXplOiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuXG4gICAgLy8gTm9uc3RhbmRhcmQgYXR0cmlidXRlcyBmb3IgYmluZGluZyBpZiBuZWVkZWRcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBhdXRvY2FwaXRhbGl6ZWAgcHJvcGVydHkuXG4gICAgICovXG4gICAgYXV0b2NhcGl0YWxpemU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnbm9uZSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYGF1dG9jb3JyZWN0YCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBhdXRvY29ycmVjdDoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICdvZmYnXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIElmIHlvdSdyZSB1c2luZyBQYXBlcklucHV0QmVoYXZpb3IgdG8gaW1wbGVtZW50IHlvdXIgb3duIHBhcGVyLWlucHV0LWxpa2VcbiAgICAgKiBlbGVtZW50LCBiaW5kIHRoaXMgdG8gdGhlIGA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBhdXRvc2F2ZWAgcHJvcGVydHksXG4gICAgICogdXNlZCB3aXRoIHR5cGU9c2VhcmNoLlxuICAgICAqL1xuICAgIGF1dG9zYXZlOiB7XG4gICAgICB0eXBlOiBTdHJpbmdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYHJlc3VsdHNgIHByb3BlcnR5LFxuICAgICAqIHVzZWQgd2l0aCB0eXBlPXNlYXJjaC5cbiAgICAgKi9cbiAgICByZXN1bHRzOiB7XG4gICAgICB0eXBlOiBOdW1iZXJcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgeW91J3JlIHVzaW5nIFBhcGVySW5wdXRCZWhhdmlvciB0byBpbXBsZW1lbnQgeW91ciBvd24gcGFwZXItaW5wdXQtbGlrZVxuICAgICAqIGVsZW1lbnQsIGJpbmQgdGhpcyB0byB0aGUgYDxpbnB1dCBpcz1cImlyb24taW5wdXRcIj5gJ3MgYGFjY2VwdGAgcHJvcGVydHksXG4gICAgICogdXNlZCB3aXRoIHR5cGU9ZmlsZS5cbiAgICAgKi9cbiAgICBhY2NlcHQ6IHtcbiAgICAgIHR5cGU6IFN0cmluZ1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBJZiB5b3UncmUgdXNpbmcgUGFwZXJJbnB1dEJlaGF2aW9yIHRvIGltcGxlbWVudCB5b3VyIG93biBwYXBlci1pbnB1dC1saWtlXG4gICAgICogZWxlbWVudCwgYmluZCB0aGlzIHRvIHRoZWA8aW5wdXQgaXM9XCJpcm9uLWlucHV0XCI+YCdzIGBtdWx0aXBsZWAgcHJvcGVydHksXG4gICAgICogdXNlZCB3aXRoIHR5cGU9ZmlsZS5cbiAgICAgKi9cbiAgICBtdWx0aXBsZToge1xuICAgICAgdHlwZTogQm9vbGVhblxuICAgIH0sXG5cbiAgICBfYXJpYURlc2NyaWJlZEJ5OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJydcbiAgICB9LFxuXG4gICAgX2FyaWFMYWJlbGxlZEJ5OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJydcbiAgICB9XG5cbiAgfSxcblxuICBsaXN0ZW5lcnM6IHtcbiAgICAnYWRkb24tYXR0YWNoZWQnOiAnX29uQWRkb25BdHRhY2hlZCcsXG4gIH0sXG5cbiAga2V5QmluZGluZ3M6IHtcbiAgICAnc2hpZnQrdGFiOmtleWRvd24nOiAnX29uU2hpZnRUYWJEb3duJ1xuICB9LFxuXG4gIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgdGFiaW5kZXg6IDBcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgaW5wdXQgZWxlbWVudC5cbiAgICovXG4gIGdldCBpbnB1dEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuJC5pbnB1dDtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgZm9jdXNhYmxlIGVsZW1lbnQuXG4gICAqL1xuICBnZXQgX2ZvY3VzYWJsZUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRFbGVtZW50O1xuICB9LFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFRoZXNlIHR5cGVzIGhhdmUgc29tZSBkZWZhdWx0IHBsYWNlaG9sZGVyIHRleHQ7IG92ZXJsYXBwaW5nXG4gICAgLy8gdGhlIGxhYmVsIG9uIHRvcCBvZiBpdCBsb29rcyB0ZXJyaWJsZS4gQXV0by1mbG9hdCB0aGUgbGFiZWwgaW4gdGhpcyBjYXNlLlxuICAgIHRoaXMuX3R5cGVzVGhhdEhhdmVUZXh0ID0gW1wiZGF0ZVwiLCBcImRhdGV0aW1lXCIsIFwiZGF0ZXRpbWUtbG9jYWxcIiwgXCJtb250aFwiLFxuICAgICAgICBcInRpbWVcIiwgXCJ3ZWVrXCIsIFwiZmlsZVwiXTtcbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fdXBkYXRlQXJpYUxhYmVsbGVkQnkoKTtcblxuICAgIC8vIEluIHRoZSAyLjAgdmVyc2lvbiBvZiB0aGUgZWxlbWVudCwgdGhpcyBpcyBoYW5kbGVkIGluIGBvbklyb25JbnB1dFJlYWR5YCxcbiAgICAvLyBpLmUuIGFmdGVyIHRoZSBuYXRpdmUgaW5wdXQgaGFzIGZpbmlzaGVkIGRpc3RyaWJ1dGluZy4gSW4gdGhlIDEuMCB2ZXJzaW9uLFxuICAgIC8vIHRoZSBpbnB1dCBpcyBpbiB0aGUgc2hhZG93IHRyZWUsIHNvIGl0J3MgYWxyZWFkeSBhdmFpbGFibGUuXG4gICAgaWYgKCFFbGVtZW50ICYmIHRoaXMuaW5wdXRFbGVtZW50ICYmXG4gICAgICAgIHRoaXMuX3R5cGVzVGhhdEhhdmVUZXh0LmluZGV4T2YodGhpcy5pbnB1dEVsZW1lbnQudHlwZSkgIT09IC0xKSB7XG4gICAgICB0aGlzLmFsd2F5c0Zsb2F0TGFiZWwgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBfYXBwZW5kU3RyaW5nV2l0aFNwYWNlOiBmdW5jdGlvbihzdHIsIG1vcmUpIHtcbiAgICBpZiAoc3RyKSB7XG4gICAgICBzdHIgPSBzdHIgKyAnICcgKyBtb3JlO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBtb3JlO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xuICB9LFxuXG4gIF9vbkFkZG9uQXR0YWNoZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIHRhcmdldCA9IGRvbShldmVudCkucm9vdFRhcmdldDtcbiAgICBpZiAodGFyZ2V0LmlkKSB7XG4gICAgICB0aGlzLl9hcmlhRGVzY3JpYmVkQnkgPSB0aGlzLl9hcHBlbmRTdHJpbmdXaXRoU3BhY2UodGhpcy5fYXJpYURlc2NyaWJlZEJ5LCB0YXJnZXQuaWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaWQgPSAncGFwZXItaW5wdXQtYWRkLW9uLScgKyBQYXBlcklucHV0SGVscGVyLk5leHRBZGRvbklEKys7XG4gICAgICB0YXJnZXQuaWQgPSBpZDtcbiAgICAgIHRoaXMuX2FyaWFEZXNjcmliZWRCeSA9IHRoaXMuX2FwcGVuZFN0cmluZ1dpdGhTcGFjZSh0aGlzLl9hcmlhRGVzY3JpYmVkQnksIGlkKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlcyB0aGUgaW5wdXQgZWxlbWVudCBhbmQgc2V0cyBhbiBlcnJvciBzdHlsZSBpZiBuZWVkZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICB2YWxpZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW5wdXRFbGVtZW50LnZhbGlkYXRlKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcndhcmQgZm9jdXMgdG8gaW5wdXRFbGVtZW50LiBPdmVycmlkZW4gZnJvbSBJcm9uQ29udHJvbFN0YXRlLlxuICAgKi9cbiAgX2ZvY3VzQmx1ckhhbmRsZXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgSXJvbkNvbnRyb2xTdGF0ZS5fZm9jdXNCbHVySGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50KTtcblxuICAgIC8vIEZvcndhcmQgdGhlIGZvY3VzIHRvIHRoZSBuZXN0ZWQgaW5wdXQuXG4gICAgaWYgKHRoaXMuZm9jdXNlZCAmJiAhdGhpcy5fc2hpZnRUYWJQcmVzc2VkICYmIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnQuZm9jdXMoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEhhbmRsZXIgdGhhdCBpcyBjYWxsZWQgd2hlbiBhIHNoaWZ0K3RhYiBrZXlwcmVzcyBpcyBkZXRlY3RlZCBieSB0aGUgbWVudS5cbiAgICpcbiAgICogQHBhcmFtIHtDdXN0b21FdmVudH0gZXZlbnQgQSBrZXkgY29tYmluYXRpb24gZXZlbnQuXG4gICAqL1xuICBfb25TaGlmdFRhYkRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIG9sZFRhYkluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG4gICAgdGhpcy5fc2hpZnRUYWJQcmVzc2VkID0gdHJ1ZTtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICB0aGlzLmFzeW5jKGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4Jywgb2xkVGFiSW5kZXgpO1xuICAgICAgdGhpcy5fc2hpZnRUYWJQcmVzc2VkID0gZmFsc2U7XG4gICAgfSwgMSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIElmIGBhdXRvVmFsaWRhdGVgIGlzIHRydWUsIHRoZW4gdmFsaWRhdGVzIHRoZSBlbGVtZW50LlxuICAgKi9cbiAgX2hhbmRsZUF1dG9WYWxpZGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuYXV0b1ZhbGlkYXRlKVxuICAgICAgdGhpcy52YWxpZGF0ZSgpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXN0b3JlcyB0aGUgY3Vyc29yIHRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiBhZnRlciB1cGRhdGluZyB0aGUgdmFsdWUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdWYWx1ZSBUaGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgc2F2ZWQuXG4gICAqL1xuICB1cGRhdGVWYWx1ZUFuZFByZXNlcnZlQ2FyZXQ6IGZ1bmN0aW9uKG5ld1ZhbHVlKSB7XG4gICAgLy8gTm90IGFsbCBlbGVtZW50cyBtaWdodCBoYXZlIHNlbGVjdGlvbiwgYW5kIGV2ZW4gaWYgdGhleSBoYXZlIHRoZVxuICAgIC8vIHJpZ2h0IHByb3BlcnRpZXMsIGFjY2Vzc2luZyB0aGVtIG1pZ2h0IHRocm93IGFuIGV4Y2VwdGlvbiAobGlrZSBmb3JcbiAgICAvLyA8aW5wdXQgdHlwZT1udW1iZXI+KVxuICAgIHRyeSB7XG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLmlucHV0RWxlbWVudC5zZWxlY3Rpb25TdGFydDtcbiAgICAgIHRoaXMudmFsdWUgPSBuZXdWYWx1ZTtcblxuICAgICAgLy8gVGhlIGN1cnNvciBhdXRvbWF0aWNhbGx5IGp1bXBzIHRvIHRoZSBlbmQgYWZ0ZXIgcmUtc2V0dGluZyB0aGUgdmFsdWUsXG4gICAgICAvLyBzbyByZXN0b3JlIGl0IHRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvbi5cbiAgICAgIHRoaXMuaW5wdXRFbGVtZW50LnNlbGVjdGlvblN0YXJ0ID0gc3RhcnQ7XG4gICAgICB0aGlzLmlucHV0RWxlbWVudC5zZWxlY3Rpb25FbmQgPSBzdGFydDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBKdXN0IHNldCB0aGUgdmFsdWUgYW5kIGdpdmUgdXAgb24gdGhlIGNhcmV0LlxuICAgICAgdGhpcy52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfSxcblxuICBfY29tcHV0ZUFsd2F5c0Zsb2F0TGFiZWw6IGZ1bmN0aW9uKGFsd2F5c0Zsb2F0TGFiZWwsIHBsYWNlaG9sZGVyKSB7XG4gICAgcmV0dXJuIHBsYWNlaG9sZGVyIHx8IGFsd2F5c0Zsb2F0TGFiZWw7XG4gIH0sXG5cbiAgX3VwZGF0ZUFyaWFMYWJlbGxlZEJ5OiBmdW5jdGlvbigpIHtcbiAgICB2YXIgbGFiZWwgPSBkb20odGhpcy5yb290KS5xdWVyeVNlbGVjdG9yKCdsYWJlbCcpO1xuICAgIGlmICghbGFiZWwpIHtcbiAgICAgIHRoaXMuX2FyaWFMYWJlbGxlZEJ5ID0gJyc7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsYWJlbGxlZEJ5O1xuICAgIGlmIChsYWJlbC5pZCkge1xuICAgICAgbGFiZWxsZWRCeSA9IGxhYmVsLmlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYWJlbGxlZEJ5ID0gJ3BhcGVyLWlucHV0LWxhYmVsLScgKyBQYXBlcklucHV0SGVscGVyLk5leHRMYWJlbElEKys7XG4gICAgICBsYWJlbC5pZCA9IGxhYmVsbGVkQnk7XG4gICAgfVxuICAgIHRoaXMuX2FyaWFMYWJlbGxlZEJ5ID0gbGFiZWxsZWRCeTtcbiAgfSxcblxuICBfb25DaGFuZ2U6ZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAvLyBJbiB0aGUgU2hhZG93IERPTSwgdGhlIGBjaGFuZ2VgIGV2ZW50IGlzIG5vdCBsZWFrZWQgaW50byB0aGVcbiAgICAvLyBhbmNlc3RvciB0cmVlLCBzbyB3ZSBtdXN0IGRvIHRoaXMgbWFudWFsbHkuXG4gICAgLy8gU2VlIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJjb21wb25lbnRzL3NwZWMvc2hhZG93LyNldmVudHMtdGhhdC1hcmUtbm90LWxlYWtlZC1pbnRvLWFuY2VzdG9yLXRyZWVzLlxuICAgIGlmICh0aGlzLnNoYWRvd1Jvb3QpIHtcbiAgICAgIHRoaXMuZmlyZShldmVudC50eXBlLCB7c291cmNlRXZlbnQ6IGV2ZW50fSwge1xuICAgICAgICBub2RlOiB0aGlzLFxuICAgICAgICBidWJibGVzOiBldmVudC5idWJibGVzLFxuICAgICAgICBjYW5jZWxhYmxlOiBldmVudC5jYW5jZWxhYmxlXG4gICAgICB9KTtcbiAgICB9XG4gIH0sXG5cbiAgX2F1dG9mb2N1c0NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIEZpcmVmb3ggZG9lc24ndCByZXNwZWN0IHRoZSBhdXRvZm9jdXMgYXR0cmlidXRlIGlmIGl0J3MgYXBwbGllZCBhZnRlclxuICAgIC8vIHRoZSBwYWdlIGlzIGxvYWRlZCAoQ2hyb21lL1dlYktpdCBkbyByZXNwZWN0IGl0KSwgcHJldmVudGluZyBhblxuICAgIC8vIGF1dG9mb2N1cyBhdHRyaWJ1dGUgc3BlY2lmaWVkIGluIG1hcmt1cCBmcm9tIHRha2luZyBlZmZlY3Qgd2hlbiB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHVwZ3JhZGVkLiBBcyBhIHdvcmthcm91bmQsIGlmIHRoZSBhdXRvZm9jdXMgcHJvcGVydHkgaXMgc2V0LFxuICAgIC8vIGFuZCB0aGUgZm9jdXMgaGFzbid0IGFscmVhZHkgYmVlbiBtb3ZlZCBlbHNld2hlcmUsIHdlIHRha2UgZm9jdXMuXG4gICAgaWYgKHRoaXMuYXV0b2ZvY3VzICYmIHRoaXMuX2ZvY3VzYWJsZUVsZW1lbnQpIHtcblxuICAgICAgLy8gSW4gSUUgMTEsIHRoZSBkZWZhdWx0IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgY2FuIGJlIHRoZSBwYWdlJ3NcbiAgICAgIC8vIG91dGVybW9zdCBodG1sIGVsZW1lbnQsIGJ1dCB0aGVyZSBhcmUgYWxzbyBjYXNlcyAodW5kZXIgdGhlXG4gICAgICAvLyBwb2x5ZmlsbD8pIGluIHdoaWNoIHRoZSBhY3RpdmVFbGVtZW50IGlzIG5vdCBhIHJlYWwgSFRNTEVsZW1lbnQsIGJ1dFxuICAgICAgLy8ganVzdCBhIHBsYWluIG9iamVjdC4gV2UgaWRlbnRpZnkgdGhlIGxhdHRlciBjYXNlIGFzIGhhdmluZyBubyB2YWxpZFxuICAgICAgLy8gYWN0aXZlRWxlbWVudC5cbiAgICAgIHZhciBhY3RpdmVFbGVtZW50ID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgIHZhciBpc0FjdGl2ZUVsZW1lbnRWYWxpZCA9IGFjdGl2ZUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcblxuICAgICAgLy8gSGFzIHNvbWUgb3RoZXIgZWxlbWVudCBoYXMgYWxyZWFkeSB0YWtlbiB0aGUgZm9jdXM/XG4gICAgICB2YXIgaXNTb21lRWxlbWVudEFjdGl2ZSA9IGlzQWN0aXZlRWxlbWVudFZhbGlkICYmXG4gICAgICAgICAgYWN0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSAmJlxuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQgIT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDsgLyogSUUgMTEgKi9cbiAgICAgIGlmICghaXNTb21lRWxlbWVudEFjdGl2ZSkge1xuICAgICAgICAvLyBObyBzcGVjaWZpYyBlbGVtZW50IGhhcyB0YWtlbiB0aGUgZm9jdXMgeWV0LCBzbyB3ZSBjYW4gdGFrZSBpdC5cbiAgICAgICAgdGhpcy5fZm9jdXNhYmxlRWxlbWVudC5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IFBhcGVySW5wdXRCZWhhdmlvciA9IFtcbiAgSXJvbkNvbnRyb2xTdGF0ZSxcbiAgSXJvbkExMXlLZXlzQmVoYXZpb3IsXG4gIFBhcGVySW5wdXRCZWhhdmlvckltcGxcbl07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC1iZWhhdmlvci5qc1xuLy8gbW9kdWxlIGlkID0gOTFcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvdHlwb2dyYXBoeS5qcyc7XG5pbXBvcnQgeyBQYXBlcklucHV0QWRkb25CZWhhdmlvciB9IGZyb20gJy4vcGFwZXItaW5wdXQtYWRkb24tYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcblBvbHltZXIoe1xuICBfdGVtcGxhdGU6IGBcbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgZmxvYXQ6IHJpZ2h0O1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY2FwdGlvbjtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY2hhci1jb3VudGVyO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaGlkZGVuXSkge1xuICAgICAgICBkaXNwbGF5OiBub25lICFpbXBvcnRhbnQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0LWNvbnRleHQoW2Rpcj1cInJ0bFwiXSkge1xuICAgICAgICBmbG9hdDogbGVmdDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPHNwYW4+W1tfY2hhckNvdW50ZXJTdHJdXTwvc3Bhbj5cbmAsXG5cbiAgaXM6ICdwYXBlci1pbnB1dC1jaGFyLWNvdW50ZXInLFxuXG4gIGJlaGF2aW9yczogW1xuICAgIFBhcGVySW5wdXRBZGRvbkJlaGF2aW9yXG4gIF0sXG5cbiAgcHJvcGVydGllczoge1xuICAgIF9jaGFyQ291bnRlclN0cjoge1xuICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgdmFsdWU6ICcwJ1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBvdmVycmlkZXMgdGhlIHVwZGF0ZSBmdW5jdGlvbiBpbiBQYXBlcklucHV0QWRkb25CZWhhdmlvci5cbiAgICogQHBhcmFtIHt7XG4gICAqICAgaW5wdXRFbGVtZW50OiAoRWxlbWVudHx1bmRlZmluZWQpLFxuICAgKiAgIHZhbHVlOiAoc3RyaW5nfHVuZGVmaW5lZCksXG4gICAqICAgaW52YWxpZDogYm9vbGVhblxuICAgKiB9fSBzdGF0ZSAtXG4gICAqICAgICBpbnB1dEVsZW1lbnQ6IFRoZSBpbnB1dCBlbGVtZW50LlxuICAgKiAgICAgdmFsdWU6IFRoZSBpbnB1dCB2YWx1ZS5cbiAgICogICAgIGludmFsaWQ6IFRydWUgaWYgdGhlIGlucHV0IHZhbHVlIGlzIGludmFsaWQuXG4gICAqL1xuICB1cGRhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5pbnB1dEVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGF0ZS52YWx1ZSA9IHN0YXRlLnZhbHVlIHx8ICcnO1xuXG4gICAgdmFyIGNvdW50ZXIgPSBzdGF0ZS52YWx1ZS50b1N0cmluZygpLmxlbmd0aC50b1N0cmluZygpO1xuXG4gICAgaWYgKHN0YXRlLmlucHV0RWxlbWVudC5oYXNBdHRyaWJ1dGUoJ21heGxlbmd0aCcpKSB7XG4gICAgICBjb3VudGVyICs9ICcvJyArIHN0YXRlLmlucHV0RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ21heGxlbmd0aCcpO1xuICAgIH1cblxuICAgIHRoaXMuX2NoYXJDb3VudGVyU3RyID0gY291bnRlcjtcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC1jaGFyLWNvdW50ZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi4vaXJvbi1mbGV4LWxheW91dC9pcm9uLWZsZXgtbGF5b3V0LmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvdHlwb2dyYXBoeS5qcyc7XG5pbXBvcnQgeyBQb2x5bWVyIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXItZm4uanMnO1xuaW1wb3J0IHsgZGFzaFRvQ2FtZWxDYXNlIH0gZnJvbSAnLi4vcG9seW1lci9saWIvdXRpbHMvY2FzZS1tYXAuanMnO1xuaW1wb3J0IHsgZG9tIH0gZnJvbSAnLi4vcG9seW1lci9saWIvbGVnYWN5L3BvbHltZXIuZG9tLmpzJztcblBvbHltZXIoe1xuICBfdGVtcGxhdGU6IGBcbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgICAgICBwYWRkaW5nOiA4cHggMDtcblxuICAgICAgICAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1zaGFyZWQtaW5wdXQtc3R5bGU6IHtcbiAgICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7IC8qIHRvIG1ha2UgYSBzdGFja2luZyBjb250ZXh0ICovXG4gICAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgICAgICBib3gtc2hhZG93OiBub25lO1xuICAgICAgICAgIHBhZGRpbmc6IDA7XG4gICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgICAgbWF4LXdpZHRoOiAxMDAlO1xuICAgICAgICAgIGJhY2tncm91bmQ6IHRyYW5zcGFyZW50O1xuICAgICAgICAgIGJvcmRlcjogbm9uZTtcbiAgICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWlucHV0LWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgICAgICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XG4gICAgICAgICAgdGV4dC1hbGlnbjogaW5oZXJpdDtcbiAgICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogYm90dG9tO1xuXG4gICAgICAgICAgQGFwcGx5IC0tcGFwZXItZm9udC1zdWJoZWFkO1xuICAgICAgICB9O1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lcjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2lubGluZV0pIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSB7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBvcGFjaXR5OiAwLjMzO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1kaXNhYmxlZDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICBbaGlkZGVuXSB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmUgIWltcG9ydGFudDtcbiAgICAgIH1cblxuICAgICAgLmZsb2F0ZWQtbGFiZWwtcGxhY2Vob2xkZXIge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNhcHRpb247XG4gICAgICB9XG5cbiAgICAgIC51bmRlcmxpbmUge1xuICAgICAgICBoZWlnaHQ6IDJweDtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgfVxuXG4gICAgICAuZm9jdXNlZC1saW5lIHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZpdDtcbiAgICAgICAgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkIHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1mb2N1cy1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuXG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcbiAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogY2VudGVyIGNlbnRlcjtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHNjYWxlM2QoMCwxLDEpO1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlM2QoMCwxLDEpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci11bmRlcmxpbmUtZm9jdXM7XG4gICAgICB9XG5cbiAgICAgIC51bmRlcmxpbmUuaXMtaGlnaGxpZ2h0ZWQgLmZvY3VzZWQtbGluZSB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBub25lO1xuICAgICAgICB0cmFuc2Zvcm06IG5vbmU7XG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gMC4yNXM7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjI1cztcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci10cmFuc2l0aW9uLWVhc2luZztcbiAgICAgIH1cblxuICAgICAgLnVuZGVybGluZS5pcy1pbnZhbGlkIC5mb2N1c2VkLWxpbmUge1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1pbnZhbGlkLWNvbG9yLCB2YXIoLS1lcnJvci1jb2xvcikpO1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogbm9uZTtcbiAgICAgICAgdHJhbnNmb3JtOiBub25lO1xuICAgICAgICAtd2Via2l0LXRyYW5zaXRpb246IC13ZWJraXQtdHJhbnNmb3JtIDAuMjVzO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4yNXM7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdHJhbnNpdGlvbi1lYXNpbmc7XG4gICAgICB9XG5cbiAgICAgIC51bmZvY3VzZWQtbGluZSB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1maXQ7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBzb2xpZCB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItY29sb3IsIHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci11bmRlcmxpbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIC51bmZvY3VzZWQtbGluZSB7XG4gICAgICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQ7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWNvbG9yLCB2YXIoLS1zZWNvbmRhcnktdGV4dC1jb2xvcikpO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItdW5kZXJsaW5lLWRpc2FibGVkO1xuICAgICAgfVxuXG4gICAgICAuaW5wdXQtd3JhcHBlciB7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1ob3Jpem9udGFsO1xuICAgICAgICBAYXBwbHkgLS1sYXlvdXQtY2VudGVyO1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIC5pbnB1dC1jb250ZW50IHtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZsZXgtYXV0bztcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LXJlbGF0aXZlO1xuICAgICAgICBtYXgtd2lkdGg6IDEwMCU7XG4gICAgICB9XG5cbiAgICAgIC5pbnB1dC1jb250ZW50IDo6c2xvdHRlZChsYWJlbCksXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWxhYmVsKSB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICByaWdodDogMDtcbiAgICAgICAgbGVmdDogMDtcbiAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIGZvbnQ6IGluaGVyaXQ7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItY29sb3IsIHZhcigtLXNlY29uZGFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gMC4yNXMsIHdpZHRoIDAuMjVzO1xuICAgICAgICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMC4yNXMsIHdpZHRoIDAuMjVzO1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IGxlZnQgdG9wO1xuICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiBsZWZ0IHRvcDtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1ub3dyYXA7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtc3ViaGVhZDtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWxhYmVsO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci10cmFuc2l0aW9uLWVhc2luZztcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQubGFiZWwtaXMtZmxvYXRpbmcgOjpzbG90dGVkKGxhYmVsKSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmxhYmVsLWlzLWZsb2F0aW5nIDo6c2xvdHRlZCgucGFwZXItaW5wdXQtbGFiZWwpIHtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZVkoLTc1JSkgc2NhbGUoMC43NSk7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWSgtNzUlKSBzY2FsZSgwLjc1KTtcblxuICAgICAgICAvKiBTaW5jZSB3ZSBzY2FsZSB0byA3NS8xMDAgb2YgdGhlIHNpemUsIHdlIGFjdHVhbGx5IGhhdmUgMTAwLzc1IG9mIHRoZVxuICAgICAgICBvcmlnaW5hbCBzcGFjZSBub3cgYXZhaWxhYmxlICovXG4gICAgICAgIHdpZHRoOiAxMzMlO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1sYWJlbC1mbG9hdGluZztcbiAgICAgIH1cblxuICAgICAgOmhvc3QtY29udGV4dChbZGlyPVwicnRsXCJdKSAuaW5wdXQtY29udGVudC5sYWJlbC1pcy1mbG9hdGluZyA6OnNsb3R0ZWQobGFiZWwpLFxuICAgICAgOmhvc3QtY29udGV4dChbZGlyPVwicnRsXCJdKSAuaW5wdXQtY29udGVudC5sYWJlbC1pcy1mbG9hdGluZyA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWxhYmVsKSB7XG4gICAgICAgIC8qIFRPRE8obm9tcyk6IEZpZ3VyZSBvdXQgd2h5IGxlYXZpbmcgdGhlIHdpZHRoIGF0IDEzMyUgYmVmb3JlIHRoZSBhbmltYXRpb25cbiAgICAgICAgICogYWN0dWFsbHkgbWFrZXNcbiAgICAgICAgICogaXQgd2lkZXIgb24gdGhlIHJpZ2h0IHNpZGUsIG5vdCBsZWZ0IHNpZGUsIGFzIHlvdSB3b3VsZCBleHBlY3QgaW4gUlRMICovXG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IHJpZ2h0IHRvcDtcbiAgICAgICAgdHJhbnNmb3JtLW9yaWdpbjogcmlnaHQgdG9wO1xuICAgICAgfVxuXG4gICAgICAuaW5wdXQtY29udGVudC5sYWJlbC1pcy1oaWdobGlnaHRlZCA6OnNsb3R0ZWQobGFiZWwpLFxuICAgICAgLmlucHV0LWNvbnRlbnQubGFiZWwtaXMtaGlnaGxpZ2h0ZWQgOjpzbG90dGVkKC5wYXBlci1pbnB1dC1sYWJlbCkge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWZvY3VzLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWxhYmVsLWZvY3VzO1xuICAgICAgfVxuXG4gICAgICAuaW5wdXQtY29udGVudC5pcy1pbnZhbGlkIDo6c2xvdHRlZChsYWJlbCksXG4gICAgICAuaW5wdXQtY29udGVudC5pcy1pbnZhbGlkIDo6c2xvdHRlZCgucGFwZXItaW5wdXQtbGFiZWwpIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1pbnZhbGlkLWNvbG9yLCB2YXIoLS1lcnJvci1jb2xvcikpO1xuICAgICAgfVxuXG4gICAgICAuaW5wdXQtY29udGVudC5sYWJlbC1pcy1oaWRkZW4gOjpzbG90dGVkKGxhYmVsKSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmxhYmVsLWlzLWhpZGRlbiA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWxhYmVsKSB7XG4gICAgICAgIHZpc2liaWxpdHk6IGhpZGRlbjtcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKGlyb24taW5wdXQpIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLXNoYXJlZC1pbnB1dC1zdHlsZTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKGlucHV0KSxcbiAgICAgIC5pbnB1dC1jb250ZW50IDo6c2xvdHRlZCh0ZXh0YXJlYSksXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQoaXJvbi1hdXRvZ3Jvdy10ZXh0YXJlYSksXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWlucHV0KSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1zaGFyZWQtaW5wdXQtc3R5bGU7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1pbnB1dDtcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQgOjpzbG90dGVkKGlucHV0KTo6LXdlYmtpdC1vdXRlci1zcGluLWJ1dHRvbixcbiAgICAgIC5pbnB1dC1jb250ZW50IDo6c2xvdHRlZChpbnB1dCk6Oi13ZWJraXQtaW5uZXItc3Bpbi1idXR0b24ge1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1jb250YWluZXItaW5wdXQtd2Via2l0LXNwaW5uZXI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5pbnB1dC1jb250ZW50LmZvY3VzZWQgOjpzbG90dGVkKGlucHV0KSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmZvY3VzZWQgOjpzbG90dGVkKHRleHRhcmVhKSxcbiAgICAgIC5pbnB1dC1jb250ZW50LmZvY3VzZWQgOjpzbG90dGVkKGlyb24tYXV0b2dyb3ctdGV4dGFyZWEpLFxuICAgICAgLmlucHV0LWNvbnRlbnQuZm9jdXNlZCA6OnNsb3R0ZWQoLnBhcGVyLWlucHV0LWlucHV0KSB7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWNvbnRhaW5lci1pbnB1dC1mb2N1cztcbiAgICAgIH1cblxuICAgICAgLmlucHV0LWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQoaW5wdXQpLFxuICAgICAgLmlucHV0LWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQodGV4dGFyZWEpLFxuICAgICAgLmlucHV0LWNvbnRlbnQuaXMtaW52YWxpZCA6OnNsb3R0ZWQoaXJvbi1hdXRvZ3Jvdy10ZXh0YXJlYSksXG4gICAgICAuaW5wdXQtY29udGVudC5pcy1pbnZhbGlkIDo6c2xvdHRlZCgucGFwZXItaW5wdXQtaW5wdXQpIHtcbiAgICAgICAgQGFwcGx5IC0tcGFwZXItaW5wdXQtY29udGFpbmVyLWlucHV0LWludmFsaWQ7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC5wcmVmaXggOjpzbG90dGVkKCopIHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LXN1YmhlYWQ7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1mbGV4LW5vbmU7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LXByZWZpeDtcbiAgICAgIH1cblxuICAgICAgLnN1ZmZpeCA6OnNsb3R0ZWQoKikge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtc3ViaGVhZDtcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWZsZXgtbm9uZTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1pbnB1dC1zdWZmaXg7XG4gICAgICB9XG5cbiAgICAgIC8qIEZpcmVmb3ggc2V0cyBhIG1pbi13aWR0aCBvbiB0aGUgaW5wdXQsIHdoaWNoIGNhbiBjYXVzZSBsYXlvdXQgaXNzdWVzICovXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQoaW5wdXQpIHtcbiAgICAgICAgbWluLXdpZHRoOiAwO1xuICAgICAgfVxuXG4gICAgICAuaW5wdXQtY29udGVudCA6OnNsb3R0ZWQodGV4dGFyZWEpIHtcbiAgICAgICAgcmVzaXplOiBub25lO1xuICAgICAgfVxuXG4gICAgICAuYWRkLW9uLWNvbnRlbnQge1xuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XG4gICAgICB9XG5cbiAgICAgIC5hZGQtb24tY29udGVudC5pcy1pbnZhbGlkIDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItaW52YWxpZC1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgLmFkZC1vbi1jb250ZW50LmlzLWhpZ2hsaWdodGVkIDo6c2xvdHRlZCgqKSB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItZm9jdXMtY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBjbGFzcz1cImZsb2F0ZWQtbGFiZWwtcGxhY2Vob2xkZXJcIiBhcmlhLWhpZGRlbj1cInRydWVcIiBoaWRkZW49XCJbW25vTGFiZWxGbG9hdF1dXCI+Jm5ic3A7PC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwiaW5wdXQtd3JhcHBlclwiPlxuICAgICAgPHNwYW4gY2xhc3M9XCJwcmVmaXhcIj48c2xvdCBuYW1lPVwicHJlZml4XCI+PC9zbG90Pjwvc3Bhbj5cblxuICAgICAgPGRpdiBjbGFzc1xcJD1cIltbX2NvbXB1dGVJbnB1dENvbnRlbnRDbGFzcyhub0xhYmVsRmxvYXQsYWx3YXlzRmxvYXRMYWJlbCxmb2N1c2VkLGludmFsaWQsX2lucHV0SGFzQ29udGVudCldXVwiIGlkPVwibGFiZWxBbmRJbnB1dENvbnRhaW5lclwiPlxuICAgICAgICA8c2xvdCBuYW1lPVwibGFiZWxcIj48L3Nsb3Q+XG4gICAgICAgIDxzbG90IG5hbWU9XCJpbnB1dFwiPjwvc2xvdD5cbiAgICAgIDwvZGl2PlxuXG4gICAgICA8c3BhbiBjbGFzcz1cInN1ZmZpeFwiPjxzbG90IG5hbWU9XCJzdWZmaXhcIj48L3Nsb3Q+PC9zcGFuPlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzc1xcJD1cIltbX2NvbXB1dGVVbmRlcmxpbmVDbGFzcyhmb2N1c2VkLGludmFsaWQpXV1cIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJ1bmZvY3VzZWQtbGluZVwiPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzcz1cImZvY3VzZWQtbGluZVwiPjwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBjbGFzc1xcJD1cIltbX2NvbXB1dGVBZGRPbkNvbnRlbnRDbGFzcyhmb2N1c2VkLGludmFsaWQpXV1cIj5cbiAgICAgIDxzbG90IG5hbWU9XCJhZGQtb25cIj48L3Nsb3Q+XG4gICAgPC9kaXY+XG5gLFxuXG4gIGlzOiAncGFwZXItaW5wdXQtY29udGFpbmVyJyxcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gZGlzYWJsZSB0aGUgZmxvYXRpbmcgbGFiZWwuIFRoZSBsYWJlbCBkaXNhcHBlYXJzIHdoZW4gdGhlIGlucHV0IHZhbHVlIGlzXG4gICAgICogbm90IG51bGwuXG4gICAgICovXG4gICAgbm9MYWJlbEZsb2F0OiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIGFsd2F5cyBmbG9hdCB0aGUgZmxvYXRpbmcgbGFiZWwuXG4gICAgICovXG4gICAgYWx3YXlzRmxvYXRMYWJlbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGUgYXR0cmlidXRlIHRvIGxpc3RlbiBmb3IgdmFsdWUgY2hhbmdlcyBvbi5cbiAgICAgKi9cbiAgICBhdHRyRm9yVmFsdWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnYmluZC12YWx1ZSdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHRvIHRydWUgdG8gYXV0by12YWxpZGF0ZSB0aGUgaW5wdXQgdmFsdWUgd2hlbiBpdCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIGF1dG9WYWxpZGF0ZToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBpbnB1dCBpcyBpbnZhbGlkLiBUaGlzIHByb3BlcnR5IGlzIHNldCBhdXRvbWF0aWNhbGx5IHdoZW4gdGhlIGlucHV0IHZhbHVlXG4gICAgICogY2hhbmdlcyBpZiBhdXRvLXZhbGlkYXRpbmcsIG9yIHdoZW4gdGhlIGBpcm9uLWlucHV0LXZhbGlkYXRlYCBldmVudCBpcyBoZWFyZCBmcm9tIGEgY2hpbGQuXG4gICAgICovXG4gICAgaW52YWxpZDoge1xuICAgICAgb2JzZXJ2ZXI6ICdfaW52YWxpZENoYW5nZWQnLFxuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoZSBpbnB1dCBoYXMgZm9jdXMuXG4gICAgICovXG4gICAgZm9jdXNlZDoge1xuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgbm90aWZ5OiB0cnVlXG4gICAgfSxcblxuICAgIF9hZGRvbnM6IHtcbiAgICAgIHR5cGU6IEFycmF5XG4gICAgICAvLyBkbyBub3Qgc2V0IGEgZGVmYXVsdCB2YWx1ZSBoZXJlIGludGVudGlvbmFsbHkgLSBpdCB3aWxsIGJlIGluaXRpYWxpemVkIGxhemlseSB3aGVuIGFcbiAgICAgIC8vIGRpc3RyaWJ1dGVkIGNoaWxkIGlzIGF0dGFjaGVkLCB3aGljaCBtYXkgb2NjdXIgYmVmb3JlIGNvbmZpZ3VyYXRpb24gZm9yIHRoaXMgZWxlbWVudFxuICAgICAgLy8gaW4gcG9seWZpbGwuXG4gICAgfSxcblxuICAgIF9pbnB1dEhhc0NvbnRlbnQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2VcbiAgICB9LFxuXG4gICAgX2lucHV0U2VsZWN0b3I6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnaW5wdXQsaXJvbi1pbnB1dCx0ZXh0YXJlYSwucGFwZXItaW5wdXQtaW5wdXQnXG4gICAgfSxcblxuICAgIF9ib3VuZE9uRm9jdXM6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25Gb2N1cy5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfYm91bmRPbkJsdXI6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25CbHVyLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9ib3VuZE9uSW5wdXQ6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25JbnB1dC5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfYm91bmRWYWx1ZUNoYW5nZWQ6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25WYWx1ZUNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbGlzdGVuZXJzOiB7XG4gICAgJ2FkZG9uLWF0dGFjaGVkJzogJ19vbkFkZG9uQXR0YWNoZWQnLFxuICAgICdpcm9uLWlucHV0LXZhbGlkYXRlJzogJ19vbklyb25JbnB1dFZhbGlkYXRlJ1xuICB9LFxuXG4gIGdldCBfdmFsdWVDaGFuZ2VkRXZlbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXR0ckZvclZhbHVlICsgJy1jaGFuZ2VkJztcbiAgfSxcblxuICBnZXQgX3Byb3BlcnR5Rm9yVmFsdWUoKSB7XG4gICAgcmV0dXJuIGRhc2hUb0NhbWVsQ2FzZSh0aGlzLmF0dHJGb3JWYWx1ZSk7XG4gIH0sXG5cbiAgZ2V0IF9pbnB1dEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIGRvbSh0aGlzKS5xdWVyeVNlbGVjdG9yKHRoaXMuX2lucHV0U2VsZWN0b3IpO1xuICB9LFxuXG4gIGdldCBfaW5wdXRFbGVtZW50VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lucHV0RWxlbWVudFt0aGlzLl9wcm9wZXJ0eUZvclZhbHVlXSB8fCB0aGlzLl9pbnB1dEVsZW1lbnQudmFsdWU7XG4gIH0sXG5cbiAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuICAgIGlmICghdGhpcy5fYWRkb25zKSB7XG4gICAgICB0aGlzLl9hZGRvbnMgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMuX2JvdW5kT25Gb2N1cywgdHJ1ZSk7XG4gICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fYm91bmRPbkJsdXIsIHRydWUpO1xuICB9LFxuXG4gIGF0dGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5hdHRyRm9yVmFsdWUpIHtcbiAgICAgIHRoaXMuX2lucHV0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHRoaXMuX3ZhbHVlQ2hhbmdlZEV2ZW50LCB0aGlzLl9ib3VuZFZhbHVlQ2hhbmdlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl9vbklucHV0KTtcbiAgICB9XG5cbiAgICAvLyBPbmx5IHZhbGlkYXRlIHdoZW4gYXR0YWNoZWQgaWYgdGhlIGlucHV0IGFscmVhZHkgaGFzIGEgdmFsdWUuXG4gICAgaWYgKHRoaXMuX2lucHV0RWxlbWVudFZhbHVlICYmIHRoaXMuX2lucHV0RWxlbWVudFZhbHVlICE9ICcnKSB7XG4gICAgICB0aGlzLl9oYW5kbGVWYWx1ZUFuZEF1dG9WYWxpZGF0ZSh0aGlzLl9pbnB1dEVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYW5kbGVWYWx1ZSh0aGlzLl9pbnB1dEVsZW1lbnQpO1xuICAgIH1cbiAgfSxcblxuICBfb25BZGRvbkF0dGFjaGVkOiBmdW5jdGlvbihldmVudCkge1xuICAgIGlmICghdGhpcy5fYWRkb25zKSB7XG4gICAgICB0aGlzLl9hZGRvbnMgPSBbXTtcbiAgICB9XG4gICAgdmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICBpZiAodGhpcy5fYWRkb25zLmluZGV4T2YodGFyZ2V0KSA9PT0gLTEpIHtcbiAgICAgIHRoaXMuX2FkZG9ucy5wdXNoKHRhcmdldCk7XG4gICAgICBpZiAodGhpcy5pc0F0dGFjaGVkKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZVZhbHVlKHRoaXMuX2lucHV0RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIF9vbkZvY3VzOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9zZXRGb2N1c2VkKHRydWUpO1xuICB9LFxuXG4gIF9vbkJsdXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NldEZvY3VzZWQoZmFsc2UpO1xuICAgIHRoaXMuX2hhbmRsZVZhbHVlQW5kQXV0b1ZhbGlkYXRlKHRoaXMuX2lucHV0RWxlbWVudCk7XG4gIH0sXG5cbiAgX29uSW5wdXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5faGFuZGxlVmFsdWVBbmRBdXRvVmFsaWRhdGUoZXZlbnQudGFyZ2V0KTtcbiAgfSxcblxuICBfb25WYWx1ZUNoYW5nZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdmFyIGlucHV0ID0gZXZlbnQudGFyZ2V0O1xuXG4gICAgLy8gUHJvYmxlbTogaWYgdGhlIGlucHV0IGlzIHJlcXVpcmVkIGJ1dCBoYXMgbm8gdGV4dCBlbnRlcmVkLCB3ZSBzaG91bGRcbiAgICAvLyBvbmx5IHZhbGlkYXRlIGl0IG9uIGJsdXIgKHNvIHRoYXQgYW4gZW1wdHkgZm9ybSBkb2Vzbid0IGNvbWUgdXAgcmVkXG4gICAgLy8gaW1tZWRpYXRlbHk7IGhvd2V2ZXIsIGluIHRoaXMgaGFuZGxlciwgd2UgZG9uJ3Qga25vdyB3aGV0aGVyIHRoaXMgaXNcbiAgICAvLyB0aGUgYm9vdGluZyB1cCB2YWx1ZSBvciBhIHZhbHVlIGluIHRoZSBmdXR1cmUuIEkgYW0gYXNzdW1pbmcgdGhhdCB0aGVcbiAgICAvLyBjYXNlICB3ZSBjYXJlIGFib3V0IG1hbmlmZXN0cyBpdHNlbGYgd2hlbiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLlxuICAgIC8vIElmIHRoaXMgY2F1c2VzIGZ1dHVyZSBwcm9ibGVtcywgd2UgbmVlZCB0byBkbyBzb21ldGhpbmcgbGlrZSB0cmFjayB3aGV0aGVyXG4gICAgLy8gdGhlIGlyb24taW5wdXQtcmVhZHkgZXZlbnQgaGFzIGZpcmVkLCBhbmQgdGhpcyBoYW5kbGVyIGNhbWUgYmVmb3JlIHRoYXQuXG5cbiAgICBpZiAoaW5wdXQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2hhbmRsZVZhbHVlQW5kQXV0b1ZhbGlkYXRlKGV2ZW50LnRhcmdldCk7XG4gIH0sXG5cbiAgX2hhbmRsZVZhbHVlOiBmdW5jdGlvbihpbnB1dEVsZW1lbnQpIHtcbiAgICB2YXIgdmFsdWUgPSB0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZTtcblxuICAgIC8vIHR5cGU9XCJudW1iZXJcIiBoYWNrIG5lZWRlZCBiZWNhdXNlIHRoaXMudmFsdWUgaXMgZW1wdHkgdW50aWwgaXQncyB2YWxpZFxuICAgIGlmICh2YWx1ZSB8fCB2YWx1ZSA9PT0gMCB8fCAoaW5wdXRFbGVtZW50LnR5cGUgPT09ICdudW1iZXInICYmICFpbnB1dEVsZW1lbnQuY2hlY2tWYWxpZGl0eSgpKSkge1xuICAgICAgdGhpcy5faW5wdXRIYXNDb250ZW50ID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5faW5wdXRIYXNDb250ZW50ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGVBZGRvbnMoe1xuICAgICAgaW5wdXRFbGVtZW50OiBpbnB1dEVsZW1lbnQsXG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBpbnZhbGlkOiB0aGlzLmludmFsaWRcbiAgICB9KTtcbiAgfSxcblxuICBfaGFuZGxlVmFsdWVBbmRBdXRvVmFsaWRhdGU6IGZ1bmN0aW9uKGlucHV0RWxlbWVudCkge1xuICAgIGlmICh0aGlzLmF1dG9WYWxpZGF0ZSAmJiBpbnB1dEVsZW1lbnQpIHtcbiAgICAgIHZhciB2YWxpZDtcblxuICAgICAgaWYgKGlucHV0RWxlbWVudC52YWxpZGF0ZSkge1xuICAgICAgICB2YWxpZCA9IGlucHV0RWxlbWVudC52YWxpZGF0ZSh0aGlzLl9pbnB1dEVsZW1lbnRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWxpZCA9IGlucHV0RWxlbWVudC5jaGVja1ZhbGlkaXR5KCk7XG4gICAgICB9XG4gICAgICB0aGlzLmludmFsaWQgPSAhdmFsaWQ7XG4gICAgfVxuXG4gICAgLy8gQ2FsbCB0aGlzIGxhc3QgdG8gbm90aWZ5IHRoZSBhZGQtb25zLlxuICAgIHRoaXMuX2hhbmRsZVZhbHVlKGlucHV0RWxlbWVudCk7XG4gIH0sXG5cbiAgX29uSXJvbklucHV0VmFsaWRhdGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgdGhpcy5pbnZhbGlkID0gdGhpcy5faW5wdXRFbGVtZW50LmludmFsaWQ7XG4gIH0sXG5cbiAgX2ludmFsaWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fYWRkb25zKSB7XG4gICAgICB0aGlzLnVwZGF0ZUFkZG9ucyh7aW52YWxpZDogdGhpcy5pbnZhbGlkfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgdG8gdXBkYXRlIHRoZSBzdGF0ZSBvZiBhZGQtb25zLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGUgQWRkLW9uIHN0YXRlLlxuICAgKi9cbiAgdXBkYXRlQWRkb25zOiBmdW5jdGlvbihzdGF0ZSkge1xuICAgIGZvciAodmFyIGFkZG9uLCBpbmRleCA9IDA7IGFkZG9uID0gdGhpcy5fYWRkb25zW2luZGV4XTsgaW5kZXgrKykge1xuICAgICAgYWRkb24udXBkYXRlKHN0YXRlKTtcbiAgICB9XG4gIH0sXG5cbiAgX2NvbXB1dGVJbnB1dENvbnRlbnRDbGFzczogZnVuY3Rpb24obm9MYWJlbEZsb2F0LCBhbHdheXNGbG9hdExhYmVsLCBmb2N1c2VkLCBpbnZhbGlkLCBfaW5wdXRIYXNDb250ZW50KSB7XG4gICAgdmFyIGNscyA9ICdpbnB1dC1jb250ZW50JztcbiAgICBpZiAoIW5vTGFiZWxGbG9hdCkge1xuICAgICAgdmFyIGxhYmVsID0gdGhpcy5xdWVyeVNlbGVjdG9yKCdsYWJlbCcpO1xuXG4gICAgICBpZiAoYWx3YXlzRmxvYXRMYWJlbCB8fCBfaW5wdXRIYXNDb250ZW50KSB7XG4gICAgICAgIGNscyArPSAnIGxhYmVsLWlzLWZsb2F0aW5nJztcbiAgICAgICAgLy8gSWYgdGhlIGxhYmVsIGlzIGZsb2F0aW5nLCBpZ25vcmUgYW55IG9mZnNldHMgdGhhdCBtYXkgaGF2ZSBiZWVuXG4gICAgICAgIC8vIGFwcGxpZWQgZnJvbSBhIHByZWZpeCBlbGVtZW50LlxuICAgICAgICB0aGlzLiQubGFiZWxBbmRJbnB1dENvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdzdGF0aWMnO1xuXG4gICAgICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICAgICAgY2xzICs9ICcgaXMtaW52YWxpZCc7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9jdXNlZCkge1xuICAgICAgICAgIGNscyArPSBcIiBsYWJlbC1pcy1oaWdobGlnaHRlZFwiO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXaGVuIHRoZSBsYWJlbCBpcyBub3QgZmxvYXRpbmcsIGl0IHNob3VsZCBvdmVybGFwIHRoZSBpbnB1dCBlbGVtZW50LlxuICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICB0aGlzLiQubGFiZWxBbmRJbnB1dENvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgICBjbHMgKz0gJyBpcy1pbnZhbGlkJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoX2lucHV0SGFzQ29udGVudCkge1xuICAgICAgICBjbHMgKz0gJyBsYWJlbC1pcy1oaWRkZW4nO1xuICAgICAgfVxuICAgICAgaWYgKGludmFsaWQpIHtcbiAgICAgICAgY2xzICs9ICcgaXMtaW52YWxpZCc7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmb2N1c2VkKSB7XG4gICAgICBjbHMgKz0gJyBmb2N1c2VkJztcbiAgICB9XG4gICAgcmV0dXJuIGNscztcbiAgfSxcblxuICBfY29tcHV0ZVVuZGVybGluZUNsYXNzOiBmdW5jdGlvbihmb2N1c2VkLCBpbnZhbGlkKSB7XG4gICAgdmFyIGNscyA9ICd1bmRlcmxpbmUnO1xuICAgIGlmIChpbnZhbGlkKSB7XG4gICAgICBjbHMgKz0gJyBpcy1pbnZhbGlkJztcbiAgICB9IGVsc2UgaWYgKGZvY3VzZWQpIHtcbiAgICAgIGNscyArPSAnIGlzLWhpZ2hsaWdodGVkJ1xuICAgIH1cbiAgICByZXR1cm4gY2xzO1xuICB9LFxuXG4gIF9jb21wdXRlQWRkT25Db250ZW50Q2xhc3M6IGZ1bmN0aW9uKGZvY3VzZWQsIGludmFsaWQpIHtcbiAgICB2YXIgY2xzID0gJ2FkZC1vbi1jb250ZW50JztcbiAgICBpZiAoaW52YWxpZCkge1xuICAgICAgY2xzICs9ICcgaXMtaW52YWxpZCc7XG4gICAgfSBlbHNlIGlmIChmb2N1c2VkKSB7XG4gICAgICBjbHMgKz0gJyBpcy1oaWdobGlnaHRlZCdcbiAgICB9XG4gICAgcmV0dXJuIGNscztcbiAgfVxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1pbnB1dC9wYXBlci1pbnB1dC1jb250YWluZXIuanNcbi8vIG1vZHVsZSBpZCA9IDkzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCAnLi4vcG9seW1lci9wb2x5bWVyLmpzJztcbmltcG9ydCAnLi4vcGFwZXItc3R5bGVzL2RlZmF1bHQtdGhlbWUuanMnO1xuaW1wb3J0ICcuLi9wYXBlci1zdHlsZXMvdHlwb2dyYXBoeS5qcyc7XG5pbXBvcnQgeyBQYXBlcklucHV0QWRkb25CZWhhdmlvciB9IGZyb20gJy4vcGFwZXItaW5wdXQtYWRkb24tYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcblBvbHltZXIoe1xuICBfdGVtcGxhdGU6IGBcbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgdmlzaWJpbGl0eTogaGlkZGVuO1xuXG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1pbnB1dC1jb250YWluZXItaW52YWxpZC1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNhcHRpb247XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWlucHV0LWVycm9yO1xuICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgIGxlZnQ6MDtcbiAgICAgICAgcmlnaHQ6MDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2ludmFsaWRdKSB7XG4gICAgICAgIHZpc2liaWxpdHk6IHZpc2libGU7XG4gICAgICB9O1xuICAgIDwvc3R5bGU+XG5cbiAgICA8c2xvdD48L3Nsb3Q+XG5gLFxuXG4gIGlzOiAncGFwZXItaW5wdXQtZXJyb3InLFxuXG4gIGJlaGF2aW9yczogW1xuICAgIFBhcGVySW5wdXRBZGRvbkJlaGF2aW9yXG4gIF0sXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIGVycm9yIGlzIHNob3dpbmcuXG4gICAgICovXG4gICAgaW52YWxpZDoge1xuICAgICAgcmVhZE9ubHk6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICB0eXBlOiBCb29sZWFuXG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBUaGlzIG92ZXJyaWRlcyB0aGUgdXBkYXRlIGZ1bmN0aW9uIGluIFBhcGVySW5wdXRBZGRvbkJlaGF2aW9yLlxuICAgKiBAcGFyYW0ge3tcbiAgICogICBpbnB1dEVsZW1lbnQ6IChFbGVtZW50fHVuZGVmaW5lZCksXG4gICAqICAgdmFsdWU6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAgICogICBpbnZhbGlkOiBib29sZWFuXG4gICAqIH19IHN0YXRlIC1cbiAgICogICAgIGlucHV0RWxlbWVudDogVGhlIGlucHV0IGVsZW1lbnQuXG4gICAqICAgICB2YWx1ZTogVGhlIGlucHV0IHZhbHVlLlxuICAgKiAgICAgaW52YWxpZDogVHJ1ZSBpZiB0aGUgaW5wdXQgdmFsdWUgaXMgaW52YWxpZC5cbiAgICovXG4gIHVwZGF0ZTogZnVuY3Rpb24oc3RhdGUpIHtcbiAgICB0aGlzLl9zZXRJbnZhbGlkKHN0YXRlLmludmFsaWQpO1xuICB9XG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLWlucHV0L3BhcGVyLWlucHV0LWVycm9yLmpzXG4vLyBtb2R1bGUgaWQgPSA5NFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzJztcbmltcG9ydCB7IFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciB9IGZyb20gJy4uL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCB7IGFmdGVyTmV4dFJlbmRlciB9IGZyb20gJy4uL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuanMnO1xuaW1wb3J0IHsgUGFwZXJJbmt5Rm9jdXNCZWhhdmlvckltcGwgfSBmcm9tICcuLi9wYXBlci1iZWhhdmlvcnMvcGFwZXItaW5reS1mb2N1cy1iZWhhdmlvci5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci1jaGVja2JveFwiPlxuICA8dGVtcGxhdGUgc3RyaXAtd2hpdGVzcGFjZT1cIlwiPlxuICAgIDxzdHlsZT5cbiAgICAgIDpob3N0IHtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB3aGl0ZS1zcGFjZTogbm93cmFwO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1zaXplOiB2YXIoLS1wYXBlci1jaGVja2JveC1zaXplLCAxOHB4KTtcbiAgICAgICAgLyogLTFweCBpcyBhIHNlbnRpbmVsIGZvciB0aGUgZGVmYXVsdCBhbmQgaXMgcmVwbGFjZWQgaW4gXFxgYXR0YWNoZWRcXGAuICovXG4gICAgICAgIC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1pbmstc2l6ZTogdmFyKC0tcGFwZXItY2hlY2tib3gtaW5rLXNpemUsIC0xcHgpO1xuICAgICAgICBAYXBwbHkgLS1wYXBlci1mb250LWNvbW1vbi1iYXNlO1xuICAgICAgICBsaW5lLWhlaWdodDogMDtcbiAgICAgICAgLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2hpZGRlbl0pIHtcbiAgICAgICAgZGlzcGxheTogbm9uZSAhaW1wb3J0YW50O1xuICAgICAgfVxuXG4gICAgICA6aG9zdCg6Zm9jdXMpIHtcbiAgICAgICAgb3V0bGluZTogbm9uZTtcbiAgICAgIH1cblxuICAgICAgLmhpZGRlbiB7XG4gICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgICNjaGVja2JveENvbnRhaW5lciB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICB3aWR0aDogdmFyKC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1zaXplKTtcbiAgICAgICAgaGVpZ2h0OiB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUpO1xuICAgICAgICBtaW4td2lkdGg6IHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZSk7XG4gICAgICAgIG1hcmdpbjogdmFyKC0tcGFwZXItY2hlY2tib3gtbWFyZ2luLCBpbml0aWFsKTtcbiAgICAgICAgdmVydGljYWwtYWxpZ246IHZhcigtLXBhcGVyLWNoZWNrYm94LXZlcnRpY2FsLWFsaWduLCBtaWRkbGUpO1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci1jaGVja2JveC11bmNoZWNrZWQtYmFja2dyb3VuZC1jb2xvciwgdHJhbnNwYXJlbnQpO1xuICAgICAgfVxuXG4gICAgICAjaW5rIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuXG4gICAgICAgIC8qIENlbnRlciB0aGUgcmlwcGxlIGluIHRoZSBjaGVja2JveCBieSBuZWdhdGl2ZSBvZmZzZXR0aW5nIGl0IGJ5XG4gICAgICAgICAqIChpbmtXaWR0aCAtIHJpcHBsZVdpZHRoKSAvIDIgKi9cbiAgICAgICAgdG9wOiBjYWxjKDBweCAtICh2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LWluay1zaXplKSAtIHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZSkpIC8gMik7XG4gICAgICAgIGxlZnQ6IGNhbGMoMHB4IC0gKHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtaW5rLXNpemUpIC0gdmFyKC0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1zaXplKSkgLyAyKTtcbiAgICAgICAgd2lkdGg6IHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtaW5rLXNpemUpO1xuICAgICAgICBoZWlnaHQ6IHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtaW5rLXNpemUpO1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtdW5jaGVja2VkLWluay1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgIG9wYWNpdHk6IDAuNjtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0LWNvbnRleHQoW2Rpcj1cInJ0bFwiXSkgI2luayB7XG4gICAgICAgIHJpZ2h0OiBjYWxjKDBweCAtICh2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LWluay1zaXplKSAtIHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZSkpIC8gMik7XG4gICAgICAgIGxlZnQ6IGF1dG87XG4gICAgICB9XG5cbiAgICAgICNpbmtbY2hlY2tlZF0ge1xuICAgICAgICBjb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtY2hlY2tlZC1pbmstY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgI2NoZWNrYm94IHtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIGJvcmRlcjogc29saWQgMnB4O1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LXVuY2hlY2tlZC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDJweDtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogYmFja2dyb3VuZC1jb2xvciAxNDBtcywgYm9yZGVyLWNvbG9yIDE0MG1zO1xuICAgICAgICB0cmFuc2l0aW9uOiBiYWNrZ3JvdW5kLWNvbG9yIDE0MG1zLCBib3JkZXItY29sb3IgMTQwbXM7XG4gICAgICB9XG5cbiAgICAgIC8qIGNoZWNrYm94IGNoZWNrZWQgYW5pbWF0aW9ucyAqL1xuICAgICAgI2NoZWNrYm94LmNoZWNrZWQgI2NoZWNrbWFyayB7XG4gICAgICAgIC13ZWJraXQtYW5pbWF0aW9uOiBjaGVja21hcmstZXhwYW5kIDE0MG1zIGVhc2Utb3V0IGZvcndhcmRzO1xuICAgICAgICBhbmltYXRpb246IGNoZWNrbWFyay1leHBhbmQgMTQwbXMgZWFzZS1vdXQgZm9yd2FyZHM7XG4gICAgICB9XG5cbiAgICAgIEAtd2Via2l0LWtleWZyYW1lcyBjaGVja21hcmstZXhwYW5kIHtcbiAgICAgICAgMCUge1xuICAgICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgwLCAwKSByb3RhdGUoNDVkZWcpO1xuICAgICAgICB9XG4gICAgICAgIDEwMCUge1xuICAgICAgICAgIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLCAxKSByb3RhdGUoNDVkZWcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEBrZXlmcmFtZXMgY2hlY2ttYXJrLWV4cGFuZCB7XG4gICAgICAgIDAlIHtcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDAsIDApIHJvdGF0ZSg0NWRlZyk7XG4gICAgICAgIH1cbiAgICAgICAgMTAwJSB7XG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLCAxKSByb3RhdGUoNDVkZWcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgICNjaGVja2JveC5jaGVja2VkIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtY2hlY2tlZC1jb2xvciwgdmFyKC0tcHJpbWFyeS1jb2xvcikpO1xuICAgICAgICBib3JkZXItY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LWNoZWNrZWQtY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgI2NoZWNrbWFyayB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgd2lkdGg6IDM2JTtcbiAgICAgICAgaGVpZ2h0OiA3MCU7XG4gICAgICAgIGJvcmRlci1zdHlsZTogc29saWQ7XG4gICAgICAgIGJvcmRlci10b3A6IG5vbmU7XG4gICAgICAgIGJvcmRlci1sZWZ0OiBub25lO1xuICAgICAgICBib3JkZXItcmlnaHQtd2lkdGg6IGNhbGMoMi8xNSAqIHZhcigtLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZSkpO1xuICAgICAgICBib3JkZXItYm90dG9tLXdpZHRoOiBjYWxjKDIvMTUgKiB2YXIoLS1jYWxjdWxhdGVkLXBhcGVyLWNoZWNrYm94LXNpemUpKTtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1wYXBlci1jaGVja2JveC1jaGVja21hcmstY29sb3IsIHdoaXRlKTtcbiAgICAgICAgLXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOiA5NyUgODYlO1xuICAgICAgICB0cmFuc2Zvcm0tb3JpZ2luOiA5NyUgODYlO1xuICAgICAgICBib3gtc2l6aW5nOiBjb250ZW50LWJveDsgLyogcHJvdGVjdCBhZ2FpbnN0IHBhZ2UtbGV2ZWwgYm94LXNpemluZyAqL1xuICAgICAgfVxuXG4gICAgICA6aG9zdC1jb250ZXh0KFtkaXI9XCJydGxcIl0pICNjaGVja21hcmsge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybS1vcmlnaW46IDUwJSAxNCU7XG4gICAgICAgIHRyYW5zZm9ybS1vcmlnaW46IDUwJSAxNCU7XG4gICAgICB9XG5cbiAgICAgIC8qIGxhYmVsICovXG4gICAgICAjY2hlY2tib3hMYWJlbCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXBhcGVyLWNoZWNrYm94LWxhYmVsLXNwYWNpbmcsIDhweCk7XG4gICAgICAgIHdoaXRlLXNwYWNlOiBub3JtYWw7XG4gICAgICAgIGxpbmUtaGVpZ2h0OiBub3JtYWw7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci1jaGVja2JveC1sYWJlbC1jb2xvciwgdmFyKC0tcHJpbWFyeS10ZXh0LWNvbG9yKSk7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWNoZWNrYm94LWxhYmVsO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbY2hlY2tlZF0pICNjaGVja2JveExhYmVsIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLWNoZWNrYm94LWxhYmVsLWNoZWNrZWQtY29sb3IsIHZhcigtLXBhcGVyLWNoZWNrYm94LWxhYmVsLWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKSk7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWNoZWNrYm94LWxhYmVsLWNoZWNrZWQ7XG4gICAgICB9XG5cbiAgICAgIDpob3N0LWNvbnRleHQoW2Rpcj1cInJ0bFwiXSkgI2NoZWNrYm94TGFiZWwge1xuICAgICAgICBwYWRkaW5nLXJpZ2h0OiB2YXIoLS1wYXBlci1jaGVja2JveC1sYWJlbC1zcGFjaW5nLCA4cHgpO1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IDA7XG4gICAgICB9XG5cbiAgICAgICNjaGVja2JveExhYmVsW2hpZGRlbl0ge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgICAgfVxuXG4gICAgICAvKiBkaXNhYmxlZCBzdGF0ZSAqL1xuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAjY2hlY2tib3gge1xuICAgICAgICBvcGFjaXR5OiAwLjU7XG4gICAgICAgIGJvcmRlci1jb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtdW5jaGVja2VkLWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXVtjaGVja2VkXSkgI2NoZWNrYm94IHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItY2hlY2tib3gtdW5jaGVja2VkLWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAjY2hlY2tib3hMYWJlbCAge1xuICAgICAgICBvcGFjaXR5OiAwLjY1O1xuICAgICAgfVxuXG4gICAgICAvKiBpbnZhbGlkIHN0YXRlICovXG4gICAgICAjY2hlY2tib3guaW52YWxpZDpub3QoLmNoZWNrZWQpIHtcbiAgICAgICAgYm9yZGVyLWNvbG9yOiB2YXIoLS1wYXBlci1jaGVja2JveC1lcnJvci1jb2xvciwgdmFyKC0tZXJyb3ItY29sb3IpKTtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuXG4gICAgPGRpdiBpZD1cImNoZWNrYm94Q29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGlkPVwiY2hlY2tib3hcIiBjbGFzc1xcJD1cIltbX2NvbXB1dGVDaGVja2JveENsYXNzKGNoZWNrZWQsIGludmFsaWQpXV1cIj5cbiAgICAgICAgPGRpdiBpZD1cImNoZWNrbWFya1wiIGNsYXNzXFwkPVwiW1tfY29tcHV0ZUNoZWNrbWFya0NsYXNzKGNoZWNrZWQpXV1cIj48L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuXG4gICAgPGRpdiBpZD1cImNoZWNrYm94TGFiZWxcIj48c2xvdD48L3Nsb3Q+PC9kaXY+XG4gIDwvdGVtcGxhdGU+XG5cbiAgXG48L2RvbS1tb2R1bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblBvbHltZXIoe1xuICBpczogJ3BhcGVyLWNoZWNrYm94JyxcblxuICBiZWhhdmlvcnM6IFtcbiAgICBQYXBlckNoZWNrZWRFbGVtZW50QmVoYXZpb3JcbiAgXSxcblxuICBob3N0QXR0cmlidXRlczoge1xuICAgIHJvbGU6ICdjaGVja2JveCcsXG4gICAgJ2FyaWEtY2hlY2tlZCc6IGZhbHNlLFxuICAgIHRhYmluZGV4OiAwXG4gIH0sXG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgY2hhbmdlcyBkdWUgdG8gdXNlciBpbnRlcmFjdGlvbi5cbiAgICAgKlxuICAgICAqIEBldmVudCBjaGFuZ2VcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBldmVudCBpcm9uLWNoYW5nZVxuICAgICAqL1xuICAgIGFyaWFBY3RpdmVBdHRyaWJ1dGU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbHVlOiAnYXJpYS1jaGVja2VkJ1xuICAgIH1cbiAgfSxcblxuICBhdHRhY2hlZDogZnVuY3Rpb24oKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBzdHlsZXMgaGF2ZSByZXNvbHZlZCB0byBjaGVjayBmb3IgdGhlIGRlZmF1bHQgc2VudGluZWwuXG4gICAgLy8gU2VlIHBvbHltZXIjNDAwOSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgIGFmdGVyTmV4dFJlbmRlcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpbmtTaXplID0gdGhpcy5nZXRDb21wdXRlZFN0eWxlVmFsdWUoJy0tY2FsY3VsYXRlZC1wYXBlci1jaGVja2JveC1pbmstc2l6ZScpLnRyaW0oKTtcbiAgICAgIC8vIElmIHVuc2V0LCBjb21wdXRlIGFuZCBzZXQgdGhlIGRlZmF1bHQgYC0tcGFwZXItY2hlY2tib3gtaW5rLXNpemVgLlxuICAgICAgaWYgKGlua1NpemUgPT09ICctMXB4Jykge1xuICAgICAgICB2YXIgY2hlY2tib3hTaXplVGV4dCA9IHRoaXMuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKCctLWNhbGN1bGF0ZWQtcGFwZXItY2hlY2tib3gtc2l6ZScpLnRyaW0oKTtcblxuICAgICAgICB2YXIgdW5pdHMgPSBjaGVja2JveFNpemVUZXh0Lm1hdGNoKC9bQS1aYS16XSskLylbMF0gfHwgJ3B4JztcbiAgICAgICAgdmFyIGNoZWNrYm94U2l6ZSA9IHBhcnNlRmxvYXQoY2hlY2tib3hTaXplVGV4dCwgMTApO1xuICAgICAgICB2YXIgZGVmYXVsdElua1NpemUgPSAoOCAvIDMpICogY2hlY2tib3hTaXplO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ3B4Jykge1xuICAgICAgICAgIGRlZmF1bHRJbmtTaXplID0gTWF0aC5mbG9vcihkZWZhdWx0SW5rU2l6ZSk7XG5cbiAgICAgICAgICAvLyBUaGUgY2hlY2tib3ggYW5kIHJpcHBsZSBuZWVkIHRvIGhhdmUgdGhlIHNhbWUgcGFyaXR5IHNvIHRoYXQgdGhlaXJcbiAgICAgICAgICAvLyBjZW50ZXJzIGFsaWduLlxuICAgICAgICAgIGlmIChkZWZhdWx0SW5rU2l6ZSAlIDIgIT09IGNoZWNrYm94U2l6ZSAlIDIpIHtcbiAgICAgICAgICAgIGRlZmF1bHRJbmtTaXplKys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVTdHlsZXMoe1xuICAgICAgICAgICctLXBhcGVyLWNoZWNrYm94LWluay1zaXplJzogZGVmYXVsdElua1NpemUgKyB1bml0cyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgX2NvbXB1dGVDaGVja2JveENsYXNzOiBmdW5jdGlvbihjaGVja2VkLCBpbnZhbGlkKSB7XG4gICAgdmFyIGNsYXNzTmFtZSA9ICcnO1xuICAgIGlmIChjaGVja2VkKSB7XG4gICAgICBjbGFzc05hbWUgKz0gJ2NoZWNrZWQgJztcbiAgICB9XG4gICAgaWYgKGludmFsaWQpIHtcbiAgICAgIGNsYXNzTmFtZSArPSAnaW52YWxpZCc7XG4gICAgfVxuICAgIHJldHVybiBjbGFzc05hbWU7XG4gIH0sXG5cbiAgX2NvbXB1dGVDaGVja21hcmtDbGFzczogZnVuY3Rpb24oY2hlY2tlZCkge1xuICAgIHJldHVybiBjaGVja2VkID8gJycgOiAnaGlkZGVuJztcbiAgfSxcblxuICAvLyBjcmVhdGUgcmlwcGxlIGluc2lkZSB0aGUgY2hlY2tib3hDb250YWluZXJcbiAgX2NyZWF0ZVJpcHBsZTogZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5fcmlwcGxlQ29udGFpbmVyID0gdGhpcy4kLmNoZWNrYm94Q29udGFpbmVyO1xuICAgIHJldHVybiBQYXBlcklua3lGb2N1c0JlaGF2aW9ySW1wbC5fY3JlYXRlUmlwcGxlLmNhbGwodGhpcyk7XG4gIH1cblxufSk7XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9AcG9seW1lci9wYXBlci1jaGVja2JveC9wYXBlci1jaGVja2JveC5qc1xuLy8gbW9kdWxlIGlkID0gOTVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0ICcuLi9wb2x5bWVyL3BvbHltZXIuanMnO1xuaW1wb3J0IHsgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLXZhbGlkYXRhYmxlLWJlaGF2aW9yL2lyb24tdmFsaWRhdGFibGUtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgSXJvbkZvcm1FbGVtZW50QmVoYXZpb3IgfSBmcm9tICcuLi9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci9pcm9uLWZvcm0tZWxlbWVudC1iZWhhdmlvci5qcyc7XG5cbmV4cG9ydCBjb25zdCBJcm9uQ2hlY2tlZEVsZW1lbnRCZWhhdmlvckltcGwgPSB7XG5cbiAgcHJvcGVydGllczoge1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBldmVudCBpcm9uLWNoYW5nZVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogR2V0cyBvciBzZXRzIHRoZSBzdGF0ZSwgYHRydWVgIGlzIGNoZWNrZWQgYW5kIGBmYWxzZWAgaXMgdW5jaGVja2VkLlxuICAgICAqL1xuICAgIGNoZWNrZWQ6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICB2YWx1ZTogZmFsc2UsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWUsXG4gICAgICBub3RpZnk6IHRydWUsXG4gICAgICBvYnNlcnZlcjogJ19jaGVja2VkQ2hhbmdlZCdcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSWYgdHJ1ZSwgdGhlIGJ1dHRvbiB0b2dnbGVzIHRoZSBhY3RpdmUgc3RhdGUgd2l0aCBlYWNoIHRhcCBvciBwcmVzc1xuICAgICAqIG9mIHRoZSBzcGFjZWJhci5cbiAgICAgKi9cbiAgICB0b2dnbGVzOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgdmFsdWU6IHRydWUsXG4gICAgICByZWZsZWN0VG9BdHRyaWJ1dGU6IHRydWVcbiAgICB9LFxuXG4gICAgLyogT3ZlcnJpZGVuIGZyb20gUG9seW1lci5Jcm9uRm9ybUVsZW1lbnRCZWhhdmlvciAqL1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICB2YWx1ZTogJ29uJyxcbiAgICAgIG9ic2VydmVyOiAnX3ZhbHVlQ2hhbmdlZCdcbiAgICB9XG4gIH0sXG5cbiAgb2JzZXJ2ZXJzOiBbXG4gICAgJ19yZXF1aXJlZENoYW5nZWQocmVxdWlyZWQpJ1xuICBdLFxuXG4gIGNyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgIC8vIFVzZWQgYnkgYGlyb24tZm9ybWAgdG8gaGFuZGxlIHRoZSBjYXNlIHRoYXQgYW4gZWxlbWVudCB3aXRoIHRoaXMgYmVoYXZpb3JcbiAgICAvLyBkb2Vzbid0IGhhdmUgYSByb2xlIG9mICdjaGVja2JveCcgb3IgJ3JhZGlvJywgYnV0IHNob3VsZCBzdGlsbCBvbmx5IGJlXG4gICAgLy8gaW5jbHVkZWQgd2hlbiB0aGUgZm9ybSBpcyBzZXJpYWxpemVkIGlmIGB0aGlzLmNoZWNrZWQgPT09IHRydWVgLlxuICAgIHRoaXMuX2hhc0lyb25DaGVja2VkRWxlbWVudEJlaGF2aW9yID0gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgZWxlbWVudCBpcyByZXF1aXJlZCBhbmQgbm90IGNoZWNrZWQsIGFuZCB0cnVlIG90aGVyd2lzZS5cbiAgICogQHBhcmFtIHsqPX0gX3ZhbHVlIElnbm9yZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgYHJlcXVpcmVkYCBpcyBmYWxzZSBvciBpZiBgY2hlY2tlZGAgaXMgdHJ1ZS5cbiAgICovXG4gIF9nZXRWYWxpZGl0eTogZnVuY3Rpb24oX3ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlzYWJsZWQgfHwgIXRoaXMucmVxdWlyZWQgfHwgdGhpcy5jaGVja2VkO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIGFyaWEtcmVxdWlyZWQgbGFiZWwgd2hlbiBgcmVxdWlyZWRgIGlzIGNoYW5nZWQuXG4gICAqL1xuICBfcmVxdWlyZWRDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5yZXF1aXJlZCkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2FyaWEtcmVxdWlyZWQnLCAndHJ1ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1yZXF1aXJlZCcpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRmlyZSBgaXJvbi1jaGFuZ2VkYCB3aGVuIHRoZSBjaGVja2VkIHN0YXRlIGNoYW5nZXMuXG4gICAqL1xuICBfY2hlY2tlZENoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYWN0aXZlID0gdGhpcy5jaGVja2VkO1xuICAgIHRoaXMuZmlyZSgnaXJvbi1jaGFuZ2UnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVzZXQgdmFsdWUgdG8gJ29uJyBpZiBpdCBpcyBzZXQgdG8gYHVuZGVmaW5lZGAuXG4gICAqL1xuICBfdmFsdWVDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy52YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMudmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHRoaXMudmFsdWUgPSAnb24nO1xuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9yID0gW1xuICBJcm9uRm9ybUVsZW1lbnRCZWhhdmlvcixcbiAgSXJvblZhbGlkYXRhYmxlQmVoYXZpb3IsXG4gIElyb25DaGVja2VkRWxlbWVudEJlaGF2aW9ySW1wbFxuXTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL2lyb24tY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yL2lyb24tY2hlY2tlZC1lbGVtZW50LWJlaGF2aW9yLmpzXG4vLyBtb2R1bGUgaWQgPSA5NlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgJy4uL3BvbHltZXIvcG9seW1lci5qcyc7XG5pbXBvcnQgJy4uL2lyb24tZmxleC1sYXlvdXQvaXJvbi1mbGV4LWxheW91dC5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9jb2xvci5qcyc7XG5pbXBvcnQgJy4uL3BhcGVyLXN0eWxlcy9kZWZhdWx0LXRoZW1lLmpzJztcbmltcG9ydCB7IFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvciB9IGZyb20gJy4uL3BhcGVyLWJlaGF2aW9ycy9wYXBlci1jaGVja2VkLWVsZW1lbnQtYmVoYXZpb3IuanMnO1xuaW1wb3J0IHsgUG9seW1lciB9IGZyb20gJy4uL3BvbHltZXIvbGliL2xlZ2FjeS9wb2x5bWVyLWZuLmpzJztcbmltcG9ydCB7IGFmdGVyTmV4dFJlbmRlciB9IGZyb20gJy4uL3BvbHltZXIvbGliL3V0aWxzL3JlbmRlci1zdGF0dXMuanMnO1xuaW1wb3J0IHsgc2V0VG91Y2hBY3Rpb24gfSBmcm9tICcuLi9wb2x5bWVyL2xpYi91dGlscy9nZXN0dXJlcy5qcyc7XG5pbXBvcnQgeyBQYXBlclJpcHBsZUJlaGF2aW9yIH0gZnJvbSAnLi4vcGFwZXItYmVoYXZpb3JzL3BhcGVyLXJpcHBsZS1iZWhhdmlvci5qcyc7XG5jb25zdCAkX2RvY3VtZW50Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4kX2RvY3VtZW50Q29udGFpbmVyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCAnZGlzcGxheTogbm9uZTsnKTtcblxuJF9kb2N1bWVudENvbnRhaW5lci5pbm5lckhUTUwgPSBgPGRvbS1tb2R1bGUgaWQ9XCJwYXBlci10b2dnbGUtYnV0dG9uXCI+XG4gIDx0ZW1wbGF0ZSBzdHJpcC13aGl0ZXNwYWNlPVwiXCI+XG5cbiAgICA8c3R5bGU+XG4gICAgICA6aG9zdCB7XG4gICAgICAgIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgICAgICAgQGFwcGx5IC0tbGF5b3V0LWhvcml6b250YWw7XG4gICAgICAgIEBhcHBseSAtLWxheW91dC1jZW50ZXI7XG4gICAgICAgIEBhcHBseSAtLXBhcGVyLWZvbnQtY29tbW9uLWJhc2U7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtkaXNhYmxlZF0pIHtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KDpmb2N1cykge1xuICAgICAgICBvdXRsaW5lOm5vbmU7XG4gICAgICB9XG5cbiAgICAgIC50b2dnbGUtYmFyIHtcbiAgICAgICAgcG9zaXRpb246IGFic29sdXRlO1xuICAgICAgICBoZWlnaHQ6IDEwMCU7XG4gICAgICAgIHdpZHRoOiAxMDAlO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xuICAgICAgICBvcGFjaXR5OiAwLjQ7XG4gICAgICAgIHRyYW5zaXRpb246IGJhY2tncm91bmQtY29sb3IgbGluZWFyIC4wOHM7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWJhci1jb2xvciwgIzAwMDAwMCk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtYmFyO1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWJ1dHRvbiB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtM3B4O1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBoZWlnaHQ6IDIwcHg7XG4gICAgICAgIHdpZHRoOiAyMHB4O1xuICAgICAgICBib3JkZXItcmFkaXVzOiA1MCU7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMXB4IDVweCAwIHJnYmEoMCwgMCwgMCwgMC42KTtcbiAgICAgICAgdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gbGluZWFyIC4wOHMsIGJhY2tncm91bmQtY29sb3IgbGluZWFyIC4wOHM7XG4gICAgICAgIHRyYW5zaXRpb246IHRyYW5zZm9ybSBsaW5lYXIgLjA4cywgYmFja2dyb3VuZC1jb2xvciBsaW5lYXIgLjA4cztcbiAgICAgICAgd2lsbC1jaGFuZ2U6IHRyYW5zZm9ybTtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogdmFyKC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtYnV0dG9uLWNvbG9yLCB2YXIoLS1wYXBlci1ncmV5LTUwKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi11bmNoZWNrZWQtYnV0dG9uO1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWJ1dHRvbi5kcmFnZ2luZyB7XG4gICAgICAgIC13ZWJraXQtdHJhbnNpdGlvbjogbm9uZTtcbiAgICAgICAgdHJhbnNpdGlvbjogbm9uZTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2NoZWNrZWRdOm5vdChbZGlzYWJsZWRdKSkgLnRvZ2dsZS1iYXIge1xuICAgICAgICBvcGFjaXR5OiAwLjU7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tY2hlY2tlZC1iYXItY29sb3IsIHZhcigtLXByaW1hcnktY29sb3IpKTtcblxuICAgICAgICBAYXBwbHkgLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtYmFyO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbZGlzYWJsZWRdKSAudG9nZ2xlLWJhciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6ICMwMDA7XG4gICAgICAgIG9wYWNpdHk6IDAuMTI7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtjaGVja2VkXSkgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlKDE2cHgsIDApO1xuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgxNnB4LCAwKTtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2NoZWNrZWRdOm5vdChbZGlzYWJsZWRdKSkgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtYnV0dG9uLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWJ1dHRvbjtcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2Rpc2FibGVkXSkgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiAjYmRiZGJkO1xuICAgICAgICBvcGFjaXR5OiAxO1xuICAgICAgfVxuXG4gICAgICAudG9nZ2xlLWluayB7XG4gICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcbiAgICAgICAgdG9wOiAtMTRweDtcbiAgICAgICAgbGVmdDogLTE0cHg7XG4gICAgICAgIHJpZ2h0OiBhdXRvO1xuICAgICAgICBib3R0b206IGF1dG87XG4gICAgICAgIHdpZHRoOiA0OHB4O1xuICAgICAgICBoZWlnaHQ6IDQ4cHg7XG4gICAgICAgIG9wYWNpdHk6IDAuNTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLXVuY2hlY2tlZC1pbmstY29sb3IsIHZhcigtLXByaW1hcnktdGV4dC1jb2xvcikpO1xuXG4gICAgICAgIEBhcHBseSAtLXBhcGVyLXRvZ2dsZS1idXR0b24tdW5jaGVja2VkLWluaztcbiAgICAgIH1cblxuICAgICAgOmhvc3QoW2NoZWNrZWRdKSAudG9nZ2xlLWluayB7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWNoZWNrZWQtaW5rLWNvbG9yLCB2YXIoLS1wcmltYXJ5LWNvbG9yKSk7XG5cbiAgICAgICAgQGFwcGx5IC0tcGFwZXItdG9nZ2xlLWJ1dHRvbi1jaGVja2VkLWluaztcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1jb250YWluZXIge1xuICAgICAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgd2lkdGg6IDM2cHg7XG4gICAgICAgIGhlaWdodDogMTRweDtcbiAgICAgICAgLyogVGhlIHRvZ2dsZSBidXR0b24gaGFzIGFuIGFic29sdXRlIHBvc2l0aW9uIG9mIC0zcHg7IFRoZSBleHRyYSAxcHhcbiAgICAgICAgLyogYWNjb3VudHMgZm9yIHRoZSB0b2dnbGUgYnV0dG9uIHNoYWRvdyBib3guICovXG4gICAgICAgIG1hcmdpbjogNHB4IDFweDtcbiAgICAgIH1cblxuICAgICAgLnRvZ2dsZS1sYWJlbCB7XG4gICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xuICAgICAgICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlO1xuICAgICAgICBwYWRkaW5nLWxlZnQ6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24tbGFiZWwtc3BhY2luZywgOHB4KTtcbiAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIGNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWxhYmVsLWNvbG9yLCB2YXIoLS1wcmltYXJ5LXRleHQtY29sb3IpKTtcbiAgICAgIH1cblxuICAgICAgLyogaW52YWxpZCBzdGF0ZSAqL1xuICAgICAgOmhvc3QoW2ludmFsaWRdKSAudG9nZ2xlLWJhciB7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24taW52YWxpZC1iYXItY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG4gICAgICB9XG5cbiAgICAgIDpob3N0KFtpbnZhbGlkXSkgLnRvZ2dsZS1idXR0b24ge1xuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1wYXBlci10b2dnbGUtYnV0dG9uLWludmFsaWQtYnV0dG9uLWNvbG9yLCB2YXIoLS1lcnJvci1jb2xvcikpO1xuICAgICAgfVxuXG4gICAgICA6aG9zdChbaW52YWxpZF0pIC50b2dnbGUtaW5rIHtcbiAgICAgICAgY29sb3I6IHZhcigtLXBhcGVyLXRvZ2dsZS1idXR0b24taW52YWxpZC1pbmstY29sb3IsIHZhcigtLWVycm9yLWNvbG9yKSk7XG4gICAgICB9XG4gICAgPC9zdHlsZT5cblxuICAgIDxkaXYgY2xhc3M9XCJ0b2dnbGUtY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGlkPVwidG9nZ2xlQmFyXCIgY2xhc3M9XCJ0b2dnbGUtYmFyXCI+PC9kaXY+XG4gICAgICA8ZGl2IGlkPVwidG9nZ2xlQnV0dG9uXCIgY2xhc3M9XCJ0b2dnbGUtYnV0dG9uXCI+PC9kaXY+XG4gICAgPC9kaXY+XG5cbiAgICA8ZGl2IGNsYXNzPVwidG9nZ2xlLWxhYmVsXCI+PHNsb3Q+PC9zbG90PjwvZGl2PlxuXG4gIDwvdGVtcGxhdGU+XG5cbiAgXG48L2RvbS1tb2R1bGU+YDtcblxuZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCgkX2RvY3VtZW50Q29udGFpbmVyKTtcblBvbHltZXIoe1xuICBpczogJ3BhcGVyLXRvZ2dsZS1idXR0b24nLFxuXG4gIGJlaGF2aW9yczogW1xuICAgIFBhcGVyQ2hlY2tlZEVsZW1lbnRCZWhhdmlvclxuICBdLFxuXG4gIGhvc3RBdHRyaWJ1dGVzOiB7XG4gICAgcm9sZTogJ2J1dHRvbicsXG4gICAgJ2FyaWEtcHJlc3NlZCc6ICdmYWxzZScsXG4gICAgdGFiaW5kZXg6IDBcbiAgfSxcblxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogRmlyZWQgd2hlbiB0aGUgY2hlY2tlZCBzdGF0ZSBjaGFuZ2VzIGR1ZSB0byB1c2VyIGludGVyYWN0aW9uLlxuICAgICAqXG4gICAgICogQGV2ZW50IGNoYW5nZVxuICAgICAqL1xuICAgIC8qKlxuICAgICAqIEZpcmVkIHdoZW4gdGhlIGNoZWNrZWQgc3RhdGUgY2hhbmdlcy5cbiAgICAgKlxuICAgICAqIEBldmVudCBpcm9uLWNoYW5nZVxuICAgICAqL1xuICB9LFxuXG4gIGxpc3RlbmVyczoge1xuICAgIHRyYWNrOiAnX29udHJhY2snXG4gIH0sXG5cbiAgYXR0YWNoZWQ6IGZ1bmN0aW9uKCkge1xuICAgIGFmdGVyTmV4dFJlbmRlcih0aGlzLCBmdW5jdGlvbigpIHtcbiAgICAgIHNldFRvdWNoQWN0aW9uKHRoaXMsICdwYW4teScpO1xuICAgIH0pO1xuICB9LFxuXG4gIF9vbnRyYWNrOiBmdW5jdGlvbihldmVudCkge1xuICAgIHZhciB0cmFjayA9IGV2ZW50LmRldGFpbDtcbiAgICBpZiAodHJhY2suc3RhdGUgPT09ICdzdGFydCcpIHtcbiAgICAgIHRoaXMuX3RyYWNrU3RhcnQodHJhY2spO1xuICAgIH0gZWxzZSBpZiAodHJhY2suc3RhdGUgPT09ICd0cmFjaycpIHtcbiAgICAgIHRoaXMuX3RyYWNrTW92ZSh0cmFjayk7XG4gICAgfSBlbHNlIGlmICh0cmFjay5zdGF0ZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHRoaXMuX3RyYWNrRW5kKHRyYWNrKTtcbiAgICB9XG4gIH0sXG5cbiAgX3RyYWNrU3RhcnQ6IGZ1bmN0aW9uKHRyYWNrKSB7XG4gICAgdGhpcy5fd2lkdGggPSB0aGlzLiQudG9nZ2xlQmFyLm9mZnNldFdpZHRoIC8gMjtcbiAgICAvKlxuICAgICAqIGtlZXAgYW4gdHJhY2stb25seSBjaGVjayBzdGF0ZSB0byBrZWVwIHRoZSBkcmFnZ2luZyBiZWhhdmlvciBzbW9vdGhcbiAgICAgKiB3aGlsZSB0b2dnbGluZyBhY3RpdmF0aW9uc1xuICAgICAqL1xuICAgIHRoaXMuX3RyYWNrQ2hlY2tlZCA9IHRoaXMuY2hlY2tlZDtcbiAgICB0aGlzLiQudG9nZ2xlQnV0dG9uLmNsYXNzTGlzdC5hZGQoJ2RyYWdnaW5nJyk7XG4gIH0sXG5cbiAgX3RyYWNrTW92ZTogZnVuY3Rpb24odHJhY2spIHtcbiAgICB2YXIgZHggPSB0cmFjay5keDtcbiAgICB0aGlzLl94ID0gTWF0aC5taW4odGhpcy5fd2lkdGgsXG4gICAgICAgIE1hdGgubWF4KDAsIHRoaXMuX3RyYWNrQ2hlY2tlZCA/IHRoaXMuX3dpZHRoICsgZHggOiBkeCkpO1xuICAgIHRoaXMudHJhbnNsYXRlM2QodGhpcy5feCArICdweCcsIDAsIDAsIHRoaXMuJC50b2dnbGVCdXR0b24pO1xuICAgIHRoaXMuX3VzZXJBY3RpdmF0ZSh0aGlzLl94ID4gKHRoaXMuX3dpZHRoIC8gMikpO1xuICB9LFxuXG4gIF90cmFja0VuZDogZnVuY3Rpb24odHJhY2spIHtcbiAgICB0aGlzLiQudG9nZ2xlQnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdnaW5nJyk7XG4gICAgdGhpcy50cmFuc2Zvcm0oJycsIHRoaXMuJC50b2dnbGVCdXR0b24pO1xuICB9LFxuXG4gIC8vIGN1c3RvbWl6ZSB0aGUgZWxlbWVudCdzIHJpcHBsZVxuICBfY3JlYXRlUmlwcGxlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLl9yaXBwbGVDb250YWluZXIgPSB0aGlzLiQudG9nZ2xlQnV0dG9uO1xuICAgIHZhciByaXBwbGUgPSBQYXBlclJpcHBsZUJlaGF2aW9yLl9jcmVhdGVSaXBwbGUoKTtcbiAgICByaXBwbGUuaWQgPSAnaW5rJztcbiAgICByaXBwbGUuc2V0QXR0cmlidXRlKCdyZWNlbnRlcnMnLCAnJyk7XG4gICAgcmlwcGxlLmNsYXNzTGlzdC5hZGQoJ2NpcmNsZScsICd0b2dnbGUtaW5rJyk7XG4gICAgcmV0dXJuIHJpcHBsZTtcbiAgfVxuXG59KTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL0Bwb2x5bWVyL3BhcGVyLXRvZ2dsZS1idXR0b24vcGFwZXItdG9nZ2xlLWJ1dHRvbi5qc1xuLy8gbW9kdWxlIGlkID0gOTdcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IFdlYkNvbXBvbmVudHMgZnJvbSAnQHdlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzL3dlYmNvbXBvbmVudHMtbGl0ZS5qcyc7XG5cbnZhciBnZXRCcmVha3BvaW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gd2luZG93LmdldENvbXB1dGVkU3R5bGUod2luZG93LmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ2JvZHknKSwgJzpiZWZvcmUnKS5nZXRQcm9wZXJ0eVZhbHVlKCdjb250ZW50JykucmVwbGFjZSgvXCIvZywgJycpO1xufTtcblxuZnVuY3Rpb24gYnJlYWtwb2ludChicmVha3BvaW50LCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBpZiAoZ2V0QnJlYWtwb2ludCgpID09PSBicmVha3BvaW50KSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgICAkKHdpbmRvdykucmVzaXplKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChnZXRCcmVha3BvaW50KCkgPT09IGJyZWFrcG9pbnQpIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2V0QnJlYWtwb2ludCgpID09PSBicmVha3BvaW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2t0b3AoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGJyZWFrcG9pbnQoXCJkZXNrdG9wXCIsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gdGFibGV0KGNhbGxiYWNrKSB7XG4gIHJldHVybiBicmVha3BvaW50KFwidGFibGV0XCIsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gcGhvbmUoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGJyZWFrcG9pbnQoXCJwaG9uZVwiLCBjYWxsYmFjayk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9nbG9iYWwvY2xpZW50LmpzIiwiKGZ1bmN0aW9uKCl7LypcblxuIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbid1c2Ugc3RyaWN0Jzt2YXIgcCxxPVwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdz09PXRoaXM/dGhpczpcInVuZGVmaW5lZFwiIT10eXBlb2YgZ2xvYmFsJiZudWxsIT1nbG9iYWw/Z2xvYmFsOnRoaXMsYmE9XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnRpZXM/T2JqZWN0LmRlZmluZVByb3BlcnR5OmZ1bmN0aW9uKGEsYixjKXthIT1BcnJheS5wcm90b3R5cGUmJmEhPU9iamVjdC5wcm90b3R5cGUmJihhW2JdPWMudmFsdWUpfTtmdW5jdGlvbiBjYSgpe2NhPWZ1bmN0aW9uKCl7fTtxLlN5bWJvbHx8KHEuU3ltYm9sPWRhKX12YXIgZGE9ZnVuY3Rpb24oKXt2YXIgYT0wO3JldHVybiBmdW5jdGlvbihiKXtyZXR1cm5cImpzY29tcF9zeW1ib2xfXCIrKGJ8fFwiXCIpK2ErK319KCk7XG5mdW5jdGlvbiBlYSgpe2NhKCk7dmFyIGE9cS5TeW1ib2wuaXRlcmF0b3I7YXx8KGE9cS5TeW1ib2wuaXRlcmF0b3I9cS5TeW1ib2woXCJpdGVyYXRvclwiKSk7XCJmdW5jdGlvblwiIT10eXBlb2YgQXJyYXkucHJvdG90eXBlW2FdJiZiYShBcnJheS5wcm90b3R5cGUsYSx7Y29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwLHZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGZhKHRoaXMpfX0pO2VhPWZ1bmN0aW9uKCl7fX1mdW5jdGlvbiBmYShhKXt2YXIgYj0wO3JldHVybiBoYShmdW5jdGlvbigpe3JldHVybiBiPGEubGVuZ3RoP3tkb25lOiExLHZhbHVlOmFbYisrXX06e2RvbmU6ITB9fSl9ZnVuY3Rpb24gaGEoYSl7ZWEoKTthPXtuZXh0OmF9O2FbcS5TeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9O3JldHVybiBhfWZ1bmN0aW9uIGlhKGEpe2VhKCk7dmFyIGI9YVtTeW1ib2wuaXRlcmF0b3JdO3JldHVybiBiP2IuY2FsbChhKTpmYShhKX1cbmZ1bmN0aW9uIGphKGEpe2Zvcih2YXIgYixjPVtdOyEoYj1hLm5leHQoKSkuZG9uZTspYy5wdXNoKGIudmFsdWUpO3JldHVybiBjfVxuKGZ1bmN0aW9uKCl7aWYoIWZ1bmN0aW9uKCl7dmFyIGE9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJFdmVudFwiKTthLmluaXRFdmVudChcImZvb1wiLCEwLCEwKTthLnByZXZlbnREZWZhdWx0KCk7cmV0dXJuIGEuZGVmYXVsdFByZXZlbnRlZH0oKSl7dmFyIGE9RXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0O0V2ZW50LnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdD1mdW5jdGlvbigpe3RoaXMuY2FuY2VsYWJsZSYmKGEuY2FsbCh0aGlzKSxPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcyxcImRlZmF1bHRQcmV2ZW50ZWRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuITB9LGNvbmZpZ3VyYWJsZTohMH0pKX19dmFyIGI9L1RyaWRlbnQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7aWYoIXdpbmRvdy5DdXN0b21FdmVudHx8YiYmXCJmdW5jdGlvblwiIT09dHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudCl3aW5kb3cuQ3VzdG9tRXZlbnQ9ZnVuY3Rpb24oYSxiKXtiPWJ8fHt9O3ZhciBjPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiQ3VzdG9tRXZlbnRcIik7XG5jLmluaXRDdXN0b21FdmVudChhLCEhYi5idWJibGVzLCEhYi5jYW5jZWxhYmxlLGIuZGV0YWlsKTtyZXR1cm4gY30sd2luZG93LkN1c3RvbUV2ZW50LnByb3RvdHlwZT13aW5kb3cuRXZlbnQucHJvdG90eXBlO2lmKCF3aW5kb3cuRXZlbnR8fGImJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB3aW5kb3cuRXZlbnQpe3ZhciBjPXdpbmRvdy5FdmVudDt3aW5kb3cuRXZlbnQ9ZnVuY3Rpb24oYSxiKXtiPWJ8fHt9O3ZhciBjPWRvY3VtZW50LmNyZWF0ZUV2ZW50KFwiRXZlbnRcIik7Yy5pbml0RXZlbnQoYSwhIWIuYnViYmxlcywhIWIuY2FuY2VsYWJsZSk7cmV0dXJuIGN9O2lmKGMpZm9yKHZhciBkIGluIGMpd2luZG93LkV2ZW50W2RdPWNbZF07d2luZG93LkV2ZW50LnByb3RvdHlwZT1jLnByb3RvdHlwZX1pZighd2luZG93Lk1vdXNlRXZlbnR8fGImJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiB3aW5kb3cuTW91c2VFdmVudCl7Yj13aW5kb3cuTW91c2VFdmVudDt3aW5kb3cuTW91c2VFdmVudD1mdW5jdGlvbihhLFxuYil7Yj1ifHx7fTt2YXIgYz1kb2N1bWVudC5jcmVhdGVFdmVudChcIk1vdXNlRXZlbnRcIik7Yy5pbml0TW91c2VFdmVudChhLCEhYi5idWJibGVzLCEhYi5jYW5jZWxhYmxlLGIudmlld3x8d2luZG93LGIuZGV0YWlsLGIuc2NyZWVuWCxiLnNjcmVlblksYi5jbGllbnRYLGIuY2xpZW50WSxiLmN0cmxLZXksYi5hbHRLZXksYi5zaGlmdEtleSxiLm1ldGFLZXksYi5idXR0b24sYi5yZWxhdGVkVGFyZ2V0KTtyZXR1cm4gY307aWYoYilmb3IoZCBpbiBiKXdpbmRvdy5Nb3VzZUV2ZW50W2RdPWJbZF07d2luZG93Lk1vdXNlRXZlbnQucHJvdG90eXBlPWIucHJvdG90eXBlfUFycmF5LmZyb218fChBcnJheS5mcm9tPWZ1bmN0aW9uKGEpe3JldHVybltdLnNsaWNlLmNhbGwoYSl9KTtPYmplY3QuYXNzaWdufHwoT2JqZWN0LmFzc2lnbj1mdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1bXS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKSxkPTAsZTtkPGMubGVuZ3RoO2QrKylpZihlPWNbZF0pZm9yKHZhciBmPVxuYSxtPWUsbj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhtKSx3PTA7dzxuLmxlbmd0aDt3KyspZT1uW3ddLGZbZV09bVtlXTtyZXR1cm4gYX0pfSkod2luZG93LldlYkNvbXBvbmVudHMpOyhmdW5jdGlvbigpe2Z1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gYihhLGIpe3N3aXRjaChhLm5vZGVUeXBlKXtjYXNlIE5vZGUuRE9DVU1FTlRfTk9ERTpyZXR1cm4gdy5jYWxsKGEsYik7Y2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6cmV0dXJuIEkuY2FsbChhLGIpO2RlZmF1bHQ6cmV0dXJuIG4uY2FsbChhLGIpfX12YXIgYz1cInVuZGVmaW5lZFwiPT09dHlwZW9mIEhUTUxUZW1wbGF0ZUVsZW1lbnQsZD0hKGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKS5jbG9uZU5vZGUoKWluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCksZT0hMTsvVHJpZGVudC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSYmZnVuY3Rpb24oKXtmdW5jdGlvbiBhKGEsYil7aWYoYSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpZm9yKHZhciBkO2Q9YS5maXJzdENoaWxkOyljLmNhbGwodGhpcyxkLGIpO2Vsc2UgYy5jYWxsKHRoaXMsYSxiKTtyZXR1cm4gYX1lPSEwO3ZhciBiPU5vZGUucHJvdG90eXBlLmNsb25lTm9kZTtcbk5vZGUucHJvdG90eXBlLmNsb25lTm9kZT1mdW5jdGlvbihhKXthPWIuY2FsbCh0aGlzLGEpO3RoaXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50JiYoYS5fX3Byb3RvX189RG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUpO3JldHVybiBhfTtEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsPUhUTUxFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsO0RvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3I9SFRNTEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3I7T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUse25vZGVUeXBlOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFfSxjb25maWd1cmFibGU6ITB9LGxvY2FsTmFtZTp7Z2V0OmZ1bmN0aW9uKCl7fSxjb25maWd1cmFibGU6ITB9LG5vZGVOYW1lOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cIiNkb2N1bWVudC1mcmFnbWVudFwifSxcbmNvbmZpZ3VyYWJsZTohMH19KTt2YXIgYz1Ob2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmU7Tm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlPWE7dmFyIGQ9Tm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQ7Tm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQ9ZnVuY3Rpb24oYil7YiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQ/YS5jYWxsKHRoaXMsYixudWxsKTpkLmNhbGwodGhpcyxiKTtyZXR1cm4gYn07dmFyIGY9Tm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQsaD1Ob2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQ7Tm9kZS5wcm90b3R5cGUucmVwbGFjZUNoaWxkPWZ1bmN0aW9uKGIsYyl7YiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQ/KGEuY2FsbCh0aGlzLGIsYyksZi5jYWxsKHRoaXMsYykpOmguY2FsbCh0aGlzLGIsYyk7cmV0dXJuIGN9O0RvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVEb2N1bWVudEZyYWdtZW50PWZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5jcmVhdGVFbGVtZW50KFwiZGZcIik7XG5hLl9fcHJvdG9fXz1Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZTtyZXR1cm4gYX07dmFyIGc9RG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGU7RG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGU9ZnVuY3Rpb24oYSxiKXtiPWcuY2FsbCh0aGlzLGEsYnx8ITEpO2EgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50JiYoYi5fX3Byb3RvX189RG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUpO3JldHVybiBifX0oKTt2YXIgZj1Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGUsaD1Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudCxnPURvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlLGs9Tm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQsbD1Ob2RlLnByb3RvdHlwZS5hcHBlbmRDaGlsZCxtPU5vZGUucHJvdG90eXBlLnJlcGxhY2VDaGlsZCxuPUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwsdz1Eb2N1bWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCxJPURvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwsXG5aYT1mdW5jdGlvbigpe2lmKCFjKXt2YXIgYT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIiksYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7Yi5jb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikpO2EuY29udGVudC5hcHBlbmRDaGlsZChiKTthPWEuY2xvbmVOb2RlKCEwKTtyZXR1cm4gMD09PWEuY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aHx8MD09PWEuY29udGVudC5maXJzdENoaWxkLmNvbnRlbnQuY2hpbGROb2Rlcy5sZW5ndGh8fGR9fSgpO2lmKGMpe3ZhciB0PWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudChcInRlbXBsYXRlXCIpLG5hPSEwLGFhPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTthYS50ZXh0Q29udGVudD1cInRlbXBsYXRle2Rpc3BsYXk6bm9uZTt9XCI7dmFyIFQ9ZG9jdW1lbnQuaGVhZDtULmluc2VydEJlZm9yZShhYSxULmZpcnN0RWxlbWVudENoaWxkKTtcbmEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoSFRNTEVsZW1lbnQucHJvdG90eXBlKTt2YXIgVT0hZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKS5oYXNPd25Qcm9wZXJ0eShcImlubmVySFRNTFwiKTthLkQ9ZnVuY3Rpb24oYil7aWYoIWIuY29udGVudCl7Yi5jb250ZW50PXQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2Zvcih2YXIgYztjPWIuZmlyc3RDaGlsZDspbC5jYWxsKGIuY29udGVudCxjKTtpZihVKWIuX19wcm90b19fPWEucHJvdG90eXBlO2Vsc2UgaWYoYi5jbG9uZU5vZGU9ZnVuY3Rpb24oYil7cmV0dXJuIGEuYSh0aGlzLGIpfSxuYSl0cnl7bmMoYiksb2MoYil9Y2F0Y2goTmcpe25hPSExfWEuSihiLmNvbnRlbnQpfX07dmFyIG5jPWZ1bmN0aW9uKGIpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiaW5uZXJIVE1MXCIse2dldDpmdW5jdGlvbigpe2Zvcih2YXIgYT1cIlwiLGI9dGhpcy5jb250ZW50LmZpcnN0Q2hpbGQ7YjtiPWIubmV4dFNpYmxpbmcpYSs9Yi5vdXRlckhUTUx8fFxuYi5kYXRhLnJlcGxhY2UoR2UscGMpO3JldHVybiBhfSxzZXQ6ZnVuY3Rpb24oYil7dC5ib2R5LmlubmVySFRNTD1iO2ZvcihhLkoodCk7dGhpcy5jb250ZW50LmZpcnN0Q2hpbGQ7KWsuY2FsbCh0aGlzLmNvbnRlbnQsdGhpcy5jb250ZW50LmZpcnN0Q2hpbGQpO2Zvcig7dC5ib2R5LmZpcnN0Q2hpbGQ7KWwuY2FsbCh0aGlzLmNvbnRlbnQsdC5ib2R5LmZpcnN0Q2hpbGQpfSxjb25maWd1cmFibGU6ITB9KX0sb2M9ZnVuY3Rpb24oYSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsXCJvdXRlckhUTUxcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuXCI8dGVtcGxhdGU+XCIrdGhpcy5pbm5lckhUTUwrXCI8L3RlbXBsYXRlPlwifSxzZXQ6ZnVuY3Rpb24oYSl7aWYodGhpcy5wYXJlbnROb2RlKXt0LmJvZHkuaW5uZXJIVE1MPWE7Zm9yKGE9dGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTt0LmJvZHkuZmlyc3RDaGlsZDspbC5jYWxsKGEsdC5ib2R5LmZpcnN0Q2hpbGQpO20uY2FsbCh0aGlzLnBhcmVudE5vZGUsXG5hLHRoaXMpfWVsc2UgdGhyb3cgRXJyb3IoXCJGYWlsZWQgdG8gc2V0IHRoZSAnb3V0ZXJIVE1MJyBwcm9wZXJ0eSBvbiAnRWxlbWVudCc6IFRoaXMgZWxlbWVudCBoYXMgbm8gcGFyZW50IG5vZGUuXCIpO30sY29uZmlndXJhYmxlOiEwfSl9O25jKGEucHJvdG90eXBlKTtvYyhhLnByb3RvdHlwZSk7YS5KPWZ1bmN0aW9uKGMpe2M9YihjLFwidGVtcGxhdGVcIik7Zm9yKHZhciBkPTAsZT1jLmxlbmd0aCxmO2Q8ZSYmKGY9Y1tkXSk7ZCsrKWEuRChmKX07ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIixmdW5jdGlvbigpe2EuSihkb2N1bWVudCl9KTtEb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudD1mdW5jdGlvbigpe3ZhciBiPWguYXBwbHkodGhpcyxhcmd1bWVudHMpO1widGVtcGxhdGVcIj09PWIubG9jYWxOYW1lJiZhLkQoYik7cmV0dXJuIGJ9O3ZhciBHZT0vWyZcXHUwMEEwPD5dL2cscGM9ZnVuY3Rpb24oYSl7c3dpdGNoKGEpe2Nhc2UgXCImXCI6cmV0dXJuXCImYW1wO1wiO1xuY2FzZSBcIjxcIjpyZXR1cm5cIiZsdDtcIjtjYXNlIFwiPlwiOnJldHVyblwiJmd0O1wiO2Nhc2UgXCJcXHUwMGEwXCI6cmV0dXJuXCImbmJzcDtcIn19fWlmKGN8fFphKXthLmE9ZnVuY3Rpb24oYSxiKXt2YXIgYz1mLmNhbGwoYSwhMSk7dGhpcy5EJiZ0aGlzLkQoYyk7YiYmKGwuY2FsbChjLmNvbnRlbnQsZi5jYWxsKGEuY29udGVudCwhMCkpLCRhKGMuY29udGVudCxhLmNvbnRlbnQpKTtyZXR1cm4gY307dmFyICRhPWZ1bmN0aW9uKGMsZCl7aWYoZC5xdWVyeVNlbGVjdG9yQWxsJiYoZD1iKGQsXCJ0ZW1wbGF0ZVwiKSwwIT09ZC5sZW5ndGgpKXtjPWIoYyxcInRlbXBsYXRlXCIpO2Zvcih2YXIgZT0wLGY9Yy5sZW5ndGgsaCxnO2U8ZjtlKyspZz1kW2VdLGg9Y1tlXSxhJiZhLkQmJmEuRChnKSxtLmNhbGwoaC5wYXJlbnROb2RlLEhlLmNhbGwoZywhMCksaCl9fSxIZT1Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGU9ZnVuY3Rpb24oYil7aWYoIWUmJmQmJnRoaXMgaW5zdGFuY2VvZiBEb2N1bWVudEZyYWdtZW50KWlmKGIpdmFyIGM9XG5JZS5jYWxsKHRoaXMub3duZXJEb2N1bWVudCx0aGlzLCEwKTtlbHNlIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO2Vsc2UgdGhpcy5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFJiZcInRlbXBsYXRlXCI9PT10aGlzLmxvY2FsTmFtZT9jPWEuYSh0aGlzLGIpOmM9Zi5jYWxsKHRoaXMsYik7YiYmJGEoYyx0aGlzKTtyZXR1cm4gY30sSWU9RG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGU9ZnVuY3Rpb24oYixjKXtjPWN8fCExO2lmKFwidGVtcGxhdGVcIj09PWIubG9jYWxOYW1lKXJldHVybiBhLmEoYixjKTt2YXIgZD1nLmNhbGwodGhpcyxiLGMpO2MmJiRhKGQsYik7cmV0dXJuIGR9fWMmJih3aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudD1hKX0pKCk7dmFyIGthO0FycmF5LmlzQXJyYXk/a2E9QXJyYXkuaXNBcnJheTprYT1mdW5jdGlvbihhKXtyZXR1cm5cIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYSl9O3ZhciBsYT1rYTt2YXIgbWE9MCxvYSxwYT1cInVuZGVmaW5lZFwiIT09dHlwZW9mIHdpbmRvdz93aW5kb3c6dm9pZCAwLHFhPXBhfHx7fSxyYT1xYS5NdXRhdGlvbk9ic2VydmVyfHxxYS5XZWJLaXRNdXRhdGlvbk9ic2VydmVyLHNhPVwidW5kZWZpbmVkXCIhPT10eXBlb2YgVWludDhDbGFtcGVkQXJyYXkmJlwidW5kZWZpbmVkXCIhPT10eXBlb2YgaW1wb3J0U2NyaXB0cyYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBNZXNzYWdlQ2hhbm5lbDtmdW5jdGlvbiB0YSgpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2Ygb2E/ZnVuY3Rpb24oKXtvYSh1YSl9OnZhKCl9ZnVuY3Rpb24gd2EoKXt2YXIgYT0wLGI9bmV3IHJhKHVhKSxjPWRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiXCIpO2Iub2JzZXJ2ZShjLHtjaGFyYWN0ZXJEYXRhOiEwfSk7cmV0dXJuIGZ1bmN0aW9uKCl7Yy5kYXRhPWE9KythJTJ9fVxuZnVuY3Rpb24geGEoKXt2YXIgYT1uZXcgTWVzc2FnZUNoYW5uZWw7YS5wb3J0MS5vbm1lc3NhZ2U9dWE7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIGEucG9ydDIucG9zdE1lc3NhZ2UoMCl9fWZ1bmN0aW9uIHZhKCl7dmFyIGE9c2V0VGltZW91dDtyZXR1cm4gZnVuY3Rpb24oKXtyZXR1cm4gYSh1YSwxKX19dmFyIHlhPUFycmF5KDFFMyk7ZnVuY3Rpb24gdWEoKXtmb3IodmFyIGE9MDthPG1hO2ErPTIpKDAseWFbYV0pKHlhW2ErMV0pLHlhW2FdPXZvaWQgMCx5YVthKzFdPXZvaWQgMDttYT0wfXZhciB6YSxBYTtcbmlmKFwidW5kZWZpbmVkXCI9PT10eXBlb2Ygc2VsZiYmXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBwcm9jZXNzJiZcIltvYmplY3QgcHJvY2Vzc11cIj09PXt9LnRvU3RyaW5nLmNhbGwocHJvY2VzcykpQWE9ZnVuY3Rpb24oKXtyZXR1cm4gcHJvY2Vzcy5qYih1YSl9O2Vsc2V7dmFyIEJhO2lmKHJhKUJhPXdhKCk7ZWxzZXt2YXIgQ2E7aWYoc2EpQ2E9eGEoKTtlbHNle3ZhciBEYTtpZih2b2lkIDA9PT1wYSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIHJlcXVpcmUpdHJ5e3ZhciBFYT1yZXF1aXJlKFwidmVydHhcIik7b2E9RWEubGJ8fEVhLmtiO0RhPXRhKCl9Y2F0Y2goYSl7RGE9dmEoKX1lbHNlIERhPXZhKCk7Q2E9RGF9QmE9Q2F9QWE9QmF9emE9QWE7ZnVuY3Rpb24gRmEoYSxiKXt5YVttYV09YTt5YVttYSsxXT1iO21hKz0yOzI9PT1tYSYmemEoKX07ZnVuY3Rpb24gR2EoYSxiKXt2YXIgYz10aGlzLGQ9bmV3IHRoaXMuY29uc3RydWN0b3IoSGEpO3ZvaWQgMD09PWRbSWFdJiZKYShkKTt2YXIgZT1jLmc7aWYoZSl7dmFyIGY9YXJndW1lbnRzW2UtMV07RmEoZnVuY3Rpb24oKXtyZXR1cm4gS2EoZSxkLGYsYy5mKX0pfWVsc2UgTGEoYyxkLGEsYik7cmV0dXJuIGR9O2Z1bmN0aW9uIE1hKGEpe2lmKGEmJlwib2JqZWN0XCI9PT10eXBlb2YgYSYmYS5jb25zdHJ1Y3Rvcj09PXRoaXMpcmV0dXJuIGE7dmFyIGI9bmV3IHRoaXMoSGEpO05hKGIsYSk7cmV0dXJuIGJ9O3ZhciBJYT1NYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMTYpO2Z1bmN0aW9uIEhhKCl7fXZhciBQYT1uZXcgT2E7ZnVuY3Rpb24gUWEoYSl7dHJ5e3JldHVybiBhLnRoZW59Y2F0Y2goYil7cmV0dXJuIFBhLmVycm9yPWIsUGF9fWZ1bmN0aW9uIFJhKGEsYixjLGQpe3RyeXthLmNhbGwoYixjLGQpfWNhdGNoKGUpe3JldHVybiBlfX1mdW5jdGlvbiBTYShhLGIsYyl7RmEoZnVuY3Rpb24oYSl7dmFyIGQ9ITEsZj1SYShjLGIsZnVuY3Rpb24oYyl7ZHx8KGQ9ITAsYiE9PWM/TmEoYSxjKTpyKGEsYykpfSxmdW5jdGlvbihiKXtkfHwoZD0hMCx1KGEsYikpfSk7IWQmJmYmJihkPSEwLHUoYSxmKSl9LGEpfWZ1bmN0aW9uIFRhKGEsYil7MT09PWIuZz9yKGEsYi5mKToyPT09Yi5nP3UoYSxiLmYpOkxhKGIsdm9pZCAwLGZ1bmN0aW9uKGIpe3JldHVybiBOYShhLGIpfSxmdW5jdGlvbihiKXtyZXR1cm4gdShhLGIpfSl9XG5mdW5jdGlvbiBVYShhLGIsYyl7Yi5jb25zdHJ1Y3Rvcj09PWEuY29uc3RydWN0b3ImJmM9PT1HYSYmYi5jb25zdHJ1Y3Rvci5yZXNvbHZlPT09TWE/VGEoYSxiKTpjPT09UGE/KHUoYSxQYS5lcnJvciksUGEuZXJyb3I9bnVsbCk6dm9pZCAwPT09Yz9yKGEsYik6XCJmdW5jdGlvblwiPT09dHlwZW9mIGM/U2EoYSxiLGMpOnIoYSxiKX1mdW5jdGlvbiBOYShhLGIpe2lmKGE9PT1iKXUoYSxuZXcgVHlwZUVycm9yKFwiWW91IGNhbm5vdCByZXNvbHZlIGEgcHJvbWlzZSB3aXRoIGl0c2VsZlwiKSk7ZWxzZXt2YXIgYz10eXBlb2YgYjtudWxsPT09Ynx8XCJvYmplY3RcIiE9PWMmJlwiZnVuY3Rpb25cIiE9PWM/cihhLGIpOlVhKGEsYixRYShiKSl9fWZ1bmN0aW9uIFZhKGEpe2EucGEmJmEucGEoYS5mKTtXYShhKX1mdW5jdGlvbiByKGEsYil7dm9pZCAwPT09YS5nJiYoYS5mPWIsYS5nPTEsMCE9PWEuSS5sZW5ndGgmJkZhKFdhLGEpKX1cbmZ1bmN0aW9uIHUoYSxiKXt2b2lkIDA9PT1hLmcmJihhLmc9MixhLmY9YixGYShWYSxhKSl9ZnVuY3Rpb24gTGEoYSxiLGMsZCl7dmFyIGU9YS5JLGY9ZS5sZW5ndGg7YS5wYT1udWxsO2VbZl09YjtlW2YrMV09YztlW2YrMl09ZDswPT09ZiYmYS5nJiZGYShXYSxhKX1mdW5jdGlvbiBXYShhKXt2YXIgYj1hLkksYz1hLmc7aWYoMCE9PWIubGVuZ3RoKXtmb3IodmFyIGQsZSxmPWEuZixoPTA7aDxiLmxlbmd0aDtoKz0zKWQ9YltoXSxlPWJbaCtjXSxkP0thKGMsZCxlLGYpOmUoZik7YS5JLmxlbmd0aD0wfX1mdW5jdGlvbiBPYSgpe3RoaXMuZXJyb3I9bnVsbH12YXIgWGE9bmV3IE9hO1xuZnVuY3Rpb24gS2EoYSxiLGMsZCl7dmFyIGU9XCJmdW5jdGlvblwiPT09dHlwZW9mIGM7aWYoZSl7dHJ5e3ZhciBmPWMoZCl9Y2F0Y2gobCl7WGEuZXJyb3I9bCxmPVhhfWlmKGY9PT1YYSl7dmFyIGg9ITA7dmFyIGc9Zi5lcnJvcjtmLmVycm9yPW51bGx9ZWxzZSB2YXIgaz0hMDtpZihiPT09Zil7dShiLG5ldyBUeXBlRXJyb3IoXCJBIHByb21pc2VzIGNhbGxiYWNrIGNhbm5vdCByZXR1cm4gdGhhdCBzYW1lIHByb21pc2UuXCIpKTtyZXR1cm59fWVsc2UgZj1kLGs9ITA7dm9pZCAwPT09Yi5nJiYoZSYmaz9OYShiLGYpOmg/dShiLGcpOjE9PT1hP3IoYixmKToyPT09YSYmdShiLGYpKX1mdW5jdGlvbiBZYShhLGIpe3RyeXtiKGZ1bmN0aW9uKGIpe05hKGEsYil9LGZ1bmN0aW9uKGIpe3UoYSxiKX0pfWNhdGNoKGMpe3UoYSxjKX19dmFyIGFiPTA7ZnVuY3Rpb24gSmEoYSl7YVtJYV09YWIrKzthLmc9dm9pZCAwO2EuZj12b2lkIDA7YS5JPVtdfTtmdW5jdGlvbiBiYihhLGIpe3RoaXMuR2E9YTt0aGlzLkE9bmV3IGEoSGEpO3RoaXMuQVtJYV18fEphKHRoaXMuQSk7aWYobGEoYikpaWYodGhpcy5TPXRoaXMubGVuZ3RoPWIubGVuZ3RoLHRoaXMuZj1BcnJheSh0aGlzLmxlbmd0aCksMD09PXRoaXMubGVuZ3RoKXIodGhpcy5BLHRoaXMuZik7ZWxzZXt0aGlzLmxlbmd0aD10aGlzLmxlbmd0aHx8MDtmb3IoYT0wO3ZvaWQgMD09PXRoaXMuZyYmYTxiLmxlbmd0aDthKyspY2IodGhpcyxiW2FdLGEpOzA9PT10aGlzLlMmJnIodGhpcy5BLHRoaXMuZil9ZWxzZSB1KHRoaXMuQSxFcnJvcihcIkFycmF5IE1ldGhvZHMgbXVzdCBiZSBwcm92aWRlZCBhbiBBcnJheVwiKSl9XG5mdW5jdGlvbiBjYihhLGIsYyl7dmFyIGQ9YS5HYSxlPWQucmVzb2x2ZTtlPT09TWE/KGU9UWEoYiksZT09PUdhJiZ2b2lkIDAhPT1iLmc/ZGIoYSxiLmcsYyxiLmYpOlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBlPyhhLlMtLSxhLmZbY109Yik6ZD09PXY/KGQ9bmV3IGQoSGEpLFVhKGQsYixlKSxlYihhLGQsYykpOmViKGEsbmV3IGQoZnVuY3Rpb24oYSl7cmV0dXJuIGEoYil9KSxjKSk6ZWIoYSxlKGIpLGMpfWZ1bmN0aW9uIGRiKGEsYixjLGQpe3ZhciBlPWEuQTt2b2lkIDA9PT1lLmcmJihhLlMtLSwyPT09Yj91KGUsZCk6YS5mW2NdPWQpOzA9PT1hLlMmJnIoZSxhLmYpfWZ1bmN0aW9uIGViKGEsYixjKXtMYShiLHZvaWQgMCxmdW5jdGlvbihiKXtyZXR1cm4gZGIoYSwxLGMsYil9LGZ1bmN0aW9uKGIpe3JldHVybiBkYihhLDIsYyxiKX0pfTtmdW5jdGlvbiBmYihhKXtyZXR1cm4obmV3IGJiKHRoaXMsYSkpLkF9O2Z1bmN0aW9uIGdiKGEpe3ZhciBiPXRoaXM7cmV0dXJuIGxhKGEpP25ldyBiKGZ1bmN0aW9uKGMsZCl7Zm9yKHZhciBlPWEubGVuZ3RoLGY9MDtmPGU7ZisrKWIucmVzb2x2ZShhW2ZdKS50aGVuKGMsZCl9KTpuZXcgYihmdW5jdGlvbihhLGIpe3JldHVybiBiKG5ldyBUeXBlRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IHRvIHJhY2UuXCIpKX0pfTtmdW5jdGlvbiBoYihhKXt2YXIgYj1uZXcgdGhpcyhIYSk7dShiLGEpO3JldHVybiBifTtmdW5jdGlvbiB2KGEpe3RoaXNbSWFdPWFiKys7dGhpcy5mPXRoaXMuZz12b2lkIDA7dGhpcy5JPVtdO2lmKEhhIT09YSl7aWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIGEpdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHBhc3MgYSByZXNvbHZlciBmdW5jdGlvbiBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIHByb21pc2UgY29uc3RydWN0b3JcIik7aWYodGhpcyBpbnN0YW5jZW9mIHYpWWEodGhpcyxhKTtlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdQcm9taXNlJzogUGxlYXNlIHVzZSB0aGUgJ25ldycgb3BlcmF0b3IsIHRoaXMgb2JqZWN0IGNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjYWxsZWQgYXMgYSBmdW5jdGlvbi5cIik7fX12LnByb3RvdHlwZT17Y29uc3RydWN0b3I6dix0aGVuOkdhLGE6ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudGhlbihudWxsLGEpfX07LypcblxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbndpbmRvdy5Qcm9taXNlfHwod2luZG93LlByb21pc2U9dix2LnByb3RvdHlwZVtcImNhdGNoXCJdPXYucHJvdG90eXBlLmEsdi5wcm90b3R5cGUudGhlbj12LnByb3RvdHlwZS50aGVuLHYuYWxsPWZiLHYucmFjZT1nYix2LnJlc29sdmU9TWEsdi5yZWplY3Q9aGIpOyhmdW5jdGlvbihhKXtmdW5jdGlvbiBiKGEsYil7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIHdpbmRvdy5DdXN0b21FdmVudClyZXR1cm4gbmV3IEN1c3RvbUV2ZW50KGEsYik7dmFyIGM9ZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtjLmluaXRDdXN0b21FdmVudChhLCEhYi5idWJibGVzLCEhYi5jYW5jZWxhYmxlLGIuZGV0YWlsKTtyZXR1cm4gY31mdW5jdGlvbiBjKGEpe2lmKG0pcmV0dXJuIGEub3duZXJEb2N1bWVudCE9PWRvY3VtZW50P2Eub3duZXJEb2N1bWVudDpudWxsO3ZhciBiPWEuX19pbXBvcnREb2M7aWYoIWImJmEucGFyZW50Tm9kZSl7Yj1hLnBhcmVudE5vZGU7aWYoXCJmdW5jdGlvblwiPT09dHlwZW9mIGIuY2xvc2VzdCliPWIuY2xvc2VzdChcImxpbmtbcmVsPWltcG9ydF1cIik7ZWxzZSBmb3IoOyFnKGIpJiYoYj1iLnBhcmVudE5vZGUpOyk7YS5fX2ltcG9ydERvYz1ifXJldHVybiBifWZ1bmN0aW9uIGQoYSl7dmFyIGI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtbcmVsPWltcG9ydF06bm90KFtpbXBvcnQtZGVwZW5kZW5jeV0pXCIpLFxuYz1iLmxlbmd0aDtjP2woYixmdW5jdGlvbihiKXtyZXR1cm4gaChiLGZ1bmN0aW9uKCl7MD09PS0tYyYmYSgpfSl9KTphKCl9ZnVuY3Rpb24gZShhKXtmdW5jdGlvbiBiKCl7XCJsb2FkaW5nXCIhPT1kb2N1bWVudC5yZWFkeVN0YXRlJiZkb2N1bWVudC5ib2R5JiYoZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixiKSxhKCkpfWRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsYik7YigpfWZ1bmN0aW9uIGYoYSl7ZShmdW5jdGlvbigpe3JldHVybiBkKGZ1bmN0aW9uKCl7cmV0dXJuIGEmJmEoKX0pfSl9ZnVuY3Rpb24gaChhLGIpe2lmKGEuX19sb2FkZWQpYiYmYigpO2Vsc2UgaWYoXCJzY3JpcHRcIj09PWEubG9jYWxOYW1lJiYhYS5zcmN8fFwic3R5bGVcIj09PWEubG9jYWxOYW1lJiYhYS5maXJzdENoaWxkKWEuX19sb2FkZWQ9ITAsYiYmYigpO2Vsc2V7dmFyIGM9ZnVuY3Rpb24oZCl7YS5yZW1vdmVFdmVudExpc3RlbmVyKGQudHlwZSxcbmMpO2EuX19sb2FkZWQ9ITA7YiYmYigpfTthLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsYyk7YWEmJlwic3R5bGVcIj09PWEubG9jYWxOYW1lfHxhLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLGMpfX1mdW5jdGlvbiBnKGEpe3JldHVybiBhLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJlwibGlua1wiPT09YS5sb2NhbE5hbWUmJlwiaW1wb3J0XCI9PT1hLnJlbH1mdW5jdGlvbiBrKCl7dmFyIGE9dGhpczt0aGlzLmE9e307dGhpcy5iPTA7dGhpcy5oPW5ldyBNdXRhdGlvbk9ic2VydmVyKGZ1bmN0aW9uKGIpe3JldHVybiBhLlFhKGIpfSk7dGhpcy5oLm9ic2VydmUoZG9jdW1lbnQuaGVhZCx7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9KTt0aGlzLmMoZG9jdW1lbnQpfWZ1bmN0aW9uIGwoYSxiLGMpe3ZhciBkPWE/YS5sZW5ndGg6MCxlPWM/LTE6MTtmb3IoYz1jP2QtMTowO2M8ZCYmMDw9YztjKz1lKWIoYVtjXSxjKX12YXIgbT1cImltcG9ydFwiaW4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIiksXG5uPW51bGw7ITE9PT1cImN1cnJlbnRTY3JpcHRcImluIGRvY3VtZW50JiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZG9jdW1lbnQsXCJjdXJyZW50U2NyaXB0XCIse2dldDpmdW5jdGlvbigpe3JldHVybiBufHwoXCJjb21wbGV0ZVwiIT09ZG9jdW1lbnQucmVhZHlTdGF0ZT9kb2N1bWVudC5zY3JpcHRzW2RvY3VtZW50LnNjcmlwdHMubGVuZ3RoLTFdOm51bGwpfSxjb25maWd1cmFibGU6ITB9KTt2YXIgdz0vKHVybFxcKCkoW14pXSopKFxcKSkvZyxJPS8oQGltcG9ydFtcXHNdKyg/IXVybFxcKCkpKFteO10qKSg7KS9nLFphPS8oPGxpbmtbXj5dKikocmVsPVsnfFwiXT9zdHlsZXNoZWV0Wyd8XCJdP1tePl0qPikvZyx0PXtLYTpmdW5jdGlvbihhLGIpe2EuaHJlZiYmYS5zZXRBdHRyaWJ1dGUoXCJocmVmXCIsdC5ZKGEuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSxiKSk7YS5zcmMmJmEuc2V0QXR0cmlidXRlKFwic3JjXCIsdC5ZKGEuZ2V0QXR0cmlidXRlKFwic3JjXCIpLGIpKTtpZihcInN0eWxlXCI9PT1hLmxvY2FsTmFtZSl7dmFyIGM9XG50LnVhKGEudGV4dENvbnRlbnQsYix3KTthLnRleHRDb250ZW50PXQudWEoYyxiLEkpfX0sdWE6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBhLnJlcGxhY2UoYyxmdW5jdGlvbihhLGMsZCxlKXthPWQucmVwbGFjZSgvW1wiJ10vZyxcIlwiKTtiJiYoYT10LlkoYSxiKSk7cmV0dXJuIGMrXCInXCIrYStcIidcIitlfSl9LFk6ZnVuY3Rpb24oYSxiKXtpZih2b2lkIDA9PT10LmNhKXt0LmNhPSExO3RyeXt2YXIgYz1uZXcgVVJMKFwiYlwiLFwiaHR0cDovL2FcIik7Yy5wYXRobmFtZT1cImMlMjBkXCI7dC5jYT1cImh0dHA6Ly9hL2MlMjBkXCI9PT1jLmhyZWZ9Y2F0Y2gocGMpe319aWYodC5jYSlyZXR1cm4obmV3IFVSTChhLGIpKS5ocmVmO2M9dC5EYTtjfHwoYz1kb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoXCJ0ZW1wXCIpLHQuRGE9YyxjLm1hPWMuY3JlYXRlRWxlbWVudChcImJhc2VcIiksYy5oZWFkLmFwcGVuZENoaWxkKGMubWEpLGMubGE9Yy5jcmVhdGVFbGVtZW50KFwiYVwiKSk7Yy5tYS5ocmVmPVxuYjtjLmxhLmhyZWY9YTtyZXR1cm4gYy5sYS5ocmVmfHxhfX0sbmE9e2FzeW5jOiEwLGxvYWQ6ZnVuY3Rpb24oYSxiLGMpe2lmKGEpaWYoYS5tYXRjaCgvXmRhdGE6Lykpe2E9YS5zcGxpdChcIixcIik7dmFyIGQ9YVsxXTtkPS0xPGFbMF0uaW5kZXhPZihcIjtiYXNlNjRcIik/YXRvYihkKTpkZWNvZGVVUklDb21wb25lbnQoZCk7YihkKX1lbHNle3ZhciBlPW5ldyBYTUxIdHRwUmVxdWVzdDtlLm9wZW4oXCJHRVRcIixhLG5hLmFzeW5jKTtlLm9ubG9hZD1mdW5jdGlvbigpe3ZhciBhPWUucmVzcG9uc2VVUkx8fGUuZ2V0UmVzcG9uc2VIZWFkZXIoXCJMb2NhdGlvblwiKTthJiYwPT09YS5pbmRleE9mKFwiL1wiKSYmKGE9KGxvY2F0aW9uLm9yaWdpbnx8bG9jYXRpb24ucHJvdG9jb2wrXCIvL1wiK2xvY2F0aW9uLmhvc3QpK2EpO3ZhciBkPWUucmVzcG9uc2V8fGUucmVzcG9uc2VUZXh0OzMwND09PWUuc3RhdHVzfHwwPT09ZS5zdGF0dXN8fDIwMDw9ZS5zdGF0dXMmJjMwMD5lLnN0YXR1cz9iKGQsYSk6YyhkKX07XG5lLnNlbmQoKX1lbHNlIGMoXCJlcnJvcjogaHJlZiBtdXN0IGJlIHNwZWNpZmllZFwiKX19LGFhPS9UcmlkZW50Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpfHwvRWRnZVxcL1xcZC4vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO2sucHJvdG90eXBlLmM9ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczthPWEucXVlcnlTZWxlY3RvckFsbChcImxpbmtbcmVsPWltcG9ydF1cIik7bChhLGZ1bmN0aW9uKGEpe3JldHVybiBiLkwoYSl9KX07ay5wcm90b3R5cGUuTD1mdW5jdGlvbihhKXt2YXIgYj10aGlzLGM9YS5ocmVmO2lmKHZvaWQgMCE9PXRoaXMuYVtjXSl7dmFyIGQ9dGhpcy5hW2NdO2QmJmQuX19sb2FkZWQmJihhLmltcG9ydD1kLHRoaXMubyhhKSl9ZWxzZSB0aGlzLmIrKyx0aGlzLmFbY109XCJwZW5kaW5nXCIsbmEubG9hZChjLGZ1bmN0aW9uKGEsZCl7YT1iLlJhKGEsZHx8Yyk7Yi5hW2NdPWE7Yi5iLS07Yi5jKGEpO2Iuc2EoKX0sZnVuY3Rpb24oKXtiLmFbY109bnVsbDtiLmItLTtiLnNhKCl9KX07XG5rLnByb3RvdHlwZS5SYT1mdW5jdGlvbihhLGIpe2lmKCFhKXJldHVybiBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7YWEmJihhPWEucmVwbGFjZShaYSxmdW5jdGlvbihhLGIsYyl7cmV0dXJuLTE9PT1hLmluZGV4T2YoXCJ0eXBlPVwiKT9iK1wiIHR5cGU9aW1wb3J0LWRpc2FibGUgXCIrYzphfSkpO3ZhciBjPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtjLmlubmVySFRNTD1hO2lmKGMuY29udGVudClhPWMuY29udGVudDtlbHNlIGZvcihhPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtjLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYy5maXJzdENoaWxkKTtpZihjPWEucXVlcnlTZWxlY3RvcihcImJhc2VcIikpYj10LlkoYy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpLGIpLGMucmVtb3ZlQXR0cmlidXRlKFwiaHJlZlwiKTtjPWEucXVlcnlTZWxlY3RvckFsbCgnbGlua1tyZWw9aW1wb3J0XSwgbGlua1tyZWw9c3R5bGVzaGVldF1baHJlZl1bdHlwZT1pbXBvcnQtZGlzYWJsZV0sXFxuICAgIHN0eWxlOm5vdChbdHlwZV0pLCBsaW5rW3JlbD1zdHlsZXNoZWV0XVtocmVmXTpub3QoW3R5cGVdKSxcXG4gICAgc2NyaXB0Om5vdChbdHlwZV0pLCBzY3JpcHRbdHlwZT1cImFwcGxpY2F0aW9uL2phdmFzY3JpcHRcIl0sXFxuICAgIHNjcmlwdFt0eXBlPVwidGV4dC9qYXZhc2NyaXB0XCJdJyk7XG52YXIgZD0wO2woYyxmdW5jdGlvbihhKXtoKGEpO3QuS2EoYSxiKTthLnNldEF0dHJpYnV0ZShcImltcG9ydC1kZXBlbmRlbmN5XCIsXCJcIik7XCJzY3JpcHRcIj09PWEubG9jYWxOYW1lJiYhYS5zcmMmJmEudGV4dENvbnRlbnQmJihhLnNldEF0dHJpYnV0ZShcInNyY1wiLFwiZGF0YTp0ZXh0L2phdmFzY3JpcHQ7Y2hhcnNldD11dGYtOCxcIitlbmNvZGVVUklDb21wb25lbnQoYS50ZXh0Q29udGVudCsoXCJcXG4vLyMgc291cmNlVVJMPVwiK2IrKGQ/XCItXCIrZDpcIlwiKStcIi5qc1xcblwiKSkpLGEudGV4dENvbnRlbnQ9XCJcIixkKyspfSk7cmV0dXJuIGF9O2sucHJvdG90eXBlLnNhPWZ1bmN0aW9uKCl7dmFyIGE9dGhpcztpZighdGhpcy5iKXt0aGlzLmguZGlzY29ubmVjdCgpO3RoaXMuZmxhdHRlbihkb2N1bWVudCk7dmFyIGI9ITEsYz0hMSxkPWZ1bmN0aW9uKCl7YyYmYiYmKGEuYyhkb2N1bWVudCksYS5ifHwoYS5oLm9ic2VydmUoZG9jdW1lbnQuaGVhZCx7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9KSxhLlBhKCkpKX07XG50aGlzLldhKGZ1bmN0aW9uKCl7Yz0hMDtkKCl9KTt0aGlzLlNhKGZ1bmN0aW9uKCl7Yj0hMDtkKCl9KX19O2sucHJvdG90eXBlLmZsYXR0ZW49ZnVuY3Rpb24oYSl7dmFyIGI9dGhpczthPWEucXVlcnlTZWxlY3RvckFsbChcImxpbmtbcmVsPWltcG9ydF1cIik7bChhLGZ1bmN0aW9uKGEpe3ZhciBjPWIuYVthLmhyZWZdOyhhLmltcG9ydD1jKSYmYy5ub2RlVHlwZT09PU5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSYmKGIuYVthLmhyZWZdPWEsYS5yZWFkeVN0YXRlPVwibG9hZGluZ1wiLGEuaW1wb3J0PWEsYi5mbGF0dGVuKGMpLGEuYXBwZW5kQ2hpbGQoYykpfSl9O2sucHJvdG90eXBlLlNhPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoZSl7aWYoZTxkKXt2YXIgZj1jW2VdLGc9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtmLnJlbW92ZUF0dHJpYnV0ZShcImltcG9ydC1kZXBlbmRlbmN5XCIpO2woZi5hdHRyaWJ1dGVzLGZ1bmN0aW9uKGEpe3JldHVybiBnLnNldEF0dHJpYnV0ZShhLm5hbWUsXG5hLnZhbHVlKX0pO249ZztmLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGcsZik7aChnLGZ1bmN0aW9uKCl7bj1udWxsO2IoZSsxKX0pfWVsc2UgYSgpfXZhciBjPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzY3JpcHRbaW1wb3J0LWRlcGVuZGVuY3ldXCIpLGQ9Yy5sZW5ndGg7YigwKX07ay5wcm90b3R5cGUuV2E9ZnVuY3Rpb24oYSl7dmFyIGI9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcInN0eWxlW2ltcG9ydC1kZXBlbmRlbmN5XSxcXG4gICAgbGlua1tyZWw9c3R5bGVzaGVldF1baW1wb3J0LWRlcGVuZGVuY3ldXCIpLGQ9Yi5sZW5ndGg7aWYoZCl7dmFyIGU9YWEmJiEhZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImxpbmtbcmVsPXN0eWxlc2hlZXRdW2hyZWZdW3R5cGU9aW1wb3J0LWRpc2FibGVdXCIpO2woYixmdW5jdGlvbihiKXtoKGIsZnVuY3Rpb24oKXtiLnJlbW92ZUF0dHJpYnV0ZShcImltcG9ydC1kZXBlbmRlbmN5XCIpOzA9PT0tLWQmJmEoKX0pO2lmKGUmJmIucGFyZW50Tm9kZSE9PVxuZG9jdW1lbnQuaGVhZCl7dmFyIGY9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChiLmxvY2FsTmFtZSk7Zi5fX2FwcGxpZWRFbGVtZW50PWI7Zi5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsXCJpbXBvcnQtcGxhY2Vob2xkZXJcIik7Yi5wYXJlbnROb2RlLmluc2VydEJlZm9yZShmLGIubmV4dFNpYmxpbmcpO2ZvcihmPWMoYik7ZiYmYyhmKTspZj1jKGYpO2YucGFyZW50Tm9kZSE9PWRvY3VtZW50LmhlYWQmJihmPW51bGwpO2RvY3VtZW50LmhlYWQuaW5zZXJ0QmVmb3JlKGIsZik7Yi5yZW1vdmVBdHRyaWJ1dGUoXCJ0eXBlXCIpfX0pfWVsc2UgYSgpfTtrLnByb3RvdHlwZS5QYT1mdW5jdGlvbigpe3ZhciBhPXRoaXMsYj1kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwibGlua1tyZWw9aW1wb3J0XVwiKTtsKGIsZnVuY3Rpb24oYil7cmV0dXJuIGEubyhiKX0sITApfTtrLnByb3RvdHlwZS5vPWZ1bmN0aW9uKGEpe2EuX19sb2FkZWR8fChhLl9fbG9hZGVkPSEwLGEuaW1wb3J0JiYoYS5pbXBvcnQucmVhZHlTdGF0ZT1cblwiY29tcGxldGVcIiksYS5kaXNwYXRjaEV2ZW50KGIoYS5pbXBvcnQ/XCJsb2FkXCI6XCJlcnJvclwiLHtidWJibGVzOiExLGNhbmNlbGFibGU6ITEsZGV0YWlsOnZvaWQgMH0pKSl9O2sucHJvdG90eXBlLlFhPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXM7bChhLGZ1bmN0aW9uKGEpe3JldHVybiBsKGEuYWRkZWROb2RlcyxmdW5jdGlvbihhKXthJiZhLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUmJihnKGEpP2IuTChhKTpiLmMoYSkpfSl9KX07aWYobSl7dmFyIFQ9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtbcmVsPWltcG9ydF1cIik7bChULGZ1bmN0aW9uKGEpe2EuaW1wb3J0JiZcImxvYWRpbmdcIj09PWEuaW1wb3J0LnJlYWR5U3RhdGV8fChhLl9fbG9hZGVkPSEwKX0pO1Q9ZnVuY3Rpb24oYSl7YT1hLnRhcmdldDtnKGEpJiYoYS5fX2xvYWRlZD0hMCl9O2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsVCwhMCk7ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsXG5ULCEwKX1lbHNle3ZhciBVPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsXCJiYXNlVVJJXCIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSgoIVV8fFUuY29uZmlndXJhYmxlP05vZGU6RWxlbWVudCkucHJvdG90eXBlLFwiYmFzZVVSSVwiLHtnZXQ6ZnVuY3Rpb24oKXt2YXIgYT1nKHRoaXMpP3RoaXM6Yyh0aGlzKTtyZXR1cm4gYT9hLmhyZWY6VSYmVS5nZXQ/VS5nZXQuY2FsbCh0aGlzKTooZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcImJhc2VcIil8fHdpbmRvdy5sb2NhdGlvbikuaHJlZn0sY29uZmlndXJhYmxlOiEwLGVudW1lcmFibGU6ITB9KTtlKGZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBrfSl9ZihmdW5jdGlvbigpe3JldHVybiBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KGIoXCJIVE1MSW1wb3J0c0xvYWRlZFwiLHtjYW5jZWxhYmxlOiEwLGJ1YmJsZXM6ITAsZGV0YWlsOnZvaWQgMH0pKX0pO2EudXNlTmF0aXZlPW07YS53aGVuUmVhZHk9ZjthLmltcG9ydEZvckVsZW1lbnQ9XG5jfSkod2luZG93LkhUTUxJbXBvcnRzPXdpbmRvdy5IVE1MSW1wb3J0c3x8e30pOy8qXG5cbiBDb3B5cmlnaHQgKGMpIDIwMTQgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG53aW5kb3cuV2ViQ29tcG9uZW50cz13aW5kb3cuV2ViQ29tcG9uZW50c3x8e2ZsYWdzOnt9fTt2YXIgaWI9ZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc2NyaXB0W3NyYyo9XCJ3ZWJjb21wb25lbnRzLWxpdGUuanNcIl0nKSxqYj0vd2MtKC4rKS8seD17fTtpZigheC5ub09wdHMpe2xvY2F0aW9uLnNlYXJjaC5zbGljZSgxKS5zcGxpdChcIiZcIikuZm9yRWFjaChmdW5jdGlvbihhKXthPWEuc3BsaXQoXCI9XCIpO3ZhciBiO2FbMF0mJihiPWFbMF0ubWF0Y2goamIpKSYmKHhbYlsxXV09YVsxXXx8ITApfSk7aWYoaWIpZm9yKHZhciBrYj0wLGxiO2xiPWliLmF0dHJpYnV0ZXNba2JdO2tiKyspXCJzcmNcIiE9PWxiLm5hbWUmJih4W2xiLm5hbWVdPWxiLnZhbHVlfHwhMCk7aWYoeC5sb2cmJngubG9nLnNwbGl0KXt2YXIgbWI9eC5sb2cuc3BsaXQoXCIsXCIpO3gubG9nPXt9O21iLmZvckVhY2goZnVuY3Rpb24oYSl7eC5sb2dbYV09ITB9KX1lbHNlIHgubG9nPXt9fVxud2luZG93LldlYkNvbXBvbmVudHMuZmxhZ3M9eDt2YXIgbmI9eC5zaGFkeWRvbTtuYiYmKHdpbmRvdy5TaGFkeURPTT13aW5kb3cuU2hhZHlET018fHt9LHdpbmRvdy5TaGFkeURPTS5mb3JjZT1uYik7dmFyIG9iPXgucmVnaXN0ZXJ8fHguY2U7b2ImJndpbmRvdy5jdXN0b21FbGVtZW50cyYmKHdpbmRvdy5jdXN0b21FbGVtZW50cy5mb3JjZVBvbHlmaWxsPW9iKTsvKlxuXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xudmFyIHk9d2luZG93LlNoYWR5RE9NfHx7fTt5Lk1hPSEoIUVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvd3x8IU5vZGUucHJvdG90eXBlLmdldFJvb3ROb2RlKTt2YXIgcGI9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihOb2RlLnByb3RvdHlwZSxcImZpcnN0Q2hpbGRcIik7eS5NPSEhKHBiJiZwYi5jb25maWd1cmFibGUmJnBiLmdldCk7eS50YT15LmZvcmNlfHwheS5NYTtmdW5jdGlvbiBxYihhKXtyZXR1cm4gYS5fX3NoYWR5JiZ2b2lkIDAhPT1hLl9fc2hhZHkuZmlyc3RDaGlsZH1mdW5jdGlvbiB6KGEpe3JldHVyblwiU2hhZHlSb290XCI9PT1hLkFhfWZ1bmN0aW9uIHJiKGEpe2E9YS5nZXRSb290Tm9kZSgpO2lmKHooYSkpcmV0dXJuIGF9dmFyIHNiPUVsZW1lbnQucHJvdG90eXBlLHRiPXNiLm1hdGNoZXN8fHNiLm1hdGNoZXNTZWxlY3Rvcnx8c2IubW96TWF0Y2hlc1NlbGVjdG9yfHxzYi5tc01hdGNoZXNTZWxlY3Rvcnx8c2Iub01hdGNoZXNTZWxlY3Rvcnx8c2Iud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuZnVuY3Rpb24gdWIoYSxiKXtpZihhJiZiKWZvcih2YXIgYz1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiKSxkPTAsZTtkPGMubGVuZ3RoJiYoZT1jW2RdKTtkKyspe3ZhciBmPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYixlKTtmJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxlLGYpfX1mdW5jdGlvbiB2YihhLGIpe2Zvcih2YXIgYz1bXSxkPTE7ZDxhcmd1bWVudHMubGVuZ3RoOysrZCljW2QtMV09YXJndW1lbnRzW2RdO2ZvcihkPTA7ZDxjLmxlbmd0aDtkKyspdWIoYSxjW2RdKTtyZXR1cm4gYX1mdW5jdGlvbiB3YihhLGIpe2Zvcih2YXIgYyBpbiBiKWFbY109YltjXX12YXIgeGI9ZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXCJcIikseWI9MCx6Yj1bXTsobmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24oKXtmb3IoO3piLmxlbmd0aDspdHJ5e3piLnNoaWZ0KCkoKX1jYXRjaChhKXt0aHJvdyB4Yi50ZXh0Q29udGVudD15YisrLGE7fX0pKS5vYnNlcnZlKHhiLHtjaGFyYWN0ZXJEYXRhOiEwfSk7XG5mdW5jdGlvbiBBYihhKXt6Yi5wdXNoKGEpO3hiLnRleHRDb250ZW50PXliKyt9dmFyIEJiPSEhZG9jdW1lbnQuY29udGFpbnM7ZnVuY3Rpb24gQ2IoYSxiKXtmb3IoO2I7KXtpZihiPT1hKXJldHVybiEwO2I9Yi5wYXJlbnROb2RlfXJldHVybiExfTt2YXIgRGI9W10sRWI7ZnVuY3Rpb24gRmIoYSl7RWJ8fChFYj0hMCxBYihHYikpO0RiLnB1c2goYSl9ZnVuY3Rpb24gR2IoKXtFYj0hMTtmb3IodmFyIGE9ISFEYi5sZW5ndGg7RGIubGVuZ3RoOylEYi5zaGlmdCgpKCk7cmV0dXJuIGF9R2IubGlzdD1EYjtmdW5jdGlvbiBIYigpe3RoaXMuYT0hMTt0aGlzLmFkZGVkTm9kZXM9W107dGhpcy5yZW1vdmVkTm9kZXM9W107dGhpcy5WPW5ldyBTZXR9ZnVuY3Rpb24gSWIoYSl7YS5hfHwoYS5hPSEwLEFiKGZ1bmN0aW9uKCl7SmIoYSl9KSl9ZnVuY3Rpb24gSmIoYSl7aWYoYS5hKXthLmE9ITE7dmFyIGI9YS50YWtlUmVjb3JkcygpO2IubGVuZ3RoJiZhLlYuZm9yRWFjaChmdW5jdGlvbihhKXthKGIpfSl9fUhiLnByb3RvdHlwZS50YWtlUmVjb3Jkcz1mdW5jdGlvbigpe2lmKHRoaXMuYWRkZWROb2Rlcy5sZW5ndGh8fHRoaXMucmVtb3ZlZE5vZGVzLmxlbmd0aCl7dmFyIGE9W3thZGRlZE5vZGVzOnRoaXMuYWRkZWROb2RlcyxyZW1vdmVkTm9kZXM6dGhpcy5yZW1vdmVkTm9kZXN9XTt0aGlzLmFkZGVkTm9kZXM9W107dGhpcy5yZW1vdmVkTm9kZXM9W107cmV0dXJuIGF9cmV0dXJuW119O1xuZnVuY3Rpb24gS2IoYSxiKXthLl9fc2hhZHk9YS5fX3NoYWR5fHx7fTthLl9fc2hhZHkuTnx8KGEuX19zaGFkeS5OPW5ldyBIYik7YS5fX3NoYWR5Lk4uVi5hZGQoYik7dmFyIGM9YS5fX3NoYWR5Lk47cmV0dXJue0VhOmIsQzpjLEhhOmEsdGFrZVJlY29yZHM6ZnVuY3Rpb24oKXtyZXR1cm4gYy50YWtlUmVjb3JkcygpfX19ZnVuY3Rpb24gTGIoYSl7dmFyIGI9YSYmYS5DO2ImJihiLlYuZGVsZXRlKGEuRWEpLGIuVi5zaXplfHwoYS5IYS5fX3NoYWR5Lk49bnVsbCkpfVxuZnVuY3Rpb24gTWIoYSxiKXt2YXIgYz1iLmdldFJvb3ROb2RlKCk7cmV0dXJuIGEubWFwKGZ1bmN0aW9uKGEpe3ZhciBiPWM9PT1hLnRhcmdldC5nZXRSb290Tm9kZSgpO2lmKGImJmEuYWRkZWROb2Rlcyl7aWYoYj1BcnJheS5mcm9tKGEuYWRkZWROb2RlcykuZmlsdGVyKGZ1bmN0aW9uKGEpe3JldHVybiBjPT09YS5nZXRSb290Tm9kZSgpfSksYi5sZW5ndGgpcmV0dXJuIGE9T2JqZWN0LmNyZWF0ZShhKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImFkZGVkTm9kZXNcIix7dmFsdWU6Yixjb25maWd1cmFibGU6ITB9KSxhfWVsc2UgaWYoYilyZXR1cm4gYX0pLmZpbHRlcihmdW5jdGlvbihhKXtyZXR1cm4gYX0pfTt2YXIgQT17fSxOYj1FbGVtZW50LnByb3RvdHlwZS5pbnNlcnRCZWZvcmUsT2I9RWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2hpbGQsUGI9RWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLFFiPUVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSxSYj1FbGVtZW50LnByb3RvdHlwZS5jbG9uZU5vZGUsU2I9RG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGUsVGI9RWxlbWVudC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcixVYj1FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyLFZiPVdpbmRvdy5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcixXYj1XaW5kb3cucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIsWGI9RWxlbWVudC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCxZYj1FbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yLFpiPUVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwsJGI9Tm9kZS5wcm90b3R5cGUuY29udGFpbnN8fFxuSFRNTEVsZW1lbnQucHJvdG90eXBlLmNvbnRhaW5zO0EuYXBwZW5kQ2hpbGQ9RWxlbWVudC5wcm90b3R5cGUuYXBwZW5kQ2hpbGQ7QS5pbnNlcnRCZWZvcmU9TmI7QS5yZW1vdmVDaGlsZD1PYjtBLnNldEF0dHJpYnV0ZT1QYjtBLnJlbW92ZUF0dHJpYnV0ZT1RYjtBLmNsb25lTm9kZT1SYjtBLmltcG9ydE5vZGU9U2I7QS5hZGRFdmVudExpc3RlbmVyPVRiO0EucmVtb3ZlRXZlbnRMaXN0ZW5lcj1VYjtBLmFiPVZiO0EuYmI9V2I7QS5kaXNwYXRjaEV2ZW50PVhiO0EucXVlcnlTZWxlY3Rvcj1ZYjtBLnF1ZXJ5U2VsZWN0b3JBbGw9WmI7QS5jb250YWlucz0kYjt2YXIgYWM9L1smXFx1MDBBMFwiXS9nLGJjPS9bJlxcdTAwQTA8Pl0vZztmdW5jdGlvbiBjYyhhKXtzd2l0Y2goYSl7Y2FzZSBcIiZcIjpyZXR1cm5cIiZhbXA7XCI7Y2FzZSBcIjxcIjpyZXR1cm5cIiZsdDtcIjtjYXNlIFwiPlwiOnJldHVyblwiJmd0O1wiO2Nhc2UgJ1wiJzpyZXR1cm5cIiZxdW90O1wiO2Nhc2UgXCJcXHUwMGEwXCI6cmV0dXJuXCImbmJzcDtcIn19ZnVuY3Rpb24gZGMoYSl7Zm9yKHZhciBiPXt9LGM9MDtjPGEubGVuZ3RoO2MrKyliW2FbY11dPSEwO3JldHVybiBifXZhciBlYz1kYyhcImFyZWEgYmFzZSBiciBjb2wgY29tbWFuZCBlbWJlZCBociBpbWcgaW5wdXQga2V5Z2VuIGxpbmsgbWV0YSBwYXJhbSBzb3VyY2UgdHJhY2sgd2JyXCIuc3BsaXQoXCIgXCIpKSxmYz1kYyhcInN0eWxlIHNjcmlwdCB4bXAgaWZyYW1lIG5vZW1iZWQgbm9mcmFtZXMgcGxhaW50ZXh0IG5vc2NyaXB0XCIuc3BsaXQoXCIgXCIpKTtcbmZ1bmN0aW9uIGdjKGEsYil7XCJ0ZW1wbGF0ZVwiPT09YS5sb2NhbE5hbWUmJihhPWEuY29udGVudCk7Zm9yKHZhciBjPVwiXCIsZD1iP2IoYSk6YS5jaGlsZE5vZGVzLGU9MCxmPWQubGVuZ3RoLGg7ZTxmJiYoaD1kW2VdKTtlKyspe2E6e3ZhciBnPWg7dmFyIGs9YTt2YXIgbD1iO3N3aXRjaChnLm5vZGVUeXBlKXtjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOmZvcih2YXIgbT1nLmxvY2FsTmFtZSxuPVwiPFwiK20sdz1nLmF0dHJpYnV0ZXMsST0wO2s9d1tJXTtJKyspbis9XCIgXCIray5uYW1lKyc9XCInK2sudmFsdWUucmVwbGFjZShhYyxjYykrJ1wiJztuKz1cIj5cIjtnPWVjW21dP246bitnYyhnLGwpK1wiPC9cIittK1wiPlwiO2JyZWFrIGE7Y2FzZSBOb2RlLlRFWFRfTk9ERTpnPWcuZGF0YTtnPWsmJmZjW2subG9jYWxOYW1lXT9nOmcucmVwbGFjZShiYyxjYyk7YnJlYWsgYTtjYXNlIE5vZGUuQ09NTUVOVF9OT0RFOmc9XCJcXHgzYyEtLVwiK2cuZGF0YStcIi0tXFx4M2VcIjticmVhayBhO2RlZmF1bHQ6dGhyb3cgd2luZG93LmNvbnNvbGUuZXJyb3IoZyksXG5FcnJvcihcIm5vdCBpbXBsZW1lbnRlZFwiKTt9fWMrPWd9cmV0dXJuIGN9O3ZhciBCPXt9LEM9ZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihkb2N1bWVudCxOb2RlRmlsdGVyLlNIT1dfQUxMLG51bGwsITEpLEQ9ZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihkb2N1bWVudCxOb2RlRmlsdGVyLlNIT1dfRUxFTUVOVCxudWxsLCExKTtmdW5jdGlvbiBoYyhhKXt2YXIgYj1bXTtDLmN1cnJlbnROb2RlPWE7Zm9yKGE9Qy5maXJzdENoaWxkKCk7YTspYi5wdXNoKGEpLGE9Qy5uZXh0U2libGluZygpO3JldHVybiBifUIucGFyZW50Tm9kZT1mdW5jdGlvbihhKXtDLmN1cnJlbnROb2RlPWE7cmV0dXJuIEMucGFyZW50Tm9kZSgpfTtCLmZpcnN0Q2hpbGQ9ZnVuY3Rpb24oYSl7Qy5jdXJyZW50Tm9kZT1hO3JldHVybiBDLmZpcnN0Q2hpbGQoKX07Qi5sYXN0Q2hpbGQ9ZnVuY3Rpb24oYSl7Qy5jdXJyZW50Tm9kZT1hO3JldHVybiBDLmxhc3RDaGlsZCgpfTtCLnByZXZpb3VzU2libGluZz1mdW5jdGlvbihhKXtDLmN1cnJlbnROb2RlPWE7cmV0dXJuIEMucHJldmlvdXNTaWJsaW5nKCl9O1xuQi5uZXh0U2libGluZz1mdW5jdGlvbihhKXtDLmN1cnJlbnROb2RlPWE7cmV0dXJuIEMubmV4dFNpYmxpbmcoKX07Qi5jaGlsZE5vZGVzPWhjO0IucGFyZW50RWxlbWVudD1mdW5jdGlvbihhKXtELmN1cnJlbnROb2RlPWE7cmV0dXJuIEQucGFyZW50Tm9kZSgpfTtCLmZpcnN0RWxlbWVudENoaWxkPWZ1bmN0aW9uKGEpe0QuY3VycmVudE5vZGU9YTtyZXR1cm4gRC5maXJzdENoaWxkKCl9O0IubGFzdEVsZW1lbnRDaGlsZD1mdW5jdGlvbihhKXtELmN1cnJlbnROb2RlPWE7cmV0dXJuIEQubGFzdENoaWxkKCl9O0IucHJldmlvdXNFbGVtZW50U2libGluZz1mdW5jdGlvbihhKXtELmN1cnJlbnROb2RlPWE7cmV0dXJuIEQucHJldmlvdXNTaWJsaW5nKCl9O0IubmV4dEVsZW1lbnRTaWJsaW5nPWZ1bmN0aW9uKGEpe0QuY3VycmVudE5vZGU9YTtyZXR1cm4gRC5uZXh0U2libGluZygpfTtcbkIuY2hpbGRyZW49ZnVuY3Rpb24oYSl7dmFyIGI9W107RC5jdXJyZW50Tm9kZT1hO2ZvcihhPUQuZmlyc3RDaGlsZCgpO2E7KWIucHVzaChhKSxhPUQubmV4dFNpYmxpbmcoKTtyZXR1cm4gYn07Qi5pbm5lckhUTUw9ZnVuY3Rpb24oYSl7cmV0dXJuIGdjKGEsZnVuY3Rpb24oYSl7cmV0dXJuIGhjKGEpfSl9O0IudGV4dENvbnRlbnQ9ZnVuY3Rpb24oYSl7c3dpdGNoKGEubm9kZVR5cGUpe2Nhc2UgTm9kZS5FTEVNRU5UX05PREU6Y2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6YT1kb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGEsTm9kZUZpbHRlci5TSE9XX1RFWFQsbnVsbCwhMSk7Zm9yKHZhciBiPVwiXCIsYztjPWEubmV4dE5vZGUoKTspYis9Yy5ub2RlVmFsdWU7cmV0dXJuIGI7ZGVmYXVsdDpyZXR1cm4gYS5ub2RlVmFsdWV9fTt2YXIgaWM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFbGVtZW50LnByb3RvdHlwZSxcImlubmVySFRNTFwiKXx8T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsXCJpbm5lckhUTUxcIiksamM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KFwiaW5lcnRcIiksa2M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihEb2N1bWVudC5wcm90b3R5cGUsXCJhY3RpdmVFbGVtZW50XCIpLGxjPXtwYXJlbnRFbGVtZW50OntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5wYXJlbnROb2RlO2EmJmEubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERSYmKGE9bnVsbCk7cmV0dXJuIHZvaWQgMCE9PWE/YTpCLnBhcmVudEVsZW1lbnQodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH0scGFyZW50Tm9kZTp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkucGFyZW50Tm9kZTtcbnJldHVybiB2b2lkIDAhPT1hP2E6Qi5wYXJlbnROb2RlKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LG5leHRTaWJsaW5nOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5uZXh0U2libGluZztyZXR1cm4gdm9pZCAwIT09YT9hOkIubmV4dFNpYmxpbmcodGhpcyl9LGNvbmZpZ3VyYWJsZTohMH0scHJldmlvdXNTaWJsaW5nOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLl9fc2hhZHkmJnRoaXMuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc7cmV0dXJuIHZvaWQgMCE9PWE/YTpCLnByZXZpb3VzU2libGluZyh0aGlzKX0sY29uZmlndXJhYmxlOiEwfSxjbGFzc05hbWU6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpfHxcIlwifSxzZXQ6ZnVuY3Rpb24oYSl7dGhpcy5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLGEpfSxjb25maWd1cmFibGU6ITB9LG5leHRFbGVtZW50U2libGluZzp7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5fX3NoYWR5JiZcbnZvaWQgMCE9PXRoaXMuX19zaGFkeS5uZXh0U2libGluZyl7Zm9yKHZhciBhPXRoaXMubmV4dFNpYmxpbmc7YSYmYS5ub2RlVHlwZSE9PU5vZGUuRUxFTUVOVF9OT0RFOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9cmV0dXJuIEIubmV4dEVsZW1lbnRTaWJsaW5nKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LHByZXZpb3VzRWxlbWVudFNpYmxpbmc6e2dldDpmdW5jdGlvbigpe2lmKHRoaXMuX19zaGFkeSYmdm9pZCAwIT09dGhpcy5fX3NoYWR5LnByZXZpb3VzU2libGluZyl7Zm9yKHZhciBhPXRoaXMucHJldmlvdXNTaWJsaW5nO2EmJmEubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERTspYT1hLnByZXZpb3VzU2libGluZztyZXR1cm4gYX1yZXR1cm4gQi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKHRoaXMpfSxjb25maWd1cmFibGU6ITB9fSxtYz17Y2hpbGROb2Rlczp7Z2V0OmZ1bmN0aW9uKCl7aWYocWIodGhpcykpe2lmKCF0aGlzLl9fc2hhZHkuY2hpbGROb2Rlcyl7dGhpcy5fX3NoYWR5LmNoaWxkTm9kZXM9XG5bXTtmb3IodmFyIGE9dGhpcy5maXJzdENoaWxkO2E7YT1hLm5leHRTaWJsaW5nKXRoaXMuX19zaGFkeS5jaGlsZE5vZGVzLnB1c2goYSl9dmFyIGI9dGhpcy5fX3NoYWR5LmNoaWxkTm9kZXN9ZWxzZSBiPUIuY2hpbGROb2Rlcyh0aGlzKTtiLml0ZW09ZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19O3JldHVybiBifSxjb25maWd1cmFibGU6ITB9LGNoaWxkRWxlbWVudENvdW50OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGh9LGNvbmZpZ3VyYWJsZTohMH0sZmlyc3RDaGlsZDp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkuZmlyc3RDaGlsZDtyZXR1cm4gdm9pZCAwIT09YT9hOkIuZmlyc3RDaGlsZCh0aGlzKX0sY29uZmlndXJhYmxlOiEwfSxsYXN0Q2hpbGQ6e2dldDpmdW5jdGlvbigpe3ZhciBhPXRoaXMuX19zaGFkeSYmdGhpcy5fX3NoYWR5Lmxhc3RDaGlsZDtyZXR1cm4gdm9pZCAwIT09YT9hOkIubGFzdENoaWxkKHRoaXMpfSxcbmNvbmZpZ3VyYWJsZTohMH0sdGV4dENvbnRlbnQ6e2dldDpmdW5jdGlvbigpe2lmKHFiKHRoaXMpKXtmb3IodmFyIGE9W10sYj0wLGM9dGhpcy5jaGlsZE5vZGVzLGQ7ZD1jW2JdO2IrKylkLm5vZGVUeXBlIT09Tm9kZS5DT01NRU5UX05PREUmJmEucHVzaChkLnRleHRDb250ZW50KTtyZXR1cm4gYS5qb2luKFwiXCIpfXJldHVybiBCLnRleHRDb250ZW50KHRoaXMpfSxzZXQ6ZnVuY3Rpb24oYSl7c3dpdGNoKHRoaXMubm9kZVR5cGUpe2Nhc2UgTm9kZS5FTEVNRU5UX05PREU6Y2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6Zm9yKDt0aGlzLmZpcnN0Q2hpbGQ7KXRoaXMucmVtb3ZlQ2hpbGQodGhpcy5maXJzdENoaWxkKTsoMDxhLmxlbmd0aHx8dGhpcy5ub2RlVHlwZT09PU5vZGUuRUxFTUVOVF9OT0RFKSYmdGhpcy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShhKSk7YnJlYWs7ZGVmYXVsdDp0aGlzLm5vZGVWYWx1ZT1hfX0sY29uZmlndXJhYmxlOiEwfSxmaXJzdEVsZW1lbnRDaGlsZDp7Z2V0OmZ1bmN0aW9uKCl7aWYodGhpcy5fX3NoYWR5JiZcbnZvaWQgMCE9PXRoaXMuX19zaGFkeS5maXJzdENoaWxkKXtmb3IodmFyIGE9dGhpcy5maXJzdENoaWxkO2EmJmEubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERTspYT1hLm5leHRTaWJsaW5nO3JldHVybiBhfXJldHVybiBCLmZpcnN0RWxlbWVudENoaWxkKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LGxhc3RFbGVtZW50Q2hpbGQ6e2dldDpmdW5jdGlvbigpe2lmKHRoaXMuX19zaGFkeSYmdm9pZCAwIT09dGhpcy5fX3NoYWR5Lmxhc3RDaGlsZCl7Zm9yKHZhciBhPXRoaXMubGFzdENoaWxkO2EmJmEubm9kZVR5cGUhPT1Ob2RlLkVMRU1FTlRfTk9ERTspYT1hLnByZXZpb3VzU2libGluZztyZXR1cm4gYX1yZXR1cm4gQi5sYXN0RWxlbWVudENoaWxkKHRoaXMpfSxjb25maWd1cmFibGU6ITB9LGNoaWxkcmVuOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYTtxYih0aGlzKT9hPUFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbCh0aGlzLmNoaWxkTm9kZXMsZnVuY3Rpb24oYSl7cmV0dXJuIGEubm9kZVR5cGU9PT1cbk5vZGUuRUxFTUVOVF9OT0RFfSk6YT1CLmNoaWxkcmVuKHRoaXMpO2EuaXRlbT1mdW5jdGlvbihiKXtyZXR1cm4gYVtiXX07cmV0dXJuIGF9LGNvbmZpZ3VyYWJsZTohMH0saW5uZXJIVE1MOntnZXQ6ZnVuY3Rpb24oKXt2YXIgYT1cInRlbXBsYXRlXCI9PT10aGlzLmxvY2FsTmFtZT90aGlzLmNvbnRlbnQ6dGhpcztyZXR1cm4gcWIodGhpcyk/Z2MoYSk6Qi5pbm5lckhUTUwoYSl9LHNldDpmdW5jdGlvbihhKXtmb3IodmFyIGI9XCJ0ZW1wbGF0ZVwiPT09dGhpcy5sb2NhbE5hbWU/dGhpcy5jb250ZW50OnRoaXM7Yi5maXJzdENoaWxkOyliLnJlbW92ZUNoaWxkKGIuZmlyc3RDaGlsZCk7dmFyIGM9dGhpcy5sb2NhbE5hbWU7YyYmXCJ0ZW1wbGF0ZVwiIT09Y3x8KGM9XCJkaXZcIik7Yz1qYy5jcmVhdGVFbGVtZW50KGMpO2ZvcihpYyYmaWMuc2V0P2ljLnNldC5jYWxsKGMsYSk6Yy5pbm5lckhUTUw9YTtjLmZpcnN0Q2hpbGQ7KWIuYXBwZW5kQ2hpbGQoYy5maXJzdENoaWxkKX0sY29uZmlndXJhYmxlOiEwfX0sXG5xYz17c2hhZG93Um9vdDp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX19zaGFkeSYmdGhpcy5fX3NoYWR5LlVhfHxudWxsfSxjb25maWd1cmFibGU6ITB9fSxyYz17YWN0aXZlRWxlbWVudDp7Z2V0OmZ1bmN0aW9uKCl7dmFyIGE9a2MmJmtjLmdldD9rYy5nZXQuY2FsbChkb2N1bWVudCk6eS5NP3ZvaWQgMDpkb2N1bWVudC5hY3RpdmVFbGVtZW50O2lmKGEmJmEubm9kZVR5cGUpe3ZhciBiPSEheih0aGlzKTtpZih0aGlzPT09ZG9jdW1lbnR8fGImJnRoaXMuaG9zdCE9PWEmJkEuY29udGFpbnMuY2FsbCh0aGlzLmhvc3QsYSkpe2ZvcihiPXJiKGEpO2ImJmIhPT10aGlzOylhPWIuaG9zdCxiPXJiKGEpO2E9dGhpcz09PWRvY3VtZW50P2I/bnVsbDphOmI9PT10aGlzP2E6bnVsbH1lbHNlIGE9bnVsbH1lbHNlIGE9bnVsbDtyZXR1cm4gYX0sc2V0OmZ1bmN0aW9uKCl7fSxjb25maWd1cmFibGU6ITB9fTtcbmZ1bmN0aW9uIEUoYSxiLGMpe2Zvcih2YXIgZCBpbiBiKXt2YXIgZT1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGEsZCk7ZSYmZS5jb25maWd1cmFibGV8fCFlJiZjP09iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGQsYltkXSk6YyYmY29uc29sZS53YXJuKFwiQ291bGQgbm90IGRlZmluZVwiLGQsXCJvblwiLGEpfX1mdW5jdGlvbiBGKGEpe0UoYSxsYyk7RShhLG1jKTtFKGEscmMpfXZhciBzYz15Lk0/ZnVuY3Rpb24oKXt9OmZ1bmN0aW9uKGEpe2EuX19zaGFkeSYmYS5fX3NoYWR5LkJhfHwoYS5fX3NoYWR5PWEuX19zaGFkeXx8e30sYS5fX3NoYWR5LkJhPSEwLEUoYSxsYywhMCkpfSx0Yz15Lk0/ZnVuY3Rpb24oKXt9OmZ1bmN0aW9uKGEpe2EuX19zaGFkeSYmYS5fX3NoYWR5LnphfHwoYS5fX3NoYWR5PWEuX19zaGFkeXx8e30sYS5fX3NoYWR5LnphPSEwLEUoYSxtYywhMCksRShhLHFjLCEwKSl9O2Z1bmN0aW9uIHVjKGEsYixjKXtzYyhhKTtjPWN8fG51bGw7YS5fX3NoYWR5PWEuX19zaGFkeXx8e307Yi5fX3NoYWR5PWIuX19zaGFkeXx8e307YyYmKGMuX19zaGFkeT1jLl9fc2hhZHl8fHt9KTthLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nPWM/Yy5fX3NoYWR5LnByZXZpb3VzU2libGluZzpiLmxhc3RDaGlsZDt2YXIgZD1hLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nO2QmJmQuX19zaGFkeSYmKGQuX19zaGFkeS5uZXh0U2libGluZz1hKTsoZD1hLl9fc2hhZHkubmV4dFNpYmxpbmc9YykmJmQuX19zaGFkeSYmKGQuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc9YSk7YS5fX3NoYWR5LnBhcmVudE5vZGU9YjtjP2M9PT1iLl9fc2hhZHkuZmlyc3RDaGlsZCYmKGIuX19zaGFkeS5maXJzdENoaWxkPWEpOihiLl9fc2hhZHkubGFzdENoaWxkPWEsYi5fX3NoYWR5LmZpcnN0Q2hpbGR8fChiLl9fc2hhZHkuZmlyc3RDaGlsZD1hKSk7Yi5fX3NoYWR5LmNoaWxkTm9kZXM9bnVsbH1cbmZ1bmN0aW9uIHZjKGEpe2lmKCFhLl9fc2hhZHl8fHZvaWQgMD09PWEuX19zaGFkeS5maXJzdENoaWxkKXthLl9fc2hhZHk9YS5fX3NoYWR5fHx7fTthLl9fc2hhZHkuZmlyc3RDaGlsZD1CLmZpcnN0Q2hpbGQoYSk7YS5fX3NoYWR5Lmxhc3RDaGlsZD1CLmxhc3RDaGlsZChhKTt0YyhhKTtmb3IodmFyIGI9YS5fX3NoYWR5LmNoaWxkTm9kZXM9Qi5jaGlsZE5vZGVzKGEpLGM9MCxkO2M8Yi5sZW5ndGgmJihkPWJbY10pO2MrKylkLl9fc2hhZHk9ZC5fX3NoYWR5fHx7fSxkLl9fc2hhZHkucGFyZW50Tm9kZT1hLGQuX19zaGFkeS5uZXh0U2libGluZz1iW2MrMV18fG51bGwsZC5fX3NoYWR5LnByZXZpb3VzU2libGluZz1iW2MtMV18fG51bGwsc2MoZCl9fTtmdW5jdGlvbiB3YyhhLGIsYyl7aWYoYj09PWEpdGhyb3cgRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnYXBwZW5kQ2hpbGQnIG9uICdOb2RlJzogVGhlIG5ldyBjaGlsZCBlbGVtZW50IGNvbnRhaW5zIHRoZSBwYXJlbnQuXCIpO2lmKGMpe3ZhciBkPWMuX19zaGFkeSYmYy5fX3NoYWR5LnBhcmVudE5vZGU7aWYodm9pZCAwIT09ZCYmZCE9PWF8fHZvaWQgMD09PWQmJkIucGFyZW50Tm9kZShjKSE9PWEpdGhyb3cgRXJyb3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAnaW5zZXJ0QmVmb3JlJyBvbiAnTm9kZSc6IFRoZSBub2RlIGJlZm9yZSB3aGljaCB0aGUgbmV3IG5vZGUgaXMgdG8gYmUgaW5zZXJ0ZWQgaXMgbm90IGEgY2hpbGQgb2YgdGhpcyBub2RlLlwiKTt9aWYoYz09PWIpcmV0dXJuIGI7Yi5wYXJlbnROb2RlJiZ4YyhiLnBhcmVudE5vZGUsYik7ZD1yYihhKTt2YXIgZTtpZihlPWQpYTp7aWYoIWIuX19ub0luc2VydGlvblBvaW50KXt2YXIgZjtcInNsb3RcIj09PWIubG9jYWxOYW1lP2Y9W2JdOlxuYi5xdWVyeVNlbGVjdG9yQWxsJiYoZj1iLnF1ZXJ5U2VsZWN0b3JBbGwoXCJzbG90XCIpKTtpZihmJiZmLmxlbmd0aCl7ZT1mO2JyZWFrIGF9fWU9dm9pZCAwfShmPWUpJiZkLkgucHVzaC5hcHBseShkLkgsW10uY29uY2F0KGYgaW5zdGFuY2VvZiBBcnJheT9mOmphKGlhKGYpKSkpO2QmJihcInNsb3RcIj09PWEubG9jYWxOYW1lfHxmKSYmeWMoZCk7aWYocWIoYSkpe2Q9Yzt0YyhhKTthLl9fc2hhZHk9YS5fX3NoYWR5fHx7fTt2b2lkIDAhPT1hLl9fc2hhZHkuZmlyc3RDaGlsZCYmKGEuX19zaGFkeS5jaGlsZE5vZGVzPW51bGwpO2lmKGIubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpe2Y9Yi5jaGlsZE5vZGVzO2ZvcihlPTA7ZTxmLmxlbmd0aDtlKyspdWMoZltlXSxhLGQpO2IuX19zaGFkeT1iLl9fc2hhZHl8fHt9O2Q9dm9pZCAwIT09Yi5fX3NoYWR5LmZpcnN0Q2hpbGQ/bnVsbDp2b2lkIDA7Yi5fX3NoYWR5LmZpcnN0Q2hpbGQ9Yi5fX3NoYWR5Lmxhc3RDaGlsZD1cbmQ7Yi5fX3NoYWR5LmNoaWxkTm9kZXM9ZH1lbHNlIHVjKGIsYSxkKTtpZih6YyhhKSl7eWMoYS5fX3NoYWR5LnJvb3QpO3ZhciBoPSEwfWVsc2UgYS5fX3NoYWR5LnJvb3QmJihoPSEwKX1ofHwoaD16KGEpP2EuaG9zdDphLGM/KGM9QWMoYyksQS5pbnNlcnRCZWZvcmUuY2FsbChoLGIsYykpOkEuYXBwZW5kQ2hpbGQuY2FsbChoLGIpKTtCYyhhLGIpO3JldHVybiBifVxuZnVuY3Rpb24geGMoYSxiKXtpZihiLnBhcmVudE5vZGUhPT1hKXRocm93IEVycm9yKFwiVGhlIG5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIG5vZGU6IFwiK2IpO3ZhciBjPXJiKGIpO2lmKHFiKGEpKXtiLl9fc2hhZHk9Yi5fX3NoYWR5fHx7fTthLl9fc2hhZHk9YS5fX3NoYWR5fHx7fTtiPT09YS5fX3NoYWR5LmZpcnN0Q2hpbGQmJihhLl9fc2hhZHkuZmlyc3RDaGlsZD1iLl9fc2hhZHkubmV4dFNpYmxpbmcpO2I9PT1hLl9fc2hhZHkubGFzdENoaWxkJiYoYS5fX3NoYWR5Lmxhc3RDaGlsZD1iLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nKTt2YXIgZD1iLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nLGU9Yi5fX3NoYWR5Lm5leHRTaWJsaW5nO2QmJihkLl9fc2hhZHk9ZC5fX3NoYWR5fHx7fSxkLl9fc2hhZHkubmV4dFNpYmxpbmc9ZSk7ZSYmKGUuX19zaGFkeT1lLl9fc2hhZHl8fHt9LGUuX19zaGFkeS5wcmV2aW91c1NpYmxpbmc9ZCk7Yi5fX3NoYWR5LnBhcmVudE5vZGU9XG5iLl9fc2hhZHkucHJldmlvdXNTaWJsaW5nPWIuX19zaGFkeS5uZXh0U2libGluZz12b2lkIDA7dm9pZCAwIT09YS5fX3NoYWR5LmNoaWxkTm9kZXMmJihhLl9fc2hhZHkuY2hpbGROb2Rlcz1udWxsKTtpZih6YyhhKSl7eWMoYS5fX3NoYWR5LnJvb3QpO3ZhciBmPSEwfX1DYyhiKTtpZihjKXsoZD1hJiZcInNsb3RcIj09PWEubG9jYWxOYW1lKSYmKGY9ITApO0RjKGMpO2U9Yy5sO2Zvcih2YXIgaCBpbiBlKWZvcih2YXIgZz1lW2hdLGs9MDtrPGcubGVuZ3RoO2srKyl7dmFyIGw9Z1trXTtpZihDYihiLGwpKXtnLnNwbGljZShrLDEpO3ZhciBtPWMucy5pbmRleE9mKGwpOzA8PW0mJmMucy5zcGxpY2UobSwxKTtrLS07aWYobT1sLl9fc2hhZHkuSylmb3IobD0wO2w8bS5sZW5ndGg7bCsrKXt2YXIgbj1tW2xdLHc9Qi5wYXJlbnROb2RlKG4pO3cmJkEucmVtb3ZlQ2hpbGQuY2FsbCh3LG4pfW09ITB9fShtfHxkKSYmeWMoYyl9Znx8KGY9eihhKT9hLmhvc3Q6YSwoIWEuX19zaGFkeS5yb290JiZcblwic2xvdFwiIT09Yi5sb2NhbE5hbWV8fGY9PT1CLnBhcmVudE5vZGUoYikpJiZBLnJlbW92ZUNoaWxkLmNhbGwoZixiKSk7QmMoYSxudWxsLGIpO3JldHVybiBifWZ1bmN0aW9uIENjKGEpe2lmKGEuX19zaGFkeSYmdm9pZCAwIT09YS5fX3NoYWR5LmthKWZvcih2YXIgYj1hLmNoaWxkTm9kZXMsYz0wLGQ9Yi5sZW5ndGgsZTtjPGQmJihlPWJbY10pO2MrKylDYyhlKTthLl9fc2hhZHkmJihhLl9fc2hhZHkua2E9dm9pZCAwKX1mdW5jdGlvbiBBYyhhKXt2YXIgYj1hO2EmJlwic2xvdFwiPT09YS5sb2NhbE5hbWUmJihiPShiPWEuX19zaGFkeSYmYS5fX3NoYWR5LkspJiZiLmxlbmd0aD9iWzBdOkFjKGEubmV4dFNpYmxpbmcpKTtyZXR1cm4gYn1mdW5jdGlvbiB6YyhhKXtyZXR1cm4oYT1hJiZhLl9fc2hhZHkmJmEuX19zaGFkeS5yb290KSYmRWMoYSl9XG5mdW5jdGlvbiBGYyhhLGIpe2lmKFwic2xvdFwiPT09YilhPWEucGFyZW50Tm9kZSx6YyhhKSYmeWMoYS5fX3NoYWR5LnJvb3QpO2Vsc2UgaWYoXCJzbG90XCI9PT1hLmxvY2FsTmFtZSYmXCJuYW1lXCI9PT1iJiYoYj1yYihhKSkpe3ZhciBjPWEuQ2EsZD1HYyhhKTtpZihkIT09Yyl7Yz1iLmxbY107dmFyIGU9Yy5pbmRleE9mKGEpOzA8PWUmJmMuc3BsaWNlKGUsMSk7Yz1iLmxbZF18fChiLmxbZF09W10pO2MucHVzaChhKTsxPGMubGVuZ3RoJiYoYi5sW2RdPUhjKGMpKX15YyhiKX19ZnVuY3Rpb24gQmMoYSxiLGMpe2lmKGE9YS5fX3NoYWR5JiZhLl9fc2hhZHkuTiliJiZhLmFkZGVkTm9kZXMucHVzaChiKSxjJiZhLnJlbW92ZWROb2Rlcy5wdXNoKGMpLEliKGEpfVxuZnVuY3Rpb24gSWMoYSl7aWYoYSYmYS5ub2RlVHlwZSl7YS5fX3NoYWR5PWEuX19zaGFkeXx8e307dmFyIGI9YS5fX3NoYWR5LmthO3ZvaWQgMD09PWImJih6KGEpP2I9YTpiPShiPWEucGFyZW50Tm9kZSk/SWMoYik6YSxBLmNvbnRhaW5zLmNhbGwoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGEpJiYoYS5fX3NoYWR5LmthPWIpKTtyZXR1cm4gYn19ZnVuY3Rpb24gSmMoYSxiLGMpe3ZhciBkPVtdO0tjKGEuY2hpbGROb2RlcyxiLGMsZCk7cmV0dXJuIGR9ZnVuY3Rpb24gS2MoYSxiLGMsZCl7Zm9yKHZhciBlPTAsZj1hLmxlbmd0aCxoO2U8ZiYmKGg9YVtlXSk7ZSsrKXt2YXIgZztpZihnPWgubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSl7Zz1oO3ZhciBrPWIsbD1jLG09ZCxuPWsoZyk7biYmbS5wdXNoKGcpO2wmJmwobik/Zz1uOihLYyhnLmNoaWxkTm9kZXMsayxsLG0pLGc9dm9pZCAwKX1pZihnKWJyZWFrfX12YXIgTGM9bnVsbDtcbmZ1bmN0aW9uIE1jKGEsYixjKXtMY3x8KExjPXdpbmRvdy5TaGFkeUNTUyYmd2luZG93LlNoYWR5Q1NTLlNjb3BpbmdTaGltKTtMYyYmXCJjbGFzc1wiPT09Yj9MYy5zZXRFbGVtZW50Q2xhc3MoYSxjKTooQS5zZXRBdHRyaWJ1dGUuY2FsbChhLGIsYyksRmMoYSxiKSl9ZnVuY3Rpb24gTmMoYSxiKXtpZihhLm93bmVyRG9jdW1lbnQhPT1kb2N1bWVudClyZXR1cm4gQS5pbXBvcnROb2RlLmNhbGwoZG9jdW1lbnQsYSxiKTt2YXIgYz1BLmltcG9ydE5vZGUuY2FsbChkb2N1bWVudCxhLCExKTtpZihiKXthPWEuY2hpbGROb2RlcztiPTA7Zm9yKHZhciBkO2I8YS5sZW5ndGg7YisrKWQ9TmMoYVtiXSwhMCksYy5hcHBlbmRDaGlsZChkKX1yZXR1cm4gY307dmFyIE9jPVwiX19ldmVudFdyYXBwZXJzXCIrRGF0ZS5ub3coKSxQYz17Ymx1cjohMCxmb2N1czohMCxmb2N1c2luOiEwLGZvY3Vzb3V0OiEwLGNsaWNrOiEwLGRibGNsaWNrOiEwLG1vdXNlZG93bjohMCxtb3VzZWVudGVyOiEwLG1vdXNlbGVhdmU6ITAsbW91c2Vtb3ZlOiEwLG1vdXNlb3V0OiEwLG1vdXNlb3ZlcjohMCxtb3VzZXVwOiEwLHdoZWVsOiEwLGJlZm9yZWlucHV0OiEwLGlucHV0OiEwLGtleWRvd246ITAsa2V5dXA6ITAsY29tcG9zaXRpb25zdGFydDohMCxjb21wb3NpdGlvbnVwZGF0ZTohMCxjb21wb3NpdGlvbmVuZDohMCx0b3VjaHN0YXJ0OiEwLHRvdWNoZW5kOiEwLHRvdWNobW92ZTohMCx0b3VjaGNhbmNlbDohMCxwb2ludGVyb3ZlcjohMCxwb2ludGVyZW50ZXI6ITAscG9pbnRlcmRvd246ITAscG9pbnRlcm1vdmU6ITAscG9pbnRlcnVwOiEwLHBvaW50ZXJjYW5jZWw6ITAscG9pbnRlcm91dDohMCxwb2ludGVybGVhdmU6ITAsZ290cG9pbnRlcmNhcHR1cmU6ITAsbG9zdHBvaW50ZXJjYXB0dXJlOiEwLFxuZHJhZ3N0YXJ0OiEwLGRyYWc6ITAsZHJhZ2VudGVyOiEwLGRyYWdsZWF2ZTohMCxkcmFnb3ZlcjohMCxkcm9wOiEwLGRyYWdlbmQ6ITAsRE9NQWN0aXZhdGU6ITAsRE9NRm9jdXNJbjohMCxET01Gb2N1c091dDohMCxrZXlwcmVzczohMH07ZnVuY3Rpb24gUWMoYSxiKXt2YXIgYz1bXSxkPWE7Zm9yKGE9YT09PXdpbmRvdz93aW5kb3c6YS5nZXRSb290Tm9kZSgpO2Q7KWMucHVzaChkKSxkPWQuYXNzaWduZWRTbG90P2QuYXNzaWduZWRTbG90OmQubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUmJmQuaG9zdCYmKGJ8fGQhPT1hKT9kLmhvc3Q6ZC5wYXJlbnROb2RlO2NbYy5sZW5ndGgtMV09PT1kb2N1bWVudCYmYy5wdXNoKHdpbmRvdyk7cmV0dXJuIGN9XG5mdW5jdGlvbiBSYyhhLGIpe2lmKCF6KXJldHVybiBhO2E9UWMoYSwhMCk7Zm9yKHZhciBjPTAsZCxlLGYsaDtjPGIubGVuZ3RoO2MrKylpZihkPWJbY10sZj1kPT09d2luZG93P3dpbmRvdzpkLmdldFJvb3ROb2RlKCksZiE9PWUmJihoPWEuaW5kZXhPZihmKSxlPWYpLCF6KGYpfHwtMTxoKXJldHVybiBkfVxudmFyIFNjPXtnZXQgY29tcG9zZWQoKXshMSE9PXRoaXMuaXNUcnVzdGVkJiZ2b2lkIDA9PT10aGlzLlomJih0aGlzLlo9UGNbdGhpcy50eXBlXSk7cmV0dXJuIHRoaXMuWnx8ITF9LGNvbXBvc2VkUGF0aDpmdW5jdGlvbigpe3RoaXMubmF8fCh0aGlzLm5hPVFjKHRoaXMuX190YXJnZXQsdGhpcy5jb21wb3NlZCkpO3JldHVybiB0aGlzLm5hfSxnZXQgdGFyZ2V0KCl7cmV0dXJuIFJjKHRoaXMuY3VycmVudFRhcmdldCx0aGlzLmNvbXBvc2VkUGF0aCgpKX0sZ2V0IHJlbGF0ZWRUYXJnZXQoKXtpZighdGhpcy5hYSlyZXR1cm4gbnVsbDt0aGlzLm9hfHwodGhpcy5vYT1RYyh0aGlzLmFhLCEwKSk7cmV0dXJuIFJjKHRoaXMuY3VycmVudFRhcmdldCx0aGlzLm9hKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7RXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO3RoaXMuJD0hMH0sc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7RXZlbnQucHJvdG90eXBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbi5jYWxsKHRoaXMpO1xudGhpcy4kPXRoaXMueWE9ITB9fTtmdW5jdGlvbiBUYyhhKXtmdW5jdGlvbiBiKGIsZCl7Yj1uZXcgYShiLGQpO2IuWj1kJiYhIWQuY29tcG9zZWQ7cmV0dXJuIGJ9d2IoYixhKTtiLnByb3RvdHlwZT1hLnByb3RvdHlwZTtyZXR1cm4gYn12YXIgVWM9e2ZvY3VzOiEwLGJsdXI6ITB9O2Z1bmN0aW9uIFZjKGEpe3JldHVybiBhLl9fdGFyZ2V0IT09YS50YXJnZXR8fGEuYWEhPT1hLnJlbGF0ZWRUYXJnZXR9ZnVuY3Rpb24gV2MoYSxiLGMpe2lmKGM9Yi5fX2hhbmRsZXJzJiZiLl9faGFuZGxlcnNbYS50eXBlXSYmYi5fX2hhbmRsZXJzW2EudHlwZV1bY10pZm9yKHZhciBkPTAsZTsoZT1jW2RdKSYmKCFWYyhhKXx8YS50YXJnZXQhPT1hLnJlbGF0ZWRUYXJnZXQpJiYoZS5jYWxsKGIsYSksIWEueWEpO2QrKyk7fVxuZnVuY3Rpb24gWGMoYSl7dmFyIGI9YS5jb21wb3NlZFBhdGgoKTtPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImN1cnJlbnRUYXJnZXRcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGR9LGNvbmZpZ3VyYWJsZTohMH0pO2Zvcih2YXIgYz1iLmxlbmd0aC0xOzA8PWM7Yy0tKXt2YXIgZD1iW2NdO1djKGEsZCxcImNhcHR1cmVcIik7aWYoYS4kKXJldHVybn1PYmplY3QuZGVmaW5lUHJvcGVydHkoYSxcImV2ZW50UGhhc2VcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIEV2ZW50LkFUX1RBUkdFVH19KTt2YXIgZTtmb3IoYz0wO2M8Yi5sZW5ndGg7YysrKXtkPWJbY107dmFyIGY9ZC5fX3NoYWR5JiZkLl9fc2hhZHkucm9vdDtpZigwPT09Y3x8ZiYmZj09PWUpaWYoV2MoYSxkLFwiYnViYmxlXCIpLGQhPT13aW5kb3cmJihlPWQuZ2V0Um9vdE5vZGUoKSksYS4kKWJyZWFrfX1cbmZ1bmN0aW9uIFljKGEsYixjLGQsZSxmKXtmb3IodmFyIGg9MDtoPGEubGVuZ3RoO2grKyl7dmFyIGc9YVtoXSxrPWcudHlwZSxsPWcuY2FwdHVyZSxtPWcub25jZSxuPWcucGFzc2l2ZTtpZihiPT09Zy5ub2RlJiZjPT09ayYmZD09PWwmJmU9PT1tJiZmPT09bilyZXR1cm4gaH1yZXR1cm4tMX1cbmZ1bmN0aW9uIFpjKGEsYixjKXtpZihiKXtpZihjJiZcIm9iamVjdFwiPT09dHlwZW9mIGMpe3ZhciBkPSEhYy5jYXB0dXJlO3ZhciBlPSEhYy5vbmNlO3ZhciBmPSEhYy5wYXNzaXZlfWVsc2UgZD0hIWMsZj1lPSExO3ZhciBoPWMmJmMuYmF8fHRoaXMsZz1iW09jXTtpZihnKXtpZigtMTxZYyhnLGgsYSxkLGUsZikpcmV0dXJufWVsc2UgYltPY109W107Zz1mdW5jdGlvbihkKXtlJiZ0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSxiLGMpO2QuX190YXJnZXR8fCRjKGQpO2lmKGghPT10aGlzKXt2YXIgZj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGQsXCJjdXJyZW50VGFyZ2V0XCIpO09iamVjdC5kZWZpbmVQcm9wZXJ0eShkLFwiY3VycmVudFRhcmdldFwiLHtnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gaH0sY29uZmlndXJhYmxlOiEwfSl9aWYoZC5jb21wb3NlZHx8LTE8ZC5jb21wb3NlZFBhdGgoKS5pbmRleE9mKGgpKWlmKFZjKGQpJiZkLnRhcmdldD09PWQucmVsYXRlZFRhcmdldClkLmV2ZW50UGhhc2U9PT1cbkV2ZW50LkJVQkJMSU5HX1BIQVNFJiZkLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO2Vsc2UgaWYoZC5ldmVudFBoYXNlPT09RXZlbnQuQ0FQVFVSSU5HX1BIQVNFfHxkLmJ1YmJsZXN8fGQudGFyZ2V0PT09aHx8aCBpbnN0YW5jZW9mIFdpbmRvdyl7dmFyIGc9XCJvYmplY3RcIj09PXR5cGVvZiBiJiZiLmhhbmRsZUV2ZW50P2IuaGFuZGxlRXZlbnQoZCk6Yi5jYWxsKGgsZCk7aCE9PXRoaXMmJihmPyhPYmplY3QuZGVmaW5lUHJvcGVydHkoZCxcImN1cnJlbnRUYXJnZXRcIixmKSxmPW51bGwpOmRlbGV0ZSBkLmN1cnJlbnRUYXJnZXQpO3JldHVybiBnfX07YltPY10ucHVzaCh7bm9kZTp0aGlzLHR5cGU6YSxjYXB0dXJlOmQsb25jZTplLHBhc3NpdmU6ZixjYjpnfSk7VWNbYV0/KHRoaXMuX19oYW5kbGVycz10aGlzLl9faGFuZGxlcnN8fHt9LHRoaXMuX19oYW5kbGVyc1thXT10aGlzLl9faGFuZGxlcnNbYV18fHtjYXB0dXJlOltdLGJ1YmJsZTpbXX0sdGhpcy5fX2hhbmRsZXJzW2FdW2Q/XG5cImNhcHR1cmVcIjpcImJ1YmJsZVwiXS5wdXNoKGcpKToodGhpcyBpbnN0YW5jZW9mIFdpbmRvdz9BLmFiOkEuYWRkRXZlbnRMaXN0ZW5lcikuY2FsbCh0aGlzLGEsZyxjKX19XG5mdW5jdGlvbiBhZChhLGIsYyl7aWYoYil7aWYoYyYmXCJvYmplY3RcIj09PXR5cGVvZiBjKXt2YXIgZD0hIWMuY2FwdHVyZTt2YXIgZT0hIWMub25jZTt2YXIgZj0hIWMucGFzc2l2ZX1lbHNlIGQ9ISFjLGY9ZT0hMTt2YXIgaD1jJiZjLmJhfHx0aGlzLGc9dm9pZCAwO3ZhciBrPW51bGw7dHJ5e2s9YltPY119Y2F0Y2gobCl7fWsmJihlPVljKGssaCxhLGQsZSxmKSwtMTxlJiYoZz1rLnNwbGljZShlLDEpWzBdLmNiLGsubGVuZ3RofHwoYltPY109dm9pZCAwKSkpOyh0aGlzIGluc3RhbmNlb2YgV2luZG93P0EuYmI6QS5yZW1vdmVFdmVudExpc3RlbmVyKS5jYWxsKHRoaXMsYSxnfHxiLGMpO2cmJlVjW2FdJiZ0aGlzLl9faGFuZGxlcnMmJnRoaXMuX19oYW5kbGVyc1thXSYmKGE9dGhpcy5fX2hhbmRsZXJzW2FdW2Q/XCJjYXB0dXJlXCI6XCJidWJibGVcIl0sZz1hLmluZGV4T2YoZyksLTE8ZyYmYS5zcGxpY2UoZywxKSl9fVxuZnVuY3Rpb24gYmQoKXtmb3IodmFyIGEgaW4gVWMpd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoYSxmdW5jdGlvbihhKXthLl9fdGFyZ2V0fHwoJGMoYSksWGMoYSkpfSwhMCl9ZnVuY3Rpb24gJGMoYSl7YS5fX3RhcmdldD1hLnRhcmdldDthLmFhPWEucmVsYXRlZFRhcmdldDtpZih5Lk0pe3ZhciBiPU9iamVjdC5nZXRQcm90b3R5cGVPZihhKTtpZighYi5oYXNPd25Qcm9wZXJ0eShcIl9fcGF0Y2hQcm90b1wiKSl7dmFyIGM9T2JqZWN0LmNyZWF0ZShiKTtjLmZiPWI7dWIoYyxTYyk7Yi5fX3BhdGNoUHJvdG89Y31hLl9fcHJvdG9fXz1iLl9fcGF0Y2hQcm90b31lbHNlIHViKGEsU2MpfXZhciBjZD1UYyh3aW5kb3cuRXZlbnQpLGRkPVRjKHdpbmRvdy5DdXN0b21FdmVudCksZWQ9VGMod2luZG93Lk1vdXNlRXZlbnQpO2Z1bmN0aW9uIGZkKGEsYil7cmV0dXJue2luZGV4OmEsTzpbXSxVOmJ9fVxuZnVuY3Rpb24gZ2QoYSxiLGMsZCl7dmFyIGU9MCxmPTAsaD0wLGc9MCxrPU1hdGgubWluKGItZSxkLWYpO2lmKDA9PWUmJjA9PWYpYTp7Zm9yKGg9MDtoPGs7aCsrKWlmKGFbaF0hPT1jW2hdKWJyZWFrIGE7aD1rfWlmKGI9PWEubGVuZ3RoJiZkPT1jLmxlbmd0aCl7Zz1hLmxlbmd0aDtmb3IodmFyIGw9Yy5sZW5ndGgsbT0wO208ay1oJiZoZChhWy0tZ10sY1stLWxdKTspbSsrO2c9bX1lKz1oO2YrPWg7Yi09ZztkLT1nO2lmKDA9PWItZSYmMD09ZC1mKXJldHVybltdO2lmKGU9PWIpe2ZvcihiPWZkKGUsMCk7ZjxkOyliLk8ucHVzaChjW2YrK10pO3JldHVybltiXX1pZihmPT1kKXJldHVybltmZChlLGItZSldO2s9ZTtoPWY7ZD1kLWgrMTtnPWItaysxO2I9QXJyYXkoZCk7Zm9yKGw9MDtsPGQ7bCsrKWJbbF09QXJyYXkoZyksYltsXVswXT1sO2ZvcihsPTA7bDxnO2wrKyliWzBdW2xdPWw7Zm9yKGw9MTtsPGQ7bCsrKWZvcihtPTE7bTxnO20rKylpZihhW2srbS0xXT09PWNbaCtsLTFdKWJbbF1bbV09XG5iW2wtMV1bbS0xXTtlbHNle3ZhciBuPWJbbC0xXVttXSsxLHc9YltsXVttLTFdKzE7YltsXVttXT1uPHc/bjp3fWs9Yi5sZW5ndGgtMTtoPWJbMF0ubGVuZ3RoLTE7ZD1iW2tdW2hdO2ZvcihhPVtdOzA8a3x8MDxoOykwPT1rPyhhLnB1c2goMiksaC0tKTowPT1oPyhhLnB1c2goMyksay0tKTooZz1iW2stMV1baC0xXSxsPWJbay0xXVtoXSxtPWJba11baC0xXSxuPWw8bT9sPGc/bDpnOm08Zz9tOmcsbj09Zz8oZz09ZD9hLnB1c2goMCk6KGEucHVzaCgxKSxkPWcpLGstLSxoLS0pOm49PWw/KGEucHVzaCgzKSxrLS0sZD1sKTooYS5wdXNoKDIpLGgtLSxkPW0pKTthLnJldmVyc2UoKTtiPXZvaWQgMDtrPVtdO2ZvcihoPTA7aDxhLmxlbmd0aDtoKyspc3dpdGNoKGFbaF0pe2Nhc2UgMDpiJiYoay5wdXNoKGIpLGI9dm9pZCAwKTtlKys7ZisrO2JyZWFrO2Nhc2UgMTpifHwoYj1mZChlLDApKTtiLlUrKztlKys7Yi5PLnB1c2goY1tmXSk7ZisrO2JyZWFrO2Nhc2UgMjpifHwoYj1mZChlLDApKTtcbmIuVSsrO2UrKzticmVhaztjYXNlIDM6Ynx8KGI9ZmQoZSwwKSksYi5PLnB1c2goY1tmXSksZisrfWImJmsucHVzaChiKTtyZXR1cm4ga31mdW5jdGlvbiBoZChhLGIpe3JldHVybiBhPT09Yn07dmFyIGlkPXt9O2Z1bmN0aW9uIEcoYSxiLGMpe2lmKGEhPT1pZCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWxsZWdhbCBjb25zdHJ1Y3RvclwiKTthPWRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTthLl9fcHJvdG9fXz1HLnByb3RvdHlwZTthLkFhPVwiU2hhZHlSb290XCI7dmMoYik7dmMoYSk7YS5ob3N0PWI7YS5hPWMmJmMubW9kZTtiLl9fc2hhZHk9Yi5fX3NoYWR5fHx7fTtiLl9fc2hhZHkucm9vdD1hO2IuX19zaGFkeS5VYT1cImNsb3NlZFwiIT09YS5hP2E6bnVsbDthLlQ9ITE7YS5zPVtdO2EubD17fTthLkg9W107Yz1CLmNoaWxkTm9kZXMoYik7Zm9yKHZhciBkPTAsZT1jLmxlbmd0aDtkPGU7ZCsrKUEucmVtb3ZlQ2hpbGQuY2FsbChiLGNbZF0pO3JldHVybiBhfUcucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUpO2Z1bmN0aW9uIHljKGEpe2EuVHx8KGEuVD0hMCxGYihmdW5jdGlvbigpe3JldHVybiBqZChhKX0pKX1cbmZ1bmN0aW9uIGpkKGEpe2Zvcih2YXIgYjthOyl7YS5UJiYoYj1hKTthOnt2YXIgYz1hO2E9Yy5ob3N0LmdldFJvb3ROb2RlKCk7aWYoeihhKSlmb3IodmFyIGQ9Yy5ob3N0LmNoaWxkTm9kZXMsZT0wO2U8ZC5sZW5ndGg7ZSsrKWlmKGM9ZFtlXSxcInNsb3RcIj09Yy5sb2NhbE5hbWUpYnJlYWsgYTthPXZvaWQgMH19YiYmYi5fcmVuZGVyUm9vdCgpfVxuRy5wcm90b3R5cGUuX3JlbmRlclJvb3Q9ZnVuY3Rpb24oKXt0aGlzLlQ9ITE7RGModGhpcyk7Zm9yKHZhciBhPTAsYjthPHRoaXMucy5sZW5ndGg7YSsrKXtiPXRoaXMuc1thXTt2YXIgYz1iLl9fc2hhZHkuYXNzaWduZWROb2RlcztiLl9fc2hhZHkuYXNzaWduZWROb2Rlcz1bXTtiLl9fc2hhZHkuSz1bXTtpZihiLl9fc2hhZHkucWE9Yylmb3IodmFyIGQ9MDtkPGMubGVuZ3RoO2QrKyl7dmFyIGU9Y1tkXTtlLl9fc2hhZHkuZ2E9ZS5fX3NoYWR5LmFzc2lnbmVkU2xvdDtlLl9fc2hhZHkuYXNzaWduZWRTbG90PT09YiYmKGUuX19zaGFkeS5hc3NpZ25lZFNsb3Q9bnVsbCl9fWZvcihiPXRoaXMuaG9zdC5maXJzdENoaWxkO2I7Yj1iLm5leHRTaWJsaW5nKWtkKHRoaXMsYik7Zm9yKGE9MDthPHRoaXMucy5sZW5ndGg7YSsrKXtiPXRoaXMuc1thXTtpZighYi5fX3NoYWR5LmFzc2lnbmVkTm9kZXMubGVuZ3RoKWZvcihjPWIuZmlyc3RDaGlsZDtjO2M9Yy5uZXh0U2libGluZylrZCh0aGlzLFxuYyxiKTtjPWIucGFyZW50Tm9kZTsoYz1jLl9fc2hhZHkmJmMuX19zaGFkeS5yb290KSYmRWMoYykmJmMuX3JlbmRlclJvb3QoKTtsZCh0aGlzLGIuX19zaGFkeS5LLGIuX19zaGFkeS5hc3NpZ25lZE5vZGVzKTtpZihjPWIuX19zaGFkeS5xYSl7Zm9yKGQ9MDtkPGMubGVuZ3RoO2QrKyljW2RdLl9fc2hhZHkuZ2E9bnVsbDtiLl9fc2hhZHkucWE9bnVsbDtjLmxlbmd0aD5iLl9fc2hhZHkuYXNzaWduZWROb2Rlcy5sZW5ndGgmJihiLl9fc2hhZHkuaWE9ITApfWIuX19zaGFkeS5pYSYmKGIuX19zaGFkeS5pYT0hMSxtZCh0aGlzLGIpKX1hPXRoaXMucztiPVtdO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspZD1hW2NdLnBhcmVudE5vZGUsZC5fX3NoYWR5JiZkLl9fc2hhZHkucm9vdHx8ISgwPmIuaW5kZXhPZihkKSl8fGIucHVzaChkKTtmb3IoYT0wO2E8Yi5sZW5ndGg7YSsrKXtjPWJbYV07ZD1jPT09dGhpcz90aGlzLmhvc3Q6YztlPVtdO2M9Yy5jaGlsZE5vZGVzO2Zvcih2YXIgZj0wO2Y8XG5jLmxlbmd0aDtmKyspe3ZhciBoPWNbZl07aWYoXCJzbG90XCI9PWgubG9jYWxOYW1lKXtoPWguX19zaGFkeS5LO2Zvcih2YXIgZz0wO2c8aC5sZW5ndGg7ZysrKWUucHVzaChoW2ddKX1lbHNlIGUucHVzaChoKX1jPXZvaWQgMDtmPUIuY2hpbGROb2RlcyhkKTtoPWdkKGUsZS5sZW5ndGgsZixmLmxlbmd0aCk7Zm9yKHZhciBrPWc9MDtnPGgubGVuZ3RoJiYoYz1oW2ddKTtnKyspe2Zvcih2YXIgbD0wLG07bDxjLk8ubGVuZ3RoJiYobT1jLk9bbF0pO2wrKylCLnBhcmVudE5vZGUobSk9PT1kJiZBLnJlbW92ZUNoaWxkLmNhbGwoZCxtKSxmLnNwbGljZShjLmluZGV4K2ssMSk7ay09Yy5VfWZvcihrPTA7azxoLmxlbmd0aCYmKGM9aFtrXSk7aysrKWZvcihnPWZbYy5pbmRleF0sbD1jLmluZGV4O2w8Yy5pbmRleCtjLlU7bCsrKW09ZVtsXSxBLmluc2VydEJlZm9yZS5jYWxsKGQsbSxnKSxmLnNwbGljZShsLDAsbSl9fTtcbmZ1bmN0aW9uIGtkKGEsYixjKXtiLl9fc2hhZHk9Yi5fX3NoYWR5fHx7fTt2YXIgZD1iLl9fc2hhZHkuZ2E7Yi5fX3NoYWR5LmdhPW51bGw7Y3x8KGM9KGE9YS5sW2Iuc2xvdHx8XCJfX2NhdGNoYWxsXCJdKSYmYVswXSk7Yz8oYy5fX3NoYWR5LmFzc2lnbmVkTm9kZXMucHVzaChiKSxiLl9fc2hhZHkuYXNzaWduZWRTbG90PWMpOmIuX19zaGFkeS5hc3NpZ25lZFNsb3Q9dm9pZCAwO2QhPT1iLl9fc2hhZHkuYXNzaWduZWRTbG90JiZiLl9fc2hhZHkuYXNzaWduZWRTbG90JiYoYi5fX3NoYWR5LmFzc2lnbmVkU2xvdC5fX3NoYWR5LmlhPSEwKX1mdW5jdGlvbiBsZChhLGIsYyl7Zm9yKHZhciBkPTAsZTtkPGMubGVuZ3RoJiYoZT1jW2RdKTtkKyspaWYoXCJzbG90XCI9PWUubG9jYWxOYW1lKXt2YXIgZj1lLl9fc2hhZHkuYXNzaWduZWROb2RlcztmJiZmLmxlbmd0aCYmbGQoYSxiLGYpfWVsc2UgYi5wdXNoKGNbZF0pfVxuZnVuY3Rpb24gbWQoYSxiKXtBLmRpc3BhdGNoRXZlbnQuY2FsbChiLG5ldyBFdmVudChcInNsb3RjaGFuZ2VcIikpO2IuX19zaGFkeS5hc3NpZ25lZFNsb3QmJm1kKGEsYi5fX3NoYWR5LmFzc2lnbmVkU2xvdCl9ZnVuY3Rpb24gRGMoYSl7aWYoYS5ILmxlbmd0aCl7Zm9yKHZhciBiPWEuSCxjLGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXTtlLl9fc2hhZHk9ZS5fX3NoYWR5fHx7fTt2YyhlKTt2YyhlLnBhcmVudE5vZGUpO3ZhciBmPUdjKGUpO2EubFtmXT8oYz1jfHx7fSxjW2ZdPSEwLGEubFtmXS5wdXNoKGUpKTphLmxbZl09W2VdO2Eucy5wdXNoKGUpfWlmKGMpZm9yKHZhciBoIGluIGMpYS5sW2hdPUhjKGEubFtoXSk7YS5IPVtdfX1mdW5jdGlvbiBHYyhhKXt2YXIgYj1hLm5hbWV8fGEuZ2V0QXR0cmlidXRlKFwibmFtZVwiKXx8XCJfX2NhdGNoYWxsXCI7cmV0dXJuIGEuQ2E9Yn1cbmZ1bmN0aW9uIEhjKGEpe3JldHVybiBhLnNvcnQoZnVuY3Rpb24oYSxjKXthPW5kKGEpO2Zvcih2YXIgYj1uZChjKSxlPTA7ZTxhLmxlbmd0aDtlKyspe2M9YVtlXTt2YXIgZj1iW2VdO2lmKGMhPT1mKXJldHVybiBhPUFycmF5LmZyb20oYy5wYXJlbnROb2RlLmNoaWxkTm9kZXMpLGEuaW5kZXhPZihjKS1hLmluZGV4T2YoZil9fSl9ZnVuY3Rpb24gbmQoYSl7dmFyIGI9W107ZG8gYi51bnNoaWZ0KGEpO3doaWxlKGE9YS5wYXJlbnROb2RlKTtyZXR1cm4gYn1mdW5jdGlvbiBFYyhhKXtEYyhhKTtyZXR1cm4hIWEucy5sZW5ndGh9Ry5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lcj1mdW5jdGlvbihhLGIsYyl7XCJvYmplY3RcIiE9PXR5cGVvZiBjJiYoYz17Y2FwdHVyZTohIWN9KTtjLmJhPXRoaXM7dGhpcy5ob3N0LmFkZEV2ZW50TGlzdGVuZXIoYSxiLGMpfTtcbkcucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI9ZnVuY3Rpb24oYSxiLGMpe1wib2JqZWN0XCIhPT10eXBlb2YgYyYmKGM9e2NhcHR1cmU6ISFjfSk7Yy5iYT10aGlzO3RoaXMuaG9zdC5yZW1vdmVFdmVudExpc3RlbmVyKGEsYixjKX07Ry5wcm90b3R5cGUuZ2V0RWxlbWVudEJ5SWQ9ZnVuY3Rpb24oYSl7cmV0dXJuIEpjKHRoaXMsZnVuY3Rpb24oYil7cmV0dXJuIGIuaWQ9PWF9LGZ1bmN0aW9uKGEpe3JldHVybiEhYX0pWzBdfHxudWxsfTt2YXIgb2Q9Ry5wcm90b3R5cGU7RShvZCxtYywhMCk7RShvZCxyYywhMCk7ZnVuY3Rpb24gcGQoYSl7dmFyIGI9YS5nZXRSb290Tm9kZSgpO3ooYikmJmpkKGIpO3JldHVybiBhLl9fc2hhZHkmJmEuX19zaGFkeS5hc3NpZ25lZFNsb3R8fG51bGx9XG52YXIgcWQ9e2FkZEV2ZW50TGlzdGVuZXI6WmMuYmluZCh3aW5kb3cpLHJlbW92ZUV2ZW50TGlzdGVuZXI6YWQuYmluZCh3aW5kb3cpfSxyZD17YWRkRXZlbnRMaXN0ZW5lcjpaYyxyZW1vdmVFdmVudExpc3RlbmVyOmFkLGFwcGVuZENoaWxkOmZ1bmN0aW9uKGEpe3JldHVybiB3Yyh0aGlzLGEpfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gd2ModGhpcyxhLGIpfSxyZW1vdmVDaGlsZDpmdW5jdGlvbihhKXtyZXR1cm4geGModGhpcyxhKX0scmVwbGFjZUNoaWxkOmZ1bmN0aW9uKGEsYil7d2ModGhpcyxhLGIpO3hjKHRoaXMsYik7cmV0dXJuIGF9LGNsb25lTm9kZTpmdW5jdGlvbihhKXtpZihcInRlbXBsYXRlXCI9PXRoaXMubG9jYWxOYW1lKXZhciBiPUEuY2xvbmVOb2RlLmNhbGwodGhpcyxhKTtlbHNlIGlmKGI9QS5jbG9uZU5vZGUuY2FsbCh0aGlzLCExKSxhKXthPXRoaXMuY2hpbGROb2Rlcztmb3IodmFyIGM9MCxkO2M8YS5sZW5ndGg7YysrKWQ9YVtjXS5jbG9uZU5vZGUoITApLFxuYi5hcHBlbmRDaGlsZChkKX1yZXR1cm4gYn0sZ2V0Um9vdE5vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gSWModGhpcyl9LGNvbnRhaW5zOmZ1bmN0aW9uKGEpe3JldHVybiBDYih0aGlzLGEpfSxnZXQgaXNDb25uZWN0ZWQoKXt2YXIgYT10aGlzLm93bmVyRG9jdW1lbnQ7aWYoQmImJkEuY29udGFpbnMuY2FsbChhLHRoaXMpfHxhLmRvY3VtZW50RWxlbWVudCYmQS5jb250YWlucy5jYWxsKGEuZG9jdW1lbnRFbGVtZW50LHRoaXMpKXJldHVybiEwO2ZvcihhPXRoaXM7YSYmIShhIGluc3RhbmNlb2YgRG9jdW1lbnQpOylhPWEucGFyZW50Tm9kZXx8KGEgaW5zdGFuY2VvZiBHP2EuaG9zdDp2b2lkIDApO3JldHVybiEhKGEmJmEgaW5zdGFuY2VvZiBEb2N1bWVudCl9LGRpc3BhdGNoRXZlbnQ6ZnVuY3Rpb24oYSl7R2IoKTtyZXR1cm4gQS5kaXNwYXRjaEV2ZW50LmNhbGwodGhpcyxhKX19LHNkPXtnZXQgYXNzaWduZWRTbG90KCl7cmV0dXJuIHBkKHRoaXMpfX0sdGQ9e3F1ZXJ5U2VsZWN0b3I6ZnVuY3Rpb24oYSl7cmV0dXJuIEpjKHRoaXMsXG5mdW5jdGlvbihiKXtyZXR1cm4gdGIuY2FsbChiLGEpfSxmdW5jdGlvbihhKXtyZXR1cm4hIWF9KVswXXx8bnVsbH0scXVlcnlTZWxlY3RvckFsbDpmdW5jdGlvbihhKXtyZXR1cm4gSmModGhpcyxmdW5jdGlvbihiKXtyZXR1cm4gdGIuY2FsbChiLGEpfSl9fSx1ZD17YXNzaWduZWROb2RlczpmdW5jdGlvbihhKXtpZihcInNsb3RcIj09PXRoaXMubG9jYWxOYW1lKXt2YXIgYj10aGlzLmdldFJvb3ROb2RlKCk7eihiKSYmamQoYik7cmV0dXJuIHRoaXMuX19zaGFkeT8oYSYmYS5mbGF0dGVuP3RoaXMuX19zaGFkeS5LOnRoaXMuX19zaGFkeS5hc3NpZ25lZE5vZGVzKXx8W106W119fX0sdmQ9dmIoe3NldEF0dHJpYnV0ZTpmdW5jdGlvbihhLGIpe01jKHRoaXMsYSxiKX0scmVtb3ZlQXR0cmlidXRlOmZ1bmN0aW9uKGEpe0EucmVtb3ZlQXR0cmlidXRlLmNhbGwodGhpcyxhKTtGYyh0aGlzLGEpfSxhdHRhY2hTaGFkb3c6ZnVuY3Rpb24oYSl7aWYoIXRoaXMpdGhyb3dcIk11c3QgcHJvdmlkZSBhIGhvc3QuXCI7XG5pZighYSl0aHJvd1wiTm90IGVub3VnaCBhcmd1bWVudHMuXCI7cmV0dXJuIG5ldyBHKGlkLHRoaXMsYSl9LGdldCBzbG90KCl7cmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwic2xvdFwiKX0sc2V0IHNsb3QoYSl7TWModGhpcyxcInNsb3RcIixhKX0sZ2V0IGFzc2lnbmVkU2xvdCgpe3JldHVybiBwZCh0aGlzKX19LHRkLHVkKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh2ZCxxYyk7dmFyIHdkPXZiKHtpbXBvcnROb2RlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIE5jKGEsYil9LGdldEVsZW1lbnRCeUlkOmZ1bmN0aW9uKGEpe3JldHVybiBKYyh0aGlzLGZ1bmN0aW9uKGIpe3JldHVybiBiLmlkPT1hfSxmdW5jdGlvbihhKXtyZXR1cm4hIWF9KVswXXx8bnVsbH19LHRkKTtPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3ZCx7X2FjdGl2ZUVsZW1lbnQ6cmMuYWN0aXZlRWxlbWVudH0pO1xudmFyIHhkPUhUTUxFbGVtZW50LnByb3RvdHlwZS5ibHVyLHlkPXZiKHtibHVyOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5fX3NoYWR5JiZ0aGlzLl9fc2hhZHkucm9vdDsoYT1hJiZhLmFjdGl2ZUVsZW1lbnQpP2EuYmx1cigpOnhkLmNhbGwodGhpcyl9fSk7ZnVuY3Rpb24gSChhLGIpe2Zvcih2YXIgYz1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhiKSxkPTA7ZDxjLmxlbmd0aDtkKyspe3ZhciBlPWNbZF0sZj1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGIsZSk7Zi52YWx1ZT9hW2VdPWYudmFsdWU6T2JqZWN0LmRlZmluZVByb3BlcnR5KGEsZSxmKX19O2lmKHkudGEpe3ZhciBTaGFkeURPTT17aW5Vc2U6eS50YSxwYXRjaDpmdW5jdGlvbihhKXtyZXR1cm4gYX0saXNTaGFkeVJvb3Q6eixlbnF1ZXVlOkZiLGZsdXNoOkdiLHNldHRpbmdzOnksZmlsdGVyTXV0YXRpb25zOk1iLG9ic2VydmVDaGlsZHJlbjpLYix1bm9ic2VydmVDaGlsZHJlbjpMYixuYXRpdmVNZXRob2RzOkEsbmF0aXZlVHJlZTpCfTt3aW5kb3cuU2hhZHlET009U2hhZHlET007d2luZG93LkV2ZW50PWNkO3dpbmRvdy5DdXN0b21FdmVudD1kZDt3aW5kb3cuTW91c2VFdmVudD1lZDtiZCgpO3ZhciB6ZD13aW5kb3cuY3VzdG9tRWxlbWVudHMmJndpbmRvdy5jdXN0b21FbGVtZW50cy5uYXRpdmVIVE1MRWxlbWVudHx8SFRNTEVsZW1lbnQ7SCh3aW5kb3cuTm9kZS5wcm90b3R5cGUscmQpO0god2luZG93LldpbmRvdy5wcm90b3R5cGUscWQpO0god2luZG93LlRleHQucHJvdG90eXBlLHNkKTtIKHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSx0ZCk7SCh3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUsXG52ZCk7SCh3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLHdkKTt3aW5kb3cuSFRNTFNsb3RFbGVtZW50JiZIKHdpbmRvdy5IVE1MU2xvdEVsZW1lbnQucHJvdG90eXBlLHVkKTtIKHpkLnByb3RvdHlwZSx5ZCk7eS5NJiYoRih3aW5kb3cuTm9kZS5wcm90b3R5cGUpLEYod2luZG93LlRleHQucHJvdG90eXBlKSxGKHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSksRih3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUpLEYoemQucHJvdG90eXBlKSxGKHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUpLHdpbmRvdy5IVE1MU2xvdEVsZW1lbnQmJkYod2luZG93LkhUTUxTbG90RWxlbWVudC5wcm90b3R5cGUpKTt3aW5kb3cuU2hhZG93Um9vdD1HfTt2YXIgQWQ9bmV3IFNldChcImFubm90YXRpb24teG1sIGNvbG9yLXByb2ZpbGUgZm9udC1mYWNlIGZvbnQtZmFjZS1zcmMgZm9udC1mYWNlLXVyaSBmb250LWZhY2UtZm9ybWF0IGZvbnQtZmFjZS1uYW1lIG1pc3NpbmctZ2x5cGhcIi5zcGxpdChcIiBcIikpO2Z1bmN0aW9uIEJkKGEpe3ZhciBiPUFkLmhhcyhhKTthPS9eW2Etel1bLjAtOV9hLXpdKi1bXFwtLjAtOV9hLXpdKiQvLnRlc3QoYSk7cmV0dXJuIWImJmF9ZnVuY3Rpb24gSihhKXt2YXIgYj1hLmlzQ29ubmVjdGVkO2lmKHZvaWQgMCE9PWIpcmV0dXJuIGI7Zm9yKDthJiYhKGEuX19DRV9pc0ltcG9ydERvY3VtZW50fHxhIGluc3RhbmNlb2YgRG9jdW1lbnQpOylhPWEucGFyZW50Tm9kZXx8KHdpbmRvdy5TaGFkb3dSb290JiZhIGluc3RhbmNlb2YgU2hhZG93Um9vdD9hLmhvc3Q6dm9pZCAwKTtyZXR1cm4hKCFhfHwhKGEuX19DRV9pc0ltcG9ydERvY3VtZW50fHxhIGluc3RhbmNlb2YgRG9jdW1lbnQpKX1cbmZ1bmN0aW9uIENkKGEsYil7Zm9yKDtiJiZiIT09YSYmIWIubmV4dFNpYmxpbmc7KWI9Yi5wYXJlbnROb2RlO3JldHVybiBiJiZiIT09YT9iLm5leHRTaWJsaW5nOm51bGx9XG5mdW5jdGlvbiBLKGEsYixjKXtjPXZvaWQgMD09PWM/bmV3IFNldDpjO2Zvcih2YXIgZD1hO2Q7KXtpZihkLm5vZGVUeXBlPT09Tm9kZS5FTEVNRU5UX05PREUpe3ZhciBlPWQ7YihlKTt2YXIgZj1lLmxvY2FsTmFtZTtpZihcImxpbmtcIj09PWYmJlwiaW1wb3J0XCI9PT1lLmdldEF0dHJpYnV0ZShcInJlbFwiKSl7ZD1lLmltcG9ydDtpZihkIGluc3RhbmNlb2YgTm9kZSYmIWMuaGFzKGQpKWZvcihjLmFkZChkKSxkPWQuZmlyc3RDaGlsZDtkO2Q9ZC5uZXh0U2libGluZylLKGQsYixjKTtkPUNkKGEsZSk7Y29udGludWV9ZWxzZSBpZihcInRlbXBsYXRlXCI9PT1mKXtkPUNkKGEsZSk7Y29udGludWV9aWYoZT1lLl9fQ0Vfc2hhZG93Um9vdClmb3IoZT1lLmZpcnN0Q2hpbGQ7ZTtlPWUubmV4dFNpYmxpbmcpSyhlLGIsYyl9ZD1kLmZpcnN0Q2hpbGQ/ZC5maXJzdENoaWxkOkNkKGEsZCl9fWZ1bmN0aW9uIEwoYSxiLGMpe2FbYl09Y307ZnVuY3Rpb24gRGQoKXt0aGlzLmE9bmV3IE1hcDt0aGlzLm89bmV3IE1hcDt0aGlzLmg9W107dGhpcy5jPSExfWZ1bmN0aW9uIEVkKGEsYixjKXthLmEuc2V0KGIsYyk7YS5vLnNldChjLmNvbnN0cnVjdG9yLGMpfWZ1bmN0aW9uIEZkKGEsYil7YS5jPSEwO2EuaC5wdXNoKGIpfWZ1bmN0aW9uIEdkKGEsYil7YS5jJiZLKGIsZnVuY3Rpb24oYil7cmV0dXJuIGEuYihiKX0pfURkLnByb3RvdHlwZS5iPWZ1bmN0aW9uKGEpe2lmKHRoaXMuYyYmIWEuX19DRV9wYXRjaGVkKXthLl9fQ0VfcGF0Y2hlZD0hMDtmb3IodmFyIGI9MDtiPHRoaXMuaC5sZW5ndGg7YisrKXRoaXMuaFtiXShhKX19O2Z1bmN0aW9uIE0oYSxiKXt2YXIgYz1bXTtLKGIsZnVuY3Rpb24oYSl7cmV0dXJuIGMucHVzaChhKX0pO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspe3ZhciBkPWNbYl07MT09PWQuX19DRV9zdGF0ZT9hLmNvbm5lY3RlZENhbGxiYWNrKGQpOkhkKGEsZCl9fVxuZnVuY3Rpb24gTihhLGIpe3ZhciBjPVtdO0soYixmdW5jdGlvbihhKXtyZXR1cm4gYy5wdXNoKGEpfSk7Zm9yKGI9MDtiPGMubGVuZ3RoO2IrKyl7dmFyIGQ9Y1tiXTsxPT09ZC5fX0NFX3N0YXRlJiZhLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGQpfX1cbmZ1bmN0aW9uIE8oYSxiLGMpe2M9dm9pZCAwPT09Yz97fTpjO3ZhciBkPWMuJGF8fG5ldyBTZXQsZT1jLndhfHxmdW5jdGlvbihiKXtyZXR1cm4gSGQoYSxiKX0sZj1bXTtLKGIsZnVuY3Rpb24oYil7aWYoXCJsaW5rXCI9PT1iLmxvY2FsTmFtZSYmXCJpbXBvcnRcIj09PWIuZ2V0QXR0cmlidXRlKFwicmVsXCIpKXt2YXIgYz1iLmltcG9ydDtjIGluc3RhbmNlb2YgTm9kZSYmKGMuX19DRV9pc0ltcG9ydERvY3VtZW50PSEwLGMuX19DRV9oYXNSZWdpc3RyeT0hMCk7YyYmXCJjb21wbGV0ZVwiPT09Yy5yZWFkeVN0YXRlP2MuX19DRV9kb2N1bWVudExvYWRIYW5kbGVkPSEwOmIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIixmdW5jdGlvbigpe3ZhciBjPWIuaW1wb3J0O2lmKCFjLl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCl7Yy5fX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQ9ITA7dmFyIGY9bmV3IFNldChkKTtmLmRlbGV0ZShjKTtPKGEsYyx7JGE6Zix3YTplfSl9fSl9ZWxzZSBmLnB1c2goYil9LGQpO2lmKGEuYylmb3IoYj1cbjA7YjxmLmxlbmd0aDtiKyspYS5iKGZbYl0pO2ZvcihiPTA7YjxmLmxlbmd0aDtiKyspZShmW2JdKX1cbmZ1bmN0aW9uIEhkKGEsYil7aWYodm9pZCAwPT09Yi5fX0NFX3N0YXRlKXt2YXIgYz1iLm93bmVyRG9jdW1lbnQ7aWYoYy5kZWZhdWx0Vmlld3x8Yy5fX0NFX2lzSW1wb3J0RG9jdW1lbnQmJmMuX19DRV9oYXNSZWdpc3RyeSlpZihjPWEuYS5nZXQoYi5sb2NhbE5hbWUpKXtjLmNvbnN0cnVjdGlvblN0YWNrLnB1c2goYik7dmFyIGQ9Yy5jb25zdHJ1Y3Rvcjt0cnl7dHJ5e2lmKG5ldyBkIT09Yil0aHJvdyBFcnJvcihcIlRoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvciBkaWQgbm90IHByb2R1Y2UgdGhlIGVsZW1lbnQgYmVpbmcgdXBncmFkZWQuXCIpO31maW5hbGx5e2MuY29uc3RydWN0aW9uU3RhY2sucG9wKCl9fWNhdGNoKGgpe3Rocm93IGIuX19DRV9zdGF0ZT0yLGg7fWIuX19DRV9zdGF0ZT0xO2IuX19DRV9kZWZpbml0aW9uPWM7aWYoYy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spZm9yKGM9Yy5vYnNlcnZlZEF0dHJpYnV0ZXMsZD0wO2Q8Yy5sZW5ndGg7ZCsrKXt2YXIgZT1jW2RdLFxuZj1iLmdldEF0dHJpYnV0ZShlKTtudWxsIT09ZiYmYS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soYixlLG51bGwsZixudWxsKX1KKGIpJiZhLmNvbm5lY3RlZENhbGxiYWNrKGIpfX19RGQucHJvdG90eXBlLmNvbm5lY3RlZENhbGxiYWNrPWZ1bmN0aW9uKGEpe3ZhciBiPWEuX19DRV9kZWZpbml0aW9uO2IuY29ubmVjdGVkQ2FsbGJhY2smJmIuY29ubmVjdGVkQ2FsbGJhY2suY2FsbChhKX07RGQucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrPWZ1bmN0aW9uKGEpe3ZhciBiPWEuX19DRV9kZWZpbml0aW9uO2IuZGlzY29ubmVjdGVkQ2FsbGJhY2smJmIuZGlzY29ubmVjdGVkQ2FsbGJhY2suY2FsbChhKX07XG5EZC5wcm90b3R5cGUuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrPWZ1bmN0aW9uKGEsYixjLGQsZSl7dmFyIGY9YS5fX0NFX2RlZmluaXRpb247Zi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2smJi0xPGYub2JzZXJ2ZWRBdHRyaWJ1dGVzLmluZGV4T2YoYikmJmYuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrLmNhbGwoYSxiLGMsZCxlKX07ZnVuY3Rpb24gSWQoYSl7dmFyIGI9ZG9jdW1lbnQ7dGhpcy5qPWE7dGhpcy5hPWI7dGhpcy5DPXZvaWQgMDtPKHRoaXMuaix0aGlzLmEpO1wibG9hZGluZ1wiPT09dGhpcy5hLnJlYWR5U3RhdGUmJih0aGlzLkM9bmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5iLmJpbmQodGhpcykpLHRoaXMuQy5vYnNlcnZlKHRoaXMuYSx7Y2hpbGRMaXN0OiEwLHN1YnRyZWU6ITB9KSl9ZnVuY3Rpb24gSmQoYSl7YS5DJiZhLkMuZGlzY29ubmVjdCgpfUlkLnByb3RvdHlwZS5iPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMuYS5yZWFkeVN0YXRlO1wiaW50ZXJhY3RpdmVcIiE9PWImJlwiY29tcGxldGVcIiE9PWJ8fEpkKHRoaXMpO2ZvcihiPTA7YjxhLmxlbmd0aDtiKyspZm9yKHZhciBjPWFbYl0uYWRkZWROb2RlcyxkPTA7ZDxjLmxlbmd0aDtkKyspTyh0aGlzLmosY1tkXSl9O2Z1bmN0aW9uIEtkKCl7dmFyIGE9dGhpczt0aGlzLmI9dGhpcy5hPXZvaWQgMDt0aGlzLmM9bmV3IFByb21pc2UoZnVuY3Rpb24oYil7YS5iPWI7YS5hJiZiKGEuYSl9KX1LZC5wcm90b3R5cGUucmVzb2x2ZT1mdW5jdGlvbihhKXtpZih0aGlzLmEpdGhyb3cgRXJyb3IoXCJBbHJlYWR5IHJlc29sdmVkLlwiKTt0aGlzLmE9YTt0aGlzLmImJnRoaXMuYihhKX07ZnVuY3Rpb24gUChhKXt0aGlzLmRhPSExO3RoaXMuaj1hO3RoaXMuaGE9bmV3IE1hcDt0aGlzLmVhPWZ1bmN0aW9uKGEpe3JldHVybiBhKCl9O3RoaXMuUj0hMTt0aGlzLmZhPVtdO3RoaXMuRmE9bmV3IElkKGEpfVxuUC5wcm90b3R5cGUuZGVmaW5lPWZ1bmN0aW9uKGEsYil7dmFyIGM9dGhpcztpZighKGIgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkN1c3RvbSBlbGVtZW50IGNvbnN0cnVjdG9ycyBtdXN0IGJlIGZ1bmN0aW9ucy5cIik7aWYoIUJkKGEpKXRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBlbGVtZW50IG5hbWUgJ1wiK2ErXCInIGlzIG5vdCB2YWxpZC5cIik7aWYodGhpcy5qLmEuZ2V0KGEpKXRocm93IEVycm9yKFwiQSBjdXN0b20gZWxlbWVudCB3aXRoIG5hbWUgJ1wiK2ErXCInIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZC5cIik7aWYodGhpcy5kYSl0aHJvdyBFcnJvcihcIkEgY3VzdG9tIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBkZWZpbmVkLlwiKTt0aGlzLmRhPSEwO3RyeXt2YXIgZD1mdW5jdGlvbihhKXt2YXIgYj1lW2FdO2lmKHZvaWQgMCE9PWImJiEoYiBpbnN0YW5jZW9mIEZ1bmN0aW9uKSl0aHJvdyBFcnJvcihcIlRoZSAnXCIrYStcIicgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLlwiKTtcbnJldHVybiBifSxlPWIucHJvdG90eXBlO2lmKCEoZSBpbnN0YW5jZW9mIE9iamVjdCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZSBpcyBub3QgYW4gb2JqZWN0LlwiKTt2YXIgZj1kKFwiY29ubmVjdGVkQ2FsbGJhY2tcIik7dmFyIGg9ZChcImRpc2Nvbm5lY3RlZENhbGxiYWNrXCIpO3ZhciBnPWQoXCJhZG9wdGVkQ2FsbGJhY2tcIik7dmFyIGs9ZChcImF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja1wiKTt2YXIgbD1iLm9ic2VydmVkQXR0cmlidXRlc3x8W119Y2F0Y2gobSl7cmV0dXJufWZpbmFsbHl7dGhpcy5kYT0hMX1iPXtsb2NhbE5hbWU6YSxjb25zdHJ1Y3RvcjpiLGNvbm5lY3RlZENhbGxiYWNrOmYsZGlzY29ubmVjdGVkQ2FsbGJhY2s6aCxhZG9wdGVkQ2FsbGJhY2s6ZyxhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2s6ayxvYnNlcnZlZEF0dHJpYnV0ZXM6bCxjb25zdHJ1Y3Rpb25TdGFjazpbXX07RWQodGhpcy5qLGEsYik7dGhpcy5mYS5wdXNoKGIpO1xudGhpcy5SfHwodGhpcy5SPSEwLHRoaXMuZWEoZnVuY3Rpb24oKXtyZXR1cm4gTGQoYyl9KSl9O2Z1bmN0aW9uIExkKGEpe2lmKCExIT09YS5SKXthLlI9ITE7Zm9yKHZhciBiPWEuZmEsYz1bXSxkPW5ldyBNYXAsZT0wO2U8Yi5sZW5ndGg7ZSsrKWQuc2V0KGJbZV0ubG9jYWxOYW1lLFtdKTtPKGEuaixkb2N1bWVudCx7d2E6ZnVuY3Rpb24oYil7aWYodm9pZCAwPT09Yi5fX0NFX3N0YXRlKXt2YXIgZT1iLmxvY2FsTmFtZSxmPWQuZ2V0KGUpO2Y/Zi5wdXNoKGIpOmEuai5hLmdldChlKSYmYy5wdXNoKGIpfX19KTtmb3IoZT0wO2U8Yy5sZW5ndGg7ZSsrKUhkKGEuaixjW2VdKTtmb3IoOzA8Yi5sZW5ndGg7KXt2YXIgZj1iLnNoaWZ0KCk7ZT1mLmxvY2FsTmFtZTtmPWQuZ2V0KGYubG9jYWxOYW1lKTtmb3IodmFyIGg9MDtoPGYubGVuZ3RoO2grKylIZChhLmosZltoXSk7KGU9YS5oYS5nZXQoZSkpJiZlLnJlc29sdmUodm9pZCAwKX19fVxuUC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKGEpe2lmKGE9dGhpcy5qLmEuZ2V0KGEpKXJldHVybiBhLmNvbnN0cnVjdG9yfTtQLnByb3RvdHlwZS53aGVuRGVmaW5lZD1mdW5jdGlvbihhKXtpZighQmQoYSkpcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBTeW50YXhFcnJvcihcIidcIithK1wiJyBpcyBub3QgYSB2YWxpZCBjdXN0b20gZWxlbWVudCBuYW1lLlwiKSk7dmFyIGI9dGhpcy5oYS5nZXQoYSk7aWYoYilyZXR1cm4gYi5jO2I9bmV3IEtkO3RoaXMuaGEuc2V0KGEsYik7dGhpcy5qLmEuZ2V0KGEpJiYhdGhpcy5mYS5zb21lKGZ1bmN0aW9uKGIpe3JldHVybiBiLmxvY2FsTmFtZT09PWF9KSYmYi5yZXNvbHZlKHZvaWQgMCk7cmV0dXJuIGIuY307UC5wcm90b3R5cGUuVGE9ZnVuY3Rpb24oYSl7SmQodGhpcy5GYSk7dmFyIGI9dGhpcy5lYTt0aGlzLmVhPWZ1bmN0aW9uKGMpe3JldHVybiBhKGZ1bmN0aW9uKCl7cmV0dXJuIGIoYyl9KX19O1xud2luZG93LkN1c3RvbUVsZW1lbnRSZWdpc3RyeT1QO1AucHJvdG90eXBlLmRlZmluZT1QLnByb3RvdHlwZS5kZWZpbmU7UC5wcm90b3R5cGUuZ2V0PVAucHJvdG90eXBlLmdldDtQLnByb3RvdHlwZS53aGVuRGVmaW5lZD1QLnByb3RvdHlwZS53aGVuRGVmaW5lZDtQLnByb3RvdHlwZS5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrPVAucHJvdG90eXBlLlRhO3ZhciBNZD13aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnQsTmQ9d2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50TlMsT2Q9d2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5pbXBvcnROb2RlLFBkPXdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUucHJlcGVuZCxRZD13aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmFwcGVuZCxSZD13aW5kb3cuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucHJlcGVuZCxTZD13aW5kb3cuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUuYXBwZW5kLFRkPXdpbmRvdy5Ob2RlLnByb3RvdHlwZS5jbG9uZU5vZGUsVWQ9d2luZG93Lk5vZGUucHJvdG90eXBlLmFwcGVuZENoaWxkLFZkPXdpbmRvdy5Ob2RlLnByb3RvdHlwZS5pbnNlcnRCZWZvcmUsV2Q9d2luZG93Lk5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkLFhkPXdpbmRvdy5Ob2RlLnByb3RvdHlwZS5yZXBsYWNlQ2hpbGQsWWQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuTm9kZS5wcm90b3R5cGUsXG5cInRleHRDb250ZW50XCIpLFpkPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5hdHRhY2hTaGFkb3csJGQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUsXCJpbm5lckhUTUxcIiksYWU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZSxiZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLGNlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGUsZGU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZU5TLGVlPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGVOUyxmZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQXR0cmlidXRlTlMsZ2U9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmluc2VydEFkamFjZW50RWxlbWVudCxoZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUucHJlcGVuZCxpZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYXBwZW5kLFxuamU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLmJlZm9yZSxrZT13aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuYWZ0ZXIsbGU9d2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlcGxhY2VXaXRoLG1lPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmUsbmU9d2luZG93LkhUTUxFbGVtZW50LG9lPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iod2luZG93LkhUTUxFbGVtZW50LnByb3RvdHlwZSxcImlubmVySFRNTFwiKSxwZT13aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlLmluc2VydEFkamFjZW50RWxlbWVudDt2YXIgcWU9bmV3IGZ1bmN0aW9uKCl7fTtmdW5jdGlvbiByZSgpe3ZhciBhPXNlO3dpbmRvdy5IVE1MRWxlbWVudD1mdW5jdGlvbigpe2Z1bmN0aW9uIGIoKXt2YXIgYj10aGlzLmNvbnN0cnVjdG9yLGQ9YS5vLmdldChiKTtpZighZCl0aHJvdyBFcnJvcihcIlRoZSBjdXN0b20gZWxlbWVudCBiZWluZyBjb25zdHJ1Y3RlZCB3YXMgbm90IHJlZ2lzdGVyZWQgd2l0aCBgY3VzdG9tRWxlbWVudHNgLlwiKTt2YXIgZT1kLmNvbnN0cnVjdGlvblN0YWNrO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gZT1NZC5jYWxsKGRvY3VtZW50LGQubG9jYWxOYW1lKSxPYmplY3Quc2V0UHJvdG90eXBlT2YoZSxiLnByb3RvdHlwZSksZS5fX0NFX3N0YXRlPTEsZS5fX0NFX2RlZmluaXRpb249ZCxhLmIoZSksZTtkPWUubGVuZ3RoLTE7dmFyIGY9ZVtkXTtpZihmPT09cWUpdGhyb3cgRXJyb3IoXCJUaGUgSFRNTEVsZW1lbnQgY29uc3RydWN0b3Igd2FzIGVpdGhlciBjYWxsZWQgcmVlbnRyYW50bHkgZm9yIHRoaXMgY29uc3RydWN0b3Igb3IgY2FsbGVkIG11bHRpcGxlIHRpbWVzLlwiKTtcbmVbZF09cWU7T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsYi5wcm90b3R5cGUpO2EuYihmKTtyZXR1cm4gZn1iLnByb3RvdHlwZT1uZS5wcm90b3R5cGU7cmV0dXJuIGJ9KCl9O2Z1bmN0aW9uIHRlKGEsYixjKXtmdW5jdGlvbiBkKGIpe3JldHVybiBmdW5jdGlvbihjKXtmb3IodmFyIGQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDsrK2UpZFtlLTBdPWFyZ3VtZW50c1tlXTtlPVtdO2Zvcih2YXIgZj1bXSxsPTA7bDxkLmxlbmd0aDtsKyspe3ZhciBtPWRbbF07bSBpbnN0YW5jZW9mIEVsZW1lbnQmJkoobSkmJmYucHVzaChtKTtpZihtIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudClmb3IobT1tLmZpcnN0Q2hpbGQ7bTttPW0ubmV4dFNpYmxpbmcpZS5wdXNoKG0pO2Vsc2UgZS5wdXNoKG0pfWIuYXBwbHkodGhpcyxkKTtmb3IoZD0wO2Q8Zi5sZW5ndGg7ZCsrKU4oYSxmW2RdKTtpZihKKHRoaXMpKWZvcihkPTA7ZDxlLmxlbmd0aDtkKyspZj1lW2RdLGYgaW5zdGFuY2VvZiBFbGVtZW50JiZNKGEsZil9fXZvaWQgMCE9PWMuWCYmKGIucHJlcGVuZD1kKGMuWCkpO3ZvaWQgMCE9PWMuYXBwZW5kJiYoYi5hcHBlbmQ9ZChjLmFwcGVuZCkpfTtmdW5jdGlvbiB1ZSgpe3ZhciBhPXNlO0woRG9jdW1lbnQucHJvdG90eXBlLFwiY3JlYXRlRWxlbWVudFwiLGZ1bmN0aW9uKGIpe2lmKHRoaXMuX19DRV9oYXNSZWdpc3RyeSl7dmFyIGM9YS5hLmdldChiKTtpZihjKXJldHVybiBuZXcgYy5jb25zdHJ1Y3Rvcn1iPU1kLmNhbGwodGhpcyxiKTthLmIoYik7cmV0dXJuIGJ9KTtMKERvY3VtZW50LnByb3RvdHlwZSxcImltcG9ydE5vZGVcIixmdW5jdGlvbihiLGMpe2I9T2QuY2FsbCh0aGlzLGIsYyk7dGhpcy5fX0NFX2hhc1JlZ2lzdHJ5P08oYSxiKTpHZChhLGIpO3JldHVybiBifSk7TChEb2N1bWVudC5wcm90b3R5cGUsXCJjcmVhdGVFbGVtZW50TlNcIixmdW5jdGlvbihiLGMpe2lmKHRoaXMuX19DRV9oYXNSZWdpc3RyeSYmKG51bGw9PT1ifHxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj09PWIpKXt2YXIgZD1hLmEuZ2V0KGMpO2lmKGQpcmV0dXJuIG5ldyBkLmNvbnN0cnVjdG9yfWI9TmQuY2FsbCh0aGlzLGIsYyk7YS5iKGIpO3JldHVybiBifSk7XG50ZShhLERvY3VtZW50LnByb3RvdHlwZSx7WDpQZCxhcHBlbmQ6UWR9KX07ZnVuY3Rpb24gdmUoKXt2YXIgYT1zZTtmdW5jdGlvbiBiKGIsZCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGIsXCJ0ZXh0Q29udGVudFwiLHtlbnVtZXJhYmxlOmQuZW51bWVyYWJsZSxjb25maWd1cmFibGU6ITAsZ2V0OmQuZ2V0LHNldDpmdW5jdGlvbihiKXtpZih0aGlzLm5vZGVUeXBlPT09Tm9kZS5URVhUX05PREUpZC5zZXQuY2FsbCh0aGlzLGIpO2Vsc2V7dmFyIGM9dm9pZCAwO2lmKHRoaXMuZmlyc3RDaGlsZCl7dmFyIGU9dGhpcy5jaGlsZE5vZGVzLGc9ZS5sZW5ndGg7aWYoMDxnJiZKKHRoaXMpKXtjPUFycmF5KGcpO2Zvcih2YXIgaz0wO2s8ZztrKyspY1trXT1lW2tdfX1kLnNldC5jYWxsKHRoaXMsYik7aWYoYylmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKU4oYSxjW2JdKX19fSl9TChOb2RlLnByb3RvdHlwZSxcImluc2VydEJlZm9yZVwiLGZ1bmN0aW9uKGIsZCl7aWYoYiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShiLmNoaWxkTm9kZXMpO1xuYj1WZC5jYWxsKHRoaXMsYixkKTtpZihKKHRoaXMpKWZvcihkPTA7ZDxjLmxlbmd0aDtkKyspTShhLGNbZF0pO3JldHVybiBifWM9SihiKTtkPVZkLmNhbGwodGhpcyxiLGQpO2MmJk4oYSxiKTtKKHRoaXMpJiZNKGEsYik7cmV0dXJuIGR9KTtMKE5vZGUucHJvdG90eXBlLFwiYXBwZW5kQ2hpbGRcIixmdW5jdGlvbihiKXtpZihiIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCl7dmFyIGM9QXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGIuY2hpbGROb2Rlcyk7Yj1VZC5jYWxsKHRoaXMsYik7aWYoSih0aGlzKSlmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKylNKGEsY1tlXSk7cmV0dXJuIGJ9Yz1KKGIpO2U9VWQuY2FsbCh0aGlzLGIpO2MmJk4oYSxiKTtKKHRoaXMpJiZNKGEsYik7cmV0dXJuIGV9KTtMKE5vZGUucHJvdG90eXBlLFwiY2xvbmVOb2RlXCIsZnVuY3Rpb24oYil7Yj1UZC5jYWxsKHRoaXMsYik7dGhpcy5vd25lckRvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnk/TyhhLGIpOlxuR2QoYSxiKTtyZXR1cm4gYn0pO0woTm9kZS5wcm90b3R5cGUsXCJyZW1vdmVDaGlsZFwiLGZ1bmN0aW9uKGIpe3ZhciBjPUooYiksZT1XZC5jYWxsKHRoaXMsYik7YyYmTihhLGIpO3JldHVybiBlfSk7TChOb2RlLnByb3RvdHlwZSxcInJlcGxhY2VDaGlsZFwiLGZ1bmN0aW9uKGIsZCl7aWYoYiBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpe3ZhciBjPUFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShiLmNoaWxkTm9kZXMpO2I9WGQuY2FsbCh0aGlzLGIsZCk7aWYoSih0aGlzKSlmb3IoTihhLGQpLGQ9MDtkPGMubGVuZ3RoO2QrKylNKGEsY1tkXSk7cmV0dXJuIGJ9Yz1KKGIpO3ZhciBmPVhkLmNhbGwodGhpcyxiLGQpLGg9Sih0aGlzKTtoJiZOKGEsZCk7YyYmTihhLGIpO2gmJk0oYSxiKTtyZXR1cm4gZn0pO1lkJiZZZC5nZXQ/YihOb2RlLnByb3RvdHlwZSxZZCk6RmQoYSxmdW5jdGlvbihhKXtiKGEse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe2Zvcih2YXIgYT1cbltdLGI9MDtiPHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7YisrKWEucHVzaCh0aGlzLmNoaWxkTm9kZXNbYl0udGV4dENvbnRlbnQpO3JldHVybiBhLmpvaW4oXCJcIil9LHNldDpmdW5jdGlvbihhKXtmb3IoO3RoaXMuZmlyc3RDaGlsZDspV2QuY2FsbCh0aGlzLHRoaXMuZmlyc3RDaGlsZCk7VWQuY2FsbCh0aGlzLGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGEpKX19KX0pfTtmdW5jdGlvbiB3ZShhKXt2YXIgYj1FbGVtZW50LnByb3RvdHlwZTtmdW5jdGlvbiBjKGIpe3JldHVybiBmdW5jdGlvbihjKXtmb3IodmFyIGQ9W10sZT0wO2U8YXJndW1lbnRzLmxlbmd0aDsrK2UpZFtlLTBdPWFyZ3VtZW50c1tlXTtlPVtdO2Zvcih2YXIgZz1bXSxrPTA7azxkLmxlbmd0aDtrKyspe3ZhciBsPWRba107bCBpbnN0YW5jZW9mIEVsZW1lbnQmJkoobCkmJmcucHVzaChsKTtpZihsIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudClmb3IobD1sLmZpcnN0Q2hpbGQ7bDtsPWwubmV4dFNpYmxpbmcpZS5wdXNoKGwpO2Vsc2UgZS5wdXNoKGwpfWIuYXBwbHkodGhpcyxkKTtmb3IoZD0wO2Q8Zy5sZW5ndGg7ZCsrKU4oYSxnW2RdKTtpZihKKHRoaXMpKWZvcihkPTA7ZDxlLmxlbmd0aDtkKyspZz1lW2RdLGcgaW5zdGFuY2VvZiBFbGVtZW50JiZNKGEsZyl9fXZvaWQgMCE9PWplJiYoYi5iZWZvcmU9YyhqZSkpO3ZvaWQgMCE9PWplJiYoYi5hZnRlcj1jKGtlKSk7dm9pZCAwIT09XG5sZSYmTChiLFwicmVwbGFjZVdpdGhcIixmdW5jdGlvbihiKXtmb3IodmFyIGM9W10sZD0wO2Q8YXJndW1lbnRzLmxlbmd0aDsrK2QpY1tkLTBdPWFyZ3VtZW50c1tkXTtkPVtdO2Zvcih2YXIgaD1bXSxnPTA7ZzxjLmxlbmd0aDtnKyspe3ZhciBrPWNbZ107ayBpbnN0YW5jZW9mIEVsZW1lbnQmJkooaykmJmgucHVzaChrKTtpZihrIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudClmb3Ioaz1rLmZpcnN0Q2hpbGQ7aztrPWsubmV4dFNpYmxpbmcpZC5wdXNoKGspO2Vsc2UgZC5wdXNoKGspfWc9Sih0aGlzKTtsZS5hcHBseSh0aGlzLGMpO2ZvcihjPTA7YzxoLmxlbmd0aDtjKyspTihhLGhbY10pO2lmKGcpZm9yKE4oYSx0aGlzKSxjPTA7YzxkLmxlbmd0aDtjKyspaD1kW2NdLGggaW5zdGFuY2VvZiBFbGVtZW50JiZNKGEsaCl9KTt2b2lkIDAhPT1tZSYmTChiLFwicmVtb3ZlXCIsZnVuY3Rpb24oKXt2YXIgYj1KKHRoaXMpO21lLmNhbGwodGhpcyk7YiYmTihhLHRoaXMpfSl9O2Z1bmN0aW9uIHhlKCl7dmFyIGE9c2U7ZnVuY3Rpb24gYihiLGMpe09iamVjdC5kZWZpbmVQcm9wZXJ0eShiLFwiaW5uZXJIVE1MXCIse2VudW1lcmFibGU6Yy5lbnVtZXJhYmxlLGNvbmZpZ3VyYWJsZTohMCxnZXQ6Yy5nZXQsc2V0OmZ1bmN0aW9uKGIpe3ZhciBkPXRoaXMsZT12b2lkIDA7Sih0aGlzKSYmKGU9W10sSyh0aGlzLGZ1bmN0aW9uKGEpe2EhPT1kJiZlLnB1c2goYSl9KSk7Yy5zZXQuY2FsbCh0aGlzLGIpO2lmKGUpZm9yKHZhciBmPTA7ZjxlLmxlbmd0aDtmKyspe3ZhciBsPWVbZl07MT09PWwuX19DRV9zdGF0ZSYmYS5kaXNjb25uZWN0ZWRDYWxsYmFjayhsKX10aGlzLm93bmVyRG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeT9PKGEsdGhpcyk6R2QoYSx0aGlzKTtyZXR1cm4gYn19KX1mdW5jdGlvbiBjKGIsYyl7TChiLFwiaW5zZXJ0QWRqYWNlbnRFbGVtZW50XCIsZnVuY3Rpb24oYixkKXt2YXIgZT1KKGQpO2I9Yy5jYWxsKHRoaXMsYixkKTtlJiZOKGEsZCk7SihiKSYmTShhLGQpO1xucmV0dXJuIGJ9KX1aZCYmTChFbGVtZW50LnByb3RvdHlwZSxcImF0dGFjaFNoYWRvd1wiLGZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLl9fQ0Vfc2hhZG93Um9vdD1hPVpkLmNhbGwodGhpcyxhKX0pOyRkJiYkZC5nZXQ/YihFbGVtZW50LnByb3RvdHlwZSwkZCk6b2UmJm9lLmdldD9iKEhUTUxFbGVtZW50LnByb3RvdHlwZSxvZSk6RmQoYSxmdW5jdGlvbihhKXtiKGEse2VudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVybiBUZC5jYWxsKHRoaXMsITApLmlubmVySFRNTH0sc2V0OmZ1bmN0aW9uKGEpe3ZhciBiPVwidGVtcGxhdGVcIj09PXRoaXMubG9jYWxOYW1lLGM9Yj90aGlzLmNvbnRlbnQ6dGhpcyxkPU1kLmNhbGwoZG9jdW1lbnQsdGhpcy5sb2NhbE5hbWUpO2ZvcihkLmlubmVySFRNTD1hOzA8Yy5jaGlsZE5vZGVzLmxlbmd0aDspV2QuY2FsbChjLGMuY2hpbGROb2Rlc1swXSk7Zm9yKGE9Yj9kLmNvbnRlbnQ6ZDswPGEuY2hpbGROb2Rlcy5sZW5ndGg7KVVkLmNhbGwoYyxcbmEuY2hpbGROb2Rlc1swXSl9fSl9KTtMKEVsZW1lbnQucHJvdG90eXBlLFwic2V0QXR0cmlidXRlXCIsZnVuY3Rpb24oYixjKXtpZigxIT09dGhpcy5fX0NFX3N0YXRlKXJldHVybiBiZS5jYWxsKHRoaXMsYixjKTt2YXIgZD1hZS5jYWxsKHRoaXMsYik7YmUuY2FsbCh0aGlzLGIsYyk7Yz1hZS5jYWxsKHRoaXMsYik7YS5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sodGhpcyxiLGQsYyxudWxsKX0pO0woRWxlbWVudC5wcm90b3R5cGUsXCJzZXRBdHRyaWJ1dGVOU1wiLGZ1bmN0aW9uKGIsYyxmKXtpZigxIT09dGhpcy5fX0NFX3N0YXRlKXJldHVybiBlZS5jYWxsKHRoaXMsYixjLGYpO3ZhciBkPWRlLmNhbGwodGhpcyxiLGMpO2VlLmNhbGwodGhpcyxiLGMsZik7Zj1kZS5jYWxsKHRoaXMsYixjKTthLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLGMsZCxmLGIpfSk7TChFbGVtZW50LnByb3RvdHlwZSxcInJlbW92ZUF0dHJpYnV0ZVwiLGZ1bmN0aW9uKGIpe2lmKDEhPT10aGlzLl9fQ0Vfc3RhdGUpcmV0dXJuIGNlLmNhbGwodGhpcyxcbmIpO3ZhciBjPWFlLmNhbGwodGhpcyxiKTtjZS5jYWxsKHRoaXMsYik7bnVsbCE9PWMmJmEuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsYixjLG51bGwsbnVsbCl9KTtMKEVsZW1lbnQucHJvdG90eXBlLFwicmVtb3ZlQXR0cmlidXRlTlNcIixmdW5jdGlvbihiLGMpe2lmKDEhPT10aGlzLl9fQ0Vfc3RhdGUpcmV0dXJuIGZlLmNhbGwodGhpcyxiLGMpO3ZhciBkPWRlLmNhbGwodGhpcyxiLGMpO2ZlLmNhbGwodGhpcyxiLGMpO3ZhciBlPWRlLmNhbGwodGhpcyxiLGMpO2QhPT1lJiZhLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLGMsZCxlLGIpfSk7cGU/YyhIVE1MRWxlbWVudC5wcm90b3R5cGUscGUpOmdlP2MoRWxlbWVudC5wcm90b3R5cGUsZ2UpOmNvbnNvbGUud2FybihcIkN1c3RvbSBFbGVtZW50czogYEVsZW1lbnQjaW5zZXJ0QWRqYWNlbnRFbGVtZW50YCB3YXMgbm90IHBhdGNoZWQuXCIpO3RlKGEsRWxlbWVudC5wcm90b3R5cGUse1g6aGUsYXBwZW5kOmllfSk7d2UoYSl9XG47dmFyIHllPXdpbmRvdy5jdXN0b21FbGVtZW50cztpZigheWV8fHllLmZvcmNlUG9seWZpbGx8fFwiZnVuY3Rpb25cIiE9dHlwZW9mIHllLmRlZmluZXx8XCJmdW5jdGlvblwiIT10eXBlb2YgeWUuZ2V0KXt2YXIgc2U9bmV3IERkO3JlKCk7dWUoKTt0ZShzZSxEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSx7WDpSZCxhcHBlbmQ6U2R9KTt2ZSgpO3hlKCk7ZG9jdW1lbnQuX19DRV9oYXNSZWdpc3RyeT0hMDt2YXIgY3VzdG9tRWxlbWVudHM9bmV3IFAoc2UpO09iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csXCJjdXN0b21FbGVtZW50c1wiLHtjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCx2YWx1ZTpjdXN0b21FbGVtZW50c30pfTtmdW5jdGlvbiB6ZSgpe3RoaXMuZW5kPXRoaXMuc3RhcnQ9MDt0aGlzLnJ1bGVzPXRoaXMucGFyZW50PXRoaXMucHJldmlvdXM9bnVsbDt0aGlzLmNzc1RleHQ9dGhpcy5wYXJzZWRDc3NUZXh0PVwiXCI7dGhpcy5hdFJ1bGU9ITE7dGhpcy50eXBlPTA7dGhpcy5wYXJzZWRTZWxlY3Rvcj10aGlzLnNlbGVjdG9yPXRoaXMua2V5ZnJhbWVzTmFtZT1cIlwifVxuZnVuY3Rpb24gQWUoYSl7YT1hLnJlcGxhY2UoQmUsXCJcIikucmVwbGFjZShDZSxcIlwiKTt2YXIgYj1EZSxjPWEsZD1uZXcgemU7ZC5zdGFydD0wO2QuZW5kPWMubGVuZ3RoO2Zvcih2YXIgZT1kLGY9MCxoPWMubGVuZ3RoO2Y8aDtmKyspaWYoXCJ7XCI9PT1jW2ZdKXtlLnJ1bGVzfHwoZS5ydWxlcz1bXSk7dmFyIGc9ZSxrPWcucnVsZXNbZy5ydWxlcy5sZW5ndGgtMV18fG51bGw7ZT1uZXcgemU7ZS5zdGFydD1mKzE7ZS5wYXJlbnQ9ZztlLnByZXZpb3VzPWs7Zy5ydWxlcy5wdXNoKGUpfWVsc2VcIn1cIj09PWNbZl0mJihlLmVuZD1mKzEsZT1lLnBhcmVudHx8ZCk7cmV0dXJuIGIoZCxhKX1cbmZ1bmN0aW9uIERlKGEsYil7dmFyIGM9Yi5zdWJzdHJpbmcoYS5zdGFydCxhLmVuZC0xKTthLnBhcnNlZENzc1RleHQ9YS5jc3NUZXh0PWMudHJpbSgpO2EucGFyZW50JiYoYz1iLnN1YnN0cmluZyhhLnByZXZpb3VzP2EucHJldmlvdXMuZW5kOmEucGFyZW50LnN0YXJ0LGEuc3RhcnQtMSksYz1FZShjKSxjPWMucmVwbGFjZShGZSxcIiBcIiksYz1jLnN1YnN0cmluZyhjLmxhc3RJbmRleE9mKFwiO1wiKSsxKSxjPWEucGFyc2VkU2VsZWN0b3I9YS5zZWxlY3Rvcj1jLnRyaW0oKSxhLmF0UnVsZT0wPT09Yy5pbmRleE9mKFwiQFwiKSxhLmF0UnVsZT8wPT09Yy5pbmRleE9mKFwiQG1lZGlhXCIpP2EudHlwZT1KZTpjLm1hdGNoKEtlKSYmKGEudHlwZT1MZSxhLmtleWZyYW1lc05hbWU9YS5zZWxlY3Rvci5zcGxpdChGZSkucG9wKCkpOmEudHlwZT0wPT09Yy5pbmRleE9mKFwiLS1cIik/TWU6TmUpO2lmKGM9YS5ydWxlcylmb3IodmFyIGQ9MCxlPWMubGVuZ3RoLGY7ZDxlJiYoZj1jW2RdKTtkKyspRGUoZixcbmIpO3JldHVybiBhfWZ1bmN0aW9uIEVlKGEpe3JldHVybiBhLnJlcGxhY2UoL1xcXFwoWzAtOWEtZl17MSw2fSlcXHMvZ2ksZnVuY3Rpb24oYSxjKXthPWM7Zm9yKGM9Ni1hLmxlbmd0aDtjLS07KWE9XCIwXCIrYTtyZXR1cm5cIlxcXFxcIithfSl9XG5mdW5jdGlvbiBPZShhLGIsYyl7Yz12b2lkIDA9PT1jP1wiXCI6Yzt2YXIgZD1cIlwiO2lmKGEuY3NzVGV4dHx8YS5ydWxlcyl7dmFyIGU9YS5ydWxlcyxmO2lmKGY9ZSlmPWVbMF0sZj0hKGYmJmYuc2VsZWN0b3ImJjA9PT1mLnNlbGVjdG9yLmluZGV4T2YoXCItLVwiKSk7aWYoZil7Zj0wO2Zvcih2YXIgaD1lLmxlbmd0aCxnO2Y8aCYmKGc9ZVtmXSk7ZisrKWQ9T2UoZyxiLGQpfWVsc2UgYj9iPWEuY3NzVGV4dDooYj1hLmNzc1RleHQsYj1iLnJlcGxhY2UoUGUsXCJcIikucmVwbGFjZShRZSxcIlwiKSxiPWIucmVwbGFjZShSZSxcIlwiKS5yZXBsYWNlKFNlLFwiXCIpKSwoZD1iLnRyaW0oKSkmJihkPVwiICBcIitkK1wiXFxuXCIpfWQmJihhLnNlbGVjdG9yJiYoYys9YS5zZWxlY3RvcitcIiB7XFxuXCIpLGMrPWQsYS5zZWxlY3RvciYmKGMrPVwifVxcblxcblwiKSk7cmV0dXJuIGN9XG52YXIgTmU9MSxMZT03LEplPTQsTWU9MUUzLEJlPS9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9naW0sQ2U9L0BpbXBvcnRbXjtdKjsvZ2ltLFBlPS8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/KD86WztcXG5dfCQpL2dpbSxRZT0vKD86XlteO1xcLVxcc31dKyk/LS1bXjt7fV0qPzpbXnt9O10qP3tbXn1dKj99KD86WztcXG5dfCQpPy9naW0sUmU9L0BhcHBseVxccypcXCg/W14pO10qXFwpP1xccyooPzpbO1xcbl18JCk/L2dpbSxTZT0vW147Ol0qPzpbXjtdKj92YXJcXChbXjtdKlxcKSg/Ols7XFxuXXwkKT8vZ2ltLEtlPS9eQFteXFxzXSprZXlmcmFtZXMvLEZlPS9cXHMrL2c7dmFyIFE9ISh3aW5kb3cuU2hhZHlET00mJndpbmRvdy5TaGFkeURPTS5pblVzZSksVGU7ZnVuY3Rpb24gVWUoYSl7VGU9YSYmYS5zaGltY3NzcHJvcGVydGllcz8hMTpRfHwhKG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvNjAxfEVkZ2VcXC8xNS8pfHwhd2luZG93LkNTU3x8IUNTUy5zdXBwb3J0c3x8IUNTUy5zdXBwb3J0cyhcImJveC1zaGFkb3dcIixcIjAgMCAwIHZhcigtLWZvbylcIikpfXdpbmRvdy5TaGFkeUNTUyYmdm9pZCAwIT09d2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcz9UZT13aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzOndpbmRvdy5TaGFkeUNTUz8oVWUod2luZG93LlNoYWR5Q1NTKSx3aW5kb3cuU2hhZHlDU1M9dm9pZCAwKTpVZSh3aW5kb3cuV2ViQ29tcG9uZW50cyYmd2luZG93LldlYkNvbXBvbmVudHMuZmxhZ3MpO3ZhciBSPVRlO3ZhciBWZT0vKD86XnxbO1xcc3tdXFxzKikoLS1bXFx3LV0qPylcXHMqOlxccyooPzooKD86Jyg/OlxcXFwnfC4pKj8nfFwiKD86XFxcXFwifC4pKj9cInxcXChbXildKj9cXCl8W159O3tdKSspfFxceyhbXn1dKilcXH0oPzooPz1bO1xcc31dKXwkKSkvZ2ksV2U9Lyg/Ol58XFxXKylAYXBwbHlcXHMqXFwoPyhbXik7XFxuXSopXFwpPy9naSxYZT0vKC0tW1xcdy1dKylcXHMqKFs6LDspXXwkKS9naSxZZT0vKGFuaW1hdGlvblxccyo6KXwoYW5pbWF0aW9uLW5hbWVcXHMqOikvLFplPS9AbWVkaWFcXHMoLiopLywkZT0vXFx7W159XSpcXH0vZzt2YXIgYWY9bmV3IFNldDtmdW5jdGlvbiBiZihhLGIpe2lmKCFhKXJldHVyblwiXCI7XCJzdHJpbmdcIj09PXR5cGVvZiBhJiYoYT1BZShhKSk7YiYmY2YoYSxiKTtyZXR1cm4gT2UoYSxSKX1mdW5jdGlvbiBkZihhKXshYS5fX2Nzc1J1bGVzJiZhLnRleHRDb250ZW50JiYoYS5fX2Nzc1J1bGVzPUFlKGEudGV4dENvbnRlbnQpKTtyZXR1cm4gYS5fX2Nzc1J1bGVzfHxudWxsfWZ1bmN0aW9uIGVmKGEpe3JldHVybiEhYS5wYXJlbnQmJmEucGFyZW50LnR5cGU9PT1MZX1mdW5jdGlvbiBjZihhLGIsYyxkKXtpZihhKXt2YXIgZT0hMSxmPWEudHlwZTtpZihkJiZmPT09SmUpe3ZhciBoPWEuc2VsZWN0b3IubWF0Y2goWmUpO2gmJih3aW5kb3cubWF0Y2hNZWRpYShoWzFdKS5tYXRjaGVzfHwoZT0hMCkpfWY9PT1OZT9iKGEpOmMmJmY9PT1MZT9jKGEpOmY9PT1NZSYmKGU9ITApO2lmKChhPWEucnVsZXMpJiYhZSl7ZT0wO2Y9YS5sZW5ndGg7Zm9yKHZhciBnO2U8ZiYmKGc9YVtlXSk7ZSsrKWNmKGcsYixjLGQpfX19XG5mdW5jdGlvbiBmZihhLGIsYyxkKXt2YXIgZT1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7YiYmZS5zZXRBdHRyaWJ1dGUoXCJzY29wZVwiLGIpO2UudGV4dENvbnRlbnQ9YTtnZihlLGMsZCk7cmV0dXJuIGV9dmFyIFM9bnVsbDtmdW5jdGlvbiBnZihhLGIsYyl7Yj1ifHxkb2N1bWVudC5oZWFkO2IuaW5zZXJ0QmVmb3JlKGEsYyYmYy5uZXh0U2libGluZ3x8Yi5maXJzdENoaWxkKTtTP2EuY29tcGFyZURvY3VtZW50UG9zaXRpb24oUyk9PT1Ob2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORyYmKFM9YSk6Uz1hfVxuZnVuY3Rpb24gaGYoYSxiKXt2YXIgYz1hLmluZGV4T2YoXCJ2YXIoXCIpO2lmKC0xPT09YylyZXR1cm4gYihhLFwiXCIsXCJcIixcIlwiKTthOnt2YXIgZD0wO3ZhciBlPWMrMztmb3IodmFyIGY9YS5sZW5ndGg7ZTxmO2UrKylpZihcIihcIj09PWFbZV0pZCsrO2Vsc2UgaWYoXCIpXCI9PT1hW2VdJiYwPT09LS1kKWJyZWFrIGE7ZT0tMX1kPWEuc3Vic3RyaW5nKGMrNCxlKTtjPWEuc3Vic3RyaW5nKDAsYyk7YT1oZihhLnN1YnN0cmluZyhlKzEpLGIpO2U9ZC5pbmRleE9mKFwiLFwiKTtyZXR1cm4tMT09PWU/YihjLGQudHJpbSgpLFwiXCIsYSk6YihjLGQuc3Vic3RyaW5nKDAsZSkudHJpbSgpLGQuc3Vic3RyaW5nKGUrMSkudHJpbSgpLGEpfWZ1bmN0aW9uIGpmKGEsYil7UT9hLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsYik6d2luZG93LlNoYWR5RE9NLm5hdGl2ZU1ldGhvZHMuc2V0QXR0cmlidXRlLmNhbGwoYSxcImNsYXNzXCIsYil9XG5mdW5jdGlvbiBWKGEpe3ZhciBiPWEubG9jYWxOYW1lLGM9XCJcIjtiPy0xPGIuaW5kZXhPZihcIi1cIil8fChjPWIsYj1hLmdldEF0dHJpYnV0ZSYmYS5nZXRBdHRyaWJ1dGUoXCJpc1wiKXx8XCJcIik6KGI9YS5pcyxjPWEuZXh0ZW5kcyk7cmV0dXJue2lzOmIsUDpjfX07ZnVuY3Rpb24ga2YoKXt9ZnVuY3Rpb24gbGYoYSxiLGMpe3ZhciBkPVc7YS5fX3N0eWxlU2NvcGVkP2EuX19zdHlsZVNjb3BlZD1udWxsOm1mKGQsYSxifHxcIlwiLGMpfWZ1bmN0aW9uIG1mKGEsYixjLGQpe2Iubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSYmbmYoYixjLGQpO2lmKGI9XCJ0ZW1wbGF0ZVwiPT09Yi5sb2NhbE5hbWU/KGIuY29udGVudHx8Yi5nYikuY2hpbGROb2RlczpiLmNoaWxkcmVufHxiLmNoaWxkTm9kZXMpZm9yKHZhciBlPTA7ZTxiLmxlbmd0aDtlKyspbWYoYSxiW2VdLGMsZCl9XG5mdW5jdGlvbiBuZihhLGIsYyl7aWYoYilpZihhLmNsYXNzTGlzdCljPyhhLmNsYXNzTGlzdC5yZW1vdmUoXCJzdHlsZS1zY29wZVwiKSxhLmNsYXNzTGlzdC5yZW1vdmUoYikpOihhLmNsYXNzTGlzdC5hZGQoXCJzdHlsZS1zY29wZVwiKSxhLmNsYXNzTGlzdC5hZGQoYikpO2Vsc2UgaWYoYS5nZXRBdHRyaWJ1dGUpe3ZhciBkPWEuZ2V0QXR0cmlidXRlKG9mKTtjP2QmJihiPWQucmVwbGFjZShcInN0eWxlLXNjb3BlXCIsXCJcIikucmVwbGFjZShiLFwiXCIpLGpmKGEsYikpOmpmKGEsKGQ/ZCtcIiBcIjpcIlwiKStcInN0eWxlLXNjb3BlIFwiK2IpfX1mdW5jdGlvbiBwZihhLGIsYyl7dmFyIGQ9VyxlPWEuX19jc3NCdWlsZDtRfHxcInNoYWR5XCI9PT1lP2I9YmYoYixjKTooYT1WKGEpLGI9cWYoZCxiLGEuaXMsYS5QLGMpK1wiXFxuXFxuXCIpO3JldHVybiBiLnRyaW0oKX1cbmZ1bmN0aW9uIHFmKGEsYixjLGQsZSl7dmFyIGY9cmYoYyxkKTtjPWM/c2YrYzpcIlwiO3JldHVybiBiZihiLGZ1bmN0aW9uKGIpe2IuY3x8KGIuc2VsZWN0b3I9Yi5tPXRmKGEsYixhLmIsYyxmKSxiLmM9ITApO2UmJmUoYixjLGYpfSl9ZnVuY3Rpb24gcmYoYSxiKXtyZXR1cm4gYj9cIltpcz1cIithK1wiXVwiOmF9ZnVuY3Rpb24gdGYoYSxiLGMsZCxlKXt2YXIgZj1iLnNlbGVjdG9yLnNwbGl0KHVmKTtpZighZWYoYikpe2I9MDtmb3IodmFyIGg9Zi5sZW5ndGgsZztiPGgmJihnPWZbYl0pO2IrKylmW2JdPWMuY2FsbChhLGcsZCxlKX1yZXR1cm4gZi5qb2luKHVmKX1mdW5jdGlvbiB2ZihhKXtyZXR1cm4gYS5yZXBsYWNlKHdmLGZ1bmN0aW9uKGEsYyxkKXstMTxkLmluZGV4T2YoXCIrXCIpP2Q9ZC5yZXBsYWNlKC9cXCsvZyxcIl9fX1wiKTotMTxkLmluZGV4T2YoXCJfX19cIikmJihkPWQucmVwbGFjZSgvX19fL2csXCIrXCIpKTtyZXR1cm5cIjpcIitjK1wiKFwiK2QrXCIpXCJ9KX1cbmtmLnByb3RvdHlwZS5iPWZ1bmN0aW9uKGEsYixjKXt2YXIgZD0hMTthPWEudHJpbSgpO3ZhciBlPXdmLnRlc3QoYSk7ZSYmKGE9YS5yZXBsYWNlKHdmLGZ1bmN0aW9uKGEsYixjKXtyZXR1cm5cIjpcIitiK1wiKFwiK2MucmVwbGFjZSgvXFxzL2csXCJcIikrXCIpXCJ9KSxhPXZmKGEpKTthPWEucmVwbGFjZSh4Zix5ZitcIiAkMVwiKTthPWEucmVwbGFjZSh6ZixmdW5jdGlvbihhLGUsZyl7ZHx8KGE9QWYoZyxlLGIsYyksZD1kfHxhLnN0b3AsZT1hLkphLGc9YS52YWx1ZSk7cmV0dXJuIGUrZ30pO2UmJihhPXZmKGEpKTtyZXR1cm4gYX07XG5mdW5jdGlvbiBBZihhLGIsYyxkKXt2YXIgZT1hLmluZGV4T2YoQmYpOzA8PWEuaW5kZXhPZih5Zik/YT1DZihhLGQpOjAhPT1lJiYoYT1jP0RmKGEsYyk6YSk7Yz0hMTswPD1lJiYoYj1cIlwiLGM9ITApO2lmKGMpe3ZhciBmPSEwO2MmJihhPWEucmVwbGFjZShFZixmdW5jdGlvbihhLGIpe3JldHVyblwiID4gXCIrYn0pKX1hPWEucmVwbGFjZShGZixmdW5jdGlvbihhLGIsYyl7cmV0dXJuJ1tkaXI9XCInK2MrJ1wiXSAnK2IrXCIsIFwiK2IrJ1tkaXI9XCInK2MrJ1wiXSd9KTtyZXR1cm57dmFsdWU6YSxKYTpiLHN0b3A6Zn19ZnVuY3Rpb24gRGYoYSxiKXthPWEuc3BsaXQoR2YpO2FbMF0rPWI7cmV0dXJuIGEuam9pbihHZil9XG5mdW5jdGlvbiBDZihhLGIpe3ZhciBjPWEubWF0Y2goSGYpO3JldHVybihjPWMmJmNbMl0udHJpbSgpfHxcIlwiKT9jWzBdLm1hdGNoKElmKT9hLnJlcGxhY2UoSGYsZnVuY3Rpb24oYSxjLGYpe3JldHVybiBiK2Z9KTpjLnNwbGl0KElmKVswXT09PWI/YzpKZjphLnJlcGxhY2UoeWYsYil9ZnVuY3Rpb24gS2YoYSl7YS5zZWxlY3Rvcj09PUxmJiYoYS5zZWxlY3Rvcj1cImh0bWxcIil9a2YucHJvdG90eXBlLmM9ZnVuY3Rpb24oYSl7cmV0dXJuIGEubWF0Y2goQmYpP3RoaXMuYihhLE1mKTpEZihhLnRyaW0oKSxNZil9O3EuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoa2YucHJvdG90eXBlLHthOntjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm5cInN0eWxlLXNjb3BlXCJ9fX0pO1xudmFyIHdmPS86KG50aFstXFx3XSspXFwoKFteKV0rKVxcKS8sTWY9XCI6bm90KC5zdHlsZS1zY29wZSlcIix1Zj1cIixcIix6Zj0vKF58W1xccz4rfl0rKSgoPzpcXFsuKz9cXF18W15cXHM+K349W10pKykvZyxJZj0vW1suOiMqXS8seWY9XCI6aG9zdFwiLExmPVwiOnJvb3RcIixCZj1cIjo6c2xvdHRlZFwiLHhmPW5ldyBSZWdFeHAoXCJeKFwiK0JmK1wiKVwiKSxIZj0vKDpob3N0KSg/OlxcKCgoPzpcXChbXikoXSpcXCl8W14pKF0qKSs/KVxcKSkvLEVmPS8oPzo6OnNsb3R0ZWQpKD86XFwoKCg/OlxcKFteKShdKlxcKXxbXikoXSopKz8pXFwpKS8sRmY9LyguKik6ZGlyXFwoKD86KGx0cnxydGwpKVxcKS8sc2Y9XCIuXCIsR2Y9XCI6XCIsb2Y9XCJjbGFzc1wiLEpmPVwic2hvdWxkX25vdF9tYXRjaFwiLFc9bmV3IGtmO2Z1bmN0aW9uIE5mKGEsYixjLGQpe3RoaXMudz1hfHxudWxsO3RoaXMuYj1ifHxudWxsO3RoaXMuamE9Y3x8W107dGhpcy5HPW51bGw7dGhpcy5QPWR8fFwiXCI7dGhpcy5hPXRoaXMudT10aGlzLkI9bnVsbH1mdW5jdGlvbiBYKGEpe3JldHVybiBhP2EuX19zdHlsZUluZm86bnVsbH1mdW5jdGlvbiBPZihhLGIpe3JldHVybiBhLl9fc3R5bGVJbmZvPWJ9TmYucHJvdG90eXBlLmM9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy53fTtOZi5wcm90b3R5cGUuX2dldFN0eWxlUnVsZXM9TmYucHJvdG90eXBlLmM7dmFyIFBmLFFmPXdpbmRvdy5FbGVtZW50LnByb3RvdHlwZTtQZj1RZi5tYXRjaGVzfHxRZi5tYXRjaGVzU2VsZWN0b3J8fFFmLm1vek1hdGNoZXNTZWxlY3Rvcnx8UWYubXNNYXRjaGVzU2VsZWN0b3J8fFFmLm9NYXRjaGVzU2VsZWN0b3J8fFFmLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjt2YXIgUmY9bmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChcIlRyaWRlbnRcIik7ZnVuY3Rpb24gU2YoKXt9ZnVuY3Rpb24gVGYoYSl7dmFyIGI9e30sYz1bXSxkPTA7Y2YoYSxmdW5jdGlvbihhKXtVZihhKTthLmluZGV4PWQrKzthPWEuaS5jc3NUZXh0O2Zvcih2YXIgYztjPVhlLmV4ZWMoYSk7KXt2YXIgZT1jWzFdO1wiOlwiIT09Y1syXSYmKGJbZV09ITApfX0sZnVuY3Rpb24oYSl7Yy5wdXNoKGEpfSk7YS5iPWM7YT1bXTtmb3IodmFyIGUgaW4gYilhLnB1c2goZSk7cmV0dXJuIGF9XG5mdW5jdGlvbiBVZihhKXtpZighYS5pKXt2YXIgYj17fSxjPXt9O1ZmKGEsYykmJihiLnY9YyxhLnJ1bGVzPW51bGwpO2IuY3NzVGV4dD1hLnBhcnNlZENzc1RleHQucmVwbGFjZSgkZSxcIlwiKS5yZXBsYWNlKFZlLFwiXCIpO2EuaT1ifX1mdW5jdGlvbiBWZihhLGIpe3ZhciBjPWEuaTtpZihjKXtpZihjLnYpcmV0dXJuIE9iamVjdC5hc3NpZ24oYixjLnYpLCEwfWVsc2V7Yz1hLnBhcnNlZENzc1RleHQ7Zm9yKHZhciBkO2E9VmUuZXhlYyhjKTspe2Q9KGFbMl18fGFbM10pLnRyaW0oKTtpZihcImluaGVyaXRcIiE9PWR8fFwidW5zZXRcIiE9PWQpYlthWzFdLnRyaW0oKV09ZDtkPSEwfXJldHVybiBkfX1cbmZ1bmN0aW9uIFdmKGEsYixjKXtiJiYoYj0wPD1iLmluZGV4T2YoXCI7XCIpP1hmKGEsYixjKTpoZihiLGZ1bmN0aW9uKGIsZSxmLGgpe2lmKCFlKXJldHVybiBiK2g7KGU9V2YoYSxjW2VdLGMpKSYmXCJpbml0aWFsXCIhPT1lP1wiYXBwbHktc2hpbS1pbmhlcml0XCI9PT1lJiYoZT1cImluaGVyaXRcIik6ZT1XZihhLGNbZl18fGYsYyl8fGY7cmV0dXJuIGIrKGV8fFwiXCIpK2h9KSk7cmV0dXJuIGImJmIudHJpbSgpfHxcIlwifVxuZnVuY3Rpb24gWGYoYSxiLGMpe2I9Yi5zcGxpdChcIjtcIik7Zm9yKHZhciBkPTAsZSxmO2Q8Yi5sZW5ndGg7ZCsrKWlmKGU9YltkXSl7V2UubGFzdEluZGV4PTA7aWYoZj1XZS5leGVjKGUpKWU9V2YoYSxjW2ZbMV1dLGMpO2Vsc2UgaWYoZj1lLmluZGV4T2YoXCI6XCIpLC0xIT09Zil7dmFyIGg9ZS5zdWJzdHJpbmcoZik7aD1oLnRyaW0oKTtoPVdmKGEsaCxjKXx8aDtlPWUuc3Vic3RyaW5nKDAsZikraH1iW2RdPWUmJmUubGFzdEluZGV4T2YoXCI7XCIpPT09ZS5sZW5ndGgtMT9lLnNsaWNlKDAsLTEpOmV8fFwiXCJ9cmV0dXJuIGIuam9pbihcIjtcIil9XG5mdW5jdGlvbiBZZihhLGIpe3ZhciBjPXt9LGQ9W107Y2YoYSxmdW5jdGlvbihhKXthLml8fFVmKGEpO3ZhciBlPWEubXx8YS5wYXJzZWRTZWxlY3RvcjtiJiZhLmkudiYmZSYmUGYuY2FsbChiLGUpJiYoVmYoYSxjKSxhPWEuaW5kZXgsZT1wYXJzZUludChhLzMyLDEwKSxkW2VdPShkW2VdfHwwKXwxPDxhJTMyKX0sbnVsbCwhMCk7cmV0dXJue3Y6YyxrZXk6ZH19XG5mdW5jdGlvbiBaZihhLGIsYyxkKXtiLml8fFVmKGIpO2lmKGIuaS52KXt2YXIgZT1WKGEpO2E9ZS5pcztlPWUuUDtlPWE/cmYoYSxlKTpcImh0bWxcIjt2YXIgZj1iLnBhcnNlZFNlbGVjdG9yLGg9XCI6aG9zdCA+ICpcIj09PWZ8fFwiaHRtbFwiPT09ZixnPTA9PT1mLmluZGV4T2YoXCI6aG9zdFwiKSYmIWg7XCJzaGFkeVwiPT09YyYmKGg9Zj09PWUrXCIgPiAqLlwiK2V8fC0xIT09Zi5pbmRleE9mKFwiaHRtbFwiKSxnPSFoJiYwPT09Zi5pbmRleE9mKGUpKTtcInNoYWRvd1wiPT09YyYmKGg9XCI6aG9zdCA+ICpcIj09PWZ8fFwiaHRtbFwiPT09ZixnPWcmJiFoKTtpZihofHxnKWM9ZSxnJiYoUSYmIWIubSYmKGIubT10ZihXLGIsVy5iLGE/c2YrYTpcIlwiLGUpKSxjPWIubXx8ZSksZCh7WGE6YyxPYTpnLGliOmh9KX19XG5mdW5jdGlvbiAkZihhLGIpe3ZhciBjPXt9LGQ9e30sZT1iJiZiLl9fY3NzQnVpbGQ7Y2YoYixmdW5jdGlvbihiKXtaZihhLGIsZSxmdW5jdGlvbihlKXtQZi5jYWxsKGEuaGJ8fGEsZS5YYSkmJihlLk9hP1ZmKGIsYyk6VmYoYixkKSl9KX0sbnVsbCwhMCk7cmV0dXJue1ZhOmQsTmE6Y319XG5mdW5jdGlvbiBhZyhhLGIsYyxkKXt2YXIgZT1WKGIpLGY9cmYoZS5pcyxlLlApLGg9bmV3IFJlZ0V4cChcIig/Ol58W14uI1s6XSlcIisoYi5leHRlbmRzP1wiXFxcXFwiK2Yuc2xpY2UoMCwtMSkrXCJcXFxcXVwiOmYpK1wiKCR8Wy46W1xcXFxzPit+XSlcIik7ZT1YKGIpLnc7dmFyIGc9YmcoZSxkKTtyZXR1cm4gcGYoYixlLGZ1bmN0aW9uKGIpe3ZhciBlPVwiXCI7Yi5pfHxVZihiKTtiLmkuY3NzVGV4dCYmKGU9WGYoYSxiLmkuY3NzVGV4dCxjKSk7Yi5jc3NUZXh0PWU7aWYoIVEmJiFlZihiKSYmYi5jc3NUZXh0KXt2YXIgaz1lPWIuY3NzVGV4dDtudWxsPT1iLnJhJiYoYi5yYT1ZZS50ZXN0KGUpKTtpZihiLnJhKWlmKG51bGw9PWIuVyl7Yi5XPVtdO2Zvcih2YXIgbiBpbiBnKWs9Z1tuXSxrPWsoZSksZSE9PWsmJihlPWssYi5XLnB1c2gobikpfWVsc2V7Zm9yKG49MDtuPGIuVy5sZW5ndGg7KytuKWs9Z1tiLldbbl1dLGU9ayhlKTtrPWV9Yi5jc3NUZXh0PWs7Yi5tPWIubXx8Yi5zZWxlY3RvcjtlPVwiLlwiK2Q7XG5uPWIubS5zcGxpdChcIixcIik7az0wO2Zvcih2YXIgdz1uLmxlbmd0aCxJO2s8dyYmKEk9bltrXSk7aysrKW5ba109SS5tYXRjaChoKT9JLnJlcGxhY2UoZixlKTplK1wiIFwiK0k7Yi5zZWxlY3Rvcj1uLmpvaW4oXCIsXCIpfX0pfWZ1bmN0aW9uIGJnKGEsYil7YT1hLmI7dmFyIGM9e307aWYoIVEmJmEpZm9yKHZhciBkPTAsZT1hW2RdO2Q8YS5sZW5ndGg7ZT1hWysrZF0pe3ZhciBmPWUsaD1iO2YuaD1uZXcgUmVnRXhwKGYua2V5ZnJhbWVzTmFtZSxcImdcIik7Zi5hPWYua2V5ZnJhbWVzTmFtZStcIi1cIitoO2YubT1mLm18fGYuc2VsZWN0b3I7Zi5zZWxlY3Rvcj1mLm0ucmVwbGFjZShmLmtleWZyYW1lc05hbWUsZi5hKTtjW2Uua2V5ZnJhbWVzTmFtZV09Y2coZSl9cmV0dXJuIGN9ZnVuY3Rpb24gY2coYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3JldHVybiBiLnJlcGxhY2UoYS5oLGEuYSl9fVxuZnVuY3Rpb24gZGcoYSxiKXt2YXIgYz1lZyxkPWRmKGEpO2EudGV4dENvbnRlbnQ9YmYoZCxmdW5jdGlvbihhKXt2YXIgZD1hLmNzc1RleHQ9YS5wYXJzZWRDc3NUZXh0O2EuaSYmYS5pLmNzc1RleHQmJihkPWQucmVwbGFjZShQZSxcIlwiKS5yZXBsYWNlKFFlLFwiXCIpLGEuY3NzVGV4dD1YZihjLGQsYikpfSl9cS5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhTZi5wcm90b3R5cGUse2E6e2NvbmZpZ3VyYWJsZTohMCxlbnVtZXJhYmxlOiEwLGdldDpmdW5jdGlvbigpe3JldHVyblwieC1zY29wZVwifX19KTt2YXIgZWc9bmV3IFNmO3ZhciBmZz17fSxnZz13aW5kb3cuY3VzdG9tRWxlbWVudHM7aWYoZ2cmJiFRKXt2YXIgaGc9Z2cuZGVmaW5lO2dnLmRlZmluZT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ9ZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIiBTaGFkeSBET00gc3R5bGVzIGZvciBcIithK1wiIFwiKSxlPWRvY3VtZW50LmhlYWQ7ZS5pbnNlcnRCZWZvcmUoZCwoUz9TLm5leHRTaWJsaW5nOm51bGwpfHxlLmZpcnN0Q2hpbGQpO1M9ZDtmZ1thXT1kO3JldHVybiBoZy5jYWxsKGdnLGEsYixjKX19O2Z1bmN0aW9uIGlnKCl7dGhpcy5jYWNoZT17fX1pZy5wcm90b3R5cGUuc3RvcmU9ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9dGhpcy5jYWNoZVthXXx8W107ZS5wdXNoKHt2OmIsc3R5bGVFbGVtZW50OmMsdTpkfSk7MTAwPGUubGVuZ3RoJiZlLnNoaWZ0KCk7dGhpcy5jYWNoZVthXT1lfTtpZy5wcm90b3R5cGUuZmV0Y2g9ZnVuY3Rpb24oYSxiLGMpe2lmKGE9dGhpcy5jYWNoZVthXSlmb3IodmFyIGQ9YS5sZW5ndGgtMTswPD1kO2QtLSl7dmFyIGU9YVtkXSxmO2E6e2ZvcihmPTA7ZjxjLmxlbmd0aDtmKyspe3ZhciBoPWNbZl07aWYoZS52W2hdIT09YltoXSl7Zj0hMTticmVhayBhfX1mPSEwfWlmKGYpcmV0dXJuIGV9fTtmdW5jdGlvbiBqZygpe31cbmZ1bmN0aW9uIGtnKGEpe2Zvcih2YXIgYj0wO2I8YS5sZW5ndGg7YisrKXt2YXIgYz1hW2JdO2lmKGMudGFyZ2V0IT09ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZjLnRhcmdldCE9PWRvY3VtZW50LmhlYWQpZm9yKHZhciBkPTA7ZDxjLmFkZGVkTm9kZXMubGVuZ3RoO2QrKyl7dmFyIGU9Yy5hZGRlZE5vZGVzW2RdO2lmKGUubm9kZVR5cGU9PT1Ob2RlLkVMRU1FTlRfTk9ERSl7dmFyIGY9ZS5nZXRSb290Tm9kZSgpO3ZhciBoPWU7dmFyIGc9W107aC5jbGFzc0xpc3Q/Zz1BcnJheS5mcm9tKGguY2xhc3NMaXN0KTpoIGluc3RhbmNlb2Ygd2luZG93LlNWR0VsZW1lbnQmJmguaGFzQXR0cmlidXRlKFwiY2xhc3NcIikmJihnPWguZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikuc3BsaXQoL1xccysvKSk7aD1nO2c9aC5pbmRleE9mKFcuYSk7aWYoKGg9LTE8Zz9oW2crMV06XCJcIikmJmY9PT1lLm93bmVyRG9jdW1lbnQpbGYoZSxoLCEwKTtlbHNlIGlmKGYubm9kZVR5cGU9PT1Ob2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUmJlxuKGY9Zi5ob3N0KSlpZihmPVYoZikuaXMsaD09PWYpZm9yKGU9d2luZG93LlNoYWR5RE9NLm5hdGl2ZU1ldGhvZHMucXVlcnlTZWxlY3RvckFsbC5jYWxsKGUsXCI6bm90KC5cIitXLmErXCIpXCIpLGY9MDtmPGUubGVuZ3RoO2YrKyluZihlW2ZdLGgpO2Vsc2UgaCYmbGYoZSxoLCEwKSxsZihlLGYpfX19fVxuaWYoIVEpe3ZhciBsZz1uZXcgTXV0YXRpb25PYnNlcnZlcihrZyksbWc9ZnVuY3Rpb24oYSl7bGcub2JzZXJ2ZShhLHtjaGlsZExpc3Q6ITAsc3VidHJlZTohMH0pfTtpZih3aW5kb3cuY3VzdG9tRWxlbWVudHMmJiF3aW5kb3cuY3VzdG9tRWxlbWVudHMucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayltZyhkb2N1bWVudCk7ZWxzZXt2YXIgbmc9ZnVuY3Rpb24oKXttZyhkb2N1bWVudC5ib2R5KX07d2luZG93LkhUTUxJbXBvcnRzP3dpbmRvdy5IVE1MSW1wb3J0cy53aGVuUmVhZHkobmcpOnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe2lmKFwibG9hZGluZ1wiPT09ZG9jdW1lbnQucmVhZHlTdGF0ZSl7dmFyIGE9ZnVuY3Rpb24oKXtuZygpO2RvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsYSl9O2RvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsYSl9ZWxzZSBuZygpfSl9amc9ZnVuY3Rpb24oKXtrZyhsZy50YWtlUmVjb3JkcygpKX19XG52YXIgb2c9amc7dmFyIHBnPXt9O3ZhciBxZz1Qcm9taXNlLnJlc29sdmUoKTtmdW5jdGlvbiByZyhhKXtpZihhPXBnW2FdKWEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uPWEuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9ufHwwLGEuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uPWEuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9ufHwwLGEuX2FwcGx5U2hpbU5leHRWZXJzaW9uPShhLl9hcHBseVNoaW1OZXh0VmVyc2lvbnx8MCkrMX1mdW5jdGlvbiBzZyhhKXtyZXR1cm4gYS5fYXBwbHlTaGltQ3VycmVudFZlcnNpb249PT1hLl9hcHBseVNoaW1OZXh0VmVyc2lvbn1mdW5jdGlvbiB0ZyhhKXthLl9hcHBseVNoaW1WYWxpZGF0aW5nVmVyc2lvbj1hLl9hcHBseVNoaW1OZXh0VmVyc2lvbjthLmJ8fChhLmI9ITAscWcudGhlbihmdW5jdGlvbigpe2EuX2FwcGx5U2hpbUN1cnJlbnRWZXJzaW9uPWEuX2FwcGx5U2hpbU5leHRWZXJzaW9uO2EuYj0hMX0pKX07dmFyIHVnPW51bGwsdmc9d2luZG93LkhUTUxJbXBvcnRzJiZ3aW5kb3cuSFRNTEltcG9ydHMud2hlblJlYWR5fHxudWxsLHdnO2Z1bmN0aW9uIHhnKGEpe3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe3ZnP3ZnKGEpOih1Z3x8KHVnPW5ldyBQcm9taXNlKGZ1bmN0aW9uKGEpe3dnPWF9KSxcImNvbXBsZXRlXCI9PT1kb2N1bWVudC5yZWFkeVN0YXRlP3dnKCk6ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIixmdW5jdGlvbigpe1wiY29tcGxldGVcIj09PWRvY3VtZW50LnJlYWR5U3RhdGUmJndnKCl9KSksdWcudGhlbihmdW5jdGlvbigpe2EmJmEoKX0pKX0pfTt2YXIgeWc9bmV3IGlnO2Z1bmN0aW9uIFkoKXt2YXIgYT10aGlzO3RoaXMuTD17fTt0aGlzLmM9ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O3ZhciBiPW5ldyB6ZTtiLnJ1bGVzPVtdO3RoaXMuaD1PZih0aGlzLmMsbmV3IE5mKGIpKTt0aGlzLm89ITE7dGhpcy5iPXRoaXMuYT1udWxsO3hnKGZ1bmN0aW9uKCl7emcoYSl9KX1wPVkucHJvdG90eXBlO3AueGE9ZnVuY3Rpb24oKXtvZygpfTtwLkxhPWZ1bmN0aW9uKGEpe3JldHVybiBkZihhKX07cC5aYT1mdW5jdGlvbihhKXtyZXR1cm4gYmYoYSl9O1xucC5wcmVwYXJlVGVtcGxhdGU9ZnVuY3Rpb24oYSxiLGMpe2lmKCFhLmgpe2EuaD0hMDthLm5hbWU9YjthLmV4dGVuZHM9YztwZ1tiXT1hO3ZhciBkPShkPWEuY29udGVudC5xdWVyeVNlbGVjdG9yKFwic3R5bGVcIikpP2QuZ2V0QXR0cmlidXRlKFwiY3NzLWJ1aWxkXCIpfHxcIlwiOlwiXCI7dmFyIGU9W107Zm9yKHZhciBmPWEuY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwic3R5bGVcIiksaD0wO2g8Zi5sZW5ndGg7aCsrKXt2YXIgZz1mW2hdO2lmKGcuaGFzQXR0cmlidXRlKFwic2hhZHktdW5zY29wZWRcIikpe2lmKCFRKXt2YXIgaz1nLnRleHRDb250ZW50O2FmLmhhcyhrKXx8KGFmLmFkZChrKSxrPWcuY2xvbmVOb2RlKCEwKSxkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGspKTtnLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZyl9fWVsc2UgZS5wdXNoKGcudGV4dENvbnRlbnQpLGcucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnKX1lPWUuam9pbihcIlwiKS50cmltKCk7Yz17aXM6YixleHRlbmRzOmMsZWI6ZH07XG5RfHxsZihhLmNvbnRlbnQsYik7emcodGhpcyk7Zj1XZS50ZXN0KGUpfHxWZS50ZXN0KGUpO1dlLmxhc3RJbmRleD0wO1ZlLmxhc3RJbmRleD0wO2U9QWUoZSk7ZiYmUiYmdGhpcy5hJiZ0aGlzLmEudHJhbnNmb3JtUnVsZXMoZSxiKTthLl9zdHlsZUFzdD1lO2Eubz1kO2Q9W107Unx8KGQ9VGYoYS5fc3R5bGVBc3QpKTtpZighZC5sZW5ndGh8fFIpZT1RP2EuY29udGVudDpudWxsLGI9ZmdbYl0sZj1wZihjLGEuX3N0eWxlQXN0KSxiPWYubGVuZ3RoP2ZmKGYsYy5pcyxlLGIpOnZvaWQgMCxhLmE9YjthLmM9ZH19O1xuZnVuY3Rpb24gQWcoYSl7IWEuYiYmd2luZG93LlNoYWR5Q1NTJiZ3aW5kb3cuU2hhZHlDU1MuQ3VzdG9tU3R5bGVJbnRlcmZhY2UmJihhLmI9d2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlLGEuYi50cmFuc2Zvcm1DYWxsYmFjaz1mdW5jdGlvbihiKXthLnZhKGIpfSxhLmIudmFsaWRhdGVDYWxsYmFjaz1mdW5jdGlvbigpe3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpeyhhLmIuZW5xdWV1ZWR8fGEubykmJmEuRigpfSl9KX1mdW5jdGlvbiB6ZyhhKXshYS5hJiZ3aW5kb3cuU2hhZHlDU1MmJndpbmRvdy5TaGFkeUNTUy5BcHBseVNoaW0mJihhLmE9d2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbSxhLmEuaW52YWxpZENhbGxiYWNrPXJnKTtBZyhhKX1cbnAuRj1mdW5jdGlvbigpe3pnKHRoaXMpO2lmKHRoaXMuYil7dmFyIGE9dGhpcy5iLnByb2Nlc3NTdHlsZXMoKTtpZih0aGlzLmIuZW5xdWV1ZWQpe2lmKFIpZm9yKHZhciBiPTA7YjxhLmxlbmd0aDtiKyspe3ZhciBjPXRoaXMuYi5nZXRTdHlsZUZvckN1c3RvbVN0eWxlKGFbYl0pO2lmKGMmJlImJnRoaXMuYSl7dmFyIGQ9ZGYoYyk7emcodGhpcyk7dGhpcy5hLnRyYW5zZm9ybVJ1bGVzKGQpO2MudGV4dENvbnRlbnQ9YmYoZCl9fWVsc2UgZm9yKEJnKHRoaXMsdGhpcy5jLHRoaXMuaCksYj0wO2I8YS5sZW5ndGg7YisrKShjPXRoaXMuYi5nZXRTdHlsZUZvckN1c3RvbVN0eWxlKGFbYl0pKSYmZGcoYyx0aGlzLmguQik7dGhpcy5iLmVucXVldWVkPSExO3RoaXMubyYmIVImJnRoaXMuc3R5bGVEb2N1bWVudCgpfX19O1xucC5zdHlsZUVsZW1lbnQ9ZnVuY3Rpb24oYSxiKXt2YXIgYz1WKGEpLmlzLGQ9WChhKTtpZighZCl7dmFyIGU9VihhKTtkPWUuaXM7ZT1lLlA7dmFyIGY9ZmdbZF07ZD1wZ1tkXTtpZihkKXt2YXIgaD1kLl9zdHlsZUFzdDt2YXIgZz1kLmN9ZD1PZihhLG5ldyBOZihoLGYsZyxlKSl9YSE9PXRoaXMuYyYmKHRoaXMubz0hMCk7YiYmKGQuRz1kLkd8fHt9LE9iamVjdC5hc3NpZ24oZC5HLGIpKTtpZihSKXtpZihkLkcpe2I9ZC5HO2Zvcih2YXIgayBpbiBiKW51bGw9PT1rP2Euc3R5bGUucmVtb3ZlUHJvcGVydHkoayk6YS5zdHlsZS5zZXRQcm9wZXJ0eShrLGJba10pfWlmKCgoaz1wZ1tjXSl8fGE9PT10aGlzLmMpJiZrJiZrLmEmJiFzZyhrKSl7aWYoc2coayl8fGsuX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uIT09ay5fYXBwbHlTaGltTmV4dFZlcnNpb24pemcodGhpcyksdGhpcy5hJiZ0aGlzLmEudHJhbnNmb3JtUnVsZXMoay5fc3R5bGVBc3QsYyksay5hLnRleHRDb250ZW50PXBmKGEsXG5kLncpLHRnKGspO1EmJihjPWEuc2hhZG93Um9vdCkmJihjLnF1ZXJ5U2VsZWN0b3IoXCJzdHlsZVwiKS50ZXh0Q29udGVudD1wZihhLGQudykpO2Qudz1rLl9zdHlsZUFzdH19ZWxzZSBpZihCZyh0aGlzLGEsZCksZC5qYSYmZC5qYS5sZW5ndGgpe2M9ZDtrPVYoYSkuaXM7ZD0oYj15Zy5mZXRjaChrLGMuQixjLmphKSk/Yi5zdHlsZUVsZW1lbnQ6bnVsbDtoPWMudTsoZz1iJiZiLnUpfHwoZz10aGlzLkxba109KHRoaXMuTFtrXXx8MCkrMSxnPWsrXCItXCIrZyk7Yy51PWc7Zz1jLnU7ZT1lZztlPWQ/ZC50ZXh0Q29udGVudHx8XCJcIjphZyhlLGEsYy5CLGcpO2Y9WChhKTt2YXIgbD1mLmE7bCYmIVEmJmwhPT1kJiYobC5fdXNlQ291bnQtLSwwPj1sLl91c2VDb3VudCYmbC5wYXJlbnROb2RlJiZsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobCkpO1E/Zi5hPyhmLmEudGV4dENvbnRlbnQ9ZSxkPWYuYSk6ZSYmKGQ9ZmYoZSxnLGEuc2hhZG93Um9vdCxmLmIpKTpkP2QucGFyZW50Tm9kZXx8KFJmJiZcbi0xPGUuaW5kZXhPZihcIkBtZWRpYVwiKSYmKGQudGV4dENvbnRlbnQ9ZSksZ2YoZCxudWxsLGYuYikpOmUmJihkPWZmKGUsZyxudWxsLGYuYikpO2QmJihkLl91c2VDb3VudD1kLl91c2VDb3VudHx8MCxmLmEhPWQmJmQuX3VzZUNvdW50KyssZi5hPWQpO2c9ZDtRfHwoZD1jLnUsZj1lPWEuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIil8fFwiXCIsaCYmKGY9ZS5yZXBsYWNlKG5ldyBSZWdFeHAoXCJcXFxccyp4LXNjb3BlXFxcXHMqXCIraCtcIlxcXFxzKlwiLFwiZ1wiKSxcIiBcIikpLGYrPShmP1wiIFwiOlwiXCIpK1wieC1zY29wZSBcIitkLGUhPT1mJiZqZihhLGYpKTtifHx5Zy5zdG9yZShrLGMuQixnLGMudSl9fTtmdW5jdGlvbiBDZyhhLGIpe3JldHVybihiPWIuZ2V0Um9vdE5vZGUoKS5ob3N0KT9YKGIpP2I6Q2coYSxiKTphLmN9XG5mdW5jdGlvbiBCZyhhLGIsYyl7YT1DZyhhLGIpO3ZhciBkPVgoYSk7YT1PYmplY3QuY3JlYXRlKGQuQnx8bnVsbCk7dmFyIGU9JGYoYixjLncpO2I9WWYoZC53LGIpLnY7T2JqZWN0LmFzc2lnbihhLGUuTmEsYixlLlZhKTtiPWMuRztmb3IodmFyIGYgaW4gYilpZigoZT1iW2ZdKXx8MD09PWUpYVtmXT1lO2Y9ZWc7Yj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhKTtmb3IoZT0wO2U8Yi5sZW5ndGg7ZSsrKWQ9YltlXSxhW2RdPVdmKGYsYVtkXSxhKTtjLkI9YX1wLnN0eWxlRG9jdW1lbnQ9ZnVuY3Rpb24oYSl7dGhpcy5zdHlsZVN1YnRyZWUodGhpcy5jLGEpfTtcbnAuc3R5bGVTdWJ0cmVlPWZ1bmN0aW9uKGEsYil7dmFyIGM9YS5zaGFkb3dSb290OyhjfHxhPT09dGhpcy5jKSYmdGhpcy5zdHlsZUVsZW1lbnQoYSxiKTtpZihiPWMmJihjLmNoaWxkcmVufHxjLmNoaWxkTm9kZXMpKWZvcihhPTA7YTxiLmxlbmd0aDthKyspdGhpcy5zdHlsZVN1YnRyZWUoYlthXSk7ZWxzZSBpZihhPWEuY2hpbGRyZW58fGEuY2hpbGROb2Rlcylmb3IoYj0wO2I8YS5sZW5ndGg7YisrKXRoaXMuc3R5bGVTdWJ0cmVlKGFbYl0pfTtwLnZhPWZ1bmN0aW9uKGEpe3ZhciBiPXRoaXMsYz1kZihhKTtjZihjLGZ1bmN0aW9uKGEpe2lmKFEpS2YoYSk7ZWxzZXt2YXIgYz1XO2Euc2VsZWN0b3I9YS5wYXJzZWRTZWxlY3RvcjtLZihhKTthLnNlbGVjdG9yPWEubT10ZihjLGEsYy5jLHZvaWQgMCx2b2lkIDApfVImJih6ZyhiKSxiLmEmJmIuYS50cmFuc2Zvcm1SdWxlKGEpKX0pO1I/YS50ZXh0Q29udGVudD1iZihjKTp0aGlzLmgudy5ydWxlcy5wdXNoKGMpfTtcbnAuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlPWZ1bmN0aW9uKGEsYil7dmFyIGM7Unx8KGM9KFgoYSl8fFgoQ2codGhpcyxhKSkpLkJbYl0pO3JldHVybihjPWN8fHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGEpLmdldFByb3BlcnR5VmFsdWUoYikpP2MudHJpbSgpOlwiXCJ9O3AuWWE9ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLmdldFJvb3ROb2RlKCk7Yj1iP2Iuc3BsaXQoL1xccy8pOltdO2M9Yy5ob3N0JiZjLmhvc3QubG9jYWxOYW1lO2lmKCFjKXt2YXIgZD1hLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpO2lmKGQpe2Q9ZC5zcGxpdCgvXFxzLyk7Zm9yKHZhciBlPTA7ZTxkLmxlbmd0aDtlKyspaWYoZFtlXT09PVcuYSl7Yz1kW2UrMV07YnJlYWt9fX1jJiZiLnB1c2goVy5hLGMpO1J8fChjPVgoYSkpJiZjLnUmJmIucHVzaChlZy5hLGMudSk7amYoYSxiLmpvaW4oXCIgXCIpKX07cC5JYT1mdW5jdGlvbihhKXtyZXR1cm4gWChhKX07WS5wcm90b3R5cGUuZmx1c2g9WS5wcm90b3R5cGUueGE7XG5ZLnByb3RvdHlwZS5wcmVwYXJlVGVtcGxhdGU9WS5wcm90b3R5cGUucHJlcGFyZVRlbXBsYXRlO1kucHJvdG90eXBlLnN0eWxlRWxlbWVudD1ZLnByb3RvdHlwZS5zdHlsZUVsZW1lbnQ7WS5wcm90b3R5cGUuc3R5bGVEb2N1bWVudD1ZLnByb3RvdHlwZS5zdHlsZURvY3VtZW50O1kucHJvdG90eXBlLnN0eWxlU3VidHJlZT1ZLnByb3RvdHlwZS5zdHlsZVN1YnRyZWU7WS5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlPVkucHJvdG90eXBlLmdldENvbXB1dGVkU3R5bGVWYWx1ZTtZLnByb3RvdHlwZS5zZXRFbGVtZW50Q2xhc3M9WS5wcm90b3R5cGUuWWE7WS5wcm90b3R5cGUuX3N0eWxlSW5mb0Zvck5vZGU9WS5wcm90b3R5cGUuSWE7WS5wcm90b3R5cGUudHJhbnNmb3JtQ3VzdG9tU3R5bGVGb3JEb2N1bWVudD1ZLnByb3RvdHlwZS52YTtZLnByb3RvdHlwZS5nZXRTdHlsZUFzdD1ZLnByb3RvdHlwZS5MYTtZLnByb3RvdHlwZS5zdHlsZUFzdFRvU3RyaW5nPVkucHJvdG90eXBlLlphO1xuWS5wcm90b3R5cGUuZmx1c2hDdXN0b21TdHlsZXM9WS5wcm90b3R5cGUuRjtPYmplY3QuZGVmaW5lUHJvcGVydGllcyhZLnByb3RvdHlwZSx7bmF0aXZlU2hhZG93OntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gUX19LG5hdGl2ZUNzczp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIFJ9fX0pO3ZhciBaPW5ldyBZLERnLEVnO3dpbmRvdy5TaGFkeUNTUyYmKERnPXdpbmRvdy5TaGFkeUNTUy5BcHBseVNoaW0sRWc9d2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlKTt3aW5kb3cuU2hhZHlDU1M9e1Njb3BpbmdTaGltOloscHJlcGFyZVRlbXBsYXRlOmZ1bmN0aW9uKGEsYixjKXtaLkYoKTtaLnByZXBhcmVUZW1wbGF0ZShhLGIsYyl9LHN0eWxlU3VidHJlZTpmdW5jdGlvbihhLGIpe1ouRigpO1ouc3R5bGVTdWJ0cmVlKGEsYil9LHN0eWxlRWxlbWVudDpmdW5jdGlvbihhKXtaLkYoKTtaLnN0eWxlRWxlbWVudChhKX0sc3R5bGVEb2N1bWVudDpmdW5jdGlvbihhKXtaLkYoKTtaLnN0eWxlRG9jdW1lbnQoYSl9LGdldENvbXB1dGVkU3R5bGVWYWx1ZTpmdW5jdGlvbihhLGIpe3JldHVybiBaLmdldENvbXB1dGVkU3R5bGVWYWx1ZShhLGIpfSxuYXRpdmVDc3M6UixuYXRpdmVTaGFkb3c6UX07RGcmJih3aW5kb3cuU2hhZHlDU1MuQXBwbHlTaGltPURnKTtcbkVnJiYod2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlPUVnKTt2YXIgRmc9d2luZG93LmN1c3RvbUVsZW1lbnRzLEdnPXdpbmRvdy5IVE1MSW1wb3J0cyxIZz13aW5kb3cuSFRNTFRlbXBsYXRlRWxlbWVudDt3aW5kb3cuV2ViQ29tcG9uZW50cz13aW5kb3cuV2ViQ29tcG9uZW50c3x8e307aWYoRmcmJkZnLnBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2spe3ZhciBJZyxKZz1mdW5jdGlvbigpe2lmKElnKXtIZy5KJiZIZy5KKHdpbmRvdy5kb2N1bWVudCk7dmFyIGE9SWc7SWc9bnVsbDthKCk7cmV0dXJuITB9fSxLZz1HZy53aGVuUmVhZHk7RmcucG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayhmdW5jdGlvbihhKXtJZz1hO0tnKEpnKX0pO0dnLndoZW5SZWFkeT1mdW5jdGlvbihhKXtLZyhmdW5jdGlvbigpe0pnKCk/R2cud2hlblJlYWR5KGEpOmEoKX0pfX1cbkdnLndoZW5SZWFkeShmdW5jdGlvbigpe3JlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpe3dpbmRvdy5XZWJDb21wb25lbnRzLnJlYWR5PSEwO2RvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFwiV2ViQ29tcG9uZW50c1JlYWR5XCIse2J1YmJsZXM6ITB9KSl9KX0pO3ZhciBMZz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7TGcudGV4dENvbnRlbnQ9XCJib2R5IHt0cmFuc2l0aW9uOiBvcGFjaXR5IGVhc2UtaW4gMC4yczsgfSBcXG5ib2R5W3VucmVzb2x2ZWRdIHtvcGFjaXR5OiAwOyBkaXNwbGF5OiBibG9jazsgb3ZlcmZsb3c6IGhpZGRlbjsgcG9zaXRpb246IHJlbGF0aXZlOyB9IFxcblwiO3ZhciBNZz1kb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiaGVhZFwiKTtNZy5pbnNlcnRCZWZvcmUoTGcsTWcuZmlyc3RDaGlsZCk7fSkuY2FsbCh0aGlzKTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViY29tcG9uZW50cy1saXRlLmpzLm1hcFxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzL3dlYmNvbXBvbmVudHMtbGl0ZS5qc1xuLy8gbW9kdWxlIGlkID0gOTlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzXG4vLyBtb2R1bGUgaWQgPSAxMDBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1xuLy8gbW9kdWxlIGlkID0gMTAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEVsZW1lbnQgYXMgUG9seW1lckVsZW1lbnQgfSBmcm9tICdAcG9seW1lci9wb2x5bWVyL3BvbHltZXItZWxlbWVudCc7XG5pbXBvcnQgdmlldyBmcm9tICcuL3R0YS11bmRlcmxpbmVkLXRleHQuaHRtbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRUQVVuZGVybGluZWRUZXh0IGV4dGVuZHMgUG9seW1lckVsZW1lbnQge1xuICBzdGF0aWMgZ2V0IGlzKCkge1xuICAgIHJldHVybiBcInR0YS11bmRlcmxpbmVkLXRleHRcIjtcbiAgfVxuXG4gIHN0YXRpYyBnZXQgdGVtcGxhdGUoKSB7XG4gICAgcmV0dXJuIHZpZXc7XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgc3RhdGljIGdldCBwcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiB7XG4gICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgfSxcbiAgICAgIGhhc0hyOiB7XG4gICAgICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbi8vIFJlZ2lzdGVyIGN1c3RvbSBlbGVtZW50IGNsYXNzIHdpdGggYnJvd3NlclxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKFRUQVVuZGVybGluZWRUZXh0LmlzLCBUVEFVbmRlcmxpbmVkVGV4dCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9lbGVtZW50cy90dGEtdW5kZXJsaW5lZC10ZXh0L3R0YS11bmRlcmxpbmVkLXRleHQuanMiLCJtb2R1bGUuZXhwb3J0cyA9IFwiPHN0eWxlPlxcbiAgaHIge1xcbiAgICAgIGJvcmRlcjogMC41cHggc29saWQ7XFxuICB9XFxuPC9zdHlsZT5cXG5cXG48ZGl2PltbdGV4dF1dPC9kaXY+XFxuXFxuPCEtLSBUT0RPIGhvdyBkbyB3ZSBjb25kaXRpb25hbGx5IGhpZGUgdGhpcyBiYXNlZCBvbiBoYXNIcj8gLS0+XFxuPGhyPlxcblwiXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9lbGVtZW50cy90dGEtdW5kZXJsaW5lZC10ZXh0L3R0YS11bmRlcmxpbmVkLXRleHQuaHRtbFxuLy8gbW9kdWxlIGlkID0gMTAzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCJdLCJzb3VyY2VSb290IjoiIn0=